PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modinfo:
040000             0009  ; 05/08/2022:	Added mos_feof
040000             0010  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0011  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0012  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0013  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0014  ; 13/10/2022:	Added mos_oscli
040000             0015  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0016  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0017  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0018  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0019  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0020  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0021  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0022  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0023  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0024  ; 19/05/2023:	Added sysvar_scrMode
040000             0025  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0026  ; 03/08/2023:	Added mos_setkbvector
040000             0027  ; 10/08/2023:	Added mos_getkbmap
040000             0028  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0029  
040000             0030  ; VDP control (VDU 23, 0, n)
040000             0031  ;
040000             0032  vdp_gp:			EQU 	80h
040000             0033  vdp_keycode:		EQU 	81h
040000             0034  vdp_cursor:		EQU	82h
040000             0035  vdp_scrchar:		EQU	83h
040000             0036  vdp_scrpixel:		EQU	84h
040000             0037  vdp_audio:		EQU	85h
040000             0038  vdp_mode:		EQU	86h
040000             0039  vdp_rtc:		EQU	87h
040000             0040  vdp_keystate:		EQU	88h
040000             0041  vdp_logicalcoords:	EQU	C0h
040000             0042  vdp_terminalmode:	EQU	FFh
040000             0043  
040000             0044  ; MOS high level functions
040000             0045  ;
040000             0046  mos_getkey:		EQU	00h
040000             0047  mos_load:		EQU	01h
040000             0048  mos_save:		EQU	02h
040000             0049  mos_cd:			EQU	03h
040000             0050  mos_dir:		EQU	04h
040000             0051  mos_del:		EQU	05h
040000             0052  mos_ren:		EQU	06h
040000             0053  mos_mkdir:		EQU	07h
040000             0054  mos_sysvars:		EQU	08h
040000             0055  mos_editline:		EQU	09h
040000             0056  mos_fopen:		EQU	0Ah
040000             0057  mos_fclose:		EQU	0Bh
040000             0058  mos_fgetc:		EQU	0Ch
040000             0059  mos_fputc:		EQU	0Dh
040000             0060  mos_feof:		EQU	0Eh
040000             0061  mos_getError:		EQU	0Fh
040000             0062  mos_oscli:		EQU	10h
040000             0063  mos_copy:		EQU	11h
040000             0064  mos_getrtc:		EQU	12h
040000             0065  mos_setrtc:		EQU	13h
040000             0066  mos_setintvector:	EQU	14h
040000             0067  mos_uopen:		EQU	15h
040000             0068  mos_uclose:		EQU	16h
040000             0069  mos_ugetc:		EQU	17h
040000             0070  mos_uputc:		EQU 	18h
040000             0071  mos_getfil:		EQU	19h
040000             0072  mos_fread:		EQU	1Ah
040000             0073  mos_fwrite:		EQU	1Bh
040000             0074  mos_flseek:		EQU	1Ch
040000             0075  mos_setkbvector:	EQU	1Dh
040000             0076  mos_getkbmap:		EQU	1Eh
040000             0077  mos_i2c_open:		EQU	1Fh
040000             0078  mos_i2c_close:		EQU	20h
040000             0079  mos_i2c_write:		EQU	21h
040000             0080  mos_i2c_read:		EQU	22h
040000             0081  
040000             0082  
040000             0083  ; FatFS file access functions
040000             0084  ;
040000             0085  ffs_fopen:		EQU	80h
040000             0086  ffs_fclose:		EQU	81h
040000             0087  ffs_fread:		EQU	82h
040000             0088  ffs_fwrite:		EQU	83h
040000             0089  ffs_flseek:		EQU	84h
040000             0090  ffs_ftruncate:		EQU	85h
040000             0091  ffs_fsync:		EQU	86h
040000             0092  ffs_fforward:		EQU	87h
040000             0093  ffs_fexpand:		EQU	88h
040000             0094  ffs_fgets:		EQU	89h
040000             0095  ffs_fputc:		EQU	8Ah
040000             0096  ffs_fputs:		EQU	8Bh
040000             0097  ffs_fprintf:		EQU	8Ch
040000             0098  ffs_ftell:		EQU	8Dh
040000             0099  ffs_feof:		EQU	8Eh
040000             0100  ffs_fsize:		EQU	8Fh
040000             0101  ffs_ferror:		EQU	90h
040000             0102  
040000             0103  ; FatFS directory access functions
040000             0104  ;
040000             0105  ffs_dopen:		EQU	91h
040000             0106  ffs_dclose:		EQU	92h
040000             0107  ffs_dread:		EQU	93h
040000             0108  ffs_dfindfirst:		EQU	94h
040000             0109  ffs_dfindnext:		EQU	95h
040000             0110  
040000             0111  ; FatFS file and directory management functions
040000             0112  ;
040000             0113  ffs_stat:		EQU	96h
040000             0114  ffs_unlink:		EQU	97h
040000             0115  ffs_rename:		EQU	98h
040000             0116  ffs_chmod:		EQU	99h
040000             0117  ffs_utime:		EQU	9Ah
040000             0118  ffs_mkdir:		EQU	9Bh
040000             0119  ffs_chdir:		EQU	9Ch
040000             0120  ffs_chdrive:		EQU	9Dh
040000             0121  ffs_getcwd:		EQU	9Eh
040000             0122  
040000             0123  ; FatFS volume management and system configuration functions
040000             0124  ;
040000             0125  ffs_mount:		EQU	9Fh
040000             0126  ffs_mkfs:		EQU	A0h
040000             0127  ffs_fdisk:		EQU	A1h
040000             0128  ffs_getfree:		EQU	A2h
040000             0129  ffs_getlabel:		EQU	A3h
040000             0130  ffs_setlabel:		EQU	A4h
040000             0131  ffs_setcp:		EQU	A5h
040000             0132  
040000             0133  ; File access modes
040000             0134  ;
040000             0135  fa_read:		EQU	01h
040000             0136  fa_write:		EQU	02h
040000             0137  fa_open_existing:	EQU	00h
040000             0138  fa_create_new:		EQU	04h
040000             0139  fa_create_always:	EQU	08h
040000             0140  fa_open_always:		EQU	10h
040000             0141  fa_open_append:		EQU	30h
040000             0142  
040000             0143  ; System variable indexes for api_sysvars
040000             0144  ; Index into _sysvars in globals.asm
040000             0145  ;
040000             0146  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0147  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0148  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0149  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0150  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0151  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0152  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0153  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0154  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0155  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0156  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0157  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0158  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0159  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0160  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0161  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0162  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0163  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0164  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0165  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0166  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0167  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0168  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0169  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0170  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0171  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0172  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0173  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0174  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0175  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0176  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0177  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0178  
040000             0179  ; Flags for the VPD protocol
040000             0180  ;
040000             0181  vdp_pflag_cursor:	EQU	00000001b
040000             0182  vdp_pflag_scrchar:	EQU	00000010b
040000             0183  vdp_pflag_point:	EQU	00000100b
040000             0184  vdp_pflag_audio:	EQU	00001000b
040000             0185  vdp_pflag_mode:		EQU	00010000b
040000             0186  vdp_pflag_rtc:		EQU	00100000b
040000             0187  vdp_pflag_mouse:	EQU	01000000b
040000             0188  ; vdp_pflag_buffered:	EQU	10000000b
040000             0189  
040000             0190  ;
040000             0191  ; FatFS structures
040000             0192  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0193  ;
040000             0194  ; Object ID and allocation information (FFOBJID)
040000             0195  ;
040000             0196  ; FFOBJID	.STRUCT
040000             0197  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0198  ; 	id:		DS	2	; Hosting volume mount ID
040000             0199  ; 	attr:		DS	1	; Object attribute
040000             0200  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0201  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0202  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0203  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0204  ; ;
040000             0205  ; ; File object structure (FIL)
040000             0206  ; ;
040000             0207  ; FIL .STRUCT
040000             0208  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0209  ; 	flag:		DS	1	; File status flags
040000             0210  ; 	err:		DS	1	; Abort flag (error code)
040000             0211  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0212  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0213  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0214  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0215  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0216  ; FIL_SIZE .ENDSTRUCT FIL
040000             0217  ; ;
040000             0218  ; ; Directory object structure (DIR)
040000             0219  ; ;
040000             0220  ; DIR .STRUCT
040000             0221  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0222  ; 	dptr:		DS	4	; Current read/write offset
040000             0223  ; 	clust:		DS	4	; Current cluster
040000             0224  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0225  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0226  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0227  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0228  ; DIR_SIZE .ENDSTRUCT DIR
040000             0229  ; ;
040000             0230  ; ; File information structure (FILINFO)
040000             0231  ; ;
040000             0232  ; FILINFO .STRUCT
040000             0233  ; 	fsize:		DS 	4	; File size
040000             0234  ; 	fdate:		DS	2	; Modified date
040000             0235  ; 	ftime:		DS	2	; Modified time
040000             0236  ; 	fattrib:	DS	1	; File attribute
040000             0237  ; 	altname:	DS	13	; Alternative file name
040000             0238  ; 	fname:		DS	256	; Primary file name
040000             0239  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0240  
040000             0241  ; FFOBJID offsets
040000             0242  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0243  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0244  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0245  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0246  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0247  FFOBJID.objsize:  EQU 11   ; Object size
040000             0248  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0249  
040000             0250  ; FIL offsets (including FFOBJID fields)
040000             0251  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0252  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0253  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0254  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0255  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0256  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0257  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0258  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0259  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0260  
040000             0261  ; DIR offsets (including FFOBJID fields)
040000             0262  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0263  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0264  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0265  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0266  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0267  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0268  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0269  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0270  
040000             0271  ; FILINFO offsets
040000             0272  FILINFO.fsize:    EQU 0    ; File size
040000             0273  FILINFO.fdate:    EQU 4    ; Modified date
040000             0274  FILINFO.ftime:    EQU 6    ; Modified time
040000             0275  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0276  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0277  FILINFO.fname:    EQU 22   ; Primary file name
040000             0278  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0279  
040000             0280  ;
040000             0281  ; Macro for calling the API
040000             0282  ; Parameters:
040000             0283  ; - function: One of the function numbers listed above
040000             0284  ;
040000             0285  			MACRO MOSCALL	function
040000             0286  			LD	A, function
040000             0287  			RST.LIS	08h
040000             0288  			ENDMACRO 	; --- End mos_api.inc ---
040000             0289  
040000             0290  ; --- Begin macros.inc ---
040000             0291  	; Title:	BBC Basic Interpreter - Z80 version
040000             0292  	;		Useful macros
040000             0293  	; Author:	Dean Belfield
040000             0294  	; Created:	12/05/2023
040000             0295  	; Last Updated:	11/06/2023
040000             0296  	;
040000             0297  	; Modinfo:
040000             0298  	; 11/06/2023:	Modified to run in ADL mode
040000             0299  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0300  
040000             0301  	MACRO EXREG	rp1, rp2
040000             0302  		PUSH	rp1
040000             0303  		POP	rp2
040000             0304  	ENDMACRO
040000             0305  
040000             0306  	; MACRO ADD8U_DE	reg
040000             0307  		MACRO ADD8U_DE
040000             0308  		ADD	A, E
040000             0309  		LD	E, A
040000             0310  		ADC	A, D
040000             0311  		SUB	E
040000             0312  		LD	D, A
040000             0313  	ENDMACRO
040000             0314  
040000             0315  	; MACRO ADD8U_HL	reg
040000             0316  	MACRO ADD8U_HL
040000             0317  		ADD	A, L
040000             0318  		LD	L, A
040000             0319  		ADC	A, H
040000             0320  		SUB	L
040000             0321  		LD	H, A
040000             0322  	ENDMACRO
040000             0323  
040000             0324  	MACRO VDU	val
040000             0325  		LD	A, val
040000             0326  		CALL	OSWRCH
040000             0327  	ENDMACRO
040000             0328  
040000             0329  	MACRO SET_GPIO	reg, val
040000             0330  		IN0	A, (reg)
040000             0331  		OR	val
040000             0332  		OUT0	(reg), A
040000             0333  	ENDMACRO
040000             0334  
040000             0335  	MACRO RES_GPIO	reg, val
040000             0336  		PUSH	BC
040000             0337  		LD	A, val
040000             0338  		CPL
040000             0339  		LD	C, A
040000             0340  		IN0	A, (reg)
040000             0341  		AND	C
040000             0342  		OUT0	(reg), A
040000             0343  		POP	BC
040000             0344  	ENDMACRO
040000             0345  ; --- End macros.inc ---
040000             0346  
040000             0347  ; --- Begin equs_top.inc ---
040000             0348  ; --- Begin equs.inc ---
040000             0349  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0350  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0351  PA_DR:			EQU		96h
040000             0352  PA_DDR:			EQU		97h
040000             0353  PA_ALT1:		EQU		98h
040000             0354  PA_ALT2:		EQU		99h
040000             0355  PB_DR:          	EQU		9Ah
040000             0356  PB_DDR:        	 	EQU		9Bh
040000             0357  PB_ALT1:        	EQU		9Ch
040000             0358  PB_ALT2:        	EQU		9Dh
040000             0359  PC_DR:          	EQU		9Eh
040000             0360  PC_DDR:         	EQU		9Fh
040000             0361  PC_ALT1:        	EQU		A0h
040000             0362  PC_ALT2:        	EQU		A1h
040000             0363  PD_DR:          	EQU		A2h
040000             0364  PD_DDR:			EQU		A3h
040000             0365  PD_ALT1:		EQU		A4h
040000             0366  PD_ALT2:		EQU		A5h
040000             0367  GPIOMODE_OUT:		EQU		0	; Output
040000             0368  GPIOMODE_IN:		EQU		1	; Input
040000             0369  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0370  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0371  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0372  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0373  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0374  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0375  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0376  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0377  CR:			EQU     0DH
040000             0378  LF:			EQU     0AH
040000             0379  ESC:			EQU     1BH
040000             0380  ; --- End equs.inc ---
040000             0381  
040000             0382  ; --- Begin eval.asm ---
040000             0383  FUNTOK:			EQU	8DH			; First token number
040000             0384  ANDK:			EQU     80H
040000             0385  DIVK:			EQU     81H
040000             0386  EORK:			EQU     82H
040000             0387  MODK:			EQU     83H
040000             0388  ORK:			EQU     84H
040000             0389  ; --- End eval.asm ---
040000             0390  
040000             0391  ; --- Begin exec.asm ---
040000             0392  ; --- End exec.asm ---
040000             0393  
040000             0394  ; --- Begin fpp.asm ---
040000             0395  BADOP:			EQU     1               ;Bad operation code
040000             0396  DIVBY0:			EQU     18              ;Division by zero
040000             0397  TOOBIG_FP:			EQU     20              ;Too big
040000             0398  NGROOT:			EQU     21              ;Negative root
040000             0399  LOGRNG:			EQU     22              ;Log range
040000             0400  ACLOST:			EQU     23              ;Accuracy lost
040000             0401  EXPRNG:			EQU     24              ;Exp range
040000             0402  ; --- End fpp.asm ---
040000             0403  
040000             0404  ; --- Begin init.asm ---
040000             0405  ; --- End init.asm ---
040000             0406  
040000             0407  ; --- Begin main.asm ---
040000             0408  DATA_:	EQU     DCH
040000             0409  DEF_:	EQU     DDH
040000             0410  DIM:	EQU     DEH
040000             0411  ELSE_:	EQU     8BH
040000             0412  FN:	EQU     A4H
040000             0413  FOR:	EQU     E3H
040000             0414  GOSUB:	EQU     E4H
040000             0415  GOTO:	EQU     E5H
040000             0416  LINE_:	EQU     86H
040000             0417  LINO:	EQU     8DH
040000             0418  LOCAL_:	EQU     EAH
040000             0419  NEXT:	EQU     EDH
040000             0420  OFF_:	EQU     87H
040000             0421  ON_:	EQU     EEH
040000             0422  PROC:	EQU     F2H
040000             0423  REM:	EQU     F4H
040000             0424  REN:	EQU     CCH
040000             0425  REPEAT:	EQU     F5H
040000             0426  RESTOR:	EQU     F7H
040000             0427  SPC:	EQU     89H
040000             0428  STEP:	EQU     88H
040000             0429  TAB:	EQU     8AH
040000             0430  TAND:	EQU     80H
040000             0431  TCALL:	EQU     D6H
040000             0432  TERROR:	EQU     85H
040000             0433  TGOSUB:	EQU     E4H
040000             0434  TGOTO:	EQU     E5H
040000             0435  THEN:	EQU     8CH
040000             0436  TIF:	EQU     E7H
040000             0437  TO:	EQU     B8H
040000             0438  TON:	EQU     EEH
040000             0439  TOR:	EQU     84H
040000             0440  TPROC:	EQU     F2H
040000             0441  TRACE:	EQU     FCH
040000             0442  TSTOP:	EQU     FAH
040000             0443  UNTIL:	EQU     FDH
040000             0444  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040000             0445  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040000             0446  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040000             0447  ; --- End main.asm ---
040000             0448  ; --- End equs_top.inc ---
040000             0449  
040000             0450  ; --- Begin init.asm ---
040000             0451  ;
040000             0452  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0453  ;		Initialisation Code
040000             0454  ; Author:	Dean Belfield
040000             0455  ; Created:	12/05/2023
040000             0456  ; Last Updated:	26/11/2023
040000             0457  ;
040000             0458  ; Modinfo:
040000             0459  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0460  ; 26/11/2023:	Moved the ram clear routine into here
040000             0461  
040000             0462  			; SEGMENT CODE
040000             0463  
040000             0464  			; XDEF	_end
040000             0465  
040000             0466  			; XREF	_main				; In main.asm
040000             0467  
040000             0468  			; XREF	RAM_START			; In ram.asm
040000             0469  			; XREF	RAM_END
040000             0470  
040000             0471  			.ASSUME	ADL = 1
040000             0472  
040000             0473  			; INCLUDE	"equs.inc"
040000             0474  
040000             0475  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0476  
040000             0477  ;
040000             0478  ; Start in ADL mode
040000             0479  ;
040000 C3 45 00 04 0480  			JP	_start				; Jump to start
040004             0481  ;
040004             0482  ; The header stuff is from byte 64 onwards
040004             0483  ;
040004 62 62 63 62 0484  _exec_name:		DB	"bbcbasic24ez.bin", 0		; The executable name, only used in argv
       61 73 69 63 
       32 34 65 7A 
       2E 62 69 6E 
       00          
040015             0485  
040015 00 00 00 00 0486  			ALIGN	64
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
040040             0487  
040040 4D 4F 53    0488  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0489  			DB	00h				; MOS header version 0
040044 01          0490  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0491  ;
040045             0492  ; And the code follows on immediately after the header
040045             0493  ;
040045 F5          0494  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0495  			PUSH		BC
040047 D5          0496  			PUSH		DE
040048 DD E5       0497  			PUSH		IX
04004A FD E5       0498  			PUSH		IY
04004C             0499  
04004C ED 73 D7 00 0500  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0501  
040051 DD 21 DA 00 0502  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0503  			PUSH		IX
040058 CD 88 00 04 0504  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0505  			POP		IX			; IX: argv
04005E 06 00       0506  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0507  			CALL		_clear_ram
040064 C3 F9 2F 04 0508  			JP		_main			; Start user code
040068             0509  ;
040068             0510  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0511  ;
040068 ED 7B D7 00 0512  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0513  
04006D FD E1       0514  			POP		IY			; Restore the registers
04006F DD E1       0515  			POP		IX
040071 D1          0516  			POP		DE
040072 C1          0517  			POP		BC
040073 F1          0518  			POP		AF
040074 C9          0519  			RET					; Return to MOS
040075             0520  
040075             0521  ;Clear the application memory
040075             0522  ;
040075 C5          0523  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0524  			LD		HL, RAM_START
04007A 11 01 4A 04 0525  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0526  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0527  			XOR		A
040083 77          0528  			LD		(HL), A
040084 ED B0       0529  			LDIR
040086 C1          0530  			POP		BC
040087 C9          0531  			RET
040088             0532  
040088             0533  ; Parse the parameter string into a C array
040088             0534  ; Parameters
040088             0535  ; - HL: Address of parameter string
040088             0536  ; - IX: Address for array pointer storage
040088             0537  ; Returns:
040088             0538  ; -  C: Number of parameters parsed
040088             0539  ;
040088 01 04 00 04 0540  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0541  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0542  			INC	IX
040091 DD 23       0543  			INC	IX
040093 DD 23       0544  			INC	IX
040095 CD D0 00 04 0545  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0546  ;
040099 01 01 00 00 0547  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0548  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0549  ;
04009F             0550  _parse_params_1:
04009F C5          0551  			PUSH	BC			; Stack ARGC
0400A0 E5          0552  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0553  			CALL	_get_token		; Get the next token
0400A5 79          0554  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0555  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0556  			POP	BC			; ARGC
0400A8 B7          0557  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0558  			RET	Z
0400AA             0559  ;
0400AA DD 1F 00    0560  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0561  			PUSH	HL			; DE=HL
0400AE D1          0562  			POP	DE
0400AF CD D0 00 04 0563  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0564  			XOR	A
0400B4 12          0565  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0566  			INC	IX
0400B7 DD 23       0567  			INC	IX
0400B9 DD 23       0568  			INC	IX			; Advance to next pointer position
0400BB 0C          0569  			INC	C			; Increment ARGC
0400BC 79          0570  			LD	A, C			; Check for C >= A
0400BD B8          0571  			CP	B
0400BE 38 DF       0572  			JR	C, _parse_params_1	; And loop
0400C0 C9          0573  			RET
0400C1             0574  
0400C1             0575  ; Get the next token
0400C1             0576  ; Parameters:
0400C1             0577  ; - HL: Address of parameter string
0400C1             0578  ; Returns:
0400C1             0579  ; - HL: Address of first character after token
0400C1             0580  ; -  C: Length of token (in characters)
0400C1             0581  ;
0400C1 0E 00       0582  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0583  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0584  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0585  			RET 	Z
0400C6 FE 0D       0586  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0587  			RET	Z
0400C9 FE 20       0588  			CP	' '			; Exit if space (end of token)
0400CB C8          0589  			RET	Z
0400CC 23          0590  			INC	HL			; Advance to next character
0400CD 0C          0591  			INC 	C			; Increment length
0400CE 18 F3       0592  			JR	@B
0400D0             0593  
0400D0             0594  ; Skip spaces in the parameter string
0400D0             0595  ; Parameters:
0400D0             0596  ; - HL: Address of parameter string
0400D0             0597  ; Returns:
0400D0             0598  ; - HL: Address of next none-space character
0400D0             0599  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0600  ;
0400D0 7E          0601  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0602  			CP	' '			; Exit if not space
0400D3 C0          0603  			RET	NZ
0400D4 23          0604  			INC	HL			; Advance to next character
0400D5 18 F9       0605  			JR	_skip_spaces		; Increment length
0400D7             0606  
0400D7             0607  ; Storage
0400D7             0608  ;
0400D7             0609  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0610  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0611  ; --- End init.asm ---
04010A             0612  
04010A             0613  ; --- Begin sorry.asm ---
04010A             0614  ;
04010A             0615  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0616  ;		Catch-all for unimplemented functionality
04010A             0617  ; Author:	Dean Belfield
04010A             0618  ; Created:	12/05/2023
04010A             0619  ; Last Updated:	12/05/2023
04010A             0620  ;
04010A             0621  ; Modinfo:
04010A             0622  
04010A             0623  			; .ASSUME	ADL = 1
04010A             0624  
04010A             0625  			; SEGMENT CODE
04010A             0626  
04010A             0627  			; XDEF	ENVEL
04010A             0628  			; XDEF	ADVAL
04010A             0629  			; XDEF	PUTIMS
04010A             0630  
04010A             0631  			; XREF	EXTERR
04010A             0632  
04010A             0633  ENVEL:
04010A             0634  ADVAL:
04010A             0635  PUTIMS:
04010A AF          0636  			XOR     A
04010B CD D8 37 04 0637  			CALL    EXTERR
04010F 53 6F 72 72 0638  			DEFB    "Sorry"
       79          
040114 00          0639  			DEFB    0
040115             0640  ; --- End sorry.asm ---
040115             0641  
040115             0642  ; --- Begin eval.asm ---
040115             0643  ;
040115             0644  ; Title:	BBC Basic Interpreter - Z80 version
040115             0645  ;		Expression Evaluation & Arithmetic Module - "EVAL"
040115             0646  ; Author:	(C) Copyright  R.T.Russell  1984
040115             0647  ; Modified By:	Dean Belfield
040115             0648  ; Created:	12/05/2023
040115             0649  ; Last Updated:	17/08/2023
040115             0650  ;
040115             0651  ; Modinfo:
040115             0652  ; 07/06/2023:	Modified to run in ADL mode
040115             0653  ; 26/06/2023:	Fixed HEX and HEXSTR
040115             0654  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
040115             0655  ; 17/08/2023:	Added binary constants
040115             0656  
040115             0657  			; .ASSUME	ADL = 1
040115             0658  
040115             0659  			; INCLUDE	"equs.inc"
040115             0660  			; INCLUDE "macros.inc"
040115             0661  			; INCLUDE "mos_api.inc"	; In MOS/src
040115             0662  
040115             0663  			; SEGMENT CODE
040115             0664  
040115             0665  			; XDEF	EXPR
040115             0666  			; XDEF	EXPRN
040115             0667  			; XDEF	EXPRI
040115             0668  			; XDEF	EXPRS
040115             0669  			; XDEF	ITEMI
040115             0670  			; XDEF	LOADN
040115             0671  			; XDEF	LOAD4
040115             0672  			; XDEF	CONS
040115             0673  			; XDEF	LOADS
040115             0674  			; XDEF	SFIX
040115             0675  			; XDEF	VAL0
040115             0676  			; XDEF	SEARCH
040115             0677  			; XDEF	SWAP
040115             0678  			; XDEF	TEST
040115             0679  			; XDEF	DECODE
040115             0680  			; XDEF	HEXSTR
040115             0681  			; XDEF	STR
040115             0682  			; XDEF	ZERO
040115             0683  			; XDEF	PUSHS
040115             0684  			; XDEF	POPS
040115             0685  			; XDEF	COMMA
040115             0686  			; XDEF	BRAKET
040115             0687  			; XDEF	NXT
040115             0688  			; XDEF	COUNT0
040115             0689  
040115             0690  			; XREF	ADVAL
040115             0691  			; XREF	FN_EX
040115             0692  			; XREF	POINT
040115             0693  			; XREF	USR
040115             0694  			; XREF	SYNTAX
040115             0695  			; XREF	ERROR_
040115             0696  			; XREF	CHECK
040115             0697  			; XREF	GETVAR
040115             0698  			; XREF	LISTON
040115             0699  			; XREF	RANGE
040115             0700  			; XREF	FPP
040115             0701  			; XREF	GETCSR
040115             0702  			; XREF	CHANEL
040115             0703  			; XREF	OSSTAT
040115             0704  			; XREF	OSBGET
040115             0705  			; XREF	LOMEM
040115             0706  			; XREF	HIMEM
040115             0707  			; XREF	PAGE_
040115             0708  			; XREF	TOP
040115             0709  			; XREF	ERL
040115             0710  			; XREF	ERR
040115             0711  			; XREF	COUNT
040115             0712  			; XREF	OSOPEN
040115             0713  			; XREF	GETEXT
040115             0714  			; XREF	GETPTR
040115             0715  			; XREF	GETIME
040115             0716  			; XREF	GETIMS
040115             0717  			; XREF	LEXAN2
040115             0718  			; XREF	RANDOM
040115             0719  			; XREF	STORE5
040115             0720  			; XREF	GETSCHR
040115             0721  			; XREF	OSRDCH
040115             0722  			; XREF	OSKEY
040115             0723  			; XREF	INKEY1
040115             0724  			; XREF	EXTERR
040115             0725  ;
040115             0726  ; BINARY FLOATING POINT REPRESENTATION:
040115             0727  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
040115             0728  ;     8 BIT EXCESS-128 SIGNED EXPONENT
040115             0729  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
040115             0730  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
040115             0731  ;
040115             0732  ; BINARY INTEGER REPRESENTATION:
040115             0733  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
040115             0734  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
040115             0735  ;
040115             0736  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
040115             0737  ;                             EXPONENT - C
040115             0738  ;
040115             0739  
040115             0740  ;
040115             0741  ; Table of addresses for functions
040115             0742  ;
040115             0743  ; FUNTOK:			EQU	8DH			; First token number
040115             0744  ;
040115 F6 08 04    0745  FUNTBL:			DW24	DECODE			; Line number
040118 A4 05 04    0746  			DW24	OPENIN			; OPENIN
04011B C6 05 04    0747  			DW24	PTR_EV			; PTR
04011E 60 05 04    0748  			DW24	PAGEV			; PAGE
040121 D0 05 04    0749  			DW24	TIMEV			; TIME
040124 4C 05 04    0750  			DW24	LOMEMV			; LOMEM
040127 56 05 04    0751  			DW24	HIMEMV			; HIMEM
04012A 24 06 04    0752  			DW24	ABSV			; ABS
04012D 60 06 04    0753  			DW24	ACS			; ACS
040130 0A 01 04    0754  			DW24	ADVAL			; ADVAL
040133 35 05 04    0755  			DW24	ASC			; ASC
040136 58 06 04    0756  			DW24	ASN			; ASN
040139 5C 06 04    0757  			DW24	ATN			; ATN
04013C FE 04 04    0758  			DW24	BGET			; BGET
04013F 44 06 04    0759  			DW24	COS			; COS
040142 8B 05 04    0760  			DW24	COUNTV			; COUNT
040145 2C 06 04    0761  			DW24	DEG			; DEG
040148 7F 05 04    0762  			DW24	ERLV			; ERL
04014B 85 05 04    0763  			DW24	ERRV			; ERR
04014E 89 06 04    0764  			DW24	EVAL_			; EVAL
040151 4C 06 04    0765  			DW24	EXP			; EXP
040154 BC 05 04    0766  			DW24	EXT			; EXT
040157 A3 09 04    0767  			DW24	ZERO			; FALSE
04015A 92 10 04    0768  			DW24	FN_EX			; FN
04015D 1C 05 04    0769  			DW24	GET			; GET
040160 0B 05 04    0770  			DW24	INKEY			; INKEY
040163 3B 07 04    0771  			DW24	INSTR			; INSTR(
040166 38 06 04    0772  			DW24	INT_			; INT
040169 45 05 04    0773  			DW24	LEN			; LEN
04016C 50 06 04    0774  			DW24	LN			; LN
04016F 54 06 04    0775  			DW24	LOG			; LOG
040172 28 06 04    0776  			DW24	NOTK			; NOT
040175 A0 05 04    0777  			DW24	OPENUP			; OPENUP
040178 9D 05 04    0778  			DW24	OPENOT			; OPENOUT
04017B 20 06 04    0779  			DW24	PI			; PI
04017E D0 44 04    0780  			DW24	POINT			; POINT(
040181 DD 04 04    0781  			DW24	POS			; POS
040184 30 06 04    0782  			DW24	RAD			; RAD
040187 BD 06 04    0783  			DW24	RND			; RND
04018A 34 06 04    0784  			DW24	SGN			; SGN
04018D 48 06 04    0785  			DW24	SIN			; SIN
040190 3C 06 04    0786  			DW24	SQR			; SQR
040193 40 06 04    0787  			DW24	TAN			; TAN
040196 6A 05 04    0788  			DW24	TOPV			; TO(P)
040199 15 06 04    0789  			DW24	TRUE			; TRUE
04019C 5F 15 04    0790  			DW24	USR			; USR
04019F 7A 06 04    0791  			DW24	VAL			; VAL
0401A2 E6 04 04    0792  			DW24	VPOS			; VPOS
0401A5 CF 07 04    0793  			DW24	CHRS			; CHRS
0401A8 D7 07 04    0794  			DW24	GETS			; GETS
0401AB E8 07 04    0795  			DW24	INKEYS			; INKEYS
0401AE 6D 08 04    0796  			DW24	LEFTS			; LEFTS(
0401B1 35 08 04    0797  			DW24	MIDS			; MIDS(
0401B4 8D 08 04    0798  			DW24	RIGHTS			; RIGHTS(
0401B7 5A 09 04    0799  			DW24	STRS			; STR$
0401BA AE 08 04    0800  			DW24	STRING_			; STRINGS(
0401BD EE 04 04    0801  			DW24	EOF			; EOF
0401C0             0802  ;
0401C0             0803  FUNTBL_END:		EQU	$
0401C0             0804  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401C0             0805  ; TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401C0             0806  ;
0401C0             0807  ; ANDK:			EQU     80H
0401C0             0808  ; DIVK:			EQU     81H
0401C0             0809  ; EORK:			EQU     82H
0401C0             0810  ; MODK:			EQU     83H
0401C0             0811  ; ORK:			EQU     84H
0401C0             0812  ;
0401C0 00 06 04    0813  SOPTBL:			DW24	SLE			; <= (STRING)
0401C3 09 06 04    0814  			DW24	SNE			; <>
0401C6 F9 05 04    0815  			DW24	SGE			; >=
0401C9 EA 05 04    0816  			DW24	SLT			; <
0401CC 10 06 04    0817  			DW24	SEQ			; =
0401CF F1 05 04    0818  			DW24	SGT			; >
0401D2             0819  ;
0401D2             0820  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401D2             0821  ;     Expression type is returned in A'F':
0401D2             0822  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401D2             0823  ;         String - A' bit 7=1, F' sign bit set.
0401D2             0824  ; Floating-point or integer result returned in HLH'L'C
0401D2             0825  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401D2             0826  ; String result returned in string accumulator, DE set.
0401D2             0827  ;
0401D2             0828  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401D2             0829  ;               (2) ^
0401D2             0830  ;               (3) * / MOD DIV
0401D2             0831  ;               (4) + -
0401D2             0832  ;               (5) = <> <= >= > <
0401D2             0833  ;               (6) AND
0401D2             0834  ;               (7) EOR OR
0401D2             0835  
0401D2             0836  ;
0401D2             0837  ; Level 7: EOR and OR
0401D2             0838  ;
0401D2 CD EB 01 04 0839  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401D6 FE 82       0840  EXPR0A:			CP      EORK            	; Is operator EOR?
0401D8 28 03       0841  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401DA FE 84       0842  			CP      ORK			; Is operator OR
0401DC C0          0843  			RET     NZ			; No, so return
0401DD             0844  ;
0401DD CD 51 0A 04 0845  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401E1 CD EB 01 04 0846  			CALL    EXPR1           	; Get second operand
0401E5 CD 60 0A 04 0847  			CALL    DOIT            	; Do the operation
0401E9 18 EB       0848  			JR      EXPR0A          	; And continue
0401EB             0849  ;
0401EB             0850  ; Level 6: AND
0401EB             0851  ;
0401EB CD 00 02 04 0852  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401EF FE 80       0853  EXPR1A:			CP      ANDK			; Is operator AND?
0401F1 C0          0854  			RET     NZ			; No, so return
0401F2 CD 51 0A 04 0855  			CALL    SAVE_EV			; Save first operand
0401F6 CD 00 02 04 0856  			CALL    EXPR2			; Get second operand
0401FA CD 60 0A 04 0857  			CALL    DOIT			; Do the operation
0401FE 18 EF       0858  			JR      EXPR1A			; And continue
040200             0859  ;
040200             0860  ; Level 5: Comparisons
040200             0861  ;
040200 CD 72 02 04 0862  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
040204 CD 28 0A 04 0863  			CALL    RELOP?			; Is it ">", "=" or "<"?
040208 C0          0864  			RET     NZ			; No, so return
040209 47          0865  			LD      B,A			; Store the first operator in B
04020A FD 23       0866  			INC     IY              	; Bump over operator
04020C CD 83 0A 04 0867  			CALL    NXT			;
040210 CD 28 0A 04 0868  			CALL    RELOP?          	; Is it a compound operator?
040214 20 09       0869  			JR      NZ,EXPR2B		; No, so skip next bit
040216 FD 23       0870  			INC     IY			; Bump over operator
040218 B8          0871  			CP      B			; Compare with first
040219 CA AA 0C 04 0872  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
04021D 80          0873  			ADD     A,B
04021E 47          0874  			LD      B,A			; B: Unique code for the compound operator
04021F 78          0875  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040220 08          0876  			EX      AF,AF'
040221 FA 3B 02 04 0877  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
040225 08          0878  			EX      AF,AF'
040226 D6 04       0879  			SUB     4
040228 FE 3A       0880  			CP      '>'-4
04022A 20 02       0881  			JR      NZ,EXPR2C
04022C C6 02       0882  			ADD     A,2
04022E CD 53 0A 04 0883  EXPR2C:			CALL    SAVE1
040232 CD 72 02 04 0884  			CALL    EXPR3
040236 CD 60 0A 04 0885  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04023A C9          0886  			RET
04023B             0887  ;
04023B 08          0888  EXPR2S:			EX      AF,AF'			; Handle string comparisons
04023C 3D          0889  			DEC     A
04023D E6 07       0890  			AND     7
04023F CD C4 09 04 0891  			CALL    PUSHS           	; Save string on the stack
040243 F5          0892  			PUSH    AF              	; Save the operator
040244 CD 72 02 04 0893  			CALL    EXPR3           	; Get the second string
040248 08          0894  			EX      AF,AF'
040249 F2 46 03 04 0895  			JP      P,TYPE_EV_
04024D F1          0896  			POP     AF
04024E 4B          0897  			LD      C,E             	; Length of string #2
04024F D1          0898  			POP     DE
040250 21 00 00 00 0899  			LD      HL,0
040254 39          0900  			ADD     HL,SP
040255 43          0901  			LD      B,E             	; Length of string #1
040256 D5          0902  			PUSH    DE
040257 11 00 4A 04 0903  			LD      DE,ACCS
04025B EB          0904  			EX      DE,HL
04025C CD 8F 0A 04 0905  			CALL    DISPT2
040260 D1          0906  			POP     DE
040261 EB          0907  			EX      DE,HL
040262 7D          0908  			LD	A,L
040263 21 00 00 00 0909  			LD	HL,0
040267 6F          0910  			LD	L,A
040268 39          0911  			ADD     HL,SP
040269 F9          0912  			LD      SP,HL
04026A EB          0913  			EX      DE,HL
04026B AF          0914  			XOR     A               	; Numeric marker
04026C 4F          0915  			LD      C,A             	; Integer marker
04026D 08          0916  			EX      AF,AF'
04026E FD 7E 00    0917  			LD      A,(IY)
040271 C9          0918  			RET
040272             0919  ;
040272             0920  ; Level 4: + and -
040272             0921  ;
040272 CD D4 02 04 0922  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
040276 FE 2D       0923  EXPR3A:			CP      '-'			; Is it "-"?
040278 28 09       0924  			JR      Z,EXPR3B		; Yes, so skip the next bit
04027A FE 2B       0925  			CP      '+'			; Is it "+"?
04027C C0          0926  			RET     NZ			; No, so return
04027D 08          0927  			EX      AF,AF'			; Get the type
04027E FA 91 02 04 0928  			JP      M,EXPR3S		; Branch here if string
040282 08          0929  			EX      AF,AF'
040283 CD 51 0A 04 0930  EXPR3B:			CALL    SAVE_EV			; Save the first operator
040287 CD D4 02 04 0931  			CALL    EXPR4			; Fetch the second operator
04028B CD 60 0A 04 0932  			CALL    DOIT			; Do the operation
04028F 18 E5       0933  			JR      EXPR3A			; And continue
040291             0934  ;
040291 08          0935  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040292 FD 23       0936  			INC     IY              	; Bump past the "+"
040294 CD C4 09 04 0937  			CALL    PUSHS           	; Save the string on the stack
040298 CD D4 02 04 0938  			CALL    EXPR4           	; Fetch the second operator
04029C 08          0939  			EX      AF,AF'
04029D F2 46 03 04 0940  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0402A1 01 00 00 00 0941  			LD	BC, 0			; Clear BC
0402A5 4B          0942  			LD      C,E             	; C: Length of the second string
0402A6 D1          0943  			POP     DE
0402A7 D5          0944  			PUSH    DE
0402A8 21 00 4A 04 0945  			LD      HL,ACCS
0402AC 7B          0946  			LD	A,E			;  E: Length of the first string
0402AD 11 00 4A 04 0947  			LD      DE,ACCS
0402B1 5F          0948  			LD	E,A 			; DE: Pointer to the end of the first string
0402B2 79          0949  			LD      A,C
0402B3 B7          0950  			OR      A
0402B4 28 0F       0951  			JR      Z,EXP3S3
0402B6 6F          0952  			LD      L,A             	; Source
0402B7 83          0953  			ADD     A,E
0402B8 5F          0954  			LD      E,A             	; Destination
0402B9 3E 13       0955  			LD      A,19
0402BB DA C1 37 04 0956  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402BF D5          0957  			PUSH    DE
0402C0 1D          0958  			DEC     E
0402C1 2D          0959  			DEC     L
0402C2 ED B8       0960  			LDDR                    	; Copy
0402C4 D1          0961  			POP     DE
0402C5 D9          0962  EXP3S3:			EXX
0402C6 C1          0963  			POP     BC
0402C7 CD F1 09 04 0964  			CALL    POPS            	; Restore from stack
0402CB D9          0965  			EXX
0402CC F6 80       0966  			OR      80H             	; Flag as a string
0402CE 08          0967  			EX      AF,AF'
0402CF FD 7E 00    0968  			LD      A,(IY)			; Fetch the next character
0402D2 18 A2       0969  			JR      EXPR3A			; And continue
0402D4             0970  ;
0402D4             0971  ; Level 3: * / MOD DIV
0402D4             0972  ;
0402D4 CD F5 02 04 0973  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402D8 FE 2A       0974  EXPR4A:			CP      '*'			; "*" is valid
0402DA 28 0B       0975  			JR      Z,EXPR4B
0402DC FE 2F       0976  			CP      '/'			; "/" is valid
0402DE 28 07       0977  			JR      Z,EXPR4B
0402E0 FE 83       0978  			CP      MODK			; MOD token is valid
0402E2 28 03       0979  			JR      Z,EXPR4B
0402E4 FE 81       0980  			CP      DIVK			; DIV token is valid
0402E6 C0          0981  			RET     NZ			; And return if it is anything else
0402E7 CD 51 0A 04 0982  EXPR4B:			CALL    SAVE_EV
0402EB CD F5 02 04 0983  			CALL    EXPR5
0402EF CD 60 0A 04 0984  			CALL    DOIT
0402F3 18 E3       0985  			JR      EXPR4A
0402F5             0986  ;
0402F5             0987  ; Level 2: ^
0402F5             0988  ;
0402F5 CD D5 03 04 0989  EXPR5:			CALL    ITEM			; Get variable
0402F9 B7          0990  			OR      A               	; Test type
0402FA 08          0991  			EX      AF,AF'          	; Save type
0402FB CD 83 0A 04 0992  EXPR5A:			CALL    NXT			; Skip spaces
0402FF FE 5E       0993  			CP      '^'			; Is the operator "^"?
040301 C0          0994  			RET     NZ			; No, so return
040302 CD 51 0A 04 0995  			CALL    SAVE_EV			; Save first operand
040306 CD D5 03 04 0996  			CALL    ITEM			; Get second operand
04030A B7          0997  			OR      A			; Test type
04030B 08          0998  			EX      AF,AF'			; Save type
04030C CD 60 0A 04 0999  			CALL    DOIT			; Do the operation
040310 18 E9       1000  			JR      EXPR5A			; And continue
040312             1001  ;
040312             1002  ; Evaluate a numeric expression
040312             1003  ;
040312 CD D2 01 04 1004  EXPRN:			CALL    EXPR			; Evaluate expression
040316 08          1005  			EX      AF,AF'			; Get the type
040317 F0          1006  			RET     P			; And return if it is a number
040318 18 2C       1007  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031A             1008  ;
04031A             1009  ; Evaluate a fixed-point expression
04031A             1010  ;
04031A CD D2 01 04 1011  EXPRI:			CALL    EXPR			; Evaluate the expression
04031E 08          1012  			EX      AF,AF'			; Get the type
04031F F2 72 06 04 1013  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040323 18 21       1014  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040325             1015  ;
040325             1016  ; Evaluate a string expression
040325             1017  ;
040325 CD D2 01 04 1018  EXPRS:			CALL    EXPR			; Evaluate the expression
040329 08          1019  			EX      AF,AF'			; Get the type
04032A F8          1020  			RET     M			; And return if it is a string
04032B 18 19       1021  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032D             1022  ;
04032D             1023  ; Get a numeric variable
04032D             1024  ;
04032D CD D5 03 04 1025  ITEMN:			CALL    ITEM			; Get the variable
040331 B7          1026  			OR      A			; Test the type
040332 F0          1027  			RET     P			; And return if it is a number
040333 18 11       1028  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040335             1029  ;
040335             1030  ; Get a fixed-point variable
040335             1031  ;
040335 CD D5 03 04 1032  ITEMI:			CALL    ITEM			; Get the variable
040339 B7          1033  			OR      A			; Test the type
04033A F2 72 06 04 1034  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04033E 18 06       1035  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040340             1036  ;
040340             1037  ; Get a string variable
040340             1038  ;
040340 CD D5 03 04 1039  ITEMS:			CALL    ITEM			; Get the variable
040344 B7          1040  			OR      A			; Test the type
040345 F8          1041  			RET     M			; If it is a string, then return
040346             1042  ;							; Otherwise
040346 3E 06       1043  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040348 C3 C1 37 04 1044  			JP      ERROR_
04034C             1045  ;
04034C             1046  ; Evaluate a bracketed expression
04034C             1047  ;
04034C CD D2 01 04 1048  ITEM1:			CALL    EXPR            	; Evaluate the expression
040350 CD 42 0A 04 1049  			CALL    BRAKET			; Check for closing bracket
040354 08          1050  			EX      AF,AF'
040355 C9          1051  			RET
040356             1052  ;
040356             1053  ; HEX - Get hexadecimal constant.
040356             1054  ;   Inputs: ASCII string at (IY)
040356             1055  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040356             1056  ;           IY updated (points to delimiter)
040356             1057  ;
040356 CD A3 09 04 1058  HEX:			CALL    ZERO			; Set result to 0
04035A CD 0B 0A 04 1059  			CALL    HEXDIG			; Fetch the character from IY
04035E 38 1B       1060  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040360 FD 23       1061  HEX1:			INC     IY			; Move pointer to next character
040362 E6 0F       1062  			AND     0FH			; Clear the top nibble
040364 06 04       1063  			LD      B,4			; Loop counter
040366             1064  ;
040366 D9          1065  HEX2:			EXX				; Shift the result left B (4) times. This makes
040367 52 29       1066  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040369 D9          1067  			EXX				; .
04036A 52 ED 6A    1068  			ADC.S   HL,HL			; .
04036D 10 F7       1069  			DJNZ    HEX2			; And loop
04036F D9          1070  			EXX
040370 B5          1071  			OR      L			; OR in the digit
040371 6F          1072  			LD      L,A
040372 D9          1073  			EXX
040373             1074  ;
040373 CD 0B 0A 04 1075  			CALL    HEXDIG			; Fetch the next character
040377 30 E7       1076  			JR      NC,HEX1			; If it is a HEX digit then loop
040379 AF          1077  			XOR     A			; Clear A
04037A C9          1078  			RET
04037B             1079  ;
04037B 3E 1C       1080  BADHEX:			LD      A,28
04037D C3 C1 37 04 1081  			JP      ERROR_          	; Error: "Bad HEX"
040381             1082  ;
040381             1083  ; BIN - Get binary constant.
040381             1084  ;   Inputs: ASCII string at (IY)
040381             1085  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040381             1086  ;           IY updated (points to delimiter)
040381             1087  ;
040381 CD A3 09 04 1088  BIN:			CALL    ZERO			; Set result to 0
040385 CD 1E 0A 04 1089  			CALL	BINDIG			; Fetch the character from IY
040389 38 13       1090  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04038B FD 23       1091  BIN1:			INC	IY			; Move pointer to next character
04038D 0F          1092  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04038E D9          1093  			EXX				;
04038F 52 ED 6A    1094  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040392 D9          1095  			EXX
040393 52 ED 6A    1096  			ADC.S	HL,HL
040396 CD 1E 0A 04 1097  			CALL	BINDIG			; Fetch the next character
04039A 30 EF       1098  			JR	NC,BIN1
04039C AF          1099  			XOR	A			; Clear A
04039D C9          1100  			RET
04039E             1101  ;
04039E 3E 1C       1102  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0403A0 CD D8 37 04 1103  			CALL	EXTERR
0403A4 42 61 64 20 1104  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0403AF             1105  ;
0403AF             1106  ; MINUS - Unary minus.
0403AF             1107  ;   Inputs: IY = text pointer
0403AF             1108  ;  Outputs: Numeric result, same type as argument.
0403AF             1109  ;           Result in H'L'HLC
0403AF             1110  ;
0403AF CD 2D 03 04 1111  MINUS:			CALL    ITEMN			; Get the numeric argument
0403B3 0D          1112  MINUS0:			DEC     C			; Check exponent (C)
0403B4 0C          1113  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403B5 28 06       1114  			JR      Z,NEGATE_EV        	; So do an integer negation
0403B7             1115  ;
0403B7 7C          1116  			LD      A,H			; Do a FP negation by
0403B8 EE 80       1117  			XOR     80H             	; Toggling the sign bit (H)
0403BA 67          1118  			LD      H,A
0403BB AF          1119  			XOR     A               	; Numeric marker
0403BC C9          1120  			RET
0403BD             1121  ;
0403BD D9          1122  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403BE 7C          1123  			LD      A,H			; First do a one's complement by negating all the bytes
0403BF 2F          1124  			CPL
0403C0 67          1125  			LD      H,A
0403C1 7D          1126  			LD      A,L
0403C2 2F          1127  			CPL
0403C3 6F          1128  			LD      L,A
0403C4 D9          1129  			EXX
0403C5 7C          1130  			LD      A,H
0403C6 2F          1131  			CPL
0403C7 67          1132  			LD      H,A
0403C8 7D          1133  			LD      A,L
0403C9 2F          1134  			CPL
0403CA 6F          1135  			LD      L,A
0403CB D9          1136  ADD1:			EXX				; Then add 1
0403CC 23          1137  			INC     HL
0403CD 7C          1138  			LD      A,H
0403CE B5          1139  			OR      L
0403CF D9          1140  			EXX
0403D0 3E 00       1141  			LD      A,0             	; Numeric marker
0403D2 C0          1142  			RET     NZ
0403D3 23          1143  			INC     HL
0403D4 C9          1144  			RET
0403D5             1145  ;
0403D5             1146  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403D5             1147  ; Item type is returned in A:  Bit 7=0 numeric.
0403D5             1148  ;                              Bit 7=1 string.
0403D5             1149  ; Numeric item returned in HLH'L'C.
0403D5             1150  ; String item returned in string accumulator,
0403D5             1151  ;   DE addresses byte after last (E=length).
0403D5             1152  ;
0403D5 CD 8C 16 04 1153  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403D9 CD 83 0A 04 1154  			CALL    NXT			; Skip spaces
0403DD FD 23       1155  			INC     IY			; Move to the prefix character
0403DF FE 26       1156  			CP      '&'			; If `&`
0403E1 CA 56 03 04 1157  			JP      Z,HEX           	; Then get a HEX constant
0403E5 FE 25       1158  			CP	'%'			; If '%'
0403E7 28 98       1159  			JR	Z,BIN			; Then get a BINARY constant
0403E9 FE 2D       1160  			CP      '-'			; If `-`
0403EB 28 C2       1161  			JR      Z,MINUS         	; Then get a negative number
0403ED FE 2B       1162  			CP      '+'			; If `+`
0403EF CA 2D 03 04 1163  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403F3 FE 28       1164  			CP      '('			; If `(`
0403F5 CA 4C 03 04 1165  			JP      Z,ITEM1         	; Start of a bracketed expression
0403F9 FE 22       1166  			CP      34			; If `"`
0403FB 28 7A       1167  			JR      Z,CONS          	; Start of a string constant
0403FD FE C6       1168  			CP      TCMD			; Is it out of range of the function table?
0403FF D2 AA 0C 04 1169  			JP      NC,SYNTAX       	; Error: "Syntax Error"
040403 FE 8D       1170  			CP      FUNTOK			; If it is in range, then
040405 D2 96 0A 04 1171  			JP      NC,DISPAT       	; It's a function
040409 FD 2B       1172  			DEC     IY
04040B FE 3A       1173  			CP      ':'
04040D 30 0C       1174  			JR      NC,ITEM2		; VARIABLE?
04040F FE 30       1175  			CP      '0'
040411 D2 9E 04 04 1176  			JP      NC,CON			; NUMERIC CONSTANT
040415 FE 2E       1177  			CP      '.'
040417 CA 9E 04 04 1178  			JP      Z,CON			; NUMERIC CONSTANT
04041B CD 9B 3A 04 1179  ITEM2:			CALL    GETVAR			; VARIABLE
04041F 20 37       1180  			JR      NZ,NOSUCH
040421 B7          1181  			OR      A
040422 FA B0 04 04 1182  			JP      M,LOADS			; STRING VARIABLE
040426 B7          1183  LOADN:			OR      A
040427 28 20       1184  			JR      Z,LOAD1			; BYTE VARIABLE
040429 0E 00       1185  			LD      C,0
04042B CB 47       1186  			BIT     0,A
04042D 28 03       1187  			JR      Z,LOAD4			; INTEGER VARIABLE
04042F DD 4E 04    1188  LOAD5:			LD      C,(IX+4)
040432 D9          1189  LOAD4:			EXX
040433 21 00 00 00 1190  			LD	HL, 0			; TODO: Optimise
040437 DD 6E 00    1191  			LD      L,(IX+0)
04043A DD 66 01    1192  			LD      H,(IX+1)
04043D D9          1193  			EXX
04043E 21 00 00 00 1194  			LD	HL, 0			; TODO: Optimise
040442 DD 6E 02    1195  			LD      L,(IX+2)
040445 DD 66 03    1196  			LD      H,(IX+3)
040448 C9          1197  			RET
040449             1198  ;
040449 21 00 00 00 1199  LOAD1:			LD      HL,0
04044D D9          1200  			EXX
04044E 21 00 00 00 1201  			LD      HL,0			; TODO: Optimise
040452 DD 6E 00    1202  			LD      L,(IX+0)
040455 D9          1203  			EXX
040456 4C          1204  			LD      C,H
040457 C9          1205  			RET
040458             1206  ;
040458 DA AA 0C 04 1207  NOSUCH:			JP      C,SYNTAX
04045C 3A 40 4D 04 1208  			LD      A,(LISTON)
040460 CB 6F       1209  			BIT     5,A
040462 3E 1A       1210  			LD      A,26
040464 20 26       1211  			JR      NZ,ERROR0_EV		; Throw "No such variable"
040466 FD 23       1212  NOS1:			INC     IY
040468 CD D0 3C 04 1213  			CALL    RANGE
04046C 30 F8       1214  			JR      NC,NOS1
04046E DD 21 40 4C 1215  			LD      IX,PC
       04          
040473 AF          1216  			XOR     A
040474 4F          1217  			LD      C,A
040475 18 BB       1218  			JR      LOAD4
040477             1219  ;
040477             1220  ;CONS - Get string constant from ASCII string.
040477             1221  ;   Inputs: ASCII string at (IY)
040477             1222  ;  Outputs: Result in string accumulator.
040477             1223  ;           D = MS byte of ACCS, E = string length
040477             1224  ;           A7 = 1 (string marker)
040477             1225  ;           IY updated
040477             1226  ;
040477 11 00 4A 04 1227  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04047B FD 7E 00    1228  CONS3:			LD      A,(IY)			; Fetch the first character and
04047E FD 23       1229  			INC     IY			; Increment the pointer
040480 FE 22       1230  			CP      '"'			; Check for start quote
040482 28 0C       1231  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040484             1232  ;
040484 12          1233  CONS1:			LD      (DE),A			; Store the character in the string accumulator
040485 1C          1234  			INC     E			; Increment the string accumulator pointer
040486 FE 0D       1235  			CP      CR			; Is it CR
040488 20 F1       1236  			JR      NZ,CONS3		; No, so keep looping
04048A             1237  ;
04048A 3E 09       1238  			LD      A,9
04048C C3 C1 37 04 1239  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040490             1240  ;
040490 FD 7E 00    1241  CONS2:			LD      A,(IY)			; Fetch the next character
040493 FE 22       1242  			CP      '"'			; Check for end quote?
040495 FD 23       1243  			INC     IY			; Increment the pointer
040497 28 EB       1244  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040499 FD 2B       1245  			DEC     IY			;
04049B 3E 80       1246  			LD      A,80H           	; String marker
04049D C9          1247  			RET
04049E             1248  ;
04049E             1249  ;CON - Get unsigned numeric constant from ASCII string.
04049E             1250  ;   Inputs: ASCII string at (IY).
04049E             1251  ;  Outputs: Variable-type result in HLH'L'C
04049E             1252  ;           IY updated (points to delimiter)
04049E             1253  ;           A7 = 0 (numeric marker)
04049E             1254  ;
04049E FD E5       1255  CON:			PUSH    IY
0404A0 DD E1       1256  			POP     IX
0404A2 3E 24       1257  			LD      A,36
0404A4 CD AD 20 04 1258  			CALL    FPP
0404A8 38 E2       1259  			JR      C,ERROR0_EV
0404AA DD E5       1260  			PUSH    IX
0404AC FD E1       1261  			POP     IY
0404AE AF          1262  			XOR     A
0404AF C9          1263  			RET
0404B0             1264  ;
0404B0 11 00 4A 04 1265  LOADS:			LD      DE,ACCS			; Where to store the string
0404B4 1F          1266  			RRA
0404B5 30 1A       1267  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404B7             1268  ;
0404B7 D9          1269  			EXX				; This block was a call to LOAD4
0404B8 DD 6E 00    1270  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404BB DD 66 01    1271  			LD      H,(IX+1)		; The maximum original string length
0404BE D9          1272  			EXX
0404BF DD 27 02    1273  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404C2             1274  ;
0404C2 D9          1275  			EXX
0404C3 7D          1276  			LD      A,L
0404C4 D9          1277  			EXX
0404C5 B7          1278  			OR      A
0404C6 01 00 00 00 1279  			LD	BC,0			; BC: Number of bytes to copy
0404CA 4F          1280  			LD      C,A
0404CB 3E 80       1281  			LD      A,80H           	; String marker
0404CD C8          1282  			RET     Z
0404CE ED B0       1283  			LDIR
0404D0 C9          1284  			RET
0404D1 7E          1285  LOADS2:			LD      A,(HL)
0404D2 12          1286  			LD      (DE),A
0404D3 23          1287  			INC     HL
0404D4 FE 0D       1288  			CP      CR
0404D6 3E 80       1289  			LD      A,80H           	; String marker
0404D8 C8          1290  			RET     Z
0404D9 1C          1291  			INC     E
0404DA 20 F5       1292  			JR      NZ,LOADS2
0404DC C9          1293  			RET                     	; Return null string
0404DD             1294  ;
0404DD             1295  ;VARIABLE-TYPE FUNCTIONS:
0404DD             1296  ;
0404DD             1297  ;Result returned in HLH'L'C (floating point)
0404DD             1298  ;Result returned in HLH'L' (C=0) (integer)
0404DD             1299  ;Result returned in string accumulator & DE (string)
0404DD             1300  ;All registers destroyed.
0404DD             1301  ;IY (text pointer) updated.
0404DD             1302  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404DD             1303  ;
0404DD             1304  ;POS - horizontal cursor position.
0404DD             1305  ;VPOS - vertical cursor position.
0404DD             1306  ;EOF - return status of file.
0404DD             1307  ;BGET - read byte from file.
0404DD             1308  ;INKEY - as GET but wait only n centiseconds.
0404DD             1309  ;GET - wait for keypress and return ASCII value.
0404DD             1310  ;GET(n) - input from Z80 port n.
0404DD             1311  ;ASC - ASCII value of string.
0404DD             1312  ;LEN - length of string.
0404DD             1313  ;LOMEM - location of dynamic variables.
0404DD             1314  ;HIMEM - top of available RAM.
0404DD             1315  ;PAGE - start of current text page.
0404DD             1316  ;TOP - address of first free byte after program.
0404DD             1317  ;ERL - line number where last error occurred.
0404DD             1318  ;ERR - number of last error.
0404DD             1319  ;COUNT - number of printing characters since CR.
0404DD             1320  ;Results are integer numeric.
0404DD             1321  ;
0404DD CD 2D 3F 04 1322  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404E1 EB          1323  			EX      DE,HL			;  L: The X cursor position
0404E2 C3 91 05 04 1324  			JP      COUNT1			; Return an 8-bit value
0404E6             1325  ;
0404E6 CD 2D 3F 04 1326  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404EA C3 91 05 04 1327  			JP      COUNT1			; Return an 8-bit value
0404EE             1328  ;
0404EE CD C3 18 04 1329  EOF:			CALL    CHANEL			; Check for EOF
0404F2 CD B6 43 04 1330  			CALL    OSSTAT
0404F6 CA 15 06 04 1331  			JP      Z,TRUE			; Yes, so return true
0404FA C3 A3 09 04 1332  			JP      ZERO			; Otherwise return false (zero)
0404FE             1333  ;
0404FE CD C3 18 04 1334  BGET:			CALL    CHANEL          	; Channel number
040502 CD A5 43 04 1335  			CALL    OSBGET
040506 6F          1336  			LD      L,A
040507 C3 8F 05 04 1337  			JP      COUNT0			; Return an 8-bit value
04050B             1338  ;
04050B CD 35 03 04 1339  INKEY:			CALL    ITEMI			; Get the argument
04050F CB 7C       1340  			BIT	7, H			; Check the sign
040511 D9          1341  			EXX				; HL: The argument
040512 C2 FB 07 04 1342  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040516 CD ED 07 04 1343  			CALL	INKEY0 			; Do INKEY(n)
04051A 18 1D       1344  			JR      ASC0			; Return a numeric value
04051C             1345  ;
04051C CD 83 0A 04 1346  GET:			CALL    NXT			; Skip whitespace
040520 FE 28       1347  			CP      '('			; Is it GET(
040522 20 0B       1348  			JR      NZ,GET0			; No, so get a keyboard character
040524 CD 35 03 04 1349  			CALL    ITEMI           	; Yes, so fetch the port address
040528 D9          1350  			EXX
040529 44          1351  			LD      B,H			; BC: The port address
04052A 4D          1352  			LD      C,L
04052B ED 68       1353  			IN      L,(C)           	;  L: Input from port BC
04052D 18 60       1354  			JR      COUNT0			; Return an 8-bit value
04052F             1355  ;
04052F CD D7 07 04 1356  GET0:			CALL    GETS			; Read the keyboard character
040533 18 0A       1357  			JR      ASC1			; And return the value
040535             1358  ;
040535 CD 40 03 04 1359  ASC:			CALL    ITEMS			; Get the string argument argument
040539 AF          1360  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04053A BB          1361  			CP      E			; Is the pointer 0
04053B CA 15 06 04 1362  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04053F 2A 00 4A 04 1363  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040543 18 4A       1364  			JR      COUNT0			; An 8-bit value
040545             1365  ;
040545 CD 40 03 04 1366  LEN:			CALL    ITEMS			; Get the string argument
040549 EB          1367  			EX      DE,HL			; HL: Pointer into ACCS
04054A 18 43       1368  			JR      COUNT0			; Return L
04054C             1369  ;
04054C 2A 1A 4D 04 1370  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040550 3A 1C 4D 04 1371  			LD	A, (LOMEM+2)
040554 18 41       1372  			JR      COUNT2			; A 24-bit value
040556             1373  ;
040556 2A 20 4D 04 1374  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04055A 3A 22 4D 04 1375  			LD	A, (HIMEM+2)
04055E 18 37       1376  			JR      COUNT2			; A 24-bit value
040560             1377  ;
040560 2A 14 4D 04 1378  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040564 3A 16 4D 04 1379  			LD	A, (PAGE_+2)		; A 24-bit value
040568 18 2D       1380  			JR      COUNT2
04056A             1381  ;
04056A FD 7E 00    1382  TOPV:			LD      A,(IY)			; Return the TOP system variable
04056D FD 23       1383  			INC     IY              	; Skip "P"
04056F FE 50       1384  			CP      'P'
040571 C2 AA 0C 04 1385  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
040575 2A 17 4D 04 1386  			LD      HL,(TOP)
040579 3A 19 4D 04 1387  			LD	A, (TOP+2)
04057D 18 18       1388  			JR      COUNT2
04057F             1389  ;
04057F 2A 33 4D 04 1390  ERLV:			LD      HL,(ERL)		; Return the error line
040583 18 0C       1391  			JR      COUNT1			; A 16-bit value
040585             1392  ;
040585 2A 3F 4D 04 1393  ERRV:			LD      HL,(ERR)		; Return the error value
040589 18 04       1394  			JR      COUNT0			; An 8-bit value
04058B             1395  ;
04058B 2A 3D 4D 04 1396  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04058F             1397  
04058F 26 00       1398  COUNT0:			LD      H,0			; Return L
040591 D9          1399  COUNT1:			EXX				; Return HL
040592 AF          1400  			XOR     A
040593 4F          1401  			LD      C,A             	; Integer marker
040594 67          1402  			LD      H,A
040595 6F          1403  			LD      L,A
040596 C9          1404  			RET
040597 D9          1405  COUNT2:			EXX
040598 6F          1406  			LD	L,A
040599 AF          1407  			XOR	A
04059A 4F          1408  			LD	C,A			; Integer marker
04059B 67          1409  			LD	H,A
04059C C9          1410  			RET
04059D             1411  ;
04059D             1412  ;OPENIN - Open a file for reading.
04059D             1413  ;OPENOT - Open a file for writing.
04059D             1414  ;OPENUP - Open a file for reading or writing.
04059D             1415  ;Result is integer channel number (0 if error)
04059D             1416  ;
04059D AF          1417  OPENOT:			XOR     A			; Open for writing
04059E 18 06       1418  			JR	OPENIN_1
0405A0             1419  ;
0405A0 3E 02       1420  OPENUP:			LD      A,2			; Open for reading / writing
0405A2 18 02       1421  			JR	OPENIN_1
0405A4             1422  ;
0405A4 3E 01       1423  OPENIN:			LD      A,1			; Open for reading
0405A6             1424  ;
0405A6 F5          1425  OPENIN_1:		PUSH    AF              	; Save OPEN type
0405A7 CD 40 03 04 1426  			CALL    ITEMS           	; Fetch the filename
0405AB 3E 0D       1427  			LD      A,CR
0405AD 12          1428  			LD      (DE),A
0405AE F1          1429  			POP     AF              	; Restore the OPEN type
0405AF C6 FF       1430  			ADD     A,-1            	; Affect the flags
0405B1 21 00 4A 04 1431  			LD      HL,ACCS
0405B5 CD 8E 43 04 1432  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405B9 6F          1433  			LD      L,A			; L: Channel number
0405BA 18 D3       1434  			JR      COUNT0			; Return channel number to BASIC
0405BC             1435  ;
0405BC             1436  ;EXT - Return length of file.
0405BC             1437  ;PTR_EV - Return current file pointer.
0405BC             1438  ;Results are integer numeric.
0405BC             1439  ;
0405BC CD C3 18 04 1440  EXT:			CALL    CHANEL
0405C0 CD EC 43 04 1441  			CALL    GETEXT
0405C4 18 15       1442  			JR      TIME0
0405C6             1443  ;
0405C6 CD C3 18 04 1444  PTR_EV:			CALL    CHANEL
0405CA CD C0 43 04 1445  			CALL    GETPTR
0405CE 18 0B       1446  			JR      TIME0
0405D0             1447  ;
0405D0             1448  ;TIME - Return current value of elapsed time.
0405D0             1449  ;Result is integer numeric.
0405D0             1450  ;
0405D0 FD 7E 00    1451  TIMEV:			LD      A,(IY)
0405D3 FE 24       1452  			CP      '$'
0405D5 28 0A       1453  			JR      Z,TIMEVS
0405D7 CD 0D 3F 04 1454  			CALL    GETIME
0405DB D5          1455  TIME0:			PUSH    DE
0405DC D9          1456  			EXX
0405DD E1          1457  			POP     HL
0405DE AF          1458  			XOR     A
0405DF 4F          1459  			LD      C,A
0405E0 C9          1460  			RET
0405E1             1461  ;
0405E1             1462  ;TIME$ - Return date/time string.
0405E1             1463  ;Result is string
0405E1             1464  ;
0405E1 FD 23       1465  TIMEVS:			INC     IY              ;SKIP $
0405E3 CD 05 44 04 1466  			CALL    GETIMS
0405E7 3E 80       1467  			LD      A,80H           ;MARK STRING
0405E9 C9          1468  			RET
0405EA             1469  ;
0405EA             1470  ;String comparison:
0405EA             1471  ;
0405EA CD 9F 09 04 1472  SLT:			CALL    SCP
0405EE D0          1473  			RET     NC
0405EF 18 24       1474  			JR      TRUE
0405F1             1475  ;
0405F1 CD 9F 09 04 1476  SGT:			CALL    SCP
0405F5 C8          1477  			RET     Z
0405F6 D8          1478  			RET     C
0405F7 18 1C       1479  			JR      TRUE
0405F9             1480  ;
0405F9 CD 9F 09 04 1481  SGE:			CALL    SCP
0405FD D8          1482  			RET     C
0405FE 18 15       1483  			JR      TRUE
040600             1484  ;
040600 CD 9F 09 04 1485  SLE:			CALL    SCP
040604 28 0F       1486  			JR      Z,TRUE
040606 D0          1487  			RET     NC
040607 18 0C       1488  			JR      TRUE
040609             1489  ;
040609 CD 9F 09 04 1490  SNE:			CALL    SCP
04060D C8          1491  			RET     Z
04060E 18 05       1492  			JR      TRUE
040610             1493  ;
040610 CD 9F 09 04 1494  SEQ:			CALL    SCP
040614 C0          1495  			RET     NZ
040615 3E FF       1496  TRUE:			LD      A,-1
040617 D9          1497  			EXX
040618 67          1498  			LD      H,A
040619 6F          1499  			LD      L,A
04061A D9          1500  			EXX
04061B 67          1501  			LD      H,A
04061C 6F          1502  			LD      L,A
04061D 3C          1503  			INC     A
04061E 4F          1504  			LD      C,A
04061F C9          1505  			RET
040620             1506  ;
040620             1507  ;PI - Return PI (3.141592654)
040620             1508  ;Result is floating-point numeric.
040620             1509  ;
040620 3E 23       1510  PI:			LD      A,35
040622 18 44       1511  			JR      FPP1
040624             1512  ;
040624             1513  ;ABS - Absolute value
040624             1514  ;Result is numeric, variable type.
040624             1515  ;
040624 3E 10       1516  ABSV:			LD      A,16
040626 18 3A       1517  			JR      FPPN
040628             1518  ;
040628             1519  ;NOT - Complement integer.
040628             1520  ;Result is integer numeric.
040628             1521  ;
040628 3E 1A       1522  NOTK:			LD      A,26
04062A 18 36       1523  			JR      FPPN
04062C             1524  ;
04062C             1525  ;DEG - Convert radians to degrees
04062C             1526  ;Result is floating-point numeric.
04062C             1527  ;
04062C 3E 15       1528  DEG:			LD      A,21
04062E 18 32       1529  			JR      FPPN
040630             1530  ;
040630             1531  ;RAD - Convert degrees to radians
040630             1532  ;Result is floating-point numeric.
040630             1533  ;
040630 3E 1B       1534  RAD:			LD      A,27
040632 18 2E       1535  			JR      FPPN
040634             1536  ;
040634             1537  ;SGN - Return -1, 0 or +1
040634             1538  ;Result is integer numeric.
040634             1539  ;
040634 3E 1C       1540  SGN:			LD      A,28
040636 18 2A       1541  			JR      FPPN
040638             1542  ;
040638             1543  ;INT - Floor function
040638             1544  ;Result is integer numeric.
040638             1545  ;
040638 3E 17       1546  INT_:			LD      A,23
04063A 18 26       1547  			JR      FPPN
04063C             1548  ;
04063C             1549  ;SQR - square root
04063C             1550  ;Result is floating-point numeric.
04063C             1551  ;
04063C 3E 1E       1552  SQR:			LD      A,30
04063E 18 22       1553  			JR      FPPN
040640             1554  ;
040640             1555  ;TAN - Tangent function
040640             1556  ;Result is floating-point numeric.
040640             1557  ;
040640 3E 1F       1558  TAN:			LD      A,31
040642 18 1E       1559  			JR      FPPN
040644             1560  ;
040644             1561  ;COS - Cosine function
040644             1562  ;Result is floating-point numeric.
040644             1563  ;
040644 3E 14       1564  COS:			LD      A,20
040646 18 1A       1565  			JR      FPPN
040648             1566  ;
040648             1567  ;SIN - Sine function
040648             1568  ;Result is floating-point numeric.
040648             1569  ;
040648 3E 1D       1570  SIN:			LD      A,29
04064A 18 16       1571  			JR      FPPN
04064C             1572  ;
04064C             1573  ;EXP - Exponential function
04064C             1574  ;Result is floating-point numeric.
04064C             1575  ;
04064C 3E 16       1576  EXP:			LD      A,22
04064E 18 12       1577  			JR      FPPN
040650             1578  ;
040650             1579  ;LN - Natural log.
040650             1580  ;Result is floating-point numeric.
040650             1581  ;
040650 3E 18       1582  LN:			LD      A,24
040652 18 0E       1583  			JR      FPPN
040654             1584  ;
040654             1585  ;LOG - base-10 logarithm.
040654             1586  ;Result is floating-point numeric.
040654             1587  ;
040654 3E 19       1588  LOG:			LD      A,25
040656 18 0A       1589  			JR      FPPN
040658             1590  ;
040658             1591  ;ASN - Arc-sine
040658             1592  ;Result is floating-point numeric.
040658             1593  ;
040658 3E 12       1594  ASN:			LD      A,18
04065A 18 06       1595  			JR      FPPN
04065C             1596  ;
04065C             1597  ;ATN - arc-tangent
04065C             1598  ;Result is floating-point numeric.
04065C             1599  ;
04065C 3E 13       1600  ATN:			LD      A,19
04065E 18 02       1601  			JR      FPPN
040660             1602  ;
040660             1603  ;ACS - arc-cosine
040660             1604  ;Result is floating point numeric.
040660             1605  ;
040660 3E 11       1606  ACS:			LD      A,17
040662 F5          1607  FPPN:			PUSH    AF
040663 CD 2D 03 04 1608  			CALL    ITEMN
040667 F1          1609  			POP     AF
040668 CD AD 20 04 1610  FPP1:			CALL    FPP
04066C DA C1 37 04 1611  			JP      C,ERROR_
040670 AF          1612  			XOR     A
040671 C9          1613  			RET
040672             1614  ;
040672             1615  ;SFIX - Convert to fixed-point notation
040672             1616  ;
040672 3E 26       1617  SFIX:			LD      A,38
040674 18 F2       1618  			JR      FPP1
040676             1619  ;
040676             1620  ;SFLOAT - Convert to floating-point notation
040676             1621  ;
040676 3E 27       1622  SFLOAT:			LD      A,39
040678 18 EE       1623  			JR      FPP1
04067A             1624  ;
04067A             1625  ;VAL - Return numeric value of string.
04067A             1626  ;Result is variable type numeric.
04067A             1627  ;
04067A CD 40 03 04 1628  VAL:			CALL    ITEMS
04067E AF          1629  VAL0:			XOR     A
04067F 12          1630  			LD      (DE),A
040680 DD 21 00 4A 1631  			LD      IX,ACCS
       04          
040685 3E 24       1632  			LD      A,36
040687 18 DF       1633  			JR      FPP1
040689             1634  ;
040689             1635  ;EVAL - Pass string to expression evaluator.
040689             1636  ;Result is variable type (numeric or string).
040689             1637  ;
040689 CD 40 03 04 1638  EVAL_:			CALL    ITEMS
04068D 3E 0D       1639  			LD      A,CR
04068F 12          1640  			LD      (DE),A
040690 FD E5       1641  			PUSH    IY
040692 11 00 4A 04 1642  			LD      DE,ACCS
040696 FD 21 00 4A 1643  			LD      IY,ACCS
       04          
04069B 0E 00       1644  			LD      C,0
04069D CD 00 3D 04 1645  			CALL    LEXAN2          ;TOKENISE
0406A1 12          1646  			LD      (DE),A
0406A2 13          1647  			INC     DE
0406A3 AF          1648  			XOR     A
0406A4 CD C4 09 04 1649  			CALL    PUSHS           ;PUT ON STACK
0406A8 FD 21 03 00 1650  			LD      IY,SIZEW	;WAS 2
       00          
0406AD FD 39       1651  			ADD     IY,SP
0406AF CD D2 01 04 1652  			CALL    EXPR
0406B3 FD E1       1653  			POP     IY
0406B5 FD 39       1654  			ADD     IY,SP
0406B7 FD F9       1655  			LD      SP,IY           ;ADJUST STACK POINTER
0406B9 FD E1       1656  			POP     IY
0406BB 08          1657  			EX      AF,AF'
0406BC C9          1658  			RET
0406BD             1659  ;
0406BD             1660  ;RND - Random number function.
0406BD             1661  ; RND gives random integer 0-&FFFFFFFF
0406BD             1662  ; RND(-n) seeds random number & returns -n.
0406BD             1663  ; RND(0) returns last value in RND(1) form.
0406BD             1664  ; RND(1) returns floating-point 0-0.99999999.
0406BD             1665  ; RND(n) returns random integer 1-n.
0406BD             1666  ;
0406BD DD 21 38 4D 1667  RND:			LD      IX,RANDOM
       04          
0406C2 CD 83 0A 04 1668  			CALL    NXT
0406C6 FE 28       1669  			CP      '('
0406C8 28 20       1670  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406CA CD 2F 04 04 1671  			CALL    LOAD5
0406CE CB 19       1672  RND1:			RR      C
0406D0 06 20       1673  			LD      B,32
0406D2 D9          1674  RND2:			EXX                     ;CALCULATE NEXT
0406D3 52 ED 6A    1675  			ADC.S   HL,HL
0406D6 D9          1676  			EXX
0406D7 52 ED 6A    1677  			ADC.S   HL,HL
0406DA CB 5D       1678  			BIT     3,L
0406DC 28 01       1679  			JR      Z,RND3
0406DE 3F          1680  			CCF
0406DF 10 F1       1681  RND3:			DJNZ    RND2
0406E1 CB 11       1682  RND4:			RL      C               ;SAVE CARRY
0406E3 CD 18 16 04 1683  			CALL    STORE5          ;STORE NEW NUMBER
0406E7 AF          1684  			XOR     A
0406E8 4F          1685  			LD      C,A
0406E9 C9          1686  			RET
0406EA CD 35 03 04 1687  RND5:			CALL    ITEMI
0406EE DD 21 38 4D 1688  			LD      IX,RANDOM
       04          
0406F3 CB 7C       1689  			BIT     7,H             ;NEGATIVE?
0406F5 37          1690  			SCF
0406F6 20 E9       1691  			JR      NZ,RND4         ;SEED
0406F8 CD EF 08 04 1692  			CALL    TEST
0406FC F5          1693  			PUSH    AF
0406FD CD E7 08 04 1694  			CALL    SWAP
040701 D9          1695  			EXX
040702 CD 2F 04 04 1696  			CALL    LOAD5
040706 C4 CE 06 04 1697  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
04070A D9          1698  			EXX                     ;SCRAMBLE (CARE!)
04070B 0E 7F       1699  			LD      C,7FH
04070D CB 7C       1700  RND6:			BIT     7,H             ;FLOAT
04070F 20 0A       1701  			JR      NZ,RND7
040711 D9          1702  			EXX
040712 52 29       1703  			ADD.S   HL,HL
040714 D9          1704  			EXX
040715 52 ED 6A    1705  			ADC.S   HL,HL
040718 0D          1706  			DEC     C
040719 20 F2       1707  			JR      NZ,RND6
04071B CB BC       1708  RND7:			RES     7,H             ;POSITIVE 0-0.999999
04071D F1          1709  			POP     AF
04071E C8          1710  			RET     Z               ;ZERO ARGUMENT
04071F D9          1711  			EXX
040720 7B          1712  			LD      A,E
040721 3D          1713  			DEC     A
040722 B2          1714  			OR      D
040723 D9          1715  			EXX
040724 B3          1716  			OR      E
040725 B2          1717  			OR      D
040726 C8          1718  			RET     Z               ;ARGUMENT=1
040727 06 00       1719  			LD      B,0             ;INTEGER MARKER
040729 3E 0A       1720  			LD      A,10
04072B CD AD 20 04 1721  			CALL    FPP             ;MULTIPLY
04072F DA C1 37 04 1722  			JP      C,ERROR_
040733 CD 72 06 04 1723  			CALL    SFIX
040737 C3 CB 03 04 1724  			JP      ADD1
04073B             1725  ;
04073B             1726  ; INSTR - String search.
04073B             1727  ; Result is integer numeric.
04073B             1728  ;
04073B CD 31 0A 04 1729  INSTR:			CALL    EXPRSC			; Get the first string expression
04073F CD C4 09 04 1730  			CALL    PUSHS           	; Push the string onto the stack
040743 CD 25 03 04 1731  			CALL    EXPRS           	; Get the second string expression
040747 C1          1732  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
040748 21 00 00 00 1733  			LD      HL,0
04074C 39          1734  			ADD     HL,SP           	; HL: Pointer to main string
04074D C5          1735  			PUSH    BC              	;  C: Main string length
04074E 43          1736  			LD      B,E             	;  B: Sub-string length
04074F CD 83 0A 04 1737  			CALL    NXT			; Skip whitespace
040753 FE 2C       1738  			CP      ','			; Check if there is a comma for the third parameter
040755 3E 00       1739  			LD      A,0			;  A: Default start position in string
040757 20 1A       1740  			JR      NZ,INSTR1		; No, so skip the next bit
040759 FD 23       1741  			INC     IY              	; Skip the comma
04075B C5          1742  			PUSH    BC              	; Save the lengths
04075C E5          1743  			PUSH    HL              	; Save the pointer to the main string
04075D CD C4 09 04 1744  			CALL    PUSHS			; Push the string onto the stack
040761 CD 1A 03 04 1745  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040765 C1          1746  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040766 CD F1 09 04 1747  			CALL    POPS			; Pop the string off the stack
04076A E1          1748  			POP     HL              	; Restore the pointer to the main string
04076B C1          1749  			POP     BC              	; Restore the lengths
04076C D9          1750  			EXX
04076D 7D          1751  			LD      A,L			; A: The start position in the  string
04076E D9          1752  			EXX
04076F B7          1753  			OR      A			; Set the flags
040770 28 01       1754  			JR      Z,INSTR1		; If it is zero, then skip
040772 3D          1755  			DEC     A
040773 11 00 4A 04 1756  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040777 CD 95 07 04 1757  			CALL    SEARCH			; Do the search
04077B D1          1758  			POP     DE
04077C 28 03       1759  			JR      Z,INSTR2        	; NB: Carry cleared
04077E ED 62       1760  			SBC     HL,HL
040780 39          1761  			ADD     HL,SP
040781 ED 72       1762  INSTR2:			SBC     HL,SP
040783 EB          1763  			EX      DE,HL
040784 7D          1764  			LD	A,L
040785 21 00 00 00 1765  			LD      HL,0
040789 6F          1766  			LD	L,A
04078A 39          1767  			ADD     HL,SP
04078B F9          1768  			LD      SP,HL
04078C EB          1769  			EX      DE,HL
04078D CD 42 0A 04 1770  			CALL    BRAKET			; Check for closing bracket
040791 C3 91 05 04 1771  			JP      COUNT1			; Return a numeric integer
040795             1772  ;
040795             1773  ; SEARCH - Search string for sub-string
040795             1774  ;    Inputs: Main string at HL length C
040795             1775  ;            Sub-string  at DE length B
040795             1776  ;            Starting offset A
040795             1777  ;   Outputs: NZ - not found
040795             1778  ;            Z - found at location HL-1
040795             1779  ;            Carry always cleared
040795             1780  ;
040795 C5          1781  SEARCH:			PUSH    BC			; Add the starting offset to HL
040796 01 00 00 00 1782  			LD      BC,0
04079A 4F          1783  			LD      C,A
04079B 09          1784  			ADD     HL,BC           	; New start address
04079C C1          1785  			POP     BC
04079D 91          1786  			SUB     C			; If the starting offset > main string length, then do nothing
04079E 30 2C       1787  			JR      NC,SRCH4
0407A0 ED 44       1788  			NEG
0407A2 4F          1789  			LD      C,A             	; Remaining length
0407A3             1790  ;
0407A3 C5          1791  SRCH1:			PUSH    BC
0407A4 79          1792  			LD	A,C
0407A5 01 00 00 00 1793  			LD	BC,0
0407A9 4F          1794  			LD	C,A
0407AA 1A          1795  			LD      A,(DE)
0407AB ED B1       1796  			CPIR                    	; Find the first character
0407AD 79          1797  			LD      A,C
0407AE C1          1798  			POP     BC
0407AF 20 1B       1799  			JR      NZ,SRCH4
0407B1 4F          1800  			LD      C,A
0407B2             1801  ;
0407B2             1802  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407B2             1803  ;
0407B2 05          1804  			DEC     B			; Bug fix
0407B3 B8          1805  			CP      B			; Bug fix
0407B4 04          1806  			INC     B			; Bug fix
0407B5 38 15       1807  			JR      C,SRCH4			; Bug fix
0407B7             1808  ;
0407B7 C5          1809  			PUSH    BC
0407B8 D5          1810  			PUSH    DE
0407B9 E5          1811  			PUSH    HL
0407BA 05          1812  			DEC     B
0407BB 28 08       1813  			JR      Z,SRCH3         	; Found!
0407BD 13          1814  SRCH2:			INC     DE
0407BE 1A          1815  			LD      A,(DE)
0407BF BE          1816  			CP      (HL)
0407C0 20 03       1817  			JR      NZ,SRCH3
0407C2 23          1818  			INC     HL
0407C3 10 F8       1819  			DJNZ    SRCH2
0407C5 E1          1820  SRCH3:			POP     HL
0407C6 D1          1821  			POP     DE
0407C7 C1          1822  			POP     BC
0407C8 20 D9       1823  			JR      NZ,SRCH1
0407CA AF          1824  			XOR     A               	; Flags: Z, NC
0407CB C9          1825  			RET                     	; Found
0407CC             1826  ;
0407CC F6 FF       1827  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407CE C9          1828  			RET                     	; Not found
0407CF             1829  ;
0407CF             1830  ;CHRS - Return character with given ASCII value.
0407CF             1831  ;Result is string.
0407CF             1832  ;
0407CF CD 35 03 04 1833  CHRS:			CALL    ITEMI
0407D3 D9          1834  			EXX
0407D4 7D          1835  			LD      A,L
0407D5 18 0E       1836  			JR      GET1
0407D7             1837  ;
0407D7             1838  ;GETS - Return key pressed as stringor character at position (X,Y).
0407D7             1839  ;Result is string.
0407D7             1840  ;
0407D7 CD 83 0A 04 1841  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407DB FE 28       1842  			CP	'('
0407DD CA 63 44 04 1843  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407E1 CD 8A 3F 04 1844  			CALL    OSRDCH
0407E5 37          1845  GET1:			SCF
0407E6 18 09       1846  			JR      INKEY1
0407E8             1847  ;
0407E8             1848  ; INKEYS - Wait up to n centiseconds for keypress.
0407E8             1849  ;          Return key pressed as string or null
0407E8             1850  ;          string if time elapsed.
0407E8             1851  ; Result is string.
0407E8             1852  ;
0407E8 CD 35 03 04 1853  INKEYS:			CALL    ITEMI			; Fetch the argument
0407EC D9          1854  			EXX
0407ED CD 93 3F 04 1855  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407F1 11 00 4A 04 1856  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407F5 12          1857  			LD      (DE),A
0407F6 3E 80       1858  			LD      A,80H
0407F8 D0          1859  			RET     NC
0407F9 1C          1860  			INC     E
0407FA C9          1861  			RET
0407FB             1862  ;
0407FB             1863  ; INKEYM - Check immediately whether a given key is being pressed
0407FB             1864  ; Result is integer numeric
0407FB             1865  ;
0407FB             1866  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407FB 3E 1E       0001M 			LD	A, function
0407FD 49 CF       0002M 			RST.LIS	08h
0407FF 23          1867  			INC	HL			; Index from 0
040800 7D          1868  			LD	A, L			; Negate the LSB of the answer
040801 ED 44       1869  			NEG
040803 4F          1870  			LD	C, A			;  E: The positive keycode value
040804 3E 01       1871  			LD	A, 1			; Throw an "Out of range" error
040806 FA C1 37 04 1872  			JP	M, ERROR_		; if the argument < - 128
04080A             1873  ;
04080A 21 2D 08 04 1874  			LD	HL, BITLOOKUP		; HL: The bit lookup table
04080E 11 00 00 00 1875  			LD	DE, 0
040812 79          1876  			LD	A, C
040813 E6 07       1877  			AND	00000111b		; Just need the first three bits
040815 5F          1878  			LD	E, A			; DE: The bit number
040816 19          1879  			ADD	HL, DE
040817 46          1880  			LD	B, (HL)			;  B: The mask
040818             1881  ;
040818 79          1882  			LD	A, C			; Fetch the keycode again
040819 E6 78       1883  			AND	01111000b		; And divide by 8
04081B 0F          1884  			RRCA
04081C 0F          1885  			RRCA
04081D 0F          1886  			RRCA
04081E 5F          1887  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04081F DD 19       1888  			ADD	IX, DE			; IX: The address
040821 78          1889  			LD	A, B			;  B: The mask
040822 DD A6 00    1890  			AND	(IX+0)			; Check whether the bit is set
040825 CA A3 09 04 1891  			JP	Z, ZERO			; No, so return 0
040829 C3 15 06 04 1892  			JP	TRUE			; Otherwise return -1
04082D             1893  ;
04082D             1894  ; A bit lookup table
04082D             1895  ;
04082D 01 02 04 08 1896  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040831 10 20 40 80 1897  			DB	10h, 20h, 40h, 80h
040835             1898  ;
040835             1899  ; MID$ - Return sub-string.
040835             1900  ; Result is string.
040835             1901  ;
040835 CD 31 0A 04 1902  MIDS:			CALL    EXPRSC			; Get the first string expression
040839 CD C4 09 04 1903  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04083D CD 1A 03 04 1904  			CALL    EXPRI			; Get the second expression
040841 C1          1905  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040842 CD F1 09 04 1906  			CALL    POPS			; Pop the string back off the stack to the string accumulator
040846 D9          1907  			EXX
040847 7D          1908  			LD      A,L			; A: The start index
040848 D9          1909  			EXX
040849 B7          1910  			OR      A			; If the start index is 0, then we don't need to do the next bit
04084A 28 0E       1911  			JR      Z,MIDS1
04084C 3D          1912  			DEC     A
04084D 6F          1913  			LD      L,A			; L: The start index - 1
04084E 93          1914  			SUB     E			; Subtract from the string length
04084F 1E 00       1915  			LD      E,0			; Preemptively set the string length to 0
040851 30 07       1916  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040853 ED 44       1917  			NEG				; Negate the answer and
040855 4F          1918  			LD      C,A			; C: Number of bytes to copy
040856 CD 99 08 04 1919  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04085A CD 83 0A 04 1920  MIDS1:			CALL    NXT			; Skip whitespace
04085E FE 2C       1921  			CP      ','			; Check for a comma
040860 FD 23       1922  			INC     IY			; Advance to the next character in the BASIC line
040862 28 0D       1923  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040864 FD 2B       1924  			DEC     IY			; Restore the BASIC program pointer
040866 CD 42 0A 04 1925  			CALL    BRAKET			; Check for a bracket
04086A 3E 80       1926  			LD      A,80H			; String marker
04086C C9          1927  			RET
04086D             1928  ;
04086D             1929  ; LEFT$ - Return left part of string.
04086D             1930  ; Carry cleared if entire string returned.
04086D             1931  ; Result is string.
04086D             1932  ;
04086D CD 31 0A 04 1933  LEFTS:			CALL    EXPRSC			; Get the first string expression
040871 CD C4 09 04 1934  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040875 CD 1A 03 04 1935  			CALL    EXPRI			; Get the second expression
040879 C1          1936  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04087A CD F1 09 04 1937  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04087E CD 42 0A 04 1938  			CALL    BRAKET			; Check for closing bracket
040882 D9          1939  			EXX
040883 7D          1940  			LD      A,L			; L: The second parameter
040884 D9          1941  			EXX
040885 BB          1942  			CP      E			; Compare with the string length
040886 30 02       1943  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
040888 6B          1944  			LD      L,E             	; For RIGHTS, no effect in LEFTS
040889 5F          1945  LEFT2:			LD      E,A			; E: The new length of string
04088A 3E 80       1946  LEFT3:			LD      A,80H           	; String marker
04088C C9          1947  			RET
04088D             1948  ;
04088D             1949  ; RIGHT$ - Return right part of string.
04088D             1950  ; Result is string.
04088D             1951  ;
04088D CD 6D 08 04 1952  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040891 D0          1953  			RET     NC			; Do nothing if the second parameter is >= string length
040892 1C          1954  			INC     E			; Check for a zero length string
040893 1D          1955  			DEC     E
040894 C8          1956  			RET     Z			; Yes, so do nothing
040895 4B          1957  			LD      C,E			;  C: Number of bytes to copy
040896 7D          1958  			LD      A,L
040897 93          1959  			SUB     E
040898 6F          1960  			LD      L,A			;  L: Index into the string
040899 79          1961  RIGHT1:			LD	A,C
04089A 01 00 00 00 1962  			LD	BC,0
04089E 4F          1963  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04089F 7D          1964  			LD	A,L
0408A0 21 00 4A 04 1965  			LD	HL,ACCS
0408A4 6F          1966  			LD	L,A			; HL: Source (in ACCS)
0408A5 11 00 4A 04 1967  			LD      DE,ACCS			; DE: Destination (start of ACCS)
0408A9 ED B0       1968  			LDIR                    	; Copy
0408AB 3E 80       1969  			LD      A,80H			; String marker
0408AD C9          1970  			RET
0408AE             1971  ;
0408AE             1972  ; STRINGS - Return n concatenations of a string.
0408AE             1973  ; Result is string.
0408AE             1974  ;
0408AE CD 1A 03 04 1975  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408B2 CD 35 0A 04 1976  			CALL    COMMA			; Check for comma
0408B6 D9          1977  			EXX
0408B7 7D          1978  			LD      A,L			; L: Number of iterations of string
0408B8 D9          1979  			EXX
0408B9 F5          1980  			PUSH    AF
0408BA CD 25 03 04 1981  			CALL    EXPRS			; Get the string
0408BE CD 42 0A 04 1982  			CALL    BRAKET			; Check for closing bracket
0408C2 F1          1983  			POP     AF			; A: Number of iterations of string
0408C3 B7          1984  			OR      A			; Set flags
0408C4 28 C3       1985  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408C6 3D          1986  			DEC     A
0408C7 4F          1987  			LD      C,A			; C: Loop counter
0408C8 3E 80       1988  			LD      A,80H			; String marker
0408CA C8          1989  			RET     Z
0408CB 1C          1990  			INC     E			; Check for empty string
0408CC 1D          1991  			DEC     E
0408CD C8          1992  			RET     Z              		; And return
0408CE 43          1993  			LD      B,E			; B: String length tally
0408CF 21 00 4A 04 1994  			LD	HL,ACCS
0408D3 C5          1995  STRIN1:			PUSH    BC
0408D4 7E          1996  STRIN2:			LD      A,(HL)
0408D5 23          1997  			INC     HL
0408D6 12          1998  			LD      (DE),A
0408D7 1C          1999  			INC     E
0408D8 3E 13       2000  			LD      A,19
0408DA CA C1 37 04 2001  			JP      Z,ERROR_         	; Throw a "String too long" error
0408DE 10 F4       2002  			DJNZ    STRIN2
0408E0 C1          2003  			POP     BC
0408E1 0D          2004  			DEC     C
0408E2 20 EF       2005  			JR      NZ,STRIN1
0408E4 3E 80       2006  			LD      A,80H
0408E6 C9          2007  			RET
0408E7             2008  ;
0408E7             2009  ;SUBROUTINES
0408E7             2010  ;
0408E7             2011  ;SWAP - Swap arguments
0408E7             2012  ;Exchanges DE,HL D'E',H'L' and B,C
0408E7             2013  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408E7             2014  ;
0408E7 79          2015  SWAP:			LD      A,C
0408E8 48          2016  			LD      C,B
0408E9 47          2017  			LD      B,A
0408EA EB          2018  			EX      DE,HL
0408EB D9          2019  			EXX
0408EC EB          2020  			EX      DE,HL
0408ED D9          2021  			EXX
0408EE C9          2022  			RET
0408EF             2023  ;
0408EF             2024  ;TEST - Test HLH'L' for zero
0408EF             2025  ;Outputs: Z-flag set & A=0 if zero
0408EF             2026  ;Destroys: A,F
0408EF             2027  ;
0408EF 7C          2028  TEST:			LD      A,H
0408F0 B5          2029  			OR      L
0408F1 D9          2030  			EXX
0408F2 B4          2031  			OR      H
0408F3 B5          2032  			OR      L
0408F4 D9          2033  			EXX
0408F5 C9          2034  			RET
0408F6             2035  ;
0408F6             2036  ;DECODE - Decode line number in pseudo-binary.
0408F6             2037  ;   Inputs: IY = Text pointer.
0408F6             2038  ;   Outputs: HL=0, H'L'=line number, C=0.
0408F6             2039  ;   Destroys: A,C,H,L,H',L',IY,F
0408F6             2040  ;
0408F6 D9          2041  DECODE:			EXX
0408F7 21 00 00 00 2042  			LD	HL, 0
0408FB FD 7E 00    2043  			LD      A,(IY)
0408FE FD 23       2044  			INC     IY
040900 17          2045  			RLA
040901 17          2046  			RLA
040902 67          2047  			LD      H,A
040903 E6 C0       2048  			AND     0C0H
040905 FD AE 00    2049  			XOR     (IY)
040908 FD 23       2050  			INC     IY
04090A 6F          2051  			LD      L,A
04090B 7C          2052  			LD      A,H
04090C 17          2053  			RLA
04090D 17          2054  			RLA
04090E E6 C0       2055  			AND     0C0H
040910 FD AE 00    2056  			XOR     (IY)
040913 FD 23       2057  			INC     IY
040915 67          2058  			LD      H,A
040916 D9          2059  			EXX
040917             2060  ;			XOR     A
040917             2061  ;			LD      C,A
040917             2062  ;			LD      H,A
040917             2063  ;			LD      L,A
040917 21 00 00 00 2064  			LD	HL, 0
04091B 4D          2065  			LD	C, L
04091C C9          2066  			RET
04091D             2067  ;
04091D             2068  ;HEXSTR - convert numeric value to HEX string.
04091D             2069  ;   Inputs: HLH'L'C = integer or floating-point number
04091D             2070  ;  Outputs: String in string accumulator.
04091D             2071  ;           E = string length.  D = ACCS/256
04091D             2072  ;
04091D FD 23       2073  HEXSTS:			INC     IY              ;SKIP TILDE
04091F CD 2D 03 04 2074  			CALL    ITEMN
040923 CD 2A 09 04 2075  			CALL    HEXSTR
040927 3E 80       2076  			LD      A,80H
040929 C9          2077  			RET
04092A             2078  ;
04092A CD 72 06 04 2079  HEXSTR:			CALL    SFIX
04092E 01 08 00 00 2080  			LD      BC,8
040932 11 00 4A 04 2081  			LD      DE,ACCS
040936 C5          2082  HEXST1:			PUSH    BC
040937 06 04       2083  			LD      B,4
040939 AF          2084  			XOR     A
04093A D9          2085  HEXST2:			EXX
04093B 52 29       2086  			ADD.S	HL,HL
04093D D9          2087  			EXX
04093E 52 ED 6A    2088  			ADC.S	HL,HL
040941 17          2089  			RLA
040942 10 F6       2090  			DJNZ    HEXST2
040944 C1          2091  			POP     BC
040945 0D          2092  			DEC     C
040946 F8          2093  			RET     M
040947 28 06       2094  			JR      Z,HEXST3
040949 B7          2095  			OR      A
04094A 20 03       2096  			JR      NZ,HEXST3
04094C B8          2097  			CP      B
04094D 28 E7       2098  			JR      Z,HEXST1
04094F C6 90       2099  HEXST3:			ADD     A,90H
040951 27          2100  			DAA
040952 CE 40       2101  			ADC     A,40H
040954 27          2102  			DAA
040955 12          2103  			LD      (DE),A
040956 13          2104  			INC     DE
040957 47          2105  			LD      B,A
040958 18 DC       2106  			JR      HEXST1
04095A             2107  ;
04095A             2108  ;Function STR - convert numeric value to ASCII string.
04095A             2109  ;   Inputs: HLH'L'C = integer or floating-point number.
04095A             2110  ;  Outputs: String in string accumulator.
04095A             2111  ;           E = length, D = ACCS/256
04095A             2112  ;           A = 80H (type=string)
04095A             2113  ;
04095A             2114  ;First normalise for decimal output:
04095A             2115  ;
04095A CD 83 0A 04 2116  STRS:			CALL    NXT
04095E FE 7E       2117  			CP      '~'
040960 28 BB       2118  			JR      Z,HEXSTS
040962 CD 2D 03 04 2119  			CALL    ITEMN
040966 DD 21 00 4C 2120  			LD      IX,STAVAR
       04          
04096B DD 7E 03    2121  			LD      A,(IX+3)
04096E B7          2122  			OR      A
04096F DD 21 9C 09 2123  			LD      IX,G9-1         ;G9 FORMAT
       04          
040974 28 05       2124  			JR      Z,STR0
040976 DD 21 00 4C 2125  STR:			LD      IX,STAVAR
       04          
04097B 11 00 4A 04 2126  STR0:			LD      DE,ACCS
04097F 3E 25       2127  			LD      A,37
040981 CD AD 20 04 2128  			CALL    FPP
040985 DA C1 37 04 2129  			JP      C,ERROR_
040989 DD CB 02 46 2130  			BIT     0,(IX+2)
04098D 3E 80       2131  STR1:			LD      A,80H           ;STRING MARKER
04098F C8          2132  			RET     Z
040990 79          2133  			LD      A,C
040991 C6 04       2134  			ADD     A,4
040993 BB          2135  STR2:			CP      E
040994 28 F7       2136  			JR      Z,STR1
040996 EB          2137  			EX      DE,HL
040997 36 20       2138  			LD      (HL),' '        ;TRAILING SPACE
040999 23          2139  			INC     HL
04099A EB          2140  			EX      DE,HL
04099B 18 F6       2141  			JR      STR2
04099D             2142  ;
04099D 09 00       2143  G9:			DW    9
04099F             2144  ;
04099F             2145  ;STRING COMPARE
04099F             2146  ;Compare string (DE) length B with string (HL) length C.
04099F             2147  ;Result preset to false.
04099F             2148  ;
04099F CD AD 09 04 2149  SCP:			CALL	SCP0
0409A3             2150  ;
0409A3 3E 00       2151  ZERO:			LD      A,0
0409A5 D9          2152  			EXX
0409A6 67          2153  			LD      H,A
0409A7 6F          2154  			LD      L,A
0409A8 D9          2155  			EXX
0409A9 67          2156  			LD      H,A
0409AA 6F          2157  			LD      L,A
0409AB 4F          2158  			LD      C,A
0409AC C9          2159  			RET
0409AD             2160  ;
0409AD 04          2161  SCP0:			INC     B
0409AE 0C          2162  			INC     C
0409AF 05          2163  SCP1:			DEC     B
0409B0 28 0A       2164  			JR      Z,SCP2
0409B2 0D          2165  			DEC     C
0409B3 28 0C       2166  			JR      Z,SCP3
0409B5 1A          2167  			LD      A,(DE)
0409B6 BE          2168  			CP      (HL)
0409B7 C0          2169  			RET     NZ
0409B8 13          2170  			INC     DE
0409B9 23          2171  			INC     HL
0409BA 18 F3       2172  			JR      SCP1
0409BC B7          2173  SCP2:			OR      A
0409BD 0D          2174  			DEC     C
0409BE C8          2175  			RET     Z
0409BF 37          2176  			SCF
0409C0 C9          2177  			RET
0409C1 B7          2178  SCP3:			OR      A
0409C2 0C          2179  			INC     C
0409C3 C9          2180  			RET
0409C4             2181  ;
0409C4             2182  ; PUSHS - SAVE STRING ON STACK.
0409C4             2183  ;     Inputs: String in string accumulator.
0409C4             2184  ;             E = string length.
0409C4             2185  ;             A - saved on stack.
0409C4             2186  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409C4             2187  ;
0409C4 CD 8C 16 04 2188  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409C8 DD E1       2189  			POP     IX              	; IX: Return address
0409CA B7          2190  			OR      A               	; Clear the carry flag
0409CB 01 00 00 00 2191  			LD	BC,0			; BC: Length of the string
0409CF 4B          2192  			LD	C,E
0409D0 21 00 4A 04 2193  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409D4 11 00 4A 04 2194  			LD	DE,ACCS
0409D8 59          2195  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409D9 ED 52       2196  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409DB 39          2197  			ADD     HL,SP			; Grow the stack
0409DC F9          2198  			LD      SP,HL
0409DD 57          2199  			LD      D,A			;  D: This needs to be set to A for some functions
0409DE 47          2200  			LD	B,A			; Stack A and C (the string length)
0409DF C5          2201  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409E0 06 00       2202  			LD	B,0			; Reset B to 0 for the LDIR in this function
0409E2 28 0B       2203  			JR      Z,PUSHS1        	; Is it zero length?
0409E4 11 00 4A 04 2204  			LD      DE,ACCS			; DE: Destination
0409E8 EB          2205  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409E9 ED B0       2206  			LDIR	                    	; Copy to stack
0409EB CD 8C 16 04 2207  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409EF DD E9       2208  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F1             2209  ;
0409F1             2210  ; POPS - RESTORE STRING FROM STACK.
0409F1             2211  ;     Inputs: C = string length.
0409F1             2212  ;    Outputs: String in string accumulator.
0409F1             2213  ;             E = string length.
0409F1             2214  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409F1             2215  ;
0409F1 DD E1       2216  POPS:			POP     IX              	; IX: Return address
0409F3 69          2217  			LD	L,C			; Temporarily store string length in L
0409F4 01 00 00 00 2218  			LD	BC,0
0409F8 4D          2219  			LD	C,L			; BC: Number of bytes to copy
0409F9 21 00 00 00 2220  			LD      HL,0			; HL: 0
0409FD 39          2221  			ADD     HL,SP			; HL: Stack address
0409FE 11 00 4A 04 2222  			LD      DE,ACCS			; DE: Destination
040A02 0C          2223  			INC     C			; Quick check to see if this is a zero length string
040A03 0D          2224  			DEC     C
040A04 28 02       2225  			JR      Z,POPS1         	; Yes it is, so skip
040A06 ED B0       2226  			LDIR                    	; No, so copy from the stack
040A08 F9          2227  POPS1:			LD      SP,HL			; Shrink the stack
040A09 DD E9       2228  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
040A0B             2229  ;
040A0B FD 7E 00    2230  HEXDIG:			LD      A,(IY)
040A0E FE 30       2231  			CP      '0'
040A10 D8          2232  			RET     C
040A11 FE 3A       2233  			CP      '9'+1
040A13 3F          2234  			CCF
040A14 D0          2235  			RET     NC
040A15 FE 41       2236  			CP      'A'
040A17 D8          2237  			RET     C
040A18 D6 37       2238  			SUB     'A'-10
040A1A FE 10       2239  			CP      16
040A1C 3F          2240  			CCF
040A1D C9          2241  			RET
040A1E             2242  ;
040A1E FD 7E 00    2243  BINDIG:			LD	A,(IY)
040A21 FE 30       2244  			CP	'0'
040A23 D8          2245  			RET	C
040A24 FE 32       2246  			CP	'1'+1
040A26 3F          2247  			CCF
040A27 C9          2248  			RET
040A28             2249  ;
040A28 FE 3E       2250  RELOP?:			CP      '>'
040A2A D0          2251  			RET     NC
040A2B FE 3D       2252  			CP      '='
040A2D D0          2253  			RET     NC
040A2E FE 3C       2254  			CP      '<'
040A30 C9          2255  			RET
040A31             2256  ;
040A31 CD 25 03 04 2257  EXPRSC:			CALL    EXPRS
040A35 CD 83 0A 04 2258  COMMA:			CALL    NXT
040A39 FD 23       2259  			INC     IY
040A3B FE 2C       2260  			CP      ','
040A3D C8          2261  			RET     Z
040A3E 3E 05       2262  			LD      A,5
040A40 18 0B       2263  			JR      ERROR1_EV          ;"Missing ,"
040A42             2264  ;
040A42 CD 83 0A 04 2265  BRAKET:			CALL    NXT
040A46 FD 23       2266  			INC     IY
040A48 FE 29       2267  			CP      ')'
040A4A C8          2268  			RET     Z
040A4B 3E 1B       2269  			LD      A,27
040A4D C3 C1 37 04 2270  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A51             2271  ;
040A51 FD 23       2272  SAVE_EV:			INC     IY
040A53 08          2273  SAVE1:			EX      AF,AF'
040A54 FA 46 03 04 2274  			JP      M,TYPE_EV_
040A58 08          2275  			EX      AF,AF'
040A59 E3          2276  			EX      (SP),HL
040A5A D9          2277  			EXX
040A5B E5          2278  			PUSH    HL
040A5C D9          2279  			EXX
040A5D F5          2280  			PUSH    AF
040A5E C5          2281  			PUSH    BC
040A5F E9          2282  			JP      (HL)
040A60             2283  ;
040A60 08          2284  DOIT:			EX      AF,AF'
040A61 FA 46 03 04 2285  			JP      M,TYPE_EV_
040A65 D9          2286  			EXX
040A66 C1          2287  			POP     BC              ;RETURN ADDRESS
040A67 D9          2288  			EXX
040A68 79          2289  			LD      A,C
040A69 C1          2290  			POP     BC
040A6A 47          2291  			LD      B,A
040A6B F1          2292  			POP     AF              ;OPERATOR
040A6C D9          2293  			EXX
040A6D EB          2294  			EX      DE,HL
040A6E E1          2295  			POP     HL
040A6F D9          2296  			EXX
040A70 EB          2297  			EX      DE,HL
040A71 E1          2298  			POP     HL
040A72 D9          2299  			EXX
040A73 C5          2300  			PUSH    BC
040A74 D9          2301  			EXX
040A75 E6 0F       2302  			AND     0FH
040A77 CD AD 20 04 2303  			CALL    FPP
040A7B 38 D0       2304  			JR      C,ERROR1_EV
040A7D AF          2305  			XOR     A
040A7E 08          2306  			EX      AF,AF'          ;TYPE
040A7F FD 7E 00    2307  			LD      A,(IY)
040A82 C9          2308  			RET
040A83             2309  ;
040A83             2310  ; Skip spaces
040A83             2311  ; - IY: String pointer
040A83             2312  ; Returns:
040A83             2313  ;  - A: The non-space character found
040A83             2314  ; - IY: Points to the character before that
040A83             2315  ;
040A83 FD 7E 00    2316  NXT:			LD      A,(IY)			; Fetch the character
040A86 FE 20       2317  			CP      ' '			; If it is space, then return
040A88 C0          2318  			RET     NZ
040A89 FD 23       2319  			INC     IY			; Increment the pointer and
040A8B C3 83 0A 04 2320  			JP      NXT			; Loop
040A8F             2321  ;
040A8F E5          2322  DISPT2:			PUSH    HL
040A90 21 C0 01 04 2323  			LD      HL,SOPTBL
040A94 18 07       2324  			JR      DISPT0
040A96             2325  ;
040A96 E5          2326  DISPAT:			PUSH    HL
040A97 D6 8D       2327  			SUB     FUNTOK
040A99 21 15 01 04 2328  			LD      HL,FUNTBL
040A9D C5          2329  DISPT0:			PUSH    BC
040A9E             2330  
040A9E 01 03 00 00 2331  			LD	BC, 3
040AA2 47          2332  			LD	B, A
040AA3 ED 4C       2333  			MLT	BC
040AA5 09          2334  			ADD	HL, BC
040AA6 ED 27       2335  			LD	HL, (HL)
040AA8             2336  
040AA8             2337  ;			ADD     A,A
040AA8             2338  ;			LD      C,A
040AA8             2339  ;			LD      B,0
040AA8             2340  ;			ADD     HL,BC
040AA8             2341  ;			LD      A,(HL)
040AA8             2342  ;			INC     HL
040AA8             2343  ;			LD      H,(HL)
040AA8             2344  ;			LD      L,A
040AA8             2345  
040AA8 C1          2346  			POP     BC
040AA9 E3          2347  			EX      (SP),HL
040AAA C9          2348  			RET                     ;OFF TO ROUTINE
040AAB             2349  
040AAB             2350  ; --- End eval.asm ---
040AAB             2351  
040AAB             2352  ; --- Begin exec.asm ---
040AAB             2353  ;
040AAB             2354  ; Title:	BBC Basic Interpreter - Z80 version
040AAB             2355  ;		Statement Execution & Assembler Module - "EXEC"
040AAB             2356  ; Author:	(C) Copyright  R.T.Russell  1984
040AAB             2357  ; Modified By:	Dean Belfield
040AAB             2358  ; Created:	12/05/2023
040AAB             2359  ; Last Updated:	26/06/2023
040AAB             2360  ;
040AAB             2361  ; Modinfo:
040AAB             2362  ; 27/01/1984:	Version 2.1
040AAB             2363  ; 02/03/1987:	Version 3.0
040AAB             2364  ; 11/06/1987:	Version 3.1
040AAB             2365  ; 12/05/2023:	Modified by Dean Belfield
040AAB             2366  ; 07/06/2023:	Modified to run in ADL mode
040AAB             2367  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040AAB             2368  
040AAB             2369  			; .ASSUME	ADL = 1
040AAB             2370  
040AAB             2371  			; INCLUDE	"equs.inc"
040AAB             2372  
040AAB             2373  			; SEGMENT CODE
040AAB             2374  
040AAB             2375  			; XDEF	XEQ
040AAB             2376  			; XDEF	CHAIN0
040AAB             2377  			; XDEF	RUN
040AAB             2378  			; XDEF	SYNTAX
040AAB             2379  			; XDEF	ESCAPE
040AAB             2380  			; XDEF	FN_EX
040AAB             2381  			; XDEF	USR
040AAB             2382  			; XDEF	STORE5
040AAB             2383  			; XDEF	STORE4
040AAB             2384  			; XDEF	CHECK
040AAB             2385  			; XDEF	TERMQ
040AAB             2386  			; XDEF	FILL
040AAB             2387  			; XDEF	X4OR5
040AAB             2388  			; XDEF	MUL16
040AAB             2389  			; XDEF	CHANEL
040AAB             2390  			; XDEF	ASSEM
040AAB             2391  
040AAB             2392  			; XREF	AUTO
040AAB             2393  			; XREF	DELETE
040AAB             2394  			; XREF	LOAD
040AAB             2395  			; XREF	LIST_
040AAB             2396  			; XREF	NEW
040AAB             2397  			; XREF	OLD
040AAB             2398  			; XREF	RENUM
040AAB             2399  			; XREF	SAVE
040AAB             2400  			; XREF	SOUND
040AAB             2401  			; XREF	CLG
040AAB             2402  			; XREF	DRAW
040AAB             2403  			; XREF	ENVEL
040AAB             2404  			; XREF	GCOL
040AAB             2405  			; XREF	MODE
040AAB             2406  			; XREF	MOVE
040AAB             2407  			; XREF	PLOT
040AAB             2408  			; XREF	COLOUR
040AAB             2409  			; XREF	EXPRS
040AAB             2410  			; XREF	HIMEM
040AAB             2411  			; XREF	LOAD0
040AAB             2412  			; XREF	RANDOM
040AAB             2413  			; XREF	CLEAR
040AAB             2414  			; XREF	ERRTRP
040AAB             2415  			; XREF	PAGE_
040AAB             2416  			; XREF	DATAPTR
040AAB             2417  			; XREF	ERRLIN
040AAB             2418  			; XREF	TRAP
040AAB             2419  			; XREF	NXT
040AAB             2420  			; XREF	SETLIN
040AAB             2421  			; XREF	CLOOP
040AAB             2422  			; XREF	OSSHUT
040AAB             2423  			; XREF	WARM
040AAB             2424  			; XREF	TRACEN
040AAB             2425  			; XREF	OUTCHR
040AAB             2426  			; XREF	PBCDL
040AAB             2427  			; XREF	OSCLI
040AAB             2428  			; XREF	LISTON
040AAB             2429  			; XREF	GETVAR
040AAB             2430  			; XREF	PUTVAR
040AAB             2431  			; XREF	DATPTR
040AAB             2432  			; XREF	ERROR_
040AAB             2433  			; XREF	EXPR
040AAB             2434  			; XREF	CREATE
040AAB             2435  			; XREF	EXPRI
040AAB             2436  			; XREF	BRAKET
040AAB             2437  			; XREF	FREE
040AAB             2438  			; XREF	OSBPUT
040AAB             2439  			; XREF	COUNT
040AAB             2440  			; XREF	STR
040AAB             2441  			; XREF	HEXSTR
040AAB             2442  			; XREF	CRLF
040AAB             2443  			; XREF	ITEMI
040AAB             2444  			; XREF	FINDL
040AAB             2445  			; XREF	TEST
040AAB             2446  			; XREF	EXPRN
040AAB             2447  			; XREF	DLOAD5
040AAB             2448  			; XREF	DLOAD5_SPL
040AAB             2449  			; XREF	LOADN
040AAB             2450  			; XREF	FPP
040AAB             2451  			; XREF	SWAP
040AAB             2452  			; XREF	GETDEF
040AAB             2453  			; XREF	ZERO
040AAB             2454  			; XREF	OSBGET
040AAB             2455  			; XREF	BUFFER
040AAB             2456  			; XREF	CONS
040AAB             2457  			; XREF	VAL0
040AAB             2458  			; XREF	OSLINE
040AAB             2459  			; XREF	CLRSCN
040AAB             2460  			; XREF	TELL
040AAB             2461  			; XREF	SAYLN
040AAB             2462  			; XREF	REPORT
040AAB             2463  			; XREF	PUTPTR
040AAB             2464  			; XREF	PUTIME
040AAB             2465  			; XREF	PUTIMS
040AAB             2466  			; XREF	LOMEM
040AAB             2467  			; XREF	WIDTH
040AAB             2468  			; XREF	OSWRCH
040AAB             2469  			; XREF	COMMA
040AAB             2470  			; XREF	OSCALL
040AAB             2471  			; XREF	SFIX
040AAB             2472  			; XREF	LOAD4
040AAB             2473  			; XREF	PUSHS
040AAB             2474  			; XREF	POPS
040AAB             2475  			; XREF	LOADS
040AAB             2476  			; XREF	PUTCSR
040AAB             2477  			; XREF	OUT_
040AAB             2478  			; XREF	R0
040AAB             2479  ;
040AAB             2480  ; List of token values used in this module
040AAB             2481  ; consolidated with the token values in main.asm
040AAB             2482  ; TAND:			EQU     80H
040AAB             2483  ; TOR:			EQU     84H
040AAB             2484  ; TERROR:			EQU     85H
040AAB             2485  ; LINE_:			EQU     86H
040AAB             2486  ; OFF_:			EQU     87H
040AAB             2487  ; STEP:			EQU     88H
040AAB             2488  ; SPC:			EQU     89H
040AAB             2489  ; TAB:			EQU     8AH
040AAB             2490  ; ELSE_:			EQU     8BH
040AAB             2491  ; THEN:			EQU     8CH
040AAB             2492  ; LINO:			EQU     8DH
040AAB             2493  ; TO:				EQU     B8H
040AAB             2494  ; TCALL:			EQU     D6H
040AAB             2495  ; DATA_:			EQU     DCH
040AAB             2496  ; DEF_:			EQU     DDH
040AAB             2497  ; TGOSUB:			EQU     E4H
040AAB             2498  ; TGOTO:			EQU     E5H
040AAB             2499  ; TON:			EQU     EEH
040AAB             2500  ; TPROC:			EQU     F2H
040AAB             2501  ; TSTOP:			EQU     FAH
040AAB             2502  
040AAB             2503  ; TCMD:			EQU     C6H ; in eval.asm
040AAB             2504  
040AAB             2505  ; The command table
040AAB             2506  ; Commands are tokens from C6H onwards; this lookup table is used to
040AAB             2507  ; run the corresponding function; Note that DATA and DEF both use the same
040AAB             2508  ; code as REM
040AAB             2509  ;
040AAB 4A 37 04    2510  CMDTAB:			DW24  AUTO			; C6H
040AAE AD 35 04    2511  			DW24  DELETE			; C7H
040AB1 8B 37 04    2512  			DW24  LOAD			; C8H
040AB4 E8 35 04    2513  			DW24  LIST_			; C9H
040AB7 68 37 04    2514  			DW24  NEW			; CAH
040ABA 6E 37 04    2515  			DW24  OLD			; CBH
040ABD 77 36 04    2516  			DW24  RENUM			; CCH
040AC0 9C 37 04    2517  			DW24  SAVE			; CDH
040AC3 E5 15 04    2518  			DW24  PUT			; CEH
040AC6 DB 13 04    2519  			DW24  PTR_EX			; CFH
040AC9 F5 13 04    2520  			DW24  PAGEV_EX			; D0H
040ACC 08 14 04    2521  			DW24  TIMEV_EX			; D1H
040ACF 31 14 04    2522  			DW24  LOMEMV_EX			; D2H
040AD2 4A 14 04    2523  			DW24  HIMEMV_EX			; D3H
040AD5 8D 46 04    2524  			DW24  SOUND			; D4H
040AD8 FF 14 04    2525  			DW24  BPUT			; D5H
040ADB 17 15 04    2526  			DW24  CALL_			; D6H
040ADE 5F 0B 04    2527  			DW24  CHAIN			; D7H
040AE1 AA 13 04    2528  			DW24  CLR			; D8H
040AE4 F3 14 04    2529  			DW24  CLOSE			; D9H
040AE7 29 44 04    2530  			DW24  CLG			; DAH
040AEA 7D 13 04    2531  			DW24  CLS			; DBH
040AED 3E 0C 04    2532  			DW24  REM_EX             		; DCH: DATA
040AF0 3E 0C 04    2533  			DW24  REM_EX             		; DDH: DEF
040AF3 04 0D 04    2534  			DW24  DIM_EX			; DEH
040AF6 53 46 04    2535  			DW24  DRAW			; DFH
040AF9 D9 0B 04    2536  			DW24  END_			; E0H
040AFC 95 11 04    2537  			DW24  ENDPRO			; E1H
040AFF 0A 01 04    2538  			DW24  ENVEL			; E2H
040B02 AA 0F 04    2539  			DW24  FOR_EX			; E3H
040B05 5A 0F 04    2540  			DW24  GOSUB_EX			; E4H
040B08 3E 0F 04    2541  			DW24  GOTO_EX			; E5H
040B0B E7 45 04    2542  			DW24  GCOL			; E6H
040B0E 49 13 04    2543  			DW24  IF_			; E7H
040B11 37 12 04    2544  			DW24  INPUT			; E8H
040B14 5F 0C 04    2545  			DW24  LET			; E9H
040B17 3A 11 04    2546  			DW24  LOCAL_EX_			; EAH
040B1A 39 44 04    2547  			DW24  MODE			; EBH
040B1D 4B 46 04    2548  			DW24  MOVE			; ECH
040B20 F8 0F 04    2549  			DW24  NEXT_EX			; EDH
040B23 D1 0E 04    2550  			DW24  ON_EX_			; EEH
040B26 B4 14 04    2551  			DW24  VDU			; EFH
040B29 19 46 04    2552  			DW24  PLOT			; F0H
040B2C DA 0D 04    2553  			DW24  PRINT_			; F1H
040B2F 97 10 04    2554  			DW24  PROC_EX			; F2H
040B32 E9 12 04    2555  			DW24  READ			; F3H
040B35 3E 0C 04    2556  			DW24  REM_EX			; F4H
040B38 7A 0F 04    2557  			DW24  REPEAT_EX			; F5H
040B3B A2 13 04    2558  			DW24  REPOR			; F6H
040B3E B4 13 04    2559  			DW24  RESTOR_EX			; F7H
040B41 68 0F 04    2560  			DW24  RETURN			; F8H
040B44 59 0B 04    2561  			DW24  RUN			; F9H
040B47 8A 13 04    2562  			DW24  STOP			; FAH
040B4A 35 45 04    2563  			DW24  COLOUR			; FBH
040B4D 96 14 04    2564  			DW24  TRACE_EX			; FCH
040B50 84 0F 04    2565  			DW24  UNTIL_EX			; FDH
040B53 88 14 04    2566  			DW24  WIDTHV			; FEH
040B56 24 0C 04    2567  			DW24  CLI             		; FFH: OSCLI
040B59             2568  
040B59             2569  ; RUN
040B59             2570  ; RUN "filename"
040B59             2571  ;
040B59 CD B7 17 04 2572  RUN:			CALL    TERMQ			; Standalone RUN command?
040B5D 28 10       2573  			JR      Z,RUN0			; Yes, so just RUN the code
040B5F             2574  
040B5F             2575  ; CHAIN "filename"
040B5F             2576  ;
040B5F CD 25 03 04 2577  CHAIN:			CALL    EXPRS			; Get the filename
040B63 3E 0D       2578  			LD      A,CR			; Terminate it with a CR
040B65 12          2579  			LD      (DE),A
040B66 ED 7B 20 4D 2580  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B6B CD 80 38 04 2581  			CALL    LOAD0			; And load the file in
040B6F             2582  ;
040B6F ED 7B 20 4D 2583  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B74 DD 21 38 4D 2584  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B79 ED 5F       2585  @@:			LD      A, R			; Use the R register to seed the random number generator
040B7B 28 FC       2586  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B7D 07          2587  			RLCA				; Rotate it
040B7E 07          2588  			RLCA
040B7F DD 77 03    2589  			LD      (IX+3),A		; And store
040B82 9F          2590  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B83 DD 77 04    2591  			LD      (IX+4),A		; And store
040B86 CD D7 38 04 2592  			CALL    CLEAR
040B8A 21 00 00 00 2593  			LD      HL,0			; Clear the error trap sysvar
040B8E 22 2C 4D 04 2594  			LD      (ERRTRP),HL
040B92 2A 14 4D 04 2595  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B96 3E DC       2596  			LD      A,DATA_			; The DATA token value
040B98 CD 8B 18 04 2597  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B9C 22 31 4D 04 2598  			LD      (DATPTR),HL     	; Set data pointer
040BA0 FD 2A 14 4D 2599  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040BA5             2600  ;
040BA5 CD ED 0B 04 2601  XEQ0:			CALL    NEWLIN
040BA9 FD 22 35 4D 2602  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040BAE CD CE 3F 04 2603  			CALL    TRAP           		; Check keyboard
040BB2 CD 83 0A 04 2604  XEQ1:			CALL    NXT
040BB6 FD 23       2605  			INC     IY
040BB8 FE 3A       2606  			CP      ':'             	; Seperator
040BBA 28 F6       2607  			JR      Z,XEQ1
040BBC FE 0D       2608  			CP      CR
040BBE 28 E5       2609  			JR      Z,XEQ0          	; New program line
040BC0 D6 C6       2610  			SUB     TCMD
040BC2 DA 4D 0C 04 2611  			JP      C,LET0          	; Implied "LET"
040BC6             2612  
040BC6 01 03 00 00 2613  			LD	BC, 3
040BCA 47          2614  			LD	B, A
040BCB ED 4C       2615  			MLT	BC
040BCD 21 AB 0A 04 2616  			LD	HL,CMDTAB
040BD1 09          2617  			ADD	HL, BC
040BD2 ED 27       2618  			LD	HL, (HL)		; Table entry
040BD4             2619  
040BD4             2620  ;			ADD     A,A
040BD4             2621  ;			LD      C,A
040BD4             2622  ;			LD      B,0
040BD4             2623  ;			LD      HL,CMDTAB
040BD4             2624  ;			ADD     HL,BC
040BD4             2625  ;			LD      A,(HL)          	; Table entry
040BD4             2626  ;			INC     HL
040BD4             2627  ;			LD      H,(HL)
040BD4             2628  ;			LD      L,A
040BD4             2629  
040BD4 CD 83 0A 04 2630  			CALL    NXT
040BD8 E9          2631  			JP      (HL)            	; Execute the statement
040BD9             2632  
040BD9             2633  ;END
040BD9             2634  ;
040BD9 CD 0F 3A 04 2635  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BDD 7C          2636  			LD      A,H
040BDE B5          2637  			OR      L               ;DIRECT?
040BDF CA E1 30 04 2638  			JP      Z,CLOOP
040BE3 1E 00       2639  			LD      E,0
040BE5 CD 9D 43 04 2640  			CALL    OSSHUT          ;CLOSE ALL FILES
040BE9 C3 E0 30 04 2641  			JP      WARM            ;"Ready"
040BED             2642  ;
040BED FD 7E 00    2643  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BF0 01 03 00 00 2644  			LD      BC,3
040BF4 FD 09       2645  			ADD     IY,BC
040BF6 B7          2646  			OR      A
040BF7 28 E0       2647  			JR      Z,END_           ;LENGTH=0, EXIT
040BF9 2A 26 4D 04 2648  			LD      HL,(TRACEN)
040BFD 7C          2649  			LD      A,H
040BFE B5          2650  			OR      L
040BFF C8          2651  			RET     Z
040C00 11 00 00 00 2652  			LD	DE, 0		;Clear DE
040C04 FD 56 FF    2653  			LD      D,(IY-1)        ;DE = LINE NUMBER
040C07 FD 5E FE    2654  			LD      E,(IY-2)
040C0A ED 52       2655  			SBC     HL,DE
040C0C D8          2656  			RET     C
040C0D EB          2657  			EX      DE,HL
040C0E 3E 5B       2658  			LD      A,'['           ;TRACE
040C10 CD B0 39 04 2659  			CALL    OUTCHR
040C14 CD 58 3A 04 2660  			CALL    PBCDL
040C18 3E 5D       2661  			LD      A,']'
040C1A CD B0 39 04 2662  			CALL    OUTCHR
040C1E 3E 20       2663  			LD      A,' '
040C20 C3 B0 39 04 2664  			JP      OUTCHR
040C24             2665  
040C24             2666  ; Routines for each statement -------------------------------------------------
040C24             2667  
040C24             2668  ; OSCLI
040C24             2669  ;
040C24 CD 25 03 04 2670  CLI:			CALL    EXPRS
040C28 3E 0D       2671  			LD      A,CR
040C2A 12          2672  			LD      (DE),A
040C2B 21 00 4A 04 2673  			LD      HL,ACCS
040C2F CD F1 3F 04 2674  			CALL    OSCLI
040C33 C3 A9 0B 04 2675  			JP      XEQ
040C37             2676  
040C37             2677  ; REM, *
040C37             2678  ;
040C37 FD E5       2679  EXT_EX:			PUSH    IY
040C39 E1          2680  			POP     HL
040C3A CD F1 3F 04 2681  			CALL    OSCLI
040C3E FD E5       2682  REM_EX:			PUSH    IY
040C40 E1          2683  			POP     HL
040C41 3E 0D       2684  			LD      A,CR
040C43 47          2685  			LD      B,A
040C44 ED B1       2686  			CPIR                    ;FIND LINE END
040C46 E5          2687  			PUSH    HL
040C47 FD E1       2688  			POP     IY
040C49 C3 A5 0B 04 2689  			JP      XEQ0
040C4D             2690  
040C4D             2691  ; [LET] var = expr
040C4D             2692  ;
040C4D FE C5       2693  LET0:			CP      ELSE_-TCMD
040C4F 28 ED       2694  			JR      Z,REM_EX
040C51             2695  			; CP      ('*'-TCMD) & 0FFH
040C51             2696  			; JR      Z,EXT_EX
040C51             2697  			; CP      ('='-TCMD) & 0FFH
040C51             2698  			; JR      Z,FNEND
040C51             2699  			; CP      ('['-TCMD) & 0FFH
040C51             2700  			; ez80asm doesn't like () in expressions
040C51 FE 64       2701  			CP      '*'-TCMD & 0FFH
040C53 28 E2       2702  			JR      Z,EXT_EX
040C55 FE 77       2703  			CP      '='-TCMD & 0FFH
040C57 28 5B       2704  			JR      Z,FNEND
040C59 FE 95       2705  			CP      '['-TCMD & 0FFH
040C5B 28 25       2706  			JR      Z,ASM
040C5D FD 2B       2707  			DEC     IY
040C5F CD FB 15 04 2708  LET:			CALL    ASSIGN			; Assign the variable
040C63 CA A9 0B 04 2709  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C67 38 41       2710  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C69             2711  ;
040C69 F5          2712  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C6A CD CD 17 04 2713  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C6E E5          2714  			PUSH    HL			; HL: Address of the variable
040C6F CD 25 03 04 2715  			CALL    EXPRS
040C73 DD E1       2716  			POP     IX			; IX: Address of the variable
040C75 F1          2717  			POP     AF			; AF: The variable type
040C76 CD 3D 16 04 2718  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C7A C3 A9 0B 04 2719  XEQR:			JP      XEQ
040C7E             2720  ;
040C7E CD ED 0B 04 2721  ASM0:			CALL    NEWLIN
040C82 FD 22 35 4D 2722  ASM:			LD      (ERRLIN),IY
       04          
040C87 CD CE 3F 04 2723  			CALL    TRAP
040C8B CD D8 18 04 2724  			CALL    ASSEM
040C8F 38 19       2725  			JR      C,SYNTAX
040C91 FE 0D       2726  			CP      CR
040C93 28 E9       2727  			JR      Z,ASM0
040C95 21 40 4D 04 2728  			LD      HL,LISTON
040C99 7E          2729  			LD      A,(HL)
040C9A E6 0F       2730  			AND     0FH
040C9C F6 B0       2731  			OR      B0H
040C9E 77          2732  			LD      (HL),A
040C9F 18 D9       2733  			JR      XEQR
040CA1             2734  ;
040CA1 CD 9B 3A 04 2735  VAR_:			CALL    GETVAR
040CA5 C8          2736  			RET     Z
040CA6 D2 8A 3A 04 2737  			JP      NC,PUTVAR
040CAA 3E 10       2738  SYNTAX:			LD      A,16            ;"Syntax error"
040CAC 18 02       2739  			JR	ERROR0_EX
040CAE 3E 11       2740  ESCAPE:			LD      A,17            ;"Escape"
040CB0 C3 C1 37 04 2741  ERROR0_EX:			JP      ERROR_
040CB4             2742  
040CB4             2743  ; =
040CB4             2744  ;
040CB4 CD D2 01 04 2745  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CB8 43          2746  			LD      B,E
040CB9 EB          2747  			EX      DE,HL
040CBA D9          2748  			EXX                     ;SAVE RESULT
040CBB EB          2749  			EX      DE,HL           ; IN DEB'C'D'E'
040CBC C1          2750  FNEND5:			POP     BC
040CBD 21 95 17 04 2751  			LD      HL,LOCCHK
040CC1 B7          2752  			OR      A
040CC2 ED 42       2753  			SBC     HL,BC
040CC4 28 1C       2754  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CC6 21 97 10 04 2755  			LD      HL,FNCHK
040CCA B7          2756  			OR      A
040CCB ED 42       2757  			SBC     HL,BC
040CCD 3E 07       2758  			LD      A,7
040CCF 20 DF       2759  			JR      NZ,ERROR0_EX       ;"No FN"
040CD1 FD E1       2760  			POP     IY
040CD3 FD 22 35 4D 2761  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CD8 EB          2762  			EX      DE,HL
040CD9 D9          2763  			EXX
040CDA EB          2764  			EX      DE,HL
040CDB 11 00 4A 04 2765  			LD      DE,ACCS
040CDF 58          2766  			LD      E,B
040CE0 08          2767  			EX      AF,AF'
040CE1 C9          2768  			RET
040CE2             2769  ;
040CE2 DD E1       2770  FNEND0:			POP     IX
040CE4 C1          2771  			POP     BC
040CE5 78          2772  			LD      A,B
040CE6 B7          2773  			OR      A
040CE7 FA F5 0C 04 2774  			JP      M,FNEND1        ;STRING
040CEB E1          2775  			POP     HL
040CEC D9          2776  			EXX
040CED E1          2777  			POP     HL
040CEE D9          2778  			EXX
040CEF CD 13 16 04 2779  			CALL    STORE
040CF3 18 C7       2780  			JR      FNEND5
040CF5 21 00 00 00 2781  FNEND1:			LD      HL,0
040CF9 39          2782  			ADD     HL,SP
040CFA D5          2783  			PUSH    DE
040CFB 59          2784  			LD      E,C
040CFC CD 41 16 04 2785  			CALL    STORES
040D00 D1          2786  			POP     DE
040D01 F9          2787  			LD      SP,HL
040D02 18 B8       2788  			JR      FNEND5
040D04             2789  
040D04             2790  ; DIM var(dim1[,dim2[,...]])[,var(...]
040D04             2791  ; DIM var expr[,var expr...]
040D04             2792  ;
040D04 CD 9B 3A 04 2793  DIM_EX:			CALL    GETVAR          	; Get the variable
040D08 DA 94 0D 04 2794  			JP      C,BADDIM		; Throw a "Bad Dim" error
040D0C CA 9E 0D 04 2795  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040D10 CD 0F 3C 04 2796  			CALL    CREATE			; Create a new entity
040D14 E5          2797  			PUSH    HL			; HL: Address of the entity
040D15 DD E1       2798  			POP     IX			; IX: Address of the entity
040D17 FD 7E 00    2799  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D1A FE 28       2800  			CP      '('			; Check for opening brackets
040D1C 7A          2801  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D1D 20 7F       2802  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D1F             2803  ;
040D1F             2804  ; At this point we're reserving a variable array
040D1F             2805  ;
040D1F E5          2806  			PUSH    HL			; HL: Address of the entity
040D20 F5          2807  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D21 11 01 00 00 2808  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D25 42          2809  			LD      B,D			;  B: The number of dimensions in the array
040D26             2810  ;
040D26 FD 23       2811  DIM1:			INC     IY			; Skip to the next token
040D28 C5          2812  			PUSH    BC			; Stack the dimension counter
040D29 D5          2813  			PUSH    DE			; Stack the total size of array accumulator
040D2A DD E5       2814  			PUSH    IX			; Stack the entity address
040D2C CD 1A 03 04 2815  			CALL    EXPRI           	; Fetch the size of this dimension
040D30 CB 7C       2816  			BIT     7,H			; If it is negative then
040D32 20 60       2817  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D34 D9          2818  			EXX
040D35 23          2819  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D36 DD E1       2820  			POP     IX			; IX: The entity address
040D38 DD 23       2821  			INC     IX
040D3A DD 75 00    2822  			LD      (IX),L          	; Save the size of this dimension in the entity
040D3D DD 23       2823  			INC     IX
040D3F DD 74 00    2824  			LD      (IX),H
040D42 C1          2825  			POP     BC
040D43 CD AF 18 04 2826  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D47 38 4F       2827  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D49 EB          2828  			EX      DE,HL           	; DE: The new total size of array accumulator
040D4A C1          2829  			POP     BC
040D4B 04          2830  			INC     B               	;  B: The dimension counter; increment
040D4C FD 7E 00    2831  			LD      A,(IY)			; Fetch the nex token
040D4F FE 2C       2832  			CP      ','             	; Check for another dimension in the array
040D51 28 D3       2833  			JR      Z,DIM1			; And loop
040D53             2834  ;
040D53 CD 42 0A 04 2835  			CALL    BRAKET          	; Check for closing bracket
040D57 F1          2836  			POP     AF              	; Restore the type
040D58 DD 23       2837  			INC     IX
040D5A DD E3       2838  			EX      (SP),IX
040D5C DD 70 00    2839  			LD      (IX),B          	; Number of dimensions
040D5F CD A2 18 04 2840  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D63 E1          2841  			POP     HL			; Restore the entity address
040D64 38 32       2842  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D66             2843  ;
040D66             2844  ; We now allocate the memory for the array
040D66             2845  ;
040D66 19          2846  DIM3:			ADD     HL,DE
040D67 38 2F       2847  			JR      C,NOROOM
040D69 E5          2848  			PUSH    HL
040D6A 24          2849  			INC     H
040D6B 28 2B       2850  			JR      Z,NOROOM
040D6D ED 72       2851  			SBC     HL,SP
040D6F 30 27       2852  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D71 E1          2853  			POP     HL
040D72 22 1D 4D 04 2854  			LD      (FREE),HL
040D76 7A          2855  DIM2:			LD      A,D
040D77 B3          2856  			OR      E
040D78 28 06       2857  			JR      Z,DIM5
040D7A 2B          2858  			DEC     HL
040D7B 36 00       2859  			LD      (HL),0         		; Initialise the array
040D7D 1B          2860  			DEC     DE
040D7E 18 F6       2861  			JR      DIM2
040D80 CD 83 0A 04 2862  DIM5:			CALL    NXT
040D84 FE 2C       2863  			CP      ','            		; Another variable?
040D86 C2 A9 0B 04 2864  			JP      NZ,XEQ
040D8A FD 23       2865  			INC     IY
040D8C CD 83 0A 04 2866  			CALL    NXT
040D90 C3 04 0D 04 2867  			JP      DIM_EX
040D94             2868  ;
040D94             2869  ; DIM errors
040D94             2870  ;
040D94 3E 0A       2871  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D96 18 02       2872  			JR	ERROR1_EX
040D98 3E 0B       2873  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D9A C3 C1 37 04 2874  ERROR1_EX:			JP      ERROR_
040D9E             2875  ;
040D9E             2876  ; At this point we're reserving a block of memory, i.e.
040D9E             2877  ; DIM var expr[,var expr...]
040D9E             2878  ;
040D9E B7          2879  DIM4:			OR      A			;  A: The dimension variable type
040D9F 28 F3       2880  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040DA1 FA 94 0D 04 2881  			JP      M,BADDIM        	; or a string
040DA5 47          2882  			LD      B,A			; Temporarily store the dimension variable type in B
040DA6 FD 7E FF    2883  			LD      A,(IY-1)		; Get the last character but one
040DA9 FE 29       2884  			CP      ')'			; Check if it is a trailing bracket
040DAB 28 E7       2885  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040DAD             2886  ;
040DAD 21 00 00 00 2887  			LD	HL,0			; Clear HL
040DB1 3A 1D 4D 04 2888  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DB5 6F          2889  			LD	L,A
040DB6 3A 1E 4D 04 2890  			LD	A,(FREE+1)
040DBA 67          2891  			LD	H,A
040DBB 78          2892  			LD	A,B			; Restore the dimension variable type
040DBC D9          2893  			EXX
040DBD 21 00 00 00 2894  			LD	HL,0			; Clear HL
040DC1 47          2895  			LD	B,A			; Temporarily store the dimension variable type in B
040DC2 3A 1F 4D 04 2896  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DC6 6F          2897  			LD	L,A
040DC7 78          2898  			LD	A,B			; Restore the dimension variable type
040DC8 4C          2899  			LD	C,H
040DC9 CD 13 16 04 2900  			CALL    STORE           	; Store the address
040DCD CD 1A 03 04 2901  			CALL    EXPRI			; Get the number of bytes to store
040DD1 D9          2902  			EXX
040DD2 23          2903  			INC     HL			; Add one to it
040DD3 EB          2904  			EX      DE,HL
040DD4 2A 1D 4D 04 2905  			LD      HL,(FREE)
040DD8 18 8C       2906  			JR      DIM3			; Continue with the DIM
040DDA             2907  
040DDA             2908  ; PRINT list...
040DDA             2909  ; PRINT #channel,list...
040DDA             2910  ;
040DDA FE 23       2911  PRINT_:			CP      '#'
040DDC 20 7C       2912  			JR      NZ,PRINT0
040DDE CD CF 18 04 2913  			CALL    CHNL            ;CHANNEL NO. = E
040DE2 CD 83 0A 04 2914  PRNTN1:			CALL    NXT
040DE6 FE 2C       2915  			CP      ','
040DE8 C2 A9 0B 04 2916  			JP      NZ,XEQ
040DEC FD 23       2917  			INC     IY
040DEE D5          2918  			PUSH    DE
040DEF CD D2 01 04 2919  			CALL    EXPR            ;ITEM TO PRINT
040DF3 08          2920  			EX      AF,AF'
040DF4 FA 1A 0E 04 2921  			JP      M,PRNTN2        ;STRING
040DF8 D1          2922  			POP     DE
040DF9 C5          2923  			PUSH    BC
040DFA D9          2924  			EXX
040DFB 7D          2925  			LD      A,L
040DFC D9          2926  			EXX
040DFD CD AD 43 04 2927  			CALL    OSBPUT
040E01 D9          2928  			EXX
040E02 7C          2929  			LD      A,H
040E03 D9          2930  			EXX
040E04 CD AD 43 04 2931  			CALL    OSBPUT
040E08 7D          2932  			LD      A,L
040E09 CD AD 43 04 2933  			CALL    OSBPUT
040E0D 7C          2934  			LD      A,H
040E0E CD AD 43 04 2935  			CALL    OSBPUT
040E12 C1          2936  			POP     BC
040E13 79          2937  			LD      A,C
040E14 CD AD 43 04 2938  			CALL    OSBPUT
040E18 18 C8       2939  			JR      PRNTN1
040E1A 4B          2940  PRNTN2:			LD      C,E
040E1B D1          2941  			POP     DE
040E1C 21 00 4A 04 2942  			LD      HL,ACCS
040E20 0C          2943  			INC     C
040E21 0D          2944  PRNTN3:			DEC     C
040E22 28 0A       2945  			JR      Z,PRNTN4
040E24 7E          2946  			LD      A,(HL)
040E25 23          2947  			INC     HL
040E26 C5          2948  			PUSH    BC
040E27 CD AD 43 04 2949  			CALL    OSBPUT
040E2B C1          2950  			POP     BC
040E2C 18 F3       2951  			JR      PRNTN3
040E2E 3E 0D       2952  PRNTN4:			LD      A,CR
040E30 CD AD 43 04 2953  			CALL    OSBPUT
040E34 18 AC       2954  			JR      PRNTN1
040E36             2955  ;
040E36 06 02       2956  PRINT6:			LD      B,2
040E38 18 27       2957  			JR      PRINTC
040E3A 01 00 01 00 2958  PRINT8:			LD      BC,100H
040E3E 18 21       2959  			JR      PRINTC
040E40 21 00 4C 04 2960  PRINT9:			LD      HL,STAVAR
040E44 AF          2961  			XOR     A
040E45 BE          2962  			CP      (HL)
040E46 28 12       2963  			JR      Z,PRINT0
040E48 3A 3D 4D 04 2964  			LD      A,(COUNT)
040E4C B7          2965  			OR      A
040E4D 28 0B       2966  			JR      Z,PRINT0
040E4F 96          2967  PRINTA:			SUB     (HL)
040E50 28 08       2968  			JR      Z,PRINT0
040E52 30 FB       2969  			JR      NC,PRINTA
040E54 ED 44       2970  			NEG
040E56 CD 2C 18 04 2971  			CALL    FILL
040E5A 3A 00 4C 04 2972  PRINT0:			LD      A,(STAVAR)
040E5E 4F          2973  			LD      C,A             ;PRINTS
040E5F 06 00       2974  			LD      B,0             ;PRINTF
040E61 CD B7 17 04 2975  PRINTC:			CALL    TERMQ
040E65 28 3F       2976  			JR      Z,PRINT4
040E67 CB 80       2977  			RES     0,B
040E69 FD 23       2978  			INC     IY
040E6B FE 7E       2979  			CP      '~'
040E6D 28 C7       2980  			JR      Z,PRINT6
040E6F FE 3B       2981  			CP      ';'
040E71 28 C7       2982  			JR      Z,PRINT8
040E73 FE 2C       2983  			CP      ','
040E75 28 C9       2984  			JR      Z,PRINT9
040E77 CD DC 17 04 2985  			CALL    FORMAT          ;SPC, TAB, '
040E7B 28 E4       2986  			JR      Z,PRINTC
040E7D FD 2B       2987  			DEC     IY
040E7F C5          2988  			PUSH    BC
040E80 CD D2 01 04 2989  			CALL    EXPR            ;VARIABLE TYPE
040E84 08          2990  			EX      AF,AF'
040E85 FA 9F 0E 04 2991  			JP      M,PRINT3        ;STRING
040E89 D1          2992  			POP     DE
040E8A D5          2993  			PUSH    DE
040E8B CB 4A       2994  			BIT     1,D
040E8D F5          2995  			PUSH    AF
040E8E CC 76 09 04 2996  			CALL    Z,STR           ;DECIMAL
040E92 F1          2997  			POP     AF
040E93 C4 2A 09 04 2998  			CALL    NZ,HEXSTR       ;HEX
040E97 C1          2999  			POP     BC
040E98 C5          3000  			PUSH    BC
040E99 79          3001  			LD      A,C
040E9A 93          3002  			SUB     E
040E9B D4 2C 18 04 3003  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E9F C1          3004  PRINT3:			POP     BC
040EA0 CD 3B 18 04 3005  			CALL    PTEXT           ;PRINT
040EA4 18 BB       3006  			JR      PRINTC
040EA6 CB 40       3007  PRINT4:			BIT     0,B
040EA8 CC A8 39 04 3008  			CALL    Z,CRLF
040EAC C3 A9 0B 04 3009  			JP      XEQ
040EB0             3010  
040EB0             3011  ; ON ERROR statement [:statement...]
040EB0             3012  ; ON ERROR OFF
040EB0             3013  ;
040EB0 FD 23       3014  ONERR:			INC     IY              ;SKIP "ERROR"
040EB2 21 00 00 00 3015  			LD      HL,0
040EB6 22 2C 4D 04 3016  			LD      (ERRTRP),HL
040EBA CD 83 0A 04 3017  			CALL    NXT
040EBE FE 87       3018  			CP      OFF_
040EC0 FD 23       3019  			INC     IY
040EC2 CA A9 0B 04 3020  			JP      Z,XEQ
040EC6 FD 2B       3021  			DEC     IY
040EC8 FD 22 2C 4D 3022  			LD      (ERRTRP),IY
       04          
040ECD C3 3E 0C 04 3023  			JP      REM_EX
040ED1             3024  
040ED1             3025  ; ON expr GOTO line[,line...] [ELSE statement]
040ED1             3026  ; ON expr GOTO line[,line...] [ELSE line]
040ED1             3027  ; ON expr GOSUB line[,line...] [ELSE statement]
040ED1             3028  ; ON expr GOSUB line[,line...] [ELSE line]
040ED1             3029  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040ED1             3030  ;
040ED1 FE 85       3031  ON_EX_:			CP      TERROR
040ED3 28 DB       3032  			JR      Z,ONERR         ;"ON ERROR"
040ED5 CD 1A 03 04 3033  			CALL    EXPRI
040ED9 FD 7E 00    3034  			LD      A,(IY)
040EDC FD 23       3035  			INC     IY
040EDE 1E 2C       3036  			LD      E,','           ;SEPARATOR
040EE0 FE E5       3037  			CP      TGOTO
040EE2 28 0B       3038  			JR      Z,ON1
040EE4 FE E4       3039  			CP      TGOSUB
040EE6 28 07       3040  			JR      Z,ON1
040EE8 1E F2       3041  			LD      E,TPROC
040EEA BB          3042  			CP      E
040EEB 3E 27       3043  			LD      A,39
040EED 20 45       3044  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EEF 57          3045  ON1:			LD      D,A
040EF0 D9          3046  			EXX
040EF1 E5          3047  			PUSH    HL
040EF2 D9          3048  			EXX
040EF3 C1          3049  			POP     BC              ;ON INDEX
040EF4 78          3050  			LD      A,B
040EF5 B4          3051  			OR      H
040EF6 B5          3052  			OR      L
040EF7 20 2A       3053  			JR      NZ,ON4          ;OUT OF RANGE
040EF9 B1          3054  			OR      C
040EFA 28 27       3055  			JR      Z,ON4
040EFC 0D          3056  			DEC     C
040EFD 28 0E       3057  			JR      Z,ON3           ;INDEX=1
040EFF CD B7 17 04 3058  ON2:			CALL    TERMQ
040F03 28 1E       3059  			JR      Z,ON4           ;OUT OF RANGE
040F05 FD 23       3060  			INC     IY              ;SKIP DELIMITER
040F07 BB          3061  			CP      E
040F08 20 F5       3062  			JR      NZ,ON2
040F0A 0D          3063  			DEC     C
040F0B 20 F2       3064  			JR      NZ,ON2
040F0D 7B          3065  ON3:			LD      A,E
040F0E FE F2       3066  			CP      TPROC
040F10 28 26       3067  			JR      Z,ONPROC
040F12 D5          3068  			PUSH    DE
040F13 CD 35 03 04 3069  			CALL    ITEMI           ;LINE NUMBER
040F17 D1          3070  			POP     DE
040F18 7A          3071  			LD      A,D
040F19 FE E5       3072  			CP      TGOTO
040F1B 28 2D       3073  			JR      Z,GOTO2
040F1D CD C4 17 04 3074  			CALL    SPAN            ;SKIP REST OF LIST
040F21 18 3B       3075  			JR      GOSUB1
040F23             3076  ;
040F23 FD 7E 00    3077  ON4:			LD      A,(IY)
040F26 FD 23       3078  			INC     IY
040F28 FE 8B       3079  			CP      ELSE_
040F2A CA 5E 13 04 3080  			JP      Z,IF1           ;ELSE CLAUSE
040F2E FE 0D       3081  			CP      CR
040F30 20 F1       3082  			JR      NZ,ON4
040F32 3E 28       3083  			LD      A,40
040F34 C3 C1 37 04 3084  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F38             3085  ;
040F38 3E EE       3086  ONPROC:			LD      A,TON
040F3A C3 97 10 04 3087  			JP      PROC_EX
040F3E             3088  
040F3E             3089  ; GOTO line
040F3E             3090  ;
040F3E CD 35 03 04 3091  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F42 CD B7 17 04 3092  GOTO1:			CALL    TERMQ			; Check for terminator
040F46 C2 AA 0C 04 3093  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F4A D9          3094  GOTO2:			EXX
040F4B CD F0 39 04 3095  			CALL    FINDL			; HL: Line number - Find the line
040F4F E5          3096  			PUSH    HL			; HL: Address of the line
040F50 FD E1       3097  			POP     IY			; IY = HL
040F52 CA A5 0B 04 3098  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F56 3E 29       3099  			LD      A,41			; Otherwise throw a "No such line" error
040F58 18 DA       3100  			JR      ERROR2_EX
040F5A             3101  
040F5A             3102  ; GOSUB line
040F5A             3103  ; This pushes the following data onto the execution stack
040F5A             3104  ; - 3 bytes: Current execution address
040F5A             3105  ; - 3 bytes: Marker (the address of label GOSCHK)
040F5A             3106  ;
040F5A CD 35 03 04 3107  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F5E FD E5       3108  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F60 CD 8C 16 04 3109  			CALL    CHECK           	; Check there is enough room
040F64 CD 42 0F 04 3110  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F68             3111  GOSCHK:			EQU     $
040F68             3112  
040F68             3113  ; RETURN
040F68             3114  ; This pops the following data off the execution stack as pushed by GOSUB
040F68             3115  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F68             3116  ; - 3 bytes: The return execution address
040F68             3117  ;
040F68 D1          3118  RETURN:			POP     DE			; Pop the marker off the execution stack
040F69 21 68 0F 04 3119  			LD      HL,GOSCHK		; Compare with GOSCHK
040F6D B7          3120  			OR      A
040F6E ED 52       3121  			SBC     HL,DE
040F70 FD E1       3122  			POP     IY			; Pop the return address off the execution stack
040F72 CA A9 0B 04 3123  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F76 3E 26       3124  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F78 18 BA       3125  			JR      ERROR2_EX
040F7A             3126  
040F7A             3127  ; REPEAT
040F7A             3128  ; This pushes the following data onto the execution stack
040F7A             3129  ; - 3 bytes: Current execution address
040F7A             3130  ; - 3 bytes: Marker (the address of label REPCHK)
040F7A             3131  ;
040F7A FD E5       3132  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F7C CD 8C 16 04 3133  			CALL    CHECK			; Check if there is enough room
040F80 CD A9 0B 04 3134  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F84             3135  REPCHK:			EQU     $
040F84             3136  
040F84             3137  ; UNTIL expr
040F84             3138  ; This pops the following data off the execution stack
040F84             3139  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F84             3140  ; - 3 bytes: The address of the REPEAT instruction
040F84             3141  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F84             3142  ;
040F84 C1          3143  UNTIL_EX:			POP     BC			; Fetch the marker
040F85 C5          3144  			PUSH    BC			; And push it back onto the execution stack
040F86 21 84 0F 04 3145  			LD      HL,REPCHK		; Compare with REPCHK
040F8A B7          3146  			OR      A
040F8B ED 42       3147  			SBC     HL,BC
040F8D 3E 2B       3148  			LD      A,43
040F8F 20 A3       3149  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F91 CD 1A 03 04 3150  			CALL    EXPRI			; Fetch the expression
040F95 CD EF 08 04 3151  			CALL    TEST			; Test if the expression evaluates to zero
040F99 C1          3152  			POP     BC			; Pop the marker
040F9A D1          3153  			POP     DE			; Pop the address of the REPEAT instruction
040F9B 20 05       3154  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F9D D5          3155  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F9E C5          3156  			PUSH    BC			; Push the marker back on the stack
040F9F D5          3157  			PUSH    DE			; IY = DE
040FA0 FD E1       3158  			POP     IY			; This sets the execution address back to the REPEAT instruction
040FA2 C3 A9 0B 04 3159  XEQ2:			JP      XEQ			; Continue execution
040FA6             3160  
040FA6             3161  ; FOR var = expr TO expr [STEP expr]
040FA6             3162  ; This pushes the following data onto the execution stack
040FA6             3163  ; - 3 bytes: The limit value
040FA6             3164  ; - 3 bytes: The step value
040FA6             3165  ; - 3 bytes: The current execution address
040FA6             3166  ; - 3 bytes: The address of the loop variable
040FA6             3167  ; - 3 bytes: Marker (the address of FORCHK)
040FA6             3168  ;
040FA6 3E 22       3169  FORVAR:			LD      A,34
040FA8 18 8A       3170  			JR      ERROR2_EX          	; Throw "FOR variable" error
040FAA             3171  ;
040FAA CD FB 15 04 3172  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040FAE 20 F6       3173  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040FB0 F5          3174  			PUSH    AF              	; Save the variable type
040FB1 FD 7E 00    3175  			LD      A,(IY)			; Check the next token
040FB4 FE B8       3176  			CP      TO			; Compare with the token value for "TO"
040FB6 3E 24       3177  			LD      A,36			; Set the error code to 36 ("No TO")
040FB8 C2 34 0F 04 3178  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FBC FD 23       3179  			INC     IY			; Skip to the next token
040FBE             3180  ;
040FBE DD E5       3181  			PUSH    IX
040FC0 CD 12 03 04 3182  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FC4 DD E1       3183  			POP     IX
040FC6 F1          3184  			POP     AF
040FC7 47          3185  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FC8 C5          3186  			PUSH    BC              	; Stack the LIMIT value
040FC9 E5          3187  			PUSH    HL
040FCA 21 00 00 00 3188  			LD      HL,0
040FCE 4C          3189  			LD      C,H
040FCF D9          3190  			EXX
040FD0 E5          3191  			PUSH    HL
040FD1             3192  ;
040FD1 21 01 00 00 3193  			LD      HL,1            	; The preset STEP value is 1
040FD5 D9          3194  			EXX
040FD6 FD 7E 00    3195  			LD      A,(IY)			; Fetch the next token
040FD9 FE 88       3196  			CP      STEP			; Compare with the token value for "STEP"
040FDB 20 0A       3197  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FDD             3198  ;
040FDD FD 23       3199  			INC     IY			; Skip past the STEP token
040FDF DD E5       3200  			PUSH    IX
040FE1 CD 12 03 04 3201  			CALL    EXPRN          		; Fetch the STEP expression value
040FE5 DD E1       3202  			POP     IX
040FE7             3203  ;
040FE7 C5          3204  FOR1:			PUSH    BC			; Stack the STEP value
040FE8 E5          3205  			PUSH    HL
040FE9 D9          3206  			EXX
040FEA E5          3207  			PUSH    HL
040FEB D9          3208  			EXX
040FEC             3209  ;
040FEC FD E5       3210  			PUSH    IY              	; Stack the current execution address
040FEE DD E5       3211  			PUSH    IX              	; Stack the loop variable
040FF0 CD 8C 16 04 3212  			CALL    CHECK
040FF4 CD A9 0B 04 3213  			CALL    XEQ
040FF8             3214  FORCHK:			EQU     $
040FF8             3215  
040FF8             3216  ; NEXT [var[,var...]]
040FF8             3217  ; This pops the following data off the execution stack
040FF8             3218  ; - 3 bytes: Marker (the address of FORCHK)
040FF8             3219  ; - 3 bytes: The address of the loop variable
040FF8             3220  ; - 3 bytes: The current execution address
040FF8             3221  ; - 3 bytes: The step value
040FF8             3222  ; - 3 bytes: The limit value
040FF8             3223  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FF8             3224  ;
040FF8 C1          3225  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FF9 21 F8 0F 04 3226  			LD      HL,FORCHK		; Compare with FORCHK
040FFD B7          3227  			OR      A
040FFE ED 42       3228  			SBC     HL,BC
041000 3E 20       3229  			LD      A,32
041002 C2 8E 10 04 3230  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
041006 CD B7 17 04 3231  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
04100A E1          3232  			POP     HL			; Pop the address of the loop variable off the execution stack
04100B E5          3233  			PUSH    HL			; Push it back onto the execution stack
04100C C5          3234  			PUSH    BC			; Push the marker back onto the execution stack
04100D E5          3235  			PUSH    HL			; HL: Address of the loop variable off the stack
04100E C4 9B 3A 04 3236  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041012 D1          3237  			POP     DE			; DE: Address of the loop variable off the stack
041013 EB          3238  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041014 B7          3239  			OR      A
041015 ED 52       3240  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041017 20 61       3241  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041019 D5          3242  			PUSH    DE
04101A DD 21 0C 00 3243  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
04101F DD 39       3244  			ADD     IX,SP
041021 CD 24 2A 04 3245  			CALL    DLOAD5_SPL      	; Load the STEP value
041025 DD 7E 10    3246  			LD      A,(IX+16)       	; Get the STEP type
041028 DD E1       3247  			POP     IX
04102A CD 26 04 04 3248  			CALL    LOADN           	; Load the LOOP variable
04102E CB 7A       3249  			BIT     7,D             	; Check the sign
041030 F5          3250  			PUSH    AF
041031 3E 0B       3251  			LD      A,'+' & 0FH
041033 CD AD 20 04 3252  			CALL    FPP             	; Add the STEP
041037 38 55       3253  			JR      C,ERROR3_EX
041039 F1          3254  			POP     AF              	; Restore TYPE
04103A F5          3255  			PUSH    AF
04103B CD 13 16 04 3256  			CALL    STORE           	; Update the variable
04103F DD 21 15 00 3257  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041044 DD 39       3258  			ADD     IX,SP
041046 CD 24 2A 04 3259  			CALL    DLOAD5_SPL      	; Load the LIMIT value
04104A F1          3260  			POP     AF
04104B CC E7 08 04 3261  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
04104F             3262  			; LD      A,0+('<'-4) & 0FH
04104F 3E 08       3263  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041051 CD AD 20 04 3264  			CALL    FPP             	; Test against the limit
041055 38 37       3265  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041057 24          3266  			INC     H
041058 20 14       3267  			JR      NZ,LOOP_        	; Keep looping
04105A 21 1B 00 00 3268  			LD      HL,27			; Adjust the stack
04105E 39          3269  			ADD     HL,SP
04105F F9          3270  			LD      SP,HL
041060 CD 83 0A 04 3271  			CALL    NXT
041064 FE 2C       3272  			CP      ','			; Check for multiple variables
041066 C2 A9 0B 04 3273  			JP      NZ,XEQ			; No, so we are done at ths point
04106A FD 23       3274  			INC     IY			; Increment to the next variable
04106C 18 8A       3275  			JR      NEXT_EX			; And continue
04106E             3276  ;
04106E C1          3277  LOOP_:			POP     BC
04106F D1          3278  			POP     DE
041070 FD E1       3279  			POP     IY
041072 FD E5       3280  			PUSH    IY
041074 D5          3281  			PUSH    DE
041075 C5          3282  			PUSH    BC
041076 C3 A9 0B 04 3283  			JP      XEQ
04107A             3284  ;
04107A 21 1B 00 00 3285  NEXT1:			LD      HL,27			; TODO: What does this do?
04107E 39          3286  			ADD     HL,SP
04107F F9          3287  			LD      SP,HL			; Adjust the stack
041080 C1          3288  			POP     BC
041081 21 F8 0F 04 3289  			LD      HL,FORCHK
041085 ED 42       3290  			SBC     HL,BC
041087 E1          3291  			POP     HL              	; Variable pointer
041088 E5          3292  			PUSH    HL
041089 C5          3293  			PUSH    BC
04108A 28 89       3294  			JR      Z,NEXT0
04108C             3295  ;
04108C 3E 21       3296  			LD      A,33
04108E C3 C1 37 04 3297  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041092             3298  
041092             3299  ; FNname
041092             3300  ; N.B. ENTERED WITH A <> TON
041092             3301  ;
041092 F5          3302  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041093 CD 9C 10 04 3303  			CALL    PROC1
041097             3304  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041097             3305  
041097             3306  ; PROCname
041097             3307  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
041097             3308  ; This pushes the following data onto the execution stack
041097             3309  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
041097             3310  ; - 3 bytes: Marker (the address of PROCHK)
041097             3311  ;
041097 F5          3312  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041098 CD 9C 10 04 3313  			CALL    PROC1			; and is also space reserved on the stack for the return address
04109C             3314  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
04109C             3315  ;
04109C CD 8C 16 04 3316  PROC1:			CALL    CHECK			; Check there is space for this
0410A0 FD 2B       3317  			DEC     IY			; Decrement IY to the PROC token
0410A2 FD E5       3318  			PUSH    IY			; Stack the pointer
0410A4 CD 5C 3B 04 3319  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410A8 C1          3320  			POP     BC			; BC = IY
0410A9 28 41       3321  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0410AB 3E 1E       3322  			LD      A,30
0410AD 38 DF       3323  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0410AF             3324  ;
0410AF             3325  ; At this point the PROC/FN has not yet been registered in the dynamic area
0410AF             3326  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0410AF             3327  ;
0410AF C5          3328  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0410B0 2A 14 4D 04 3329  			LD      HL,(PAGE_)		; HL: Start of program memory
0410B4             3330  ;
0410B4 3E DD       3331  PROC2:			LD      A,DEF_			;  A: The token to search for
0410B6 CD 8B 18 04 3332  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410BA 38 26       3333  			JR      C,PROC3			; Not found, so jump to PROC3
0410BC E5          3334  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410BD FD E1       3335  			POP     IY			; IY = HL
0410BF FD 23       3336  			INC     IY              	; Skip the DEF token
0410C1 CD 83 0A 04 3337  			CALL    NXT			; And any whitespace
0410C5 CD 5C 3B 04 3338  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410C9 FD E5       3339  			PUSH    IY
0410CB D1          3340  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410CC 38 09       3341  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410CE C4 0F 3C 04 3342  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410D2 FD E5       3343  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410D4 D1          3344  			POP     DE			; DE = IY
0410D5 ED 1F       3345  			LD	(HL),DE			; Save address
0410D7             3346  ;
0410D7 EB          3347  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410D8 3E 0D       3348  			LD      A,CR			; The character to search for
0410DA 01 00 01 00 3349  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410DE ED B1       3350  			CPIR                    	; Skip to next line
0410E0 18 D2       3351  			JR      PROC2			; Rinse, lather and repeat
0410E2             3352  ;
0410E2             3353  ; At this point a DEF has not been found for the PROC/FN
0410E2             3354  ;
0410E2 FD E1       3355  PROC3:			POP     IY              	; Restore the execution address
0410E4 CD 5C 3B 04 3356  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410E8 3E 1D       3357  			LD      A,29
0410EA 20 A2       3358  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410EC             3359  ;
0410EC             3360  ; At this point we have a PROC/FN entry in the dynamic area
0410EC             3361  ;
0410EC ED 17       3362  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410EE 21 03 00 00 3363  			LD	HL,3
0410F2 39          3364  			ADD     HL,SP
0410F3 CD 83 0A 04 3365  			CALL    NXT             	; Allow space before "("
0410F7 D5          3366  			PUSH    DE              	; Exchange DE and IY
0410F8 FD E3       3367  			EX      (SP),IY
0410FA FE 28       3368  			CP      '('             	; Arguments?
0410FC D1          3369  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410FD 20 20       3370  			JR      NZ,PROC5
0410FF CD 83 0A 04 3371  			CALL    NXT             	; Allow space before "("
041103 FE 28       3372  			CP      '('
041105 C2 AA 0C 04 3373  			JP      NZ,SYNTAX       	; Throw "Syntax error"
041109 FD E5       3374  			PUSH    IY
04110B C1          3375  			POP     BC              	; Save IY in BC
04110C D9          3376  			EXX
04110D CD 37 17 04 3377  			CALL    SAVLOC          	; Save local parameters
041111 CD 42 0A 04 3378  			CALL    BRAKET          	; Closing bracket
041115 D9          3379  			EXX
041116 C5          3380  			PUSH    BC
041117 FD E1       3381  			POP     IY              	; Restore IY
041119 E5          3382  			PUSH    HL
04111A CD B3 16 04 3383  			CALL    ARGUE           	; Transfer arguments
04111E E1          3384  			POP     HL
04111F             3385  ;
04111F 23          3386  PROC5:			INC	HL			; Increment to the ON PROC flag address
041120 7E          3387  			LD	A, (HL)			; And fetch the value
041121 2B          3388  			DEC 	HL
041122 ED 1F       3389  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041124 FE EE       3390  			CP	TON			; Was it "ON PROC"?
041126 C2 A9 0B 04 3391  			JP	NZ, XEQ			; No, so back to XEQ
04112A D5          3392  			PUSH    DE			; Exchange DE and IY
04112B FD E3       3393  			EX      (SP),IY
04112D CD C4 17 04 3394  			CALL    SPAN            	; Skip rest of ON list
041131 FD E3       3395  			EX      (SP),IY			; Exchange DE and IY
041133 D1          3396  			POP     DE
041134 ED 1F       3397  			LD	(HL), DE		; Save the return address
041136 C3 A9 0B 04 3398  			JP      XEQ
04113A             3399  
04113A             3400  ; LOCAL var[,var...]
04113A             3401  ;
04113A C1          3402  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
04113B C5          3403  			PUSH    BC
04113C 21 97 10 04 3404  			LD      HL,FNCHK		; Check if we are in a FN
041140 B7          3405  			OR      A
041141 ED 42       3406  			SBC     HL,BC
041143 28 16       3407  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041145 21 9C 10 04 3408  			LD      HL,PROCHK		; Now check if we are in a PROC
041149 B7          3409  			OR      A
04114A ED 42       3410  			SBC     HL,BC
04114C 28 0D       3411  			JR      Z,LOCAL1		; Again, all good, we can use local
04114E 21 95 17 04 3412  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041152 B7          3413  			OR      A
041153 ED 42       3414  			SBC     HL,BC			; If it is not present, then
041155 3E 0C       3415  			LD      A,12
041157 C2 C1 37 04 3416  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
04115B             3417  ;
04115B             3418  ; At this point we are adding a local variable into a PROC or FN
04115B             3419  ;
04115B FD E5       3420  LOCAL1:			PUSH    IY			; IY: BASIC pointer
04115D C1          3421  			POP     BC			; BC: Copy of the BASIC pointer
04115E D9          3422  			EXX
04115F FD 2B       3423  			DEC     IY
041161 CD 37 17 04 3424  			CALL    SAVLOC
041165 D9          3425  			EXX
041166 C5          3426  			PUSH    BC
041167 FD E1       3427  			POP     IY
041169             3428  ;
041169 CD 9B 3A 04 3429  LOCAL2:			CALL    GETVAR			; Get the variable location
04116D C2 AA 0C 04 3430  			JP      NZ,SYNTAX
041171 B7          3431  			OR      A               	; Check the variable type (80h = string)
041172 08          3432  			EX      AF,AF'
041173 CD A3 09 04 3433  			CALL    ZERO			; Zero the variable anyway
041177 08          3434  			EX      AF,AF'
041178 F5          3435  			PUSH    AF
041179 F4 13 16 04 3436  			CALL    P,STORE         	; Call STORE if it is not a string
04117D F1          3437  			POP     AF
04117E 59          3438  			LD      E,C
04117F FC 41 16 04 3439  			CALL    M,STORES		; Call STORES if it is a string
041183 CD 83 0A 04 3440  			CALL    NXT			; Skip to the next character in the expression
041187 FE 2C       3441  			CP      ','			; Is it a comma?
041189 C2 A9 0B 04 3442  			JP      NZ,XEQ			; No, so we're done, carry on executing
04118D FD 23       3443  			INC     IY			; Yes, so skip the comma
04118F CD 83 0A 04 3444  			CALL    NXT			; And any whitespace
041193 18 D4       3445  			JR      LOCAL2			; Then loop back and handle any further local variables
041195             3446  
041195             3447  ; ENDPROC
041195             3448  ;
041195 C1          3449  ENDPRO:			POP     BC			; Pop the check value off the stack
041196 21 95 17 04 3450  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
04119A B7          3451  			OR      A
04119B ED 42       3452  			SBC     HL,BC
04119D 28 13       3453  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04119F             3454  ;
04119F 21 9C 10 04 3455  			LD      HL,PROCHK       	; Check if it is the PROC marker
0411A3 B7          3456  			OR      A
0411A4 ED 42       3457  			SBC     HL,BC
0411A6 FD E1       3458  			POP     IY
0411A8 CA A9 0B 04 3459  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0411AC 3E 0D       3460  			LD      A,13			; Otherwise throw the "No PROC" error
0411AE C3 C1 37 04 3461  			JP      ERROR_
0411B2             3462  ;
0411B2 DD E1       3463  UNSTK:			POP     IX			; Unstack a single local variable
0411B4 C1          3464  			POP     BC
0411B5 78          3465  			LD      A,B
0411B6 B7          3466  			OR      A
0411B7 FA C5 11 04 3467  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411BB E1          3468  			POP     HL			; Unstack a normal variable
0411BC D9          3469  			EXX
0411BD E1          3470  			POP     HL
0411BE D9          3471  			EXX
0411BF CD 13 16 04 3472  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411C3 18 D0       3473  			JR      ENDPRO			; And loop back to ENDPRO
0411C5             3474  ;
0411C5 21 00 00 00 3475  UNSTK1:			LD      HL,0			; Unstack a string
0411C9 39          3476  			ADD     HL,SP
0411CA 59          3477  			LD      E,C
0411CB CD 41 16 04 3478  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411CF F9          3479  			LD      SP,HL
0411D0 18 C3       3480  			JR      ENDPRO
0411D2             3481  
0411D2             3482  ; INPUT #channel,var,var...
0411D2             3483  ;
0411D2 CD CF 18 04 3484  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411D6 CD 83 0A 04 3485  INPN1:			CALL    NXT
0411DA FE 2C       3486  			CP      ','
0411DC C2 A9 0B 04 3487  			JP      NZ,XEQ
0411E0 FD 23       3488  			INC     IY
0411E2 CD 83 0A 04 3489  			CALL    NXT
0411E6 D5          3490  			PUSH    DE
0411E7 CD A1 0C 04 3491  			CALL    VAR_
0411EB D1          3492  			POP     DE
0411EC F5          3493  			PUSH    AF              ;SAVE TYPE
0411ED E5          3494  			PUSH    HL              ;VARPTR
0411EE B7          3495  			OR      A
0411EF FA 1B 12 04 3496  			JP      M,INPN2         ;STRING
0411F3 CD A5 43 04 3497  			CALL    OSBGET
0411F7 D9          3498  			EXX
0411F8 6F          3499  			LD      L,A
0411F9 D9          3500  			EXX
0411FA CD A5 43 04 3501  			CALL    OSBGET
0411FE D9          3502  			EXX
0411FF 67          3503  			LD      H,A
041200 D9          3504  			EXX
041201 CD A5 43 04 3505  			CALL    OSBGET
041205 6F          3506  			LD      L,A
041206 CD A5 43 04 3507  			CALL    OSBGET
04120A 67          3508  			LD      H,A
04120B CD A5 43 04 3509  			CALL    OSBGET
04120F 4F          3510  			LD      C,A
041210 DD E1       3511  			POP     IX
041212 F1          3512  			POP     AF              ;RESTORE TYPE
041213 D5          3513  			PUSH    DE              ;SAVE CHANNEL
041214 CD 13 16 04 3514  			CALL    STORE
041218 D1          3515  			POP     DE
041219 18 BB       3516  			JR      INPN1
04121B 21 00 4A 04 3517  INPN2:			LD      HL,ACCS
04121F CD A5 43 04 3518  INPN3:			CALL    OSBGET
041223 FE 0D       3519  			CP      CR
041225 28 04       3520  			JR      Z,INPN4
041227 77          3521  			LD      (HL),A
041228 2C          3522  			INC     L
041229 20 F4       3523  			JR      NZ,INPN3
04122B DD E1       3524  INPN4:			POP     IX
04122D F1          3525  			POP     AF
04122E D5          3526  			PUSH    DE
04122F EB          3527  			EX      DE,HL
041230 CD 3D 16 04 3528  			CALL    STACCS
041234 D1          3529  			POP     DE
041235 18 9F       3530  			JR      INPN1
041237             3531  
041237             3532  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041237             3533  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041237             3534  ;
041237 FE 23       3535  INPUT:			CP      '#'
041239 28 97       3536  			JR      Z,INPUTN
04123B 0E 00       3537  			LD      C,0             ;FLAG PROMPT
04123D FE 86       3538  			CP      LINE_
04123F 20 04       3539  			JR      NZ,INPUT0
041241 FD 23       3540  			INC     IY              ;SKIP "LINE"
041243 0E 80       3541  			LD      C,80H
041245 21 00 4B 04 3542  INPUT0:			LD      HL,BUFFER
041249 36 0D       3543  			LD      (HL),CR         ;INITIALISE EMPTY
04124B CD B7 17 04 3544  INPUT1:			CALL    TERMQ
04124F CA A9 0B 04 3545  			JP      Z,XEQ           ;DONE
041253 FD 23       3546  			INC     IY
041255 FE 2C       3547  			CP      ','
041257 28 5C       3548  			JR      Z,INPUT3        ;SKIP COMMA
041259 FE 3B       3549  			CP      ';'
04125B 28 58       3550  			JR      Z,INPUT3
04125D E5          3551  			PUSH    HL              ;SAVE BUFFER POINTER
04125E FE 22       3552  			CP      34		;ASCII ""
041260 20 0C       3553  			JR      NZ,INPUT6
041262 C5          3554  			PUSH    BC
041263 CD 77 04 04 3555  			CALL    CONS
041267 C1          3556  			POP     BC
041268 CD 3B 18 04 3557  			CALL    PTEXT           ;PRINT PROMPT
04126C 18 06       3558  			JR      INPUT9
04126E CD DC 17 04 3559  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041272 20 05       3560  			JR      NZ,INPUT2
041274 E1          3561  INPUT9:			POP     HL
041275 CB C1       3562  			SET     0,C             ;FLAG NO PROMPT
041277 18 CC       3563  			JR      INPUT0
041279 FD 2B       3564  INPUT2:			DEC     IY
04127B C5          3565  			PUSH    BC
04127C CD A1 0C 04 3566  			CALL    VAR_
041280 C1          3567  			POP     BC
041281 E1          3568  			POP     HL
041282 F5          3569  			PUSH    AF              ;SAVE TYPE
041283 7E          3570  			LD      A,(HL)
041284 23          3571  			INC     HL
041285 FE 0D       3572  			CP      CR              ;BUFFER EMPTY?
041287 CC B9 12 04 3573  			CALL    Z,REFILL
04128B CB 79       3574  			BIT     7,C
04128D F5          3575  			PUSH    AF
04128E C4 5D 18 04 3576  			CALL    NZ,LINES
041292 F1          3577  			POP     AF
041293 CC 4A 18 04 3578  			CALL    Z,FETCHS
041297 F1          3579  			POP     AF              ;RESTORE TYPE
041298 C5          3580  			PUSH    BC
041299 E5          3581  			PUSH    HL
04129A B7          3582  			OR      A
04129B FA AF 12 04 3583  			JP      M,INPUT4        ;STRING
04129F F5          3584  			PUSH    AF
0412A0 DD E5       3585  			PUSH    IX
0412A2 CD 7E 06 04 3586  			CALL    VAL0
0412A6 DD E1       3587  			POP     IX
0412A8 F1          3588  			POP     AF
0412A9 CD 13 16 04 3589  			CALL    STORE
0412AD 18 04       3590  			JR      INPUT5
0412AF CD 3D 16 04 3591  INPUT4:			CALL    STACCS
0412B3 E1          3592  INPUT5:			POP     HL
0412B4 C1          3593  			POP     BC
0412B5 CB 81       3594  INPUT3:			RES     0,C
0412B7 18 92       3595  			JR      INPUT1
0412B9             3596  ;
0412B9 CB 41       3597  REFILL:			BIT     0,C
0412BB 20 0C       3598  			JR      NZ,REFIL0       ;NO PROMPT
0412BD 3E 3F       3599  			LD      A,'?'
0412BF CD B0 39 04 3600  			CALL    OUTCHR          ;PROMPT
0412C3 3E 20       3601  			LD      A,' '
0412C5 CD B0 39 04 3602  			CALL    OUTCHR
0412C9 21 00 4B 04 3603  REFIL0:			LD      HL,BUFFER
0412CD C5          3604  			PUSH    BC
0412CE E5          3605  			PUSH    HL
0412CF DD E5       3606  			PUSH    IX
0412D1 CD C0 3E 04 3607  			CALL    OSLINE
0412D5 DD E1       3608  			POP     IX
0412D7 E1          3609  			POP     HL
0412D8 C1          3610  			POP     BC
0412D9 47          3611  			LD      B,A             ;POS AT ENTRY
0412DA AF          3612  			XOR     A
0412DB 32 3D 4D 04 3613  			LD      (COUNT),A
0412DF B8          3614  			CP      B
0412E0 C8          3615  			RET     Z
0412E1 7E          3616  REFIL1:			LD      A,(HL)
0412E2 FE 0D       3617  			CP      CR
0412E4 C8          3618  			RET     Z
0412E5 23          3619  			INC     HL
0412E6 10 F9       3620  			DJNZ    REFIL1
0412E8 C9          3621  			RET
0412E9             3622  
0412E9             3623  ; READ var[,var...]
0412E9             3624  ;
0412E9 FE 23       3625  READ:			CP      '#'
0412EB CA D2 11 04 3626  			JP      Z,INPUTN
0412EF 2A 31 4D 04 3627  			LD      HL,(DATPTR)
0412F3 7E          3628  READ0:			LD      A,(HL)
0412F4 23          3629  			INC     HL              ;SKIP COMMA OR "DATA"
0412F5 FE 0D       3630  			CP      CR              ;END OF DATA STMT?
0412F7 CC 3B 13 04 3631  			CALL    Z,GETDAT
0412FB E5          3632  			PUSH    HL
0412FC CD A1 0C 04 3633  			CALL    VAR_
041300 E1          3634  			POP     HL
041301 B7          3635  			OR      A
041302 FA 1B 13 04 3636  			JP      M,READ1         ;STRING
041306 E5          3637  			PUSH    HL
041307 FD E3       3638  			EX      (SP),IY
041309 F5          3639  			PUSH    AF              ;SAVE TYPE
04130A DD E5       3640  			PUSH    IX
04130C CD 12 03 04 3641  			CALL    EXPRN
041310 DD E1       3642  			POP     IX
041312 F1          3643  			POP     AF
041313 CD 13 16 04 3644  			CALL    STORE
041317 FD E3       3645  			EX      (SP),IY
041319 18 09       3646  			JR      READ2
04131B CD 4A 18 04 3647  READ1:			CALL    FETCHS
04131F E5          3648  			PUSH    HL
041320 CD 3D 16 04 3649  			CALL    STACCS
041324 E1          3650  READ2:			POP     HL
041325 22 31 4D 04 3651  			LD      (DATPTR),HL
041329 CD 83 0A 04 3652  			CALL    NXT
04132D FE 2C       3653  			CP      ','
04132F C2 A9 0B 04 3654  			JP      NZ,XEQ
041333 FD 23       3655  			INC     IY
041335 CD 83 0A 04 3656  			CALL    NXT
041339 18 B8       3657  			JR      READ0
04133B             3658  ;
04133B 3E DC       3659  GETDAT:			LD      A,DATA_
04133D CD 8B 18 04 3660  			CALL    SEARCH_EX
041341 23          3661  			INC     HL
041342 D0          3662  			RET     NC
041343 3E 2A       3663  			LD      A,42
041345 C3 C1 37 04 3664  ERROR4:			JP      ERROR_           ;"Out of DATA"
041349             3665  
041349             3666  ; IF expr statement
041349             3667  ; IF expr THEN statement [ELSE statement]
041349             3668  ; IF expr THEN line [ELSE line]
041349             3669  ;
041349 CD 1A 03 04 3670  IF_:			CALL    EXPRI
04134D CD EF 08 04 3671  			CALL    TEST
041351 28 19       3672  			JR      Z,IFNOT         ;FALSE
041353 FD 7E 00    3673  			LD      A,(IY)
041356 FE 8C       3674  			CP      THEN
041358 C2 A9 0B 04 3675  			JP      NZ,XEQ
04135C FD 23       3676  			INC     IY              ;SKIP "THEN"
04135E CD 83 0A 04 3677  IF1:			CALL    NXT
041362 FE 8D       3678  			CP      LINO
041364 C2 A9 0B 04 3679  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
041368 C3 3E 0F 04 3680  			JP      GOTO_EX            ;LINE NO. FOLLOWS
04136C FD 7E 00    3681  IFNOT:			LD      A,(IY)
04136F FE 0D       3682  			CP      CR
041371 FD 23       3683  			INC     IY
041373 CA A5 0B 04 3684  			JP      Z,XEQ0          ;END OF LINE
041377 FE 8B       3685  			CP      ELSE_
041379 20 F1       3686  			JR      NZ,IFNOT
04137B 18 E1       3687  			JR      IF1
04137D             3688  
04137D             3689  ; CLS
04137D             3690  ;
04137D CD 33 44 04 3691  CLS:		CALL    CLRSCN
041381 AF          3692  			XOR     A
041382 32 3D 4D 04 3693  			LD      (COUNT),A
041386 C3 A9 0B 04 3694  			JP      XEQ
04138A             3695  
04138A             3696  ; STOP
04138A             3697  ;
04138A CD F1 3D 04 3698  STOP:			CALL    TELL
04138E 0D          3699  			DB	CR
04138F 0A          3700  			DB	LF
041390 FA          3701  			DB	TSTOP
041391 00          3702  			DB	0
041392 CD 0F 3A 04 3703  			CALL    SETLIN          ;FIND CURRENT LINE
041396 CD 43 3A 04 3704  			CALL    SAYLN
04139A CD A8 39 04 3705  			CALL    CRLF
04139E C3 E1 30 04 3706  			JP      CLOOP
0413A2             3707  
0413A2             3708  ; REPORT
0413A2             3709  ;
0413A2 CD E3 3D 04 3710  REPOR:			CALL    REPORT
0413A6 C3 A9 0B 04 3711  			JP      XEQ
0413AA             3712  
0413AA             3713  ; CLEAR
0413AA             3714  ;
0413AA CD D7 38 04 3715  CLR:			CALL    CLEAR
0413AE 2A 14 4D 04 3716  			LD      HL,(PAGE_)
0413B2 18 19       3717  			JR      RESTR1
0413B4             3718  
0413B4             3719  ; RESTORE [line]
0413B4             3720  ;
0413B4 2A 14 4D 04 3721  RESTOR_EX:			LD      HL,(PAGE_)
0413B8 CD B7 17 04 3722  			CALL    TERMQ
0413BC 28 0F       3723  			JR      Z,RESTR1
0413BE CD 35 03 04 3724  			CALL    ITEMI
0413C2 D9          3725  			EXX
0413C3 CD F0 39 04 3726  			CALL    FINDL           ;SEARCH FOR LINE
0413C7 3E 29       3727  			LD      A,41
0413C9 C2 45 13 04 3728  			JP      NZ,ERROR4       ;"No such line"
0413CD 3E DC       3729  RESTR1:			LD      A,DATA_
0413CF CD 8B 18 04 3730  			CALL    SEARCH_EX
0413D3 22 31 4D 04 3731  			LD      (DATPTR),HL
0413D7 C3 A9 0B 04 3732  			JP      XEQ
0413DB             3733  
0413DB             3734  ; PTR#channel=expr
0413DB             3735  ; PAGE=expr
0413DB             3736  ; TIME=expr
0413DB             3737  ; LOMEM=expr
0413DB             3738  ; HIMEM=expr
0413DB             3739  ;
0413DB CD C3 18 04 3740  PTR_EX:			CALL    CHANEL
0413DF CD CD 17 04 3741  			CALL    EQUALS
0413E3 7B          3742  			LD      A,E
0413E4 F5          3743  			PUSH    AF
0413E5 CD 1A 03 04 3744  			CALL    EXPRI
0413E9 E5          3745  			PUSH    HL
0413EA D9          3746  			EXX
0413EB D1          3747  			POP     DE
0413EC F1          3748  			POP     AF
0413ED CD D9 43 04 3749  			CALL    PUTPTR
0413F1 C3 A9 0B 04 3750  			JP      XEQ
0413F5             3751  ;
0413F5 CD CD 17 04 3752  PAGEV_EX:			CALL    EQUALS
0413F9 CD 1A 03 04 3753  			CALL    EXPRI
0413FD D9          3754  			EXX
0413FE 2E 00       3755  			LD      L,0
041400 22 14 4D 04 3756  			LD      (PAGE_),HL
041404 C3 A9 0B 04 3757  			JP      XEQ
041408             3758  ;
041408 FE 24       3759  TIMEV_EX:			CP      '$'
04140A 28 13       3760  			JR      Z,TIMEVS_EX
04140C CD CD 17 04 3761  			CALL    EQUALS
041410 CD 1A 03 04 3762  			CALL    EXPRI
041414 E5          3763  			PUSH    HL
041415 D9          3764  			EXX
041416 D1          3765  			POP     DE
041417 CD F8 3E 04 3766  			CALL    PUTIME
04141B C3 A9 0B 04 3767  			JP      XEQ
04141F             3768  ;
04141F FD 23       3769  TIMEVS_EX:			INC     IY              ;SKIP '$'
041421 CD CD 17 04 3770  			CALL    EQUALS
041425 CD 25 03 04 3771  			CALL    EXPRS
041429 CD 0A 01 04 3772  			CALL    PUTIMS
04142D C3 A9 0B 04 3773  			JP      XEQ
041431             3774  ;
041431 CD CD 17 04 3775  LOMEMV_EX:			CALL    EQUALS
041435 CD 1A 03 04 3776  			CALL    EXPRI
041439 CD D7 38 04 3777  			CALL    CLEAR
04143D D9          3778  			EXX
04143E 22 1A 4D 04 3779  			LD      (LOMEM),HL
041442 22 1D 4D 04 3780  			LD      (FREE),HL
041446 C3 A9 0B 04 3781  			JP      XEQ
04144A             3782  ;
04144A CD CD 17 04 3783  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
04144E CD 1A 03 04 3784  			CALL    EXPRI			; Load the expression into registers
041452 7D          3785  			LD	A,L			;  A: The MSB of the 24-bit value
041453 D9          3786  			EXX				; HL: The LSW of the 24-bit value
041454 22 4A 4D 04 3787  			LD	(R0),HL
041458 32 4C 4D 04 3788  			LD	(R0+2),A
04145C 2A 1D 4D 04 3789  			LD	HL,(FREE)
041460 11 00 01 00 3790  			LD      DE,256
041464 19          3791  			ADD	HL,DE
041465 EB          3792  			EX	DE,HL			; DE: FREE + 256
041466 2A 4A 4D 04 3793  			LD	HL,(R0)			; HL: The passed expression
04146A AF          3794  			XOR     A
04146B ED 52       3795  			SBC     HL,DE
04146D 19          3796  			ADD     HL,DE			; Do a bounds check
04146E DA C1 37 04 3797  			JP      C,ERROR_         	; Throw the error: "No room"
041472 ED 5B 20 4D 3798  			LD      DE,(HIMEM)
       04          
041477 22 20 4D 04 3799  			LD      (HIMEM),HL
04147B EB          3800  			EX      DE,HL
04147C ED 72       3801  			SBC     HL,SP			; Adjust the stack
04147E C2 A9 0B 04 3802  			JP      NZ,XEQ
041482 EB          3803  			EX      DE,HL
041483 F9          3804  			LD      SP,HL           	; Load the SP
041484 C3 A9 0B 04 3805  			JP      XEQ
041488             3806  
041488             3807  ; WIDTH expr
041488             3808  ;
041488 CD 1A 03 04 3809  WIDTHV:			CALL    EXPRI
04148C D9          3810  			EXX
04148D 7D          3811  			LD      A,L
04148E 32 3E 4D 04 3812  			LD      (WIDTH),A
041492 C3 A9 0B 04 3813  			JP      XEQ
041496             3814  
041496             3815  ; TRACE ON
041496             3816  ; TRACE OFF
041496             3817  ; TRACE line
041496             3818  ;
041496 FD 23       3819  TRACE_EX:			INC     IY
041498 21 00 00 00 3820  			LD      HL,0
04149C FE EE       3821  			CP      TON
04149E 28 0B       3822  			JR      Z,TRACE0
0414A0 FE 87       3823  			CP      OFF_
0414A2 28 08       3824  			JR      Z,TRACE1
0414A4 FD 2B       3825  			DEC     IY
0414A6 CD 1A 03 04 3826  			CALL    EXPRI
0414AA D9          3827  			EXX
0414AB 2B          3828  TRACE0:			DEC     HL
0414AC 22 26 4D 04 3829  TRACE1:			LD      (TRACEN),HL
0414B0 C3 A9 0B 04 3830  			JP      XEQ
0414B4             3831  
0414B4             3832  ; VDU expr,expr;....
0414B4             3833  ;
0414B4 DD 21 00 4B 3834  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0414B9 DD E5       3835  VDU1:			PUSH	IX
0414BB CD 1A 03 04 3836  			CALL    EXPRI			; Fetch the VDU character
0414BF DD E1       3837  			POP	IX
0414C1 D9          3838  			EXX
0414C2 DD 75 00    3839  			LD	(IX+0),L		; Write out the character to the buffer
0414C5 DD 23       3840  			INC	IX
0414C7 FD 7E 00    3841  			LD      A,(IY)			;  A: The separator character
0414CA FE 2C       3842  			CP      ','			; Is it a comma?
0414CC 28 09       3843  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414CE FE 3B       3844  			CP      ';'			; Is it a semicolon?
0414D0 20 07       3845  			JR      NZ,VDU3			; No, so skip to the next expression
0414D2 DD 74 00    3846  			LD	(IX+0),H		; Write out the high byte to the buffer
0414D5 DD 23       3847  			INC	IX
0414D7 FD 23       3848  VDU2:			INC     IY			; Skip to the next character
0414D9 CD B7 17 04 3849  VDU3:			CALL    TERMQ			; Skip past white space
0414DD 20 DA       3850  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414DF DD 7D       3851  			LD	A,IXL			;  A: Number of bytes to write out
0414E1 B7          3852  			OR	A
0414E2 28 0B       3853  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414E4 21 00 4B 04 3854  			LD	HL,BUFFER		; HL: Start of stream
0414E8 01 00 00 00 3855  			LD	BC,0
0414EC 4F          3856  			LD	C,A			; BC: Number of bytes to write out
0414ED 5B DF       3857  			RST.LIL	18h			; Output the buffer to MOS
0414EF C3 A9 0B 04 3858  VDU4:			JP      XEQ
0414F3             3859  
0414F3             3860  ; CLOSE channel number
0414F3             3861  ;
0414F3 CD C3 18 04 3862  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414F7 CD 9D 43 04 3863  			CALL    OSSHUT			; Close the channel
0414FB C3 A9 0B 04 3864  			JP      XEQ
0414FF             3865  
0414FF             3866  ; BPUT channel,byte
0414FF             3867  ;
0414FF CD C3 18 04 3868  BPUT:			CALL    CHANEL          	; Fetch the channel number
041503 D5          3869  			PUSH    DE			; DE: Channel number
041504 CD 35 0A 04 3870  			CALL    COMMA			; Skip to the next expression
041508 CD 1A 03 04 3871  			CALL    EXPRI           	; Feth the data
04150C D9          3872  			EXX
04150D 7D          3873  			LD      A,L			; A: The byte to write
04150E D1          3874  			POP     DE
04150F CD AD 43 04 3875  			CALL    OSBPUT			; Write the byte out
041513 C3 A9 0B 04 3876  			JP      XEQ
041517             3877  
041517             3878  ; CALL address[,var[,var...]]
041517             3879  ;
041517             3880  ; Note that the parameter table differs from the Z80 version
041517             3881  ; Each entry now takes up 4 bytes, not 3, so the table is now:
041517             3882  ;  -1 byte:  Number of parameters
041517             3883  ; Then, for each parameter:
041517             3884  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
041517             3885  ;  -3 bytes: Parameter address
041517             3886  ;
041517             3887  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
041517             3888  ;
041517 CD 1A 03 04 3889  CALL_:			CALL    EXPRI           	; Fetch the address
04151B 7D          3890  			LD	A,L			;  A: MSB of address
04151C D9          3891  			EXX
04151D 22 4A 4D 04 3892  			LD	(R0+0),HL		; HL: LSW of address
041521 32 4C 4D 04 3893  			LD	(R0+2),A
041525 06 00       3894  			LD      B,0             	;  B: The parameter counter
041527 11 00 4B 04 3895  			LD      DE,BUFFER       	; DE: Vector
04152B             3896  ;
04152B CD 83 0A 04 3897  CALL1:			CALL    NXT			; Skip whitespace
04152F FE 2C       3898  			CP      ','			; Check for comma
041531 20 1B       3899  			JR      NZ,CALL2		; If no more parameters, then jump here
041533 FD 23       3900  			INC     IY			; Skip to the next character
041535 04          3901  			INC     B			; Increment the parameter count
041536 CD 83 0A 04 3902  			CALL    NXT			; Skip whitespace
04153A C5          3903  			PUSH    BC
04153B D5          3904  			PUSH    DE
04153C CD A1 0C 04 3905  			CALL    VAR_
041540 D1          3906  			POP     DE
041541 C1          3907  			POP     BC
041542 13          3908  			INC     DE
041543 12          3909  			LD      (DE),A			; Save the parameter type
041544 13          3910  			INC     DE
041545 EB          3911  			EX      DE,HL
041546 ED 1F       3912  			LD	(HL),DE			; Save the parameter address (3 bytes)
041548 23          3913  			INC	HL
041549 23          3914  			INC	HL
04154A 23          3915  			INC	HL
04154B EB          3916  			EX      DE,HL
04154C 18 DD       3917  			JR      CALL1
04154E             3918  ;
04154E 78          3919  CALL2:			LD      A,B
04154F 32 00 4B 04 3920  			LD      (BUFFER),A      	; Save the parameter count
041553 2A 4A 4D 04 3921  			LD	HL,(R0)			; HL: Address of the code
041557 CD 71 15 04 3922  			CALL    USR1			; And call it
04155B C3 A9 0B 04 3923  			JP      XEQ
04155F             3924  
04155F             3925  ; USR(address)
04155F             3926  ;
04155F CD 35 03 04 3927  USR:			CALL    ITEMI			; Evaluate the expression
041563 7D          3928  			LD	A,L			;  A: MSB of address
041564 D9          3929  			EXX
041565 22 4A 4D 04 3930  			LD	(R0+0),HL		; HL: LSW of address
041569 32 4C 4D 04 3931  			LD	(R0+2),A
04156D 2A 4A 4D 04 3932  			LD	HL,(R0)			; Get the 24-bit address in HL
041571             3933  ;
041571 E5          3934  USR1:			PUSH    HL              	; Address on stack
041572 FD E3       3935  			EX      (SP),IY
041574 24          3936  			INC     H               	; Check for PAGE &00FFxx
041575 B4          3937  			OR	H
041576 21 E0 15 04 3938  			LD      HL,USR2         	; Return address
04157A E5          3939  			PUSH    HL
04157B DD 21 00 4C 3940  			LD      IX,STAVAR
       04          
041580 CC 63 43 04 3941  			CALL    Z,OSCALL        	; Intercept &00FFxx
041584             3942  ;
041584 DD 4E 18    3943  			LD      C, (IX+24)		; F%
041587 C5          3944  			PUSH    BC
041588             3945  ;
041588 DD 7E 08    3946  			LD	A, (IX+8)		; B% -> MSW
04158B 32 4B 4D 04 3947  			LD	(R0+1), A
04158F DD 7E 09    3948  			LD	A, (IX+9)
041592 32 4C 4D 04 3949  			LD	(R0+2), A
041596 DD 7E 0C    3950  			LD	A, (IX+12)		; C% -> LSB
041599 32 4A 4D 04 3951  			LD	(R0+0), A
04159D ED 4B 4A 4D 3952  			LD	BC, (R0)
       04          
0415A2             3953  ;
0415A2 DD 7E 10    3954  			LD	A, (IX+16)		; D% -> MSW
0415A5 32 4B 4D 04 3955  			LD	(R0+1), A
0415A9 DD 7E 11    3956  			LD	A, (IX+17)
0415AC 32 4C 4D 04 3957  			LD	(R0+2), A
0415B0 DD 7E 14    3958  			LD	A, (IX+20)		; E% -> LSB
0415B3 32 4A 4D 04 3959  			LD	(R0+0), A
0415B7 ED 5B 4A 4D 3960  			LD	DE, (R0)
       04          
0415BC             3961  ;
0415BC DD 7E 20    3962  			LD	A, (IX+32)		; H% -> MSW
0415BF 32 4B 4D 04 3963  			LD	(R0+1), A
0415C3 DD 7E 21    3964  			LD	A, (IX+33)
0415C6 32 4C 4D 04 3965  			LD	(R0+2), A
0415CA DD 7E 30    3966  			LD	A, (IX+48)		; L% -> LSB
0415CD 32 4A 4D 04 3967  			LD	(R0+0), A
0415D1 2A 4A 4D 04 3968  			LD	HL, (R0)
0415D5             3969  ;
0415D5 F1          3970  			POP     AF			; F%
0415D6 DD 7E 04    3971  			LD      A, (IX+4)        	; A%
0415D9             3972  
0415D9 DD 21 00 4B 3973  			LD      IX,BUFFER
       04          
0415DE FD E9       3974  			JP      (IY)            	; Off to user routine
0415E0             3975  ;
0415E0 FD E1       3976  USR2:			POP     IY
0415E2 AF          3977  			XOR     A
0415E3 4F          3978  			LD      C,A
0415E4 C9          3979  			RET
0415E5             3980  
0415E5             3981  ; PUT port,data
0415E5             3982  ;
0415E5 CD 1A 03 04 3983  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415E9 D9          3984  			EXX
0415EA E5          3985  			PUSH    HL
0415EB CD 35 0A 04 3986  			CALL    COMMA
0415EF CD 1A 03 04 3987  			CALL    EXPRI           ;DATA
0415F3 D9          3988  			EXX
0415F4 C1          3989  			POP     BC
0415F5 ED 69       3990  			OUT     (C),L           ;OUTPUT TO PORT BC
0415F7 C3 A9 0B 04 3991  			JP      XEQ
0415FB             3992  
0415FB             3993  ; SUBROUTINES -----------------------------------------------------------------
0415FB             3994  
0415FB             3995  ; ASSIGN - Assign a numeric value to a variable.
0415FB             3996  ; Outputs: NC,  Z - OK, numeric.
0415FB             3997  ;          NC, NZ - OK, string.
0415FB             3998  ;           C, NZ - illegal
0415FB             3999  ;
0415FB CD 9B 3A 04 4000  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415FF D8          4001  			RET     C               	; Return with C if it is an illegal variable
041600 C4 8A 3A 04 4002  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
041604 B7          4003  			OR      A
041605 F8          4004  			RET     M               	; Return if type is string (81h)
041606 F5          4005  			PUSH    AF              	; It's a numeric type from this point on
041607 CD CD 17 04 4006  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
04160B E5          4007  			PUSH    HL
04160C CD 12 03 04 4008  			CALL    EXPRN
041610 DD E1       4009  			POP     IX
041612 F1          4010  			POP     AF
041613 CB 47       4011  STORE:			BIT     0,A
041615 28 13       4012  			JR      Z,STOREI
041617 BF          4013  			CP      A               	; Set the variable to 0
041618 DD 71 04    4014  STORE5:			LD      (IX+4),C
04161B D9          4015  STORE4:			EXX
04161C DD 75 00    4016  			LD      (IX+0),L
04161F DD 74 01    4017  			LD      (IX+1),H
041622 D9          4018  			EXX
041623 DD 75 02    4019  			LD      (IX+2),L
041626 DD 74 03    4020  			LD      (IX+3),H
041629 C9          4021  			RET
04162A F5          4022  STOREI:			PUSH    AF
04162B 0C          4023  			INC     C               ;SPEED - & PRESERVE F'
04162C 0D          4024  			DEC     C               ; WHEN CALLED BY FNEND0
04162D C4 72 06 04 4025  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
041631 F1          4026  			POP     AF
041632 FE 04       4027  			CP      4
041634 28 E5       4028  			JR      Z,STORE4
041636 BF          4029  			CP      A               ;SET ZERO
041637 D9          4030  STORE1:			EXX
041638 DD 75 00    4031  			LD      (IX+0),L
04163B D9          4032  			EXX
04163C C9          4033  			RET
04163D             4034  ;
04163D             4035  ; Copy a string from the string accumulator to variable storage on the stack
04163D             4036  ; Parameters:
04163D             4037  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
04163D             4038  ; - IX: Address of the variable storage on the stack
04163D             4039  ;
04163D 21 00 4A 04 4040  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041641             4041  ;
041641             4042  ; Parameters:
041641             4043  ; As above, but:
041641             4044  ; - HL: Address of the string to be stored
041641             4045  ; -  E: The string length
041641             4046  ; NB:
041641             4047  ; Strings are mutable
041641             4048  ; Strings are stored in the following format in the variable:
041641             4049  ; - Address of the next variable (3 bytes)
041641             4050  ; - The rest of the variable name - this is zero terminated
041641             4051  ; - Current string length (byte)
041641             4052  ; - Maximum (original) string length (byte)
041641             4053  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041641             4054  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041641             4055  ;
041641 1F          4056  STORES:			RRA				; Rotate right to shift bit 0 into carry
041642 30 5D       4057  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041644 E5          4058  			PUSH    HL			; Stack ACCS
041645             4059  ;
041645             4060  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
041645             4061  ;
041645 D9          4062  			EXX				; This block was a call to LOAD4
041646 DD 6E 00    4063  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
041649 DD 66 01    4064  			LD      H,(IX+1)		; The maximum original string length
04164C D9          4065  			EXX
04164D DD 27 02    4066  			LD	HL,(IX+2)		; Address of the string (24-bit)
041650             4067  ;
041650 7B          4068  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041651 D9          4069  			EXX
041652 6F          4070  			LD      L,A			; L': Length of string currently stored on the stack
041653 7C          4071  			LD      A,H             	; H': The maximum (original) string length
041654 D9          4072  			EXX
041655 BB          4073  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041656 30 17       4074  			JR      NC,STORS1       	; Yes there is, so skip the next bit
041658             4075  ;
041658             4076  ; At this point we're either initialising a new string or assigning more memory to an existing string
041658             4077  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
041658             4078  ; then the existing and new strings may both exist in memory.
041658             4079  ;
041658 D9          4080  			EXX
041659 65          4081  			LD      H,L			; H: Set the maximum string length to the string length
04165A D9          4082  			EXX
04165B E5          4083  			PUSH    HL
04165C 01 00 00 00 4084  			LD	BC, 0
041660 4F          4085  			LD      C,A			; BC: The maximum (original) string length
041661 09          4086  			ADD     HL,BC			; Work out whether this is the last string in memory
041662 ED 4B 1D 4D 4087  			LD      BC,(FREE)
       04          
041667 ED 42       4088  			SBC     HL,BC			; Is string last?
041669 E1          4089  			POP     HL
04166A 37          4090  			SCF
04166B 28 02       4091  			JR      Z,STORS1
04166D             4092  			; LD	HL, BC			; HL=BC
04166D C5          4093  			push bc
04166E E1          4094  			pop hl
04166F             4095  ;
04166F             4096  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
04166F             4097  ; - H': The maximum (original) string length
04166F             4098  ; - L': The actual string length (must be less than H')
04166F             4099  ; - HL: Address of the string in memory
04166F             4100  ;
04166F D9          4101  STORS1:			EXX				; This block was a call to STORE4
041670 DD 75 00    4102  			LD      (IX+0),L		; The actual string length (must be less then H')
041673 DD 74 01    4103  			LD      (IX+1),H		; The maximum (original) string length
041676 D9          4104  			EXX
041677 DD 2F 02    4105  			LD	(IX+2),HL		; The pointer to the original string
04167A             4106  ;
04167A 01 00 00 00 4107  			LD	BC, 0
04167E 4B          4108  			LD      C,E			; BC: The new string length
04167F EB          4109  			EX      DE,HL
041680 E1          4110  			POP     HL
041681 0D          4111  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041682 0C          4112  			INC     C			; check whether BC is 0 without affecting the carry flag
041683 C8          4113  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041684 ED B0       4114  			LDIR				; Replace the string in memory
041686 D0          4115  			RET     NC
041687 ED 53 1D 4D 4116  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
04168C             4117  ;
04168C             4118  ; Check whether the stack is full
04168C             4119  ;
04168C E5          4120  CHECK:			PUSH    HL
04168D C5          4121  			PUSH	BC
04168E 2A 1D 4D 04 4122  			LD      HL,(FREE)		; HL: Address of first free space byte
041692 01 00 01 00 4123  			LD	BC,100h			; BC: One page of memory
041696 09          4124  			ADD	HL,BC			; Add a page to FREE
041697 ED 72       4125  			SBC     HL,SP			; And subtract the current SP
041699 C1          4126  			POP	BC
04169A E1          4127  			POP     HL
04169B D8          4128  			RET     C			; The SP is not in the same page, so just return
04169C AF          4129  			XOR     A			; Otherwise
04169D C3 C1 37 04 4130  			JP      ERROR_			; Throw error "No room"
0416A1             4131  ;
0416A1 01 00 00 00 4132  STORS3:			LD	BC,0
0416A5 4B          4133  			LD      C,E			; BC: String length
0416A6 DD E5       4134  			PUSH    IX
0416A8 D1          4135  			POP     DE			; DE: Destination
0416A9 AF          4136  			XOR     A			; Check if string length is 0
0416AA B9          4137  			CP      C
0416AB 28 02       4138  			JR      Z,STORS5		; Yes, so don't copy
0416AD ED B0       4139  			LDIR
0416AF 3E 0D       4140  STORS5:			LD      A,CR			; Finally add the terminator
0416B1 12          4141  			LD      (DE),A
0416B2 C9          4142  			RET
0416B3             4143  
0416B3             4144  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0416B3             4145  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0416B3             4146  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0416B3             4147  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0416B3             4148  ;    Inputs: DE addresses parameter list
0416B3             4149  ;            IY addresses dummy variable list
0416B3             4150  ;   Outputs: DE,IY updated
0416B3             4151  ;  Destroys: Everything
0416B3             4152  ;
0416B3 3E FF       4153  ARGUE:			LD      A,-1
0416B5 F5          4154  			PUSH    AF              	; Put marker on the stack
0416B6 FD 23       4155  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416B8 13          4156  			INC     DE
0416B9 D5          4157  			PUSH    DE
0416BA CD 83 0A 04 4158  			CALL    NXT			; Skip any whitespace
0416BE CD 9B 3A 04 4159  			CALL    GETVAR			; Get the location of the variable in HL/IX
0416C2 38 3F       4160  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416C4 C4 8A 3A 04 4161  			CALL    NZ,PUTVAR
0416C8 D1          4162  			POP     DE
0416C9 E5          4163  			PUSH    HL              	; VARPTR
0416CA B7          4164  			OR      A               	; Check the variable type
0416CB F5          4165  			PUSH    AF
0416CC D5          4166  			PUSH    DE
0416CD FD E3       4167  			EX      (SP),IY
0416CF FA E7 16 04 4168  			JP      M,ARGUE2        	; Jump here if it is a string
0416D3             4169  ;
0416D3 CD 12 03 04 4170  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416D7 FD E3       4171  			EX      (SP),IY
0416D9 D1          4172  			POP     DE
0416DA F1          4173  			POP     AF
0416DB D9          4174  			EXX
0416DC E5          4175  			PUSH    HL
0416DD D9          4176  			EXX
0416DE E5          4177  			PUSH    HL
0416DF 47          4178  			LD      B,A
0416E0 C5          4179  			PUSH    BC
0416E1 CD 8C 16 04 4180  			CALL    CHECK           	; Check room
0416E5 18 0F       4181  			JR      ARGUE4
0416E7             4182  ;
0416E7 CD 25 03 04 4183  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416EB FD E3       4184  			EX      (SP),IY
0416ED D9          4185  			EXX
0416EE D1          4186  			POP     DE
0416EF D9          4187  			EXX
0416F0 F1          4188  			POP     AF
0416F1 CD C4 09 04 4189  			CALL    PUSHS
0416F5 D9          4190  			EXX
0416F6             4191  ;
0416F6 CD 83 0A 04 4192  ARGUE4:			CALL    NXT			; Skip whitespace
0416FA FE 2C       4193  			CP      ','			; Check to see if the next value is a comma
0416FC 20 0B       4194  			JR      NZ,ARGUE5		; No, so jump here
0416FE 1A          4195  			LD      A,(DE)
0416FF FE 2C       4196  			CP      ','			; Are there any more arguments?
041701 28 B3       4197  			JR      Z,ARGUE1        	; Yes, so loop
041703             4198  ;
041703 3E 1F       4199  ARGERR:			LD      A,31
041705 C3 C1 37 04 4200  			JP      ERROR_           	; Throw error "Arguments"
041709             4201  ;
041709 CD 42 0A 04 4202  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
04170D 1A          4203  			LD      A,(DE)
04170E FE 29       4204  			CP      ')'
041710 20 F1       4205  			JR      NZ,ARGERR
041712 13          4206  			INC     DE
041713 D9          4207  			EXX
041714 C1          4208  ARGUE6:			POP     BC
041715 78          4209  			LD      A,B
041716 3C          4210  			INC     A
041717 D9          4211  			EXX
041718 C8          4212  			RET     Z               	; Marker popped
041719 D9          4213  			EXX
04171A 3D          4214  			DEC     A
04171B FA 2B 17 04 4215  			JP      M,ARGUE7        	; If it is a string, then jump here
04171F E1          4216  			POP     HL
041720 D9          4217  			EXX
041721 E1          4218  			POP     HL
041722 D9          4219  			EXX
041723 DD E1       4220  			POP     IX
041725 CD 13 16 04 4221  			CALL    STORE	           	; Write to dummy variable
041729 18 E9       4222  			JR      ARGUE6
04172B             4223  ;
04172B CD F1 09 04 4224  ARGUE7:			CALL    POPS
04172F DD E1       4225  			POP     IX
041731 CD 3D 16 04 4226  			CALL    STACCS
041735 18 DD       4227  			JR      ARGUE6
041737             4228  
041737             4229  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
041737             4230  ;   OF A FUNCTION OR PROCEDURE.
041737             4231  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
041737             4232  ;    Inputs: IY is parameters pointer
041737             4233  ;   Outputs: IY updated
041737             4234  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
041737             4235  ;
041737 D1          4236  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
041738             4237  ;
041738 FD 23       4238  SAVLO1:			INC     IY              	; Bump past '(' or ','
04173A CD 83 0A 04 4239  			CALL    NXT			; And also any whitespace
04173E D5          4240  			PUSH    DE			; Push the return address back onto the stack
04173F D9          4241  			EXX
041740 C5          4242  			PUSH    BC
041741 D5          4243  			PUSH    DE
041742 E5          4244  			PUSH    HL
041743 D9          4245  			EXX
041744 CD A1 0C 04 4246  			CALL    VAR_             	; Dummy variable
041748 D9          4247  			EXX
041749 E1          4248  			POP     HL
04174A D1          4249  			POP     DE
04174B C1          4250  			POP     BC
04174C D9          4251  			EXX
04174D D1          4252  			POP     DE
04174E B7          4253  			OR      A               	; Check the variable type
04174F FA 62 17 04 4254  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041753 D9          4255  			EXX
041754 E5          4256  			PUSH    HL              	; Save H'L'
041755 D9          4257  			EXX
041756 47          4258  			LD      B,A             	;  B: Variable type
041757 CD 26 04 04 4259  			CALL    LOADN
04175B D9          4260  			EXX
04175C E3          4261  			EX      (SP),HL
04175D D9          4262  			EXX
04175E E5          4263  			PUSH    HL
04175F C5          4264  			PUSH    BC
041760 18 2D       4265  			JR      SAVLO4
041762             4266  ;
041762 F5          4267  SAVLO2:			PUSH    AF              	; Save the type (string)
041763 D5          4268  			PUSH    DE
041764 D9          4269  			EXX
041765 E5          4270  			PUSH    HL
041766 D9          4271  			EXX
041767 CD B0 04 04 4272  			CALL    LOADS
04176B D9          4273  			EXX
04176C E1          4274  			POP     HL
04176D D9          4275  			EXX
04176E 01 00 00 00 4276  			LD	BC,0
041772 4B          4277  			LD      C,E			; BC: String length
041773 D1          4278  			POP     DE
041774 CD 8C 16 04 4279  			CALL    CHECK			; Check if there is space on the stack
041778 F1          4280  			POP     AF              	; Level stack
041779 21 00 00 00 4281  			LD      HL,0
04177D ED 42       4282  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
04177F 39          4283  			ADD     HL,SP			; Make space for the string on the stack
041780 F9          4284  			LD      SP,HL
041781 47          4285  			LD      B,A             	;  B: Variable type
041782 C5          4286  			PUSH    BC
041783 28 0A       4287  			JR      Z,SAVLO4
041785 D5          4288  			PUSH    DE
041786 11 00 4A 04 4289  			LD      DE,ACCS
04178A EB          4290  			EX      DE,HL
04178B 45          4291  			LD      B,L
04178C ED B0       4292  			LDIR                    	; Save the string onto the stack
04178E D1          4293  			POP     DE
04178F             4294  ;
04178F DD E5       4295  SAVLO4:			PUSH    IX			; VARPTR
041791 CD 95 17 04 4296  			CALL    SAVLO5
041795             4297  LOCCHK:			EQU     $
041795 CD 8C 16 04 4298  SAVLO5:			CALL    CHECK
041799 CD 83 0A 04 4299  			CALL    NXT
04179D FE 2C       4300  			CP      ','             	; Are there any more local variables?
04179F 28 97       4301  			JR      Z,SAVLO1		; Yes, so loop
0417A1 EB          4302  			EX      DE,HL			; DE -> HL: The return address
0417A2 E9          4303  			JP      (HL)            	; And effectvely return
0417A3             4304  ;
0417A3 FD 7E 00    4305  DELIM:			LD      A,(IY)          	; Assembler delimiter
0417A6 FE 20       4306  			CP      ' '
0417A8 C8          4307  			RET     Z
0417A9 FE 2C       4308  			CP      ','
0417AB C8          4309  			RET     Z
0417AC FE 29       4310  			CP      ')'
0417AE C8          4311  			RET     Z
0417AF FE 3B       4312  TERM:			CP      ';'             	; Assembler terminator
0417B1 C8          4313  			RET     Z
0417B2 FE 5C       4314  			CP      '\'
0417B4 C8          4315  			RET     Z
0417B5 18 07       4316  			JR      TERM0
0417B7             4317  ;
0417B7 CD 83 0A 04 4318  TERMQ:			CALL    NXT
0417BB FE 8B       4319  			CP      ELSE_
0417BD D0          4320  			RET     NC
0417BE FE 3A       4321  TERM0:			CP      ':'             	; Assembler seperator
0417C0 D0          4322  			RET     NC
0417C1 FE 0D       4323  			CP      CR
0417C3 C9          4324  			RET
0417C4             4325  ;
0417C4 CD B7 17 04 4326  SPAN:			CALL    TERMQ
0417C8 C8          4327  			RET     Z
0417C9 FD 23       4328  			INC     IY
0417CB 18 F7       4329  			JR      SPAN
0417CD             4330  ;
0417CD             4331  ; This snippet is used to check whether an expression is followed by an '=' symbol
0417CD             4332  ;
0417CD CD 83 0A 04 4333  EQUALS:			CALL    NXT			; Skip whitespace
0417D1 FD 23       4334  			INC     IY			; Skip past the character in question
0417D3 FE 3D       4335  			CP      '='			; Is it '='
0417D5 C8          4336  			RET     Z			; Yes, so return
0417D6 3E 04       4337  			LD      A,4			; Otherwise
0417D8 C3 C1 37 04 4338  			JP      ERROR_           	; Throw error "Mistake"
0417DC             4339  ;
0417DC FE 8A       4340  FORMAT:			CP      TAB
0417DE 28 0D       4341  			JR      Z,DOTAB
0417E0 FE 89       4342  			CP      SPC
0417E2 28 40       4343  			JR      Z,DOSPC
0417E4 FE 27       4344  			CP      '''
0417E6 C0          4345  			RET     NZ
0417E7 CD A8 39 04 4346  			CALL    CRLF
0417EB AF          4347  			XOR     A
0417EC C9          4348  			RET
0417ED             4349  ;
0417ED C5          4350  DOTAB:			PUSH    BC
0417EE CD 1A 03 04 4351  			CALL    EXPRI
0417F2 D9          4352  			EXX
0417F3 C1          4353  			POP     BC
0417F4 FD 7E 00    4354  			LD      A,(IY)
0417F7 FE 2C       4355  			CP      ','
0417F9 28 14       4356  			JR      Z,DOTAB1
0417FB CD 42 0A 04 4357  			CALL    BRAKET
0417FF 7D          4358  			LD      A,L
041800 21 3D 4D 04 4359  TABIT:			LD      HL,COUNT
041804 BE          4360  			CP      (HL)
041805 C8          4361  			RET     Z
041806 F5          4362  			PUSH    AF
041807 DC A8 39 04 4363  			CALL    C,CRLF
04180B F1          4364  			POP     AF
04180C 96          4365  			SUB     (HL)
04180D 18 1D       4366  			JR      FILL
04180F FD 23       4367  DOTAB1:			INC     IY
041811 C5          4368  			PUSH    BC
041812 E5          4369  			PUSH    HL
041813 CD 1A 03 04 4370  			CALL    EXPRI
041817 D9          4371  			EXX
041818 D1          4372  			POP     DE
041819 C1          4373  			POP     BC
04181A CD 42 0A 04 4374  			CALL    BRAKET
04181E CD 22 3F 04 4375  			CALL    PUTCSR
041822 AF          4376  			XOR     A
041823 C9          4377  			RET
041824             4378  ;
041824 C5          4379  DOSPC:			PUSH    BC
041825 CD 35 03 04 4380  			CALL    ITEMI
041829 D9          4381  			EXX
04182A 7D          4382  			LD      A,L
04182B C1          4383  			POP     BC
04182C B7          4384  FILL:			OR      A
04182D C8          4385  			RET     Z
04182E C5          4386  			PUSH    BC
04182F 47          4387  			LD      B,A
041830 3E 20       4388  FILL1:			LD      A,' '
041832 CD B0 39 04 4389  			CALL    OUTCHR
041836 10 F8       4390  			DJNZ    FILL1
041838 C1          4391  			POP     BC
041839 AF          4392  			XOR     A
04183A C9          4393  			RET
04183B             4394  ;
04183B 21 00 4A 04 4395  PTEXT:			LD      HL,ACCS
04183F 1C          4396  			INC     E
041840 1D          4397  PTEXT1:			DEC     E
041841 C8          4398  			RET     Z
041842 7E          4399  			LD      A,(HL)
041843 23          4400  			INC     HL
041844 CD B0 39 04 4401  			CALL    OUTCHR
041848 18 F6       4402  			JR      PTEXT1
04184A             4403  ;
04184A F5          4404  FETCHS:			PUSH    AF
04184B C5          4405  			PUSH    BC
04184C E5          4406  			PUSH    HL
04184D FD E3       4407  			EX      (SP),IY
04184F CD 6A 18 04 4408  			CALL    XTRACT
041853 CD 83 0A 04 4409  			CALL    NXT
041857 FD E3       4410  			EX      (SP),IY
041859 E1          4411  			POP     HL
04185A C1          4412  			POP     BC
04185B F1          4413  			POP     AF
04185C C9          4414  			RET
04185D             4415  ;
04185D 11 00 4A 04 4416  LINES:			LD      DE,ACCS
041861 7E          4417  LINE1S:			LD      A,(HL)
041862 12          4418  			LD      (DE),A
041863 FE 0D       4419  			CP      CR
041865 C8          4420  			RET     Z
041866 23          4421  			INC     HL
041867 1C          4422  			INC     E
041868 18 F7       4423  			JR      LINE1S
04186A             4424  ;
04186A CD 83 0A 04 4425  XTRACT:			CALL    NXT
04186E FE 22       4426  			CP      '"'
041870 FD 23       4427  			INC     IY
041872 CA 77 04 04 4428  			JP      Z,CONS
041876 FD 2B       4429  			DEC     IY
041878 11 00 4A 04 4430  			LD      DE,ACCS
04187C FD 7E 00    4431  XTRAC1:			LD      A,(IY)
04187F 12          4432  			LD      (DE),A
041880 FE 2C       4433  			CP      ','
041882 C8          4434  			RET     Z
041883 FE 0D       4435  			CP      CR
041885 C8          4436  			RET     Z
041886 FD 23       4437  			INC     IY
041888 1C          4438  			INC     E
041889 18 F1       4439  			JR      XTRAC1
04188B             4440  
04188B             4441  ; Search for a token at the start of a program line
04188B             4442  ; - HL: Pointer to the start of a tokenised line in the program area
04188B             4443  ; Returns:
04188B             4444  ; - HL: Pointer to the
04188B             4445  ; -  F: Carry set if not found
04188B             4446  ; Corrupts:
04188B             4447  ; - BC
04188B             4448  ;
04188B 01 00 00 00 4449  SEARCH_EX:			LD      BC,0			; Clear BC
04188F             4450  ;
04188F 4E          4451  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041890 0C          4452  			INC     C			; Check for 0, i.e. end of program marker
041891 0D          4453  			DEC     C
041892 28 0B       4454  			JR      Z,SRCH2_EX         	; Not found the token, so end
041894 23          4455  			INC     HL			; Skip the line length and line number
041895 23          4456  			INC     HL
041896 23          4457  			INC     HL
041897 BE          4458  			CP      (HL)			; Compare with the token
041898 C8          4459  			RET     Z			; Found it, so return with carry not set
041899 0D          4460  			DEC     C			; Skip to the next line
04189A 0D          4461  			DEC     C
04189B 0D          4462  			DEC     C
04189C 09          4463  			ADD     HL,BC
04189D 18 F0       4464  			JR      SRCH1_EX			; Rinse, lather and repeat
04189F             4465  ;
04189F 2B          4466  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0418A0 37          4467  			SCF				; And set the carry flag
0418A1 C9          4468  			RET
0418A2             4469  
0418A2             4470  ; Multiply by 4 or 5
0418A2             4471  ; This function is used to allocate space for dimensioned variables
0418A2             4472  ; This is a 24-bit operation
0418A2             4473  ; - DE: Number to multiple
0418A2             4474  ; -  A: 04h (Integer) - takes up 4 bytes
0418A2             4475  ;       05h (Float)   - takes up 5 bytes
0418A2             4476  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0418A2             4477  ; Returns:
0418A2             4478  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0418A2             4479  ; -  F: Carry if overflow
0418A2             4480  ; Corrupts:
0418A2             4481  ; - HL
0418A2 FE 04       4482  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0418A4             4483  			; LD	HL,DE
0418A4 D5          4484  			push de
0418A5 E1          4485  			pop hl
0418A6 29          4486  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0418A7 D8          4487  			RET     C			; Exit if overflow
0418A8 29          4488  			ADD     HL,HL			; Multiply by 2 again
0418A9 D8          4489  			RET     C			; Exit if overflow
0418AA EB          4490  			EX      DE,HL			; DE: Product
0418AB C8          4491  			RET     Z			; Exit if A = 4
0418AC 19          4492  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0418AD EB          4493  			EX      DE,HL			; DE: Product
0418AE C9          4494  			RET
0418AF             4495  
0418AF             4496  ; 16-bit unsigned multiply
0418AF             4497  ; - HL: Operand 1
0418AF             4498  ; - BC: Operand 2
0418AF             4499  ; Returns:
0418AF             4500  ; - HL: Result
0418AF             4501  ; -  F: C if overflow
0418AF             4502  ;
0418AF C5          4503  MUL16:			PUSH	BC
0418B0 51          4504  			LD	D, C			; Set up the registers for the multiplies
0418B1 5D          4505  			LD	E, L
0418B2 69          4506  			LD	L, C
0418B3 4B          4507  			LD	C, E
0418B4 ED 6C       4508  			MLT	HL			; HL = H * C (*256)
0418B6 ED 5C       4509  			MLT	DE			; DE = L * C
0418B8 ED 4C       4510  			MLT	BC			; BC = B * L (*256)
0418BA 09          4511  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418BB C1          4512  			POP	BC
0418BC AF          4513  			XOR	A
0418BD 9C          4514  			SBC	H			; If H is not zero then it's an overflow
0418BE D8          4515  			RET	C
0418BF 65          4516  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418C0 6F          4517  			LD	L, A
0418C1 19          4518  			ADD	HL, DE
0418C2 C9          4519  			RET
0418C3             4520  ;
0418C3 CD 83 0A 04 4521  CHANEL:			CALL    NXT			; Skip whitespace
0418C7 FE 23       4522  			CP      '#'			; Check for the '#' symbol
0418C9 3E 2D       4523  			LD      A,45
0418CB C2 C1 37 04 4524  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418CF FD 23       4525  CHNL:			INC     IY             		; Bump past the '#'
0418D1 CD 35 03 04 4526  			CALL    ITEMI			; Get the channel number
0418D5 D9          4527  			EXX
0418D6 EB          4528  			EX      DE,HL			; DE: The channel number
0418D7 C9          4529  			RET
0418D8             4530  
0418D8             4531  ; ASSEMBLER -------------------------------------------------------------------
0418D8             4532  
0418D8             4533  ; Language independant control section:
0418D8             4534  ;  Outputs: A=delimiter, carry set if syntax error.
0418D8             4535  ;
0418D8 CD F8 1D 04 4536  ASSEM:			CALL    SKIP
0418DC FD 23       4537  			INC     IY
0418DE FE 3A       4538  			CP      ':'
0418E0 28 F6       4539  			JR      Z,ASSEM
0418E2 FE 5D       4540  			CP      ']'
0418E4 C8          4541  			RET     Z
0418E5 FE 0D       4542  			CP      CR
0418E7 C8          4543  			RET     Z
0418E8 FD 2B       4544  			DEC     IY
0418EA DD 2A 40 4C 4545  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       04          
0418EF 21 40 4D 04 4546  			LD      HL,LISTON
0418F3 CB 76       4547  			BIT     6,(HL)
0418F5 28 05       4548  			JR      Z,ASSEM0
0418F7 DD 2A 3C 4C 4549  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       04          
0418FC DD E5       4550  ASSEM0:			PUSH    IX
0418FE FD E5       4551  			PUSH    IY
041900 CD B0 19 04 4552  			CALL    ASMB
041904 C1          4553  			POP     BC
041905 D1          4554  			POP     DE
041906 D8          4555  			RET     C
041907 CD F8 1D 04 4556  			CALL    SKIP
04190B 37          4557  			SCF
04190C C0          4558  			RET     NZ
04190D FD 2B       4559  			DEC     IY
04190F FD 23       4560  ASSEM3:			INC     IY
041911 FD 7E 00    4561  			LD      A,(IY)
041914 CD BE 17 04 4562  			CALL    TERM0
041918 20 F5       4563  			JR      NZ,ASSEM3
04191A 3A 40 4D 04 4564  			LD      A,(LISTON)
04191E DD E5       4565  			PUSH    IX
041920 E1          4566  			POP     HL
041921 B7          4567  			OR      A
041922 ED 52       4568  			SBC     HL,DE
041924 EB          4569  			EX      DE,HL           	; DE: Number of bytes
041925 E5          4570  			PUSH    HL
041926 2A 40 4C 04 4571  			LD      HL,(PC)
04192A E5          4572  			PUSH    HL
04192B 19          4573  			ADD     HL,DE
04192C 22 40 4C 04 4574  			LD      (PC),HL         	; Update PC
041930 CB 77       4575  			BIT     6,A
041932 28 09       4576  			JR      Z,ASSEM5
041934 2A 3C 4C 04 4577  			LD      HL,(OC)
041938 19          4578  			ADD     HL,DE
041939 22 3C 4C 04 4579  			LD      (OC),HL         	; Update OC
04193D E1          4580  ASSEM5:			POP     HL              	; Old PC
04193E DD E1       4581  			POP     IX              	; Code here
041940 CB 67       4582  			BIT     4,A
041942 28 94       4583  			JR      Z,ASSEM
041944 22 4A 4D 04 4584  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
041948 3A 4C 4D 04 4585  			LD	A,(R0+2)		; Print out the address
04194C CD 9A 19 04 4586  			CALL	HEX_EX
041950 7C          4587  			LD      A,H
041951 CD 9A 19 04 4588  			CALL    HEX_EX
041955 7D          4589  			LD      A,L
041956 CD 92 19 04 4590  			CALL    HEXSP
04195A AF          4591  			XOR     A
04195B BB          4592  			CP      E
04195C 28 18       4593  			JR      Z,ASSEM2
04195E             4594  ;
04195E 3A 3D 4D 04 4595  ASSEM1:			LD      A,(COUNT)
041962 FE 14       4596  			CP      20
041964 3E 07       4597  			LD      A,7
041966 D4 00 18 04 4598  			CALL    NC,TABIT        	; Next line
04196A DD 7E 00    4599  			LD      A,(IX)
04196D CD 92 19 04 4600  			CALL    HEXSP
041971 DD 23       4601  			INC     IX
041973 1D          4602  			DEC     E
041974 20 E8       4603  			JR      NZ,ASSEM1
041976             4604  ;
041976 3E 16       4605  ASSEM2:			LD      A,22			; Tab to the disassembly field
041978 CD 00 18 04 4606  			CALL    TABIT
04197C FD E5       4607  			PUSH    IY
04197E E1          4608  			POP     HL
04197F ED 42       4609  			SBC     HL,BC
041981 0A          4610  ASSEM4:			LD      A,(BC)
041982 CD CD 39 04 4611  			CALL    OUT_
041986 03          4612  			INC     BC
041987 2D          4613  			DEC     L
041988 20 F7       4614  			JR      NZ,ASSEM4
04198A CD A8 39 04 4615  			CALL    CRLF
04198E C3 D8 18 04 4616  			JP      ASSEM
041992             4617  ;
041992 CD 9A 19 04 4618  HEXSP:			CALL    HEX_EX
041996 3E 20       4619  			LD      A,' '
041998 18 12       4620  			JR      OUTCH1
04199A F5          4621  HEX_EX:			PUSH    AF
04199B 0F          4622  			RRCA
04199C 0F          4623  			RRCA
04199D 0F          4624  			RRCA
04199E 0F          4625  			RRCA
04199F CD A4 19 04 4626  			CALL    HEXOUT
0419A3 F1          4627  			POP     AF
0419A4 E6 0F       4628  HEXOUT:			AND     0FH
0419A6 C6 90       4629  			ADD     A,90H
0419A8 27          4630  			DAA
0419A9 CE 40       4631  			ADC     A,40H
0419AB 27          4632  			DAA
0419AC C3 CD 39 04 4633  OUTCH1:			JP      OUT_
0419B0             4634  
0419B0             4635  ; Processor Specific Translation Section:
0419B0             4636  ;
0419B0             4637  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0419B0             4638  ;                 C: Opcode beig built
0419B0             4639  ;                 D: Flags
0419B0             4640  ;			Bit 7: Set to 1 if the instruction uses long addressing
0419B0             4641  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0419B0             4642  ;                 E: Offset from IX or IY
0419B0             4643  ;                HL: Numeric operand value
0419B0             4644  ;                IX: Code destination pointer
0419B0             4645  ;                IY: Source text pointer
0419B0             4646  ;    Inputs: A = initial character
0419B0             4647  ;   Outputs: Carry set if syntax error.
0419B0             4648  ;
0419B0 FE 2E       4649  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0419B2 20 1F       4650  			JR      NZ,ASMB1		; No, so just process the instruction
0419B4 FD 23       4651  			INC     IY			; Skip past the dot to the label name
0419B6 DD E5       4652  			PUSH    IX			; Store the code destination pointer
0419B8 CD A1 0C 04 4653  			CALL    VAR_			; Create a variable
0419BC F5          4654  			PUSH    AF
0419BD CD A3 09 04 4655  			CALL    ZERO			; Zero it
0419C1 3A 42 4C 04 4656  			LD	A,(PC+2)
0419C5 6F          4657  			LD	L,A			; The MSB of the 24-bit address
0419C6 D9          4658  			EXX
0419C7 2A 40 4C 04 4659  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419CB D9          4660  			EXX
0419CC F1          4661  			POP     AF
0419CD CD 13 16 04 4662  			CALL    STORE			; Store the program counter
0419D1 DD E1       4663  			POP     IX			; Restore the code destination pointer
0419D3             4664  ;
0419D3 3A 40 4D 04 4665  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419D7 E6 80       4666  			AND	80H
0419D9 57          4667  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419DA CD F8 1D 04 4668  			CALL    SKIP			; Skip any whitespace
0419DE C8          4669  			RET     Z			; And return if there is nothing further to process
0419DF FE D6       4670  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419E1 0E C4       4671  			LD      C,0C4H			;  A: The base operand
0419E3 FD 23       4672  			INC     IY			; Skip past the token
0419E5 CA 2D 1B 04 4673  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419E9 FD 2B       4674  			DEC     IY			; Skip back, as we're not doing the above at this point
0419EB 21 0F 1E 04 4675  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419EF CD A7 1D 04 4676  			CALL    FIND			; Find the opcode
0419F3 D8          4677  			RET     C			; If not found, then return; carry indicates an error condition
0419F4 48          4678  			LD      C,B     		;  C: A copy of the opcode
0419F5             4679  ;
0419F5             4680  ; GROUP 0: Trivial cases requiring no computation
0419F5             4681  ; GROUP 1: As Group 0, but with "ED" prefix
0419F5             4682  ;
0419F5 D6 44       4683  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419F7 30 08       4684  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419F9 FE CB       4685  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419FB D4 00 1D 04 4686  			CALL    NC,ED			; Needs to be prefixed with ED
0419FF 18 76       4687  			JR      BYTE0			; Then write the opcode byte
041A01             4688  ;
041A01             4689  ; GROUP 2: BIT, RES, SET
041A01             4690  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
041A01             4691  ;
041A01 D6 0A       4692  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
041A03 30 12       4693  			JR      NC,GROUP04		; If not in that range, then check GROUP4
041A05 FE F9       4694  			CP      3-10			;
041A07 DC 95 1D 04 4695  			CALL    C,BIT_
041A0B D8          4696  			RET     C
041A0C CD 66 1D 04 4697  			CALL    REGLO
041A10 D8          4698  			RET     C
041A11 CD 04 1D 04 4699  			CALL    CB
041A15 18 60       4700  			JR      BYTE0
041A17             4701  ;
041A17             4702  ; GROUP 4 - PUSH, POP, EX (SP)
041A17             4703  ;
041A17 D6 03       4704  GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A19 30 07       4705  			JR      NC,GROUP05		; If not in that range, then check GROUP5
041A1B CD 88 1D 04 4706  GROUP04_1:		CALL    PAIR_EX
041A1F D8          4707  			RET     C
041A20 18 55       4708  			JR      BYTE0
041A22             4709  ;
041A22             4710  ; GROUP 5 - SUB, AND, XOR, OR, CP
041A22             4711  ; GROUP 6 - ADD, ADC, SBC
041A22             4712  ;
041A22 D6 0A       4713  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A24 30 39       4714  			JR      NC,GROUP07
041A26 FE FD       4715  			CP      5-8
041A28 06 07       4716  			LD      B,7
041A2A D4 14 1D 04 4717  			CALL    NC,OPND			; Get the first operand
041A2E 78          4718  			LD      A,B
041A2F FE 07       4719  			CP      7			; Is the operand 'A'?
041A31 20 15       4720  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A33             4721  ;
041A33 CD 66 1D 04 4722  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A37 79          4723  			LD      A,C
041A38 30 2E       4724  			JR      NC,BIND1		; If it is a register, then write that out
041A3A EE 46       4725  			XOR     46H			; Handle ADD A,n
041A3C CD 06 1D 04 4726  			CALL    BIND
041A40 CD 46 1D 04 4727  DB_:			CALL    NUMBER
041A44 C3 FF 1A 04 4728  			JP      VAL8
041A48             4729  ;
041A48 E6 3F       4730  GROUP05_HL:		AND     3FH
041A4A FE 0C       4731  			CP      12
041A4C 37          4732  			SCF
041A4D C0          4733  			RET     NZ
041A4E 79          4734  			LD      A,C
041A4F FE 80       4735  			CP      80H
041A51 0E 09       4736  			LD      C,9
041A53 28 C6       4737  			JR      Z,GROUP04_1
041A55 EE 1C       4738  			XOR     1CH
041A57 0F          4739  			RRCA
041A58 4F          4740  			LD      C,A
041A59 CD 00 1D 04 4741  			CALL    ED
041A5D 18 BC       4742  			JR      GROUP04_1
041A5F             4743  ;
041A5F             4744  ; GROUP 7 - INC, DEC
041A5F             4745  ;
041A5F D6 02       4746  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A61 30 19       4747  			JR      NC,GROUP08
041A63 CD 6D 1D 04 4748  			CALL    REGHI
041A67 79          4749  			LD      A,C
041A68 D2 06 1D 04 4750  BIND1:			JP      NC,BIND
041A6C EE 64       4751  			XOR     64H
041A6E 07          4752  			RLCA
041A6F 07          4753  			RLCA
041A70 07          4754  			RLCA
041A71 4F          4755  			LD      C,A
041A72 CD 8D 1D 04 4756  			CALL    PAIR1_EX
041A76 D8          4757  			RET     C
041A77 79          4758  BYTE0:			LD      A,C
041A78 C3 35 1D 04 4759  			JP      BYTE_
041A7C             4760  ;
041A7C             4761  ; Group 8: IN0, OUT0
041A7C             4762  ;
041A7C D6 02       4763  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A7E 30 2C       4764  			JR	NC,GROUP09
041A80 FE FF       4765  			CP	1-2
041A82 CC 46 1D 04 4766  			CALL    Z,NUMBER		; Fetch number first if OUT
041A86 08          4767  			EX      AF,AF'			; Save flags
041A87 CD 5A 1D 04 4768  			CALL    REG			; Get the register value regardless
041A8B D8          4769  			RET     C			; Return if not a register
041A8C 08          4770  			EX      AF,AF'			; Restore the flags
041A8D DC 46 1D 04 4771  			CALL    C,NUMBER		; Fetch number last if IN
041A91 78          4772  			LD	A,B			; Get the register number
041A92 FE 06       4773  			CP	6			; Fail on (HL)
041A94 37          4774  			SCF
041A95 C8          4775  			RET	Z
041A96 FE 08       4776  			CP	8			; Check it is just single pairs only
041A98 3F          4777  			CCF
041A99 D8          4778  			RET	C			; And return if it is an invalid register
041A9A 07          4779  			RLCA				; Bind with the operand
041A9B 07          4780  			RLCA
041A9C 07          4781  			RLCA
041A9D 81          4782  			ADD	A,C
041A9E 4F          4783  			LD	C,A
041A9F CD 00 1D 04 4784  			CALL	ED			; Prefix with ED
041AA3 79          4785  			LD	A,C
041AA4 CD 35 1D 04 4786  			CALL	BYTE_			; Write out the operand
041AA8 C3 FF 1A 04 4787  			JP	VAL8			; Write out the value
041AAC             4788  ;
041AAC             4789  ; GROUP 9 - IN
041AAC             4790  ; GROUP 10 - OUT
041AAC             4791  ;
041AAC D6 02       4792  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041AAE 30 25       4793  			JR      NC,GROUP11
041AB0 FE FF       4794  			CP      1-2			; Check if Group 9 or Group 1
041AB2 CC F4 1C 04 4795  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AB6 08          4796  			EX      AF,AF'			; Save flags
041AB7 CD 6D 1D 04 4797  			CALL    REGHI			; Get the register value regardless
041ABB D8          4798  			RET     C			; Return if not a register
041ABC 08          4799  			EX      AF,AF'			; Restore the flags
041ABD DC F4 1C 04 4800  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041AC1 24          4801  			INC     H			; If it is IN r,(C) or OUT (C),r then
041AC2 28 B3       4802  			JR      Z,BYTE0			; Just write the operand out
041AC4             4803  ;
041AC4 78          4804  			LD      A,B			; Check the register
041AC5 FE 07       4805  			CP      7
041AC7 37          4806  			SCF
041AC8 C0          4807  			RET     NZ			; If it is not A, then return
041AC9             4808  ;
041AC9 79          4809  			LD      A,C			; Bind the register with the operand
041ACA EE 03       4810  			XOR     3
041ACC 07          4811  			RLCA
041ACD 07          4812  			RLCA
041ACE 07          4813  			RLCA
041ACF CD 35 1D 04 4814  			CALL    BYTE_			; Write out the operand
041AD3 18 2A       4815  			JR      VAL8			; And the value
041AD5             4816  ;
041AD5             4817  ; GROUP 11 - JR, DJNZ
041AD5             4818  ;
041AD5 D6 02       4819  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041AD7 30 2B       4820  			JR      NC,GROUP12
041AD9 FE FF       4821  			CP      1-2
041ADB C4 74 1D 04 4822  			CALL    NZ,COND_
041ADF 79          4823  			LD      A,C
041AE0 30 02       4824  			JR      NC,@F
041AE2 3E 18       4825  			LD      A,18H
041AE4 CD 35 1D 04 4826  @@:			CALL    BYTE_
041AE8 CD 46 1D 04 4827  			CALL    NUMBER
041AEC ED 5B 40 4C 4828  			LD      DE,(PC)
       04          
041AF1 13          4829  			INC     DE
041AF2 37          4830  			SCF
041AF3 ED 52       4831  			SBC     HL,DE
041AF5 7D          4832  			LD      A,L
041AF6 17          4833  			RLA
041AF7 9F          4834  			SBC     A,A
041AF8 BC          4835  			CP      H
041AF9 3E 01       4836  TOOFAR:			LD      A,1
041AFB C2 C1 37 04 4837  			JP      NZ,ERROR_		; Throw an "Out of range" error
041AFF 7D          4838  VAL8:			LD      A,L
041B00 C3 35 1D 04 4839  			JP      BYTE_
041B04             4840  ;
041B04             4841  ; GROUP 12 - JP
041B04             4842  ;
041B04 D6 01       4843  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041B06 30 21       4844  			JR	NC,GROUP13
041B08 CD 5A 1C 04 4845  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041B0C D8          4846  			RET	C			; Exit if an invalid suffix is provided
041B0D CD 74 1D 04 4847  			CALL    COND_			; Evaluate the conditions
041B11 79          4848  			LD      A,C
041B12 30 0D       4849  			JR      NC,GROUP12_1
041B14 78          4850  			LD      A,B
041B15 E6 3F       4851  			AND     3FH
041B17 FE 06       4852  			CP      6
041B19 3E E9       4853  			LD      A,0E9H
041B1B CA 35 1D 04 4854  			JP      Z,BYTE_
041B1F 3E C3       4855  			LD      A,0C3H
041B21 CD 35 1D 04 4856  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B25 C3 AF 1C 04 4857  			JP	ADDR_			; Output the address
041B29             4858  ;
041B29             4859  ; GROUP 13 - CALL
041B29             4860  ;
041B29 D6 01       4861  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B2B 30 0C       4862  			JR	NC,GROUP14
041B2D CD 72 1C 04 4863  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B31 CD 54 1B 04 4864  			CALL    GROUP15_1		; Output the opcode (with conditions)
041B35 C3 AF 1C 04 4865  			JP	ADDR_			; Output the address
041B39             4866  ;
041B39             4867  ; GROUP 14 - RST
041B39             4868  ;
041B39 D6 01       4869  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B3B 30 13       4870  			JR	NC,GROUP15
041B3D CD 72 1C 04 4871  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B41 D8          4872  			RET	C			; Exit if an invalid suffix provided
041B42 CD 46 1D 04 4873  			CALL    NUMBER
041B46 A1          4874  			AND     C
041B47 B4          4875  			OR      H
041B48 20 AF       4876  			JR      NZ,TOOFAR
041B4A 7D          4877  			LD      A,L
041B4B B1          4878  			OR      C
041B4C C3 35 1D 04 4879  	  		JP      BYTE_
041B50             4880  ;
041B50             4881  ; GROUP 15 - RET
041B50             4882  ;
041B50 D6 01       4883  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B52 30 0F       4884  			JR	NC,GROUP16
041B54 CD 74 1D 04 4885  GROUP15_1:		CALL    COND_
041B58 79          4886  			LD      A,C
041B59 D2 35 1D 04 4887  			JP      NC,BYTE_
041B5D F6 09       4888  			OR      9
041B5F C3 35 1D 04 4889  			JP      BYTE_
041B63             4890  ;
041B63             4891  ; GROUP 16 - LD
041B63             4892  ;
041B63 D6 01       4893  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B65 30 74       4894  			JR	NC,GROUP17
041B67 CD 72 1C 04 4895  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B6B CD A3 1D 04 4896  			CALL    LDOP			; Check for accumulator loads
041B6F D2 CF 1C 04 4897  			JP      NC,LDA			; Yes, so jump here
041B73 CD 6D 1D 04 4898  			CALL    REGHI
041B77 08          4899  			EX      AF,AF'
041B78 CD F8 1D 04 4900  			CALL    SKIP
041B7C FE 28       4901  			CP      '('			; Check for bracket
041B7E 28 24       4902  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B80 08          4903  			EX      AF,AF'
041B81 D2 33 1A 04 4904  			JP      NC,GROUP05_1		; Load single register direct; go here
041B85 0E 01       4905  			LD      C,1
041B87 CD 8D 1D 04 4906  			CALL    PAIR1_EX
041B8B D8          4907  			RET     C
041B8C 3E 0E       4908  			LD      A,14
041B8E B8          4909  			CP      B
041B8F 47          4910  			LD      B,A
041B90 CC 88 1D 04 4911  			CALL    Z,PAIR_EX
041B94 78          4912  			LD      A,B
041B95 E6 3F       4913  			AND     3FH
041B97 FE 0C       4914  			CP      12
041B99 79          4915  			LD      A,C
041B9A C2 21 1B 04 4916  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B9E 3E F9       4917  			LD      A,0F9H
041BA0 C3 35 1D 04 4918  			JP      BYTE_
041BA4             4919  ;
041BA4 08          4920  LDIN:			EX      AF,AF'
041BA5 C5          4921  			PUSH    BC
041BA6 D4 66 1D 04 4922  			CALL    NC,REGLO
041BAA 79          4923  			LD      A,C
041BAB C1          4924  			POP     BC
041BAC D2 06 1D 04 4925  			JP      NC,BIND
041BB0 0E 0A       4926  			LD      C,0AH
041BB2 CD 8D 1D 04 4927  			CALL    PAIR1_EX
041BB6 CD DA 1C 04 4928  			CALL    LD16
041BBA D2 21 1B 04 4929  			JP      NC,GROUP12_1
041BBE CD 46 1D 04 4930  			CALL    NUMBER
041BC2 0E 02       4931  			LD      C,2
041BC4 CD 88 1D 04 4932  			CALL    PAIR_EX
041BC8 CD DA 1C 04 4933  			CALL    LD16
041BCC D8          4934  			RET     C
041BCD CD 35 1D 04 4935  			CALL    BYTE_
041BD1 CB 7A       4936  			BIT	7,D			; Check the ADL flag
041BD3 C2 C4 1C 04 4937  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BD7 C3 B7 1C 04 4938  			JP      VAL16			; Otherwise use 16-bit addresses
041BDB             4939  ;
041BDB             4940  ; Group 17 - TST
041BDB             4941  ;
041BDB D6 01       4942  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BDD 30 25       4943  			JR	NC,OPTS
041BDF CD 00 1D 04 4944  			CALL	ED			; Needs to be prefixed with ED
041BE3 CD 5A 1D 04 4945  			CALL	REG			; Fetch the register
041BE7 30 0E       4946  			JR	NC,GROUP17_1		; It's just a register
041BE9             4947  ;
041BE9 3E 64       4948  			LD	A,64H			; Opcode for TST n
041BEB CD 35 1D 04 4949  			CALL	BYTE_			; Write out the opcode
041BEF CD 46 1D 04 4950  			CALL	NUMBER			; Get the number
041BF3 C3 FF 1A 04 4951  			JP	VAL8			; And write that out
041BF7             4952  ;
041BF7 78          4953  GROUP17_1:		LD	A,B			; Check the register rangs
041BF8 FE 08       4954  			CP	8
041BFA 3F          4955  			CCF
041BFB D8          4956  			RET	C			; Ret with carry flag set for error if out of range
041BFC 07          4957  			RLCA				; Get the opcode value
041BFD 07          4958  			RLCA
041BFE 07          4959  			RLCA
041BFF 81          4960  			ADD	A,C			; Add the opcode base in
041C00 C3 35 1D 04 4961  			JP	BYTE_
041C04             4962  
041C04             4963  ;
041C04             4964  ; Assembler directives - OPT, ADL
041C04             4965  ;
041C04 D6 02       4966  OPTS:			SUB	2
041C06 30 2B       4967  			JR	NC, DEFS
041C08 FE FF       4968  			CP	1-2			; Check for ADL opcode
041C0A 28 13       4969  			JR	Z, ADL_
041C0C             4970  ;
041C0C CD 46 1D 04 4971  OPT:			CALL    NUMBER			; Fetch the OPT value
041C10 21 40 4D 04 4972  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041C14 E6 07       4973  			AND	7			; Only interested in the first three bits
041C16 4F          4974  			LD      C,A			; Store the new OPT value in C
041C17 ED 6F       4975  			RLD				; Shift the top nibble of LISTON (OPT) into A
041C19 E6 08       4976  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041C1B B1          4977  			OR	C			; OR in the new value
041C1C ED 67       4978  			RRD				; And shift the nibble back in
041C1E C9          4979  			RET
041C1F             4980  ;
041C1F CD 46 1D 04 4981  ADL_:			CALL	NUMBER			; Fetch the ADL value
041C23 E6 01       4982  			AND	1			; Only interested if it is 0 or 1
041C25 0F          4983  			RRCA				; Rotate to bit 7
041C26 4F          4984  			LD	C,A			; Store in C
041C27 3A 40 4D 04 4985  			LD	A,(LISTON)		; Get the LISTON system variable
041C2B E6 7F       4986  			AND	7Fh			; Clear bit 7
041C2D B1          4987  			OR	C			; OR in the ADL value
041C2E 32 40 4D 04 4988  			LD	(LISTON),A		; Store
041C32 C9          4989  			RET
041C33             4990  ;
041C33             4991  ; DEFB, DEFW, DEFL, DEFM
041C33             4992  ;
041C33 B7          4993  DEFS:			OR	A			; Handle DEFB
041C34 CA 40 1A 04 4994  			JP	Z, DB_
041C38 3D          4995  			DEC	A			; Handle DEFW
041C39 CA B3 1C 04 4996  			JP	Z, ADDR16
041C3D 3D          4997  			DEC	A			; Handle DEFL
041C3E CA C0 1C 04 4998  			JP	Z, ADDR24
041C42             4999  ;
041C42 DD E5       5000  			PUSH    IX			; Handle DEFM
041C44 CD 25 03 04 5001  			CALL    EXPRS
041C48 DD E1       5002  			POP     IX
041C4A 21 00 4A 04 5003  			LD      HL,ACCS
041C4E AF          5004  @@:			XOR     A
041C4F BB          5005  			CP      E
041C50 C8          5006  			RET     Z
041C51 7E          5007  			LD      A,(HL)
041C52 23          5008  			INC     HL
041C53 CD 35 1D 04 5009  			CALL    BYTE_
041C57 1D          5010  			DEC     E
041C58 18 F4       5011  			JR      @B
041C5A             5012  
041C5A             5013  ;
041C5A             5014  ;SUBROUTINES:
041C5A             5015  ;
041C5A FD 7E 00    5016  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C5D FE 2E       5017  			CP	'.'
041C5F 28 02       5018  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C61 B7          5019  			OR	A			; Reset the carry flag (no error)
041C62 C9          5020  			RET				; And return
041C63 FD 23       5021  @@:			INC	IY			; Skip the dot
041C65 C5          5022  			PUSH	BC			; Push the operand
041C66 21 8E 20 04 5023  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C6A CD A7 1D 04 5024  			CALL	FIND			; Look up the operand
041C6E 30 24       5025  			JR	NC,EZ80SF_OK
041C70 C1          5026  			POP	BC			; Not found at this point, so will return with a C (error)
041C71 C9          5027  			RET
041C72             5028  ;
041C72 FD 7E 00    5029  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C75 FE 2E       5030  			CP	'.'
041C77 28 02       5031  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C79 B7          5032  			OR	A			; Reset the carry flag (no error)
041C7A C9          5033  			RET				; And return
041C7B FD 23       5034  @@:			INC	IY 			; Skip the dot
041C7D C5          5035  			PUSH	BC			; Push the operand
041C7E 21 86 20 04 5036  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C82 CD A7 1D 04 5037  			CALL	FIND 			; Look up the operand
041C86 30 0C       5038  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C88 CD A3 1C 04 5039  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C8C CD A7 1D 04 5040  			CALL	FIND
041C90 30 02       5041  			JR	NC,EZ80SF_OK
041C92 C1          5042  			POP	BC			; Not found at this point, so will return with a C (error)
041C93 C9          5043  			RET
041C94             5044  ;
041C94 78          5045  EZ80SF_OK:		LD	A,B			; The operand value
041C95 D4 35 1D 04 5046  			CALL	NC,BYTE_ 		; Write it out if found
041C99 CB BA       5047  			RES	7,D			; Clear the default ADL mode from the flags
041C9B E6 02       5048  			AND	2			; Check the second half of the suffix (.xxL)
041C9D 0F          5049  			RRCA				; Shift into bit 7
041C9E 0F          5050  			RRCA
041C9F B2          5051  			OR	D			; Or into bit 7 of D
041CA0 57          5052  			LD	D,A
041CA1 C1          5053  			POP	BC 			; Restore the operand
041CA2 C9          5054  			RET
041CA3             5055  ;
041CA3 21 97 20 04 5056  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041CA7 CB 7A       5057  			BIT 	7,D			; if bit 7 of D is 0
041CA9 C8          5058  			RET	Z
041CAA 21 A2 20 04 5059  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041CAE C9          5060  			RET
041CAF             5061  ;
041CAF CB 7A       5062  ADDR_:			BIT	7,D			; Check the ADL flag
041CB1 20 0D       5063  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CB3             5064  ;
041CB3 CD 46 1D 04 5065  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CB7 CD FF 1A 04 5066  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CBB 7C          5067  			LD      A,H
041CBC C3 35 1D 04 5068  			JP      BYTE_
041CC0             5069  ;
041CC0 CD 46 1D 04 5070  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CC4 CD B7 1C 04 5071  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CC8 D9          5072  			EXX
041CC9 7D          5073  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CCA D9          5074  			EXX
041CCB C3 35 1D 04 5075  			JP	BYTE_
041CCF             5076  ;
041CCF FE 04       5077  LDA:			CP      4
041CD1 DC 00 1D 04 5078  			CALL    C,ED
041CD5 78          5079  			LD      A,B
041CD6 C3 35 1D 04 5080  			JP      BYTE_
041CDA             5081  ;
041CDA 78          5082  LD16:			LD      A,B
041CDB 38 0F       5083  			JR      C,LD8
041CDD 78          5084  			LD      A,B
041CDE E6 3F       5085  			AND     3FH
041CE0 FE 0C       5086  			CP      12
041CE2 79          5087  			LD      A,C
041CE3 C8          5088  			RET     Z
041CE4 CD 00 1D 04 5089  			CALL    ED
041CE8 79          5090  			LD      A,C
041CE9 F6 43       5091  			OR      43H
041CEB C9          5092  			RET
041CEC             5093  ;
041CEC FE 07       5094  LD8:			CP      7
041CEE 37          5095  			SCF
041CEF C0          5096  			RET     NZ
041CF0 79          5097  			LD      A,C
041CF1 F6 30       5098  			OR      30H
041CF3 C9          5099  			RET
041CF4             5100  ;
041CF4             5101  ; Used in IN and OUT to handle whether the operand is C or a number
041CF4             5102  ;
041CF4 C5          5103  CORN:			PUSH    BC
041CF5 CD 14 1D 04 5104  			CALL    OPND			; Get the operand
041CF9 CB 68       5105  			BIT     5,B
041CFB C1          5106  			POP     BC
041CFC 28 48       5107  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CFE 26 FF       5108  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041D00             5109  ;
041D00 3E ED       5110  ED:			LD      A,0EDH			; Write an ED prefix out
041D02 18 31       5111  			JR      BYTE_
041D04             5112  ;
041D04 3E CB       5113  CB:			LD      A,0CBH
041D06 FE 76       5114  BIND:			CP      76H
041D08 37          5115  			SCF
041D09 C8          5116  			RET     Z               	; Reject LD (HL),(HL)
041D0A CD 35 1D 04 5117  			CALL    BYTE_
041D0E CB 72       5118  			BIT	6,D			; Check the index bit in flags
041D10 C8          5119  			RET     Z
041D11 7B          5120  			LD      A,E			; If there is an index, output the offset
041D12 18 21       5121  			JR      BYTE_
041D14             5122  ;
041D14             5123  ; Search through the operand table
041D14             5124  ; Returns:
041D14             5125  ; - B: The operand type
041D14             5126  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041D14             5127  ; - E: The IX/IY offset
041D14             5128  ; - F: Carry if not found
041D14             5129  ;
041D14 E5          5130  OPND:			PUSH    HL			; Preserve HL
041D15 21 18 20 04 5131  			LD      HL,OPRNDS		; The operands table
041D19 CD A7 1D 04 5132  			CALL    FIND			; Find the operand
041D1D E1          5133  			POP     HL
041D1E D8          5134  			RET     C			; Return if not found
041D1F CB 78       5135  			BIT     7,B			; Check if it is an index register (IX, IY)
041D21 C8          5136  			RET     Z			; Return if it isn't
041D22 CB F2       5137  			SET	6,D			; Set flag to indicate we've got an index
041D24 CB 58       5138  			BIT     3,B			; Check if an offset is required
041D26 E5          5139  			PUSH    HL
041D27 CC 3C 1D 04 5140  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D2B 5D          5141  			LD      E,L			; E: The offset
041D2C E1          5142  			POP     HL
041D2D 3E DD       5143  			LD	A,DDH			; IX prefix
041D2F CB 70       5144  			BIT     6,B			; If bit 6 is reset then
041D31 28 02       5145  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D33 3E FD       5146  			LD	A,FDH			; IY prefix
041D35             5147  ;
041D35 DD 77 00    5148  BYTE_:			LD      (IX),A			; Write a byte out
041D38 DD 23       5149  			INC     IX
041D3A B7          5150  			OR      A
041D3B C9          5151  			RET
041D3C             5152  ;
041D3C FD 7E 00    5153  OFFSET_EX:			LD      A,(IY)
041D3F FE 29       5154  			CP      ')'
041D41 21 00 00 00 5155  			LD      HL,0
041D45 C8          5156  			RET     Z
041D46 CD F8 1D 04 5157  NUMBER:			CALL    SKIP
041D4A C5          5158  			PUSH    BC
041D4B D5          5159  			PUSH    DE
041D4C DD E5       5160  			PUSH    IX
041D4E CD 1A 03 04 5161  			CALL    EXPRI
041D52 DD E1       5162  			POP     IX
041D54 D9          5163  			EXX
041D55 D1          5164  			POP     DE
041D56 C1          5165  			POP     BC
041D57 7D          5166  			LD      A,L
041D58 B7          5167  			OR      A
041D59 C9          5168  			RET
041D5A             5169  ;
041D5A CD 14 1D 04 5170  REG:			CALL    OPND
041D5E D8          5171  			RET     C
041D5F 78          5172  			LD      A,B
041D60 E6 3F       5173  			AND     3FH
041D62 FE 08       5174  			CP      8
041D64 3F          5175  			CCF
041D65 C9          5176  			RET
041D66             5177  ;
041D66 CD 5A 1D 04 5178  REGLO:			CALL    REG
041D6A D8          5179  			RET     C
041D6B 18 33       5180  			JR      ORC
041D6D             5181  ;
041D6D CD 5A 1D 04 5182  REGHI:			CALL    REG
041D71 D8          5183  			RET     C
041D72 18 29       5184  			JR      SHL3
041D74             5185  ;
041D74 CD 14 1D 04 5186  COND_:			CALL    OPND
041D78 D8          5187  			RET     C
041D79 78          5188  			LD      A,B
041D7A E6 1F       5189  			AND     1FH
041D7C D6 10       5190  			SUB     16
041D7E 30 1D       5191  			JR      NC,SHL3
041D80 FE F1       5192  			CP      -15
041D82 37          5193  			SCF
041D83 C0          5194  			RET     NZ
041D84 3E 03       5195  			LD      A,3
041D86 18 15       5196  			JR      SHL3
041D88             5197  ;
041D88 CD 14 1D 04 5198  PAIR_EX:			CALL    OPND
041D8C D8          5199  			RET     C
041D8D 78          5200  PAIR1_EX:			LD      A,B
041D8E E6 0F       5201  			AND     0FH
041D90 D6 08       5202  			SUB     8
041D92 D8          5203  			RET     C
041D93 18 08       5204  			JR      SHL3
041D95             5205  ;
041D95 CD 46 1D 04 5206  BIT_:			CALL    NUMBER
041D99 FE 08       5207  			CP      8
041D9B 3F          5208  			CCF
041D9C D8          5209  			RET     C
041D9D 07          5210  SHL3:			RLCA
041D9E 07          5211  			RLCA
041D9F 07          5212  			RLCA
041DA0 B1          5213  ORC:			OR      C
041DA1 4F          5214  			LD      C,A
041DA2 C9          5215  			RET
041DA3             5216  ;
041DA3 21 5D 20 04 5217  LDOP:			LD      HL,LDOPS
041DA7             5218  
041DA7             5219  ;
041DA7             5220  ; Look up a value in a table
041DA7             5221  ; Parameters:
041DA7             5222  ; - IY: Address of the assembly language line in the BASIC program area
041DA7             5223  ; - HL: Address of the table
041DA7             5224  ; Returns:
041DA7             5225  ; - B: The operand code
041DA7             5226  ; - F: Carry set if not found
041DA7             5227  ;
041DA7 CD F8 1D 04 5228  FIND:			CALL    SKIP			; Skip delimiters
041DAB             5229  ;
041DAB 06 00       5230  EXIT_:			LD      B,0			; Set B to 0
041DAD 37          5231  			SCF				; Set the carry flag
041DAE C8          5232  			RET     Z			; Returns if Z
041DAF             5233  ;
041DAF FE DD       5234  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041DB1 28 04       5235  			JR      Z,FIND0
041DB3 FE 85       5236  			CP      TOR+1			; Special case for tokens AND and OR
041DB5 3F          5237  			CCF
041DB6 D8          5238  			RET     C
041DB7 7E          5239  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DB8 B7          5240  			OR      A
041DB9 28 F0       5241  			JR      Z,EXIT_			; Exit
041DBB FD AE 00    5242  			XOR     (IY)
041DBE E6 5F       5243  			AND     01011111B
041DC0 28 09       5244  			JR      Z,FIND2
041DC2 CB 7E       5245  FIND1:			BIT     7,(HL)
041DC4 23          5246  			INC     HL
041DC5 28 FB       5247  			JR      Z,FIND1
041DC7 23          5248  			INC     HL
041DC8 04          5249  			INC     B
041DC9 18 EC       5250  			JR      FIND0
041DCB             5251  ;
041DCB FD E5       5252  FIND2:			PUSH    IY
041DCD CB 7E       5253  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DCF FD 23       5254  			INC     IY
041DD1 23          5255  			INC     HL
041DD2 20 11       5256  			JR      NZ,FIND5		; Yes
041DD4 BE          5257  			CP      (HL)
041DD5 CC F7 1D 04 5258  			CALL    Z,SKIP0
041DD9 7E          5259  			LD      A,(HL)
041DDA FD AE 00    5260  			XOR     (IY)
041DDD E6 5F       5261  			AND     01011111B
041DDF 28 EC       5262  			JR      Z,FIND3
041DE1 FD E1       5263  FIND4:			POP     IY
041DE3 18 DD       5264  			JR      FIND1
041DE5             5265  ;
041DE5 CD A3 17 04 5266  FIND5:			CALL    DELIM			; Is it a delimiter?
041DE9 C4 0C 1E 04 5267  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DED C4 06 1E 04 5268  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DF1 20 EE       5269  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DF3             5270  ;
041DF3 78          5271  FIND6:			LD      A,B			; At this point we have a token
041DF4 46          5272  			LD      B,(HL)			; Fetch the token type code
041DF5 E1          5273  			POP     HL			; Restore the stack
041DF6 C9          5274  			RET
041DF7             5275  ;
041DF7 23          5276  SKIP0:			INC     HL
041DF8 CD A3 17 04 5277  SKIP:			CALL    DELIM			; Is it a delimiter?
041DFC C0          5278  			RET     NZ			; No, so return
041DFD CD AF 17 04 5279  			CALL    TERM			; Is it a terminator?
041E01 C8          5280  			RET     Z			; Yes, so return
041E02 FD 23       5281  			INC     IY			; Increment the basic program counter
041E04 18 F2       5282  			JR      SKIP			; And loop
041E06             5283  ;
041E06 FE 2B       5284  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041E08 C8          5285  			RET     Z
041E09 FE 2D       5286  			CP      '-'
041E0B C9          5287  			RET
041E0C             5288  ;
041E0C FE 2E       5289  DOT:			CP	'.'			; Check if it is a dot character
041E0E C9          5290  			RET
041E0F             5291  ; Z80 opcode list
041E0F             5292  ;
041E0F             5293  ; Group 0: (15 opcodes)
041E0F             5294  ; Trivial cases requiring no computation
041E0F             5295  ;
041E0F 4E 4F 50 00 5296  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E13 52 4C 43 41 5297  			DB	"RLC","A"+80H,07h
       07          
041E18 45 58 00 41 5298  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041E22 52 52 43 41 5299  			DB	"RRC","A"+80H,0FH
       0F          
041E27 52 4C 41 17 5300  			DB	"RL","A"+80H,17H
041E2B 52 52 41 1F 5301  			DB	"RR","A"+80H,1FH
041E2F 44 41 41 27 5302  			DB	"DA","A"+80H,27H
041E33 43 50 4C 2F 5303  			DB	"CP","L"+80H,2FH
041E37 53 43 46 37 5304  			DB	"SC","F"+80H,37H
041E3B 43 43 46 3F 5305  			DB	"CC","F"+80H,3FH
041E3F 48 41 4C 54 5306  			DB	"HAL","T"+80H,76H
       76          
041E44 45 58 58 D9 5307  			DB	"EX","X"+80H,D9H
041E48 45 58 00 44 5308  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
041E51 44 49 F3    5309  			DB	"D","I"+80H,F3H
041E54 45 49 FB    5310  			DB	"E","I"+80H,FBH
041E57             5311  ;
041E57             5312  ; Group 1: (53 opcodes)
041E57             5313  ; As Group 0, but with an ED prefix
041E57             5314  ;
041E57 4E 45 47 44 5315  			DB	"NE","G"+80H,44H	; 0Fh
041E5B 49 4D 00 30 5316  			DB	"IM",0,"0"+80H,46H
       46          
041E60 52 45 54 4E 5317  			DB	"RET","N"+80H,45H
       45          
041E65 4D 4C 54 00 5318  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
041E6C 52 45 54 49 5319  			DB	"RET","I"+80H,4DH
       4D          
041E71 49 4D 00 31 5320  			DB	"IM",0,"1"+80H,56H
       56          
041E76 4D 4C 54 00 5321  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
041E7D 49 4D 00 32 5322  			DB	"IM",0,"2"+80H,5EH
       5E          
041E82 52 52 44 67 5323  			DB	"RR","D"+80H,67H
041E86 4D 4C 54 00 5324  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
041E8D 4C 44 00 4D 5325  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
041E95 4C 44 00 41 5326  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
041E9D 52 4C 44 6F 5327  			DB	"RL","D"+80H,6FH
041EA1 53 4C 50 76 5328  			DB	"SL","P"+80H,76H
041EA5 4D 4C 54 00 5329  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041EAC 53 54 4D 49 5330  			DB	"STMI","X"+80H,7DH
       58 7D       
041EB2 52 53 4D 49 5331  			DB	"RSMI","X"+80H,7EH
       58 7E       
041EB8 49 4E 49 4D 5332  			DB	"INI","M"+80H,82H
       82          
041EBD 4F 54 49 4D 5333  			DB	"OTI","M"+80H,83H
       83          
041EC2 49 4E 49 32 5334  			DB	"INI","2"+80H,84H
       84          
041EC7 49 4E 44 4D 5335  			DB	"IND","M"+80H,8AH
       8A          
041ECC 4F 54 44 4D 5336  			DB	"OTD","M"+80H,8BH
       8B          
041ED1 49 4E 44 32 5337  			DB	"IND","2"+80H,8CH
       8C          
041ED6 49 4E 49 4D 5338  			DB	"INIM","R"+80H,92H
       52 92       
041EDC 4F 54 49 4D 5339  			DB	"OTIM","R"+80H,93H
       52 93       
041EE2 49 4E 49 32 5340  			DB	"INI2","R"+80H,94H
       52 94       
041EE8 49 4E 44 4D 5341  			DB	"INDM","R"+80H,9AH
       52 9A       
041EEE 4F 54 44 4D 5342  			DB	"OTDM","R"+80H,9BH
       52 9B       
041EF4 49 4E 44 32 5343  			DB	"IND2","R"+80H,9CH
       52 9C       
041EFA 4C 44 49 A0 5344  			DB	"LD","I"+80H,A0H
041EFE 43 50 49 A1 5345  			DB	"CP","I"+80H,A1H
041F02 49 4E 49 A2 5346  			DB	"IN","I"+80H,A2H
041F06 4F 55 54 49 5347  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041F0C 4F 55 54 49 5348  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041F11 4C 44 44 A8 5349  			DB	"LD","D"+80H,A8H
041F15 43 50 44 A9 5350  			DB	"CP","D"+80H,A9H
041F19 49 4E 44 AA 5351  			DB	"IN","D"+80H,AAH
041F1D 4F 55 54 44 5352  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041F23 4F 55 54 44 5353  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
041F28 4C 44 49 52 5354  			DB	"LDI","R"+80H,B0H
       B0          
041F2D 43 50 49 52 5355  			DB	"CPI","R"+80H,B1H
       B1          
041F32 49 4E 49 52 5356  			DB	"INI","R"+80H,B2H
       B2          
041F37 4F 54 49 52 5357  			DB	"OTI","R"+80H,B3H
       B3          
041F3C 4F 54 49 32 5358  			DB	"OTI2","R"+80H,B4H
       52 B4       
041F42 4C 44 44 52 5359  			DB	"LDD","R"+80H,B8H
       B8          
041F47 43 50 44 52 5360  			DB	"CPD","R"+80H,B9H
       B9          
041F4C 49 4E 44 52 5361  			DB	"IND","R"+80H,BAH
       BA          
041F51 4F 54 44 52 5362  			DB	"OTD","R"+80H,BBH
       BB          
041F56 4F 54 44 32 5363  			DB	"OTD2","R"+80H,BCH
       52 BC       
041F5C 49 4E 49 52 5364  			DB	"INIR","X"+80H,C2H
       58 C2       
041F62 4F 54 49 52 5365  			DB	"OTIR","X"+80H,C3H
       58 C3       
041F68 49 4E 44 52 5366  			DB	"INDR","X"+80H,CAH
       58 CA       
041F6E 4F 54 44 52 5367  			DB	"OTDR","X"+80H,CBH
       58 CB       
041F74             5368  ;
041F74             5369  ; Group 2: (3 opcodes)
041F74             5370  ;
041F74 42 49 54 40 5371  			DB	"BI","T"+80H,40H	; 44h
041F78 52 45 53 80 5372  			DB	"RE","S"+80H,80H
041F7C 53 45 54 C0 5373  			DB	"SE","T"+80H,C0H
041F80             5374  ;
041F80             5375  ; Group 3: (7 opcodes)
041F80             5376  ;
041F80 52 4C 43 00 5377  			DB	"RL","C"+80H,00H	; 47h
041F84 52 52 43 08 5378  			DB	"RR","C"+80H,08H
041F88 52 4C 10    5379  			DB	"R","L"+80H,10H
041F8B 52 52 18    5380  			DB	"R","R"+80H,18H
041F8E 53 4C 41 20 5381  			DB	"SL","A"+80H,20H
041F92 53 52 41 28 5382  			DB	"SR","A"+80H,28H
041F96 53 52 4C 38 5383  			DB	"SR","L"+80H,38H
041F9A             5384  ;
041F9A             5385  ; Group 4: (3 opcodes)
041F9A             5386  ;
041F9A 50 4F 50 C1 5387  			DB	"PO","P"+80H,C1H	; 4Eh
041F9E 50 55 53 48 5388  			DB	"PUS","H"+80H,C5H
       C5          
041FA3 45 58 00 28 5389  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
041FAA             5390  ;
041FAA             5391  ; Group 5: (7 opcodes)
041FAA             5392  ;
041FAA 53 55 42 90 5393  			DB	"SU","B"+80H,90H	; 51h
041FAE 41 4E 44 A0 5394  			DB	"AN","D"+80H,A0H
041FB2 58 4F 52 A8 5395  			DB	"XO","R"+80H,A8H
041FB6 4F 52 B0    5396  			DB	"O","R"+80H,B0H
041FB9 43 50 B8    5397  			DB	"C","P"+80H,B8H
041FBC 80 A0       5398  			DB	TAND,A0H		; 56h TAND: Tokenised AND
041FBE 84 B0       5399  			DB	TOR,B0H			; 57h TOR: Tokenised OR
041FC0             5400  ;
041FC0             5401  ; Group 6 (3 opcodes)
041FC0             5402  ;
041FC0 41 44 44 80 5403  			DB	"AD","D"+80H,80H	; 58h
041FC4 41 44 43 88 5404  			DB	"AD","C"+80H,88H
041FC8 53 42 43 98 5405  			DB	"SB","C"+80H,98H
041FCC             5406  ;
041FCC             5407  ; Group 7: (2 opcodes)
041FCC             5408  ;
041FCC 49 4E 43 04 5409  			DB	"IN","C"+80H,04H	; 5Bh
041FD0 44 45 43 05 5410  			DB	"DE","C"+80H,05H
041FD4             5411  ;
041FD4             5412  ; Group 8: (2 opcodes)
041FD4             5413  ;
041FD4 49 4E 30 00 5414  			DB	"IN","0"+80H,00H	; 5Dh
041FD8 4F 55 54 30 5415  			DB	"OUT","0"+80H,01H
       01          
041FDD             5416  ;
041FDD             5417  ; Group 9: (1 opcode)
041FDD             5418  ;
041FDD 49 4E 40    5419  			DB	"I","N"+80H,40H		; 5Fh
041FE0             5420  ;
041FE0             5421  ; Group 10: (1 opcode)
041FE0             5422  ;
041FE0 4F 55 54 41 5423  			DB	"OU","T"+80H,41H	; 60h
041FE4             5424  ;
041FE4             5425  ; Group 11: (2 opcodes)
041FE4             5426  ;
041FE4 4A 52 20    5427  			DB	"J","R"+80H,20H		; 61h
041FE7 44 4A 4E 5A 5428  			DB	"DJN","Z"+80H,10H
       10          
041FEC             5429  ;
041FEC             5430  ; Group 12: (1 opcode)
041FEC             5431  ;
041FEC 4A 50 C2    5432  			DB	"J","P"+80H,C2H		; 63h
041FEF             5433  ;
041FEF             5434  ; Group 13: (1 opcode)
041FEF             5435  ;
041FEF 43 41 4C 4C 5436  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041FF4             5437  ;
041FF4             5438  ; Group 14: (1 opcode)
041FF4             5439  ;
041FF4 52 53 54 C7 5440  			DB	"RS","T"+80H,C7H	; 65h
041FF8             5441  ;
041FF8             5442  ; Group 15: (1 opcode)
041FF8             5443  ;
041FF8 52 45 54 C0 5444  			DB	"RE","T"+80H,C0H	; 66h
041FFC             5445  ;
041FFC             5446  ; Group 16: (1 opcode)
041FFC             5447  ;
041FFC 4C 44 40    5448  			DB	"L","D"+80H,40H		; 67h
041FFF             5449  ;
041FFF             5450  ; Group 17: (1 opcode)
041FFF             5451  ;
041FFF 54 53 54 04 5452  			DB	"TS","T"+80H,04H	; 68h
042003             5453  
042003             5454  ;
042003             5455  ; Assembler Directives
042003             5456  ;
042003 4F 50 54 00 5457  			DB	"OP","T"+80H,00H	; 69h OPT
042007 41 44 4C 00 5458  			DB	"AD","L"+80H,00H	; 6Ah ADL
04200B             5459  ;
04200B 5D 42 00    5460  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
04200E 5D 57 00    5461  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042011 5D 4C 00    5462  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042014 5D 4D 00    5463  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
042017             5464  ;
042017 00          5465  			DB	0
042018             5466  ;
042018             5467  ; Operands
042018             5468  ;
042018 42 00       5469  OPRNDS:			DB	"B"+80H, 00H
04201A 43 01       5470  			DB	"C"+80H, 01H
04201C 44 02       5471  			DB	"D"+80H, 02H
04201E 45 03       5472  			DB	"E"+80H, 03H
042020 48 04       5473  			DB	"H"+80H, 04H
042022 4C 05       5474  			DB	"L"+80H, 05H
042024 28 48 4C 06 5475  			DB	"(H","L"+80H,06H
042028 41 07       5476  			DB	"A"+80H, 07H
04202A 28 49 58 86 5477  			DB	"(I","X"+80H,86H
04202E 28 49 59 C6 5478  			DB	"(I","Y"+80H,C6H
042032             5479  ;
042032 42 43 08    5480  			DB	"B","C"+80H,08H
042035 44 45 0A    5481  			DB	"D","E"+80H,0AH
042038 48 4C 0C    5482  			DB	"H","L"+80H,0CH
04203B 49 58 8C    5483  			DB	"I","X"+80H,8CH
04203E 49 59 CC    5484  			DB	"I","Y"+80H,CCH
042041 41 46 0E    5485  			DB	"A","F"+80H,0EH
042044 53 50 0E    5486  			DB	"S","P"+80H,0EH
042047             5487  ;
042047 4E 5A 10    5488  			DB	"N","Z"+80H,10H
04204A 5A 11       5489  			DB	"Z"+80H,11H
04204C 4E 43 12    5490  			DB	"N","C"+80H,12H
04204F 50 4F 14    5491  			DB	"P","O"+80H,14H
042052 50 45 15    5492  			DB	"P","E"+80H,15H
042055 50 16       5493  			DB	"P"+80H,16H
042057 4D 17       5494  			DB	"M"+80H,17H
042059             5495  ;
042059 28 43 20    5496  			DB	"(","C"+80H,20H
04205C             5497  ;
04205C 00          5498  			DB	0
04205D             5499  ;
04205D             5500  ; Load operations
04205D             5501  ;
04205D 49 00 41 47 5502  LDOPS:			DB	"I",0,"A"+80H,47H
042061 52 00 41 4F 5503  			DB	"R",0,"A"+80H,4FH
042065 41 00 49 57 5504  			DB	"A",0,"I"+80H,57H
042069 41 00 52 5F 5505  			DB	"A",0,"R"+80H,5FH
04206D 28 42 43 00 5506  			DB	"(BC",0,"A"+80H,02h
       41 02       
042073 28 44 45 00 5507  			DB	"(DE",0,"A"+80H,12H
       41 12       
042079 41 00 28 42 5508  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
04207F 41 00 28 44 5509  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
042085             5510  ;
042085 00          5511  			DB	0
042086             5512  ;
042086             5513  ; eZ80 addressing mode suffixes
042086             5514  ;
042086             5515  ; Fully qualified suffixes
042086             5516  ;
042086 4C 49 53 49 5517  EZ80SFS_1:		DB	"LI","S"+80H,49H
04208A 53 49 4C 52 5518  			DB	"SI","L"+80H,52H
04208E 53 49 53 40 5519  EZ80SFS_2:		DB	"SI","S"+80H,40H
042092 4C 49 4C 5B 5520  			DB	"LI","L"+80H,5BH
042096             5521  ;
042096 00          5522  			DB	0
042097             5523  ;
042097             5524  ; Shortcuts when ADL mode is 0
042097             5525  ;
042097 53 40       5526  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042099 4C 49       5527  			DB	"L"+80H,49H		; Equivalent to .LIS
04209B 49 53 40    5528  			DB	"I","S"+80H,40H		; Equivalent to .SIS
04209E 49 4C 52    5529  			DB	"I","L"+80H,52H		; Equivalent to .SIL
0420A1             5530  ;
0420A1 00          5531  			DB	0
0420A2             5532  ;
0420A2             5533  ; Shortcuts when ADL mode is 1
0420A2             5534  ;
0420A2 53 52       5535  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0420A4 4C 5B       5536  			DB	"L"+80H,5BH		; Equivalent to .LIL
0420A6 49 53 49    5537  			DB	"I","S"+80H,49H		; Equivalent to .LIS
0420A9 49 4C 5B    5538  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0420AC             5539  ;
0420AC 00          5540  			DB	0
0420AD             5541  ;
0420AD             5542  ; .LIST
0420AD             5543  ;
0420AD             5544  ; already defined in equs.inc
0420AD             5545  ; LF:			EQU     0AH
0420AD             5546  ; CR:			EQU     0DH; --- End exec.asm ---
0420AD             5547  
0420AD             5548  ; --- Begin fpp.asm ---
0420AD             5549  ;
0420AD             5550  ; Title:	BBC Basic Interpreter - Z80 version
0420AD             5551  ;		Z80 Floating Point Package
0420AD             5552  ; Author:	(C) Copyright  R.T.Russell  1986
0420AD             5553  ; Modified By:	Dean Belfield
0420AD             5554  ; Created:	03/05/2022
0420AD             5555  ; Last Updated:	07/06/2023
0420AD             5556  ;
0420AD             5557  ; Modinfo:
0420AD             5558  ; 26/10/1986:	Version 0.0
0420AD             5559  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0420AD             5560  ; 12/05/2023:	Modified by Dean Belfield
0420AD             5561  ; 07/06/2023:	Modified to run in ADL mode
0420AD             5562  
0420AD             5563  			; .ASSUME	ADL = 1
0420AD             5564  
0420AD             5565  			; SEGMENT CODE
0420AD             5566  
0420AD             5567  			; XDEF	FPP
0420AD             5568  			; XDEF	DLOAD5
0420AD             5569  			; XDEF	DLOAD5_SPL
0420AD             5570  ;
0420AD             5571  ;BINARY FLOATING POINT REPRESENTATION:
0420AD             5572  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0420AD             5573  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0420AD             5574  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0420AD             5575  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0420AD             5576  ;
0420AD             5577  ;BINARY INTEGER REPRESENTATION:
0420AD             5578  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0420AD             5579  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0420AD             5580  ;
0420AD             5581  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0420AD             5582  ;                            EXPONENT - C
0420AD             5583  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0420AD             5584  ;                               EXPONENT - B
0420AD             5585  
0420AD             5586  ;
0420AD             5587  ;Error codes:
0420AD             5588  ;
0420AD             5589  
0420AD             5590  ; BADOP:			EQU     1               ;Bad operation code
0420AD             5591  ; DIVBY0:			EQU     18              ;Division by zero
0420AD             5592  ; TOOBIG_FP:			EQU     20              ;Too big
0420AD             5593  ; NGROOT:			EQU     21              ;Negative root
0420AD             5594  ; LOGRNG:			EQU     22              ;Log range
0420AD             5595  ; ACLOST:			EQU     23              ;Accuracy lost
0420AD             5596  ; EXPRNG:			EQU     24              ;Exp range
0420AD             5597  ;
0420AD             5598  ;Call entry and despatch code:
0420AD             5599  ;
0420AD FD E5       5600  FPP:			PUSH    IY              ;Save IY
0420AF FD 21 00 00 5601          		LD      IY,0
       00          
0420B4 FD 39       5602          		ADD     IY,SP           ;Save SP in IY
0420B6 CD C6 20 04 5603          		CALL    OP              ;Perform operation
0420BA BF          5604          		CP      A               ;Good return (Z, NC)
0420BB FD E1       5605  EXIT_FP_:			POP     IY              ;Restore IY
0420BD C9          5606          		RET                     ;Return to caller
0420BE             5607  ;
0420BE             5608  ;Error exit:
0420BE             5609  ;
0420BE 3E 01       5610  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420C0 FD F9       5611  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420C2 B7          5612          		OR      A               ;Set NZ
0420C3 37          5613          		SCF                     ;Set C
0420C4 18 F5       5614          		JR      EXIT_FP_
0420C6             5615  ;
0420C6             5616  ;Perform operation or function:
0420C6             5617  ;
0420C6             5618  ; OP:			CP      (RTABLE-DTABLE)/3
0420C6 FE 2A       5619  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420C8             5620  
0420C8 30 F4       5621          		JR      NC,BAD_FP
0420CA             5622          		; CP      (FTABLE-DTABLE)/3
0420CA FE 10       5623  				CP      FTABLE-DTABLE/3 ; ditto
0420CC 30 08       5624          		JR      NC,DISPAT_FP
0420CE 08          5625          		EX      AF,AF'
0420CF 78          5626          		LD      A,B
0420D0 B1          5627          		OR      C               ;Both integer?
0420D1 C4 D9 2B 04 5628          		CALL    NZ,FLOATA       ;No, so float both
0420D5 08          5629          		EX      AF,AF'
0420D6 E5          5630  DISPAT_FP:			PUSH    HL
0420D7 21 E9 20 04 5631          		LD      HL,DTABLE
0420DB C5          5632          		PUSH    BC
0420DC 01 03 00 00 5633  			LD	BC, 3		; C = 3
0420E0 47          5634  			LD	B, A 		; B = op-code
0420E1 ED 4C       5635  			MLT 	BC 		;BC = op-code * 3
0420E3 09          5636  			ADD	HL, BC 		;Add to table base
0420E4 ED 27       5637  			LD	HL, (HL)	;Get the routine address (24-bit)
0420E6             5638  
0420E6             5639  ;        		ADD     A, A            ;A = op-code * 2
0420E6             5640  ;        		LD      C,A
0420E6             5641  ;        		LD      B,0             ;BC = op-code * 2
0420E6             5642  ;        		ADD     HL,BC
0420E6             5643  ;        		LD      A,(HL)          ;Get low byte
0420E6             5644  ;        		INC     HL
0420E6             5645  ;        		LD      H,(HL)          ;Get high byte
0420E6             5646  ;        		LD      L,A
0420E6             5647  
0420E6 C1          5648          		POP     BC
0420E7 E3          5649          		EX      (SP),HL
0420E8 C9          5650          		RET                     ;Off to routine
0420E9             5651  ;
0420E9             5652  ;Despatch table:
0420E9             5653  ;
0420E9 9B 21 04    5654  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420EC 09 22 04    5655          		DW24  IBDIV           ;DIV
0420EF AE 21 04    5656          		DW24  IEOR            ;EOR
0420F2 D4 21 04    5657          		DW24  IMOD            ;MOD
0420F5 C1 21 04    5658          		DW24  IOR             ;OR
0420F8 8F 24 04    5659          		DW24  ILE             ;<=
0420FB 9E 24 04    5660          		DW24  INE             ;<>
0420FE 82 24 04    5661          		DW24  IGE             ;>=
042101 67 24 04    5662          		DW24  ILT             ;<
042104 AB 24 04    5663          		DW24  IEQ             ;=
042107 F7 22 04    5664          		DW24  IMUL            ;*
04210A 32 22 04    5665          		DW24  IADD            ;+
04210D 74 24 04    5666          		DW24  IGT             ;>
042110 19 22 04    5667          		DW24  ISUB            ;-
042113 AE 23 04    5668          		DW24  IPOW            ;^
042116 A4 22 04    5669          		DW24  IDIV            ;/
042119             5670  ;
042119             5671  FTABLE:
042119 BD 24 04    5672  				DW24  ABSV_FP            ;ABS
04211C A3 28 04    5673          		DW24  ACS_FP             ;ACS
04211F E1 27 04    5674          		DW24  ASN_FP             ;ASN
042122 11 28 04    5675          		DW24  ATN_FP             ;ATN
042125 DC 25 04    5676          		DW24  COS_FP             ;COS
042128 EB 24 04    5677          		DW24  DEG_FP             ;DEG
04212B 98 26 04    5678          		DW24  EXP_FP             ;EXP
04212E 3F 25 04    5679          		DW24  INT_FP_            ;INT
042131 36 27 04    5680          		DW24  LN_FP              ;LN
042134 CB 27 04    5681          		DW24  LOG_FP             ;LOG
042137 C9 24 04    5682          		DW24  NOTK_FP            ;NOT
04213A F5 24 04    5683          		DW24  RAD_FP             ;RAD
04213D 10 25 04    5684          		DW24  SGN_FP             ;SGN
042140 E9 25 04    5685          		DW24  SIN_FP             ;SIN
042143 58 25 04    5686          		DW24  SQR_FP             ;SQR
042146 B6 25 04    5687          		DW24  TAN_FP             ;TAN
042149             5688  ;
042149 66 2C 04    5689  		        DW24  ZERO_FP            ;ZERO
04214C 71 26 04    5690          		DW24  FONE_FP            ;FONE
04214F B0 24 04    5691          		DW24  TRUE_FP            ;TRUE
042152 DD 24 04    5692          		DW24  PI_FP              ;PI
042155             5693  ;
042155 24 25 04    5694  		        DW24  VAL_FP             ;VAL
042158 AC 28 04    5695          		DW24  STR_FP             ;STR$
04215B             5696  ;
04215B 0D 2B 04    5697          		DW24  SFIX_FP            ;FIX
04215E E9 2B 04    5698          		DW24  SFLOAT_FP          ;FLOAT
042161             5699  ;
042161 37 2C 04    5700  		        DW24  FTEST_FP           ;TEST
042164 49 2C 04    5701          		DW24  FCOMP_FP           ;COMPARE
042167             5702  ;
042167 97 21 04    5703  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04216A 05 22 04    5704          		DW24  FBDIV           ;DIV
04216D AA 21 04    5705          		DW24  FEOR            ;EOR
042170 D0 21 04    5706          		DW24  FMOD            ;MOD
042173 BD 21 04    5707          		DW24  FFOR             ;OR
042176 89 24 04    5708          		DW24  FLE             ;<=
042179 98 24 04    5709          		DW24  FNE             ;<>
04217C 7C 24 04    5710          		DW24  FGE             ;>=
04217F 61 24 04    5711          		DW24  FLT             ;<
042182 A5 24 04    5712          		DW24  FEQ             ;=
042185 51 23 04    5713          		DW24  FMUL            ;*
042188 3F 22 04    5714          		DW24  FADD            ;+
04218B 6E 24 04    5715          		DW24  FGT             ;>
04218E 26 22 04    5716          		DW24  FSUB            ;-
042191 2E 24 04    5717          		DW24  FPOW            ;^
042194 A8 22 04    5718          		DW24  FDIV            ;/
042197             5719  ;
042197             5720  ;       PAGE
042197             5721  ;
042197             5722  ;ARITHMETIC AND LOGICAL OPERATORS:
042197             5723  ;All take two arguments, in HLH'L'C & DED'E'B.
042197             5724  ;Output in HLH'L'C
042197             5725  ;All registers except IX, IY destroyed.
042197             5726  ; (N.B. FPOW destroys IX).
042197             5727  ;
042197             5728  ;FAND - Floating-point AND.
042197             5729  ;IAND - Integer AND.
042197             5730  ;
042197 CD 01 2B 04 5731  FAND:			CALL    FIX2
04219B 7C          5732  IAND:			LD      A,H
04219C A2          5733          		AND     D
04219D 67          5734          		LD      H,A
04219E 7D          5735          		LD      A,L
04219F A3          5736          		AND     E
0421A0 6F          5737          		LD      L,A
0421A1 D9          5738          		EXX
0421A2 7C          5739          		LD      A,H
0421A3 A2          5740          		AND     D
0421A4 67          5741          		LD      H,A
0421A5 7D          5742          		LD      A,L
0421A6 A3          5743          		AND     E
0421A7 6F          5744          		LD      L,A
0421A8 D9          5745          		EXX
0421A9 C9          5746          		RET
0421AA             5747  ;
0421AA             5748  ;FEOR - Floating-point exclusive-OR.
0421AA             5749  ;IEOR - Integer exclusive-OR.
0421AA             5750  ;
0421AA CD 01 2B 04 5751  FEOR:			CALL    FIX2
0421AE 7C          5752  IEOR:			LD      A,H
0421AF AA          5753          		XOR     D
0421B0 67          5754          		LD      H,A
0421B1 7D          5755          		LD      A,L
0421B2 AB          5756          		XOR     E
0421B3 6F          5757          		LD      L,A
0421B4 D9          5758          		EXX
0421B5 7C          5759          		LD      A,H
0421B6 AA          5760          		XOR     D
0421B7 67          5761          		LD      H,A
0421B8 7D          5762          		LD      A,L
0421B9 AB          5763          		XOR     E
0421BA 6F          5764          		LD      L,A
0421BB D9          5765          		EXX
0421BC C9          5766          		RET
0421BD             5767  ;
0421BD             5768  ;FFOR - Floating-point OR.
0421BD             5769  ;IOR - Integer OR.
0421BD             5770  ;
0421BD CD 01 2B 04 5771  FFOR:			CALL    FIX2
0421C1 7C          5772  IOR:			LD      A,H
0421C2 B2          5773          		OR      D
0421C3 67          5774          		LD      H,A
0421C4 7D          5775          		LD      A,L
0421C5 B3          5776          		OR      E
0421C6 6F          5777          		LD      L,A
0421C7 D9          5778          		EXX
0421C8 7C          5779          		LD      A,H
0421C9 B2          5780          		OR      D
0421CA 67          5781          		LD      H,A
0421CB 7D          5782          		LD      A,L
0421CC B3          5783          		OR      E
0421CD 6F          5784          		LD      L,A
0421CE D9          5785          		EXX
0421CF C9          5786          		RET
0421D0             5787  ;
0421D0             5788  ;FMOD - Floating-point remainder.
0421D0             5789  ;IMOD - Integer remainder.
0421D0             5790  ;
0421D0 CD 01 2B 04 5791  FMOD:			CALL    FIX2
0421D4 7C          5792  IMOD:			LD      A,H
0421D5 AA          5793          		XOR     D               ;DIV RESULT SIGN
0421D6 CB 7C       5794          		BIT     7,H
0421D8 08          5795          		EX      AF,AF'
0421D9 CB 7C       5796          		BIT     7,H
0421DB C4 1D 2B 04 5797          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421DF CD 1A 2C 04 5798          		CALL    SWAP_FP
0421E3 CB 7C       5799          		BIT     7,H
0421E5 C4 1D 2B 04 5800          		CALL    NZ,NEGATE
0421E9 44          5801          		LD      B,H
0421EA 4D          5802          		LD      C,L
0421EB 21 00 00 00 5803          		LD      HL,0
0421EF D9          5804          		EXX
0421F0 44          5805          		LD      B,H
0421F1 4D          5806          		LD      C,L
0421F2 21 00 00 00 5807          		LD      HL,0
0421F6 3E DF       5808          		LD      A,-33
0421F8 CD A7 2D 04 5809          		CALL    DIVA            ;DIVIDE
0421FC D9          5810          		EXX
0421FD 0E 00       5811          		LD      C,0             ;INTEGER MARKER
0421FF 08          5812          		EX      AF,AF'
042200 C8          5813          		RET     Z
042201 C3 1D 2B 04 5814          		JP      NEGATE
042205             5815  ;
042205             5816  ;BDIV - Integer division.
042205             5817  ;
042205 CD 01 2B 04 5818  FBDIV:			CALL    FIX2
042209 CD D4 21 04 5819  IBDIV:			CALL    IMOD
04220D B7          5820          		OR      A
04220E CD 1A 2C 04 5821          		CALL    SWAP_FP
042212 0E 00       5822          		LD      C,0
042214 F0          5823          		RET     P
042215 C3 1D 2B 04 5824          		JP      NEGATE
042219             5825  ;
042219             5826  ;ISUB - Integer subtraction.
042219             5827  ;FSUB - Floating point subtraction with rounding.
042219             5828  ;
042219 CD B5 2C 04 5829  ISUB:			CALL    SUB_
04221D E0          5830          		RET     PO
04221E CD AD 2C 04 5831          		CALL    ADD_
042222 CD DD 2B 04 5832          		CALL    FLOAT2
042226 7A          5833  FSUB:			LD      A,D
042227 EE 80       5834          		XOR     80H             ;CHANGE SIGN THEN ADD
042229 57          5835          		LD      D,A
04222A 18 13       5836          		JR      FADD
04222C             5837  ;
04222C             5838  ;Reverse subtract.
04222C             5839  ;
04222C 7C          5840  RSUB:			LD      A,H
04222D EE 80       5841          		XOR     80H
04222F 67          5842          		LD      H,A
042230 18 0D       5843          		JR      FADD
042232             5844  ;
042232             5845  ;IADD - Integer addition.
042232             5846  ;FADD - Floating point addition with rounding.
042232             5847  ;
042232 CD AD 2C 04 5848  IADD:			CALL    ADD_
042236 E0          5849          		RET     PO
042237 CD B5 2C 04 5850          		CALL    SUB_
04223B CD DD 2B 04 5851          		CALL    FLOAT2
04223F 05          5852  FADD:			DEC     B
042240 04          5853          		INC     B
042241 C8          5854          		RET     Z               ;ARG 2 ZERO
042242 0D          5855          		DEC     C
042243 0C          5856          		INC     C
042244 CA 1A 2C 04 5857          		JP      Z,SWAP_FP          ;ARG 1 ZERO
042248 D9          5858          		EXX
042249 01 00 00 00 5859          		LD      BC,0            ;INITIALISE
04224D D9          5860          		EXX
04224E 7C          5861          		LD      A,H
04224F AA          5862          		XOR     D               ;XOR SIGNS
042250 F5          5863          		PUSH    AF
042251 78          5864          		LD      A,B
042252 B9          5865          		CP      C               ;COMPARE EXPONENTS
042253 DC 1A 2C 04 5866          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042257 78          5867          		LD      A,B
042258 CB FC       5868          		SET     7,H             ;IMPLIED 1
04225A C4 EE 2A 04 5869          		CALL    NZ,FIX          ;ALIGN
04225E F1          5870          		POP     AF
04225F 7A          5871          		LD      A,D             ;SIGN OF LARGER
042260 CB FA       5872          		SET     7,D             ;IMPLIED 1
042262 FA 72 22 04 5873          		JP      M,FADD3         ;SIGNS DIFFERENT
042266 CD AD 2C 04 5874          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04226A DC 22 2C 04 5875          		CALL    C,DIV2          ;NORMALISE
04226E CB FC       5876          		SET     7,H
042270 18 0D       5877          		JR      FADD4
042272             5878  ;
042272 CD B5 2C 04 5879  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042276 DC 35 2B 04 5880          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04227A CD B4 2B 04 5881          		CALL    FLO48
04227E 2F          5882          		CPL                     ;CHANGE RESULT SIGN
04227F D9          5883  FADD4:			EXX
042280 EB          5884          		EX      DE,HL
042281 21 00 80 00 5885          		LD      HL,8000H
042285 B7          5886          		OR      A               ;CLEAR CARRY
042286 52 ED 42    5887          		SBC.S   HL,BC
042289 EB          5888          		EX      DE,HL
04228A D9          5889          		EXX
04228B CC 14 2C 04 5890          		CALL    Z,ODD           ;ROUND UNBIASSED
04228F DC 02 2C 04 5891          		CALL    C,ADD1_FP          ;ROUND UP
042293 DC 2F 2C 04 5892          		CALL    C,INCC
042297 CB BC       5893          		RES     7,H
042299 0D          5894          		DEC     C
04229A 0C          5895          		INC     C
04229B CA 66 2C 04 5896          		JP      Z,ZERO_FP
04229F B7          5897          		OR      A               ;RESULT SIGNQ
0422A0 F0          5898          		RET     P               ;POSITIVE
0422A1 CB FC       5899          		SET     7,H             ;NEGATIVE
0422A3 C9          5900          		RET
0422A4             5901  ;
0422A4             5902  ;IDIV - Integer division.
0422A4             5903  ;FDIV - Floating point division with rounding.
0422A4             5904  ;
0422A4 CD DD 2B 04 5905  IDIV:			CALL    FLOAT2
0422A8 05          5906  FDIV:			DEC     B               ;TEST FOR ZERO
0422A9 04          5907          		INC     B
0422AA 3E 12       5908          		LD      A,DIVBY0
0422AC CA C0 20 04 5909          		JP      Z,ERROR_FP_         ;"Division by zero"
0422B0 0D          5910          		DEC     C               ;TEST FOR ZERO
0422B1 0C          5911          		INC     C
0422B2 C8          5912          		RET     Z
0422B3 7C          5913          		LD      A,H
0422B4 AA          5914          		XOR     D               ;CALC. RESULT SIGN
0422B5 08          5915          		EX      AF,AF'          ;SAVE SIGN
0422B6 CB FA       5916          		SET     7,D             ;REPLACE IMPLIED 1's
0422B8 CB FC       5917          		SET     7,H
0422BA C5          5918          		PUSH    BC              ;SAVE EXPONENTS
0422BB 42          5919          		LD      B,D             ;LOAD REGISTERS
0422BC 4B          5920          		LD      C,E
0422BD 11 00 00 00 5921          		LD      DE,0
0422C1 D9          5922          		EXX
0422C2 42          5923          		LD      B,D
0422C3 4B          5924          		LD      C,E
0422C4 11 00 00 00 5925          		LD      DE,0
0422C8 3E E0       5926          		LD      A,-32           ;LOOP COUNTER
0422CA CD A7 2D 04 5927          		CALL    DIVA            ;DIVIDE
0422CE D9          5928          		EXX
0422CF CB 7A       5929          		BIT     7,D
0422D1 D9          5930          		EXX
0422D2 CC C6 2D 04 5931          		CALL    Z,DIVB          ;NORMALISE & INC A
0422D6 EB          5932          		EX      DE,HL
0422D7 D9          5933          		EXX
0422D8 CB 38       5934          		SRL     B               ;DIVISOR/2
0422DA CB 19       5935          		RR      C
0422DC B7          5936          		OR      A               ;CLEAR CARRY
0422DD 52 ED 42    5937          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422E0 3F          5938          		CCF
0422E1 EB          5939          		EX      DE,HL           ;RESULT IN HLH'L'
0422E2 CC 14 2C 04 5940          		CALL    Z,ODD           ;ROUND UNBIASSED
0422E6 DC 02 2C 04 5941          		CALL    C,ADD1_FP          ;ROUND UP
0422EA C1          5942          		POP     BC              ;RESTORE EXPONENTS
0422EB DC 2F 2C 04 5943          		CALL    C,INCC
0422EF 1F          5944          		RRA                     ;LSB OF A TO CARRY
0422F0 79          5945          		LD      A,C             ;COMPUTE NEW EXPONENT
0422F1 98          5946          		SBC     A,B
0422F2 3F          5947          		CCF
0422F3 C3 94 23 04 5948          		JP      CHKOVF
0422F7             5949  ;
0422F7             5950  ;IMUL - Integer multiplication.
0422F7             5951  ;
0422F7 7C          5952  IMUL:			LD      A,H
0422F8 AA          5953          		XOR     D
0422F9 08          5954          		EX      AF,AF'          ;SAVE RESULT SIGN
0422FA CB 7C       5955          		BIT     7,H
0422FC C4 1D 2B 04 5956          		CALL    NZ,NEGATE
042300 CD 1A 2C 04 5957          		CALL    SWAP_FP
042304 CB 7C       5958          		BIT     7,H
042306 C4 1D 2B 04 5959          		CALL    NZ,NEGATE
04230A 44          5960          		LD      B,H
04230B 4D          5961          		LD      C,L
04230C 21 00 00 00 5962          		LD      HL,0
042310 D9          5963          		EXX
042311 44          5964          		LD      B,H
042312 4D          5965          		LD      C,L
042313 21 00 00 00 5966          		LD      HL,0
042317 3E DF       5967          		LD      A,-33
042319 CD DE 2D 04 5968          		CALL    MULA            ;MULTIPLY
04231D D9          5969          		EXX
04231E 0E BF       5970          		LD      C,191           ;PRESET EXPONENT
042320 CD 42 2C 04 5971          		CALL    TEST_FP            ;TEST RANGE
042324 20 0F       5972          		JR      NZ,IMUL1        ;TOO BIG
042326 CB 7A       5973          		BIT     7,D
042328 20 0B       5974          		JR      NZ,IMUL1
04232A CD 1A 2C 04 5975          		CALL    SWAP_FP
04232E 4A          5976          		LD      C,D             ;INTEGER MARKER
04232F 08          5977          		EX      AF,AF'
042330 F0          5978          		RET     P
042331 C3 1D 2B 04 5979          		JP      NEGATE
042335             5980  ;
042335 0D          5981  IMUL1:			DEC     C
042336 D9          5982          		EXX
042337 CB 23       5983          		SLA     E
042339 CB 12       5984          		RL      D
04233B D9          5985          		EXX
04233C CB 13       5986          		RL      E
04233E CB 12       5987          		RL      D
042340 D9          5988          		EXX
042341 52 ED 6A    5989          		ADC.S   HL,HL
042344 D9          5990          		EXX
042345 52 ED 6A    5991          		ADC.S   HL,HL
042348 F2 35 23 04 5992          		JP      P,IMUL1         ;NORMALISE
04234C 08          5993          		EX      AF,AF'
04234D F8          5994          		RET     M
04234E CB BC       5995          		RES     7,H             ;POSITIVE
042350 C9          5996          		RET
042351             5997  ;
042351             5998  ;FMUL - Floating point multiplication with rounding.
042351             5999  ;
042351 05          6000  FMUL:			DEC     B               ;TEST FOR ZERO
042352 04          6001          		INC     B
042353 CA 66 2C 04 6002          		JP      Z,ZERO_FP
042357 0D          6003          		DEC     C               ;TEST FOR ZERO
042358 0C          6004          		INC     C
042359 C8          6005          		RET     Z
04235A 7C          6006          		LD      A,H
04235B AA          6007          		XOR     D               ;CALC. RESULT SIGN
04235C 08          6008          		EX      AF,AF'
04235D CB FA       6009          		SET     7,D             ;REPLACE IMPLIED 1's
04235F CB FC       6010          		SET     7,H
042361 C5          6011          		PUSH    BC              ;SAVE EXPONENTS
042362 44          6012          		LD      B,H             ;LOAD REGISTERS
042363 4D          6013          		LD      C,L
042364 21 00 00 00 6014          		LD      HL,0
042368 D9          6015          		EXX
042369 44          6016          		LD      B,H
04236A 4D          6017          		LD      C,L
04236B 21 00 00 00 6018          		LD      HL,0
04236F 3E E0       6019          		LD      A,-32           ;LOOP COUNTER
042371 CD DE 2D 04 6020          		CALL    MULA            ;MULTIPLY
042375 DC F4 2D 04 6021          		CALL    C,MULB          ;NORMALISE & INC A
042379 D9          6022          		EXX
04237A E5          6023          		PUSH    HL
04237B 21 00 80 00 6024          		LD      HL,8000H
04237F B7          6025          		OR      A               ;CLEAR CARRY
042380 52 ED 52    6026          		SBC.S   HL,DE
042383 E1          6027          		POP     HL
042384 CC 14 2C 04 6028          		CALL    Z,ODD           ;ROUND UNBIASSED
042388 DC 02 2C 04 6029          		CALL    C,ADD1_FP          ;ROUND UP
04238C C1          6030          		POP     BC              ;RESTORE EXPONENTS
04238D DC 2F 2C 04 6031          		CALL    C,INCC
042391 1F          6032          		RRA                     ;LSB OF A TO CARRY
042392 79          6033          		LD      A,C             ;COMPUTE NEW EXPONENT
042393 88          6034          		ADC     A,B
042394 38 06       6035  CHKOVF:			JR      C,CHKO1
042396 F2 66 2C 04 6036          		JP      P,ZERO_FP          ;UNDERFLOW
04239A 18 04       6037          		JR      CHKO2
04239C FA 31 2C 04 6038  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0423A0 C6 80       6039  CHKO2:			ADD     A,80H
0423A2 4F          6040          		LD      C,A
0423A3 CA 66 2C 04 6041          		JP      Z,ZERO_FP
0423A7 08          6042          		EX      AF,AF'          ;RESTORE SIGN BIT
0423A8 CB BC       6043          		RES     7,H
0423AA F0          6044          		RET     P
0423AB CB FC       6045          		SET     7,H
0423AD C9          6046          		RET
0423AE             6047  ;
0423AE             6048  ;IPOW - Integer involution.
0423AE             6049  ;
0423AE CD 1A 2C 04 6050  IPOW:			CALL    SWAP_FP
0423B2 CB 7C       6051          		BIT     7,H
0423B4 F5          6052          		PUSH    AF              ;SAVE SIGN
0423B5 C4 1D 2B 04 6053          		CALL    NZ,NEGATE
0423B9 48          6054  IPOW0:			LD      C,B
0423BA 06 20       6055          		LD      B,32            ;LOOP COUNTER
0423BC CD D2 2C 04 6056  IPOW1:			CALL    X2
0423C0 38 08       6057          		JR      C,IPOW2
0423C2 10 F8       6058          		DJNZ    IPOW1
0423C4 F1          6059          		POP     AF
0423C5 D9          6060          		EXX
0423C6 2C          6061          		INC     L               ;RESULT=1
0423C7 D9          6062          		EXX
0423C8 4C          6063          		LD      C,H
0423C9 C9          6064          		RET
0423CA             6065  ;
0423CA F1          6066  IPOW2:			POP     AF
0423CB C5          6067          		PUSH    BC
0423CC EB          6068          		EX      DE,HL
0423CD E5          6069          		PUSH    HL
0423CE D9          6070          		EXX
0423CF EB          6071          		EX      DE,HL
0423D0 E5          6072          		PUSH    HL
0423D1 D9          6073          		EXX
0423D2 DD 21 00 00 6074          		LD      IX,0
       00          
0423D7 DD 39       6075          		ADD     IX,SP
0423D9 28 48       6076          		JR      Z,IPOW4
0423DB C5          6077          		PUSH    BC
0423DC D9          6078          		EXX
0423DD D5          6079          		PUSH    DE
0423DE D9          6080          		EXX
0423DF D5          6081          		PUSH    DE
0423E0 CD E9 2B 04 6082          		CALL    SFLOAT_FP
0423E4 CD 1D 27 04 6083          		CALL    RECIP
0423E8 DD 71 04    6084          		LD      (IX+4),C
0423EB D9          6085          		EXX
0423EC DD 75 00    6086          		LD      (IX+0),L
0423EF DD 74 01    6087          		LD      (IX+1),H
0423F2 D9          6088          		EXX
0423F3 DD 75 02    6089          		LD      (IX+2),L
0423F6 DD 74 03    6090          		LD      (IX+3),H
0423F9 18 21       6091          		JR      IPOW5
0423FB             6092  ;
0423FB C5          6093  IPOW3:			PUSH    BC
0423FC D9          6094          		EXX
0423FD CB 23       6095          		SLA     E
0423FF CB 12       6096          		RL      D
042401 D5          6097          		PUSH    DE
042402 D9          6098          		EXX
042403 CB 13       6099          		RL      E
042405 CB 12       6100          		RL      D
042407 D5          6101          		PUSH    DE
042408 3E 0A       6102          		LD      A,'*' & 0FH
04240A F5          6103          		PUSH    AF
04240B CD E6 2C 04 6104          		CALL    COPY_
04240F CD C6 20 04 6105          		CALL    OP              ;SQUARE
042413 F1          6106          		POP     AF
042414 CD 12 2A 04 6107          		CALL    DLOAD5
042418 DC C6 20 04 6108          		CALL    C,OP            ;MULTIPLY BY X
04241C D1          6109  IPOW5:			POP     DE
04241D D9          6110          		EXX
04241E D1          6111          		POP     DE
04241F D9          6112          		EXX
042420 79          6113          		LD      A,C
042421 C1          6114          		POP     BC
042422 4F          6115          		LD      C,A
042423 10 D6       6116  IPOW4:			DJNZ    IPOW3
042425 F1          6117          		POP     AF
042426 F1          6118          		POP     AF
042427 F1          6119          		POP     AF
042428 C9          6120          		RET
042429             6121  ;
042429 F1          6122  FPOW0:			POP     AF
04242A F1          6123          		POP     AF
04242B F1          6124          		POP     AF
04242C 18 8B       6125          		JR      IPOW0
04242E             6126  ;
04242E             6127  ;FPOW - Floating-point involution.
04242E             6128  ;
04242E CB 7A       6129  FPOW:			BIT     7,D
042430 F5          6130          		PUSH    AF
042431 CD 1A 2C 04 6131          		CALL    SWAP_FP
042435 CD F6 2C 04 6132          		CALL    PUSH5
042439 0D          6133          		DEC     C
04243A 0C          6134          		INC     C
04243B 28 EC       6135          		JR      Z,FPOW0
04243D 3E 9E       6136          		LD      A,158
04243F B9          6137          		CP      C
042440 38 0A       6138          		JR      C,FPOW1
042442 3C          6139          		INC     A
042443 CD EE 2A 04 6140          		CALL    FIX
042447 08          6141          		EX      AF,AF'
042448 F2 29 24 04 6142          		JP      P,FPOW0
04244C CD 1A 2C 04 6143  FPOW1:			CALL    SWAP_FP
042450 CD 3A 27 04 6144          		CALL    LN0
042454 CD FF 2C 04 6145          		CALL    POP5
042458 F1          6146          		POP     AF
042459 CD 51 23 04 6147          		CALL    FMUL
04245D C3 9C 26 04 6148          		JP      EXP0
042461             6149  ;
042461             6150  ;Integer and floating-point compare.
042461             6151  ;Result is TRUE (-1) or FALSE (0).
042461             6152  ;
042461 CD 70 2C 04 6153  FLT:			CALL    FCP
042465 18 04       6154          		JR      ILT1
042467 CD 62 2C 04 6155  ILT:			CALL    ICP
04246B D0          6156  ILT1:			RET     NC
04246C 18 42       6157          		JR      TRUE_FP
04246E             6158  ;
04246E CD 70 2C 04 6159  FGT:			CALL    FCP
042472 18 04       6160          		JR      IGT1
042474 CD 62 2C 04 6161  IGT:			CALL    ICP
042478 C8          6162  IGT1:			RET     Z
042479 D8          6163          		RET     C
04247A 18 34       6164          		JR      TRUE_FP
04247C             6165  ;
04247C CD 70 2C 04 6166  FGE:			CALL    FCP
042480 18 04       6167          		JR      IGE1
042482 CD 62 2C 04 6168  IGE:			CALL    ICP
042486 D8          6169  IGE1:			RET     C
042487 18 27       6170          		JR      TRUE_FP
042489             6171  ;
042489 CD 70 2C 04 6172  FLE:			CALL    FCP
04248D 18 04       6173          		JR      ILE1
04248F CD 62 2C 04 6174  ILE:			CALL    ICP
042493 28 1B       6175  ILE1:			JR      Z,TRUE_FP
042495 D0          6176          		RET     NC
042496 18 18       6177          		JR      TRUE_FP
042498             6178  ;
042498 CD 70 2C 04 6179  FNE:			CALL    FCP
04249C 18 04       6180          		JR      INE1
04249E CD 62 2C 04 6181  INE:			CALL    ICP
0424A2 C8          6182  INE1:			RET     Z
0424A3 18 0B       6183          		JR      TRUE_FP
0424A5             6184  ;
0424A5 CD 70 2C 04 6185  FEQ:			CALL    FCP
0424A9 18 04       6186          		JR      IEQ1
0424AB CD 62 2C 04 6187  IEQ:			CALL    ICP
0424AF C0          6188  IEQ1:			RET     NZ
0424B0 21 FF FF FF 6189  TRUE_FP:			LD      HL,-1
0424B4 D9          6190          		EXX
0424B5 21 FF FF FF 6191          		LD      HL,-1
0424B9 D9          6192          		EXX
0424BA AF          6193          		XOR     A
0424BB 4F          6194          		LD      C,A
0424BC C9          6195          		RET
0424BD             6196  ;
0424BD             6197  ;FUNCTIONS:
0424BD             6198  ;
0424BD             6199  ;Result returned in HLH'L'C (floating point)
0424BD             6200  ;Result returned in HLH'L' (C=0) (integer)
0424BD             6201  ;All registers except IY destroyed.
0424BD             6202  ;
0424BD             6203  ;ABS - Absolute value
0424BD             6204  ;Result is numeric, variable type.
0424BD             6205  ;
0424BD CB 7C       6206  ABSV_FP:			BIT     7,H
0424BF C8          6207          		RET     Z               ;POSITIVE/ZERO
0424C0 0D          6208          		DEC     C
0424C1 0C          6209          		INC     C
0424C2 CA 1D 2B 04 6210          		JP      Z,NEGATE        ;INTEGER
0424C6 CB BC       6211          		RES     7,H
0424C8 C9          6212          		RET
0424C9             6213  ;
0424C9             6214  ;NOT - Complement integer.
0424C9             6215  ;Result is integer numeric.
0424C9             6216  ;
0424C9 CD 0D 2B 04 6217  NOTK_FP:			CALL    SFIX_FP
0424CD 7C          6218          		LD      A,H
0424CE 2F          6219          		CPL
0424CF 67          6220          		LD      H,A
0424D0 7D          6221          		LD      A,L
0424D1 2F          6222          		CPL
0424D2 6F          6223          		LD      L,A
0424D3 D9          6224          		EXX
0424D4 7C          6225          		LD      A,H
0424D5 2F          6226          		CPL
0424D6 67          6227          		LD      H,A
0424D7 7D          6228          		LD      A,L
0424D8 2F          6229          		CPL
0424D9 6F          6230          		LD      L,A
0424DA D9          6231          		EXX
0424DB AF          6232          		XOR     A               ;NUMERIC MARKER
0424DC C9          6233          		RET
0424DD             6234  ;
0424DD             6235  ;PI - Return PI (3.141592654)
0424DD             6236  ;Result is floating-point numeric.
0424DD             6237  ;
0424DD 21 0F 49 00 6238  PI_FP:			LD      HL,490FH
0424E1 D9          6239          		EXX
0424E2 21 A2 DA 00 6240          		LD      HL,0DAA2H
0424E6 D9          6241          		EXX
0424E7 0E 81       6242          		LD      C,81H
0424E9 AF          6243          		XOR     A               ;NUMERIC MARKER
0424EA C9          6244          		RET
0424EB             6245  ;
0424EB             6246  ;DEG - Convert radians to degrees
0424EB             6247  ;Result is floating-point numeric.
0424EB             6248  ;
0424EB CD FF 24 04 6249  DEG_FP:			CALL    FPI180
0424EF CD 51 23 04 6250          		CALL    FMUL
0424F3 AF          6251          		XOR     A
0424F4 C9          6252          		RET
0424F5             6253  ;
0424F5             6254  ;RAD - Convert degrees to radians
0424F5             6255  ;Result is floating-point numeric.
0424F5             6256  ;
0424F5 CD FF 24 04 6257  RAD_FP:			CALL    FPI180
0424F9 CD A8 22 04 6258          		CALL    FDIV
0424FD AF          6259          		XOR     A
0424FE C9          6260          		RET
0424FF             6261  ;
0424FF             6262  ;180/PI
0424FF             6263  ;
0424FF CD E9 2B 04 6264  FPI180:			CALL    SFLOAT_FP
042503 11 2E 65 00 6265          		LD      DE,652EH
042507 D9          6266          		EXX
042508 11 D3 E0 00 6267          		LD      DE,0E0D3H
04250C D9          6268          		EXX
04250D 06 85       6269          		LD      B,85H
04250F C9          6270          		RET
042510             6271  ;
042510             6272  ;SGN - Return -1, 0 or +1
042510             6273  ;Result is integer numeric.
042510             6274  ;
042510 CD 42 2C 04 6275  SGN_FP:			CALL    TEST_FP
042514 B1          6276          		OR      C
042515 C8          6277          		RET     Z               ;ZERO
042516 CB 7C       6278          		BIT     7,H
042518 C2 B0 24 04 6279          		JP      NZ,TRUE_FP         ;-1
04251C CD 66 2C 04 6280          		CALL    ZERO_FP
042520 C3 02 2C 04 6281          		JP      ADD1_FP            ;1
042524             6282  ;
042524             6283  ;VAL - Return numeric value of string.
042524             6284  ;Input: ASCII string at IX
042524             6285  ;Result is variable type numeric.
042524             6286  ;
042524 CD 80 2E 04 6287  VAL_FP:			CALL    SIGNQ
042528 F5          6288          		PUSH    AF
042529 CD 30 2A 04 6289          		CALL    CON_FP
04252D F1          6290          		POP     AF
04252E FE 2D       6291          		CP      '-'
042530 3E 00       6292          		LD      A,0             ;NUMERIC MARKER
042532 C0          6293          		RET     NZ
042533 0D          6294          		DEC     C
042534 0C          6295          		INC     C
042535 CA 1D 2B 04 6296          		JP      Z,NEGATE        ;ZERO/INTEGER
042539 7C          6297          		LD      A,H
04253A EE 80       6298          		XOR     80H             ;CHANGE SIGN (FP)
04253C 67          6299          		LD      H,A
04253D AF          6300          		XOR     A
04253E C9          6301          		RET
04253F             6302  ;
04253F             6303  ;INT - Floor function
04253F             6304  ;Result is integer numeric.
04253F             6305  ;
04253F 0D          6306  INT_FP_:			DEC     C
042540 0C          6307          		INC     C
042541 C8          6308          		RET     Z               ;ZERO/INTEGER
042542 3E 9F       6309          		LD      A,159
042544 44          6310          		LD      B,H             ;B7=SIGN BIT
042545 CD EE 2A 04 6311          		CALL    FIX
042549 08          6312          		EX      AF,AF'
04254A A0          6313          		AND     B
04254B FC 02 2C 04 6314          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04254F 78          6315          		LD      A,B
042550 B7          6316          		OR      A
042551 FC 1D 2B 04 6317          		CALL    M,NEGATE
042555 AF          6318          		XOR     A
042556 4F          6319          		LD      C,A
042557 C9          6320          		RET
042558             6321  ;
042558             6322  ;SQR - square root
042558             6323  ;Result is floating-point numeric.
042558             6324  ;
042558 CD E9 2B 04 6325  SQR_FP:			CALL    SFLOAT_FP
04255C CB 7C       6326  SQR0:			BIT     7,H
04255E 3E 15       6327          		LD      A,NGROOT
042560 C2 C0 20 04 6328          		JP      NZ,ERROR_FP_        ;"-ve root"
042564 0D          6329          		DEC     C
042565 0C          6330          		INC     C
042566 C8          6331          		RET     Z               ;ZERO
042567 CB FC       6332          		SET     7,H             ;IMPLIED 1
042569 CB 41       6333          		BIT     0,C
04256B CC 22 2C 04 6334          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
04256F 79          6335          		LD      A,C
042570 D6 80       6336          		SUB     80H
042572 CB 2F       6337          		SRA     A               ;HALVE EXPONENT
042574 C6 80       6338          		ADD     A,80H
042576 4F          6339          		LD      C,A
042577 C5          6340          		PUSH    BC              ;SAVE EXPONENT
042578 EB          6341          		EX      DE,HL
042579 21 00 00 00 6342          		LD      HL,0
04257D 44          6343          		LD      B,H
04257E 4D          6344          		LD      C,L
04257F D9          6345          		EXX
042580 EB          6346          		EX      DE,HL
042581 21 00 00 00 6347          		LD      HL,0
042585 44          6348          		LD      B,H
042586 4D          6349          		LD      C,L
042587 3E E1       6350          		LD      A,-31
042589 CD 18 2E 04 6351          		CALL    SQRA            ;ROOT
04258D D9          6352          		EXX
04258E CB 78       6353          		BIT     7,B
042590 D9          6354          		EXX
042591 CC 18 2E 04 6355          		CALL    Z,SQRA          ;NORMALISE & INC A
042595 CD 59 2E 04 6356          		CALL    SQRB
042599 B7          6357          		OR      A               ;CLEAR CARRY
04259A CD C6 2D 04 6358          		CALL    DIVB
04259E CB 1B       6359          		RR      E               ;LSB TO CARRY
0425A0 60          6360          		LD      H,B
0425A1 69          6361          		LD      L,C
0425A2 D9          6362          		EXX
0425A3 60          6363          		LD      H,B
0425A4 69          6364          		LD      L,C
0425A5 DC 02 2C 04 6365          		CALL    C,ADD1_FP          ;ROUND UP
0425A9 C1          6366          		POP     BC              ;RESTORE EXPONENT
0425AA DC 2F 2C 04 6367          		CALL    C,INCC
0425AE 1F          6368          		RRA
0425AF 9F          6369          		SBC     A,A
0425B0 81          6370          		ADD     A,C
0425B1 4F          6371          		LD      C,A
0425B2 CB BC       6372          		RES     7,H             ;POSITIVE
0425B4 AF          6373          		XOR     A
0425B5 C9          6374          		RET
0425B6             6375  ;
0425B6             6376  ;TAN - Tangent function
0425B6             6377  ;Result is floating-point numeric.
0425B6             6378  ;
0425B6 CD E9 2B 04 6379  TAN_FP:			CALL    SFLOAT_FP
0425BA CD F6 2C 04 6380          		CALL    PUSH5
0425BE CD E0 25 04 6381          		CALL    COS0
0425C2 CD FF 2C 04 6382          		CALL    POP5
0425C6 CD F6 2C 04 6383          		CALL    PUSH5
0425CA CD 1A 2C 04 6384          		CALL    SWAP_FP
0425CE CD ED 25 04 6385          		CALL    SIN0
0425D2 CD FF 2C 04 6386          		CALL    POP5
0425D6 CD A8 22 04 6387          		CALL    FDIV
0425DA AF          6388          		XOR     A               ;NUMERIC MARKER
0425DB C9          6389          		RET
0425DC             6390  ;
0425DC             6391  ;COS - Cosine function
0425DC             6392  ;Result is floating-point numeric.
0425DC             6393  ;
0425DC CD E9 2B 04 6394  COS_FP:			CALL    SFLOAT_FP
0425E0 CD 45 2B 04 6395  COS0:			CALL    SCALE
0425E4 1C          6396          		INC     E
0425E5 1C          6397          		INC     E
0425E6 7B          6398          		LD      A,E
0425E7 18 10       6399          		JR      SIN1
0425E9             6400  ;
0425E9             6401  ;SIN - Sine function
0425E9             6402  ;Result is floating-point numeric.
0425E9             6403  ;
0425E9 CD E9 2B 04 6404  SIN_FP:			CALL    SFLOAT_FP
0425ED E5          6405  SIN0:			PUSH    HL              ;H7=SIGN
0425EE CD 45 2B 04 6406          		CALL    SCALE
0425F2 F1          6407          		POP     AF
0425F3 07          6408          		RLCA
0425F4 07          6409          		RLCA
0425F5 07          6410          		RLCA
0425F6 E6 04       6411          		AND     4
0425F8 AB          6412          		XOR     E
0425F9 F5          6413  SIN1:			PUSH    AF              ;OCTANT
0425FA CB BC       6414          		RES     7,H
0425FC 1F          6415          		RRA
0425FD CD 8B 26 04 6416          		CALL    PIBY4
042601 DC 2C 22 04 6417          		CALL    C,RSUB          ;X=(PI/4)-X
042605 F1          6418          		POP     AF
042606 F5          6419          		PUSH    AF
042607 E6 03       6420          		AND     3
042609 E2 42 26 04 6421          		JP      PO,SIN2         ;USE COSINE APPROX.
04260D CD F6 2C 04 6422          		CALL    PUSH5           ;SAVE X
042611 CD EE 2C 04 6423          		CALL    SQUARE          ;PUSH X*X
042615 CD 33 2D 04 6424          		CALL    POLY
042619 B7 A8       6425          		DW	0A8B7H          ;a(8)
04261B 11 36       6426          		DW	3611H
04261D 6D          6427          		DB	6DH
04261E 26 DE       6428          		DW	0DE26H          ;a(6)
042620 05 D0       6429          		DW	0D005H
042622 73          6430          		DB	73H
042623 C0 80       6431          		DW	80C0H           ;a(4)
042625 88 08       6432          		DW	888H
042627 79          6433          		DB	79H
042628 9D AA       6434          		DW	0AA9DH          ;a(2)
04262A AA AA       6435          		DW	0AAAAH
04262C 7D          6436          		DB	7DH
04262D 00 00       6437          		DW	0               ;a(0)
04262F 00 00       6438          		DW	0
042631 80          6439          		DB	80H
042632 CD FF 2C 04 6440          		CALL    POP5
042636 CD FF 2C 04 6441          		CALL    POP5
04263A CD 51 23 04 6442          		CALL    FMUL
04263E C3 67 26 04 6443          		JP      SIN3
042642             6444  ;
042642 CD EE 2C 04 6445  SIN2:			CALL    SQUARE          ;PUSH X*X
042646 CD 33 2D 04 6446          		CALL    POLY
04264A 71 D5       6447          		DW	0D571H          ;b(8)
04264C 78 4C       6448          		DW	4C78H
04264E 70          6449          		DB	70H
04264F AF 94       6450          		DW	94AFH           ;b(6)
042651 03 B6       6451          		DW	0B603H
042653 76          6452          		DB	76H
042654 C8 9C       6453          		DW	9CC8H           ;b(4)
042656 AA 2A       6454          		DW	2AAAH
042658 7B          6455          		DB	7BH
042659 DD FF       6456          		DW	0FFDDH          ;b(2)
04265B FF FF       6457          		DW	0FFFFH
04265D 7E          6458          		DB	7EH
04265E 00 00       6459          		DW	0               ;b(0)
042660 00 00       6460          		DW	0
042662 80          6461          		DB	80H
042663 CD FF 2C 04 6462          		CALL    POP5
042667 F1          6463  SIN3:			POP     AF
042668 E6 04       6464          		AND     4
04266A C8          6465          		RET     Z
04266B 0D          6466          		DEC     C
04266C 0C          6467          		INC     C
04266D C8          6468          		RET     Z               ;ZERO
04266E CB FC       6469          		SET     7,H             ;MAKE NEGATIVE
042670 C9          6470          		RET
042671             6471  ;
042671             6472  ;Floating-point one:
042671             6473  ;
042671 21 00 00 00 6474  FONE_FP:			LD      HL,0
042675 D9          6475          		EXX
042676 21 00 00 00 6476          		LD      HL,0
04267A D9          6477          		EXX
04267B 0E 80       6478          		LD      C,80H
04267D C9          6479          		RET
04267E             6480  ;
04267E 11 00 00 00 6481  DONE:			LD      DE,0
042682 D9          6482          		EXX
042683 11 00 00 00 6483          		LD      DE,0
042687 D9          6484          		EXX
042688 06 80       6485          		LD      B,80H
04268A C9          6486          		RET
04268B             6487  ;
04268B 11 0F 49 00 6488  PIBY4:			LD      DE,490FH
04268F D9          6489          		EXX
042690 11 A2 DA 00 6490          		LD      DE,0DAA2H
042694 D9          6491          		EXX
042695 06 7F       6492          		LD      B,7FH
042697 C9          6493          		RET
042698             6494  ;
042698             6495  ;EXP - Exponential function
042698             6496  ;Result is floating-point numeric.
042698             6497  ;
042698 CD E9 2B 04 6498  EXP_FP:			CALL    SFLOAT_FP
04269C CD 29 27 04 6499  EXP0:			CALL    LN2             ;LN(2)
0426A0 D9          6500          		EXX
0426A1 1D          6501  	        	DEC     E
0426A2 01 CF D1 00 6502  		        LD      BC,0D1CFH       ;0.6931471805599453
0426A6 D9          6503          		EXX
0426A7 E5          6504          		PUSH    HL              ;H7=SIGN
0426A8 CD 58 2B 04 6505          		CALL    MOD48           ;"MODULUS"
0426AC F1          6506          		POP     AF
0426AD CB 7B       6507          		BIT     7,E
0426AF 28 0B       6508          		JR      Z,EXP1
0426B1 17          6509          		RLA
0426B2 DA 66 2C 04 6510          		JP      C,ZERO_FP
0426B6 3E 18       6511          		LD      A,EXPRNG
0426B8 C3 C0 20 04 6512          		JP      ERROR_FP_           ;"Exp range"
0426BC             6513  ;
0426BC E6 80       6514  EXP1:			AND     80H
0426BE B3          6515          		OR      E
0426BF F5          6516          		PUSH    AF              ;INTEGER PART
0426C0 CB BC       6517          		RES     7,H
0426C2 CD F6 2C 04 6518          		CALL    PUSH5           ;PUSH X*LN(2)
0426C6 CD 33 2D 04 6519          		CALL    POLY
0426CA 72 40       6520          		DW	4072H           ;a(7)
0426CC 2E 94       6521          		DW	942EH
0426CE 73          6522          		DB	73H
0426CF 65 6F       6523          		DW	6F65H           ;a(6)
0426D1 4F 2E       6524          		DW	2E4FH
0426D3 76          6525          		DB	76H
0426D4 37 6D       6526          		DW	6D37H           ;a(5)
0426D6 02 88       6527          		DW	8802H
0426D8 79          6528          		DB	79H
0426D9 12 E5       6529          		DW	0E512H          ;a(4)
0426DB A0 2A       6530          		DW	2AA0H
0426DD 7B          6531          		DB	7BH
0426DE 14 4F       6532          		DW	4F14H           ;a(3)
0426E0 AA AA       6533          		DW	0AAAAH
0426E2 7D          6534          		DB	7DH
0426E3 56 FD       6535          		DW	0FD56H          ;a(2)
0426E5 FF 7F       6536          		DW	7FFFH
0426E7 7E          6537          		DB	7EH
0426E8 FE FF       6538          		DW	0FFFEH          ;a(1)
0426EA FF FF       6539          		DW	0FFFFH
0426EC 7F          6540          		DB	7FH
0426ED 00 00       6541          		DW	0               ;a(0)
0426EF 00 00       6542          		DW	0
0426F1 80          6543          		DB	80H
0426F2 CD FF 2C 04 6544          		CALL    POP5
0426F6 F1          6545          		POP     AF
0426F7 F5          6546          		PUSH    AF
0426F8 F4 1D 27 04 6547          		CALL    P,RECIP         ;X=1/X
0426FC F1          6548          		POP     AF
0426FD F2 05 27 04 6549          		JP      P,EXP4
042701 E6 7F       6550          		AND     7FH
042703 ED 44       6551          		NEG
042705 C6 80       6552  EXP4:			ADD     A,80H
042707 81          6553          		ADD     A,C
042708 38 06       6554          		JR      C,EXP2
04270A F2 66 2C 04 6555          		JP      P,ZERO_FP          ;UNDERFLOW
04270E 18 04       6556          		JR      EXP3
042710 FA 31 2C 04 6557  EXP2:			JP      M,OFLOW         ;OVERFLOW
042714 C6 80       6558  EXP3:			ADD     A,80H
042716 CA 66 2C 04 6559          		JP      Z,ZERO_FP
04271A 4F          6560          		LD      C,A
04271B AF          6561          		XOR     A               ;NUMERIC MARKER
04271C C9          6562          		RET
04271D             6563  ;
04271D CD 7E 26 04 6564  RECIP:			CALL    DONE
042721 CD 1A 2C 04 6565  RDIV:			CALL    SWAP_FP
042725 C3 A8 22 04 6566          		JP      FDIV            ;RECIPROCAL
042729             6567  ;
042729 11 72 31 00 6568  LN2:			LD      DE,3172H        ;LN(2)
04272D D9          6569          		EXX
04272E 11 F8 17 00 6570          		LD      DE,17F8H
042732 D9          6571          		EXX
042733 06 7F       6572          		LD      B,7FH
042735 C9          6573          		RET
042736             6574  ;
042736             6575  ;LN - Natural log.
042736             6576  ;Result is floating-point numeric.
042736             6577  ;
042736 CD E9 2B 04 6578  LN_FP:			CALL    SFLOAT_FP
04273A 3E 16       6579  LN0:			LD      A,LOGRNG
04273C CB 7C       6580          		BIT     7,H
04273E C2 C0 20 04 6581          		JP      NZ,ERROR_FP_        ;"Log range"
042742 0C          6582          		INC     C
042743 0D          6583          		DEC     C
042744 CA C0 20 04 6584          		JP      Z,ERROR_FP_
042748 11 04 35 00 6585          		LD      DE,3504H        ;SQR(2)
04274C D9          6586          		EXX
04274D 11 33 F3 00 6587          		LD      DE,0F333H       ;1.41421356237
042751 D9          6588          		EXX
042752 CD 79 2C 04 6589          		CALL    ICP0            ;MANTISSA>SQR(2)?
042756 79          6590          		LD      A,C             ;EXPONENT
042757 0E 80       6591          		LD      C,80H           ;1 <= X < 2
042759 38 02       6592          		JR      C,LN4
04275B 0D          6593          		DEC     C
04275C 3C          6594          		INC     A
04275D F5          6595  LN4:			PUSH    AF              ;SAVE EXPONENT
04275E CD 0B 2D 04 6596          		CALL    RATIO           ;X=(X-1)/(X+1)
042762 CD F6 2C 04 6597          		CALL    PUSH5
042766 CD EE 2C 04 6598  		        CALL    SQUARE          ;PUSH X*X
04276A CD 33 2D 04 6599          		CALL    POLY
04276E 48 CC       6600          		DW	0CC48H          ;a(9)
042770 FB 74       6601          		DW	74FBH
042772 7D          6602          		DB	7DH
042773 AF AE       6603          		DW	0AEAFH          ;a(7)
042775 FF 11       6604          		DW	11FFH
042777 7E          6605          		DB	7EH
042778 8C D9       6606          		DW	0D98CH          ;a(5)
04277A CD 4C       6607          		DW	4CCDH
04277C 7E          6608          		DB	7EH
04277D E3 A9       6609          		DW	0A9E3H          ;a(3)
04277F AA 2A       6610          		DW	2AAAH
042781 7F          6611          		DB	7FH
042782 00 00       6612          		DW	0               ;a(1)
042784 00 00       6613          		DW	0
042786 81          6614          		DB	81H
042787 CD FF 2C 04 6615          		CALL    POP5
04278B CD FF 2C 04 6616          		CALL    POP5
04278F CD 51 23 04 6617          		CALL    FMUL
042793 F1          6618          		POP     AF              ;EXPONENT
042794 CD F6 2C 04 6619          		CALL    PUSH5
042798 08          6620          		EX      AF,AF'
042799 CD 66 2C 04 6621          		CALL    ZERO_FP
04279D 08          6622          		EX      AF,AF'
04279E D6 80       6623          		SUB     80H
0427A0 28 1F       6624          		JR      Z,LN3
0427A2 30 02       6625          		JR      NC,LN1
0427A4 2F          6626          		CPL
0427A5 3C          6627          		INC     A
0427A6 67          6628  LN1:			LD      H,A
0427A7 0E 87       6629          		LD      C,87H
0427A9 F5          6630          		PUSH    AF
0427AA CD C9 2B 04 6631          		CALL    FLOAT_
0427AE CB BC       6632          		RES     7,H
0427B0 CD 29 27 04 6633          		CALL    LN2
0427B4 CD 51 23 04 6634          		CALL    FMUL
0427B8 F1          6635          		POP     AF
0427B9 30 06       6636          		JR      NC,LN3
0427BB FA C1 27 04 6637          		JP      M,LN3
0427BF CB FC       6638          		SET     7,H
0427C1 CD FF 2C 04 6639  LN3:			CALL    POP5
0427C5 CD 3F 22 04 6640          		CALL    FADD
0427C9 AF          6641          		XOR     A
0427CA C9          6642          		RET
0427CB             6643  ;
0427CB             6644  ;LOG - base-10 logarithm.
0427CB             6645  ;Result is floating-point numeric.
0427CB             6646  ;
0427CB CD 36 27 04 6647  LOG_FP:			CALL    LN_FP
0427CF 11 5B 5E 00 6648          		LD      DE,5E5BH        ;LOG(e)
0427D3 D9          6649          		EXX
0427D4 11 A9 D8 00 6650          		LD      DE,0D8A9H
0427D8 D9          6651          		EXX
0427D9 06 7E       6652          		LD      B,7EH
0427DB CD 51 23 04 6653          		CALL    FMUL
0427DF AF          6654          		XOR     A
0427E0 C9          6655          		RET
0427E1             6656  ;
0427E1             6657  ;ASN - Arc-sine
0427E1             6658  ;Result is floating-point numeric.
0427E1             6659  ;
0427E1 CD E9 2B 04 6660  ASN_FP:			CALL    SFLOAT_FP
0427E5 CD F6 2C 04 6661          		CALL    PUSH5
0427E9 CD E6 2C 04 6662          		CALL    COPY_
0427ED CD 51 23 04 6663          		CALL    FMUL
0427F1 CD 7E 26 04 6664          		CALL    DONE
0427F5 CD 2C 22 04 6665          		CALL    RSUB
0427F9 CD 5C 25 04 6666          		CALL    SQR0
0427FD CD FF 2C 04 6667          		CALL    POP5
042801 0C          6668          		INC     C
042802 0D          6669          		DEC     C
042803 3E 02       6670          		LD      A,2
042805 D5          6671          		PUSH    DE
042806 CA 8B 28 04 6672          		JP      Z,ACS1
04280A D1          6673          		POP     DE
04280B CD 21 27 04 6674          		CALL    RDIV
04280F 18 04       6675          		JR      ATN0
042811             6676  ;
042811             6677  ;ATN - arc-tangent
042811             6678  ;Result is floating-point numeric.
042811             6679  ;
042811 CD E9 2B 04 6680  ATN_FP:			CALL    SFLOAT_FP
042815 E5          6681  ATN0:			PUSH    HL              ;SAVE SIGN
042816 CB BC       6682          		RES     7,H
042818 11 13 54 00 6683          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
04281C D9          6684          		EXX
04281D 11 D0 CC 00 6685          		LD      DE,0CCD0H
042821 D9          6686          		EXX
042822 06 7E       6687          		LD      B,7EH
042824 CD 76 2C 04 6688          		CALL    FCP0            ;COMPARE
042828 06 00       6689          		LD      B,0
04282A 38 22       6690          		JR      C,ATN2
04282C 11 82 1A 00 6691          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
042830 D9          6692          		EXX
042831 11 9A 79 00 6693          		LD      DE,799AH
042835 D9          6694          		EXX
042836 06 81       6695          		LD      B,81H
042838 CD 76 2C 04 6696          		CALL    FCP0            ;COMPARE
04283C 38 0A       6697          		JR      C,ATN1
04283E CD 1D 27 04 6698          		CALL    RECIP           ;X=1/X
042842 06 02       6699          		LD      B,2
042844 C3 4E 28 04 6700          		JP      ATN2
042848 CD 0B 2D 04 6701  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
04284C 06 01       6702          		LD      B,1
04284E C5          6703  ATN2:			PUSH    BC              ;SAVE FLAG
04284F CD F6 2C 04 6704          		CALL    PUSH5
042853 CD EE 2C 04 6705          		CALL    SQUARE          ;PUSH X*X
042857 CD 33 2D 04 6706          		CALL    POLY
04285B 35 F3       6707          		DW	0F335H          ;a(13)
04285D D8 37       6708          		DW	37D8H
04285F 7B          6709          		DB	7BH
042860 91 6B       6710          		DW	6B91H           ;a(11)
042862 B9 AA       6711          		DW	0AAB9H
042864 7C          6712          		DB	7CH
042865 DE 41       6713          		DW	41DEH           ;a(9)
042867 97 61       6714          		DW	6197H
042869 7C          6715          		DB	7CH
04286A 7B 9D       6716          		DW	9D7BH           ;a(7)
04286C 37 92       6717          		DW	9237H
04286E 7D          6718          		DB	7DH
04286F 5A 2A       6719          		DW	2A5AH           ;a(5)
042871 CC 4C       6720          		DW	4CCCH
042873 7D          6721          		DB	7DH
042874 5C A9       6722          		DW	0A95CH          ;a(3)
042876 AA AA       6723          		DW	0AAAAH
042878 7E          6724          		DB	7EH
042879 00 00       6725          		DW	0               ;a(1)
04287B 00 00       6726          		DW	0
04287D 80          6727          		DB	80H
04287E CD FF 2C 04 6728          		CALL    POP5
042882 CD FF 2C 04 6729          		CALL    POP5
042886 CD 51 23 04 6730          		CALL    FMUL
04288A F1          6731          		POP     AF
04288B CD 8B 26 04 6732  ACS1:			CALL    PIBY4           ;PI/4
04288F 1F          6733          		RRA
042890 F5          6734          		PUSH    AF
042891 DC 3F 22 04 6735          		CALL    C,FADD
042895 F1          6736          		POP     AF
042896 04          6737          		INC     B
042897 1F          6738          		RRA
042898 DC 2C 22 04 6739          		CALL    C,RSUB
04289C F1          6740          		POP     AF
04289D B7          6741          		OR      A
04289E F0          6742          		RET     P
04289F CB FC       6743          		SET     7,H             ;MAKE NEGATIVE
0428A1 AF          6744          		XOR     A
0428A2 C9          6745          		RET
0428A3             6746  ;
0428A3             6747  ;ACS - Arc cosine=PI/2-ASN.
0428A3             6748  ;Result is floating point numeric.
0428A3             6749  ;
0428A3 CD E1 27 04 6750  ACS_FP:			CALL    ASN_FP
0428A7 3E 02       6751          		LD      A,2
0428A9 F5          6752          		PUSH    AF
0428AA 18 DF       6753          		JR      ACS1
0428AC             6754  ;
0428AC             6755  ;Function STR - convert numeric value to ASCII string.
0428AC             6756  ;   Inputs: HLH'L'C = integer or floating-point number
0428AC             6757  ;           DE = address at which to store string
0428AC             6758  ;           IX = address of @% format control
0428AC             6759  ;  Outputs: String stored, with NUL terminator
0428AC             6760  ;
0428AC             6761  ;First normalise for decimal output:
0428AC             6762  ;
0428AC CD E9 2B 04 6763  STR_FP:			CALL    SFLOAT_FP
0428B0 06 00       6764          		LD      B,0             ;DEFAULT PT. POSITION
0428B2 CB 7C       6765          		BIT     7,H             ;NEGATIVE?
0428B4 28 06       6766          		JR      Z,STR10
0428B6 CB BC       6767          		RES     7,H
0428B8 3E 2D       6768          		LD      A,'-'
0428BA 12          6769          		LD      (DE),A          ;STORE SIGN
0428BB 13          6770          		INC     DE
0428BC AF          6771  STR10:			XOR     A               ;CLEAR A
0428BD B9          6772          		CP      C
0428BE 28 4E       6773          		JR      Z,STR02          ;ZERO
0428C0 D5          6774          		PUSH    DE              ;SAVE TEXT POINTER
0428C1 78          6775          		LD      A,B
0428C2 F5          6776  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428C3 79          6777          		LD      A,C             ;BINARY EXPONENT
0428C4 FE A1       6778          		CP      161
0428C6 30 1C       6779          		JR      NC,STR14
0428C8 FE 9B       6780          		CP      155
0428CA 30 29       6781          		JR      NC,STR15
0428CC 2F          6782          		CPL
0428CD FE E1       6783          		CP      225
0428CF 38 02       6784          		JR      C,STR13
0428D1 3E F8       6785          		LD      A,-8
0428D3 C6 1C       6786  STR13:			ADD     A,28
0428D5 CD 62 2D 04 6787          		CALL    POWR10
0428D9 F5          6788          		PUSH    AF
0428DA CD 51 23 04 6789          		CALL    FMUL
0428DE F1          6790          		POP     AF
0428DF 47          6791          		LD      B,A
0428E0 F1          6792          		POP     AF
0428E1 90          6793          		SUB     B
0428E2 18 DE       6794          		JR      STR11
0428E4 D6 20       6795  STR14:			SUB     32
0428E6 CD 62 2D 04 6796          		CALL    POWR10
0428EA F5          6797          		PUSH    AF
0428EB CD A8 22 04 6798          		CALL    FDIV
0428EF F1          6799          		POP     AF
0428F0 47          6800          		LD      B,A
0428F1 F1          6801          		POP     AF
0428F2 80          6802          		ADD     A,B
0428F3 18 CD       6803          		JR      STR11
0428F5 3E 09       6804  STR15:			LD      A,9
0428F7 CD 62 2D 04 6805          		CALL    POWR10          ;10^9
0428FB CD 76 2C 04 6806          		CALL    FCP0
0428FF 79          6807          		LD      A,C
042900 C1          6808          		POP     BC
042901 4F          6809          		LD      C,A
042902 CB FC       6810          		SET     7,H             ;IMPLIED 1
042904 DC 9E 2C 04 6811          		CALL    C,X10B          ;X10, DEC B
042908 D1          6812          		POP     DE              ;RESTORE TEXT POINTER
042909 CB B9       6813          		RES     7,C
04290B 3E 00       6814          		LD      A,0
04290D 17          6815          		RLA                     ;PUT CARRY IN LSB
04290E             6816  ;
04290E             6817  ;At this point decimal normalisation has been done,
04290E             6818  ;now convert to decimal digits:
04290E             6819  ;      AHLH'L' = number in normalised integer form
04290E             6820  ;            B = decimal place adjustment
04290E             6821  ;            C = binary place adjustment (29-33)
04290E             6822  ;
04290E 0C          6823  STR02:			INC     C
04290F 08          6824          		EX      AF,AF'          ;SAVE A
042910 78          6825          		LD      A,B
042911 DD CB 02 4E 6826          		BIT     1,(IX+2)
042915 20 08       6827          		JR      NZ,STR20
042917 AF          6828          		XOR     A
042918 DD BE 01    6829          		CP      (IX+1)
04291B 28 0B       6830          		JR      Z,STR21
04291D 3E F6       6831          		LD      A,-10
04291F DD 86 01    6832  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042922 B7          6833          		OR      A               ;CLEAR CARRY
042923 FA 28 29 04 6834          		JP      M,STR21
042927 AF          6835          		XOR     A
042928 F5          6836  STR21:			PUSH    AF
042929 08          6837          		EX      AF,AF'          ;RESTORE A
04292A CD D2 2C 04 6838  STR22:			CALL    X2              ;RL AHLH'L'
04292E 8F          6839          		ADC     A,A
04292F FE 0A       6840          		CP      10
042931 38 05       6841          		JR      C,STR23
042933 D6 0A       6842          		SUB     10
042935 D9          6843          		EXX
042936 2C          6844          		INC     L               ;SET RESULT BIT
042937 D9          6845          		EXX
042938 0D          6846  STR23:			DEC     C
042939 20 EF       6847          		JR      NZ,STR22        ;32 TIMES
04293B 4F          6848          		LD      C,A             ;REMAINDER
04293C 7C          6849          		LD      A,H
04293D E6 3F       6850          		AND     3FH             ;CLEAR OUT JUNK
04293F 67          6851          		LD      H,A
042940 F1          6852          		POP     AF
042941 F2 4F 29 04 6853          		JP      P,STR24
042945 3C          6854          		INC     A
042946 20 1C       6855          		JR      NZ,STR26
042948 3E 04       6856          		LD      A,4
04294A B9          6857          		CP      C               ;ROUND UP?
04294B 3E 00       6858          		LD      A,0
04294D 18 15       6859          		JR      STR26
04294F F5          6860  STR24:			PUSH    AF
042950 79          6861          		LD      A,C
042951 CE 30       6862          		ADC     A,'0'           ;ADD CARRY
042953 FE 30       6863          		CP      '0'
042955 28 05       6864          		JR      Z,STR25         ;SUPPRESS ZERO
042957 FE 3A       6865          		CP      '9'+1
042959 3F          6866          		CCF
04295A 30 08       6867          		JR      NC,STR26
04295C E3          6868  STR25:			EX      (SP),HL
04295D CB 75       6869          		BIT     6,L             ;ZERO FLAG
04295F E3          6870  		        EX      (SP),HL
042960 20 05       6871          		JR      NZ,STR27
042962 3E 30       6872          		LD      A,'0'
042964 3C          6873  STR26:			INC     A               ;SET +VE
042965 3D          6874          		DEC     A
042966 F5          6875          		PUSH    AF              ;PUT ON STACK + CARRY
042967 04          6876  STR27:			INC     B
042968 CD 42 2C 04 6877          		CALL    TEST_FP            ;IS HLH'L' ZERO?
04296C 0E 20       6878          		LD      C,32
04296E 3E 00       6879          		LD      A,0
042970 20 B8       6880          		JR      NZ,STR22
042972 F1          6881          		POP     AF
042973 F5          6882          		PUSH    AF
042974 3E 00       6883          		LD      A,0
042976 38 B2       6884          		JR      C,STR22
042978             6885  ;
042978             6886  ;At this point, the decimal character string is stored
042978             6887  ; on the stack. Trailing zeroes are suppressed and may
042978             6888  ; need to be replaced.
042978             6889  ;B register holds decimal point position.
042978             6890  ;Now format number and store as ASCII string:
042978             6891  ;
042978 EB          6892  STR3:			EX      DE,HL           ;STRING POINTER
042979 0E FF       6893          		LD      C,-1            ;FLAG "E"
04297B 16 01       6894          		LD      D,1
04297D DD 5E 01    6895          		LD      E,(IX+1)        ;f2
042980 DD CB 02 46 6896          		BIT     0,(IX+2)
042984 20 35       6897          		JR      NZ,STR34        ;E MODE
042986 DD CB 02 4E 6898          		BIT     1,(IX+2)
04298A 28 12       6899          		JR      Z,STR31
04298C 78          6900          		LD      A,B             ;F MODE
04298D B7          6901          		OR      A
04298E 28 05       6902          		JR      Z,STR30
042990 FA 95 29 04 6903          		JP      M,STR30
042994 50          6904          		LD      D,B
042995 7A          6905  STR30:			LD      A,D
042996 DD 86 01    6906          		ADD     A,(IX+1)
042999 5F          6907          		LD      E,A
04299A FE 0B       6908          		CP      11
04299C 38 19       6909          		JR      C,STR32
04299E 78          6910  STR31:			LD      A,B             ;G MODE
04299F 11 01 01 00 6911          		LD      DE,101H
0429A3 B7          6912          		OR      A
0429A4 FA BB 29 04 6913          		JP      M,STR34
0429A8 28 0D       6914          		JR      Z,STR32
0429AA DD 7E 01    6915          		LD      A,(IX+1)
0429AD B7          6916          		OR      A
0429AE 20 02       6917          		JR      NZ,STR3A
0429B0 3E 0A       6918          		LD      A,10
0429B2 B8          6919  STR3A:			CP      B
0429B3 38 06       6920          		JR      C,STR34
0429B5 50          6921          		LD      D,B
0429B6 58          6922          		LD      E,B
0429B7 78          6923  STR32:			LD      A,B
0429B8 C6 81       6924          		ADD     A,129
0429BA 4F          6925          		LD      C,A
0429BB CB FA       6926  STR34:			SET     7,D
0429BD 1D          6927          		DEC     E
0429BE 7A          6928  STR35:			LD      A,D
0429BF B9          6929          		CP      C
0429C0 30 0E       6930          		JR      NC,STR33
0429C2 F1          6931  STR36:			POP     AF
0429C3 28 04       6932          		JR      Z,STR37
0429C5 F2 D2 29 04 6933          		JP      P,STR38
0429C9 F5          6934  STR37:			PUSH    AF
0429CA 1C          6935          		INC     E
0429CB 1D          6936          		DEC     E
0429CC FA E3 29 04 6937          		JP      M,STR4
0429D0 3E 30       6938  STR33:			LD      A,'0'
0429D2 15          6939  STR38:			DEC     D
0429D3 E2 DA 29 04 6940          		JP      PO,STR39
0429D7 36 2E       6941          		LD      (HL),'.'
0429D9 23          6942          		INC     HL
0429DA 77          6943  STR39:			LD      (HL),A
0429DB 23          6944          		INC     HL
0429DC 1D          6945          		DEC     E
0429DD F2 BE 29 04 6946          		JP      P,STR35
0429E1 18 DF       6947          		JR      STR36
0429E3             6948  ;
0429E3 F1          6949  STR4:			POP     AF
0429E4 0C          6950  STR40:			INC     C
0429E5 4D          6951          		LD      C,L
0429E6 20 28       6952          		JR      NZ,STR44
0429E8 36 45       6953          		LD      (HL),'E'        ;EXPONENT
0429EA 23          6954          		INC     HL
0429EB 78          6955          		LD      A,B
0429EC 3D          6956          		DEC     A
0429ED F2 F6 29 04 6957          		JP      P,STR41
0429F1 36 2D       6958          		LD      (HL),'-'
0429F3 23          6959          		INC     HL
0429F4 ED 44       6960          		NEG
0429F6 36 30       6961  STR41:			LD      (HL),'0'
0429F8 28 15       6962          		JR      Z,STR47
0429FA FE 0A       6963          		CP      10
0429FC 47          6964          		LD      B,A
0429FD 3E 3A       6965          		LD      A,':'
0429FF 38 03       6966          		JR      C,STR42
042A01 23          6967          		INC     HL
042A02 36 30       6968          		LD      (HL),'0'
042A04 34          6969  STR42:			INC     (HL)
042A05 BE          6970          		CP      (HL)
042A06 20 05       6971          		JR      NZ,STR43
042A08 36 30       6972          		LD      (HL),'0'
042A0A 2B          6973          		DEC     HL
042A0B 34          6974          		INC     (HL)
042A0C 23          6975          		INC     HL
042A0D 10 F5       6976  STR43:			DJNZ    STR42
042A0F 23          6977  STR47:			INC     HL
042A10 EB          6978  STR44:			EX      DE,HL
042A11 C9          6979        			RET
042A12             6980  ;
042A12             6981  ;Support subroutines:
042A12             6982  ;
042A12 DD 46 04    6983  DLOAD5:			LD      B,(IX+4)
042A15 D9          6984          		EXX
042A16 DD 5E 00    6985          		LD      E,(IX+0)
042A19 DD 56 01    6986          		LD      D,(IX+1)
042A1C D9          6987          		EXX
042A1D DD 5E 02    6988          		LD      E,(IX+2)
042A20 DD 56 03    6989          		LD      D,(IX+3)
042A23 C9          6990          		RET
042A24             6991  ;
042A24 DD 46 06    6992  DLOAD5_SPL:		LD      B,(IX+6)
042A27 D9          6993  			EXX
042A28 DD 17 00    6994  			LD	DE, (IX+0)
042A2B D9          6995  			EXX
042A2C DD 17 03    6996  			LD	DE, (IX+3)
042A2F C9          6997  			RET
042A30             6998  ;
042A30             6999  ;CON_FP - Get unsigned numeric constant from ASCII string.
042A30             7000  ;   Inputs: ASCII string at (IX).
042A30             7001  ;  Outputs: Variable-type result in HLH'L'C
042A30             7002  ;           IX updated (points to delimiter)
042A30             7003  ;           A7 = 0 (numeric marker)
042A30             7004  ;
042A30 CD 66 2C 04 7005  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A34 0E 00       7006          		LD      C,0             ;TRUNCATION COUNTER
042A36 CD C4 2A 04 7007          		CALL    UINT          ;GET INTEGER PART
042A3A FE 2E       7008          		CP      '.'
042A3C 06 00       7009          		LD      B,0             ;DECL. PLACE COUNTER
042A3E CC C2 2A 04 7010          		CALL    Z,NUMBIX        ;GET FRACTION PART
042A42 FE 45       7011          		CP      'E'
042A44 3E 00       7012          		LD      A,0             ;INITIALISE EXPONENT
042A46 CC 90 2A 04 7013          		CALL    Z,GETEXP        ;GET EXPONENT
042A4A CB 7C       7014          		BIT     7,H
042A4C 20 08       7015          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A4E B7          7016          		OR      A
042A4F 20 05       7017          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A51 B8          7018          		CP      B
042A52 20 02       7019          		JR      NZ,CON0         ;DECIMAL POINT
042A54 B9          7020          		CP      C
042A55 C8          7021          		RET     Z               ;INTEGER
042A56 90          7022  CON0:			SUB     B
042A57 81          7023          		ADD     A,C
042A58 0E 9F       7024          		LD      C,159
042A5A CD C9 2B 04 7025          		CALL    FLOAT_
042A5E CB BC       7026          		RES     7,H             ;DITCH IMPLIED 1
042A60 B7          7027          		OR      A
042A61 C8          7028          		RET     Z               ;DONE
042A62 FA 70 2A 04 7029          		JP      M,CON2          ;NEGATIVE EXPONENT
042A66 CD 62 2D 04 7030          		CALL    POWR10
042A6A CD 51 23 04 7031          		CALL    FMUL            ;SCALE
042A6E AF          7032          		XOR     A
042A6F C9          7033          		RET
042A70 FE DA       7034  CON2:			CP      -38
042A72 38 0C       7035          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A74 ED 44       7036          		NEG
042A76 CD 62 2D 04 7037          		CALL    POWR10
042A7A CD A8 22 04 7038          		CALL    FDIV            ;SCALE
042A7E AF          7039          		XOR     A
042A7F C9          7040          		RET
042A80 F5          7041  CON3:			PUSH    AF
042A81 3E 26       7042          		LD      A,38
042A83 CD 62 2D 04 7043          		CALL    POWR10
042A87 CD A8 22 04 7044          		CALL    FDIV
042A8B F1          7045          		POP     AF
042A8C C6 26       7046          		ADD     A,38
042A8E 18 E0       7047          		JR      CON2
042A90             7048  ;
042A90             7049  ;GETEXP - Get decimal exponent from string
042A90             7050  ;     Inputs: ASCII string at (IX)
042A90             7051  ;             (IX points at 'E')
042A90             7052  ;             A = initial value
042A90             7053  ;    Outputs: A = new exponent
042A90             7054  ;             IX updated.
042A90             7055  ;   Destroys: A,A',IX,F,F'
042A90             7056  ;
042A90 C5          7057  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A91 47          7058          		LD      B,A             ;INITIAL VALUE
042A92 0E 02       7059          		LD      C,2             ;2 DIGITS MAX
042A94 DD 23       7060          		INC     IX              ;BUMP PAST 'E'
042A96 CD 80 2E 04 7061          		CALL    SIGNQ
042A9A 08          7062          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A9B CD 76 2E 04 7063  GETEX1:			CALL    DIGITQ
042A9F 38 18       7064          		JR      C,GETEX2
042AA1 78          7065          		LD      A,B             ;B=B*10
042AA2 87          7066          		ADD     A,A
042AA3 87          7067          		ADD     A,A
042AA4 80          7068          		ADD     A,B
042AA5 87          7069          		ADD     A,A
042AA6 47          7070          		LD      B,A
042AA7 DD 7E 00    7071          		LD      A,(IX)          ;GET BACK DIGIT
042AAA DD 23       7072          		INC     IX
042AAC E6 0F       7073          		AND     0FH             ;MASK UNWANTED BITS
042AAE 80          7074          		ADD     A,B             ;ADD IN DIGIT
042AAF 47          7075          		LD      B,A
042AB0 0D          7076          		DEC     C
042AB1 F2 9B 2A 04 7077          		JP      P,GETEX1
042AB5 06 64       7078          		LD      B,100           ;FORCE OVERFLOW
042AB7 18 E2       7079          		JR      GETEX1
042AB9 08          7080  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042ABA FE 2D       7081          		CP      '-'
042ABC 78          7082          		LD      A,B
042ABD C1          7083          		POP     BC              ;RESTORE
042ABE C0          7084          		RET     NZ
042ABF ED 44       7085          		NEG                     ;NEGATE EXPONENT
042AC1 C9          7086          		RET
042AC2             7087  ;
042AC2             7088  ;UINT: Get unsigned integer from string.
042AC2             7089  ;    Inputs: string at (IX)
042AC2             7090  ;            C = truncated digit count
042AC2             7091  ;                (initially zero)
042AC2             7092  ;            B = total digit count
042AC2             7093  ;            HLH'L' = initial value
042AC2             7094  ;   Outputs: HLH'L' = number (binary integer)
042AC2             7095  ;            A = delimiter.
042AC2             7096  ;            B, C & IX updated
042AC2             7097  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042AC2             7098  ;
042AC2 DD 23       7099  NUMBIX:			INC     IX
042AC4 CD 76 2E 04 7100  UINT:			CALL    DIGITQ
042AC8 D8          7101          		RET     C
042AC9 04          7102          		INC     B               ;INCREMENT DIGIT COUNT
042ACA DD 23       7103          		INC     IX
042ACC CD BF 2C 04 7104          		CALL    X10             ;*10 & COPY OLD VALUE
042AD0 38 15       7105          		JR      C,NUMB1         ;OVERFLOW
042AD2 0D          7106          		DEC     C               ;SEE IF TRUNCATED
042AD3 0C          7107          		INC     C
042AD4 20 11       7108          		JR      NZ,NUMB1        ;IMPORTANT!
042AD6 E6 0F       7109          		AND     0FH
042AD8 D9          7110          		EXX
042AD9 06 00       7111          		LD      B,0
042ADB 4F          7112          		LD      C,A
042ADC 52 09       7113          		ADD.S   HL,BC           ;ADD IN DIGIT
042ADE D9          7114          		EXX
042ADF 30 E3       7115          		JR      NC,UINT
042AE1 52 23       7116          		INC.S   HL              ;CARRY
042AE3 7C          7117          		LD      A,H
042AE4 B5          7118          		OR      L
042AE5 20 DD       7119          		JR      NZ,UINT
042AE7 0C          7120  NUMB1:			INC     C               ;TRUNCATION COUNTER
042AE8 CD 1D 2C 04 7121          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AEC 18 D6       7122          		JR      UINT
042AEE             7123  ;
042AEE             7124  ;FIX - Fix number to specified exponent value.
042AEE             7125  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AEE             7126  ;            A = desired exponent (A>C)
042AEE             7127  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AEE             7128  ;            fraction shifted into B'C'
042AEE             7129  ;            A'F' positive if integer input
042AEE             7130  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AEE             7131  ;
042AEE 08          7132  FIX:			EX      AF,AF'
042AEF AF          7133          		XOR     A
042AF0 08          7134          		EX      AF,AF'
042AF1 CB FC       7135          		SET     7,H             ;IMPLIED 1
042AF3 CD 22 2C 04 7136  FIX1:			CALL    DIV2
042AF7 B9          7137          		CP      C
042AF8 C8          7138          		RET     Z
042AF9 D2 F3 2A 04 7139          		JP      NC,FIX1
042AFD C3 31 2C 04 7140          		JP      OFLOW
042B01             7141  ;
042B01             7142  ;SFIX - Convert to integer if necessary.
042B01             7143  ;    Input: Variable-type number in HLH'L'C
042B01             7144  ;   Output: Integer in HLH'L', C=0
042B01             7145  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042B01             7146  ;
042B01             7147  ;NEGATE - Negate HLH'L'
042B01             7148  ;    Destroys: H,L,H',L',F
042B01             7149  ;
042B01 CD 1A 2C 04 7150  FIX2:			CALL    SWAP_FP
042B05 CD 0D 2B 04 7151          		CALL    SFIX_FP
042B09 CD 1A 2C 04 7152          		CALL    SWAP_FP
042B0D 0D          7153  SFIX_FP:			DEC     C
042B0E 0C          7154          		INC     C
042B0F C8          7155          		RET     Z               ;INTEGER/ZERO
042B10 CB 7C       7156          		BIT     7,H             ;SIGN
042B12 F5          7157          		PUSH    AF
042B13 3E 9F       7158          		LD      A,159
042B15 CD EE 2A 04 7159          		CALL    FIX
042B19 F1          7160          		POP     AF
042B1A 0E 00       7161          		LD      C,0
042B1C C8          7162          		RET     Z
042B1D B7          7163  NEGATE:			OR      A               ;CLEAR CARRY
042B1E D9          7164          		EXX
042B1F D5          7165  NEG0:			PUSH    DE
042B20 EB          7166          		EX      DE,HL
042B21 21 00 00 00 7167          		LD      HL,0
042B25 52 ED 52    7168          		SBC.S   HL,DE
042B28 D1          7169          		POP     DE
042B29 D9          7170          		EXX
042B2A D5          7171          		PUSH    DE
042B2B EB          7172          		EX      DE,HL
042B2C 21 00 00 00 7173          		LD      HL,0
042B30 52 ED 52    7174          		SBC.S   HL,DE
042B33 D1          7175          		POP     DE
042B34 C9          7176          		RET
042B35             7177  ;
042B35             7178  ;NEG - Negate HLH'L'B'C'
042B35             7179  ;    Also complements A (used in FADD)
042B35             7180  ;    Destroys: A,H,L,B',C',H',L',F
042B35             7181  ;
042B35 D9          7182  NEG_:			EXX
042B36 2F          7183          		CPL
042B37 E5          7184          		PUSH    HL
042B38 B7          7185          		OR      A               ;CLEAR CARRY
042B39 21 00 00 00 7186          		LD      HL,0
042B3D 52 ED 42    7187          		SBC.S   HL,BC
042B40 44          7188          		LD      B,H
042B41 4D          7189          		LD      C,L
042B42 E1          7190          		POP     HL
042B43 18 DA       7191          		JR      NEG0
042B45             7192  ;
042B45             7193  ;SCALE - Trig scaling.
042B45             7194  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B45             7195  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B45             7196  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B45             7197  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B45             7198  ;           E = quotient (bit 7 is sticky)
042B45             7199  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B45             7200  ;FLO48 - Float unsigned number (48 bits)
042B45             7201  ;    Input/output in HLH'L'B'C'C
042B45             7202  ;   Destroys: C,H,L,B',C',H',L',F
042B45             7203  ;
042B45 3E 96       7204  SCALE:			LD      A,150
042B47 B9          7205          		CP      C
042B48 3E 17       7206          		LD      A,ACLOST
042B4A DA C0 20 04 7207          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B4E CD 8B 26 04 7208          		CALL    PIBY4
042B52 D9          7209          		EXX
042B53 01 69 21 00 7210          		LD      BC,2169H        ;3.141592653589793238
042B57 D9          7211          		EXX
042B58 CB FA       7212  MOD48:			SET     7,D             ;IMPLIED 1
042B5A CB FC       7213          		SET     7,H
042B5C 79          7214          		LD      A,C
042B5D 0E 00       7215          		LD      C,0             ;INIT QUOTIENT
042B5F DD 21 00 00 7216          		LD      IX,0
       00          
042B64 DD E5       7217          		PUSH    IX              ;PUT ZERO ON STACK
042B66 B8          7218          		CP      B
042B67 38 46       7219          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B69 D9          7220  MOD481:			EXX                     ;CARRY=0 HERE
042B6A E3          7221          		EX      (SP),HL
042B6B 52 ED 42    7222          		SBC.S   HL,BC
042B6E E3          7223          		EX      (SP),HL
042B6F 52 ED 52    7224          		SBC.S   HL,DE
042B72 D9          7225          		EXX
042B73 52 ED 52    7226          		SBC.S   HL,DE
042B76 30 0C       7227          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B78 D9          7228          		EXX
042B79 E3          7229          		EX      (SP),HL
042B7A 52 09       7230          		ADD.S   HL,BC
042B7C E3          7231          		EX      (SP),HL
042B7D 52 ED 5A    7232          		ADC.S   HL,DE
042B80 D9          7233          		EXX
042B81 52 ED 5A    7234          		ADC.S   HL,DE
042B84 3F          7235  MOD482:			CCF
042B85 CB 11       7236          		RL      C               ;QUOTIENT
042B87 30 02       7237          		JR      NC,MOD483
042B89 CB F9       7238          		SET     7,C             ;STICKY BIT
042B8B 3D          7239  MOD483:			DEC     A
042B8C B8          7240          		CP      B
042B8D 38 1F       7241          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B8F E3          7242          		EX      (SP),HL
042B90 52 29       7243          		ADD.S   HL,HL           ;DIVIDEND * 2
042B92 E3          7244          		EX      (SP),HL
042B93 D9          7245          		EXX
042B94 52 ED 6A    7246          		ADC.S   HL,HL
042B97 D9          7247          		EXX
042B98 52 ED 6A    7248          		ADC.S   HL,HL
042B9B 30 CC       7249          		JR      NC,MOD481       ;AGAIN
042B9D B7          7250          		OR      A
042B9E D9          7251          		EXX
042B9F E3          7252          		EX      (SP),HL
042BA0 52 ED 42    7253          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042BA3 E3          7254          		EX      (SP),HL
042BA4 52 ED 52    7255          		SBC.S   HL,DE
042BA7 D9          7256          		EXX
042BA8 52 ED 52    7257          		SBC.S   HL,DE
042BAB B7          7258          		OR      A
042BAC 18 D6       7259          		JR      MOD482
042BAE             7260  ;
042BAE 3C          7261  MOD484:			INC     A
042BAF 59          7262  MOD485:			LD      E,C             ;QUOTIENT
042BB0 4F          7263          		LD      C,A             ;REMAINDER EXPONENT
042BB1 D9          7264          		EXX
042BB2 C1          7265          		POP     BC
042BB3 D9          7266          		EXX
042BB4 CB 7C       7267  FLO48:			BIT     7,H
042BB6 C0          7268          		RET     NZ
042BB7 D9          7269          		EXX
042BB8 CB 21       7270          		SLA     C
042BBA CB 10       7271          		RL      B
042BBC 52 ED 6A    7272          		ADC.S   HL,HL
042BBF D9          7273          		EXX
042BC0 52 ED 6A    7274          		ADC.S   HL,HL
042BC3 0D          7275          		DEC     C
042BC4 C2 B4 2B 04 7276          		JP      NZ,FLO48
042BC8 C9          7277          		RET
042BC9             7278  ;
042BC9             7279  ;Float unsigned number
042BC9             7280  ;    Input/output in HLH'L'C
042BC9             7281  ;   Destroys: C,H,L,H',L',F
042BC9             7282  ;
042BC9 CB 7C       7283  FLOAT_:			BIT     7,H
042BCB C0          7284          		RET     NZ
042BCC D9          7285          		EXX                     ;SAME AS "X2"
042BCD 52 29       7286          		ADD.S   HL,HL           ;TIME-CRITICAL
042BCF D9          7287          		EXX                     ;REGION
042BD0 52 ED 6A    7288          		ADC.S   HL,HL           ;(BENCHMARKS)
042BD3 0D          7289          		DEC     C
042BD4 C2 C9 2B 04 7290          		JP      NZ,FLOAT_
042BD8 C9          7291          		RET
042BD9             7292  ;
042BD9             7293  ;SFLOAT - Convert to floating-point if necessary.
042BD9             7294  ;    Input: Variable-type number in HLH'L'C
042BD9             7295  ;    Output: Floating-point in HLH'L'C
042BD9             7296  ;    Destroys: A,C,H,L,H',L',F
042BD9             7297  ;
042BD9 08          7298  FLOATA:			EX      AF,AF'
042BDA             7299          		; ADD     A,(RTABLE-DTABLE)/3
042BDA C6 2A       7300          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BDC 08          7301          		EX      AF,AF'
042BDD CD 1A 2C 04 7302  FLOAT2:			CALL    SWAP_FP
042BE1 CD E9 2B 04 7303          		CALL    SFLOAT_FP
042BE5 CD 1A 2C 04 7304          		CALL    SWAP_FP
042BE9 0D          7305  SFLOAT_FP:			DEC     C
042BEA 0C          7306          		INC     C
042BEB C0          7307          		RET     NZ              ;ALREADY FLOATING-POINT
042BEC CD 42 2C 04 7308          		CALL    TEST_FP
042BF0 C8          7309          		RET     Z               ;ZERO
042BF1 7C          7310          		LD      A,H
042BF2 B7          7311          		OR      A
042BF3 FC 1D 2B 04 7312          		CALL    M,NEGATE
042BF7 0E 9F       7313          		LD      C,159
042BF9 CD C9 2B 04 7314          		CALL    FLOAT_
042BFD B7          7315          		OR      A
042BFE F8          7316          		RET     M               ;NEGATIVE
042BFF CB BC       7317          		RES     7,H
042C01 C9          7318          		RET
042C02             7319  ;
042C02             7320  ;ROUND UP
042C02             7321  ;Return with carry set if 32-bit overflow
042C02             7322  ;   Destroys: H,L,B',C',H',L',F
042C02             7323  ;
042C02 D9          7324  ADD1_FP:			EXX
042C03 01 01 00 00 7325          		LD      BC,1
042C07 52 09       7326          		ADD.S   HL,BC
042C09 D9          7327          		EXX
042C0A D0          7328          		RET     NC
042C0B C5          7329          		PUSH    BC
042C0C 01 01 00 00 7330          		LD      BC,1
042C10 52 09       7331          		ADD.S   HL,BC
042C12 C1          7332          		POP     BC
042C13 C9          7333          		RET
042C14             7334  ;
042C14             7335  ;ODD - Add one if even, leave alone if odd.
042C14             7336  ; (Used to perform unbiassed rounding, i.e.
042C14             7337  ;  number is rounded up half the time)
042C14             7338  ;    Destroys: L',F (carry cleared)
042C14             7339  ;
042C14 B7          7340  ODD:			OR      A               ;CLEAR CARRY
042C15 D9          7341          		EXX
042C16 CB C5       7342          		SET     0,L             ;MAKE ODD
042C18 D9          7343          		EXX
042C19 C9          7344          		RET
042C1A             7345  ;
042C1A             7346  ;SWAP_FP - Swap arguments.
042C1A             7347  ;    Exchanges DE,HL D'E',H'L' and B,C
042C1A             7348  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042C1A             7349  ;SWAP1 - Swap DEHL with D'E'H'L'
042C1A             7350  ;    Destroys: D,E,H,L,D',E',H',L'
042C1A             7351  ;
042C1A 79          7352  SWAP_FP:			LD      A,C
042C1B 48          7353          		LD      C,B
042C1C 47          7354          		LD      B,A
042C1D EB          7355  SWAP1:			EX      DE,HL
042C1E D9          7356          		EXX
042C1F EB          7357          		EX      DE,HL
042C20 D9          7358          		EXX
042C21 C9          7359          		RET
042C22             7360  ;
042C22             7361  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042C22             7362  ; INCC - destroys C,F
042C22             7363  ; OFLOW
042C22             7364  ;
042C22 CD DB 2C 04 7365  DIV2:			CALL    D2
042C26 D9          7366          		EXX
042C27 CB 18       7367          		RR      B
042C29 CB 19       7368          		RR      C
042C2B 08          7369          		EX      AF,AF'
042C2C B0          7370          		OR      B
042C2D 08          7371          		EX      AF,AF'
042C2E D9          7372          		EXX
042C2F 0C          7373  INCC:			INC     C
042C30 C0          7374          		RET     NZ
042C31 3E 14       7375  OFLOW:			LD      A,TOOBIG_FP
042C33 C3 C0 20 04 7376          		JP      ERROR_FP_           ;"Too big"
042C37             7377  ;
042C37             7378  ; FTEST - Test for zero & sign
042C37             7379  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042C37             7380  ;
042C37 CD 42 2C 04 7381  FTEST_FP:			CALL    TEST_FP
042C3B C8          7382          		RET     Z
042C3C 7C          7383          		LD      A,H
042C3D E6 80       7384          		AND     10000000B
042C3F F6 40       7385          		OR      01000000B
042C41 C9          7386          		RET
042C42             7387  ;
042C42             7388  ; TEST_FP - Test HLH'L' for zero.
042C42             7389  ;     Output: Z-flag set & A=0 if HLH'L'=0
042C42             7390  ;     Destroys: A,F
042C42             7391  ;
042C42 7C          7392  TEST_FP:			LD      A,H
042C43 B5          7393          		OR      L
042C44 D9          7394          		EXX
042C45 B4          7395          		OR      H
042C46 B5          7396          		OR      L
042C47 D9          7397          		EXX
042C48 C9          7398          		RET
042C49             7399  ;
042C49             7400  ; FCOMP - Compare two numbers
042C49             7401  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C49             7402  ;
042C49 78          7403  FCOMP_FP:			LD      A,B
042C4A B1          7404          		OR      C               ;Both integer?
042C4B 20 0B       7405          		JR      NZ,FCOMP1
042C4D CD 62 2C 04 7406          		CALL    ICP
042C51 3E 00       7407  FCOMP0:			LD      A,0
042C53 C8          7408          		RET     Z               ;Equal
042C54 3E 80       7409          		LD      A,80H
042C56 1F          7410          		RRA
042C57 C9          7411          		RET
042C58             7412  ;
042C58 CD DD 2B 04 7413  FCOMP1:			CALL    FLOAT2          ;Float both
042C5C CD 70 2C 04 7414          		CALL    FCP
042C60 18 EF       7415          		JR      FCOMP0
042C62             7416  ;
042C62             7417  ; Integer and floating point compare.
042C62             7418  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C62             7419  ; Result pre-set to FALSE
042C62             7420  ; ICP1, FCP1 destroy A,F
042C62             7421  ;
042C62             7422  ; ZERO - Return zero.
042C62             7423  ;  Destroys: A,C,H,L,H',L'
042C62             7424  ;
042C62 CD 95 2C 04 7425  ICP:			CALL    ICP1
042C66 3E 00       7426  ZERO_FP:			LD      A,0
042C68 D9          7427          		EXX
042C69 67          7428          		LD      H,A
042C6A 6F          7429  	       		LD      L,A
042C6B D9          7430          		EXX
042C6C 67          7431        			LD      H,A
042C6D 6F          7432       			LD      L,A
042C6E 4F          7433  	    		LD      C,A
042C6F C9          7434          		RET
042C70             7435  ;
042C70 CD 87 2C 04 7436  FCP:			CALL    FCP1
042C74 18 F0       7437          		JR      ZERO_FP            ;PRESET FALSE
042C76             7438  ;
042C76 79          7439  FCP0:			LD      A,C
042C77 B8          7440          		CP      B               ;COMPARE EXPONENTS
042C78 C0          7441          		RET     NZ
042C79             7442  ICP0:
042C79 52 ED 52    7443  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C7C 52 19       7444          		ADD.S   HL,DE
042C7E C0          7445          		RET     NZ
042C7F D9          7446          		EXX
042C80 52 ED 52    7447          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C83 52 19       7448          		ADD.S   HL,DE
042C85 D9          7449          		EXX
042C86 C9          7450          		RET
042C87             7451  ;
042C87 7C          7452  FCP1:			LD      A,H
042C88 AA          7453          		XOR     D
042C89 7C          7454          		LD      A,H
042C8A 17          7455          		RLA
042C8B F8          7456          		RET     M
042C8C 30 E8       7457          		JR      NC,FCP0
042C8E CD 76 2C 04 7458          		CALL    FCP0
042C92 C8          7459          		RET     Z               ;** V0.1 BUG FIX
042C93 3F          7460          		CCF
042C94 C9          7461          		RET
042C95             7462  ;
042C95 7C          7463  ICP1:			LD      A,H
042C96 AA          7464          		XOR     D
042C97 F2 79 2C 04 7465          		JP      P,ICP0
042C9B 7C          7466          		LD      A,H
042C9C 17          7467          		RLA
042C9D C9          7468          		RET
042C9E             7469  ;
042C9E             7470  ; ADD - Integer add.
042C9E             7471  ; Carry, sign & zero flags valid on exit
042C9E             7472  ;     Destroys: H,L,H',L',F
042C9E             7473  ;
042C9E 05          7474  X10B:			DEC     B
042C9F 0C          7475          		INC     C
042CA0 CD E7 2C 04 7476  X5:			CALL    COPY0
042CA4 CD DA 2C 04 7477          		CALL    D2C
042CA8 CD DA 2C 04 7478          		CALL    D2C
042CAC 08          7479          		EX      AF,AF'          ;SAVE CARRY
042CAD D9          7480  ADD_:			EXX
042CAE 52 19       7481          		ADD.S   HL,DE
042CB0 D9          7482          		EXX
042CB1 52 ED 5A    7483          		ADC.S   HL,DE
042CB4 C9          7484          		RET
042CB5             7485  ;
042CB5             7486  ; SUB - Integer subtract.
042CB5             7487  ; Carry, sign & zero flags valid on exit
042CB5             7488  ;     Destroys: H,L,H',L',F
042CB5             7489  ;
042CB5 D9          7490  SUB_:			EXX
042CB6 B7          7491          		OR      A
042CB7 52 ED 52    7492          		SBC.S   HL,DE
042CBA D9          7493          		EXX
042CBB 52 ED 52    7494          		SBC.S   HL,DE
042CBE C9          7495          		RET
042CBF             7496  ;
042CBF             7497  ; X10 - unsigned integer * 10
042CBF             7498  ;    Inputs: HLH'L' initial value
042CBF             7499  ;   Outputs: DED'E' = initial HLH'L'
042CBF             7500  ;            Carry bit set if overflow
042CBF             7501  ;            If carry not set HLH'L'=result
042CBF             7502  ;  Destroys: D,E,H,L,D',E',H',L',F
042CBF             7503  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042CBF             7504  ;     Carry set if MSB=1 before shift.
042CBF             7505  ;     Sign set if MSB=1 after shift.
042CBF             7506  ;     Destroys: H,L,H',L',F
042CBF             7507  ;
042CBF CD E7 2C 04 7508  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CC3 CD D2 2C 04 7509          		CALL    X2
042CC7 D8          7510          		RET     C               ;TOO BIG
042CC8 CD D2 2C 04 7511          		CALL    X2
042CCC D8          7512          		RET     C
042CCD CD AD 2C 04 7513          		CALL    ADD_
042CD1 D8          7514          		RET     C
042CD2 D9          7515  X2:			EXX
042CD3 52 29       7516          		ADD.S   HL,HL
042CD5 D9          7517          		EXX
042CD6 52 ED 6A    7518          		ADC.S   HL,HL
042CD9 C9          7519          		RET
042CDA             7520  ;
042CDA             7521  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042CDA             7522  ;     Carry set if LSB=1 before shift.
042CDA             7523  ;     Destroys: H,L,H',L',F
042CDA             7524  ;
042CDA 0C          7525  D2C:			INC     C
042CDB CB 3C       7526  D2:			SRL     H
042CDD CB 1D       7527          		RR      L
042CDF D9          7528          		EXX
042CE0 CB 1C       7529          		RR      H
042CE2 CB 1D       7530          		RR      L
042CE4 D9          7531          		EXX
042CE5 C9          7532          		RET
042CE6             7533  ;
042CE6             7534  ; COPY - COPY HLH'L'C INTO DED'E'B
042CE6             7535  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CE6             7536  ;
042CE6 41          7537  COPY_:			LD      B,C
042CE7 54          7538  COPY0:			LD      D,H
042CE8 5D          7539          		LD      E,L
042CE9 D9          7540          		EXX
042CEA 54          7541          		LD      D,H
042CEB 5D          7542          		LD      E,L
042CEC D9          7543          		EXX
042CED C9          7544          		RET
042CEE             7545  ;
042CEE             7546  ; SQUARE - PUSH X*X
042CEE             7547  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CEE             7548  ;   Destroys: SP,IX
042CEE             7549  ;
042CEE CD E6 2C 04 7550  SQUARE:			CALL    COPY_
042CF2 CD 51 23 04 7551          		CALL    FMUL
042CF6 DD E1       7552  PUSH5:			POP     IX              ;RETURN ADDRESS
042CF8 C5          7553          		PUSH    BC
042CF9 E5          7554          		PUSH    HL
042CFA D9          7555          		EXX
042CFB E5          7556          		PUSH    HL
042CFC D9          7557          		EXX
042CFD DD E9       7558          		JP      (IX)            ;"RETURN"
042CFF             7559  ;
042CFF             7560  ; POP5 - POP DED'E'B OFF STACK.
042CFF             7561  ;   Destroys: A,B,D,E,D',E',SP,IX
042CFF             7562  ;
042CFF DD E1       7563  POP5:			POP     IX              ;RETURN ADDRESS
042D01 D9          7564          		EXX
042D02 D1          7565          		POP     DE
042D03 D9          7566          		EXX
042D04 D1          7567          		POP     DE
042D05 79          7568          		LD      A,C
042D06 C1          7569          		POP     BC
042D07 41          7570          		LD      B,C
042D08 4F          7571          		LD      C,A
042D09 DD E9       7572          		JP      (IX)            ;"RETURN"
042D0B             7573  ;
042D0B             7574  ; RATIO - Calculate (X-1)/(X+1)
042D0B             7575  ;     Inputs: X in HLH'L'C
042D0B             7576  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042D0B             7577  ;   Destroys: Everything except IY,SP,I
042D0B             7578  ;
042D0B CD F6 2C 04 7579  RATIO:			CALL    PUSH5           ;SAVE X
042D0F CD 7E 26 04 7580          		CALL    DONE
042D13 CD 3F 22 04 7581          		CALL    FADD
042D17 CD FF 2C 04 7582          		CALL    POP5            ;RESTORE X
042D1B CD F6 2C 04 7583          		CALL    PUSH5           ;SAVE X+1
042D1F CD 1A 2C 04 7584          		CALL    SWAP_FP
042D23 CD 7E 26 04 7585          		CALL    DONE
042D27 CD 26 22 04 7586          		CALL    FSUB
042D2B CD FF 2C 04 7587          		CALL    POP5            ;RESTORE X+1
042D2F C3 A8 22 04 7588          		JP      FDIV
042D33             7589  ;
042D33             7590  ; POLY - Evaluate a polynomial.
042D33             7591  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042D33             7592  ;             Polynomial coefficients follow call.
042D33             7593  ;    Outputs: Result in HLH'L'C
042D33             7594  ;   Destroys: Everything except IY,SP,I
042D33             7595  ; Routine terminates on finding a coefficient >=1.
042D33             7596  ; Note: The last coefficient is EXECUTED on return
042D33             7597  ;       so must contain only innocuous bytes!
042D33             7598  ;
042D33 DD 21 03 00 7599  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042D38 DD 39       7600          		ADD     IX, SP
042D3A DD E3       7601          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D3C             7602  ;
042D3C CD 12 2A 04 7603          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042D40 CD 51 23 04 7604  POLY1:			CALL    FMUL
042D44 11 05 00 00 7605          		LD      DE, 5				; Skip to the next coefficient
042D48 DD 19       7606          		ADD     IX, DE
042D4A CD 12 2A 04 7607          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D4E DD E3       7608          		EX      (SP), IX			; Restore the SP just in case we need to return
042D50 04          7609          		INC     B
042D51 05          7610          		DEC     B               		; Test B for end byte (80h)
042D52 FA 3F 22 04 7611          		JP      M,FADD				; Yes, so add and return
042D56 CD 3F 22 04 7612          		CALL    FADD				; No, so add
042D5A CD 24 2A 04 7613          		CALL    DLOAD5_SPL			; Load X from SP
042D5E DD E3       7614          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D60 18 DE       7615          		JR      POLY1				; And loop
042D62             7616  ;
042D62             7617  ; POWR10 - Calculate power of ten.
042D62             7618  ;     Inputs: A=power of 10 required (A<128)
042D62             7619  ;             A=binary exponent to be exceeded (A>=128)
042D62             7620  ;    Outputs: DED'E'B = result
042D62             7621  ;             A = actual power of ten returned
042D62             7622  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D62             7623  ;
042D62 3C          7624  POWR10:			INC     A
042D63 08          7625          		EX      AF,AF'
042D64 E5          7626          		PUSH    HL
042D65 D9          7627          		EXX
042D66 E5          7628          		PUSH    HL
042D67 D9          7629          		EXX
042D68 CD 7E 26 04 7630          		CALL    DONE
042D6C CD 1A 2C 04 7631          		CALL    SWAP_FP
042D70 AF          7632          		XOR     A
042D71 08          7633  POWR11:			EX      AF,AF'
042D72 3D          7634          		DEC     A
042D73 28 26       7635          		JR      Z,POWR14        ;EXIT TYPE 1
042D75 F2 7D 2D 04 7636          		JP      P,POWR13
042D79 B9          7637          		CP      C
042D7A 38 1F       7638          		JR      C,POWR14        ;EXIT TYPE 2
042D7C 3C          7639          		INC     A
042D7D 08          7640  POWR13:			EX      AF,AF'
042D7E 3C          7641          		INC     A
042D7F CB FC       7642          		SET     7,H
042D81 CD A0 2C 04 7643          		CALL    X5
042D85 30 06       7644          		JR      NC,POWR12
042D87 08          7645          		EX      AF,AF'
042D88 CD DA 2C 04 7646          		CALL    D2C
042D8C 08          7647          		EX      AF,AF'
042D8D 08          7648  POWR12:			EX      AF,AF'
042D8E DC 02 2C 04 7649          		CALL    C,ADD1_FP          ;ROUND UP
042D92 0C          7650          		INC     C
042D93 FA 71 2D 04 7651          		JP      M,POWR11
042D97 C3 31 2C 04 7652          		JP      OFLOW
042D9B CD 1A 2C 04 7653  POWR14:			CALL    SWAP_FP
042D9F CB BA       7654          		RES     7,D
042DA1 D9          7655          		EXX
042DA2 E1          7656          		POP     HL
042DA3 D9          7657          		EXX
042DA4 E1          7658          		POP     HL
042DA5 08          7659          		EX      AF,AF'
042DA6 C9          7660          		RET
042DA7             7661  ;
042DA7             7662  ; DIVA, DIVB - DIVISION PRIMITIVE.
042DA7             7663  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042DA7             7664  ;               Remainder in H'L'HL
042DA7             7665  ;     Inputs: A = loop counter (normally -32)
042DA7             7666  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042DA7             7667  ;
042DA7 B7          7668  DIVA:			OR      A               ;CLEAR CARRY
042DA8             7669  DIV0:
042DA8 52 ED 42    7670  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DAB D9          7671          		EXX
042DAC 52 ED 42    7672          		SBC.S   HL,BC
042DAF D9          7673          		EXX
042DB0 30 07       7674          		JR      NC,DIV1
042DB2 52 09       7675          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DB4 D9          7676          		EXX
042DB5 52 ED 4A    7677          		ADC.S   HL,BC
042DB8 D9          7678          		EXX
042DB9 3F          7679  DIV1:			CCF
042DBA CB 13       7680  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DBC CB 12       7681          		RL      D
042DBE D9          7682          		EXX
042DBF CB 13       7683          		RL      E
042DC1 CB 12       7684          		RL      D
042DC3 D9          7685          		EXX
042DC4 3C          7686          		INC     A
042DC5 F0          7687          		RET     P
042DC6             7688  DIVB:
042DC6 52 ED 6A    7689  			ADC.S   HL,HL           ;DIVIDEND*2
042DC9 D9          7690          		EXX
042DCA 52 ED 6A    7691          		ADC.S   HL,HL
042DCD D9          7692          		EXX
042DCE 30 D8       7693          		JR      NC,DIV0
042DD0 B7          7694          		OR      A
042DD1 52 ED 42    7695          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DD4 D9          7696          		EXX
042DD5 52 ED 42    7697          		SBC.S   HL,BC
042DD8 D9          7698          		EXX
042DD9 37          7699          		SCF
042DDA C3 BA 2D 04 7700          		JP      DIVC
042DDE             7701  ;
042DDE             7702  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042DDE             7703  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042DDE             7704  ;    Inputs: A = loop counter (usually -32)
042DDE             7705  ;            H'L'HL = 0
042DDE             7706  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042DDE             7707  ;
042DDE B7          7708  MULA:			OR      A               ;CLEAR CARRY
042DDF D9          7709  MUL0:			EXX
042DE0 CB 1A       7710          		RR      D               ;MULTIPLIER/2
042DE2 CB 1B       7711          		RR      E
042DE4 D9          7712          		EXX
042DE5 CB 1A       7713          		RR      D
042DE7 CB 1B       7714          		RR      E
042DE9 30 07       7715          		JR      NC,MUL1
042DEB 52 09       7716          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DED D9          7717          		EXX
042DEE 52 ED 4A    7718          		ADC.S   HL,BC
042DF1 D9          7719          		EXX
042DF2 3C          7720  MUL1:			INC     A
042DF3 F0          7721          		RET     P
042DF4 D9          7722  MULB:			EXX
042DF5 CB 1C       7723          		RR      H               ;PRODUCT/2
042DF7 CB 1D       7724          		RR      L
042DF9 D9          7725          		EXX
042DFA CB 1C       7726          		RR      H
042DFC CB 1D       7727          		RR      L
042DFE C3 DF 2D 04 7728          		JP      MUL0
042E02             7729  ;
042E02             7730  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042E02             7731  ;     Function: B'C'BC = SQR (D'E'DE)
042E02             7732  ;     Inputs: A = loop counter (normally -31)
042E02             7733  ;             B'C'BCH'L'HL initialised to 0
042E02             7734  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042E02             7735  ;
042E02             7736  SQR1:
042E02 52 ED 42    7737  			SBC.S   HL,BC
042E05 D9          7738          		EXX
042E06 52 ED 42    7739          		SBC.S   HL,BC
042E09 D9          7740          		EXX
042E0A 0C          7741          		INC     C
042E0B 30 09       7742          		JR      NC,SQR2
042E0D 0D          7743          		DEC     C
042E0E 52 09       7744          		ADD.S   HL,BC
042E10 D9          7745          		EXX
042E11 52 ED 4A    7746          		ADC.S   HL,BC
042E14 D9          7747          		EXX
042E15 0D          7748          		DEC     C
042E16 3C          7749  SQR2:			INC     A
042E17 F0          7750          		RET     P
042E18 CB 21       7751  SQRA:			SLA     C
042E1A CB 10       7752          		RL      B
042E1C D9          7753          		EXX
042E1D CB 11       7754          		RL      C
042E1F CB 10       7755          		RL      B
042E21 D9          7756          		EXX
042E22 0C          7757          		INC     C
042E23 CB 23       7758          		SLA     E
042E25 CB 12       7759          		RL      D
042E27 D9          7760          		EXX
042E28 CB 13       7761          		RL      E
042E2A CB 12       7762          		RL      D
042E2C D9          7763          		EXX
042E2D 52 ED 6A    7764          		ADC.S   HL,HL
042E30 D9          7765          		EXX
042E31 52 ED 6A    7766          		ADC.S   HL,HL
042E34 D9          7767          		EXX
042E35 CB 23       7768          		SLA     E
042E37 CB 12       7769          		RL      D
042E39 D9          7770          		EXX
042E3A CB 13       7771          		RL      E
042E3C CB 12       7772          		RL      D
042E3E D9          7773          		EXX
042E3F 52 ED 6A    7774          		ADC.S   HL,HL
042E42 D9          7775          		EXX
042E43 52 ED 6A    7776          		ADC.S   HL,HL
042E46 D9          7777          		EXX
042E47 D2 02 2E 04 7778          		JP      NC,SQR1
042E4B B7          7779  SQR3:			OR      A
042E4C 52 ED 42    7780          		SBC.S   HL,BC
042E4F D9          7781          		EXX
042E50 52 ED 42    7782          		SBC.S   HL,BC
042E53 D9          7783          		EXX
042E54 0C          7784          		INC     C
042E55 C3 16 2E 04 7785          		JP      SQR2
042E59             7786  ;
042E59             7787  SQRB:
042E59 52 29       7788  			ADD.S   HL,HL
042E5B D9          7789          		EXX
042E5C 52 ED 6A    7790          		ADC.S   HL,HL
042E5F D9          7791          		EXX
042E60 38 E9       7792          		JR      C,SQR3
042E62 3C          7793          		INC     A
042E63 0C          7794          		INC     C
042E64 52 ED 42    7795          		SBC.S   HL,BC
042E67 D9          7796          		EXX
042E68 52 ED 42    7797          		SBC.S   HL,BC
042E6B D9          7798          		EXX
042E6C D0          7799          		RET     NC
042E6D 52 09       7800          		ADD.S   HL,BC
042E6F D9          7801          		EXX
042E70 52 ED 4A    7802          		ADC.S   HL,BC
042E73 D9          7803          		EXX
042E74 0D          7804          		DEC     C
042E75 C9          7805          		RET
042E76             7806  ;
042E76 DD 7E 00    7807  DIGITQ:			LD      A,(IX)
042E79 FE 3A       7808          		CP      '9'+1
042E7B 3F          7809          		CCF
042E7C D8          7810          		RET     C
042E7D FE 30       7811          		CP      '0'
042E7F C9          7812          		RET
042E80             7813  ;
042E80 DD 7E 00    7814  SIGNQ:			LD      A,(IX)
042E83 DD 23       7815          		INC     IX
042E85 FE 20       7816          		CP      ' '
042E87 28 F7       7817          		JR      Z,SIGNQ
042E89 FE 2B       7818          		CP      '+'
042E8B C8          7819          		RET     Z
042E8C FE 2D       7820          		CP      '-'
042E8E C8          7821          		RET     Z
042E8F DD 2B       7822          		DEC     IX
042E91 C9          7823          		RET; --- End fpp.asm ---
042E92             7824  
042E92             7825  ; --- Begin gpio.asm ---
042E92             7826  ;
042E92             7827  ; Title:	BBC Basic for AGON - GPIO functions
042E92             7828  ; Author:	Dean Belfield
042E92             7829  ; Created:	12/05/2023
042E92             7830  ; Last Updated:	12/05/2023
042E92             7831  ;
042E92             7832  ; Modinfo:
042E92             7833  
042E92             7834  			; INCLUDE	"macros.inc"
042E92             7835  			; INCLUDE	"equs.inc"
042E92             7836  
042E92             7837  			; .ASSUME	ADL = 1
042E92             7838  
042E92             7839  			; SEGMENT CODE
042E92             7840  
042E92             7841  			; XDEF	GPIOB_SETMODE
042E92             7842  
042E92             7843  			; XREF	SWITCH_A
042E92             7844  
042E92             7845  ;  A: Mode
042E92             7846  ;  B: Pins
042E92             7847  ;
042E92 CD 55 3E 04 7848  GPIOB_SETMODE:		CALL	SWITCH_A
042E96 AA 2E       7849  			DW	GPIOB_M0	; Output
042E98 CF 2E       7850  			DW	GPIOB_M1	; Input
042E9A EF 2E       7851  			DW	GPIOB_M2	; Open Drain IO
042E9C 0F 2F       7852  			DW	GPIOB_M3	; Open Source IO
042E9E 2A 2F       7853  			DW	GPIOB_M4	; Interrupt, Dual Edge
042EA0 56 2F       7854  			DW	GPIOB_M5	; Alt Function
042EA2 71 2F       7855  			DW	GPIOB_M6	; Interrupt, Active Low
042EA4 98 2F       7856  			DW	GPIOB_M7	; Interrupt, Active High
042EA6 BA 2F       7857  			DW	GPIOB_M8	; Interrupt, Falling Edge
042EA8 DC 2F       7858  			DW	GPIOB_M9	; Interrupt, Rising Edge
042EAA             7859  
042EAA             7860  ; Output
042EAA             7861  ;
042EAA             7862  GPIOB_M0:		RES_GPIO PB_DDR,  B
042EAA C5          0001M 		PUSH	BC
042EAB 78          0002M 		LD	A, val
042EAC 2F          0003M 		CPL
042EAD 4F          0004M 		LD	C, A
042EAE ED 38 9B    0005M 		IN0	A, (reg)
042EB1 A1          0006M 		AND	C
042EB2 ED 39 9B    0007M 		OUT0	(reg), A
042EB5 C1          0008M 		POP	BC
042EB6             7863  			RES_GPIO PB_ALT1, B
042EB6 C5          0001M 		PUSH	BC
042EB7 78          0002M 		LD	A, val
042EB8 2F          0003M 		CPL
042EB9 4F          0004M 		LD	C, A
042EBA ED 38 9C    0005M 		IN0	A, (reg)
042EBD A1          0006M 		AND	C
042EBE ED 39 9C    0007M 		OUT0	(reg), A
042EC1 C1          0008M 		POP	BC
042EC2             7864  			RES_GPIO PB_ALT2, B
042EC2 C5          0001M 		PUSH	BC
042EC3 78          0002M 		LD	A, val
042EC4 2F          0003M 		CPL
042EC5 4F          0004M 		LD	C, A
042EC6 ED 38 9D    0005M 		IN0	A, (reg)
042EC9 A1          0006M 		AND	C
042ECA ED 39 9D    0007M 		OUT0	(reg), A
042ECD C1          0008M 		POP	BC
042ECE C9          7865  			RET
042ECF             7866  
042ECF             7867  ; Input
042ECF             7868  ;
042ECF             7869  GPIOB_M1:		SET_GPIO PB_DDR,  B
042ECF ED 38 9B    0001M 		IN0	A, (reg)
042ED2 B0          0002M 		OR	val
042ED3 ED 39 9B    0003M 		OUT0	(reg), A
042ED6             7870  			RES_GPIO PB_ALT1, B
042ED6 C5          0001M 		PUSH	BC
042ED7 78          0002M 		LD	A, val
042ED8 2F          0003M 		CPL
042ED9 4F          0004M 		LD	C, A
042EDA ED 38 9C    0005M 		IN0	A, (reg)
042EDD A1          0006M 		AND	C
042EDE ED 39 9C    0007M 		OUT0	(reg), A
042EE1 C1          0008M 		POP	BC
042EE2             7871  			RES_GPIO PB_ALT2, B
042EE2 C5          0001M 		PUSH	BC
042EE3 78          0002M 		LD	A, val
042EE4 2F          0003M 		CPL
042EE5 4F          0004M 		LD	C, A
042EE6 ED 38 9D    0005M 		IN0	A, (reg)
042EE9 A1          0006M 		AND	C
042EEA ED 39 9D    0007M 		OUT0	(reg), A
042EED C1          0008M 		POP	BC
042EEE C9          7872  			RET
042EEF             7873  
042EEF             7874  ; Open Drain IO
042EEF             7875  ;
042EEF             7876  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EEF C5          0001M 		PUSH	BC
042EF0 78          0002M 		LD	A, val
042EF1 2F          0003M 		CPL
042EF2 4F          0004M 		LD	C, A
042EF3 ED 38 9B    0005M 		IN0	A, (reg)
042EF6 A1          0006M 		AND	C
042EF7 ED 39 9B    0007M 		OUT0	(reg), A
042EFA C1          0008M 		POP	BC
042EFB             7877  			SET_GPIO PB_ALT1, B
042EFB ED 38 9C    0001M 		IN0	A, (reg)
042EFE B0          0002M 		OR	val
042EFF ED 39 9C    0003M 		OUT0	(reg), A
042F02             7878  			RES_GPIO PB_ALT2, B
042F02 C5          0001M 		PUSH	BC
042F03 78          0002M 		LD	A, val
042F04 2F          0003M 		CPL
042F05 4F          0004M 		LD	C, A
042F06 ED 38 9D    0005M 		IN0	A, (reg)
042F09 A1          0006M 		AND	C
042F0A ED 39 9D    0007M 		OUT0	(reg), A
042F0D C1          0008M 		POP	BC
042F0E C9          7879  			RET
042F0F             7880  
042F0F             7881  ; Open Source IO
042F0F             7882  ;
042F0F             7883  GPIOB_M3:		SET_GPIO PB_DDR,  B
042F0F ED 38 9B    0001M 		IN0	A, (reg)
042F12 B0          0002M 		OR	val
042F13 ED 39 9B    0003M 		OUT0	(reg), A
042F16             7884  			SET_GPIO PB_ALT1, B
042F16 ED 38 9C    0001M 		IN0	A, (reg)
042F19 B0          0002M 		OR	val
042F1A ED 39 9C    0003M 		OUT0	(reg), A
042F1D             7885  			RES_GPIO PB_ALT2, B
042F1D C5          0001M 		PUSH	BC
042F1E 78          0002M 		LD	A, val
042F1F 2F          0003M 		CPL
042F20 4F          0004M 		LD	C, A
042F21 ED 38 9D    0005M 		IN0	A, (reg)
042F24 A1          0006M 		AND	C
042F25 ED 39 9D    0007M 		OUT0	(reg), A
042F28 C1          0008M 		POP	BC
042F29 C9          7886  			RET
042F2A             7887  
042F2A             7888  ; Interrupt, Dual Edge
042F2A             7889  ;
042F2A             7890  GPIOB_M4:		SET_GPIO PB_DR,   B
042F2A ED 38 9A    0001M 		IN0	A, (reg)
042F2D B0          0002M 		OR	val
042F2E ED 39 9A    0003M 		OUT0	(reg), A
042F31             7891  			RES_GPIO PB_DDR,  B
042F31 C5          0001M 		PUSH	BC
042F32 78          0002M 		LD	A, val
042F33 2F          0003M 		CPL
042F34 4F          0004M 		LD	C, A
042F35 ED 38 9B    0005M 		IN0	A, (reg)
042F38 A1          0006M 		AND	C
042F39 ED 39 9B    0007M 		OUT0	(reg), A
042F3C C1          0008M 		POP	BC
042F3D             7892  			RES_GPIO PB_ALT1, B
042F3D C5          0001M 		PUSH	BC
042F3E 78          0002M 		LD	A, val
042F3F 2F          0003M 		CPL
042F40 4F          0004M 		LD	C, A
042F41 ED 38 9C    0005M 		IN0	A, (reg)
042F44 A1          0006M 		AND	C
042F45 ED 39 9C    0007M 		OUT0	(reg), A
042F48 C1          0008M 		POP	BC
042F49             7893  			RES_GPIO PB_ALT2, B
042F49 C5          0001M 		PUSH	BC
042F4A 78          0002M 		LD	A, val
042F4B 2F          0003M 		CPL
042F4C 4F          0004M 		LD	C, A
042F4D ED 38 9D    0005M 		IN0	A, (reg)
042F50 A1          0006M 		AND	C
042F51 ED 39 9D    0007M 		OUT0	(reg), A
042F54 C1          0008M 		POP	BC
042F55 C9          7894  			RET
042F56             7895  
042F56             7896  ; Alt Function
042F56             7897  ;
042F56             7898  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F56 ED 38 9B    0001M 		IN0	A, (reg)
042F59 B0          0002M 		OR	val
042F5A ED 39 9B    0003M 		OUT0	(reg), A
042F5D             7899  			RES_GPIO PB_ALT1, B
042F5D C5          0001M 		PUSH	BC
042F5E 78          0002M 		LD	A, val
042F5F 2F          0003M 		CPL
042F60 4F          0004M 		LD	C, A
042F61 ED 38 9C    0005M 		IN0	A, (reg)
042F64 A1          0006M 		AND	C
042F65 ED 39 9C    0007M 		OUT0	(reg), A
042F68 C1          0008M 		POP	BC
042F69             7900  			SET_GPIO PB_ALT2, B
042F69 ED 38 9D    0001M 		IN0	A, (reg)
042F6C B0          0002M 		OR	val
042F6D ED 39 9D    0003M 		OUT0	(reg), A
042F70 C9          7901  			RET
042F71             7902  
042F71             7903  ; Interrupt, Active Low
042F71             7904  ;
042F71             7905  GPIOB_M6:		RES_GPIO PB_DR,   B
042F71 C5          0001M 		PUSH	BC
042F72 78          0002M 		LD	A, val
042F73 2F          0003M 		CPL
042F74 4F          0004M 		LD	C, A
042F75 ED 38 9A    0005M 		IN0	A, (reg)
042F78 A1          0006M 		AND	C
042F79 ED 39 9A    0007M 		OUT0	(reg), A
042F7C C1          0008M 		POP	BC
042F7D             7906  			RES_GPIO PB_DDR,  B
042F7D C5          0001M 		PUSH	BC
042F7E 78          0002M 		LD	A, val
042F7F 2F          0003M 		CPL
042F80 4F          0004M 		LD	C, A
042F81 ED 38 9B    0005M 		IN0	A, (reg)
042F84 A1          0006M 		AND	C
042F85 ED 39 9B    0007M 		OUT0	(reg), A
042F88 C1          0008M 		POP	BC
042F89             7907  			SET_GPIO PB_ALT1, B
042F89 ED 38 9C    0001M 		IN0	A, (reg)
042F8C B0          0002M 		OR	val
042F8D ED 39 9C    0003M 		OUT0	(reg), A
042F90             7908  			SET_GPIO PB_ALT2, B
042F90 ED 38 9D    0001M 		IN0	A, (reg)
042F93 B0          0002M 		OR	val
042F94 ED 39 9D    0003M 		OUT0	(reg), A
042F97 C9          7909  			RET
042F98             7910  
042F98             7911  
042F98             7912  ; Interrupt, Active High
042F98             7913  ;
042F98             7914  GPIOB_M7:		SET_GPIO PB_DR,   B
042F98 ED 38 9A    0001M 		IN0	A, (reg)
042F9B B0          0002M 		OR	val
042F9C ED 39 9A    0003M 		OUT0	(reg), A
042F9F             7915  			RES_GPIO PB_DDR,  B
042F9F C5          0001M 		PUSH	BC
042FA0 78          0002M 		LD	A, val
042FA1 2F          0003M 		CPL
042FA2 4F          0004M 		LD	C, A
042FA3 ED 38 9B    0005M 		IN0	A, (reg)
042FA6 A1          0006M 		AND	C
042FA7 ED 39 9B    0007M 		OUT0	(reg), A
042FAA C1          0008M 		POP	BC
042FAB             7916  			SET_GPIO PB_ALT1, B
042FAB ED 38 9C    0001M 		IN0	A, (reg)
042FAE B0          0002M 		OR	val
042FAF ED 39 9C    0003M 		OUT0	(reg), A
042FB2             7917  			SET_GPIO PB_ALT2, B
042FB2 ED 38 9D    0001M 		IN0	A, (reg)
042FB5 B0          0002M 		OR	val
042FB6 ED 39 9D    0003M 		OUT0	(reg), A
042FB9 C9          7918  			RET
042FBA             7919  
042FBA             7920  
042FBA             7921  ; Interrupt, Falling Edge
042FBA             7922  ;
042FBA             7923  GPIOB_M8:		RES_GPIO PB_DR,   B
042FBA C5          0001M 		PUSH	BC
042FBB 78          0002M 		LD	A, val
042FBC 2F          0003M 		CPL
042FBD 4F          0004M 		LD	C, A
042FBE ED 38 9A    0005M 		IN0	A, (reg)
042FC1 A1          0006M 		AND	C
042FC2 ED 39 9A    0007M 		OUT0	(reg), A
042FC5 C1          0008M 		POP	BC
042FC6             7924  			SET_GPIO PB_DDR,  B
042FC6 ED 38 9B    0001M 		IN0	A, (reg)
042FC9 B0          0002M 		OR	val
042FCA ED 39 9B    0003M 		OUT0	(reg), A
042FCD             7925  			SET_GPIO PB_ALT1, B
042FCD ED 38 9C    0001M 		IN0	A, (reg)
042FD0 B0          0002M 		OR	val
042FD1 ED 39 9C    0003M 		OUT0	(reg), A
042FD4             7926  			SET_GPIO PB_ALT2, B
042FD4 ED 38 9D    0001M 		IN0	A, (reg)
042FD7 B0          0002M 		OR	val
042FD8 ED 39 9D    0003M 		OUT0	(reg), A
042FDB C9          7927  			RET
042FDC             7928  
042FDC             7929  ; Interrupt, Rising Edge
042FDC             7930  ;
042FDC             7931  GPIOB_M9:		SET_GPIO PB_DR,   B
042FDC ED 38 9A    0001M 		IN0	A, (reg)
042FDF B0          0002M 		OR	val
042FE0 ED 39 9A    0003M 		OUT0	(reg), A
042FE3             7932  			SET_GPIO PB_DDR,  B
042FE3 ED 38 9B    0001M 		IN0	A, (reg)
042FE6 B0          0002M 		OR	val
042FE7 ED 39 9B    0003M 		OUT0	(reg), A
042FEA             7933  			SET_GPIO PB_ALT1, B
042FEA ED 38 9C    0001M 		IN0	A, (reg)
042FED B0          0002M 		OR	val
042FEE ED 39 9C    0003M 		OUT0	(reg), A
042FF1             7934  			SET_GPIO PB_ALT2, B
042FF1 ED 38 9D    0001M 		IN0	A, (reg)
042FF4 B0          0002M 		OR	val
042FF5 ED 39 9D    0003M 		OUT0	(reg), A
042FF8 C9          7935  			RET	; --- End gpio.asm ---
042FF9             7936  
042FF9             7937  ; --- Begin main.asm ---
042FF9             7938  ;
042FF9             7939  ; Title:	BBC Basic Interpreter - Z80 version
042FF9             7940  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FF9             7941  ; Author:	(C) Copyright  R.T.Russell  1984
042FF9             7942  ; Modified By:	Dean Belfield
042FF9             7943  ; Created:	12/05/2023
042FF9             7944  ; Last Updated:	26/11/2023
042FF9             7945  ;
042FF9             7946  ; Modinfo:
042FF9             7947  ; 07/05/1984:	Version 2.3
042FF9             7948  ; 01/03/1987:	Version 3.0
042FF9             7949  ; 03/05/2022:	Modified by Dean Belfield
042FF9             7950  ; 06/06/2023:	Modified to run in ADL mode
042FF9             7951  ; 26/06/2023:	Fixed binary and unary indirection
042FF9             7952  ; 17/08/2023:	Added binary constants
042FF9             7953  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FF9             7954  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FF9             7955  
042FF9             7956  			; .ASSUME	ADL = 1
042FF9             7957  
042FF9             7958  			; INCLUDE	"equs.inc"
042FF9             7959  
042FF9             7960  			; SEGMENT CODE
042FF9             7961  
042FF9             7962  			; XDEF	_main
042FF9             7963  
042FF9             7964  			; XDEF	COLD
042FF9             7965  			; XDEF	WARM
042FF9             7966  			; XDEF	CLOOP
042FF9             7967  			; XDEF	DELETE
042FF9             7968  			; XDEF	LIST_
042FF9             7969  			; XDEF	RENUM
042FF9             7970  			; XDEF	AUTO
042FF9             7971  			; XDEF	NEW
042FF9             7972  			; XDEF	OLD
042FF9             7973  			; XDEF	LOAD
042FF9             7974  			; XDEF	SAVE
042FF9             7975  			; XDEF	ERROR_
042FF9             7976  			; XDEF	EXTERR
042FF9             7977  			; XDEF	LOAD0
042FF9             7978  			; XDEF	CLEAR
042FF9             7979  			; XDEF	CRLF
042FF9             7980  			; XDEF	OUTCHR
042FF9             7981  			; XDEF	OUT_
042FF9             7982  			; XDEF	FINDL
042FF9             7983  			; XDEF	SETLIN
042FF9             7984  			; XDEF	PBCDL
042FF9             7985  			; XDEF	SAYLN
042FF9             7986  			; XDEF	PUTVAR
042FF9             7987  			; XDEF	GETVAR
042FF9             7988  			; XDEF	GETDEF
042FF9             7989  			; XDEF	CREATE
042FF9             7990  			; XDEF	RANGE
042FF9             7991  			; XDEF	LEXAN2
042FF9             7992  			; XDEF	REPORT
042FF9             7993  			; XDEF	TELL
042FF9             7994  			; XDEF	SPACE_
042FF9             7995  			; XDEF	KEYWDS
042FF9             7996  			; XDEF	KEYWDL
042FF9             7997  			; XDEF	ONEDIT
042FF9             7998  			; XDEF	ONEDIT1
042FF9             7999  			; XDEF	LISTIT
042FF9             8000  			; XDEF	CLEAN
042FF9             8001  
042FF9             8002  			; XREF	LISTON
042FF9             8003  			; XREF	ERRTXT
042FF9             8004  			; XREF	OSINIT
042FF9             8005  			; XREF	HIMEM
042FF9             8006  			; XREF	PAGE_
042FF9             8007  			; XREF	CHAIN0
042FF9             8008  			; XREF	PROMPT
042FF9             8009  			; XREF	ERRTRP
042FF9             8010  			; XREF	ERRLIN
042FF9             8011  			; XREF	AUTONO
042FF9             8012  			; XREF	LINENO
042FF9             8013  			; XREF	INCREM
042FF9             8014  			; XREF	OSLINE
042FF9             8015  			; XREF	COUNT
042FF9             8016  			; XREF	NXT
042FF9             8017  			; XREF	BUFFER
042FF9             8018  			; XREF	XEQ
042FF9             8019  			; XREF	TOP
042FF9             8020  			; XREF	EXPRI
042FF9             8021  			; XREF	SEARCH
042FF9             8022  			; XREF	LTRAP
042FF9             8023  			; XREF	LOMEM
042FF9             8024  			; XREF	DECODE
042FF9             8025  			; XREF	EXPRS
042FF9             8026  			; XREF	OSSAVE
042FF9             8027  			; XREF	ERR
042FF9             8028  			; XREF	ERL
042FF9             8029  			; XREF	TRACEN
042FF9             8030  			; XREF	RESET
042FF9             8031  			; XREF	OSSHUT
042FF9             8032  			; XREF	OSLOAD
042FF9             8033  			; XREF	FREE
042FF9             8034  			; XREF	DYNVAR
042FF9             8035  			; XREF	FILL
042FF9             8036  			; XREF	OSWRCH
042FF9             8037  			; XREF	WIDTH
042FF9             8038  			; XREF	COMMA
042FF9             8039  			; XREF	MUL16
042FF9             8040  			; XREF	BRAKET
042FF9             8041  			; XREF	X4OR5
042FF9             8042  			; XREF	LOADN
042FF9             8043  			; XREF	SFIX
042FF9             8044  			; XREF	ITEMI
042FF9             8045  			; XREF	FNPTR
042FF9             8046  			; XREF	PROPTR
042FF9             8047  			; XREF	CHECK
042FF9             8048  			; XREF	TERMQ
042FF9             8049  			; XREF	OSWRCHCH
042FF9             8050  			; XREF	NEWIT
042FF9             8051  			; XREF	BAD
042FF9             8052  			; XREF	RAM_START
042FF9             8053  			; XREF	RAM_END
042FF9             8054  			; XREF	R0
042FF9             8055  			; XREF	STAR_VERSION
042FF9             8056  
042FF9             8057  			; XREF	_end			; In init.asm
042FF9             8058  
042FF9             8059  ;
042FF9             8060  ; This defines the block of tokens that are pseudo-variables.
042FF9             8061  ; There are two versions of each token, a GET and a SET
042FF9             8062  
042FF9             8063  ; Name  : GET : SET
042FF9             8064  ; ------:-----:----
042FF9             8065  ; PTR   : 8Fh : CFh
042FF9             8066  ; PAGE  : 90h : D0h
042FF9             8067  ; TIME  : 91h : D1h
042FF9             8068  ; LOMEM : 92h : D2h
042FF9             8069  ; HIMEM : 93h : D3h
042FF9             8070  ;
042FF9             8071  ; Examples:
042FF9             8072  ;   LET A% = PAGE : REM This is the GET version
042FF9             8073  ;   PAGE = 40000  : REM This is the SET version
042FF9             8074  ;
042FF9             8075  ; TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FF9             8076  ; TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FF9             8077  ; OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FF9             8078  
042FF9             8079  ; The main routine
042FF9             8080  ; IXU: argv - pointer to array of parameters
042FF9             8081  ;   C: argc - number of parameters
042FF9             8082  ; Returns:
042FF9             8083  ;  HL: Error code, or 0 if OK
042FF9             8084  ;
042FF9 21 00 4A 04 8085  _main:			LD	HL, ACCS		; Clear the ACCS
042FFD 36 00       8086  			LD	(HL), 0
042FFF 79          8087  			LD	A, C
043000 FE 02       8088  			CP	2
043002 28 2D       8089  			JR	Z, AUTOLOAD		; 2 parameters = autoload
043004 38 3F       8090  			JR	C, COLD			; 1 parameter = normal start
043006 CD AA 40 04 8091  			CALL	STAR_VERSION
04300A CD F1 3D 04 8092  			CALL	TELL
04300E 55 73 61 67 8093  			DB	"Usage:\n\r"
       65 3A 0A 0D 
043016 52 55 4E 20 8094  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
043029 21 00 00 00 8095  			LD	HL, 0			; The error code
04302D C3 68 00 04 8096  			JP	_end
043031             8097  ;
043031 DD 27 03    8098  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043034 11 00 4A 04 8099  			LD	DE, ACCS		;  DE: Destination address
043038 7E          8100  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
043039 12          8101  			LD	(DE), A			;
04303A 23          8102  			INC	HL			; Increase the source pointer
04303B 1C          8103  			INC	E			; We only need to increase E as ACCS is on a page boundary
04303C 28 03       8104  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
04303E B7          8105  			OR	A
04303F 20 F7       8106  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043041 1D          8107  AUTOLOAD_2:		DEC	E
043042 3E 0D       8108  			LD	A, CR
043044 12          8109  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
043045             8110  ;
043045 E1          8111  COLD:			POP	HL			; Pop the return address to init off SPS
043046 E5          8112  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043047 21 00 4C 04 8113  			LD	HL, STAVAR		; Cold start
04304B F9          8114  			LD	SP, HL
04304C 36 0A       8115  			LD	(HL), 10
04304E 23          8116  			INC	HL
04304F 36 09       8117  			LD	(HL),9
043051 CD E2 3F 04 8118  			CALL    OSINIT			; Call the machine specific OS initialisation routines
043055 ED 53 20 4D 8119  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
04305A 22 14 4D 04 8120  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
04305E 3E B7       8121  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043060 32 40 4D 04 8122  			LD      (LISTON),A
043064 21 BD 30 04 8123  			LD      HL,NOTICE
043068 22 2F 4D 04 8124  			LD      (ERRTXT),HL
04306C CD CD 38 04 8125  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043070 3A 00 4A 04 8126  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043074 B7          8127  			OR	A
043075 C2 66 0B 04 8128  			JP	NZ,CHAIN0		; Yes, so load and run
043079 CD AA 40 04 8129  			CALL	STAR_VERSION		;
04307D CD F1 3D 04 8130  			CALL    TELL			; Output the welcome message
043081 42 42 43 20 8131  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
04309F 45 5A 38 30 8132  			db      "EZ80ASM ADL Version 0.01beta\n\r"
       41 53 4D 20 
       41 44 4C 20 
       56 65 72 73 
       69 6F 6E 20 
       30 2E 30 31 
       62 65 74 61 
       0A 0D       
0430BD 28 43 29 20 8133  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0430DD 0A 0D 00    8134  			DB	"\n\r", 0
0430E0             8135  ;
0430E0 F6          8136  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0430E1             8137  ;
0430E1             8138  ; This is the main entry point for BASIC
0430E1             8139  ;
0430E1 37          8140  CLOOP:			SCF				; See above - not sure why this is here!
0430E2 ED 7B 20 4D 8141  			LD      SP,(HIMEM)
       04          
0430E7 CD 5B 3F 04 8142  			CALL    PROMPT          	; Prompt user
0430EB 21 40 4D 04 8143  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430EF 7E          8144  			LD      A,(HL)			; Fetch the value
0430F0 E6 0F       8145  			AND     0FH             	; Bottom nibble: LISTO
0430F2 F6 B0       8146  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430F4 77          8147  			LD      (HL),A			; Store back in
0430F5 ED 62       8148  			SBC     HL,HL           	; HL: 0
0430F7 22 2C 4D 04 8149  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430FB 22 35 4D 04 8150  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430FF             8151  ;
0430FF 2A 29 4D 04 8152  			LD      HL,(AUTONO)		; Get the auto line number
043103 22 23 4D 04 8153  			LD      (LINENO),HL		; Store in line number
043107 7C          8154  			LD      A,H			; If the auto line number is zero then
043108 B5          8155  			OR      L
043109 28 1E       8156  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
04310B             8157  ;
04310B             8158  ; This section handles auto line numbering
04310B             8159  ;
04310B E5          8160  			PUSH    HL			; Stack the line number
04310C CD 5C 3A 04 8161  			CALL    PBCD           	 	; Output the line number
043110 E1          8162  			POP     HL			; Pop the line number back off the stack
043111             8163  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
043111             8164  ;			LD      B,0			; So clear B
043111 01 00 00 00 8165  			LD	BC, 0			; Load BC with Increment
043115 3A 41 4D 04 8166  			LD	A,(INCREM)
043119 4F          8167  			LD	C, A
04311A 09          8168  			ADD     HL,BC			; Add the increment to the line number
04311B DA 86 3C 04 8169  			JP      C,TOOBIG		; And error if we wrap
04311F 22 29 4D 04 8170  			LD      (AUTONO),HL		; Store the new auto line number
043123 3E 20       8171  			LD      A,' '			; Print a space
043125 CD B0 39 04 8172  			CALL    OUTCHR
043129             8173  ;
043129             8174  ; This section invokes the line editor
043129             8175  ;
043129 21 00 4A 04 8176  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
04312D CD C0 3E 04 8177  			CALL    OSLINE          	; Call the line editor in MOS
043131 CD 3D 31 04 8178  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
043135 DC A0 38 04 8179  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
043139 C3 E1 30 04 8180  			JP      CLOOP			; Jump back to immediate mode
04313D             8181  ;
04313D             8182  ; This bit enters the line into memory
04313D             8183  ; Also called from OSLOAD_TXT
04313D             8184  ; Returns:
04313D             8185  ; F: C if a new line has been entered (CLEAN will need to be called)
04313D             8186  ;
04313D AF          8187  ONEDIT1:		XOR     A			; Entry point after *EDIT
04313E 32 3D 4D 04 8188  			LD      (COUNT),A
043142 FD 21 00 4A 8189  			LD      IY,ACCS
       04          
043147 CD 5A 3C 04 8190  			CALL    LINNUM			; HL: The line number from the input buffer
04314B CD 83 0A 04 8191  			CALL    NXT			; Skip spaces
04314F 7C          8192  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043150 B5          8193  			OR      L
043151 28 04       8194  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043153 22 23 4D 04 8195  			LD      (LINENO),HL		; Otherwise store it
043157             8196  ;
043157             8197  ; This bit does the lexical analysis and tokenisation
043157             8198  ;
043157 0E 01       8199  LNZERO:			LD	C,1			; Left mode
043159 11 00 4B 04 8200  			LD      DE,BUFFER		; Buffer for tokenised BASIC
04315D CD 00 3D 04 8201  			CALL    LEXAN2          	; Lexical analysis on the user input
043161 12          8202  			LD      (DE),A          	; Terminator
043162 AF          8203  			XOR     A
043163             8204  ;			LD      B,A
043163             8205  ;			LD      C,E             	; BC: Line length
043163 01 00 00 00 8206  			LD	BC,0
043167 4B          8207  			LD	C,E			; BC: Line length
043168 13          8208  			INC     DE
043169 12          8209  			LD      (DE),A          	; Zero next
04316A 2A 23 4D 04 8210  			LD      HL,(LINENO)		; Get the line number
04316E 7C          8211  			LD      A,H			; Is it zero, i.e. a command with no line number?
04316F B5          8212  			OR      L
043170 FD 21 00 4B 8213  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
043175 CA A9 0B 04 8214  			JP      Z,XEQ           	; Execute it
043179             8215  ;
043179             8216  ; This section stores the BASIC line in memory
043179             8217  ;
043179 C5          8218  			PUSH    BC
04317A E5          8219  			PUSH    HL
04317B CD AC 38 04 8220  			CALL    SETTOP          	; Set TOP sysvar
04317F E1          8221  			POP     HL
043180 CD F0 39 04 8222  			CALL    FINDL			; Find the address of the line
043184 CC 63 38 04 8223  			CALL    Z,DEL			; Delete the existing line if found
043188 C1          8224  			POP     BC
043189 79          8225  			LD      A,C			; Check for the line length being zero, i.e.
04318A B7          8226  			OR      A			; the user has just entered a line number in the command line
04318B C8          8227  			RET	Z 	         	; If so, then don't do anything else
04318C C6 04       8228  			ADD     A,4
04318E 4F          8229  			LD      C,A             	; Length inclusive
04318F D5          8230  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043190 C5          8231  			PUSH    BC              	; BC: Line length
043191 EB          8232  			EX      DE,HL			; DE: Address of the line in memory
043192 2A 17 4D 04 8233  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043196 E5          8234  			PUSH    HL			; Stack TOP (current TOP value)
043197 09          8235  			ADD     HL,BC			; Add the line length to HL, the new TOP value
043198 E5          8236  			PUSH    HL			; Stack HL (new TOP value)
043199 24          8237  			INC     H			; Add 256 to HL
04319A AF          8238  			XOR     A
04319B ED 72       8239  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04319D E1          8240  			POP     HL			; Pop HL (new TOP value)
04319E D2 C1 37 04 8241  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0431A2 22 17 4D 04 8242  			LD      (TOP),HL		; Store new value of TOP
0431A6 E3          8243  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0431A7 E5          8244  			PUSH    HL			; PUSH current TOP value
0431A8 23          8245  			INC     HL
0431A9 B7          8246  			OR      A
0431AA ED 52       8247  			SBC     HL,DE			; DE: Address of the line in memory
0431AC 44          8248  			LD      B,H             	; BC: Amount to move
0431AD 4D          8249  			LD      C,L
0431AE E1          8250  			POP     HL			; HL: Destination (current TOP value)
0431AF D1          8251  			POP     DE			; DE: Source (new TOP value)
0431B0 28 02       8252  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0431B2 ED B8       8253  			LDDR                    	; Otherwise, make space for the new line in the program
0431B4 C1          8254  ATEND:			POP     BC              	; BC: Line length
0431B5 D1          8255  			POP     DE              	; DE: Line number
0431B6 23          8256  			INC     HL			; HL: Destination address
0431B7 71          8257  			LD      (HL),C          	; Store length
0431B8 23          8258  			INC     HL
0431B9 73          8259  			LD      (HL),E          	; Store line number
0431BA 23          8260  			INC     HL
0431BB 72          8261  			LD      (HL),D
0431BC 23          8262  			INC     HL
0431BD 11 00 4B 04 8263  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0431C1 EB          8264  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0431C2 0D          8265  			DEC     C			; Subtract 3 from the number of bytes to copy to
0431C3 0D          8266  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0431C4 0D          8267  			DEC     C
0431C5 ED B0       8268  			LDIR                    	; Add the line to the BASIC program
0431C7 37          8269  			SCF				; To flag we need to call CLEAN
0431C8 C9          8270  			RET
0431C9             8271  ;
0431C9             8272  ; List of tokens and keywords. If a keyword is followed by 0 then
0431C9             8273  ; it will only match with the keyword followed immediately by
0431C9             8274  ; a delimiter
0431C9             8275  ;
0431C9 80 41 4E 44 8276  KEYWDS:			DB    80H, "AND"
0431CD 94 41 42 53 8277  			DB    94H, "ABS"
0431D1 95 41 43 53 8278  			DB    95H, "ACS"
0431D5 96 41 44 56 8279  			DB    96H, "ADVAL"
       41 4C       
0431DB 97 41 53 43 8280  			DB    97H, "ASC"
0431DF 98 41 53 4E 8281  			DB    98H, "ASN"
0431E3 99 41 54 4E 8282  			DB    99H, "ATN"
0431E7 C6 41 55 54 8283  			DB    C6H, "AUTO"
       4F          
0431EC 9A 42 47 45 8284  			DB    9AH, "BGET", 0
       54 00       
0431F2 D5 42 50 55 8285  			DB    D5H, "BPUT", 0
       54 00       
0431F8 FB 43 4F 4C 8286  			DB    FBH, "COLOUR"
       4F 55 52    
0431FF FB 43 4F 4C 8287  			DB    FBH, "COLOR"
       4F 52       
043205 D6 43 41 4C 8288  			DB    D6H, "CALL"
       4C          
04320A D7 43 48 41 8289  			DB    D7H, "CHAIN"
       49 4E       
043210 BD 43 48 52 8290  			DB    BDH, "CHR$"
       24          
043215 D8 43 4C 45 8291  			DB    D8H, "CLEAR", 0
       41 52 00    
04321C D9 43 4C 4F 8292  			DB    D9H, "CLOSE", 0
       53 45 00    
043223 DA 43 4C 47 8293  			DB    DAH, "CLG", 0
       00          
043228 DB 43 4C 53 8294  			DB    DBH, "CLS", 0
       00          
04322D 9B 43 4F 53 8295  			DB    9BH, "COS"
043231 9C 43 4F 55 8296  			DB    9CH, "COUNT", 0
       4E 54 00    
043238 DC 44 41 54 8297  			DB    DCH, "DATA"
       41          
04323D 9D 44 45 47 8298  			DB    9DH, "DEG"
043241 DD 44 45 46 8299  			DB    DDH, "DEF"
043245 C7 44 45 4C 8300  			DB    C7H, "DELETE"
       45 54 45    
04324C 81 44 49 56 8301  			DB    81H, "DIV"
043250 DE 44 49 4D 8302  			DB    DEH, "DIM"
043254 DF 44 52 41 8303  			DB    DFH, "DRAW"
       57          
043259 E1 45 4E 44 8304  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043262 E0 45 4E 44 8305  			DB    E0H, "END", 0
       00          
043267 E2 45 4E 56 8306  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
043270 8B 45 4C 53 8307  			DB    8BH, "ELSE"
       45          
043275 A0 45 56 41 8308  			DB    A0H, "EVAL"
       4C          
04327A 9E 45 52 4C 8309  			DB    9EH, "ERL", 0
       00          
04327F 85 45 52 52 8310  			DB    85H, "ERROR"
       4F 52       
043285 C5 45 4F 46 8311  			DB    C5H, "EOF", 0
       00          
04328A 82 45 4F 52 8312  			DB    82H, "EOR"
04328E 9F 45 52 52 8313  			DB    9FH, "ERR", 0
       00          
043293 A1 45 58 50 8314  			DB    A1H, "EXP"
043297 A2 45 58 54 8315  			DB    A2H, "EXT", 0
       00          
04329C E3 46 4F 52 8316  			DB    E3H, "FOR"
0432A0 A3 46 41 4C 8317  			DB    A3H, "FALSE", 0
       53 45 00    
0432A7 A4 46 4E    8318  			DB    A4H, "FN"
0432AA E5 47 4F 54 8319  			DB    E5H, "GOTO"
       4F          
0432AF BE 47 45 54 8320  			DB    BEH, "GET$"
       24          
0432B4 A5 47 45 54 8321  			DB    A5H, "GET"
0432B8 E4 47 4F 53 8322  			DB    E4H, "GOSUB"
       55 42       
0432BE E6 47 43 4F 8323  			DB    E6H, "GCOL"
       4C          
0432C3 93 48 49 4D 8324  			DB    93H, "HIMEM", 0
       45 4D 00    
0432CA E8 49 4E 50 8325  			DB    E8H, "INPUT"
       55 54       
0432D0 E7 49 46    8326  			DB    E7H, "IF"
0432D3 BF 49 4E 4B 8327  			DB    BFH, "INKEY$"
       45 59 24    
0432DA A6 49 4E 4B 8328  			DB    A6H, "INKEY"
       45 59       
0432E0 A8 49 4E 54 8329  			DB    A8H, "INT"
0432E4 A7 49 4E 53 8330  			DB    A7H, "INSTR("
       54 52 28    
0432EB C9 4C 49 53 8331  			DB    C9H, "LIST"
       54          
0432F0 86 4C 49 4E 8332  			DB    86H, "LINE"
       45          
0432F5 C8 4C 4F 41 8333  			DB    C8H, "LOAD"
       44          
0432FA 92 4C 4F 4D 8334  			DB    92H, "LOMEM", 0
       45 4D 00    
043301 EA 4C 4F 43 8335  			DB    EAH, "LOCAL"
       41 4C       
043307 C0 4C 45 46 8336  			DB    C0H, "LEFT$("
       54 24 28    
04330E A9 4C 45 4E 8337  			DB    A9H, "LEN"
043312 E9 4C 45 54 8338  			DB    E9H, "LET"
043316 AB 4C 4F 47 8339  			DB    ABH, "LOG"
04331A AA 4C 4E    8340  			DB    AAH, "LN"
04331D C1 4D 49 44 8341  			DB    C1H, "MID$("
       24 28       
043323 EB 4D 4F 44 8342  			DB    EBH, "MODE"
       45          
043328 83 4D 4F 44 8343  			DB    83H, "MOD"
04332C EC 4D 4F 56 8344  			DB    ECH, "MOVE"
       45          
043331 ED 4E 45 58 8345  			DB    EDH, "NEXT"
       54          
043336 CA 4E 45 57 8346  			DB    CAH, "NEW", 0
       00          
04333B AC 4E 4F 54 8347  			DB    ACH, "NOT"
04333F CB 4F 4C 44 8348  			DB    CBH, "OLD", 0
       00          
043344 EE 4F 4E    8349  			DB    EEH, "ON"
043347 87 4F 46 46 8350  			DB    87H, "OFF"
04334B 84 4F 52    8351  			DB    84H, "OR"
04334E 8E 4F 50 45 8352  			DB    8EH, "OPENIN"
       4E 49 4E    
043355 AE 4F 50 45 8353  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
04335D AD 4F 50 45 8354  			DB    ADH, "OPENUP"
       4E 55 50    
043364 FF 4F 53 43 8355  			DB    FFH, "OSCLI"
       4C 49       
04336A F1 50 52 49 8356  			DB    F1H, "PRINT"
       4E 54       
043370 90 50 41 47 8357  			DB    90H, "PAGE", 0
       45 00       
043376 8F 50 54 52 8358  			DB    8FH, "PTR", 0
       00          
04337B AF 50 49 00 8359  			DB    AFH, "PI", 0
04337F F0 50 4C 4F 8360  			DB    F0H, "PLOT"
       54          
043384 B0 50 4F 49 8361  			DB    B0H, "POINT("
       4E 54 28    
04338B F2 50 52 4F 8362  			DB    F2H, "PROC"
       43          
043390 B1 50 4F 53 8363  			DB    B1H, "POS", 0
       00          
043395 CE 50 55 54 8364  			DB    CEH, "PUT"
043399 F8 52 45 54 8365  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0433A1 F5 52 45 50 8366  			DB    F5H, "REPEAT"
       45 41 54    
0433A8 F6 52 45 50 8367  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0433B0 F3 52 45 41 8368  			DB    F3H, "READ"
       44          
0433B5 F4 52 45 4D 8369  			DB    F4H, "REM"
0433B9 F9 52 55 4E 8370  			DB    F9H, "RUN", 0
       00          
0433BE B2 52 41 44 8371  			DB    B2H, "RAD"
0433C2 F7 52 45 53 8372  			DB    F7H, "RESTORE"
       54 4F 52 45 
0433CA C2 52 49 47 8373  			DB    C2H, "RIGHT$("
       48 54 24 28 
0433D2 B3 52 4E 44 8374  			DB    B3H, "RND", 0
       00          
0433D7 CC 52 45 4E 8375  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0433E0 88 53 54 45 8376  			DB    88H, "STEP"
       50          
0433E5 CD 53 41 56 8377  			DB    CDH, "SAVE"
       45          
0433EA B4 53 47 4E 8378  			DB    B4H, "SGN"
0433EE B5 53 49 4E 8379  			DB    B5H, "SIN"
0433F2 B6 53 51 52 8380  			DB    B6H, "SQR"
0433F6 89 53 50 43 8381  			DB    89H, "SPC"
0433FA C3 53 54 52 8382  			DB    C3H, "STR$"
       24          
0433FF C4 53 54 52 8383  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
043408 D4 53 4F 55 8384  			DB    D4H, "SOUND"
       4E 44       
04340E FA 53 54 4F 8385  			DB    FAH, "STOP", 0
       50 00       
043414 B7 54 41 4E 8386  			DB    B7H, "TAN"
043418 8C 54 48 45 8387  			DB    8CH, "THEN"
       4E          
04341D B8 54 4F    8388  			DB    B8H, "TO"
043420 8A 54 41 42 8389  			DB    8AH, "TAB("
       28          
043425 FC 54 52 41 8390  			DB    FCH, "TRACE"
       43 45       
04342B 91 54 49 4D 8391  			DB    91H, "TIME", 0
       45 00       
043431 B9 54 52 55 8392  			DB    B9H, "TRUE", 0
       45 00       
043437 FD 55 4E 54 8393  			DB    FDH, "UNTIL"
       49 4C       
04343D BA 55 53 52 8394  			DB    BAH, "USR"
043441 EF 56 44 55 8395  			DB    EFH, "VDU"
043445 BB 56 41 4C 8396  			DB    BBH, "VAL"
043449 BC 56 50 4F 8397  			DB    BCH, "VPOS", 0
       53 00       
04344F FE 57 49 44 8398  			DB    FEH, "WIDTH"
       54 48       
043455 D3 48 49 4D 8399  			DB    D3H, "HIMEM"
       45 4D       
04345B D2 4C 4F 4D 8400  			DB    D2H, "LOMEM"
       45 4D       
043461 D0 50 41 47 8401  			DB    D0H, "PAGE"
       45          
043466 CF 50 54 52 8402  			DB    CFH, "PTR"
04346A D1 54 49 4D 8403  			DB    D1H, "TIME"
       45          
04346F             8404  ;
04346F             8405  ; These are indexed from the ERRWDS table
04346F             8406  ;
04346F 01 4D 69 73 8407  			DB    01H, "Missing "
       73 69 6E 67 
       20          
043478 02 4E 6F 20 8408  			DB    02H, "No such "
       73 75 63 68 
       20          
043481 03 42 61 64 8409  			DB    03H, "Bad "
       20          
043486 04 20 72 61 8410  			DB    04H, " range"
       6E 67 65    
04348D 05 76 61 72 8411  			DB    05H, "variable"
       69 61 62 6C 
       65          
043496 06 4F 75 74 8412  			DB    06H, "Out of"
       20 6F 66    
04349D 07 4E 6F 20 8413  			DB    07H, "No "
0434A1 08 20 73 70 8414  			DB    08H, " space"
       61 63 65    
0434A8             8415  
0434A8             8416  KEYWDL:			EQU     $-KEYWDS
0434A8 FF FF       8417  			DW    -1
0434AA             8418  ;
0434AA             8419  ; Error messages
0434AA             8420  ;
0434AA 07 72 6F 6F 8421  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0434B0 06 04 00    8422  			DB    6, 4, 0			;  1: Out of range
0434B3 00          8423  			DB    0				;  2: *
0434B4 00          8424  			DB    0				;  3: *
0434B5 4D 69 73 74 8425  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0434BD 01 2C 00    8426  			DB    1, ",", 0			;  5: Missing ,
0434C0 54 79 70 65 8427  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0434CE 07 A4 00    8428  			DB    7, FN, 0			;  7: No FN
0434D1 00          8429  			DB    0				;  8: *
0434D2 01 22 00    8430  			DB    1, 34, 0			;  9: Missing "
0434D5 03 DE 00    8431  			DB    3, DIM, 0			; 10: Bad DIM
0434D8 DE 08 00    8432  			DB    DIM, 8, 0			; 11: DIM space
0434DB 4E 6F 74 20 8433  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0434E1 07 F2 00    8434  			DB    7, PROC, 0		; 13: No PROC
0434E4 41 72 72 61 8435  			DB    "Array", 0		; 14: Array
       79 00       
0434EA 53 75 62 73 8436  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0434F4 53 79 6E 74 8437  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
043501 45 73 63 61 8438  			DB    "Escape", 0		; 17: Escape
       70 65 00    
043508 44 69 76 69 8439  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
043519 53 74 72 69 8440  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
043529 54 6F 6F 20 8441  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
043531 2D 76 65 20 8442  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
04353A 4C 6F 67 04 8443  			DB    "Log", 4, 0		; 22: Log range
       00          
04353F 41 63 63 75 8444  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
04354D 45 78 70 04 8445  			DB    "Exp", 4, 0		; 24: Exp range
       00          
043552 00          8446  			DB    0				; 25: *
043553 02 05 00    8447  			DB    2, 5, 0			; 26: No such variable
043556 01 29 00    8448  			DB    1, ")", 0			; 27: Missing )
043559 03 48 45 58 8449  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
04355E 02 A4 2F F2 8450  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043563 03 63 61 6C 8451  			DB    3, "call", 0		; 30: Bad call
       6C 00       
043569 41 72 67 75 8452  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043573 07 E3 00    8453  			DB    7, FOR, 0			; 32: No FOR
043576 43 61 6E 27 8454  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043584 E3 20 05 00 8455  			DB    FOR, " ", 5, 0		; 34: FOR variable
043588 00          8456  			DB    0				; 35: *
043589 07 B8 00    8457  			DB    7, TO, 0			; 36: No TO
04358C 00          8458  			DB    0				; 37: *
04358D 07 E4 00    8459  			DB    7, GOSUB, 0		; 38: No GOSUB
043590 EE 20 73 79 8460  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
043599 EE 04 00    8461  			DB    ON_, 4, 0			; 40: ON range
04359C 02 6C 69 6E 8462  			DB    2, "line", 0		; 41: No such line
       65 00       
0435A2 06 20 DC 00 8463  			DB    6, " ", DATA_, 0		; 42: Out of DATA
0435A6 07 F5 00    8464  			DB    7, REPEAT, 0		; 43: No REPEAT
0435A9 00          8465  			DB    0				; 44: *
0435AA 01 23 00    8466  			DB    1, "#", 0			; 45: Missing #
0435AD             8467  ;
0435AD             8468  ; COMMANDS:
0435AD             8469  ;
0435AD             8470  ; DELETE line,line
0435AD             8471  ;
0435AD CD AC 38 04 8472  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0435B1 CD B4 3C 04 8473  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435B5 7E          8474  DELET1:			LD      A,(HL)			; Check whether it's the last line
0435B6 B7          8475  			OR      A
0435B7 CA 3E 36 04 8476  			JP      Z,WARMNC		; Yes, so do nothing
0435BB 23          8477  			INC     HL			; Skip the line length byte
0435BC 11 00 00 00 8478  			LD	DE, 0			; Clear DE
0435C0 5E          8479  			LD      E,(HL)			; Fetch the line number in DE
0435C1 23          8480  			INC     HL
0435C2 56          8481  			LD      D,(HL)
0435C3 7A          8482  			LD      A,D			; If the line number is zero then
0435C4 B3          8483  			OR      E
0435C5 28 1D       8484  			JR      Z,CLOOP1        	; Do nothing
0435C7 2B          8485  			DEC     HL			; Decrement BASIC program pointer back to length
0435C8 2B          8486  			DEC     HL
0435C9 EB          8487  			EX      DE,HL			; Check if we've gone past the terminating line
0435CA 37          8488  			SCF
0435CB ED 42       8489  			SBC     HL,BC
0435CD EB          8490  			EX      DE,HL
0435CE 30 6E       8491  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0435D0 C5          8492  			PUSH    BC
0435D1 CD 63 38 04 8493  			CALL    DEL			; Delete the line pointed to by HL
0435D5 C1          8494  			POP     BC
0435D6 18 DD       8495  			JR      DELET1			; And loop round to the next line
0435D8             8496  ;
0435D8             8497  ; LISTO expr
0435D8             8498  ;
0435D8 FD 23       8499  LISTO:			INC     IY              	; Skip "O" byte
0435DA CD 1A 03 04 8500  			CALL    EXPRI			; Get expr
0435DE D9          8501  			EXX
0435DF 7D          8502  			LD      A,L
0435E0 32 40 4D 04 8503  			LD      (LISTON),A		; Store in LISTON sysvar
0435E4 C3 E1 30 04 8504  CLOOP1:			JP      CLOOP
0435E8             8505  ;
0435E8             8506  ; LIST
0435E8             8507  ; LIST line
0435E8             8508  ; LIST line,line [IF string]
0435E8             8509  ; LIST ,line
0435E8             8510  ; LIST line,
0435E8             8511  ;
0435E8 FE 4F       8512  LIST_:			CP      'O'			; Check for O (LISTO)
0435EA 28 EC       8513  			JR      Z,LISTO			; and jump to LISTO if zero
0435EC CD B4 3C 04 8514  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435F0 CD 83 0A 04 8515  			CALL    NXT			; Skip space
0435F4 FE E7       8516  			CP      TIF             	; Check for IF clause (token IF)
0435F6 3E 00       8517  			LD      A,0             	; Initialise the IF clause string length
0435F8 20 17       8518  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435FA             8519  ;
0435FA FD 23       8520  			INC     IY              	; Skip the IF token
0435FC CD 83 0A 04 8521  			CALL    NXT             	; And skip any spaces
043600 EB          8522  			EX      DE,HL			; DE: Address in memory
043601 FD E5       8523  			PUSH    IY			; LD IY, HL
043603 E1          8524  			POP     HL              	; HL is now the address of the tokenised line
043604 3E 0D       8525  			LD      A,CR
043606 C5          8526  			PUSH    BC			; Stack the second line number arg
043607 01 00 01 00 8527  			LD      BC,256
04360B ED B1       8528  			CPIR                    	; Locate CR byte
04360D 79          8529  			LD      A,C
04360E 2F          8530  			CPL                    	 	; A: Substring length (of IF clause)
04360F C1          8531  			POP     BC			; Restore the second line number arg
043610 EB          8532  			EX      DE,HL			; HL: Address in memory
043611             8533  ;
043611 5F          8534  LISTB:			LD      E,A             	; E: IF clause string length
043612 78          8535  			LD      A,B			; Check whether a second line number was passed (BC!=0)
043613 B1          8536  			OR      C
043614 20 01       8537  			JR      NZ,LISTA		; If there isn't a second line number
043616 0B          8538  			DEC     BC			; then we set it to the maximum of 65535
043617             8539  ;
043617 D9          8540  LISTA:			EXX
043618 DD 21 40 4D 8541  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
04361D 01 00 00 00 8542  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
043621 D9          8543  			EXX
043622 3E 14       8544  			LD      A,20			; Number of lines to list
043624             8545  ;
043624 C5          8546  LISTC:			PUSH    BC              	; Save second line number
043625 D5          8547  			PUSH    DE              	; Save IF clause length
043626 E5          8548  			PUSH    HL              	; Save BASIC program counter
043627 08          8549  			EX      AF,AF'
043628             8550  ;
043628             8551  ; BBC BASIC for Z80 lines are stored as follows:
043628             8552  ;
043628             8553  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
043628             8554  ; - [&00] [&FF] [&FF]: End of program marker
043628             8555  ;
043628             8556  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
043628             8557  ;
043628 7E          8558  			LD      A,(HL)			; Check for end of program marker
043629 B7          8559  			OR      A			; If found
04362A 28 12       8560  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
04362C             8561  ;
04362C             8562  ; Check if past terminating line number
04362C             8563  ;
04362C 7B          8564  			LD      A,E             	; A: IF clause length
04362D 23          8565  			INC     HL			; Skip the length byte
04362E 11 00 00 00 8566  			LD	DE,0			; Clear DE
043632 5E          8567  			LD      E,(HL)			; Fetch the line number in DE
043633 23          8568  			INC     HL
043634 56          8569  			LD      D,(HL)
043635 2B          8570  			DEC     HL			; Step HL back to the length byte
043636 2B          8571  			DEC     HL
043637 D5          8572  			PUSH    DE             	 	; Push the line number on the stack
043638 EB          8573  			EX      DE,HL			; HL: line number
043639 37          8574  			SCF				; Do a 16-bit compare of HL and DE
04363A ED 42       8575  			SBC     HL,BC
04363C EB          8576  			EX      DE,HL
04363D D1          8577  			POP     DE              	; Restore the line number
04363E D2 E0 30 04 8578  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043642 4E          8579  			LD      C,(HL)          	; C: Line length + 4
043643 47          8580  			LD      B,A             	; B: IF clause length
043644             8581  ;
043644             8582  ; Check if "UNLISTABLE":
043644             8583  ;
043644 7A          8584  			LD      A,D			; TODO: What is "UNLISTABLE?"
043645 B3          8585  			OR      E
043646 CA E1 30 04 8586  			JP      Z,CLOOP
04364A             8587  ;
04364A             8588  ; Check for IF clause:
04364A             8589  ;
04364A 23          8590  			INC     HL			; Skip the length
04364B 23          8591  			INC     HL			; Skip the line number
04364C 23          8592  			INC     HL              	; HL: Address of the tokenised BASIC line
04364D 0D          8593  			DEC     C			;  C: Line length
04364E 0D          8594  			DEC     C
04364F 0D          8595  			DEC     C
043650 0D          8596  			DEC     C
043651 D5          8597  			PUSH    DE              	; Save the line number
043652 E5          8598  			PUSH    HL              	; Save the BASIC program address
043653 AF          8599  			XOR     A               	;
043654 B8          8600  			CP      B              	 	; Check for an IF clause (B!=0)
043655 FD E5       8601  			PUSH    IY			; LD IY, DE
043657 D1          8602  			POP     DE              	; DE: Address of the IF clause string in the input buffer
043658 C4 95 07 04 8603  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
04365C E1          8604  			POP     HL              	; Restore BASIC program address
04365D D1          8605  			POP     DE              	; Restore line number
04365E FD E5       8606  			PUSH    IY
043660 CC F3 38 04 8607  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043664 FD E1       8608  			POP     IY
043666             8609  ;
043666 08          8610  			EX      AF,AF'
043667 3D          8611  			DEC     A			; Decrement line list counter
043668 CD D2 3F 04 8612  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
04366C E1          8613  			POP     HL             	 	; Restore BASIC program address to beginning of line
04366D 11 00 00 00 8614  			LD	DE,0
043671 5E          8615  			LD      E,(HL)			; Fetch the length of line in DE
043672 19          8616  			ADD     HL,DE           	; Go to the next line
043673 D1          8617  			POP     DE              	; Restore IF clause length
043674 C1          8618  			POP     BC              	; Restore second line number
043675 18 AD       8619  			JR      LISTC			; Loop back to do next line
043677             8620  ;
043677             8621  ; RENUMBER
043677             8622  ; RENUMBER start
043677             8623  ; RENUMBER start,increment
043677             8624  ; RENUMBER ,increment
043677             8625  ;
043677 CD D7 38 04 8626  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04367B CD 8C 3C 04 8627  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04367F D9          8628  			EXX
043680 2A 14 4D 04 8629  			LD      HL,(PAGE_)		; HL: Top of program
043684 ED 5B 1A 4D 8630  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
043689             8631  ;
043689             8632  ; Build the table
043689             8633  ;
043689 7E          8634  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
04368A B7          8635  			OR      A			; Is it zero, i.e. the end of program marker?
04368B 28 36       8636  			JR      Z,RENUM2		; Yes, so skip to the next part
04368D 23          8637  			INC     HL
04368E 4E          8638  			LD      C,(HL)          	; BC: The OLD line number
04368F 23          8639  			INC     HL
043690 46          8640  			LD      B,(HL)
043691 78          8641  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043692 B1          8642  			OR      C
043693 CA E1 30 04 8643  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043697 EB          8644  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043698 71          8645  			LD      (HL),C			; Store the OLD line number in the heap
043699 23          8646  			INC     HL
04369A 70          8647  			LD      (HL),B
04369B 23          8648  			INC     HL
04369C D9          8649  			EXX				; HL: line number, BC: increment (16-bit values)
04369D E5          8650  			PUSH    HL			; HL: Stack the NEW line number value
04369E 52 09       8651  			ADD.S   HL,BC           	; Add the increment
0436A0 DA 86 3C 04 8652  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0436A4 D9          8653  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0436A5 C1          8654  			POP     BC			; BC: Pop the NEW line number value off the stack
0436A6 71          8655  			LD      (HL),C			; Store the NEW line number in the heap
0436A7 23          8656  			INC     HL
0436A8 70          8657  			LD      (HL),B
0436A9 23          8658  			INC     HL
0436AA EB          8659  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436AB 2B          8660  			DEC     HL			; Back up to the line length byte
0436AC 2B          8661  			DEC     HL
0436AD 01 00 00 00 8662  			LD	BC, 0
0436B1 4E          8663  			LD      C,(HL)			; BC: Line length
0436B2 09          8664  			ADD	HL,BC           	; Advance HL to next line
0436B3 EB          8665  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0436B4 E5          8666  			PUSH    HL
0436B5 24          8667  			INC     H			; Increment to next page
0436B6 ED 72       8668  			SBC     HL,SP			; Subtract from SP
0436B8 E1          8669  			POP     HL
0436B9 EB          8670  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436BA 38 CD       8671  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0436BC CD D8 37 04 8672  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0436C0 CC          8673  			DB    	REN
0436C1 08          8674  			DB    	8
0436C2 00          8675  			DB    	0
0436C3             8676  ;
0436C3             8677  ; At this point a list of BASIC line numbers have been written to the heap
0436C3             8678  ; as word pairs:
0436C3             8679  ; - DW: The OLD line number
0436C3             8680  ; - DW: The NEW line number
0436C3             8681  ;
0436C3 EB          8682  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0436C4 36 FF       8683  			LD      (HL),-1			; Mark the end with FFFFh
0436C6 23          8684  			INC     HL
0436C7 36 FF       8685  			LD      (HL),-1
0436C9 ED 5B 1A 4D 8686  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
0436CE D9          8687  			EXX
0436CF 2A 14 4D 04 8688  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436D3 4E          8689  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436D4 79          8690  			LD      A,C			; If it is zero, then no program, so...
0436D5 B7          8691  			OR      A
0436D6 CA E0 30 04 8692  			JP      Z,WARM			; Jump to warm start
0436DA D9          8693  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436DB EB          8694  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436DC 23          8695  			INC     HL			; Skip to the NEW line number
0436DD 23          8696  			INC     HL
0436DE 5E          8697  			LD      E,(HL)			; DE: The NEW line number
0436DF 23          8698  			INC     HL
0436E0 56          8699  			LD      D,(HL)
0436E1 23          8700  			INC     HL
0436E2 D5          8701  			PUSH    DE			; Stack the NEW line number
0436E3 EB          8702  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436E4 22 23 4D 04 8703  			LD      (LINENO),HL		; Store the line number in LINENO
0436E8 D9          8704  			EXX				; HL: Pointer to the BASIC program area
0436E9 D1          8705  			POP     DE			; DE: The NEW line number
0436EA 23          8706  			INC     HL
0436EB 73          8707  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436EC 23          8708  			INC     HL
0436ED 72          8709  			LD      (HL),D
0436EE 23          8710  			INC     HL
0436EF 0D          8711  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436F0 0D          8712  			DEC     C
0436F1 0D          8713  			DEC     C
0436F2 79          8714  			LD	A,C
0436F3 01 00 00 00 8715  			LD	BC,0
0436F7 4F          8716  			LD	C,A			; BC: Line length
0436F8             8717  ;
0436F8 3E 8D       8718  RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436FA ED B1       8719  			CPIR                    	; Search for the token
0436FC 20 D5       8720  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0436FE             8721  ;
0436FE             8722  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0436FE             8723  ;
0436FE C5          8724  			PUSH    BC			; Stack everything
0436FF E5          8725  			PUSH    HL
043700 E5          8726  			PUSH    HL			; HL: Pointer to encoded line number
043701 FD E1       8727  			POP     IY			; IY: Pointer to encoded line number
043703 D9          8728  			EXX
043704 CD F6 08 04 8729  			CALL    DECODE			; Decode the encoded line number (in HL')
043708 D9          8730  			EXX				; HL: Decoded line number
043709 44          8731  			LD      B,H			; BC: Decoded line number
04370A 4D          8732  			LD      C,L
04370B 2A 1A 4D 04 8733  			LD      HL,(LOMEM)		; HL: Pointer to heap
04370F             8734  ;
04370F             8735  ; This section of code cross-references the decoded (OLD) line number with the list
04370F             8736  ; created previously in the global heap
04370F             8737  ;
04370F 5E          8738  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
043710 23          8739  			INC     HL
043711 56          8740  			LD      D,(HL)
043712 23          8741  			INC     HL
043713 EB          8742  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
043714 B7          8743  			OR      A               	; Clear the carry and...
043715 52 ED 42    8744  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
043718 EB          8745  			EX      DE,HL			; HL: Pointer in the global heap
043719 5E          8746  			LD      E,(HL)          	; DE: The NEW line number
04371A 23          8747  			INC     HL
04371B 56          8748  			LD      D,(HL)
04371C 23          8749  			INC     HL
04371D 38 F0       8750  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
04371F EB          8751  			EX      DE,HL			; DE: Pointer in the global heap
043720 28 1D       8752  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
043722             8753  ;
043722 CD F1 3D 04 8754  			CALL    TELL			; Display this error if the line number is not found
043726 46 61 69 6C 8755  			DB    	"Failed at "
       65 64 20 61 
       74 20       
043730 00          8756  			DB    	0
043731 2A 23 4D 04 8757  			LD      HL,(LINENO)
043735 CD 58 3A 04 8758  			CALL    PBCDL
043739 CD A8 39 04 8759  			CALL    CRLF
04373D 18 07       8760  			JR      RENUM6			; And carry on renumbering
04373F             8761  ;
04373F             8762  ; This snippet re-encodes the line number in the BASIC program
04373F             8763  ;
04373F D1          8764  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
043740 D5          8765  			PUSH    DE
043741 1B          8766  			DEC     DE			; Back up a byte to the LINO token
043742 CD BD 3D 04 8767  			CALL    ENCODE          	; Re-write the new line number out
043746 E1          8768  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
043747 C1          8769  			POP     BC			; BC: The remaining line length
043748 18 AE       8770  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
04374A             8771  ;
04374A             8772  ; AUTO
04374A             8773  ; AUTO start,increment
04374A             8774  ; AUTO start
04374A             8775  ; AUTO ,increment
04374A             8776  ;
04374A CD 8C 3C 04 8777  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
04374E 22 29 4D 04 8778  			LD      (AUTONO),HL		; Store the start in AUTONO
043752 79          8779  			LD      A,C			; Increment is 8 bit (0-255)
043753 32 41 4D 04 8780  			LD      (INCREM),A		; Store that in INCREM
043757 18 2E       8781  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043759             8782  ;
043759             8783  ; BAD
043759             8784  ; NEW
043759             8785  ;
043759 CD F1 3D 04 8786  BAD:			CALL    TELL            	; Output "Bad program" error
04375D 03          8787  			DB    3				; Token for "BAD"
04375E 70 72 6F 67 8788  			DB    "program"
       72 61 6D    
043765 0D          8789  			DB    CR
043766 0A          8790  			DB    LF
043767 00          8791  			DB    0				; Falls through to NEW
043768             8792  ;
043768 CD CD 38 04 8793  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
04376C 18 19       8794  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04376E             8795  ;
04376E             8796  ; OLD
04376E             8797  ;
04376E 2A 14 4D 04 8798  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043772 E5          8799  			PUSH    HL			; Stack it
043773 23          8800  			INC     HL			; Skip the potential length byte of first line of code
043774 23          8801  			INC     HL			; And the line number word
043775 23          8802  			INC     HL
043776 01 FC 00 00 8803  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
04377A 3E 0D       8804  			LD      A,CR
04377C ED B1       8805  			CPIR
04377E 20 D9       8806  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
043780 7D          8807  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043781 E1          8808  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043782 77          8809  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043783 CD A0 38 04 8810  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043787 C3 E1 30 04 8811  CLOOP0:			JP      CLOOP			; Jump back to the command loop
04378B             8812  ;
04378B             8813  ; LOAD filename
04378B             8814  ;
04378B CD 25 03 04 8815  LOAD:			CALL    EXPRS           	; Get the filename
04378F 3E 0D       8816  			LD      A,CR			; DE points to the last byte of filename in ACCS
043791 12          8817  			LD      (DE),A			; Terminate filename with a CR
043792 CD 80 38 04 8818  			CALL    LOAD0			; Load the file in, then CLEAN
043796 CD D7 38 04 8819  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04379A 18 21       8820  			JR      WARM0			; Jump back to the command loop
04379C             8821  ;
04379C             8822  ; SAVE filename
04379C             8823  ;
04379C CD AC 38 04 8824  SAVE:			CALL    SETTOP          	; Set TOP sysvar
0437A0 CD 25 03 04 8825  			CALL    EXPRS           	; Get the filename
0437A4 3E 0D       8826  			LD      A,CR			; Terminate the filename with a CR
0437A6 12          8827  			LD      (DE),A
0437A7 ED 5B 14 4D 8828  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
0437AC 2A 17 4D 04 8829  			LD      HL,(TOP)		; HL: Top of program memory
0437B0 B7          8830  			OR      A			; Calculate program size (TOP-PAGE)
0437B1 ED 52       8831  			SBC     HL,DE
0437B3 44          8832  			LD      B,H             	; BC: Length of program in bytes
0437B4 4D          8833  			LD      C,L
0437B5 21 00 4A 04 8834  			LD      HL,ACCS			; HL: Address of the filename
0437B9 CD 9F 42 04 8835  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0437BD C3 E0 30 04 8836  WARM0:			JP      WARM			; Jump back to the command loop
0437C1             8837  
0437C1             8838  ;
0437C1             8839  ; ERROR
0437C1             8840  ; Called whenever BASIC needs to halt with an error
0437C1             8841  ; Error messages are indexed from 0
0437C1             8842  ; Inputs:
0437C1             8843  ;  A: Error number
0437C1             8844  ;
0437C1 ED 7B 20 4D 8845  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437C6 21 AA 34 04 8846  			LD      HL,ERRWDS		; Index into the error string table
0437CA B7          8847  			OR      A			; We don't need to search for the first error
0437CB 28 0A       8848  			JR      Z,ERROR1		; So skip the search routine
0437CD             8849  ;
0437CD             8850  ; Search the error table for error #A
0437CD             8851  ; HL will end up being the pointer into the correct error
0437CD             8852  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0437CD             8853  ;
0437CD 47          8854  			LD      B,A             	; Store error number in B
0437CE 08          8855  			EX      AF,AF'			; Store error number in AF'
0437CF AF          8856  			XOR     A
0437D0 BE          8857  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437D1 23          8858  			INC     HL			; Increment the string pointer
0437D2 20 FC       8859  			JR      NZ,ERROR0		; Loop until with hit a 0
0437D4 10 FA       8860  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0437D6 08          8861  			EX      AF,AF'			; Restore the error number from AF'
0437D7             8862  ;
0437D7             8863  ; At this point HL points to the tokenised error string
0437D7             8864  ;
0437D7 E5          8865  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0437D8             8866  
0437D8             8867  ;
0437D8             8868  ; EXTERR
0437D8             8869  ; Inputs:
0437D8             8870  ;  A: Error number
0437D8             8871  ;
0437D8             8872  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0437D8             8873  ; The error text immediately follows the CALL to EXTERR, for example:
0437D8             8874  ; > CALL  EXTERR
0437D8             8875  ; > DB    "Silly", 0
0437D8             8876  ; So we can get the address of the string by popping the return address off the stack
0437D8             8877  ;
0437D8 E1          8878  EXTERR:			POP     HL			; Pop the error string pointer
0437D9 22 2F 4D 04 8879  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437DD ED 7B 20 4D 8880  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437E2 32 3F 4D 04 8881  			LD      (ERR),A			; Store error number in ERR sysvar
0437E6 CD 0F 3A 04 8882  			CALL    SETLIN			; Get line number
0437EA 22 33 4D 04 8883  			LD      (ERL),HL		; Store in ERL sysvar
0437EE B7          8884  			OR      A			; Is error number 0?
0437EF 28 0D       8885  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437F1             8886  ;
0437F1 2A 2C 4D 04 8887  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0437F5 7C          8888  			LD      A,H
0437F6 B5          8889  			OR      L
0437F7 E5          8890  			PUSH    HL			; HL: Error line
0437F8 FD E1       8891  			POP     IY			; IY: HL
0437FA C2 A9 0B 04 8892  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437FE             8893  ;
0437FE 21 00 00 00 8894  ERROR2:			LD      HL,0
043802 22 29 4D 04 8895  			LD      (AUTONO),HL		; Cancel AUTO
043806 22 26 4D 04 8896  			LD      (TRACEN),HL     	; Cancel TRACE
04380A CD 28 44 04 8897  			CALL    RESET           	; Reset OPSYS
04380E CD A8 39 04 8898  			CALL    CRLF			; Output newline
043812 CD E3 3D 04 8899  			CALL    REPORT          	; Output the error message
043816 CD 43 3A 04 8900  			CALL    SAYLN			; Output " at line nnnn" message.
04381A 1E 00       8901  			LD      E,0			; Close all files
04381C DC 9D 43 04 8902  			CALL    C,OSSHUT
043820 CD A8 39 04 8903  			CALL    CRLF			; Output newline
043824 C3 E1 30 04 8904  			JP      CLOOP			; Back to CLOOP
043828             8905  ;
043828             8906  ; SUBROUTINES:
043828             8907  ;
043828             8908  ; LEX - SEARCH FOR KEYWORDS
043828             8909  ;   Inputs: HL = start of keyword table
043828             8910  ;           IY = start of match text
043828             8911  ;  Outputs: If found, Z-flag set, A=token.
043828             8912  ;           If not found, Z-flag reset, A=(IY).
043828             8913  ;           IY updated (if NZ, IY unchanged).
043828             8914  ; Destroys: A,B,H,L,IY,F
043828             8915  ;
043828 21 C9 31 04 8916  LEX:			LD      HL,KEYWDS		; Address of the keywords table
04382C             8917  ;
04382C FD 7E 00    8918  LEX0:			LD      A,(IY)			; Fetch the character to match
04382F 46          8919  			LD      B,(HL)			; B: The token from the keywords table
043830 23          8920  			INC     HL			; Increment the pointer in the keywords table
043831 BE          8921  			CP      (HL)			; Compare the first characters
043832 28 08       8922  			JR      Z,LEX2			; If there is a match, then skip to LEX2
043834 D8          8923  			RET     C               	; No match, so fail
043835             8924  ;
043835             8925  ; This snippet of code skips to the next token in the KEYWDS table
043835             8926  ;
043835 23          8927  LEX1:			INC     HL			; Increment the pointer
043836 CB 7E       8928  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
043838 28 FB       8929  			JR      Z,LEX1			; No, so loop
04383A 18 F0       8930  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
04383C             8931  ;
04383C FD E5       8932  LEX2:			PUSH    IY              	; Save the input pointer
04383E 23          8933  LEX3:			INC     HL			; Increment the keyword pointer
04383F CB 7E       8934  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043841 20 1C       8935  			JR      NZ,LEX6         	; Jump to here as we've found a token
043843 FD 23       8936  			INC     IY			; Increment the text pointer
043845 FD 7E 00    8937  			LD      A,(IY)			; Fetch the character
043848 FE 2E       8938  			CP      '.'			; Is it an abbreviated keyword?
04384A 28 13       8939  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
04384C BE          8940  			CP      (HL)			; Compare with the keywords list
04384D 28 EF       8941  			JR      Z,LEX3			; It's a match, so continue checking this keyword
04384F CD DC 3C 04 8942  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043853 38 04       8943  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
043855             8944  ;
043855 FD E1       8945  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
043857 18 DC       8946  			JR      LEX1			; And loop back to start again
043859             8947  ;
043859             8948  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
043859             8949  ; immediately delimited
043859             8950  ;
043859 7E          8951  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
04385A B7          8952  			OR      A			; If it is not zero, then...
04385B 20 F8       8953  			JR      NZ,LEX4			; Keep searching
04385D FD 2B       8954  			DEC     IY			; If it is zero, then skip the input pointer back one byte
04385F             8955  ;
04385F             8956  ; We've found a token at this point
04385F             8957  ;
04385F F1          8958  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
043860 AF          8959  			XOR     A			; Set the Z flag
043861 78          8960  			LD      A,B			; A: The token
043862 C9          8961  			RET
043863             8962  ;
043863             8963  ; DEL - DELETE A PROGRAM LINE.
043863             8964  ;   Inputs: HL addresses program line.
043863             8965  ; Destroys: B,C,F
043863             8966  ;
043863             8967  ; This simply erases the line by moving all of the code after the line to be deleted back over
043863             8968  ; it using an LDIR
043863             8969  ;
043863 D5          8970  DEL:			PUSH    DE
043864 E5          8971  			PUSH    HL
043865 E5          8972  			PUSH    HL			; HL: Address of the program line
043866 06 00       8973  			LD      B,0			; BC: Length of the line
043868 4E          8974  			LD      C,(HL)
043869 09          8975  			ADD     HL,BC			; HL: Advanced to the start of the next line
04386A E5          8976  			PUSH    HL
04386B EB          8977  			EX      DE,HL			; DE: Pointer to the next line
04386C 2A 17 4D 04 8978  			LD      HL,(TOP)		; HL: Pointer to the end of the program
043870 ED 52       8979  			SBC     HL,DE
043872 44          8980  			LD      B,H			; BC: Size of block to move
043873 4D          8981  			LD      C,L
043874 E1          8982  			POP     HL			; HL: Pointer to next line
043875 D1          8983  			POP     DE			; DE: Pointer to this line
043876 ED B0       8984  			LDIR                    	; Delete the line
043878 ED 53 17 4D 8985  			LD      (TOP),DE		; Adjust TOP
       04          
04387D E1          8986  			POP     HL
04387E D1          8987  			POP     DE
04387F C9          8988  			RET
043880             8989  ;
043880             8990  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
043880             8991  ;   Inputs: Filename in ACCS (term CR)
043880             8992  ; Destroys: A,B,C,D,E,H,L,F
043880             8993  ;
043880             8994  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
043880             8995  ; AND WRITE FF FF, THEN LOAD (TOP).
043880             8996  ; Destroys: A,B,C,H,L,F
043880             8997  ;
043880 ED 5B 14 4D 8998  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
043885 21 00 FF FF 8999  			LD      HL,-256
043889 39          9000  			ADD     HL,SP
04388A ED 52       9001  			SBC     HL,DE           	; Find available space
04388C 44          9002  			LD      B,H
04388D 4D          9003  			LD      C,L
04388E 21 00 4A 04 9004  			LD      HL,ACCS
043892 CD 06 42 04 9005  			CALL    OSLOAD          	; Call the OSLOAD function in patch
043896 D4 CD 38 04 9006  			CALL    NC,NEWIT		; If NC then NEW
04389A 3E 00       9007  			LD      A,0
04389C D2 C1 37 04 9008  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0438A0             9009  ;
0438A0 CD AC 38 04 9010  CLEAN:			CALL    SETTOP			; Set TOP sysvar
0438A4 2B          9011  			DEC     HL			; Write out the end of program markers
0438A5 36 FF       9012  			LD      (HL),-1
0438A7 2B          9013  			DEC     HL
0438A8 36 FF       9014  			LD      (HL),-1
0438AA 18 2B       9015  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0438AC             9016  ;
0438AC             9017  ; Set the TOP sysvar; the first free location after the end of the current program
0438AC             9018  ; Returns:
0438AC             9019  ; - HL: TOP
0438AC             9020  ;
0438AC 2A 14 4D 04 9021  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0438B0 01 00 00 00 9022  			LD	BC, 0			; BC: 0
0438B4 3E 0D       9023  			LD      A,CR			; End of line marker
0438B6 4E          9024  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0438B7 0C          9025  			INC     C			; Check for zero
0438B8 0D          9026  			DEC     C
0438B9 28 0A       9027  			JR      Z,SETOP2		; If it is zero, we've reached the end
0438BB 09          9028  			ADD     HL,BC			; Skip to next line
0438BC 2B          9029  			DEC     HL			; Check end of previous line
0438BD BE          9030  			CP      (HL)
0438BE 23          9031  			INC     HL
0438BF 28 F5       9032  			JR      Z,SETOP1		; If CR then loop
0438C1 C3 59 37 04 9033  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0438C5             9034  ;
0438C5 23          9035  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0438C6 23          9036  			INC     HL			; NB: Called from NEWIT
0438C7 23          9037  			INC     HL
0438C8 22 17 4D 04 9038  			LD      (TOP),HL		; Store in TOP sysvar
0438CC C9          9039  			RET
0438CD             9040  ;
0438CD             9041  ; NEWIT - NEW PROGRAM THEN CLEAR
0438CD             9042  ;   Destroys: H,L
0438CD             9043  ;
0438CD             9044  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0438CD             9045  ; FUNCTION AND PROCEDURE POINTERS.
0438CD             9046  ;   Destroys: Nothing
0438CD             9047  ;
0438CD 2A 14 4D 04 9048  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438D1 36 00       9049  			LD      (HL),0			; Stick a 0 in there
0438D3 CD C5 38 04 9050  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438D7             9051  ;
0438D7 E5          9052  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438D8 2A 17 4D 04 9053  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438DC 22 1A 4D 04 9054  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0438E0 22 1D 4D 04 9055  			LD      (FREE),HL		; And the FREE sysvar with that value
0438E4 21 6C 4C 04 9056  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438E8 C5          9057  			PUSH    BC
0438E9             9058  			; LD      B,3*(54+2)		; Loop counter
0438E9 06 A8       9059  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438EB 36 00       9060  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438ED 23          9061  			INC     HL
0438EE 10 FB       9062  			DJNZ    CLEAR1
0438F0 C1          9063  			POP     BC
0438F1 E1          9064  			POP     HL			; Restore the BASIC program pointer
0438F2 C9          9065  			RET
0438F3             9066  ;
0438F3             9067  ;LISTIT - LIST A PROGRAM LINE.
0438F3             9068  ;    Inputs: HL addresses line
0438F3             9069  ;            DE = line number (binary)
0438F3             9070  ;            IX = Pointer to LISTON
0438F3             9071  ;             B = FOR/NEXT indent level
0438F3             9072  ;             C = REPEAT/UNTIL indent level
0438F3             9073  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0438F3             9074  ;
0438F3 E5          9075  LISTIT:			PUSH    HL			; Stack the address of the line
0438F4 EB          9076  			EX      DE,HL			; HL: Line number
0438F5 C5          9077  			PUSH    BC
0438F6 CD 5C 3A 04 9078  			CALL    PBCD			; Print the line number
0438FA C1          9079  			POP     BC
0438FB E1          9080  			POP     HL			; HL: Address of the first token/character
0438FC 7E          9081  			LD      A,(HL)			; Fetch the token
0438FD FE ED       9082  			CP      NEXT			; Is it NEXT...
0438FF CC 89 39 04 9083  			CALL    Z,INDENT		; Yes, so indent in
043903 FE FD       9084  			CP      UNTIL			; Or is it UNTIL...
043905 CC 89 39 04 9085  			CALL    Z,INDENT		; Yes, so indent in
043909 D9          9086  			EXX
04390A 3E 20       9087  			LD      A,' '
04390C DD CB 00 46 9088  			BIT     0,(IX)			; If BIT 0 of LISTON is set
043910 C4 B0 39 04 9089  			CALL    NZ,OUTCHR		; Then print a space after the line number
043914 78          9090  			LD      A,B			; Fetch the FOR/NEXT indent level
043915 87          9091  			ADD     A,A			; Multiply by 2
043916 DD CB 00 4E 9092  			BIT     1,(IX)			; If BIT 1 of LISTON is set
04391A C4 2C 18 04 9093  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
04391E 79          9094  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
04391F 87          9095  			ADD     A,A			; Multiply by 2
043920 DD CB 00 56 9096  			BIT     2,(IX)			; If BIT 2 of LISTON is set
043924 C4 2C 18 04 9097  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
043928 D9          9098  			EXX
043929 7E          9099  			LD      A,(HL)			; Fetch the token
04392A FE E3       9100  			CP      FOR			; Is it FOR?
04392C CC 89 39 04 9101  			CALL    Z,INDENT		; Yes, so indent
043930 FE F5       9102  			CP      REPEAT			; Is it REPEAT?
043932 CC 89 39 04 9103  			CALL    Z,INDENT		; Yes, so indent
043936 1E 00       9104  			LD      E,0			; E: The quote counter - reset to 0
043938 7E          9105  LIST8:			LD      A,(HL)			; Fetch a character / token byte
043939 23          9106  			INC     HL
04393A FE 0D       9107  			CP      CR			; Is it end of line?
04393C 28 0B       9108  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
04393E FE 22       9109  			CP      34			; Is it a quote character?
043940 20 01       9110  			JR      NZ,LIST7		; No, so skip to next bit
043942 1C          9111  			INC     E			; Otherwise increment quote counter
043943 CD 78 39 04 9112  LIST7:			CALL    LOUT			; Output the character / token
043947 18 EF       9113  			JR      LIST8			; And repeat
043949             9114  ;
043949             9115  ; DB: Modification for *EDIT
043949             9116  ; Terminate the line with either a CRLF or a NUL character
043949             9117  ;
043949 DD CB 00 5E 9118  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
04394D 28 59       9119  			JR	Z, CRLF			; Yes, so print a CRLF
04394F AF          9120  			XOR	A			; Otherwise print a NUL (0)
043950 C3 61 3F 04 9121  			JP	OSWRCH
043954             9122  ;
043954             9123  ; Decode the 3 byte GOTO type line number
043954             9124  ;
043954 E5          9125  PRLINO:			PUSH    HL			; Swap HL and IY
043955 FD E1       9126  			POP     IY			; IY: Pointer to the line number
043957 C5          9127  			PUSH    BC
043958 CD F6 08 04 9128  			CALL    DECODE			; Decode
04395C C1          9129  			POP     BC
04395D D9          9130  			EXX
04395E C5          9131  			PUSH    BC
04395F CD 58 3A 04 9132  			CALL    PBCDL			; Output the line number
043963 C1          9133  			POP     BC
043964 D9          9134  			EXX
043965 FD E5       9135  			PUSH    IY			; Swap HL and IY
043967 E1          9136  			POP     HL			; HL: Pointer to the next character in the line
043968 C9          9137  			RET
043969             9138  ;
043969             9139  ; DB: Modification for internationalisation
043969             9140  ;
043969 CD CD 39 04 9141  PRREM:			CALL	OUT_			; Output the REM token
04396D 7E          9142  @@:			LD	A, (HL)			; Fetch the character
04396E FE 0D       9143  			CP	CR			; If it is end of line, then
043970 C8          9144  			RET	Z			; we have finished
043971 CD B0 39 04 9145  			CALL	OUTCHR			; Ouput the character
043975 23          9146  			INC	HL
043976 18 F5       9147  			JR	@B			; And loop
043978             9148  ;
043978             9149  ; DB: End of modification
043978             9150  ;
043978 CB 43       9151  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
04397A 20 34       9152  			JR      NZ,OUTCHR		; don't tokenise, just output the character
04397C FE F4       9153  			CP	REM			; DB: Is it REM
04397E 28 E9       9154  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
043980 FE 8D       9155  			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
043982 28 D0       9156  			JR      Z,PRLINO		; Yes, so decode and print the line number
043984 CD CD 39 04 9157  			CALL    OUT_			; Output a character / keyword
043988 7E          9158  			LD      A,(HL)			; Fetch the next character
043989             9159  ;
043989             9160  ; This block of code handles the indentation
043989             9161  ; B: Counter for FOR/NEXT indent
043989             9162  ; C: Counter for REPEAT/UNTIL indent
043989             9163  ;
043989 D9          9164  INDENT:			EXX
04398A FE E3       9165  			CP      FOR			; If the token is FOR
04398C 28 09       9166  			JR      Z,IND1			; Then INC B
04398E FE ED       9167  			CP      NEXT			; If it is NEXT
043990 20 06       9168  			JR      NZ,IND2_		; Then...
043992 05          9169  			DEC     B			; DEC B
043993 F2 98 39 04 9170  			JP      P,IND2_			; If we have gone below 0 then
043997 04          9171  IND1:			INC     B			; Increment back to 0
043998             9172  ;
043998 FE F5       9173  IND2_:			CP      REPEAT			; If the token is REPEAT
04399A 28 09       9174  			JR      Z,IND3			; Then INC C
04399C FE FD       9175  			CP      UNTIL			; If it is UNTIL
04399E 20 06       9176  			JR      NZ,IND4			; Then...
0439A0 0D          9177  			DEC     C			; DEC C
0439A1 F2 A6 39 04 9178  			JP      P,IND4			; If we have gone below 0 then
0439A5 0C          9179  IND3:			INC     C			; Incremet back to 0
0439A6 D9          9180  IND4:			EXX
0439A7 C9          9181  			RET
0439A8             9182  ;
0439A8             9183  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
0439A8             9184  ;  Destroys: A,F
0439A8             9185  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
0439A8             9186  ;    Inputs: A = character
0439A8             9187  ;  Destroys: A,F
0439A8             9188  ;
0439A8 3E 0D       9189  CRLF:			LD      A,CR			; Output CR
0439AA CD B0 39 04 9190  			CALL    OUTCHR
0439AE 3E 0A       9191  			LD      A,LF			; Output LF
0439B0             9192  ;
0439B0 CD 61 3F 04 9193  OUTCHR:			CALL    OSWRCH			; Output the character in A
0439B4 D6 0D       9194  			SUB     CR			; Check for CR
0439B6 28 06       9195  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0439B8 D8          9196  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0439B9 3A 3D 4D 04 9197  			LD      A,(COUNT)		; Increment the count
0439BD 3C          9198  			INC     A
0439BE             9199  ;
0439BE 32 3D 4D 04 9200  CARRET:			LD      (COUNT),A		; Store the new count value
0439C2 C8          9201  			RET     Z			; Return if the count has wrapped to 0
0439C3 E5          9202  			PUSH    HL			; Now check if count = print width
0439C4 2A 3E 4D 04 9203  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0439C8 BD          9204  			CP      L			; L is the width. Compare it with count.
0439C9 E1          9205  			POP     HL
0439CA C0          9206  			RET     NZ			; If we've not hit print width, then just return
0439CB 18 DB       9207  			JR      CRLF			; Otherwise output CRLF
0439CD             9208  ;
0439CD             9209  ; OUT - SEND CHARACTER OR KEYWORD
0439CD             9210  ;   Inputs: A = character (>=10, <128)
0439CD             9211  ;           A = Token (<10, >=128)
0439CD             9212  ;  Destroys: A,F
0439CD             9213  ;
0439CD FE 8A       9214  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0439CF EA B0 39 04 9215  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439D3             9216  ;
0439D3             9217  ; This bit looks up the character in the KEYWDS token table and expands it
0439D3             9218  ; Note the CP 138; this sets the overflow flag as follows:
0439D3             9219  ;
0439D3             9220  ; NB:
0439D3             9221  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0439D3             9222  ;  2. CP is effectively a SUB; sets the flags without affecting A
0439D3             9223  ;  3. The operation n - -118 ~ n + 118
0439D3             9224  ;
0439D3             9225  ; So:
0439D3             9226  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0439D3             9227  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0439D3             9228  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0439D3             9229  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0439D3             9230  ;
0439D3 C5          9231  			PUSH    BC			; Preserve BC and HL
0439D4 E5          9232  			PUSH    HL
0439D5 21 C9 31 04 9233  			LD      HL,KEYWDS		; The list of tokens and keywords
0439D9 01 DF 02 00 9234  			LD      BC,KEYWDL		; The length of the keyword list
0439DD ED B1       9235  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439DF             9236  ;							; At this point HL points to the next byte, the first character of the token
0439DF 7E          9237  TOKEN1:			LD      A,(HL)			; Fetch the character
0439E0 23          9238  			INC     HL			; Increment to the next byte in the token table
0439E1 FE 8A       9239  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439E3 F5          9240  			PUSH    AF			; Then...
0439E4 EC B0 39 04 9241  			CALL    PE,OUTCHR		; Output the character...
0439E8 F1          9242  			POP     AF			;
0439E9 EA DF 39 04 9243  			JP      PE,TOKEN1		; And loop to the next character
0439ED E1          9244  			POP     HL			; Done, so tidy up the stack and exit
0439EE C1          9245  			POP     BC
0439EF C9          9246  			RET
0439F0             9247  ;
0439F0             9248  ; FINDL - FIND PROGRAM LINE
0439F0             9249  ;   Inputs: HL = line number (binary)
0439F0             9250  ;  Outputs: HL addresses line (if found)
0439F0             9251  ;           DE = line number
0439F0             9252  ;           Z-flag set if found.
0439F0             9253  ; Destroys: A,B,C,D,E,H,L,F
0439F0             9254  ;
0439F0 EB          9255  FINDL:			EX      DE,HL			; DE: Line number (binary)
0439F1 2A 14 4D 04 9256  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439F5 AF          9257  			XOR     A               	;  A: 0
0439F6 BE          9258  			CP      (HL)			; Check for end of program marker
0439F7 3C          9259  			INC     A			;  A: 1
0439F8 D0          9260  			RET     NC			; Return with 1 if 0
0439F9 AF          9261  			XOR     A               	; Clear the carry flag
0439FA             9262  ;			LD      B,A			;  B: 0
0439FA 01 00 00 00 9263  			LD	BC, 0			; BC: 0
0439FE             9264  ;
0439FE 4E          9265  FINDL1:			LD      C,(HL)			;  C: The line length
0439FF E5          9266  			PUSH    HL			; Stack the current program counter
043A00 23          9267  			INC     HL			; Skip to the line number bytes
043A01 7E          9268  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
043A02 23          9269  			INC     HL
043A03 66          9270  			LD      H,(HL)
043A04 6F          9271  			LD      L,A
043A05 52 ED 52    9272  			SBC.S   HL,DE			; Compare with the line number we're searching for
043A08 E1          9273  			POP     HL			; Get the current program counter
043A09 D0          9274  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
043A0A 09          9275  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
043A0B C3 FE 39 04 9276  			JP      FINDL1			; And loop
043A0F             9277  ;
043A0F             9278  ; SETLIN - Search program for line containing address
043A0F             9279  ;          Update (LINENO)
043A0F             9280  ;   Inputs: Address in (ERRLIN)
043A0F             9281  ;  Outputs: Line number in HL and (LINENO)
043A0F             9282  ; Destroys: B,C,D,E,H,L,F
043A0F             9283  ;
043A0F 01 00 00 00 9284  SETLIN:			LD	BC, 0			; Zero BC for later
043A13             9285  ;			LD      B, 0			; Zero B for later
043A13 ED 5B 35 4D 9286  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
043A18 2A 14 4D 04 9287  			LD      HL, (PAGE_)		; HL: Start of user program area
043A1C B7          9288  			OR      A			; Do a 24 bit compare without destroying HL
043A1D ED 52       9289  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
043A1F 19          9290  			ADD     HL, DE			;  C: DE > HL
043A20 30 1B       9291  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
043A22             9292  ;
043A22 4E          9293  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
043A23 0C          9294  			INC     C			; This is a way to check for zero without using the accumulator
043A24 0D          9295  			DEC     C			; If it is zero, then...
043A25 28 16       9296  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
043A27 09          9297  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
043A28 ED 52       9298  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
043A2A 19          9299  			ADD     HL, DE
043A2B 38 F5       9300  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
043A2D ED 42       9301  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
043A2F 23          9302  			INC     HL			; Skip the length counter
043A30 11 00 00 00 9303  			LD	DE, 0			; Zero DE
043A34 5E          9304  			LD      E, (HL)          	; Fetch the line number
043A35 23          9305  			INC     HL
043A36 56          9306  			LD      D, (HL)
043A37 EB          9307  			EX      DE, HL			; HL: The line number
043A38 22 23 4D 04 9308  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A3C C9          9309  			RET
043A3D             9310  ;
043A3D 21 00 00 00 9311  SET3:			LD      HL, 0			; We've not found the line at this point so
043A41 18 F5       9312  			JR      SET2			; Set LINENO to 0
043A43             9313  ;
043A43             9314  ;SAYLN - PRINT " at line nnnn" MESSAGE.
043A43             9315  ;  Outputs: Carry=0 if line number is zero.
043A43             9316  ;           Carry=1 if line number is non-zero.
043A43             9317  ; Destroys: A,B,C,D,E,H,L,F
043A43             9318  ;
043A43 2A 23 4D 04 9319  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A47 7C          9320  			LD      A,H			; If it is zero then
043A48 B5          9321  			OR      L
043A49 C8          9322  			RET     Z			; Don't need to do anything; return with F:C set to 0
043A4A CD F1 3D 04 9323  			CALL    TELL			; Output the error message
043A4E 20 61 74 20 9324  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
043A58 0E 00       9325  PBCDL:			LD      C,0			; C: Leading character (NUL)
043A5A 18 02       9326  			JR      PBCD0			; Output the line number; return with F:C set to 1
043A5C             9327  ;
043A5C             9328  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
043A5C             9329  ;   Inputs: HL = number (binary).
043A5C             9330  ;  Outputs: Carry = 1
043A5C             9331  ; Destroys: A,B,C,D,E,H,L,F
043A5C             9332  ;
043A5C 0E 20       9333  PBCD:			LD      C,' '			; C: Leading character (" ")
043A5E 06 05       9334  PBCD0:			LD      B,5			; Number of digits in result
043A60 11 10 27 00 9335  			LD      DE,10000		; Start off with the 10,000 column
043A64 AF          9336  PBCD1:			XOR     A			; Counter
043A65 ED 52       9337  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A67 3C          9338  			INC     A
043A68 30 FB       9339  			JR      NC,PBCD2
043A6A 19          9340  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A6B 3D          9341  			DEC     A			; A: Number of 10,000s
043A6C 28 04       9342  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A6E CB E1       9343  			SET     4,C			; C: Set to '0' ASCII (30h)
043A70 CB E9       9344  			SET     5,C
043A72 B1          9345  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A73 C4 B0 39 04 9346  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A77 78          9347  			LD      A,B			; If on first transition, skip this
043A78 FE 05       9348  			CP      5			; TODO: Need to find out why
043A7A 28 06       9349  			JR      Z,PBCD4
043A7C 29          9350  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A7D 54          9351  			LD      D,H			;         : rather than shifting DE right
043A7E 5D          9352  			LD      E,L			;         : This makes a lot of sense
043A7F 29          9353  			ADD     HL,HL			; HL x  4
043A80 29          9354  			ADD     HL,HL			; HL x  8
043A81 19          9355  			ADD     HL,DE			; HL x 10
043A82 11 E8 03 00 9356  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A86 10 DC       9357  			DJNZ    PBCD1			; Loop until done
043A88 37          9358  			SCF				; SCF set for SAYLN in this module
043A89 C9          9359  			RET
043A8A             9360  ;
043A8A             9361  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A8A             9362  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A8A             9363  ;  Outputs: As GETVAR.
043A8A             9364  ; Destroys: everything
043A8A             9365  ;
043A8A CD 0F 3C 04 9366  PUTVAR:			CALL    CREATE			; Create the variable
043A8E FD 7E 00    9367  			LD      A,(IY)			; Fetch the next character
043A91 FE 28       9368  			CP      '('			; Check for bad use of array
043A93 20 70       9369  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A95 3E 0E       9370  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A97 C3 C1 37 04 9371  ERROR3:			JP      ERROR_
043A9B             9372  ;
043A9B             9373  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A9B             9374  ;   Inputs: IY addresses first character.
043A9B             9375  ;  Outputs: Carry set and NZ if illegal character.
043A9B             9376  ;           Z-flag set if variable found, then:
043A9B             9377  ;            A = variable type (0,4,5,128 or 129)
043A9B             9378  ;            HL = IX = variable pointer.
043A9B             9379  ;            IY updated
043A9B             9380  ;           If Z-flag & carry reset, then:
043A9B             9381  ;            HL, IY set for subsequent PUTVAR call.
043A9B             9382  ; Destroys: everything
043A9B             9383  ;
043A9B FD 7E 00    9384  GETVAR:			LD      A,(IY)			; Get the first character
043A9E FE 24       9385  			CP      '$'			; Is it a string?
043AA0 28 69       9386  			JR      Z,GETV4			; Yes, so branch here
043AA2 FE 21       9387  			CP      '!'			; Is it indirection (32-bit)?
043AA4 28 69       9388  			JR      Z,GETV5			; Yes, so branch here
043AA6 FE 3F       9389  			CP      '?'			; Is it indirection (8-bit)?
043AA8 28 69       9390  			JR      Z,GETV6			; Yes, so branch here
043AAA             9391  ;
043AAA CD 79 3B 04 9392  			CALL    LOCATE			; Locate the variable
043AAE C0          9393  			RET     NZ			; And exit here if not found
043AAF             9394  ;
043AAF             9395  ; At this point:
043AAF             9396  ;  HL: Address of variable in memory
043AAF             9397  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043AAF             9398  ;
043AAF FD 7E 00    9399  			LD      A,(IY)			; Further checks
043AB2 FE 28       9400  			CP      '('             	; Is it an array?
043AB4 20 47       9401  			JR      NZ,GETVX        	; No, so exit
043AB6             9402  ;
043AB6             9403  ; We are processing an array at this point
043AB6             9404  ;
043AB6 D5          9405  			PUSH    DE              	; Save the variable type (in D)
043AB7 7E          9406  			LD      A,(HL)          	; Fetch the number of dimensions
043AB8 B7          9407  			OR      A
043AB9 28 DA       9408  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043ABB 23          9409  			INC     HL			;
043ABC 11 00 00 00 9410  			LD      DE,0            	; Accumulator
043AC0 F5          9411  			PUSH    AF
043AC1 FD 23       9412  			INC     IY              	; Skip "("
043AC3 18 05       9413  			JR      GETV3
043AC5             9414  ;
043AC5 F5          9415  GETV2:			PUSH    AF
043AC6 CD 35 0A 04 9416  			CALL    COMMA
043ACA E5          9417  GETV3:			PUSH    HL
043ACB D5          9418  			PUSH    DE
043ACC CD 1A 03 04 9419  			CALL    EXPRI			; Get the subscript
043AD0 D9          9420  			EXX
043AD1 D1          9421  			POP     DE
043AD2 E3          9422  			EX      (SP),HL
043AD3 4E          9423  			LD      C,(HL)
043AD4 23          9424  			INC     HL
043AD5 46          9425  			LD      B,(HL)
043AD6 23          9426  			INC     HL
043AD7 E3          9427  			EX      (SP),HL
043AD8 EB          9428  			EX      DE,HL
043AD9 D5          9429  			PUSH    DE
043ADA CD AF 18 04 9430  			CALL    MUL16			; HL=HL*BC
043ADE D1          9431  			POP     DE
043ADF 19          9432  			ADD     HL,DE
043AE0 EB          9433  			EX      DE,HL
043AE1 B7          9434  			OR      A
043AE2 ED 42       9435  			SBC     HL,BC
043AE4 3E 0F       9436  			LD      A,15
043AE6 30 AF       9437  			JR      NC,ERROR3		; Throw a "Subscript" error
043AE8 E1          9438  			POP     HL
043AE9 F1          9439  			POP     AF
043AEA 3D          9440  			DEC     A               	; Dimension counter
043AEB 20 D8       9441  			JR      NZ,GETV2
043AED CD 42 0A 04 9442  			CALL    BRAKET          	; Check for closing bracket
043AF1 F1          9443  			POP     AF              	; Restore the type
043AF2 E5          9444  			PUSH    HL
043AF3 CD A2 18 04 9445  			CALL    X4OR5           	; DE=DE*n
043AF7 E1          9446  			POP     HL
043AF8 19          9447  			ADD     HL,DE
043AF9 57          9448  			LD      D,A             	; The type
043AFA FD 7E 00    9449  			LD      A,(IY)
043AFD FE 3F       9450  GETVX:			CP      '?'
043AFF 28 1E       9451  			JR      Z,GETV9
043B01 FE 21       9452  			CP      '!'
043B03 28 16       9453  			JR      Z,GETV8
043B05 E5          9454  GETVZ:			PUSH    HL              	; Set exit conditions
043B06 DD E1       9455  			POP     IX
043B08 7A          9456  			LD      A,D
043B09 BF          9457  			CP      A
043B0A C9          9458  			RET
043B0B             9459  ;
043B0B             9460  ; Process strings, unary & binary indirection:
043B0B             9461  ;
043B0B 3E 80       9462  GETV4:			LD      A,128           	; Static strings
043B0D 18 05       9463  			JR      GETV7
043B0F             9464  ;
043B0F 3E 04       9465  GETV5:			LD      A,4             	; Unary 32-bit indirection
043B11 18 01       9466  			JR      GETV7
043B13             9467  ;
043B13 AF          9468  GETV6:			XOR     A               	; Unary 8-bit indirection
043B14             9469  ;
043B14 21 00 00 00 9470  GETV7:			LD      HL,0
043B18 F5          9471  			PUSH    AF
043B19 18 24       9472  			JR      GETV0
043B1B             9473  ;
043B1B 06 04       9474  GETV8:			LD      B,4             	; Binary 32-bt indirection
043B1D 18 02       9475  			JR      GETVA
043B1F             9476  ;
043B1F 06 00       9477  GETV9:			LD      B,0             	; Binary 8-bit indirection
043B21             9478  ;
043B21 E5          9479  GETVA:			PUSH    HL
043B22 DD E1       9480  			POP     IX
043B24 7A          9481  			LD      A,D            		; Fetch the variable type
043B25 FE 81       9482  			CP      129			; Is it a string?
043B27 C8          9483  			RET     Z               	; Yes, so exit here
043B28 C5          9484  			PUSH    BC
043B29 CD 26 04 04 9485  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043B2D CD 72 06 04 9486  			CALL    SFIX
043B31 7D          9487  			LD	A,L
043B32 D9          9488  			EXX
043B33 22 4A 4D 04 9489  			LD	(R0+0),HL
043B37 32 4C 4D 04 9490  			LD	(R0+2),A
043B3B 2A 4A 4D 04 9491  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B3F             9492  ;
043B3F E5          9493  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B40 FD 23       9494  			INC     IY
043B42 CD 35 03 04 9495  			CALL    ITEMI
043B46 7D          9496  			LD	A,L			;  A: The MSB of the address
043B47 D9          9497  			EXX
043B48 22 4A 4D 04 9498  			LD	(R0+0),HL		; HL: The LSW of the address
043B4C 32 4C 4D 04 9499  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B50 D1          9500  			POP     DE
043B51 F1          9501  			POP     AF
043B52 2A 4A 4D 04 9502  			LD	HL,(R0)			; HL: L'HL
043B56 19          9503  			ADD     HL,DE
043B57 E5          9504  			PUSH    HL
043B58 DD E1       9505  			POP     IX
043B5A BF          9506  			CP      A
043B5B C9          9507  			RET
043B5C             9508  ;
043B5C             9509  ;GETDEF - Find entry for FN or PROC in dynamic area.
043B5C             9510  ;   Inputs: IY addresses byte following "DEF" token.
043B5C             9511  ;  Outputs: Z flag set if found
043B5C             9512  ;           Carry set if neither FN or PROC first.
043B5C             9513  ;           If Z: HL points to entry
043B5C             9514  ;                 IY addresses delimiter
043B5C             9515  ; Destroys: A,D,E,H,L,IY,F
043B5C             9516  ;
043B5C FD 7E 01    9517  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B5F CD DC 3C 04 9518  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B63 D8          9519  			RET     C			; No so return with C set
043B64 FD 7E 00    9520  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B67 21 0E 4D 04 9521  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B6B FE A4       9522  			CP      FN			; Is it the token FN?
043B6D 28 4A       9523  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B6F 21 11 4D 04 9524  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B73 FE F2       9525  			CP      PROC			; Is it the token PROC?
043B75 28 42       9526  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B77 37          9527  			SCF				; No, so just return with C set
043B78 C9          9528  			RET
043B79             9529  ;
043B79             9530  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B79             9531  ; If illegal first character return carry, non-zero.
043B79             9532  ; If found, return no-carry, zero.
043B79             9533  ; If not found, return no-carry, non-zero.
043B79             9534  ;   Inputs: IY=Addresses first character of name.
043B79             9535  ;            A=(IY)
043B79             9536  ;  Outputs:  F=Z set if found, then:
043B79             9537  ;           IY=addresses terminator
043B79             9538  ;           HL=addresses location of variable
043B79             9539  ;            D=type of variable: 4 = integer
043B79             9540  ;                                5 = floating point
043B79             9541  ;                              129 = string
043B79             9542  ; Destroys: A,D,E,H,L,IY,F
043B79             9543  ;
043B79             9544  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B79             9545  ; They can contain any alphanumeric character and underscore (_)
043B79             9546  ; String variables are postfixed with the dollar ($) character
043B79             9547  ; Integer variables are postfixed with the percent (%) character
043B79             9548  ; Static integer variables are named @%, A% to Z%
043B79             9549  ; All other variables are dynamic
043B79             9550  ;
043B79 D6 40       9551  LOCATE:			SUB     '@'			; Check for valid range
043B7B D8          9552  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B7C 21 00 00 00 9553  			LD      HL, 0			; Clear HL
043B80 FE 1B       9554  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B82 30 1E       9555  			JR      NC,LOC0         	; Then branch here
043B84 6F          9556  			LD	L, A			; HL = A
043B85 FD 7E 01    9557  			LD      A,(IY+1)        	; Check the 2nd character
043B88 FE 25       9558  			CP      '%'			; If not "%" then it is not static...
043B8A 20 21       9559  			JR      NZ,LOC1         	; Branch here
043B8C FD 7E 02    9560  			LD      A,(IY+2)		; Check the 3rd character
043B8F FE 28       9561  			CP      '('			; If it is "(" (array) then it is not static...
043B91 28 1A       9562  			JR      Z,LOC1          	; Branch here
043B93             9563  ;
043B93             9564  ; At this point we're dealing with a static variable
043B93             9565  ;
043B93 29          9566  			ADD     HL,HL			; HL: Variable index * 4
043B94 29          9567  			ADD	HL,HL
043B95 11 00 4C 04 9568  			LD      DE,STAVAR       	; The static variable area in memory
043B99 19          9569  			ADD     HL,DE			; HL: The address of the static variable
043B9A FD 23       9570  			INC     IY			; Skip the program pointer past the static variable name
043B9C FD 23       9571  			INC     IY
043B9E 16 04       9572  			LD      D,4             	; Set the type to be integer
043BA0 AF          9573  			XOR     A			; Set the Z flag
043BA1 C9          9574  			RET
043BA2             9575  ;
043BA2             9576  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043BA2             9577  ;
043BA2 FE 1F       9578  LOC0:			CP      '_'-'@'			; Check the first character is in
043BA4 D8          9579  			RET     C			; the range "_" to
043BA5 FE 3B       9580  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043BA7 3F          9581  			CCF				; If it is not in range then
043BA8 3D          9582  			DEC     A               	; Set NZ flag and
043BA9 D8          9583  			RET     C			; Exit here
043BAA D6 03       9584  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043BAC 6F          9585  			LD	L, A			; HL = A
043BAD             9586  ;
043BAD             9587  ; Yes, it's definitely a dynamic variable at this point...
043BAD             9588  ;
043BAD 7D          9589  LOC1:			LD	A, L			; Fetch variable index
043BAE 87          9590  			ADD	A, A			; x 2
043BAF 85          9591  			ADD	A, L			; x 3
043BB0 D6 03       9592  			SUB	3			; Subtract 2 TODO: Should be 3
043BB2 6F          9593  			LD	L, A
043BB3 11 6C 4C 04 9594  			LD      DE, DYNVAR       	; The dynamic variable storage
043BB7 D8          9595  			RET	C			; Bounds check to trap for variable '@'
043BB8 19          9596  			ADD     HL, DE			; HL: Address of first entry
043BB9             9597  ;
043BB9             9598  ; Loop through the linked list of variables to find a match
043BB9             9599  ;
043BB9 ED 17       9600  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043BBB E5          9601  			PUSH	HL			; Need to preserve HL for LOC6
043BBC AF          9602  			XOR	A			; Reset carry flag
043BBD ED 62       9603  			SBC	HL, HL			; Set HL to 0
043BBF ED 52       9604  			SBC	HL, DE			; Compare with 0
043BC1 E1          9605  			POP	HL			; Restore the original pointer
043BC2 28 49       9606  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043BC4             9607  			; LD	HL, DE			; Make a copy of this pointer in HL
043BC4 D5          9608  			push de
043BC5 E1          9609  			pop hl ; how was that even possible?
043BC6 23          9610  			INC     HL              	; Skip the link (24-bits)
043BC7 23          9611  			INC     HL
043BC8 23          9612  			INC	HL			; HL: Address of the variable name in DYNVARS
043BC9 FD E5       9613  			PUSH    IY			; IY: Address of the variable name in the program
043BCB             9614  ;
043BCB 7E          9615  LOC3:			LD      A,(HL)         		; Compare
043BCC 23          9616  			INC     HL
043BCD FD 23       9617  			INC     IY
043BCF FD BE 00    9618  			CP      (IY)
043BD2 28 F7       9619  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043BD4 B7          9620  			OR      A               	; Have we hit a terminator?
043BD5 28 07       9621  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BD7             9622  ;
043BD7 FD E1       9623  LOC4:			POP     IY			; Restore the pointer in the program
043BD9 EB          9624  			EX      DE, HL			; HL: New pointer in DYNVARS
043BDA C3 B9 3B 04 9625  			JP      LOC2            	; Loop round and try again
043BDE             9626  ;
043BDE             9627  ; We might have located a variable at this point, just need to do a few more tests
043BDE             9628  ;
043BDE FD 2B       9629  LOC5:			DEC     IY
043BE0 FD 7E 00    9630  			LD      A,(IY)
043BE3 FE 28       9631  			CP      '('
043BE5 28 15       9632  			JR      Z,LOC5A         	; FOUND
043BE7 FD 23       9633  			INC     IY
043BE9 CD D0 3C 04 9634  			CALL    RANGE
043BED 38 0D       9635  			JR      C,LOC5A         	; FOUND
043BEF FE 28       9636  			CP      '('
043BF1 28 E4       9637  			JR      Z,LOC4          	; KEEP LOOKING
043BF3 FD 7E FF    9638  			LD      A,(IY-1)
043BF6 CD DC 3C 04 9639  			CALL    RANGE1
043BFA 30 DB       9640  			JR      NC,LOC4         	; KEEP LOOKING
043BFC D1          9641  LOC5A:			POP     DE
043BFD FD 7E FF    9642  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043C00 FE 24       9643  			CP      '$'			; Is it a string?
043C02 16 81       9644  			LD      D,129			; Yes, so return D = 129
043C04 C8          9645  			RET     Z
043C05 FE 25       9646  			CP      '%'			; Is it an integer?
043C07 16 04       9647  			LD      D,4			; Yes, so return D = 4
043C09 C8          9648  			RET     Z
043C0A 14          9649  			INC     D			; At this point it must be a float
043C0B BF          9650  			CP      A			; Set the flags
043C0C C9          9651  			RET
043C0D             9652  ;
043C0D             9653  ; The variable is undefined at this point; HL will be zero
043C0D             9654  ;
043C0D 3C          9655  LOC6:			INC     A               	; Set NZ flag
043C0E C9          9656  			RET
043C0F             9657  ;
043C0F             9658  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043C0F             9659  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043C0F             9660  ;  Outputs: As LOCATE, GETDEF.
043C0F             9661  ; Destroys: As LOCATE, GETDEF.
043C0F             9662  ;
043C0F AF          9663  CREATE:			XOR     A
043C10 ED 5B 1D 4D 9664  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043C15 ED 1F       9665  			LD	(HL), DE		; Store
043C17 EB          9666  			EX      DE,HL
043C18 77          9667  			LD      (HL),A			; Clear the link of the new entity
043C19 23          9668  			INC     HL
043C1A 77          9669  			LD      (HL),A
043C1B 23          9670  			INC     HL
043C1C 77          9671  			LD      (HL),A
043C1D 23          9672  			INC     HL
043C1E FD 23       9673  LOC7:			INC     IY
043C20 CD D0 3C 04 9674  			CALL    RANGE           	; END OF VARIABLE?
043C24 38 15       9675  			JR      C,LOC8
043C26 77          9676  			LD      (HL),A
043C27 23          9677  			INC     HL
043C28 CD DC 3C 04 9678  			CALL    RANGE1
043C2C 30 F0       9679  			JR      NC,LOC7
043C2E FE 28       9680  			CP      '('
043C30 28 09       9681  			JR      Z,LOC8
043C32 FD 7E 01    9682  			LD      A,(IY+1)
043C35 FE 28       9683  			CP      '('
043C37 28 E5       9684  			JR      Z,LOC7
043C39 FD 23       9685  			INC     IY
043C3B 36 00       9686  LOC8:			LD      (HL),0          	; TERMINATOR
043C3D 23          9687  			INC     HL
043C3E E5          9688  			PUSH    HL
043C3F CD FD 3B 04 9689  			CALL    TYPE_			; Get the variable type in D
043C43 3E 04       9690  			LD      A,4			; If it is an integer then it takes up 4 bytes
043C45 BA          9691  			CP      D
043C46 28 01       9692  			JR      Z,LOC9			; So skip the next bit
043C48 3C          9693  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C49 36 00       9694  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C4B 23          9695  			INC     HL
043C4C 3D          9696  			DEC     A
043C4D 20 FA       9697  			JR      NZ,LOC9
043C4F 22 1D 4D 04 9698  			LD      (FREE),HL		; Adjust the stack
043C53 CD 8C 16 04 9699  			CALL    CHECK			; Check whether we are out of space
043C57 E1          9700  			POP     HL
043C58 AF          9701  			XOR     A
043C59 C9          9702  			RET
043C5A             9703  ;
043C5A             9704  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043C5A             9705  ;   Inputs: IY = Text Pointer
043C5A             9706  ;  Outputs: HL = Line number (zero if none)
043C5A             9707  ;           IY updated
043C5A             9708  ; Destroys: A,D,E,H,L,IY,F
043C5A             9709  ;
043C5A             9710  ; This bit of code performs a BASE 10 shift to build up the number
043C5A             9711  ; So if the string passed is "345", the algorithm does this:
043C5A             9712  ;
043C5A             9713  ;    HL : Digit	: Operation
043C5A             9714  ; ----- : ----- : ---------
043C5A             9715  ; 00000 :	:
043C5A             9716  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043C5A             9717  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043C5A             9718  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043C5A             9719  ;
043C5A             9720  ; The multiply by 10 is done by an unrolled shift and add loop
043C5A             9721  ;
043C5A CD 83 0A 04 9722  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C5E 40 21 00 00 9723  			LD.SIS  HL,0			; The running total
043C62 FD 7E 00    9724  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C65 D6 30       9725  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C67 D8          9726  			RET     C			; And return if less than 0
043C68 FE 0A       9727  			CP      10			; Or greater than or equal to 10
043C6A D0          9728  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C6B FD 23       9729  			INC     IY			; Increment the string pointer
043C6D 54          9730  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C6E 5D          9731  			LD      E,L			; Store the original number in DE
043C6F 52 29       9732  			ADD.S   HL,HL           	; *2
043C71 38 13       9733  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C73 52 29       9734  			ADD.S   HL,HL           	; *4S
043C75 38 0F       9735  			JR      C,TOOBIG
043C77 52 19       9736  			ADD.S   HL,DE           	; *5
043C79 38 0B       9737  			JR      C,TOOBIG
043C7B 52 29       9738  			ADD.S   HL,HL           	; *10
043C7D 38 07       9739  			JR      C,TOOBIG
043C7F 5F          9740  			LD      E,A			; A->DE: the digit to add in
043C80 16 00       9741  			LD      D,0
043C82 52 19       9742  			ADD.S   HL,DE           	; Add in the digit to the running total
043C84 30 DC       9743  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C86             9744  ;
043C86 3E 14       9745  TOOBIG:			LD      A,20
043C88 C3 C1 37 04 9746  			JP      ERROR_           	; Error: "Too big"
043C8C             9747  ;
043C8C             9748  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C8C             9749  ;   Inputs: IY = text pointer
043C8C             9750  ;  Outputs: HL = first number (10 by default)
043C8C             9751  ;           BC = second number (10 by default)
043C8C             9752  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C8C             9753  ;
043C8C CD 5A 3C 04 9754  PAIR:			CALL    LINNUM          	; Parse the first line number
043C90 7C          9755  			LD      A,H			; If it is not zero, then...
043C91 B5          9756  			OR      L
043C92 20 02       9757  			JR      NZ,PAIR1		; Skip...
043C94 2E 0A       9758  			LD      L,10			; HL: the default value (10)
043C96             9759  ;
043C96 CD B7 17 04 9760  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C9A FD 23       9761  			INC     IY			; Skip to next character
043C9C E5          9762  			PUSH    HL			; Stack the first line number
043C9D 21 0A 00 00 9763  			LD      HL,10			; HL: the second default (10)
043CA1 C4 5A 3C 04 9764  			CALL    NZ,LINNUM       	; Parse the second line number
043CA5 E3          9765  			EX      (SP),HL			; HL: The first line number (off the stack)
043CA6 C1          9766  			POP     BC			; BC: Second line number
043CA7 78          9767  			LD      A,B			; If the second line number is not zero then...
043CA8 B1          9768  			OR      C			; We're good...
043CA9 C0          9769  			RET     NZ			; Exit, otherwise...
043CAA CD D8 37 04 9770  			CALL    EXTERR			; Throw error: "Silly"
043CAE 53 69 6C 6C 9771  			DB    	"Silly", 0
       79 00       
043CB4             9772  ;
043CB4             9773  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043CB4             9774  ;   Inputs: IY = text pointer
043CB4             9775  ;  Outputs: HL = points to program text
043CB4             9776  ;           BC = second number (0 by default)
043CB4             9777  ; Destroys: A,B,C,D,E,H,L,IY,F
043CB4             9778  ;
043CB4 CD 5A 3C 04 9779  DLPAIR:			CALL    LINNUM			; Parse the first line number
043CB8 E5          9780  			PUSH    HL			; Stack it
043CB9 CD B7 17 04 9781  			CALL    TERMQ			; Check for ELSE, : or CR
043CBD 28 0A       9782  			JR      Z,DLP1			; And exit if so
043CBF FE E7       9783  			CP      TIF			; Is the token IF?
043CC1 28 06       9784  			JR      Z,DLP1			; Yes, so skip the next bit...
043CC3 FD 23       9785  			INC     IY			; Otherwise...
043CC5 CD 5A 3C 04 9786  			CALL    LINNUM			; Fetch the second line number
043CC9 E3          9787  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043CCA CD F0 39 04 9788  			CALL    FINDL			; HL: Find the address of the line
043CCE C1          9789  			POP     BC			; BC: The second number
043CCF C9          9790  			RET
043CD0             9791  ;
043CD0             9792  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043CD0             9793  ;   Inputs: IY addresses character
043CD0             9794  ;  Outputs: Carry set if out-of-range.
043CD0             9795  ; Destroys: A,F
043CD0             9796  ;
043CD0             9797  ; It is called here to check the following
043CD0             9798  ; In range: "$", "%" and "("
043CD0             9799  ;   Plus all characters in RANGE1 and RANGE2
043CD0             9800  ;
043CD0 FD 7E 00    9801  RANGE:			LD      A,(IY)			; Fetch the character
043CD3 FE 24       9802  			CP      '$'			; Postfix for string variable is valid
043CD5 C8          9803  			RET     Z
043CD6 FE 25       9804  			CP      '%'			; Postfix for integer variable is valid
043CD8 C8          9805  			RET     Z
043CD9 FE 28       9806  			CP      '('			; Postfix for array is valid
043CDB C8          9807  			RET     Z
043CDC             9808  ;
043CDC             9809  ; It is called here to check the following
043CDC             9810  ; In range: "0" to "9" and "@"
043CDC             9811  ;   Plus all characters in RANGE2
043CDC             9812  ;
043CDC FE 30       9813  RANGE1:			CP      '0'			; If it is between '0'...
043CDE D8          9814  			RET     C
043CDF FE 3A       9815  			CP      '9'+1			; And '9'...
043CE1 3F          9816  			CCF
043CE2 D0          9817  			RET     NC			; Then it is valid
043CE3 FE 40       9818  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CE5 C8          9819  			RET     Z
043CE6             9820  ;
043CE6             9821  ; It is called here to check the following
043CE6             9822  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043CE6             9823  ;
043CE6 FE 41       9824  RANGE2:			CP      'A'			; If it is between 'A'...
043CE8 D8          9825  			RET     C
043CE9 FE 5B       9826  			CP      'Z'+1			; And 'Z'...
043CEB 3F          9827  			CCF
043CEC D0          9828  			RET     NC			; Then it is valid
043CED FE 5F       9829  			CP      '_'			; If it is underscore, grave, or between 'a'
043CEF D8          9830  			RET     C
043CF0 FE 7B       9831  			CP      'z'+1			; And 'z'
043CF2 3F          9832  			CCF				; Then it is valid
043CF3 C9          9833  			RET
043CF4             9834  ;
043CF4             9835  ; Throw a 'LINE space' error (line too long)
043CF4             9836  ; This is called from LEXAN
043CF4             9837  ;
043CF4 AF          9838  SPACE_: 		XOR     A
043CF5 CD D8 37 04 9839  			CALL    EXTERR          	; "LINE space"
043CF9 86 08 00    9840  			DB    	LINE_, 8, 0
043CFC             9841  ;
043CFC             9842  ; LEXAN - LEXICAL ANALYSIS.
043CFC             9843  ;  Bit 0,C: 1=left, 0=right
043CFC             9844  ;  Bit 2,C: 1=in BINARY
043CFC             9845  ;  Bit 3,C: 1=in HEX
043CFC             9846  ;  Bit 4,C: 1=accept line number
043CFC             9847  ;  Bit 5,C: 1=in variable, FN, PROC
043CFC             9848  ;  Bit 6,C: 1=in REM, DATA, *
043CFC             9849  ;  Bit 7,C: 1=in quotes
043CFC             9850  ;   Inputs: IY addresses source string
043CFC             9851  ;           DE addresses destination string (must be page boundary)
043CFC             9852  ;            C sets initial mode
043CFC             9853  ;  Outputs: DE, IY updated
043CFC             9854  ;            A holds carriage return
043CFC             9855  ;
043CFC 12          9856  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CFD 13          9857  			INC     DE              	; Increment the pointers
043CFE FD 23       9858  			INC     IY			; And fall through to the main function
043D00             9859  ;
043D00             9860  ; This is the main entry point
043D00             9861  ;
043D00 7B          9862  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043D01 FE FC       9863  			CP      252             	; If it is >= 252 bytes, then...
043D03 30 EF       9864  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043D05 FD 7E 00    9865  			LD      A,(IY)			; Fetch character from source string
043D08 FE 0D       9866  			CP      CR			; If it is a CR
043D0A C8          9867  			RET     Z               	; Then it is end of line; we're done parsing
043D0B CD DC 3C 04 9868  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043D0F 30 06       9869  			JR      NC,LEXAN3		; Yes, so skip
043D11 CB A9       9870  			RES     5,C             	; FLAG: NOT IN VARIABLE
043D13 CB 99       9871  			RES     3,C             	; FLAG: NOT IN HEX
043D15 CB 91       9872  			RES	2,C			; FLAG: NOT IN BINARY
043D17             9873  ;
043D17 FE 20       9874  LEXAN3:			CP      ' '			; Ignore spaces
043D19 28 E1       9875  			JR      Z,LEXAN1
043D1B FE 2C       9876  			CP      ','			; Ignore commas
043D1D 28 DD       9877  			JR      Z,LEXAN1
043D1F FE 32       9878  			CP	'2'			; If less than '2'
043D21 30 02       9879  			JR	NC, @F			; No, so skip
043D23 CB 91       9880  			RES	2,C			; FLAG: NOT IN BINARY
043D25 FE 47       9881  @@:			CP      'G'			; If less then 'G'
043D27 38 02       9882  			JR      C,LEXAN4		; Yes, so skip
043D29 CB 99       9883  			RES     3,C             	; FLAG: NOT IN HEX
043D2B             9884  ;
043D2B FE 22       9885  LEXAN4:			CP      34			; Is it a quote character?
043D2D 20 05       9886  			JR      NZ,LEXAN5		; No, so skip
043D2F CB 11       9887  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D31 3F          9888  			CCF                     	; Toggle the carry
043D32 CB 19       9889  			RR      C			; And then shifting it back into bit 7 of C
043D34             9890  ;
043D34 CB 61       9891  LEXAN5:			BIT     4,C			; Accept line number?
043D36 28 12       9892  			JR      Z,LEXAN6		; No, so skip
043D38 CB A1       9893  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D3A C5          9894  			PUSH    BC
043D3B D5          9895  			PUSH    DE
043D3C CD 5A 3C 04 9896  			CALL    LINNUM         		; Parse the line number to HL
043D40 D1          9897  			POP     DE
043D41 C1          9898  			POP     BC
043D42 7C          9899  			LD      A,H			; If it is not zero
043D43 B5          9900  			OR      L
043D44 C4 BD 3D 04 9901  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D48 18 B6       9902  			JR      LEXAN2          	; And loop
043D4A             9903  ;
043D4A 0D          9904  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D4B 28 0A       9905  			JR      Z,LEXAN7        	; If so, skip
043D4D 0C          9906  			INC     C			; Otherwise restore C
043D4E 20 AC       9907  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D50 B7          9908  			OR      A			; Set the flags based on the character
043D51 F4 28 38 04 9909  			CALL    P,LEX           	; Tokenise if A < 128
043D55 18 13       9910  			JR      LEXAN8			; And skip
043D57             9911  ;
043D57             9912  ; Processing the LEFT hand side here
043D57             9913  ;
043D57 FE 2A       9914  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D59 28 17       9915  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D5B B7          9916  			OR      A			; Set the flags based on the character
043D5C F4 28 38 04 9917  			CALL    P,LEX           	; Tokenise if A < 128
043D60             9918  ;
043D60             9919  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043D60             9920  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043D60             9921  ; Examples:
043D60             9922  ;   LET A% = PAGE : REM This is the GET version
043D60             9923  ;   PAGE = 40000  : REM This is the SET version
043D60             9924  ;
043D60 FE 8F       9925  			CP      TOKLO			; TOKLO is 8Fh
043D62 38 06       9926  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D64 FE 94       9927  			CP      TOKHI+1			; TOKHI is 93h
043D66 30 02       9928  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D68 C6 40       9929  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D6A             9930  ;
043D6A FE F4       9931  LEXAN8:			CP      REM			; If the token is REM
043D6C 28 04       9932  			JR      Z,LEXAN9		; Then stop tokenising
043D6E FE DC       9933  			CP      DATA_			; If it is not DATA then
043D70 20 02       9934  			JR      NZ,LEXANA		; Skip
043D72 CB F1       9935  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D74             9936  ;
043D74 FE A4       9937  LEXANA:			CP      FN			; If the token is FN
043D76 28 0A       9938  			JR      Z,LEXANB
043D78 FE F2       9939  			CP      PROC			; Or the token is PROC
043D7A 28 06       9940  			JR      Z,LEXANB		; Then jump to here
043D7C CD E6 3C 04 9941  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D80 38 02       9942  			JR      C,LEXANC		; Jump here if out of range
043D82             9943  ;
043D82 CB E9       9944  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D84 FE 26       9945  LEXANC:			CP      '&'			; Check for hex prefix
043D86 20 02       9946  			JR      NZ,LEXAND		; If not, skip
043D88 CB D9       9947  			SET     3,C             	; FLAG: IN HEX
043D8A             9948  ;
043D8A FE 25       9949  LEXAND:			CP	'%'			; Check for binary prefix
043D8C 20 02       9950  			JR	NZ,LEXANE		; If not, skip
043D8E CB D1       9951  			SET	2,C			; FLAG: IN BINARY
043D90             9952  ;
043D90 21 B4 3D 04 9953  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D94 C5          9954  			PUSH    BC
043D95 01 06 00 00 9955  			LD      BC,LIST1L		; The list length
043D99 ED B1       9956  			CPIR				; Check if the token is in this list
043D9B C1          9957  			POP     BC
043D9C 20 02       9958  			JR      NZ,LEXANF		; If not, then skip
043D9E CB E1       9959  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043DA0             9960  ;
043DA0 21 B8 3D 04 9961  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043DA4 C5          9962  			PUSH    BC
043DA5 01 05 00 00 9963  			LD      BC,LIST2L		; The list length
043DA9 ED B1       9964  			CPIR				; Check if the token is in this list
043DAB C1          9965  			POP     BC
043DAC 20 02       9966  			JR      NZ,LEXANG		; If not, then skip
043DAE CB C1       9967  			SET     0,C             	; FLAG: ENTER LEFT MODE
043DB0 C3 FC 3C 04 9968  LEXANG:			JP      LEXAN1			; And loop
043DB4             9969  
043DB4             9970  ;
043DB4             9971  ; LIST1: List of tokens that must be followed by line numbers
043DB4             9972  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043DB4             9973  ;
043DB4 E5          9974  LIST1:			DB	GOTO
043DB5 E4          9975  			DB	GOSUB
043DB6 F7          9976  			DB	RESTOR
043DB7 FC          9977  			DB	TRACE
043DB8 8C          9978  LIST2:			DB	THEN
043DB9 8B          9979  			DB	ELSE_
043DBA             9980  LIST1L:			EQU     $-LIST1
043DBA F5          9981  			DB	REPEAT
043DBB 85          9982  			DB	TERROR
043DBC 3A          9983  			DB    	':'
043DBD             9984  LIST2L:			EQU     $-LIST2
043DBD             9985  ;
043DBD             9986  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043DBD             9987  ;   Inputs: HL=line number, DE=string pointer
043DBD             9988  ;  Outputs: DE updated, BIT 4,C set.
043DBD             9989  ; Destroys: A,B,C,D,E,F
043DBD             9990  ;
043DBD             9991  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043DBD             9992  ;
043DBD             9993  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043DBD             9994  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043DBD             9995  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043DBD             9996  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043DBD             9997  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043DBD             9998  ;
043DBD CB E1       9999  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043DBF EB          10000  			EX      DE, HL			; HL: string pointer, DE: line number
043DC0 36 8D       10001  			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
043DC2 23          10002  			INC     HL
043DC3 7A          10003  			LD      A,D			; Get the high byte
043DC4 E6 C0       10004  			AND     0C0H			; Get the top two bits	DD000000
043DC6 0F          10005  			RRCA				; Shift right		00DD0000
043DC7 0F          10006  			RRCA
043DC8 47          10007  			LD      B,A			; Store in B
043DC9 7B          10008  			LD      A,E			; Get the low byte
043DCA E6 C0       10009  			AND     0C0H			; Get the top two bits	EE000000
043DCC B0          10010  			OR      B			; Combine with D	EEDD0000
043DCD 0F          10011  			RRCA				; Shift right		00EEDD00
043DCE 0F          10012  			RRCA
043DCF EE 54       10013  			XOR     01010100B		; XOR with 54h
043DD1 77          10014  			LD      (HL),A			; Store this as the second byte
043DD2 23          10015  			INC     HL
043DD3 7B          10016  			LD      A,E			; Get the low byte
043DD4 E6 3F       10017  			AND     3FH			; Strip the top two bits off
043DD6 F6 40       10018  			OR      '@'			; OR with 40h
043DD8 77          10019  			LD      (HL),A			; Store
043DD9 23          10020  			INC     HL
043DDA 7A          10021  			LD      A,D			; Get the high byte
043DDB E6 3F       10022  			AND     3FH			; Strip the top two bits off
043DDD F6 40       10023  			OR      '@'			; OR with 40h
043DDF 77          10024  			LD      (HL),A			; Store
043DE0 23          10025  			INC     HL
043DE1 EB          10026  			EX      DE,HL			; DE: string pointer, HL: line number
043DE2 C9          10027  			RET
043DE3             10028  ;
043DE3             10029  ; TEXT - OUTPUT MESSAGE.
043DE3             10030  ;   Inputs: HL addresses text (terminated by nul)
043DE3             10031  ;  Outputs: HL addresses character following nul.
043DE3             10032  ; Destroys: A,H,L,F
043DE3             10033  ;
043DE3 2A 2F 4D 04 10034  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DE7             10035  ;
043DE7 7E          10036  TEXT_:			LD      A, (HL)			; Fetch the character
043DE8 23          10037  			INC     HL			; Increment pointer to next character
043DE9 B7          10038  			OR      A			; Check for the nul (0) string terminator
043DEA C8          10039  			RET     Z			; And return if so
043DEB CD CD 39 04 10040  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DEF 18 F6       10041  			JR      TEXT_			; And loop
043DF1             10042  ;
043DF1             10043  ; TELL - OUTPUT MESSAGE.
043DF1             10044  ;   Inputs: Text follows subroutine call (term=nul)
043DF1             10045  ; Destroys: A,F
043DF1             10046  ;
043DF1             10047  ; Example usage:
043DF1             10048  ;
043DF1             10049  ;	CALL	TELL			Call the function
043DF1             10050  ;	DB	"Hello World", 0	Followed by a zero terminated string
043DF1             10051  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043DF1             10052  ;
043DF1 E3          10053  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DF2 CD E7 3D 04 10054  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DF6 E3          10055  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DF7 C9          10056  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043DF8             10057  
043DF8             10058  ; --- Begin misc.asm ---
043DF8             10059  ;
043DF8             10060  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043DF8             10061  ; Author:	Dean Belfield
043DF8             10062  ; Created:	12/05/2023
043DF8             10063  ; Last Updated:	12/05/2023
043DF8             10064  ;
043DF8             10065  ; Modinfo:
043DF8             10066  
043DF8             10067  			; INCLUDE	"equs.inc"
043DF8             10068  			; INCLUDE	"macros.inc"
043DF8             10069  
043DF8             10070  			; .ASSUME	ADL = 1
043DF8             10071  
043DF8             10072  			; SEGMENT CODE
043DF8             10073  
043DF8             10074  			; XDEF	ASC_TO_NUMBER
043DF8             10075  			; XDEF	SWITCH_A
043DF8             10076  			; XDEF	NULLTOCR
043DF8             10077  			; XDEF	CRTONULL
043DF8             10078  			; XDEF	CSTR_FNAME
043DF8             10079  			; XDEF	CSTR_LINE
043DF8             10080  			; XDEF	CSTR_FINDCH
043DF8             10081  			; XDEF	CSTR_ENDSWITH
043DF8             10082  			; XDEF	CSTR_CAT
043DF8             10083  
043DF8             10084  			; XREF	OSWRCH
043DF8             10085  			; XREF	KEYWDS
043DF8             10086  			; XREF	KEYWDL
043DF8             10087  
043DF8             10088  ; Read a number and convert to binary
043DF8             10089  ; If prefixed with &, will read as hex, otherwise decimal
043DF8             10090  ;   Inputs: HL: Pointer in string buffer
043DF8             10091  ;  Outputs: HL: Updated text pointer
043DF8             10092  ;           DE: Value
043DF8             10093  ;            A: Terminator (spaces skipped)
043DF8             10094  ; Destroys: A,D,E,H,L,F
043DF8             10095  ;
043DF8 C5          10096  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DF9 11 00 00 00 10097  			LD	DE, 0			; Initialise DE
043DFD CD 3F 3E 04 10098  			CALL	SKIPSPC			; Skip whitespace
043E01 7E          10099  			LD	A, (HL)			; Read first character
043E02 FE 26       10100  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043E04 20 1F       10101  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043E06 23          10102  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043E07             10103  ;
043E07 7E          10104  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043E08 CD 4D 3E 04 10105  			CALL    UPPERC			; Convert to uppercase
043E0C D6 30       10106  			SUB	'0'			; Normalise to 0
043E0E 38 2E       10107  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E10 FE 0A       10108  			CP 	10			; Check if >= 10
043E12 38 06       10109  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043E14 D6 07       10110  			SUB 	7			; Adjust ASCII A-F to nibble
043E16 FE 10       10111  			CP 	16			; Check for > F
043E18 30 24       10112  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043E1A EB          10113  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043E1B 29          10114  			ADD	HL, HL
043E1C 29          10115  			ADD	HL, HL
043E1D 29          10116  			ADD	HL, HL
043E1E 29          10117  			ADD	HL, HL
043E1F EB          10118  			EX	DE, HL
043E20 B3          10119  			OR      E			; OR the new digit in to the least significant nibble
043E21 5F          10120  			LD      E, A
043E22 23          10121  			INC     HL			; Onto the next character
043E23 18 E2       10122  			JR      ASC_TO_NUMBER1		; And loop
043E25             10123  ;
043E25 7E          10124  ASC_TO_NUMBER3:		LD	A, (HL)
043E26 D6 30       10125  			SUB	'0'			; Normalise to 0
043E28 38 14       10126  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E2A FE 0A       10127  			CP	10			; Check if >= 10
043E2C 30 10       10128  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043E2E EB          10129  			EX 	DE, HL 			; Stick DE in HL
043E2F 44          10130  			LD	B, H 			; And copy HL into BC
043E30 4D          10131  			LD	C, L
043E31 29          10132  			ADD	HL, HL 			; x 2
043E32 29          10133  			ADD	HL, HL 			; x 4
043E33 09          10134  			ADD	HL, BC 			; x 5
043E34 29          10135  			ADD	HL, HL 			; x 10
043E35 EB          10136  			EX	DE, HL
043E36             10137  			ADD8U_DE 			; Add A to DE (macro)
043E36 83          0001M 		ADD	A, E
043E37 5F          0002M 		LD	E, A
043E38 8A          0003M 		ADC	A, D
043E39 93          0004M 		SUB	E
043E3A 57          0005M 		LD	D, A
043E3B 23          10138  			INC	HL
043E3C 18 E7       10139  			JR	ASC_TO_NUMBER3
043E3E C1          10140  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043E3F             10141  
043E3F             10142  ; Skip a space
043E3F             10143  ; HL: Pointer in string buffer
043E3F             10144  ;
043E3F 7E          10145  SKIPSPC:			LD      A, (HL)
043E40 FE 20       10146  			CP      ' '
043E42 C0          10147  			RET     NZ
043E43 23          10148  			INC     HL
043E44 18 F9       10149  			JR      SKIPSPC
043E46             10150  
043E46             10151  ; Skip a string
043E46             10152  ; HL: Pointer in string buffer
043E46             10153  ;
043E46 7E          10154  SKIPNOTSP:		LD	A, (HL)
043E47 FE 20       10155  			CP	' '
043E49 C8          10156  			RET	Z
043E4A 23          10157  			INC	HL
043E4B 18 F9       10158  			JR	SKIPNOTSP
043E4D             10159  
043E4D             10160  ; Convert a character to upper case
043E4D             10161  ;  A: Character to convert
043E4D             10162  ;
043E4D E6 7F       10163  UPPERC:  		AND     7FH
043E4F FE 60       10164  			CP      '`'
043E51 D8          10165  			RET     C
043E52 E6 5F       10166  			AND     5FH			; Convert to upper case
043E54 C9          10167  			RET
043E55             10168  
043E55             10169  ; Switch on A - lookup table immediately after call
043E55             10170  ;  A: Index into lookup table
043E55             10171  ;
043E55 E3          10172  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E56 87          10173  			ADD	A, A			; Multiply A by two
043E57             10174  			ADD8U_HL 			; Add to HL (macro)
043E57 85          0001M 		ADD	A, L
043E58 6F          0002M 		LD	L, A
043E59 8C          0003M 		ADC	A, H
043E5A 95          0004M 		SUB	L
043E5B 67          0005M 		LD	H, A
043E5C 7E          10175  			LD	A, (HL)			; follow the call. Fetch an address from the
043E5D 23          10176  			INC	HL 			; table.
043E5E 66          10177  			LD	H, (HL)
043E5F 6F          10178  			LD	L, A
043E60 E3          10179  			EX	(SP), HL		; Swap this new address back, restores HL
043E61 C9          10180  			RET				; Return program control to this new address
043E62             10181  
043E62             10182  ; Convert the buffer to a null terminated string and back
043E62             10183  ; HL: Buffer address
043E62             10184  ;
043E62 C5          10185  NULLTOCR:		PUSH 	BC
043E63 06 00       10186  			LD	B, 0
043E65 0E 0D       10187  			LD	C, CR
043E67 18 05       10188  			JR	CRTONULL0
043E69             10189  ;
043E69 C5          10190  CRTONULL:		PUSH	BC
043E6A 06 0D       10191  			LD	B, CR
043E6C 0E 00       10192  			LD	C, 0
043E6E             10193  ;
043E6E E5          10194  CRTONULL0:		PUSH	HL
043E6F 7E          10195  CRTONULL1:		LD	A, (HL)
043E70 B8          10196  			CP 	B
043E71 28 03       10197  			JR	Z, CRTONULL2
043E73 23          10198  			INC	HL
043E74 18 F9       10199  			JR	CRTONULL1
043E76 71          10200  CRTONULL2:		LD	(HL), C
043E77 E1          10201  			POP 	HL
043E78 C1          10202  			POP	BC
043E79 C9          10203  			RET
043E7A             10204  
043E7A             10205  ; Copy a filename to DE and zero terminate it
043E7A             10206  ; HL: Source
043E7A             10207  ; DE: Destination (ACCS)
043E7A             10208  ;
043E7A 7E          10209  CSTR_FNAME:		LD	A, (HL)			; Get source
043E7B FE 20       10210  			CP	32			; Is it space
043E7D 28 09       10211  			JR	Z, @F
043E7F FE 0D       10212  			CP	CR			; Or is it CR
043E81 28 05       10213  			JR	Z, @F
043E83 12          10214  			LD	(DE), A			; No, so store
043E84 23          10215  			INC	HL			; Increment
043E85 13          10216  			INC	DE
043E86 18 F2       10217  			JR	CSTR_FNAME		; And loop
043E88 AF          10218  @@:			XOR	A			; Zero terminate the target string
043E89 12          10219  			LD	(DE), A
043E8A 13          10220  			INC	DE			; And point to next free address
043E8B C9          10221  			RET
043E8C             10222  
043E8C             10223  ; Copy a CR terminated line to DE and zero terminate it
043E8C             10224  ; HL: Source
043E8C             10225  ; DE: Destination (ACCS)
043E8C             10226  ;
043E8C 7E          10227  CSTR_LINE:		LD	A, (HL)			; Get source
043E8D FE 0D       10228  			CP	CR			; Is it CR
043E8F 28 05       10229  			JR	Z, @F
043E91 12          10230  			LD	(DE), A			; No, so store
043E92 23          10231  			INC	HL			; Increment
043E93 13          10232  			INC	DE
043E94 18 F6       10233  			JR	CSTR_LINE		; And loop
043E96 AF          10234  @@:			XOR	A			; Zero terminate the target string
043E97 12          10235  			LD	(DE), A
043E98 13          10236  			INC	DE			; And point to next free address
043E99 C9          10237  			RET
043E9A             10238  
043E9A             10239  ; Find the first occurrence of a character (case sensitive)
043E9A             10240  ; HL: Source
043E9A             10241  ;  C: Character to find
043E9A             10242  ; Returns:
043E9A             10243  ; HL: Pointer to character, or end of string marker
043E9A             10244  ;
043E9A 7E          10245  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E9B B9          10246  			CP	C			; Is it our character?
043E9C C8          10247  			RET	Z			; Yes, so exit
043E9D B7          10248  			OR	A			; Is it the end of string?
043E9E C8          10249  			RET	Z			; Yes, so exit
043E9F 23          10250  			INC	HL
043EA0 18 F8       10251  			JR	CSTR_FINDCH
043EA2             10252  
043EA2             10253  ; Check whether a string ends with another string (case insensitive)
043EA2             10254  ; HL: Source
043EA2             10255  ; DE: The substring we want to test with
043EA2             10256  ; Returns:
043EA2             10257  ;  F: Z if HL ends with DE, otherwise NZ
043EA2             10258  ;
043EA2 7E          10259  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043EA3 CD 4D 3E 04 10260  			CALL	UPPERC			; Convert to upper case
043EA7 4F          10261  			LD	C, A
043EA8 1A          10262  			LD	A, (DE)			; Get the substring byte
043EA9 B9          10263  			CP	C
043EAA C0          10264  			RET	NZ			; Return NZ if at any point the strings don't match
043EAB B1          10265  			OR	C			; Check whether both bytes are zero
043EAC C8          10266  			RET	Z			; If so, return, as we have reached the end of both strings
043EAD 23          10267  			INC	HL
043EAE 13          10268  			INC	DE
043EAF 18 F1       10269  			JR	CSTR_ENDSWITH		; And loop
043EB1             10270  
043EB1             10271  ; Concatenate a string onto the end of another string
043EB1             10272  ; HL: Source
043EB1             10273  ; DE: Second string
043EB1             10274  ;
043EB1 7E          10275  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043EB2 B7          10276  			OR	A
043EB3 28 03       10277  			JR	Z, CSTR_CAT_1
043EB5 23          10278  			INC	HL
043EB6 18 F9       10279  			JR	CSTR_CAT
043EB8             10280  ;
043EB8 1A          10281  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043EB9 77          10282  			LD	(HL), A
043EBA B7          10283  			OR	A			; Check for end of string
043EBB C8          10284  			RET	Z			; And return
043EBC 23          10285  			INC	HL
043EBD 13          10286  			INC	DE
043EBE 18 F8       10287  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043EC0             10288  
043EC0             10289  ; --- Begin patch.asm ---
043EC0             10290  ;
043EC0             10291  ; Title:	BBC Basic for AGON
043EC0             10292  ; Author:	Dean Belfield
043EC0             10293  ; Created:	12/05/2023
043EC0             10294  ; Last Updated:	15/11/2023
043EC0             10295  ;
043EC0             10296  ; Modinfo:
043EC0             10297  ; 11/07/2023:	Fixed *BYE for ADL mode
043EC0             10298  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043EC0             10299  
043EC0             10300  			; .ASSUME	ADL = 1
043EC0             10301  
043EC0             10302  			; INCLUDE	"equs.inc"
043EC0             10303  			; INCLUDE "macros.inc"
043EC0             10304  			; INCLUDE "mos_api.inc"	; In MOS/src
043EC0             10305  
043EC0             10306  			; SEGMENT CODE
043EC0             10307  
043EC0             10308  			; XDEF	OSWRCH
043EC0             10309  			; XDEF	OSLINE
043EC0             10310  			; XDEF	ESCSET
043EC0             10311  			; XDEF	PUTIME
043EC0             10312  			; XDEF	GETIME
043EC0             10313  			; XDEF	PUTCSR
043EC0             10314  			; XDEF 	GETCSR
043EC0             10315  			; XDEF	OSRDCH
043EC0             10316  			; XDEF	PROMPT
043EC0             10317  			; XDEF	OSKEY
043EC0             10318  			; XDEF	TRAP
043EC0             10319  			; XDEF	LTRAP
043EC0             10320  			; XDEF	OSINIT
043EC0             10321  			; XDEF	OSCLI
043EC0             10322  			; XDEF	OSBPUT
043EC0             10323  			; XDEF	OSBGET
043EC0             10324  			; XDEF	OSSTAT
043EC0             10325  			; XDEF	OSSHUT
043EC0             10326  			; XDEF	OSOPEN
043EC0             10327  			; XDEF	OSCALL
043EC0             10328  			; XDEF	GETPTR
043EC0             10329  			; XDEF	PUTPTR
043EC0             10330  			; XDEF	GETEXT
043EC0             10331  			; XDEF	GETIMS
043EC0             10332  			; XDEF	RESET
043EC0             10333  			; XDEF	OSLOAD
043EC0             10334  			; XDEF	OSSAVE
043EC0             10335  			; XDEF	EXPR_W2
043EC0             10336  			; XDEF	STAR_VERSION
043EC0             10337  
043EC0             10338  			; XREF	_end			; In init.asm
043EC0             10339  
043EC0             10340  			; XREF	ASC_TO_NUMBER
043EC0             10341  			; XREF	RAM_START
043EC0             10342  			; XREF	RAM_END
043EC0             10343  			; XREF	FLAGS
043EC0             10344  			; XREF	ESCAPE
043EC0             10345  			; XREF	USER
043EC0             10346  			; XREF	RAM_Top
043EC0             10347  			; XREF	EXTERR
043EC0             10348  			; XREF	COUNT0
043EC0             10349  			; XREF	EXPRI
043EC0             10350  			; XREF	COMMA
043EC0             10351  			; XREF	XEQ
043EC0             10352  			; XREF	NXT
043EC0             10353  			; XREF	NULLTOCR
043EC0             10354  			; XREF	CRLF
043EC0             10355  			; XREF	CSTR_FNAME
043EC0             10356  			; XREF	CSTR_LINE
043EC0             10357  			; XREF	CSTR_FINDCH
043EC0             10358  			; XREF	CSTR_ENDSWITH
043EC0             10359  			; XREF	CSTR_CAT
043EC0             10360  			; XREF	FINDL
043EC0             10361  			; XREF	OUT_
043EC0             10362  			; XREF	ERROR_
043EC0             10363  			; XREF	ONEDIT
043EC0             10364  			; XREF	TELL
043EC0             10365  			; XREF	OSWRCHPT
043EC0             10366  			; XREF	OSWRCHCH
043EC0             10367  			; XREF	OSWRCHFH
043EC0             10368  			; XREF	LISTON
043EC0             10369  			; XREF	LISTIT
043EC0             10370  			; XREF	PAGE_
043EC0             10371  			; XREF	ONEDIT1
043EC0             10372  			; XREF	CLEAN
043EC0             10373  			; XREF	NEWIT
043EC0             10374  			; XREF	BAD
043EC0             10375  			; XREF	VBLANK_INIT
043EC0             10376  			; XREF	VBLANK_STOP
043EC0             10377  			; XREF	KEYDOWN
043EC0             10378  			; XREF	KEYASCII
043EC0             10379  			; XREF	WIDTH
043EC0             10380  			; XREF	ASSEM
043EC0             10381  
043EC0             10382  ; OSLINE: Invoke the line editor
043EC0             10383  ;
043EC0 1E 01       10384  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043EC2             10385  
043EC2             10386  ; Entry point to line editor that does not clear the buffer
043EC2             10387  ;
043EC2 FD E5       10388  OSLINE1:		PUSH	IY
043EC4 E5          10389  			PUSH	HL			; Buffer address
043EC5 01 00 01 00 10390  			LD	BC, 256			; Buffer length
043EC9             10391  			MOSCALL	mos_editline		; Call the MOS line editor
043EC9 3E 09       0001M 			LD	A, function
043ECB 49 CF       0002M 			RST.LIS	08h
043ECD E1          10392  			POP	HL			; Pop the address
043ECE FD E1       10393  			POP	IY
043ED0 F5          10394  			PUSH	AF			; Stack the return value (key pressed)
043ED1 CD 62 3E 04 10395  			CALL	NULLTOCR		; Turn the 0 character to a CR
043ED5 CD A8 39 04 10396  			CALL	CRLF			; Display CRLF
043ED9 F1          10397  			POP	AF
043EDA FE 1B       10398  			CP	1Bh 			; Check if ESC terminated the input
043EDC CA D8 3F 04 10399  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043EE0 3A 42 4D 04 10400  			LD	A, (FLAGS)		; Otherwise
043EE4 CB BF       10401  			RES	7, A 			; Clear the escape flag
043EE6 32 42 4D 04 10402  			LD	(FLAGS), A
043EEA CD AF 41 04 10403  			CALL	WAIT_VBLANK 		; Wait a frame
043EEE AF          10404   			XOR	A			; Return A = 0
043EEF 32 47 4D 04 10405  			LD	(KEYDOWN), A
043EF3 32 48 4D 04 10406  			LD	(KEYASCII), A
043EF7 C9          10407  			RET
043EF8             10408  
043EF8             10409  ; PUTIME: set current time to DE:HL, in centiseconds.
043EF8             10410  ;
043EF8 DD E5       10411  PUTIME:			PUSH 	IX
043EFA             10412  			MOSCALL	mos_sysvars
043EFA 3E 08       0001M 			LD	A, function
043EFC 49 CF       0002M 			RST.LIS	08h
043EFE DD 75 00    10413  			LD	(IX + sysvar_time + 0), L
043F01 DD 74 01    10414  			LD	(IX + sysvar_time + 1), H
043F04 DD 73 02    10415  			LD	(IX + sysvar_time + 2), E
043F07 DD 72 03    10416  			LD	(IX + sysvar_time + 3), D
043F0A DD E1       10417  			POP	IX
043F0C C9          10418  			RET
043F0D             10419  
043F0D             10420  ; GETIME: return current time in DE:HL, in centiseconds
043F0D             10421  ;
043F0D DD E5       10422  GETIME:			PUSH 	IX
043F0F             10423  			MOSCALL	mos_sysvars
043F0F 3E 08       0001M 			LD	A, function
043F11 49 CF       0002M 			RST.LIS	08h
043F13 DD 6E 00    10424  			LD	L, (IX + sysvar_time + 0)
043F16 DD 66 01    10425  			LD	H, (IX + sysvar_time + 1)
043F19 DD 5E 02    10426  			LD	E, (IX + sysvar_time + 2)
043F1C DD 56 03    10427  			LD	D, (IX + sysvar_time + 3)
043F1F DD E1       10428  			POP	IX
043F21 C9          10429  			RET
043F22             10430  
043F22             10431  ; PUTCSR: move to cursor to x=DE, y=HL
043F22             10432  ;
043F22 3E 1F       10433  PUTCSR:			LD	A, 1Fh			; TAB
043F24 5B D7       10434  			RST.LIL	10h
043F26 7B          10435  			LD	A, E			; X
043F27 5B D7       10436  			RST.LIL 10h
043F29 7D          10437  			LD	A, L			; Y
043F2A 5B D7       10438  			RST.LIL 10h
043F2C C9          10439  			RET
043F2D             10440  
043F2D             10441  ; GETCSR: return cursor position in x=DE, y=HL
043F2D             10442  ;
043F2D DD E5       10443  GETCSR:			PUSH	IX			; Get the system vars in IX
043F2F             10444  			MOSCALL	mos_sysvars		; Reset the semaphore
043F2F 3E 08       0001M 			LD	A, function
043F31 49 CF       0002M 			RST.LIS	08h
043F33 DD CB 04 86 10445  			RES	0, (IX+sysvar_vpd_pflags)
043F37             10446  			VDU	23
043F37 3E 17       0001M 		LD	A, val
043F39 CD 61 3F 04 0002M 		CALL	OSWRCH
043F3D             10447  			VDU	0
043F3D 3E 00       0001M 		LD	A, val
043F3F CD 61 3F 04 0002M 		CALL	OSWRCH
043F43             10448  			VDU	vdp_cursor
043F43 3E 82       0001M 		LD	A, val
043F45 CD 61 3F 04 0002M 		CALL	OSWRCH
043F49 DD CB 04 46 10449  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F4D 28 FA       10450  			JR	Z, @B			; Wait for the result
043F4F 16 00       10451  			LD 	D, 0
043F51 62          10452  			LD	H, D
043F52 DD 5E 07    10453  			LD	E, (IX + sysvar_cursorX)
043F55 DD 6E 08    10454  			LD	L, (IX + sysvar_cursorY)
043F58 DD E1       10455  			POP	IX
043F5A C9          10456  			RET
043F5B             10457  
043F5B             10458  ; PROMPT: output the input prompt
043F5B             10459  ;
043F5B 3E 3E       10460  PROMPT: 		LD	A,'>'
043F5D C3 61 3F 04 10461  			JP	OSWRCH
043F61             10462  
043F61             10463  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F61             10464  ; A: Character to write
043F61             10465  ;
043F61 E5          10466  OSWRCH:			PUSH	HL
043F62 21 40 4D 04 10467  			LD	HL, LISTON		; Fetch the LISTON variable
043F66 CB 5E       10468  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F68 20 0B       10469  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F6A             10470  ;
043F6A 2A 45 4D 04 10471  			LD	HL, (OSWRCHCH)		; L: Channel #
043F6E 2D          10472  			DEC	L			; If it is 1
043F6F 28 10       10473  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F71             10474  ;
043F71 E1          10475  			POP	HL			; Otherwise
043F72 5B D7       10476  			RST.LIL	10h			; Output the character to MOS
043F74 C9          10477  			RET
043F75             10478  ;
043F75 2A 43 4D 04 10479  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F79 77          10480  			LD	(HL), A			; Echo the character into the buffer
043F7A 23          10481  			INC	HL			; Increment pointer
043F7B 22 43 4D 04 10482  			LD	(OSWRCHPT), HL		; Write pointer back
043F7F E1          10483  			POP	HL
043F80 C9          10484  			RET
043F81             10485  ;
043F81 D5          10486  OSWRCH_FILE:		PUSH	DE
043F82 5C          10487  			LD	E, H			; Filehandle to E
043F83 CD AD 43 04 10488  			CALL	OSBPUT			; Write the byte out
043F87 D1          10489  			POP	DE
043F88 E1          10490  			POP	HL
043F89 C9          10491  			RET
043F8A             10492  
043F8A             10493  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F8A             10494  ; This is only called in GETS (eval.asm)
043F8A             10495  ;
043F8A             10496  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F8A 3E 00       0001M 			LD	A, function
043F8C 49 CF       0002M 			RST.LIS	08h
043F8E FE 1B       10497  			CP	1Bh
043F90 28 46       10498  			JR	Z, LTRAP1
043F92 C9          10499  			RET
043F93             10500  
043F93             10501  
043F93             10502  ;OSKEY - Read key with time-limit, test for ESCape.
043F93             10503  ;Main function is carried out in user patch.
043F93             10504  ;   Inputs: HL = time limit (centiseconds)
043F93             10505  ;  Outputs: Carry reset if time-out
043F93             10506  ;           If carry set A = character
043F93             10507  ; Destroys: A,H,L,F
043F93             10508  ;
043F93 CD C4 3F 04 10509  OSKEY:			CALL	READKEY			; Read the keyboard
043F97 28 0A       10510  			JR	Z, @F 			; Skip if we have a key
043F99 7C          10511  			LD	A, H 			; Check loop counter
043F9A B5          10512  			OR 	L
043F9B C8          10513  			RET 	Z 			; Return, we've not got a key at this point
043F9C CD AF 41 04 10514  			CALL	WAIT_VBLANK 		; Wait a frame
043FA0 2B          10515  			DEC 	HL			; Decrement
043FA1 18 F0       10516  			JR	OSKEY 			; And loop
043FA3             10517  ;
043FA3 21 47 4D 04 10518  @@:			LD	HL, KEYDOWN		; We have a key, so
043FA7 36 00       10519  			LD	(HL), 0			; clear the keydown flag
043FA9 FE 1B       10520  			CP	1BH			; If we are not pressing ESC,
043FAB 37          10521  			SCF 				; then flag we've got a character
043FAC C0          10522  			RET	NZ
043FAD             10523  ;
043FAD             10524  ; ESCSET
043FAD             10525  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043FAD             10526  ;
043FAD E5          10527  ESCSET: 		PUSH    HL
043FAE 21 42 4D 04 10528          		LD      HL,FLAGS		; Pointer to FLAGS
043FB2 CB 76       10529          		BIT     6,(HL)			; If bit 6 is set, then
043FB4 20 02       10530          		JR      NZ,ESCDIS		; escape is disabled, so skip
043FB6 CB FE       10531          		SET     7,(HL)			; Set bit 7, the escape flag
043FB8 E1          10532  ESCDIS: 		POP     HL
043FB9 C9          10533          		RET
043FBA             10534  ;
043FBA             10535  ; ESCTEST
043FBA             10536  ; Test for ESC key
043FBA             10537  ;
043FBA CD C4 3F 04 10538  ESCTEST:		CALL	READKEY			; Read the keyboard
043FBE C0          10539  			RET	NZ			; Skip if no key is pressed
043FBF FE 1B       10540  			CP	1BH			; If ESC pressed then
043FC1 28 EA       10541  			JR	Z,ESCSET		; jump to the escape set routine
043FC3 C9          10542  			RET
043FC4             10543  
043FC4             10544  ; Read the keyboard
043FC4             10545  ; Returns:
043FC4             10546  ; - A: ASCII of the pressed key
043FC4             10547  ; - F: Z if the key is pressed, otherwise NZ
043FC4             10548  ;
043FC4 3A 47 4D 04 10549  READKEY:		LD	A, (KEYDOWN)		; Get key down
043FC8 3D          10550  			DEC	A 			; Set Z flag if keydown is 1
043FC9 3A 48 4D 04 10551  			LD	A, (KEYASCII)		; Get key ASCII value
043FCD C9          10552  			RET
043FCE             10553  ;
043FCE             10554  ; TRAP
043FCE             10555  ; This is called whenever BASIC needs to check for ESC
043FCE             10556  ;
043FCE CD BA 3F 04 10557  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FD2             10558  ;
043FD2 3A 42 4D 04 10559  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FD6 B7          10560  			OR	A			; This checks for bit 7; if it is not set then the result will
043FD7 F0          10561  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FD8 21 42 4D 04 10562  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FDC CB BE       10563  			RES	7,(HL)			; Clear the escape pressed flag and
043FDE C3 AE 0C 04 10564  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FE2             10565  
043FE2             10566  ;OSINIT - Initialise RAM mapping etc.
043FE2             10567  ;If BASIC is entered by BBCBASIC FILENAME then file
043FE2             10568  ;FILENAME.BBC is automatically CHAINed.
043FE2             10569  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043FE2             10570  ;            HL = initial value of PAGE (user program)
043FE2             10571  ;            Z-flag reset indicates AUTO-RUN.
043FE2             10572  ;  Destroys: A,D,E,H,L,F
043FE2             10573  ;
043FE2 CD 47 49 04 10574  OSINIT:			CALL	VBLANK_INIT
043FE6 AF          10575  			XOR	A
043FE7 21 00 4E 04 10576  			LD 	HL, USER
043FEB 11 00 00 0B 10577  			LD	DE, RAM_Top
043FEF 5F          10578  			LD	E, A			; Page boundary
043FF0 C9          10579  			RET
043FF1             10580  
043FF1             10581  ;
043FF1             10582  ;OSCLI - Process a MOS command
043FF1             10583  ;
043FF1 CD 65 40 04 10584  OSCLI: 			CALL    SKIPSP
043FF5 FE 0D       10585  			CP      CR
043FF7 C8          10586  			RET     Z
043FF8 FE 7C       10587  			CP      '|'
043FFA C8          10588  			RET     Z
043FFB EB          10589  			EX      DE,HL
043FFC 21 74 40 04 10590  			LD      HL,COMDS
044000 1A          10591  OSCLI0:			LD      A,(DE)
044001 CD 6C 40 04 10592  			CALL    UPPRC
044005 BE          10593  			CP      (HL)
044006 28 0B       10594  			JR      Z,OSCLI2
044008 38 30       10595  			JR      C,OSCLI6
04400A CB 7E       10596  OSCLI1:			BIT     7,(HL)
04400C 23          10597  			INC     HL
04400D 28 FB       10598  			JR      Z,OSCLI1
04400F 23          10599  			INC     HL
044010 23          10600  			INC     HL
044011 18 ED       10601  			JR      OSCLI0
044013             10602  ;
044013 D5          10603  OSCLI2:			PUSH    DE
044014 13          10604  OSCLI3:			INC     DE
044015 23          10605  			INC     HL
044016 1A          10606  			LD      A,(DE)
044017 CD 6C 40 04 10607  			CALL    UPPRC
04401B FE 2E       10608  			CP      '.'			; ABBREVIATED?
04401D 28 0A       10609  			JR      Z,OSCLI4
04401F AE          10610  			XOR     (HL)
044020 28 F2       10611  			JR      Z,OSCLI3
044022 FE 80       10612  			CP      80H
044024 28 03       10613  			JR      Z,OSCLI4
044026 D1          10614  			POP     DE
044027 18 E1       10615  			JR      OSCLI1
044029             10616  ;
044029 F1          10617  OSCLI4:			POP     AF
04402A 13          10618  		        INC     DE
04402B CB 7E       10619  OSCLI5:			BIT     7,(HL)
04402D 23          10620  			INC     HL
04402E 28 FB       10621  			JR      Z,OSCLI5
044030 7E          10622  			LD      A,(HL)
044031 23          10623  			INC     HL
044032 66          10624  			LD      H,(HL)
044033 6F          10625  			LD      L,A
044034 E5          10626  			PUSH    HL
044035 EB          10627  			EX      DE,HL
044036 C3 65 40 04 10628  			JP      SKIPSP
04403A             10629  ;
04403A EB          10630  OSCLI6:			EX	DE, HL			; HL: Buffer for command
04403B 11 00 4A 04 10631  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
04403F D5          10632  			PUSH	DE			; Store buffer address
044040 CD 8C 3E 04 10633  			CALL	CSTR_LINE		; Fetch the line
044044 E1          10634  			POP	HL			; HL: Pointer to command string in ACCS
044045 FD E5       10635  			PUSH	IY
044047             10636  			MOSCALL	mos_oscli		; Returns OSCLI error in A
044047 3E 10       0001M 			LD	A, function
044049 49 CF       0002M 			RST.LIS	08h
04404B FD E1       10637  			POP	IY
04404D B7          10638  			OR	A			; 0 means MOS returned OK
04404E C8          10639  			RET	Z			; So don't do anything
04404F C3 89 42 04 10640  			JP 	OSERROR			; Otherwise it's a MOS error
044053             10641  
044053 3E FE       10642  HUH:    		LD      A,254			; Bad command error
044055 CD D8 37 04 10643          		CALL    EXTERR
044059 42 61 64 20 10644          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044064 00          10645          		DEFB    0
044065             10646  
044065 7E          10647  SKIPSP:			LD      A,(HL)
044066 FE 20       10648          		CP      ' '
044068 C0          10649          		RET     NZ
044069 23          10650          		INC     HL
04406A 18 F9       10651          		JR      SKIPSP
04406C             10652  
04406C E6 7F       10653  UPPRC:  		AND     7FH
04406E FE 60       10654  			CP      '`'
044070 D8          10655  			RET     C
044071 E6 5F       10656  			AND     5FH			; CONVERT TO UPPER CASE
044073 C9          10657  			RET
044074             10658  
044074             10659  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044074             10660  ; These must be in alphabetical order
044074             10661  ;
044074 41 53 4D    10662  COMDS:  		DB	"AS","M"+80h		; ASM
044077 92 40       10663  			DW	STAR_ASM
044079 42 59 45    10664  			DB	"BY","E"+80h		; BYE
04407C 9E 40       10665  			DW	STAR_BYE
04407E 45 44 49 54 10666  			DB	"EDI","T"+80h		; EDIT
044082 D3 40       10667  			DW	STAR_EDIT
044084 46 58       10668  			DB	"F","X"+80h		; FX
044086 13 41       10669  			DW	STAR_FX
044088 56 45 52 53 10670  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
04408F AA 40       10671  			DW	STAR_VERSION
044091 FF          10672  			DB	FFh
044092             10673  
044092             10674  ; *ASM string
044092             10675  ;
044092 FD E5       10676  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044094 E5          10677  			PUSH	HL			; HL = IY
044095 FD E1       10678  			POP	IY
044097 CD D8 18 04 10679  			CALL	ASSEM			; Invoke the assembler
04409B FD E1       10680  			POP	IY
04409D C9          10681  			RET
04409E             10682  
04409E             10683  ; *BYE
04409E             10684  ;
04409E CD 5B 49 04 10685  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0440A2 21 00 00 00 10686  			LD	HL, 0			; The return value
0440A6 C3 68 00 04 10687  			JP	_end 			; Jump back to the end routine in init.asm
0440AA             10688  
0440AA             10689  ; *VERSION
0440AA             10690  ;
0440AA CD F1 3D 04 10691  STAR_VERSION:		CALL    TELL			; Output the welcome message
0440AE 42 42 43 20 10692  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0440D2 C9          10693  			RET
0440D3             10694  
0440D3             10695  ; *EDIT linenum
0440D3             10696  ;
0440D3 CD F8 3D 04 10697  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440D7 EB          10698  			EX	DE, HL			; HL: Line number
0440D8 CD F0 39 04 10699  			CALL	FINDL			; HL: Address in RAM of tokenised line
0440DC 3E 29       10700  			LD	A, 41			; F:NZ If the line is not found
0440DE C2 C1 37 04 10701  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0440E2             10702  ;
0440E2             10703  ; Use LISTIT to output the line to the ACCS buffer
0440E2             10704  ;
0440E2 23          10705  			INC	HL			; Skip the length byte
0440E3 5E          10706  			LD	E, (HL)			; Fetch the line number
0440E4 23          10707  			INC	HL
0440E5 56          10708  			LD	D, (HL)
0440E6 23          10709  			INC	HL
0440E7 DD 21 00 4A 10710  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0440EC DD 22 43 4D 10711  			LD	(OSWRCHPT), IX
       04          
0440F1 DD 21 40 4D 10712  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0440F6 DD 7E 00    10713  			LD	A, (IX)			; Store that variable
0440F9 F5          10714  			PUSH	AF
0440FA DD 36 00 09 10715  			LD	(IX), 09h		; Set to echo to buffer
0440FE CD F3 38 04 10716  			CALL	LISTIT
044102 F1          10717  			POP	AF
044103 DD 77 00    10718  			LD	(IX), A			; Restore the original LISTON variable
044106 21 00 4A 04 10719  			LD	HL, ACCS		; HL: ACCS
04410A 5D          10720  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
04410B CD C2 3E 04 10721  			CALL	OSLINE1			; Invoke the editor
04410F C3 31 31 04 10722  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
044113             10723  
044113             10724  ; OSCLI FX n
044113             10725  ;
044113 CD F8 3D 04 10726  STAR_FX:		CALL	ASC_TO_NUMBER
044117 4B          10727  			LD	C, E			; C: Save FX #
044118 CD F8 3D 04 10728  			CALL	ASC_TO_NUMBER
04411C 7A          10729  			LD	A, D  			; Is first parameter > 255?
04411D B7          10730  			OR 	A
04411E 28 03       10731  			JR	Z, STAR_FX1		; Yes, so skip next bit
044120 EB          10732  			EX	DE, HL 			; Parameter is 16-bit
044121 18 07       10733  			JR	STAR_FX2
044123             10734  ;
044123 43          10735  STAR_FX1:		LD	B, E 			; B: Save First parameter
044124 CD F8 3D 04 10736  			CALL	ASC_TO_NUMBER		; Fetch second parameter
044128 68          10737  			LD	L, B 			; L: First parameter
044129 63          10738  			LD	H, E 			; H: Second parameter
04412A             10739  ;
04412A 79          10740  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
04412B             10741  ;
04412B             10742  ; OSBYTE
04412B             10743  ;  A: FX #
04412B             10744  ;  L: First parameter
04412B             10745  ;  H: Second parameter
04412B             10746  ;
04412B FE 0B       10747  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
04412D 28 18       10748  			JR	Z, OSBYTE_0B
04412F FE 0C       10749  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044131 28 43       10750  			JR	Z, OSBYTE_0C
044133 FE 13       10751  			CP	13H			; *FX 19: Wait for vblank
044135 28 6E       10752  			JR	Z, OSBYTE_13
044137 FE 76       10753  			CP	76H			; *FX 118, n: Set keyboard LED
044139 CA C0 41 04 10754  			JP	Z, OSBYTE_76
04413D FE A0       10755  			CP	A0H
04413F CA F0 41 04 10756  			JP	Z, OSBYTE_A0
044143 C3 53 40 04 10757  			JP	HUH			; Anything else trips an error
044147             10758  
044147             10759  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
044147             10760  ; Parameters:
044147             10761  ; - HL: Repeat delay
044147             10762  ;
044147             10763  OSBYTE_0B:		VDU	23
044147 3E 17       0001M 		LD	A, val
044149 CD 61 3F 04 0002M 		CALL	OSWRCH
04414D             10764  			VDU	0
04414D 3E 00       0001M 		LD	A, val
04414F CD 61 3F 04 0002M 		CALL	OSWRCH
044153             10765  			VDU	vdp_keystate
044153 3E 88       0001M 		LD	A, val
044155 CD 61 3F 04 0002M 		CALL	OSWRCH
044159             10766  			VDU	L
044159 7D          0001M 		LD	A, val
04415A CD 61 3F 04 0002M 		CALL	OSWRCH
04415E             10767  			VDU	H
04415E 7C          0001M 		LD	A, val
04415F CD 61 3F 04 0002M 		CALL	OSWRCH
044163             10768  			VDU	0
044163 3E 00       0001M 		LD	A, val
044165 CD 61 3F 04 0002M 		CALL	OSWRCH
044169             10769  			VDU 	0
044169 3E 00       0001M 		LD	A, val
04416B CD 61 3F 04 0002M 		CALL	OSWRCH
04416F             10770  			VDU	255
04416F 3E FF       0001M 		LD	A, val
044171 CD 61 3F 04 0002M 		CALL	OSWRCH
044175 C9          10771  			RET
044176             10772  
044176             10773  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
044176             10774  ; Parameters:
044176             10775  ; - HL: Repeat rate
044176             10776  ;
044176             10777  OSBYTE_0C:		VDU	23
044176 3E 17       0001M 		LD	A, val
044178 CD 61 3F 04 0002M 		CALL	OSWRCH
04417C             10778  			VDU	0
04417C 3E 00       0001M 		LD	A, val
04417E CD 61 3F 04 0002M 		CALL	OSWRCH
044182             10779  			VDU	vdp_keystate
044182 3E 88       0001M 		LD	A, val
044184 CD 61 3F 04 0002M 		CALL	OSWRCH
044188             10780  			VDU	0
044188 3E 00       0001M 		LD	A, val
04418A CD 61 3F 04 0002M 		CALL	OSWRCH
04418E             10781  			VDU 	0
04418E 3E 00       0001M 		LD	A, val
044190 CD 61 3F 04 0002M 		CALL	OSWRCH
044194             10782  			VDU	L
044194 7D          0001M 		LD	A, val
044195 CD 61 3F 04 0002M 		CALL	OSWRCH
044199             10783  			VDU	H
044199 7C          0001M 		LD	A, val
04419A CD 61 3F 04 0002M 		CALL	OSWRCH
04419E             10784  			VDU	255
04419E 3E FF       0001M 		LD	A, val
0441A0 CD 61 3F 04 0002M 		CALL	OSWRCH
0441A4 C9          10785  			RET
0441A5             10786  
0441A5             10787  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
0441A5             10788  ;
0441A5 CD AF 41 04 10789  OSBYTE_13:		CALL	WAIT_VBLANK
0441A9 2E 00       10790  			LD	L, 0			; Returns 0
0441AB C3 8F 05 04 10791  			JP	COUNT0
0441AF             10792  ;
0441AF DD E5       10793  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0441B1             10794  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441B1 3E 08       0001M 			LD	A, function
0441B3 49 CF       0002M 			RST.LIS	08h
0441B5 DD 7E 00    10795  			LD	A, (IX + sysvar_time + 0)
0441B8 DD BE 00    10796  @@:			CP 	A, (IX + sysvar_time + 0)
0441BB 28 FB       10797  			JR	Z, @B
0441BD DD E1       10798  			POP	IX
0441BF C9          10799  			RET
0441C0             10800  
0441C0             10801  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0441C0             10802  ; Parameters:
0441C0             10803  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0441C0             10804  ;
0441C0             10805  OSBYTE_76:		VDU	23
0441C0 3E 17       0001M 		LD	A, val
0441C2 CD 61 3F 04 0002M 		CALL	OSWRCH
0441C6             10806  			VDU	0
0441C6 3E 00       0001M 		LD	A, val
0441C8 CD 61 3F 04 0002M 		CALL	OSWRCH
0441CC             10807  			VDU	vdp_keystate
0441CC 3E 88       0001M 		LD	A, val
0441CE CD 61 3F 04 0002M 		CALL	OSWRCH
0441D2             10808  			VDU	0
0441D2 3E 00       0001M 		LD	A, val
0441D4 CD 61 3F 04 0002M 		CALL	OSWRCH
0441D8             10809  			VDU 	0
0441D8 3E 00       0001M 		LD	A, val
0441DA CD 61 3F 04 0002M 		CALL	OSWRCH
0441DE             10810  			VDU	0
0441DE 3E 00       0001M 		LD	A, val
0441E0 CD 61 3F 04 0002M 		CALL	OSWRCH
0441E4             10811  			VDU	0
0441E4 3E 00       0001M 		LD	A, val
0441E6 CD 61 3F 04 0002M 		CALL	OSWRCH
0441EA             10812  			VDU	L
0441EA 7D          0001M 		LD	A, val
0441EB CD 61 3F 04 0002M 		CALL	OSWRCH
0441EF C9          10813  			RET
0441F0             10814  
0441F0             10815  ; OSBYTE 0xA0: Fetch system variable
0441F0             10816  ; Parameters:
0441F0             10817  ; - L: The system variable to fetch
0441F0             10818  ;
0441F0 DD E5       10819  OSBYTE_A0:		PUSH	IX
0441F2             10820  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441F2 3E 08       0001M 			LD	A, function
0441F4 49 CF       0002M 			RST.LIS	08h
0441F6 01 00 00 00 10821  			LD	BC, 0
0441FA 4D          10822  			LD	C, L			; BCU = L
0441FB DD 09       10823  			ADD	IX, BC			; Add to IX
0441FD DD 6E 00    10824  			LD	L, (IX + 0)		; Fetch the return value
044200 DD E1       10825  			POP	IX
044202 C3 8F 05 04 10826  			JP 	COUNT0
044206             10827  
044206             10828  ;OSLOAD - Load an area of memory from a file.
044206             10829  ;   Inputs: HL addresses filename (CR terminated)
044206             10830  ;           DE = address at which to load
044206             10831  ;           BC = maximum allowed size (bytes)
044206             10832  ;  Outputs: Carry reset indicates no room for file.
044206             10833  ; Destroys: A,B,C,D,E,H,L,F
044206             10834  ;
044206 C5          10835  OSLOAD:			PUSH	BC			; Stack the size
044207 D5          10836  			PUSH	DE			; Stack the load address
044208 11 00 4A 04 10837  			LD	DE, ACCS		; Buffer address for filename
04420C CD 7A 3E 04 10838  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044210 21 00 4A 04 10839  			LD	HL, ACCS		; HL: Filename
044214 CD 06 43 04 10840  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044218 CD 1A 43 04 10841  			CALL	EXT_HANDLER		; Get the default handler
04421C D1          10842  			POP	DE			; Restore the load address
04421D C1          10843  			POP	BC			; Restore the size
04421E B7          10844  			OR	A
04421F 28 60       10845  			JR 	Z, OSLOAD_BBC
044221             10846  ;
044221             10847  ; Load the file in as a text file
044221             10848  ;
044221 AF          10849  OSLOAD_TXT:		XOR	A			; Set file attributes to read
044222 CD 8E 43 04 10850  			CALL	OSOPEN			; Open the file
044226 5F          10851  			LD 	E, A 			; The filehandle
044227 B7          10852  			OR	A
044228 3E 04       10853  			LD	A, 4			; File not found error
04422A 28 5D       10854  			JR	Z, OSERROR		; Jump to error handler
04422C CD CD 38 04 10855  			CALL	NEWIT			; Call NEW to clear the program space
044230             10856  ;
044230 21 00 4A 04 10857  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044234             10858  ;
044234             10859  ; First skip any whitespace (indents) at the beginning of the input
044234             10860  ;
044234 CD A5 43 04 10861  @@:			CALL	OSBGET			; Read the byte into A
044238 38 1E       10862  			JR	C, OSLOAD_TXT3		; Is it EOF?
04423A FE 0A       10863  			CP	LF 			; Is it LF?
04423C 28 1A       10864  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
04423E FE 21       10865  			CP	21h			; Is it less than or equal to ASCII space?
044240 38 F2       10866  			JR	C, @B 			; Yes, so keep looping
044242 77          10867  			LD	(HL), A 		; Store the first character
044243 2C          10868  			INC	L
044244             10869  ;
044244             10870  ; Now read the rest of the line in
044244             10871  ;
044244 CD A5 43 04 10872  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
044248 38 2B       10873  			JR	C, OSLOAD_TXT4		; Is it EOF?
04424A FE 20       10874  			CP	20h			; Skip if not an ASCII character
04424C 38 06       10875  			JR	C, @F
04424E 77          10876  			LD	(HL), A 		; Store in the input buffer
04424F 2C          10877  			INC	L			; Increment the buffer pointer
044250 CA 59 37 04 10878  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044254 FE 0A       10879  @@:			CP	LF			; Check for LF
044256 20 EC       10880  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
044258             10881  ;
044258             10882  ; Finally, handle EOL/EOF
044258             10883  ;
044258 36 0D       10884  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
04425A 7D          10885  			LD	A, L			; Check for minimum line length
04425B FE 02       10886  			CP	2			; If it is 2 characters or less (including CR)
04425D 38 0A       10887  			JR	C, @F			; Then don't bother entering it
04425F D5          10888  			PUSH	DE			; Preserve the filehandle
044260 CD 3D 31 04 10889  			CALL	ONEDIT1			; Enter the line in memory
044264 DC A0 38 04 10890  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
044268 D1          10891  			POP	DE
044269 CD B6 43 04 10892  @@:			CALL	OSSTAT			; End of file?
04426D 20 C1       10893  			JR	NZ, OSLOAD_TXT1		; No, so loop
04426F CD 9D 43 04 10894  			CALL	OSSHUT			; Close the file
044273 37          10895  			SCF				; Flag to BASIC that we're good
044274 C9          10896  			RET
044275             10897  ;
044275             10898  ; Special case for BASIC programs with no blank line at the end
044275             10899  ;
044275 FE 20       10900  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044277 38 06       10901  			JR	C, @F
044279 77          10902  			LD	(HL), A			; Store the character
04427A 2C          10903  			INC	L
04427B CA 59 37 04 10904  			JP	Z, BAD
04427F 18 D7       10905  @@:			JR	OSLOAD_TXT3
044281             10906  
044281             10907  ;
044281             10908  ; Load the file in as a tokenised binary blob
044281             10909  ;
044281             10910  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044281 3E 01       0001M 			LD	A, function
044283 49 CF       0002M 			RST.LIS	08h
044285 D0          10911  			RET	NC			; If load returns with carry reset - NO ROOM
044286 B7          10912  			OR	A			; If there is no error (A=0)
044287 37          10913  			SCF				; Need to set carry indicating there was room
044288 C8          10914  			RET	Z			; Return
044289             10915  ;
044289 F5          10916  OSERROR:		PUSH	AF			; Handle the MOS error
04428A 21 00 4A 04 10917  			LD	HL, ACCS		; Address of the buffer
04428E 01 00 01 00 10918  			LD	BC, 256			; Length of the buffer
044292 5F          10919  			LD	E, A			; The error code
044293             10920  			MOSCALL	mos_getError		; Copy the error message into the buffer
044293 3E 0F       0001M 			LD	A, function
044295 49 CF       0002M 			RST.LIS	08h
044297 F1          10921  			POP	AF
044298 E5          10922  			PUSH	HL			; Stack the address of the error (now in ACCS)
044299 C6 7F       10923  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
04429B C3 D8 37 04 10924  			JP	EXTERR			; Trigger an external error
04429F             10925  
04429F             10926  ;OSSAVE - Save an area of memory to a file.
04429F             10927  ;   Inputs: HL addresses filename (term CR)
04429F             10928  ;           DE = start address of data to save
04429F             10929  ;           BC = length of data to save (bytes)
04429F             10930  ; Destroys: A,B,C,D,E,H,L,F
04429F             10931  ;
04429F C5          10932  OSSAVE:			PUSH	BC			; Stack the size
0442A0 D5          10933  			PUSH	DE			; Stack the save address
0442A1 11 00 4A 04 10934  			LD	DE, ACCS		; Buffer address for filename
0442A5 CD 7A 3E 04 10935  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0442A9 21 00 4A 04 10936  			LD	HL, ACCS		; HL: Filename
0442AD CD 06 43 04 10937  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0442B1 CD 1A 43 04 10938  			CALL	EXT_HANDLER		; Get the default handler
0442B5 D1          10939  			POP	DE			; Restore the save address
0442B6 C1          10940  			POP	BC			; Restore the size
0442B7 B7          10941  			OR	A			; Is the extension .BBC
0442B8 28 44       10942  			JR	Z, OSSAVE_BBC		; Yes, so use that
0442BA             10943  ;
0442BA             10944  ; Save the file out as a text file
0442BA             10945  ;
0442BA 3A 45 4D 04 10946  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0442BE F5          10947  			PUSH	AF
0442BF AF          10948  			XOR	A
0442C0 3C          10949  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0442C1 32 45 4D 04 10950  			LD	(OSWRCHCH), A
0442C5 CD 8E 43 04 10951  			CALL	OSOPEN			; Open the file
0442C9 32 46 4D 04 10952  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0442CD DD 21 40 4D 10953  			LD	IX, LISTON		; Required for LISTIT
       04          
0442D2 2A 14 4D 04 10954  			LD	HL, (PAGE_)		; Get start of program area
0442D6 D9          10955  			EXX
0442D7 01 00 00 00 10956  			LD	BC, 0			; Set the initial indent counters
0442DB D9          10957  			EXX
0442DC 7E          10958  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442DD B7          10959  			OR	A
0442DE 28 0F       10960  			JR	Z, OSSAVE_TXT2
0442E0 23          10961  			INC	HL			; Skip the length byte
0442E1 11 00 00 00 10962  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442E5 5E          10963  			LD	E, (HL)			; Get the line number
0442E6 23          10964  			INC	HL
0442E7 56          10965  			LD	D, (HL)
0442E8 23          10966  			INC	HL
0442E9 CD F3 38 04 10967  			CALL	LISTIT			; List the line
0442ED 18 ED       10968  			JR	OSSAVE_TXT1
0442EF 3A 46 4D 04 10969  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442F3 5F          10970  			LD	E, A
0442F4 CD 9D 43 04 10971  			CALL	OSSHUT			; Close it
0442F8 F1          10972  			POP	AF			; Restore the channel
0442F9 32 45 4D 04 10973  			LD	(OSWRCHCH), A
0442FD C9          10974  			RET
0442FE             10975  ;
0442FE             10976  ; Save the file out as a tokenised binary blob
0442FE             10977  ;
0442FE             10978  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442FE 3E 02       0001M 			LD	A, function
044300 49 CF       0002M 			RST.LIS	08h
044302 B7          10979  			OR	A			; If there is no error (A=0)
044303 C8          10980  			RET	Z			; Just return
044304 18 83       10981  			JR	OSERROR			; Trip an error
044306             10982  
044306             10983  ; Check if an extension is specified in the filename
044306             10984  ; Add a default if not specified
044306             10985  ; HL: Filename (CSTR format)
044306             10986  ;
044306 E5          10987  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044307 0E 2E       10988  			LD	C, '.'			; Search for dot (marks start of extension)
044309 CD 9A 3E 04 10989  			CALL	CSTR_FINDCH
04430D B7          10990  			OR	A			; Check for end of string marker
04430E 20 08       10991  			JR	NZ, @F			; No, so skip as we have an extension at this point
044310 11 4A 43 04 10992  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
044314 CD B1 3E 04 10993  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
044318 E1          10994  @@:			POP	HL			; Restore the filename pointer
044319 C9          10995  			RET
04431A             10996  
04431A             10997  ; Check if an extension is valid and, if so, provide a pointer to a handler
04431A             10998  ; HL: Filename (CSTR format)
04431A             10999  ; Returns:
04431A             11000  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
04431A             11001  ;
04431A E5          11002  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
04431B 0E 2E       11003  			LD	C, '.'			; Find the '.'
04431D CD 9A 3E 04 11004  			CALL	CSTR_FINDCH
044321 11 4A 43 04 11005  			LD	DE, EXT_LOOKUP		; The lookup table
044325             11006  ;
044325 E5          11007  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
044326 CD A2 3E 04 11008  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
04432A E1          11009  			POP	HL			; Restore the pointer to the extension
04432B 28 19       11010  			JR	Z, EXT_HANDLER_2	; We have a match!
04432D             11011  ;
04432D 1A          11012  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
04432E 13          11013  			INC	DE
04432F B7          11014  			OR	A
044330 20 FB       11015  			JR	NZ, @B
044332 13          11016  			INC	DE			; Skip the file extension # byte
044333             11017  ;
044333 1A          11018  			LD	A, (DE)			; Are we at the end of the table?
044334 B7          11019  			OR	A
044335 20 EE       11020  			JR	NZ, EXT_HANDLER_1	; No, so loop
044337             11021  ;
044337 3E CC       11022  			LD      A,204			; Throw a "Bad name" error
044339 CD D8 37 04 11023          		CALL    EXTERR
04433D 42 61 64 20 11024          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
044346             11025  ;
044346 13          11026  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
044347 1A          11027  			LD	A, (DE)
044348 E1          11028  			POP	HL			; Restore the filename pointer
044349 C9          11029  			RET
04434A             11030  ;
04434A             11031  
04434A             11032  
04434A             11033  ; Extension lookup table
04434A             11034  ; CSTR, TYPE
04434A             11035  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
04434A             11036  ; 	- 1: Human readable plain text
04434A             11037  ;
04434A 2E 42 42 43 11038  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
044350 2E 54 58 54 11039  			DB	".TXT", 0, 1
       00 01       
044356 2E 41 53 43 11040  			DB	".ASC", 0, 1
       00 01       
04435C 2E 42 41 53 11041  			DB	".BAS", 0, 1
       00 01       
044362 00          11042  			DB	0			; End of table
044363             11043  
044363             11044  ;OSCALL - Intercept page &FF calls and provide an alternative address
044363             11045  ;
044363             11046  ;&FFF7:	OSCLI	Execute *command.
044363             11047  ;&FFF4:	OSBYTE	Various byte-wide functions.
044363             11048  ;&FFF1:	OSWORD	Various control block functions.
044363             11049  ;&FFEE:	OSWRCH	Write character to output stream.
044363             11050  ;&FFE7:	OSNEWL	Write NewLine to output stream.
044363             11051  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
044363             11052  ;&FFE0:	OSRDCH	Wait for character from input stream.
044363             11053  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
044363             11054  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
044363             11055  ;&FFD7:	OSBGET	Read a byte from an a channel.
044363             11056  ;&FFD4:	OSBPUT	Write a byte to a channel.
044363             11057  ;&FFD1:	OSGBPB	Read and write blocks of data.
044363             11058  ;&FFCE:	OSFIND	Open or close a file.
044363             11059  ;
044363 21 79 43 04 11060  OSCALL:			LD	HL, OSCALL_TABLE
044367 7E          11061  OSCALL_1:		LD	A, (HL)
044368 23          11062  			INC	HL
044369 FE FF       11063  			CP	FFh
04436B C8          11064  			RET	Z
04436C FD BD       11065  			CP	A, IYL
04436E 28 06       11066  			JR	Z, OSCALL_2
044370 D0          11067  			RET	NC
044371 23          11068  			INC	HL
044372 23          11069  			INC	HL
044373 23          11070  			INC	HL
044374 18 F1       11071  			JR	OSCALL_1
044376 ED 31       11072  OSCALL_2:		LD	IY,(HL)
044378 C9          11073  			RET
044379 D4          11074  OSCALL_TABLE:		DB 	D4h
04437A AD 43 04    11075  			DW24 	OSBPUT
04437D D7          11076  			DB 	D7h
04437E A5 43 04    11077  			DW24 	OSBGET
044381 EE          11078  			DB 	EEh
044382 61 3F 04    11079  			DW24 	OSWRCH
044385 F4          11080  			DB	F4h
044386 2B 41 04    11081  			DW24 	OSBYTE
044389 F7          11082  			DB	F7h
04438A F1 3F 04    11083  			DW24	OSCLI
04438D FF          11084  			DB	FFh
04438E             11085  
04438E             11086  ; OSOPEN
04438E             11087  ; HL: Pointer to path
04438E             11088  ;  F: C Z
04438E             11089  ;     x x OPENIN
04438E             11090  ; 	  OPENOUT
04438E             11091  ;     x	  OPENUP
04438E             11092  ; Returns:
04438E             11093  ;  A: Filehandle, 0 if cannot open
04438E             11094  ;
04438E 0E 01       11095  OSOPEN:			LD	C, fa_read
044390 28 06       11096  			JR	Z, @F
044392 0E 32       11097  			LD	C, fa_write | fa_open_append
044394 38 02       11098  			JR	C, @F
044396 0E 0A       11099  			LD	C, fa_write | fa_create_always
044398             11100  @@:			MOSCALL	mos_fopen
044398 3E 0A       0001M 			LD	A, function
04439A 49 CF       0002M 			RST.LIS	08h
04439C C9          11101  			RET
04439D             11102  
04439D             11103  ;OSSHUT - Close disk file(s).
04439D             11104  ; E = file channel
04439D             11105  ;  If E=0 all files are closed (except SPOOL)
04439D             11106  ; Destroys: A,B,C,D,E,H,L,F
04439D             11107  ;
04439D C5          11108  OSSHUT:			PUSH	BC
04439E 4B          11109  			LD	C, E
04439F             11110  			MOSCALL	mos_fclose
04439F 3E 0B       0001M 			LD	A, function
0443A1 49 CF       0002M 			RST.LIS	08h
0443A3 C1          11111  			POP	BC
0443A4 C9          11112  			RET
0443A5             11113  
0443A5             11114  ; OSBGET - Read a byte from a random disk file.
0443A5             11115  ;  E = file channel
0443A5             11116  ; Returns
0443A5             11117  ;  A = byte read
0443A5             11118  ;  Carry set if LAST BYTE of file
0443A5             11119  ; Destroys: A,B,C,F
0443A5             11120  ;
0443A5 C5          11121  OSBGET:			PUSH	BC
0443A6 4B          11122  			LD	C, E
0443A7             11123  			MOSCALL	mos_fgetc
0443A7 3E 0C       0001M 			LD	A, function
0443A9 49 CF       0002M 			RST.LIS	08h
0443AB C1          11124  			POP	BC
0443AC C9          11125  			RET
0443AD             11126  
0443AD             11127  ; OSBPUT - Write a byte to a random disk file.
0443AD             11128  ;  E = file channel
0443AD             11129  ;  A = byte to write
0443AD             11130  ; Destroys: A,B,C,F
0443AD             11131  ;
0443AD C5          11132  OSBPUT:			PUSH	BC
0443AE 4B          11133  			LD	C, E
0443AF 47          11134  			LD	B, A
0443B0             11135  			MOSCALL	mos_fputc
0443B0 3E 0D       0001M 			LD	A, function
0443B2 49 CF       0002M 			RST.LIS	08h
0443B4 C1          11136  			POP	BC
0443B5 C9          11137  			RET
0443B6             11138  
0443B6             11139  ; OSSTAT - Read file status
0443B6             11140  ;  E = file channel
0443B6             11141  ; Returns
0443B6             11142  ;  F: Z flag set - EOF
0443B6             11143  ;  A: If Z then A = 0
0443B6             11144  ; Destroys: A,D,E,H,L,F
0443B6             11145  ;
0443B6 C5          11146  OSSTAT:			PUSH	BC
0443B7 4B          11147  			LD	C, E
0443B8             11148  			MOSCALL	mos_feof
0443B8 3E 0E       0001M 			LD	A, function
0443BA 49 CF       0002M 			RST.LIS	08h
0443BC C1          11149  			POP	BC
0443BD FE 01       11150  			CP	1
0443BF C9          11151  			RET
0443C0             11152  
0443C0             11153  ; GETPTR - Return file pointer.
0443C0             11154  ;    E = file channel
0443C0             11155  ; Returns:
0443C0             11156  ; DEHL = pointer (0-&7FFFFF)
0443C0             11157  ; Destroys: A,B,C,D,E,H,L,F
0443C0             11158  ;
0443C0 FD E5       11159  GETPTR:			PUSH		IY
0443C2 4B          11160  			LD		C, E
0443C3             11161  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0443C3 3E 19       0001M 			LD	A, function
0443C5 49 CF       0002M 			RST.LIS	08h
0443C7 E5          11162  			PUSH		HL
0443C8 FD E1       11163  			POP		IY		; IYU: Pointer to FIL structure
0443CA FD 6E 11    11164  			LD		L, (IY + FIL.fptr + 0)
0443CD FD 66 12    11165  			LD		H, (IY + FIL.fptr + 1)
0443D0 FD 5E 13    11166  			LD		E, (IY + FIL.fptr + 2)
0443D3 FD 56 14    11167  			LD		D, (IY + FIL.fptr + 3)
0443D6 FD E1       11168  			POP		IY
0443D8 C9          11169  			RET
0443D9             11170  
0443D9             11171  ; PUTPTR - Update file pointer.
0443D9             11172  ;    A = file channel
0443D9             11173  ; DEHL = new pointer (0-&7FFFFF)
0443D9             11174  ; Destroys: A,B,C,D,E,H,L,F
0443D9             11175  ;
0443D9 FD E5       11176  PUTPTR:			PUSH		IY
0443DB 4F          11177  			LD		C, A  		; C: Filehandle
0443DC E5          11178  			PUSH		HL
0443DD 21 02 00 00 11179  			LD		HL, 2
0443E1 39          11180  			ADD		HL, SP
0443E2 73          11181  			LD		(HL), E 	; 3rd byte of DWORD set to E
0443E3 E1          11182  			POP		HL
0443E4 5A          11183  			LD		E, D  		; 4th byte passed as E
0443E5             11184  			MOSCALL		mos_flseek
0443E5 3E 1C       0001M 			LD	A, function
0443E7 49 CF       0002M 			RST.LIS	08h
0443E9 FD E1       11185  			POP		IY
0443EB C9          11186  			RET
0443EC             11187  
0443EC             11188  ; GETEXT - Find file size.
0443EC             11189  ;    E = file channel
0443EC             11190  ; Returns:
0443EC             11191  ; DEHL = file size (0-&800000)
0443EC             11192  ; Destroys: A,B,C,D,E,H,L,F
0443EC             11193  ;
0443EC FD E5       11194  GETEXT:         PUSH    IY
0443EE 4B          11195                  LD      C, E
0443EF             11196                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443EF 3E 19       0001M 			LD	A, function
0443F1 49 CF       0002M 			RST.LIS	08h
0443F3 E5          11197                  PUSH    HL
0443F4 FD E1       11198                  POP     IY          ; IYU: Pointer to FIL structure
0443F6             11199                  ; Access the obj.objsize field using the offset values
0443F6 FD 6E 0B    11200                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443F9 FD 66 0C    11201                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443FC FD 5E 0D    11202                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443FF FD 56 0E    11203                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
044402             11204  
044402 FD E1       11205                  POP     IY
044404 C9          11206  			RET
044405             11207  
044405             11208  ; GETIMS - Get time from RTC
044405             11209  ;
044405 FD E5       11210  GETIMS:			PUSH	IY
044407 21 00 4A 04 11211  			LD	HL, ACCS 		; Where to store the time string
04440B             11212  			MOSCALL	mos_getrtc
04440B 3E 12       0001M 			LD	A, function
04440D 49 CF       0002M 			RST.LIS	08h
04440F 11 00 4A 04 11213  			LD	DE, ACCS		; DE: pointer to start of string accumulator
044413 5F          11214  			LD	E, A 			;  E: now points to the end of the string
044414 FD E1       11215  			POP	IY
044416 C9          11216  			RET
044417             11217  
044417             11218  ; Get two word values from EXPR in DE, HL
044417             11219  ; IY: Pointer to expression string
044417             11220  ; Returns:
044417             11221  ; DE: P1
044417             11222  ; HL: P2
044417             11223  ;
044417 CD 1A 03 04 11224  EXPR_W2:		CALL	EXPRI			; Get first parameter
04441B D9          11225  			EXX
04441C E5          11226  			PUSH	HL
04441D CD 35 0A 04 11227  			CALL	COMMA
044421 CD 1A 03 04 11228  			CALL	EXPRI			; Get second parameter
044425 D9          11229  			EXX
044426 D1          11230  			POP	DE
044427 C9          11231  			RET
044428             11232  
044428             11233  ; Stuff not implemented yet
044428             11234  ;
044428 C9          11235  RESET:			RET
044429             11236  ; --- End patch.asm ---
044429             11237  
044429             11238  ; --- Begin agon_graphics.asm ---
044429             11239  ;
044429             11240  ; Title:	BBC Basic for AGON - Graphics stuff
044429             11241  ; Author:	Dean Belfield
044429             11242  ; Created:	12/05/2023
044429             11243  ; Last Updated:	07/06/2023
044429             11244  ;
044429             11245  ; Modinfo:
044429             11246  ; 07/06/2023:	Modified to run in ADL mode
044429             11247  
044429             11248  			; .ASSUME	ADL = 1
044429             11249  
044429             11250  			; INCLUDE	"equs.inc"
044429             11251  			; INCLUDE "macros.inc"
044429             11252  			; INCLUDE "mos_api.inc"	; In MOS/src
044429             11253  
044429             11254  			; SEGMENT CODE
044429             11255  
044429             11256  			; XDEF	CLG
044429             11257  			; XDEF	CLRSCN
044429             11258  			; XDEF	MODE
044429             11259  			; XDEF	COLOUR
044429             11260  			; XDEF	GCOL
044429             11261  			; XDEF	MOVE
044429             11262  			; XDEF	PLOT
044429             11263  			; XDEF	DRAW
044429             11264  			; XDEF	POINT
044429             11265  			; XDEF	GETSCHR
044429             11266  
044429             11267  			; XREF	OSWRCH
044429             11268  			; XREF	ASC_TO_NUMBER
044429             11269  			; XREF	EXTERR
044429             11270  			; XREF	EXPRI
044429             11271  			; XREF	COMMA
044429             11272  			; XREF	XEQ
044429             11273  			; XREF	NXT
044429             11274  			; XREF	BRAKET
044429             11275  			; XREF	COUNT0
044429             11276  			; XREF	CRTONULL
044429             11277  			; XREF	NULLTOCR
044429             11278  			; XREF	CRLF
044429             11279  			; XREF	EXPR_W2
044429             11280  			; XREF	INKEY1
044429             11281  
044429             11282  ; CLG: clears the graphics area
044429             11283  ;
044429             11284  CLG:			VDU	10h
044429 3E 10       0001M 		LD	A, val
04442B CD 61 3F 04 0002M 		CALL	OSWRCH
04442F C3 A9 0B 04 11285  			JP	XEQ
044433             11286  
044433             11287  ; CLS: clears the text area
044433             11288  ;
044433 3E 0C       11289  CLRSCN:			LD	A, 0Ch
044435 C3 61 3F 04 11290  			JP	OSWRCH
044439             11291  
044439             11292  ; MODE n: Set video mode
044439             11293  ;
044439 DD E5       11294  MODE:			PUSH	IX			; Get the system vars in IX
04443B             11295  			MOSCALL	mos_sysvars		; Reset the semaphore
04443B 3E 08       0001M 			LD	A, function
04443D 49 CF       0002M 			RST.LIS	08h
04443F DD CB 04 A6 11296  			RES	4, (IX+sysvar_vpd_pflags)
044443 CD 1A 03 04 11297  			CALL    EXPRI
044447 D9          11298  			EXX
044448             11299  			VDU	16H			; Mode change
044448 3E 16       0001M 		LD	A, val
04444A CD 61 3F 04 0002M 		CALL	OSWRCH
04444E             11300  			VDU	L
04444E 7D          0001M 		LD	A, val
04444F CD 61 3F 04 0002M 		CALL	OSWRCH
044453             11301  			MOSCALL	mos_sysvars
044453 3E 08       0001M 			LD	A, function
044455 49 CF       0002M 			RST.LIS	08h
044457 DD CB 04 66 11302  @@:			BIT	4, (IX+sysvar_vpd_pflags)
04445B 28 FA       11303  			JR	Z, @B			; Wait for the result
04445D DD E1       11304  			POP	IX
04445F C3 A9 0B 04 11305  			JP	XEQ
044463             11306  
044463             11307  ; GET(x,y): Get the ASCII code of a character on screen
044463             11308  ;
044463 FD 23       11309  GETSCHR:		INC	IY
044465 CD 1A 03 04 11310  			CALL    EXPRI      		; Get X coordinate
044469 D9          11311  			EXX
04446A 22 00 4A 04 11312  			LD	(VDU_BUFFER+0), HL
04446E CD 35 0A 04 11313  			CALL	COMMA
044472 CD 1A 03 04 11314  			CALL	EXPRI			; Get Y coordinate
044476 D9          11315  			EXX
044477 22 02 4A 04 11316  			LD	(VDU_BUFFER+2), HL
04447B CD 42 0A 04 11317  			CALL	BRAKET			; Closing bracket
04447F             11318  ;
04447F DD E5       11319  			PUSH	IX			; Get the system vars in IX
044481             11320  			MOSCALL	mos_sysvars		; Reset the semaphore
044481 3E 08       0001M 			LD	A, function
044483 49 CF       0002M 			RST.LIS	08h
044485 DD CB 04 8E 11321  			RES	1, (IX+sysvar_vpd_pflags)
044489             11322  			VDU	23
044489 3E 17       0001M 		LD	A, val
04448B CD 61 3F 04 0002M 		CALL	OSWRCH
04448F             11323  			VDU	0
04448F 3E 00       0001M 		LD	A, val
044491 CD 61 3F 04 0002M 		CALL	OSWRCH
044495             11324  			VDU	vdp_scrchar
044495 3E 83       0001M 		LD	A, val
044497 CD 61 3F 04 0002M 		CALL	OSWRCH
04449B             11325  			VDU	(VDU_BUFFER+0)
04449B 3A 00 4A 04 0001M 		LD	A, val
04449F CD 61 3F 04 0002M 		CALL	OSWRCH
0444A3             11326  			VDU	(VDU_BUFFER+1)
0444A3 3A 01 4A 04 0001M 		LD	A, val
0444A7 CD 61 3F 04 0002M 		CALL	OSWRCH
0444AB             11327  			VDU	(VDU_BUFFER+2)
0444AB 3A 02 4A 04 0001M 		LD	A, val
0444AF CD 61 3F 04 0002M 		CALL	OSWRCH
0444B3             11328  			VDU	(VDU_BUFFER+3)
0444B3 3A 03 4A 04 0001M 		LD	A, val
0444B7 CD 61 3F 04 0002M 		CALL	OSWRCH
0444BB DD CB 04 4E 11329  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0444BF 28 FA       11330  			JR	Z, @B			; Wait for the result
0444C1 DD 7E 09    11331  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0444C4 B7          11332  			OR	A			; Check for 00h
0444C5 37          11333  			SCF				; C = character map
0444C6 20 02       11334  			JR	NZ, @F			; We have a character, so skip next bit
0444C8 AF          11335  			XOR	A			; Clear carry
0444C9 3D          11336  			DEC	A			; Set A to FFh
0444CA DD E1       11337  @@:			POP	IX
0444CC C3 F1 07 04 11338  			JP	INKEY1			; Jump back to the GET command
0444D0             11339  
0444D0             11340  ; POINT(x,y): Get the pixel colour of a point on screen
0444D0             11341  ;
0444D0 CD 1A 03 04 11342  POINT:			CALL    EXPRI      		; Get X coordinate
0444D4 D9          11343  			EXX
0444D5 22 00 4A 04 11344  			LD	(VDU_BUFFER+0), HL
0444D9 CD 35 0A 04 11345  			CALL	COMMA
0444DD CD 1A 03 04 11346  			CALL	EXPRI			; Get Y coordinate
0444E1 D9          11347  			EXX
0444E2 22 02 4A 04 11348  			LD	(VDU_BUFFER+2), HL
0444E6 CD 42 0A 04 11349  			CALL	BRAKET			; Closing bracket
0444EA             11350  ;
0444EA DD E5       11351  			PUSH	IX			; Get the system vars in IX
0444EC             11352  			MOSCALL	mos_sysvars		; Reset the semaphore
0444EC 3E 08       0001M 			LD	A, function
0444EE 49 CF       0002M 			RST.LIS	08h
0444F0 DD CB 04 96 11353  			RES	2, (IX+sysvar_vpd_pflags)
0444F4             11354  			VDU	23
0444F4 3E 17       0001M 		LD	A, val
0444F6 CD 61 3F 04 0002M 		CALL	OSWRCH
0444FA             11355  			VDU	0
0444FA 3E 00       0001M 		LD	A, val
0444FC CD 61 3F 04 0002M 		CALL	OSWRCH
044500             11356  			VDU	vdp_scrpixel
044500 3E 84       0001M 		LD	A, val
044502 CD 61 3F 04 0002M 		CALL	OSWRCH
044506             11357  			VDU	(VDU_BUFFER+0)
044506 3A 00 4A 04 0001M 		LD	A, val
04450A CD 61 3F 04 0002M 		CALL	OSWRCH
04450E             11358  			VDU	(VDU_BUFFER+1)
04450E 3A 01 4A 04 0001M 		LD	A, val
044512 CD 61 3F 04 0002M 		CALL	OSWRCH
044516             11359  			VDU	(VDU_BUFFER+2)
044516 3A 02 4A 04 0001M 		LD	A, val
04451A CD 61 3F 04 0002M 		CALL	OSWRCH
04451E             11360  			VDU	(VDU_BUFFER+3)
04451E 3A 03 4A 04 0001M 		LD	A, val
044522 CD 61 3F 04 0002M 		CALL	OSWRCH
044526 DD CB 04 56 11361  @@:			BIT	2, (IX+sysvar_vpd_pflags)
04452A 28 FA       11362  			JR	Z, @B			; Wait for the result
04452C             11363  ;
04452C             11364  ; Return the data as a 1 byte index
04452C             11365  ;
04452C DD 6E 16    11366  			LD	L, (IX+sysvar_scrpixelIndex)
04452F DD E1       11367  			POP	IX
044531 C3 8F 05 04 11368  			JP	COUNT0
044535             11369  
044535             11370  
044535             11371  ; COLOUR colour
044535             11372  ; COLOUR L,P
044535             11373  ; COLOUR L,R,G,B
044535             11374  ;
044535 CD 1A 03 04 11375  COLOUR:			CALL	EXPRI			; The colour / mode
044539 D9          11376  			EXX
04453A 7D          11377  			LD	A, L
04453B 32 00 4A 04 11378  			LD	(VDU_BUFFER+0), A	; Store first parameter
04453F CD 83 0A 04 11379  			CALL	NXT			; Are there any more parameters?
044543 FE 2C       11380  			CP	','
044545 28 12       11381  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
044547             11382  ;
044547             11383  			VDU	11h			; Just set the colour
044547 3E 11       0001M 		LD	A, val
044549 CD 61 3F 04 0002M 		CALL	OSWRCH
04454D             11384  			VDU	(VDU_BUFFER+0)
04454D 3A 00 4A 04 0001M 		LD	A, val
044551 CD 61 3F 04 0002M 		CALL	OSWRCH
044555 C3 A9 0B 04 11385  			JP	XEQ
044559             11386  ;
044559 CD 35 0A 04 11387  COLOUR_1:		CALL	COMMA
04455D CD 1A 03 04 11388  			CALL	EXPRI			; Parse R (OR P)
044561 D9          11389  			EXX
044562 7D          11390  			LD	A, L
044563 32 01 4A 04 11391  			LD	(VDU_BUFFER+1), A
044567 CD 83 0A 04 11392  			CALL	NXT			; Are there any more parameters?
04456B FE 2C       11393  			CP	','
04456D 28 2C       11394  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
04456F             11395  ;
04456F             11396  			VDU	13h			; VDU:COLOUR
04456F 3E 13       0001M 		LD	A, val
044571 CD 61 3F 04 0002M 		CALL	OSWRCH
044575             11397  			VDU	(VDU_BUFFER+0)		; Logical Colour
044575 3A 00 4A 04 0001M 		LD	A, val
044579 CD 61 3F 04 0002M 		CALL	OSWRCH
04457D             11398  			VDU	(VDU_BUFFER+1)		; Palette Colour
04457D 3A 01 4A 04 0001M 		LD	A, val
044581 CD 61 3F 04 0002M 		CALL	OSWRCH
044585             11399  			VDU	0			; RGB set to 0
044585 3E 00       0001M 		LD	A, val
044587 CD 61 3F 04 0002M 		CALL	OSWRCH
04458B             11400  			VDU	0
04458B 3E 00       0001M 		LD	A, val
04458D CD 61 3F 04 0002M 		CALL	OSWRCH
044591             11401  			VDU	0
044591 3E 00       0001M 		LD	A, val
044593 CD 61 3F 04 0002M 		CALL	OSWRCH
044597 C3 A9 0B 04 11402  			JP	XEQ
04459B             11403  ;
04459B CD 35 0A 04 11404  COLOUR_2:		CALL	COMMA
04459F CD 1A 03 04 11405  			CALL	EXPRI			; Parse G
0445A3 D9          11406  			EXX
0445A4 7D          11407  			LD	A, L
0445A5 32 02 4A 04 11408  			LD	(VDU_BUFFER+2), A
0445A9 CD 35 0A 04 11409  			CALL	COMMA
0445AD CD 1A 03 04 11410  			CALL	EXPRI			; Parse B
0445B1 D9          11411  			EXX
0445B2 7D          11412  			LD	A, L
0445B3 32 03 4A 04 11413  			LD	(VDU_BUFFER+3), A
0445B7             11414  			VDU	13h			; VDU:COLOUR
0445B7 3E 13       0001M 		LD	A, val
0445B9 CD 61 3F 04 0002M 		CALL	OSWRCH
0445BD             11415  			VDU	(VDU_BUFFER+0)		; Logical Colour
0445BD 3A 00 4A 04 0001M 		LD	A, val
0445C1 CD 61 3F 04 0002M 		CALL	OSWRCH
0445C5             11416  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0445C5 3E FF       0001M 		LD	A, val
0445C7 CD 61 3F 04 0002M 		CALL	OSWRCH
0445CB             11417  			VDU	(VDU_BUFFER+1)		; R
0445CB 3A 01 4A 04 0001M 		LD	A, val
0445CF CD 61 3F 04 0002M 		CALL	OSWRCH
0445D3             11418  			VDU	(VDU_BUFFER+2)		; G
0445D3 3A 02 4A 04 0001M 		LD	A, val
0445D7 CD 61 3F 04 0002M 		CALL	OSWRCH
0445DB             11419  			VDU	(VDU_BUFFER+3)		; B
0445DB 3A 03 4A 04 0001M 		LD	A, val
0445DF CD 61 3F 04 0002M 		CALL	OSWRCH
0445E3 C3 A9 0B 04 11420  			JP	XEQ
0445E7             11421  
0445E7             11422  ; GCOL mode,colour
0445E7             11423  ;
0445E7 CD 1A 03 04 11424  GCOL:			CALL	EXPRI			; Parse MODE
0445EB D9          11425  			EXX
0445EC 7D          11426  			LD	A, L
0445ED 32 00 4A 04 11427  			LD	(VDU_BUFFER+0), A
0445F1 CD 35 0A 04 11428  			CALL	COMMA
0445F5             11429  ;
0445F5 CD 1A 03 04 11430  			CALL	EXPRI			; Parse Colour
0445F9 D9          11431  			EXX
0445FA 7D          11432  			LD	A, L
0445FB 32 01 4A 04 11433  			LD	(VDU_BUFFER+1), A
0445FF             11434  ;
0445FF             11435  			VDU	12h			; VDU:GCOL
0445FF 3E 12       0001M 		LD	A, val
044601 CD 61 3F 04 0002M 		CALL	OSWRCH
044605             11436  			VDU	(VDU_BUFFER+0)		; Mode
044605 3A 00 4A 04 0001M 		LD	A, val
044609 CD 61 3F 04 0002M 		CALL	OSWRCH
04460D             11437  			VDU	(VDU_BUFFER+1)		; Colour
04460D 3A 01 4A 04 0001M 		LD	A, val
044611 CD 61 3F 04 0002M 		CALL	OSWRCH
044615 C3 A9 0B 04 11438  			JP	XEQ
044619             11439  
044619             11440  ; PLOT mode,x,y
044619             11441  ;
044619 CD 1A 03 04 11442  PLOT:			CALL	EXPRI		; Parse mode
04461D D9          11443  			EXX
04461E E5          11444  			PUSH	HL		; Push mode (L) onto stack
04461F CD 35 0A 04 11445  			CALL	COMMA
044623 CD 17 44 04 11446  			CALL	EXPR_W2		; Parse X and Y
044627 C1          11447  			POP	BC		; Pop mode (C) off stack
044628             11448  PLOT_1:			VDU	19H		; VDU code for PLOT
044628 3E 19       0001M 		LD	A, val
04462A CD 61 3F 04 0002M 		CALL	OSWRCH
04462E             11449  			VDU	C		;  C: Mode
04462E 79          0001M 		LD	A, val
04462F CD 61 3F 04 0002M 		CALL	OSWRCH
044633             11450  			VDU	E		; DE: X
044633 7B          0001M 		LD	A, val
044634 CD 61 3F 04 0002M 		CALL	OSWRCH
044638             11451  			VDU	D
044638 7A          0001M 		LD	A, val
044639 CD 61 3F 04 0002M 		CALL	OSWRCH
04463D             11452  			VDU	L		; HL: Y
04463D 7D          0001M 		LD	A, val
04463E CD 61 3F 04 0002M 		CALL	OSWRCH
044642             11453  			VDU	H
044642 7C          0001M 		LD	A, val
044643 CD 61 3F 04 0002M 		CALL	OSWRCH
044647 C3 A9 0B 04 11454  			JP	XEQ
04464B             11455  
04464B             11456  ; MOVE x,y
04464B             11457  ;
04464B CD 17 44 04 11458  MOVE:			CALL	EXPR_W2		; Parse X and Y
04464F 0E 04       11459  			LD	C, 04H		; Plot mode 04H (Move)
044651 18 D5       11460  			JR	PLOT_1		; Plot
044653             11461  
044653             11462  ; DRAW x1,y1
044653             11463  ; DRAW x1,y1,x2,y2
044653             11464  ;
044653 CD 17 44 04 11465  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
044657 CD 83 0A 04 11466  			CALL	NXT		; Are there any more parameters?
04465B FE 2C       11467  			CP	','
04465D 0E 05       11468  			LD	C, 05h		; Code for LINE
04465F 20 C7       11469  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044661             11470  			VDU	19h		; Move to the first coordinates
044661 3E 19       0001M 		LD	A, val
044663 CD 61 3F 04 0002M 		CALL	OSWRCH
044667             11471  			VDU	04h
044667 3E 04       0001M 		LD	A, val
044669 CD 61 3F 04 0002M 		CALL	OSWRCH
04466D             11472  			VDU	E
04466D 7B          0001M 		LD	A, val
04466E CD 61 3F 04 0002M 		CALL	OSWRCH
044672             11473  			VDU	D
044672 7A          0001M 		LD	A, val
044673 CD 61 3F 04 0002M 		CALL	OSWRCH
044677             11474  			VDU	L
044677 7D          0001M 		LD	A, val
044678 CD 61 3F 04 0002M 		CALL	OSWRCH
04467C             11475  			VDU	H
04467C 7C          0001M 		LD	A, val
04467D CD 61 3F 04 0002M 		CALL	OSWRCH
044681 CD 35 0A 04 11476  			CALL	COMMA
044685 C5          11477  			PUSH	BC
044686 CD 17 44 04 11478  			CALL	EXPR_W2		; Get X2 and Y2
04468A C1          11479  			POP	BC
04468B 18 9B       11480  			JR	PLOT_1		; Now DRAW the line to those positions
04468D             11481  
04468D             11482  
04468D             11483  
04468D             11484  ; --- End agon_graphics.asm ---
04468D             11485  
04468D             11486  ; --- Begin agon_sound.asm ---
04468D             11487  ;
04468D             11488  ; Title:	BBC Basic for AGON - Audio stuff
04468D             11489  ; Author:	Dean Belfield
04468D             11490  ; Created:	12/05/2023
04468D             11491  ; Last Updated:	12/05/2023
04468D             11492  ;
04468D             11493  ; Modinfo:
04468D             11494  
04468D             11495  			; .ASSUME	ADL = 1
04468D             11496  
04468D             11497  			; INCLUDE	"equs.inc"
04468D             11498  			; INCLUDE "macros.inc"
04468D             11499  			; INCLUDE "mos_api.inc"	; In MOS/src
04468D             11500  
04468D             11501  			; SEGMENT CODE
04468D             11502  
04468D             11503  			; XDEF	SOUND
04468D             11504  
04468D             11505  			; XREF	COMMA
04468D             11506  			; XREF	EXPR_W2
04468D             11507  			; XREF	XEQ
04468D             11508  			; XREF	LTRAP
04468D             11509  			; XREF	OSWRCH
04468D             11510  			; XREF	VDU_BUFFER
04468D             11511  
04468D             11512  
04468D             11513  ; SOUND channel,volume,pitch,duration
04468D             11514  ; volume: 0 (off) to -15 (full volume)
04468D             11515  ; pitch: 0 - 255
04468D             11516  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
04468D             11517  ;
04468D CD 17 44 04 11518  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044691 7D          11519  			LD	A, L 			;  A: Volume
044692 F5          11520  			PUSH	AF
044693 D5          11521  			PUSH	DE
044694 CD 35 0A 04 11522  			CALL	COMMA
044698 CD 17 44 04 11523  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
04469C 53          11524  			LD	D, E			;  D: Pitch
04469D 5D          11525  			LD	E, L 			;  E: Duration
04469E E1          11526  			POP	HL 			; HL: Channel/Control
04469F F1          11527  			POP	AF
0446A0 ED 44       11528  			NEG
0446A2 FE 10       11529  			CP	16			; Check volume is in bounds
0446A4 D2 A9 0B 04 11530  			JP	NC, XEQ			; Out of bounds, do nothing
0446A8             11531  ;
0446A8             11532  ; Store	in VDU vars
0446A8             11533  ;
0446A8 4F          11534  			LD	C, A			; Store Volume in C
0446A9 7D          11535  			LD	A, L
0446AA 32 00 4A 04 11536  			LD	(VDU_BUFFER+0), A	; Channel
0446AE AF          11537  			XOR	A
0446AF 32 01 4A 04 11538  			LD	(VDU_BUFFER+1), A	; Waveform
0446B3             11539  ;
0446B3             11540  ; Calculate the volume
0446B3             11541  ;
0446B3 06 06       11542  			LD	B, 6			; C already contains the volume
0446B5 ED 4C       11543  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0446B7 79          11544  			LD	A, C
0446B8 32 02 4A 04 11545  			LD	(VDU_BUFFER+2), A
0446BC             11546  ;
0446BC             11547  ; And the frequency
0446BC             11548  ;
0446BC 4B          11549  			LD	C, E			; Store duration in C
0446BD 26 00       11550  			LD	H, 0			; Lookup the frequency
0446BF 6A          11551  			LD	L, D
0446C0 11 47 47 04 11552  			LD	DE, SOUND_FREQ_LOOKUP
0446C4 29          11553  			ADD	HL, HL
0446C5 19          11554  			ADD	HL, DE
0446C6 7E          11555  			LD	A, (HL)
0446C7 32 03 4A 04 11556  			LD	(VDU_BUFFER+3), A
0446CB 23          11557  			INC	HL
0446CC 7E          11558  			LD	A, (HL)
0446CD 32 04 4A 04 11559  			LD	(VDU_BUFFER+4), A
0446D1             11560  ;
0446D1             11561  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0446D1             11562  ;
0446D1 06 32       11563  			LD	B, 50			; C contains the duration, so MLT by 50
0446D3 ED 4C       11564  			MLT	BC
0446D5 ED 43 05 4A 11565  			LD	(VDU_BUFFER+5), BC
       04          
0446DA             11566  ;
0446DA DD E5       11567  			PUSH	IX			; Get the system vars in IX
0446DC             11568  			MOSCALL	mos_sysvars		; Reset the semaphore
0446DC 3E 08       0001M 			LD	A, function
0446DE 49 CF       0002M 			RST.LIS	08h
0446E0 5B DD CB 04 11569  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0446E5             11570  ;
0446E5             11571  			VDU	23			; Send the sound command
0446E5 3E 17       0001M 		LD	A, val
0446E7 CD 61 3F 04 0002M 		CALL	OSWRCH
0446EB             11572  			VDU	0
0446EB 3E 00       0001M 		LD	A, val
0446ED CD 61 3F 04 0002M 		CALL	OSWRCH
0446F1             11573  			VDU	vdp_audio
0446F1 3E 85       0001M 		LD	A, val
0446F3 CD 61 3F 04 0002M 		CALL	OSWRCH
0446F7             11574  			VDU	(VDU_BUFFER+0)		; 0: Channel
0446F7 3A 00 4A 04 0001M 		LD	A, val
0446FB CD 61 3F 04 0002M 		CALL	OSWRCH
0446FF             11575  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446FF 3A 01 4A 04 0001M 		LD	A, val
044703 CD 61 3F 04 0002M 		CALL	OSWRCH
044707             11576  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
044707 3A 02 4A 04 0001M 		LD	A, val
04470B CD 61 3F 04 0002M 		CALL	OSWRCH
04470F             11577  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
04470F 3A 03 4A 04 0001M 		LD	A, val
044713 CD 61 3F 04 0002M 		CALL	OSWRCH
044717             11578  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
044717 3A 04 4A 04 0001M 		LD	A, val
04471B CD 61 3F 04 0002M 		CALL	OSWRCH
04471F             11579  			VDU	(VDU_BUFFER+5)		; 5: Duration L
04471F 3A 05 4A 04 0001M 		LD	A, val
044723 CD 61 3F 04 0002M 		CALL	OSWRCH
044727             11580  			VDU	(VDU_BUFFER+6)		; 6: Duration H
044727 3A 06 4A 04 0001M 		LD	A, val
04472B CD 61 3F 04 0002M 		CALL	OSWRCH
04472F             11581  ;
04472F             11582  ; Wait for acknowledgement
04472F             11583  ;
04472F 5B DD CB 04 11584  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
044734 28 F9       11585  			JR	Z, @B			; Wait for the result
044736 CD D2 3F 04 11586  			CALL	LTRAP			; Check for ESC
04473A 5B DD 7E 0E 11587  			LD.LIL	A, (IX+sysvar_audioSuccess)
04473E A7          11588  			AND	A			; Check if VDP has queued the note
04473F 28 9F       11589  			JR	Z, SOUND0		; No, so loop back and send again
044741             11590  ;
044741 DD E1       11591  			POP	IX
044743 C3 A9 0B 04 11592  			JP	XEQ
044747             11593  
044747             11594  ; Frequency Lookup Table
044747             11595  ; Set up to replicate the BBC Micro audio frequencies
044747             11596  ;
044747             11597  ; Split over 5 complete octaves, with 53 being middle C
044747             11598  ; * C4: 262hz
044747             11599  ; + A4: 440hz
044747             11600  ;
044747             11601  ;	2	3	4	5	6	7	8
044747             11602  ;
044747             11603  ; B	1	49	97	145	193	241
044747             11604  ; A#	0	45	93	141	189	237
044747             11605  ; A		41	89+	137	185	233
044747             11606  ; G#		37	85	133	181	229
044747             11607  ; G		33	81	129	177	225
044747             11608  ; F#		29	77	125	173	221
044747             11609  ; F		25	73	121	169	217
044747             11610  ; E		21	69	117	165	213
044747             11611  ; D#		17	65	113	161	209
044747             11612  ; D		13	61	109	157	205	253
044747             11613  ; C#		9	57	105	153	201	249
044747             11614  ; C		5	53*	101	149	197	245
044747             11615  ;
044747 75 00 76 00 11616  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
044757 89 00 8B 00 11617  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
044767 99 00 9C 00 11618  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
044777 AC 00 AF 00 11619  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
044787 C1 00 C4 00 11620  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
044797 D9 00 DC 00 11621  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
0447A7 F3 00 F7 00 11622  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0447B7 11 01 15 01 11623  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0447C7 33 01 37 01 11624  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0447D7 58 01 5D 01 11625  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0447E7 82 01 88 01 11626  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0447F7 B2 01 B8 01 11627  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
044807 E7 01 EE 01 11628  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
044817 22 02 2A 02 11629  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
044827 65 02 6E 02 11630  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
044837 B1 02 BB 02 11631  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
044847 05 03 10 03 11632  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
044857 63 03 70 03 11633  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
044867 CE 03 DC 03 11634  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
044877 45 04 55 04 11635  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
044887 CB 04 DD 04 11636  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
044897 62 05 76 05 11637  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
0448A7 0A 06 21 06 11638  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0448B7 C8 06 E1 06 11639  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0448C7 9C 07 B8 07 11640  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0448D7 8A 08 A9 08 11641  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0448E7 95 09 B9 09 11642  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0448F7 C2 0A EA 0A 11643  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
044907 13 0C 40 0C 11644  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
044917 8E 0D C0 0D 11645  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
044927 36 0F 6F 0F 11646  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
044937 13 11 53 11 11647  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
044947             11648  
044947             11649  
044947             11650  ; --- End agon_sound.asm ---
044947             11651  
044947             11652  ; --- Begin interrupts.asm ---
044947             11653  ;
044947             11654  ; Title:	BBC Basic for AGON - Interrupts
044947             11655  ; Author:	Dean Belfield
044947             11656  ; Created:	12/05/2023
044947             11657  ; Last Updated:	07/06/2023
044947             11658  ;
044947             11659  ; Modinfo:
044947             11660  ; 07/06/2023:	Modified to run in ADL mode
044947             11661  
044947             11662  			; .ASSUME	ADL = 1
044947             11663  
044947             11664  			; INCLUDE	"macros.inc"
044947             11665  			; INCLUDE	"equs.inc"
044947             11666  			; INCLUDE "mos_api.inc"	; In MOS/src
044947             11667  
044947             11668  			; SEGMENT CODE
044947             11669  
044947             11670  			; XDEF	VBLANK_INIT
044947             11671  			; XDEF	VBLANK_STOP
044947             11672  			; XDEF	VBLANK_HANDLER
044947             11673  
044947             11674  			; XREF	ESCSET
044947             11675  			; XREF	KEYDOWN		; In ram.asm
044947             11676  			; XREF	KEYASCII 	; In ram.asm
044947             11677  			; XREF	KEYCOUNT	; In ram.asm
044947             11678  
044947             11679  ; Hook into the MOS VBLANK interrupt
044947             11680  ;
044947 F3          11681  VBLANK_INIT:		DI
044948 21 9C 49 04 11682  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
04494C 1E 32       11683  			LD		E, 32h				; Set up the VBlank Interrupt Vector
04494E             11684  			MOSCALL		mos_setintvector
04494E 3E 14       0001M 			LD	A, function
044950 49 CF       0002M 			RST.LIS	08h
044952             11685  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044952 EB          11686  			ex de,hl
044953 21 AA 49 04 11687  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044957 ED 1F       11688  			LD		(HL), DE			; Self-modify the code
044959 FB          11689  			EI
04495A C9          11690  			RET
04495B             11691  
04495B             11692  ; Unhook the custom VBLANK interrupt
04495B             11693  ;
04495B F3          11694  VBLANK_STOP:		DI
04495C 21 AA 49 04 11695  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044960 ED 17       11696  			LD		DE, (HL)
044962 EB          11697  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
044963 1E 32       11698  			LD		E, 32h
044965             11699  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
044965 3E 14       0001M 			LD	A, function
044967 49 CF       0002M 			RST.LIS	08h
044969 FB          11700  			EI
04496A C9          11701  			RET
04496B             11702  
04496B             11703  ; A safe LIS call to ESCSET
04496B             11704  ;
04496B             11705  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
04496B 3E 08       0001M 			LD	A, function
04496D 49 CF       0002M 			RST.LIS	08h
04496F 21 49 4D 04 11706  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044973 DD 7E 19    11707  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
044976 BE          11708  			CP 		(HL)				; with our local copy
044977 20 0A       11709  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044979             11710  ;
044979 AF          11711  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
04497A 32 48 4D 04 11712  			LD		(KEYASCII), A
04497E 32 47 4D 04 11713  			LD		(KEYDOWN), A
044982 C9          11714  			RET	 					; And return
044983             11715  ;
044983 77          11716  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044984 DD 7E 18    11717  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044987 B7          11718  			OR		A
044988 28 EF       11719  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
04498A             11720  ;
04498A 32 47 4D 04 11721  			LD		(KEYDOWN), A 			; Store the keydown value
04498E DD 7E 05    11722  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044991 32 48 4D 04 11723  			LD		(KEYASCII), A 			; Store locally
044995 FE 1B       11724  			CP		1Bh				; Is it escape?
044997 CC AD 3F 04 11725  			CALL		Z, ESCSET			; Yes, so set the escape flags
04499B C9          11726  			RET						; Return to the interrupt handler
04499C             11727  
04499C F3          11728  VBLANK_HANDLER:		DI
04499D F5          11729  			PUSH		AF
04499E E5          11730  			PUSH		HL
04499F DD E5       11731  			PUSH		IX
0449A1 CD 6B 49 04 11732  			CALL		DO_KEYBOARD
0449A5 DD E1       11733  			POP		IX
0449A7 E1          11734  			POP		HL
0449A8 F1          11735  			POP		AF
0449A9             11736  ;
0449A9             11737  ; Finally jump to the MOS interrupt
0449A9             11738  ;
0449A9 C3 00 00 00 11739  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
0449AD             11740  
0449AD             11741  ; --- Begin ram.asm ---
0449AD             11742  ;
0449AD             11743  ; Title:	BBC Basic Interpreter - Z80 version
0449AD             11744  ;		RAM Module for BBC Basic Interpreter
0449AD             11745  ;		For use with Version 2.0 of BBC BASIC
0449AD             11746  ;		Standard CP/M Distribution Version
0449AD             11747  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0449AD             11748  ; Modified By:	Dean Belfield
0449AD             11749  ; Created:	12/05/2023
0449AD             11750  ; Last Updated:	26/06/2023
0449AD             11751  ;
0449AD             11752  ; Modinfo:
0449AD             11753  ; 06/06/2023:	Modified to run in ADL mode
0449AD             11754  ; 26/06/2023:	Added temporary stores R0 and R1
0449AD             11755  
0449AD             11756  			; .ASSUME	ADL = 1
0449AD             11757  
0449AD             11758  			; DEFINE	LORAM, SPACE = ROM
0449AD             11759  			; SEGMENT LORAM
0449AD             11760  
0449AD             11761  			; XDEF	ACCS
0449AD             11762  			; XDEF	BUFFER
0449AD             11763  			; XDEF	STAVAR
0449AD             11764  			; XDEF	DYNVAR
0449AD             11765  			; XDEF	FNPTR
0449AD             11766  			; XDEF	PROPTR
0449AD             11767  			; XDEF	PAGE_
0449AD             11768  			; XDEF	TOP
0449AD             11769  			; XDEF	LOMEM
0449AD             11770  			; XDEF 	FREE
0449AD             11771  			; XDEF	HIMEM
0449AD             11772  			; XDEF	LINENO
0449AD             11773  			; XDEF	TRACEN
0449AD             11774  			; XDEF	AUTONO
0449AD             11775  			; XDEF	ERRTRP
0449AD             11776  			; XDEF	ERRTXT
0449AD             11777  			; XDEF	DATPTR
0449AD             11778  			; XDEF	ERL
0449AD             11779  			; XDEF	ERRLIN
0449AD             11780  			; XDEF	RANDOM
0449AD             11781  			; XDEF	COUNT
0449AD             11782  			; XDEF	WIDTH
0449AD             11783  			; XDEF	ERR
0449AD             11784  			; XDEF	LISTON
0449AD             11785  			; XDEF	INCREM
0449AD             11786  
0449AD             11787  			; XDEF	FLAGS
0449AD             11788  			; XDEF	OSWRCHPT
0449AD             11789  			; XDEF	OSWRCHCH
0449AD             11790  			; XDEF	OSWRCHFH
0449AD             11791  			; XDEF	KEYDOWN
0449AD             11792  			; XDEF	KEYASCII
0449AD             11793  			; XDEF	KEYCOUNT
0449AD             11794  
0449AD             11795  			; XDEF	R0
0449AD             11796  			; XDEF	R1
0449AD             11797  
0449AD             11798  			; XDEF	RAM_START
0449AD             11799  			; XDEF	RAM_END
0449AD             11800  			; XDEF	USER
0449AD             11801  
0449AD 00 00 00 00 11802  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
044A00             11803  RAM_START:
044A00             11804  ;
044A00 00 00 00 00 11805  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 11806  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 11807  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 11808  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    11809  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    11810  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             11811  ;
044D14 00 00 00    11812  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    11813  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    11814  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    11815  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    11816  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             11817  ;
044D23 00 00 00    11818  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    11819  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    11820  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    11821  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       11822  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       11823  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       11824  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    11825  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 11826  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          11827  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          11828  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          11829  ERR:            BLKB    1,0               ; Error Number
044D40 00          11830  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             11831                                  ; - BIT 0: If set, output a space after the line number
044D41             11832                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             11833                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             11834                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             11835                                  ; OPT FLAG (top nibble)
044D41             11836                                  ; - BIT 4: If set, then list whilst assembling
044D41             11837                                  ; - BIT 5: If set, then assembler errors are reported
044D41             11838                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             11839                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          11840  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             11841  ;
044D42             11842  ; Extra Agon-implementation specific system variables
044D42             11843  ;
044D42 00          11844  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             11845                                  ; - BIT 7: Set if ESC pressed
044D43             11846                                  ; - BIT 6: Set to disable ESC
044D43 00 00       11847  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          11848  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             11849                                  ; - 0: Console
044D46             11850                                  ; - 1: File
044D46 00          11851  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          11852  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          11853  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          11854  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    11855  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    11856  R1:             BLKB    3,0
044D50             11857  
044D50             11858  ;
044D50             11859  ; This must be at the end
044D50             11860  ;
044D50             11861  RAM_END:
044D50             11862  ; moved to user.asm
044D50             11863  ; 			ALIGN	256
044D50             11864  ; USER:							; Must be aligned on a page boundary
044D50             11865  	; --- End ram.asm ---
044D50             11866  
044D50             11867  ; --- Begin user.asm ---
044D50             11868  ; this must be the last include to allow unbounded user space for programs
044D50             11869  
044D50             11870  			; .ASSUME	ADL = 1
044D50             11871  
044D50 00 00 00 00 11872  			ALIGN	256
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044E00             11873  USER:							; Must be aligned on a page boundary; --- End user.asm ---
044E00             11874  
044E00             11875  ; --- Begin equs_bottom.inc ---
044E00             11876  ; --- Begin equs.inc ---
044E00             11877  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
044E00             11878  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
044E00             11879  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044E00             11880  ; --- End equs.inc ---
044E00             11881  
044E00             11882  ; --- Begin eval.asm ---
044E00             11883  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
044E00             11884  ; 041DFA D6 C6       0258*  			SUB     TCMD
044E00             11885  
044E00             11886  ; --- End eval.asm ---
044E00             11887  
044E00             11888  ; --- Begin exec.asm ---
044E00             11889  ; --- End exec.asm ---
044E00             11890  
044E00             11891  ; --- Begin fpp.asm ---
044E00             11892  ; --- End fpp.asm ---
044E00             11893  
044E00             11894  ; --- Begin init.asm ---
044E00             11895  ; --- End init.asm ---
044E00             11896  
044E00             11897  ; --- Begin main.asm ---
044E00             11898  ; --- End main.asm ---
044E00             11899  
044E00             11900  ; --- Begin mos_api.inc ---
044E00             11901  ; --- End mos_api.inc ---
044E00             11902  
044E00             11903  ; --- End equs_bottom.inc ---
044E00             11904  
