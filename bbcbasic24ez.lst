PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modinfo:
040000             0009  ; 05/08/2022:	Added mos_feof
040000             0010  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0011  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0012  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0013  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0014  ; 13/10/2022:	Added mos_oscli
040000             0015  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0016  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0017  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0018  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0019  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0020  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0021  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0022  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0023  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0024  ; 19/05/2023:	Added sysvar_scrMode
040000             0025  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0026  ; 03/08/2023:	Added mos_setkbvector
040000             0027  ; 10/08/2023:	Added mos_getkbmap
040000             0028  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0029  
040000             0030  ; VDP control (VDU 23, 0, n)
040000             0031  ;
040000             0032  vdp_gp:			EQU 	80h
040000             0033  vdp_keycode:		EQU 	81h
040000             0034  vdp_cursor:		EQU	82h
040000             0035  vdp_scrchar:		EQU	83h
040000             0036  vdp_scrpixel:		EQU	84h
040000             0037  vdp_audio:		EQU	85h
040000             0038  vdp_mode:		EQU	86h
040000             0039  vdp_rtc:		EQU	87h
040000             0040  vdp_keystate:		EQU	88h
040000             0041  vdp_logicalcoords:	EQU	C0h
040000             0042  vdp_terminalmode:	EQU	FFh
040000             0043  
040000             0044  ; MOS high level functions
040000             0045  ;
040000             0046  mos_getkey:		EQU	00h
040000             0047  mos_load:		EQU	01h
040000             0048  mos_save:		EQU	02h
040000             0049  mos_cd:			EQU	03h
040000             0050  mos_dir:		EQU	04h
040000             0051  mos_del:		EQU	05h
040000             0052  mos_ren:		EQU	06h
040000             0053  mos_mkdir:		EQU	07h
040000             0054  mos_sysvars:		EQU	08h
040000             0055  mos_editline:		EQU	09h
040000             0056  mos_fopen:		EQU	0Ah
040000             0057  mos_fclose:		EQU	0Bh
040000             0058  mos_fgetc:		EQU	0Ch
040000             0059  mos_fputc:		EQU	0Dh
040000             0060  mos_feof:		EQU	0Eh
040000             0061  mos_getError:		EQU	0Fh
040000             0062  mos_oscli:		EQU	10h
040000             0063  mos_copy:		EQU	11h
040000             0064  mos_getrtc:		EQU	12h
040000             0065  mos_setrtc:		EQU	13h
040000             0066  mos_setintvector:	EQU	14h
040000             0067  mos_uopen:		EQU	15h
040000             0068  mos_uclose:		EQU	16h
040000             0069  mos_ugetc:		EQU	17h
040000             0070  mos_uputc:		EQU 	18h
040000             0071  mos_getfil:		EQU	19h
040000             0072  mos_fread:		EQU	1Ah
040000             0073  mos_fwrite:		EQU	1Bh
040000             0074  mos_flseek:		EQU	1Ch
040000             0075  mos_setkbvector:	EQU	1Dh
040000             0076  mos_getkbmap:		EQU	1Eh
040000             0077  mos_i2c_open:		EQU	1Fh
040000             0078  mos_i2c_close:		EQU	20h
040000             0079  mos_i2c_write:		EQU	21h
040000             0080  mos_i2c_read:		EQU	22h
040000             0081  
040000             0082  
040000             0083  ; FatFS file access functions
040000             0084  ;
040000             0085  ffs_fopen:		EQU	80h
040000             0086  ffs_fclose:		EQU	81h
040000             0087  ffs_fread:		EQU	82h
040000             0088  ffs_fwrite:		EQU	83h
040000             0089  ffs_flseek:		EQU	84h
040000             0090  ffs_ftruncate:		EQU	85h
040000             0091  ffs_fsync:		EQU	86h
040000             0092  ffs_fforward:		EQU	87h
040000             0093  ffs_fexpand:		EQU	88h
040000             0094  ffs_fgets:		EQU	89h
040000             0095  ffs_fputc:		EQU	8Ah
040000             0096  ffs_fputs:		EQU	8Bh
040000             0097  ffs_fprintf:		EQU	8Ch
040000             0098  ffs_ftell:		EQU	8Dh
040000             0099  ffs_feof:		EQU	8Eh
040000             0100  ffs_fsize:		EQU	8Fh
040000             0101  ffs_ferror:		EQU	90h
040000             0102  
040000             0103  ; FatFS directory access functions
040000             0104  ;
040000             0105  ffs_dopen:		EQU	91h
040000             0106  ffs_dclose:		EQU	92h
040000             0107  ffs_dread:		EQU	93h
040000             0108  ffs_dfindfirst:		EQU	94h
040000             0109  ffs_dfindnext:		EQU	95h
040000             0110  
040000             0111  ; FatFS file and directory management functions
040000             0112  ;
040000             0113  ffs_stat:		EQU	96h
040000             0114  ffs_unlink:		EQU	97h
040000             0115  ffs_rename:		EQU	98h
040000             0116  ffs_chmod:		EQU	99h
040000             0117  ffs_utime:		EQU	9Ah
040000             0118  ffs_mkdir:		EQU	9Bh
040000             0119  ffs_chdir:		EQU	9Ch
040000             0120  ffs_chdrive:		EQU	9Dh
040000             0121  ffs_getcwd:		EQU	9Eh
040000             0122  
040000             0123  ; FatFS volume management and system configuration functions
040000             0124  ;
040000             0125  ffs_mount:		EQU	9Fh
040000             0126  ffs_mkfs:		EQU	A0h
040000             0127  ffs_fdisk:		EQU	A1h
040000             0128  ffs_getfree:		EQU	A2h
040000             0129  ffs_getlabel:		EQU	A3h
040000             0130  ffs_setlabel:		EQU	A4h
040000             0131  ffs_setcp:		EQU	A5h
040000             0132  
040000             0133  ; File access modes
040000             0134  ;
040000             0135  fa_read:		EQU	01h
040000             0136  fa_write:		EQU	02h
040000             0137  fa_open_existing:	EQU	00h
040000             0138  fa_create_new:		EQU	04h
040000             0139  fa_create_always:	EQU	08h
040000             0140  fa_open_always:		EQU	10h
040000             0141  fa_open_append:		EQU	30h
040000             0142  
040000             0143  ; System variable indexes for api_sysvars
040000             0144  ; Index into _sysvars in globals.asm
040000             0145  ;
040000             0146  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0147  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0148  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0149  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0150  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0151  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0152  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0153  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0154  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0155  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0156  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0157  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0158  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0159  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0160  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0161  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0162  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0163  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0164  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0165  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0166  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0167  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0168  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0169  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0170  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0171  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0172  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0173  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0174  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0175  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0176  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0177  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0178  
040000             0179  ; Flags for the VPD protocol
040000             0180  ;
040000             0181  vdp_pflag_cursor:	EQU	00000001b
040000             0182  vdp_pflag_scrchar:	EQU	00000010b
040000             0183  vdp_pflag_point:	EQU	00000100b
040000             0184  vdp_pflag_audio:	EQU	00001000b
040000             0185  vdp_pflag_mode:		EQU	00010000b
040000             0186  vdp_pflag_rtc:		EQU	00100000b
040000             0187  vdp_pflag_mouse:	EQU	01000000b
040000             0188  ; vdp_pflag_buffered:	EQU	10000000b
040000             0189  
040000             0190  ;
040000             0191  ; FatFS structures
040000             0192  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0193  ;
040000             0194  ; Object ID and allocation information (FFOBJID)
040000             0195  ;
040000             0196  ; FFOBJID	.STRUCT
040000             0197  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0198  ; 	id:		DS	2	; Hosting volume mount ID
040000             0199  ; 	attr:		DS	1	; Object attribute
040000             0200  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0201  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0202  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0203  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0204  ; ;
040000             0205  ; ; File object structure (FIL)
040000             0206  ; ;
040000             0207  ; FIL .STRUCT
040000             0208  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0209  ; 	flag:		DS	1	; File status flags
040000             0210  ; 	err:		DS	1	; Abort flag (error code)
040000             0211  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0212  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0213  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0214  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0215  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0216  ; FIL_SIZE .ENDSTRUCT FIL
040000             0217  ; ;
040000             0218  ; ; Directory object structure (DIR)
040000             0219  ; ;
040000             0220  ; DIR .STRUCT
040000             0221  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0222  ; 	dptr:		DS	4	; Current read/write offset
040000             0223  ; 	clust:		DS	4	; Current cluster
040000             0224  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0225  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0226  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0227  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0228  ; DIR_SIZE .ENDSTRUCT DIR
040000             0229  ; ;
040000             0230  ; ; File information structure (FILINFO)
040000             0231  ; ;
040000             0232  ; FILINFO .STRUCT
040000             0233  ; 	fsize:		DS 	4	; File size
040000             0234  ; 	fdate:		DS	2	; Modified date
040000             0235  ; 	ftime:		DS	2	; Modified time
040000             0236  ; 	fattrib:	DS	1	; File attribute
040000             0237  ; 	altname:	DS	13	; Alternative file name
040000             0238  ; 	fname:		DS	256	; Primary file name
040000             0239  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0240  
040000             0241  ; FFOBJID offsets
040000             0242  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0243  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0244  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0245  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0246  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0247  FFOBJID.objsize:  EQU 11   ; Object size
040000             0248  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0249  
040000             0250  ; FIL offsets (including FFOBJID fields)
040000             0251  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0252  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0253  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0254  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0255  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0256  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0257  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0258  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0259  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0260  
040000             0261  ; DIR offsets (including FFOBJID fields)
040000             0262  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0263  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0264  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0265  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0266  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0267  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0268  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0269  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0270  
040000             0271  ; FILINFO offsets
040000             0272  FILINFO.fsize:    EQU 0    ; File size
040000             0273  FILINFO.fdate:    EQU 4    ; Modified date
040000             0274  FILINFO.ftime:    EQU 6    ; Modified time
040000             0275  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0276  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0277  FILINFO.fname:    EQU 22   ; Primary file name
040000             0278  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0279  
040000             0280  ;
040000             0281  ; Macro for calling the API
040000             0282  ; Parameters:
040000             0283  ; - function: One of the function numbers listed above
040000             0284  ;
040000             0285  			MACRO MOSCALL	function
040000             0286  			LD	A, function
040000             0287  			RST.LIS	08h
040000             0288  			ENDMACRO 	; --- End mos_api.inc ---
040000             0289  
040000             0290  ; --- Begin macros.inc ---
040000             0291  	; Title:	BBC Basic Interpreter - Z80 version
040000             0292  	;		Useful macros
040000             0293  	; Author:	Dean Belfield
040000             0294  	; Created:	12/05/2023
040000             0295  	; Last Updated:	11/06/2023
040000             0296  	;
040000             0297  	; Modinfo:
040000             0298  	; 11/06/2023:	Modified to run in ADL mode
040000             0299  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0300  
040000             0301  	MACRO EXREG	rp1, rp2
040000             0302  		PUSH	rp1
040000             0303  		POP	rp2
040000             0304  	ENDMACRO
040000             0305  
040000             0306  	; MACRO ADD8U_DE	reg
040000             0307  		MACRO ADD8U_DE
040000             0308  		ADD	A, E
040000             0309  		LD	E, A
040000             0310  		ADC	A, D
040000             0311  		SUB	E
040000             0312  		LD	D, A
040000             0313  	ENDMACRO
040000             0314  
040000             0315  	; MACRO ADD8U_HL	reg
040000             0316  	MACRO ADD8U_HL
040000             0317  		ADD	A, L
040000             0318  		LD	L, A
040000             0319  		ADC	A, H
040000             0320  		SUB	L
040000             0321  		LD	H, A
040000             0322  	ENDMACRO
040000             0323  
040000             0324  	MACRO VDU	val
040000             0325  		LD	A, val
040000             0326  		CALL	OSWRCH
040000             0327  	ENDMACRO
040000             0328  
040000             0329  	MACRO SET_GPIO	reg, val
040000             0330  		IN0	A, (reg)
040000             0331  		OR	val
040000             0332  		OUT0	(reg), A
040000             0333  	ENDMACRO
040000             0334  
040000             0335  	MACRO RES_GPIO	reg, val
040000             0336  		PUSH	BC
040000             0337  		LD	A, val
040000             0338  		CPL
040000             0339  		LD	C, A
040000             0340  		IN0	A, (reg)
040000             0341  		AND	C
040000             0342  		OUT0	(reg), A
040000             0343  		POP	BC
040000             0344  	ENDMACRO
040000             0345  ; --- End macros.inc ---
040000             0346  
040000             0347  ; --- Begin equs_top.inc ---
040000             0348  ; --- Begin equs.inc ---
040000             0349  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0350  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0351  PA_DR:			EQU		96h
040000             0352  PA_DDR:			EQU		97h
040000             0353  PA_ALT1:		EQU		98h
040000             0354  PA_ALT2:		EQU		99h
040000             0355  PB_DR:          	EQU		9Ah
040000             0356  PB_DDR:        	 	EQU		9Bh
040000             0357  PB_ALT1:        	EQU		9Ch
040000             0358  PB_ALT2:        	EQU		9Dh
040000             0359  PC_DR:          	EQU		9Eh
040000             0360  PC_DDR:         	EQU		9Fh
040000             0361  PC_ALT1:        	EQU		A0h
040000             0362  PC_ALT2:        	EQU		A1h
040000             0363  PD_DR:          	EQU		A2h
040000             0364  PD_DDR:			EQU		A3h
040000             0365  PD_ALT1:		EQU		A4h
040000             0366  PD_ALT2:		EQU		A5h
040000             0367  GPIOMODE_OUT:		EQU		0	; Output
040000             0368  GPIOMODE_IN:		EQU		1	; Input
040000             0369  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0370  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0371  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0372  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0373  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0374  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0375  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0376  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0377  CR:			EQU     0DH
040000             0378  LF:			EQU     0AH
040000             0379  ESC:			EQU     1BH
040000             0380  ; --- End equs.inc ---
040000             0381  
040000             0382  ; --- Begin eval.asm ---
040000             0383  FUNTOK:			EQU	8DH			; First token number
040000             0384  ANDK:			EQU     80H
040000             0385  DIVK:			EQU     81H
040000             0386  EORK:			EQU     82H
040000             0387  MODK:			EQU     83H
040000             0388  ORK:			EQU     84H
040000             0389  ; --- End eval.asm ---
040000             0390  
040000             0391  ; --- Begin exec.asm ---
040000             0392  ; --- End exec.asm ---
040000             0393  
040000             0394  ; --- Begin fpp.asm ---
040000             0395  BADOP:			EQU     1               ;Bad operation code
040000             0396  DIVBY0:			EQU     18              ;Division by zero
040000             0397  TOOBIG_FP:			EQU     20              ;Too big
040000             0398  NGROOT:			EQU     21              ;Negative root
040000             0399  LOGRNG:			EQU     22              ;Log range
040000             0400  ACLOST:			EQU     23              ;Accuracy lost
040000             0401  EXPRNG:			EQU     24              ;Exp range
040000             0402  ; --- End fpp.asm ---
040000             0403  
040000             0404  ; --- Begin init.asm ---
040000             0405  ; --- End init.asm ---
040000             0406  
040000             0407  ; --- Begin main.asm ---
040000             0408  DATA_:	EQU     DCH
040000             0409  DEF_:	EQU     DDH
040000             0410  DIM:	EQU     DEH
040000             0411  ELSE_:	EQU     8BH
040000             0412  FN:	EQU     A4H
040000             0413  FOR:	EQU     E3H
040000             0414  GOSUB:	EQU     E4H
040000             0415  GOTO:	EQU     E5H
040000             0416  LINE_:	EQU     86H
040000             0417  LINO:	EQU     8DH
040000             0418  LOCAL_:	EQU     EAH
040000             0419  NEXT:	EQU     EDH
040000             0420  OFF_:	EQU     87H
040000             0421  ON_:	EQU     EEH
040000             0422  PROC:	EQU     F2H
040000             0423  REM:	EQU     F4H
040000             0424  REN:	EQU     CCH
040000             0425  REPEAT:	EQU     F5H
040000             0426  RESTOR:	EQU     F7H
040000             0427  SPC:	EQU     89H
040000             0428  STEP:	EQU     88H
040000             0429  TAB:	EQU     8AH
040000             0430  TAND:	EQU     80H
040000             0431  TCALL:	EQU     D6H
040000             0432  TERROR:	EQU     85H
040000             0433  TGOSUB:	EQU     E4H
040000             0434  TGOTO:	EQU     E5H
040000             0435  THEN:	EQU     8CH
040000             0436  TIF:	EQU     E7H
040000             0437  TO:	EQU     B8H
040000             0438  TON:	EQU     EEH
040000             0439  TOR:	EQU     84H
040000             0440  TPROC:	EQU     F2H
040000             0441  TRACE:	EQU     FCH
040000             0442  TSTOP:	EQU     FAH
040000             0443  UNTIL:	EQU     FDH
040000             0444  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040000             0445  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040000             0446  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040000             0447  ; --- End main.asm ---
040000             0448  ; --- End equs_top.inc ---
040000             0449  
040000             0450  ; --- Begin init.asm ---
040000             0451  ;
040000             0452  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0453  ;		Initialisation Code
040000             0454  ; Author:	Dean Belfield
040000             0455  ; Created:	12/05/2023
040000             0456  ; Last Updated:	26/11/2023
040000             0457  ;
040000             0458  ; Modinfo:
040000             0459  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0460  ; 26/11/2023:	Moved the ram clear routine into here
040000             0461  
040000             0462  			; SEGMENT CODE
040000             0463  
040000             0464  			; XDEF	_end
040000             0465  
040000             0466  			; XREF	_main				; In main.asm
040000             0467  
040000             0468  			; XREF	RAM_START			; In ram.asm
040000             0469  			; XREF	RAM_END
040000             0470  
040000             0471  			; .ASSUME	ADL = 1
040000             0472  
040000             0473  			; INCLUDE	"equs.inc"
040000             0474  
040000             0475  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0476  
040000             0477  ;
040000             0478  ; Start in ADL mode
040000             0479  ;
040000 C3 45 00 04 0480  			JP	_start				; Jump to start
040004             0481  ;
040004             0482  ; The header stuff is from byte 64 onwards
040004             0483  ;
040004 42 42 43 42 0484  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040011             0485  
040011 00 00 00 00 0486  			ALIGN	64
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
040040             0487  
040040 4D 4F 53    0488  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0489  			DB	00h				; MOS header version 0
040044 01          0490  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0491  ;
040045             0492  ; And the code follows on immediately after the header
040045             0493  ;
040045 F5          0494  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0495  			PUSH		BC
040047 D5          0496  			PUSH		DE
040048 DD E5       0497  			PUSH		IX
04004A FD E5       0498  			PUSH		IY
04004C             0499  
04004C ED 73 D7 00 0500  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0501  
040051 DD 21 DA 00 0502  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0503  			PUSH		IX
040058 CD 88 00 04 0504  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0505  			POP		IX			; IX: argv
04005E 06 00       0506  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0507  			CALL		_clear_ram
040064 C3 EE 2F 04 0508  			JP		_main			; Start user code
040068             0509  ;
040068             0510  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0511  ;
040068 ED 7B D7 00 0512  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0513  
04006D FD E1       0514  			POP		IY			; Restore the registers
04006F DD E1       0515  			POP		IX
040071 D1          0516  			POP		DE
040072 C1          0517  			POP		BC
040073 F1          0518  			POP		AF
040074 C9          0519  			RET					; Return to MOS
040075             0520  
040075             0521  ;Clear the application memory
040075             0522  ;
040075 C5          0523  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0524  			LD		HL, RAM_START
04007A 11 01 4A 04 0525  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0526  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0527  			XOR		A
040083 77          0528  			LD		(HL), A
040084 ED B0       0529  			LDIR
040086 C1          0530  			POP		BC
040087 C9          0531  			RET
040088             0532  
040088             0533  ; Parse the parameter string into a C array
040088             0534  ; Parameters
040088             0535  ; - HL: Address of parameter string
040088             0536  ; - IX: Address for array pointer storage
040088             0537  ; Returns:
040088             0538  ; -  C: Number of parameters parsed
040088             0539  ;
040088 01 04 00 04 0540  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0541  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0542  			INC	IX
040091 DD 23       0543  			INC	IX
040093 DD 23       0544  			INC	IX
040095 CD D0 00 04 0545  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0546  ;
040099 01 01 00 00 0547  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0548  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0549  ;
04009F             0550  _parse_params_1:
04009F C5          0551  			PUSH	BC			; Stack ARGC
0400A0 E5          0552  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0553  			CALL	_get_token		; Get the next token
0400A5 79          0554  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0555  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0556  			POP	BC			; ARGC
0400A8 B7          0557  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0558  			RET	Z
0400AA             0559  ;
0400AA DD 1F 00    0560  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0561  			PUSH	HL			; DE=HL
0400AE D1          0562  			POP	DE
0400AF CD D0 00 04 0563  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0564  			XOR	A
0400B4 12          0565  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0566  			INC	IX
0400B7 DD 23       0567  			INC	IX
0400B9 DD 23       0568  			INC	IX			; Advance to next pointer position
0400BB 0C          0569  			INC	C			; Increment ARGC
0400BC 79          0570  			LD	A, C			; Check for C >= A
0400BD B8          0571  			CP	B
0400BE 38 DF       0572  			JR	C, _parse_params_1	; And loop
0400C0 C9          0573  			RET
0400C1             0574  
0400C1             0575  ; Get the next token
0400C1             0576  ; Parameters:
0400C1             0577  ; - HL: Address of parameter string
0400C1             0578  ; Returns:
0400C1             0579  ; - HL: Address of first character after token
0400C1             0580  ; -  C: Length of token (in characters)
0400C1             0581  ;
0400C1 0E 00       0582  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0583  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0584  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0585  			RET 	Z
0400C6 FE 0D       0586  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0587  			RET	Z
0400C9 FE 20       0588  			CP	' '			; Exit if space (end of token)
0400CB C8          0589  			RET	Z
0400CC 23          0590  			INC	HL			; Advance to next character
0400CD 0C          0591  			INC 	C			; Increment length
0400CE 18 F3       0592  			JR	@B
0400D0             0593  
0400D0             0594  ; Skip spaces in the parameter string
0400D0             0595  ; Parameters:
0400D0             0596  ; - HL: Address of parameter string
0400D0             0597  ; Returns:
0400D0             0598  ; - HL: Address of next none-space character
0400D0             0599  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0600  ;
0400D0 7E          0601  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0602  			CP	' '			; Exit if not space
0400D3 C0          0603  			RET	NZ
0400D4 23          0604  			INC	HL			; Advance to next character
0400D5 18 F9       0605  			JR	_skip_spaces		; Increment length
0400D7             0606  
0400D7             0607  ; Storage
0400D7             0608  ;
0400D7             0609  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0610  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0611  
04010A             0612  ; --- Begin eval.asm ---
04010A             0613  ;
04010A             0614  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0615  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0616  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0617  ; Modified By:	Dean Belfield
04010A             0618  ; Created:	12/05/2023
04010A             0619  ; Last Updated:	17/08/2023
04010A             0620  ;
04010A             0621  ; Modinfo:
04010A             0622  ; 07/06/2023:	Modified to run in ADL mode
04010A             0623  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0624  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0625  ; 17/08/2023:	Added binary constants
04010A             0626  
04010A             0627  			; .ASSUME	ADL = 1
04010A             0628  
04010A             0629  			; INCLUDE	"equs.inc"
04010A             0630  			; INCLUDE "macros.inc"
04010A             0631  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0632  
04010A             0633  			; SEGMENT CODE
04010A             0634  
04010A             0635  			; XDEF	EXPR
04010A             0636  			; XDEF	EXPRN
04010A             0637  			; XDEF	EXPRI
04010A             0638  			; XDEF	EXPRS
04010A             0639  			; XDEF	ITEMI
04010A             0640  			; XDEF	LOADN
04010A             0641  			; XDEF	LOAD4
04010A             0642  			; XDEF	CONS
04010A             0643  			; XDEF	LOADS
04010A             0644  			; XDEF	SFIX
04010A             0645  			; XDEF	VAL0
04010A             0646  			; XDEF	SEARCH
04010A             0647  			; XDEF	SWAP
04010A             0648  			; XDEF	TEST
04010A             0649  			; XDEF	DECODE
04010A             0650  			; XDEF	HEXSTR
04010A             0651  			; XDEF	STR
04010A             0652  			; XDEF	ZERO
04010A             0653  			; XDEF	PUSHS
04010A             0654  			; XDEF	POPS
04010A             0655  			; XDEF	COMMA
04010A             0656  			; XDEF	BRAKET
04010A             0657  			; XDEF	NXT
04010A             0658  			; XDEF	COUNT0
04010A             0659  
04010A             0660  			; XREF	ADVAL
04010A             0661  			; XREF	FN_EX
04010A             0662  			; XREF	POINT
04010A             0663  			; XREF	USR
04010A             0664  			; XREF	SYNTAX
04010A             0665  			; XREF	ERROR_
04010A             0666  			; XREF	CHECK
04010A             0667  			; XREF	GETVAR
04010A             0668  			; XREF	LISTON
04010A             0669  			; XREF	RANGE
04010A             0670  			; XREF	FPP
04010A             0671  			; XREF	GETCSR
04010A             0672  			; XREF	CHANEL
04010A             0673  			; XREF	OSSTAT
04010A             0674  			; XREF	OSBGET
04010A             0675  			; XREF	LOMEM
04010A             0676  			; XREF	HIMEM
04010A             0677  			; XREF	PAGE_
04010A             0678  			; XREF	TOP
04010A             0679  			; XREF	ERL
04010A             0680  			; XREF	ERR
04010A             0681  			; XREF	COUNT
04010A             0682  			; XREF	OSOPEN
04010A             0683  			; XREF	GETEXT
04010A             0684  			; XREF	GETPTR
04010A             0685  			; XREF	GETIME
04010A             0686  			; XREF	GETIMS
04010A             0687  			; XREF	LEXAN2
04010A             0688  			; XREF	RANDOM
04010A             0689  			; XREF	STORE5
04010A             0690  			; XREF	GETSCHR
04010A             0691  			; XREF	OSRDCH
04010A             0692  			; XREF	OSKEY
04010A             0693  			; XREF	INKEY1
04010A             0694  			; XREF	EXTERR
04010A             0695  ;
04010A             0696  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0697  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0698  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0699  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0700  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0701  ;
04010A             0702  ; BINARY INTEGER REPRESENTATION:
04010A             0703  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0704  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0705  ;
04010A             0706  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0707  ;                             EXPONENT - C
04010A             0708  ;
04010A             0709  
04010A             0710  ;
04010A             0711  ; Table of addresses for functions
04010A             0712  ;
04010A             0713  ; FUNTOK:			EQU	8DH			; First token number
04010A             0714  ;
04010A EB 08 04    0715  FUNTBL:			DW24	DECODE			; Line number
04010D 99 05 04    0716  			DW24	OPENIN			; OPENIN
040110 BB 05 04    0717  			DW24	PTR_EV			; PTR
040113 55 05 04    0718  			DW24	PAGEV			; PAGE
040116 C5 05 04    0719  			DW24	TIMEV			; TIME
040119 41 05 04    0720  			DW24	LOMEMV			; LOMEM
04011C 4B 05 04    0721  			DW24	HIMEMV			; HIMEM
04011F 19 06 04    0722  			DW24	ABSV			; ABS
040122 55 06 04    0723  			DW24	ACS			; ACS
040125 A2 49 04    0724  			DW24	ADVAL			; ADVAL
040128 2A 05 04    0725  			DW24	ASC			; ASC
04012B 4D 06 04    0726  			DW24	ASN			; ASN
04012E 51 06 04    0727  			DW24	ATN			; ATN
040131 F3 04 04    0728  			DW24	BGET			; BGET
040134 39 06 04    0729  			DW24	COS			; COS
040137 80 05 04    0730  			DW24	COUNTV			; COUNT
04013A 21 06 04    0731  			DW24	DEG			; DEG
04013D 74 05 04    0732  			DW24	ERLV			; ERL
040140 7A 05 04    0733  			DW24	ERRV			; ERR
040143 7E 06 04    0734  			DW24	EVAL_			; EVAL
040146 41 06 04    0735  			DW24	EXP			; EXP
040149 B1 05 04    0736  			DW24	EXT			; EXT
04014C 98 09 04    0737  			DW24	ZERO			; FALSE
04014F 87 10 04    0738  			DW24	FN_EX			; FN
040152 11 05 04    0739  			DW24	GET			; GET
040155 00 05 04    0740  			DW24	INKEY			; INKEY
040158 30 07 04    0741  			DW24	INSTR			; INSTR(
04015B 2D 06 04    0742  			DW24	INT_			; INT
04015E 3A 05 04    0743  			DW24	LEN			; LEN
040161 45 06 04    0744  			DW24	LN			; LN
040164 49 06 04    0745  			DW24	LOG			; LOG
040167 1D 06 04    0746  			DW24	NOTK			; NOT
04016A 95 05 04    0747  			DW24	OPENUP			; OPENUP
04016D 92 05 04    0748  			DW24	OPENOT			; OPENOUT
040170 15 06 04    0749  			DW24	PI			; PI
040173 C5 44 04    0750  			DW24	POINT			; POINT(
040176 D2 04 04    0751  			DW24	POS			; POS
040179 25 06 04    0752  			DW24	RAD			; RAD
04017C B2 06 04    0753  			DW24	RND			; RND
04017F 29 06 04    0754  			DW24	SGN			; SGN
040182 3D 06 04    0755  			DW24	SIN			; SIN
040185 31 06 04    0756  			DW24	SQR			; SQR
040188 35 06 04    0757  			DW24	TAN			; TAN
04018B 5F 05 04    0758  			DW24	TOPV			; TO(P)
04018E 0A 06 04    0759  			DW24	TRUE			; TRUE
040191 54 15 04    0760  			DW24	USR			; USR
040194 6F 06 04    0761  			DW24	VAL			; VAL
040197 DB 04 04    0762  			DW24	VPOS			; VPOS
04019A C4 07 04    0763  			DW24	CHRS			; CHRS
04019D CC 07 04    0764  			DW24	GETS			; GETS
0401A0 DD 07 04    0765  			DW24	INKEYS			; INKEYS
0401A3 62 08 04    0766  			DW24	LEFTS			; LEFTS(
0401A6 2A 08 04    0767  			DW24	MIDS			; MIDS(
0401A9 82 08 04    0768  			DW24	RIGHTS			; RIGHTS(
0401AC 4F 09 04    0769  			DW24	STRS			; STR$
0401AF A3 08 04    0770  			DW24	STRING_			; STRINGS(
0401B2 E3 04 04    0771  			DW24	EOF			; EOF
0401B5             0772  ;
0401B5             0773  FUNTBL_END:		EQU	$
0401B5             0774  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0775  ; TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0776  ;
0401B5             0777  ; ANDK:			EQU     80H
0401B5             0778  ; DIVK:			EQU     81H
0401B5             0779  ; EORK:			EQU     82H
0401B5             0780  ; MODK:			EQU     83H
0401B5             0781  ; ORK:			EQU     84H
0401B5             0782  ;
0401B5 F5 05 04    0783  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 FE 05 04    0784  			DW24	SNE			; <>
0401BB EE 05 04    0785  			DW24	SGE			; >=
0401BE DF 05 04    0786  			DW24	SLT			; <
0401C1 05 06 04    0787  			DW24	SEQ			; =
0401C4 E6 05 04    0788  			DW24	SGT			; >
0401C7             0789  ;
0401C7             0790  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0791  ;     Expression type is returned in A'F':
0401C7             0792  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0793  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0794  ; Floating-point or integer result returned in HLH'L'C
0401C7             0795  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0796  ; String result returned in string accumulator, DE set.
0401C7             0797  ;
0401C7             0798  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0799  ;               (2) ^
0401C7             0800  ;               (3) * / MOD DIV
0401C7             0801  ;               (4) + -
0401C7             0802  ;               (5) = <> <= >= > <
0401C7             0803  ;               (6) AND
0401C7             0804  ;               (7) EOR OR
0401C7             0805  
0401C7             0806  ;
0401C7             0807  ; Level 7: EOR and OR
0401C7             0808  ;
0401C7 CD E0 01 04 0809  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0810  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0811  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0812  			CP      ORK			; Is operator OR
0401D1 C0          0813  			RET     NZ			; No, so return
0401D2             0814  ;
0401D2 CD 46 0A 04 0815  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0816  			CALL    EXPR1           	; Get second operand
0401DA CD 55 0A 04 0817  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0818  			JR      EXPR0A          	; And continue
0401E0             0819  ;
0401E0             0820  ; Level 6: AND
0401E0             0821  ;
0401E0 CD F5 01 04 0822  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0823  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0824  			RET     NZ			; No, so return
0401E7 CD 46 0A 04 0825  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0826  			CALL    EXPR2			; Get second operand
0401EF CD 55 0A 04 0827  			CALL    DOIT			; Do the operation
0401F3 18 EF       0828  			JR      EXPR1A			; And continue
0401F5             0829  ;
0401F5             0830  ; Level 5: Comparisons
0401F5             0831  ;
0401F5 CD 67 02 04 0832  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 1D 0A 04 0833  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0834  			RET     NZ			; No, so return
0401FE 47          0835  			LD      B,A			; Store the first operator in B
0401FF FD 23       0836  			INC     IY              	; Bump over operator
040201 CD 78 0A 04 0837  			CALL    NXT			;
040205 CD 1D 0A 04 0838  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0839  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0840  			INC     IY			; Bump over operator
04020D B8          0841  			CP      B			; Compare with first
04020E CA 9F 0C 04 0842  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0843  			ADD     A,B
040213 47          0844  			LD      B,A			; B: Unique code for the compound operator
040214 78          0845  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0846  			EX      AF,AF'
040216 FA 30 02 04 0847  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0848  			EX      AF,AF'
04021B D6 04       0849  			SUB     4
04021D FE 3A       0850  			CP      '>'-4
04021F 20 02       0851  			JR      NZ,EXPR2C
040221 C6 02       0852  			ADD     A,2
040223 CD 48 0A 04 0853  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0854  			CALL    EXPR3
04022B CD 55 0A 04 0855  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0856  			RET
040230             0857  ;
040230 08          0858  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0859  			DEC     A
040232 E6 07       0860  			AND     7
040234 CD B9 09 04 0861  			CALL    PUSHS           	; Save string on the stack
040238 F5          0862  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0863  			CALL    EXPR3           	; Get the second string
04023D 08          0864  			EX      AF,AF'
04023E F2 3B 03 04 0865  			JP      P,TYPE_EV_
040242 F1          0866  			POP     AF
040243 4B          0867  			LD      C,E             	; Length of string #2
040244 D1          0868  			POP     DE
040245 21 00 00 00 0869  			LD      HL,0
040249 39          0870  			ADD     HL,SP
04024A 43          0871  			LD      B,E             	; Length of string #1
04024B D5          0872  			PUSH    DE
04024C 11 00 4A 04 0873  			LD      DE,ACCS
040250 EB          0874  			EX      DE,HL
040251 CD 84 0A 04 0875  			CALL    DISPT2
040255 D1          0876  			POP     DE
040256 EB          0877  			EX      DE,HL
040257 7D          0878  			LD	A,L
040258 21 00 00 00 0879  			LD	HL,0
04025C 6F          0880  			LD	L,A
04025D 39          0881  			ADD     HL,SP
04025E F9          0882  			LD      SP,HL
04025F EB          0883  			EX      DE,HL
040260 AF          0884  			XOR     A               	; Numeric marker
040261 4F          0885  			LD      C,A             	; Integer marker
040262 08          0886  			EX      AF,AF'
040263 FD 7E 00    0887  			LD      A,(IY)
040266 C9          0888  			RET
040267             0889  ;
040267             0890  ; Level 4: + and -
040267             0891  ;
040267 CD C9 02 04 0892  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0893  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0894  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0895  			CP      '+'			; Is it "+"?
040271 C0          0896  			RET     NZ			; No, so return
040272 08          0897  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0898  			JP      M,EXPR3S		; Branch here if string
040277 08          0899  			EX      AF,AF'
040278 CD 46 0A 04 0900  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C9 02 04 0901  			CALL    EXPR4			; Fetch the second operator
040280 CD 55 0A 04 0902  			CALL    DOIT			; Do the operation
040284 18 E5       0903  			JR      EXPR3A			; And continue
040286             0904  ;
040286 08          0905  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0906  			INC     IY              	; Bump past the "+"
040289 CD B9 09 04 0907  			CALL    PUSHS           	; Save the string on the stack
04028D CD C9 02 04 0908  			CALL    EXPR4           	; Fetch the second operator
040291 08          0909  			EX      AF,AF'
040292 F2 3B 03 04 0910  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0911  			LD	BC, 0			; Clear BC
04029A 4B          0912  			LD      C,E             	; C: Length of the second string
04029B D1          0913  			POP     DE
04029C D5          0914  			PUSH    DE
04029D 21 00 4A 04 0915  			LD      HL,ACCS
0402A1 7B          0916  			LD	A,E			;  E: Length of the first string
0402A2 11 00 4A 04 0917  			LD      DE,ACCS
0402A6 5F          0918  			LD	E,A 			; DE: Pointer to the end of the first string
0402A7 79          0919  			LD      A,C
0402A8 B7          0920  			OR      A
0402A9 28 0F       0921  			JR      Z,EXP3S3
0402AB 6F          0922  			LD      L,A             	; Source
0402AC 83          0923  			ADD     A,E
0402AD 5F          0924  			LD      E,A             	; Destination
0402AE 3E 13       0925  			LD      A,19
0402B0 DA B6 37 04 0926  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402B4 D5          0927  			PUSH    DE
0402B5 1D          0928  			DEC     E
0402B6 2D          0929  			DEC     L
0402B7 ED B8       0930  			LDDR                    	; Copy
0402B9 D1          0931  			POP     DE
0402BA D9          0932  EXP3S3:			EXX
0402BB C1          0933  			POP     BC
0402BC CD E6 09 04 0934  			CALL    POPS            	; Restore from stack
0402C0 D9          0935  			EXX
0402C1 F6 80       0936  			OR      80H             	; Flag as a string
0402C3 08          0937  			EX      AF,AF'
0402C4 FD 7E 00    0938  			LD      A,(IY)			; Fetch the next character
0402C7 18 A2       0939  			JR      EXPR3A			; And continue
0402C9             0940  ;
0402C9             0941  ; Level 3: * / MOD DIV
0402C9             0942  ;
0402C9 CD EA 02 04 0943  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402CD FE 2A       0944  EXPR4A:			CP      '*'			; "*" is valid
0402CF 28 0B       0945  			JR      Z,EXPR4B
0402D1 FE 2F       0946  			CP      '/'			; "/" is valid
0402D3 28 07       0947  			JR      Z,EXPR4B
0402D5 FE 83       0948  			CP      MODK			; MOD token is valid
0402D7 28 03       0949  			JR      Z,EXPR4B
0402D9 FE 81       0950  			CP      DIVK			; DIV token is valid
0402DB C0          0951  			RET     NZ			; And return if it is anything else
0402DC CD 46 0A 04 0952  EXPR4B:			CALL    SAVE_EV
0402E0 CD EA 02 04 0953  			CALL    EXPR5
0402E4 CD 55 0A 04 0954  			CALL    DOIT
0402E8 18 E3       0955  			JR      EXPR4A
0402EA             0956  ;
0402EA             0957  ; Level 2: ^
0402EA             0958  ;
0402EA CD CA 03 04 0959  EXPR5:			CALL    ITEM			; Get variable
0402EE B7          0960  			OR      A               	; Test type
0402EF 08          0961  			EX      AF,AF'          	; Save type
0402F0 CD 78 0A 04 0962  EXPR5A:			CALL    NXT			; Skip spaces
0402F4 FE 5E       0963  			CP      '^'			; Is the operator "^"?
0402F6 C0          0964  			RET     NZ			; No, so return
0402F7 CD 46 0A 04 0965  			CALL    SAVE_EV			; Save first operand
0402FB CD CA 03 04 0966  			CALL    ITEM			; Get second operand
0402FF B7          0967  			OR      A			; Test type
040300 08          0968  			EX      AF,AF'			; Save type
040301 CD 55 0A 04 0969  			CALL    DOIT			; Do the operation
040305 18 E9       0970  			JR      EXPR5A			; And continue
040307             0971  ;
040307             0972  ; Evaluate a numeric expression
040307             0973  ;
040307 CD C7 01 04 0974  EXPRN:			CALL    EXPR			; Evaluate expression
04030B 08          0975  			EX      AF,AF'			; Get the type
04030C F0          0976  			RET     P			; And return if it is a number
04030D 18 2C       0977  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030F             0978  ;
04030F             0979  ; Evaluate a fixed-point expression
04030F             0980  ;
04030F CD C7 01 04 0981  EXPRI:			CALL    EXPR			; Evaluate the expression
040313 08          0982  			EX      AF,AF'			; Get the type
040314 F2 67 06 04 0983  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040318 18 21       0984  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031A             0985  ;
04031A             0986  ; Evaluate a string expression
04031A             0987  ;
04031A CD C7 01 04 0988  EXPRS:			CALL    EXPR			; Evaluate the expression
04031E 08          0989  			EX      AF,AF'			; Get the type
04031F F8          0990  			RET     M			; And return if it is a string
040320 18 19       0991  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040322             0992  ;
040322             0993  ; Get a numeric variable
040322             0994  ;
040322 CD CA 03 04 0995  ITEMN:			CALL    ITEM			; Get the variable
040326 B7          0996  			OR      A			; Test the type
040327 F0          0997  			RET     P			; And return if it is a number
040328 18 11       0998  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032A             0999  ;
04032A             1000  ; Get a fixed-point variable
04032A             1001  ;
04032A CD CA 03 04 1002  ITEMI:			CALL    ITEM			; Get the variable
04032E B7          1003  			OR      A			; Test the type
04032F F2 67 06 04 1004  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040333 18 06       1005  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040335             1006  ;
040335             1007  ; Get a string variable
040335             1008  ;
040335 CD CA 03 04 1009  ITEMS:			CALL    ITEM			; Get the variable
040339 B7          1010  			OR      A			; Test the type
04033A F8          1011  			RET     M			; If it is a string, then return
04033B             1012  ;							; Otherwise
04033B 3E 06       1013  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
04033D C3 B6 37 04 1014  			JP      ERROR_
040341             1015  ;
040341             1016  ; Evaluate a bracketed expression
040341             1017  ;
040341 CD C7 01 04 1018  ITEM1:			CALL    EXPR            	; Evaluate the expression
040345 CD 37 0A 04 1019  			CALL    BRAKET			; Check for closing bracket
040349 08          1020  			EX      AF,AF'
04034A C9          1021  			RET
04034B             1022  ;
04034B             1023  ; HEX - Get hexadecimal constant.
04034B             1024  ;   Inputs: ASCII string at (IY)
04034B             1025  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
04034B             1026  ;           IY updated (points to delimiter)
04034B             1027  ;
04034B CD 98 09 04 1028  HEX:			CALL    ZERO			; Set result to 0
04034F CD 00 0A 04 1029  			CALL    HEXDIG			; Fetch the character from IY
040353 38 1B       1030  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040355 FD 23       1031  HEX1:			INC     IY			; Move pointer to next character
040357 E6 0F       1032  			AND     0FH			; Clear the top nibble
040359 06 04       1033  			LD      B,4			; Loop counter
04035B             1034  ;
04035B D9          1035  HEX2:			EXX				; Shift the result left B (4) times. This makes
04035C 52 29       1036  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
04035E D9          1037  			EXX				; .
04035F 52 ED 6A    1038  			ADC.S   HL,HL			; .
040362 10 F7       1039  			DJNZ    HEX2			; And loop
040364 D9          1040  			EXX
040365 B5          1041  			OR      L			; OR in the digit
040366 6F          1042  			LD      L,A
040367 D9          1043  			EXX
040368             1044  ;
040368 CD 00 0A 04 1045  			CALL    HEXDIG			; Fetch the next character
04036C 30 E7       1046  			JR      NC,HEX1			; If it is a HEX digit then loop
04036E AF          1047  			XOR     A			; Clear A
04036F C9          1048  			RET
040370             1049  ;
040370 3E 1C       1050  BADHEX:			LD      A,28
040372 C3 B6 37 04 1051  			JP      ERROR_          	; Error: "Bad HEX"
040376             1052  ;
040376             1053  ; BIN - Get binary constant.
040376             1054  ;   Inputs: ASCII string at (IY)
040376             1055  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040376             1056  ;           IY updated (points to delimiter)
040376             1057  ;
040376 CD 98 09 04 1058  BIN:			CALL    ZERO			; Set result to 0
04037A CD 13 0A 04 1059  			CALL	BINDIG			; Fetch the character from IY
04037E 38 13       1060  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
040380 FD 23       1061  BIN1:			INC	IY			; Move pointer to next character
040382 0F          1062  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
040383 D9          1063  			EXX				;
040384 52 ED 6A    1064  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040387 D9          1065  			EXX
040388 52 ED 6A    1066  			ADC.S	HL,HL
04038B CD 13 0A 04 1067  			CALL	BINDIG			; Fetch the next character
04038F 30 EF       1068  			JR	NC,BIN1
040391 AF          1069  			XOR	A			; Clear A
040392 C9          1070  			RET
040393             1071  ;
040393 3E 1C       1072  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040395 CD CD 37 04 1073  			CALL	EXTERR
040399 42 61 64 20 1074  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0403A4             1075  ;
0403A4             1076  ; MINUS - Unary minus.
0403A4             1077  ;   Inputs: IY = text pointer
0403A4             1078  ;  Outputs: Numeric result, same type as argument.
0403A4             1079  ;           Result in H'L'HLC
0403A4             1080  ;
0403A4 CD 22 03 04 1081  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A8 0D          1082  MINUS0:			DEC     C			; Check exponent (C)
0403A9 0C          1083  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403AA 28 06       1084  			JR      Z,NEGATE_EV        	; So do an integer negation
0403AC             1085  ;
0403AC 7C          1086  			LD      A,H			; Do a FP negation by
0403AD EE 80       1087  			XOR     80H             	; Toggling the sign bit (H)
0403AF 67          1088  			LD      H,A
0403B0 AF          1089  			XOR     A               	; Numeric marker
0403B1 C9          1090  			RET
0403B2             1091  ;
0403B2 D9          1092  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403B3 7C          1093  			LD      A,H			; First do a one's complement by negating all the bytes
0403B4 2F          1094  			CPL
0403B5 67          1095  			LD      H,A
0403B6 7D          1096  			LD      A,L
0403B7 2F          1097  			CPL
0403B8 6F          1098  			LD      L,A
0403B9 D9          1099  			EXX
0403BA 7C          1100  			LD      A,H
0403BB 2F          1101  			CPL
0403BC 67          1102  			LD      H,A
0403BD 7D          1103  			LD      A,L
0403BE 2F          1104  			CPL
0403BF 6F          1105  			LD      L,A
0403C0 D9          1106  ADD1:			EXX				; Then add 1
0403C1 23          1107  			INC     HL
0403C2 7C          1108  			LD      A,H
0403C3 B5          1109  			OR      L
0403C4 D9          1110  			EXX
0403C5 3E 00       1111  			LD      A,0             	; Numeric marker
0403C7 C0          1112  			RET     NZ
0403C8 23          1113  			INC     HL
0403C9 C9          1114  			RET
0403CA             1115  ;
0403CA             1116  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403CA             1117  ; Item type is returned in A:  Bit 7=0 numeric.
0403CA             1118  ;                              Bit 7=1 string.
0403CA             1119  ; Numeric item returned in HLH'L'C.
0403CA             1120  ; String item returned in string accumulator,
0403CA             1121  ;   DE addresses byte after last (E=length).
0403CA             1122  ;
0403CA CD 81 16 04 1123  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403CE CD 78 0A 04 1124  			CALL    NXT			; Skip spaces
0403D2 FD 23       1125  			INC     IY			; Move to the prefix character
0403D4 FE 26       1126  			CP      '&'			; If `&`
0403D6 CA 4B 03 04 1127  			JP      Z,HEX           	; Then get a HEX constant
0403DA FE 25       1128  			CP	'%'			; If '%'
0403DC 28 98       1129  			JR	Z,BIN			; Then get a BINARY constant
0403DE FE 2D       1130  			CP      '-'			; If `-`
0403E0 28 C2       1131  			JR      Z,MINUS         	; Then get a negative number
0403E2 FE 2B       1132  			CP      '+'			; If `+`
0403E4 CA 22 03 04 1133  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E8 FE 28       1134  			CP      '('			; If `(`
0403EA CA 41 03 04 1135  			JP      Z,ITEM1         	; Start of a bracketed expression
0403EE FE 22       1136  			CP      34			; If `"`
0403F0 28 7A       1137  			JR      Z,CONS          	; Start of a string constant
0403F2 FE C6       1138  			CP      TCMD			; Is it out of range of the function table?
0403F4 D2 9F 0C 04 1139  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F8 FE 8D       1140  			CP      FUNTOK			; If it is in range, then
0403FA D2 8B 0A 04 1141  			JP      NC,DISPAT       	; It's a function
0403FE FD 2B       1142  			DEC     IY
040400 FE 3A       1143  			CP      ':'
040402 30 0C       1144  			JR      NC,ITEM2		; VARIABLE?
040404 FE 30       1145  			CP      '0'
040406 D2 93 04 04 1146  			JP      NC,CON			; NUMERIC CONSTANT
04040A FE 2E       1147  			CP      '.'
04040C CA 93 04 04 1148  			JP      Z,CON			; NUMERIC CONSTANT
040410 CD 90 3A 04 1149  ITEM2:			CALL    GETVAR			; VARIABLE
040414 20 37       1150  			JR      NZ,NOSUCH
040416 B7          1151  			OR      A
040417 FA A5 04 04 1152  			JP      M,LOADS			; STRING VARIABLE
04041B B7          1153  LOADN:			OR      A
04041C 28 20       1154  			JR      Z,LOAD1			; BYTE VARIABLE
04041E 0E 00       1155  			LD      C,0
040420 CB 47       1156  			BIT     0,A
040422 28 03       1157  			JR      Z,LOAD4			; INTEGER VARIABLE
040424 DD 4E 04    1158  LOAD5:			LD      C,(IX+4)
040427 D9          1159  LOAD4:			EXX
040428 21 00 00 00 1160  			LD	HL, 0			; TODO: Optimise
04042C DD 6E 00    1161  			LD      L,(IX+0)
04042F DD 66 01    1162  			LD      H,(IX+1)
040432 D9          1163  			EXX
040433 21 00 00 00 1164  			LD	HL, 0			; TODO: Optimise
040437 DD 6E 02    1165  			LD      L,(IX+2)
04043A DD 66 03    1166  			LD      H,(IX+3)
04043D C9          1167  			RET
04043E             1168  ;
04043E 21 00 00 00 1169  LOAD1:			LD      HL,0
040442 D9          1170  			EXX
040443 21 00 00 00 1171  			LD      HL,0			; TODO: Optimise
040447 DD 6E 00    1172  			LD      L,(IX+0)
04044A D9          1173  			EXX
04044B 4C          1174  			LD      C,H
04044C C9          1175  			RET
04044D             1176  ;
04044D DA 9F 0C 04 1177  NOSUCH:			JP      C,SYNTAX
040451 3A 40 4D 04 1178  			LD      A,(LISTON)
040455 CB 6F       1179  			BIT     5,A
040457 3E 1A       1180  			LD      A,26
040459 20 26       1181  			JR      NZ,ERROR0_EV		; Throw "No such variable"
04045B FD 23       1182  NOS1:			INC     IY
04045D CD C5 3C 04 1183  			CALL    RANGE
040461 30 F8       1184  			JR      NC,NOS1
040463 DD 21 40 4C 1185  			LD      IX,PC
       04          
040468 AF          1186  			XOR     A
040469 4F          1187  			LD      C,A
04046A 18 BB       1188  			JR      LOAD4
04046C             1189  ;
04046C             1190  ;CONS - Get string constant from ASCII string.
04046C             1191  ;   Inputs: ASCII string at (IY)
04046C             1192  ;  Outputs: Result in string accumulator.
04046C             1193  ;           D = MS byte of ACCS, E = string length
04046C             1194  ;           A7 = 1 (string marker)
04046C             1195  ;           IY updated
04046C             1196  ;
04046C 11 00 4A 04 1197  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040470 FD 7E 00    1198  CONS3:			LD      A,(IY)			; Fetch the first character and
040473 FD 23       1199  			INC     IY			; Increment the pointer
040475 FE 22       1200  			CP      '"'			; Check for start quote
040477 28 0C       1201  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040479             1202  ;
040479 12          1203  CONS1:			LD      (DE),A			; Store the character in the string accumulator
04047A 1C          1204  			INC     E			; Increment the string accumulator pointer
04047B FE 0D       1205  			CP      CR			; Is it CR
04047D 20 F1       1206  			JR      NZ,CONS3		; No, so keep looping
04047F             1207  ;
04047F 3E 09       1208  			LD      A,9
040481 C3 B6 37 04 1209  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040485             1210  ;
040485 FD 7E 00    1211  CONS2:			LD      A,(IY)			; Fetch the next character
040488 FE 22       1212  			CP      '"'			; Check for end quote?
04048A FD 23       1213  			INC     IY			; Increment the pointer
04048C 28 EB       1214  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
04048E FD 2B       1215  			DEC     IY			;
040490 3E 80       1216  			LD      A,80H           	; String marker
040492 C9          1217  			RET
040493             1218  ;
040493             1219  ;CON - Get unsigned numeric constant from ASCII string.
040493             1220  ;   Inputs: ASCII string at (IY).
040493             1221  ;  Outputs: Variable-type result in HLH'L'C
040493             1222  ;           IY updated (points to delimiter)
040493             1223  ;           A7 = 0 (numeric marker)
040493             1224  ;
040493 FD E5       1225  CON:			PUSH    IY
040495 DD E1       1226  			POP     IX
040497 3E 24       1227  			LD      A,36
040499 CD A2 20 04 1228  			CALL    FPP
04049D 38 E2       1229  			JR      C,ERROR0_EV
04049F DD E5       1230  			PUSH    IX
0404A1 FD E1       1231  			POP     IY
0404A3 AF          1232  			XOR     A
0404A4 C9          1233  			RET
0404A5             1234  ;
0404A5 11 00 4A 04 1235  LOADS:			LD      DE,ACCS			; Where to store the string
0404A9 1F          1236  			RRA
0404AA 30 1A       1237  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404AC             1238  ;
0404AC D9          1239  			EXX				; This block was a call to LOAD4
0404AD DD 6E 00    1240  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404B0 DD 66 01    1241  			LD      H,(IX+1)		; The maximum original string length
0404B3 D9          1242  			EXX
0404B4 DD 27 02    1243  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B7             1244  ;
0404B7 D9          1245  			EXX
0404B8 7D          1246  			LD      A,L
0404B9 D9          1247  			EXX
0404BA B7          1248  			OR      A
0404BB 01 00 00 00 1249  			LD	BC,0			; BC: Number of bytes to copy
0404BF 4F          1250  			LD      C,A
0404C0 3E 80       1251  			LD      A,80H           	; String marker
0404C2 C8          1252  			RET     Z
0404C3 ED B0       1253  			LDIR
0404C5 C9          1254  			RET
0404C6 7E          1255  LOADS2:			LD      A,(HL)
0404C7 12          1256  			LD      (DE),A
0404C8 23          1257  			INC     HL
0404C9 FE 0D       1258  			CP      CR
0404CB 3E 80       1259  			LD      A,80H           	; String marker
0404CD C8          1260  			RET     Z
0404CE 1C          1261  			INC     E
0404CF 20 F5       1262  			JR      NZ,LOADS2
0404D1 C9          1263  			RET                     	; Return null string
0404D2             1264  ;
0404D2             1265  ;VARIABLE-TYPE FUNCTIONS:
0404D2             1266  ;
0404D2             1267  ;Result returned in HLH'L'C (floating point)
0404D2             1268  ;Result returned in HLH'L' (C=0) (integer)
0404D2             1269  ;Result returned in string accumulator & DE (string)
0404D2             1270  ;All registers destroyed.
0404D2             1271  ;IY (text pointer) updated.
0404D2             1272  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404D2             1273  ;
0404D2             1274  ;POS - horizontal cursor position.
0404D2             1275  ;VPOS - vertical cursor position.
0404D2             1276  ;EOF - return status of file.
0404D2             1277  ;BGET - read byte from file.
0404D2             1278  ;INKEY - as GET but wait only n centiseconds.
0404D2             1279  ;GET - wait for keypress and return ASCII value.
0404D2             1280  ;GET(n) - input from Z80 port n.
0404D2             1281  ;ASC - ASCII value of string.
0404D2             1282  ;LEN - length of string.
0404D2             1283  ;LOMEM - location of dynamic variables.
0404D2             1284  ;HIMEM - top of available RAM.
0404D2             1285  ;PAGE - start of current text page.
0404D2             1286  ;TOP - address of first free byte after program.
0404D2             1287  ;ERL - line number where last error occurred.
0404D2             1288  ;ERR - number of last error.
0404D2             1289  ;COUNT - number of printing characters since CR.
0404D2             1290  ;Results are integer numeric.
0404D2             1291  ;
0404D2 CD 22 3F 04 1292  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D6 EB          1293  			EX      DE,HL			;  L: The X cursor position
0404D7 C3 86 05 04 1294  			JP      COUNT1			; Return an 8-bit value
0404DB             1295  ;
0404DB CD 22 3F 04 1296  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DF C3 86 05 04 1297  			JP      COUNT1			; Return an 8-bit value
0404E3             1298  ;
0404E3 CD B8 18 04 1299  EOF:			CALL    CHANEL			; Check for EOF
0404E7 CD AB 43 04 1300  			CALL    OSSTAT
0404EB CA 0A 06 04 1301  			JP      Z,TRUE			; Yes, so return true
0404EF C3 98 09 04 1302  			JP      ZERO			; Otherwise return false (zero)
0404F3             1303  ;
0404F3 CD B8 18 04 1304  BGET:			CALL    CHANEL          	; Channel number
0404F7 CD 9A 43 04 1305  			CALL    OSBGET
0404FB 6F          1306  			LD      L,A
0404FC C3 84 05 04 1307  			JP      COUNT0			; Return an 8-bit value
040500             1308  ;
040500 CD 2A 03 04 1309  INKEY:			CALL    ITEMI			; Get the argument
040504 CB 7C       1310  			BIT	7, H			; Check the sign
040506 D9          1311  			EXX				; HL: The argument
040507 C2 F0 07 04 1312  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
04050B CD E2 07 04 1313  			CALL	INKEY0 			; Do INKEY(n)
04050F 18 1D       1314  			JR      ASC0			; Return a numeric value
040511             1315  ;
040511 CD 78 0A 04 1316  GET:			CALL    NXT			; Skip whitespace
040515 FE 28       1317  			CP      '('			; Is it GET(
040517 20 0B       1318  			JR      NZ,GET0			; No, so get a keyboard character
040519 CD 2A 03 04 1319  			CALL    ITEMI           	; Yes, so fetch the port address
04051D D9          1320  			EXX
04051E 44          1321  			LD      B,H			; BC: The port address
04051F 4D          1322  			LD      C,L
040520 ED 68       1323  			IN      L,(C)           	;  L: Input from port BC
040522 18 60       1324  			JR      COUNT0			; Return an 8-bit value
040524             1325  ;
040524 CD CC 07 04 1326  GET0:			CALL    GETS			; Read the keyboard character
040528 18 0A       1327  			JR      ASC1			; And return the value
04052A             1328  ;
04052A CD 35 03 04 1329  ASC:			CALL    ITEMS			; Get the string argument argument
04052E AF          1330  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052F BB          1331  			CP      E			; Is the pointer 0
040530 CA 0A 06 04 1332  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
040534 2A 00 4A 04 1333  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040538 18 4A       1334  			JR      COUNT0			; An 8-bit value
04053A             1335  ;
04053A CD 35 03 04 1336  LEN:			CALL    ITEMS			; Get the string argument
04053E EB          1337  			EX      DE,HL			; HL: Pointer into ACCS
04053F 18 43       1338  			JR      COUNT0			; Return L
040541             1339  ;
040541 2A 1A 4D 04 1340  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040545 3A 1C 4D 04 1341  			LD	A, (LOMEM+2)
040549 18 41       1342  			JR      COUNT2			; A 24-bit value
04054B             1343  ;
04054B 2A 20 4D 04 1344  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054F 3A 22 4D 04 1345  			LD	A, (HIMEM+2)
040553 18 37       1346  			JR      COUNT2			; A 24-bit value
040555             1347  ;
040555 2A 14 4D 04 1348  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040559 3A 16 4D 04 1349  			LD	A, (PAGE_+2)		; A 24-bit value
04055D 18 2D       1350  			JR      COUNT2
04055F             1351  ;
04055F FD 7E 00    1352  TOPV:			LD      A,(IY)			; Return the TOP system variable
040562 FD 23       1353  			INC     IY              	; Skip "P"
040564 FE 50       1354  			CP      'P'
040566 C2 9F 0C 04 1355  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
04056A 2A 17 4D 04 1356  			LD      HL,(TOP)
04056E 3A 19 4D 04 1357  			LD	A, (TOP+2)
040572 18 18       1358  			JR      COUNT2
040574             1359  ;
040574 2A 33 4D 04 1360  ERLV:			LD      HL,(ERL)		; Return the error line
040578 18 0C       1361  			JR      COUNT1			; A 16-bit value
04057A             1362  ;
04057A 2A 3F 4D 04 1363  ERRV:			LD      HL,(ERR)		; Return the error value
04057E 18 04       1364  			JR      COUNT0			; An 8-bit value
040580             1365  ;
040580 2A 3D 4D 04 1366  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
040584             1367  
040584 26 00       1368  COUNT0:			LD      H,0			; Return L
040586 D9          1369  COUNT1:			EXX				; Return HL
040587 AF          1370  			XOR     A
040588 4F          1371  			LD      C,A             	; Integer marker
040589 67          1372  			LD      H,A
04058A 6F          1373  			LD      L,A
04058B C9          1374  			RET
04058C D9          1375  COUNT2:			EXX
04058D 6F          1376  			LD	L,A
04058E AF          1377  			XOR	A
04058F 4F          1378  			LD	C,A			; Integer marker
040590 67          1379  			LD	H,A
040591 C9          1380  			RET
040592             1381  ;
040592             1382  ;OPENIN - Open a file for reading.
040592             1383  ;OPENOT - Open a file for writing.
040592             1384  ;OPENUP - Open a file for reading or writing.
040592             1385  ;Result is integer channel number (0 if error)
040592             1386  ;
040592 AF          1387  OPENOT:			XOR     A			; Open for writing
040593 18 06       1388  			JR	OPENIN_1
040595             1389  ;
040595 3E 02       1390  OPENUP:			LD      A,2			; Open for reading / writing
040597 18 02       1391  			JR	OPENIN_1
040599             1392  ;
040599 3E 01       1393  OPENIN:			LD      A,1			; Open for reading
04059B             1394  ;
04059B F5          1395  OPENIN_1:		PUSH    AF              	; Save OPEN type
04059C CD 35 03 04 1396  			CALL    ITEMS           	; Fetch the filename
0405A0 3E 0D       1397  			LD      A,CR
0405A2 12          1398  			LD      (DE),A
0405A3 F1          1399  			POP     AF              	; Restore the OPEN type
0405A4 C6 FF       1400  			ADD     A,-1            	; Affect the flags
0405A6 21 00 4A 04 1401  			LD      HL,ACCS
0405AA CD 83 43 04 1402  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405AE 6F          1403  			LD      L,A			; L: Channel number
0405AF 18 D3       1404  			JR      COUNT0			; Return channel number to BASIC
0405B1             1405  ;
0405B1             1406  ;EXT - Return length of file.
0405B1             1407  ;PTR_EV - Return current file pointer.
0405B1             1408  ;Results are integer numeric.
0405B1             1409  ;
0405B1 CD B8 18 04 1410  EXT:			CALL    CHANEL
0405B5 CD E1 43 04 1411  			CALL    GETEXT
0405B9 18 15       1412  			JR      TIME0
0405BB             1413  ;
0405BB CD B8 18 04 1414  PTR_EV:			CALL    CHANEL
0405BF CD B5 43 04 1415  			CALL    GETPTR
0405C3 18 0B       1416  			JR      TIME0
0405C5             1417  ;
0405C5             1418  ;TIME - Return current value of elapsed time.
0405C5             1419  ;Result is integer numeric.
0405C5             1420  ;
0405C5 FD 7E 00    1421  TIMEV:			LD      A,(IY)
0405C8 FE 24       1422  			CP      '$'
0405CA 28 0A       1423  			JR      Z,TIMEVS
0405CC CD 02 3F 04 1424  			CALL    GETIME
0405D0 D5          1425  TIME0:			PUSH    DE
0405D1 D9          1426  			EXX
0405D2 E1          1427  			POP     HL
0405D3 AF          1428  			XOR     A
0405D4 4F          1429  			LD      C,A
0405D5 C9          1430  			RET
0405D6             1431  ;
0405D6             1432  ;TIME$ - Return date/time string.
0405D6             1433  ;Result is string
0405D6             1434  ;
0405D6 FD 23       1435  TIMEVS:			INC     IY              ;SKIP $
0405D8 CD FA 43 04 1436  			CALL    GETIMS
0405DC 3E 80       1437  			LD      A,80H           ;MARK STRING
0405DE C9          1438  			RET
0405DF             1439  ;
0405DF             1440  ;String comparison:
0405DF             1441  ;
0405DF CD 94 09 04 1442  SLT:			CALL    SCP
0405E3 D0          1443  			RET     NC
0405E4 18 24       1444  			JR      TRUE
0405E6             1445  ;
0405E6 CD 94 09 04 1446  SGT:			CALL    SCP
0405EA C8          1447  			RET     Z
0405EB D8          1448  			RET     C
0405EC 18 1C       1449  			JR      TRUE
0405EE             1450  ;
0405EE CD 94 09 04 1451  SGE:			CALL    SCP
0405F2 D8          1452  			RET     C
0405F3 18 15       1453  			JR      TRUE
0405F5             1454  ;
0405F5 CD 94 09 04 1455  SLE:			CALL    SCP
0405F9 28 0F       1456  			JR      Z,TRUE
0405FB D0          1457  			RET     NC
0405FC 18 0C       1458  			JR      TRUE
0405FE             1459  ;
0405FE CD 94 09 04 1460  SNE:			CALL    SCP
040602 C8          1461  			RET     Z
040603 18 05       1462  			JR      TRUE
040605             1463  ;
040605 CD 94 09 04 1464  SEQ:			CALL    SCP
040609 C0          1465  			RET     NZ
04060A 3E FF       1466  TRUE:			LD      A,-1
04060C D9          1467  			EXX
04060D 67          1468  			LD      H,A
04060E 6F          1469  			LD      L,A
04060F D9          1470  			EXX
040610 67          1471  			LD      H,A
040611 6F          1472  			LD      L,A
040612 3C          1473  			INC     A
040613 4F          1474  			LD      C,A
040614 C9          1475  			RET
040615             1476  ;
040615             1477  ;PI - Return PI (3.141592654)
040615             1478  ;Result is floating-point numeric.
040615             1479  ;
040615 3E 23       1480  PI:			LD      A,35
040617 18 44       1481  			JR      FPP1
040619             1482  ;
040619             1483  ;ABS - Absolute value
040619             1484  ;Result is numeric, variable type.
040619             1485  ;
040619 3E 10       1486  ABSV:			LD      A,16
04061B 18 3A       1487  			JR      FPPN
04061D             1488  ;
04061D             1489  ;NOT - Complement integer.
04061D             1490  ;Result is integer numeric.
04061D             1491  ;
04061D 3E 1A       1492  NOTK:			LD      A,26
04061F 18 36       1493  			JR      FPPN
040621             1494  ;
040621             1495  ;DEG - Convert radians to degrees
040621             1496  ;Result is floating-point numeric.
040621             1497  ;
040621 3E 15       1498  DEG:			LD      A,21
040623 18 32       1499  			JR      FPPN
040625             1500  ;
040625             1501  ;RAD - Convert degrees to radians
040625             1502  ;Result is floating-point numeric.
040625             1503  ;
040625 3E 1B       1504  RAD:			LD      A,27
040627 18 2E       1505  			JR      FPPN
040629             1506  ;
040629             1507  ;SGN - Return -1, 0 or +1
040629             1508  ;Result is integer numeric.
040629             1509  ;
040629 3E 1C       1510  SGN:			LD      A,28
04062B 18 2A       1511  			JR      FPPN
04062D             1512  ;
04062D             1513  ;INT - Floor function
04062D             1514  ;Result is integer numeric.
04062D             1515  ;
04062D 3E 17       1516  INT_:			LD      A,23
04062F 18 26       1517  			JR      FPPN
040631             1518  ;
040631             1519  ;SQR - square root
040631             1520  ;Result is floating-point numeric.
040631             1521  ;
040631 3E 1E       1522  SQR:			LD      A,30
040633 18 22       1523  			JR      FPPN
040635             1524  ;
040635             1525  ;TAN - Tangent function
040635             1526  ;Result is floating-point numeric.
040635             1527  ;
040635 3E 1F       1528  TAN:			LD      A,31
040637 18 1E       1529  			JR      FPPN
040639             1530  ;
040639             1531  ;COS - Cosine function
040639             1532  ;Result is floating-point numeric.
040639             1533  ;
040639 3E 14       1534  COS:			LD      A,20
04063B 18 1A       1535  			JR      FPPN
04063D             1536  ;
04063D             1537  ;SIN - Sine function
04063D             1538  ;Result is floating-point numeric.
04063D             1539  ;
04063D 3E 1D       1540  SIN:			LD      A,29
04063F 18 16       1541  			JR      FPPN
040641             1542  ;
040641             1543  ;EXP - Exponential function
040641             1544  ;Result is floating-point numeric.
040641             1545  ;
040641 3E 16       1546  EXP:			LD      A,22
040643 18 12       1547  			JR      FPPN
040645             1548  ;
040645             1549  ;LN - Natural log.
040645             1550  ;Result is floating-point numeric.
040645             1551  ;
040645 3E 18       1552  LN:			LD      A,24
040647 18 0E       1553  			JR      FPPN
040649             1554  ;
040649             1555  ;LOG - base-10 logarithm.
040649             1556  ;Result is floating-point numeric.
040649             1557  ;
040649 3E 19       1558  LOG:			LD      A,25
04064B 18 0A       1559  			JR      FPPN
04064D             1560  ;
04064D             1561  ;ASN - Arc-sine
04064D             1562  ;Result is floating-point numeric.
04064D             1563  ;
04064D 3E 12       1564  ASN:			LD      A,18
04064F 18 06       1565  			JR      FPPN
040651             1566  ;
040651             1567  ;ATN - arc-tangent
040651             1568  ;Result is floating-point numeric.
040651             1569  ;
040651 3E 13       1570  ATN:			LD      A,19
040653 18 02       1571  			JR      FPPN
040655             1572  ;
040655             1573  ;ACS - arc-cosine
040655             1574  ;Result is floating point numeric.
040655             1575  ;
040655 3E 11       1576  ACS:			LD      A,17
040657 F5          1577  FPPN:			PUSH    AF
040658 CD 22 03 04 1578  			CALL    ITEMN
04065C F1          1579  			POP     AF
04065D CD A2 20 04 1580  FPP1:			CALL    FPP
040661 DA B6 37 04 1581  			JP      C,ERROR_
040665 AF          1582  			XOR     A
040666 C9          1583  			RET
040667             1584  ;
040667             1585  ;SFIX - Convert to fixed-point notation
040667             1586  ;
040667 3E 26       1587  SFIX:			LD      A,38
040669 18 F2       1588  			JR      FPP1
04066B             1589  ;
04066B             1590  ;SFLOAT - Convert to floating-point notation
04066B             1591  ;
04066B 3E 27       1592  SFLOAT:			LD      A,39
04066D 18 EE       1593  			JR      FPP1
04066F             1594  ;
04066F             1595  ;VAL - Return numeric value of string.
04066F             1596  ;Result is variable type numeric.
04066F             1597  ;
04066F CD 35 03 04 1598  VAL:			CALL    ITEMS
040673 AF          1599  VAL0:			XOR     A
040674 12          1600  			LD      (DE),A
040675 DD 21 00 4A 1601  			LD      IX,ACCS
       04          
04067A 3E 24       1602  			LD      A,36
04067C 18 DF       1603  			JR      FPP1
04067E             1604  ;
04067E             1605  ;EVAL - Pass string to expression evaluator.
04067E             1606  ;Result is variable type (numeric or string).
04067E             1607  ;
04067E CD 35 03 04 1608  EVAL_:			CALL    ITEMS
040682 3E 0D       1609  			LD      A,CR
040684 12          1610  			LD      (DE),A
040685 FD E5       1611  			PUSH    IY
040687 11 00 4A 04 1612  			LD      DE,ACCS
04068B FD 21 00 4A 1613  			LD      IY,ACCS
       04          
040690 0E 00       1614  			LD      C,0
040692 CD F5 3C 04 1615  			CALL    LEXAN2          ;TOKENISE
040696 12          1616  			LD      (DE),A
040697 13          1617  			INC     DE
040698 AF          1618  			XOR     A
040699 CD B9 09 04 1619  			CALL    PUSHS           ;PUT ON STACK
04069D FD 21 03 00 1620  			LD      IY,SIZEW	;WAS 2
       00          
0406A2 FD 39       1621  			ADD     IY,SP
0406A4 CD C7 01 04 1622  			CALL    EXPR
0406A8 FD E1       1623  			POP     IY
0406AA FD 39       1624  			ADD     IY,SP
0406AC FD F9       1625  			LD      SP,IY           ;ADJUST STACK POINTER
0406AE FD E1       1626  			POP     IY
0406B0 08          1627  			EX      AF,AF'
0406B1 C9          1628  			RET
0406B2             1629  ;
0406B2             1630  ;RND - Random number function.
0406B2             1631  ; RND gives random integer 0-&FFFFFFFF
0406B2             1632  ; RND(-n) seeds random number & returns -n.
0406B2             1633  ; RND(0) returns last value in RND(1) form.
0406B2             1634  ; RND(1) returns floating-point 0-0.99999999.
0406B2             1635  ; RND(n) returns random integer 1-n.
0406B2             1636  ;
0406B2 DD 21 38 4D 1637  RND:			LD      IX,RANDOM
       04          
0406B7 CD 78 0A 04 1638  			CALL    NXT
0406BB FE 28       1639  			CP      '('
0406BD 28 20       1640  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BF CD 24 04 04 1641  			CALL    LOAD5
0406C3 CB 19       1642  RND1:			RR      C
0406C5 06 20       1643  			LD      B,32
0406C7 D9          1644  RND2:			EXX                     ;CALCULATE NEXT
0406C8 52 ED 6A    1645  			ADC.S   HL,HL
0406CB D9          1646  			EXX
0406CC 52 ED 6A    1647  			ADC.S   HL,HL
0406CF CB 5D       1648  			BIT     3,L
0406D1 28 01       1649  			JR      Z,RND3
0406D3 3F          1650  			CCF
0406D4 10 F1       1651  RND3:			DJNZ    RND2
0406D6 CB 11       1652  RND4:			RL      C               ;SAVE CARRY
0406D8 CD 0D 16 04 1653  			CALL    STORE5          ;STORE NEW NUMBER
0406DC AF          1654  			XOR     A
0406DD 4F          1655  			LD      C,A
0406DE C9          1656  			RET
0406DF CD 2A 03 04 1657  RND5:			CALL    ITEMI
0406E3 DD 21 38 4D 1658  			LD      IX,RANDOM
       04          
0406E8 CB 7C       1659  			BIT     7,H             ;NEGATIVE?
0406EA 37          1660  			SCF
0406EB 20 E9       1661  			JR      NZ,RND4         ;SEED
0406ED CD E4 08 04 1662  			CALL    TEST
0406F1 F5          1663  			PUSH    AF
0406F2 CD DC 08 04 1664  			CALL    SWAP
0406F6 D9          1665  			EXX
0406F7 CD 24 04 04 1666  			CALL    LOAD5
0406FB C4 C3 06 04 1667  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FF D9          1668  			EXX                     ;SCRAMBLE (CARE!)
040700 0E 7F       1669  			LD      C,7FH
040702 CB 7C       1670  RND6:			BIT     7,H             ;FLOAT
040704 20 0A       1671  			JR      NZ,RND7
040706 D9          1672  			EXX
040707 52 29       1673  			ADD.S   HL,HL
040709 D9          1674  			EXX
04070A 52 ED 6A    1675  			ADC.S   HL,HL
04070D 0D          1676  			DEC     C
04070E 20 F2       1677  			JR      NZ,RND6
040710 CB BC       1678  RND7:			RES     7,H             ;POSITIVE 0-0.999999
040712 F1          1679  			POP     AF
040713 C8          1680  			RET     Z               ;ZERO ARGUMENT
040714 D9          1681  			EXX
040715 7B          1682  			LD      A,E
040716 3D          1683  			DEC     A
040717 B2          1684  			OR      D
040718 D9          1685  			EXX
040719 B3          1686  			OR      E
04071A B2          1687  			OR      D
04071B C8          1688  			RET     Z               ;ARGUMENT=1
04071C 06 00       1689  			LD      B,0             ;INTEGER MARKER
04071E 3E 0A       1690  			LD      A,10
040720 CD A2 20 04 1691  			CALL    FPP             ;MULTIPLY
040724 DA B6 37 04 1692  			JP      C,ERROR_
040728 CD 67 06 04 1693  			CALL    SFIX
04072C C3 C0 03 04 1694  			JP      ADD1
040730             1695  ;
040730             1696  ; INSTR - String search.
040730             1697  ; Result is integer numeric.
040730             1698  ;
040730 CD 26 0A 04 1699  INSTR:			CALL    EXPRSC			; Get the first string expression
040734 CD B9 09 04 1700  			CALL    PUSHS           	; Push the string onto the stack
040738 CD 1A 03 04 1701  			CALL    EXPRS           	; Get the second string expression
04073C C1          1702  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
04073D 21 00 00 00 1703  			LD      HL,0
040741 39          1704  			ADD     HL,SP           	; HL: Pointer to main string
040742 C5          1705  			PUSH    BC              	;  C: Main string length
040743 43          1706  			LD      B,E             	;  B: Sub-string length
040744 CD 78 0A 04 1707  			CALL    NXT			; Skip whitespace
040748 FE 2C       1708  			CP      ','			; Check if there is a comma for the third parameter
04074A 3E 00       1709  			LD      A,0			;  A: Default start position in string
04074C 20 1A       1710  			JR      NZ,INSTR1		; No, so skip the next bit
04074E FD 23       1711  			INC     IY              	; Skip the comma
040750 C5          1712  			PUSH    BC              	; Save the lengths
040751 E5          1713  			PUSH    HL              	; Save the pointer to the main string
040752 CD B9 09 04 1714  			CALL    PUSHS			; Push the string onto the stack
040756 CD 0F 03 04 1715  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
04075A C1          1716  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
04075B CD E6 09 04 1717  			CALL    POPS			; Pop the string off the stack
04075F E1          1718  			POP     HL              	; Restore the pointer to the main string
040760 C1          1719  			POP     BC              	; Restore the lengths
040761 D9          1720  			EXX
040762 7D          1721  			LD      A,L			; A: The start position in the  string
040763 D9          1722  			EXX
040764 B7          1723  			OR      A			; Set the flags
040765 28 01       1724  			JR      Z,INSTR1		; If it is zero, then skip
040767 3D          1725  			DEC     A
040768 11 00 4A 04 1726  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
04076C CD 8A 07 04 1727  			CALL    SEARCH			; Do the search
040770 D1          1728  			POP     DE
040771 28 03       1729  			JR      Z,INSTR2        	; NB: Carry cleared
040773 ED 62       1730  			SBC     HL,HL
040775 39          1731  			ADD     HL,SP
040776 ED 72       1732  INSTR2:			SBC     HL,SP
040778 EB          1733  			EX      DE,HL
040779 7D          1734  			LD	A,L
04077A 21 00 00 00 1735  			LD      HL,0
04077E 6F          1736  			LD	L,A
04077F 39          1737  			ADD     HL,SP
040780 F9          1738  			LD      SP,HL
040781 EB          1739  			EX      DE,HL
040782 CD 37 0A 04 1740  			CALL    BRAKET			; Check for closing bracket
040786 C3 86 05 04 1741  			JP      COUNT1			; Return a numeric integer
04078A             1742  ;
04078A             1743  ; SEARCH - Search string for sub-string
04078A             1744  ;    Inputs: Main string at HL length C
04078A             1745  ;            Sub-string  at DE length B
04078A             1746  ;            Starting offset A
04078A             1747  ;   Outputs: NZ - not found
04078A             1748  ;            Z - found at location HL-1
04078A             1749  ;            Carry always cleared
04078A             1750  ;
04078A C5          1751  SEARCH:			PUSH    BC			; Add the starting offset to HL
04078B 01 00 00 00 1752  			LD      BC,0
04078F 4F          1753  			LD      C,A
040790 09          1754  			ADD     HL,BC           	; New start address
040791 C1          1755  			POP     BC
040792 91          1756  			SUB     C			; If the starting offset > main string length, then do nothing
040793 30 2C       1757  			JR      NC,SRCH4
040795 ED 44       1758  			NEG
040797 4F          1759  			LD      C,A             	; Remaining length
040798             1760  ;
040798 C5          1761  SRCH1:			PUSH    BC
040799 79          1762  			LD	A,C
04079A 01 00 00 00 1763  			LD	BC,0
04079E 4F          1764  			LD	C,A
04079F 1A          1765  			LD      A,(DE)
0407A0 ED B1       1766  			CPIR                    	; Find the first character
0407A2 79          1767  			LD      A,C
0407A3 C1          1768  			POP     BC
0407A4 20 1B       1769  			JR      NZ,SRCH4
0407A6 4F          1770  			LD      C,A
0407A7             1771  ;
0407A7             1772  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A7             1773  ;
0407A7 05          1774  			DEC     B			; Bug fix
0407A8 B8          1775  			CP      B			; Bug fix
0407A9 04          1776  			INC     B			; Bug fix
0407AA 38 15       1777  			JR      C,SRCH4			; Bug fix
0407AC             1778  ;
0407AC C5          1779  			PUSH    BC
0407AD D5          1780  			PUSH    DE
0407AE E5          1781  			PUSH    HL
0407AF 05          1782  			DEC     B
0407B0 28 08       1783  			JR      Z,SRCH3         	; Found!
0407B2 13          1784  SRCH2:			INC     DE
0407B3 1A          1785  			LD      A,(DE)
0407B4 BE          1786  			CP      (HL)
0407B5 20 03       1787  			JR      NZ,SRCH3
0407B7 23          1788  			INC     HL
0407B8 10 F8       1789  			DJNZ    SRCH2
0407BA E1          1790  SRCH3:			POP     HL
0407BB D1          1791  			POP     DE
0407BC C1          1792  			POP     BC
0407BD 20 D9       1793  			JR      NZ,SRCH1
0407BF AF          1794  			XOR     A               	; Flags: Z, NC
0407C0 C9          1795  			RET                     	; Found
0407C1             1796  ;
0407C1 F6 FF       1797  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407C3 C9          1798  			RET                     	; Not found
0407C4             1799  ;
0407C4             1800  ;CHRS - Return character with given ASCII value.
0407C4             1801  ;Result is string.
0407C4             1802  ;
0407C4 CD 2A 03 04 1803  CHRS:			CALL    ITEMI
0407C8 D9          1804  			EXX
0407C9 7D          1805  			LD      A,L
0407CA 18 0E       1806  			JR      GET1
0407CC             1807  ;
0407CC             1808  ;GETS - Return key pressed as stringor character at position (X,Y).
0407CC             1809  ;Result is string.
0407CC             1810  ;
0407CC CD 78 0A 04 1811  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407D0 FE 28       1812  			CP	'('
0407D2 CA 58 44 04 1813  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D6 CD 7F 3F 04 1814  			CALL    OSRDCH
0407DA 37          1815  GET1:			SCF
0407DB 18 09       1816  			JR      INKEY1
0407DD             1817  ;
0407DD             1818  ; INKEYS - Wait up to n centiseconds for keypress.
0407DD             1819  ;          Return key pressed as string or null
0407DD             1820  ;          string if time elapsed.
0407DD             1821  ; Result is string.
0407DD             1822  ;
0407DD CD 2A 03 04 1823  INKEYS:			CALL    ITEMI			; Fetch the argument
0407E1 D9          1824  			EXX
0407E2 CD 88 3F 04 1825  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E6 11 00 4A 04 1826  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407EA 12          1827  			LD      (DE),A
0407EB 3E 80       1828  			LD      A,80H
0407ED D0          1829  			RET     NC
0407EE 1C          1830  			INC     E
0407EF C9          1831  			RET
0407F0             1832  ;
0407F0             1833  ; INKEYM - Check immediately whether a given key is being pressed
0407F0             1834  ; Result is integer numeric
0407F0             1835  ;
0407F0             1836  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407F0 3E 1E       0001M 			LD	A, function
0407F2 49 CF       0002M 			RST.LIS	08h
0407F4 23          1837  			INC	HL			; Index from 0
0407F5 7D          1838  			LD	A, L			; Negate the LSB of the answer
0407F6 ED 44       1839  			NEG
0407F8 4F          1840  			LD	C, A			;  E: The positive keycode value
0407F9 3E 01       1841  			LD	A, 1			; Throw an "Out of range" error
0407FB FA B6 37 04 1842  			JP	M, ERROR_		; if the argument < - 128
0407FF             1843  ;
0407FF 21 22 08 04 1844  			LD	HL, BITLOOKUP		; HL: The bit lookup table
040803 11 00 00 00 1845  			LD	DE, 0
040807 79          1846  			LD	A, C
040808 E6 07       1847  			AND	00000111b		; Just need the first three bits
04080A 5F          1848  			LD	E, A			; DE: The bit number
04080B 19          1849  			ADD	HL, DE
04080C 46          1850  			LD	B, (HL)			;  B: The mask
04080D             1851  ;
04080D 79          1852  			LD	A, C			; Fetch the keycode again
04080E E6 78       1853  			AND	01111000b		; And divide by 8
040810 0F          1854  			RRCA
040811 0F          1855  			RRCA
040812 0F          1856  			RRCA
040813 5F          1857  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
040814 DD 19       1858  			ADD	IX, DE			; IX: The address
040816 78          1859  			LD	A, B			;  B: The mask
040817 DD A6 00    1860  			AND	(IX+0)			; Check whether the bit is set
04081A CA 98 09 04 1861  			JP	Z, ZERO			; No, so return 0
04081E C3 0A 06 04 1862  			JP	TRUE			; Otherwise return -1
040822             1863  ;
040822             1864  ; A bit lookup table
040822             1865  ;
040822 01 02 04 08 1866  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040826 10 20 40 80 1867  			DB	10h, 20h, 40h, 80h
04082A             1868  ;
04082A             1869  ; MID$ - Return sub-string.
04082A             1870  ; Result is string.
04082A             1871  ;
04082A CD 26 0A 04 1872  MIDS:			CALL    EXPRSC			; Get the first string expression
04082E CD B9 09 04 1873  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040832 CD 0F 03 04 1874  			CALL    EXPRI			; Get the second expression
040836 C1          1875  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040837 CD E6 09 04 1876  			CALL    POPS			; Pop the string back off the stack to the string accumulator
04083B D9          1877  			EXX
04083C 7D          1878  			LD      A,L			; A: The start index
04083D D9          1879  			EXX
04083E B7          1880  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083F 28 0E       1881  			JR      Z,MIDS1
040841 3D          1882  			DEC     A
040842 6F          1883  			LD      L,A			; L: The start index - 1
040843 93          1884  			SUB     E			; Subtract from the string length
040844 1E 00       1885  			LD      E,0			; Preemptively set the string length to 0
040846 30 07       1886  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040848 ED 44       1887  			NEG				; Negate the answer and
04084A 4F          1888  			LD      C,A			; C: Number of bytes to copy
04084B CD 8E 08 04 1889  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084F CD 78 0A 04 1890  MIDS1:			CALL    NXT			; Skip whitespace
040853 FE 2C       1891  			CP      ','			; Check for a comma
040855 FD 23       1892  			INC     IY			; Advance to the next character in the BASIC line
040857 28 0D       1893  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040859 FD 2B       1894  			DEC     IY			; Restore the BASIC program pointer
04085B CD 37 0A 04 1895  			CALL    BRAKET			; Check for a bracket
04085F 3E 80       1896  			LD      A,80H			; String marker
040861 C9          1897  			RET
040862             1898  ;
040862             1899  ; LEFT$ - Return left part of string.
040862             1900  ; Carry cleared if entire string returned.
040862             1901  ; Result is string.
040862             1902  ;
040862 CD 26 0A 04 1903  LEFTS:			CALL    EXPRSC			; Get the first string expression
040866 CD B9 09 04 1904  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04086A CD 0F 03 04 1905  			CALL    EXPRI			; Get the second expression
04086E C1          1906  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086F CD E6 09 04 1907  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
040873 CD 37 0A 04 1908  			CALL    BRAKET			; Check for closing bracket
040877 D9          1909  			EXX
040878 7D          1910  			LD      A,L			; L: The second parameter
040879 D9          1911  			EXX
04087A BB          1912  			CP      E			; Compare with the string length
04087B 30 02       1913  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
04087D 6B          1914  			LD      L,E             	; For RIGHTS, no effect in LEFTS
04087E 5F          1915  LEFT2:			LD      E,A			; E: The new length of string
04087F 3E 80       1916  LEFT3:			LD      A,80H           	; String marker
040881 C9          1917  			RET
040882             1918  ;
040882             1919  ; RIGHT$ - Return right part of string.
040882             1920  ; Result is string.
040882             1921  ;
040882 CD 62 08 04 1922  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040886 D0          1923  			RET     NC			; Do nothing if the second parameter is >= string length
040887 1C          1924  			INC     E			; Check for a zero length string
040888 1D          1925  			DEC     E
040889 C8          1926  			RET     Z			; Yes, so do nothing
04088A 4B          1927  			LD      C,E			;  C: Number of bytes to copy
04088B 7D          1928  			LD      A,L
04088C 93          1929  			SUB     E
04088D 6F          1930  			LD      L,A			;  L: Index into the string
04088E 79          1931  RIGHT1:			LD	A,C
04088F 01 00 00 00 1932  			LD	BC,0
040893 4F          1933  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
040894 7D          1934  			LD	A,L
040895 21 00 4A 04 1935  			LD	HL,ACCS
040899 6F          1936  			LD	L,A			; HL: Source (in ACCS)
04089A 11 00 4A 04 1937  			LD      DE,ACCS			; DE: Destination (start of ACCS)
04089E ED B0       1938  			LDIR                    	; Copy
0408A0 3E 80       1939  			LD      A,80H			; String marker
0408A2 C9          1940  			RET
0408A3             1941  ;
0408A3             1942  ; STRINGS - Return n concatenations of a string.
0408A3             1943  ; Result is string.
0408A3             1944  ;
0408A3 CD 0F 03 04 1945  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A7 CD 2A 0A 04 1946  			CALL    COMMA			; Check for comma
0408AB D9          1947  			EXX
0408AC 7D          1948  			LD      A,L			; L: Number of iterations of string
0408AD D9          1949  			EXX
0408AE F5          1950  			PUSH    AF
0408AF CD 1A 03 04 1951  			CALL    EXPRS			; Get the string
0408B3 CD 37 0A 04 1952  			CALL    BRAKET			; Check for closing bracket
0408B7 F1          1953  			POP     AF			; A: Number of iterations of string
0408B8 B7          1954  			OR      A			; Set flags
0408B9 28 C3       1955  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408BB 3D          1956  			DEC     A
0408BC 4F          1957  			LD      C,A			; C: Loop counter
0408BD 3E 80       1958  			LD      A,80H			; String marker
0408BF C8          1959  			RET     Z
0408C0 1C          1960  			INC     E			; Check for empty string
0408C1 1D          1961  			DEC     E
0408C2 C8          1962  			RET     Z              		; And return
0408C3 43          1963  			LD      B,E			; B: String length tally
0408C4 21 00 4A 04 1964  			LD	HL,ACCS
0408C8 C5          1965  STRIN1:			PUSH    BC
0408C9 7E          1966  STRIN2:			LD      A,(HL)
0408CA 23          1967  			INC     HL
0408CB 12          1968  			LD      (DE),A
0408CC 1C          1969  			INC     E
0408CD 3E 13       1970  			LD      A,19
0408CF CA B6 37 04 1971  			JP      Z,ERROR_         	; Throw a "String too long" error
0408D3 10 F4       1972  			DJNZ    STRIN2
0408D5 C1          1973  			POP     BC
0408D6 0D          1974  			DEC     C
0408D7 20 EF       1975  			JR      NZ,STRIN1
0408D9 3E 80       1976  			LD      A,80H
0408DB C9          1977  			RET
0408DC             1978  ;
0408DC             1979  ;SUBROUTINES
0408DC             1980  ;
0408DC             1981  ;SWAP - Swap arguments
0408DC             1982  ;Exchanges DE,HL D'E',H'L' and B,C
0408DC             1983  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408DC             1984  ;
0408DC 79          1985  SWAP:			LD      A,C
0408DD 48          1986  			LD      C,B
0408DE 47          1987  			LD      B,A
0408DF EB          1988  			EX      DE,HL
0408E0 D9          1989  			EXX
0408E1 EB          1990  			EX      DE,HL
0408E2 D9          1991  			EXX
0408E3 C9          1992  			RET
0408E4             1993  ;
0408E4             1994  ;TEST - Test HLH'L' for zero
0408E4             1995  ;Outputs: Z-flag set & A=0 if zero
0408E4             1996  ;Destroys: A,F
0408E4             1997  ;
0408E4 7C          1998  TEST:			LD      A,H
0408E5 B5          1999  			OR      L
0408E6 D9          2000  			EXX
0408E7 B4          2001  			OR      H
0408E8 B5          2002  			OR      L
0408E9 D9          2003  			EXX
0408EA C9          2004  			RET
0408EB             2005  ;
0408EB             2006  ;DECODE - Decode line number in pseudo-binary.
0408EB             2007  ;   Inputs: IY = Text pointer.
0408EB             2008  ;   Outputs: HL=0, H'L'=line number, C=0.
0408EB             2009  ;   Destroys: A,C,H,L,H',L',IY,F
0408EB             2010  ;
0408EB D9          2011  DECODE:			EXX
0408EC 21 00 00 00 2012  			LD	HL, 0
0408F0 FD 7E 00    2013  			LD      A,(IY)
0408F3 FD 23       2014  			INC     IY
0408F5 17          2015  			RLA
0408F6 17          2016  			RLA
0408F7 67          2017  			LD      H,A
0408F8 E6 C0       2018  			AND     0C0H
0408FA FD AE 00    2019  			XOR     (IY)
0408FD FD 23       2020  			INC     IY
0408FF 6F          2021  			LD      L,A
040900 7C          2022  			LD      A,H
040901 17          2023  			RLA
040902 17          2024  			RLA
040903 E6 C0       2025  			AND     0C0H
040905 FD AE 00    2026  			XOR     (IY)
040908 FD 23       2027  			INC     IY
04090A 67          2028  			LD      H,A
04090B D9          2029  			EXX
04090C             2030  ;			XOR     A
04090C             2031  ;			LD      C,A
04090C             2032  ;			LD      H,A
04090C             2033  ;			LD      L,A
04090C 21 00 00 00 2034  			LD	HL, 0
040910 4D          2035  			LD	C, L
040911 C9          2036  			RET
040912             2037  ;
040912             2038  ;HEXSTR - convert numeric value to HEX string.
040912             2039  ;   Inputs: HLH'L'C = integer or floating-point number
040912             2040  ;  Outputs: String in string accumulator.
040912             2041  ;           E = string length.  D = ACCS/256
040912             2042  ;
040912 FD 23       2043  HEXSTS:			INC     IY              ;SKIP TILDE
040914 CD 22 03 04 2044  			CALL    ITEMN
040918 CD 1F 09 04 2045  			CALL    HEXSTR
04091C 3E 80       2046  			LD      A,80H
04091E C9          2047  			RET
04091F             2048  ;
04091F CD 67 06 04 2049  HEXSTR:			CALL    SFIX
040923 01 08 00 00 2050  			LD      BC,8
040927 11 00 4A 04 2051  			LD      DE,ACCS
04092B C5          2052  HEXST1:			PUSH    BC
04092C 06 04       2053  			LD      B,4
04092E AF          2054  			XOR     A
04092F D9          2055  HEXST2:			EXX
040930 52 29       2056  			ADD.S	HL,HL
040932 D9          2057  			EXX
040933 52 ED 6A    2058  			ADC.S	HL,HL
040936 17          2059  			RLA
040937 10 F6       2060  			DJNZ    HEXST2
040939 C1          2061  			POP     BC
04093A 0D          2062  			DEC     C
04093B F8          2063  			RET     M
04093C 28 06       2064  			JR      Z,HEXST3
04093E B7          2065  			OR      A
04093F 20 03       2066  			JR      NZ,HEXST3
040941 B8          2067  			CP      B
040942 28 E7       2068  			JR      Z,HEXST1
040944 C6 90       2069  HEXST3:			ADD     A,90H
040946 27          2070  			DAA
040947 CE 40       2071  			ADC     A,40H
040949 27          2072  			DAA
04094A 12          2073  			LD      (DE),A
04094B 13          2074  			INC     DE
04094C 47          2075  			LD      B,A
04094D 18 DC       2076  			JR      HEXST1
04094F             2077  ;
04094F             2078  ;Function STR - convert numeric value to ASCII string.
04094F             2079  ;   Inputs: HLH'L'C = integer or floating-point number.
04094F             2080  ;  Outputs: String in string accumulator.
04094F             2081  ;           E = length, D = ACCS/256
04094F             2082  ;           A = 80H (type=string)
04094F             2083  ;
04094F             2084  ;First normalise for decimal output:
04094F             2085  ;
04094F CD 78 0A 04 2086  STRS:			CALL    NXT
040953 FE 7E       2087  			CP      '~'
040955 28 BB       2088  			JR      Z,HEXSTS
040957 CD 22 03 04 2089  			CALL    ITEMN
04095B DD 21 00 4C 2090  			LD      IX,STAVAR
       04          
040960 DD 7E 03    2091  			LD      A,(IX+3)
040963 B7          2092  			OR      A
040964 DD 21 91 09 2093  			LD      IX,G9-1         ;G9 FORMAT
       04          
040969 28 05       2094  			JR      Z,STR0
04096B DD 21 00 4C 2095  STR:			LD      IX,STAVAR
       04          
040970 11 00 4A 04 2096  STR0:			LD      DE,ACCS
040974 3E 25       2097  			LD      A,37
040976 CD A2 20 04 2098  			CALL    FPP
04097A DA B6 37 04 2099  			JP      C,ERROR_
04097E DD CB 02 46 2100  			BIT     0,(IX+2)
040982 3E 80       2101  STR1:			LD      A,80H           ;STRING MARKER
040984 C8          2102  			RET     Z
040985 79          2103  			LD      A,C
040986 C6 04       2104  			ADD     A,4
040988 BB          2105  STR2:			CP      E
040989 28 F7       2106  			JR      Z,STR1
04098B EB          2107  			EX      DE,HL
04098C 36 20       2108  			LD      (HL),' '        ;TRAILING SPACE
04098E 23          2109  			INC     HL
04098F EB          2110  			EX      DE,HL
040990 18 F6       2111  			JR      STR2
040992             2112  ;
040992 09 00       2113  G9:			DW    9
040994             2114  ;
040994             2115  ;STRING COMPARE
040994             2116  ;Compare string (DE) length B with string (HL) length C.
040994             2117  ;Result preset to false.
040994             2118  ;
040994 CD A2 09 04 2119  SCP:			CALL	SCP0
040998             2120  ;
040998 3E 00       2121  ZERO:			LD      A,0
04099A D9          2122  			EXX
04099B 67          2123  			LD      H,A
04099C 6F          2124  			LD      L,A
04099D D9          2125  			EXX
04099E 67          2126  			LD      H,A
04099F 6F          2127  			LD      L,A
0409A0 4F          2128  			LD      C,A
0409A1 C9          2129  			RET
0409A2             2130  ;
0409A2 04          2131  SCP0:			INC     B
0409A3 0C          2132  			INC     C
0409A4 05          2133  SCP1:			DEC     B
0409A5 28 0A       2134  			JR      Z,SCP2
0409A7 0D          2135  			DEC     C
0409A8 28 0C       2136  			JR      Z,SCP3
0409AA 1A          2137  			LD      A,(DE)
0409AB BE          2138  			CP      (HL)
0409AC C0          2139  			RET     NZ
0409AD 13          2140  			INC     DE
0409AE 23          2141  			INC     HL
0409AF 18 F3       2142  			JR      SCP1
0409B1 B7          2143  SCP2:			OR      A
0409B2 0D          2144  			DEC     C
0409B3 C8          2145  			RET     Z
0409B4 37          2146  			SCF
0409B5 C9          2147  			RET
0409B6 B7          2148  SCP3:			OR      A
0409B7 0C          2149  			INC     C
0409B8 C9          2150  			RET
0409B9             2151  ;
0409B9             2152  ; PUSHS - SAVE STRING ON STACK.
0409B9             2153  ;     Inputs: String in string accumulator.
0409B9             2154  ;             E = string length.
0409B9             2155  ;             A - saved on stack.
0409B9             2156  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B9             2157  ;
0409B9 CD 81 16 04 2158  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409BD DD E1       2159  			POP     IX              	; IX: Return address
0409BF B7          2160  			OR      A               	; Clear the carry flag
0409C0 01 00 00 00 2161  			LD	BC,0			; BC: Length of the string
0409C4 4B          2162  			LD	C,E
0409C5 21 00 4A 04 2163  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C9 11 00 4A 04 2164  			LD	DE,ACCS
0409CD 59          2165  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409CE ED 52       2166  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409D0 39          2167  			ADD     HL,SP			; Grow the stack
0409D1 F9          2168  			LD      SP,HL
0409D2 57          2169  			LD      D,A			;  D: This needs to be set to A for some functions
0409D3 47          2170  			LD	B,A			; Stack A and C (the string length)
0409D4 C5          2171  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409D5 06 00       2172  			LD	B,0			; Reset B to 0 for the LDIR in this function
0409D7 28 0B       2173  			JR      Z,PUSHS1        	; Is it zero length?
0409D9 11 00 4A 04 2174  			LD      DE,ACCS			; DE: Destination
0409DD EB          2175  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409DE ED B0       2176  			LDIR	                    	; Copy to stack
0409E0 CD 81 16 04 2177  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409E4 DD E9       2178  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409E6             2179  ;
0409E6             2180  ; POPS - RESTORE STRING FROM STACK.
0409E6             2181  ;     Inputs: C = string length.
0409E6             2182  ;    Outputs: String in string accumulator.
0409E6             2183  ;             E = string length.
0409E6             2184  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409E6             2185  ;
0409E6 DD E1       2186  POPS:			POP     IX              	; IX: Return address
0409E8 69          2187  			LD	L,C			; Temporarily store string length in L
0409E9 01 00 00 00 2188  			LD	BC,0
0409ED 4D          2189  			LD	C,L			; BC: Number of bytes to copy
0409EE 21 00 00 00 2190  			LD      HL,0			; HL: 0
0409F2 39          2191  			ADD     HL,SP			; HL: Stack address
0409F3 11 00 4A 04 2192  			LD      DE,ACCS			; DE: Destination
0409F7 0C          2193  			INC     C			; Quick check to see if this is a zero length string
0409F8 0D          2194  			DEC     C
0409F9 28 02       2195  			JR      Z,POPS1         	; Yes it is, so skip
0409FB ED B0       2196  			LDIR                    	; No, so copy from the stack
0409FD F9          2197  POPS1:			LD      SP,HL			; Shrink the stack
0409FE DD E9       2198  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
040A00             2199  ;
040A00 FD 7E 00    2200  HEXDIG:			LD      A,(IY)
040A03 FE 30       2201  			CP      '0'
040A05 D8          2202  			RET     C
040A06 FE 3A       2203  			CP      '9'+1
040A08 3F          2204  			CCF
040A09 D0          2205  			RET     NC
040A0A FE 41       2206  			CP      'A'
040A0C D8          2207  			RET     C
040A0D D6 37       2208  			SUB     'A'-10
040A0F FE 10       2209  			CP      16
040A11 3F          2210  			CCF
040A12 C9          2211  			RET
040A13             2212  ;
040A13 FD 7E 00    2213  BINDIG:			LD	A,(IY)
040A16 FE 30       2214  			CP	'0'
040A18 D8          2215  			RET	C
040A19 FE 32       2216  			CP	'1'+1
040A1B 3F          2217  			CCF
040A1C C9          2218  			RET
040A1D             2219  ;
040A1D FE 3E       2220  RELOP?:			CP      '>'
040A1F D0          2221  			RET     NC
040A20 FE 3D       2222  			CP      '='
040A22 D0          2223  			RET     NC
040A23 FE 3C       2224  			CP      '<'
040A25 C9          2225  			RET
040A26             2226  ;
040A26 CD 1A 03 04 2227  EXPRSC:			CALL    EXPRS
040A2A CD 78 0A 04 2228  COMMA:			CALL    NXT
040A2E FD 23       2229  			INC     IY
040A30 FE 2C       2230  			CP      ','
040A32 C8          2231  			RET     Z
040A33 3E 05       2232  			LD      A,5
040A35 18 0B       2233  			JR      ERROR1_EV          ;"Missing ,"
040A37             2234  ;
040A37 CD 78 0A 04 2235  BRAKET:			CALL    NXT
040A3B FD 23       2236  			INC     IY
040A3D FE 29       2237  			CP      ')'
040A3F C8          2238  			RET     Z
040A40 3E 1B       2239  			LD      A,27
040A42 C3 B6 37 04 2240  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A46             2241  ;
040A46 FD 23       2242  SAVE_EV:			INC     IY
040A48 08          2243  SAVE1:			EX      AF,AF'
040A49 FA 3B 03 04 2244  			JP      M,TYPE_EV_
040A4D 08          2245  			EX      AF,AF'
040A4E E3          2246  			EX      (SP),HL
040A4F D9          2247  			EXX
040A50 E5          2248  			PUSH    HL
040A51 D9          2249  			EXX
040A52 F5          2250  			PUSH    AF
040A53 C5          2251  			PUSH    BC
040A54 E9          2252  			JP      (HL)
040A55             2253  ;
040A55 08          2254  DOIT:			EX      AF,AF'
040A56 FA 3B 03 04 2255  			JP      M,TYPE_EV_
040A5A D9          2256  			EXX
040A5B C1          2257  			POP     BC              ;RETURN ADDRESS
040A5C D9          2258  			EXX
040A5D 79          2259  			LD      A,C
040A5E C1          2260  			POP     BC
040A5F 47          2261  			LD      B,A
040A60 F1          2262  			POP     AF              ;OPERATOR
040A61 D9          2263  			EXX
040A62 EB          2264  			EX      DE,HL
040A63 E1          2265  			POP     HL
040A64 D9          2266  			EXX
040A65 EB          2267  			EX      DE,HL
040A66 E1          2268  			POP     HL
040A67 D9          2269  			EXX
040A68 C5          2270  			PUSH    BC
040A69 D9          2271  			EXX
040A6A E6 0F       2272  			AND     0FH
040A6C CD A2 20 04 2273  			CALL    FPP
040A70 38 D0       2274  			JR      C,ERROR1_EV
040A72 AF          2275  			XOR     A
040A73 08          2276  			EX      AF,AF'          ;TYPE
040A74 FD 7E 00    2277  			LD      A,(IY)
040A77 C9          2278  			RET
040A78             2279  ;
040A78             2280  ; Skip spaces
040A78             2281  ; - IY: String pointer
040A78             2282  ; Returns:
040A78             2283  ;  - A: The non-space character found
040A78             2284  ; - IY: Points to the character before that
040A78             2285  ;
040A78 FD 7E 00    2286  NXT:			LD      A,(IY)			; Fetch the character
040A7B FE 20       2287  			CP      ' '			; If it is space, then return
040A7D C0          2288  			RET     NZ
040A7E FD 23       2289  			INC     IY			; Increment the pointer and
040A80 C3 78 0A 04 2290  			JP      NXT			; Loop
040A84             2291  ;
040A84 E5          2292  DISPT2:			PUSH    HL
040A85 21 B5 01 04 2293  			LD      HL,SOPTBL
040A89 18 07       2294  			JR      DISPT0
040A8B             2295  ;
040A8B E5          2296  DISPAT:			PUSH    HL
040A8C D6 8D       2297  			SUB     FUNTOK
040A8E 21 0A 01 04 2298  			LD      HL,FUNTBL
040A92 C5          2299  DISPT0:			PUSH    BC
040A93             2300  
040A93 01 03 00 00 2301  			LD	BC, 3
040A97 47          2302  			LD	B, A
040A98 ED 4C       2303  			MLT	BC
040A9A 09          2304  			ADD	HL, BC
040A9B ED 27       2305  			LD	HL, (HL)
040A9D             2306  
040A9D             2307  ;			ADD     A,A
040A9D             2308  ;			LD      C,A
040A9D             2309  ;			LD      B,0
040A9D             2310  ;			ADD     HL,BC
040A9D             2311  ;			LD      A,(HL)
040A9D             2312  ;			INC     HL
040A9D             2313  ;			LD      H,(HL)
040A9D             2314  ;			LD      L,A
040A9D             2315  
040A9D C1          2316  			POP     BC
040A9E E3          2317  			EX      (SP),HL
040A9F C9          2318  			RET                     ;OFF TO ROUTINE
040AA0             2319  
040AA0             2320  ; --- End eval.asm ---
040AA0             2321  
040AA0             2322  ; --- Begin exec.asm ---
040AA0             2323  ;
040AA0             2324  ; Title:	BBC Basic Interpreter - Z80 version
040AA0             2325  ;		Statement Execution & Assembler Module - "EXEC"
040AA0             2326  ; Author:	(C) Copyright  R.T.Russell  1984
040AA0             2327  ; Modified By:	Dean Belfield
040AA0             2328  ; Created:	12/05/2023
040AA0             2329  ; Last Updated:	26/06/2023
040AA0             2330  ;
040AA0             2331  ; Modinfo:
040AA0             2332  ; 27/01/1984:	Version 2.1
040AA0             2333  ; 02/03/1987:	Version 3.0
040AA0             2334  ; 11/06/1987:	Version 3.1
040AA0             2335  ; 12/05/2023:	Modified by Dean Belfield
040AA0             2336  ; 07/06/2023:	Modified to run in ADL mode
040AA0             2337  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040AA0             2338  
040AA0             2339  			; .ASSUME	ADL = 1
040AA0             2340  
040AA0             2341  			; INCLUDE	"equs.inc"
040AA0             2342  
040AA0             2343  			; SEGMENT CODE
040AA0             2344  
040AA0             2345  			; XDEF	XEQ
040AA0             2346  			; XDEF	CHAIN0
040AA0             2347  			; XDEF	RUN
040AA0             2348  			; XDEF	SYNTAX
040AA0             2349  			; XDEF	ESCAPE
040AA0             2350  			; XDEF	FN_EX
040AA0             2351  			; XDEF	USR
040AA0             2352  			; XDEF	STORE5
040AA0             2353  			; XDEF	STORE4
040AA0             2354  			; XDEF	CHECK
040AA0             2355  			; XDEF	TERMQ
040AA0             2356  			; XDEF	FILL
040AA0             2357  			; XDEF	X4OR5
040AA0             2358  			; XDEF	MUL16
040AA0             2359  			; XDEF	CHANEL
040AA0             2360  			; XDEF	ASSEM
040AA0             2361  
040AA0             2362  			; XREF	AUTO
040AA0             2363  			; XREF	DELETE
040AA0             2364  			; XREF	LOAD
040AA0             2365  			; XREF	LIST_
040AA0             2366  			; XREF	NEW
040AA0             2367  			; XREF	OLD
040AA0             2368  			; XREF	RENUM
040AA0             2369  			; XREF	SAVE
040AA0             2370  			; XREF	SOUND
040AA0             2371  			; XREF	CLG
040AA0             2372  			; XREF	DRAW
040AA0             2373  			; XREF	ENVEL
040AA0             2374  			; XREF	GCOL
040AA0             2375  			; XREF	MODE
040AA0             2376  			; XREF	MOVE
040AA0             2377  			; XREF	PLOT
040AA0             2378  			; XREF	COLOUR
040AA0             2379  			; XREF	EXPRS
040AA0             2380  			; XREF	HIMEM
040AA0             2381  			; XREF	LOAD0
040AA0             2382  			; XREF	RANDOM
040AA0             2383  			; XREF	CLEAR
040AA0             2384  			; XREF	ERRTRP
040AA0             2385  			; XREF	PAGE_
040AA0             2386  			; XREF	DATAPTR
040AA0             2387  			; XREF	ERRLIN
040AA0             2388  			; XREF	TRAP
040AA0             2389  			; XREF	NXT
040AA0             2390  			; XREF	SETLIN
040AA0             2391  			; XREF	CLOOP
040AA0             2392  			; XREF	OSSHUT
040AA0             2393  			; XREF	WARM
040AA0             2394  			; XREF	TRACEN
040AA0             2395  			; XREF	OUTCHR
040AA0             2396  			; XREF	PBCDL
040AA0             2397  			; XREF	OSCLI
040AA0             2398  			; XREF	LISTON
040AA0             2399  			; XREF	GETVAR
040AA0             2400  			; XREF	PUTVAR
040AA0             2401  			; XREF	DATPTR
040AA0             2402  			; XREF	ERROR_
040AA0             2403  			; XREF	EXPR
040AA0             2404  			; XREF	CREATE
040AA0             2405  			; XREF	EXPRI
040AA0             2406  			; XREF	BRAKET
040AA0             2407  			; XREF	FREE
040AA0             2408  			; XREF	OSBPUT
040AA0             2409  			; XREF	COUNT
040AA0             2410  			; XREF	STR
040AA0             2411  			; XREF	HEXSTR
040AA0             2412  			; XREF	CRLF
040AA0             2413  			; XREF	ITEMI
040AA0             2414  			; XREF	FINDL
040AA0             2415  			; XREF	TEST
040AA0             2416  			; XREF	EXPRN
040AA0             2417  			; XREF	DLOAD5
040AA0             2418  			; XREF	DLOAD5_SPL
040AA0             2419  			; XREF	LOADN
040AA0             2420  			; XREF	FPP
040AA0             2421  			; XREF	SWAP
040AA0             2422  			; XREF	GETDEF
040AA0             2423  			; XREF	ZERO
040AA0             2424  			; XREF	OSBGET
040AA0             2425  			; XREF	BUFFER
040AA0             2426  			; XREF	CONS
040AA0             2427  			; XREF	VAL0
040AA0             2428  			; XREF	OSLINE
040AA0             2429  			; XREF	CLRSCN
040AA0             2430  			; XREF	TELL
040AA0             2431  			; XREF	SAYLN
040AA0             2432  			; XREF	REPORT
040AA0             2433  			; XREF	PUTPTR
040AA0             2434  			; XREF	PUTIME
040AA0             2435  			; XREF	PUTIMS
040AA0             2436  			; XREF	LOMEM
040AA0             2437  			; XREF	WIDTH
040AA0             2438  			; XREF	OSWRCH
040AA0             2439  			; XREF	COMMA
040AA0             2440  			; XREF	OSCALL
040AA0             2441  			; XREF	SFIX
040AA0             2442  			; XREF	LOAD4
040AA0             2443  			; XREF	PUSHS
040AA0             2444  			; XREF	POPS
040AA0             2445  			; XREF	LOADS
040AA0             2446  			; XREF	PUTCSR
040AA0             2447  			; XREF	OUT_
040AA0             2448  			; XREF	R0
040AA0             2449  ;
040AA0             2450  ; List of token values used in this module
040AA0             2451  ; consolidated with the token values in main.asm
040AA0             2452  ; TAND:			EQU     80H
040AA0             2453  ; TOR:			EQU     84H
040AA0             2454  ; TERROR:			EQU     85H
040AA0             2455  ; LINE_:			EQU     86H
040AA0             2456  ; OFF_:			EQU     87H
040AA0             2457  ; STEP:			EQU     88H
040AA0             2458  ; SPC:			EQU     89H
040AA0             2459  ; TAB:			EQU     8AH
040AA0             2460  ; ELSE_:			EQU     8BH
040AA0             2461  ; THEN:			EQU     8CH
040AA0             2462  ; LINO:			EQU     8DH
040AA0             2463  ; TO:				EQU     B8H
040AA0             2464  ; TCALL:			EQU     D6H
040AA0             2465  ; DATA_:			EQU     DCH
040AA0             2466  ; DEF_:			EQU     DDH
040AA0             2467  ; TGOSUB:			EQU     E4H
040AA0             2468  ; TGOTO:			EQU     E5H
040AA0             2469  ; TON:			EQU     EEH
040AA0             2470  ; TPROC:			EQU     F2H
040AA0             2471  ; TSTOP:			EQU     FAH
040AA0             2472  
040AA0             2473  ; TCMD:			EQU     C6H ; in eval.asm
040AA0             2474  
040AA0             2475  ; The command table
040AA0             2476  ; Commands are tokens from C6H onwards; this lookup table is used to
040AA0             2477  ; run the corresponding function; Note that DATA and DEF both use the same
040AA0             2478  ; code as REM
040AA0             2479  ;
040AA0 3F 37 04    2480  CMDTAB:			DW24  AUTO			; C6H
040AA3 A2 35 04    2481  			DW24  DELETE			; C7H
040AA6 80 37 04    2482  			DW24  LOAD			; C8H
040AA9 DD 35 04    2483  			DW24  LIST_			; C9H
040AAC 5D 37 04    2484  			DW24  NEW			; CAH
040AAF 63 37 04    2485  			DW24  OLD			; CBH
040AB2 6C 36 04    2486  			DW24  RENUM			; CCH
040AB5 91 37 04    2487  			DW24  SAVE			; CDH
040AB8 DA 15 04    2488  			DW24  PUT			; CEH
040ABB D0 13 04    2489  			DW24  PTR_EX			; CFH
040ABE EA 13 04    2490  			DW24  PAGEV_EX			; D0H
040AC1 FD 13 04    2491  			DW24  TIMEV_EX			; D1H
040AC4 26 14 04    2492  			DW24  LOMEMV_EX			; D2H
040AC7 3F 14 04    2493  			DW24  HIMEMV_EX			; D3H
040ACA 82 46 04    2494  			DW24  SOUND			; D4H
040ACD F4 14 04    2495  			DW24  BPUT			; D5H
040AD0 0C 15 04    2496  			DW24  CALL_			; D6H
040AD3 54 0B 04    2497  			DW24  CHAIN			; D7H
040AD6 9F 13 04    2498  			DW24  CLR			; D8H
040AD9 E8 14 04    2499  			DW24  CLOSE			; D9H
040ADC 1E 44 04    2500  			DW24  CLG			; DAH
040ADF 72 13 04    2501  			DW24  CLS			; DBH
040AE2 33 0C 04    2502  			DW24  REM_EX             		; DCH: DATA
040AE5 33 0C 04    2503  			DW24  REM_EX             		; DDH: DEF
040AE8 F9 0C 04    2504  			DW24  DIM_EX			; DEH
040AEB 48 46 04    2505  			DW24  DRAW			; DFH
040AEE CE 0B 04    2506  			DW24  END_			; E0H
040AF1 8A 11 04    2507  			DW24  ENDPRO			; E1H
040AF4 A2 49 04    2508  			DW24  ENVEL			; E2H
040AF7 9F 0F 04    2509  			DW24  FOR_EX			; E3H
040AFA 4F 0F 04    2510  			DW24  GOSUB_EX			; E4H
040AFD 33 0F 04    2511  			DW24  GOTO_EX			; E5H
040B00 DC 45 04    2512  			DW24  GCOL			; E6H
040B03 3E 13 04    2513  			DW24  IF_			; E7H
040B06 2C 12 04    2514  			DW24  INPUT			; E8H
040B09 54 0C 04    2515  			DW24  LET			; E9H
040B0C 2F 11 04    2516  			DW24  LOCAL_EX_			; EAH
040B0F 2E 44 04    2517  			DW24  MODE			; EBH
040B12 40 46 04    2518  			DW24  MOVE			; ECH
040B15 ED 0F 04    2519  			DW24  NEXT_EX			; EDH
040B18 C6 0E 04    2520  			DW24  ON_EX_			; EEH
040B1B A9 14 04    2521  			DW24  VDU			; EFH
040B1E 0E 46 04    2522  			DW24  PLOT			; F0H
040B21 CF 0D 04    2523  			DW24  PRINT_			; F1H
040B24 8C 10 04    2524  			DW24  PROC_EX			; F2H
040B27 DE 12 04    2525  			DW24  READ			; F3H
040B2A 33 0C 04    2526  			DW24  REM_EX			; F4H
040B2D 6F 0F 04    2527  			DW24  REPEAT_EX			; F5H
040B30 97 13 04    2528  			DW24  REPOR			; F6H
040B33 A9 13 04    2529  			DW24  RESTOR_EX			; F7H
040B36 5D 0F 04    2530  			DW24  RETURN			; F8H
040B39 4E 0B 04    2531  			DW24  RUN			; F9H
040B3C 7F 13 04    2532  			DW24  STOP			; FAH
040B3F 2A 45 04    2533  			DW24  COLOUR			; FBH
040B42 8B 14 04    2534  			DW24  TRACE_EX			; FCH
040B45 79 0F 04    2535  			DW24  UNTIL_EX			; FDH
040B48 7D 14 04    2536  			DW24  WIDTHV			; FEH
040B4B 19 0C 04    2537  			DW24  CLI             		; FFH: OSCLI
040B4E             2538  
040B4E             2539  ; RUN
040B4E             2540  ; RUN "filename"
040B4E             2541  ;
040B4E CD AC 17 04 2542  RUN:			CALL    TERMQ			; Standalone RUN command?
040B52 28 10       2543  			JR      Z,RUN0			; Yes, so just RUN the code
040B54             2544  
040B54             2545  ; CHAIN "filename"
040B54             2546  ;
040B54 CD 1A 03 04 2547  CHAIN:			CALL    EXPRS			; Get the filename
040B58 3E 0D       2548  			LD      A,CR			; Terminate it with a CR
040B5A 12          2549  			LD      (DE),A
040B5B ED 7B 20 4D 2550  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B60 CD 75 38 04 2551  			CALL    LOAD0			; And load the file in
040B64             2552  ;
040B64 ED 7B 20 4D 2553  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B69 DD 21 38 4D 2554  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B6E ED 5F       2555  @@:			LD      A, R			; Use the R register to seed the random number generator
040B70 28 FC       2556  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B72 07          2557  			RLCA				; Rotate it
040B73 07          2558  			RLCA
040B74 DD 77 03    2559  			LD      (IX+3),A		; And store
040B77 9F          2560  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B78 DD 77 04    2561  			LD      (IX+4),A		; And store
040B7B CD CC 38 04 2562  			CALL    CLEAR
040B7F 21 00 00 00 2563  			LD      HL,0			; Clear the error trap sysvar
040B83 22 2C 4D 04 2564  			LD      (ERRTRP),HL
040B87 2A 14 4D 04 2565  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B8B 3E DC       2566  			LD      A,DATA_			; The DATA token value
040B8D CD 80 18 04 2567  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B91 22 31 4D 04 2568  			LD      (DATPTR),HL     	; Set data pointer
040B95 FD 2A 14 4D 2569  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B9A             2570  ;
040B9A CD E2 0B 04 2571  XEQ0:			CALL    NEWLIN
040B9E FD 22 35 4D 2572  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040BA3 CD C3 3F 04 2573  			CALL    TRAP           		; Check keyboard
040BA7 CD 78 0A 04 2574  XEQ1:			CALL    NXT
040BAB FD 23       2575  			INC     IY
040BAD FE 3A       2576  			CP      ':'             	; Seperator
040BAF 28 F6       2577  			JR      Z,XEQ1
040BB1 FE 0D       2578  			CP      CR
040BB3 28 E5       2579  			JR      Z,XEQ0          	; New program line
040BB5 D6 C6       2580  			SUB     TCMD
040BB7 DA 42 0C 04 2581  			JP      C,LET0          	; Implied "LET"
040BBB             2582  
040BBB 01 03 00 00 2583  			LD	BC, 3
040BBF 47          2584  			LD	B, A
040BC0 ED 4C       2585  			MLT	BC
040BC2 21 A0 0A 04 2586  			LD	HL,CMDTAB
040BC6 09          2587  			ADD	HL, BC
040BC7 ED 27       2588  			LD	HL, (HL)		; Table entry
040BC9             2589  
040BC9             2590  ;			ADD     A,A
040BC9             2591  ;			LD      C,A
040BC9             2592  ;			LD      B,0
040BC9             2593  ;			LD      HL,CMDTAB
040BC9             2594  ;			ADD     HL,BC
040BC9             2595  ;			LD      A,(HL)          	; Table entry
040BC9             2596  ;			INC     HL
040BC9             2597  ;			LD      H,(HL)
040BC9             2598  ;			LD      L,A
040BC9             2599  
040BC9 CD 78 0A 04 2600  			CALL    NXT
040BCD E9          2601  			JP      (HL)            	; Execute the statement
040BCE             2602  
040BCE             2603  ;END
040BCE             2604  ;
040BCE CD 04 3A 04 2605  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BD2 7C          2606  			LD      A,H
040BD3 B5          2607  			OR      L               ;DIRECT?
040BD4 CA D6 30 04 2608  			JP      Z,CLOOP
040BD8 1E 00       2609  			LD      E,0
040BDA CD 92 43 04 2610  			CALL    OSSHUT          ;CLOSE ALL FILES
040BDE C3 D5 30 04 2611  			JP      WARM            ;"Ready"
040BE2             2612  ;
040BE2 FD 7E 00    2613  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BE5 01 03 00 00 2614  			LD      BC,3
040BE9 FD 09       2615  			ADD     IY,BC
040BEB B7          2616  			OR      A
040BEC 28 E0       2617  			JR      Z,END_           ;LENGTH=0, EXIT
040BEE 2A 26 4D 04 2618  			LD      HL,(TRACEN)
040BF2 7C          2619  			LD      A,H
040BF3 B5          2620  			OR      L
040BF4 C8          2621  			RET     Z
040BF5 11 00 00 00 2622  			LD	DE, 0		;Clear DE
040BF9 FD 56 FF    2623  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BFC FD 5E FE    2624  			LD      E,(IY-2)
040BFF ED 52       2625  			SBC     HL,DE
040C01 D8          2626  			RET     C
040C02 EB          2627  			EX      DE,HL
040C03 3E 5B       2628  			LD      A,'['           ;TRACE
040C05 CD A5 39 04 2629  			CALL    OUTCHR
040C09 CD 4D 3A 04 2630  			CALL    PBCDL
040C0D 3E 5D       2631  			LD      A,']'
040C0F CD A5 39 04 2632  			CALL    OUTCHR
040C13 3E 20       2633  			LD      A,' '
040C15 C3 A5 39 04 2634  			JP      OUTCHR
040C19             2635  
040C19             2636  ; Routines for each statement -------------------------------------------------
040C19             2637  
040C19             2638  ; OSCLI
040C19             2639  ;
040C19 CD 1A 03 04 2640  CLI:			CALL    EXPRS
040C1D 3E 0D       2641  			LD      A,CR
040C1F 12          2642  			LD      (DE),A
040C20 21 00 4A 04 2643  			LD      HL,ACCS
040C24 CD E6 3F 04 2644  			CALL    OSCLI
040C28 C3 9E 0B 04 2645  			JP      XEQ
040C2C             2646  
040C2C             2647  ; REM, *
040C2C             2648  ;
040C2C FD E5       2649  EXT_EX:			PUSH    IY
040C2E E1          2650  			POP     HL
040C2F CD E6 3F 04 2651  			CALL    OSCLI
040C33 FD E5       2652  REM_EX:			PUSH    IY
040C35 E1          2653  			POP     HL
040C36 3E 0D       2654  			LD      A,CR
040C38 47          2655  			LD      B,A
040C39 ED B1       2656  			CPIR                    ;FIND LINE END
040C3B E5          2657  			PUSH    HL
040C3C FD E1       2658  			POP     IY
040C3E C3 9A 0B 04 2659  			JP      XEQ0
040C42             2660  
040C42             2661  ; [LET] var = expr
040C42             2662  ;
040C42 FE C5       2663  LET0:			CP      ELSE_-TCMD
040C44 28 ED       2664  			JR      Z,REM_EX
040C46             2665  			; CP      ('*'-TCMD) & 0FFH
040C46             2666  			; JR      Z,EXT_EX
040C46             2667  			; CP      ('='-TCMD) & 0FFH
040C46             2668  			; JR      Z,FNEND
040C46             2669  			; CP      ('['-TCMD) & 0FFH
040C46             2670  			; ez80asm doesn't like () in expressions
040C46 FE 64       2671  			CP      '*'-TCMD & 0FFH
040C48 28 E2       2672  			JR      Z,EXT_EX
040C4A FE 77       2673  			CP      '='-TCMD & 0FFH
040C4C 28 5B       2674  			JR      Z,FNEND
040C4E FE 95       2675  			CP      '['-TCMD & 0FFH
040C50 28 25       2676  			JR      Z,ASM
040C52 FD 2B       2677  			DEC     IY
040C54 CD F0 15 04 2678  LET:			CALL    ASSIGN			; Assign the variable
040C58 CA 9E 0B 04 2679  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C5C 38 41       2680  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C5E             2681  ;
040C5E F5          2682  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C5F CD C2 17 04 2683  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C63 E5          2684  			PUSH    HL			; HL: Address of the variable
040C64 CD 1A 03 04 2685  			CALL    EXPRS
040C68 DD E1       2686  			POP     IX			; IX: Address of the variable
040C6A F1          2687  			POP     AF			; AF: The variable type
040C6B CD 32 16 04 2688  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C6F C3 9E 0B 04 2689  XEQR:			JP      XEQ
040C73             2690  ;
040C73 CD E2 0B 04 2691  ASM0:			CALL    NEWLIN
040C77 FD 22 35 4D 2692  ASM:			LD      (ERRLIN),IY
       04          
040C7C CD C3 3F 04 2693  			CALL    TRAP
040C80 CD CD 18 04 2694  			CALL    ASSEM
040C84 38 19       2695  			JR      C,SYNTAX
040C86 FE 0D       2696  			CP      CR
040C88 28 E9       2697  			JR      Z,ASM0
040C8A 21 40 4D 04 2698  			LD      HL,LISTON
040C8E 7E          2699  			LD      A,(HL)
040C8F E6 0F       2700  			AND     0FH
040C91 F6 B0       2701  			OR      B0H
040C93 77          2702  			LD      (HL),A
040C94 18 D9       2703  			JR      XEQR
040C96             2704  ;
040C96 CD 90 3A 04 2705  VAR_:			CALL    GETVAR
040C9A C8          2706  			RET     Z
040C9B D2 7F 3A 04 2707  			JP      NC,PUTVAR
040C9F 3E 10       2708  SYNTAX:			LD      A,16            ;"Syntax error"
040CA1 18 02       2709  			JR	ERROR0_EX
040CA3 3E 11       2710  ESCAPE:			LD      A,17            ;"Escape"
040CA5 C3 B6 37 04 2711  ERROR0_EX:			JP      ERROR_
040CA9             2712  
040CA9             2713  ; =
040CA9             2714  ;
040CA9 CD C7 01 04 2715  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CAD 43          2716  			LD      B,E
040CAE EB          2717  			EX      DE,HL
040CAF D9          2718  			EXX                     ;SAVE RESULT
040CB0 EB          2719  			EX      DE,HL           ; IN DEB'C'D'E'
040CB1 C1          2720  FNEND5:			POP     BC
040CB2 21 8A 17 04 2721  			LD      HL,LOCCHK
040CB6 B7          2722  			OR      A
040CB7 ED 42       2723  			SBC     HL,BC
040CB9 28 1C       2724  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CBB 21 8C 10 04 2725  			LD      HL,FNCHK
040CBF B7          2726  			OR      A
040CC0 ED 42       2727  			SBC     HL,BC
040CC2 3E 07       2728  			LD      A,7
040CC4 20 DF       2729  			JR      NZ,ERROR0_EX       ;"No FN"
040CC6 FD E1       2730  			POP     IY
040CC8 FD 22 35 4D 2731  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CCD EB          2732  			EX      DE,HL
040CCE D9          2733  			EXX
040CCF EB          2734  			EX      DE,HL
040CD0 11 00 4A 04 2735  			LD      DE,ACCS
040CD4 58          2736  			LD      E,B
040CD5 08          2737  			EX      AF,AF'
040CD6 C9          2738  			RET
040CD7             2739  ;
040CD7 DD E1       2740  FNEND0:			POP     IX
040CD9 C1          2741  			POP     BC
040CDA 78          2742  			LD      A,B
040CDB B7          2743  			OR      A
040CDC FA EA 0C 04 2744  			JP      M,FNEND1        ;STRING
040CE0 E1          2745  			POP     HL
040CE1 D9          2746  			EXX
040CE2 E1          2747  			POP     HL
040CE3 D9          2748  			EXX
040CE4 CD 08 16 04 2749  			CALL    STORE
040CE8 18 C7       2750  			JR      FNEND5
040CEA 21 00 00 00 2751  FNEND1:			LD      HL,0
040CEE 39          2752  			ADD     HL,SP
040CEF D5          2753  			PUSH    DE
040CF0 59          2754  			LD      E,C
040CF1 CD 36 16 04 2755  			CALL    STORES
040CF5 D1          2756  			POP     DE
040CF6 F9          2757  			LD      SP,HL
040CF7 18 B8       2758  			JR      FNEND5
040CF9             2759  
040CF9             2760  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF9             2761  ; DIM var expr[,var expr...]
040CF9             2762  ;
040CF9 CD 90 3A 04 2763  DIM_EX:			CALL    GETVAR          	; Get the variable
040CFD DA 89 0D 04 2764  			JP      C,BADDIM		; Throw a "Bad Dim" error
040D01 CA 93 0D 04 2765  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040D05 CD 04 3C 04 2766  			CALL    CREATE			; Create a new entity
040D09 E5          2767  			PUSH    HL			; HL: Address of the entity
040D0A DD E1       2768  			POP     IX			; IX: Address of the entity
040D0C FD 7E 00    2769  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D0F FE 28       2770  			CP      '('			; Check for opening brackets
040D11 7A          2771  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D12 20 7F       2772  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D14             2773  ;
040D14             2774  ; At this point we're reserving a variable array
040D14             2775  ;
040D14 E5          2776  			PUSH    HL			; HL: Address of the entity
040D15 F5          2777  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D16 11 01 00 00 2778  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D1A 42          2779  			LD      B,D			;  B: The number of dimensions in the array
040D1B             2780  ;
040D1B FD 23       2781  DIM1:			INC     IY			; Skip to the next token
040D1D C5          2782  			PUSH    BC			; Stack the dimension counter
040D1E D5          2783  			PUSH    DE			; Stack the total size of array accumulator
040D1F DD E5       2784  			PUSH    IX			; Stack the entity address
040D21 CD 0F 03 04 2785  			CALL    EXPRI           	; Fetch the size of this dimension
040D25 CB 7C       2786  			BIT     7,H			; If it is negative then
040D27 20 60       2787  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D29 D9          2788  			EXX
040D2A 23          2789  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D2B DD E1       2790  			POP     IX			; IX: The entity address
040D2D DD 23       2791  			INC     IX
040D2F DD 75 00    2792  			LD      (IX),L          	; Save the size of this dimension in the entity
040D32 DD 23       2793  			INC     IX
040D34 DD 74 00    2794  			LD      (IX),H
040D37 C1          2795  			POP     BC
040D38 CD A4 18 04 2796  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D3C 38 4F       2797  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D3E EB          2798  			EX      DE,HL           	; DE: The new total size of array accumulator
040D3F C1          2799  			POP     BC
040D40 04          2800  			INC     B               	;  B: The dimension counter; increment
040D41 FD 7E 00    2801  			LD      A,(IY)			; Fetch the nex token
040D44 FE 2C       2802  			CP      ','             	; Check for another dimension in the array
040D46 28 D3       2803  			JR      Z,DIM1			; And loop
040D48             2804  ;
040D48 CD 37 0A 04 2805  			CALL    BRAKET          	; Check for closing bracket
040D4C F1          2806  			POP     AF              	; Restore the type
040D4D DD 23       2807  			INC     IX
040D4F DD E3       2808  			EX      (SP),IX
040D51 DD 70 00    2809  			LD      (IX),B          	; Number of dimensions
040D54 CD 97 18 04 2810  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D58 E1          2811  			POP     HL			; Restore the entity address
040D59 38 32       2812  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D5B             2813  ;
040D5B             2814  ; We now allocate the memory for the array
040D5B             2815  ;
040D5B 19          2816  DIM3:			ADD     HL,DE
040D5C 38 2F       2817  			JR      C,NOROOM
040D5E E5          2818  			PUSH    HL
040D5F 24          2819  			INC     H
040D60 28 2B       2820  			JR      Z,NOROOM
040D62 ED 72       2821  			SBC     HL,SP
040D64 30 27       2822  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D66 E1          2823  			POP     HL
040D67 22 1D 4D 04 2824  			LD      (FREE),HL
040D6B 7A          2825  DIM2:			LD      A,D
040D6C B3          2826  			OR      E
040D6D 28 06       2827  			JR      Z,DIM5
040D6F 2B          2828  			DEC     HL
040D70 36 00       2829  			LD      (HL),0         		; Initialise the array
040D72 1B          2830  			DEC     DE
040D73 18 F6       2831  			JR      DIM2
040D75 CD 78 0A 04 2832  DIM5:			CALL    NXT
040D79 FE 2C       2833  			CP      ','            		; Another variable?
040D7B C2 9E 0B 04 2834  			JP      NZ,XEQ
040D7F FD 23       2835  			INC     IY
040D81 CD 78 0A 04 2836  			CALL    NXT
040D85 C3 F9 0C 04 2837  			JP      DIM_EX
040D89             2838  ;
040D89             2839  ; DIM errors
040D89             2840  ;
040D89 3E 0A       2841  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D8B 18 02       2842  			JR	ERROR1_EX
040D8D 3E 0B       2843  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D8F C3 B6 37 04 2844  ERROR1_EX:			JP      ERROR_
040D93             2845  ;
040D93             2846  ; At this point we're reserving a block of memory, i.e.
040D93             2847  ; DIM var expr[,var expr...]
040D93             2848  ;
040D93 B7          2849  DIM4:			OR      A			;  A: The dimension variable type
040D94 28 F3       2850  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D96 FA 89 0D 04 2851  			JP      M,BADDIM        	; or a string
040D9A 47          2852  			LD      B,A			; Temporarily store the dimension variable type in B
040D9B FD 7E FF    2853  			LD      A,(IY-1)		; Get the last character but one
040D9E FE 29       2854  			CP      ')'			; Check if it is a trailing bracket
040DA0 28 E7       2855  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040DA2             2856  ;
040DA2 21 00 00 00 2857  			LD	HL,0			; Clear HL
040DA6 3A 1D 4D 04 2858  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DAA 6F          2859  			LD	L,A
040DAB 3A 1E 4D 04 2860  			LD	A,(FREE+1)
040DAF 67          2861  			LD	H,A
040DB0 78          2862  			LD	A,B			; Restore the dimension variable type
040DB1 D9          2863  			EXX
040DB2 21 00 00 00 2864  			LD	HL,0			; Clear HL
040DB6 47          2865  			LD	B,A			; Temporarily store the dimension variable type in B
040DB7 3A 1F 4D 04 2866  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DBB 6F          2867  			LD	L,A
040DBC 78          2868  			LD	A,B			; Restore the dimension variable type
040DBD 4C          2869  			LD	C,H
040DBE CD 08 16 04 2870  			CALL    STORE           	; Store the address
040DC2 CD 0F 03 04 2871  			CALL    EXPRI			; Get the number of bytes to store
040DC6 D9          2872  			EXX
040DC7 23          2873  			INC     HL			; Add one to it
040DC8 EB          2874  			EX      DE,HL
040DC9 2A 1D 4D 04 2875  			LD      HL,(FREE)
040DCD 18 8C       2876  			JR      DIM3			; Continue with the DIM
040DCF             2877  
040DCF             2878  ; PRINT list...
040DCF             2879  ; PRINT #channel,list...
040DCF             2880  ;
040DCF FE 23       2881  PRINT_:			CP      '#'
040DD1 20 7C       2882  			JR      NZ,PRINT0
040DD3 CD C4 18 04 2883  			CALL    CHNL            ;CHANNEL NO. = E
040DD7 CD 78 0A 04 2884  PRNTN1:			CALL    NXT
040DDB FE 2C       2885  			CP      ','
040DDD C2 9E 0B 04 2886  			JP      NZ,XEQ
040DE1 FD 23       2887  			INC     IY
040DE3 D5          2888  			PUSH    DE
040DE4 CD C7 01 04 2889  			CALL    EXPR            ;ITEM TO PRINT
040DE8 08          2890  			EX      AF,AF'
040DE9 FA 0F 0E 04 2891  			JP      M,PRNTN2        ;STRING
040DED D1          2892  			POP     DE
040DEE C5          2893  			PUSH    BC
040DEF D9          2894  			EXX
040DF0 7D          2895  			LD      A,L
040DF1 D9          2896  			EXX
040DF2 CD A2 43 04 2897  			CALL    OSBPUT
040DF6 D9          2898  			EXX
040DF7 7C          2899  			LD      A,H
040DF8 D9          2900  			EXX
040DF9 CD A2 43 04 2901  			CALL    OSBPUT
040DFD 7D          2902  			LD      A,L
040DFE CD A2 43 04 2903  			CALL    OSBPUT
040E02 7C          2904  			LD      A,H
040E03 CD A2 43 04 2905  			CALL    OSBPUT
040E07 C1          2906  			POP     BC
040E08 79          2907  			LD      A,C
040E09 CD A2 43 04 2908  			CALL    OSBPUT
040E0D 18 C8       2909  			JR      PRNTN1
040E0F 4B          2910  PRNTN2:			LD      C,E
040E10 D1          2911  			POP     DE
040E11 21 00 4A 04 2912  			LD      HL,ACCS
040E15 0C          2913  			INC     C
040E16 0D          2914  PRNTN3:			DEC     C
040E17 28 0A       2915  			JR      Z,PRNTN4
040E19 7E          2916  			LD      A,(HL)
040E1A 23          2917  			INC     HL
040E1B C5          2918  			PUSH    BC
040E1C CD A2 43 04 2919  			CALL    OSBPUT
040E20 C1          2920  			POP     BC
040E21 18 F3       2921  			JR      PRNTN3
040E23 3E 0D       2922  PRNTN4:			LD      A,CR
040E25 CD A2 43 04 2923  			CALL    OSBPUT
040E29 18 AC       2924  			JR      PRNTN1
040E2B             2925  ;
040E2B 06 02       2926  PRINT6:			LD      B,2
040E2D 18 27       2927  			JR      PRINTC
040E2F 01 00 01 00 2928  PRINT8:			LD      BC,100H
040E33 18 21       2929  			JR      PRINTC
040E35 21 00 4C 04 2930  PRINT9:			LD      HL,STAVAR
040E39 AF          2931  			XOR     A
040E3A BE          2932  			CP      (HL)
040E3B 28 12       2933  			JR      Z,PRINT0
040E3D 3A 3D 4D 04 2934  			LD      A,(COUNT)
040E41 B7          2935  			OR      A
040E42 28 0B       2936  			JR      Z,PRINT0
040E44 96          2937  PRINTA:			SUB     (HL)
040E45 28 08       2938  			JR      Z,PRINT0
040E47 30 FB       2939  			JR      NC,PRINTA
040E49 ED 44       2940  			NEG
040E4B CD 21 18 04 2941  			CALL    FILL
040E4F 3A 00 4C 04 2942  PRINT0:			LD      A,(STAVAR)
040E53 4F          2943  			LD      C,A             ;PRINTS
040E54 06 00       2944  			LD      B,0             ;PRINTF
040E56 CD AC 17 04 2945  PRINTC:			CALL    TERMQ
040E5A 28 3F       2946  			JR      Z,PRINT4
040E5C CB 80       2947  			RES     0,B
040E5E FD 23       2948  			INC     IY
040E60 FE 7E       2949  			CP      '~'
040E62 28 C7       2950  			JR      Z,PRINT6
040E64 FE 3B       2951  			CP      ';'
040E66 28 C7       2952  			JR      Z,PRINT8
040E68 FE 2C       2953  			CP      ','
040E6A 28 C9       2954  			JR      Z,PRINT9
040E6C CD D1 17 04 2955  			CALL    FORMAT          ;SPC, TAB, '
040E70 28 E4       2956  			JR      Z,PRINTC
040E72 FD 2B       2957  			DEC     IY
040E74 C5          2958  			PUSH    BC
040E75 CD C7 01 04 2959  			CALL    EXPR            ;VARIABLE TYPE
040E79 08          2960  			EX      AF,AF'
040E7A FA 94 0E 04 2961  			JP      M,PRINT3        ;STRING
040E7E D1          2962  			POP     DE
040E7F D5          2963  			PUSH    DE
040E80 CB 4A       2964  			BIT     1,D
040E82 F5          2965  			PUSH    AF
040E83 CC 6B 09 04 2966  			CALL    Z,STR           ;DECIMAL
040E87 F1          2967  			POP     AF
040E88 C4 1F 09 04 2968  			CALL    NZ,HEXSTR       ;HEX
040E8C C1          2969  			POP     BC
040E8D C5          2970  			PUSH    BC
040E8E 79          2971  			LD      A,C
040E8F 93          2972  			SUB     E
040E90 D4 21 18 04 2973  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E94 C1          2974  PRINT3:			POP     BC
040E95 CD 30 18 04 2975  			CALL    PTEXT           ;PRINT
040E99 18 BB       2976  			JR      PRINTC
040E9B CB 40       2977  PRINT4:			BIT     0,B
040E9D CC 9D 39 04 2978  			CALL    Z,CRLF
040EA1 C3 9E 0B 04 2979  			JP      XEQ
040EA5             2980  
040EA5             2981  ; ON ERROR statement [:statement...]
040EA5             2982  ; ON ERROR OFF
040EA5             2983  ;
040EA5 FD 23       2984  ONERR:			INC     IY              ;SKIP "ERROR"
040EA7 21 00 00 00 2985  			LD      HL,0
040EAB 22 2C 4D 04 2986  			LD      (ERRTRP),HL
040EAF CD 78 0A 04 2987  			CALL    NXT
040EB3 FE 87       2988  			CP      OFF_
040EB5 FD 23       2989  			INC     IY
040EB7 CA 9E 0B 04 2990  			JP      Z,XEQ
040EBB FD 2B       2991  			DEC     IY
040EBD FD 22 2C 4D 2992  			LD      (ERRTRP),IY
       04          
040EC2 C3 33 0C 04 2993  			JP      REM_EX
040EC6             2994  
040EC6             2995  ; ON expr GOTO line[,line...] [ELSE statement]
040EC6             2996  ; ON expr GOTO line[,line...] [ELSE line]
040EC6             2997  ; ON expr GOSUB line[,line...] [ELSE statement]
040EC6             2998  ; ON expr GOSUB line[,line...] [ELSE line]
040EC6             2999  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EC6             3000  ;
040EC6 FE 85       3001  ON_EX_:			CP      TERROR
040EC8 28 DB       3002  			JR      Z,ONERR         ;"ON ERROR"
040ECA CD 0F 03 04 3003  			CALL    EXPRI
040ECE FD 7E 00    3004  			LD      A,(IY)
040ED1 FD 23       3005  			INC     IY
040ED3 1E 2C       3006  			LD      E,','           ;SEPARATOR
040ED5 FE E5       3007  			CP      TGOTO
040ED7 28 0B       3008  			JR      Z,ON1
040ED9 FE E4       3009  			CP      TGOSUB
040EDB 28 07       3010  			JR      Z,ON1
040EDD 1E F2       3011  			LD      E,TPROC
040EDF BB          3012  			CP      E
040EE0 3E 27       3013  			LD      A,39
040EE2 20 45       3014  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EE4 57          3015  ON1:			LD      D,A
040EE5 D9          3016  			EXX
040EE6 E5          3017  			PUSH    HL
040EE7 D9          3018  			EXX
040EE8 C1          3019  			POP     BC              ;ON INDEX
040EE9 78          3020  			LD      A,B
040EEA B4          3021  			OR      H
040EEB B5          3022  			OR      L
040EEC 20 2A       3023  			JR      NZ,ON4          ;OUT OF RANGE
040EEE B1          3024  			OR      C
040EEF 28 27       3025  			JR      Z,ON4
040EF1 0D          3026  			DEC     C
040EF2 28 0E       3027  			JR      Z,ON3           ;INDEX=1
040EF4 CD AC 17 04 3028  ON2:			CALL    TERMQ
040EF8 28 1E       3029  			JR      Z,ON4           ;OUT OF RANGE
040EFA FD 23       3030  			INC     IY              ;SKIP DELIMITER
040EFC BB          3031  			CP      E
040EFD 20 F5       3032  			JR      NZ,ON2
040EFF 0D          3033  			DEC     C
040F00 20 F2       3034  			JR      NZ,ON2
040F02 7B          3035  ON3:			LD      A,E
040F03 FE F2       3036  			CP      TPROC
040F05 28 26       3037  			JR      Z,ONPROC
040F07 D5          3038  			PUSH    DE
040F08 CD 2A 03 04 3039  			CALL    ITEMI           ;LINE NUMBER
040F0C D1          3040  			POP     DE
040F0D 7A          3041  			LD      A,D
040F0E FE E5       3042  			CP      TGOTO
040F10 28 2D       3043  			JR      Z,GOTO2
040F12 CD B9 17 04 3044  			CALL    SPAN            ;SKIP REST OF LIST
040F16 18 3B       3045  			JR      GOSUB1
040F18             3046  ;
040F18 FD 7E 00    3047  ON4:			LD      A,(IY)
040F1B FD 23       3048  			INC     IY
040F1D FE 8B       3049  			CP      ELSE_
040F1F CA 53 13 04 3050  			JP      Z,IF1           ;ELSE CLAUSE
040F23 FE 0D       3051  			CP      CR
040F25 20 F1       3052  			JR      NZ,ON4
040F27 3E 28       3053  			LD      A,40
040F29 C3 B6 37 04 3054  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F2D             3055  ;
040F2D 3E EE       3056  ONPROC:			LD      A,TON
040F2F C3 8C 10 04 3057  			JP      PROC_EX
040F33             3058  
040F33             3059  ; GOTO line
040F33             3060  ;
040F33 CD 2A 03 04 3061  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F37 CD AC 17 04 3062  GOTO1:			CALL    TERMQ			; Check for terminator
040F3B C2 9F 0C 04 3063  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F3F D9          3064  GOTO2:			EXX
040F40 CD E5 39 04 3065  			CALL    FINDL			; HL: Line number - Find the line
040F44 E5          3066  			PUSH    HL			; HL: Address of the line
040F45 FD E1       3067  			POP     IY			; IY = HL
040F47 CA 9A 0B 04 3068  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F4B 3E 29       3069  			LD      A,41			; Otherwise throw a "No such line" error
040F4D 18 DA       3070  			JR      ERROR2_EX
040F4F             3071  
040F4F             3072  ; GOSUB line
040F4F             3073  ; This pushes the following data onto the execution stack
040F4F             3074  ; - 3 bytes: Current execution address
040F4F             3075  ; - 3 bytes: Marker (the address of label GOSCHK)
040F4F             3076  ;
040F4F CD 2A 03 04 3077  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F53 FD E5       3078  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F55 CD 81 16 04 3079  			CALL    CHECK           	; Check there is enough room
040F59 CD 37 0F 04 3080  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F5D             3081  GOSCHK:			EQU     $
040F5D             3082  
040F5D             3083  ; RETURN
040F5D             3084  ; This pops the following data off the execution stack as pushed by GOSUB
040F5D             3085  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F5D             3086  ; - 3 bytes: The return execution address
040F5D             3087  ;
040F5D D1          3088  RETURN:			POP     DE			; Pop the marker off the execution stack
040F5E 21 5D 0F 04 3089  			LD      HL,GOSCHK		; Compare with GOSCHK
040F62 B7          3090  			OR      A
040F63 ED 52       3091  			SBC     HL,DE
040F65 FD E1       3092  			POP     IY			; Pop the return address off the execution stack
040F67 CA 9E 0B 04 3093  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F6B 3E 26       3094  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F6D 18 BA       3095  			JR      ERROR2_EX
040F6F             3096  
040F6F             3097  ; REPEAT
040F6F             3098  ; This pushes the following data onto the execution stack
040F6F             3099  ; - 3 bytes: Current execution address
040F6F             3100  ; - 3 bytes: Marker (the address of label REPCHK)
040F6F             3101  ;
040F6F FD E5       3102  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F71 CD 81 16 04 3103  			CALL    CHECK			; Check if there is enough room
040F75 CD 9E 0B 04 3104  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F79             3105  REPCHK:			EQU     $
040F79             3106  
040F79             3107  ; UNTIL expr
040F79             3108  ; This pops the following data off the execution stack
040F79             3109  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F79             3110  ; - 3 bytes: The address of the REPEAT instruction
040F79             3111  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F79             3112  ;
040F79 C1          3113  UNTIL_EX:			POP     BC			; Fetch the marker
040F7A C5          3114  			PUSH    BC			; And push it back onto the execution stack
040F7B 21 79 0F 04 3115  			LD      HL,REPCHK		; Compare with REPCHK
040F7F B7          3116  			OR      A
040F80 ED 42       3117  			SBC     HL,BC
040F82 3E 2B       3118  			LD      A,43
040F84 20 A3       3119  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F86 CD 0F 03 04 3120  			CALL    EXPRI			; Fetch the expression
040F8A CD E4 08 04 3121  			CALL    TEST			; Test if the expression evaluates to zero
040F8E C1          3122  			POP     BC			; Pop the marker
040F8F D1          3123  			POP     DE			; Pop the address of the REPEAT instruction
040F90 20 05       3124  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F92 D5          3125  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F93 C5          3126  			PUSH    BC			; Push the marker back on the stack
040F94 D5          3127  			PUSH    DE			; IY = DE
040F95 FD E1       3128  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F97 C3 9E 0B 04 3129  XEQ2:			JP      XEQ			; Continue execution
040F9B             3130  
040F9B             3131  ; FOR var = expr TO expr [STEP expr]
040F9B             3132  ; This pushes the following data onto the execution stack
040F9B             3133  ; - 3 bytes: The limit value
040F9B             3134  ; - 3 bytes: The step value
040F9B             3135  ; - 3 bytes: The current execution address
040F9B             3136  ; - 3 bytes: The address of the loop variable
040F9B             3137  ; - 3 bytes: Marker (the address of FORCHK)
040F9B             3138  ;
040F9B 3E 22       3139  FORVAR:			LD      A,34
040F9D 18 8A       3140  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F9F             3141  ;
040F9F CD F0 15 04 3142  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040FA3 20 F6       3143  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040FA5 F5          3144  			PUSH    AF              	; Save the variable type
040FA6 FD 7E 00    3145  			LD      A,(IY)			; Check the next token
040FA9 FE B8       3146  			CP      TO			; Compare with the token value for "TO"
040FAB 3E 24       3147  			LD      A,36			; Set the error code to 36 ("No TO")
040FAD C2 29 0F 04 3148  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FB1 FD 23       3149  			INC     IY			; Skip to the next token
040FB3             3150  ;
040FB3 DD E5       3151  			PUSH    IX
040FB5 CD 07 03 04 3152  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB9 DD E1       3153  			POP     IX
040FBB F1          3154  			POP     AF
040FBC 47          3155  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FBD C5          3156  			PUSH    BC              	; Stack the LIMIT value
040FBE E5          3157  			PUSH    HL
040FBF 21 00 00 00 3158  			LD      HL,0
040FC3 4C          3159  			LD      C,H
040FC4 D9          3160  			EXX
040FC5 E5          3161  			PUSH    HL
040FC6             3162  ;
040FC6 21 01 00 00 3163  			LD      HL,1            	; The preset STEP value is 1
040FCA D9          3164  			EXX
040FCB FD 7E 00    3165  			LD      A,(IY)			; Fetch the next token
040FCE FE 88       3166  			CP      STEP			; Compare with the token value for "STEP"
040FD0 20 0A       3167  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FD2             3168  ;
040FD2 FD 23       3169  			INC     IY			; Skip past the STEP token
040FD4 DD E5       3170  			PUSH    IX
040FD6 CD 07 03 04 3171  			CALL    EXPRN          		; Fetch the STEP expression value
040FDA DD E1       3172  			POP     IX
040FDC             3173  ;
040FDC C5          3174  FOR1:			PUSH    BC			; Stack the STEP value
040FDD E5          3175  			PUSH    HL
040FDE D9          3176  			EXX
040FDF E5          3177  			PUSH    HL
040FE0 D9          3178  			EXX
040FE1             3179  ;
040FE1 FD E5       3180  			PUSH    IY              	; Stack the current execution address
040FE3 DD E5       3181  			PUSH    IX              	; Stack the loop variable
040FE5 CD 81 16 04 3182  			CALL    CHECK
040FE9 CD 9E 0B 04 3183  			CALL    XEQ
040FED             3184  FORCHK:			EQU     $
040FED             3185  
040FED             3186  ; NEXT [var[,var...]]
040FED             3187  ; This pops the following data off the execution stack
040FED             3188  ; - 3 bytes: Marker (the address of FORCHK)
040FED             3189  ; - 3 bytes: The address of the loop variable
040FED             3190  ; - 3 bytes: The current execution address
040FED             3191  ; - 3 bytes: The step value
040FED             3192  ; - 3 bytes: The limit value
040FED             3193  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FED             3194  ;
040FED C1          3195  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FEE 21 ED 0F 04 3196  			LD      HL,FORCHK		; Compare with FORCHK
040FF2 B7          3197  			OR      A
040FF3 ED 42       3198  			SBC     HL,BC
040FF5 3E 20       3199  			LD      A,32
040FF7 C2 83 10 04 3200  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FFB CD AC 17 04 3201  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FFF E1          3202  			POP     HL			; Pop the address of the loop variable off the execution stack
041000 E5          3203  			PUSH    HL			; Push it back onto the execution stack
041001 C5          3204  			PUSH    BC			; Push the marker back onto the execution stack
041002 E5          3205  			PUSH    HL			; HL: Address of the loop variable off the stack
041003 C4 90 3A 04 3206  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041007 D1          3207  			POP     DE			; DE: Address of the loop variable off the stack
041008 EB          3208  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041009 B7          3209  			OR      A
04100A ED 52       3210  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
04100C 20 61       3211  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
04100E D5          3212  			PUSH    DE
04100F DD 21 0C 00 3213  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
041014 DD 39       3214  			ADD     IX,SP
041016 CD 19 2A 04 3215  			CALL    DLOAD5_SPL      	; Load the STEP value
04101A DD 7E 10    3216  			LD      A,(IX+16)       	; Get the STEP type
04101D DD E1       3217  			POP     IX
04101F CD 1B 04 04 3218  			CALL    LOADN           	; Load the LOOP variable
041023 CB 7A       3219  			BIT     7,D             	; Check the sign
041025 F5          3220  			PUSH    AF
041026 3E 0B       3221  			LD      A,'+' & 0FH
041028 CD A2 20 04 3222  			CALL    FPP             	; Add the STEP
04102C 38 55       3223  			JR      C,ERROR3_EX
04102E F1          3224  			POP     AF              	; Restore TYPE
04102F F5          3225  			PUSH    AF
041030 CD 08 16 04 3226  			CALL    STORE           	; Update the variable
041034 DD 21 15 00 3227  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041039 DD 39       3228  			ADD     IX,SP
04103B CD 19 2A 04 3229  			CALL    DLOAD5_SPL      	; Load the LIMIT value
04103F F1          3230  			POP     AF
041040 CC DC 08 04 3231  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
041044             3232  			; LD      A,0+('<'-4) & 0FH
041044 3E 08       3233  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041046 CD A2 20 04 3234  			CALL    FPP             	; Test against the limit
04104A 38 37       3235  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
04104C 24          3236  			INC     H
04104D 20 14       3237  			JR      NZ,LOOP_        	; Keep looping
04104F 21 1B 00 00 3238  			LD      HL,27			; Adjust the stack
041053 39          3239  			ADD     HL,SP
041054 F9          3240  			LD      SP,HL
041055 CD 78 0A 04 3241  			CALL    NXT
041059 FE 2C       3242  			CP      ','			; Check for multiple variables
04105B C2 9E 0B 04 3243  			JP      NZ,XEQ			; No, so we are done at ths point
04105F FD 23       3244  			INC     IY			; Increment to the next variable
041061 18 8A       3245  			JR      NEXT_EX			; And continue
041063             3246  ;
041063 C1          3247  LOOP_:			POP     BC
041064 D1          3248  			POP     DE
041065 FD E1       3249  			POP     IY
041067 FD E5       3250  			PUSH    IY
041069 D5          3251  			PUSH    DE
04106A C5          3252  			PUSH    BC
04106B C3 9E 0B 04 3253  			JP      XEQ
04106F             3254  ;
04106F 21 1B 00 00 3255  NEXT1:			LD      HL,27			; TODO: What does this do?
041073 39          3256  			ADD     HL,SP
041074 F9          3257  			LD      SP,HL			; Adjust the stack
041075 C1          3258  			POP     BC
041076 21 ED 0F 04 3259  			LD      HL,FORCHK
04107A ED 42       3260  			SBC     HL,BC
04107C E1          3261  			POP     HL              	; Variable pointer
04107D E5          3262  			PUSH    HL
04107E C5          3263  			PUSH    BC
04107F 28 89       3264  			JR      Z,NEXT0
041081             3265  ;
041081 3E 21       3266  			LD      A,33
041083 C3 B6 37 04 3267  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041087             3268  
041087             3269  ; FNname
041087             3270  ; N.B. ENTERED WITH A <> TON
041087             3271  ;
041087 F5          3272  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041088 CD 91 10 04 3273  			CALL    PROC1
04108C             3274  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
04108C             3275  
04108C             3276  ; PROCname
04108C             3277  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
04108C             3278  ; This pushes the following data onto the execution stack
04108C             3279  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
04108C             3280  ; - 3 bytes: Marker (the address of PROCHK)
04108C             3281  ;
04108C F5          3282  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
04108D CD 91 10 04 3283  			CALL    PROC1			; and is also space reserved on the stack for the return address
041091             3284  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041091             3285  ;
041091 CD 81 16 04 3286  PROC1:			CALL    CHECK			; Check there is space for this
041095 FD 2B       3287  			DEC     IY			; Decrement IY to the PROC token
041097 FD E5       3288  			PUSH    IY			; Stack the pointer
041099 CD 51 3B 04 3289  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
04109D C1          3290  			POP     BC			; BC = IY
04109E 28 41       3291  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0410A0 3E 1E       3292  			LD      A,30
0410A2 38 DF       3293  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0410A4             3294  ;
0410A4             3295  ; At this point the PROC/FN has not yet been registered in the dynamic area
0410A4             3296  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0410A4             3297  ;
0410A4 C5          3298  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0410A5 2A 14 4D 04 3299  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A9             3300  ;
0410A9 3E DD       3301  PROC2:			LD      A,DEF_			;  A: The token to search for
0410AB CD 80 18 04 3302  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410AF 38 26       3303  			JR      C,PROC3			; Not found, so jump to PROC3
0410B1 E5          3304  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410B2 FD E1       3305  			POP     IY			; IY = HL
0410B4 FD 23       3306  			INC     IY              	; Skip the DEF token
0410B6 CD 78 0A 04 3307  			CALL    NXT			; And any whitespace
0410BA CD 51 3B 04 3308  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410BE FD E5       3309  			PUSH    IY
0410C0 D1          3310  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410C1 38 09       3311  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410C3 C4 04 3C 04 3312  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410C7 FD E5       3313  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C9 D1          3314  			POP     DE			; DE = IY
0410CA ED 1F       3315  			LD	(HL),DE			; Save address
0410CC             3316  ;
0410CC EB          3317  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410CD 3E 0D       3318  			LD      A,CR			; The character to search for
0410CF 01 00 01 00 3319  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410D3 ED B1       3320  			CPIR                    	; Skip to next line
0410D5 18 D2       3321  			JR      PROC2			; Rinse, lather and repeat
0410D7             3322  ;
0410D7             3323  ; At this point a DEF has not been found for the PROC/FN
0410D7             3324  ;
0410D7 FD E1       3325  PROC3:			POP     IY              	; Restore the execution address
0410D9 CD 51 3B 04 3326  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410DD 3E 1D       3327  			LD      A,29
0410DF 20 A2       3328  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410E1             3329  ;
0410E1             3330  ; At this point we have a PROC/FN entry in the dynamic area
0410E1             3331  ;
0410E1 ED 17       3332  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410E3 21 03 00 00 3333  			LD	HL,3
0410E7 39          3334  			ADD     HL,SP
0410E8 CD 78 0A 04 3335  			CALL    NXT             	; Allow space before "("
0410EC D5          3336  			PUSH    DE              	; Exchange DE and IY
0410ED FD E3       3337  			EX      (SP),IY
0410EF FE 28       3338  			CP      '('             	; Arguments?
0410F1 D1          3339  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410F2 20 20       3340  			JR      NZ,PROC5
0410F4 CD 78 0A 04 3341  			CALL    NXT             	; Allow space before "("
0410F8 FE 28       3342  			CP      '('
0410FA C2 9F 0C 04 3343  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410FE FD E5       3344  			PUSH    IY
041100 C1          3345  			POP     BC              	; Save IY in BC
041101 D9          3346  			EXX
041102 CD 2C 17 04 3347  			CALL    SAVLOC          	; Save local parameters
041106 CD 37 0A 04 3348  			CALL    BRAKET          	; Closing bracket
04110A D9          3349  			EXX
04110B C5          3350  			PUSH    BC
04110C FD E1       3351  			POP     IY              	; Restore IY
04110E E5          3352  			PUSH    HL
04110F CD A8 16 04 3353  			CALL    ARGUE           	; Transfer arguments
041113 E1          3354  			POP     HL
041114             3355  ;
041114 23          3356  PROC5:			INC	HL			; Increment to the ON PROC flag address
041115 7E          3357  			LD	A, (HL)			; And fetch the value
041116 2B          3358  			DEC 	HL
041117 ED 1F       3359  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041119 FE EE       3360  			CP	TON			; Was it "ON PROC"?
04111B C2 9E 0B 04 3361  			JP	NZ, XEQ			; No, so back to XEQ
04111F D5          3362  			PUSH    DE			; Exchange DE and IY
041120 FD E3       3363  			EX      (SP),IY
041122 CD B9 17 04 3364  			CALL    SPAN            	; Skip rest of ON list
041126 FD E3       3365  			EX      (SP),IY			; Exchange DE and IY
041128 D1          3366  			POP     DE
041129 ED 1F       3367  			LD	(HL), DE		; Save the return address
04112B C3 9E 0B 04 3368  			JP      XEQ
04112F             3369  
04112F             3370  ; LOCAL var[,var...]
04112F             3371  ;
04112F C1          3372  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041130 C5          3373  			PUSH    BC
041131 21 8C 10 04 3374  			LD      HL,FNCHK		; Check if we are in a FN
041135 B7          3375  			OR      A
041136 ED 42       3376  			SBC     HL,BC
041138 28 16       3377  			JR      Z,LOCAL1		; Yes, so all good, we can use local
04113A 21 91 10 04 3378  			LD      HL,PROCHK		; Now check if we are in a PROC
04113E B7          3379  			OR      A
04113F ED 42       3380  			SBC     HL,BC
041141 28 0D       3381  			JR      Z,LOCAL1		; Again, all good, we can use local
041143 21 8A 17 04 3382  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041147 B7          3383  			OR      A
041148 ED 42       3384  			SBC     HL,BC			; If it is not present, then
04114A 3E 0C       3385  			LD      A,12
04114C C2 B6 37 04 3386  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041150             3387  ;
041150             3388  ; At this point we are adding a local variable into a PROC or FN
041150             3389  ;
041150 FD E5       3390  LOCAL1:			PUSH    IY			; IY: BASIC pointer
041152 C1          3391  			POP     BC			; BC: Copy of the BASIC pointer
041153 D9          3392  			EXX
041154 FD 2B       3393  			DEC     IY
041156 CD 2C 17 04 3394  			CALL    SAVLOC
04115A D9          3395  			EXX
04115B C5          3396  			PUSH    BC
04115C FD E1       3397  			POP     IY
04115E             3398  ;
04115E CD 90 3A 04 3399  LOCAL2:			CALL    GETVAR			; Get the variable location
041162 C2 9F 0C 04 3400  			JP      NZ,SYNTAX
041166 B7          3401  			OR      A               	; Check the variable type (80h = string)
041167 08          3402  			EX      AF,AF'
041168 CD 98 09 04 3403  			CALL    ZERO			; Zero the variable anyway
04116C 08          3404  			EX      AF,AF'
04116D F5          3405  			PUSH    AF
04116E F4 08 16 04 3406  			CALL    P,STORE         	; Call STORE if it is not a string
041172 F1          3407  			POP     AF
041173 59          3408  			LD      E,C
041174 FC 36 16 04 3409  			CALL    M,STORES		; Call STORES if it is a string
041178 CD 78 0A 04 3410  			CALL    NXT			; Skip to the next character in the expression
04117C FE 2C       3411  			CP      ','			; Is it a comma?
04117E C2 9E 0B 04 3412  			JP      NZ,XEQ			; No, so we're done, carry on executing
041182 FD 23       3413  			INC     IY			; Yes, so skip the comma
041184 CD 78 0A 04 3414  			CALL    NXT			; And any whitespace
041188 18 D4       3415  			JR      LOCAL2			; Then loop back and handle any further local variables
04118A             3416  
04118A             3417  ; ENDPROC
04118A             3418  ;
04118A C1          3419  ENDPRO:			POP     BC			; Pop the check value off the stack
04118B 21 8A 17 04 3420  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
04118F B7          3421  			OR      A
041190 ED 42       3422  			SBC     HL,BC
041192 28 13       3423  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041194             3424  ;
041194 21 91 10 04 3425  			LD      HL,PROCHK       	; Check if it is the PROC marker
041198 B7          3426  			OR      A
041199 ED 42       3427  			SBC     HL,BC
04119B FD E1       3428  			POP     IY
04119D CA 9E 0B 04 3429  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0411A1 3E 0D       3430  			LD      A,13			; Otherwise throw the "No PROC" error
0411A3 C3 B6 37 04 3431  			JP      ERROR_
0411A7             3432  ;
0411A7 DD E1       3433  UNSTK:			POP     IX			; Unstack a single local variable
0411A9 C1          3434  			POP     BC
0411AA 78          3435  			LD      A,B
0411AB B7          3436  			OR      A
0411AC FA BA 11 04 3437  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411B0 E1          3438  			POP     HL			; Unstack a normal variable
0411B1 D9          3439  			EXX
0411B2 E1          3440  			POP     HL
0411B3 D9          3441  			EXX
0411B4 CD 08 16 04 3442  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B8 18 D0       3443  			JR      ENDPRO			; And loop back to ENDPRO
0411BA             3444  ;
0411BA 21 00 00 00 3445  UNSTK1:			LD      HL,0			; Unstack a string
0411BE 39          3446  			ADD     HL,SP
0411BF 59          3447  			LD      E,C
0411C0 CD 36 16 04 3448  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411C4 F9          3449  			LD      SP,HL
0411C5 18 C3       3450  			JR      ENDPRO
0411C7             3451  
0411C7             3452  ; INPUT #channel,var,var...
0411C7             3453  ;
0411C7 CD C4 18 04 3454  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411CB CD 78 0A 04 3455  INPN1:			CALL    NXT
0411CF FE 2C       3456  			CP      ','
0411D1 C2 9E 0B 04 3457  			JP      NZ,XEQ
0411D5 FD 23       3458  			INC     IY
0411D7 CD 78 0A 04 3459  			CALL    NXT
0411DB D5          3460  			PUSH    DE
0411DC CD 96 0C 04 3461  			CALL    VAR_
0411E0 D1          3462  			POP     DE
0411E1 F5          3463  			PUSH    AF              ;SAVE TYPE
0411E2 E5          3464  			PUSH    HL              ;VARPTR
0411E3 B7          3465  			OR      A
0411E4 FA 10 12 04 3466  			JP      M,INPN2         ;STRING
0411E8 CD 9A 43 04 3467  			CALL    OSBGET
0411EC D9          3468  			EXX
0411ED 6F          3469  			LD      L,A
0411EE D9          3470  			EXX
0411EF CD 9A 43 04 3471  			CALL    OSBGET
0411F3 D9          3472  			EXX
0411F4 67          3473  			LD      H,A
0411F5 D9          3474  			EXX
0411F6 CD 9A 43 04 3475  			CALL    OSBGET
0411FA 6F          3476  			LD      L,A
0411FB CD 9A 43 04 3477  			CALL    OSBGET
0411FF 67          3478  			LD      H,A
041200 CD 9A 43 04 3479  			CALL    OSBGET
041204 4F          3480  			LD      C,A
041205 DD E1       3481  			POP     IX
041207 F1          3482  			POP     AF              ;RESTORE TYPE
041208 D5          3483  			PUSH    DE              ;SAVE CHANNEL
041209 CD 08 16 04 3484  			CALL    STORE
04120D D1          3485  			POP     DE
04120E 18 BB       3486  			JR      INPN1
041210 21 00 4A 04 3487  INPN2:			LD      HL,ACCS
041214 CD 9A 43 04 3488  INPN3:			CALL    OSBGET
041218 FE 0D       3489  			CP      CR
04121A 28 04       3490  			JR      Z,INPN4
04121C 77          3491  			LD      (HL),A
04121D 2C          3492  			INC     L
04121E 20 F4       3493  			JR      NZ,INPN3
041220 DD E1       3494  INPN4:			POP     IX
041222 F1          3495  			POP     AF
041223 D5          3496  			PUSH    DE
041224 EB          3497  			EX      DE,HL
041225 CD 32 16 04 3498  			CALL    STACCS
041229 D1          3499  			POP     DE
04122A 18 9F       3500  			JR      INPN1
04122C             3501  
04122C             3502  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             3503  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             3504  ;
04122C FE 23       3505  INPUT:			CP      '#'
04122E 28 97       3506  			JR      Z,INPUTN
041230 0E 00       3507  			LD      C,0             ;FLAG PROMPT
041232 FE 86       3508  			CP      LINE_
041234 20 04       3509  			JR      NZ,INPUT0
041236 FD 23       3510  			INC     IY              ;SKIP "LINE"
041238 0E 80       3511  			LD      C,80H
04123A 21 00 4B 04 3512  INPUT0:			LD      HL,BUFFER
04123E 36 0D       3513  			LD      (HL),CR         ;INITIALISE EMPTY
041240 CD AC 17 04 3514  INPUT1:			CALL    TERMQ
041244 CA 9E 0B 04 3515  			JP      Z,XEQ           ;DONE
041248 FD 23       3516  			INC     IY
04124A FE 2C       3517  			CP      ','
04124C 28 5C       3518  			JR      Z,INPUT3        ;SKIP COMMA
04124E FE 3B       3519  			CP      ';'
041250 28 58       3520  			JR      Z,INPUT3
041252 E5          3521  			PUSH    HL              ;SAVE BUFFER POINTER
041253 FE 22       3522  			CP      34		;ASCII ""
041255 20 0C       3523  			JR      NZ,INPUT6
041257 C5          3524  			PUSH    BC
041258 CD 6C 04 04 3525  			CALL    CONS
04125C C1          3526  			POP     BC
04125D CD 30 18 04 3527  			CALL    PTEXT           ;PRINT PROMPT
041261 18 06       3528  			JR      INPUT9
041263 CD D1 17 04 3529  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041267 20 05       3530  			JR      NZ,INPUT2
041269 E1          3531  INPUT9:			POP     HL
04126A CB C1       3532  			SET     0,C             ;FLAG NO PROMPT
04126C 18 CC       3533  			JR      INPUT0
04126E FD 2B       3534  INPUT2:			DEC     IY
041270 C5          3535  			PUSH    BC
041271 CD 96 0C 04 3536  			CALL    VAR_
041275 C1          3537  			POP     BC
041276 E1          3538  			POP     HL
041277 F5          3539  			PUSH    AF              ;SAVE TYPE
041278 7E          3540  			LD      A,(HL)
041279 23          3541  			INC     HL
04127A FE 0D       3542  			CP      CR              ;BUFFER EMPTY?
04127C CC AE 12 04 3543  			CALL    Z,REFILL
041280 CB 79       3544  			BIT     7,C
041282 F5          3545  			PUSH    AF
041283 C4 52 18 04 3546  			CALL    NZ,LINES
041287 F1          3547  			POP     AF
041288 CC 3F 18 04 3548  			CALL    Z,FETCHS
04128C F1          3549  			POP     AF              ;RESTORE TYPE
04128D C5          3550  			PUSH    BC
04128E E5          3551  			PUSH    HL
04128F B7          3552  			OR      A
041290 FA A4 12 04 3553  			JP      M,INPUT4        ;STRING
041294 F5          3554  			PUSH    AF
041295 DD E5       3555  			PUSH    IX
041297 CD 73 06 04 3556  			CALL    VAL0
04129B DD E1       3557  			POP     IX
04129D F1          3558  			POP     AF
04129E CD 08 16 04 3559  			CALL    STORE
0412A2 18 04       3560  			JR      INPUT5
0412A4 CD 32 16 04 3561  INPUT4:			CALL    STACCS
0412A8 E1          3562  INPUT5:			POP     HL
0412A9 C1          3563  			POP     BC
0412AA CB 81       3564  INPUT3:			RES     0,C
0412AC 18 92       3565  			JR      INPUT1
0412AE             3566  ;
0412AE CB 41       3567  REFILL:			BIT     0,C
0412B0 20 0C       3568  			JR      NZ,REFIL0       ;NO PROMPT
0412B2 3E 3F       3569  			LD      A,'?'
0412B4 CD A5 39 04 3570  			CALL    OUTCHR          ;PROMPT
0412B8 3E 20       3571  			LD      A,' '
0412BA CD A5 39 04 3572  			CALL    OUTCHR
0412BE 21 00 4B 04 3573  REFIL0:			LD      HL,BUFFER
0412C2 C5          3574  			PUSH    BC
0412C3 E5          3575  			PUSH    HL
0412C4 DD E5       3576  			PUSH    IX
0412C6 CD B5 3E 04 3577  			CALL    OSLINE
0412CA DD E1       3578  			POP     IX
0412CC E1          3579  			POP     HL
0412CD C1          3580  			POP     BC
0412CE 47          3581  			LD      B,A             ;POS AT ENTRY
0412CF AF          3582  			XOR     A
0412D0 32 3D 4D 04 3583  			LD      (COUNT),A
0412D4 B8          3584  			CP      B
0412D5 C8          3585  			RET     Z
0412D6 7E          3586  REFIL1:			LD      A,(HL)
0412D7 FE 0D       3587  			CP      CR
0412D9 C8          3588  			RET     Z
0412DA 23          3589  			INC     HL
0412DB 10 F9       3590  			DJNZ    REFIL1
0412DD C9          3591  			RET
0412DE             3592  
0412DE             3593  ; READ var[,var...]
0412DE             3594  ;
0412DE FE 23       3595  READ:			CP      '#'
0412E0 CA C7 11 04 3596  			JP      Z,INPUTN
0412E4 2A 31 4D 04 3597  			LD      HL,(DATPTR)
0412E8 7E          3598  READ0:			LD      A,(HL)
0412E9 23          3599  			INC     HL              ;SKIP COMMA OR "DATA"
0412EA FE 0D       3600  			CP      CR              ;END OF DATA STMT?
0412EC CC 30 13 04 3601  			CALL    Z,GETDAT
0412F0 E5          3602  			PUSH    HL
0412F1 CD 96 0C 04 3603  			CALL    VAR_
0412F5 E1          3604  			POP     HL
0412F6 B7          3605  			OR      A
0412F7 FA 10 13 04 3606  			JP      M,READ1         ;STRING
0412FB E5          3607  			PUSH    HL
0412FC FD E3       3608  			EX      (SP),IY
0412FE F5          3609  			PUSH    AF              ;SAVE TYPE
0412FF DD E5       3610  			PUSH    IX
041301 CD 07 03 04 3611  			CALL    EXPRN
041305 DD E1       3612  			POP     IX
041307 F1          3613  			POP     AF
041308 CD 08 16 04 3614  			CALL    STORE
04130C FD E3       3615  			EX      (SP),IY
04130E 18 09       3616  			JR      READ2
041310 CD 3F 18 04 3617  READ1:			CALL    FETCHS
041314 E5          3618  			PUSH    HL
041315 CD 32 16 04 3619  			CALL    STACCS
041319 E1          3620  READ2:			POP     HL
04131A 22 31 4D 04 3621  			LD      (DATPTR),HL
04131E CD 78 0A 04 3622  			CALL    NXT
041322 FE 2C       3623  			CP      ','
041324 C2 9E 0B 04 3624  			JP      NZ,XEQ
041328 FD 23       3625  			INC     IY
04132A CD 78 0A 04 3626  			CALL    NXT
04132E 18 B8       3627  			JR      READ0
041330             3628  ;
041330 3E DC       3629  GETDAT:			LD      A,DATA_
041332 CD 80 18 04 3630  			CALL    SEARCH_EX
041336 23          3631  			INC     HL
041337 D0          3632  			RET     NC
041338 3E 2A       3633  			LD      A,42
04133A C3 B6 37 04 3634  ERROR4:			JP      ERROR_           ;"Out of DATA"
04133E             3635  
04133E             3636  ; IF expr statement
04133E             3637  ; IF expr THEN statement [ELSE statement]
04133E             3638  ; IF expr THEN line [ELSE line]
04133E             3639  ;
04133E CD 0F 03 04 3640  IF_:			CALL    EXPRI
041342 CD E4 08 04 3641  			CALL    TEST
041346 28 19       3642  			JR      Z,IFNOT         ;FALSE
041348 FD 7E 00    3643  			LD      A,(IY)
04134B FE 8C       3644  			CP      THEN
04134D C2 9E 0B 04 3645  			JP      NZ,XEQ
041351 FD 23       3646  			INC     IY              ;SKIP "THEN"
041353 CD 78 0A 04 3647  IF1:			CALL    NXT
041357 FE 8D       3648  			CP      LINO
041359 C2 9E 0B 04 3649  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
04135D C3 33 0F 04 3650  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041361 FD 7E 00    3651  IFNOT:			LD      A,(IY)
041364 FE 0D       3652  			CP      CR
041366 FD 23       3653  			INC     IY
041368 CA 9A 0B 04 3654  			JP      Z,XEQ0          ;END OF LINE
04136C FE 8B       3655  			CP      ELSE_
04136E 20 F1       3656  			JR      NZ,IFNOT
041370 18 E1       3657  			JR      IF1
041372             3658  
041372             3659  ; CLS
041372             3660  ;
041372 CD 28 44 04 3661  CLS:		CALL    CLRSCN
041376 AF          3662  			XOR     A
041377 32 3D 4D 04 3663  			LD      (COUNT),A
04137B C3 9E 0B 04 3664  			JP      XEQ
04137F             3665  
04137F             3666  ; STOP
04137F             3667  ;
04137F CD E6 3D 04 3668  STOP:			CALL    TELL
041383 0D          3669  			DB	CR
041384 0A          3670  			DB	LF
041385 FA          3671  			DB	TSTOP
041386 00          3672  			DB	0
041387 CD 04 3A 04 3673  			CALL    SETLIN          ;FIND CURRENT LINE
04138B CD 38 3A 04 3674  			CALL    SAYLN
04138F CD 9D 39 04 3675  			CALL    CRLF
041393 C3 D6 30 04 3676  			JP      CLOOP
041397             3677  
041397             3678  ; REPORT
041397             3679  ;
041397 CD D8 3D 04 3680  REPOR:			CALL    REPORT
04139B C3 9E 0B 04 3681  			JP      XEQ
04139F             3682  
04139F             3683  ; CLEAR
04139F             3684  ;
04139F CD CC 38 04 3685  CLR:			CALL    CLEAR
0413A3 2A 14 4D 04 3686  			LD      HL,(PAGE_)
0413A7 18 19       3687  			JR      RESTR1
0413A9             3688  
0413A9             3689  ; RESTORE [line]
0413A9             3690  ;
0413A9 2A 14 4D 04 3691  RESTOR_EX:			LD      HL,(PAGE_)
0413AD CD AC 17 04 3692  			CALL    TERMQ
0413B1 28 0F       3693  			JR      Z,RESTR1
0413B3 CD 2A 03 04 3694  			CALL    ITEMI
0413B7 D9          3695  			EXX
0413B8 CD E5 39 04 3696  			CALL    FINDL           ;SEARCH FOR LINE
0413BC 3E 29       3697  			LD      A,41
0413BE C2 3A 13 04 3698  			JP      NZ,ERROR4       ;"No such line"
0413C2 3E DC       3699  RESTR1:			LD      A,DATA_
0413C4 CD 80 18 04 3700  			CALL    SEARCH_EX
0413C8 22 31 4D 04 3701  			LD      (DATPTR),HL
0413CC C3 9E 0B 04 3702  			JP      XEQ
0413D0             3703  
0413D0             3704  ; PTR#channel=expr
0413D0             3705  ; PAGE=expr
0413D0             3706  ; TIME=expr
0413D0             3707  ; LOMEM=expr
0413D0             3708  ; HIMEM=expr
0413D0             3709  ;
0413D0 CD B8 18 04 3710  PTR_EX:			CALL    CHANEL
0413D4 CD C2 17 04 3711  			CALL    EQUALS
0413D8 7B          3712  			LD      A,E
0413D9 F5          3713  			PUSH    AF
0413DA CD 0F 03 04 3714  			CALL    EXPRI
0413DE E5          3715  			PUSH    HL
0413DF D9          3716  			EXX
0413E0 D1          3717  			POP     DE
0413E1 F1          3718  			POP     AF
0413E2 CD CE 43 04 3719  			CALL    PUTPTR
0413E6 C3 9E 0B 04 3720  			JP      XEQ
0413EA             3721  ;
0413EA CD C2 17 04 3722  PAGEV_EX:			CALL    EQUALS
0413EE CD 0F 03 04 3723  			CALL    EXPRI
0413F2 D9          3724  			EXX
0413F3 2E 00       3725  			LD      L,0
0413F5 22 14 4D 04 3726  			LD      (PAGE_),HL
0413F9 C3 9E 0B 04 3727  			JP      XEQ
0413FD             3728  ;
0413FD FE 24       3729  TIMEV_EX:			CP      '$'
0413FF 28 13       3730  			JR      Z,TIMEVS_EX
041401 CD C2 17 04 3731  			CALL    EQUALS
041405 CD 0F 03 04 3732  			CALL    EXPRI
041409 E5          3733  			PUSH    HL
04140A D9          3734  			EXX
04140B D1          3735  			POP     DE
04140C CD ED 3E 04 3736  			CALL    PUTIME
041410 C3 9E 0B 04 3737  			JP      XEQ
041414             3738  ;
041414 FD 23       3739  TIMEVS_EX:			INC     IY              ;SKIP '$'
041416 CD C2 17 04 3740  			CALL    EQUALS
04141A CD 1A 03 04 3741  			CALL    EXPRS
04141E CD A2 49 04 3742  			CALL    PUTIMS
041422 C3 9E 0B 04 3743  			JP      XEQ
041426             3744  ;
041426 CD C2 17 04 3745  LOMEMV_EX:			CALL    EQUALS
04142A CD 0F 03 04 3746  			CALL    EXPRI
04142E CD CC 38 04 3747  			CALL    CLEAR
041432 D9          3748  			EXX
041433 22 1A 4D 04 3749  			LD      (LOMEM),HL
041437 22 1D 4D 04 3750  			LD      (FREE),HL
04143B C3 9E 0B 04 3751  			JP      XEQ
04143F             3752  ;
04143F CD C2 17 04 3753  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041443 CD 0F 03 04 3754  			CALL    EXPRI			; Load the expression into registers
041447 7D          3755  			LD	A,L			;  A: The MSB of the 24-bit value
041448 D9          3756  			EXX				; HL: The LSW of the 24-bit value
041449 22 4A 4D 04 3757  			LD	(R0),HL
04144D 32 4C 4D 04 3758  			LD	(R0+2),A
041451 2A 1D 4D 04 3759  			LD	HL,(FREE)
041455 11 00 01 00 3760  			LD      DE,256
041459 19          3761  			ADD	HL,DE
04145A EB          3762  			EX	DE,HL			; DE: FREE + 256
04145B 2A 4A 4D 04 3763  			LD	HL,(R0)			; HL: The passed expression
04145F AF          3764  			XOR     A
041460 ED 52       3765  			SBC     HL,DE
041462 19          3766  			ADD     HL,DE			; Do a bounds check
041463 DA B6 37 04 3767  			JP      C,ERROR_         	; Throw the error: "No room"
041467 ED 5B 20 4D 3768  			LD      DE,(HIMEM)
       04          
04146C 22 20 4D 04 3769  			LD      (HIMEM),HL
041470 EB          3770  			EX      DE,HL
041471 ED 72       3771  			SBC     HL,SP			; Adjust the stack
041473 C2 9E 0B 04 3772  			JP      NZ,XEQ
041477 EB          3773  			EX      DE,HL
041478 F9          3774  			LD      SP,HL           	; Load the SP
041479 C3 9E 0B 04 3775  			JP      XEQ
04147D             3776  
04147D             3777  ; WIDTH expr
04147D             3778  ;
04147D CD 0F 03 04 3779  WIDTHV:			CALL    EXPRI
041481 D9          3780  			EXX
041482 7D          3781  			LD      A,L
041483 32 3E 4D 04 3782  			LD      (WIDTH),A
041487 C3 9E 0B 04 3783  			JP      XEQ
04148B             3784  
04148B             3785  ; TRACE ON
04148B             3786  ; TRACE OFF
04148B             3787  ; TRACE line
04148B             3788  ;
04148B FD 23       3789  TRACE_EX:			INC     IY
04148D 21 00 00 00 3790  			LD      HL,0
041491 FE EE       3791  			CP      TON
041493 28 0B       3792  			JR      Z,TRACE0
041495 FE 87       3793  			CP      OFF_
041497 28 08       3794  			JR      Z,TRACE1
041499 FD 2B       3795  			DEC     IY
04149B CD 0F 03 04 3796  			CALL    EXPRI
04149F D9          3797  			EXX
0414A0 2B          3798  TRACE0:			DEC     HL
0414A1 22 26 4D 04 3799  TRACE1:			LD      (TRACEN),HL
0414A5 C3 9E 0B 04 3800  			JP      XEQ
0414A9             3801  
0414A9             3802  ; VDU expr,expr;....
0414A9             3803  ;
0414A9 DD 21 00 4B 3804  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0414AE DD E5       3805  VDU1:			PUSH	IX
0414B0 CD 0F 03 04 3806  			CALL    EXPRI			; Fetch the VDU character
0414B4 DD E1       3807  			POP	IX
0414B6 D9          3808  			EXX
0414B7 DD 75 00    3809  			LD	(IX+0),L		; Write out the character to the buffer
0414BA DD 23       3810  			INC	IX
0414BC FD 7E 00    3811  			LD      A,(IY)			;  A: The separator character
0414BF FE 2C       3812  			CP      ','			; Is it a comma?
0414C1 28 09       3813  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414C3 FE 3B       3814  			CP      ';'			; Is it a semicolon?
0414C5 20 07       3815  			JR      NZ,VDU3			; No, so skip to the next expression
0414C7 DD 74 00    3816  			LD	(IX+0),H		; Write out the high byte to the buffer
0414CA DD 23       3817  			INC	IX
0414CC FD 23       3818  VDU2:			INC     IY			; Skip to the next character
0414CE CD AC 17 04 3819  VDU3:			CALL    TERMQ			; Skip past white space
0414D2 20 DA       3820  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414D4 DD 7D       3821  			LD	A,IXL			;  A: Number of bytes to write out
0414D6 B7          3822  			OR	A
0414D7 28 0B       3823  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D9 21 00 4B 04 3824  			LD	HL,BUFFER		; HL: Start of stream
0414DD 01 00 00 00 3825  			LD	BC,0
0414E1 4F          3826  			LD	C,A			; BC: Number of bytes to write out
0414E2 5B DF       3827  			RST.LIL	18h			; Output the buffer to MOS
0414E4 C3 9E 0B 04 3828  VDU4:			JP      XEQ
0414E8             3829  
0414E8             3830  ; CLOSE channel number
0414E8             3831  ;
0414E8 CD B8 18 04 3832  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414EC CD 92 43 04 3833  			CALL    OSSHUT			; Close the channel
0414F0 C3 9E 0B 04 3834  			JP      XEQ
0414F4             3835  
0414F4             3836  ; BPUT channel,byte
0414F4             3837  ;
0414F4 CD B8 18 04 3838  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414F8 D5          3839  			PUSH    DE			; DE: Channel number
0414F9 CD 2A 0A 04 3840  			CALL    COMMA			; Skip to the next expression
0414FD CD 0F 03 04 3841  			CALL    EXPRI           	; Feth the data
041501 D9          3842  			EXX
041502 7D          3843  			LD      A,L			; A: The byte to write
041503 D1          3844  			POP     DE
041504 CD A2 43 04 3845  			CALL    OSBPUT			; Write the byte out
041508 C3 9E 0B 04 3846  			JP      XEQ
04150C             3847  
04150C             3848  ; CALL address[,var[,var...]]
04150C             3849  ;
04150C             3850  ; Note that the parameter table differs from the Z80 version
04150C             3851  ; Each entry now takes up 4 bytes, not 3, so the table is now:
04150C             3852  ;  -1 byte:  Number of parameters
04150C             3853  ; Then, for each parameter:
04150C             3854  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
04150C             3855  ;  -3 bytes: Parameter address
04150C             3856  ;
04150C             3857  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
04150C             3858  ;
04150C CD 0F 03 04 3859  CALL_:			CALL    EXPRI           	; Fetch the address
041510 7D          3860  			LD	A,L			;  A: MSB of address
041511 D9          3861  			EXX
041512 22 4A 4D 04 3862  			LD	(R0+0),HL		; HL: LSW of address
041516 32 4C 4D 04 3863  			LD	(R0+2),A
04151A 06 00       3864  			LD      B,0             	;  B: The parameter counter
04151C 11 00 4B 04 3865  			LD      DE,BUFFER       	; DE: Vector
041520             3866  ;
041520 CD 78 0A 04 3867  CALL1:			CALL    NXT			; Skip whitespace
041524 FE 2C       3868  			CP      ','			; Check for comma
041526 20 1B       3869  			JR      NZ,CALL2		; If no more parameters, then jump here
041528 FD 23       3870  			INC     IY			; Skip to the next character
04152A 04          3871  			INC     B			; Increment the parameter count
04152B CD 78 0A 04 3872  			CALL    NXT			; Skip whitespace
04152F C5          3873  			PUSH    BC
041530 D5          3874  			PUSH    DE
041531 CD 96 0C 04 3875  			CALL    VAR_
041535 D1          3876  			POP     DE
041536 C1          3877  			POP     BC
041537 13          3878  			INC     DE
041538 12          3879  			LD      (DE),A			; Save the parameter type
041539 13          3880  			INC     DE
04153A EB          3881  			EX      DE,HL
04153B ED 1F       3882  			LD	(HL),DE			; Save the parameter address (3 bytes)
04153D 23          3883  			INC	HL
04153E 23          3884  			INC	HL
04153F 23          3885  			INC	HL
041540 EB          3886  			EX      DE,HL
041541 18 DD       3887  			JR      CALL1
041543             3888  ;
041543 78          3889  CALL2:			LD      A,B
041544 32 00 4B 04 3890  			LD      (BUFFER),A      	; Save the parameter count
041548 2A 4A 4D 04 3891  			LD	HL,(R0)			; HL: Address of the code
04154C CD 66 15 04 3892  			CALL    USR1			; And call it
041550 C3 9E 0B 04 3893  			JP      XEQ
041554             3894  
041554             3895  ; USR(address)
041554             3896  ;
041554 CD 2A 03 04 3897  USR:			CALL    ITEMI			; Evaluate the expression
041558 7D          3898  			LD	A,L			;  A: MSB of address
041559 D9          3899  			EXX
04155A 22 4A 4D 04 3900  			LD	(R0+0),HL		; HL: LSW of address
04155E 32 4C 4D 04 3901  			LD	(R0+2),A
041562 2A 4A 4D 04 3902  			LD	HL,(R0)			; Get the 24-bit address in HL
041566             3903  ;
041566 E5          3904  USR1:			PUSH    HL              	; Address on stack
041567 FD E3       3905  			EX      (SP),IY
041569 24          3906  			INC     H               	; Check for PAGE &00FFxx
04156A B4          3907  			OR	H
04156B 21 D5 15 04 3908  			LD      HL,USR2         	; Return address
04156F E5          3909  			PUSH    HL
041570 DD 21 00 4C 3910  			LD      IX,STAVAR
       04          
041575 CC 58 43 04 3911  			CALL    Z,OSCALL        	; Intercept &00FFxx
041579             3912  ;
041579 DD 4E 18    3913  			LD      C, (IX+24)		; F%
04157C C5          3914  			PUSH    BC
04157D             3915  ;
04157D DD 7E 08    3916  			LD	A, (IX+8)		; B% -> MSW
041580 32 4B 4D 04 3917  			LD	(R0+1), A
041584 DD 7E 09    3918  			LD	A, (IX+9)
041587 32 4C 4D 04 3919  			LD	(R0+2), A
04158B DD 7E 0C    3920  			LD	A, (IX+12)		; C% -> LSB
04158E 32 4A 4D 04 3921  			LD	(R0+0), A
041592 ED 4B 4A 4D 3922  			LD	BC, (R0)
       04          
041597             3923  ;
041597 DD 7E 10    3924  			LD	A, (IX+16)		; D% -> MSW
04159A 32 4B 4D 04 3925  			LD	(R0+1), A
04159E DD 7E 11    3926  			LD	A, (IX+17)
0415A1 32 4C 4D 04 3927  			LD	(R0+2), A
0415A5 DD 7E 14    3928  			LD	A, (IX+20)		; E% -> LSB
0415A8 32 4A 4D 04 3929  			LD	(R0+0), A
0415AC ED 5B 4A 4D 3930  			LD	DE, (R0)
       04          
0415B1             3931  ;
0415B1 DD 7E 20    3932  			LD	A, (IX+32)		; H% -> MSW
0415B4 32 4B 4D 04 3933  			LD	(R0+1), A
0415B8 DD 7E 21    3934  			LD	A, (IX+33)
0415BB 32 4C 4D 04 3935  			LD	(R0+2), A
0415BF DD 7E 30    3936  			LD	A, (IX+48)		; L% -> LSB
0415C2 32 4A 4D 04 3937  			LD	(R0+0), A
0415C6 2A 4A 4D 04 3938  			LD	HL, (R0)
0415CA             3939  ;
0415CA F1          3940  			POP     AF			; F%
0415CB DD 7E 04    3941  			LD      A, (IX+4)        	; A%
0415CE             3942  
0415CE DD 21 00 4B 3943  			LD      IX,BUFFER
       04          
0415D3 FD E9       3944  			JP      (IY)            	; Off to user routine
0415D5             3945  ;
0415D5 FD E1       3946  USR2:			POP     IY
0415D7 AF          3947  			XOR     A
0415D8 4F          3948  			LD      C,A
0415D9 C9          3949  			RET
0415DA             3950  
0415DA             3951  ; PUT port,data
0415DA             3952  ;
0415DA CD 0F 03 04 3953  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415DE D9          3954  			EXX
0415DF E5          3955  			PUSH    HL
0415E0 CD 2A 0A 04 3956  			CALL    COMMA
0415E4 CD 0F 03 04 3957  			CALL    EXPRI           ;DATA
0415E8 D9          3958  			EXX
0415E9 C1          3959  			POP     BC
0415EA ED 69       3960  			OUT     (C),L           ;OUTPUT TO PORT BC
0415EC C3 9E 0B 04 3961  			JP      XEQ
0415F0             3962  
0415F0             3963  ; SUBROUTINES -----------------------------------------------------------------
0415F0             3964  
0415F0             3965  ; ASSIGN - Assign a numeric value to a variable.
0415F0             3966  ; Outputs: NC,  Z - OK, numeric.
0415F0             3967  ;          NC, NZ - OK, string.
0415F0             3968  ;           C, NZ - illegal
0415F0             3969  ;
0415F0 CD 90 3A 04 3970  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415F4 D8          3971  			RET     C               	; Return with C if it is an illegal variable
0415F5 C4 7F 3A 04 3972  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415F9 B7          3973  			OR      A
0415FA F8          3974  			RET     M               	; Return if type is string (81h)
0415FB F5          3975  			PUSH    AF              	; It's a numeric type from this point on
0415FC CD C2 17 04 3976  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041600 E5          3977  			PUSH    HL
041601 CD 07 03 04 3978  			CALL    EXPRN
041605 DD E1       3979  			POP     IX
041607 F1          3980  			POP     AF
041608 CB 47       3981  STORE:			BIT     0,A
04160A 28 13       3982  			JR      Z,STOREI
04160C BF          3983  			CP      A               	; Set the variable to 0
04160D DD 71 04    3984  STORE5:			LD      (IX+4),C
041610 D9          3985  STORE4:			EXX
041611 DD 75 00    3986  			LD      (IX+0),L
041614 DD 74 01    3987  			LD      (IX+1),H
041617 D9          3988  			EXX
041618 DD 75 02    3989  			LD      (IX+2),L
04161B DD 74 03    3990  			LD      (IX+3),H
04161E C9          3991  			RET
04161F F5          3992  STOREI:			PUSH    AF
041620 0C          3993  			INC     C               ;SPEED - & PRESERVE F'
041621 0D          3994  			DEC     C               ; WHEN CALLED BY FNEND0
041622 C4 67 06 04 3995  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
041626 F1          3996  			POP     AF
041627 FE 04       3997  			CP      4
041629 28 E5       3998  			JR      Z,STORE4
04162B BF          3999  			CP      A               ;SET ZERO
04162C D9          4000  STORE1:			EXX
04162D DD 75 00    4001  			LD      (IX+0),L
041630 D9          4002  			EXX
041631 C9          4003  			RET
041632             4004  ;
041632             4005  ; Copy a string from the string accumulator to variable storage on the stack
041632             4006  ; Parameters:
041632             4007  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041632             4008  ; - IX: Address of the variable storage on the stack
041632             4009  ;
041632 21 00 4A 04 4010  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041636             4011  ;
041636             4012  ; Parameters:
041636             4013  ; As above, but:
041636             4014  ; - HL: Address of the string to be stored
041636             4015  ; -  E: The string length
041636             4016  ; NB:
041636             4017  ; Strings are mutable
041636             4018  ; Strings are stored in the following format in the variable:
041636             4019  ; - Address of the next variable (3 bytes)
041636             4020  ; - The rest of the variable name - this is zero terminated
041636             4021  ; - Current string length (byte)
041636             4022  ; - Maximum (original) string length (byte)
041636             4023  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041636             4024  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041636             4025  ;
041636 1F          4026  STORES:			RRA				; Rotate right to shift bit 0 into carry
041637 30 5D       4027  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041639 E5          4028  			PUSH    HL			; Stack ACCS
04163A             4029  ;
04163A             4030  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
04163A             4031  ;
04163A D9          4032  			EXX				; This block was a call to LOAD4
04163B DD 6E 00    4033  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04163E DD 66 01    4034  			LD      H,(IX+1)		; The maximum original string length
041641 D9          4035  			EXX
041642 DD 27 02    4036  			LD	HL,(IX+2)		; Address of the string (24-bit)
041645             4037  ;
041645 7B          4038  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041646 D9          4039  			EXX
041647 6F          4040  			LD      L,A			; L': Length of string currently stored on the stack
041648 7C          4041  			LD      A,H             	; H': The maximum (original) string length
041649 D9          4042  			EXX
04164A BB          4043  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
04164B 30 17       4044  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04164D             4045  ;
04164D             4046  ; At this point we're either initialising a new string or assigning more memory to an existing string
04164D             4047  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04164D             4048  ; then the existing and new strings may both exist in memory.
04164D             4049  ;
04164D D9          4050  			EXX
04164E 65          4051  			LD      H,L			; H: Set the maximum string length to the string length
04164F D9          4052  			EXX
041650 E5          4053  			PUSH    HL
041651 01 00 00 00 4054  			LD	BC, 0
041655 4F          4055  			LD      C,A			; BC: The maximum (original) string length
041656 09          4056  			ADD     HL,BC			; Work out whether this is the last string in memory
041657 ED 4B 1D 4D 4057  			LD      BC,(FREE)
       04          
04165C ED 42       4058  			SBC     HL,BC			; Is string last?
04165E E1          4059  			POP     HL
04165F 37          4060  			SCF
041660 28 02       4061  			JR      Z,STORS1
041662             4062  			; LD	HL, BC			; HL=BC
041662 C5          4063  			push bc
041663 E1          4064  			pop hl
041664             4065  ;
041664             4066  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041664             4067  ; - H': The maximum (original) string length
041664             4068  ; - L': The actual string length (must be less than H')
041664             4069  ; - HL: Address of the string in memory
041664             4070  ;
041664 D9          4071  STORS1:			EXX				; This block was a call to STORE4
041665 DD 75 00    4072  			LD      (IX+0),L		; The actual string length (must be less then H')
041668 DD 74 01    4073  			LD      (IX+1),H		; The maximum (original) string length
04166B D9          4074  			EXX
04166C DD 2F 02    4075  			LD	(IX+2),HL		; The pointer to the original string
04166F             4076  ;
04166F 01 00 00 00 4077  			LD	BC, 0
041673 4B          4078  			LD      C,E			; BC: The new string length
041674 EB          4079  			EX      DE,HL
041675 E1          4080  			POP     HL
041676 0D          4081  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041677 0C          4082  			INC     C			; check whether BC is 0 without affecting the carry flag
041678 C8          4083  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041679 ED B0       4084  			LDIR				; Replace the string in memory
04167B D0          4085  			RET     NC
04167C ED 53 1D 4D 4086  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
041681             4087  ;
041681             4088  ; Check whether the stack is full
041681             4089  ;
041681 E5          4090  CHECK:			PUSH    HL
041682 C5          4091  			PUSH	BC
041683 2A 1D 4D 04 4092  			LD      HL,(FREE)		; HL: Address of first free space byte
041687 01 00 01 00 4093  			LD	BC,100h			; BC: One page of memory
04168B 09          4094  			ADD	HL,BC			; Add a page to FREE
04168C ED 72       4095  			SBC     HL,SP			; And subtract the current SP
04168E C1          4096  			POP	BC
04168F E1          4097  			POP     HL
041690 D8          4098  			RET     C			; The SP is not in the same page, so just return
041691 AF          4099  			XOR     A			; Otherwise
041692 C3 B6 37 04 4100  			JP      ERROR_			; Throw error "No room"
041696             4101  ;
041696 01 00 00 00 4102  STORS3:			LD	BC,0
04169A 4B          4103  			LD      C,E			; BC: String length
04169B DD E5       4104  			PUSH    IX
04169D D1          4105  			POP     DE			; DE: Destination
04169E AF          4106  			XOR     A			; Check if string length is 0
04169F B9          4107  			CP      C
0416A0 28 02       4108  			JR      Z,STORS5		; Yes, so don't copy
0416A2 ED B0       4109  			LDIR
0416A4 3E 0D       4110  STORS5:			LD      A,CR			; Finally add the terminator
0416A6 12          4111  			LD      (DE),A
0416A7 C9          4112  			RET
0416A8             4113  
0416A8             4114  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0416A8             4115  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0416A8             4116  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0416A8             4117  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0416A8             4118  ;    Inputs: DE addresses parameter list
0416A8             4119  ;            IY addresses dummy variable list
0416A8             4120  ;   Outputs: DE,IY updated
0416A8             4121  ;  Destroys: Everything
0416A8             4122  ;
0416A8 3E FF       4123  ARGUE:			LD      A,-1
0416AA F5          4124  			PUSH    AF              	; Put marker on the stack
0416AB FD 23       4125  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416AD 13          4126  			INC     DE
0416AE D5          4127  			PUSH    DE
0416AF CD 78 0A 04 4128  			CALL    NXT			; Skip any whitespace
0416B3 CD 90 3A 04 4129  			CALL    GETVAR			; Get the location of the variable in HL/IX
0416B7 38 3F       4130  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B9 C4 7F 3A 04 4131  			CALL    NZ,PUTVAR
0416BD D1          4132  			POP     DE
0416BE E5          4133  			PUSH    HL              	; VARPTR
0416BF B7          4134  			OR      A               	; Check the variable type
0416C0 F5          4135  			PUSH    AF
0416C1 D5          4136  			PUSH    DE
0416C2 FD E3       4137  			EX      (SP),IY
0416C4 FA DC 16 04 4138  			JP      M,ARGUE2        	; Jump here if it is a string
0416C8             4139  ;
0416C8 CD 07 03 04 4140  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416CC FD E3       4141  			EX      (SP),IY
0416CE D1          4142  			POP     DE
0416CF F1          4143  			POP     AF
0416D0 D9          4144  			EXX
0416D1 E5          4145  			PUSH    HL
0416D2 D9          4146  			EXX
0416D3 E5          4147  			PUSH    HL
0416D4 47          4148  			LD      B,A
0416D5 C5          4149  			PUSH    BC
0416D6 CD 81 16 04 4150  			CALL    CHECK           	; Check room
0416DA 18 0F       4151  			JR      ARGUE4
0416DC             4152  ;
0416DC CD 1A 03 04 4153  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416E0 FD E3       4154  			EX      (SP),IY
0416E2 D9          4155  			EXX
0416E3 D1          4156  			POP     DE
0416E4 D9          4157  			EXX
0416E5 F1          4158  			POP     AF
0416E6 CD B9 09 04 4159  			CALL    PUSHS
0416EA D9          4160  			EXX
0416EB             4161  ;
0416EB CD 78 0A 04 4162  ARGUE4:			CALL    NXT			; Skip whitespace
0416EF FE 2C       4163  			CP      ','			; Check to see if the next value is a comma
0416F1 20 0B       4164  			JR      NZ,ARGUE5		; No, so jump here
0416F3 1A          4165  			LD      A,(DE)
0416F4 FE 2C       4166  			CP      ','			; Are there any more arguments?
0416F6 28 B3       4167  			JR      Z,ARGUE1        	; Yes, so loop
0416F8             4168  ;
0416F8 3E 1F       4169  ARGERR:			LD      A,31
0416FA C3 B6 37 04 4170  			JP      ERROR_           	; Throw error "Arguments"
0416FE             4171  ;
0416FE CD 37 0A 04 4172  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
041702 1A          4173  			LD      A,(DE)
041703 FE 29       4174  			CP      ')'
041705 20 F1       4175  			JR      NZ,ARGERR
041707 13          4176  			INC     DE
041708 D9          4177  			EXX
041709 C1          4178  ARGUE6:			POP     BC
04170A 78          4179  			LD      A,B
04170B 3C          4180  			INC     A
04170C D9          4181  			EXX
04170D C8          4182  			RET     Z               	; Marker popped
04170E D9          4183  			EXX
04170F 3D          4184  			DEC     A
041710 FA 20 17 04 4185  			JP      M,ARGUE7        	; If it is a string, then jump here
041714 E1          4186  			POP     HL
041715 D9          4187  			EXX
041716 E1          4188  			POP     HL
041717 D9          4189  			EXX
041718 DD E1       4190  			POP     IX
04171A CD 08 16 04 4191  			CALL    STORE	           	; Write to dummy variable
04171E 18 E9       4192  			JR      ARGUE6
041720             4193  ;
041720 CD E6 09 04 4194  ARGUE7:			CALL    POPS
041724 DD E1       4195  			POP     IX
041726 CD 32 16 04 4196  			CALL    STACCS
04172A 18 DD       4197  			JR      ARGUE6
04172C             4198  
04172C             4199  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
04172C             4200  ;   OF A FUNCTION OR PROCEDURE.
04172C             4201  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
04172C             4202  ;    Inputs: IY is parameters pointer
04172C             4203  ;   Outputs: IY updated
04172C             4204  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
04172C             4205  ;
04172C D1          4206  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
04172D             4207  ;
04172D FD 23       4208  SAVLO1:			INC     IY              	; Bump past '(' or ','
04172F CD 78 0A 04 4209  			CALL    NXT			; And also any whitespace
041733 D5          4210  			PUSH    DE			; Push the return address back onto the stack
041734 D9          4211  			EXX
041735 C5          4212  			PUSH    BC
041736 D5          4213  			PUSH    DE
041737 E5          4214  			PUSH    HL
041738 D9          4215  			EXX
041739 CD 96 0C 04 4216  			CALL    VAR_             	; Dummy variable
04173D D9          4217  			EXX
04173E E1          4218  			POP     HL
04173F D1          4219  			POP     DE
041740 C1          4220  			POP     BC
041741 D9          4221  			EXX
041742 D1          4222  			POP     DE
041743 B7          4223  			OR      A               	; Check the variable type
041744 FA 57 17 04 4224  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041748 D9          4225  			EXX
041749 E5          4226  			PUSH    HL              	; Save H'L'
04174A D9          4227  			EXX
04174B 47          4228  			LD      B,A             	;  B: Variable type
04174C CD 1B 04 04 4229  			CALL    LOADN
041750 D9          4230  			EXX
041751 E3          4231  			EX      (SP),HL
041752 D9          4232  			EXX
041753 E5          4233  			PUSH    HL
041754 C5          4234  			PUSH    BC
041755 18 2D       4235  			JR      SAVLO4
041757             4236  ;
041757 F5          4237  SAVLO2:			PUSH    AF              	; Save the type (string)
041758 D5          4238  			PUSH    DE
041759 D9          4239  			EXX
04175A E5          4240  			PUSH    HL
04175B D9          4241  			EXX
04175C CD A5 04 04 4242  			CALL    LOADS
041760 D9          4243  			EXX
041761 E1          4244  			POP     HL
041762 D9          4245  			EXX
041763 01 00 00 00 4246  			LD	BC,0
041767 4B          4247  			LD      C,E			; BC: String length
041768 D1          4248  			POP     DE
041769 CD 81 16 04 4249  			CALL    CHECK			; Check if there is space on the stack
04176D F1          4250  			POP     AF              	; Level stack
04176E 21 00 00 00 4251  			LD      HL,0
041772 ED 42       4252  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041774 39          4253  			ADD     HL,SP			; Make space for the string on the stack
041775 F9          4254  			LD      SP,HL
041776 47          4255  			LD      B,A             	;  B: Variable type
041777 C5          4256  			PUSH    BC
041778 28 0A       4257  			JR      Z,SAVLO4
04177A D5          4258  			PUSH    DE
04177B 11 00 4A 04 4259  			LD      DE,ACCS
04177F EB          4260  			EX      DE,HL
041780 45          4261  			LD      B,L
041781 ED B0       4262  			LDIR                    	; Save the string onto the stack
041783 D1          4263  			POP     DE
041784             4264  ;
041784 DD E5       4265  SAVLO4:			PUSH    IX			; VARPTR
041786 CD 8A 17 04 4266  			CALL    SAVLO5
04178A             4267  LOCCHK:			EQU     $
04178A CD 81 16 04 4268  SAVLO5:			CALL    CHECK
04178E CD 78 0A 04 4269  			CALL    NXT
041792 FE 2C       4270  			CP      ','             	; Are there any more local variables?
041794 28 97       4271  			JR      Z,SAVLO1		; Yes, so loop
041796 EB          4272  			EX      DE,HL			; DE -> HL: The return address
041797 E9          4273  			JP      (HL)            	; And effectvely return
041798             4274  ;
041798 FD 7E 00    4275  DELIM:			LD      A,(IY)          	; Assembler delimiter
04179B FE 20       4276  			CP      ' '
04179D C8          4277  			RET     Z
04179E FE 2C       4278  			CP      ','
0417A0 C8          4279  			RET     Z
0417A1 FE 29       4280  			CP      ')'
0417A3 C8          4281  			RET     Z
0417A4 FE 3B       4282  TERM:			CP      ';'             	; Assembler terminator
0417A6 C8          4283  			RET     Z
0417A7 FE 5C       4284  			CP      '\'
0417A9 C8          4285  			RET     Z
0417AA 18 07       4286  			JR      TERM0
0417AC             4287  ;
0417AC CD 78 0A 04 4288  TERMQ:			CALL    NXT
0417B0 FE 8B       4289  			CP      ELSE_
0417B2 D0          4290  			RET     NC
0417B3 FE 3A       4291  TERM0:			CP      ':'             	; Assembler seperator
0417B5 D0          4292  			RET     NC
0417B6 FE 0D       4293  			CP      CR
0417B8 C9          4294  			RET
0417B9             4295  ;
0417B9 CD AC 17 04 4296  SPAN:			CALL    TERMQ
0417BD C8          4297  			RET     Z
0417BE FD 23       4298  			INC     IY
0417C0 18 F7       4299  			JR      SPAN
0417C2             4300  ;
0417C2             4301  ; This snippet is used to check whether an expression is followed by an '=' symbol
0417C2             4302  ;
0417C2 CD 78 0A 04 4303  EQUALS:			CALL    NXT			; Skip whitespace
0417C6 FD 23       4304  			INC     IY			; Skip past the character in question
0417C8 FE 3D       4305  			CP      '='			; Is it '='
0417CA C8          4306  			RET     Z			; Yes, so return
0417CB 3E 04       4307  			LD      A,4			; Otherwise
0417CD C3 B6 37 04 4308  			JP      ERROR_           	; Throw error "Mistake"
0417D1             4309  ;
0417D1 FE 8A       4310  FORMAT:			CP      TAB
0417D3 28 0D       4311  			JR      Z,DOTAB
0417D5 FE 89       4312  			CP      SPC
0417D7 28 40       4313  			JR      Z,DOSPC
0417D9 FE 27       4314  			CP      '''
0417DB C0          4315  			RET     NZ
0417DC CD 9D 39 04 4316  			CALL    CRLF
0417E0 AF          4317  			XOR     A
0417E1 C9          4318  			RET
0417E2             4319  ;
0417E2 C5          4320  DOTAB:			PUSH    BC
0417E3 CD 0F 03 04 4321  			CALL    EXPRI
0417E7 D9          4322  			EXX
0417E8 C1          4323  			POP     BC
0417E9 FD 7E 00    4324  			LD      A,(IY)
0417EC FE 2C       4325  			CP      ','
0417EE 28 14       4326  			JR      Z,DOTAB1
0417F0 CD 37 0A 04 4327  			CALL    BRAKET
0417F4 7D          4328  			LD      A,L
0417F5 21 3D 4D 04 4329  TABIT:			LD      HL,COUNT
0417F9 BE          4330  			CP      (HL)
0417FA C8          4331  			RET     Z
0417FB F5          4332  			PUSH    AF
0417FC DC 9D 39 04 4333  			CALL    C,CRLF
041800 F1          4334  			POP     AF
041801 96          4335  			SUB     (HL)
041802 18 1D       4336  			JR      FILL
041804 FD 23       4337  DOTAB1:			INC     IY
041806 C5          4338  			PUSH    BC
041807 E5          4339  			PUSH    HL
041808 CD 0F 03 04 4340  			CALL    EXPRI
04180C D9          4341  			EXX
04180D D1          4342  			POP     DE
04180E C1          4343  			POP     BC
04180F CD 37 0A 04 4344  			CALL    BRAKET
041813 CD 17 3F 04 4345  			CALL    PUTCSR
041817 AF          4346  			XOR     A
041818 C9          4347  			RET
041819             4348  ;
041819 C5          4349  DOSPC:			PUSH    BC
04181A CD 2A 03 04 4350  			CALL    ITEMI
04181E D9          4351  			EXX
04181F 7D          4352  			LD      A,L
041820 C1          4353  			POP     BC
041821 B7          4354  FILL:			OR      A
041822 C8          4355  			RET     Z
041823 C5          4356  			PUSH    BC
041824 47          4357  			LD      B,A
041825 3E 20       4358  FILL1:			LD      A,' '
041827 CD A5 39 04 4359  			CALL    OUTCHR
04182B 10 F8       4360  			DJNZ    FILL1
04182D C1          4361  			POP     BC
04182E AF          4362  			XOR     A
04182F C9          4363  			RET
041830             4364  ;
041830 21 00 4A 04 4365  PTEXT:			LD      HL,ACCS
041834 1C          4366  			INC     E
041835 1D          4367  PTEXT1:			DEC     E
041836 C8          4368  			RET     Z
041837 7E          4369  			LD      A,(HL)
041838 23          4370  			INC     HL
041839 CD A5 39 04 4371  			CALL    OUTCHR
04183D 18 F6       4372  			JR      PTEXT1
04183F             4373  ;
04183F F5          4374  FETCHS:			PUSH    AF
041840 C5          4375  			PUSH    BC
041841 E5          4376  			PUSH    HL
041842 FD E3       4377  			EX      (SP),IY
041844 CD 5F 18 04 4378  			CALL    XTRACT
041848 CD 78 0A 04 4379  			CALL    NXT
04184C FD E3       4380  			EX      (SP),IY
04184E E1          4381  			POP     HL
04184F C1          4382  			POP     BC
041850 F1          4383  			POP     AF
041851 C9          4384  			RET
041852             4385  ;
041852 11 00 4A 04 4386  LINES:			LD      DE,ACCS
041856 7E          4387  LINE1S:			LD      A,(HL)
041857 12          4388  			LD      (DE),A
041858 FE 0D       4389  			CP      CR
04185A C8          4390  			RET     Z
04185B 23          4391  			INC     HL
04185C 1C          4392  			INC     E
04185D 18 F7       4393  			JR      LINE1S
04185F             4394  ;
04185F CD 78 0A 04 4395  XTRACT:			CALL    NXT
041863 FE 22       4396  			CP      '"'
041865 FD 23       4397  			INC     IY
041867 CA 6C 04 04 4398  			JP      Z,CONS
04186B FD 2B       4399  			DEC     IY
04186D 11 00 4A 04 4400  			LD      DE,ACCS
041871 FD 7E 00    4401  XTRAC1:			LD      A,(IY)
041874 12          4402  			LD      (DE),A
041875 FE 2C       4403  			CP      ','
041877 C8          4404  			RET     Z
041878 FE 0D       4405  			CP      CR
04187A C8          4406  			RET     Z
04187B FD 23       4407  			INC     IY
04187D 1C          4408  			INC     E
04187E 18 F1       4409  			JR      XTRAC1
041880             4410  
041880             4411  ; Search for a token at the start of a program line
041880             4412  ; - HL: Pointer to the start of a tokenised line in the program area
041880             4413  ; Returns:
041880             4414  ; - HL: Pointer to the
041880             4415  ; -  F: Carry set if not found
041880             4416  ; Corrupts:
041880             4417  ; - BC
041880             4418  ;
041880 01 00 00 00 4419  SEARCH_EX:			LD      BC,0			; Clear BC
041884             4420  ;
041884 4E          4421  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041885 0C          4422  			INC     C			; Check for 0, i.e. end of program marker
041886 0D          4423  			DEC     C
041887 28 0B       4424  			JR      Z,SRCH2_EX         	; Not found the token, so end
041889 23          4425  			INC     HL			; Skip the line length and line number
04188A 23          4426  			INC     HL
04188B 23          4427  			INC     HL
04188C BE          4428  			CP      (HL)			; Compare with the token
04188D C8          4429  			RET     Z			; Found it, so return with carry not set
04188E 0D          4430  			DEC     C			; Skip to the next line
04188F 0D          4431  			DEC     C
041890 0D          4432  			DEC     C
041891 09          4433  			ADD     HL,BC
041892 18 F0       4434  			JR      SRCH1_EX			; Rinse, lather and repeat
041894             4435  ;
041894 2B          4436  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041895 37          4437  			SCF				; And set the carry flag
041896 C9          4438  			RET
041897             4439  
041897             4440  ; Multiply by 4 or 5
041897             4441  ; This function is used to allocate space for dimensioned variables
041897             4442  ; This is a 24-bit operation
041897             4443  ; - DE: Number to multiple
041897             4444  ; -  A: 04h (Integer) - takes up 4 bytes
041897             4445  ;       05h (Float)   - takes up 5 bytes
041897             4446  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
041897             4447  ; Returns:
041897             4448  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
041897             4449  ; -  F: Carry if overflow
041897             4450  ; Corrupts:
041897             4451  ; - HL
041897 FE 04       4452  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041899             4453  			; LD	HL,DE
041899 D5          4454  			push de
04189A E1          4455  			pop hl
04189B 29          4456  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04189C D8          4457  			RET     C			; Exit if overflow
04189D 29          4458  			ADD     HL,HL			; Multiply by 2 again
04189E D8          4459  			RET     C			; Exit if overflow
04189F EB          4460  			EX      DE,HL			; DE: Product
0418A0 C8          4461  			RET     Z			; Exit if A = 4
0418A1 19          4462  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0418A2 EB          4463  			EX      DE,HL			; DE: Product
0418A3 C9          4464  			RET
0418A4             4465  
0418A4             4466  ; 16-bit unsigned multiply
0418A4             4467  ; - HL: Operand 1
0418A4             4468  ; - BC: Operand 2
0418A4             4469  ; Returns:
0418A4             4470  ; - HL: Result
0418A4             4471  ; -  F: C if overflow
0418A4             4472  ;
0418A4 C5          4473  MUL16:			PUSH	BC
0418A5 51          4474  			LD	D, C			; Set up the registers for the multiplies
0418A6 5D          4475  			LD	E, L
0418A7 69          4476  			LD	L, C
0418A8 4B          4477  			LD	C, E
0418A9 ED 6C       4478  			MLT	HL			; HL = H * C (*256)
0418AB ED 5C       4479  			MLT	DE			; DE = L * C
0418AD ED 4C       4480  			MLT	BC			; BC = B * L (*256)
0418AF 09          4481  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418B0 C1          4482  			POP	BC
0418B1 AF          4483  			XOR	A
0418B2 9C          4484  			SBC	H			; If H is not zero then it's an overflow
0418B3 D8          4485  			RET	C
0418B4 65          4486  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418B5 6F          4487  			LD	L, A
0418B6 19          4488  			ADD	HL, DE
0418B7 C9          4489  			RET
0418B8             4490  ;
0418B8 CD 78 0A 04 4491  CHANEL:			CALL    NXT			; Skip whitespace
0418BC FE 23       4492  			CP      '#'			; Check for the '#' symbol
0418BE 3E 2D       4493  			LD      A,45
0418C0 C2 B6 37 04 4494  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418C4 FD 23       4495  CHNL:			INC     IY             		; Bump past the '#'
0418C6 CD 2A 03 04 4496  			CALL    ITEMI			; Get the channel number
0418CA D9          4497  			EXX
0418CB EB          4498  			EX      DE,HL			; DE: The channel number
0418CC C9          4499  			RET
0418CD             4500  
0418CD             4501  ; ASSEMBLER -------------------------------------------------------------------
0418CD             4502  
0418CD             4503  ; Language independant control section:
0418CD             4504  ;  Outputs: A=delimiter, carry set if syntax error.
0418CD             4505  ;
0418CD CD ED 1D 04 4506  ASSEM:			CALL    SKIP
0418D1 FD 23       4507  			INC     IY
0418D3 FE 3A       4508  			CP      ':'
0418D5 28 F6       4509  			JR      Z,ASSEM
0418D7 FE 5D       4510  			CP      ']'
0418D9 C8          4511  			RET     Z
0418DA FE 0D       4512  			CP      CR
0418DC C8          4513  			RET     Z
0418DD FD 2B       4514  			DEC     IY
0418DF DD 2A 40 4C 4515  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       04          
0418E4 21 40 4D 04 4516  			LD      HL,LISTON
0418E8 CB 76       4517  			BIT     6,(HL)
0418EA 28 05       4518  			JR      Z,ASSEM0
0418EC DD 2A 3C 4C 4519  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       04          
0418F1 DD E5       4520  ASSEM0:			PUSH    IX
0418F3 FD E5       4521  			PUSH    IY
0418F5 CD A5 19 04 4522  			CALL    ASMB
0418F9 C1          4523  			POP     BC
0418FA D1          4524  			POP     DE
0418FB D8          4525  			RET     C
0418FC CD ED 1D 04 4526  			CALL    SKIP
041900 37          4527  			SCF
041901 C0          4528  			RET     NZ
041902 FD 2B       4529  			DEC     IY
041904 FD 23       4530  ASSEM3:			INC     IY
041906 FD 7E 00    4531  			LD      A,(IY)
041909 CD B3 17 04 4532  			CALL    TERM0
04190D 20 F5       4533  			JR      NZ,ASSEM3
04190F 3A 40 4D 04 4534  			LD      A,(LISTON)
041913 DD E5       4535  			PUSH    IX
041915 E1          4536  			POP     HL
041916 B7          4537  			OR      A
041917 ED 52       4538  			SBC     HL,DE
041919 EB          4539  			EX      DE,HL           	; DE: Number of bytes
04191A E5          4540  			PUSH    HL
04191B 2A 40 4C 04 4541  			LD      HL,(PC)
04191F E5          4542  			PUSH    HL
041920 19          4543  			ADD     HL,DE
041921 22 40 4C 04 4544  			LD      (PC),HL         	; Update PC
041925 CB 77       4545  			BIT     6,A
041927 28 09       4546  			JR      Z,ASSEM5
041929 2A 3C 4C 04 4547  			LD      HL,(OC)
04192D 19          4548  			ADD     HL,DE
04192E 22 3C 4C 04 4549  			LD      (OC),HL         	; Update OC
041932 E1          4550  ASSEM5:			POP     HL              	; Old PC
041933 DD E1       4551  			POP     IX              	; Code here
041935 CB 67       4552  			BIT     4,A
041937 28 94       4553  			JR      Z,ASSEM
041939 22 4A 4D 04 4554  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04193D 3A 4C 4D 04 4555  			LD	A,(R0+2)		; Print out the address
041941 CD 8F 19 04 4556  			CALL	HEX_EX
041945 7C          4557  			LD      A,H
041946 CD 8F 19 04 4558  			CALL    HEX_EX
04194A 7D          4559  			LD      A,L
04194B CD 87 19 04 4560  			CALL    HEXSP
04194F AF          4561  			XOR     A
041950 BB          4562  			CP      E
041951 28 18       4563  			JR      Z,ASSEM2
041953             4564  ;
041953 3A 3D 4D 04 4565  ASSEM1:			LD      A,(COUNT)
041957 FE 14       4566  			CP      20
041959 3E 07       4567  			LD      A,7
04195B D4 F5 17 04 4568  			CALL    NC,TABIT        	; Next line
04195F DD 7E 00    4569  			LD      A,(IX)
041962 CD 87 19 04 4570  			CALL    HEXSP
041966 DD 23       4571  			INC     IX
041968 1D          4572  			DEC     E
041969 20 E8       4573  			JR      NZ,ASSEM1
04196B             4574  ;
04196B 3E 16       4575  ASSEM2:			LD      A,22			; Tab to the disassembly field
04196D CD F5 17 04 4576  			CALL    TABIT
041971 FD E5       4577  			PUSH    IY
041973 E1          4578  			POP     HL
041974 ED 42       4579  			SBC     HL,BC
041976 0A          4580  ASSEM4:			LD      A,(BC)
041977 CD C2 39 04 4581  			CALL    OUT_
04197B 03          4582  			INC     BC
04197C 2D          4583  			DEC     L
04197D 20 F7       4584  			JR      NZ,ASSEM4
04197F CD 9D 39 04 4585  			CALL    CRLF
041983 C3 CD 18 04 4586  			JP      ASSEM
041987             4587  ;
041987 CD 8F 19 04 4588  HEXSP:			CALL    HEX_EX
04198B 3E 20       4589  			LD      A,' '
04198D 18 12       4590  			JR      OUTCH1
04198F F5          4591  HEX_EX:			PUSH    AF
041990 0F          4592  			RRCA
041991 0F          4593  			RRCA
041992 0F          4594  			RRCA
041993 0F          4595  			RRCA
041994 CD 99 19 04 4596  			CALL    HEXOUT
041998 F1          4597  			POP     AF
041999 E6 0F       4598  HEXOUT:			AND     0FH
04199B C6 90       4599  			ADD     A,90H
04199D 27          4600  			DAA
04199E CE 40       4601  			ADC     A,40H
0419A0 27          4602  			DAA
0419A1 C3 C2 39 04 4603  OUTCH1:			JP      OUT_
0419A5             4604  
0419A5             4605  ; Processor Specific Translation Section:
0419A5             4606  ;
0419A5             4607  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0419A5             4608  ;                 C: Opcode beig built
0419A5             4609  ;                 D: Flags
0419A5             4610  ;			Bit 7: Set to 1 if the instruction uses long addressing
0419A5             4611  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0419A5             4612  ;                 E: Offset from IX or IY
0419A5             4613  ;                HL: Numeric operand value
0419A5             4614  ;                IX: Code destination pointer
0419A5             4615  ;                IY: Source text pointer
0419A5             4616  ;    Inputs: A = initial character
0419A5             4617  ;   Outputs: Carry set if syntax error.
0419A5             4618  ;
0419A5 FE 2E       4619  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0419A7 20 1F       4620  			JR      NZ,ASMB1		; No, so just process the instruction
0419A9 FD 23       4621  			INC     IY			; Skip past the dot to the label name
0419AB DD E5       4622  			PUSH    IX			; Store the code destination pointer
0419AD CD 96 0C 04 4623  			CALL    VAR_			; Create a variable
0419B1 F5          4624  			PUSH    AF
0419B2 CD 98 09 04 4625  			CALL    ZERO			; Zero it
0419B6 3A 42 4C 04 4626  			LD	A,(PC+2)
0419BA 6F          4627  			LD	L,A			; The MSB of the 24-bit address
0419BB D9          4628  			EXX
0419BC 2A 40 4C 04 4629  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419C0 D9          4630  			EXX
0419C1 F1          4631  			POP     AF
0419C2 CD 08 16 04 4632  			CALL    STORE			; Store the program counter
0419C6 DD E1       4633  			POP     IX			; Restore the code destination pointer
0419C8             4634  ;
0419C8 3A 40 4D 04 4635  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419CC E6 80       4636  			AND	80H
0419CE 57          4637  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419CF CD ED 1D 04 4638  			CALL    SKIP			; Skip any whitespace
0419D3 C8          4639  			RET     Z			; And return if there is nothing further to process
0419D4 FE D6       4640  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419D6 0E C4       4641  			LD      C,0C4H			;  A: The base operand
0419D8 FD 23       4642  			INC     IY			; Skip past the token
0419DA CA 22 1B 04 4643  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419DE FD 2B       4644  			DEC     IY			; Skip back, as we're not doing the above at this point
0419E0 21 04 1E 04 4645  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419E4 CD 9C 1D 04 4646  			CALL    FIND			; Find the opcode
0419E8 D8          4647  			RET     C			; If not found, then return; carry indicates an error condition
0419E9 48          4648  			LD      C,B     		;  C: A copy of the opcode
0419EA             4649  ;
0419EA             4650  ; GROUP 0: Trivial cases requiring no computation
0419EA             4651  ; GROUP 1: As Group 0, but with "ED" prefix
0419EA             4652  ;
0419EA D6 44       4653  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419EC 30 08       4654  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419EE FE CB       4655  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419F0 D4 F5 1C 04 4656  			CALL    NC,ED			; Needs to be prefixed with ED
0419F4 18 76       4657  			JR      BYTE0			; Then write the opcode byte
0419F6             4658  ;
0419F6             4659  ; GROUP 2: BIT, RES, SET
0419F6             4660  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419F6             4661  ;
0419F6 D6 0A       4662  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419F8 30 12       4663  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419FA FE F9       4664  			CP      3-10			;
0419FC DC 8A 1D 04 4665  			CALL    C,BIT_
041A00 D8          4666  			RET     C
041A01 CD 5B 1D 04 4667  			CALL    REGLO
041A05 D8          4668  			RET     C
041A06 CD F9 1C 04 4669  			CALL    CB
041A0A 18 60       4670  			JR      BYTE0
041A0C             4671  ;
041A0C             4672  ; GROUP 4 - PUSH, POP, EX (SP)
041A0C             4673  ;
041A0C D6 03       4674  GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A0E 30 07       4675  			JR      NC,GROUP05		; If not in that range, then check GROUP5
041A10 CD 7D 1D 04 4676  GROUP04_1:		CALL    PAIR_EX
041A14 D8          4677  			RET     C
041A15 18 55       4678  			JR      BYTE0
041A17             4679  ;
041A17             4680  ; GROUP 5 - SUB, AND, XOR, OR, CP
041A17             4681  ; GROUP 6 - ADD, ADC, SBC
041A17             4682  ;
041A17 D6 0A       4683  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A19 30 39       4684  			JR      NC,GROUP07
041A1B FE FD       4685  			CP      5-8
041A1D 06 07       4686  			LD      B,7
041A1F D4 09 1D 04 4687  			CALL    NC,OPND			; Get the first operand
041A23 78          4688  			LD      A,B
041A24 FE 07       4689  			CP      7			; Is the operand 'A'?
041A26 20 15       4690  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A28             4691  ;
041A28 CD 5B 1D 04 4692  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A2C 79          4693  			LD      A,C
041A2D 30 2E       4694  			JR      NC,BIND1		; If it is a register, then write that out
041A2F EE 46       4695  			XOR     46H			; Handle ADD A,n
041A31 CD FB 1C 04 4696  			CALL    BIND
041A35 CD 3B 1D 04 4697  DB_:			CALL    NUMBER
041A39 C3 F4 1A 04 4698  			JP      VAL8
041A3D             4699  ;
041A3D E6 3F       4700  GROUP05_HL:		AND     3FH
041A3F FE 0C       4701  			CP      12
041A41 37          4702  			SCF
041A42 C0          4703  			RET     NZ
041A43 79          4704  			LD      A,C
041A44 FE 80       4705  			CP      80H
041A46 0E 09       4706  			LD      C,9
041A48 28 C6       4707  			JR      Z,GROUP04_1
041A4A EE 1C       4708  			XOR     1CH
041A4C 0F          4709  			RRCA
041A4D 4F          4710  			LD      C,A
041A4E CD F5 1C 04 4711  			CALL    ED
041A52 18 BC       4712  			JR      GROUP04_1
041A54             4713  ;
041A54             4714  ; GROUP 7 - INC, DEC
041A54             4715  ;
041A54 D6 02       4716  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A56 30 19       4717  			JR      NC,GROUP08
041A58 CD 62 1D 04 4718  			CALL    REGHI
041A5C 79          4719  			LD      A,C
041A5D D2 FB 1C 04 4720  BIND1:			JP      NC,BIND
041A61 EE 64       4721  			XOR     64H
041A63 07          4722  			RLCA
041A64 07          4723  			RLCA
041A65 07          4724  			RLCA
041A66 4F          4725  			LD      C,A
041A67 CD 82 1D 04 4726  			CALL    PAIR1_EX
041A6B D8          4727  			RET     C
041A6C 79          4728  BYTE0:			LD      A,C
041A6D C3 2A 1D 04 4729  			JP      BYTE_
041A71             4730  ;
041A71             4731  ; Group 8: IN0, OUT0
041A71             4732  ;
041A71 D6 02       4733  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A73 30 2C       4734  			JR	NC,GROUP09
041A75 FE FF       4735  			CP	1-2
041A77 CC 3B 1D 04 4736  			CALL    Z,NUMBER		; Fetch number first if OUT
041A7B 08          4737  			EX      AF,AF'			; Save flags
041A7C CD 4F 1D 04 4738  			CALL    REG			; Get the register value regardless
041A80 D8          4739  			RET     C			; Return if not a register
041A81 08          4740  			EX      AF,AF'			; Restore the flags
041A82 DC 3B 1D 04 4741  			CALL    C,NUMBER		; Fetch number last if IN
041A86 78          4742  			LD	A,B			; Get the register number
041A87 FE 06       4743  			CP	6			; Fail on (HL)
041A89 37          4744  			SCF
041A8A C8          4745  			RET	Z
041A8B FE 08       4746  			CP	8			; Check it is just single pairs only
041A8D 3F          4747  			CCF
041A8E D8          4748  			RET	C			; And return if it is an invalid register
041A8F 07          4749  			RLCA				; Bind with the operand
041A90 07          4750  			RLCA
041A91 07          4751  			RLCA
041A92 81          4752  			ADD	A,C
041A93 4F          4753  			LD	C,A
041A94 CD F5 1C 04 4754  			CALL	ED			; Prefix with ED
041A98 79          4755  			LD	A,C
041A99 CD 2A 1D 04 4756  			CALL	BYTE_			; Write out the operand
041A9D C3 F4 1A 04 4757  			JP	VAL8			; Write out the value
041AA1             4758  ;
041AA1             4759  ; GROUP 9 - IN
041AA1             4760  ; GROUP 10 - OUT
041AA1             4761  ;
041AA1 D6 02       4762  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041AA3 30 25       4763  			JR      NC,GROUP11
041AA5 FE FF       4764  			CP      1-2			; Check if Group 9 or Group 1
041AA7 CC E9 1C 04 4765  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AAB 08          4766  			EX      AF,AF'			; Save flags
041AAC CD 62 1D 04 4767  			CALL    REGHI			; Get the register value regardless
041AB0 D8          4768  			RET     C			; Return if not a register
041AB1 08          4769  			EX      AF,AF'			; Restore the flags
041AB2 DC E9 1C 04 4770  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041AB6 24          4771  			INC     H			; If it is IN r,(C) or OUT (C),r then
041AB7 28 B3       4772  			JR      Z,BYTE0			; Just write the operand out
041AB9             4773  ;
041AB9 78          4774  			LD      A,B			; Check the register
041ABA FE 07       4775  			CP      7
041ABC 37          4776  			SCF
041ABD C0          4777  			RET     NZ			; If it is not A, then return
041ABE             4778  ;
041ABE 79          4779  			LD      A,C			; Bind the register with the operand
041ABF EE 03       4780  			XOR     3
041AC1 07          4781  			RLCA
041AC2 07          4782  			RLCA
041AC3 07          4783  			RLCA
041AC4 CD 2A 1D 04 4784  			CALL    BYTE_			; Write out the operand
041AC8 18 2A       4785  			JR      VAL8			; And the value
041ACA             4786  ;
041ACA             4787  ; GROUP 11 - JR, DJNZ
041ACA             4788  ;
041ACA D6 02       4789  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041ACC 30 2B       4790  			JR      NC,GROUP12
041ACE FE FF       4791  			CP      1-2
041AD0 C4 69 1D 04 4792  			CALL    NZ,COND_
041AD4 79          4793  			LD      A,C
041AD5 30 02       4794  			JR      NC,@F
041AD7 3E 18       4795  			LD      A,18H
041AD9 CD 2A 1D 04 4796  @@:			CALL    BYTE_
041ADD CD 3B 1D 04 4797  			CALL    NUMBER
041AE1 ED 5B 40 4C 4798  			LD      DE,(PC)
       04          
041AE6 13          4799  			INC     DE
041AE7 37          4800  			SCF
041AE8 ED 52       4801  			SBC     HL,DE
041AEA 7D          4802  			LD      A,L
041AEB 17          4803  			RLA
041AEC 9F          4804  			SBC     A,A
041AED BC          4805  			CP      H
041AEE 3E 01       4806  TOOFAR:			LD      A,1
041AF0 C2 B6 37 04 4807  			JP      NZ,ERROR_		; Throw an "Out of range" error
041AF4 7D          4808  VAL8:			LD      A,L
041AF5 C3 2A 1D 04 4809  			JP      BYTE_
041AF9             4810  ;
041AF9             4811  ; GROUP 12 - JP
041AF9             4812  ;
041AF9 D6 01       4813  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AFB 30 21       4814  			JR	NC,GROUP13
041AFD CD 4F 1C 04 4815  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041B01 D8          4816  			RET	C			; Exit if an invalid suffix is provided
041B02 CD 69 1D 04 4817  			CALL    COND_			; Evaluate the conditions
041B06 79          4818  			LD      A,C
041B07 30 0D       4819  			JR      NC,GROUP12_1
041B09 78          4820  			LD      A,B
041B0A E6 3F       4821  			AND     3FH
041B0C FE 06       4822  			CP      6
041B0E 3E E9       4823  			LD      A,0E9H
041B10 CA 2A 1D 04 4824  			JP      Z,BYTE_
041B14 3E C3       4825  			LD      A,0C3H
041B16 CD 2A 1D 04 4826  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B1A C3 A4 1C 04 4827  			JP	ADDR_			; Output the address
041B1E             4828  ;
041B1E             4829  ; GROUP 13 - CALL
041B1E             4830  ;
041B1E D6 01       4831  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B20 30 0C       4832  			JR	NC,GROUP14
041B22 CD 67 1C 04 4833  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B26 CD 49 1B 04 4834  			CALL    GROUP15_1		; Output the opcode (with conditions)
041B2A C3 A4 1C 04 4835  			JP	ADDR_			; Output the address
041B2E             4836  ;
041B2E             4837  ; GROUP 14 - RST
041B2E             4838  ;
041B2E D6 01       4839  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B30 30 13       4840  			JR	NC,GROUP15
041B32 CD 67 1C 04 4841  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B36 D8          4842  			RET	C			; Exit if an invalid suffix provided
041B37 CD 3B 1D 04 4843  			CALL    NUMBER
041B3B A1          4844  			AND     C
041B3C B4          4845  			OR      H
041B3D 20 AF       4846  			JR      NZ,TOOFAR
041B3F 7D          4847  			LD      A,L
041B40 B1          4848  			OR      C
041B41 C3 2A 1D 04 4849  	  		JP      BYTE_
041B45             4850  ;
041B45             4851  ; GROUP 15 - RET
041B45             4852  ;
041B45 D6 01       4853  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B47 30 0F       4854  			JR	NC,GROUP16
041B49 CD 69 1D 04 4855  GROUP15_1:		CALL    COND_
041B4D 79          4856  			LD      A,C
041B4E D2 2A 1D 04 4857  			JP      NC,BYTE_
041B52 F6 09       4858  			OR      9
041B54 C3 2A 1D 04 4859  			JP      BYTE_
041B58             4860  ;
041B58             4861  ; GROUP 16 - LD
041B58             4862  ;
041B58 D6 01       4863  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B5A 30 74       4864  			JR	NC,GROUP17
041B5C CD 67 1C 04 4865  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B60 CD 98 1D 04 4866  			CALL    LDOP			; Check for accumulator loads
041B64 D2 C4 1C 04 4867  			JP      NC,LDA			; Yes, so jump here
041B68 CD 62 1D 04 4868  			CALL    REGHI
041B6C 08          4869  			EX      AF,AF'
041B6D CD ED 1D 04 4870  			CALL    SKIP
041B71 FE 28       4871  			CP      '('			; Check for bracket
041B73 28 24       4872  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B75 08          4873  			EX      AF,AF'
041B76 D2 28 1A 04 4874  			JP      NC,GROUP05_1		; Load single register direct; go here
041B7A 0E 01       4875  			LD      C,1
041B7C CD 82 1D 04 4876  			CALL    PAIR1_EX
041B80 D8          4877  			RET     C
041B81 3E 0E       4878  			LD      A,14
041B83 B8          4879  			CP      B
041B84 47          4880  			LD      B,A
041B85 CC 7D 1D 04 4881  			CALL    Z,PAIR_EX
041B89 78          4882  			LD      A,B
041B8A E6 3F       4883  			AND     3FH
041B8C FE 0C       4884  			CP      12
041B8E 79          4885  			LD      A,C
041B8F C2 16 1B 04 4886  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B93 3E F9       4887  			LD      A,0F9H
041B95 C3 2A 1D 04 4888  			JP      BYTE_
041B99             4889  ;
041B99 08          4890  LDIN:			EX      AF,AF'
041B9A C5          4891  			PUSH    BC
041B9B D4 5B 1D 04 4892  			CALL    NC,REGLO
041B9F 79          4893  			LD      A,C
041BA0 C1          4894  			POP     BC
041BA1 D2 FB 1C 04 4895  			JP      NC,BIND
041BA5 0E 0A       4896  			LD      C,0AH
041BA7 CD 82 1D 04 4897  			CALL    PAIR1_EX
041BAB CD CF 1C 04 4898  			CALL    LD16
041BAF D2 16 1B 04 4899  			JP      NC,GROUP12_1
041BB3 CD 3B 1D 04 4900  			CALL    NUMBER
041BB7 0E 02       4901  			LD      C,2
041BB9 CD 7D 1D 04 4902  			CALL    PAIR_EX
041BBD CD CF 1C 04 4903  			CALL    LD16
041BC1 D8          4904  			RET     C
041BC2 CD 2A 1D 04 4905  			CALL    BYTE_
041BC6 CB 7A       4906  			BIT	7,D			; Check the ADL flag
041BC8 C2 B9 1C 04 4907  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BCC C3 AC 1C 04 4908  			JP      VAL16			; Otherwise use 16-bit addresses
041BD0             4909  ;
041BD0             4910  ; Group 17 - TST
041BD0             4911  ;
041BD0 D6 01       4912  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BD2 30 25       4913  			JR	NC,OPTS
041BD4 CD F5 1C 04 4914  			CALL	ED			; Needs to be prefixed with ED
041BD8 CD 4F 1D 04 4915  			CALL	REG			; Fetch the register
041BDC 30 0E       4916  			JR	NC,GROUP17_1		; It's just a register
041BDE             4917  ;
041BDE 3E 64       4918  			LD	A,64H			; Opcode for TST n
041BE0 CD 2A 1D 04 4919  			CALL	BYTE_			; Write out the opcode
041BE4 CD 3B 1D 04 4920  			CALL	NUMBER			; Get the number
041BE8 C3 F4 1A 04 4921  			JP	VAL8			; And write that out
041BEC             4922  ;
041BEC 78          4923  GROUP17_1:		LD	A,B			; Check the register rangs
041BED FE 08       4924  			CP	8
041BEF 3F          4925  			CCF
041BF0 D8          4926  			RET	C			; Ret with carry flag set for error if out of range
041BF1 07          4927  			RLCA				; Get the opcode value
041BF2 07          4928  			RLCA
041BF3 07          4929  			RLCA
041BF4 81          4930  			ADD	A,C			; Add the opcode base in
041BF5 C3 2A 1D 04 4931  			JP	BYTE_
041BF9             4932  
041BF9             4933  ;
041BF9             4934  ; Assembler directives - OPT, ADL
041BF9             4935  ;
041BF9 D6 02       4936  OPTS:			SUB	2
041BFB 30 2B       4937  			JR	NC, DEFS
041BFD FE FF       4938  			CP	1-2			; Check for ADL opcode
041BFF 28 13       4939  			JR	Z, ADL_
041C01             4940  ;
041C01 CD 3B 1D 04 4941  OPT:			CALL    NUMBER			; Fetch the OPT value
041C05 21 40 4D 04 4942  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041C09 E6 07       4943  			AND	7			; Only interested in the first three bits
041C0B 4F          4944  			LD      C,A			; Store the new OPT value in C
041C0C ED 6F       4945  			RLD				; Shift the top nibble of LISTON (OPT) into A
041C0E E6 08       4946  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041C10 B1          4947  			OR	C			; OR in the new value
041C11 ED 67       4948  			RRD				; And shift the nibble back in
041C13 C9          4949  			RET
041C14             4950  ;
041C14 CD 3B 1D 04 4951  ADL_:			CALL	NUMBER			; Fetch the ADL value
041C18 E6 01       4952  			AND	1			; Only interested if it is 0 or 1
041C1A 0F          4953  			RRCA				; Rotate to bit 7
041C1B 4F          4954  			LD	C,A			; Store in C
041C1C 3A 40 4D 04 4955  			LD	A,(LISTON)		; Get the LISTON system variable
041C20 E6 7F       4956  			AND	7Fh			; Clear bit 7
041C22 B1          4957  			OR	C			; OR in the ADL value
041C23 32 40 4D 04 4958  			LD	(LISTON),A		; Store
041C27 C9          4959  			RET
041C28             4960  ;
041C28             4961  ; DEFB, DEFW, DEFL, DEFM
041C28             4962  ;
041C28 B7          4963  DEFS:			OR	A			; Handle DEFB
041C29 CA 35 1A 04 4964  			JP	Z, DB_
041C2D 3D          4965  			DEC	A			; Handle DEFW
041C2E CA A8 1C 04 4966  			JP	Z, ADDR16
041C32 3D          4967  			DEC	A			; Handle DEFL
041C33 CA B5 1C 04 4968  			JP	Z, ADDR24
041C37             4969  ;
041C37 DD E5       4970  			PUSH    IX			; Handle DEFM
041C39 CD 1A 03 04 4971  			CALL    EXPRS
041C3D DD E1       4972  			POP     IX
041C3F 21 00 4A 04 4973  			LD      HL,ACCS
041C43 AF          4974  @@:			XOR     A
041C44 BB          4975  			CP      E
041C45 C8          4976  			RET     Z
041C46 7E          4977  			LD      A,(HL)
041C47 23          4978  			INC     HL
041C48 CD 2A 1D 04 4979  			CALL    BYTE_
041C4C 1D          4980  			DEC     E
041C4D 18 F4       4981  			JR      @B
041C4F             4982  
041C4F             4983  ;
041C4F             4984  ;SUBROUTINES:
041C4F             4985  ;
041C4F FD 7E 00    4986  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C52 FE 2E       4987  			CP	'.'
041C54 28 02       4988  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C56 B7          4989  			OR	A			; Reset the carry flag (no error)
041C57 C9          4990  			RET				; And return
041C58 FD 23       4991  @@:			INC	IY			; Skip the dot
041C5A C5          4992  			PUSH	BC			; Push the operand
041C5B 21 83 20 04 4993  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C5F CD 9C 1D 04 4994  			CALL	FIND			; Look up the operand
041C63 30 24       4995  			JR	NC,EZ80SF_OK
041C65 C1          4996  			POP	BC			; Not found at this point, so will return with a C (error)
041C66 C9          4997  			RET
041C67             4998  ;
041C67 FD 7E 00    4999  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C6A FE 2E       5000  			CP	'.'
041C6C 28 02       5001  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C6E B7          5002  			OR	A			; Reset the carry flag (no error)
041C6F C9          5003  			RET				; And return
041C70 FD 23       5004  @@:			INC	IY 			; Skip the dot
041C72 C5          5005  			PUSH	BC			; Push the operand
041C73 21 7B 20 04 5006  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C77 CD 9C 1D 04 5007  			CALL	FIND 			; Look up the operand
041C7B 30 0C       5008  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C7D CD 98 1C 04 5009  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C81 CD 9C 1D 04 5010  			CALL	FIND
041C85 30 02       5011  			JR	NC,EZ80SF_OK
041C87 C1          5012  			POP	BC			; Not found at this point, so will return with a C (error)
041C88 C9          5013  			RET
041C89             5014  ;
041C89 78          5015  EZ80SF_OK:		LD	A,B			; The operand value
041C8A D4 2A 1D 04 5016  			CALL	NC,BYTE_ 		; Write it out if found
041C8E CB BA       5017  			RES	7,D			; Clear the default ADL mode from the flags
041C90 E6 02       5018  			AND	2			; Check the second half of the suffix (.xxL)
041C92 0F          5019  			RRCA				; Shift into bit 7
041C93 0F          5020  			RRCA
041C94 B2          5021  			OR	D			; Or into bit 7 of D
041C95 57          5022  			LD	D,A
041C96 C1          5023  			POP	BC 			; Restore the operand
041C97 C9          5024  			RET
041C98             5025  ;
041C98 21 8C 20 04 5026  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C9C CB 7A       5027  			BIT 	7,D			; if bit 7 of D is 0
041C9E C8          5028  			RET	Z
041C9F 21 97 20 04 5029  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041CA3 C9          5030  			RET
041CA4             5031  ;
041CA4 CB 7A       5032  ADDR_:			BIT	7,D			; Check the ADL flag
041CA6 20 0D       5033  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CA8             5034  ;
041CA8 CD 3B 1D 04 5035  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CAC CD F4 1A 04 5036  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CB0 7C          5037  			LD      A,H
041CB1 C3 2A 1D 04 5038  			JP      BYTE_
041CB5             5039  ;
041CB5 CD 3B 1D 04 5040  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CB9 CD AC 1C 04 5041  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CBD D9          5042  			EXX
041CBE 7D          5043  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CBF D9          5044  			EXX
041CC0 C3 2A 1D 04 5045  			JP	BYTE_
041CC4             5046  ;
041CC4 FE 04       5047  LDA:			CP      4
041CC6 DC F5 1C 04 5048  			CALL    C,ED
041CCA 78          5049  			LD      A,B
041CCB C3 2A 1D 04 5050  			JP      BYTE_
041CCF             5051  ;
041CCF 78          5052  LD16:			LD      A,B
041CD0 38 0F       5053  			JR      C,LD8
041CD2 78          5054  			LD      A,B
041CD3 E6 3F       5055  			AND     3FH
041CD5 FE 0C       5056  			CP      12
041CD7 79          5057  			LD      A,C
041CD8 C8          5058  			RET     Z
041CD9 CD F5 1C 04 5059  			CALL    ED
041CDD 79          5060  			LD      A,C
041CDE F6 43       5061  			OR      43H
041CE0 C9          5062  			RET
041CE1             5063  ;
041CE1 FE 07       5064  LD8:			CP      7
041CE3 37          5065  			SCF
041CE4 C0          5066  			RET     NZ
041CE5 79          5067  			LD      A,C
041CE6 F6 30       5068  			OR      30H
041CE8 C9          5069  			RET
041CE9             5070  ;
041CE9             5071  ; Used in IN and OUT to handle whether the operand is C or a number
041CE9             5072  ;
041CE9 C5          5073  CORN:			PUSH    BC
041CEA CD 09 1D 04 5074  			CALL    OPND			; Get the operand
041CEE CB 68       5075  			BIT     5,B
041CF0 C1          5076  			POP     BC
041CF1 28 48       5077  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CF3 26 FF       5078  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CF5             5079  ;
041CF5 3E ED       5080  ED:			LD      A,0EDH			; Write an ED prefix out
041CF7 18 31       5081  			JR      BYTE_
041CF9             5082  ;
041CF9 3E CB       5083  CB:			LD      A,0CBH
041CFB FE 76       5084  BIND:			CP      76H
041CFD 37          5085  			SCF
041CFE C8          5086  			RET     Z               	; Reject LD (HL),(HL)
041CFF CD 2A 1D 04 5087  			CALL    BYTE_
041D03 CB 72       5088  			BIT	6,D			; Check the index bit in flags
041D05 C8          5089  			RET     Z
041D06 7B          5090  			LD      A,E			; If there is an index, output the offset
041D07 18 21       5091  			JR      BYTE_
041D09             5092  ;
041D09             5093  ; Search through the operand table
041D09             5094  ; Returns:
041D09             5095  ; - B: The operand type
041D09             5096  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041D09             5097  ; - E: The IX/IY offset
041D09             5098  ; - F: Carry if not found
041D09             5099  ;
041D09 E5          5100  OPND:			PUSH    HL			; Preserve HL
041D0A 21 0D 20 04 5101  			LD      HL,OPRNDS		; The operands table
041D0E CD 9C 1D 04 5102  			CALL    FIND			; Find the operand
041D12 E1          5103  			POP     HL
041D13 D8          5104  			RET     C			; Return if not found
041D14 CB 78       5105  			BIT     7,B			; Check if it is an index register (IX, IY)
041D16 C8          5106  			RET     Z			; Return if it isn't
041D17 CB F2       5107  			SET	6,D			; Set flag to indicate we've got an index
041D19 CB 58       5108  			BIT     3,B			; Check if an offset is required
041D1B E5          5109  			PUSH    HL
041D1C CC 31 1D 04 5110  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D20 5D          5111  			LD      E,L			; E: The offset
041D21 E1          5112  			POP     HL
041D22 3E DD       5113  			LD	A,DDH			; IX prefix
041D24 CB 70       5114  			BIT     6,B			; If bit 6 is reset then
041D26 28 02       5115  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D28 3E FD       5116  			LD	A,FDH			; IY prefix
041D2A             5117  ;
041D2A DD 77 00    5118  BYTE_:			LD      (IX),A			; Write a byte out
041D2D DD 23       5119  			INC     IX
041D2F B7          5120  			OR      A
041D30 C9          5121  			RET
041D31             5122  ;
041D31 FD 7E 00    5123  OFFSET_EX:			LD      A,(IY)
041D34 FE 29       5124  			CP      ')'
041D36 21 00 00 00 5125  			LD      HL,0
041D3A C8          5126  			RET     Z
041D3B CD ED 1D 04 5127  NUMBER:			CALL    SKIP
041D3F C5          5128  			PUSH    BC
041D40 D5          5129  			PUSH    DE
041D41 DD E5       5130  			PUSH    IX
041D43 CD 0F 03 04 5131  			CALL    EXPRI
041D47 DD E1       5132  			POP     IX
041D49 D9          5133  			EXX
041D4A D1          5134  			POP     DE
041D4B C1          5135  			POP     BC
041D4C 7D          5136  			LD      A,L
041D4D B7          5137  			OR      A
041D4E C9          5138  			RET
041D4F             5139  ;
041D4F CD 09 1D 04 5140  REG:			CALL    OPND
041D53 D8          5141  			RET     C
041D54 78          5142  			LD      A,B
041D55 E6 3F       5143  			AND     3FH
041D57 FE 08       5144  			CP      8
041D59 3F          5145  			CCF
041D5A C9          5146  			RET
041D5B             5147  ;
041D5B CD 4F 1D 04 5148  REGLO:			CALL    REG
041D5F D8          5149  			RET     C
041D60 18 33       5150  			JR      ORC
041D62             5151  ;
041D62 CD 4F 1D 04 5152  REGHI:			CALL    REG
041D66 D8          5153  			RET     C
041D67 18 29       5154  			JR      SHL3
041D69             5155  ;
041D69 CD 09 1D 04 5156  COND_:			CALL    OPND
041D6D D8          5157  			RET     C
041D6E 78          5158  			LD      A,B
041D6F E6 1F       5159  			AND     1FH
041D71 D6 10       5160  			SUB     16
041D73 30 1D       5161  			JR      NC,SHL3
041D75 FE F1       5162  			CP      -15
041D77 37          5163  			SCF
041D78 C0          5164  			RET     NZ
041D79 3E 03       5165  			LD      A,3
041D7B 18 15       5166  			JR      SHL3
041D7D             5167  ;
041D7D CD 09 1D 04 5168  PAIR_EX:			CALL    OPND
041D81 D8          5169  			RET     C
041D82 78          5170  PAIR1_EX:			LD      A,B
041D83 E6 0F       5171  			AND     0FH
041D85 D6 08       5172  			SUB     8
041D87 D8          5173  			RET     C
041D88 18 08       5174  			JR      SHL3
041D8A             5175  ;
041D8A CD 3B 1D 04 5176  BIT_:			CALL    NUMBER
041D8E FE 08       5177  			CP      8
041D90 3F          5178  			CCF
041D91 D8          5179  			RET     C
041D92 07          5180  SHL3:			RLCA
041D93 07          5181  			RLCA
041D94 07          5182  			RLCA
041D95 B1          5183  ORC:			OR      C
041D96 4F          5184  			LD      C,A
041D97 C9          5185  			RET
041D98             5186  ;
041D98 21 52 20 04 5187  LDOP:			LD      HL,LDOPS
041D9C             5188  
041D9C             5189  ;
041D9C             5190  ; Look up a value in a table
041D9C             5191  ; Parameters:
041D9C             5192  ; - IY: Address of the assembly language line in the BASIC program area
041D9C             5193  ; - HL: Address of the table
041D9C             5194  ; Returns:
041D9C             5195  ; - B: The operand code
041D9C             5196  ; - F: Carry set if not found
041D9C             5197  ;
041D9C CD ED 1D 04 5198  FIND:			CALL    SKIP			; Skip delimiters
041DA0             5199  ;
041DA0 06 00       5200  EXIT_:			LD      B,0			; Set B to 0
041DA2 37          5201  			SCF				; Set the carry flag
041DA3 C8          5202  			RET     Z			; Returns if Z
041DA4             5203  ;
041DA4 FE DD       5204  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041DA6 28 04       5205  			JR      Z,FIND0
041DA8 FE 85       5206  			CP      TOR+1			; Special case for tokens AND and OR
041DAA 3F          5207  			CCF
041DAB D8          5208  			RET     C
041DAC 7E          5209  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DAD B7          5210  			OR      A
041DAE 28 F0       5211  			JR      Z,EXIT_			; Exit
041DB0 FD AE 00    5212  			XOR     (IY)
041DB3 E6 5F       5213  			AND     01011111B
041DB5 28 09       5214  			JR      Z,FIND2
041DB7 CB 7E       5215  FIND1:			BIT     7,(HL)
041DB9 23          5216  			INC     HL
041DBA 28 FB       5217  			JR      Z,FIND1
041DBC 23          5218  			INC     HL
041DBD 04          5219  			INC     B
041DBE 18 EC       5220  			JR      FIND0
041DC0             5221  ;
041DC0 FD E5       5222  FIND2:			PUSH    IY
041DC2 CB 7E       5223  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DC4 FD 23       5224  			INC     IY
041DC6 23          5225  			INC     HL
041DC7 20 11       5226  			JR      NZ,FIND5		; Yes
041DC9 BE          5227  			CP      (HL)
041DCA CC EC 1D 04 5228  			CALL    Z,SKIP0
041DCE 7E          5229  			LD      A,(HL)
041DCF FD AE 00    5230  			XOR     (IY)
041DD2 E6 5F       5231  			AND     01011111B
041DD4 28 EC       5232  			JR      Z,FIND3
041DD6 FD E1       5233  FIND4:			POP     IY
041DD8 18 DD       5234  			JR      FIND1
041DDA             5235  ;
041DDA CD 98 17 04 5236  FIND5:			CALL    DELIM			; Is it a delimiter?
041DDE C4 01 1E 04 5237  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DE2 C4 FB 1D 04 5238  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DE6 20 EE       5239  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DE8             5240  ;
041DE8 78          5241  FIND6:			LD      A,B			; At this point we have a token
041DE9 46          5242  			LD      B,(HL)			; Fetch the token type code
041DEA E1          5243  			POP     HL			; Restore the stack
041DEB C9          5244  			RET
041DEC             5245  ;
041DEC 23          5246  SKIP0:			INC     HL
041DED CD 98 17 04 5247  SKIP:			CALL    DELIM			; Is it a delimiter?
041DF1 C0          5248  			RET     NZ			; No, so return
041DF2 CD A4 17 04 5249  			CALL    TERM			; Is it a terminator?
041DF6 C8          5250  			RET     Z			; Yes, so return
041DF7 FD 23       5251  			INC     IY			; Increment the basic program counter
041DF9 18 F2       5252  			JR      SKIP			; And loop
041DFB             5253  ;
041DFB FE 2B       5254  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DFD C8          5255  			RET     Z
041DFE FE 2D       5256  			CP      '-'
041E00 C9          5257  			RET
041E01             5258  ;
041E01 FE 2E       5259  DOT:			CP	'.'			; Check if it is a dot character
041E03 C9          5260  			RET
041E04             5261  ; Z80 opcode list
041E04             5262  ;
041E04             5263  ; Group 0: (15 opcodes)
041E04             5264  ; Trivial cases requiring no computation
041E04             5265  ;
041E04 4E 4F 50 00 5266  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E08 52 4C 43 41 5267  			DB	"RLC","A"+80H,07h
       07          
041E0D 45 58 00 41 5268  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041E17 52 52 43 41 5269  			DB	"RRC","A"+80H,0FH
       0F          
041E1C 52 4C 41 17 5270  			DB	"RL","A"+80H,17H
041E20 52 52 41 1F 5271  			DB	"RR","A"+80H,1FH
041E24 44 41 41 27 5272  			DB	"DA","A"+80H,27H
041E28 43 50 4C 2F 5273  			DB	"CP","L"+80H,2FH
041E2C 53 43 46 37 5274  			DB	"SC","F"+80H,37H
041E30 43 43 46 3F 5275  			DB	"CC","F"+80H,3FH
041E34 48 41 4C 54 5276  			DB	"HAL","T"+80H,76H
       76          
041E39 45 58 58 D9 5277  			DB	"EX","X"+80H,D9H
041E3D 45 58 00 44 5278  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
041E46 44 49 F3    5279  			DB	"D","I"+80H,F3H
041E49 45 49 FB    5280  			DB	"E","I"+80H,FBH
041E4C             5281  ;
041E4C             5282  ; Group 1: (53 opcodes)
041E4C             5283  ; As Group 0, but with an ED prefix
041E4C             5284  ;
041E4C 4E 45 47 44 5285  			DB	"NE","G"+80H,44H	; 0Fh
041E50 49 4D 00 30 5286  			DB	"IM",0,"0"+80H,46H
       46          
041E55 52 45 54 4E 5287  			DB	"RET","N"+80H,45H
       45          
041E5A 4D 4C 54 00 5288  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
041E61 52 45 54 49 5289  			DB	"RET","I"+80H,4DH
       4D          
041E66 49 4D 00 31 5290  			DB	"IM",0,"1"+80H,56H
       56          
041E6B 4D 4C 54 00 5291  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
041E72 49 4D 00 32 5292  			DB	"IM",0,"2"+80H,5EH
       5E          
041E77 52 52 44 67 5293  			DB	"RR","D"+80H,67H
041E7B 4D 4C 54 00 5294  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
041E82 4C 44 00 4D 5295  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
041E8A 4C 44 00 41 5296  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
041E92 52 4C 44 6F 5297  			DB	"RL","D"+80H,6FH
041E96 53 4C 50 76 5298  			DB	"SL","P"+80H,76H
041E9A 4D 4C 54 00 5299  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041EA1 53 54 4D 49 5300  			DB	"STMI","X"+80H,7DH
       58 7D       
041EA7 52 53 4D 49 5301  			DB	"RSMI","X"+80H,7EH
       58 7E       
041EAD 49 4E 49 4D 5302  			DB	"INI","M"+80H,82H
       82          
041EB2 4F 54 49 4D 5303  			DB	"OTI","M"+80H,83H
       83          
041EB7 49 4E 49 32 5304  			DB	"INI","2"+80H,84H
       84          
041EBC 49 4E 44 4D 5305  			DB	"IND","M"+80H,8AH
       8A          
041EC1 4F 54 44 4D 5306  			DB	"OTD","M"+80H,8BH
       8B          
041EC6 49 4E 44 32 5307  			DB	"IND","2"+80H,8CH
       8C          
041ECB 49 4E 49 4D 5308  			DB	"INIM","R"+80H,92H
       52 92       
041ED1 4F 54 49 4D 5309  			DB	"OTIM","R"+80H,93H
       52 93       
041ED7 49 4E 49 32 5310  			DB	"INI2","R"+80H,94H
       52 94       
041EDD 49 4E 44 4D 5311  			DB	"INDM","R"+80H,9AH
       52 9A       
041EE3 4F 54 44 4D 5312  			DB	"OTDM","R"+80H,9BH
       52 9B       
041EE9 49 4E 44 32 5313  			DB	"IND2","R"+80H,9CH
       52 9C       
041EEF 4C 44 49 A0 5314  			DB	"LD","I"+80H,A0H
041EF3 43 50 49 A1 5315  			DB	"CP","I"+80H,A1H
041EF7 49 4E 49 A2 5316  			DB	"IN","I"+80H,A2H
041EFB 4F 55 54 49 5317  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041F01 4F 55 54 49 5318  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041F06 4C 44 44 A8 5319  			DB	"LD","D"+80H,A8H
041F0A 43 50 44 A9 5320  			DB	"CP","D"+80H,A9H
041F0E 49 4E 44 AA 5321  			DB	"IN","D"+80H,AAH
041F12 4F 55 54 44 5322  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041F18 4F 55 54 44 5323  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
041F1D 4C 44 49 52 5324  			DB	"LDI","R"+80H,B0H
       B0          
041F22 43 50 49 52 5325  			DB	"CPI","R"+80H,B1H
       B1          
041F27 49 4E 49 52 5326  			DB	"INI","R"+80H,B2H
       B2          
041F2C 4F 54 49 52 5327  			DB	"OTI","R"+80H,B3H
       B3          
041F31 4F 54 49 32 5328  			DB	"OTI2","R"+80H,B4H
       52 B4       
041F37 4C 44 44 52 5329  			DB	"LDD","R"+80H,B8H
       B8          
041F3C 43 50 44 52 5330  			DB	"CPD","R"+80H,B9H
       B9          
041F41 49 4E 44 52 5331  			DB	"IND","R"+80H,BAH
       BA          
041F46 4F 54 44 52 5332  			DB	"OTD","R"+80H,BBH
       BB          
041F4B 4F 54 44 32 5333  			DB	"OTD2","R"+80H,BCH
       52 BC       
041F51 49 4E 49 52 5334  			DB	"INIR","X"+80H,C2H
       58 C2       
041F57 4F 54 49 52 5335  			DB	"OTIR","X"+80H,C3H
       58 C3       
041F5D 49 4E 44 52 5336  			DB	"INDR","X"+80H,CAH
       58 CA       
041F63 4F 54 44 52 5337  			DB	"OTDR","X"+80H,CBH
       58 CB       
041F69             5338  ;
041F69             5339  ; Group 2: (3 opcodes)
041F69             5340  ;
041F69 42 49 54 40 5341  			DB	"BI","T"+80H,40H	; 44h
041F6D 52 45 53 80 5342  			DB	"RE","S"+80H,80H
041F71 53 45 54 C0 5343  			DB	"SE","T"+80H,C0H
041F75             5344  ;
041F75             5345  ; Group 3: (7 opcodes)
041F75             5346  ;
041F75 52 4C 43 00 5347  			DB	"RL","C"+80H,00H	; 47h
041F79 52 52 43 08 5348  			DB	"RR","C"+80H,08H
041F7D 52 4C 10    5349  			DB	"R","L"+80H,10H
041F80 52 52 18    5350  			DB	"R","R"+80H,18H
041F83 53 4C 41 20 5351  			DB	"SL","A"+80H,20H
041F87 53 52 41 28 5352  			DB	"SR","A"+80H,28H
041F8B 53 52 4C 38 5353  			DB	"SR","L"+80H,38H
041F8F             5354  ;
041F8F             5355  ; Group 4: (3 opcodes)
041F8F             5356  ;
041F8F 50 4F 50 C1 5357  			DB	"PO","P"+80H,C1H	; 4Eh
041F93 50 55 53 48 5358  			DB	"PUS","H"+80H,C5H
       C5          
041F98 45 58 00 28 5359  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
041F9F             5360  ;
041F9F             5361  ; Group 5: (7 opcodes)
041F9F             5362  ;
041F9F 53 55 42 90 5363  			DB	"SU","B"+80H,90H	; 51h
041FA3 41 4E 44 A0 5364  			DB	"AN","D"+80H,A0H
041FA7 58 4F 52 A8 5365  			DB	"XO","R"+80H,A8H
041FAB 4F 52 B0    5366  			DB	"O","R"+80H,B0H
041FAE 43 50 B8    5367  			DB	"C","P"+80H,B8H
041FB1 80 A0       5368  			DB	TAND,A0H		; 56h TAND: Tokenised AND
041FB3 84 B0       5369  			DB	TOR,B0H			; 57h TOR: Tokenised OR
041FB5             5370  ;
041FB5             5371  ; Group 6 (3 opcodes)
041FB5             5372  ;
041FB5 41 44 44 80 5373  			DB	"AD","D"+80H,80H	; 58h
041FB9 41 44 43 88 5374  			DB	"AD","C"+80H,88H
041FBD 53 42 43 98 5375  			DB	"SB","C"+80H,98H
041FC1             5376  ;
041FC1             5377  ; Group 7: (2 opcodes)
041FC1             5378  ;
041FC1 49 4E 43 04 5379  			DB	"IN","C"+80H,04H	; 5Bh
041FC5 44 45 43 05 5380  			DB	"DE","C"+80H,05H
041FC9             5381  ;
041FC9             5382  ; Group 8: (2 opcodes)
041FC9             5383  ;
041FC9 49 4E 30 00 5384  			DB	"IN","0"+80H,00H	; 5Dh
041FCD 4F 55 54 30 5385  			DB	"OUT","0"+80H,01H
       01          
041FD2             5386  ;
041FD2             5387  ; Group 9: (1 opcode)
041FD2             5388  ;
041FD2 49 4E 40    5389  			DB	"I","N"+80H,40H		; 5Fh
041FD5             5390  ;
041FD5             5391  ; Group 10: (1 opcode)
041FD5             5392  ;
041FD5 4F 55 54 41 5393  			DB	"OU","T"+80H,41H	; 60h
041FD9             5394  ;
041FD9             5395  ; Group 11: (2 opcodes)
041FD9             5396  ;
041FD9 4A 52 20    5397  			DB	"J","R"+80H,20H		; 61h
041FDC 44 4A 4E 5A 5398  			DB	"DJN","Z"+80H,10H
       10          
041FE1             5399  ;
041FE1             5400  ; Group 12: (1 opcode)
041FE1             5401  ;
041FE1 4A 50 C2    5402  			DB	"J","P"+80H,C2H		; 63h
041FE4             5403  ;
041FE4             5404  ; Group 13: (1 opcode)
041FE4             5405  ;
041FE4 43 41 4C 4C 5406  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041FE9             5407  ;
041FE9             5408  ; Group 14: (1 opcode)
041FE9             5409  ;
041FE9 52 53 54 C7 5410  			DB	"RS","T"+80H,C7H	; 65h
041FED             5411  ;
041FED             5412  ; Group 15: (1 opcode)
041FED             5413  ;
041FED 52 45 54 C0 5414  			DB	"RE","T"+80H,C0H	; 66h
041FF1             5415  ;
041FF1             5416  ; Group 16: (1 opcode)
041FF1             5417  ;
041FF1 4C 44 40    5418  			DB	"L","D"+80H,40H		; 67h
041FF4             5419  ;
041FF4             5420  ; Group 17: (1 opcode)
041FF4             5421  ;
041FF4 54 53 54 04 5422  			DB	"TS","T"+80H,04H	; 68h
041FF8             5423  
041FF8             5424  ;
041FF8             5425  ; Assembler Directives
041FF8             5426  ;
041FF8 4F 50 54 00 5427  			DB	"OP","T"+80H,00H	; 69h OPT
041FFC 41 44 4C 00 5428  			DB	"AD","L"+80H,00H	; 6Ah ADL
042000             5429  ;
042000 5D 42 00    5430  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
042003 5D 57 00    5431  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042006 5D 4C 00    5432  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042009 5D 4D 00    5433  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
04200C             5434  ;
04200C 00          5435  			DB	0
04200D             5436  ;
04200D             5437  ; Operands
04200D             5438  ;
04200D 42 00       5439  OPRNDS:			DB	"B"+80H, 00H
04200F 43 01       5440  			DB	"C"+80H, 01H
042011 44 02       5441  			DB	"D"+80H, 02H
042013 45 03       5442  			DB	"E"+80H, 03H
042015 48 04       5443  			DB	"H"+80H, 04H
042017 4C 05       5444  			DB	"L"+80H, 05H
042019 28 48 4C 06 5445  			DB	"(H","L"+80H,06H
04201D 41 07       5446  			DB	"A"+80H, 07H
04201F 28 49 58 86 5447  			DB	"(I","X"+80H,86H
042023 28 49 59 C6 5448  			DB	"(I","Y"+80H,C6H
042027             5449  ;
042027 42 43 08    5450  			DB	"B","C"+80H,08H
04202A 44 45 0A    5451  			DB	"D","E"+80H,0AH
04202D 48 4C 0C    5452  			DB	"H","L"+80H,0CH
042030 49 58 8C    5453  			DB	"I","X"+80H,8CH
042033 49 59 CC    5454  			DB	"I","Y"+80H,CCH
042036 41 46 0E    5455  			DB	"A","F"+80H,0EH
042039 53 50 0E    5456  			DB	"S","P"+80H,0EH
04203C             5457  ;
04203C 4E 5A 10    5458  			DB	"N","Z"+80H,10H
04203F 5A 11       5459  			DB	"Z"+80H,11H
042041 4E 43 12    5460  			DB	"N","C"+80H,12H
042044 50 4F 14    5461  			DB	"P","O"+80H,14H
042047 50 45 15    5462  			DB	"P","E"+80H,15H
04204A 50 16       5463  			DB	"P"+80H,16H
04204C 4D 17       5464  			DB	"M"+80H,17H
04204E             5465  ;
04204E 28 43 20    5466  			DB	"(","C"+80H,20H
042051             5467  ;
042051 00          5468  			DB	0
042052             5469  ;
042052             5470  ; Load operations
042052             5471  ;
042052 49 00 41 47 5472  LDOPS:			DB	"I",0,"A"+80H,47H
042056 52 00 41 4F 5473  			DB	"R",0,"A"+80H,4FH
04205A 41 00 49 57 5474  			DB	"A",0,"I"+80H,57H
04205E 41 00 52 5F 5475  			DB	"A",0,"R"+80H,5FH
042062 28 42 43 00 5476  			DB	"(BC",0,"A"+80H,02h
       41 02       
042068 28 44 45 00 5477  			DB	"(DE",0,"A"+80H,12H
       41 12       
04206E 41 00 28 42 5478  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
042074 41 00 28 44 5479  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
04207A             5480  ;
04207A 00          5481  			DB	0
04207B             5482  ;
04207B             5483  ; eZ80 addressing mode suffixes
04207B             5484  ;
04207B             5485  ; Fully qualified suffixes
04207B             5486  ;
04207B 4C 49 53 49 5487  EZ80SFS_1:		DB	"LI","S"+80H,49H
04207F 53 49 4C 52 5488  			DB	"SI","L"+80H,52H
042083 53 49 53 40 5489  EZ80SFS_2:		DB	"SI","S"+80H,40H
042087 4C 49 4C 5B 5490  			DB	"LI","L"+80H,5BH
04208B             5491  ;
04208B 00          5492  			DB	0
04208C             5493  ;
04208C             5494  ; Shortcuts when ADL mode is 0
04208C             5495  ;
04208C 53 40       5496  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
04208E 4C 49       5497  			DB	"L"+80H,49H		; Equivalent to .LIS
042090 49 53 40    5498  			DB	"I","S"+80H,40H		; Equivalent to .SIS
042093 49 4C 52    5499  			DB	"I","L"+80H,52H		; Equivalent to .SIL
042096             5500  ;
042096 00          5501  			DB	0
042097             5502  ;
042097             5503  ; Shortcuts when ADL mode is 1
042097             5504  ;
042097 53 52       5505  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042099 4C 5B       5506  			DB	"L"+80H,5BH		; Equivalent to .LIL
04209B 49 53 49    5507  			DB	"I","S"+80H,49H		; Equivalent to .LIS
04209E 49 4C 5B    5508  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0420A1             5509  ;
0420A1 00          5510  			DB	0
0420A2             5511  ;
0420A2             5512  ; .LIST
0420A2             5513  ;
0420A2             5514  ; already defined in equs.inc
0420A2             5515  ; LF:			EQU     0AH
0420A2             5516  ; CR:			EQU     0DH; --- End exec.asm ---
0420A2             5517  
0420A2             5518  ; --- Begin fpp.asm ---
0420A2             5519  ;
0420A2             5520  ; Title:	BBC Basic Interpreter - Z80 version
0420A2             5521  ;		Z80 Floating Point Package
0420A2             5522  ; Author:	(C) Copyright  R.T.Russell  1986
0420A2             5523  ; Modified By:	Dean Belfield
0420A2             5524  ; Created:	03/05/2022
0420A2             5525  ; Last Updated:	07/06/2023
0420A2             5526  ;
0420A2             5527  ; Modinfo:
0420A2             5528  ; 26/10/1986:	Version 0.0
0420A2             5529  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0420A2             5530  ; 12/05/2023:	Modified by Dean Belfield
0420A2             5531  ; 07/06/2023:	Modified to run in ADL mode
0420A2             5532  
0420A2             5533  			; .ASSUME	ADL = 1
0420A2             5534  
0420A2             5535  			; SEGMENT CODE
0420A2             5536  
0420A2             5537  			; XDEF	FPP
0420A2             5538  			; XDEF	DLOAD5
0420A2             5539  			; XDEF	DLOAD5_SPL
0420A2             5540  ;
0420A2             5541  ;BINARY FLOATING POINT REPRESENTATION:
0420A2             5542  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0420A2             5543  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0420A2             5544  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0420A2             5545  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0420A2             5546  ;
0420A2             5547  ;BINARY INTEGER REPRESENTATION:
0420A2             5548  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0420A2             5549  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0420A2             5550  ;
0420A2             5551  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0420A2             5552  ;                            EXPONENT - C
0420A2             5553  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0420A2             5554  ;                               EXPONENT - B
0420A2             5555  
0420A2             5556  ;
0420A2             5557  ;Error codes:
0420A2             5558  ;
0420A2             5559  
0420A2             5560  ; BADOP:			EQU     1               ;Bad operation code
0420A2             5561  ; DIVBY0:			EQU     18              ;Division by zero
0420A2             5562  ; TOOBIG_FP:			EQU     20              ;Too big
0420A2             5563  ; NGROOT:			EQU     21              ;Negative root
0420A2             5564  ; LOGRNG:			EQU     22              ;Log range
0420A2             5565  ; ACLOST:			EQU     23              ;Accuracy lost
0420A2             5566  ; EXPRNG:			EQU     24              ;Exp range
0420A2             5567  ;
0420A2             5568  ;Call entry and despatch code:
0420A2             5569  ;
0420A2 FD E5       5570  FPP:			PUSH    IY              ;Save IY
0420A4 FD 21 00 00 5571          		LD      IY,0
       00          
0420A9 FD 39       5572          		ADD     IY,SP           ;Save SP in IY
0420AB CD BB 20 04 5573          		CALL    OP              ;Perform operation
0420AF BF          5574          		CP      A               ;Good return (Z, NC)
0420B0 FD E1       5575  EXIT_FP_:			POP     IY              ;Restore IY
0420B2 C9          5576          		RET                     ;Return to caller
0420B3             5577  ;
0420B3             5578  ;Error exit:
0420B3             5579  ;
0420B3 3E 01       5580  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420B5 FD F9       5581  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420B7 B7          5582          		OR      A               ;Set NZ
0420B8 37          5583          		SCF                     ;Set C
0420B9 18 F5       5584          		JR      EXIT_FP_
0420BB             5585  ;
0420BB             5586  ;Perform operation or function:
0420BB             5587  ;
0420BB             5588  ; OP:			CP      (RTABLE-DTABLE)/3
0420BB FE 2A       5589  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420BD             5590  
0420BD 30 F4       5591          		JR      NC,BAD_FP
0420BF             5592          		; CP      (FTABLE-DTABLE)/3
0420BF FE 10       5593  				CP      FTABLE-DTABLE/3 ; ditto
0420C1 30 08       5594          		JR      NC,DISPAT_FP
0420C3 08          5595          		EX      AF,AF'
0420C4 78          5596          		LD      A,B
0420C5 B1          5597          		OR      C               ;Both integer?
0420C6 C4 CE 2B 04 5598          		CALL    NZ,FLOATA       ;No, so float both
0420CA 08          5599          		EX      AF,AF'
0420CB E5          5600  DISPAT_FP:			PUSH    HL
0420CC 21 DE 20 04 5601          		LD      HL,DTABLE
0420D0 C5          5602          		PUSH    BC
0420D1 01 03 00 00 5603  			LD	BC, 3		; C = 3
0420D5 47          5604  			LD	B, A 		; B = op-code
0420D6 ED 4C       5605  			MLT 	BC 		;BC = op-code * 3
0420D8 09          5606  			ADD	HL, BC 		;Add to table base
0420D9 ED 27       5607  			LD	HL, (HL)	;Get the routine address (24-bit)
0420DB             5608  
0420DB             5609  ;        		ADD     A, A            ;A = op-code * 2
0420DB             5610  ;        		LD      C,A
0420DB             5611  ;        		LD      B,0             ;BC = op-code * 2
0420DB             5612  ;        		ADD     HL,BC
0420DB             5613  ;        		LD      A,(HL)          ;Get low byte
0420DB             5614  ;        		INC     HL
0420DB             5615  ;        		LD      H,(HL)          ;Get high byte
0420DB             5616  ;        		LD      L,A
0420DB             5617  
0420DB C1          5618          		POP     BC
0420DC E3          5619          		EX      (SP),HL
0420DD C9          5620          		RET                     ;Off to routine
0420DE             5621  ;
0420DE             5622  ;Despatch table:
0420DE             5623  ;
0420DE 90 21 04    5624  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420E1 FE 21 04    5625          		DW24  IBDIV           ;DIV
0420E4 A3 21 04    5626          		DW24  IEOR            ;EOR
0420E7 C9 21 04    5627          		DW24  IMOD            ;MOD
0420EA B6 21 04    5628          		DW24  IOR             ;OR
0420ED 84 24 04    5629          		DW24  ILE             ;<=
0420F0 93 24 04    5630          		DW24  INE             ;<>
0420F3 77 24 04    5631          		DW24  IGE             ;>=
0420F6 5C 24 04    5632          		DW24  ILT             ;<
0420F9 A0 24 04    5633          		DW24  IEQ             ;=
0420FC EC 22 04    5634          		DW24  IMUL            ;*
0420FF 27 22 04    5635          		DW24  IADD            ;+
042102 69 24 04    5636          		DW24  IGT             ;>
042105 0E 22 04    5637          		DW24  ISUB            ;-
042108 A3 23 04    5638          		DW24  IPOW            ;^
04210B 99 22 04    5639          		DW24  IDIV            ;/
04210E             5640  ;
04210E             5641  FTABLE:
04210E B2 24 04    5642  				DW24  ABSV_FP            ;ABS
042111 98 28 04    5643          		DW24  ACS_FP             ;ACS
042114 D6 27 04    5644          		DW24  ASN_FP             ;ASN
042117 06 28 04    5645          		DW24  ATN_FP             ;ATN
04211A D1 25 04    5646          		DW24  COS_FP             ;COS
04211D E0 24 04    5647          		DW24  DEG_FP             ;DEG
042120 8D 26 04    5648          		DW24  EXP_FP             ;EXP
042123 34 25 04    5649          		DW24  INT_FP_            ;INT
042126 2B 27 04    5650          		DW24  LN_FP              ;LN
042129 C0 27 04    5651          		DW24  LOG_FP             ;LOG
04212C BE 24 04    5652          		DW24  NOTK_FP            ;NOT
04212F EA 24 04    5653          		DW24  RAD_FP             ;RAD
042132 05 25 04    5654          		DW24  SGN_FP             ;SGN
042135 DE 25 04    5655          		DW24  SIN_FP             ;SIN
042138 4D 25 04    5656          		DW24  SQR_FP             ;SQR
04213B AB 25 04    5657          		DW24  TAN_FP             ;TAN
04213E             5658  ;
04213E 5B 2C 04    5659  		        DW24  ZERO_FP            ;ZERO
042141 66 26 04    5660          		DW24  FONE_FP            ;FONE
042144 A5 24 04    5661          		DW24  TRUE_FP            ;TRUE
042147 D2 24 04    5662          		DW24  PI_FP              ;PI
04214A             5663  ;
04214A 19 25 04    5664  		        DW24  VAL_FP             ;VAL
04214D A1 28 04    5665          		DW24  STR_FP             ;STR$
042150             5666  ;
042150 02 2B 04    5667          		DW24  SFIX_FP            ;FIX
042153 DE 2B 04    5668          		DW24  SFLOAT_FP          ;FLOAT
042156             5669  ;
042156 2C 2C 04    5670  		        DW24  FTEST_FP           ;TEST
042159 3E 2C 04    5671          		DW24  FCOMP_FP           ;COMPARE
04215C             5672  ;
04215C 8C 21 04    5673  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04215F FA 21 04    5674          		DW24  FBDIV           ;DIV
042162 9F 21 04    5675          		DW24  FEOR            ;EOR
042165 C5 21 04    5676          		DW24  FMOD            ;MOD
042168 B2 21 04    5677          		DW24  FFOR             ;OR
04216B 7E 24 04    5678          		DW24  FLE             ;<=
04216E 8D 24 04    5679          		DW24  FNE             ;<>
042171 71 24 04    5680          		DW24  FGE             ;>=
042174 56 24 04    5681          		DW24  FLT             ;<
042177 9A 24 04    5682          		DW24  FEQ             ;=
04217A 46 23 04    5683          		DW24  FMUL            ;*
04217D 34 22 04    5684          		DW24  FADD            ;+
042180 63 24 04    5685          		DW24  FGT             ;>
042183 1B 22 04    5686          		DW24  FSUB            ;-
042186 23 24 04    5687          		DW24  FPOW            ;^
042189 9D 22 04    5688          		DW24  FDIV            ;/
04218C             5689  ;
04218C             5690  ;       PAGE
04218C             5691  ;
04218C             5692  ;ARITHMETIC AND LOGICAL OPERATORS:
04218C             5693  ;All take two arguments, in HLH'L'C & DED'E'B.
04218C             5694  ;Output in HLH'L'C
04218C             5695  ;All registers except IX, IY destroyed.
04218C             5696  ; (N.B. FPOW destroys IX).
04218C             5697  ;
04218C             5698  ;FAND - Floating-point AND.
04218C             5699  ;IAND - Integer AND.
04218C             5700  ;
04218C CD F6 2A 04 5701  FAND:			CALL    FIX2
042190 7C          5702  IAND:			LD      A,H
042191 A2          5703          		AND     D
042192 67          5704          		LD      H,A
042193 7D          5705          		LD      A,L
042194 A3          5706          		AND     E
042195 6F          5707          		LD      L,A
042196 D9          5708          		EXX
042197 7C          5709          		LD      A,H
042198 A2          5710          		AND     D
042199 67          5711          		LD      H,A
04219A 7D          5712          		LD      A,L
04219B A3          5713          		AND     E
04219C 6F          5714          		LD      L,A
04219D D9          5715          		EXX
04219E C9          5716          		RET
04219F             5717  ;
04219F             5718  ;FEOR - Floating-point exclusive-OR.
04219F             5719  ;IEOR - Integer exclusive-OR.
04219F             5720  ;
04219F CD F6 2A 04 5721  FEOR:			CALL    FIX2
0421A3 7C          5722  IEOR:			LD      A,H
0421A4 AA          5723          		XOR     D
0421A5 67          5724          		LD      H,A
0421A6 7D          5725          		LD      A,L
0421A7 AB          5726          		XOR     E
0421A8 6F          5727          		LD      L,A
0421A9 D9          5728          		EXX
0421AA 7C          5729          		LD      A,H
0421AB AA          5730          		XOR     D
0421AC 67          5731          		LD      H,A
0421AD 7D          5732          		LD      A,L
0421AE AB          5733          		XOR     E
0421AF 6F          5734          		LD      L,A
0421B0 D9          5735          		EXX
0421B1 C9          5736          		RET
0421B2             5737  ;
0421B2             5738  ;FFOR - Floating-point OR.
0421B2             5739  ;IOR - Integer OR.
0421B2             5740  ;
0421B2 CD F6 2A 04 5741  FFOR:			CALL    FIX2
0421B6 7C          5742  IOR:			LD      A,H
0421B7 B2          5743          		OR      D
0421B8 67          5744          		LD      H,A
0421B9 7D          5745          		LD      A,L
0421BA B3          5746          		OR      E
0421BB 6F          5747          		LD      L,A
0421BC D9          5748          		EXX
0421BD 7C          5749          		LD      A,H
0421BE B2          5750          		OR      D
0421BF 67          5751          		LD      H,A
0421C0 7D          5752          		LD      A,L
0421C1 B3          5753          		OR      E
0421C2 6F          5754          		LD      L,A
0421C3 D9          5755          		EXX
0421C4 C9          5756          		RET
0421C5             5757  ;
0421C5             5758  ;FMOD - Floating-point remainder.
0421C5             5759  ;IMOD - Integer remainder.
0421C5             5760  ;
0421C5 CD F6 2A 04 5761  FMOD:			CALL    FIX2
0421C9 7C          5762  IMOD:			LD      A,H
0421CA AA          5763          		XOR     D               ;DIV RESULT SIGN
0421CB CB 7C       5764          		BIT     7,H
0421CD 08          5765          		EX      AF,AF'
0421CE CB 7C       5766          		BIT     7,H
0421D0 C4 12 2B 04 5767          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421D4 CD 0F 2C 04 5768          		CALL    SWAP_FP
0421D8 CB 7C       5769          		BIT     7,H
0421DA C4 12 2B 04 5770          		CALL    NZ,NEGATE
0421DE 44          5771          		LD      B,H
0421DF 4D          5772          		LD      C,L
0421E0 21 00 00 00 5773          		LD      HL,0
0421E4 D9          5774          		EXX
0421E5 44          5775          		LD      B,H
0421E6 4D          5776          		LD      C,L
0421E7 21 00 00 00 5777          		LD      HL,0
0421EB 3E DF       5778          		LD      A,-33
0421ED CD 9C 2D 04 5779          		CALL    DIVA            ;DIVIDE
0421F1 D9          5780          		EXX
0421F2 0E 00       5781          		LD      C,0             ;INTEGER MARKER
0421F4 08          5782          		EX      AF,AF'
0421F5 C8          5783          		RET     Z
0421F6 C3 12 2B 04 5784          		JP      NEGATE
0421FA             5785  ;
0421FA             5786  ;BDIV - Integer division.
0421FA             5787  ;
0421FA CD F6 2A 04 5788  FBDIV:			CALL    FIX2
0421FE CD C9 21 04 5789  IBDIV:			CALL    IMOD
042202 B7          5790          		OR      A
042203 CD 0F 2C 04 5791          		CALL    SWAP_FP
042207 0E 00       5792          		LD      C,0
042209 F0          5793          		RET     P
04220A C3 12 2B 04 5794          		JP      NEGATE
04220E             5795  ;
04220E             5796  ;ISUB - Integer subtraction.
04220E             5797  ;FSUB - Floating point subtraction with rounding.
04220E             5798  ;
04220E CD AA 2C 04 5799  ISUB:			CALL    SUB_
042212 E0          5800          		RET     PO
042213 CD A2 2C 04 5801          		CALL    ADD_
042217 CD D2 2B 04 5802          		CALL    FLOAT2
04221B 7A          5803  FSUB:			LD      A,D
04221C EE 80       5804          		XOR     80H             ;CHANGE SIGN THEN ADD
04221E 57          5805          		LD      D,A
04221F 18 13       5806          		JR      FADD
042221             5807  ;
042221             5808  ;Reverse subtract.
042221             5809  ;
042221 7C          5810  RSUB:			LD      A,H
042222 EE 80       5811          		XOR     80H
042224 67          5812          		LD      H,A
042225 18 0D       5813          		JR      FADD
042227             5814  ;
042227             5815  ;IADD - Integer addition.
042227             5816  ;FADD - Floating point addition with rounding.
042227             5817  ;
042227 CD A2 2C 04 5818  IADD:			CALL    ADD_
04222B E0          5819          		RET     PO
04222C CD AA 2C 04 5820          		CALL    SUB_
042230 CD D2 2B 04 5821          		CALL    FLOAT2
042234 05          5822  FADD:			DEC     B
042235 04          5823          		INC     B
042236 C8          5824          		RET     Z               ;ARG 2 ZERO
042237 0D          5825          		DEC     C
042238 0C          5826          		INC     C
042239 CA 0F 2C 04 5827          		JP      Z,SWAP_FP          ;ARG 1 ZERO
04223D D9          5828          		EXX
04223E 01 00 00 00 5829          		LD      BC,0            ;INITIALISE
042242 D9          5830          		EXX
042243 7C          5831          		LD      A,H
042244 AA          5832          		XOR     D               ;XOR SIGNS
042245 F5          5833          		PUSH    AF
042246 78          5834          		LD      A,B
042247 B9          5835          		CP      C               ;COMPARE EXPONENTS
042248 DC 0F 2C 04 5836          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
04224C 78          5837          		LD      A,B
04224D CB FC       5838          		SET     7,H             ;IMPLIED 1
04224F C4 E3 2A 04 5839          		CALL    NZ,FIX          ;ALIGN
042253 F1          5840          		POP     AF
042254 7A          5841          		LD      A,D             ;SIGN OF LARGER
042255 CB FA       5842          		SET     7,D             ;IMPLIED 1
042257 FA 67 22 04 5843          		JP      M,FADD3         ;SIGNS DIFFERENT
04225B CD A2 2C 04 5844          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04225F DC 17 2C 04 5845          		CALL    C,DIV2          ;NORMALISE
042263 CB FC       5846          		SET     7,H
042265 18 0D       5847          		JR      FADD4
042267             5848  ;
042267 CD AA 2C 04 5849  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
04226B DC 2A 2B 04 5850          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04226F CD A9 2B 04 5851          		CALL    FLO48
042273 2F          5852          		CPL                     ;CHANGE RESULT SIGN
042274 D9          5853  FADD4:			EXX
042275 EB          5854          		EX      DE,HL
042276 21 00 80 00 5855          		LD      HL,8000H
04227A B7          5856          		OR      A               ;CLEAR CARRY
04227B 52 ED 42    5857          		SBC.S   HL,BC
04227E EB          5858          		EX      DE,HL
04227F D9          5859          		EXX
042280 CC 09 2C 04 5860          		CALL    Z,ODD           ;ROUND UNBIASSED
042284 DC F7 2B 04 5861          		CALL    C,ADD1_FP          ;ROUND UP
042288 DC 24 2C 04 5862          		CALL    C,INCC
04228C CB BC       5863          		RES     7,H
04228E 0D          5864          		DEC     C
04228F 0C          5865          		INC     C
042290 CA 5B 2C 04 5866          		JP      Z,ZERO_FP
042294 B7          5867          		OR      A               ;RESULT SIGNQ
042295 F0          5868          		RET     P               ;POSITIVE
042296 CB FC       5869          		SET     7,H             ;NEGATIVE
042298 C9          5870          		RET
042299             5871  ;
042299             5872  ;IDIV - Integer division.
042299             5873  ;FDIV - Floating point division with rounding.
042299             5874  ;
042299 CD D2 2B 04 5875  IDIV:			CALL    FLOAT2
04229D 05          5876  FDIV:			DEC     B               ;TEST FOR ZERO
04229E 04          5877          		INC     B
04229F 3E 12       5878          		LD      A,DIVBY0
0422A1 CA B5 20 04 5879          		JP      Z,ERROR_FP_         ;"Division by zero"
0422A5 0D          5880          		DEC     C               ;TEST FOR ZERO
0422A6 0C          5881          		INC     C
0422A7 C8          5882          		RET     Z
0422A8 7C          5883          		LD      A,H
0422A9 AA          5884          		XOR     D               ;CALC. RESULT SIGN
0422AA 08          5885          		EX      AF,AF'          ;SAVE SIGN
0422AB CB FA       5886          		SET     7,D             ;REPLACE IMPLIED 1's
0422AD CB FC       5887          		SET     7,H
0422AF C5          5888          		PUSH    BC              ;SAVE EXPONENTS
0422B0 42          5889          		LD      B,D             ;LOAD REGISTERS
0422B1 4B          5890          		LD      C,E
0422B2 11 00 00 00 5891          		LD      DE,0
0422B6 D9          5892          		EXX
0422B7 42          5893          		LD      B,D
0422B8 4B          5894          		LD      C,E
0422B9 11 00 00 00 5895          		LD      DE,0
0422BD 3E E0       5896          		LD      A,-32           ;LOOP COUNTER
0422BF CD 9C 2D 04 5897          		CALL    DIVA            ;DIVIDE
0422C3 D9          5898          		EXX
0422C4 CB 7A       5899          		BIT     7,D
0422C6 D9          5900          		EXX
0422C7 CC BB 2D 04 5901          		CALL    Z,DIVB          ;NORMALISE & INC A
0422CB EB          5902          		EX      DE,HL
0422CC D9          5903          		EXX
0422CD CB 38       5904          		SRL     B               ;DIVISOR/2
0422CF CB 19       5905          		RR      C
0422D1 B7          5906          		OR      A               ;CLEAR CARRY
0422D2 52 ED 42    5907          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422D5 3F          5908          		CCF
0422D6 EB          5909          		EX      DE,HL           ;RESULT IN HLH'L'
0422D7 CC 09 2C 04 5910          		CALL    Z,ODD           ;ROUND UNBIASSED
0422DB DC F7 2B 04 5911          		CALL    C,ADD1_FP          ;ROUND UP
0422DF C1          5912          		POP     BC              ;RESTORE EXPONENTS
0422E0 DC 24 2C 04 5913          		CALL    C,INCC
0422E4 1F          5914          		RRA                     ;LSB OF A TO CARRY
0422E5 79          5915          		LD      A,C             ;COMPUTE NEW EXPONENT
0422E6 98          5916          		SBC     A,B
0422E7 3F          5917          		CCF
0422E8 C3 89 23 04 5918          		JP      CHKOVF
0422EC             5919  ;
0422EC             5920  ;IMUL - Integer multiplication.
0422EC             5921  ;
0422EC 7C          5922  IMUL:			LD      A,H
0422ED AA          5923          		XOR     D
0422EE 08          5924          		EX      AF,AF'          ;SAVE RESULT SIGN
0422EF CB 7C       5925          		BIT     7,H
0422F1 C4 12 2B 04 5926          		CALL    NZ,NEGATE
0422F5 CD 0F 2C 04 5927          		CALL    SWAP_FP
0422F9 CB 7C       5928          		BIT     7,H
0422FB C4 12 2B 04 5929          		CALL    NZ,NEGATE
0422FF 44          5930          		LD      B,H
042300 4D          5931          		LD      C,L
042301 21 00 00 00 5932          		LD      HL,0
042305 D9          5933          		EXX
042306 44          5934          		LD      B,H
042307 4D          5935          		LD      C,L
042308 21 00 00 00 5936          		LD      HL,0
04230C 3E DF       5937          		LD      A,-33
04230E CD D3 2D 04 5938          		CALL    MULA            ;MULTIPLY
042312 D9          5939          		EXX
042313 0E BF       5940          		LD      C,191           ;PRESET EXPONENT
042315 CD 37 2C 04 5941          		CALL    TEST_FP            ;TEST RANGE
042319 20 0F       5942          		JR      NZ,IMUL1        ;TOO BIG
04231B CB 7A       5943          		BIT     7,D
04231D 20 0B       5944          		JR      NZ,IMUL1
04231F CD 0F 2C 04 5945          		CALL    SWAP_FP
042323 4A          5946          		LD      C,D             ;INTEGER MARKER
042324 08          5947          		EX      AF,AF'
042325 F0          5948          		RET     P
042326 C3 12 2B 04 5949          		JP      NEGATE
04232A             5950  ;
04232A 0D          5951  IMUL1:			DEC     C
04232B D9          5952          		EXX
04232C CB 23       5953          		SLA     E
04232E CB 12       5954          		RL      D
042330 D9          5955          		EXX
042331 CB 13       5956          		RL      E
042333 CB 12       5957          		RL      D
042335 D9          5958          		EXX
042336 52 ED 6A    5959          		ADC.S   HL,HL
042339 D9          5960          		EXX
04233A 52 ED 6A    5961          		ADC.S   HL,HL
04233D F2 2A 23 04 5962          		JP      P,IMUL1         ;NORMALISE
042341 08          5963          		EX      AF,AF'
042342 F8          5964          		RET     M
042343 CB BC       5965          		RES     7,H             ;POSITIVE
042345 C9          5966          		RET
042346             5967  ;
042346             5968  ;FMUL - Floating point multiplication with rounding.
042346             5969  ;
042346 05          5970  FMUL:			DEC     B               ;TEST FOR ZERO
042347 04          5971          		INC     B
042348 CA 5B 2C 04 5972          		JP      Z,ZERO_FP
04234C 0D          5973          		DEC     C               ;TEST FOR ZERO
04234D 0C          5974          		INC     C
04234E C8          5975          		RET     Z
04234F 7C          5976          		LD      A,H
042350 AA          5977          		XOR     D               ;CALC. RESULT SIGN
042351 08          5978          		EX      AF,AF'
042352 CB FA       5979          		SET     7,D             ;REPLACE IMPLIED 1's
042354 CB FC       5980          		SET     7,H
042356 C5          5981          		PUSH    BC              ;SAVE EXPONENTS
042357 44          5982          		LD      B,H             ;LOAD REGISTERS
042358 4D          5983          		LD      C,L
042359 21 00 00 00 5984          		LD      HL,0
04235D D9          5985          		EXX
04235E 44          5986          		LD      B,H
04235F 4D          5987          		LD      C,L
042360 21 00 00 00 5988          		LD      HL,0
042364 3E E0       5989          		LD      A,-32           ;LOOP COUNTER
042366 CD D3 2D 04 5990          		CALL    MULA            ;MULTIPLY
04236A DC E9 2D 04 5991          		CALL    C,MULB          ;NORMALISE & INC A
04236E D9          5992          		EXX
04236F E5          5993          		PUSH    HL
042370 21 00 80 00 5994          		LD      HL,8000H
042374 B7          5995          		OR      A               ;CLEAR CARRY
042375 52 ED 52    5996          		SBC.S   HL,DE
042378 E1          5997          		POP     HL
042379 CC 09 2C 04 5998          		CALL    Z,ODD           ;ROUND UNBIASSED
04237D DC F7 2B 04 5999          		CALL    C,ADD1_FP          ;ROUND UP
042381 C1          6000          		POP     BC              ;RESTORE EXPONENTS
042382 DC 24 2C 04 6001          		CALL    C,INCC
042386 1F          6002          		RRA                     ;LSB OF A TO CARRY
042387 79          6003          		LD      A,C             ;COMPUTE NEW EXPONENT
042388 88          6004          		ADC     A,B
042389 38 06       6005  CHKOVF:			JR      C,CHKO1
04238B F2 5B 2C 04 6006          		JP      P,ZERO_FP          ;UNDERFLOW
04238F 18 04       6007          		JR      CHKO2
042391 FA 26 2C 04 6008  CHKO1:			JP      M,OFLOW         ;OVERFLOW
042395 C6 80       6009  CHKO2:			ADD     A,80H
042397 4F          6010          		LD      C,A
042398 CA 5B 2C 04 6011          		JP      Z,ZERO_FP
04239C 08          6012          		EX      AF,AF'          ;RESTORE SIGN BIT
04239D CB BC       6013          		RES     7,H
04239F F0          6014          		RET     P
0423A0 CB FC       6015          		SET     7,H
0423A2 C9          6016          		RET
0423A3             6017  ;
0423A3             6018  ;IPOW - Integer involution.
0423A3             6019  ;
0423A3 CD 0F 2C 04 6020  IPOW:			CALL    SWAP_FP
0423A7 CB 7C       6021          		BIT     7,H
0423A9 F5          6022          		PUSH    AF              ;SAVE SIGN
0423AA C4 12 2B 04 6023          		CALL    NZ,NEGATE
0423AE 48          6024  IPOW0:			LD      C,B
0423AF 06 20       6025          		LD      B,32            ;LOOP COUNTER
0423B1 CD C7 2C 04 6026  IPOW1:			CALL    X2
0423B5 38 08       6027          		JR      C,IPOW2
0423B7 10 F8       6028          		DJNZ    IPOW1
0423B9 F1          6029          		POP     AF
0423BA D9          6030          		EXX
0423BB 2C          6031          		INC     L               ;RESULT=1
0423BC D9          6032          		EXX
0423BD 4C          6033          		LD      C,H
0423BE C9          6034          		RET
0423BF             6035  ;
0423BF F1          6036  IPOW2:			POP     AF
0423C0 C5          6037          		PUSH    BC
0423C1 EB          6038          		EX      DE,HL
0423C2 E5          6039          		PUSH    HL
0423C3 D9          6040          		EXX
0423C4 EB          6041          		EX      DE,HL
0423C5 E5          6042          		PUSH    HL
0423C6 D9          6043          		EXX
0423C7 DD 21 00 00 6044          		LD      IX,0
       00          
0423CC DD 39       6045          		ADD     IX,SP
0423CE 28 48       6046          		JR      Z,IPOW4
0423D0 C5          6047          		PUSH    BC
0423D1 D9          6048          		EXX
0423D2 D5          6049          		PUSH    DE
0423D3 D9          6050          		EXX
0423D4 D5          6051          		PUSH    DE
0423D5 CD DE 2B 04 6052          		CALL    SFLOAT_FP
0423D9 CD 12 27 04 6053          		CALL    RECIP
0423DD DD 71 04    6054          		LD      (IX+4),C
0423E0 D9          6055          		EXX
0423E1 DD 75 00    6056          		LD      (IX+0),L
0423E4 DD 74 01    6057          		LD      (IX+1),H
0423E7 D9          6058          		EXX
0423E8 DD 75 02    6059          		LD      (IX+2),L
0423EB DD 74 03    6060          		LD      (IX+3),H
0423EE 18 21       6061          		JR      IPOW5
0423F0             6062  ;
0423F0 C5          6063  IPOW3:			PUSH    BC
0423F1 D9          6064          		EXX
0423F2 CB 23       6065          		SLA     E
0423F4 CB 12       6066          		RL      D
0423F6 D5          6067          		PUSH    DE
0423F7 D9          6068          		EXX
0423F8 CB 13       6069          		RL      E
0423FA CB 12       6070          		RL      D
0423FC D5          6071          		PUSH    DE
0423FD 3E 0A       6072          		LD      A,'*' & 0FH
0423FF F5          6073          		PUSH    AF
042400 CD DB 2C 04 6074          		CALL    COPY_
042404 CD BB 20 04 6075          		CALL    OP              ;SQUARE
042408 F1          6076          		POP     AF
042409 CD 07 2A 04 6077          		CALL    DLOAD5
04240D DC BB 20 04 6078          		CALL    C,OP            ;MULTIPLY BY X
042411 D1          6079  IPOW5:			POP     DE
042412 D9          6080          		EXX
042413 D1          6081          		POP     DE
042414 D9          6082          		EXX
042415 79          6083          		LD      A,C
042416 C1          6084          		POP     BC
042417 4F          6085          		LD      C,A
042418 10 D6       6086  IPOW4:			DJNZ    IPOW3
04241A F1          6087          		POP     AF
04241B F1          6088          		POP     AF
04241C F1          6089          		POP     AF
04241D C9          6090          		RET
04241E             6091  ;
04241E F1          6092  FPOW0:			POP     AF
04241F F1          6093          		POP     AF
042420 F1          6094          		POP     AF
042421 18 8B       6095          		JR      IPOW0
042423             6096  ;
042423             6097  ;FPOW - Floating-point involution.
042423             6098  ;
042423 CB 7A       6099  FPOW:			BIT     7,D
042425 F5          6100          		PUSH    AF
042426 CD 0F 2C 04 6101          		CALL    SWAP_FP
04242A CD EB 2C 04 6102          		CALL    PUSH5
04242E 0D          6103          		DEC     C
04242F 0C          6104          		INC     C
042430 28 EC       6105          		JR      Z,FPOW0
042432 3E 9E       6106          		LD      A,158
042434 B9          6107          		CP      C
042435 38 0A       6108          		JR      C,FPOW1
042437 3C          6109          		INC     A
042438 CD E3 2A 04 6110          		CALL    FIX
04243C 08          6111          		EX      AF,AF'
04243D F2 1E 24 04 6112          		JP      P,FPOW0
042441 CD 0F 2C 04 6113  FPOW1:			CALL    SWAP_FP
042445 CD 2F 27 04 6114          		CALL    LN0
042449 CD F4 2C 04 6115          		CALL    POP5
04244D F1          6116          		POP     AF
04244E CD 46 23 04 6117          		CALL    FMUL
042452 C3 91 26 04 6118          		JP      EXP0
042456             6119  ;
042456             6120  ;Integer and floating-point compare.
042456             6121  ;Result is TRUE (-1) or FALSE (0).
042456             6122  ;
042456 CD 65 2C 04 6123  FLT:			CALL    FCP
04245A 18 04       6124          		JR      ILT1
04245C CD 57 2C 04 6125  ILT:			CALL    ICP
042460 D0          6126  ILT1:			RET     NC
042461 18 42       6127          		JR      TRUE_FP
042463             6128  ;
042463 CD 65 2C 04 6129  FGT:			CALL    FCP
042467 18 04       6130          		JR      IGT1
042469 CD 57 2C 04 6131  IGT:			CALL    ICP
04246D C8          6132  IGT1:			RET     Z
04246E D8          6133          		RET     C
04246F 18 34       6134          		JR      TRUE_FP
042471             6135  ;
042471 CD 65 2C 04 6136  FGE:			CALL    FCP
042475 18 04       6137          		JR      IGE1
042477 CD 57 2C 04 6138  IGE:			CALL    ICP
04247B D8          6139  IGE1:			RET     C
04247C 18 27       6140          		JR      TRUE_FP
04247E             6141  ;
04247E CD 65 2C 04 6142  FLE:			CALL    FCP
042482 18 04       6143          		JR      ILE1
042484 CD 57 2C 04 6144  ILE:			CALL    ICP
042488 28 1B       6145  ILE1:			JR      Z,TRUE_FP
04248A D0          6146          		RET     NC
04248B 18 18       6147          		JR      TRUE_FP
04248D             6148  ;
04248D CD 65 2C 04 6149  FNE:			CALL    FCP
042491 18 04       6150          		JR      INE1
042493 CD 57 2C 04 6151  INE:			CALL    ICP
042497 C8          6152  INE1:			RET     Z
042498 18 0B       6153          		JR      TRUE_FP
04249A             6154  ;
04249A CD 65 2C 04 6155  FEQ:			CALL    FCP
04249E 18 04       6156          		JR      IEQ1
0424A0 CD 57 2C 04 6157  IEQ:			CALL    ICP
0424A4 C0          6158  IEQ1:			RET     NZ
0424A5 21 FF FF FF 6159  TRUE_FP:			LD      HL,-1
0424A9 D9          6160          		EXX
0424AA 21 FF FF FF 6161          		LD      HL,-1
0424AE D9          6162          		EXX
0424AF AF          6163          		XOR     A
0424B0 4F          6164          		LD      C,A
0424B1 C9          6165          		RET
0424B2             6166  ;
0424B2             6167  ;FUNCTIONS:
0424B2             6168  ;
0424B2             6169  ;Result returned in HLH'L'C (floating point)
0424B2             6170  ;Result returned in HLH'L' (C=0) (integer)
0424B2             6171  ;All registers except IY destroyed.
0424B2             6172  ;
0424B2             6173  ;ABS - Absolute value
0424B2             6174  ;Result is numeric, variable type.
0424B2             6175  ;
0424B2 CB 7C       6176  ABSV_FP:			BIT     7,H
0424B4 C8          6177          		RET     Z               ;POSITIVE/ZERO
0424B5 0D          6178          		DEC     C
0424B6 0C          6179          		INC     C
0424B7 CA 12 2B 04 6180          		JP      Z,NEGATE        ;INTEGER
0424BB CB BC       6181          		RES     7,H
0424BD C9          6182          		RET
0424BE             6183  ;
0424BE             6184  ;NOT - Complement integer.
0424BE             6185  ;Result is integer numeric.
0424BE             6186  ;
0424BE CD 02 2B 04 6187  NOTK_FP:			CALL    SFIX_FP
0424C2 7C          6188          		LD      A,H
0424C3 2F          6189          		CPL
0424C4 67          6190          		LD      H,A
0424C5 7D          6191          		LD      A,L
0424C6 2F          6192          		CPL
0424C7 6F          6193          		LD      L,A
0424C8 D9          6194          		EXX
0424C9 7C          6195          		LD      A,H
0424CA 2F          6196          		CPL
0424CB 67          6197          		LD      H,A
0424CC 7D          6198          		LD      A,L
0424CD 2F          6199          		CPL
0424CE 6F          6200          		LD      L,A
0424CF D9          6201          		EXX
0424D0 AF          6202          		XOR     A               ;NUMERIC MARKER
0424D1 C9          6203          		RET
0424D2             6204  ;
0424D2             6205  ;PI - Return PI (3.141592654)
0424D2             6206  ;Result is floating-point numeric.
0424D2             6207  ;
0424D2 21 0F 49 00 6208  PI_FP:			LD      HL,490FH
0424D6 D9          6209          		EXX
0424D7 21 A2 DA 00 6210          		LD      HL,0DAA2H
0424DB D9          6211          		EXX
0424DC 0E 81       6212          		LD      C,81H
0424DE AF          6213          		XOR     A               ;NUMERIC MARKER
0424DF C9          6214          		RET
0424E0             6215  ;
0424E0             6216  ;DEG - Convert radians to degrees
0424E0             6217  ;Result is floating-point numeric.
0424E0             6218  ;
0424E0 CD F4 24 04 6219  DEG_FP:			CALL    FPI180
0424E4 CD 46 23 04 6220          		CALL    FMUL
0424E8 AF          6221          		XOR     A
0424E9 C9          6222          		RET
0424EA             6223  ;
0424EA             6224  ;RAD - Convert degrees to radians
0424EA             6225  ;Result is floating-point numeric.
0424EA             6226  ;
0424EA CD F4 24 04 6227  RAD_FP:			CALL    FPI180
0424EE CD 9D 22 04 6228          		CALL    FDIV
0424F2 AF          6229          		XOR     A
0424F3 C9          6230          		RET
0424F4             6231  ;
0424F4             6232  ;180/PI
0424F4             6233  ;
0424F4 CD DE 2B 04 6234  FPI180:			CALL    SFLOAT_FP
0424F8 11 2E 65 00 6235          		LD      DE,652EH
0424FC D9          6236          		EXX
0424FD 11 D3 E0 00 6237          		LD      DE,0E0D3H
042501 D9          6238          		EXX
042502 06 85       6239          		LD      B,85H
042504 C9          6240          		RET
042505             6241  ;
042505             6242  ;SGN - Return -1, 0 or +1
042505             6243  ;Result is integer numeric.
042505             6244  ;
042505 CD 37 2C 04 6245  SGN_FP:			CALL    TEST_FP
042509 B1          6246          		OR      C
04250A C8          6247          		RET     Z               ;ZERO
04250B CB 7C       6248          		BIT     7,H
04250D C2 A5 24 04 6249          		JP      NZ,TRUE_FP         ;-1
042511 CD 5B 2C 04 6250          		CALL    ZERO_FP
042515 C3 F7 2B 04 6251          		JP      ADD1_FP            ;1
042519             6252  ;
042519             6253  ;VAL - Return numeric value of string.
042519             6254  ;Input: ASCII string at IX
042519             6255  ;Result is variable type numeric.
042519             6256  ;
042519 CD 75 2E 04 6257  VAL_FP:			CALL    SIGNQ
04251D F5          6258          		PUSH    AF
04251E CD 25 2A 04 6259          		CALL    CON_FP
042522 F1          6260          		POP     AF
042523 FE 2D       6261          		CP      '-'
042525 3E 00       6262          		LD      A,0             ;NUMERIC MARKER
042527 C0          6263          		RET     NZ
042528 0D          6264          		DEC     C
042529 0C          6265          		INC     C
04252A CA 12 2B 04 6266          		JP      Z,NEGATE        ;ZERO/INTEGER
04252E 7C          6267          		LD      A,H
04252F EE 80       6268          		XOR     80H             ;CHANGE SIGN (FP)
042531 67          6269          		LD      H,A
042532 AF          6270          		XOR     A
042533 C9          6271          		RET
042534             6272  ;
042534             6273  ;INT - Floor function
042534             6274  ;Result is integer numeric.
042534             6275  ;
042534 0D          6276  INT_FP_:			DEC     C
042535 0C          6277          		INC     C
042536 C8          6278          		RET     Z               ;ZERO/INTEGER
042537 3E 9F       6279          		LD      A,159
042539 44          6280          		LD      B,H             ;B7=SIGN BIT
04253A CD E3 2A 04 6281          		CALL    FIX
04253E 08          6282          		EX      AF,AF'
04253F A0          6283          		AND     B
042540 FC F7 2B 04 6284          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042544 78          6285          		LD      A,B
042545 B7          6286          		OR      A
042546 FC 12 2B 04 6287          		CALL    M,NEGATE
04254A AF          6288          		XOR     A
04254B 4F          6289          		LD      C,A
04254C C9          6290          		RET
04254D             6291  ;
04254D             6292  ;SQR - square root
04254D             6293  ;Result is floating-point numeric.
04254D             6294  ;
04254D CD DE 2B 04 6295  SQR_FP:			CALL    SFLOAT_FP
042551 CB 7C       6296  SQR0:			BIT     7,H
042553 3E 15       6297          		LD      A,NGROOT
042555 C2 B5 20 04 6298          		JP      NZ,ERROR_FP_        ;"-ve root"
042559 0D          6299          		DEC     C
04255A 0C          6300          		INC     C
04255B C8          6301          		RET     Z               ;ZERO
04255C CB FC       6302          		SET     7,H             ;IMPLIED 1
04255E CB 41       6303          		BIT     0,C
042560 CC 17 2C 04 6304          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
042564 79          6305          		LD      A,C
042565 D6 80       6306          		SUB     80H
042567 CB 2F       6307          		SRA     A               ;HALVE EXPONENT
042569 C6 80       6308          		ADD     A,80H
04256B 4F          6309          		LD      C,A
04256C C5          6310          		PUSH    BC              ;SAVE EXPONENT
04256D EB          6311          		EX      DE,HL
04256E 21 00 00 00 6312          		LD      HL,0
042572 44          6313          		LD      B,H
042573 4D          6314          		LD      C,L
042574 D9          6315          		EXX
042575 EB          6316          		EX      DE,HL
042576 21 00 00 00 6317          		LD      HL,0
04257A 44          6318          		LD      B,H
04257B 4D          6319          		LD      C,L
04257C 3E E1       6320          		LD      A,-31
04257E CD 0D 2E 04 6321          		CALL    SQRA            ;ROOT
042582 D9          6322          		EXX
042583 CB 78       6323          		BIT     7,B
042585 D9          6324          		EXX
042586 CC 0D 2E 04 6325          		CALL    Z,SQRA          ;NORMALISE & INC A
04258A CD 4E 2E 04 6326          		CALL    SQRB
04258E B7          6327          		OR      A               ;CLEAR CARRY
04258F CD BB 2D 04 6328          		CALL    DIVB
042593 CB 1B       6329          		RR      E               ;LSB TO CARRY
042595 60          6330          		LD      H,B
042596 69          6331          		LD      L,C
042597 D9          6332          		EXX
042598 60          6333          		LD      H,B
042599 69          6334          		LD      L,C
04259A DC F7 2B 04 6335          		CALL    C,ADD1_FP          ;ROUND UP
04259E C1          6336          		POP     BC              ;RESTORE EXPONENT
04259F DC 24 2C 04 6337          		CALL    C,INCC
0425A3 1F          6338          		RRA
0425A4 9F          6339          		SBC     A,A
0425A5 81          6340          		ADD     A,C
0425A6 4F          6341          		LD      C,A
0425A7 CB BC       6342          		RES     7,H             ;POSITIVE
0425A9 AF          6343          		XOR     A
0425AA C9          6344          		RET
0425AB             6345  ;
0425AB             6346  ;TAN - Tangent function
0425AB             6347  ;Result is floating-point numeric.
0425AB             6348  ;
0425AB CD DE 2B 04 6349  TAN_FP:			CALL    SFLOAT_FP
0425AF CD EB 2C 04 6350          		CALL    PUSH5
0425B3 CD D5 25 04 6351          		CALL    COS0
0425B7 CD F4 2C 04 6352          		CALL    POP5
0425BB CD EB 2C 04 6353          		CALL    PUSH5
0425BF CD 0F 2C 04 6354          		CALL    SWAP_FP
0425C3 CD E2 25 04 6355          		CALL    SIN0
0425C7 CD F4 2C 04 6356          		CALL    POP5
0425CB CD 9D 22 04 6357          		CALL    FDIV
0425CF AF          6358          		XOR     A               ;NUMERIC MARKER
0425D0 C9          6359          		RET
0425D1             6360  ;
0425D1             6361  ;COS - Cosine function
0425D1             6362  ;Result is floating-point numeric.
0425D1             6363  ;
0425D1 CD DE 2B 04 6364  COS_FP:			CALL    SFLOAT_FP
0425D5 CD 3A 2B 04 6365  COS0:			CALL    SCALE
0425D9 1C          6366          		INC     E
0425DA 1C          6367          		INC     E
0425DB 7B          6368          		LD      A,E
0425DC 18 10       6369          		JR      SIN1
0425DE             6370  ;
0425DE             6371  ;SIN - Sine function
0425DE             6372  ;Result is floating-point numeric.
0425DE             6373  ;
0425DE CD DE 2B 04 6374  SIN_FP:			CALL    SFLOAT_FP
0425E2 E5          6375  SIN0:			PUSH    HL              ;H7=SIGN
0425E3 CD 3A 2B 04 6376          		CALL    SCALE
0425E7 F1          6377          		POP     AF
0425E8 07          6378          		RLCA
0425E9 07          6379          		RLCA
0425EA 07          6380          		RLCA
0425EB E6 04       6381          		AND     4
0425ED AB          6382          		XOR     E
0425EE F5          6383  SIN1:			PUSH    AF              ;OCTANT
0425EF CB BC       6384          		RES     7,H
0425F1 1F          6385          		RRA
0425F2 CD 80 26 04 6386          		CALL    PIBY4
0425F6 DC 21 22 04 6387          		CALL    C,RSUB          ;X=(PI/4)-X
0425FA F1          6388          		POP     AF
0425FB F5          6389          		PUSH    AF
0425FC E6 03       6390          		AND     3
0425FE E2 37 26 04 6391          		JP      PO,SIN2         ;USE COSINE APPROX.
042602 CD EB 2C 04 6392          		CALL    PUSH5           ;SAVE X
042606 CD E3 2C 04 6393          		CALL    SQUARE          ;PUSH X*X
04260A CD 28 2D 04 6394          		CALL    POLY
04260E B7 A8       6395          		DW	0A8B7H          ;a(8)
042610 11 36       6396          		DW	3611H
042612 6D          6397          		DB	6DH
042613 26 DE       6398          		DW	0DE26H          ;a(6)
042615 05 D0       6399          		DW	0D005H
042617 73          6400          		DB	73H
042618 C0 80       6401          		DW	80C0H           ;a(4)
04261A 88 08       6402          		DW	888H
04261C 79          6403          		DB	79H
04261D 9D AA       6404          		DW	0AA9DH          ;a(2)
04261F AA AA       6405          		DW	0AAAAH
042621 7D          6406          		DB	7DH
042622 00 00       6407          		DW	0               ;a(0)
042624 00 00       6408          		DW	0
042626 80          6409          		DB	80H
042627 CD F4 2C 04 6410          		CALL    POP5
04262B CD F4 2C 04 6411          		CALL    POP5
04262F CD 46 23 04 6412          		CALL    FMUL
042633 C3 5C 26 04 6413          		JP      SIN3
042637             6414  ;
042637 CD E3 2C 04 6415  SIN2:			CALL    SQUARE          ;PUSH X*X
04263B CD 28 2D 04 6416          		CALL    POLY
04263F 71 D5       6417          		DW	0D571H          ;b(8)
042641 78 4C       6418          		DW	4C78H
042643 70          6419          		DB	70H
042644 AF 94       6420          		DW	94AFH           ;b(6)
042646 03 B6       6421          		DW	0B603H
042648 76          6422          		DB	76H
042649 C8 9C       6423          		DW	9CC8H           ;b(4)
04264B AA 2A       6424          		DW	2AAAH
04264D 7B          6425          		DB	7BH
04264E DD FF       6426          		DW	0FFDDH          ;b(2)
042650 FF FF       6427          		DW	0FFFFH
042652 7E          6428          		DB	7EH
042653 00 00       6429          		DW	0               ;b(0)
042655 00 00       6430          		DW	0
042657 80          6431          		DB	80H
042658 CD F4 2C 04 6432          		CALL    POP5
04265C F1          6433  SIN3:			POP     AF
04265D E6 04       6434          		AND     4
04265F C8          6435          		RET     Z
042660 0D          6436          		DEC     C
042661 0C          6437          		INC     C
042662 C8          6438          		RET     Z               ;ZERO
042663 CB FC       6439          		SET     7,H             ;MAKE NEGATIVE
042665 C9          6440          		RET
042666             6441  ;
042666             6442  ;Floating-point one:
042666             6443  ;
042666 21 00 00 00 6444  FONE_FP:			LD      HL,0
04266A D9          6445          		EXX
04266B 21 00 00 00 6446          		LD      HL,0
04266F D9          6447          		EXX
042670 0E 80       6448          		LD      C,80H
042672 C9          6449          		RET
042673             6450  ;
042673 11 00 00 00 6451  DONE:			LD      DE,0
042677 D9          6452          		EXX
042678 11 00 00 00 6453          		LD      DE,0
04267C D9          6454          		EXX
04267D 06 80       6455          		LD      B,80H
04267F C9          6456          		RET
042680             6457  ;
042680 11 0F 49 00 6458  PIBY4:			LD      DE,490FH
042684 D9          6459          		EXX
042685 11 A2 DA 00 6460          		LD      DE,0DAA2H
042689 D9          6461          		EXX
04268A 06 7F       6462          		LD      B,7FH
04268C C9          6463          		RET
04268D             6464  ;
04268D             6465  ;EXP - Exponential function
04268D             6466  ;Result is floating-point numeric.
04268D             6467  ;
04268D CD DE 2B 04 6468  EXP_FP:			CALL    SFLOAT_FP
042691 CD 1E 27 04 6469  EXP0:			CALL    LN2             ;LN(2)
042695 D9          6470          		EXX
042696 1D          6471  	        	DEC     E
042697 01 CF D1 00 6472  		        LD      BC,0D1CFH       ;0.6931471805599453
04269B D9          6473          		EXX
04269C E5          6474          		PUSH    HL              ;H7=SIGN
04269D CD 4D 2B 04 6475          		CALL    MOD48           ;"MODULUS"
0426A1 F1          6476          		POP     AF
0426A2 CB 7B       6477          		BIT     7,E
0426A4 28 0B       6478          		JR      Z,EXP1
0426A6 17          6479          		RLA
0426A7 DA 5B 2C 04 6480          		JP      C,ZERO_FP
0426AB 3E 18       6481          		LD      A,EXPRNG
0426AD C3 B5 20 04 6482          		JP      ERROR_FP_           ;"Exp range"
0426B1             6483  ;
0426B1 E6 80       6484  EXP1:			AND     80H
0426B3 B3          6485          		OR      E
0426B4 F5          6486          		PUSH    AF              ;INTEGER PART
0426B5 CB BC       6487          		RES     7,H
0426B7 CD EB 2C 04 6488          		CALL    PUSH5           ;PUSH X*LN(2)
0426BB CD 28 2D 04 6489          		CALL    POLY
0426BF 72 40       6490          		DW	4072H           ;a(7)
0426C1 2E 94       6491          		DW	942EH
0426C3 73          6492          		DB	73H
0426C4 65 6F       6493          		DW	6F65H           ;a(6)
0426C6 4F 2E       6494          		DW	2E4FH
0426C8 76          6495          		DB	76H
0426C9 37 6D       6496          		DW	6D37H           ;a(5)
0426CB 02 88       6497          		DW	8802H
0426CD 79          6498          		DB	79H
0426CE 12 E5       6499          		DW	0E512H          ;a(4)
0426D0 A0 2A       6500          		DW	2AA0H
0426D2 7B          6501          		DB	7BH
0426D3 14 4F       6502          		DW	4F14H           ;a(3)
0426D5 AA AA       6503          		DW	0AAAAH
0426D7 7D          6504          		DB	7DH
0426D8 56 FD       6505          		DW	0FD56H          ;a(2)
0426DA FF 7F       6506          		DW	7FFFH
0426DC 7E          6507          		DB	7EH
0426DD FE FF       6508          		DW	0FFFEH          ;a(1)
0426DF FF FF       6509          		DW	0FFFFH
0426E1 7F          6510          		DB	7FH
0426E2 00 00       6511          		DW	0               ;a(0)
0426E4 00 00       6512          		DW	0
0426E6 80          6513          		DB	80H
0426E7 CD F4 2C 04 6514          		CALL    POP5
0426EB F1          6515          		POP     AF
0426EC F5          6516          		PUSH    AF
0426ED F4 12 27 04 6517          		CALL    P,RECIP         ;X=1/X
0426F1 F1          6518          		POP     AF
0426F2 F2 FA 26 04 6519          		JP      P,EXP4
0426F6 E6 7F       6520          		AND     7FH
0426F8 ED 44       6521          		NEG
0426FA C6 80       6522  EXP4:			ADD     A,80H
0426FC 81          6523          		ADD     A,C
0426FD 38 06       6524          		JR      C,EXP2
0426FF F2 5B 2C 04 6525          		JP      P,ZERO_FP          ;UNDERFLOW
042703 18 04       6526          		JR      EXP3
042705 FA 26 2C 04 6527  EXP2:			JP      M,OFLOW         ;OVERFLOW
042709 C6 80       6528  EXP3:			ADD     A,80H
04270B CA 5B 2C 04 6529          		JP      Z,ZERO_FP
04270F 4F          6530          		LD      C,A
042710 AF          6531          		XOR     A               ;NUMERIC MARKER
042711 C9          6532          		RET
042712             6533  ;
042712 CD 73 26 04 6534  RECIP:			CALL    DONE
042716 CD 0F 2C 04 6535  RDIV:			CALL    SWAP_FP
04271A C3 9D 22 04 6536          		JP      FDIV            ;RECIPROCAL
04271E             6537  ;
04271E 11 72 31 00 6538  LN2:			LD      DE,3172H        ;LN(2)
042722 D9          6539          		EXX
042723 11 F8 17 00 6540          		LD      DE,17F8H
042727 D9          6541          		EXX
042728 06 7F       6542          		LD      B,7FH
04272A C9          6543          		RET
04272B             6544  ;
04272B             6545  ;LN - Natural log.
04272B             6546  ;Result is floating-point numeric.
04272B             6547  ;
04272B CD DE 2B 04 6548  LN_FP:			CALL    SFLOAT_FP
04272F 3E 16       6549  LN0:			LD      A,LOGRNG
042731 CB 7C       6550          		BIT     7,H
042733 C2 B5 20 04 6551          		JP      NZ,ERROR_FP_        ;"Log range"
042737 0C          6552          		INC     C
042738 0D          6553          		DEC     C
042739 CA B5 20 04 6554          		JP      Z,ERROR_FP_
04273D 11 04 35 00 6555          		LD      DE,3504H        ;SQR(2)
042741 D9          6556          		EXX
042742 11 33 F3 00 6557          		LD      DE,0F333H       ;1.41421356237
042746 D9          6558          		EXX
042747 CD 6E 2C 04 6559          		CALL    ICP0            ;MANTISSA>SQR(2)?
04274B 79          6560          		LD      A,C             ;EXPONENT
04274C 0E 80       6561          		LD      C,80H           ;1 <= X < 2
04274E 38 02       6562          		JR      C,LN4
042750 0D          6563          		DEC     C
042751 3C          6564          		INC     A
042752 F5          6565  LN4:			PUSH    AF              ;SAVE EXPONENT
042753 CD 00 2D 04 6566          		CALL    RATIO           ;X=(X-1)/(X+1)
042757 CD EB 2C 04 6567          		CALL    PUSH5
04275B CD E3 2C 04 6568  		        CALL    SQUARE          ;PUSH X*X
04275F CD 28 2D 04 6569          		CALL    POLY
042763 48 CC       6570          		DW	0CC48H          ;a(9)
042765 FB 74       6571          		DW	74FBH
042767 7D          6572          		DB	7DH
042768 AF AE       6573          		DW	0AEAFH          ;a(7)
04276A FF 11       6574          		DW	11FFH
04276C 7E          6575          		DB	7EH
04276D 8C D9       6576          		DW	0D98CH          ;a(5)
04276F CD 4C       6577          		DW	4CCDH
042771 7E          6578          		DB	7EH
042772 E3 A9       6579          		DW	0A9E3H          ;a(3)
042774 AA 2A       6580          		DW	2AAAH
042776 7F          6581          		DB	7FH
042777 00 00       6582          		DW	0               ;a(1)
042779 00 00       6583          		DW	0
04277B 81          6584          		DB	81H
04277C CD F4 2C 04 6585          		CALL    POP5
042780 CD F4 2C 04 6586          		CALL    POP5
042784 CD 46 23 04 6587          		CALL    FMUL
042788 F1          6588          		POP     AF              ;EXPONENT
042789 CD EB 2C 04 6589          		CALL    PUSH5
04278D 08          6590          		EX      AF,AF'
04278E CD 5B 2C 04 6591          		CALL    ZERO_FP
042792 08          6592          		EX      AF,AF'
042793 D6 80       6593          		SUB     80H
042795 28 1F       6594          		JR      Z,LN3
042797 30 02       6595          		JR      NC,LN1
042799 2F          6596          		CPL
04279A 3C          6597          		INC     A
04279B 67          6598  LN1:			LD      H,A
04279C 0E 87       6599          		LD      C,87H
04279E F5          6600          		PUSH    AF
04279F CD BE 2B 04 6601          		CALL    FLOAT_
0427A3 CB BC       6602          		RES     7,H
0427A5 CD 1E 27 04 6603          		CALL    LN2
0427A9 CD 46 23 04 6604          		CALL    FMUL
0427AD F1          6605          		POP     AF
0427AE 30 06       6606          		JR      NC,LN3
0427B0 FA B6 27 04 6607          		JP      M,LN3
0427B4 CB FC       6608          		SET     7,H
0427B6 CD F4 2C 04 6609  LN3:			CALL    POP5
0427BA CD 34 22 04 6610          		CALL    FADD
0427BE AF          6611          		XOR     A
0427BF C9          6612          		RET
0427C0             6613  ;
0427C0             6614  ;LOG - base-10 logarithm.
0427C0             6615  ;Result is floating-point numeric.
0427C0             6616  ;
0427C0 CD 2B 27 04 6617  LOG_FP:			CALL    LN_FP
0427C4 11 5B 5E 00 6618          		LD      DE,5E5BH        ;LOG(e)
0427C8 D9          6619          		EXX
0427C9 11 A9 D8 00 6620          		LD      DE,0D8A9H
0427CD D9          6621          		EXX
0427CE 06 7E       6622          		LD      B,7EH
0427D0 CD 46 23 04 6623          		CALL    FMUL
0427D4 AF          6624          		XOR     A
0427D5 C9          6625          		RET
0427D6             6626  ;
0427D6             6627  ;ASN - Arc-sine
0427D6             6628  ;Result is floating-point numeric.
0427D6             6629  ;
0427D6 CD DE 2B 04 6630  ASN_FP:			CALL    SFLOAT_FP
0427DA CD EB 2C 04 6631          		CALL    PUSH5
0427DE CD DB 2C 04 6632          		CALL    COPY_
0427E2 CD 46 23 04 6633          		CALL    FMUL
0427E6 CD 73 26 04 6634          		CALL    DONE
0427EA CD 21 22 04 6635          		CALL    RSUB
0427EE CD 51 25 04 6636          		CALL    SQR0
0427F2 CD F4 2C 04 6637          		CALL    POP5
0427F6 0C          6638          		INC     C
0427F7 0D          6639          		DEC     C
0427F8 3E 02       6640          		LD      A,2
0427FA D5          6641          		PUSH    DE
0427FB CA 80 28 04 6642          		JP      Z,ACS1
0427FF D1          6643          		POP     DE
042800 CD 16 27 04 6644          		CALL    RDIV
042804 18 04       6645          		JR      ATN0
042806             6646  ;
042806             6647  ;ATN - arc-tangent
042806             6648  ;Result is floating-point numeric.
042806             6649  ;
042806 CD DE 2B 04 6650  ATN_FP:			CALL    SFLOAT_FP
04280A E5          6651  ATN0:			PUSH    HL              ;SAVE SIGN
04280B CB BC       6652          		RES     7,H
04280D 11 13 54 00 6653          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
042811 D9          6654          		EXX
042812 11 D0 CC 00 6655          		LD      DE,0CCD0H
042816 D9          6656          		EXX
042817 06 7E       6657          		LD      B,7EH
042819 CD 6B 2C 04 6658          		CALL    FCP0            ;COMPARE
04281D 06 00       6659          		LD      B,0
04281F 38 22       6660          		JR      C,ATN2
042821 11 82 1A 00 6661          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
042825 D9          6662          		EXX
042826 11 9A 79 00 6663          		LD      DE,799AH
04282A D9          6664          		EXX
04282B 06 81       6665          		LD      B,81H
04282D CD 6B 2C 04 6666          		CALL    FCP0            ;COMPARE
042831 38 0A       6667          		JR      C,ATN1
042833 CD 12 27 04 6668          		CALL    RECIP           ;X=1/X
042837 06 02       6669          		LD      B,2
042839 C3 43 28 04 6670          		JP      ATN2
04283D CD 00 2D 04 6671  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042841 06 01       6672          		LD      B,1
042843 C5          6673  ATN2:			PUSH    BC              ;SAVE FLAG
042844 CD EB 2C 04 6674          		CALL    PUSH5
042848 CD E3 2C 04 6675          		CALL    SQUARE          ;PUSH X*X
04284C CD 28 2D 04 6676          		CALL    POLY
042850 35 F3       6677          		DW	0F335H          ;a(13)
042852 D8 37       6678          		DW	37D8H
042854 7B          6679          		DB	7BH
042855 91 6B       6680          		DW	6B91H           ;a(11)
042857 B9 AA       6681          		DW	0AAB9H
042859 7C          6682          		DB	7CH
04285A DE 41       6683          		DW	41DEH           ;a(9)
04285C 97 61       6684          		DW	6197H
04285E 7C          6685          		DB	7CH
04285F 7B 9D       6686          		DW	9D7BH           ;a(7)
042861 37 92       6687          		DW	9237H
042863 7D          6688          		DB	7DH
042864 5A 2A       6689          		DW	2A5AH           ;a(5)
042866 CC 4C       6690          		DW	4CCCH
042868 7D          6691          		DB	7DH
042869 5C A9       6692          		DW	0A95CH          ;a(3)
04286B AA AA       6693          		DW	0AAAAH
04286D 7E          6694          		DB	7EH
04286E 00 00       6695          		DW	0               ;a(1)
042870 00 00       6696          		DW	0
042872 80          6697          		DB	80H
042873 CD F4 2C 04 6698          		CALL    POP5
042877 CD F4 2C 04 6699          		CALL    POP5
04287B CD 46 23 04 6700          		CALL    FMUL
04287F F1          6701          		POP     AF
042880 CD 80 26 04 6702  ACS1:			CALL    PIBY4           ;PI/4
042884 1F          6703          		RRA
042885 F5          6704          		PUSH    AF
042886 DC 34 22 04 6705          		CALL    C,FADD
04288A F1          6706          		POP     AF
04288B 04          6707          		INC     B
04288C 1F          6708          		RRA
04288D DC 21 22 04 6709          		CALL    C,RSUB
042891 F1          6710          		POP     AF
042892 B7          6711          		OR      A
042893 F0          6712          		RET     P
042894 CB FC       6713          		SET     7,H             ;MAKE NEGATIVE
042896 AF          6714          		XOR     A
042897 C9          6715          		RET
042898             6716  ;
042898             6717  ;ACS - Arc cosine=PI/2-ASN.
042898             6718  ;Result is floating point numeric.
042898             6719  ;
042898 CD D6 27 04 6720  ACS_FP:			CALL    ASN_FP
04289C 3E 02       6721          		LD      A,2
04289E F5          6722          		PUSH    AF
04289F 18 DF       6723          		JR      ACS1
0428A1             6724  ;
0428A1             6725  ;Function STR - convert numeric value to ASCII string.
0428A1             6726  ;   Inputs: HLH'L'C = integer or floating-point number
0428A1             6727  ;           DE = address at which to store string
0428A1             6728  ;           IX = address of @% format control
0428A1             6729  ;  Outputs: String stored, with NUL terminator
0428A1             6730  ;
0428A1             6731  ;First normalise for decimal output:
0428A1             6732  ;
0428A1 CD DE 2B 04 6733  STR_FP:			CALL    SFLOAT_FP
0428A5 06 00       6734          		LD      B,0             ;DEFAULT PT. POSITION
0428A7 CB 7C       6735          		BIT     7,H             ;NEGATIVE?
0428A9 28 06       6736          		JR      Z,STR10
0428AB CB BC       6737          		RES     7,H
0428AD 3E 2D       6738          		LD      A,'-'
0428AF 12          6739          		LD      (DE),A          ;STORE SIGN
0428B0 13          6740          		INC     DE
0428B1 AF          6741  STR10:			XOR     A               ;CLEAR A
0428B2 B9          6742          		CP      C
0428B3 28 4E       6743          		JR      Z,STR02          ;ZERO
0428B5 D5          6744          		PUSH    DE              ;SAVE TEXT POINTER
0428B6 78          6745          		LD      A,B
0428B7 F5          6746  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B8 79          6747          		LD      A,C             ;BINARY EXPONENT
0428B9 FE A1       6748          		CP      161
0428BB 30 1C       6749          		JR      NC,STR14
0428BD FE 9B       6750          		CP      155
0428BF 30 29       6751          		JR      NC,STR15
0428C1 2F          6752          		CPL
0428C2 FE E1       6753          		CP      225
0428C4 38 02       6754          		JR      C,STR13
0428C6 3E F8       6755          		LD      A,-8
0428C8 C6 1C       6756  STR13:			ADD     A,28
0428CA CD 57 2D 04 6757          		CALL    POWR10
0428CE F5          6758          		PUSH    AF
0428CF CD 46 23 04 6759          		CALL    FMUL
0428D3 F1          6760          		POP     AF
0428D4 47          6761          		LD      B,A
0428D5 F1          6762          		POP     AF
0428D6 90          6763          		SUB     B
0428D7 18 DE       6764          		JR      STR11
0428D9 D6 20       6765  STR14:			SUB     32
0428DB CD 57 2D 04 6766          		CALL    POWR10
0428DF F5          6767          		PUSH    AF
0428E0 CD 9D 22 04 6768          		CALL    FDIV
0428E4 F1          6769          		POP     AF
0428E5 47          6770          		LD      B,A
0428E6 F1          6771          		POP     AF
0428E7 80          6772          		ADD     A,B
0428E8 18 CD       6773          		JR      STR11
0428EA 3E 09       6774  STR15:			LD      A,9
0428EC CD 57 2D 04 6775          		CALL    POWR10          ;10^9
0428F0 CD 6B 2C 04 6776          		CALL    FCP0
0428F4 79          6777          		LD      A,C
0428F5 C1          6778          		POP     BC
0428F6 4F          6779          		LD      C,A
0428F7 CB FC       6780          		SET     7,H             ;IMPLIED 1
0428F9 DC 93 2C 04 6781          		CALL    C,X10B          ;X10, DEC B
0428FD D1          6782          		POP     DE              ;RESTORE TEXT POINTER
0428FE CB B9       6783          		RES     7,C
042900 3E 00       6784          		LD      A,0
042902 17          6785          		RLA                     ;PUT CARRY IN LSB
042903             6786  ;
042903             6787  ;At this point decimal normalisation has been done,
042903             6788  ;now convert to decimal digits:
042903             6789  ;      AHLH'L' = number in normalised integer form
042903             6790  ;            B = decimal place adjustment
042903             6791  ;            C = binary place adjustment (29-33)
042903             6792  ;
042903 0C          6793  STR02:			INC     C
042904 08          6794          		EX      AF,AF'          ;SAVE A
042905 78          6795          		LD      A,B
042906 DD CB 02 4E 6796          		BIT     1,(IX+2)
04290A 20 08       6797          		JR      NZ,STR20
04290C AF          6798          		XOR     A
04290D DD BE 01    6799          		CP      (IX+1)
042910 28 0B       6800          		JR      Z,STR21
042912 3E F6       6801          		LD      A,-10
042914 DD 86 01    6802  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042917 B7          6803          		OR      A               ;CLEAR CARRY
042918 FA 1D 29 04 6804          		JP      M,STR21
04291C AF          6805          		XOR     A
04291D F5          6806  STR21:			PUSH    AF
04291E 08          6807          		EX      AF,AF'          ;RESTORE A
04291F CD C7 2C 04 6808  STR22:			CALL    X2              ;RL AHLH'L'
042923 8F          6809          		ADC     A,A
042924 FE 0A       6810          		CP      10
042926 38 05       6811          		JR      C,STR23
042928 D6 0A       6812          		SUB     10
04292A D9          6813          		EXX
04292B 2C          6814          		INC     L               ;SET RESULT BIT
04292C D9          6815          		EXX
04292D 0D          6816  STR23:			DEC     C
04292E 20 EF       6817          		JR      NZ,STR22        ;32 TIMES
042930 4F          6818          		LD      C,A             ;REMAINDER
042931 7C          6819          		LD      A,H
042932 E6 3F       6820          		AND     3FH             ;CLEAR OUT JUNK
042934 67          6821          		LD      H,A
042935 F1          6822          		POP     AF
042936 F2 44 29 04 6823          		JP      P,STR24
04293A 3C          6824          		INC     A
04293B 20 1C       6825          		JR      NZ,STR26
04293D 3E 04       6826          		LD      A,4
04293F B9          6827          		CP      C               ;ROUND UP?
042940 3E 00       6828          		LD      A,0
042942 18 15       6829          		JR      STR26
042944 F5          6830  STR24:			PUSH    AF
042945 79          6831          		LD      A,C
042946 CE 30       6832          		ADC     A,'0'           ;ADD CARRY
042948 FE 30       6833          		CP      '0'
04294A 28 05       6834          		JR      Z,STR25         ;SUPPRESS ZERO
04294C FE 3A       6835          		CP      '9'+1
04294E 3F          6836          		CCF
04294F 30 08       6837          		JR      NC,STR26
042951 E3          6838  STR25:			EX      (SP),HL
042952 CB 75       6839          		BIT     6,L             ;ZERO FLAG
042954 E3          6840  		        EX      (SP),HL
042955 20 05       6841          		JR      NZ,STR27
042957 3E 30       6842          		LD      A,'0'
042959 3C          6843  STR26:			INC     A               ;SET +VE
04295A 3D          6844          		DEC     A
04295B F5          6845          		PUSH    AF              ;PUT ON STACK + CARRY
04295C 04          6846  STR27:			INC     B
04295D CD 37 2C 04 6847          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042961 0E 20       6848          		LD      C,32
042963 3E 00       6849          		LD      A,0
042965 20 B8       6850          		JR      NZ,STR22
042967 F1          6851          		POP     AF
042968 F5          6852          		PUSH    AF
042969 3E 00       6853          		LD      A,0
04296B 38 B2       6854          		JR      C,STR22
04296D             6855  ;
04296D             6856  ;At this point, the decimal character string is stored
04296D             6857  ; on the stack. Trailing zeroes are suppressed and may
04296D             6858  ; need to be replaced.
04296D             6859  ;B register holds decimal point position.
04296D             6860  ;Now format number and store as ASCII string:
04296D             6861  ;
04296D EB          6862  STR3:			EX      DE,HL           ;STRING POINTER
04296E 0E FF       6863          		LD      C,-1            ;FLAG "E"
042970 16 01       6864          		LD      D,1
042972 DD 5E 01    6865          		LD      E,(IX+1)        ;f2
042975 DD CB 02 46 6866          		BIT     0,(IX+2)
042979 20 35       6867          		JR      NZ,STR34        ;E MODE
04297B DD CB 02 4E 6868          		BIT     1,(IX+2)
04297F 28 12       6869          		JR      Z,STR31
042981 78          6870          		LD      A,B             ;F MODE
042982 B7          6871          		OR      A
042983 28 05       6872          		JR      Z,STR30
042985 FA 8A 29 04 6873          		JP      M,STR30
042989 50          6874          		LD      D,B
04298A 7A          6875  STR30:			LD      A,D
04298B DD 86 01    6876          		ADD     A,(IX+1)
04298E 5F          6877          		LD      E,A
04298F FE 0B       6878          		CP      11
042991 38 19       6879          		JR      C,STR32
042993 78          6880  STR31:			LD      A,B             ;G MODE
042994 11 01 01 00 6881          		LD      DE,101H
042998 B7          6882          		OR      A
042999 FA B0 29 04 6883          		JP      M,STR34
04299D 28 0D       6884          		JR      Z,STR32
04299F DD 7E 01    6885          		LD      A,(IX+1)
0429A2 B7          6886          		OR      A
0429A3 20 02       6887          		JR      NZ,STR3A
0429A5 3E 0A       6888          		LD      A,10
0429A7 B8          6889  STR3A:			CP      B
0429A8 38 06       6890          		JR      C,STR34
0429AA 50          6891          		LD      D,B
0429AB 58          6892          		LD      E,B
0429AC 78          6893  STR32:			LD      A,B
0429AD C6 81       6894          		ADD     A,129
0429AF 4F          6895          		LD      C,A
0429B0 CB FA       6896  STR34:			SET     7,D
0429B2 1D          6897          		DEC     E
0429B3 7A          6898  STR35:			LD      A,D
0429B4 B9          6899          		CP      C
0429B5 30 0E       6900          		JR      NC,STR33
0429B7 F1          6901  STR36:			POP     AF
0429B8 28 04       6902          		JR      Z,STR37
0429BA F2 C7 29 04 6903          		JP      P,STR38
0429BE F5          6904  STR37:			PUSH    AF
0429BF 1C          6905          		INC     E
0429C0 1D          6906          		DEC     E
0429C1 FA D8 29 04 6907          		JP      M,STR4
0429C5 3E 30       6908  STR33:			LD      A,'0'
0429C7 15          6909  STR38:			DEC     D
0429C8 E2 CF 29 04 6910          		JP      PO,STR39
0429CC 36 2E       6911          		LD      (HL),'.'
0429CE 23          6912          		INC     HL
0429CF 77          6913  STR39:			LD      (HL),A
0429D0 23          6914          		INC     HL
0429D1 1D          6915          		DEC     E
0429D2 F2 B3 29 04 6916          		JP      P,STR35
0429D6 18 DF       6917          		JR      STR36
0429D8             6918  ;
0429D8 F1          6919  STR4:			POP     AF
0429D9 0C          6920  STR40:			INC     C
0429DA 4D          6921          		LD      C,L
0429DB 20 28       6922          		JR      NZ,STR44
0429DD 36 45       6923          		LD      (HL),'E'        ;EXPONENT
0429DF 23          6924          		INC     HL
0429E0 78          6925          		LD      A,B
0429E1 3D          6926          		DEC     A
0429E2 F2 EB 29 04 6927          		JP      P,STR41
0429E6 36 2D       6928          		LD      (HL),'-'
0429E8 23          6929          		INC     HL
0429E9 ED 44       6930          		NEG
0429EB 36 30       6931  STR41:			LD      (HL),'0'
0429ED 28 15       6932          		JR      Z,STR47
0429EF FE 0A       6933          		CP      10
0429F1 47          6934          		LD      B,A
0429F2 3E 3A       6935          		LD      A,':'
0429F4 38 03       6936          		JR      C,STR42
0429F6 23          6937          		INC     HL
0429F7 36 30       6938          		LD      (HL),'0'
0429F9 34          6939  STR42:			INC     (HL)
0429FA BE          6940          		CP      (HL)
0429FB 20 05       6941          		JR      NZ,STR43
0429FD 36 30       6942          		LD      (HL),'0'
0429FF 2B          6943          		DEC     HL
042A00 34          6944          		INC     (HL)
042A01 23          6945          		INC     HL
042A02 10 F5       6946  STR43:			DJNZ    STR42
042A04 23          6947  STR47:			INC     HL
042A05 EB          6948  STR44:			EX      DE,HL
042A06 C9          6949        			RET
042A07             6950  ;
042A07             6951  ;Support subroutines:
042A07             6952  ;
042A07 DD 46 04    6953  DLOAD5:			LD      B,(IX+4)
042A0A D9          6954          		EXX
042A0B DD 5E 00    6955          		LD      E,(IX+0)
042A0E DD 56 01    6956          		LD      D,(IX+1)
042A11 D9          6957          		EXX
042A12 DD 5E 02    6958          		LD      E,(IX+2)
042A15 DD 56 03    6959          		LD      D,(IX+3)
042A18 C9          6960          		RET
042A19             6961  ;
042A19 DD 46 06    6962  DLOAD5_SPL:		LD      B,(IX+6)
042A1C D9          6963  			EXX
042A1D DD 17 00    6964  			LD	DE, (IX+0)
042A20 D9          6965  			EXX
042A21 DD 17 03    6966  			LD	DE, (IX+3)
042A24 C9          6967  			RET
042A25             6968  ;
042A25             6969  ;CON_FP - Get unsigned numeric constant from ASCII string.
042A25             6970  ;   Inputs: ASCII string at (IX).
042A25             6971  ;  Outputs: Variable-type result in HLH'L'C
042A25             6972  ;           IX updated (points to delimiter)
042A25             6973  ;           A7 = 0 (numeric marker)
042A25             6974  ;
042A25 CD 5B 2C 04 6975  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A29 0E 00       6976          		LD      C,0             ;TRUNCATION COUNTER
042A2B CD B9 2A 04 6977          		CALL    UINT          ;GET INTEGER PART
042A2F FE 2E       6978          		CP      '.'
042A31 06 00       6979          		LD      B,0             ;DECL. PLACE COUNTER
042A33 CC B7 2A 04 6980          		CALL    Z,NUMBIX        ;GET FRACTION PART
042A37 FE 45       6981          		CP      'E'
042A39 3E 00       6982          		LD      A,0             ;INITIALISE EXPONENT
042A3B CC 85 2A 04 6983          		CALL    Z,GETEXP        ;GET EXPONENT
042A3F CB 7C       6984          		BIT     7,H
042A41 20 08       6985          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A43 B7          6986          		OR      A
042A44 20 05       6987          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A46 B8          6988          		CP      B
042A47 20 02       6989          		JR      NZ,CON0         ;DECIMAL POINT
042A49 B9          6990          		CP      C
042A4A C8          6991          		RET     Z               ;INTEGER
042A4B 90          6992  CON0:			SUB     B
042A4C 81          6993          		ADD     A,C
042A4D 0E 9F       6994          		LD      C,159
042A4F CD BE 2B 04 6995          		CALL    FLOAT_
042A53 CB BC       6996          		RES     7,H             ;DITCH IMPLIED 1
042A55 B7          6997          		OR      A
042A56 C8          6998          		RET     Z               ;DONE
042A57 FA 65 2A 04 6999          		JP      M,CON2          ;NEGATIVE EXPONENT
042A5B CD 57 2D 04 7000          		CALL    POWR10
042A5F CD 46 23 04 7001          		CALL    FMUL            ;SCALE
042A63 AF          7002          		XOR     A
042A64 C9          7003          		RET
042A65 FE DA       7004  CON2:			CP      -38
042A67 38 0C       7005          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A69 ED 44       7006          		NEG
042A6B CD 57 2D 04 7007          		CALL    POWR10
042A6F CD 9D 22 04 7008          		CALL    FDIV            ;SCALE
042A73 AF          7009          		XOR     A
042A74 C9          7010          		RET
042A75 F5          7011  CON3:			PUSH    AF
042A76 3E 26       7012          		LD      A,38
042A78 CD 57 2D 04 7013          		CALL    POWR10
042A7C CD 9D 22 04 7014          		CALL    FDIV
042A80 F1          7015          		POP     AF
042A81 C6 26       7016          		ADD     A,38
042A83 18 E0       7017          		JR      CON2
042A85             7018  ;
042A85             7019  ;GETEXP - Get decimal exponent from string
042A85             7020  ;     Inputs: ASCII string at (IX)
042A85             7021  ;             (IX points at 'E')
042A85             7022  ;             A = initial value
042A85             7023  ;    Outputs: A = new exponent
042A85             7024  ;             IX updated.
042A85             7025  ;   Destroys: A,A',IX,F,F'
042A85             7026  ;
042A85 C5          7027  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A86 47          7028          		LD      B,A             ;INITIAL VALUE
042A87 0E 02       7029          		LD      C,2             ;2 DIGITS MAX
042A89 DD 23       7030          		INC     IX              ;BUMP PAST 'E'
042A8B CD 75 2E 04 7031          		CALL    SIGNQ
042A8F 08          7032          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A90 CD 6B 2E 04 7033  GETEX1:			CALL    DIGITQ
042A94 38 18       7034          		JR      C,GETEX2
042A96 78          7035          		LD      A,B             ;B=B*10
042A97 87          7036          		ADD     A,A
042A98 87          7037          		ADD     A,A
042A99 80          7038          		ADD     A,B
042A9A 87          7039          		ADD     A,A
042A9B 47          7040          		LD      B,A
042A9C DD 7E 00    7041          		LD      A,(IX)          ;GET BACK DIGIT
042A9F DD 23       7042          		INC     IX
042AA1 E6 0F       7043          		AND     0FH             ;MASK UNWANTED BITS
042AA3 80          7044          		ADD     A,B             ;ADD IN DIGIT
042AA4 47          7045          		LD      B,A
042AA5 0D          7046          		DEC     C
042AA6 F2 90 2A 04 7047          		JP      P,GETEX1
042AAA 06 64       7048          		LD      B,100           ;FORCE OVERFLOW
042AAC 18 E2       7049          		JR      GETEX1
042AAE 08          7050  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AAF FE 2D       7051          		CP      '-'
042AB1 78          7052          		LD      A,B
042AB2 C1          7053          		POP     BC              ;RESTORE
042AB3 C0          7054          		RET     NZ
042AB4 ED 44       7055          		NEG                     ;NEGATE EXPONENT
042AB6 C9          7056          		RET
042AB7             7057  ;
042AB7             7058  ;UINT: Get unsigned integer from string.
042AB7             7059  ;    Inputs: string at (IX)
042AB7             7060  ;            C = truncated digit count
042AB7             7061  ;                (initially zero)
042AB7             7062  ;            B = total digit count
042AB7             7063  ;            HLH'L' = initial value
042AB7             7064  ;   Outputs: HLH'L' = number (binary integer)
042AB7             7065  ;            A = delimiter.
042AB7             7066  ;            B, C & IX updated
042AB7             7067  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042AB7             7068  ;
042AB7 DD 23       7069  NUMBIX:			INC     IX
042AB9 CD 6B 2E 04 7070  UINT:			CALL    DIGITQ
042ABD D8          7071          		RET     C
042ABE 04          7072          		INC     B               ;INCREMENT DIGIT COUNT
042ABF DD 23       7073          		INC     IX
042AC1 CD B4 2C 04 7074          		CALL    X10             ;*10 & COPY OLD VALUE
042AC5 38 15       7075          		JR      C,NUMB1         ;OVERFLOW
042AC7 0D          7076          		DEC     C               ;SEE IF TRUNCATED
042AC8 0C          7077          		INC     C
042AC9 20 11       7078          		JR      NZ,NUMB1        ;IMPORTANT!
042ACB E6 0F       7079          		AND     0FH
042ACD D9          7080          		EXX
042ACE 06 00       7081          		LD      B,0
042AD0 4F          7082          		LD      C,A
042AD1 52 09       7083          		ADD.S   HL,BC           ;ADD IN DIGIT
042AD3 D9          7084          		EXX
042AD4 30 E3       7085          		JR      NC,UINT
042AD6 52 23       7086          		INC.S   HL              ;CARRY
042AD8 7C          7087          		LD      A,H
042AD9 B5          7088          		OR      L
042ADA 20 DD       7089          		JR      NZ,UINT
042ADC 0C          7090  NUMB1:			INC     C               ;TRUNCATION COUNTER
042ADD CD 12 2C 04 7091          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AE1 18 D6       7092          		JR      UINT
042AE3             7093  ;
042AE3             7094  ;FIX - Fix number to specified exponent value.
042AE3             7095  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AE3             7096  ;            A = desired exponent (A>C)
042AE3             7097  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AE3             7098  ;            fraction shifted into B'C'
042AE3             7099  ;            A'F' positive if integer input
042AE3             7100  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AE3             7101  ;
042AE3 08          7102  FIX:			EX      AF,AF'
042AE4 AF          7103          		XOR     A
042AE5 08          7104          		EX      AF,AF'
042AE6 CB FC       7105          		SET     7,H             ;IMPLIED 1
042AE8 CD 17 2C 04 7106  FIX1:			CALL    DIV2
042AEC B9          7107          		CP      C
042AED C8          7108          		RET     Z
042AEE D2 E8 2A 04 7109          		JP      NC,FIX1
042AF2 C3 26 2C 04 7110          		JP      OFLOW
042AF6             7111  ;
042AF6             7112  ;SFIX - Convert to integer if necessary.
042AF6             7113  ;    Input: Variable-type number in HLH'L'C
042AF6             7114  ;   Output: Integer in HLH'L', C=0
042AF6             7115  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042AF6             7116  ;
042AF6             7117  ;NEGATE - Negate HLH'L'
042AF6             7118  ;    Destroys: H,L,H',L',F
042AF6             7119  ;
042AF6 CD 0F 2C 04 7120  FIX2:			CALL    SWAP_FP
042AFA CD 02 2B 04 7121          		CALL    SFIX_FP
042AFE CD 0F 2C 04 7122          		CALL    SWAP_FP
042B02 0D          7123  SFIX_FP:			DEC     C
042B03 0C          7124          		INC     C
042B04 C8          7125          		RET     Z               ;INTEGER/ZERO
042B05 CB 7C       7126          		BIT     7,H             ;SIGN
042B07 F5          7127          		PUSH    AF
042B08 3E 9F       7128          		LD      A,159
042B0A CD E3 2A 04 7129          		CALL    FIX
042B0E F1          7130          		POP     AF
042B0F 0E 00       7131          		LD      C,0
042B11 C8          7132          		RET     Z
042B12 B7          7133  NEGATE:			OR      A               ;CLEAR CARRY
042B13 D9          7134          		EXX
042B14 D5          7135  NEG0:			PUSH    DE
042B15 EB          7136          		EX      DE,HL
042B16 21 00 00 00 7137          		LD      HL,0
042B1A 52 ED 52    7138          		SBC.S   HL,DE
042B1D D1          7139          		POP     DE
042B1E D9          7140          		EXX
042B1F D5          7141          		PUSH    DE
042B20 EB          7142          		EX      DE,HL
042B21 21 00 00 00 7143          		LD      HL,0
042B25 52 ED 52    7144          		SBC.S   HL,DE
042B28 D1          7145          		POP     DE
042B29 C9          7146          		RET
042B2A             7147  ;
042B2A             7148  ;NEG - Negate HLH'L'B'C'
042B2A             7149  ;    Also complements A (used in FADD)
042B2A             7150  ;    Destroys: A,H,L,B',C',H',L',F
042B2A             7151  ;
042B2A D9          7152  NEG_:			EXX
042B2B 2F          7153          		CPL
042B2C E5          7154          		PUSH    HL
042B2D B7          7155          		OR      A               ;CLEAR CARRY
042B2E 21 00 00 00 7156          		LD      HL,0
042B32 52 ED 42    7157          		SBC.S   HL,BC
042B35 44          7158          		LD      B,H
042B36 4D          7159          		LD      C,L
042B37 E1          7160          		POP     HL
042B38 18 DA       7161          		JR      NEG0
042B3A             7162  ;
042B3A             7163  ;SCALE - Trig scaling.
042B3A             7164  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B3A             7165  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B3A             7166  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B3A             7167  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B3A             7168  ;           E = quotient (bit 7 is sticky)
042B3A             7169  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B3A             7170  ;FLO48 - Float unsigned number (48 bits)
042B3A             7171  ;    Input/output in HLH'L'B'C'C
042B3A             7172  ;   Destroys: C,H,L,B',C',H',L',F
042B3A             7173  ;
042B3A 3E 96       7174  SCALE:			LD      A,150
042B3C B9          7175          		CP      C
042B3D 3E 17       7176          		LD      A,ACLOST
042B3F DA B5 20 04 7177          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B43 CD 80 26 04 7178          		CALL    PIBY4
042B47 D9          7179          		EXX
042B48 01 69 21 00 7180          		LD      BC,2169H        ;3.141592653589793238
042B4C D9          7181          		EXX
042B4D CB FA       7182  MOD48:			SET     7,D             ;IMPLIED 1
042B4F CB FC       7183          		SET     7,H
042B51 79          7184          		LD      A,C
042B52 0E 00       7185          		LD      C,0             ;INIT QUOTIENT
042B54 DD 21 00 00 7186          		LD      IX,0
       00          
042B59 DD E5       7187          		PUSH    IX              ;PUT ZERO ON STACK
042B5B B8          7188          		CP      B
042B5C 38 46       7189          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B5E D9          7190  MOD481:			EXX                     ;CARRY=0 HERE
042B5F E3          7191          		EX      (SP),HL
042B60 52 ED 42    7192          		SBC.S   HL,BC
042B63 E3          7193          		EX      (SP),HL
042B64 52 ED 52    7194          		SBC.S   HL,DE
042B67 D9          7195          		EXX
042B68 52 ED 52    7196          		SBC.S   HL,DE
042B6B 30 0C       7197          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B6D D9          7198          		EXX
042B6E E3          7199          		EX      (SP),HL
042B6F 52 09       7200          		ADD.S   HL,BC
042B71 E3          7201          		EX      (SP),HL
042B72 52 ED 5A    7202          		ADC.S   HL,DE
042B75 D9          7203          		EXX
042B76 52 ED 5A    7204          		ADC.S   HL,DE
042B79 3F          7205  MOD482:			CCF
042B7A CB 11       7206          		RL      C               ;QUOTIENT
042B7C 30 02       7207          		JR      NC,MOD483
042B7E CB F9       7208          		SET     7,C             ;STICKY BIT
042B80 3D          7209  MOD483:			DEC     A
042B81 B8          7210          		CP      B
042B82 38 1F       7211          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B84 E3          7212          		EX      (SP),HL
042B85 52 29       7213          		ADD.S   HL,HL           ;DIVIDEND * 2
042B87 E3          7214          		EX      (SP),HL
042B88 D9          7215          		EXX
042B89 52 ED 6A    7216          		ADC.S   HL,HL
042B8C D9          7217          		EXX
042B8D 52 ED 6A    7218          		ADC.S   HL,HL
042B90 30 CC       7219          		JR      NC,MOD481       ;AGAIN
042B92 B7          7220          		OR      A
042B93 D9          7221          		EXX
042B94 E3          7222          		EX      (SP),HL
042B95 52 ED 42    7223          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B98 E3          7224          		EX      (SP),HL
042B99 52 ED 52    7225          		SBC.S   HL,DE
042B9C D9          7226          		EXX
042B9D 52 ED 52    7227          		SBC.S   HL,DE
042BA0 B7          7228          		OR      A
042BA1 18 D6       7229          		JR      MOD482
042BA3             7230  ;
042BA3 3C          7231  MOD484:			INC     A
042BA4 59          7232  MOD485:			LD      E,C             ;QUOTIENT
042BA5 4F          7233          		LD      C,A             ;REMAINDER EXPONENT
042BA6 D9          7234          		EXX
042BA7 C1          7235          		POP     BC
042BA8 D9          7236          		EXX
042BA9 CB 7C       7237  FLO48:			BIT     7,H
042BAB C0          7238          		RET     NZ
042BAC D9          7239          		EXX
042BAD CB 21       7240          		SLA     C
042BAF CB 10       7241          		RL      B
042BB1 52 ED 6A    7242          		ADC.S   HL,HL
042BB4 D9          7243          		EXX
042BB5 52 ED 6A    7244          		ADC.S   HL,HL
042BB8 0D          7245          		DEC     C
042BB9 C2 A9 2B 04 7246          		JP      NZ,FLO48
042BBD C9          7247          		RET
042BBE             7248  ;
042BBE             7249  ;Float unsigned number
042BBE             7250  ;    Input/output in HLH'L'C
042BBE             7251  ;   Destroys: C,H,L,H',L',F
042BBE             7252  ;
042BBE CB 7C       7253  FLOAT_:			BIT     7,H
042BC0 C0          7254          		RET     NZ
042BC1 D9          7255          		EXX                     ;SAME AS "X2"
042BC2 52 29       7256          		ADD.S   HL,HL           ;TIME-CRITICAL
042BC4 D9          7257          		EXX                     ;REGION
042BC5 52 ED 6A    7258          		ADC.S   HL,HL           ;(BENCHMARKS)
042BC8 0D          7259          		DEC     C
042BC9 C2 BE 2B 04 7260          		JP      NZ,FLOAT_
042BCD C9          7261          		RET
042BCE             7262  ;
042BCE             7263  ;SFLOAT - Convert to floating-point if necessary.
042BCE             7264  ;    Input: Variable-type number in HLH'L'C
042BCE             7265  ;    Output: Floating-point in HLH'L'C
042BCE             7266  ;    Destroys: A,C,H,L,H',L',F
042BCE             7267  ;
042BCE 08          7268  FLOATA:			EX      AF,AF'
042BCF             7269          		; ADD     A,(RTABLE-DTABLE)/3
042BCF C6 2A       7270          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BD1 08          7271          		EX      AF,AF'
042BD2 CD 0F 2C 04 7272  FLOAT2:			CALL    SWAP_FP
042BD6 CD DE 2B 04 7273          		CALL    SFLOAT_FP
042BDA CD 0F 2C 04 7274          		CALL    SWAP_FP
042BDE 0D          7275  SFLOAT_FP:			DEC     C
042BDF 0C          7276          		INC     C
042BE0 C0          7277          		RET     NZ              ;ALREADY FLOATING-POINT
042BE1 CD 37 2C 04 7278          		CALL    TEST_FP
042BE5 C8          7279          		RET     Z               ;ZERO
042BE6 7C          7280          		LD      A,H
042BE7 B7          7281          		OR      A
042BE8 FC 12 2B 04 7282          		CALL    M,NEGATE
042BEC 0E 9F       7283          		LD      C,159
042BEE CD BE 2B 04 7284          		CALL    FLOAT_
042BF2 B7          7285          		OR      A
042BF3 F8          7286          		RET     M               ;NEGATIVE
042BF4 CB BC       7287          		RES     7,H
042BF6 C9          7288          		RET
042BF7             7289  ;
042BF7             7290  ;ROUND UP
042BF7             7291  ;Return with carry set if 32-bit overflow
042BF7             7292  ;   Destroys: H,L,B',C',H',L',F
042BF7             7293  ;
042BF7 D9          7294  ADD1_FP:			EXX
042BF8 01 01 00 00 7295          		LD      BC,1
042BFC 52 09       7296          		ADD.S   HL,BC
042BFE D9          7297          		EXX
042BFF D0          7298          		RET     NC
042C00 C5          7299          		PUSH    BC
042C01 01 01 00 00 7300          		LD      BC,1
042C05 52 09       7301          		ADD.S   HL,BC
042C07 C1          7302          		POP     BC
042C08 C9          7303          		RET
042C09             7304  ;
042C09             7305  ;ODD - Add one if even, leave alone if odd.
042C09             7306  ; (Used to perform unbiassed rounding, i.e.
042C09             7307  ;  number is rounded up half the time)
042C09             7308  ;    Destroys: L',F (carry cleared)
042C09             7309  ;
042C09 B7          7310  ODD:			OR      A               ;CLEAR CARRY
042C0A D9          7311          		EXX
042C0B CB C5       7312          		SET     0,L             ;MAKE ODD
042C0D D9          7313          		EXX
042C0E C9          7314          		RET
042C0F             7315  ;
042C0F             7316  ;SWAP_FP - Swap arguments.
042C0F             7317  ;    Exchanges DE,HL D'E',H'L' and B,C
042C0F             7318  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042C0F             7319  ;SWAP1 - Swap DEHL with D'E'H'L'
042C0F             7320  ;    Destroys: D,E,H,L,D',E',H',L'
042C0F             7321  ;
042C0F 79          7322  SWAP_FP:			LD      A,C
042C10 48          7323          		LD      C,B
042C11 47          7324          		LD      B,A
042C12 EB          7325  SWAP1:			EX      DE,HL
042C13 D9          7326          		EXX
042C14 EB          7327          		EX      DE,HL
042C15 D9          7328          		EXX
042C16 C9          7329          		RET
042C17             7330  ;
042C17             7331  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042C17             7332  ; INCC - destroys C,F
042C17             7333  ; OFLOW
042C17             7334  ;
042C17 CD D0 2C 04 7335  DIV2:			CALL    D2
042C1B D9          7336          		EXX
042C1C CB 18       7337          		RR      B
042C1E CB 19       7338          		RR      C
042C20 08          7339          		EX      AF,AF'
042C21 B0          7340          		OR      B
042C22 08          7341          		EX      AF,AF'
042C23 D9          7342          		EXX
042C24 0C          7343  INCC:			INC     C
042C25 C0          7344          		RET     NZ
042C26 3E 14       7345  OFLOW:			LD      A,TOOBIG_FP
042C28 C3 B5 20 04 7346          		JP      ERROR_FP_           ;"Too big"
042C2C             7347  ;
042C2C             7348  ; FTEST - Test for zero & sign
042C2C             7349  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042C2C             7350  ;
042C2C CD 37 2C 04 7351  FTEST_FP:			CALL    TEST_FP
042C30 C8          7352          		RET     Z
042C31 7C          7353          		LD      A,H
042C32 E6 80       7354          		AND     10000000B
042C34 F6 40       7355          		OR      01000000B
042C36 C9          7356          		RET
042C37             7357  ;
042C37             7358  ; TEST_FP - Test HLH'L' for zero.
042C37             7359  ;     Output: Z-flag set & A=0 if HLH'L'=0
042C37             7360  ;     Destroys: A,F
042C37             7361  ;
042C37 7C          7362  TEST_FP:			LD      A,H
042C38 B5          7363          		OR      L
042C39 D9          7364          		EXX
042C3A B4          7365          		OR      H
042C3B B5          7366          		OR      L
042C3C D9          7367          		EXX
042C3D C9          7368          		RET
042C3E             7369  ;
042C3E             7370  ; FCOMP - Compare two numbers
042C3E             7371  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C3E             7372  ;
042C3E 78          7373  FCOMP_FP:			LD      A,B
042C3F B1          7374          		OR      C               ;Both integer?
042C40 20 0B       7375          		JR      NZ,FCOMP1
042C42 CD 57 2C 04 7376          		CALL    ICP
042C46 3E 00       7377  FCOMP0:			LD      A,0
042C48 C8          7378          		RET     Z               ;Equal
042C49 3E 80       7379          		LD      A,80H
042C4B 1F          7380          		RRA
042C4C C9          7381          		RET
042C4D             7382  ;
042C4D CD D2 2B 04 7383  FCOMP1:			CALL    FLOAT2          ;Float both
042C51 CD 65 2C 04 7384          		CALL    FCP
042C55 18 EF       7385          		JR      FCOMP0
042C57             7386  ;
042C57             7387  ; Integer and floating point compare.
042C57             7388  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C57             7389  ; Result pre-set to FALSE
042C57             7390  ; ICP1, FCP1 destroy A,F
042C57             7391  ;
042C57             7392  ; ZERO - Return zero.
042C57             7393  ;  Destroys: A,C,H,L,H',L'
042C57             7394  ;
042C57 CD 8A 2C 04 7395  ICP:			CALL    ICP1
042C5B 3E 00       7396  ZERO_FP:			LD      A,0
042C5D D9          7397          		EXX
042C5E 67          7398          		LD      H,A
042C5F 6F          7399  	       		LD      L,A
042C60 D9          7400          		EXX
042C61 67          7401        			LD      H,A
042C62 6F          7402       			LD      L,A
042C63 4F          7403  	    		LD      C,A
042C64 C9          7404          		RET
042C65             7405  ;
042C65 CD 7C 2C 04 7406  FCP:			CALL    FCP1
042C69 18 F0       7407          		JR      ZERO_FP            ;PRESET FALSE
042C6B             7408  ;
042C6B 79          7409  FCP0:			LD      A,C
042C6C B8          7410          		CP      B               ;COMPARE EXPONENTS
042C6D C0          7411          		RET     NZ
042C6E             7412  ICP0:
042C6E 52 ED 52    7413  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C71 52 19       7414          		ADD.S   HL,DE
042C73 C0          7415          		RET     NZ
042C74 D9          7416          		EXX
042C75 52 ED 52    7417          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C78 52 19       7418          		ADD.S   HL,DE
042C7A D9          7419          		EXX
042C7B C9          7420          		RET
042C7C             7421  ;
042C7C 7C          7422  FCP1:			LD      A,H
042C7D AA          7423          		XOR     D
042C7E 7C          7424          		LD      A,H
042C7F 17          7425          		RLA
042C80 F8          7426          		RET     M
042C81 30 E8       7427          		JR      NC,FCP0
042C83 CD 6B 2C 04 7428          		CALL    FCP0
042C87 C8          7429          		RET     Z               ;** V0.1 BUG FIX
042C88 3F          7430          		CCF
042C89 C9          7431          		RET
042C8A             7432  ;
042C8A 7C          7433  ICP1:			LD      A,H
042C8B AA          7434          		XOR     D
042C8C F2 6E 2C 04 7435          		JP      P,ICP0
042C90 7C          7436          		LD      A,H
042C91 17          7437          		RLA
042C92 C9          7438          		RET
042C93             7439  ;
042C93             7440  ; ADD - Integer add.
042C93             7441  ; Carry, sign & zero flags valid on exit
042C93             7442  ;     Destroys: H,L,H',L',F
042C93             7443  ;
042C93 05          7444  X10B:			DEC     B
042C94 0C          7445          		INC     C
042C95 CD DC 2C 04 7446  X5:			CALL    COPY0
042C99 CD CF 2C 04 7447          		CALL    D2C
042C9D CD CF 2C 04 7448          		CALL    D2C
042CA1 08          7449          		EX      AF,AF'          ;SAVE CARRY
042CA2 D9          7450  ADD_:			EXX
042CA3 52 19       7451          		ADD.S   HL,DE
042CA5 D9          7452          		EXX
042CA6 52 ED 5A    7453          		ADC.S   HL,DE
042CA9 C9          7454          		RET
042CAA             7455  ;
042CAA             7456  ; SUB - Integer subtract.
042CAA             7457  ; Carry, sign & zero flags valid on exit
042CAA             7458  ;     Destroys: H,L,H',L',F
042CAA             7459  ;
042CAA D9          7460  SUB_:			EXX
042CAB B7          7461          		OR      A
042CAC 52 ED 52    7462          		SBC.S   HL,DE
042CAF D9          7463          		EXX
042CB0 52 ED 52    7464          		SBC.S   HL,DE
042CB3 C9          7465          		RET
042CB4             7466  ;
042CB4             7467  ; X10 - unsigned integer * 10
042CB4             7468  ;    Inputs: HLH'L' initial value
042CB4             7469  ;   Outputs: DED'E' = initial HLH'L'
042CB4             7470  ;            Carry bit set if overflow
042CB4             7471  ;            If carry not set HLH'L'=result
042CB4             7472  ;  Destroys: D,E,H,L,D',E',H',L',F
042CB4             7473  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042CB4             7474  ;     Carry set if MSB=1 before shift.
042CB4             7475  ;     Sign set if MSB=1 after shift.
042CB4             7476  ;     Destroys: H,L,H',L',F
042CB4             7477  ;
042CB4 CD DC 2C 04 7478  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CB8 CD C7 2C 04 7479          		CALL    X2
042CBC D8          7480          		RET     C               ;TOO BIG
042CBD CD C7 2C 04 7481          		CALL    X2
042CC1 D8          7482          		RET     C
042CC2 CD A2 2C 04 7483          		CALL    ADD_
042CC6 D8          7484          		RET     C
042CC7 D9          7485  X2:			EXX
042CC8 52 29       7486          		ADD.S   HL,HL
042CCA D9          7487          		EXX
042CCB 52 ED 6A    7488          		ADC.S   HL,HL
042CCE C9          7489          		RET
042CCF             7490  ;
042CCF             7491  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042CCF             7492  ;     Carry set if LSB=1 before shift.
042CCF             7493  ;     Destroys: H,L,H',L',F
042CCF             7494  ;
042CCF 0C          7495  D2C:			INC     C
042CD0 CB 3C       7496  D2:			SRL     H
042CD2 CB 1D       7497          		RR      L
042CD4 D9          7498          		EXX
042CD5 CB 1C       7499          		RR      H
042CD7 CB 1D       7500          		RR      L
042CD9 D9          7501          		EXX
042CDA C9          7502          		RET
042CDB             7503  ;
042CDB             7504  ; COPY - COPY HLH'L'C INTO DED'E'B
042CDB             7505  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CDB             7506  ;
042CDB 41          7507  COPY_:			LD      B,C
042CDC 54          7508  COPY0:			LD      D,H
042CDD 5D          7509          		LD      E,L
042CDE D9          7510          		EXX
042CDF 54          7511          		LD      D,H
042CE0 5D          7512          		LD      E,L
042CE1 D9          7513          		EXX
042CE2 C9          7514          		RET
042CE3             7515  ;
042CE3             7516  ; SQUARE - PUSH X*X
042CE3             7517  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CE3             7518  ;   Destroys: SP,IX
042CE3             7519  ;
042CE3 CD DB 2C 04 7520  SQUARE:			CALL    COPY_
042CE7 CD 46 23 04 7521          		CALL    FMUL
042CEB DD E1       7522  PUSH5:			POP     IX              ;RETURN ADDRESS
042CED C5          7523          		PUSH    BC
042CEE E5          7524          		PUSH    HL
042CEF D9          7525          		EXX
042CF0 E5          7526          		PUSH    HL
042CF1 D9          7527          		EXX
042CF2 DD E9       7528          		JP      (IX)            ;"RETURN"
042CF4             7529  ;
042CF4             7530  ; POP5 - POP DED'E'B OFF STACK.
042CF4             7531  ;   Destroys: A,B,D,E,D',E',SP,IX
042CF4             7532  ;
042CF4 DD E1       7533  POP5:			POP     IX              ;RETURN ADDRESS
042CF6 D9          7534          		EXX
042CF7 D1          7535          		POP     DE
042CF8 D9          7536          		EXX
042CF9 D1          7537          		POP     DE
042CFA 79          7538          		LD      A,C
042CFB C1          7539          		POP     BC
042CFC 41          7540          		LD      B,C
042CFD 4F          7541          		LD      C,A
042CFE DD E9       7542          		JP      (IX)            ;"RETURN"
042D00             7543  ;
042D00             7544  ; RATIO - Calculate (X-1)/(X+1)
042D00             7545  ;     Inputs: X in HLH'L'C
042D00             7546  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042D00             7547  ;   Destroys: Everything except IY,SP,I
042D00             7548  ;
042D00 CD EB 2C 04 7549  RATIO:			CALL    PUSH5           ;SAVE X
042D04 CD 73 26 04 7550          		CALL    DONE
042D08 CD 34 22 04 7551          		CALL    FADD
042D0C CD F4 2C 04 7552          		CALL    POP5            ;RESTORE X
042D10 CD EB 2C 04 7553          		CALL    PUSH5           ;SAVE X+1
042D14 CD 0F 2C 04 7554          		CALL    SWAP_FP
042D18 CD 73 26 04 7555          		CALL    DONE
042D1C CD 1B 22 04 7556          		CALL    FSUB
042D20 CD F4 2C 04 7557          		CALL    POP5            ;RESTORE X+1
042D24 C3 9D 22 04 7558          		JP      FDIV
042D28             7559  ;
042D28             7560  ; POLY - Evaluate a polynomial.
042D28             7561  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042D28             7562  ;             Polynomial coefficients follow call.
042D28             7563  ;    Outputs: Result in HLH'L'C
042D28             7564  ;   Destroys: Everything except IY,SP,I
042D28             7565  ; Routine terminates on finding a coefficient >=1.
042D28             7566  ; Note: The last coefficient is EXECUTED on return
042D28             7567  ;       so must contain only innocuous bytes!
042D28             7568  ;
042D28 DD 21 03 00 7569  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042D2D DD 39       7570          		ADD     IX, SP
042D2F DD E3       7571          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D31             7572  ;
042D31 CD 07 2A 04 7573          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042D35 CD 46 23 04 7574  POLY1:			CALL    FMUL
042D39 11 05 00 00 7575          		LD      DE, 5				; Skip to the next coefficient
042D3D DD 19       7576          		ADD     IX, DE
042D3F CD 07 2A 04 7577          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D43 DD E3       7578          		EX      (SP), IX			; Restore the SP just in case we need to return
042D45 04          7579          		INC     B
042D46 05          7580          		DEC     B               		; Test B for end byte (80h)
042D47 FA 34 22 04 7581          		JP      M,FADD				; Yes, so add and return
042D4B CD 34 22 04 7582          		CALL    FADD				; No, so add
042D4F CD 19 2A 04 7583          		CALL    DLOAD5_SPL			; Load X from SP
042D53 DD E3       7584          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D55 18 DE       7585          		JR      POLY1				; And loop
042D57             7586  ;
042D57             7587  ; POWR10 - Calculate power of ten.
042D57             7588  ;     Inputs: A=power of 10 required (A<128)
042D57             7589  ;             A=binary exponent to be exceeded (A>=128)
042D57             7590  ;    Outputs: DED'E'B = result
042D57             7591  ;             A = actual power of ten returned
042D57             7592  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D57             7593  ;
042D57 3C          7594  POWR10:			INC     A
042D58 08          7595          		EX      AF,AF'
042D59 E5          7596          		PUSH    HL
042D5A D9          7597          		EXX
042D5B E5          7598          		PUSH    HL
042D5C D9          7599          		EXX
042D5D CD 73 26 04 7600          		CALL    DONE
042D61 CD 0F 2C 04 7601          		CALL    SWAP_FP
042D65 AF          7602          		XOR     A
042D66 08          7603  POWR11:			EX      AF,AF'
042D67 3D          7604          		DEC     A
042D68 28 26       7605          		JR      Z,POWR14        ;EXIT TYPE 1
042D6A F2 72 2D 04 7606          		JP      P,POWR13
042D6E B9          7607          		CP      C
042D6F 38 1F       7608          		JR      C,POWR14        ;EXIT TYPE 2
042D71 3C          7609          		INC     A
042D72 08          7610  POWR13:			EX      AF,AF'
042D73 3C          7611          		INC     A
042D74 CB FC       7612          		SET     7,H
042D76 CD 95 2C 04 7613          		CALL    X5
042D7A 30 06       7614          		JR      NC,POWR12
042D7C 08          7615          		EX      AF,AF'
042D7D CD CF 2C 04 7616          		CALL    D2C
042D81 08          7617          		EX      AF,AF'
042D82 08          7618  POWR12:			EX      AF,AF'
042D83 DC F7 2B 04 7619          		CALL    C,ADD1_FP          ;ROUND UP
042D87 0C          7620          		INC     C
042D88 FA 66 2D 04 7621          		JP      M,POWR11
042D8C C3 26 2C 04 7622          		JP      OFLOW
042D90 CD 0F 2C 04 7623  POWR14:			CALL    SWAP_FP
042D94 CB BA       7624          		RES     7,D
042D96 D9          7625          		EXX
042D97 E1          7626          		POP     HL
042D98 D9          7627          		EXX
042D99 E1          7628          		POP     HL
042D9A 08          7629          		EX      AF,AF'
042D9B C9          7630          		RET
042D9C             7631  ;
042D9C             7632  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D9C             7633  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D9C             7634  ;               Remainder in H'L'HL
042D9C             7635  ;     Inputs: A = loop counter (normally -32)
042D9C             7636  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D9C             7637  ;
042D9C B7          7638  DIVA:			OR      A               ;CLEAR CARRY
042D9D             7639  DIV0:
042D9D 52 ED 42    7640  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DA0 D9          7641          		EXX
042DA1 52 ED 42    7642          		SBC.S   HL,BC
042DA4 D9          7643          		EXX
042DA5 30 07       7644          		JR      NC,DIV1
042DA7 52 09       7645          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA9 D9          7646          		EXX
042DAA 52 ED 4A    7647          		ADC.S   HL,BC
042DAD D9          7648          		EXX
042DAE 3F          7649  DIV1:			CCF
042DAF CB 13       7650  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DB1 CB 12       7651          		RL      D
042DB3 D9          7652          		EXX
042DB4 CB 13       7653          		RL      E
042DB6 CB 12       7654          		RL      D
042DB8 D9          7655          		EXX
042DB9 3C          7656          		INC     A
042DBA F0          7657          		RET     P
042DBB             7658  DIVB:
042DBB 52 ED 6A    7659  			ADC.S   HL,HL           ;DIVIDEND*2
042DBE D9          7660          		EXX
042DBF 52 ED 6A    7661          		ADC.S   HL,HL
042DC2 D9          7662          		EXX
042DC3 30 D8       7663          		JR      NC,DIV0
042DC5 B7          7664          		OR      A
042DC6 52 ED 42    7665          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DC9 D9          7666          		EXX
042DCA 52 ED 42    7667          		SBC.S   HL,BC
042DCD D9          7668          		EXX
042DCE 37          7669          		SCF
042DCF C3 AF 2D 04 7670          		JP      DIVC
042DD3             7671  ;
042DD3             7672  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042DD3             7673  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042DD3             7674  ;    Inputs: A = loop counter (usually -32)
042DD3             7675  ;            H'L'HL = 0
042DD3             7676  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042DD3             7677  ;
042DD3 B7          7678  MULA:			OR      A               ;CLEAR CARRY
042DD4 D9          7679  MUL0:			EXX
042DD5 CB 1A       7680          		RR      D               ;MULTIPLIER/2
042DD7 CB 1B       7681          		RR      E
042DD9 D9          7682          		EXX
042DDA CB 1A       7683          		RR      D
042DDC CB 1B       7684          		RR      E
042DDE 30 07       7685          		JR      NC,MUL1
042DE0 52 09       7686          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DE2 D9          7687          		EXX
042DE3 52 ED 4A    7688          		ADC.S   HL,BC
042DE6 D9          7689          		EXX
042DE7 3C          7690  MUL1:			INC     A
042DE8 F0          7691          		RET     P
042DE9 D9          7692  MULB:			EXX
042DEA CB 1C       7693          		RR      H               ;PRODUCT/2
042DEC CB 1D       7694          		RR      L
042DEE D9          7695          		EXX
042DEF CB 1C       7696          		RR      H
042DF1 CB 1D       7697          		RR      L
042DF3 C3 D4 2D 04 7698          		JP      MUL0
042DF7             7699  ;
042DF7             7700  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DF7             7701  ;     Function: B'C'BC = SQR (D'E'DE)
042DF7             7702  ;     Inputs: A = loop counter (normally -31)
042DF7             7703  ;             B'C'BCH'L'HL initialised to 0
042DF7             7704  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DF7             7705  ;
042DF7             7706  SQR1:
042DF7 52 ED 42    7707  			SBC.S   HL,BC
042DFA D9          7708          		EXX
042DFB 52 ED 42    7709          		SBC.S   HL,BC
042DFE D9          7710          		EXX
042DFF 0C          7711          		INC     C
042E00 30 09       7712          		JR      NC,SQR2
042E02 0D          7713          		DEC     C
042E03 52 09       7714          		ADD.S   HL,BC
042E05 D9          7715          		EXX
042E06 52 ED 4A    7716          		ADC.S   HL,BC
042E09 D9          7717          		EXX
042E0A 0D          7718          		DEC     C
042E0B 3C          7719  SQR2:			INC     A
042E0C F0          7720          		RET     P
042E0D CB 21       7721  SQRA:			SLA     C
042E0F CB 10       7722          		RL      B
042E11 D9          7723          		EXX
042E12 CB 11       7724          		RL      C
042E14 CB 10       7725          		RL      B
042E16 D9          7726          		EXX
042E17 0C          7727          		INC     C
042E18 CB 23       7728          		SLA     E
042E1A CB 12       7729          		RL      D
042E1C D9          7730          		EXX
042E1D CB 13       7731          		RL      E
042E1F CB 12       7732          		RL      D
042E21 D9          7733          		EXX
042E22 52 ED 6A    7734          		ADC.S   HL,HL
042E25 D9          7735          		EXX
042E26 52 ED 6A    7736          		ADC.S   HL,HL
042E29 D9          7737          		EXX
042E2A CB 23       7738          		SLA     E
042E2C CB 12       7739          		RL      D
042E2E D9          7740          		EXX
042E2F CB 13       7741          		RL      E
042E31 CB 12       7742          		RL      D
042E33 D9          7743          		EXX
042E34 52 ED 6A    7744          		ADC.S   HL,HL
042E37 D9          7745          		EXX
042E38 52 ED 6A    7746          		ADC.S   HL,HL
042E3B D9          7747          		EXX
042E3C D2 F7 2D 04 7748          		JP      NC,SQR1
042E40 B7          7749  SQR3:			OR      A
042E41 52 ED 42    7750          		SBC.S   HL,BC
042E44 D9          7751          		EXX
042E45 52 ED 42    7752          		SBC.S   HL,BC
042E48 D9          7753          		EXX
042E49 0C          7754          		INC     C
042E4A C3 0B 2E 04 7755          		JP      SQR2
042E4E             7756  ;
042E4E             7757  SQRB:
042E4E 52 29       7758  			ADD.S   HL,HL
042E50 D9          7759          		EXX
042E51 52 ED 6A    7760          		ADC.S   HL,HL
042E54 D9          7761          		EXX
042E55 38 E9       7762          		JR      C,SQR3
042E57 3C          7763          		INC     A
042E58 0C          7764          		INC     C
042E59 52 ED 42    7765          		SBC.S   HL,BC
042E5C D9          7766          		EXX
042E5D 52 ED 42    7767          		SBC.S   HL,BC
042E60 D9          7768          		EXX
042E61 D0          7769          		RET     NC
042E62 52 09       7770          		ADD.S   HL,BC
042E64 D9          7771          		EXX
042E65 52 ED 4A    7772          		ADC.S   HL,BC
042E68 D9          7773          		EXX
042E69 0D          7774          		DEC     C
042E6A C9          7775          		RET
042E6B             7776  ;
042E6B DD 7E 00    7777  DIGITQ:			LD      A,(IX)
042E6E FE 3A       7778          		CP      '9'+1
042E70 3F          7779          		CCF
042E71 D8          7780          		RET     C
042E72 FE 30       7781          		CP      '0'
042E74 C9          7782          		RET
042E75             7783  ;
042E75 DD 7E 00    7784  SIGNQ:			LD      A,(IX)
042E78 DD 23       7785          		INC     IX
042E7A FE 20       7786          		CP      ' '
042E7C 28 F7       7787          		JR      Z,SIGNQ
042E7E FE 2B       7788          		CP      '+'
042E80 C8          7789          		RET     Z
042E81 FE 2D       7790          		CP      '-'
042E83 C8          7791          		RET     Z
042E84 DD 2B       7792          		DEC     IX
042E86 C9          7793          		RET; --- End fpp.asm ---
042E87             7794  
042E87             7795  ; --- Begin gpio.asm ---
042E87             7796  ;
042E87             7797  ; Title:	BBC Basic for AGON - GPIO functions
042E87             7798  ; Author:	Dean Belfield
042E87             7799  ; Created:	12/05/2023
042E87             7800  ; Last Updated:	12/05/2023
042E87             7801  ;
042E87             7802  ; Modinfo:
042E87             7803  
042E87             7804  			; INCLUDE	"macros.inc"
042E87             7805  			; INCLUDE	"equs.inc"
042E87             7806  
042E87             7807  			; .ASSUME	ADL = 1
042E87             7808  
042E87             7809  			; SEGMENT CODE
042E87             7810  
042E87             7811  			; XDEF	GPIOB_SETMODE
042E87             7812  
042E87             7813  			; XREF	SWITCH_A
042E87             7814  
042E87             7815  ;  A: Mode
042E87             7816  ;  B: Pins
042E87             7817  ;
042E87 CD 4A 3E 04 7818  GPIOB_SETMODE:		CALL	SWITCH_A
042E8B 9F 2E       7819  			DW	GPIOB_M0	; Output
042E8D C4 2E       7820  			DW	GPIOB_M1	; Input
042E8F E4 2E       7821  			DW	GPIOB_M2	; Open Drain IO
042E91 04 2F       7822  			DW	GPIOB_M3	; Open Source IO
042E93 1F 2F       7823  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E95 4B 2F       7824  			DW	GPIOB_M5	; Alt Function
042E97 66 2F       7825  			DW	GPIOB_M6	; Interrupt, Active Low
042E99 8D 2F       7826  			DW	GPIOB_M7	; Interrupt, Active High
042E9B AF 2F       7827  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E9D D1 2F       7828  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E9F             7829  
042E9F             7830  ; Output
042E9F             7831  ;
042E9F             7832  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E9F C5          0001M 		PUSH	BC
042EA0 78          0002M 		LD	A, val
042EA1 2F          0003M 		CPL
042EA2 4F          0004M 		LD	C, A
042EA3 ED 38 9B    0005M 		IN0	A, (reg)
042EA6 A1          0006M 		AND	C
042EA7 ED 39 9B    0007M 		OUT0	(reg), A
042EAA C1          0008M 		POP	BC
042EAB             7833  			RES_GPIO PB_ALT1, B
042EAB C5          0001M 		PUSH	BC
042EAC 78          0002M 		LD	A, val
042EAD 2F          0003M 		CPL
042EAE 4F          0004M 		LD	C, A
042EAF ED 38 9C    0005M 		IN0	A, (reg)
042EB2 A1          0006M 		AND	C
042EB3 ED 39 9C    0007M 		OUT0	(reg), A
042EB6 C1          0008M 		POP	BC
042EB7             7834  			RES_GPIO PB_ALT2, B
042EB7 C5          0001M 		PUSH	BC
042EB8 78          0002M 		LD	A, val
042EB9 2F          0003M 		CPL
042EBA 4F          0004M 		LD	C, A
042EBB ED 38 9D    0005M 		IN0	A, (reg)
042EBE A1          0006M 		AND	C
042EBF ED 39 9D    0007M 		OUT0	(reg), A
042EC2 C1          0008M 		POP	BC
042EC3 C9          7835  			RET
042EC4             7836  
042EC4             7837  ; Input
042EC4             7838  ;
042EC4             7839  GPIOB_M1:		SET_GPIO PB_DDR,  B
042EC4 ED 38 9B    0001M 		IN0	A, (reg)
042EC7 B0          0002M 		OR	val
042EC8 ED 39 9B    0003M 		OUT0	(reg), A
042ECB             7840  			RES_GPIO PB_ALT1, B
042ECB C5          0001M 		PUSH	BC
042ECC 78          0002M 		LD	A, val
042ECD 2F          0003M 		CPL
042ECE 4F          0004M 		LD	C, A
042ECF ED 38 9C    0005M 		IN0	A, (reg)
042ED2 A1          0006M 		AND	C
042ED3 ED 39 9C    0007M 		OUT0	(reg), A
042ED6 C1          0008M 		POP	BC
042ED7             7841  			RES_GPIO PB_ALT2, B
042ED7 C5          0001M 		PUSH	BC
042ED8 78          0002M 		LD	A, val
042ED9 2F          0003M 		CPL
042EDA 4F          0004M 		LD	C, A
042EDB ED 38 9D    0005M 		IN0	A, (reg)
042EDE A1          0006M 		AND	C
042EDF ED 39 9D    0007M 		OUT0	(reg), A
042EE2 C1          0008M 		POP	BC
042EE3 C9          7842  			RET
042EE4             7843  
042EE4             7844  ; Open Drain IO
042EE4             7845  ;
042EE4             7846  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EE4 C5          0001M 		PUSH	BC
042EE5 78          0002M 		LD	A, val
042EE6 2F          0003M 		CPL
042EE7 4F          0004M 		LD	C, A
042EE8 ED 38 9B    0005M 		IN0	A, (reg)
042EEB A1          0006M 		AND	C
042EEC ED 39 9B    0007M 		OUT0	(reg), A
042EEF C1          0008M 		POP	BC
042EF0             7847  			SET_GPIO PB_ALT1, B
042EF0 ED 38 9C    0001M 		IN0	A, (reg)
042EF3 B0          0002M 		OR	val
042EF4 ED 39 9C    0003M 		OUT0	(reg), A
042EF7             7848  			RES_GPIO PB_ALT2, B
042EF7 C5          0001M 		PUSH	BC
042EF8 78          0002M 		LD	A, val
042EF9 2F          0003M 		CPL
042EFA 4F          0004M 		LD	C, A
042EFB ED 38 9D    0005M 		IN0	A, (reg)
042EFE A1          0006M 		AND	C
042EFF ED 39 9D    0007M 		OUT0	(reg), A
042F02 C1          0008M 		POP	BC
042F03 C9          7849  			RET
042F04             7850  
042F04             7851  ; Open Source IO
042F04             7852  ;
042F04             7853  GPIOB_M3:		SET_GPIO PB_DDR,  B
042F04 ED 38 9B    0001M 		IN0	A, (reg)
042F07 B0          0002M 		OR	val
042F08 ED 39 9B    0003M 		OUT0	(reg), A
042F0B             7854  			SET_GPIO PB_ALT1, B
042F0B ED 38 9C    0001M 		IN0	A, (reg)
042F0E B0          0002M 		OR	val
042F0F ED 39 9C    0003M 		OUT0	(reg), A
042F12             7855  			RES_GPIO PB_ALT2, B
042F12 C5          0001M 		PUSH	BC
042F13 78          0002M 		LD	A, val
042F14 2F          0003M 		CPL
042F15 4F          0004M 		LD	C, A
042F16 ED 38 9D    0005M 		IN0	A, (reg)
042F19 A1          0006M 		AND	C
042F1A ED 39 9D    0007M 		OUT0	(reg), A
042F1D C1          0008M 		POP	BC
042F1E C9          7856  			RET
042F1F             7857  
042F1F             7858  ; Interrupt, Dual Edge
042F1F             7859  ;
042F1F             7860  GPIOB_M4:		SET_GPIO PB_DR,   B
042F1F ED 38 9A    0001M 		IN0	A, (reg)
042F22 B0          0002M 		OR	val
042F23 ED 39 9A    0003M 		OUT0	(reg), A
042F26             7861  			RES_GPIO PB_DDR,  B
042F26 C5          0001M 		PUSH	BC
042F27 78          0002M 		LD	A, val
042F28 2F          0003M 		CPL
042F29 4F          0004M 		LD	C, A
042F2A ED 38 9B    0005M 		IN0	A, (reg)
042F2D A1          0006M 		AND	C
042F2E ED 39 9B    0007M 		OUT0	(reg), A
042F31 C1          0008M 		POP	BC
042F32             7862  			RES_GPIO PB_ALT1, B
042F32 C5          0001M 		PUSH	BC
042F33 78          0002M 		LD	A, val
042F34 2F          0003M 		CPL
042F35 4F          0004M 		LD	C, A
042F36 ED 38 9C    0005M 		IN0	A, (reg)
042F39 A1          0006M 		AND	C
042F3A ED 39 9C    0007M 		OUT0	(reg), A
042F3D C1          0008M 		POP	BC
042F3E             7863  			RES_GPIO PB_ALT2, B
042F3E C5          0001M 		PUSH	BC
042F3F 78          0002M 		LD	A, val
042F40 2F          0003M 		CPL
042F41 4F          0004M 		LD	C, A
042F42 ED 38 9D    0005M 		IN0	A, (reg)
042F45 A1          0006M 		AND	C
042F46 ED 39 9D    0007M 		OUT0	(reg), A
042F49 C1          0008M 		POP	BC
042F4A C9          7864  			RET
042F4B             7865  
042F4B             7866  ; Alt Function
042F4B             7867  ;
042F4B             7868  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F4B ED 38 9B    0001M 		IN0	A, (reg)
042F4E B0          0002M 		OR	val
042F4F ED 39 9B    0003M 		OUT0	(reg), A
042F52             7869  			RES_GPIO PB_ALT1, B
042F52 C5          0001M 		PUSH	BC
042F53 78          0002M 		LD	A, val
042F54 2F          0003M 		CPL
042F55 4F          0004M 		LD	C, A
042F56 ED 38 9C    0005M 		IN0	A, (reg)
042F59 A1          0006M 		AND	C
042F5A ED 39 9C    0007M 		OUT0	(reg), A
042F5D C1          0008M 		POP	BC
042F5E             7870  			SET_GPIO PB_ALT2, B
042F5E ED 38 9D    0001M 		IN0	A, (reg)
042F61 B0          0002M 		OR	val
042F62 ED 39 9D    0003M 		OUT0	(reg), A
042F65 C9          7871  			RET
042F66             7872  
042F66             7873  ; Interrupt, Active Low
042F66             7874  ;
042F66             7875  GPIOB_M6:		RES_GPIO PB_DR,   B
042F66 C5          0001M 		PUSH	BC
042F67 78          0002M 		LD	A, val
042F68 2F          0003M 		CPL
042F69 4F          0004M 		LD	C, A
042F6A ED 38 9A    0005M 		IN0	A, (reg)
042F6D A1          0006M 		AND	C
042F6E ED 39 9A    0007M 		OUT0	(reg), A
042F71 C1          0008M 		POP	BC
042F72             7876  			RES_GPIO PB_DDR,  B
042F72 C5          0001M 		PUSH	BC
042F73 78          0002M 		LD	A, val
042F74 2F          0003M 		CPL
042F75 4F          0004M 		LD	C, A
042F76 ED 38 9B    0005M 		IN0	A, (reg)
042F79 A1          0006M 		AND	C
042F7A ED 39 9B    0007M 		OUT0	(reg), A
042F7D C1          0008M 		POP	BC
042F7E             7877  			SET_GPIO PB_ALT1, B
042F7E ED 38 9C    0001M 		IN0	A, (reg)
042F81 B0          0002M 		OR	val
042F82 ED 39 9C    0003M 		OUT0	(reg), A
042F85             7878  			SET_GPIO PB_ALT2, B
042F85 ED 38 9D    0001M 		IN0	A, (reg)
042F88 B0          0002M 		OR	val
042F89 ED 39 9D    0003M 		OUT0	(reg), A
042F8C C9          7879  			RET
042F8D             7880  
042F8D             7881  
042F8D             7882  ; Interrupt, Active High
042F8D             7883  ;
042F8D             7884  GPIOB_M7:		SET_GPIO PB_DR,   B
042F8D ED 38 9A    0001M 		IN0	A, (reg)
042F90 B0          0002M 		OR	val
042F91 ED 39 9A    0003M 		OUT0	(reg), A
042F94             7885  			RES_GPIO PB_DDR,  B
042F94 C5          0001M 		PUSH	BC
042F95 78          0002M 		LD	A, val
042F96 2F          0003M 		CPL
042F97 4F          0004M 		LD	C, A
042F98 ED 38 9B    0005M 		IN0	A, (reg)
042F9B A1          0006M 		AND	C
042F9C ED 39 9B    0007M 		OUT0	(reg), A
042F9F C1          0008M 		POP	BC
042FA0             7886  			SET_GPIO PB_ALT1, B
042FA0 ED 38 9C    0001M 		IN0	A, (reg)
042FA3 B0          0002M 		OR	val
042FA4 ED 39 9C    0003M 		OUT0	(reg), A
042FA7             7887  			SET_GPIO PB_ALT2, B
042FA7 ED 38 9D    0001M 		IN0	A, (reg)
042FAA B0          0002M 		OR	val
042FAB ED 39 9D    0003M 		OUT0	(reg), A
042FAE C9          7888  			RET
042FAF             7889  
042FAF             7890  
042FAF             7891  ; Interrupt, Falling Edge
042FAF             7892  ;
042FAF             7893  GPIOB_M8:		RES_GPIO PB_DR,   B
042FAF C5          0001M 		PUSH	BC
042FB0 78          0002M 		LD	A, val
042FB1 2F          0003M 		CPL
042FB2 4F          0004M 		LD	C, A
042FB3 ED 38 9A    0005M 		IN0	A, (reg)
042FB6 A1          0006M 		AND	C
042FB7 ED 39 9A    0007M 		OUT0	(reg), A
042FBA C1          0008M 		POP	BC
042FBB             7894  			SET_GPIO PB_DDR,  B
042FBB ED 38 9B    0001M 		IN0	A, (reg)
042FBE B0          0002M 		OR	val
042FBF ED 39 9B    0003M 		OUT0	(reg), A
042FC2             7895  			SET_GPIO PB_ALT1, B
042FC2 ED 38 9C    0001M 		IN0	A, (reg)
042FC5 B0          0002M 		OR	val
042FC6 ED 39 9C    0003M 		OUT0	(reg), A
042FC9             7896  			SET_GPIO PB_ALT2, B
042FC9 ED 38 9D    0001M 		IN0	A, (reg)
042FCC B0          0002M 		OR	val
042FCD ED 39 9D    0003M 		OUT0	(reg), A
042FD0 C9          7897  			RET
042FD1             7898  
042FD1             7899  ; Interrupt, Rising Edge
042FD1             7900  ;
042FD1             7901  GPIOB_M9:		SET_GPIO PB_DR,   B
042FD1 ED 38 9A    0001M 		IN0	A, (reg)
042FD4 B0          0002M 		OR	val
042FD5 ED 39 9A    0003M 		OUT0	(reg), A
042FD8             7902  			SET_GPIO PB_DDR,  B
042FD8 ED 38 9B    0001M 		IN0	A, (reg)
042FDB B0          0002M 		OR	val
042FDC ED 39 9B    0003M 		OUT0	(reg), A
042FDF             7903  			SET_GPIO PB_ALT1, B
042FDF ED 38 9C    0001M 		IN0	A, (reg)
042FE2 B0          0002M 		OR	val
042FE3 ED 39 9C    0003M 		OUT0	(reg), A
042FE6             7904  			SET_GPIO PB_ALT2, B
042FE6 ED 38 9D    0001M 		IN0	A, (reg)
042FE9 B0          0002M 		OR	val
042FEA ED 39 9D    0003M 		OUT0	(reg), A
042FED C9          7905  			RET	; --- End gpio.asm ---
042FEE             7906  
042FEE             7907  ; --- Begin main.asm ---
042FEE             7908  ;
042FEE             7909  ; Title:	BBC Basic Interpreter - Z80 version
042FEE             7910  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FEE             7911  ; Author:	(C) Copyright  R.T.Russell  1984
042FEE             7912  ; Modified By:	Dean Belfield
042FEE             7913  ; Created:	12/05/2023
042FEE             7914  ; Last Updated:	26/11/2023
042FEE             7915  ;
042FEE             7916  ; Modinfo:
042FEE             7917  ; 07/05/1984:	Version 2.3
042FEE             7918  ; 01/03/1987:	Version 3.0
042FEE             7919  ; 03/05/2022:	Modified by Dean Belfield
042FEE             7920  ; 06/06/2023:	Modified to run in ADL mode
042FEE             7921  ; 26/06/2023:	Fixed binary and unary indirection
042FEE             7922  ; 17/08/2023:	Added binary constants
042FEE             7923  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FEE             7924  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FEE             7925  
042FEE             7926  			; .ASSUME	ADL = 1
042FEE             7927  
042FEE             7928  			; INCLUDE	"equs.inc"
042FEE             7929  
042FEE             7930  			; SEGMENT CODE
042FEE             7931  
042FEE             7932  			; XDEF	_main
042FEE             7933  
042FEE             7934  			; XDEF	COLD
042FEE             7935  			; XDEF	WARM
042FEE             7936  			; XDEF	CLOOP
042FEE             7937  			; XDEF	DELETE
042FEE             7938  			; XDEF	LIST_
042FEE             7939  			; XDEF	RENUM
042FEE             7940  			; XDEF	AUTO
042FEE             7941  			; XDEF	NEW
042FEE             7942  			; XDEF	OLD
042FEE             7943  			; XDEF	LOAD
042FEE             7944  			; XDEF	SAVE
042FEE             7945  			; XDEF	ERROR_
042FEE             7946  			; XDEF	EXTERR
042FEE             7947  			; XDEF	LOAD0
042FEE             7948  			; XDEF	CLEAR
042FEE             7949  			; XDEF	CRLF
042FEE             7950  			; XDEF	OUTCHR
042FEE             7951  			; XDEF	OUT_
042FEE             7952  			; XDEF	FINDL
042FEE             7953  			; XDEF	SETLIN
042FEE             7954  			; XDEF	PBCDL
042FEE             7955  			; XDEF	SAYLN
042FEE             7956  			; XDEF	PUTVAR
042FEE             7957  			; XDEF	GETVAR
042FEE             7958  			; XDEF	GETDEF
042FEE             7959  			; XDEF	CREATE
042FEE             7960  			; XDEF	RANGE
042FEE             7961  			; XDEF	LEXAN2
042FEE             7962  			; XDEF	REPORT
042FEE             7963  			; XDEF	TELL
042FEE             7964  			; XDEF	SPACE_
042FEE             7965  			; XDEF	KEYWDS
042FEE             7966  			; XDEF	KEYWDL
042FEE             7967  			; XDEF	ONEDIT
042FEE             7968  			; XDEF	ONEDIT1
042FEE             7969  			; XDEF	LISTIT
042FEE             7970  			; XDEF	CLEAN
042FEE             7971  
042FEE             7972  			; XREF	LISTON
042FEE             7973  			; XREF	ERRTXT
042FEE             7974  			; XREF	OSINIT
042FEE             7975  			; XREF	HIMEM
042FEE             7976  			; XREF	PAGE_
042FEE             7977  			; XREF	CHAIN0
042FEE             7978  			; XREF	PROMPT
042FEE             7979  			; XREF	ERRTRP
042FEE             7980  			; XREF	ERRLIN
042FEE             7981  			; XREF	AUTONO
042FEE             7982  			; XREF	LINENO
042FEE             7983  			; XREF	INCREM
042FEE             7984  			; XREF	OSLINE
042FEE             7985  			; XREF	COUNT
042FEE             7986  			; XREF	NXT
042FEE             7987  			; XREF	BUFFER
042FEE             7988  			; XREF	XEQ
042FEE             7989  			; XREF	TOP
042FEE             7990  			; XREF	EXPRI
042FEE             7991  			; XREF	SEARCH
042FEE             7992  			; XREF	LTRAP
042FEE             7993  			; XREF	LOMEM
042FEE             7994  			; XREF	DECODE
042FEE             7995  			; XREF	EXPRS
042FEE             7996  			; XREF	OSSAVE
042FEE             7997  			; XREF	ERR
042FEE             7998  			; XREF	ERL
042FEE             7999  			; XREF	TRACEN
042FEE             8000  			; XREF	RESET
042FEE             8001  			; XREF	OSSHUT
042FEE             8002  			; XREF	OSLOAD
042FEE             8003  			; XREF	FREE
042FEE             8004  			; XREF	DYNVAR
042FEE             8005  			; XREF	FILL
042FEE             8006  			; XREF	OSWRCH
042FEE             8007  			; XREF	WIDTH
042FEE             8008  			; XREF	COMMA
042FEE             8009  			; XREF	MUL16
042FEE             8010  			; XREF	BRAKET
042FEE             8011  			; XREF	X4OR5
042FEE             8012  			; XREF	LOADN
042FEE             8013  			; XREF	SFIX
042FEE             8014  			; XREF	ITEMI
042FEE             8015  			; XREF	FNPTR
042FEE             8016  			; XREF	PROPTR
042FEE             8017  			; XREF	CHECK
042FEE             8018  			; XREF	TERMQ
042FEE             8019  			; XREF	OSWRCHCH
042FEE             8020  			; XREF	NEWIT
042FEE             8021  			; XREF	BAD
042FEE             8022  			; XREF	RAM_START
042FEE             8023  			; XREF	RAM_END
042FEE             8024  			; XREF	R0
042FEE             8025  			; XREF	STAR_VERSION
042FEE             8026  
042FEE             8027  			; XREF	_end			; In init.asm
042FEE             8028  
042FEE             8029  ;
042FEE             8030  ; This defines the block of tokens that are pseudo-variables.
042FEE             8031  ; There are two versions of each token, a GET and a SET
042FEE             8032  
042FEE             8033  ; Name  : GET : SET
042FEE             8034  ; ------:-----:----
042FEE             8035  ; PTR   : 8Fh : CFh
042FEE             8036  ; PAGE  : 90h : D0h
042FEE             8037  ; TIME  : 91h : D1h
042FEE             8038  ; LOMEM : 92h : D2h
042FEE             8039  ; HIMEM : 93h : D3h
042FEE             8040  ;
042FEE             8041  ; Examples:
042FEE             8042  ;   LET A% = PAGE : REM This is the GET version
042FEE             8043  ;   PAGE = 40000  : REM This is the SET version
042FEE             8044  ;
042FEE             8045  ; TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FEE             8046  ; TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FEE             8047  ; OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FEE             8048  
042FEE             8049  ; The main routine
042FEE             8050  ; IXU: argv - pointer to array of parameters
042FEE             8051  ;   C: argc - number of parameters
042FEE             8052  ; Returns:
042FEE             8053  ;  HL: Error code, or 0 if OK
042FEE             8054  ;
042FEE 21 00 4A 04 8055  _main:			LD	HL, ACCS		; Clear the ACCS
042FF2 36 00       8056  			LD	(HL), 0
042FF4 79          8057  			LD	A, C
042FF5 FE 02       8058  			CP	2
042FF7 28 2D       8059  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF9 38 3F       8060  			JR	C, COLD			; 1 parameter = normal start
042FFB CD 9F 40 04 8061  			CALL	STAR_VERSION
042FFF CD E6 3D 04 8062  			CALL	TELL
043003 55 73 61 67 8063  			DB	"Usage:\n\r"
       65 3A 0A 0D 
04300B 52 55 4E 20 8064  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
04301E 21 00 00 00 8065  			LD	HL, 0			; The error code
043022 C3 68 00 04 8066  			JP	_end
043026             8067  ;
043026 DD 27 03    8068  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043029 11 00 4A 04 8069  			LD	DE, ACCS		;  DE: Destination address
04302D 7E          8070  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
04302E 12          8071  			LD	(DE), A			;
04302F 23          8072  			INC	HL			; Increase the source pointer
043030 1C          8073  			INC	E			; We only need to increase E as ACCS is on a page boundary
043031 28 03       8074  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
043033 B7          8075  			OR	A
043034 20 F7       8076  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043036 1D          8077  AUTOLOAD_2:		DEC	E
043037 3E 0D       8078  			LD	A, CR
043039 12          8079  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
04303A             8080  ;
04303A E1          8081  COLD:			POP	HL			; Pop the return address to init off SPS
04303B E5          8082  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04303C 21 00 4C 04 8083  			LD	HL, STAVAR		; Cold start
043040 F9          8084  			LD	SP, HL
043041 36 0A       8085  			LD	(HL), 10
043043 23          8086  			INC	HL
043044 36 09       8087  			LD	(HL),9
043046 CD D7 3F 04 8088  			CALL    OSINIT			; Call the machine specific OS initialisation routines
04304A ED 53 20 4D 8089  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
04304F 22 14 4D 04 8090  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043053 3E B7       8091  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043055 32 40 4D 04 8092  			LD      (LISTON),A
043059 21 B2 30 04 8093  			LD      HL,NOTICE
04305D 22 2F 4D 04 8094  			LD      (ERRTXT),HL
043061 CD C2 38 04 8095  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043065 3A 00 4A 04 8096  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043069 B7          8097  			OR	A
04306A C2 5B 0B 04 8098  			JP	NZ,CHAIN0		; Yes, so load and run
04306E CD 9F 40 04 8099  			CALL	STAR_VERSION		;
043072 CD E6 3D 04 8100  			CALL    TELL			; Output the welcome message
043076 42 42 43 20 8101  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
043094 45 5A 38 30 8102  			db      "EZ80ASM ADL Version 0.01beta\n\r"
       41 53 4D 20 
       41 44 4C 20 
       56 65 72 73 
       69 6F 6E 20 
       30 2E 30 31 
       62 65 74 61 
       0A 0D       
0430B2 28 43 29 20 8103  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0430D2 0A 0D 00    8104  			DB	"\n\r", 0
0430D5             8105  ;
0430D5 F6          8106  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0430D6             8107  ;
0430D6             8108  ; This is the main entry point for BASIC
0430D6             8109  ;
0430D6 37          8110  CLOOP:			SCF				; See above - not sure why this is here!
0430D7 ED 7B 20 4D 8111  			LD      SP,(HIMEM)
       04          
0430DC CD 50 3F 04 8112  			CALL    PROMPT          	; Prompt user
0430E0 21 40 4D 04 8113  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430E4 7E          8114  			LD      A,(HL)			; Fetch the value
0430E5 E6 0F       8115  			AND     0FH             	; Bottom nibble: LISTO
0430E7 F6 B0       8116  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430E9 77          8117  			LD      (HL),A			; Store back in
0430EA ED 62       8118  			SBC     HL,HL           	; HL: 0
0430EC 22 2C 4D 04 8119  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430F0 22 35 4D 04 8120  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430F4             8121  ;
0430F4 2A 29 4D 04 8122  			LD      HL,(AUTONO)		; Get the auto line number
0430F8 22 23 4D 04 8123  			LD      (LINENO),HL		; Store in line number
0430FC 7C          8124  			LD      A,H			; If the auto line number is zero then
0430FD B5          8125  			OR      L
0430FE 28 1E       8126  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
043100             8127  ;
043100             8128  ; This section handles auto line numbering
043100             8129  ;
043100 E5          8130  			PUSH    HL			; Stack the line number
043101 CD 51 3A 04 8131  			CALL    PBCD           	 	; Output the line number
043105 E1          8132  			POP     HL			; Pop the line number back off the stack
043106             8133  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
043106             8134  ;			LD      B,0			; So clear B
043106 01 00 00 00 8135  			LD	BC, 0			; Load BC with Increment
04310A 3A 41 4D 04 8136  			LD	A,(INCREM)
04310E 4F          8137  			LD	C, A
04310F 09          8138  			ADD     HL,BC			; Add the increment to the line number
043110 DA 7B 3C 04 8139  			JP      C,TOOBIG		; And error if we wrap
043114 22 29 4D 04 8140  			LD      (AUTONO),HL		; Store the new auto line number
043118 3E 20       8141  			LD      A,' '			; Print a space
04311A CD A5 39 04 8142  			CALL    OUTCHR
04311E             8143  ;
04311E             8144  ; This section invokes the line editor
04311E             8145  ;
04311E 21 00 4A 04 8146  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
043122 CD B5 3E 04 8147  			CALL    OSLINE          	; Call the line editor in MOS
043126 CD 32 31 04 8148  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
04312A DC 95 38 04 8149  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
04312E C3 D6 30 04 8150  			JP      CLOOP			; Jump back to immediate mode
043132             8151  ;
043132             8152  ; This bit enters the line into memory
043132             8153  ; Also called from OSLOAD_TXT
043132             8154  ; Returns:
043132             8155  ; F: C if a new line has been entered (CLEAN will need to be called)
043132             8156  ;
043132 AF          8157  ONEDIT1:		XOR     A			; Entry point after *EDIT
043133 32 3D 4D 04 8158  			LD      (COUNT),A
043137 FD 21 00 4A 8159  			LD      IY,ACCS
       04          
04313C CD 4F 3C 04 8160  			CALL    LINNUM			; HL: The line number from the input buffer
043140 CD 78 0A 04 8161  			CALL    NXT			; Skip spaces
043144 7C          8162  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043145 B5          8163  			OR      L
043146 28 04       8164  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043148 22 23 4D 04 8165  			LD      (LINENO),HL		; Otherwise store it
04314C             8166  ;
04314C             8167  ; This bit does the lexical analysis and tokenisation
04314C             8168  ;
04314C 0E 01       8169  LNZERO:			LD	C,1			; Left mode
04314E 11 00 4B 04 8170  			LD      DE,BUFFER		; Buffer for tokenised BASIC
043152 CD F5 3C 04 8171  			CALL    LEXAN2          	; Lexical analysis on the user input
043156 12          8172  			LD      (DE),A          	; Terminator
043157 AF          8173  			XOR     A
043158             8174  ;			LD      B,A
043158             8175  ;			LD      C,E             	; BC: Line length
043158 01 00 00 00 8176  			LD	BC,0
04315C 4B          8177  			LD	C,E			; BC: Line length
04315D 13          8178  			INC     DE
04315E 12          8179  			LD      (DE),A          	; Zero next
04315F 2A 23 4D 04 8180  			LD      HL,(LINENO)		; Get the line number
043163 7C          8181  			LD      A,H			; Is it zero, i.e. a command with no line number?
043164 B5          8182  			OR      L
043165 FD 21 00 4B 8183  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
04316A CA 9E 0B 04 8184  			JP      Z,XEQ           	; Execute it
04316E             8185  ;
04316E             8186  ; This section stores the BASIC line in memory
04316E             8187  ;
04316E C5          8188  			PUSH    BC
04316F E5          8189  			PUSH    HL
043170 CD A1 38 04 8190  			CALL    SETTOP          	; Set TOP sysvar
043174 E1          8191  			POP     HL
043175 CD E5 39 04 8192  			CALL    FINDL			; Find the address of the line
043179 CC 58 38 04 8193  			CALL    Z,DEL			; Delete the existing line if found
04317D C1          8194  			POP     BC
04317E 79          8195  			LD      A,C			; Check for the line length being zero, i.e.
04317F B7          8196  			OR      A			; the user has just entered a line number in the command line
043180 C8          8197  			RET	Z 	         	; If so, then don't do anything else
043181 C6 04       8198  			ADD     A,4
043183 4F          8199  			LD      C,A             	; Length inclusive
043184 D5          8200  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043185 C5          8201  			PUSH    BC              	; BC: Line length
043186 EB          8202  			EX      DE,HL			; DE: Address of the line in memory
043187 2A 17 4D 04 8203  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
04318B E5          8204  			PUSH    HL			; Stack TOP (current TOP value)
04318C 09          8205  			ADD     HL,BC			; Add the line length to HL, the new TOP value
04318D E5          8206  			PUSH    HL			; Stack HL (new TOP value)
04318E 24          8207  			INC     H			; Add 256 to HL
04318F AF          8208  			XOR     A
043190 ED 72       8209  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
043192 E1          8210  			POP     HL			; Pop HL (new TOP value)
043193 D2 B6 37 04 8211  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043197 22 17 4D 04 8212  			LD      (TOP),HL		; Store new value of TOP
04319B E3          8213  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
04319C E5          8214  			PUSH    HL			; PUSH current TOP value
04319D 23          8215  			INC     HL
04319E B7          8216  			OR      A
04319F ED 52       8217  			SBC     HL,DE			; DE: Address of the line in memory
0431A1 44          8218  			LD      B,H             	; BC: Amount to move
0431A2 4D          8219  			LD      C,L
0431A3 E1          8220  			POP     HL			; HL: Destination (current TOP value)
0431A4 D1          8221  			POP     DE			; DE: Source (new TOP value)
0431A5 28 02       8222  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0431A7 ED B8       8223  			LDDR                    	; Otherwise, make space for the new line in the program
0431A9 C1          8224  ATEND:			POP     BC              	; BC: Line length
0431AA D1          8225  			POP     DE              	; DE: Line number
0431AB 23          8226  			INC     HL			; HL: Destination address
0431AC 71          8227  			LD      (HL),C          	; Store length
0431AD 23          8228  			INC     HL
0431AE 73          8229  			LD      (HL),E          	; Store line number
0431AF 23          8230  			INC     HL
0431B0 72          8231  			LD      (HL),D
0431B1 23          8232  			INC     HL
0431B2 11 00 4B 04 8233  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0431B6 EB          8234  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0431B7 0D          8235  			DEC     C			; Subtract 3 from the number of bytes to copy to
0431B8 0D          8236  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0431B9 0D          8237  			DEC     C
0431BA ED B0       8238  			LDIR                    	; Add the line to the BASIC program
0431BC 37          8239  			SCF				; To flag we need to call CLEAN
0431BD C9          8240  			RET
0431BE             8241  ;
0431BE             8242  ; List of tokens and keywords. If a keyword is followed by 0 then
0431BE             8243  ; it will only match with the keyword followed immediately by
0431BE             8244  ; a delimiter
0431BE             8245  ;
0431BE 80 41 4E 44 8246  KEYWDS:			DB    80H, "AND"
0431C2 94 41 42 53 8247  			DB    94H, "ABS"
0431C6 95 41 43 53 8248  			DB    95H, "ACS"
0431CA 96 41 44 56 8249  			DB    96H, "ADVAL"
       41 4C       
0431D0 97 41 53 43 8250  			DB    97H, "ASC"
0431D4 98 41 53 4E 8251  			DB    98H, "ASN"
0431D8 99 41 54 4E 8252  			DB    99H, "ATN"
0431DC C6 41 55 54 8253  			DB    C6H, "AUTO"
       4F          
0431E1 9A 42 47 45 8254  			DB    9AH, "BGET", 0
       54 00       
0431E7 D5 42 50 55 8255  			DB    D5H, "BPUT", 0
       54 00       
0431ED FB 43 4F 4C 8256  			DB    FBH, "COLOUR"
       4F 55 52    
0431F4 FB 43 4F 4C 8257  			DB    FBH, "COLOR"
       4F 52       
0431FA D6 43 41 4C 8258  			DB    D6H, "CALL"
       4C          
0431FF D7 43 48 41 8259  			DB    D7H, "CHAIN"
       49 4E       
043205 BD 43 48 52 8260  			DB    BDH, "CHR$"
       24          
04320A D8 43 4C 45 8261  			DB    D8H, "CLEAR", 0
       41 52 00    
043211 D9 43 4C 4F 8262  			DB    D9H, "CLOSE", 0
       53 45 00    
043218 DA 43 4C 47 8263  			DB    DAH, "CLG", 0
       00          
04321D DB 43 4C 53 8264  			DB    DBH, "CLS", 0
       00          
043222 9B 43 4F 53 8265  			DB    9BH, "COS"
043226 9C 43 4F 55 8266  			DB    9CH, "COUNT", 0
       4E 54 00    
04322D DC 44 41 54 8267  			DB    DCH, "DATA"
       41          
043232 9D 44 45 47 8268  			DB    9DH, "DEG"
043236 DD 44 45 46 8269  			DB    DDH, "DEF"
04323A C7 44 45 4C 8270  			DB    C7H, "DELETE"
       45 54 45    
043241 81 44 49 56 8271  			DB    81H, "DIV"
043245 DE 44 49 4D 8272  			DB    DEH, "DIM"
043249 DF 44 52 41 8273  			DB    DFH, "DRAW"
       57          
04324E E1 45 4E 44 8274  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043257 E0 45 4E 44 8275  			DB    E0H, "END", 0
       00          
04325C E2 45 4E 56 8276  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
043265 8B 45 4C 53 8277  			DB    8BH, "ELSE"
       45          
04326A A0 45 56 41 8278  			DB    A0H, "EVAL"
       4C          
04326F 9E 45 52 4C 8279  			DB    9EH, "ERL", 0
       00          
043274 85 45 52 52 8280  			DB    85H, "ERROR"
       4F 52       
04327A C5 45 4F 46 8281  			DB    C5H, "EOF", 0
       00          
04327F 82 45 4F 52 8282  			DB    82H, "EOR"
043283 9F 45 52 52 8283  			DB    9FH, "ERR", 0
       00          
043288 A1 45 58 50 8284  			DB    A1H, "EXP"
04328C A2 45 58 54 8285  			DB    A2H, "EXT", 0
       00          
043291 E3 46 4F 52 8286  			DB    E3H, "FOR"
043295 A3 46 41 4C 8287  			DB    A3H, "FALSE", 0
       53 45 00    
04329C A4 46 4E    8288  			DB    A4H, "FN"
04329F E5 47 4F 54 8289  			DB    E5H, "GOTO"
       4F          
0432A4 BE 47 45 54 8290  			DB    BEH, "GET$"
       24          
0432A9 A5 47 45 54 8291  			DB    A5H, "GET"
0432AD E4 47 4F 53 8292  			DB    E4H, "GOSUB"
       55 42       
0432B3 E6 47 43 4F 8293  			DB    E6H, "GCOL"
       4C          
0432B8 93 48 49 4D 8294  			DB    93H, "HIMEM", 0
       45 4D 00    
0432BF E8 49 4E 50 8295  			DB    E8H, "INPUT"
       55 54       
0432C5 E7 49 46    8296  			DB    E7H, "IF"
0432C8 BF 49 4E 4B 8297  			DB    BFH, "INKEY$"
       45 59 24    
0432CF A6 49 4E 4B 8298  			DB    A6H, "INKEY"
       45 59       
0432D5 A8 49 4E 54 8299  			DB    A8H, "INT"
0432D9 A7 49 4E 53 8300  			DB    A7H, "INSTR("
       54 52 28    
0432E0 C9 4C 49 53 8301  			DB    C9H, "LIST"
       54          
0432E5 86 4C 49 4E 8302  			DB    86H, "LINE"
       45          
0432EA C8 4C 4F 41 8303  			DB    C8H, "LOAD"
       44          
0432EF 92 4C 4F 4D 8304  			DB    92H, "LOMEM", 0
       45 4D 00    
0432F6 EA 4C 4F 43 8305  			DB    EAH, "LOCAL"
       41 4C       
0432FC C0 4C 45 46 8306  			DB    C0H, "LEFT$("
       54 24 28    
043303 A9 4C 45 4E 8307  			DB    A9H, "LEN"
043307 E9 4C 45 54 8308  			DB    E9H, "LET"
04330B AB 4C 4F 47 8309  			DB    ABH, "LOG"
04330F AA 4C 4E    8310  			DB    AAH, "LN"
043312 C1 4D 49 44 8311  			DB    C1H, "MID$("
       24 28       
043318 EB 4D 4F 44 8312  			DB    EBH, "MODE"
       45          
04331D 83 4D 4F 44 8313  			DB    83H, "MOD"
043321 EC 4D 4F 56 8314  			DB    ECH, "MOVE"
       45          
043326 ED 4E 45 58 8315  			DB    EDH, "NEXT"
       54          
04332B CA 4E 45 57 8316  			DB    CAH, "NEW", 0
       00          
043330 AC 4E 4F 54 8317  			DB    ACH, "NOT"
043334 CB 4F 4C 44 8318  			DB    CBH, "OLD", 0
       00          
043339 EE 4F 4E    8319  			DB    EEH, "ON"
04333C 87 4F 46 46 8320  			DB    87H, "OFF"
043340 84 4F 52    8321  			DB    84H, "OR"
043343 8E 4F 50 45 8322  			DB    8EH, "OPENIN"
       4E 49 4E    
04334A AE 4F 50 45 8323  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
043352 AD 4F 50 45 8324  			DB    ADH, "OPENUP"
       4E 55 50    
043359 FF 4F 53 43 8325  			DB    FFH, "OSCLI"
       4C 49       
04335F F1 50 52 49 8326  			DB    F1H, "PRINT"
       4E 54       
043365 90 50 41 47 8327  			DB    90H, "PAGE", 0
       45 00       
04336B 8F 50 54 52 8328  			DB    8FH, "PTR", 0
       00          
043370 AF 50 49 00 8329  			DB    AFH, "PI", 0
043374 F0 50 4C 4F 8330  			DB    F0H, "PLOT"
       54          
043379 B0 50 4F 49 8331  			DB    B0H, "POINT("
       4E 54 28    
043380 F2 50 52 4F 8332  			DB    F2H, "PROC"
       43          
043385 B1 50 4F 53 8333  			DB    B1H, "POS", 0
       00          
04338A CE 50 55 54 8334  			DB    CEH, "PUT"
04338E F8 52 45 54 8335  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043396 F5 52 45 50 8336  			DB    F5H, "REPEAT"
       45 41 54    
04339D F6 52 45 50 8337  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0433A5 F3 52 45 41 8338  			DB    F3H, "READ"
       44          
0433AA F4 52 45 4D 8339  			DB    F4H, "REM"
0433AE F9 52 55 4E 8340  			DB    F9H, "RUN", 0
       00          
0433B3 B2 52 41 44 8341  			DB    B2H, "RAD"
0433B7 F7 52 45 53 8342  			DB    F7H, "RESTORE"
       54 4F 52 45 
0433BF C2 52 49 47 8343  			DB    C2H, "RIGHT$("
       48 54 24 28 
0433C7 B3 52 4E 44 8344  			DB    B3H, "RND", 0
       00          
0433CC CC 52 45 4E 8345  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0433D5 88 53 54 45 8346  			DB    88H, "STEP"
       50          
0433DA CD 53 41 56 8347  			DB    CDH, "SAVE"
       45          
0433DF B4 53 47 4E 8348  			DB    B4H, "SGN"
0433E3 B5 53 49 4E 8349  			DB    B5H, "SIN"
0433E7 B6 53 51 52 8350  			DB    B6H, "SQR"
0433EB 89 53 50 43 8351  			DB    89H, "SPC"
0433EF C3 53 54 52 8352  			DB    C3H, "STR$"
       24          
0433F4 C4 53 54 52 8353  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433FD D4 53 4F 55 8354  			DB    D4H, "SOUND"
       4E 44       
043403 FA 53 54 4F 8355  			DB    FAH, "STOP", 0
       50 00       
043409 B7 54 41 4E 8356  			DB    B7H, "TAN"
04340D 8C 54 48 45 8357  			DB    8CH, "THEN"
       4E          
043412 B8 54 4F    8358  			DB    B8H, "TO"
043415 8A 54 41 42 8359  			DB    8AH, "TAB("
       28          
04341A FC 54 52 41 8360  			DB    FCH, "TRACE"
       43 45       
043420 91 54 49 4D 8361  			DB    91H, "TIME", 0
       45 00       
043426 B9 54 52 55 8362  			DB    B9H, "TRUE", 0
       45 00       
04342C FD 55 4E 54 8363  			DB    FDH, "UNTIL"
       49 4C       
043432 BA 55 53 52 8364  			DB    BAH, "USR"
043436 EF 56 44 55 8365  			DB    EFH, "VDU"
04343A BB 56 41 4C 8366  			DB    BBH, "VAL"
04343E BC 56 50 4F 8367  			DB    BCH, "VPOS", 0
       53 00       
043444 FE 57 49 44 8368  			DB    FEH, "WIDTH"
       54 48       
04344A D3 48 49 4D 8369  			DB    D3H, "HIMEM"
       45 4D       
043450 D2 4C 4F 4D 8370  			DB    D2H, "LOMEM"
       45 4D       
043456 D0 50 41 47 8371  			DB    D0H, "PAGE"
       45          
04345B CF 50 54 52 8372  			DB    CFH, "PTR"
04345F D1 54 49 4D 8373  			DB    D1H, "TIME"
       45          
043464             8374  ;
043464             8375  ; These are indexed from the ERRWDS table
043464             8376  ;
043464 01 4D 69 73 8377  			DB    01H, "Missing "
       73 69 6E 67 
       20          
04346D 02 4E 6F 20 8378  			DB    02H, "No such "
       73 75 63 68 
       20          
043476 03 42 61 64 8379  			DB    03H, "Bad "
       20          
04347B 04 20 72 61 8380  			DB    04H, " range"
       6E 67 65    
043482 05 76 61 72 8381  			DB    05H, "variable"
       69 61 62 6C 
       65          
04348B 06 4F 75 74 8382  			DB    06H, "Out of"
       20 6F 66    
043492 07 4E 6F 20 8383  			DB    07H, "No "
043496 08 20 73 70 8384  			DB    08H, " space"
       61 63 65    
04349D             8385  
04349D             8386  KEYWDL:			EQU     $-KEYWDS
04349D FF FF       8387  			DW    -1
04349F             8388  ;
04349F             8389  ; Error messages
04349F             8390  ;
04349F 07 72 6F 6F 8391  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0434A5 06 04 00    8392  			DB    6, 4, 0			;  1: Out of range
0434A8 00          8393  			DB    0				;  2: *
0434A9 00          8394  			DB    0				;  3: *
0434AA 4D 69 73 74 8395  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0434B2 01 2C 00    8396  			DB    1, ",", 0			;  5: Missing ,
0434B5 54 79 70 65 8397  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0434C3 07 A4 00    8398  			DB    7, FN, 0			;  7: No FN
0434C6 00          8399  			DB    0				;  8: *
0434C7 01 22 00    8400  			DB    1, 34, 0			;  9: Missing "
0434CA 03 DE 00    8401  			DB    3, DIM, 0			; 10: Bad DIM
0434CD DE 08 00    8402  			DB    DIM, 8, 0			; 11: DIM space
0434D0 4E 6F 74 20 8403  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0434D6 07 F2 00    8404  			DB    7, PROC, 0		; 13: No PROC
0434D9 41 72 72 61 8405  			DB    "Array", 0		; 14: Array
       79 00       
0434DF 53 75 62 73 8406  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0434E9 53 79 6E 74 8407  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434F6 45 73 63 61 8408  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434FD 44 69 76 69 8409  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
04350E 53 74 72 69 8410  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
04351E 54 6F 6F 20 8411  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
043526 2D 76 65 20 8412  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
04352F 4C 6F 67 04 8413  			DB    "Log", 4, 0		; 22: Log range
       00          
043534 41 63 63 75 8414  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
043542 45 78 70 04 8415  			DB    "Exp", 4, 0		; 24: Exp range
       00          
043547 00          8416  			DB    0				; 25: *
043548 02 05 00    8417  			DB    2, 5, 0			; 26: No such variable
04354B 01 29 00    8418  			DB    1, ")", 0			; 27: Missing )
04354E 03 48 45 58 8419  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
043553 02 A4 2F F2 8420  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043558 03 63 61 6C 8421  			DB    3, "call", 0		; 30: Bad call
       6C 00       
04355E 41 72 67 75 8422  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043568 07 E3 00    8423  			DB    7, FOR, 0			; 32: No FOR
04356B 43 61 6E 27 8424  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043579 E3 20 05 00 8425  			DB    FOR, " ", 5, 0		; 34: FOR variable
04357D 00          8426  			DB    0				; 35: *
04357E 07 B8 00    8427  			DB    7, TO, 0			; 36: No TO
043581 00          8428  			DB    0				; 37: *
043582 07 E4 00    8429  			DB    7, GOSUB, 0		; 38: No GOSUB
043585 EE 20 73 79 8430  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
04358E EE 04 00    8431  			DB    ON_, 4, 0			; 40: ON range
043591 02 6C 69 6E 8432  			DB    2, "line", 0		; 41: No such line
       65 00       
043597 06 20 DC 00 8433  			DB    6, " ", DATA_, 0		; 42: Out of DATA
04359B 07 F5 00    8434  			DB    7, REPEAT, 0		; 43: No REPEAT
04359E 00          8435  			DB    0				; 44: *
04359F 01 23 00    8436  			DB    1, "#", 0			; 45: Missing #
0435A2             8437  ;
0435A2             8438  ; COMMANDS:
0435A2             8439  ;
0435A2             8440  ; DELETE line,line
0435A2             8441  ;
0435A2 CD A1 38 04 8442  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0435A6 CD A9 3C 04 8443  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435AA 7E          8444  DELET1:			LD      A,(HL)			; Check whether it's the last line
0435AB B7          8445  			OR      A
0435AC CA 33 36 04 8446  			JP      Z,WARMNC		; Yes, so do nothing
0435B0 23          8447  			INC     HL			; Skip the line length byte
0435B1 11 00 00 00 8448  			LD	DE, 0			; Clear DE
0435B5 5E          8449  			LD      E,(HL)			; Fetch the line number in DE
0435B6 23          8450  			INC     HL
0435B7 56          8451  			LD      D,(HL)
0435B8 7A          8452  			LD      A,D			; If the line number is zero then
0435B9 B3          8453  			OR      E
0435BA 28 1D       8454  			JR      Z,CLOOP1        	; Do nothing
0435BC 2B          8455  			DEC     HL			; Decrement BASIC program pointer back to length
0435BD 2B          8456  			DEC     HL
0435BE EB          8457  			EX      DE,HL			; Check if we've gone past the terminating line
0435BF 37          8458  			SCF
0435C0 ED 42       8459  			SBC     HL,BC
0435C2 EB          8460  			EX      DE,HL
0435C3 30 6E       8461  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0435C5 C5          8462  			PUSH    BC
0435C6 CD 58 38 04 8463  			CALL    DEL			; Delete the line pointed to by HL
0435CA C1          8464  			POP     BC
0435CB 18 DD       8465  			JR      DELET1			; And loop round to the next line
0435CD             8466  ;
0435CD             8467  ; LISTO expr
0435CD             8468  ;
0435CD FD 23       8469  LISTO:			INC     IY              	; Skip "O" byte
0435CF CD 0F 03 04 8470  			CALL    EXPRI			; Get expr
0435D3 D9          8471  			EXX
0435D4 7D          8472  			LD      A,L
0435D5 32 40 4D 04 8473  			LD      (LISTON),A		; Store in LISTON sysvar
0435D9 C3 D6 30 04 8474  CLOOP1:			JP      CLOOP
0435DD             8475  ;
0435DD             8476  ; LIST
0435DD             8477  ; LIST line
0435DD             8478  ; LIST line,line [IF string]
0435DD             8479  ; LIST ,line
0435DD             8480  ; LIST line,
0435DD             8481  ;
0435DD FE 4F       8482  LIST_:			CP      'O'			; Check for O (LISTO)
0435DF 28 EC       8483  			JR      Z,LISTO			; and jump to LISTO if zero
0435E1 CD A9 3C 04 8484  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435E5 CD 78 0A 04 8485  			CALL    NXT			; Skip space
0435E9 FE E7       8486  			CP      TIF             	; Check for IF clause (token IF)
0435EB 3E 00       8487  			LD      A,0             	; Initialise the IF clause string length
0435ED 20 17       8488  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435EF             8489  ;
0435EF FD 23       8490  			INC     IY              	; Skip the IF token
0435F1 CD 78 0A 04 8491  			CALL    NXT             	; And skip any spaces
0435F5 EB          8492  			EX      DE,HL			; DE: Address in memory
0435F6 FD E5       8493  			PUSH    IY			; LD IY, HL
0435F8 E1          8494  			POP     HL              	; HL is now the address of the tokenised line
0435F9 3E 0D       8495  			LD      A,CR
0435FB C5          8496  			PUSH    BC			; Stack the second line number arg
0435FC 01 00 01 00 8497  			LD      BC,256
043600 ED B1       8498  			CPIR                    	; Locate CR byte
043602 79          8499  			LD      A,C
043603 2F          8500  			CPL                    	 	; A: Substring length (of IF clause)
043604 C1          8501  			POP     BC			; Restore the second line number arg
043605 EB          8502  			EX      DE,HL			; HL: Address in memory
043606             8503  ;
043606 5F          8504  LISTB:			LD      E,A             	; E: IF clause string length
043607 78          8505  			LD      A,B			; Check whether a second line number was passed (BC!=0)
043608 B1          8506  			OR      C
043609 20 01       8507  			JR      NZ,LISTA		; If there isn't a second line number
04360B 0B          8508  			DEC     BC			; then we set it to the maximum of 65535
04360C             8509  ;
04360C D9          8510  LISTA:			EXX
04360D DD 21 40 4D 8511  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
043612 01 00 00 00 8512  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
043616 D9          8513  			EXX
043617 3E 14       8514  			LD      A,20			; Number of lines to list
043619             8515  ;
043619 C5          8516  LISTC:			PUSH    BC              	; Save second line number
04361A D5          8517  			PUSH    DE              	; Save IF clause length
04361B E5          8518  			PUSH    HL              	; Save BASIC program counter
04361C 08          8519  			EX      AF,AF'
04361D             8520  ;
04361D             8521  ; BBC BASIC for Z80 lines are stored as follows:
04361D             8522  ;
04361D             8523  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
04361D             8524  ; - [&00] [&FF] [&FF]: End of program marker
04361D             8525  ;
04361D             8526  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
04361D             8527  ;
04361D 7E          8528  			LD      A,(HL)			; Check for end of program marker
04361E B7          8529  			OR      A			; If found
04361F 28 12       8530  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
043621             8531  ;
043621             8532  ; Check if past terminating line number
043621             8533  ;
043621 7B          8534  			LD      A,E             	; A: IF clause length
043622 23          8535  			INC     HL			; Skip the length byte
043623 11 00 00 00 8536  			LD	DE,0			; Clear DE
043627 5E          8537  			LD      E,(HL)			; Fetch the line number in DE
043628 23          8538  			INC     HL
043629 56          8539  			LD      D,(HL)
04362A 2B          8540  			DEC     HL			; Step HL back to the length byte
04362B 2B          8541  			DEC     HL
04362C D5          8542  			PUSH    DE             	 	; Push the line number on the stack
04362D EB          8543  			EX      DE,HL			; HL: line number
04362E 37          8544  			SCF				; Do a 16-bit compare of HL and DE
04362F ED 42       8545  			SBC     HL,BC
043631 EB          8546  			EX      DE,HL
043632 D1          8547  			POP     DE              	; Restore the line number
043633 D2 D5 30 04 8548  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043637 4E          8549  			LD      C,(HL)          	; C: Line length + 4
043638 47          8550  			LD      B,A             	; B: IF clause length
043639             8551  ;
043639             8552  ; Check if "UNLISTABLE":
043639             8553  ;
043639 7A          8554  			LD      A,D			; TODO: What is "UNLISTABLE?"
04363A B3          8555  			OR      E
04363B CA D6 30 04 8556  			JP      Z,CLOOP
04363F             8557  ;
04363F             8558  ; Check for IF clause:
04363F             8559  ;
04363F 23          8560  			INC     HL			; Skip the length
043640 23          8561  			INC     HL			; Skip the line number
043641 23          8562  			INC     HL              	; HL: Address of the tokenised BASIC line
043642 0D          8563  			DEC     C			;  C: Line length
043643 0D          8564  			DEC     C
043644 0D          8565  			DEC     C
043645 0D          8566  			DEC     C
043646 D5          8567  			PUSH    DE              	; Save the line number
043647 E5          8568  			PUSH    HL              	; Save the BASIC program address
043648 AF          8569  			XOR     A               	;
043649 B8          8570  			CP      B              	 	; Check for an IF clause (B!=0)
04364A FD E5       8571  			PUSH    IY			; LD IY, DE
04364C D1          8572  			POP     DE              	; DE: Address of the IF clause string in the input buffer
04364D C4 8A 07 04 8573  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
043651 E1          8574  			POP     HL              	; Restore BASIC program address
043652 D1          8575  			POP     DE              	; Restore line number
043653 FD E5       8576  			PUSH    IY
043655 CC E8 38 04 8577  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043659 FD E1       8578  			POP     IY
04365B             8579  ;
04365B 08          8580  			EX      AF,AF'
04365C 3D          8581  			DEC     A			; Decrement line list counter
04365D CD C7 3F 04 8582  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043661 E1          8583  			POP     HL             	 	; Restore BASIC program address to beginning of line
043662 11 00 00 00 8584  			LD	DE,0
043666 5E          8585  			LD      E,(HL)			; Fetch the length of line in DE
043667 19          8586  			ADD     HL,DE           	; Go to the next line
043668 D1          8587  			POP     DE              	; Restore IF clause length
043669 C1          8588  			POP     BC              	; Restore second line number
04366A 18 AD       8589  			JR      LISTC			; Loop back to do next line
04366C             8590  ;
04366C             8591  ; RENUMBER
04366C             8592  ; RENUMBER start
04366C             8593  ; RENUMBER start,increment
04366C             8594  ; RENUMBER ,increment
04366C             8595  ;
04366C CD CC 38 04 8596  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
043670 CD 81 3C 04 8597  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
043674 D9          8598  			EXX
043675 2A 14 4D 04 8599  			LD      HL,(PAGE_)		; HL: Top of program
043679 ED 5B 1A 4D 8600  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
04367E             8601  ;
04367E             8602  ; Build the table
04367E             8603  ;
04367E 7E          8604  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
04367F B7          8605  			OR      A			; Is it zero, i.e. the end of program marker?
043680 28 36       8606  			JR      Z,RENUM2		; Yes, so skip to the next part
043682 23          8607  			INC     HL
043683 4E          8608  			LD      C,(HL)          	; BC: The OLD line number
043684 23          8609  			INC     HL
043685 46          8610  			LD      B,(HL)
043686 78          8611  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043687 B1          8612  			OR      C
043688 CA D6 30 04 8613  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
04368C EB          8614  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04368D 71          8615  			LD      (HL),C			; Store the OLD line number in the heap
04368E 23          8616  			INC     HL
04368F 70          8617  			LD      (HL),B
043690 23          8618  			INC     HL
043691 D9          8619  			EXX				; HL: line number, BC: increment (16-bit values)
043692 E5          8620  			PUSH    HL			; HL: Stack the NEW line number value
043693 52 09       8621  			ADD.S   HL,BC           	; Add the increment
043695 DA 7B 3C 04 8622  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043699 D9          8623  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
04369A C1          8624  			POP     BC			; BC: Pop the NEW line number value off the stack
04369B 71          8625  			LD      (HL),C			; Store the NEW line number in the heap
04369C 23          8626  			INC     HL
04369D 70          8627  			LD      (HL),B
04369E 23          8628  			INC     HL
04369F EB          8629  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436A0 2B          8630  			DEC     HL			; Back up to the line length byte
0436A1 2B          8631  			DEC     HL
0436A2 01 00 00 00 8632  			LD	BC, 0
0436A6 4E          8633  			LD      C,(HL)			; BC: Line length
0436A7 09          8634  			ADD	HL,BC           	; Advance HL to next line
0436A8 EB          8635  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0436A9 E5          8636  			PUSH    HL
0436AA 24          8637  			INC     H			; Increment to next page
0436AB ED 72       8638  			SBC     HL,SP			; Subtract from SP
0436AD E1          8639  			POP     HL
0436AE EB          8640  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436AF 38 CD       8641  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0436B1 CD CD 37 04 8642  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0436B5 CC          8643  			DB    	REN
0436B6 08          8644  			DB    	8
0436B7 00          8645  			DB    	0
0436B8             8646  ;
0436B8             8647  ; At this point a list of BASIC line numbers have been written to the heap
0436B8             8648  ; as word pairs:
0436B8             8649  ; - DW: The OLD line number
0436B8             8650  ; - DW: The NEW line number
0436B8             8651  ;
0436B8 EB          8652  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0436B9 36 FF       8653  			LD      (HL),-1			; Mark the end with FFFFh
0436BB 23          8654  			INC     HL
0436BC 36 FF       8655  			LD      (HL),-1
0436BE ED 5B 1A 4D 8656  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
0436C3 D9          8657  			EXX
0436C4 2A 14 4D 04 8658  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436C8 4E          8659  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436C9 79          8660  			LD      A,C			; If it is zero, then no program, so...
0436CA B7          8661  			OR      A
0436CB CA D5 30 04 8662  			JP      Z,WARM			; Jump to warm start
0436CF D9          8663  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436D0 EB          8664  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436D1 23          8665  			INC     HL			; Skip to the NEW line number
0436D2 23          8666  			INC     HL
0436D3 5E          8667  			LD      E,(HL)			; DE: The NEW line number
0436D4 23          8668  			INC     HL
0436D5 56          8669  			LD      D,(HL)
0436D6 23          8670  			INC     HL
0436D7 D5          8671  			PUSH    DE			; Stack the NEW line number
0436D8 EB          8672  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436D9 22 23 4D 04 8673  			LD      (LINENO),HL		; Store the line number in LINENO
0436DD D9          8674  			EXX				; HL: Pointer to the BASIC program area
0436DE D1          8675  			POP     DE			; DE: The NEW line number
0436DF 23          8676  			INC     HL
0436E0 73          8677  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436E1 23          8678  			INC     HL
0436E2 72          8679  			LD      (HL),D
0436E3 23          8680  			INC     HL
0436E4 0D          8681  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436E5 0D          8682  			DEC     C
0436E6 0D          8683  			DEC     C
0436E7 79          8684  			LD	A,C
0436E8 01 00 00 00 8685  			LD	BC,0
0436EC 4F          8686  			LD	C,A			; BC: Line length
0436ED             8687  ;
0436ED 3E 8D       8688  RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436EF ED B1       8689  			CPIR                    	; Search for the token
0436F1 20 D5       8690  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0436F3             8691  ;
0436F3             8692  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0436F3             8693  ;
0436F3 C5          8694  			PUSH    BC			; Stack everything
0436F4 E5          8695  			PUSH    HL
0436F5 E5          8696  			PUSH    HL			; HL: Pointer to encoded line number
0436F6 FD E1       8697  			POP     IY			; IY: Pointer to encoded line number
0436F8 D9          8698  			EXX
0436F9 CD EB 08 04 8699  			CALL    DECODE			; Decode the encoded line number (in HL')
0436FD D9          8700  			EXX				; HL: Decoded line number
0436FE 44          8701  			LD      B,H			; BC: Decoded line number
0436FF 4D          8702  			LD      C,L
043700 2A 1A 4D 04 8703  			LD      HL,(LOMEM)		; HL: Pointer to heap
043704             8704  ;
043704             8705  ; This section of code cross-references the decoded (OLD) line number with the list
043704             8706  ; created previously in the global heap
043704             8707  ;
043704 5E          8708  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
043705 23          8709  			INC     HL
043706 56          8710  			LD      D,(HL)
043707 23          8711  			INC     HL
043708 EB          8712  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
043709 B7          8713  			OR      A               	; Clear the carry and...
04370A 52 ED 42    8714  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
04370D EB          8715  			EX      DE,HL			; HL: Pointer in the global heap
04370E 5E          8716  			LD      E,(HL)          	; DE: The NEW line number
04370F 23          8717  			INC     HL
043710 56          8718  			LD      D,(HL)
043711 23          8719  			INC     HL
043712 38 F0       8720  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
043714 EB          8721  			EX      DE,HL			; DE: Pointer in the global heap
043715 28 1D       8722  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
043717             8723  ;
043717 CD E6 3D 04 8724  			CALL    TELL			; Display this error if the line number is not found
04371B 46 61 69 6C 8725  			DB    	"Failed at "
       65 64 20 61 
       74 20       
043725 00          8726  			DB    	0
043726 2A 23 4D 04 8727  			LD      HL,(LINENO)
04372A CD 4D 3A 04 8728  			CALL    PBCDL
04372E CD 9D 39 04 8729  			CALL    CRLF
043732 18 07       8730  			JR      RENUM6			; And carry on renumbering
043734             8731  ;
043734             8732  ; This snippet re-encodes the line number in the BASIC program
043734             8733  ;
043734 D1          8734  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
043735 D5          8735  			PUSH    DE
043736 1B          8736  			DEC     DE			; Back up a byte to the LINO token
043737 CD B2 3D 04 8737  			CALL    ENCODE          	; Re-write the new line number out
04373B E1          8738  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
04373C C1          8739  			POP     BC			; BC: The remaining line length
04373D 18 AE       8740  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
04373F             8741  ;
04373F             8742  ; AUTO
04373F             8743  ; AUTO start,increment
04373F             8744  ; AUTO start
04373F             8745  ; AUTO ,increment
04373F             8746  ;
04373F CD 81 3C 04 8747  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
043743 22 29 4D 04 8748  			LD      (AUTONO),HL		; Store the start in AUTONO
043747 79          8749  			LD      A,C			; Increment is 8 bit (0-255)
043748 32 41 4D 04 8750  			LD      (INCREM),A		; Store that in INCREM
04374C 18 2E       8751  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04374E             8752  ;
04374E             8753  ; BAD
04374E             8754  ; NEW
04374E             8755  ;
04374E CD E6 3D 04 8756  BAD:			CALL    TELL            	; Output "Bad program" error
043752 03          8757  			DB    3				; Token for "BAD"
043753 70 72 6F 67 8758  			DB    "program"
       72 61 6D    
04375A 0D          8759  			DB    CR
04375B 0A          8760  			DB    LF
04375C 00          8761  			DB    0				; Falls through to NEW
04375D             8762  ;
04375D CD C2 38 04 8763  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043761 18 19       8764  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043763             8765  ;
043763             8766  ; OLD
043763             8767  ;
043763 2A 14 4D 04 8768  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043767 E5          8769  			PUSH    HL			; Stack it
043768 23          8770  			INC     HL			; Skip the potential length byte of first line of code
043769 23          8771  			INC     HL			; And the line number word
04376A 23          8772  			INC     HL
04376B 01 FC 00 00 8773  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
04376F 3E 0D       8774  			LD      A,CR
043771 ED B1       8775  			CPIR
043773 20 D9       8776  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
043775 7D          8777  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043776 E1          8778  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043777 77          8779  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043778 CD 95 38 04 8780  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04377C C3 D6 30 04 8781  CLOOP0:			JP      CLOOP			; Jump back to the command loop
043780             8782  ;
043780             8783  ; LOAD filename
043780             8784  ;
043780 CD 1A 03 04 8785  LOAD:			CALL    EXPRS           	; Get the filename
043784 3E 0D       8786  			LD      A,CR			; DE points to the last byte of filename in ACCS
043786 12          8787  			LD      (DE),A			; Terminate filename with a CR
043787 CD 75 38 04 8788  			CALL    LOAD0			; Load the file in, then CLEAN
04378B CD CC 38 04 8789  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04378F 18 21       8790  			JR      WARM0			; Jump back to the command loop
043791             8791  ;
043791             8792  ; SAVE filename
043791             8793  ;
043791 CD A1 38 04 8794  SAVE:			CALL    SETTOP          	; Set TOP sysvar
043795 CD 1A 03 04 8795  			CALL    EXPRS           	; Get the filename
043799 3E 0D       8796  			LD      A,CR			; Terminate the filename with a CR
04379B 12          8797  			LD      (DE),A
04379C ED 5B 14 4D 8798  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
0437A1 2A 17 4D 04 8799  			LD      HL,(TOP)		; HL: Top of program memory
0437A5 B7          8800  			OR      A			; Calculate program size (TOP-PAGE)
0437A6 ED 52       8801  			SBC     HL,DE
0437A8 44          8802  			LD      B,H             	; BC: Length of program in bytes
0437A9 4D          8803  			LD      C,L
0437AA 21 00 4A 04 8804  			LD      HL,ACCS			; HL: Address of the filename
0437AE CD 94 42 04 8805  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0437B2 C3 D5 30 04 8806  WARM0:			JP      WARM			; Jump back to the command loop
0437B6             8807  
0437B6             8808  ;
0437B6             8809  ; ERROR
0437B6             8810  ; Called whenever BASIC needs to halt with an error
0437B6             8811  ; Error messages are indexed from 0
0437B6             8812  ; Inputs:
0437B6             8813  ;  A: Error number
0437B6             8814  ;
0437B6 ED 7B 20 4D 8815  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437BB 21 9F 34 04 8816  			LD      HL,ERRWDS		; Index into the error string table
0437BF B7          8817  			OR      A			; We don't need to search for the first error
0437C0 28 0A       8818  			JR      Z,ERROR1		; So skip the search routine
0437C2             8819  ;
0437C2             8820  ; Search the error table for error #A
0437C2             8821  ; HL will end up being the pointer into the correct error
0437C2             8822  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0437C2             8823  ;
0437C2 47          8824  			LD      B,A             	; Store error number in B
0437C3 08          8825  			EX      AF,AF'			; Store error number in AF'
0437C4 AF          8826  			XOR     A
0437C5 BE          8827  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437C6 23          8828  			INC     HL			; Increment the string pointer
0437C7 20 FC       8829  			JR      NZ,ERROR0		; Loop until with hit a 0
0437C9 10 FA       8830  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0437CB 08          8831  			EX      AF,AF'			; Restore the error number from AF'
0437CC             8832  ;
0437CC             8833  ; At this point HL points to the tokenised error string
0437CC             8834  ;
0437CC E5          8835  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0437CD             8836  
0437CD             8837  ;
0437CD             8838  ; EXTERR
0437CD             8839  ; Inputs:
0437CD             8840  ;  A: Error number
0437CD             8841  ;
0437CD             8842  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0437CD             8843  ; The error text immediately follows the CALL to EXTERR, for example:
0437CD             8844  ; > CALL  EXTERR
0437CD             8845  ; > DB    "Silly", 0
0437CD             8846  ; So we can get the address of the string by popping the return address off the stack
0437CD             8847  ;
0437CD E1          8848  EXTERR:			POP     HL			; Pop the error string pointer
0437CE 22 2F 4D 04 8849  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437D2 ED 7B 20 4D 8850  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437D7 32 3F 4D 04 8851  			LD      (ERR),A			; Store error number in ERR sysvar
0437DB CD 04 3A 04 8852  			CALL    SETLIN			; Get line number
0437DF 22 33 4D 04 8853  			LD      (ERL),HL		; Store in ERL sysvar
0437E3 B7          8854  			OR      A			; Is error number 0?
0437E4 28 0D       8855  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437E6             8856  ;
0437E6 2A 2C 4D 04 8857  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0437EA 7C          8858  			LD      A,H
0437EB B5          8859  			OR      L
0437EC E5          8860  			PUSH    HL			; HL: Error line
0437ED FD E1       8861  			POP     IY			; IY: HL
0437EF C2 9E 0B 04 8862  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437F3             8863  ;
0437F3 21 00 00 00 8864  ERROR2:			LD      HL,0
0437F7 22 29 4D 04 8865  			LD      (AUTONO),HL		; Cancel AUTO
0437FB 22 26 4D 04 8866  			LD      (TRACEN),HL     	; Cancel TRACE
0437FF CD 1D 44 04 8867  			CALL    RESET           	; Reset OPSYS
043803 CD 9D 39 04 8868  			CALL    CRLF			; Output newline
043807 CD D8 3D 04 8869  			CALL    REPORT          	; Output the error message
04380B CD 38 3A 04 8870  			CALL    SAYLN			; Output " at line nnnn" message.
04380F 1E 00       8871  			LD      E,0			; Close all files
043811 DC 92 43 04 8872  			CALL    C,OSSHUT
043815 CD 9D 39 04 8873  			CALL    CRLF			; Output newline
043819 C3 D6 30 04 8874  			JP      CLOOP			; Back to CLOOP
04381D             8875  ;
04381D             8876  ; SUBROUTINES:
04381D             8877  ;
04381D             8878  ; LEX - SEARCH FOR KEYWORDS
04381D             8879  ;   Inputs: HL = start of keyword table
04381D             8880  ;           IY = start of match text
04381D             8881  ;  Outputs: If found, Z-flag set, A=token.
04381D             8882  ;           If not found, Z-flag reset, A=(IY).
04381D             8883  ;           IY updated (if NZ, IY unchanged).
04381D             8884  ; Destroys: A,B,H,L,IY,F
04381D             8885  ;
04381D 21 BE 31 04 8886  LEX:			LD      HL,KEYWDS		; Address of the keywords table
043821             8887  ;
043821 FD 7E 00    8888  LEX0:			LD      A,(IY)			; Fetch the character to match
043824 46          8889  			LD      B,(HL)			; B: The token from the keywords table
043825 23          8890  			INC     HL			; Increment the pointer in the keywords table
043826 BE          8891  			CP      (HL)			; Compare the first characters
043827 28 08       8892  			JR      Z,LEX2			; If there is a match, then skip to LEX2
043829 D8          8893  			RET     C               	; No match, so fail
04382A             8894  ;
04382A             8895  ; This snippet of code skips to the next token in the KEYWDS table
04382A             8896  ;
04382A 23          8897  LEX1:			INC     HL			; Increment the pointer
04382B CB 7E       8898  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
04382D 28 FB       8899  			JR      Z,LEX1			; No, so loop
04382F 18 F0       8900  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
043831             8901  ;
043831 FD E5       8902  LEX2:			PUSH    IY              	; Save the input pointer
043833 23          8903  LEX3:			INC     HL			; Increment the keyword pointer
043834 CB 7E       8904  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043836 20 1C       8905  			JR      NZ,LEX6         	; Jump to here as we've found a token
043838 FD 23       8906  			INC     IY			; Increment the text pointer
04383A FD 7E 00    8907  			LD      A,(IY)			; Fetch the character
04383D FE 2E       8908  			CP      '.'			; Is it an abbreviated keyword?
04383F 28 13       8909  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
043841 BE          8910  			CP      (HL)			; Compare with the keywords list
043842 28 EF       8911  			JR      Z,LEX3			; It's a match, so continue checking this keyword
043844 CD D1 3C 04 8912  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043848 38 04       8913  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
04384A             8914  ;
04384A FD E1       8915  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
04384C 18 DC       8916  			JR      LEX1			; And loop back to start again
04384E             8917  ;
04384E             8918  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
04384E             8919  ; immediately delimited
04384E             8920  ;
04384E 7E          8921  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
04384F B7          8922  			OR      A			; If it is not zero, then...
043850 20 F8       8923  			JR      NZ,LEX4			; Keep searching
043852 FD 2B       8924  			DEC     IY			; If it is zero, then skip the input pointer back one byte
043854             8925  ;
043854             8926  ; We've found a token at this point
043854             8927  ;
043854 F1          8928  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
043855 AF          8929  			XOR     A			; Set the Z flag
043856 78          8930  			LD      A,B			; A: The token
043857 C9          8931  			RET
043858             8932  ;
043858             8933  ; DEL - DELETE A PROGRAM LINE.
043858             8934  ;   Inputs: HL addresses program line.
043858             8935  ; Destroys: B,C,F
043858             8936  ;
043858             8937  ; This simply erases the line by moving all of the code after the line to be deleted back over
043858             8938  ; it using an LDIR
043858             8939  ;
043858 D5          8940  DEL:			PUSH    DE
043859 E5          8941  			PUSH    HL
04385A E5          8942  			PUSH    HL			; HL: Address of the program line
04385B 06 00       8943  			LD      B,0			; BC: Length of the line
04385D 4E          8944  			LD      C,(HL)
04385E 09          8945  			ADD     HL,BC			; HL: Advanced to the start of the next line
04385F E5          8946  			PUSH    HL
043860 EB          8947  			EX      DE,HL			; DE: Pointer to the next line
043861 2A 17 4D 04 8948  			LD      HL,(TOP)		; HL: Pointer to the end of the program
043865 ED 52       8949  			SBC     HL,DE
043867 44          8950  			LD      B,H			; BC: Size of block to move
043868 4D          8951  			LD      C,L
043869 E1          8952  			POP     HL			; HL: Pointer to next line
04386A D1          8953  			POP     DE			; DE: Pointer to this line
04386B ED B0       8954  			LDIR                    	; Delete the line
04386D ED 53 17 4D 8955  			LD      (TOP),DE		; Adjust TOP
       04          
043872 E1          8956  			POP     HL
043873 D1          8957  			POP     DE
043874 C9          8958  			RET
043875             8959  ;
043875             8960  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
043875             8961  ;   Inputs: Filename in ACCS (term CR)
043875             8962  ; Destroys: A,B,C,D,E,H,L,F
043875             8963  ;
043875             8964  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
043875             8965  ; AND WRITE FF FF, THEN LOAD (TOP).
043875             8966  ; Destroys: A,B,C,H,L,F
043875             8967  ;
043875 ED 5B 14 4D 8968  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
04387A 21 00 FF FF 8969  			LD      HL,-256
04387E 39          8970  			ADD     HL,SP
04387F ED 52       8971  			SBC     HL,DE           	; Find available space
043881 44          8972  			LD      B,H
043882 4D          8973  			LD      C,L
043883 21 00 4A 04 8974  			LD      HL,ACCS
043887 CD FB 41 04 8975  			CALL    OSLOAD          	; Call the OSLOAD function in patch
04388B D4 C2 38 04 8976  			CALL    NC,NEWIT		; If NC then NEW
04388F 3E 00       8977  			LD      A,0
043891 D2 B6 37 04 8978  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
043895             8979  ;
043895 CD A1 38 04 8980  CLEAN:			CALL    SETTOP			; Set TOP sysvar
043899 2B          8981  			DEC     HL			; Write out the end of program markers
04389A 36 FF       8982  			LD      (HL),-1
04389C 2B          8983  			DEC     HL
04389D 36 FF       8984  			LD      (HL),-1
04389F 18 2B       8985  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0438A1             8986  ;
0438A1             8987  ; Set the TOP sysvar; the first free location after the end of the current program
0438A1             8988  ; Returns:
0438A1             8989  ; - HL: TOP
0438A1             8990  ;
0438A1 2A 14 4D 04 8991  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0438A5 01 00 00 00 8992  			LD	BC, 0			; BC: 0
0438A9 3E 0D       8993  			LD      A,CR			; End of line marker
0438AB 4E          8994  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0438AC 0C          8995  			INC     C			; Check for zero
0438AD 0D          8996  			DEC     C
0438AE 28 0A       8997  			JR      Z,SETOP2		; If it is zero, we've reached the end
0438B0 09          8998  			ADD     HL,BC			; Skip to next line
0438B1 2B          8999  			DEC     HL			; Check end of previous line
0438B2 BE          9000  			CP      (HL)
0438B3 23          9001  			INC     HL
0438B4 28 F5       9002  			JR      Z,SETOP1		; If CR then loop
0438B6 C3 4E 37 04 9003  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0438BA             9004  ;
0438BA 23          9005  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0438BB 23          9006  			INC     HL			; NB: Called from NEWIT
0438BC 23          9007  			INC     HL
0438BD 22 17 4D 04 9008  			LD      (TOP),HL		; Store in TOP sysvar
0438C1 C9          9009  			RET
0438C2             9010  ;
0438C2             9011  ; NEWIT - NEW PROGRAM THEN CLEAR
0438C2             9012  ;   Destroys: H,L
0438C2             9013  ;
0438C2             9014  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0438C2             9015  ; FUNCTION AND PROCEDURE POINTERS.
0438C2             9016  ;   Destroys: Nothing
0438C2             9017  ;
0438C2 2A 14 4D 04 9018  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438C6 36 00       9019  			LD      (HL),0			; Stick a 0 in there
0438C8 CD BA 38 04 9020  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438CC             9021  ;
0438CC E5          9022  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438CD 2A 17 4D 04 9023  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438D1 22 1A 4D 04 9024  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0438D5 22 1D 4D 04 9025  			LD      (FREE),HL		; And the FREE sysvar with that value
0438D9 21 6C 4C 04 9026  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438DD C5          9027  			PUSH    BC
0438DE             9028  			; LD      B,3*(54+2)		; Loop counter
0438DE 06 A8       9029  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438E0 36 00       9030  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438E2 23          9031  			INC     HL
0438E3 10 FB       9032  			DJNZ    CLEAR1
0438E5 C1          9033  			POP     BC
0438E6 E1          9034  			POP     HL			; Restore the BASIC program pointer
0438E7 C9          9035  			RET
0438E8             9036  ;
0438E8             9037  ;LISTIT - LIST A PROGRAM LINE.
0438E8             9038  ;    Inputs: HL addresses line
0438E8             9039  ;            DE = line number (binary)
0438E8             9040  ;            IX = Pointer to LISTON
0438E8             9041  ;             B = FOR/NEXT indent level
0438E8             9042  ;             C = REPEAT/UNTIL indent level
0438E8             9043  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0438E8             9044  ;
0438E8 E5          9045  LISTIT:			PUSH    HL			; Stack the address of the line
0438E9 EB          9046  			EX      DE,HL			; HL: Line number
0438EA C5          9047  			PUSH    BC
0438EB CD 51 3A 04 9048  			CALL    PBCD			; Print the line number
0438EF C1          9049  			POP     BC
0438F0 E1          9050  			POP     HL			; HL: Address of the first token/character
0438F1 7E          9051  			LD      A,(HL)			; Fetch the token
0438F2 FE ED       9052  			CP      NEXT			; Is it NEXT...
0438F4 CC 7E 39 04 9053  			CALL    Z,INDENT		; Yes, so indent in
0438F8 FE FD       9054  			CP      UNTIL			; Or is it UNTIL...
0438FA CC 7E 39 04 9055  			CALL    Z,INDENT		; Yes, so indent in
0438FE D9          9056  			EXX
0438FF 3E 20       9057  			LD      A,' '
043901 DD CB 00 46 9058  			BIT     0,(IX)			; If BIT 0 of LISTON is set
043905 C4 A5 39 04 9059  			CALL    NZ,OUTCHR		; Then print a space after the line number
043909 78          9060  			LD      A,B			; Fetch the FOR/NEXT indent level
04390A 87          9061  			ADD     A,A			; Multiply by 2
04390B DD CB 00 4E 9062  			BIT     1,(IX)			; If BIT 1 of LISTON is set
04390F C4 21 18 04 9063  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
043913 79          9064  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
043914 87          9065  			ADD     A,A			; Multiply by 2
043915 DD CB 00 56 9066  			BIT     2,(IX)			; If BIT 2 of LISTON is set
043919 C4 21 18 04 9067  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
04391D D9          9068  			EXX
04391E 7E          9069  			LD      A,(HL)			; Fetch the token
04391F FE E3       9070  			CP      FOR			; Is it FOR?
043921 CC 7E 39 04 9071  			CALL    Z,INDENT		; Yes, so indent
043925 FE F5       9072  			CP      REPEAT			; Is it REPEAT?
043927 CC 7E 39 04 9073  			CALL    Z,INDENT		; Yes, so indent
04392B 1E 00       9074  			LD      E,0			; E: The quote counter - reset to 0
04392D 7E          9075  LIST8:			LD      A,(HL)			; Fetch a character / token byte
04392E 23          9076  			INC     HL
04392F FE 0D       9077  			CP      CR			; Is it end of line?
043931 28 0B       9078  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
043933 FE 22       9079  			CP      34			; Is it a quote character?
043935 20 01       9080  			JR      NZ,LIST7		; No, so skip to next bit
043937 1C          9081  			INC     E			; Otherwise increment quote counter
043938 CD 6D 39 04 9082  LIST7:			CALL    LOUT			; Output the character / token
04393C 18 EF       9083  			JR      LIST8			; And repeat
04393E             9084  ;
04393E             9085  ; DB: Modification for *EDIT
04393E             9086  ; Terminate the line with either a CRLF or a NUL character
04393E             9087  ;
04393E DD CB 00 5E 9088  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
043942 28 59       9089  			JR	Z, CRLF			; Yes, so print a CRLF
043944 AF          9090  			XOR	A			; Otherwise print a NUL (0)
043945 C3 56 3F 04 9091  			JP	OSWRCH
043949             9092  ;
043949             9093  ; Decode the 3 byte GOTO type line number
043949             9094  ;
043949 E5          9095  PRLINO:			PUSH    HL			; Swap HL and IY
04394A FD E1       9096  			POP     IY			; IY: Pointer to the line number
04394C C5          9097  			PUSH    BC
04394D CD EB 08 04 9098  			CALL    DECODE			; Decode
043951 C1          9099  			POP     BC
043952 D9          9100  			EXX
043953 C5          9101  			PUSH    BC
043954 CD 4D 3A 04 9102  			CALL    PBCDL			; Output the line number
043958 C1          9103  			POP     BC
043959 D9          9104  			EXX
04395A FD E5       9105  			PUSH    IY			; Swap HL and IY
04395C E1          9106  			POP     HL			; HL: Pointer to the next character in the line
04395D C9          9107  			RET
04395E             9108  ;
04395E             9109  ; DB: Modification for internationalisation
04395E             9110  ;
04395E CD C2 39 04 9111  PRREM:			CALL	OUT_			; Output the REM token
043962 7E          9112  @@:			LD	A, (HL)			; Fetch the character
043963 FE 0D       9113  			CP	CR			; If it is end of line, then
043965 C8          9114  			RET	Z			; we have finished
043966 CD A5 39 04 9115  			CALL	OUTCHR			; Ouput the character
04396A 23          9116  			INC	HL
04396B 18 F5       9117  			JR	@B			; And loop
04396D             9118  ;
04396D             9119  ; DB: End of modification
04396D             9120  ;
04396D CB 43       9121  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
04396F 20 34       9122  			JR      NZ,OUTCHR		; don't tokenise, just output the character
043971 FE F4       9123  			CP	REM			; DB: Is it REM
043973 28 E9       9124  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
043975 FE 8D       9125  			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
043977 28 D0       9126  			JR      Z,PRLINO		; Yes, so decode and print the line number
043979 CD C2 39 04 9127  			CALL    OUT_			; Output a character / keyword
04397D 7E          9128  			LD      A,(HL)			; Fetch the next character
04397E             9129  ;
04397E             9130  ; This block of code handles the indentation
04397E             9131  ; B: Counter for FOR/NEXT indent
04397E             9132  ; C: Counter for REPEAT/UNTIL indent
04397E             9133  ;
04397E D9          9134  INDENT:			EXX
04397F FE E3       9135  			CP      FOR			; If the token is FOR
043981 28 09       9136  			JR      Z,IND1			; Then INC B
043983 FE ED       9137  			CP      NEXT			; If it is NEXT
043985 20 06       9138  			JR      NZ,IND2_		; Then...
043987 05          9139  			DEC     B			; DEC B
043988 F2 8D 39 04 9140  			JP      P,IND2_			; If we have gone below 0 then
04398C 04          9141  IND1:			INC     B			; Increment back to 0
04398D             9142  ;
04398D FE F5       9143  IND2_:			CP      REPEAT			; If the token is REPEAT
04398F 28 09       9144  			JR      Z,IND3			; Then INC C
043991 FE FD       9145  			CP      UNTIL			; If it is UNTIL
043993 20 06       9146  			JR      NZ,IND4			; Then...
043995 0D          9147  			DEC     C			; DEC C
043996 F2 9B 39 04 9148  			JP      P,IND4			; If we have gone below 0 then
04399A 0C          9149  IND3:			INC     C			; Incremet back to 0
04399B D9          9150  IND4:			EXX
04399C C9          9151  			RET
04399D             9152  ;
04399D             9153  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
04399D             9154  ;  Destroys: A,F
04399D             9155  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
04399D             9156  ;    Inputs: A = character
04399D             9157  ;  Destroys: A,F
04399D             9158  ;
04399D 3E 0D       9159  CRLF:			LD      A,CR			; Output CR
04399F CD A5 39 04 9160  			CALL    OUTCHR
0439A3 3E 0A       9161  			LD      A,LF			; Output LF
0439A5             9162  ;
0439A5 CD 56 3F 04 9163  OUTCHR:			CALL    OSWRCH			; Output the character in A
0439A9 D6 0D       9164  			SUB     CR			; Check for CR
0439AB 28 06       9165  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0439AD D8          9166  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0439AE 3A 3D 4D 04 9167  			LD      A,(COUNT)		; Increment the count
0439B2 3C          9168  			INC     A
0439B3             9169  ;
0439B3 32 3D 4D 04 9170  CARRET:			LD      (COUNT),A		; Store the new count value
0439B7 C8          9171  			RET     Z			; Return if the count has wrapped to 0
0439B8 E5          9172  			PUSH    HL			; Now check if count = print width
0439B9 2A 3E 4D 04 9173  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0439BD BD          9174  			CP      L			; L is the width. Compare it with count.
0439BE E1          9175  			POP     HL
0439BF C0          9176  			RET     NZ			; If we've not hit print width, then just return
0439C0 18 DB       9177  			JR      CRLF			; Otherwise output CRLF
0439C2             9178  ;
0439C2             9179  ; OUT - SEND CHARACTER OR KEYWORD
0439C2             9180  ;   Inputs: A = character (>=10, <128)
0439C2             9181  ;           A = Token (<10, >=128)
0439C2             9182  ;  Destroys: A,F
0439C2             9183  ;
0439C2 FE 8A       9184  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0439C4 EA A5 39 04 9185  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439C8             9186  ;
0439C8             9187  ; This bit looks up the character in the KEYWDS token table and expands it
0439C8             9188  ; Note the CP 138; this sets the overflow flag as follows:
0439C8             9189  ;
0439C8             9190  ; NB:
0439C8             9191  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0439C8             9192  ;  2. CP is effectively a SUB; sets the flags without affecting A
0439C8             9193  ;  3. The operation n - -118 ~ n + 118
0439C8             9194  ;
0439C8             9195  ; So:
0439C8             9196  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0439C8             9197  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0439C8             9198  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0439C8             9199  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0439C8             9200  ;
0439C8 C5          9201  			PUSH    BC			; Preserve BC and HL
0439C9 E5          9202  			PUSH    HL
0439CA 21 BE 31 04 9203  			LD      HL,KEYWDS		; The list of tokens and keywords
0439CE 01 DF 02 00 9204  			LD      BC,KEYWDL		; The length of the keyword list
0439D2 ED B1       9205  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439D4             9206  ;							; At this point HL points to the next byte, the first character of the token
0439D4 7E          9207  TOKEN1:			LD      A,(HL)			; Fetch the character
0439D5 23          9208  			INC     HL			; Increment to the next byte in the token table
0439D6 FE 8A       9209  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439D8 F5          9210  			PUSH    AF			; Then...
0439D9 EC A5 39 04 9211  			CALL    PE,OUTCHR		; Output the character...
0439DD F1          9212  			POP     AF			;
0439DE EA D4 39 04 9213  			JP      PE,TOKEN1		; And loop to the next character
0439E2 E1          9214  			POP     HL			; Done, so tidy up the stack and exit
0439E3 C1          9215  			POP     BC
0439E4 C9          9216  			RET
0439E5             9217  ;
0439E5             9218  ; FINDL - FIND PROGRAM LINE
0439E5             9219  ;   Inputs: HL = line number (binary)
0439E5             9220  ;  Outputs: HL addresses line (if found)
0439E5             9221  ;           DE = line number
0439E5             9222  ;           Z-flag set if found.
0439E5             9223  ; Destroys: A,B,C,D,E,H,L,F
0439E5             9224  ;
0439E5 EB          9225  FINDL:			EX      DE,HL			; DE: Line number (binary)
0439E6 2A 14 4D 04 9226  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439EA AF          9227  			XOR     A               	;  A: 0
0439EB BE          9228  			CP      (HL)			; Check for end of program marker
0439EC 3C          9229  			INC     A			;  A: 1
0439ED D0          9230  			RET     NC			; Return with 1 if 0
0439EE AF          9231  			XOR     A               	; Clear the carry flag
0439EF             9232  ;			LD      B,A			;  B: 0
0439EF 01 00 00 00 9233  			LD	BC, 0			; BC: 0
0439F3             9234  ;
0439F3 4E          9235  FINDL1:			LD      C,(HL)			;  C: The line length
0439F4 E5          9236  			PUSH    HL			; Stack the current program counter
0439F5 23          9237  			INC     HL			; Skip to the line number bytes
0439F6 7E          9238  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439F7 23          9239  			INC     HL
0439F8 66          9240  			LD      H,(HL)
0439F9 6F          9241  			LD      L,A
0439FA 52 ED 52    9242  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439FD E1          9243  			POP     HL			; Get the current program counter
0439FE D0          9244  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439FF 09          9245  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
043A00 C3 F3 39 04 9246  			JP      FINDL1			; And loop
043A04             9247  ;
043A04             9248  ; SETLIN - Search program for line containing address
043A04             9249  ;          Update (LINENO)
043A04             9250  ;   Inputs: Address in (ERRLIN)
043A04             9251  ;  Outputs: Line number in HL and (LINENO)
043A04             9252  ; Destroys: B,C,D,E,H,L,F
043A04             9253  ;
043A04 01 00 00 00 9254  SETLIN:			LD	BC, 0			; Zero BC for later
043A08             9255  ;			LD      B, 0			; Zero B for later
043A08 ED 5B 35 4D 9256  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
043A0D 2A 14 4D 04 9257  			LD      HL, (PAGE_)		; HL: Start of user program area
043A11 B7          9258  			OR      A			; Do a 24 bit compare without destroying HL
043A12 ED 52       9259  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
043A14 19          9260  			ADD     HL, DE			;  C: DE > HL
043A15 30 1B       9261  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
043A17             9262  ;
043A17 4E          9263  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
043A18 0C          9264  			INC     C			; This is a way to check for zero without using the accumulator
043A19 0D          9265  			DEC     C			; If it is zero, then...
043A1A 28 16       9266  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
043A1C 09          9267  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
043A1D ED 52       9268  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
043A1F 19          9269  			ADD     HL, DE
043A20 38 F5       9270  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
043A22 ED 42       9271  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
043A24 23          9272  			INC     HL			; Skip the length counter
043A25 11 00 00 00 9273  			LD	DE, 0			; Zero DE
043A29 5E          9274  			LD      E, (HL)          	; Fetch the line number
043A2A 23          9275  			INC     HL
043A2B 56          9276  			LD      D, (HL)
043A2C EB          9277  			EX      DE, HL			; HL: The line number
043A2D 22 23 4D 04 9278  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A31 C9          9279  			RET
043A32             9280  ;
043A32 21 00 00 00 9281  SET3:			LD      HL, 0			; We've not found the line at this point so
043A36 18 F5       9282  			JR      SET2			; Set LINENO to 0
043A38             9283  ;
043A38             9284  ;SAYLN - PRINT " at line nnnn" MESSAGE.
043A38             9285  ;  Outputs: Carry=0 if line number is zero.
043A38             9286  ;           Carry=1 if line number is non-zero.
043A38             9287  ; Destroys: A,B,C,D,E,H,L,F
043A38             9288  ;
043A38 2A 23 4D 04 9289  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A3C 7C          9290  			LD      A,H			; If it is zero then
043A3D B5          9291  			OR      L
043A3E C8          9292  			RET     Z			; Don't need to do anything; return with F:C set to 0
043A3F CD E6 3D 04 9293  			CALL    TELL			; Output the error message
043A43 20 61 74 20 9294  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
043A4D 0E 00       9295  PBCDL:			LD      C,0			; C: Leading character (NUL)
043A4F 18 02       9296  			JR      PBCD0			; Output the line number; return with F:C set to 1
043A51             9297  ;
043A51             9298  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
043A51             9299  ;   Inputs: HL = number (binary).
043A51             9300  ;  Outputs: Carry = 1
043A51             9301  ; Destroys: A,B,C,D,E,H,L,F
043A51             9302  ;
043A51 0E 20       9303  PBCD:			LD      C,' '			; C: Leading character (" ")
043A53 06 05       9304  PBCD0:			LD      B,5			; Number of digits in result
043A55 11 10 27 00 9305  			LD      DE,10000		; Start off with the 10,000 column
043A59 AF          9306  PBCD1:			XOR     A			; Counter
043A5A ED 52       9307  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A5C 3C          9308  			INC     A
043A5D 30 FB       9309  			JR      NC,PBCD2
043A5F 19          9310  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A60 3D          9311  			DEC     A			; A: Number of 10,000s
043A61 28 04       9312  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A63 CB E1       9313  			SET     4,C			; C: Set to '0' ASCII (30h)
043A65 CB E9       9314  			SET     5,C
043A67 B1          9315  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A68 C4 A5 39 04 9316  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A6C 78          9317  			LD      A,B			; If on first transition, skip this
043A6D FE 05       9318  			CP      5			; TODO: Need to find out why
043A6F 28 06       9319  			JR      Z,PBCD4
043A71 29          9320  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A72 54          9321  			LD      D,H			;         : rather than shifting DE right
043A73 5D          9322  			LD      E,L			;         : This makes a lot of sense
043A74 29          9323  			ADD     HL,HL			; HL x  4
043A75 29          9324  			ADD     HL,HL			; HL x  8
043A76 19          9325  			ADD     HL,DE			; HL x 10
043A77 11 E8 03 00 9326  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A7B 10 DC       9327  			DJNZ    PBCD1			; Loop until done
043A7D 37          9328  			SCF				; SCF set for SAYLN in this module
043A7E C9          9329  			RET
043A7F             9330  ;
043A7F             9331  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A7F             9332  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A7F             9333  ;  Outputs: As GETVAR.
043A7F             9334  ; Destroys: everything
043A7F             9335  ;
043A7F CD 04 3C 04 9336  PUTVAR:			CALL    CREATE			; Create the variable
043A83 FD 7E 00    9337  			LD      A,(IY)			; Fetch the next character
043A86 FE 28       9338  			CP      '('			; Check for bad use of array
043A88 20 70       9339  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A8A 3E 0E       9340  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A8C C3 B6 37 04 9341  ERROR3:			JP      ERROR_
043A90             9342  ;
043A90             9343  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A90             9344  ;   Inputs: IY addresses first character.
043A90             9345  ;  Outputs: Carry set and NZ if illegal character.
043A90             9346  ;           Z-flag set if variable found, then:
043A90             9347  ;            A = variable type (0,4,5,128 or 129)
043A90             9348  ;            HL = IX = variable pointer.
043A90             9349  ;            IY updated
043A90             9350  ;           If Z-flag & carry reset, then:
043A90             9351  ;            HL, IY set for subsequent PUTVAR call.
043A90             9352  ; Destroys: everything
043A90             9353  ;
043A90 FD 7E 00    9354  GETVAR:			LD      A,(IY)			; Get the first character
043A93 FE 24       9355  			CP      '$'			; Is it a string?
043A95 28 69       9356  			JR      Z,GETV4			; Yes, so branch here
043A97 FE 21       9357  			CP      '!'			; Is it indirection (32-bit)?
043A99 28 69       9358  			JR      Z,GETV5			; Yes, so branch here
043A9B FE 3F       9359  			CP      '?'			; Is it indirection (8-bit)?
043A9D 28 69       9360  			JR      Z,GETV6			; Yes, so branch here
043A9F             9361  ;
043A9F CD 6E 3B 04 9362  			CALL    LOCATE			; Locate the variable
043AA3 C0          9363  			RET     NZ			; And exit here if not found
043AA4             9364  ;
043AA4             9365  ; At this point:
043AA4             9366  ;  HL: Address of variable in memory
043AA4             9367  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043AA4             9368  ;
043AA4 FD 7E 00    9369  			LD      A,(IY)			; Further checks
043AA7 FE 28       9370  			CP      '('             	; Is it an array?
043AA9 20 47       9371  			JR      NZ,GETVX        	; No, so exit
043AAB             9372  ;
043AAB             9373  ; We are processing an array at this point
043AAB             9374  ;
043AAB D5          9375  			PUSH    DE              	; Save the variable type (in D)
043AAC 7E          9376  			LD      A,(HL)          	; Fetch the number of dimensions
043AAD B7          9377  			OR      A
043AAE 28 DA       9378  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043AB0 23          9379  			INC     HL			;
043AB1 11 00 00 00 9380  			LD      DE,0            	; Accumulator
043AB5 F5          9381  			PUSH    AF
043AB6 FD 23       9382  			INC     IY              	; Skip "("
043AB8 18 05       9383  			JR      GETV3
043ABA             9384  ;
043ABA F5          9385  GETV2:			PUSH    AF
043ABB CD 2A 0A 04 9386  			CALL    COMMA
043ABF E5          9387  GETV3:			PUSH    HL
043AC0 D5          9388  			PUSH    DE
043AC1 CD 0F 03 04 9389  			CALL    EXPRI			; Get the subscript
043AC5 D9          9390  			EXX
043AC6 D1          9391  			POP     DE
043AC7 E3          9392  			EX      (SP),HL
043AC8 4E          9393  			LD      C,(HL)
043AC9 23          9394  			INC     HL
043ACA 46          9395  			LD      B,(HL)
043ACB 23          9396  			INC     HL
043ACC E3          9397  			EX      (SP),HL
043ACD EB          9398  			EX      DE,HL
043ACE D5          9399  			PUSH    DE
043ACF CD A4 18 04 9400  			CALL    MUL16			; HL=HL*BC
043AD3 D1          9401  			POP     DE
043AD4 19          9402  			ADD     HL,DE
043AD5 EB          9403  			EX      DE,HL
043AD6 B7          9404  			OR      A
043AD7 ED 42       9405  			SBC     HL,BC
043AD9 3E 0F       9406  			LD      A,15
043ADB 30 AF       9407  			JR      NC,ERROR3		; Throw a "Subscript" error
043ADD E1          9408  			POP     HL
043ADE F1          9409  			POP     AF
043ADF 3D          9410  			DEC     A               	; Dimension counter
043AE0 20 D8       9411  			JR      NZ,GETV2
043AE2 CD 37 0A 04 9412  			CALL    BRAKET          	; Check for closing bracket
043AE6 F1          9413  			POP     AF              	; Restore the type
043AE7 E5          9414  			PUSH    HL
043AE8 CD 97 18 04 9415  			CALL    X4OR5           	; DE=DE*n
043AEC E1          9416  			POP     HL
043AED 19          9417  			ADD     HL,DE
043AEE 57          9418  			LD      D,A             	; The type
043AEF FD 7E 00    9419  			LD      A,(IY)
043AF2 FE 3F       9420  GETVX:			CP      '?'
043AF4 28 1E       9421  			JR      Z,GETV9
043AF6 FE 21       9422  			CP      '!'
043AF8 28 16       9423  			JR      Z,GETV8
043AFA E5          9424  GETVZ:			PUSH    HL              	; Set exit conditions
043AFB DD E1       9425  			POP     IX
043AFD 7A          9426  			LD      A,D
043AFE BF          9427  			CP      A
043AFF C9          9428  			RET
043B00             9429  ;
043B00             9430  ; Process strings, unary & binary indirection:
043B00             9431  ;
043B00 3E 80       9432  GETV4:			LD      A,128           	; Static strings
043B02 18 05       9433  			JR      GETV7
043B04             9434  ;
043B04 3E 04       9435  GETV5:			LD      A,4             	; Unary 32-bit indirection
043B06 18 01       9436  			JR      GETV7
043B08             9437  ;
043B08 AF          9438  GETV6:			XOR     A               	; Unary 8-bit indirection
043B09             9439  ;
043B09 21 00 00 00 9440  GETV7:			LD      HL,0
043B0D F5          9441  			PUSH    AF
043B0E 18 24       9442  			JR      GETV0
043B10             9443  ;
043B10 06 04       9444  GETV8:			LD      B,4             	; Binary 32-bt indirection
043B12 18 02       9445  			JR      GETVA
043B14             9446  ;
043B14 06 00       9447  GETV9:			LD      B,0             	; Binary 8-bit indirection
043B16             9448  ;
043B16 E5          9449  GETVA:			PUSH    HL
043B17 DD E1       9450  			POP     IX
043B19 7A          9451  			LD      A,D            		; Fetch the variable type
043B1A FE 81       9452  			CP      129			; Is it a string?
043B1C C8          9453  			RET     Z               	; Yes, so exit here
043B1D C5          9454  			PUSH    BC
043B1E CD 1B 04 04 9455  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043B22 CD 67 06 04 9456  			CALL    SFIX
043B26 7D          9457  			LD	A,L
043B27 D9          9458  			EXX
043B28 22 4A 4D 04 9459  			LD	(R0+0),HL
043B2C 32 4C 4D 04 9460  			LD	(R0+2),A
043B30 2A 4A 4D 04 9461  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B34             9462  ;
043B34 E5          9463  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B35 FD 23       9464  			INC     IY
043B37 CD 2A 03 04 9465  			CALL    ITEMI
043B3B 7D          9466  			LD	A,L			;  A: The MSB of the address
043B3C D9          9467  			EXX
043B3D 22 4A 4D 04 9468  			LD	(R0+0),HL		; HL: The LSW of the address
043B41 32 4C 4D 04 9469  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B45 D1          9470  			POP     DE
043B46 F1          9471  			POP     AF
043B47 2A 4A 4D 04 9472  			LD	HL,(R0)			; HL: L'HL
043B4B 19          9473  			ADD     HL,DE
043B4C E5          9474  			PUSH    HL
043B4D DD E1       9475  			POP     IX
043B4F BF          9476  			CP      A
043B50 C9          9477  			RET
043B51             9478  ;
043B51             9479  ;GETDEF - Find entry for FN or PROC in dynamic area.
043B51             9480  ;   Inputs: IY addresses byte following "DEF" token.
043B51             9481  ;  Outputs: Z flag set if found
043B51             9482  ;           Carry set if neither FN or PROC first.
043B51             9483  ;           If Z: HL points to entry
043B51             9484  ;                 IY addresses delimiter
043B51             9485  ; Destroys: A,D,E,H,L,IY,F
043B51             9486  ;
043B51 FD 7E 01    9487  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B54 CD D1 3C 04 9488  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B58 D8          9489  			RET     C			; No so return with C set
043B59 FD 7E 00    9490  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B5C 21 0E 4D 04 9491  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B60 FE A4       9492  			CP      FN			; Is it the token FN?
043B62 28 4A       9493  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B64 21 11 4D 04 9494  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B68 FE F2       9495  			CP      PROC			; Is it the token PROC?
043B6A 28 42       9496  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B6C 37          9497  			SCF				; No, so just return with C set
043B6D C9          9498  			RET
043B6E             9499  ;
043B6E             9500  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B6E             9501  ; If illegal first character return carry, non-zero.
043B6E             9502  ; If found, return no-carry, zero.
043B6E             9503  ; If not found, return no-carry, non-zero.
043B6E             9504  ;   Inputs: IY=Addresses first character of name.
043B6E             9505  ;            A=(IY)
043B6E             9506  ;  Outputs:  F=Z set if found, then:
043B6E             9507  ;           IY=addresses terminator
043B6E             9508  ;           HL=addresses location of variable
043B6E             9509  ;            D=type of variable: 4 = integer
043B6E             9510  ;                                5 = floating point
043B6E             9511  ;                              129 = string
043B6E             9512  ; Destroys: A,D,E,H,L,IY,F
043B6E             9513  ;
043B6E             9514  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B6E             9515  ; They can contain any alphanumeric character and underscore (_)
043B6E             9516  ; String variables are postfixed with the dollar ($) character
043B6E             9517  ; Integer variables are postfixed with the percent (%) character
043B6E             9518  ; Static integer variables are named @%, A% to Z%
043B6E             9519  ; All other variables are dynamic
043B6E             9520  ;
043B6E D6 40       9521  LOCATE:			SUB     '@'			; Check for valid range
043B70 D8          9522  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B71 21 00 00 00 9523  			LD      HL, 0			; Clear HL
043B75 FE 1B       9524  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B77 30 1E       9525  			JR      NC,LOC0         	; Then branch here
043B79 6F          9526  			LD	L, A			; HL = A
043B7A FD 7E 01    9527  			LD      A,(IY+1)        	; Check the 2nd character
043B7D FE 25       9528  			CP      '%'			; If not "%" then it is not static...
043B7F 20 21       9529  			JR      NZ,LOC1         	; Branch here
043B81 FD 7E 02    9530  			LD      A,(IY+2)		; Check the 3rd character
043B84 FE 28       9531  			CP      '('			; If it is "(" (array) then it is not static...
043B86 28 1A       9532  			JR      Z,LOC1          	; Branch here
043B88             9533  ;
043B88             9534  ; At this point we're dealing with a static variable
043B88             9535  ;
043B88 29          9536  			ADD     HL,HL			; HL: Variable index * 4
043B89 29          9537  			ADD	HL,HL
043B8A 11 00 4C 04 9538  			LD      DE,STAVAR       	; The static variable area in memory
043B8E 19          9539  			ADD     HL,DE			; HL: The address of the static variable
043B8F FD 23       9540  			INC     IY			; Skip the program pointer past the static variable name
043B91 FD 23       9541  			INC     IY
043B93 16 04       9542  			LD      D,4             	; Set the type to be integer
043B95 AF          9543  			XOR     A			; Set the Z flag
043B96 C9          9544  			RET
043B97             9545  ;
043B97             9546  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B97             9547  ;
043B97 FE 1F       9548  LOC0:			CP      '_'-'@'			; Check the first character is in
043B99 D8          9549  			RET     C			; the range "_" to
043B9A FE 3B       9550  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B9C 3F          9551  			CCF				; If it is not in range then
043B9D 3D          9552  			DEC     A               	; Set NZ flag and
043B9E D8          9553  			RET     C			; Exit here
043B9F D6 03       9554  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043BA1 6F          9555  			LD	L, A			; HL = A
043BA2             9556  ;
043BA2             9557  ; Yes, it's definitely a dynamic variable at this point...
043BA2             9558  ;
043BA2 7D          9559  LOC1:			LD	A, L			; Fetch variable index
043BA3 87          9560  			ADD	A, A			; x 2
043BA4 85          9561  			ADD	A, L			; x 3
043BA5 D6 03       9562  			SUB	3			; Subtract 2 TODO: Should be 3
043BA7 6F          9563  			LD	L, A
043BA8 11 6C 4C 04 9564  			LD      DE, DYNVAR       	; The dynamic variable storage
043BAC D8          9565  			RET	C			; Bounds check to trap for variable '@'
043BAD 19          9566  			ADD     HL, DE			; HL: Address of first entry
043BAE             9567  ;
043BAE             9568  ; Loop through the linked list of variables to find a match
043BAE             9569  ;
043BAE ED 17       9570  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043BB0 E5          9571  			PUSH	HL			; Need to preserve HL for LOC6
043BB1 AF          9572  			XOR	A			; Reset carry flag
043BB2 ED 62       9573  			SBC	HL, HL			; Set HL to 0
043BB4 ED 52       9574  			SBC	HL, DE			; Compare with 0
043BB6 E1          9575  			POP	HL			; Restore the original pointer
043BB7 28 49       9576  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043BB9             9577  			; LD	HL, DE			; Make a copy of this pointer in HL
043BB9 D5          9578  			push de
043BBA E1          9579  			pop hl ; how was that even possible?
043BBB 23          9580  			INC     HL              	; Skip the link (24-bits)
043BBC 23          9581  			INC     HL
043BBD 23          9582  			INC	HL			; HL: Address of the variable name in DYNVARS
043BBE FD E5       9583  			PUSH    IY			; IY: Address of the variable name in the program
043BC0             9584  ;
043BC0 7E          9585  LOC3:			LD      A,(HL)         		; Compare
043BC1 23          9586  			INC     HL
043BC2 FD 23       9587  			INC     IY
043BC4 FD BE 00    9588  			CP      (IY)
043BC7 28 F7       9589  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043BC9 B7          9590  			OR      A               	; Have we hit a terminator?
043BCA 28 07       9591  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BCC             9592  ;
043BCC FD E1       9593  LOC4:			POP     IY			; Restore the pointer in the program
043BCE EB          9594  			EX      DE, HL			; HL: New pointer in DYNVARS
043BCF C3 AE 3B 04 9595  			JP      LOC2            	; Loop round and try again
043BD3             9596  ;
043BD3             9597  ; We might have located a variable at this point, just need to do a few more tests
043BD3             9598  ;
043BD3 FD 2B       9599  LOC5:			DEC     IY
043BD5 FD 7E 00    9600  			LD      A,(IY)
043BD8 FE 28       9601  			CP      '('
043BDA 28 15       9602  			JR      Z,LOC5A         	; FOUND
043BDC FD 23       9603  			INC     IY
043BDE CD C5 3C 04 9604  			CALL    RANGE
043BE2 38 0D       9605  			JR      C,LOC5A         	; FOUND
043BE4 FE 28       9606  			CP      '('
043BE6 28 E4       9607  			JR      Z,LOC4          	; KEEP LOOKING
043BE8 FD 7E FF    9608  			LD      A,(IY-1)
043BEB CD D1 3C 04 9609  			CALL    RANGE1
043BEF 30 DB       9610  			JR      NC,LOC4         	; KEEP LOOKING
043BF1 D1          9611  LOC5A:			POP     DE
043BF2 FD 7E FF    9612  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BF5 FE 24       9613  			CP      '$'			; Is it a string?
043BF7 16 81       9614  			LD      D,129			; Yes, so return D = 129
043BF9 C8          9615  			RET     Z
043BFA FE 25       9616  			CP      '%'			; Is it an integer?
043BFC 16 04       9617  			LD      D,4			; Yes, so return D = 4
043BFE C8          9618  			RET     Z
043BFF 14          9619  			INC     D			; At this point it must be a float
043C00 BF          9620  			CP      A			; Set the flags
043C01 C9          9621  			RET
043C02             9622  ;
043C02             9623  ; The variable is undefined at this point; HL will be zero
043C02             9624  ;
043C02 3C          9625  LOC6:			INC     A               	; Set NZ flag
043C03 C9          9626  			RET
043C04             9627  ;
043C04             9628  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043C04             9629  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043C04             9630  ;  Outputs: As LOCATE, GETDEF.
043C04             9631  ; Destroys: As LOCATE, GETDEF.
043C04             9632  ;
043C04 AF          9633  CREATE:			XOR     A
043C05 ED 5B 1D 4D 9634  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043C0A ED 1F       9635  			LD	(HL), DE		; Store
043C0C EB          9636  			EX      DE,HL
043C0D 77          9637  			LD      (HL),A			; Clear the link of the new entity
043C0E 23          9638  			INC     HL
043C0F 77          9639  			LD      (HL),A
043C10 23          9640  			INC     HL
043C11 77          9641  			LD      (HL),A
043C12 23          9642  			INC     HL
043C13 FD 23       9643  LOC7:			INC     IY
043C15 CD C5 3C 04 9644  			CALL    RANGE           	; END OF VARIABLE?
043C19 38 15       9645  			JR      C,LOC8
043C1B 77          9646  			LD      (HL),A
043C1C 23          9647  			INC     HL
043C1D CD D1 3C 04 9648  			CALL    RANGE1
043C21 30 F0       9649  			JR      NC,LOC7
043C23 FE 28       9650  			CP      '('
043C25 28 09       9651  			JR      Z,LOC8
043C27 FD 7E 01    9652  			LD      A,(IY+1)
043C2A FE 28       9653  			CP      '('
043C2C 28 E5       9654  			JR      Z,LOC7
043C2E FD 23       9655  			INC     IY
043C30 36 00       9656  LOC8:			LD      (HL),0          	; TERMINATOR
043C32 23          9657  			INC     HL
043C33 E5          9658  			PUSH    HL
043C34 CD F2 3B 04 9659  			CALL    TYPE_			; Get the variable type in D
043C38 3E 04       9660  			LD      A,4			; If it is an integer then it takes up 4 bytes
043C3A BA          9661  			CP      D
043C3B 28 01       9662  			JR      Z,LOC9			; So skip the next bit
043C3D 3C          9663  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C3E 36 00       9664  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C40 23          9665  			INC     HL
043C41 3D          9666  			DEC     A
043C42 20 FA       9667  			JR      NZ,LOC9
043C44 22 1D 4D 04 9668  			LD      (FREE),HL		; Adjust the stack
043C48 CD 81 16 04 9669  			CALL    CHECK			; Check whether we are out of space
043C4C E1          9670  			POP     HL
043C4D AF          9671  			XOR     A
043C4E C9          9672  			RET
043C4F             9673  ;
043C4F             9674  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043C4F             9675  ;   Inputs: IY = Text Pointer
043C4F             9676  ;  Outputs: HL = Line number (zero if none)
043C4F             9677  ;           IY updated
043C4F             9678  ; Destroys: A,D,E,H,L,IY,F
043C4F             9679  ;
043C4F             9680  ; This bit of code performs a BASE 10 shift to build up the number
043C4F             9681  ; So if the string passed is "345", the algorithm does this:
043C4F             9682  ;
043C4F             9683  ;    HL : Digit	: Operation
043C4F             9684  ; ----- : ----- : ---------
043C4F             9685  ; 00000 :	:
043C4F             9686  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043C4F             9687  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043C4F             9688  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043C4F             9689  ;
043C4F             9690  ; The multiply by 10 is done by an unrolled shift and add loop
043C4F             9691  ;
043C4F CD 78 0A 04 9692  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C53 40 21 00 00 9693  			LD.SIS  HL,0			; The running total
043C57 FD 7E 00    9694  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C5A D6 30       9695  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C5C D8          9696  			RET     C			; And return if less than 0
043C5D FE 0A       9697  			CP      10			; Or greater than or equal to 10
043C5F D0          9698  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C60 FD 23       9699  			INC     IY			; Increment the string pointer
043C62 54          9700  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C63 5D          9701  			LD      E,L			; Store the original number in DE
043C64 52 29       9702  			ADD.S   HL,HL           	; *2
043C66 38 13       9703  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C68 52 29       9704  			ADD.S   HL,HL           	; *4S
043C6A 38 0F       9705  			JR      C,TOOBIG
043C6C 52 19       9706  			ADD.S   HL,DE           	; *5
043C6E 38 0B       9707  			JR      C,TOOBIG
043C70 52 29       9708  			ADD.S   HL,HL           	; *10
043C72 38 07       9709  			JR      C,TOOBIG
043C74 5F          9710  			LD      E,A			; A->DE: the digit to add in
043C75 16 00       9711  			LD      D,0
043C77 52 19       9712  			ADD.S   HL,DE           	; Add in the digit to the running total
043C79 30 DC       9713  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C7B             9714  ;
043C7B 3E 14       9715  TOOBIG:			LD      A,20
043C7D C3 B6 37 04 9716  			JP      ERROR_           	; Error: "Too big"
043C81             9717  ;
043C81             9718  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C81             9719  ;   Inputs: IY = text pointer
043C81             9720  ;  Outputs: HL = first number (10 by default)
043C81             9721  ;           BC = second number (10 by default)
043C81             9722  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C81             9723  ;
043C81 CD 4F 3C 04 9724  PAIR:			CALL    LINNUM          	; Parse the first line number
043C85 7C          9725  			LD      A,H			; If it is not zero, then...
043C86 B5          9726  			OR      L
043C87 20 02       9727  			JR      NZ,PAIR1		; Skip...
043C89 2E 0A       9728  			LD      L,10			; HL: the default value (10)
043C8B             9729  ;
043C8B CD AC 17 04 9730  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C8F FD 23       9731  			INC     IY			; Skip to next character
043C91 E5          9732  			PUSH    HL			; Stack the first line number
043C92 21 0A 00 00 9733  			LD      HL,10			; HL: the second default (10)
043C96 C4 4F 3C 04 9734  			CALL    NZ,LINNUM       	; Parse the second line number
043C9A E3          9735  			EX      (SP),HL			; HL: The first line number (off the stack)
043C9B C1          9736  			POP     BC			; BC: Second line number
043C9C 78          9737  			LD      A,B			; If the second line number is not zero then...
043C9D B1          9738  			OR      C			; We're good...
043C9E C0          9739  			RET     NZ			; Exit, otherwise...
043C9F CD CD 37 04 9740  			CALL    EXTERR			; Throw error: "Silly"
043CA3 53 69 6C 6C 9741  			DB    	"Silly", 0
       79 00       
043CA9             9742  ;
043CA9             9743  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043CA9             9744  ;   Inputs: IY = text pointer
043CA9             9745  ;  Outputs: HL = points to program text
043CA9             9746  ;           BC = second number (0 by default)
043CA9             9747  ; Destroys: A,B,C,D,E,H,L,IY,F
043CA9             9748  ;
043CA9 CD 4F 3C 04 9749  DLPAIR:			CALL    LINNUM			; Parse the first line number
043CAD E5          9750  			PUSH    HL			; Stack it
043CAE CD AC 17 04 9751  			CALL    TERMQ			; Check for ELSE, : or CR
043CB2 28 0A       9752  			JR      Z,DLP1			; And exit if so
043CB4 FE E7       9753  			CP      TIF			; Is the token IF?
043CB6 28 06       9754  			JR      Z,DLP1			; Yes, so skip the next bit...
043CB8 FD 23       9755  			INC     IY			; Otherwise...
043CBA CD 4F 3C 04 9756  			CALL    LINNUM			; Fetch the second line number
043CBE E3          9757  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043CBF CD E5 39 04 9758  			CALL    FINDL			; HL: Find the address of the line
043CC3 C1          9759  			POP     BC			; BC: The second number
043CC4 C9          9760  			RET
043CC5             9761  ;
043CC5             9762  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043CC5             9763  ;   Inputs: IY addresses character
043CC5             9764  ;  Outputs: Carry set if out-of-range.
043CC5             9765  ; Destroys: A,F
043CC5             9766  ;
043CC5             9767  ; It is called here to check the following
043CC5             9768  ; In range: "$", "%" and "("
043CC5             9769  ;   Plus all characters in RANGE1 and RANGE2
043CC5             9770  ;
043CC5 FD 7E 00    9771  RANGE:			LD      A,(IY)			; Fetch the character
043CC8 FE 24       9772  			CP      '$'			; Postfix for string variable is valid
043CCA C8          9773  			RET     Z
043CCB FE 25       9774  			CP      '%'			; Postfix for integer variable is valid
043CCD C8          9775  			RET     Z
043CCE FE 28       9776  			CP      '('			; Postfix for array is valid
043CD0 C8          9777  			RET     Z
043CD1             9778  ;
043CD1             9779  ; It is called here to check the following
043CD1             9780  ; In range: "0" to "9" and "@"
043CD1             9781  ;   Plus all characters in RANGE2
043CD1             9782  ;
043CD1 FE 30       9783  RANGE1:			CP      '0'			; If it is between '0'...
043CD3 D8          9784  			RET     C
043CD4 FE 3A       9785  			CP      '9'+1			; And '9'...
043CD6 3F          9786  			CCF
043CD7 D0          9787  			RET     NC			; Then it is valid
043CD8 FE 40       9788  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CDA C8          9789  			RET     Z
043CDB             9790  ;
043CDB             9791  ; It is called here to check the following
043CDB             9792  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043CDB             9793  ;
043CDB FE 41       9794  RANGE2:			CP      'A'			; If it is between 'A'...
043CDD D8          9795  			RET     C
043CDE FE 5B       9796  			CP      'Z'+1			; And 'Z'...
043CE0 3F          9797  			CCF
043CE1 D0          9798  			RET     NC			; Then it is valid
043CE2 FE 5F       9799  			CP      '_'			; If it is underscore, grave, or between 'a'
043CE4 D8          9800  			RET     C
043CE5 FE 7B       9801  			CP      'z'+1			; And 'z'
043CE7 3F          9802  			CCF				; Then it is valid
043CE8 C9          9803  			RET
043CE9             9804  ;
043CE9             9805  ; Throw a 'LINE space' error (line too long)
043CE9             9806  ; This is called from LEXAN
043CE9             9807  ;
043CE9 AF          9808  SPACE_: 		XOR     A
043CEA CD CD 37 04 9809  			CALL    EXTERR          	; "LINE space"
043CEE 86 08 00    9810  			DB    	LINE_, 8, 0
043CF1             9811  ;
043CF1             9812  ; LEXAN - LEXICAL ANALYSIS.
043CF1             9813  ;  Bit 0,C: 1=left, 0=right
043CF1             9814  ;  Bit 2,C: 1=in BINARY
043CF1             9815  ;  Bit 3,C: 1=in HEX
043CF1             9816  ;  Bit 4,C: 1=accept line number
043CF1             9817  ;  Bit 5,C: 1=in variable, FN, PROC
043CF1             9818  ;  Bit 6,C: 1=in REM, DATA, *
043CF1             9819  ;  Bit 7,C: 1=in quotes
043CF1             9820  ;   Inputs: IY addresses source string
043CF1             9821  ;           DE addresses destination string (must be page boundary)
043CF1             9822  ;            C sets initial mode
043CF1             9823  ;  Outputs: DE, IY updated
043CF1             9824  ;            A holds carriage return
043CF1             9825  ;
043CF1 12          9826  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CF2 13          9827  			INC     DE              	; Increment the pointers
043CF3 FD 23       9828  			INC     IY			; And fall through to the main function
043CF5             9829  ;
043CF5             9830  ; This is the main entry point
043CF5             9831  ;
043CF5 7B          9832  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CF6 FE FC       9833  			CP      252             	; If it is >= 252 bytes, then...
043CF8 30 EF       9834  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CFA FD 7E 00    9835  			LD      A,(IY)			; Fetch character from source string
043CFD FE 0D       9836  			CP      CR			; If it is a CR
043CFF C8          9837  			RET     Z               	; Then it is end of line; we're done parsing
043D00 CD D1 3C 04 9838  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043D04 30 06       9839  			JR      NC,LEXAN3		; Yes, so skip
043D06 CB A9       9840  			RES     5,C             	; FLAG: NOT IN VARIABLE
043D08 CB 99       9841  			RES     3,C             	; FLAG: NOT IN HEX
043D0A CB 91       9842  			RES	2,C			; FLAG: NOT IN BINARY
043D0C             9843  ;
043D0C FE 20       9844  LEXAN3:			CP      ' '			; Ignore spaces
043D0E 28 E1       9845  			JR      Z,LEXAN1
043D10 FE 2C       9846  			CP      ','			; Ignore commas
043D12 28 DD       9847  			JR      Z,LEXAN1
043D14 FE 32       9848  			CP	'2'			; If less than '2'
043D16 30 02       9849  			JR	NC, @F			; No, so skip
043D18 CB 91       9850  			RES	2,C			; FLAG: NOT IN BINARY
043D1A FE 47       9851  @@:			CP      'G'			; If less then 'G'
043D1C 38 02       9852  			JR      C,LEXAN4		; Yes, so skip
043D1E CB 99       9853  			RES     3,C             	; FLAG: NOT IN HEX
043D20             9854  ;
043D20 FE 22       9855  LEXAN4:			CP      34			; Is it a quote character?
043D22 20 05       9856  			JR      NZ,LEXAN5		; No, so skip
043D24 CB 11       9857  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D26 3F          9858  			CCF                     	; Toggle the carry
043D27 CB 19       9859  			RR      C			; And then shifting it back into bit 7 of C
043D29             9860  ;
043D29 CB 61       9861  LEXAN5:			BIT     4,C			; Accept line number?
043D2B 28 12       9862  			JR      Z,LEXAN6		; No, so skip
043D2D CB A1       9863  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D2F C5          9864  			PUSH    BC
043D30 D5          9865  			PUSH    DE
043D31 CD 4F 3C 04 9866  			CALL    LINNUM         		; Parse the line number to HL
043D35 D1          9867  			POP     DE
043D36 C1          9868  			POP     BC
043D37 7C          9869  			LD      A,H			; If it is not zero
043D38 B5          9870  			OR      L
043D39 C4 B2 3D 04 9871  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D3D 18 B6       9872  			JR      LEXAN2          	; And loop
043D3F             9873  ;
043D3F 0D          9874  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D40 28 0A       9875  			JR      Z,LEXAN7        	; If so, skip
043D42 0C          9876  			INC     C			; Otherwise restore C
043D43 20 AC       9877  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D45 B7          9878  			OR      A			; Set the flags based on the character
043D46 F4 1D 38 04 9879  			CALL    P,LEX           	; Tokenise if A < 128
043D4A 18 13       9880  			JR      LEXAN8			; And skip
043D4C             9881  ;
043D4C             9882  ; Processing the LEFT hand side here
043D4C             9883  ;
043D4C FE 2A       9884  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D4E 28 17       9885  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D50 B7          9886  			OR      A			; Set the flags based on the character
043D51 F4 1D 38 04 9887  			CALL    P,LEX           	; Tokenise if A < 128
043D55             9888  ;
043D55             9889  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043D55             9890  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043D55             9891  ; Examples:
043D55             9892  ;   LET A% = PAGE : REM This is the GET version
043D55             9893  ;   PAGE = 40000  : REM This is the SET version
043D55             9894  ;
043D55 FE 8F       9895  			CP      TOKLO			; TOKLO is 8Fh
043D57 38 06       9896  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D59 FE 94       9897  			CP      TOKHI+1			; TOKHI is 93h
043D5B 30 02       9898  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D5D C6 40       9899  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D5F             9900  ;
043D5F FE F4       9901  LEXAN8:			CP      REM			; If the token is REM
043D61 28 04       9902  			JR      Z,LEXAN9		; Then stop tokenising
043D63 FE DC       9903  			CP      DATA_			; If it is not DATA then
043D65 20 02       9904  			JR      NZ,LEXANA		; Skip
043D67 CB F1       9905  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D69             9906  ;
043D69 FE A4       9907  LEXANA:			CP      FN			; If the token is FN
043D6B 28 0A       9908  			JR      Z,LEXANB
043D6D FE F2       9909  			CP      PROC			; Or the token is PROC
043D6F 28 06       9910  			JR      Z,LEXANB		; Then jump to here
043D71 CD DB 3C 04 9911  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D75 38 02       9912  			JR      C,LEXANC		; Jump here if out of range
043D77             9913  ;
043D77 CB E9       9914  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D79 FE 26       9915  LEXANC:			CP      '&'			; Check for hex prefix
043D7B 20 02       9916  			JR      NZ,LEXAND		; If not, skip
043D7D CB D9       9917  			SET     3,C             	; FLAG: IN HEX
043D7F             9918  ;
043D7F FE 25       9919  LEXAND:			CP	'%'			; Check for binary prefix
043D81 20 02       9920  			JR	NZ,LEXANE		; If not, skip
043D83 CB D1       9921  			SET	2,C			; FLAG: IN BINARY
043D85             9922  ;
043D85 21 A9 3D 04 9923  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D89 C5          9924  			PUSH    BC
043D8A 01 06 00 00 9925  			LD      BC,LIST1L		; The list length
043D8E ED B1       9926  			CPIR				; Check if the token is in this list
043D90 C1          9927  			POP     BC
043D91 20 02       9928  			JR      NZ,LEXANF		; If not, then skip
043D93 CB E1       9929  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D95             9930  ;
043D95 21 AD 3D 04 9931  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D99 C5          9932  			PUSH    BC
043D9A 01 05 00 00 9933  			LD      BC,LIST2L		; The list length
043D9E ED B1       9934  			CPIR				; Check if the token is in this list
043DA0 C1          9935  			POP     BC
043DA1 20 02       9936  			JR      NZ,LEXANG		; If not, then skip
043DA3 CB C1       9937  			SET     0,C             	; FLAG: ENTER LEFT MODE
043DA5 C3 F1 3C 04 9938  LEXANG:			JP      LEXAN1			; And loop
043DA9             9939  
043DA9             9940  ;
043DA9             9941  ; LIST1: List of tokens that must be followed by line numbers
043DA9             9942  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043DA9             9943  ;
043DA9 E5          9944  LIST1:			DB	GOTO
043DAA E4          9945  			DB	GOSUB
043DAB F7          9946  			DB	RESTOR
043DAC FC          9947  			DB	TRACE
043DAD 8C          9948  LIST2:			DB	THEN
043DAE 8B          9949  			DB	ELSE_
043DAF             9950  LIST1L:			EQU     $-LIST1
043DAF F5          9951  			DB	REPEAT
043DB0 85          9952  			DB	TERROR
043DB1 3A          9953  			DB    	':'
043DB2             9954  LIST2L:			EQU     $-LIST2
043DB2             9955  ;
043DB2             9956  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043DB2             9957  ;   Inputs: HL=line number, DE=string pointer
043DB2             9958  ;  Outputs: DE updated, BIT 4,C set.
043DB2             9959  ; Destroys: A,B,C,D,E,F
043DB2             9960  ;
043DB2             9961  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043DB2             9962  ;
043DB2             9963  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043DB2             9964  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043DB2             9965  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043DB2             9966  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043DB2             9967  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043DB2             9968  ;
043DB2 CB E1       9969  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043DB4 EB          9970  			EX      DE, HL			; HL: string pointer, DE: line number
043DB5 36 8D       9971  			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
043DB7 23          9972  			INC     HL
043DB8 7A          9973  			LD      A,D			; Get the high byte
043DB9 E6 C0       9974  			AND     0C0H			; Get the top two bits	DD000000
043DBB 0F          9975  			RRCA				; Shift right		00DD0000
043DBC 0F          9976  			RRCA
043DBD 47          9977  			LD      B,A			; Store in B
043DBE 7B          9978  			LD      A,E			; Get the low byte
043DBF E6 C0       9979  			AND     0C0H			; Get the top two bits	EE000000
043DC1 B0          9980  			OR      B			; Combine with D	EEDD0000
043DC2 0F          9981  			RRCA				; Shift right		00EEDD00
043DC3 0F          9982  			RRCA
043DC4 EE 54       9983  			XOR     01010100B		; XOR with 54h
043DC6 77          9984  			LD      (HL),A			; Store this as the second byte
043DC7 23          9985  			INC     HL
043DC8 7B          9986  			LD      A,E			; Get the low byte
043DC9 E6 3F       9987  			AND     3FH			; Strip the top two bits off
043DCB F6 40       9988  			OR      '@'			; OR with 40h
043DCD 77          9989  			LD      (HL),A			; Store
043DCE 23          9990  			INC     HL
043DCF 7A          9991  			LD      A,D			; Get the high byte
043DD0 E6 3F       9992  			AND     3FH			; Strip the top two bits off
043DD2 F6 40       9993  			OR      '@'			; OR with 40h
043DD4 77          9994  			LD      (HL),A			; Store
043DD5 23          9995  			INC     HL
043DD6 EB          9996  			EX      DE,HL			; DE: string pointer, HL: line number
043DD7 C9          9997  			RET
043DD8             9998  ;
043DD8             9999  ; TEXT - OUTPUT MESSAGE.
043DD8             10000  ;   Inputs: HL addresses text (terminated by nul)
043DD8             10001  ;  Outputs: HL addresses character following nul.
043DD8             10002  ; Destroys: A,H,L,F
043DD8             10003  ;
043DD8 2A 2F 4D 04 10004  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DDC             10005  ;
043DDC 7E          10006  TEXT_:			LD      A, (HL)			; Fetch the character
043DDD 23          10007  			INC     HL			; Increment pointer to next character
043DDE B7          10008  			OR      A			; Check for the nul (0) string terminator
043DDF C8          10009  			RET     Z			; And return if so
043DE0 CD C2 39 04 10010  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DE4 18 F6       10011  			JR      TEXT_			; And loop
043DE6             10012  ;
043DE6             10013  ; TELL - OUTPUT MESSAGE.
043DE6             10014  ;   Inputs: Text follows subroutine call (term=nul)
043DE6             10015  ; Destroys: A,F
043DE6             10016  ;
043DE6             10017  ; Example usage:
043DE6             10018  ;
043DE6             10019  ;	CALL	TELL			Call the function
043DE6             10020  ;	DB	"Hello World", 0	Followed by a zero terminated string
043DE6             10021  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043DE6             10022  ;
043DE6 E3          10023  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DE7 CD DC 3D 04 10024  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DEB E3          10025  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DEC C9          10026  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043DED             10027  
043DED             10028  ; --- Begin misc.asm ---
043DED             10029  ;
043DED             10030  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043DED             10031  ; Author:	Dean Belfield
043DED             10032  ; Created:	12/05/2023
043DED             10033  ; Last Updated:	12/05/2023
043DED             10034  ;
043DED             10035  ; Modinfo:
043DED             10036  
043DED             10037  			; INCLUDE	"equs.inc"
043DED             10038  			; INCLUDE	"macros.inc"
043DED             10039  
043DED             10040  			; .ASSUME	ADL = 1
043DED             10041  
043DED             10042  			; SEGMENT CODE
043DED             10043  
043DED             10044  			; XDEF	ASC_TO_NUMBER
043DED             10045  			; XDEF	SWITCH_A
043DED             10046  			; XDEF	NULLTOCR
043DED             10047  			; XDEF	CRTONULL
043DED             10048  			; XDEF	CSTR_FNAME
043DED             10049  			; XDEF	CSTR_LINE
043DED             10050  			; XDEF	CSTR_FINDCH
043DED             10051  			; XDEF	CSTR_ENDSWITH
043DED             10052  			; XDEF	CSTR_CAT
043DED             10053  
043DED             10054  			; XREF	OSWRCH
043DED             10055  			; XREF	KEYWDS
043DED             10056  			; XREF	KEYWDL
043DED             10057  
043DED             10058  ; Read a number and convert to binary
043DED             10059  ; If prefixed with &, will read as hex, otherwise decimal
043DED             10060  ;   Inputs: HL: Pointer in string buffer
043DED             10061  ;  Outputs: HL: Updated text pointer
043DED             10062  ;           DE: Value
043DED             10063  ;            A: Terminator (spaces skipped)
043DED             10064  ; Destroys: A,D,E,H,L,F
043DED             10065  ;
043DED C5          10066  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DEE 11 00 00 00 10067  			LD	DE, 0			; Initialise DE
043DF2 CD 34 3E 04 10068  			CALL	SKIPSPC			; Skip whitespace
043DF6 7E          10069  			LD	A, (HL)			; Read first character
043DF7 FE 26       10070  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DF9 20 1F       10071  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DFB 23          10072  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DFC             10073  ;
043DFC 7E          10074  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DFD CD 42 3E 04 10075  			CALL    UPPERC			; Convert to uppercase
043E01 D6 30       10076  			SUB	'0'			; Normalise to 0
043E03 38 2E       10077  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E05 FE 0A       10078  			CP 	10			; Check if >= 10
043E07 38 06       10079  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043E09 D6 07       10080  			SUB 	7			; Adjust ASCII A-F to nibble
043E0B FE 10       10081  			CP 	16			; Check for > F
043E0D 30 24       10082  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043E0F EB          10083  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043E10 29          10084  			ADD	HL, HL
043E11 29          10085  			ADD	HL, HL
043E12 29          10086  			ADD	HL, HL
043E13 29          10087  			ADD	HL, HL
043E14 EB          10088  			EX	DE, HL
043E15 B3          10089  			OR      E			; OR the new digit in to the least significant nibble
043E16 5F          10090  			LD      E, A
043E17 23          10091  			INC     HL			; Onto the next character
043E18 18 E2       10092  			JR      ASC_TO_NUMBER1		; And loop
043E1A             10093  ;
043E1A 7E          10094  ASC_TO_NUMBER3:		LD	A, (HL)
043E1B D6 30       10095  			SUB	'0'			; Normalise to 0
043E1D 38 14       10096  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E1F FE 0A       10097  			CP	10			; Check if >= 10
043E21 30 10       10098  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043E23 EB          10099  			EX 	DE, HL 			; Stick DE in HL
043E24 44          10100  			LD	B, H 			; And copy HL into BC
043E25 4D          10101  			LD	C, L
043E26 29          10102  			ADD	HL, HL 			; x 2
043E27 29          10103  			ADD	HL, HL 			; x 4
043E28 09          10104  			ADD	HL, BC 			; x 5
043E29 29          10105  			ADD	HL, HL 			; x 10
043E2A EB          10106  			EX	DE, HL
043E2B             10107  			ADD8U_DE 			; Add A to DE (macro)
043E2B 83          0001M 		ADD	A, E
043E2C 5F          0002M 		LD	E, A
043E2D 8A          0003M 		ADC	A, D
043E2E 93          0004M 		SUB	E
043E2F 57          0005M 		LD	D, A
043E30 23          10108  			INC	HL
043E31 18 E7       10109  			JR	ASC_TO_NUMBER3
043E33 C1          10110  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043E34             10111  
043E34             10112  ; Skip a space
043E34             10113  ; HL: Pointer in string buffer
043E34             10114  ;
043E34 7E          10115  SKIPSPC:			LD      A, (HL)
043E35 FE 20       10116  			CP      ' '
043E37 C0          10117  			RET     NZ
043E38 23          10118  			INC     HL
043E39 18 F9       10119  			JR      SKIPSPC
043E3B             10120  
043E3B             10121  ; Skip a string
043E3B             10122  ; HL: Pointer in string buffer
043E3B             10123  ;
043E3B 7E          10124  SKIPNOTSP:		LD	A, (HL)
043E3C FE 20       10125  			CP	' '
043E3E C8          10126  			RET	Z
043E3F 23          10127  			INC	HL
043E40 18 F9       10128  			JR	SKIPNOTSP
043E42             10129  
043E42             10130  ; Convert a character to upper case
043E42             10131  ;  A: Character to convert
043E42             10132  ;
043E42 E6 7F       10133  UPPERC:  		AND     7FH
043E44 FE 60       10134  			CP      '`'
043E46 D8          10135  			RET     C
043E47 E6 5F       10136  			AND     5FH			; Convert to upper case
043E49 C9          10137  			RET
043E4A             10138  
043E4A             10139  ; Switch on A - lookup table immediately after call
043E4A             10140  ;  A: Index into lookup table
043E4A             10141  ;
043E4A E3          10142  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E4B 87          10143  			ADD	A, A			; Multiply A by two
043E4C             10144  			ADD8U_HL 			; Add to HL (macro)
043E4C 85          0001M 		ADD	A, L
043E4D 6F          0002M 		LD	L, A
043E4E 8C          0003M 		ADC	A, H
043E4F 95          0004M 		SUB	L
043E50 67          0005M 		LD	H, A
043E51 7E          10145  			LD	A, (HL)			; follow the call. Fetch an address from the
043E52 23          10146  			INC	HL 			; table.
043E53 66          10147  			LD	H, (HL)
043E54 6F          10148  			LD	L, A
043E55 E3          10149  			EX	(SP), HL		; Swap this new address back, restores HL
043E56 C9          10150  			RET				; Return program control to this new address
043E57             10151  
043E57             10152  ; Convert the buffer to a null terminated string and back
043E57             10153  ; HL: Buffer address
043E57             10154  ;
043E57 C5          10155  NULLTOCR:		PUSH 	BC
043E58 06 00       10156  			LD	B, 0
043E5A 0E 0D       10157  			LD	C, CR
043E5C 18 05       10158  			JR	CRTONULL0
043E5E             10159  ;
043E5E C5          10160  CRTONULL:		PUSH	BC
043E5F 06 0D       10161  			LD	B, CR
043E61 0E 00       10162  			LD	C, 0
043E63             10163  ;
043E63 E5          10164  CRTONULL0:		PUSH	HL
043E64 7E          10165  CRTONULL1:		LD	A, (HL)
043E65 B8          10166  			CP 	B
043E66 28 03       10167  			JR	Z, CRTONULL2
043E68 23          10168  			INC	HL
043E69 18 F9       10169  			JR	CRTONULL1
043E6B 71          10170  CRTONULL2:		LD	(HL), C
043E6C E1          10171  			POP 	HL
043E6D C1          10172  			POP	BC
043E6E C9          10173  			RET
043E6F             10174  
043E6F             10175  ; Copy a filename to DE and zero terminate it
043E6F             10176  ; HL: Source
043E6F             10177  ; DE: Destination (ACCS)
043E6F             10178  ;
043E6F 7E          10179  CSTR_FNAME:		LD	A, (HL)			; Get source
043E70 FE 20       10180  			CP	32			; Is it space
043E72 28 09       10181  			JR	Z, @F
043E74 FE 0D       10182  			CP	CR			; Or is it CR
043E76 28 05       10183  			JR	Z, @F
043E78 12          10184  			LD	(DE), A			; No, so store
043E79 23          10185  			INC	HL			; Increment
043E7A 13          10186  			INC	DE
043E7B 18 F2       10187  			JR	CSTR_FNAME		; And loop
043E7D AF          10188  @@:			XOR	A			; Zero terminate the target string
043E7E 12          10189  			LD	(DE), A
043E7F 13          10190  			INC	DE			; And point to next free address
043E80 C9          10191  			RET
043E81             10192  
043E81             10193  ; Copy a CR terminated line to DE and zero terminate it
043E81             10194  ; HL: Source
043E81             10195  ; DE: Destination (ACCS)
043E81             10196  ;
043E81 7E          10197  CSTR_LINE:		LD	A, (HL)			; Get source
043E82 FE 0D       10198  			CP	CR			; Is it CR
043E84 28 05       10199  			JR	Z, @F
043E86 12          10200  			LD	(DE), A			; No, so store
043E87 23          10201  			INC	HL			; Increment
043E88 13          10202  			INC	DE
043E89 18 F6       10203  			JR	CSTR_LINE		; And loop
043E8B AF          10204  @@:			XOR	A			; Zero terminate the target string
043E8C 12          10205  			LD	(DE), A
043E8D 13          10206  			INC	DE			; And point to next free address
043E8E C9          10207  			RET
043E8F             10208  
043E8F             10209  ; Find the first occurrence of a character (case sensitive)
043E8F             10210  ; HL: Source
043E8F             10211  ;  C: Character to find
043E8F             10212  ; Returns:
043E8F             10213  ; HL: Pointer to character, or end of string marker
043E8F             10214  ;
043E8F 7E          10215  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E90 B9          10216  			CP	C			; Is it our character?
043E91 C8          10217  			RET	Z			; Yes, so exit
043E92 B7          10218  			OR	A			; Is it the end of string?
043E93 C8          10219  			RET	Z			; Yes, so exit
043E94 23          10220  			INC	HL
043E95 18 F8       10221  			JR	CSTR_FINDCH
043E97             10222  
043E97             10223  ; Check whether a string ends with another string (case insensitive)
043E97             10224  ; HL: Source
043E97             10225  ; DE: The substring we want to test with
043E97             10226  ; Returns:
043E97             10227  ;  F: Z if HL ends with DE, otherwise NZ
043E97             10228  ;
043E97 7E          10229  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E98 CD 42 3E 04 10230  			CALL	UPPERC			; Convert to upper case
043E9C 4F          10231  			LD	C, A
043E9D 1A          10232  			LD	A, (DE)			; Get the substring byte
043E9E B9          10233  			CP	C
043E9F C0          10234  			RET	NZ			; Return NZ if at any point the strings don't match
043EA0 B1          10235  			OR	C			; Check whether both bytes are zero
043EA1 C8          10236  			RET	Z			; If so, return, as we have reached the end of both strings
043EA2 23          10237  			INC	HL
043EA3 13          10238  			INC	DE
043EA4 18 F1       10239  			JR	CSTR_ENDSWITH		; And loop
043EA6             10240  
043EA6             10241  ; Concatenate a string onto the end of another string
043EA6             10242  ; HL: Source
043EA6             10243  ; DE: Second string
043EA6             10244  ;
043EA6 7E          10245  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043EA7 B7          10246  			OR	A
043EA8 28 03       10247  			JR	Z, CSTR_CAT_1
043EAA 23          10248  			INC	HL
043EAB 18 F9       10249  			JR	CSTR_CAT
043EAD             10250  ;
043EAD 1A          10251  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043EAE 77          10252  			LD	(HL), A
043EAF B7          10253  			OR	A			; Check for end of string
043EB0 C8          10254  			RET	Z			; And return
043EB1 23          10255  			INC	HL
043EB2 13          10256  			INC	DE
043EB3 18 F8       10257  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043EB5             10258  
043EB5             10259  ; --- Begin patch.asm ---
043EB5             10260  ;
043EB5             10261  ; Title:	BBC Basic for AGON
043EB5             10262  ; Author:	Dean Belfield
043EB5             10263  ; Created:	12/05/2023
043EB5             10264  ; Last Updated:	15/11/2023
043EB5             10265  ;
043EB5             10266  ; Modinfo:
043EB5             10267  ; 11/07/2023:	Fixed *BYE for ADL mode
043EB5             10268  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043EB5             10269  
043EB5             10270  			; .ASSUME	ADL = 1
043EB5             10271  
043EB5             10272  			; INCLUDE	"equs.inc"
043EB5             10273  			; INCLUDE "macros.inc"
043EB5             10274  			; INCLUDE "mos_api.inc"	; In MOS/src
043EB5             10275  
043EB5             10276  			; SEGMENT CODE
043EB5             10277  
043EB5             10278  			; XDEF	OSWRCH
043EB5             10279  			; XDEF	OSLINE
043EB5             10280  			; XDEF	ESCSET
043EB5             10281  			; XDEF	PUTIME
043EB5             10282  			; XDEF	GETIME
043EB5             10283  			; XDEF	PUTCSR
043EB5             10284  			; XDEF 	GETCSR
043EB5             10285  			; XDEF	OSRDCH
043EB5             10286  			; XDEF	PROMPT
043EB5             10287  			; XDEF	OSKEY
043EB5             10288  			; XDEF	TRAP
043EB5             10289  			; XDEF	LTRAP
043EB5             10290  			; XDEF	OSINIT
043EB5             10291  			; XDEF	OSCLI
043EB5             10292  			; XDEF	OSBPUT
043EB5             10293  			; XDEF	OSBGET
043EB5             10294  			; XDEF	OSSTAT
043EB5             10295  			; XDEF	OSSHUT
043EB5             10296  			; XDEF	OSOPEN
043EB5             10297  			; XDEF	OSCALL
043EB5             10298  			; XDEF	GETPTR
043EB5             10299  			; XDEF	PUTPTR
043EB5             10300  			; XDEF	GETEXT
043EB5             10301  			; XDEF	GETIMS
043EB5             10302  			; XDEF	RESET
043EB5             10303  			; XDEF	OSLOAD
043EB5             10304  			; XDEF	OSSAVE
043EB5             10305  			; XDEF	EXPR_W2
043EB5             10306  			; XDEF	STAR_VERSION
043EB5             10307  
043EB5             10308  			; XREF	_end			; In init.asm
043EB5             10309  
043EB5             10310  			; XREF	ASC_TO_NUMBER
043EB5             10311  			; XREF	RAM_START
043EB5             10312  			; XREF	RAM_END
043EB5             10313  			; XREF	FLAGS
043EB5             10314  			; XREF	ESCAPE
043EB5             10315  			; XREF	USER
043EB5             10316  			; XREF	RAM_Top
043EB5             10317  			; XREF	EXTERR
043EB5             10318  			; XREF	COUNT0
043EB5             10319  			; XREF	EXPRI
043EB5             10320  			; XREF	COMMA
043EB5             10321  			; XREF	XEQ
043EB5             10322  			; XREF	NXT
043EB5             10323  			; XREF	NULLTOCR
043EB5             10324  			; XREF	CRLF
043EB5             10325  			; XREF	CSTR_FNAME
043EB5             10326  			; XREF	CSTR_LINE
043EB5             10327  			; XREF	CSTR_FINDCH
043EB5             10328  			; XREF	CSTR_ENDSWITH
043EB5             10329  			; XREF	CSTR_CAT
043EB5             10330  			; XREF	FINDL
043EB5             10331  			; XREF	OUT_
043EB5             10332  			; XREF	ERROR_
043EB5             10333  			; XREF	ONEDIT
043EB5             10334  			; XREF	TELL
043EB5             10335  			; XREF	OSWRCHPT
043EB5             10336  			; XREF	OSWRCHCH
043EB5             10337  			; XREF	OSWRCHFH
043EB5             10338  			; XREF	LISTON
043EB5             10339  			; XREF	LISTIT
043EB5             10340  			; XREF	PAGE_
043EB5             10341  			; XREF	ONEDIT1
043EB5             10342  			; XREF	CLEAN
043EB5             10343  			; XREF	NEWIT
043EB5             10344  			; XREF	BAD
043EB5             10345  			; XREF	VBLANK_INIT
043EB5             10346  			; XREF	VBLANK_STOP
043EB5             10347  			; XREF	KEYDOWN
043EB5             10348  			; XREF	KEYASCII
043EB5             10349  			; XREF	WIDTH
043EB5             10350  			; XREF	ASSEM
043EB5             10351  
043EB5             10352  ; OSLINE: Invoke the line editor
043EB5             10353  ;
043EB5 1E 01       10354  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043EB7             10355  
043EB7             10356  ; Entry point to line editor that does not clear the buffer
043EB7             10357  ;
043EB7 FD E5       10358  OSLINE1:		PUSH	IY
043EB9 E5          10359  			PUSH	HL			; Buffer address
043EBA 01 00 01 00 10360  			LD	BC, 256			; Buffer length
043EBE             10361  			MOSCALL	mos_editline		; Call the MOS line editor
043EBE 3E 09       0001M 			LD	A, function
043EC0 49 CF       0002M 			RST.LIS	08h
043EC2 E1          10362  			POP	HL			; Pop the address
043EC3 FD E1       10363  			POP	IY
043EC5 F5          10364  			PUSH	AF			; Stack the return value (key pressed)
043EC6 CD 57 3E 04 10365  			CALL	NULLTOCR		; Turn the 0 character to a CR
043ECA CD 9D 39 04 10366  			CALL	CRLF			; Display CRLF
043ECE F1          10367  			POP	AF
043ECF FE 1B       10368  			CP	1Bh 			; Check if ESC terminated the input
043ED1 CA CD 3F 04 10369  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043ED5 3A 42 4D 04 10370  			LD	A, (FLAGS)		; Otherwise
043ED9 CB BF       10371  			RES	7, A 			; Clear the escape flag
043EDB 32 42 4D 04 10372  			LD	(FLAGS), A
043EDF CD A4 41 04 10373  			CALL	WAIT_VBLANK 		; Wait a frame
043EE3 AF          10374   			XOR	A			; Return A = 0
043EE4 32 47 4D 04 10375  			LD	(KEYDOWN), A
043EE8 32 48 4D 04 10376  			LD	(KEYASCII), A
043EEC C9          10377  			RET
043EED             10378  
043EED             10379  ; PUTIME: set current time to DE:HL, in centiseconds.
043EED             10380  ;
043EED DD E5       10381  PUTIME:			PUSH 	IX
043EEF             10382  			MOSCALL	mos_sysvars
043EEF 3E 08       0001M 			LD	A, function
043EF1 49 CF       0002M 			RST.LIS	08h
043EF3 DD 75 00    10383  			LD	(IX + sysvar_time + 0), L
043EF6 DD 74 01    10384  			LD	(IX + sysvar_time + 1), H
043EF9 DD 73 02    10385  			LD	(IX + sysvar_time + 2), E
043EFC DD 72 03    10386  			LD	(IX + sysvar_time + 3), D
043EFF DD E1       10387  			POP	IX
043F01 C9          10388  			RET
043F02             10389  
043F02             10390  ; GETIME: return current time in DE:HL, in centiseconds
043F02             10391  ;
043F02 DD E5       10392  GETIME:			PUSH 	IX
043F04             10393  			MOSCALL	mos_sysvars
043F04 3E 08       0001M 			LD	A, function
043F06 49 CF       0002M 			RST.LIS	08h
043F08 DD 6E 00    10394  			LD	L, (IX + sysvar_time + 0)
043F0B DD 66 01    10395  			LD	H, (IX + sysvar_time + 1)
043F0E DD 5E 02    10396  			LD	E, (IX + sysvar_time + 2)
043F11 DD 56 03    10397  			LD	D, (IX + sysvar_time + 3)
043F14 DD E1       10398  			POP	IX
043F16 C9          10399  			RET
043F17             10400  
043F17             10401  ; PUTCSR: move to cursor to x=DE, y=HL
043F17             10402  ;
043F17 3E 1F       10403  PUTCSR:			LD	A, 1Fh			; TAB
043F19 5B D7       10404  			RST.LIL	10h
043F1B 7B          10405  			LD	A, E			; X
043F1C 5B D7       10406  			RST.LIL 10h
043F1E 7D          10407  			LD	A, L			; Y
043F1F 5B D7       10408  			RST.LIL 10h
043F21 C9          10409  			RET
043F22             10410  
043F22             10411  ; GETCSR: return cursor position in x=DE, y=HL
043F22             10412  ;
043F22 DD E5       10413  GETCSR:			PUSH	IX			; Get the system vars in IX
043F24             10414  			MOSCALL	mos_sysvars		; Reset the semaphore
043F24 3E 08       0001M 			LD	A, function
043F26 49 CF       0002M 			RST.LIS	08h
043F28 DD CB 04 86 10415  			RES	0, (IX+sysvar_vpd_pflags)
043F2C             10416  			VDU	23
043F2C 3E 17       0001M 		LD	A, val
043F2E CD 56 3F 04 0002M 		CALL	OSWRCH
043F32             10417  			VDU	0
043F32 3E 00       0001M 		LD	A, val
043F34 CD 56 3F 04 0002M 		CALL	OSWRCH
043F38             10418  			VDU	vdp_cursor
043F38 3E 82       0001M 		LD	A, val
043F3A CD 56 3F 04 0002M 		CALL	OSWRCH
043F3E DD CB 04 46 10419  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F42 28 FA       10420  			JR	Z, @B			; Wait for the result
043F44 16 00       10421  			LD 	D, 0
043F46 62          10422  			LD	H, D
043F47 DD 5E 07    10423  			LD	E, (IX + sysvar_cursorX)
043F4A DD 6E 08    10424  			LD	L, (IX + sysvar_cursorY)
043F4D DD E1       10425  			POP	IX
043F4F C9          10426  			RET
043F50             10427  
043F50             10428  ; PROMPT: output the input prompt
043F50             10429  ;
043F50 3E 3E       10430  PROMPT: 		LD	A,'>'
043F52 C3 56 3F 04 10431  			JP	OSWRCH
043F56             10432  
043F56             10433  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F56             10434  ; A: Character to write
043F56             10435  ;
043F56 E5          10436  OSWRCH:			PUSH	HL
043F57 21 40 4D 04 10437  			LD	HL, LISTON		; Fetch the LISTON variable
043F5B CB 5E       10438  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F5D 20 0B       10439  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F5F             10440  ;
043F5F 2A 45 4D 04 10441  			LD	HL, (OSWRCHCH)		; L: Channel #
043F63 2D          10442  			DEC	L			; If it is 1
043F64 28 10       10443  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F66             10444  ;
043F66 E1          10445  			POP	HL			; Otherwise
043F67 5B D7       10446  			RST.LIL	10h			; Output the character to MOS
043F69 C9          10447  			RET
043F6A             10448  ;
043F6A 2A 43 4D 04 10449  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F6E 77          10450  			LD	(HL), A			; Echo the character into the buffer
043F6F 23          10451  			INC	HL			; Increment pointer
043F70 22 43 4D 04 10452  			LD	(OSWRCHPT), HL		; Write pointer back
043F74 E1          10453  			POP	HL
043F75 C9          10454  			RET
043F76             10455  ;
043F76 D5          10456  OSWRCH_FILE:		PUSH	DE
043F77 5C          10457  			LD	E, H			; Filehandle to E
043F78 CD A2 43 04 10458  			CALL	OSBPUT			; Write the byte out
043F7C D1          10459  			POP	DE
043F7D E1          10460  			POP	HL
043F7E C9          10461  			RET
043F7F             10462  
043F7F             10463  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F7F             10464  ; This is only called in GETS (eval.asm)
043F7F             10465  ;
043F7F             10466  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F7F 3E 00       0001M 			LD	A, function
043F81 49 CF       0002M 			RST.LIS	08h
043F83 FE 1B       10467  			CP	1Bh
043F85 28 46       10468  			JR	Z, LTRAP1
043F87 C9          10469  			RET
043F88             10470  
043F88             10471  
043F88             10472  ;OSKEY - Read key with time-limit, test for ESCape.
043F88             10473  ;Main function is carried out in user patch.
043F88             10474  ;   Inputs: HL = time limit (centiseconds)
043F88             10475  ;  Outputs: Carry reset if time-out
043F88             10476  ;           If carry set A = character
043F88             10477  ; Destroys: A,H,L,F
043F88             10478  ;
043F88 CD B9 3F 04 10479  OSKEY:			CALL	READKEY			; Read the keyboard
043F8C 28 0A       10480  			JR	Z, @F 			; Skip if we have a key
043F8E 7C          10481  			LD	A, H 			; Check loop counter
043F8F B5          10482  			OR 	L
043F90 C8          10483  			RET 	Z 			; Return, we've not got a key at this point
043F91 CD A4 41 04 10484  			CALL	WAIT_VBLANK 		; Wait a frame
043F95 2B          10485  			DEC 	HL			; Decrement
043F96 18 F0       10486  			JR	OSKEY 			; And loop
043F98             10487  ;
043F98 21 47 4D 04 10488  @@:			LD	HL, KEYDOWN		; We have a key, so
043F9C 36 00       10489  			LD	(HL), 0			; clear the keydown flag
043F9E FE 1B       10490  			CP	1BH			; If we are not pressing ESC,
043FA0 37          10491  			SCF 				; then flag we've got a character
043FA1 C0          10492  			RET	NZ
043FA2             10493  ;
043FA2             10494  ; ESCSET
043FA2             10495  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043FA2             10496  ;
043FA2 E5          10497  ESCSET: 		PUSH    HL
043FA3 21 42 4D 04 10498          		LD      HL,FLAGS		; Pointer to FLAGS
043FA7 CB 76       10499          		BIT     6,(HL)			; If bit 6 is set, then
043FA9 20 02       10500          		JR      NZ,ESCDIS		; escape is disabled, so skip
043FAB CB FE       10501          		SET     7,(HL)			; Set bit 7, the escape flag
043FAD E1          10502  ESCDIS: 		POP     HL
043FAE C9          10503          		RET
043FAF             10504  ;
043FAF             10505  ; ESCTEST
043FAF             10506  ; Test for ESC key
043FAF             10507  ;
043FAF CD B9 3F 04 10508  ESCTEST:		CALL	READKEY			; Read the keyboard
043FB3 C0          10509  			RET	NZ			; Skip if no key is pressed
043FB4 FE 1B       10510  			CP	1BH			; If ESC pressed then
043FB6 28 EA       10511  			JR	Z,ESCSET		; jump to the escape set routine
043FB8 C9          10512  			RET
043FB9             10513  
043FB9             10514  ; Read the keyboard
043FB9             10515  ; Returns:
043FB9             10516  ; - A: ASCII of the pressed key
043FB9             10517  ; - F: Z if the key is pressed, otherwise NZ
043FB9             10518  ;
043FB9 3A 47 4D 04 10519  READKEY:		LD	A, (KEYDOWN)		; Get key down
043FBD 3D          10520  			DEC	A 			; Set Z flag if keydown is 1
043FBE 3A 48 4D 04 10521  			LD	A, (KEYASCII)		; Get key ASCII value
043FC2 C9          10522  			RET
043FC3             10523  ;
043FC3             10524  ; TRAP
043FC3             10525  ; This is called whenever BASIC needs to check for ESC
043FC3             10526  ;
043FC3 CD AF 3F 04 10527  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FC7             10528  ;
043FC7 3A 42 4D 04 10529  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FCB B7          10530  			OR	A			; This checks for bit 7; if it is not set then the result will
043FCC F0          10531  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FCD 21 42 4D 04 10532  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FD1 CB BE       10533  			RES	7,(HL)			; Clear the escape pressed flag and
043FD3 C3 A3 0C 04 10534  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FD7             10535  
043FD7             10536  ;OSINIT - Initialise RAM mapping etc.
043FD7             10537  ;If BASIC is entered by BBCBASIC FILENAME then file
043FD7             10538  ;FILENAME.BBC is automatically CHAINed.
043FD7             10539  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043FD7             10540  ;            HL = initial value of PAGE (user program)
043FD7             10541  ;            Z-flag reset indicates AUTO-RUN.
043FD7             10542  ;  Destroys: A,D,E,H,L,F
043FD7             10543  ;
043FD7 CD 3C 49 04 10544  OSINIT:			CALL	VBLANK_INIT
043FDB AF          10545  			XOR	A
043FDC 21 00 4E 04 10546  			LD 	HL, USER
043FE0 11 00 00 0B 10547  			LD	DE, RAM_Top
043FE4 5F          10548  			LD	E, A			; Page boundary
043FE5 C9          10549  			RET
043FE6             10550  
043FE6             10551  ;
043FE6             10552  ;OSCLI - Process a MOS command
043FE6             10553  ;
043FE6 CD 5A 40 04 10554  OSCLI: 			CALL    SKIPSP
043FEA FE 0D       10555  			CP      CR
043FEC C8          10556  			RET     Z
043FED FE 7C       10557  			CP      '|'
043FEF C8          10558  			RET     Z
043FF0 EB          10559  			EX      DE,HL
043FF1 21 69 40 04 10560  			LD      HL,COMDS
043FF5 1A          10561  OSCLI0:			LD      A,(DE)
043FF6 CD 61 40 04 10562  			CALL    UPPRC
043FFA BE          10563  			CP      (HL)
043FFB 28 0B       10564  			JR      Z,OSCLI2
043FFD 38 30       10565  			JR      C,OSCLI6
043FFF CB 7E       10566  OSCLI1:			BIT     7,(HL)
044001 23          10567  			INC     HL
044002 28 FB       10568  			JR      Z,OSCLI1
044004 23          10569  			INC     HL
044005 23          10570  			INC     HL
044006 18 ED       10571  			JR      OSCLI0
044008             10572  ;
044008 D5          10573  OSCLI2:			PUSH    DE
044009 13          10574  OSCLI3:			INC     DE
04400A 23          10575  			INC     HL
04400B 1A          10576  			LD      A,(DE)
04400C CD 61 40 04 10577  			CALL    UPPRC
044010 FE 2E       10578  			CP      '.'			; ABBREVIATED?
044012 28 0A       10579  			JR      Z,OSCLI4
044014 AE          10580  			XOR     (HL)
044015 28 F2       10581  			JR      Z,OSCLI3
044017 FE 80       10582  			CP      80H
044019 28 03       10583  			JR      Z,OSCLI4
04401B D1          10584  			POP     DE
04401C 18 E1       10585  			JR      OSCLI1
04401E             10586  ;
04401E F1          10587  OSCLI4:			POP     AF
04401F 13          10588  		        INC     DE
044020 CB 7E       10589  OSCLI5:			BIT     7,(HL)
044022 23          10590  			INC     HL
044023 28 FB       10591  			JR      Z,OSCLI5
044025 7E          10592  			LD      A,(HL)
044026 23          10593  			INC     HL
044027 66          10594  			LD      H,(HL)
044028 6F          10595  			LD      L,A
044029 E5          10596  			PUSH    HL
04402A EB          10597  			EX      DE,HL
04402B C3 5A 40 04 10598  			JP      SKIPSP
04402F             10599  ;
04402F EB          10600  OSCLI6:			EX	DE, HL			; HL: Buffer for command
044030 11 00 4A 04 10601  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
044034 D5          10602  			PUSH	DE			; Store buffer address
044035 CD 81 3E 04 10603  			CALL	CSTR_LINE		; Fetch the line
044039 E1          10604  			POP	HL			; HL: Pointer to command string in ACCS
04403A FD E5       10605  			PUSH	IY
04403C             10606  			MOSCALL	mos_oscli		; Returns OSCLI error in A
04403C 3E 10       0001M 			LD	A, function
04403E 49 CF       0002M 			RST.LIS	08h
044040 FD E1       10607  			POP	IY
044042 B7          10608  			OR	A			; 0 means MOS returned OK
044043 C8          10609  			RET	Z			; So don't do anything
044044 C3 7E 42 04 10610  			JP 	OSERROR			; Otherwise it's a MOS error
044048             10611  
044048 3E FE       10612  HUH:    		LD      A,254			; Bad command error
04404A CD CD 37 04 10613          		CALL    EXTERR
04404E 42 61 64 20 10614          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044059 00          10615          		DEFB    0
04405A             10616  
04405A 7E          10617  SKIPSP:			LD      A,(HL)
04405B FE 20       10618          		CP      ' '
04405D C0          10619          		RET     NZ
04405E 23          10620          		INC     HL
04405F 18 F9       10621          		JR      SKIPSP
044061             10622  
044061 E6 7F       10623  UPPRC:  		AND     7FH
044063 FE 60       10624  			CP      '`'
044065 D8          10625  			RET     C
044066 E6 5F       10626  			AND     5FH			; CONVERT TO UPPER CASE
044068 C9          10627  			RET
044069             10628  
044069             10629  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044069             10630  ; These must be in alphabetical order
044069             10631  ;
044069 41 53 4D    10632  COMDS:  		DB	"AS","M"+80h		; ASM
04406C 87 40       10633  			DW	STAR_ASM
04406E 42 59 45    10634  			DB	"BY","E"+80h		; BYE
044071 93 40       10635  			DW	STAR_BYE
044073 45 44 49 54 10636  			DB	"EDI","T"+80h		; EDIT
044077 C8 40       10637  			DW	STAR_EDIT
044079 46 58       10638  			DB	"F","X"+80h		; FX
04407B 08 41       10639  			DW	STAR_FX
04407D 56 45 52 53 10640  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
044084 9F 40       10641  			DW	STAR_VERSION
044086 FF          10642  			DB	FFh
044087             10643  
044087             10644  ; *ASM string
044087             10645  ;
044087 FD E5       10646  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044089 E5          10647  			PUSH	HL			; HL = IY
04408A FD E1       10648  			POP	IY
04408C CD CD 18 04 10649  			CALL	ASSEM			; Invoke the assembler
044090 FD E1       10650  			POP	IY
044092 C9          10651  			RET
044093             10652  
044093             10653  ; *BYE
044093             10654  ;
044093 CD 50 49 04 10655  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044097 21 00 00 00 10656  			LD	HL, 0			; The return value
04409B C3 68 00 04 10657  			JP	_end 			; Jump back to the end routine in init.asm
04409F             10658  
04409F             10659  ; *VERSION
04409F             10660  ;
04409F CD E6 3D 04 10661  STAR_VERSION:		CALL    TELL			; Output the welcome message
0440A3 42 42 43 20 10662  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0440C7 C9          10663  			RET
0440C8             10664  
0440C8             10665  ; *EDIT linenum
0440C8             10666  ;
0440C8 CD ED 3D 04 10667  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440CC EB          10668  			EX	DE, HL			; HL: Line number
0440CD CD E5 39 04 10669  			CALL	FINDL			; HL: Address in RAM of tokenised line
0440D1 3E 29       10670  			LD	A, 41			; F:NZ If the line is not found
0440D3 C2 B6 37 04 10671  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0440D7             10672  ;
0440D7             10673  ; Use LISTIT to output the line to the ACCS buffer
0440D7             10674  ;
0440D7 23          10675  			INC	HL			; Skip the length byte
0440D8 5E          10676  			LD	E, (HL)			; Fetch the line number
0440D9 23          10677  			INC	HL
0440DA 56          10678  			LD	D, (HL)
0440DB 23          10679  			INC	HL
0440DC DD 21 00 4A 10680  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0440E1 DD 22 43 4D 10681  			LD	(OSWRCHPT), IX
       04          
0440E6 DD 21 40 4D 10682  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0440EB DD 7E 00    10683  			LD	A, (IX)			; Store that variable
0440EE F5          10684  			PUSH	AF
0440EF DD 36 00 09 10685  			LD	(IX), 09h		; Set to echo to buffer
0440F3 CD E8 38 04 10686  			CALL	LISTIT
0440F7 F1          10687  			POP	AF
0440F8 DD 77 00    10688  			LD	(IX), A			; Restore the original LISTON variable
0440FB 21 00 4A 04 10689  			LD	HL, ACCS		; HL: ACCS
0440FF 5D          10690  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044100 CD B7 3E 04 10691  			CALL	OSLINE1			; Invoke the editor
044104 C3 26 31 04 10692  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
044108             10693  
044108             10694  ; OSCLI FX n
044108             10695  ;
044108 CD ED 3D 04 10696  STAR_FX:		CALL	ASC_TO_NUMBER
04410C 4B          10697  			LD	C, E			; C: Save FX #
04410D CD ED 3D 04 10698  			CALL	ASC_TO_NUMBER
044111 7A          10699  			LD	A, D  			; Is first parameter > 255?
044112 B7          10700  			OR 	A
044113 28 03       10701  			JR	Z, STAR_FX1		; Yes, so skip next bit
044115 EB          10702  			EX	DE, HL 			; Parameter is 16-bit
044116 18 07       10703  			JR	STAR_FX2
044118             10704  ;
044118 43          10705  STAR_FX1:		LD	B, E 			; B: Save First parameter
044119 CD ED 3D 04 10706  			CALL	ASC_TO_NUMBER		; Fetch second parameter
04411D 68          10707  			LD	L, B 			; L: First parameter
04411E 63          10708  			LD	H, E 			; H: Second parameter
04411F             10709  ;
04411F 79          10710  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
044120             10711  ;
044120             10712  ; OSBYTE
044120             10713  ;  A: FX #
044120             10714  ;  L: First parameter
044120             10715  ;  H: Second parameter
044120             10716  ;
044120 FE 0B       10717  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
044122 28 18       10718  			JR	Z, OSBYTE_0B
044124 FE 0C       10719  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044126 28 43       10720  			JR	Z, OSBYTE_0C
044128 FE 13       10721  			CP	13H			; *FX 19: Wait for vblank
04412A 28 6E       10722  			JR	Z, OSBYTE_13
04412C FE 76       10723  			CP	76H			; *FX 118, n: Set keyboard LED
04412E CA B5 41 04 10724  			JP	Z, OSBYTE_76
044132 FE A0       10725  			CP	A0H
044134 CA E5 41 04 10726  			JP	Z, OSBYTE_A0
044138 C3 48 40 04 10727  			JP	HUH			; Anything else trips an error
04413C             10728  
04413C             10729  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
04413C             10730  ; Parameters:
04413C             10731  ; - HL: Repeat delay
04413C             10732  ;
04413C             10733  OSBYTE_0B:		VDU	23
04413C 3E 17       0001M 		LD	A, val
04413E CD 56 3F 04 0002M 		CALL	OSWRCH
044142             10734  			VDU	0
044142 3E 00       0001M 		LD	A, val
044144 CD 56 3F 04 0002M 		CALL	OSWRCH
044148             10735  			VDU	vdp_keystate
044148 3E 88       0001M 		LD	A, val
04414A CD 56 3F 04 0002M 		CALL	OSWRCH
04414E             10736  			VDU	L
04414E 7D          0001M 		LD	A, val
04414F CD 56 3F 04 0002M 		CALL	OSWRCH
044153             10737  			VDU	H
044153 7C          0001M 		LD	A, val
044154 CD 56 3F 04 0002M 		CALL	OSWRCH
044158             10738  			VDU	0
044158 3E 00       0001M 		LD	A, val
04415A CD 56 3F 04 0002M 		CALL	OSWRCH
04415E             10739  			VDU 	0
04415E 3E 00       0001M 		LD	A, val
044160 CD 56 3F 04 0002M 		CALL	OSWRCH
044164             10740  			VDU	255
044164 3E FF       0001M 		LD	A, val
044166 CD 56 3F 04 0002M 		CALL	OSWRCH
04416A C9          10741  			RET
04416B             10742  
04416B             10743  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
04416B             10744  ; Parameters:
04416B             10745  ; - HL: Repeat rate
04416B             10746  ;
04416B             10747  OSBYTE_0C:		VDU	23
04416B 3E 17       0001M 		LD	A, val
04416D CD 56 3F 04 0002M 		CALL	OSWRCH
044171             10748  			VDU	0
044171 3E 00       0001M 		LD	A, val
044173 CD 56 3F 04 0002M 		CALL	OSWRCH
044177             10749  			VDU	vdp_keystate
044177 3E 88       0001M 		LD	A, val
044179 CD 56 3F 04 0002M 		CALL	OSWRCH
04417D             10750  			VDU	0
04417D 3E 00       0001M 		LD	A, val
04417F CD 56 3F 04 0002M 		CALL	OSWRCH
044183             10751  			VDU 	0
044183 3E 00       0001M 		LD	A, val
044185 CD 56 3F 04 0002M 		CALL	OSWRCH
044189             10752  			VDU	L
044189 7D          0001M 		LD	A, val
04418A CD 56 3F 04 0002M 		CALL	OSWRCH
04418E             10753  			VDU	H
04418E 7C          0001M 		LD	A, val
04418F CD 56 3F 04 0002M 		CALL	OSWRCH
044193             10754  			VDU	255
044193 3E FF       0001M 		LD	A, val
044195 CD 56 3F 04 0002M 		CALL	OSWRCH
044199 C9          10755  			RET
04419A             10756  
04419A             10757  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
04419A             10758  ;
04419A CD A4 41 04 10759  OSBYTE_13:		CALL	WAIT_VBLANK
04419E 2E 00       10760  			LD	L, 0			; Returns 0
0441A0 C3 84 05 04 10761  			JP	COUNT0
0441A4             10762  ;
0441A4 DD E5       10763  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0441A6             10764  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441A6 3E 08       0001M 			LD	A, function
0441A8 49 CF       0002M 			RST.LIS	08h
0441AA DD 7E 00    10765  			LD	A, (IX + sysvar_time + 0)
0441AD DD BE 00    10766  @@:			CP 	A, (IX + sysvar_time + 0)
0441B0 28 FB       10767  			JR	Z, @B
0441B2 DD E1       10768  			POP	IX
0441B4 C9          10769  			RET
0441B5             10770  
0441B5             10771  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0441B5             10772  ; Parameters:
0441B5             10773  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0441B5             10774  ;
0441B5             10775  OSBYTE_76:		VDU	23
0441B5 3E 17       0001M 		LD	A, val
0441B7 CD 56 3F 04 0002M 		CALL	OSWRCH
0441BB             10776  			VDU	0
0441BB 3E 00       0001M 		LD	A, val
0441BD CD 56 3F 04 0002M 		CALL	OSWRCH
0441C1             10777  			VDU	vdp_keystate
0441C1 3E 88       0001M 		LD	A, val
0441C3 CD 56 3F 04 0002M 		CALL	OSWRCH
0441C7             10778  			VDU	0
0441C7 3E 00       0001M 		LD	A, val
0441C9 CD 56 3F 04 0002M 		CALL	OSWRCH
0441CD             10779  			VDU 	0
0441CD 3E 00       0001M 		LD	A, val
0441CF CD 56 3F 04 0002M 		CALL	OSWRCH
0441D3             10780  			VDU	0
0441D3 3E 00       0001M 		LD	A, val
0441D5 CD 56 3F 04 0002M 		CALL	OSWRCH
0441D9             10781  			VDU	0
0441D9 3E 00       0001M 		LD	A, val
0441DB CD 56 3F 04 0002M 		CALL	OSWRCH
0441DF             10782  			VDU	L
0441DF 7D          0001M 		LD	A, val
0441E0 CD 56 3F 04 0002M 		CALL	OSWRCH
0441E4 C9          10783  			RET
0441E5             10784  
0441E5             10785  ; OSBYTE 0xA0: Fetch system variable
0441E5             10786  ; Parameters:
0441E5             10787  ; - L: The system variable to fetch
0441E5             10788  ;
0441E5 DD E5       10789  OSBYTE_A0:		PUSH	IX
0441E7             10790  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441E7 3E 08       0001M 			LD	A, function
0441E9 49 CF       0002M 			RST.LIS	08h
0441EB 01 00 00 00 10791  			LD	BC, 0
0441EF 4D          10792  			LD	C, L			; BCU = L
0441F0 DD 09       10793  			ADD	IX, BC			; Add to IX
0441F2 DD 6E 00    10794  			LD	L, (IX + 0)		; Fetch the return value
0441F5 DD E1       10795  			POP	IX
0441F7 C3 84 05 04 10796  			JP 	COUNT0
0441FB             10797  
0441FB             10798  ;OSLOAD - Load an area of memory from a file.
0441FB             10799  ;   Inputs: HL addresses filename (CR terminated)
0441FB             10800  ;           DE = address at which to load
0441FB             10801  ;           BC = maximum allowed size (bytes)
0441FB             10802  ;  Outputs: Carry reset indicates no room for file.
0441FB             10803  ; Destroys: A,B,C,D,E,H,L,F
0441FB             10804  ;
0441FB C5          10805  OSLOAD:			PUSH	BC			; Stack the size
0441FC D5          10806  			PUSH	DE			; Stack the load address
0441FD 11 00 4A 04 10807  			LD	DE, ACCS		; Buffer address for filename
044201 CD 6F 3E 04 10808  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044205 21 00 4A 04 10809  			LD	HL, ACCS		; HL: Filename
044209 CD FB 42 04 10810  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04420D CD 0F 43 04 10811  			CALL	EXT_HANDLER		; Get the default handler
044211 D1          10812  			POP	DE			; Restore the load address
044212 C1          10813  			POP	BC			; Restore the size
044213 B7          10814  			OR	A
044214 28 60       10815  			JR 	Z, OSLOAD_BBC
044216             10816  ;
044216             10817  ; Load the file in as a text file
044216             10818  ;
044216 AF          10819  OSLOAD_TXT:		XOR	A			; Set file attributes to read
044217 CD 83 43 04 10820  			CALL	OSOPEN			; Open the file
04421B 5F          10821  			LD 	E, A 			; The filehandle
04421C B7          10822  			OR	A
04421D 3E 04       10823  			LD	A, 4			; File not found error
04421F 28 5D       10824  			JR	Z, OSERROR		; Jump to error handler
044221 CD C2 38 04 10825  			CALL	NEWIT			; Call NEW to clear the program space
044225             10826  ;
044225 21 00 4A 04 10827  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044229             10828  ;
044229             10829  ; First skip any whitespace (indents) at the beginning of the input
044229             10830  ;
044229 CD 9A 43 04 10831  @@:			CALL	OSBGET			; Read the byte into A
04422D 38 1E       10832  			JR	C, OSLOAD_TXT3		; Is it EOF?
04422F FE 0A       10833  			CP	LF 			; Is it LF?
044231 28 1A       10834  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
044233 FE 21       10835  			CP	21h			; Is it less than or equal to ASCII space?
044235 38 F2       10836  			JR	C, @B 			; Yes, so keep looping
044237 77          10837  			LD	(HL), A 		; Store the first character
044238 2C          10838  			INC	L
044239             10839  ;
044239             10840  ; Now read the rest of the line in
044239             10841  ;
044239 CD 9A 43 04 10842  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
04423D 38 2B       10843  			JR	C, OSLOAD_TXT4		; Is it EOF?
04423F FE 20       10844  			CP	20h			; Skip if not an ASCII character
044241 38 06       10845  			JR	C, @F
044243 77          10846  			LD	(HL), A 		; Store in the input buffer
044244 2C          10847  			INC	L			; Increment the buffer pointer
044245 CA 4E 37 04 10848  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044249 FE 0A       10849  @@:			CP	LF			; Check for LF
04424B 20 EC       10850  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
04424D             10851  ;
04424D             10852  ; Finally, handle EOL/EOF
04424D             10853  ;
04424D 36 0D       10854  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
04424F 7D          10855  			LD	A, L			; Check for minimum line length
044250 FE 02       10856  			CP	2			; If it is 2 characters or less (including CR)
044252 38 0A       10857  			JR	C, @F			; Then don't bother entering it
044254 D5          10858  			PUSH	DE			; Preserve the filehandle
044255 CD 32 31 04 10859  			CALL	ONEDIT1			; Enter the line in memory
044259 DC 95 38 04 10860  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
04425D D1          10861  			POP	DE
04425E CD AB 43 04 10862  @@:			CALL	OSSTAT			; End of file?
044262 20 C1       10863  			JR	NZ, OSLOAD_TXT1		; No, so loop
044264 CD 92 43 04 10864  			CALL	OSSHUT			; Close the file
044268 37          10865  			SCF				; Flag to BASIC that we're good
044269 C9          10866  			RET
04426A             10867  ;
04426A             10868  ; Special case for BASIC programs with no blank line at the end
04426A             10869  ;
04426A FE 20       10870  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
04426C 38 06       10871  			JR	C, @F
04426E 77          10872  			LD	(HL), A			; Store the character
04426F 2C          10873  			INC	L
044270 CA 4E 37 04 10874  			JP	Z, BAD
044274 18 D7       10875  @@:			JR	OSLOAD_TXT3
044276             10876  
044276             10877  ;
044276             10878  ; Load the file in as a tokenised binary blob
044276             10879  ;
044276             10880  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044276 3E 01       0001M 			LD	A, function
044278 49 CF       0002M 			RST.LIS	08h
04427A D0          10881  			RET	NC			; If load returns with carry reset - NO ROOM
04427B B7          10882  			OR	A			; If there is no error (A=0)
04427C 37          10883  			SCF				; Need to set carry indicating there was room
04427D C8          10884  			RET	Z			; Return
04427E             10885  ;
04427E F5          10886  OSERROR:		PUSH	AF			; Handle the MOS error
04427F 21 00 4A 04 10887  			LD	HL, ACCS		; Address of the buffer
044283 01 00 01 00 10888  			LD	BC, 256			; Length of the buffer
044287 5F          10889  			LD	E, A			; The error code
044288             10890  			MOSCALL	mos_getError		; Copy the error message into the buffer
044288 3E 0F       0001M 			LD	A, function
04428A 49 CF       0002M 			RST.LIS	08h
04428C F1          10891  			POP	AF
04428D E5          10892  			PUSH	HL			; Stack the address of the error (now in ACCS)
04428E C6 7F       10893  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044290 C3 CD 37 04 10894  			JP	EXTERR			; Trigger an external error
044294             10895  
044294             10896  ;OSSAVE - Save an area of memory to a file.
044294             10897  ;   Inputs: HL addresses filename (term CR)
044294             10898  ;           DE = start address of data to save
044294             10899  ;           BC = length of data to save (bytes)
044294             10900  ; Destroys: A,B,C,D,E,H,L,F
044294             10901  ;
044294 C5          10902  OSSAVE:			PUSH	BC			; Stack the size
044295 D5          10903  			PUSH	DE			; Stack the save address
044296 11 00 4A 04 10904  			LD	DE, ACCS		; Buffer address for filename
04429A CD 6F 3E 04 10905  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04429E 21 00 4A 04 10906  			LD	HL, ACCS		; HL: Filename
0442A2 CD FB 42 04 10907  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0442A6 CD 0F 43 04 10908  			CALL	EXT_HANDLER		; Get the default handler
0442AA D1          10909  			POP	DE			; Restore the save address
0442AB C1          10910  			POP	BC			; Restore the size
0442AC B7          10911  			OR	A			; Is the extension .BBC
0442AD 28 44       10912  			JR	Z, OSSAVE_BBC		; Yes, so use that
0442AF             10913  ;
0442AF             10914  ; Save the file out as a text file
0442AF             10915  ;
0442AF 3A 45 4D 04 10916  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0442B3 F5          10917  			PUSH	AF
0442B4 AF          10918  			XOR	A
0442B5 3C          10919  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0442B6 32 45 4D 04 10920  			LD	(OSWRCHCH), A
0442BA CD 83 43 04 10921  			CALL	OSOPEN			; Open the file
0442BE 32 46 4D 04 10922  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0442C2 DD 21 40 4D 10923  			LD	IX, LISTON		; Required for LISTIT
       04          
0442C7 2A 14 4D 04 10924  			LD	HL, (PAGE_)		; Get start of program area
0442CB D9          10925  			EXX
0442CC 01 00 00 00 10926  			LD	BC, 0			; Set the initial indent counters
0442D0 D9          10927  			EXX
0442D1 7E          10928  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442D2 B7          10929  			OR	A
0442D3 28 0F       10930  			JR	Z, OSSAVE_TXT2
0442D5 23          10931  			INC	HL			; Skip the length byte
0442D6 11 00 00 00 10932  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442DA 5E          10933  			LD	E, (HL)			; Get the line number
0442DB 23          10934  			INC	HL
0442DC 56          10935  			LD	D, (HL)
0442DD 23          10936  			INC	HL
0442DE CD E8 38 04 10937  			CALL	LISTIT			; List the line
0442E2 18 ED       10938  			JR	OSSAVE_TXT1
0442E4 3A 46 4D 04 10939  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442E8 5F          10940  			LD	E, A
0442E9 CD 92 43 04 10941  			CALL	OSSHUT			; Close it
0442ED F1          10942  			POP	AF			; Restore the channel
0442EE 32 45 4D 04 10943  			LD	(OSWRCHCH), A
0442F2 C9          10944  			RET
0442F3             10945  ;
0442F3             10946  ; Save the file out as a tokenised binary blob
0442F3             10947  ;
0442F3             10948  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442F3 3E 02       0001M 			LD	A, function
0442F5 49 CF       0002M 			RST.LIS	08h
0442F7 B7          10949  			OR	A			; If there is no error (A=0)
0442F8 C8          10950  			RET	Z			; Just return
0442F9 18 83       10951  			JR	OSERROR			; Trip an error
0442FB             10952  
0442FB             10953  ; Check if an extension is specified in the filename
0442FB             10954  ; Add a default if not specified
0442FB             10955  ; HL: Filename (CSTR format)
0442FB             10956  ;
0442FB E5          10957  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442FC 0E 2E       10958  			LD	C, '.'			; Search for dot (marks start of extension)
0442FE CD 8F 3E 04 10959  			CALL	CSTR_FINDCH
044302 B7          10960  			OR	A			; Check for end of string marker
044303 20 08       10961  			JR	NZ, @F			; No, so skip as we have an extension at this point
044305 11 3F 43 04 10962  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
044309 CD A6 3E 04 10963  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
04430D E1          10964  @@:			POP	HL			; Restore the filename pointer
04430E C9          10965  			RET
04430F             10966  
04430F             10967  ; Check if an extension is valid and, if so, provide a pointer to a handler
04430F             10968  ; HL: Filename (CSTR format)
04430F             10969  ; Returns:
04430F             10970  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
04430F             10971  ;
04430F E5          10972  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
044310 0E 2E       10973  			LD	C, '.'			; Find the '.'
044312 CD 8F 3E 04 10974  			CALL	CSTR_FINDCH
044316 11 3F 43 04 10975  			LD	DE, EXT_LOOKUP		; The lookup table
04431A             10976  ;
04431A E5          10977  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
04431B CD 97 3E 04 10978  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
04431F E1          10979  			POP	HL			; Restore the pointer to the extension
044320 28 19       10980  			JR	Z, EXT_HANDLER_2	; We have a match!
044322             10981  ;
044322 1A          10982  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
044323 13          10983  			INC	DE
044324 B7          10984  			OR	A
044325 20 FB       10985  			JR	NZ, @B
044327 13          10986  			INC	DE			; Skip the file extension # byte
044328             10987  ;
044328 1A          10988  			LD	A, (DE)			; Are we at the end of the table?
044329 B7          10989  			OR	A
04432A 20 EE       10990  			JR	NZ, EXT_HANDLER_1	; No, so loop
04432C             10991  ;
04432C 3E CC       10992  			LD      A,204			; Throw a "Bad name" error
04432E CD CD 37 04 10993          		CALL    EXTERR
044332 42 61 64 20 10994          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
04433B             10995  ;
04433B 13          10996  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
04433C 1A          10997  			LD	A, (DE)
04433D E1          10998  			POP	HL			; Restore the filename pointer
04433E C9          10999  			RET
04433F             11000  ;
04433F             11001  
04433F             11002  
04433F             11003  ; Extension lookup table
04433F             11004  ; CSTR, TYPE
04433F             11005  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
04433F             11006  ; 	- 1: Human readable plain text
04433F             11007  ;
04433F 2E 42 42 43 11008  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
044345 2E 54 58 54 11009  			DB	".TXT", 0, 1
       00 01       
04434B 2E 41 53 43 11010  			DB	".ASC", 0, 1
       00 01       
044351 2E 42 41 53 11011  			DB	".BAS", 0, 1
       00 01       
044357 00          11012  			DB	0			; End of table
044358             11013  
044358             11014  ;OSCALL - Intercept page &FF calls and provide an alternative address
044358             11015  ;
044358             11016  ;&FFF7:	OSCLI	Execute *command.
044358             11017  ;&FFF4:	OSBYTE	Various byte-wide functions.
044358             11018  ;&FFF1:	OSWORD	Various control block functions.
044358             11019  ;&FFEE:	OSWRCH	Write character to output stream.
044358             11020  ;&FFE7:	OSNEWL	Write NewLine to output stream.
044358             11021  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
044358             11022  ;&FFE0:	OSRDCH	Wait for character from input stream.
044358             11023  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
044358             11024  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
044358             11025  ;&FFD7:	OSBGET	Read a byte from an a channel.
044358             11026  ;&FFD4:	OSBPUT	Write a byte to a channel.
044358             11027  ;&FFD1:	OSGBPB	Read and write blocks of data.
044358             11028  ;&FFCE:	OSFIND	Open or close a file.
044358             11029  ;
044358 21 6E 43 04 11030  OSCALL:			LD	HL, OSCALL_TABLE
04435C 7E          11031  OSCALL_1:		LD	A, (HL)
04435D 23          11032  			INC	HL
04435E FE FF       11033  			CP	FFh
044360 C8          11034  			RET	Z
044361 FD BD       11035  			CP	A, IYL
044363 28 06       11036  			JR	Z, OSCALL_2
044365 D0          11037  			RET	NC
044366 23          11038  			INC	HL
044367 23          11039  			INC	HL
044368 23          11040  			INC	HL
044369 18 F1       11041  			JR	OSCALL_1
04436B ED 31       11042  OSCALL_2:		LD	IY,(HL)
04436D C9          11043  			RET
04436E D4          11044  OSCALL_TABLE:		DB 	D4h
04436F A2 43 04    11045  			DW24 	OSBPUT
044372 D7          11046  			DB 	D7h
044373 9A 43 04    11047  			DW24 	OSBGET
044376 EE          11048  			DB 	EEh
044377 56 3F 04    11049  			DW24 	OSWRCH
04437A F4          11050  			DB	F4h
04437B 20 41 04    11051  			DW24 	OSBYTE
04437E F7          11052  			DB	F7h
04437F E6 3F 04    11053  			DW24	OSCLI
044382 FF          11054  			DB	FFh
044383             11055  
044383             11056  ; OSOPEN
044383             11057  ; HL: Pointer to path
044383             11058  ;  F: C Z
044383             11059  ;     x x OPENIN
044383             11060  ; 	  OPENOUT
044383             11061  ;     x	  OPENUP
044383             11062  ; Returns:
044383             11063  ;  A: Filehandle, 0 if cannot open
044383             11064  ;
044383 0E 01       11065  OSOPEN:			LD	C, fa_read
044385 28 06       11066  			JR	Z, @F
044387 0E 32       11067  			LD	C, fa_write | fa_open_append
044389 38 02       11068  			JR	C, @F
04438B 0E 0A       11069  			LD	C, fa_write | fa_create_always
04438D             11070  @@:			MOSCALL	mos_fopen
04438D 3E 0A       0001M 			LD	A, function
04438F 49 CF       0002M 			RST.LIS	08h
044391 C9          11071  			RET
044392             11072  
044392             11073  ;OSSHUT - Close disk file(s).
044392             11074  ; E = file channel
044392             11075  ;  If E=0 all files are closed (except SPOOL)
044392             11076  ; Destroys: A,B,C,D,E,H,L,F
044392             11077  ;
044392 C5          11078  OSSHUT:			PUSH	BC
044393 4B          11079  			LD	C, E
044394             11080  			MOSCALL	mos_fclose
044394 3E 0B       0001M 			LD	A, function
044396 49 CF       0002M 			RST.LIS	08h
044398 C1          11081  			POP	BC
044399 C9          11082  			RET
04439A             11083  
04439A             11084  ; OSBGET - Read a byte from a random disk file.
04439A             11085  ;  E = file channel
04439A             11086  ; Returns
04439A             11087  ;  A = byte read
04439A             11088  ;  Carry set if LAST BYTE of file
04439A             11089  ; Destroys: A,B,C,F
04439A             11090  ;
04439A C5          11091  OSBGET:			PUSH	BC
04439B 4B          11092  			LD	C, E
04439C             11093  			MOSCALL	mos_fgetc
04439C 3E 0C       0001M 			LD	A, function
04439E 49 CF       0002M 			RST.LIS	08h
0443A0 C1          11094  			POP	BC
0443A1 C9          11095  			RET
0443A2             11096  
0443A2             11097  ; OSBPUT - Write a byte to a random disk file.
0443A2             11098  ;  E = file channel
0443A2             11099  ;  A = byte to write
0443A2             11100  ; Destroys: A,B,C,F
0443A2             11101  ;
0443A2 C5          11102  OSBPUT:			PUSH	BC
0443A3 4B          11103  			LD	C, E
0443A4 47          11104  			LD	B, A
0443A5             11105  			MOSCALL	mos_fputc
0443A5 3E 0D       0001M 			LD	A, function
0443A7 49 CF       0002M 			RST.LIS	08h
0443A9 C1          11106  			POP	BC
0443AA C9          11107  			RET
0443AB             11108  
0443AB             11109  ; OSSTAT - Read file status
0443AB             11110  ;  E = file channel
0443AB             11111  ; Returns
0443AB             11112  ;  F: Z flag set - EOF
0443AB             11113  ;  A: If Z then A = 0
0443AB             11114  ; Destroys: A,D,E,H,L,F
0443AB             11115  ;
0443AB C5          11116  OSSTAT:			PUSH	BC
0443AC 4B          11117  			LD	C, E
0443AD             11118  			MOSCALL	mos_feof
0443AD 3E 0E       0001M 			LD	A, function
0443AF 49 CF       0002M 			RST.LIS	08h
0443B1 C1          11119  			POP	BC
0443B2 FE 01       11120  			CP	1
0443B4 C9          11121  			RET
0443B5             11122  
0443B5             11123  ; GETPTR - Return file pointer.
0443B5             11124  ;    E = file channel
0443B5             11125  ; Returns:
0443B5             11126  ; DEHL = pointer (0-&7FFFFF)
0443B5             11127  ; Destroys: A,B,C,D,E,H,L,F
0443B5             11128  ;
0443B5 FD E5       11129  GETPTR:			PUSH		IY
0443B7 4B          11130  			LD		C, E
0443B8             11131  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0443B8 3E 19       0001M 			LD	A, function
0443BA 49 CF       0002M 			RST.LIS	08h
0443BC E5          11132  			PUSH		HL
0443BD FD E1       11133  			POP		IY		; IYU: Pointer to FIL structure
0443BF FD 6E 11    11134  			LD		L, (IY + FIL.fptr + 0)
0443C2 FD 66 12    11135  			LD		H, (IY + FIL.fptr + 1)
0443C5 FD 5E 13    11136  			LD		E, (IY + FIL.fptr + 2)
0443C8 FD 56 14    11137  			LD		D, (IY + FIL.fptr + 3)
0443CB FD E1       11138  			POP		IY
0443CD C9          11139  			RET
0443CE             11140  
0443CE             11141  ; PUTPTR - Update file pointer.
0443CE             11142  ;    A = file channel
0443CE             11143  ; DEHL = new pointer (0-&7FFFFF)
0443CE             11144  ; Destroys: A,B,C,D,E,H,L,F
0443CE             11145  ;
0443CE FD E5       11146  PUTPTR:			PUSH		IY
0443D0 4F          11147  			LD		C, A  		; C: Filehandle
0443D1 E5          11148  			PUSH		HL
0443D2 21 02 00 00 11149  			LD		HL, 2
0443D6 39          11150  			ADD		HL, SP
0443D7 73          11151  			LD		(HL), E 	; 3rd byte of DWORD set to E
0443D8 E1          11152  			POP		HL
0443D9 5A          11153  			LD		E, D  		; 4th byte passed as E
0443DA             11154  			MOSCALL		mos_flseek
0443DA 3E 1C       0001M 			LD	A, function
0443DC 49 CF       0002M 			RST.LIS	08h
0443DE FD E1       11155  			POP		IY
0443E0 C9          11156  			RET
0443E1             11157  
0443E1             11158  ; GETEXT - Find file size.
0443E1             11159  ;    E = file channel
0443E1             11160  ; Returns:
0443E1             11161  ; DEHL = file size (0-&800000)
0443E1             11162  ; Destroys: A,B,C,D,E,H,L,F
0443E1             11163  ;
0443E1 FD E5       11164  GETEXT:         PUSH    IY
0443E3 4B          11165                  LD      C, E
0443E4             11166                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443E4 3E 19       0001M 			LD	A, function
0443E6 49 CF       0002M 			RST.LIS	08h
0443E8 E5          11167                  PUSH    HL
0443E9 FD E1       11168                  POP     IY          ; IYU: Pointer to FIL structure
0443EB             11169                  ; Access the obj.objsize field using the offset values
0443EB FD 6E 0B    11170                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443EE FD 66 0C    11171                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443F1 FD 5E 0D    11172                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443F4 FD 56 0E    11173                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443F7             11174  
0443F7 FD E1       11175                  POP     IY
0443F9 C9          11176  			RET
0443FA             11177  
0443FA             11178  ; GETIMS - Get time from RTC
0443FA             11179  ;
0443FA FD E5       11180  GETIMS:			PUSH	IY
0443FC 21 00 4A 04 11181  			LD	HL, ACCS 		; Where to store the time string
044400             11182  			MOSCALL	mos_getrtc
044400 3E 12       0001M 			LD	A, function
044402 49 CF       0002M 			RST.LIS	08h
044404 11 00 4A 04 11183  			LD	DE, ACCS		; DE: pointer to start of string accumulator
044408 5F          11184  			LD	E, A 			;  E: now points to the end of the string
044409 FD E1       11185  			POP	IY
04440B C9          11186  			RET
04440C             11187  
04440C             11188  ; Get two word values from EXPR in DE, HL
04440C             11189  ; IY: Pointer to expression string
04440C             11190  ; Returns:
04440C             11191  ; DE: P1
04440C             11192  ; HL: P2
04440C             11193  ;
04440C CD 0F 03 04 11194  EXPR_W2:		CALL	EXPRI			; Get first parameter
044410 D9          11195  			EXX
044411 E5          11196  			PUSH	HL
044412 CD 2A 0A 04 11197  			CALL	COMMA
044416 CD 0F 03 04 11198  			CALL	EXPRI			; Get second parameter
04441A D9          11199  			EXX
04441B D1          11200  			POP	DE
04441C C9          11201  			RET
04441D             11202  
04441D             11203  ; Stuff not implemented yet
04441D             11204  ;
04441D C9          11205  RESET:			RET
04441E             11206  ; --- End patch.asm ---
04441E             11207  
04441E             11208  ; --- Begin agon_graphics.asm ---
04441E             11209  ;
04441E             11210  ; Title:	BBC Basic for AGON - Graphics stuff
04441E             11211  ; Author:	Dean Belfield
04441E             11212  ; Created:	12/05/2023
04441E             11213  ; Last Updated:	07/06/2023
04441E             11214  ;
04441E             11215  ; Modinfo:
04441E             11216  ; 07/06/2023:	Modified to run in ADL mode
04441E             11217  
04441E             11218  			; .ASSUME	ADL = 1
04441E             11219  
04441E             11220  			; INCLUDE	"equs.inc"
04441E             11221  			; INCLUDE "macros.inc"
04441E             11222  			; INCLUDE "mos_api.inc"	; In MOS/src
04441E             11223  
04441E             11224  			; SEGMENT CODE
04441E             11225  
04441E             11226  			; XDEF	CLG
04441E             11227  			; XDEF	CLRSCN
04441E             11228  			; XDEF	MODE
04441E             11229  			; XDEF	COLOUR
04441E             11230  			; XDEF	GCOL
04441E             11231  			; XDEF	MOVE
04441E             11232  			; XDEF	PLOT
04441E             11233  			; XDEF	DRAW
04441E             11234  			; XDEF	POINT
04441E             11235  			; XDEF	GETSCHR
04441E             11236  
04441E             11237  			; XREF	OSWRCH
04441E             11238  			; XREF	ASC_TO_NUMBER
04441E             11239  			; XREF	EXTERR
04441E             11240  			; XREF	EXPRI
04441E             11241  			; XREF	COMMA
04441E             11242  			; XREF	XEQ
04441E             11243  			; XREF	NXT
04441E             11244  			; XREF	BRAKET
04441E             11245  			; XREF	COUNT0
04441E             11246  			; XREF	CRTONULL
04441E             11247  			; XREF	NULLTOCR
04441E             11248  			; XREF	CRLF
04441E             11249  			; XREF	EXPR_W2
04441E             11250  			; XREF	INKEY1
04441E             11251  
04441E             11252  ; CLG: clears the graphics area
04441E             11253  ;
04441E             11254  CLG:			VDU	10h
04441E 3E 10       0001M 		LD	A, val
044420 CD 56 3F 04 0002M 		CALL	OSWRCH
044424 C3 9E 0B 04 11255  			JP	XEQ
044428             11256  
044428             11257  ; CLS: clears the text area
044428             11258  ;
044428 3E 0C       11259  CLRSCN:			LD	A, 0Ch
04442A C3 56 3F 04 11260  			JP	OSWRCH
04442E             11261  
04442E             11262  ; MODE n: Set video mode
04442E             11263  ;
04442E DD E5       11264  MODE:			PUSH	IX			; Get the system vars in IX
044430             11265  			MOSCALL	mos_sysvars		; Reset the semaphore
044430 3E 08       0001M 			LD	A, function
044432 49 CF       0002M 			RST.LIS	08h
044434 DD CB 04 A6 11266  			RES	4, (IX+sysvar_vpd_pflags)
044438 CD 0F 03 04 11267  			CALL    EXPRI
04443C D9          11268  			EXX
04443D             11269  			VDU	16H			; Mode change
04443D 3E 16       0001M 		LD	A, val
04443F CD 56 3F 04 0002M 		CALL	OSWRCH
044443             11270  			VDU	L
044443 7D          0001M 		LD	A, val
044444 CD 56 3F 04 0002M 		CALL	OSWRCH
044448             11271  			MOSCALL	mos_sysvars
044448 3E 08       0001M 			LD	A, function
04444A 49 CF       0002M 			RST.LIS	08h
04444C DD CB 04 66 11272  @@:			BIT	4, (IX+sysvar_vpd_pflags)
044450 28 FA       11273  			JR	Z, @B			; Wait for the result
044452 DD E1       11274  			POP	IX
044454 C3 9E 0B 04 11275  			JP	XEQ
044458             11276  
044458             11277  ; GET(x,y): Get the ASCII code of a character on screen
044458             11278  ;
044458 FD 23       11279  GETSCHR:		INC	IY
04445A CD 0F 03 04 11280  			CALL    EXPRI      		; Get X coordinate
04445E D9          11281  			EXX
04445F 22 00 4A 04 11282  			LD	(VDU_BUFFER+0), HL
044463 CD 2A 0A 04 11283  			CALL	COMMA
044467 CD 0F 03 04 11284  			CALL	EXPRI			; Get Y coordinate
04446B D9          11285  			EXX
04446C 22 02 4A 04 11286  			LD	(VDU_BUFFER+2), HL
044470 CD 37 0A 04 11287  			CALL	BRAKET			; Closing bracket
044474             11288  ;
044474 DD E5       11289  			PUSH	IX			; Get the system vars in IX
044476             11290  			MOSCALL	mos_sysvars		; Reset the semaphore
044476 3E 08       0001M 			LD	A, function
044478 49 CF       0002M 			RST.LIS	08h
04447A DD CB 04 8E 11291  			RES	1, (IX+sysvar_vpd_pflags)
04447E             11292  			VDU	23
04447E 3E 17       0001M 		LD	A, val
044480 CD 56 3F 04 0002M 		CALL	OSWRCH
044484             11293  			VDU	0
044484 3E 00       0001M 		LD	A, val
044486 CD 56 3F 04 0002M 		CALL	OSWRCH
04448A             11294  			VDU	vdp_scrchar
04448A 3E 83       0001M 		LD	A, val
04448C CD 56 3F 04 0002M 		CALL	OSWRCH
044490             11295  			VDU	(VDU_BUFFER+0)
044490 3A 00 4A 04 0001M 		LD	A, val
044494 CD 56 3F 04 0002M 		CALL	OSWRCH
044498             11296  			VDU	(VDU_BUFFER+1)
044498 3A 01 4A 04 0001M 		LD	A, val
04449C CD 56 3F 04 0002M 		CALL	OSWRCH
0444A0             11297  			VDU	(VDU_BUFFER+2)
0444A0 3A 02 4A 04 0001M 		LD	A, val
0444A4 CD 56 3F 04 0002M 		CALL	OSWRCH
0444A8             11298  			VDU	(VDU_BUFFER+3)
0444A8 3A 03 4A 04 0001M 		LD	A, val
0444AC CD 56 3F 04 0002M 		CALL	OSWRCH
0444B0 DD CB 04 4E 11299  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0444B4 28 FA       11300  			JR	Z, @B			; Wait for the result
0444B6 DD 7E 09    11301  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0444B9 B7          11302  			OR	A			; Check for 00h
0444BA 37          11303  			SCF				; C = character map
0444BB 20 02       11304  			JR	NZ, @F			; We have a character, so skip next bit
0444BD AF          11305  			XOR	A			; Clear carry
0444BE 3D          11306  			DEC	A			; Set A to FFh
0444BF DD E1       11307  @@:			POP	IX
0444C1 C3 E6 07 04 11308  			JP	INKEY1			; Jump back to the GET command
0444C5             11309  
0444C5             11310  ; POINT(x,y): Get the pixel colour of a point on screen
0444C5             11311  ;
0444C5 CD 0F 03 04 11312  POINT:			CALL    EXPRI      		; Get X coordinate
0444C9 D9          11313  			EXX
0444CA 22 00 4A 04 11314  			LD	(VDU_BUFFER+0), HL
0444CE CD 2A 0A 04 11315  			CALL	COMMA
0444D2 CD 0F 03 04 11316  			CALL	EXPRI			; Get Y coordinate
0444D6 D9          11317  			EXX
0444D7 22 02 4A 04 11318  			LD	(VDU_BUFFER+2), HL
0444DB CD 37 0A 04 11319  			CALL	BRAKET			; Closing bracket
0444DF             11320  ;
0444DF DD E5       11321  			PUSH	IX			; Get the system vars in IX
0444E1             11322  			MOSCALL	mos_sysvars		; Reset the semaphore
0444E1 3E 08       0001M 			LD	A, function
0444E3 49 CF       0002M 			RST.LIS	08h
0444E5 DD CB 04 96 11323  			RES	2, (IX+sysvar_vpd_pflags)
0444E9             11324  			VDU	23
0444E9 3E 17       0001M 		LD	A, val
0444EB CD 56 3F 04 0002M 		CALL	OSWRCH
0444EF             11325  			VDU	0
0444EF 3E 00       0001M 		LD	A, val
0444F1 CD 56 3F 04 0002M 		CALL	OSWRCH
0444F5             11326  			VDU	vdp_scrpixel
0444F5 3E 84       0001M 		LD	A, val
0444F7 CD 56 3F 04 0002M 		CALL	OSWRCH
0444FB             11327  			VDU	(VDU_BUFFER+0)
0444FB 3A 00 4A 04 0001M 		LD	A, val
0444FF CD 56 3F 04 0002M 		CALL	OSWRCH
044503             11328  			VDU	(VDU_BUFFER+1)
044503 3A 01 4A 04 0001M 		LD	A, val
044507 CD 56 3F 04 0002M 		CALL	OSWRCH
04450B             11329  			VDU	(VDU_BUFFER+2)
04450B 3A 02 4A 04 0001M 		LD	A, val
04450F CD 56 3F 04 0002M 		CALL	OSWRCH
044513             11330  			VDU	(VDU_BUFFER+3)
044513 3A 03 4A 04 0001M 		LD	A, val
044517 CD 56 3F 04 0002M 		CALL	OSWRCH
04451B DD CB 04 56 11331  @@:			BIT	2, (IX+sysvar_vpd_pflags)
04451F 28 FA       11332  			JR	Z, @B			; Wait for the result
044521             11333  ;
044521             11334  ; Return the data as a 1 byte index
044521             11335  ;
044521 DD 6E 16    11336  			LD	L, (IX+sysvar_scrpixelIndex)
044524 DD E1       11337  			POP	IX
044526 C3 84 05 04 11338  			JP	COUNT0
04452A             11339  
04452A             11340  
04452A             11341  ; COLOUR colour
04452A             11342  ; COLOUR L,P
04452A             11343  ; COLOUR L,R,G,B
04452A             11344  ;
04452A CD 0F 03 04 11345  COLOUR:			CALL	EXPRI			; The colour / mode
04452E D9          11346  			EXX
04452F 7D          11347  			LD	A, L
044530 32 00 4A 04 11348  			LD	(VDU_BUFFER+0), A	; Store first parameter
044534 CD 78 0A 04 11349  			CALL	NXT			; Are there any more parameters?
044538 FE 2C       11350  			CP	','
04453A 28 12       11351  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
04453C             11352  ;
04453C             11353  			VDU	11h			; Just set the colour
04453C 3E 11       0001M 		LD	A, val
04453E CD 56 3F 04 0002M 		CALL	OSWRCH
044542             11354  			VDU	(VDU_BUFFER+0)
044542 3A 00 4A 04 0001M 		LD	A, val
044546 CD 56 3F 04 0002M 		CALL	OSWRCH
04454A C3 9E 0B 04 11355  			JP	XEQ
04454E             11356  ;
04454E CD 2A 0A 04 11357  COLOUR_1:		CALL	COMMA
044552 CD 0F 03 04 11358  			CALL	EXPRI			; Parse R (OR P)
044556 D9          11359  			EXX
044557 7D          11360  			LD	A, L
044558 32 01 4A 04 11361  			LD	(VDU_BUFFER+1), A
04455C CD 78 0A 04 11362  			CALL	NXT			; Are there any more parameters?
044560 FE 2C       11363  			CP	','
044562 28 2C       11364  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044564             11365  ;
044564             11366  			VDU	13h			; VDU:COLOUR
044564 3E 13       0001M 		LD	A, val
044566 CD 56 3F 04 0002M 		CALL	OSWRCH
04456A             11367  			VDU	(VDU_BUFFER+0)		; Logical Colour
04456A 3A 00 4A 04 0001M 		LD	A, val
04456E CD 56 3F 04 0002M 		CALL	OSWRCH
044572             11368  			VDU	(VDU_BUFFER+1)		; Palette Colour
044572 3A 01 4A 04 0001M 		LD	A, val
044576 CD 56 3F 04 0002M 		CALL	OSWRCH
04457A             11369  			VDU	0			; RGB set to 0
04457A 3E 00       0001M 		LD	A, val
04457C CD 56 3F 04 0002M 		CALL	OSWRCH
044580             11370  			VDU	0
044580 3E 00       0001M 		LD	A, val
044582 CD 56 3F 04 0002M 		CALL	OSWRCH
044586             11371  			VDU	0
044586 3E 00       0001M 		LD	A, val
044588 CD 56 3F 04 0002M 		CALL	OSWRCH
04458C C3 9E 0B 04 11372  			JP	XEQ
044590             11373  ;
044590 CD 2A 0A 04 11374  COLOUR_2:		CALL	COMMA
044594 CD 0F 03 04 11375  			CALL	EXPRI			; Parse G
044598 D9          11376  			EXX
044599 7D          11377  			LD	A, L
04459A 32 02 4A 04 11378  			LD	(VDU_BUFFER+2), A
04459E CD 2A 0A 04 11379  			CALL	COMMA
0445A2 CD 0F 03 04 11380  			CALL	EXPRI			; Parse B
0445A6 D9          11381  			EXX
0445A7 7D          11382  			LD	A, L
0445A8 32 03 4A 04 11383  			LD	(VDU_BUFFER+3), A
0445AC             11384  			VDU	13h			; VDU:COLOUR
0445AC 3E 13       0001M 		LD	A, val
0445AE CD 56 3F 04 0002M 		CALL	OSWRCH
0445B2             11385  			VDU	(VDU_BUFFER+0)		; Logical Colour
0445B2 3A 00 4A 04 0001M 		LD	A, val
0445B6 CD 56 3F 04 0002M 		CALL	OSWRCH
0445BA             11386  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0445BA 3E FF       0001M 		LD	A, val
0445BC CD 56 3F 04 0002M 		CALL	OSWRCH
0445C0             11387  			VDU	(VDU_BUFFER+1)		; R
0445C0 3A 01 4A 04 0001M 		LD	A, val
0445C4 CD 56 3F 04 0002M 		CALL	OSWRCH
0445C8             11388  			VDU	(VDU_BUFFER+2)		; G
0445C8 3A 02 4A 04 0001M 		LD	A, val
0445CC CD 56 3F 04 0002M 		CALL	OSWRCH
0445D0             11389  			VDU	(VDU_BUFFER+3)		; B
0445D0 3A 03 4A 04 0001M 		LD	A, val
0445D4 CD 56 3F 04 0002M 		CALL	OSWRCH
0445D8 C3 9E 0B 04 11390  			JP	XEQ
0445DC             11391  
0445DC             11392  ; GCOL mode,colour
0445DC             11393  ;
0445DC CD 0F 03 04 11394  GCOL:			CALL	EXPRI			; Parse MODE
0445E0 D9          11395  			EXX
0445E1 7D          11396  			LD	A, L
0445E2 32 00 4A 04 11397  			LD	(VDU_BUFFER+0), A
0445E6 CD 2A 0A 04 11398  			CALL	COMMA
0445EA             11399  ;
0445EA CD 0F 03 04 11400  			CALL	EXPRI			; Parse Colour
0445EE D9          11401  			EXX
0445EF 7D          11402  			LD	A, L
0445F0 32 01 4A 04 11403  			LD	(VDU_BUFFER+1), A
0445F4             11404  ;
0445F4             11405  			VDU	12h			; VDU:GCOL
0445F4 3E 12       0001M 		LD	A, val
0445F6 CD 56 3F 04 0002M 		CALL	OSWRCH
0445FA             11406  			VDU	(VDU_BUFFER+0)		; Mode
0445FA 3A 00 4A 04 0001M 		LD	A, val
0445FE CD 56 3F 04 0002M 		CALL	OSWRCH
044602             11407  			VDU	(VDU_BUFFER+1)		; Colour
044602 3A 01 4A 04 0001M 		LD	A, val
044606 CD 56 3F 04 0002M 		CALL	OSWRCH
04460A C3 9E 0B 04 11408  			JP	XEQ
04460E             11409  
04460E             11410  ; PLOT mode,x,y
04460E             11411  ;
04460E CD 0F 03 04 11412  PLOT:			CALL	EXPRI		; Parse mode
044612 D9          11413  			EXX
044613 E5          11414  			PUSH	HL		; Push mode (L) onto stack
044614 CD 2A 0A 04 11415  			CALL	COMMA
044618 CD 0C 44 04 11416  			CALL	EXPR_W2		; Parse X and Y
04461C C1          11417  			POP	BC		; Pop mode (C) off stack
04461D             11418  PLOT_1:			VDU	19H		; VDU code for PLOT
04461D 3E 19       0001M 		LD	A, val
04461F CD 56 3F 04 0002M 		CALL	OSWRCH
044623             11419  			VDU	C		;  C: Mode
044623 79          0001M 		LD	A, val
044624 CD 56 3F 04 0002M 		CALL	OSWRCH
044628             11420  			VDU	E		; DE: X
044628 7B          0001M 		LD	A, val
044629 CD 56 3F 04 0002M 		CALL	OSWRCH
04462D             11421  			VDU	D
04462D 7A          0001M 		LD	A, val
04462E CD 56 3F 04 0002M 		CALL	OSWRCH
044632             11422  			VDU	L		; HL: Y
044632 7D          0001M 		LD	A, val
044633 CD 56 3F 04 0002M 		CALL	OSWRCH
044637             11423  			VDU	H
044637 7C          0001M 		LD	A, val
044638 CD 56 3F 04 0002M 		CALL	OSWRCH
04463C C3 9E 0B 04 11424  			JP	XEQ
044640             11425  
044640             11426  ; MOVE x,y
044640             11427  ;
044640 CD 0C 44 04 11428  MOVE:			CALL	EXPR_W2		; Parse X and Y
044644 0E 04       11429  			LD	C, 04H		; Plot mode 04H (Move)
044646 18 D5       11430  			JR	PLOT_1		; Plot
044648             11431  
044648             11432  ; DRAW x1,y1
044648             11433  ; DRAW x1,y1,x2,y2
044648             11434  ;
044648 CD 0C 44 04 11435  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
04464C CD 78 0A 04 11436  			CALL	NXT		; Are there any more parameters?
044650 FE 2C       11437  			CP	','
044652 0E 05       11438  			LD	C, 05h		; Code for LINE
044654 20 C7       11439  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044656             11440  			VDU	19h		; Move to the first coordinates
044656 3E 19       0001M 		LD	A, val
044658 CD 56 3F 04 0002M 		CALL	OSWRCH
04465C             11441  			VDU	04h
04465C 3E 04       0001M 		LD	A, val
04465E CD 56 3F 04 0002M 		CALL	OSWRCH
044662             11442  			VDU	E
044662 7B          0001M 		LD	A, val
044663 CD 56 3F 04 0002M 		CALL	OSWRCH
044667             11443  			VDU	D
044667 7A          0001M 		LD	A, val
044668 CD 56 3F 04 0002M 		CALL	OSWRCH
04466C             11444  			VDU	L
04466C 7D          0001M 		LD	A, val
04466D CD 56 3F 04 0002M 		CALL	OSWRCH
044671             11445  			VDU	H
044671 7C          0001M 		LD	A, val
044672 CD 56 3F 04 0002M 		CALL	OSWRCH
044676 CD 2A 0A 04 11446  			CALL	COMMA
04467A C5          11447  			PUSH	BC
04467B CD 0C 44 04 11448  			CALL	EXPR_W2		; Get X2 and Y2
04467F C1          11449  			POP	BC
044680 18 9B       11450  			JR	PLOT_1		; Now DRAW the line to those positions
044682             11451  
044682             11452  
044682             11453  
044682             11454  ; --- End agon_graphics.asm ---
044682             11455  
044682             11456  ; --- Begin agon_sound.asm ---
044682             11457  ;
044682             11458  ; Title:	BBC Basic for AGON - Audio stuff
044682             11459  ; Author:	Dean Belfield
044682             11460  ; Created:	12/05/2023
044682             11461  ; Last Updated:	12/05/2023
044682             11462  ;
044682             11463  ; Modinfo:
044682             11464  
044682             11465  			; .ASSUME	ADL = 1
044682             11466  
044682             11467  			; INCLUDE	"equs.inc"
044682             11468  			; INCLUDE "macros.inc"
044682             11469  			; INCLUDE "mos_api.inc"	; In MOS/src
044682             11470  
044682             11471  			; SEGMENT CODE
044682             11472  
044682             11473  			; XDEF	SOUND
044682             11474  
044682             11475  			; XREF	COMMA
044682             11476  			; XREF	EXPR_W2
044682             11477  			; XREF	XEQ
044682             11478  			; XREF	LTRAP
044682             11479  			; XREF	OSWRCH
044682             11480  			; XREF	VDU_BUFFER
044682             11481  
044682             11482  
044682             11483  ; SOUND channel,volume,pitch,duration
044682             11484  ; volume: 0 (off) to -15 (full volume)
044682             11485  ; pitch: 0 - 255
044682             11486  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
044682             11487  ;
044682 CD 0C 44 04 11488  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044686 7D          11489  			LD	A, L 			;  A: Volume
044687 F5          11490  			PUSH	AF
044688 D5          11491  			PUSH	DE
044689 CD 2A 0A 04 11492  			CALL	COMMA
04468D CD 0C 44 04 11493  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
044691 53          11494  			LD	D, E			;  D: Pitch
044692 5D          11495  			LD	E, L 			;  E: Duration
044693 E1          11496  			POP	HL 			; HL: Channel/Control
044694 F1          11497  			POP	AF
044695 ED 44       11498  			NEG
044697 FE 10       11499  			CP	16			; Check volume is in bounds
044699 D2 9E 0B 04 11500  			JP	NC, XEQ			; Out of bounds, do nothing
04469D             11501  ;
04469D             11502  ; Store	in VDU vars
04469D             11503  ;
04469D 4F          11504  			LD	C, A			; Store Volume in C
04469E 7D          11505  			LD	A, L
04469F 32 00 4A 04 11506  			LD	(VDU_BUFFER+0), A	; Channel
0446A3 AF          11507  			XOR	A
0446A4 32 01 4A 04 11508  			LD	(VDU_BUFFER+1), A	; Waveform
0446A8             11509  ;
0446A8             11510  ; Calculate the volume
0446A8             11511  ;
0446A8 06 06       11512  			LD	B, 6			; C already contains the volume
0446AA ED 4C       11513  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0446AC 79          11514  			LD	A, C
0446AD 32 02 4A 04 11515  			LD	(VDU_BUFFER+2), A
0446B1             11516  ;
0446B1             11517  ; And the frequency
0446B1             11518  ;
0446B1 4B          11519  			LD	C, E			; Store duration in C
0446B2 26 00       11520  			LD	H, 0			; Lookup the frequency
0446B4 6A          11521  			LD	L, D
0446B5 11 3C 47 04 11522  			LD	DE, SOUND_FREQ_LOOKUP
0446B9 29          11523  			ADD	HL, HL
0446BA 19          11524  			ADD	HL, DE
0446BB 7E          11525  			LD	A, (HL)
0446BC 32 03 4A 04 11526  			LD	(VDU_BUFFER+3), A
0446C0 23          11527  			INC	HL
0446C1 7E          11528  			LD	A, (HL)
0446C2 32 04 4A 04 11529  			LD	(VDU_BUFFER+4), A
0446C6             11530  ;
0446C6             11531  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0446C6             11532  ;
0446C6 06 32       11533  			LD	B, 50			; C contains the duration, so MLT by 50
0446C8 ED 4C       11534  			MLT	BC
0446CA ED 43 05 4A 11535  			LD	(VDU_BUFFER+5), BC
       04          
0446CF             11536  ;
0446CF DD E5       11537  			PUSH	IX			; Get the system vars in IX
0446D1             11538  			MOSCALL	mos_sysvars		; Reset the semaphore
0446D1 3E 08       0001M 			LD	A, function
0446D3 49 CF       0002M 			RST.LIS	08h
0446D5 5B DD CB 04 11539  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0446DA             11540  ;
0446DA             11541  			VDU	23			; Send the sound command
0446DA 3E 17       0001M 		LD	A, val
0446DC CD 56 3F 04 0002M 		CALL	OSWRCH
0446E0             11542  			VDU	0
0446E0 3E 00       0001M 		LD	A, val
0446E2 CD 56 3F 04 0002M 		CALL	OSWRCH
0446E6             11543  			VDU	vdp_audio
0446E6 3E 85       0001M 		LD	A, val
0446E8 CD 56 3F 04 0002M 		CALL	OSWRCH
0446EC             11544  			VDU	(VDU_BUFFER+0)		; 0: Channel
0446EC 3A 00 4A 04 0001M 		LD	A, val
0446F0 CD 56 3F 04 0002M 		CALL	OSWRCH
0446F4             11545  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446F4 3A 01 4A 04 0001M 		LD	A, val
0446F8 CD 56 3F 04 0002M 		CALL	OSWRCH
0446FC             11546  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446FC 3A 02 4A 04 0001M 		LD	A, val
044700 CD 56 3F 04 0002M 		CALL	OSWRCH
044704             11547  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
044704 3A 03 4A 04 0001M 		LD	A, val
044708 CD 56 3F 04 0002M 		CALL	OSWRCH
04470C             11548  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
04470C 3A 04 4A 04 0001M 		LD	A, val
044710 CD 56 3F 04 0002M 		CALL	OSWRCH
044714             11549  			VDU	(VDU_BUFFER+5)		; 5: Duration L
044714 3A 05 4A 04 0001M 		LD	A, val
044718 CD 56 3F 04 0002M 		CALL	OSWRCH
04471C             11550  			VDU	(VDU_BUFFER+6)		; 6: Duration H
04471C 3A 06 4A 04 0001M 		LD	A, val
044720 CD 56 3F 04 0002M 		CALL	OSWRCH
044724             11551  ;
044724             11552  ; Wait for acknowledgement
044724             11553  ;
044724 5B DD CB 04 11554  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
044729 28 F9       11555  			JR	Z, @B			; Wait for the result
04472B CD C7 3F 04 11556  			CALL	LTRAP			; Check for ESC
04472F 5B DD 7E 0E 11557  			LD.LIL	A, (IX+sysvar_audioSuccess)
044733 A7          11558  			AND	A			; Check if VDP has queued the note
044734 28 9F       11559  			JR	Z, SOUND0		; No, so loop back and send again
044736             11560  ;
044736 DD E1       11561  			POP	IX
044738 C3 9E 0B 04 11562  			JP	XEQ
04473C             11563  
04473C             11564  ; Frequency Lookup Table
04473C             11565  ; Set up to replicate the BBC Micro audio frequencies
04473C             11566  ;
04473C             11567  ; Split over 5 complete octaves, with 53 being middle C
04473C             11568  ; * C4: 262hz
04473C             11569  ; + A4: 440hz
04473C             11570  ;
04473C             11571  ;	2	3	4	5	6	7	8
04473C             11572  ;
04473C             11573  ; B	1	49	97	145	193	241
04473C             11574  ; A#	0	45	93	141	189	237
04473C             11575  ; A		41	89+	137	185	233
04473C             11576  ; G#		37	85	133	181	229
04473C             11577  ; G		33	81	129	177	225
04473C             11578  ; F#		29	77	125	173	221
04473C             11579  ; F		25	73	121	169	217
04473C             11580  ; E		21	69	117	165	213
04473C             11581  ; D#		17	65	113	161	209
04473C             11582  ; D		13	61	109	157	205	253
04473C             11583  ; C#		9	57	105	153	201	249
04473C             11584  ; C		5	53*	101	149	197	245
04473C             11585  ;
04473C 75 00 76 00 11586  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
04474C 89 00 8B 00 11587  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
04475C 99 00 9C 00 11588  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
04476C AC 00 AF 00 11589  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
04477C C1 00 C4 00 11590  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
04478C D9 00 DC 00 11591  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
04479C F3 00 F7 00 11592  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0447AC 11 01 15 01 11593  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0447BC 33 01 37 01 11594  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0447CC 58 01 5D 01 11595  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0447DC 82 01 88 01 11596  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0447EC B2 01 B8 01 11597  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447FC E7 01 EE 01 11598  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
04480C 22 02 2A 02 11599  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
04481C 65 02 6E 02 11600  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
04482C B1 02 BB 02 11601  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
04483C 05 03 10 03 11602  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
04484C 63 03 70 03 11603  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
04485C CE 03 DC 03 11604  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
04486C 45 04 55 04 11605  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
04487C CB 04 DD 04 11606  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
04488C 62 05 76 05 11607  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
04489C 0A 06 21 06 11608  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0448AC C8 06 E1 06 11609  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0448BC 9C 07 B8 07 11610  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0448CC 8A 08 A9 08 11611  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0448DC 95 09 B9 09 11612  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0448EC C2 0A EA 0A 11613  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448FC 13 0C 40 0C 11614  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
04490C 8E 0D C0 0D 11615  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
04491C 36 0F 6F 0F 11616  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
04492C 13 11 53 11 11617  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
04493C             11618  
04493C             11619  
04493C             11620  ; --- End agon_sound.asm ---
04493C             11621  
04493C             11622  ; --- Begin interrupts.asm ---
04493C             11623  ;
04493C             11624  ; Title:	BBC Basic for AGON - Interrupts
04493C             11625  ; Author:	Dean Belfield
04493C             11626  ; Created:	12/05/2023
04493C             11627  ; Last Updated:	07/06/2023
04493C             11628  ;
04493C             11629  ; Modinfo:
04493C             11630  ; 07/06/2023:	Modified to run in ADL mode
04493C             11631  
04493C             11632  			; .ASSUME	ADL = 1
04493C             11633  
04493C             11634  			; INCLUDE	"macros.inc"
04493C             11635  			; INCLUDE	"equs.inc"
04493C             11636  			; INCLUDE "mos_api.inc"	; In MOS/src
04493C             11637  
04493C             11638  			; SEGMENT CODE
04493C             11639  
04493C             11640  			; XDEF	VBLANK_INIT
04493C             11641  			; XDEF	VBLANK_STOP
04493C             11642  			; XDEF	VBLANK_HANDLER
04493C             11643  
04493C             11644  			; XREF	ESCSET
04493C             11645  			; XREF	KEYDOWN		; In ram.asm
04493C             11646  			; XREF	KEYASCII 	; In ram.asm
04493C             11647  			; XREF	KEYCOUNT	; In ram.asm
04493C             11648  
04493C             11649  ; Hook into the MOS VBLANK interrupt
04493C             11650  ;
04493C F3          11651  VBLANK_INIT:		DI
04493D 21 91 49 04 11652  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044941 1E 32       11653  			LD		E, 32h				; Set up the VBlank Interrupt Vector
044943             11654  			MOSCALL		mos_setintvector
044943 3E 14       0001M 			LD	A, function
044945 49 CF       0002M 			RST.LIS	08h
044947             11655  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044947 EB          11656  			ex de,hl
044948 21 9F 49 04 11657  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04494C ED 1F       11658  			LD		(HL), DE			; Self-modify the code
04494E FB          11659  			EI
04494F C9          11660  			RET
044950             11661  
044950             11662  ; Unhook the custom VBLANK interrupt
044950             11663  ;
044950 F3          11664  VBLANK_STOP:		DI
044951 21 9F 49 04 11665  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044955 ED 17       11666  			LD		DE, (HL)
044957 EB          11667  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
044958 1E 32       11668  			LD		E, 32h
04495A             11669  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
04495A 3E 14       0001M 			LD	A, function
04495C 49 CF       0002M 			RST.LIS	08h
04495E FB          11670  			EI
04495F C9          11671  			RET
044960             11672  
044960             11673  ; A safe LIS call to ESCSET
044960             11674  ;
044960             11675  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044960 3E 08       0001M 			LD	A, function
044962 49 CF       0002M 			RST.LIS	08h
044964 21 49 4D 04 11676  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044968 DD 7E 19    11677  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04496B BE          11678  			CP 		(HL)				; with our local copy
04496C 20 0A       11679  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
04496E             11680  ;
04496E AF          11681  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
04496F 32 48 4D 04 11682  			LD		(KEYASCII), A
044973 32 47 4D 04 11683  			LD		(KEYDOWN), A
044977 C9          11684  			RET	 					; And return
044978             11685  ;
044978 77          11686  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044979 DD 7E 18    11687  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
04497C B7          11688  			OR		A
04497D 28 EF       11689  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
04497F             11690  ;
04497F 32 47 4D 04 11691  			LD		(KEYDOWN), A 			; Store the keydown value
044983 DD 7E 05    11692  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044986 32 48 4D 04 11693  			LD		(KEYASCII), A 			; Store locally
04498A FE 1B       11694  			CP		1Bh				; Is it escape?
04498C CC A2 3F 04 11695  			CALL		Z, ESCSET			; Yes, so set the escape flags
044990 C9          11696  			RET						; Return to the interrupt handler
044991             11697  
044991 F3          11698  VBLANK_HANDLER:		DI
044992 F5          11699  			PUSH		AF
044993 E5          11700  			PUSH		HL
044994 DD E5       11701  			PUSH		IX
044996 CD 60 49 04 11702  			CALL		DO_KEYBOARD
04499A DD E1       11703  			POP		IX
04499C E1          11704  			POP		HL
04499D F1          11705  			POP		AF
04499E             11706  ;
04499E             11707  ; Finally jump to the MOS interrupt
04499E             11708  ;
04499E C3 00 00 00 11709  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
0449A2             11710  
0449A2             11711  ; --- Begin sorry.asm ---
0449A2             11712  ;
0449A2             11713  ; Title:	BBC Basic Interpreter - Z80 version
0449A2             11714  ;		Catch-all for unimplemented functionality
0449A2             11715  ; Author:	Dean Belfield
0449A2             11716  ; Created:	12/05/2023
0449A2             11717  ; Last Updated:	12/05/2023
0449A2             11718  ;
0449A2             11719  ; Modinfo:
0449A2             11720  
0449A2             11721  			; .ASSUME	ADL = 1
0449A2             11722  
0449A2             11723  			; SEGMENT CODE
0449A2             11724  
0449A2             11725  			; XDEF	ENVEL
0449A2             11726  			; XDEF	ADVAL
0449A2             11727  			; XDEF	PUTIMS
0449A2             11728  
0449A2             11729  			; XREF	EXTERR
0449A2             11730  
0449A2             11731  ENVEL:
0449A2             11732  ADVAL:
0449A2             11733  PUTIMS:
0449A2 AF          11734  			XOR     A
0449A3 CD CD 37 04 11735  			CALL    EXTERR
0449A7 53 6F 72 72 11736  			DEFB    "Sorry"
       79          
0449AC 00          11737  			DEFB    0
0449AD             11738  ; --- End sorry.asm ---
0449AD             11739  
0449AD             11740  ; --- Begin ram.asm ---
0449AD             11741  ;
0449AD             11742  ; Title:	BBC Basic Interpreter - Z80 version
0449AD             11743  ;		RAM Module for BBC Basic Interpreter
0449AD             11744  ;		For use with Version 2.0 of BBC BASIC
0449AD             11745  ;		Standard CP/M Distribution Version
0449AD             11746  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0449AD             11747  ; Modified By:	Dean Belfield
0449AD             11748  ; Created:	12/05/2023
0449AD             11749  ; Last Updated:	26/06/2023
0449AD             11750  ;
0449AD             11751  ; Modinfo:
0449AD             11752  ; 06/06/2023:	Modified to run in ADL mode
0449AD             11753  ; 26/06/2023:	Added temporary stores R0 and R1
0449AD             11754  
0449AD             11755  			; .ASSUME	ADL = 1
0449AD             11756  
0449AD             11757  			; DEFINE	LORAM, SPACE = ROM
0449AD             11758  			; SEGMENT LORAM
0449AD             11759  
0449AD             11760  			; XDEF	ACCS
0449AD             11761  			; XDEF	BUFFER
0449AD             11762  			; XDEF	STAVAR
0449AD             11763  			; XDEF	DYNVAR
0449AD             11764  			; XDEF	FNPTR
0449AD             11765  			; XDEF	PROPTR
0449AD             11766  			; XDEF	PAGE_
0449AD             11767  			; XDEF	TOP
0449AD             11768  			; XDEF	LOMEM
0449AD             11769  			; XDEF 	FREE
0449AD             11770  			; XDEF	HIMEM
0449AD             11771  			; XDEF	LINENO
0449AD             11772  			; XDEF	TRACEN
0449AD             11773  			; XDEF	AUTONO
0449AD             11774  			; XDEF	ERRTRP
0449AD             11775  			; XDEF	ERRTXT
0449AD             11776  			; XDEF	DATPTR
0449AD             11777  			; XDEF	ERL
0449AD             11778  			; XDEF	ERRLIN
0449AD             11779  			; XDEF	RANDOM
0449AD             11780  			; XDEF	COUNT
0449AD             11781  			; XDEF	WIDTH
0449AD             11782  			; XDEF	ERR
0449AD             11783  			; XDEF	LISTON
0449AD             11784  			; XDEF	INCREM
0449AD             11785  
0449AD             11786  			; XDEF	FLAGS
0449AD             11787  			; XDEF	OSWRCHPT
0449AD             11788  			; XDEF	OSWRCHCH
0449AD             11789  			; XDEF	OSWRCHFH
0449AD             11790  			; XDEF	KEYDOWN
0449AD             11791  			; XDEF	KEYASCII
0449AD             11792  			; XDEF	KEYCOUNT
0449AD             11793  
0449AD             11794  			; XDEF	R0
0449AD             11795  			; XDEF	R1
0449AD             11796  
0449AD             11797  			; XDEF	RAM_START
0449AD             11798  			; XDEF	RAM_END
0449AD             11799  			; XDEF	USER
0449AD             11800  
0449AD 00 00 00 00 11801  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
044A00             11802  RAM_START:
044A00             11803  ;
044A00 00 00 00 00 11804  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 11805  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 11806  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 11807  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    11808  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    11809  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             11810  ;
044D14 00 00 00    11811  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    11812  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    11813  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    11814  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    11815  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             11816  ;
044D23 00 00 00    11817  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    11818  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    11819  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    11820  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       11821  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       11822  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       11823  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    11824  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 11825  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          11826  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          11827  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          11828  ERR:            BLKB    1,0               ; Error Number
044D40 00          11829  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             11830                                  ; - BIT 0: If set, output a space after the line number
044D41             11831                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             11832                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             11833                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             11834                                  ; OPT FLAG (top nibble)
044D41             11835                                  ; - BIT 4: If set, then list whilst assembling
044D41             11836                                  ; - BIT 5: If set, then assembler errors are reported
044D41             11837                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             11838                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          11839  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             11840  ;
044D42             11841  ; Extra Agon-implementation specific system variables
044D42             11842  ;
044D42 00          11843  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             11844                                  ; - BIT 7: Set if ESC pressed
044D43             11845                                  ; - BIT 6: Set to disable ESC
044D43 00 00       11846  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          11847  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             11848                                  ; - 0: Console
044D46             11849                                  ; - 1: File
044D46 00          11850  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          11851  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          11852  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          11853  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    11854  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    11855  R1:             BLKB    3,0
044D50             11856  
044D50             11857  ;
044D50             11858  ; This must be at the end
044D50             11859  ;
044D50             11860  RAM_END:
044D50             11861  ; moved to user.asm
044D50             11862  ; 			ALIGN	256
044D50             11863  ; USER:							; Must be aligned on a page boundary
044D50             11864  	; --- End ram.asm ---
044D50             11865  
044D50             11866  ; --- Begin user.asm ---
044D50             11867  ; this must be the last include to allow unbounded user space for programs
044D50             11868  
044D50             11869  			; .ASSUME	ADL = 1
044D50             11870  
044D50 00 00 00 00 11871  			ALIGN	256
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044E00             11872  USER:							; Must be aligned on a page boundary; --- End user.asm ---
044E00             11873  
044E00             11874  ; --- Begin equs_bottom.inc ---
044E00             11875  ; --- Begin equs.inc ---
044E00             11876  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
044E00             11877  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
044E00             11878  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044E00             11879  ; --- End equs.inc ---
044E00             11880  
044E00             11881  ; --- Begin eval.asm ---
044E00             11882  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
044E00             11883  ; 041DFA D6 C6       0258*  			SUB     TCMD
044E00             11884  
044E00             11885  ; --- End eval.asm ---
044E00             11886  
044E00             11887  ; --- Begin exec.asm ---
044E00             11888  ; --- End exec.asm ---
044E00             11889  
044E00             11890  ; --- Begin fpp.asm ---
044E00             11891  ; --- End fpp.asm ---
044E00             11892  
044E00             11893  ; --- Begin init.asm ---
044E00             11894  ; --- End init.asm ---
044E00             11895  
044E00             11896  ; --- Begin main.asm ---
044E00             11897  ; --- End main.asm ---
044E00             11898  
044E00             11899  ; --- Begin mos_api.inc ---
044E00             11900  ; --- End mos_api.inc ---
044E00             11901  
044E00             11902  ; --- End equs_bottom.inc ---
044E00             11903  
