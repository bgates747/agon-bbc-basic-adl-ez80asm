        Output     Line 
       
               0001 ; --- Begin mos_api.inc ---
               0002 ;
               0003 ; Title:	AGON MOS - API for user projects
               0004 ; Author:	Dean Belfield
               0005 ; Created:	03/08/2022
               0006 ; Last Updated:	11/11/2023
               0007 ;
               0008 ; Modinfo:
               0009 ; 05/08/2022:	Added mos_feof
               0010 ; 09/08/2022:	Added system variables: cursorX, cursorY
               0011 ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
               0012 ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
               0013 ; 24/09/2022:	Added mos_getError, mos_mkdir
               0014 ; 13/10/2022:	Added mos_oscli
               0015 ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
               0016 ; 04/03/2023:	Added sysvar_scrpixelIndex
               0017 ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
               0018 ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
               0019 ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
               0020 ; 22/03/2023:	The VDP commands are now indexed from 0x80
               0021 ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
               0022 ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
               0023 ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
               0024 ; 19/05/2023:	Added sysvar_scrMode
               0025 ; 05/06/2023:	Added sysvar_rtcEnable
               0026 ; 03/08/2023:	Added mos_setkbvector
               0027 ; 10/08/2023:	Added mos_getkbmap
               0028 ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
               0029 
               0030 ; VDP control (VDU 23, 0, n)
               0031 ;
               0032 vdp_gp:			EQU 	80h
               0033 vdp_keycode:		EQU 	81h
               0034 vdp_cursor:		EQU	82h
               0035 vdp_scrchar:		EQU	83h
               0036 vdp_scrpixel:		EQU	84h
               0037 vdp_audio:		EQU	85h
               0038 vdp_mode:		EQU	86h
               0039 vdp_rtc:		EQU	87h
               0040 vdp_keystate:		EQU	88h
               0041 vdp_logicalcoords:	EQU	C0h
               0042 vdp_terminalmode:	EQU	FFh
               0043 
               0044 ; MOS high level functions
               0045 ;
               0046 mos_getkey:		EQU	00h
               0047 mos_load:		EQU	01h
               0048 mos_save:		EQU	02h
               0049 mos_cd:			EQU	03h
               0050 mos_dir:		EQU	04h
               0051 mos_del:		EQU	05h
               0052 mos_ren:		EQU	06h
               0053 mos_mkdir:		EQU	07h
               0054 mos_sysvars:		EQU	08h
               0055 mos_editline:		EQU	09h
               0056 mos_fopen:		EQU	0Ah
               0057 mos_fclose:		EQU	0Bh
               0058 mos_fgetc:		EQU	0Ch
               0059 mos_fputc:		EQU	0Dh
               0060 mos_feof:		EQU	0Eh
               0061 mos_getError:		EQU	0Fh
               0062 mos_oscli:		EQU	10h
               0063 mos_copy:		EQU	11h
               0064 mos_getrtc:		EQU	12h
               0065 mos_setrtc:		EQU	13h
               0066 mos_setintvector:	EQU	14h
               0067 mos_uopen:		EQU	15h
               0068 mos_uclose:		EQU	16h
               0069 mos_ugetc:		EQU	17h
               0070 mos_uputc:		EQU 	18h
               0071 mos_getfil:		EQU	19h
               0072 mos_fread:		EQU	1Ah
               0073 mos_fwrite:		EQU	1Bh
               0074 mos_flseek:		EQU	1Ch
               0075 mos_setkbvector:	EQU	1Dh
               0076 mos_getkbmap:		EQU	1Eh
               0077 mos_i2c_open:		EQU	1Fh
               0078 mos_i2c_close:		EQU	20h
               0079 mos_i2c_write:		EQU	21h
               0080 mos_i2c_read:		EQU	22h
               0081 
               0082 
               0083 ; FatFS file access functions
               0084 ;
               0085 ffs_fopen:		EQU	80h
               0086 ffs_fclose:		EQU	81h
               0087 ffs_fread:		EQU	82h
               0088 ffs_fwrite:		EQU	83h
               0089 ffs_flseek:		EQU	84h
               0090 ffs_ftruncate:		EQU	85h
               0091 ffs_fsync:		EQU	86h
               0092 ffs_fforward:		EQU	87h
               0093 ffs_fexpand:		EQU	88h
               0094 ffs_fgets:		EQU	89h
               0095 ffs_fputc:		EQU	8Ah
               0096 ffs_fputs:		EQU	8Bh
               0097 ffs_fprintf:		EQU	8Ch
               0098 ffs_ftell:		EQU	8Dh
               0099 ffs_feof:		EQU	8Eh
               0100 ffs_fsize:		EQU	8Fh
               0101 ffs_ferror:		EQU	90h
               0102 
               0103 ; FatFS directory access functions
               0104 ;
               0105 ffs_dopen:		EQU	91h
               0106 ffs_dclose:		EQU	92h
               0107 ffs_dread:		EQU	93h
               0108 ffs_dfindfirst:		EQU	94h
               0109 ffs_dfindnext:		EQU	95h
               0110 
               0111 ; FatFS file and directory management functions
               0112 ;
               0113 ffs_stat:		EQU	96h
               0114 ffs_unlink:		EQU	97h
               0115 ffs_rename:		EQU	98h
               0116 ffs_chmod:		EQU	99h
               0117 ffs_utime:		EQU	9Ah
               0118 ffs_mkdir:		EQU	9Bh
               0119 ffs_chdir:		EQU	9Ch
               0120 ffs_chdrive:		EQU	9Dh
               0121 ffs_getcwd:		EQU	9Eh
               0122 
               0123 ; FatFS volume management and system configuration functions
               0124 ;
               0125 ffs_mount:		EQU	9Fh
               0126 ffs_mkfs:		EQU	A0h
               0127 ffs_fdisk:		EQU	A1h
               0128 ffs_getfree:		EQU	A2h
               0129 ffs_getlabel:		EQU	A3h
               0130 ffs_setlabel:		EQU	A4h
               0131 ffs_setcp:		EQU	A5h
               0132 
               0133 ; File access modes
               0134 ;
               0135 fa_read:		EQU	01h
               0136 fa_write:		EQU	02h
               0137 fa_open_existing:	EQU	00h
               0138 fa_create_new:		EQU	04h
               0139 fa_create_always:	EQU	08h
               0140 fa_open_always:		EQU	10h
               0141 fa_open_append:		EQU	30h
               0142 
               0143 ; System variable indexes for api_sysvars
               0144 ; Index into _sysvars in globals.asm
               0145 ;
               0146 sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
               0147 sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
               0148 sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
               0149 sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
               0150 sysvar_cursorX:		EQU	07h	; 1: Cursor X position
               0151 sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
               0152 sysvar_scrchar:		EQU	09h	; 1: Character read from screen
               0153 sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
               0154 sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
               0155 sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
               0156 sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
               0157 sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
               0158 sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
               0159 sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
               0160 sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
               0161 sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
               0162 sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
               0163 sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
               0164 sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
               0165 sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
               0166 sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
               0167 sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
               0168 sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
               0169 sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
               0170 sysvar_scrMode:		EQU	27h	; 1: Screen mode
               0171 sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
               0172 sysvar_mouseX:		EQU	29h	; 2: Mouse X position
               0173 sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
               0174 sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
               0175 sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
               0176 sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
               0177 sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
               0178 
               0179 ; Flags for the VPD protocol
               0180 ;
               0181 vdp_pflag_cursor:	EQU	00000001b
               0182 vdp_pflag_scrchar:	EQU	00000010b
               0183 vdp_pflag_point:	EQU	00000100b
               0184 vdp_pflag_audio:	EQU	00001000b
               0185 vdp_pflag_mode:		EQU	00010000b
               0186 vdp_pflag_rtc:		EQU	00100000b
               0187 vdp_pflag_mouse:	EQU	01000000b
               0188 ; vdp_pflag_buffered:	EQU	10000000b
               0189 
               0190 ;
               0191 ; FatFS structures
               0192 ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
               0193 ;
               0194 ; Object ID and allocation information (FFOBJID)
               0195 ;
               0196 ; FFOBJID	.STRUCT
               0197 ; 	fs:		DS	3	; Pointer to the hosting volume of this object
               0198 ; 	id:		DS	2	; Hosting volume mount ID
               0199 ; 	attr:		DS	1	; Object attribute
               0200 ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
               0201 ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
               0202 ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
               0203 ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
               0204 ; ;
               0205 ; ; File object structure (FIL)
               0206 ; ;
               0207 ; FIL .STRUCT
               0208 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0209 ; 	flag:		DS	1	; File status flags
               0210 ; 	err:		DS	1	; Abort flag (error code)
               0211 ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
               0212 ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
               0213 ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
               0214 ; 	dir_sect:	DS	4	; Sector number containing the directory entry
               0215 ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
               0216 ; FIL_SIZE .ENDSTRUCT FIL
               0217 ; ;
               0218 ; ; Directory object structure (DIR)
               0219 ; ;
               0220 ; DIR .STRUCT
               0221 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0222 ; 	dptr:		DS	4	; Current read/write offset
               0223 ; 	clust:		DS	4	; Current cluster
               0224 ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
               0225 ; 	dir:		DS	3	; Pointer to the directory item in the win[]
               0226 ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
               0227 ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
               0228 ; DIR_SIZE .ENDSTRUCT DIR
               0229 ; ;
               0230 ; ; File information structure (FILINFO)
               0231 ; ;
               0232 ; FILINFO .STRUCT
               0233 ; 	fsize:		DS 	4	; File size
               0234 ; 	fdate:		DS	2	; Modified date
               0235 ; 	ftime:		DS	2	; Modified time
               0236 ; 	fattrib:	DS	1	; File attribute
               0237 ; 	altname:	DS	13	; Alternative file name
               0238 ; 	fname:		DS	256	; Primary file name
               0239 ; FILINFO_SIZE .ENDSTRUCT FILINFO
               0240 
               0241 ; FFOBJID offsets
               0242 FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
               0243 FFOBJID.id:       EQU 3    ; Hosting volume mount ID
               0244 FFOBJID.attr:     EQU 5    ; Object attribute
               0245 FFOBJID.stat:     EQU 6    ; Object chain status
               0246 FFOBJID.sclust:   EQU 7    ; Object data start cluster
               0247 FFOBJID.objsize:  EQU 11   ; Object size
               0248 FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
               0249 
               0250 ; FIL offsets (including FFOBJID fields)
               0251 FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0252 FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
               0253 FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
               0254 FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
               0255 FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
               0256 FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
               0257 FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
               0258 FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
               0259 FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
               0260 
               0261 ; DIR offsets (including FFOBJID fields)
               0262 DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0263 DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
               0264 DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
               0265 DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
               0266 DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
               0267 DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
               0268 DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
               0269 DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
               0270 
               0271 ; FILINFO offsets
               0272 FILINFO.fsize:    EQU 0    ; File size
               0273 FILINFO.fdate:    EQU 4    ; Modified date
               0274 FILINFO.ftime:    EQU 6    ; Modified time
               0275 FILINFO.fattrib:  EQU 8    ; File attribute
               0276 FILINFO.altname:  EQU 9    ; Alternative file name
               0277 FILINFO.fname:    EQU 22   ; Primary file name
               0278 FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
               0279 
               0280 ;
               0281 ; Macro for calling the API
               0282 ; Parameters:
               0283 ; - function: One of the function numbers listed above
               0284 ;
               0285 MACRO MOSCALL	function
               0286 LD	A, function
               0287 RST.LIS	08h
               0288 ENDMACRO 	; --- End mos_api.inc ---
               0289 
               0290 ; --- Begin macros.inc ---
               0291 ; Title:	BBC Basic Interpreter - Z80 version
               0292 ;		Useful macros
               0293 ; Author:	Dean Belfield
               0294 ; Created:	12/05/2023
               0295 ; Last Updated:	11/06/2023
               0296 ;
               0297 ; Modinfo:
               0298 ; 11/06/2023:	Modified to run in ADL mode
               0299 ; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
               0300 
               0301 MACRO EXREG	rp1, rp2
               0302 PUSH	rp1
               0303 POP	rp2
               0304 ENDMACRO
               0305 
               0306 ; MACRO ADD8U_DE	reg
               0307 MACRO ADD8U_DE
               0308 ADD	A, E
               0309 LD	E, A
               0310 ADC	A, D
               0311 SUB	E
               0312 LD	D, A
               0313 ENDMACRO
               0314 
               0315 ; MACRO ADD8U_HL	reg
               0316 MACRO ADD8U_HL
               0317 ADD	A, L
               0318 LD	L, A
               0319 ADC	A, H
               0320 SUB	L
               0321 LD	H, A
               0322 ENDMACRO
               0323 
               0324 MACRO VDU	val
               0325 LD	A, val
               0326 CALL	OSWRCH
               0327 ENDMACRO
               0328 
               0329 MACRO SET_GPIO	reg, val
               0330 IN0	A, (reg)
               0331 OR	val
               0332 OUT0	(reg), A
               0333 ENDMACRO
               0334 
               0335 MACRO RES_GPIO	reg, val
               0336 PUSH	BC
               0337 LD	A, val
               0338 CPL
               0339 LD	C, A
               0340 IN0	A, (reg)
               0341 AND	C
               0342 OUT0	(reg), A
               0343 POP	BC
               0344 ENDMACRO
               0345 ; --- End macros.inc ---
               0346 
               0347 ; --- Begin equs.inc ---
               0348 ;
               0349 ; Title:	BBC Basic for AGON - Equs
               0350 ; Author:	Dean Belfield
               0351 ; Created:	12/05/2023
               0352 ; Last Updated:	08/06/2023
               0353 ;
               0354 ; Modinfo:
               0355 ; 08/06/2023:	Added SIZEW
               0356 
               0357 ; XREF		STAVAR
               0358 ; XREF		ACCS
               0359 
               0360 RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
               0361 ;Stack_Top:		EQU		0000h	; Stack at top
               0362 SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
               0363 
               0364 ; For GPIO
               0365 ; PA not available on eZ80L92
               0366 ;
               0367 PA_DR:			EQU		96h
               0368 PA_DDR:			EQU		97h
               0369 PA_ALT1:		EQU		98h
               0370 PA_ALT2:		EQU		99h
               0371 PB_DR:          	EQU		9Ah
               0372 PB_DDR:        	 	EQU		9Bh
               0373 PB_ALT1:        	EQU		9Ch
               0374 PB_ALT2:        	EQU		9Dh
               0375 PC_DR:          	EQU		9Eh
               0376 PC_DDR:         	EQU		9Fh
               0377 PC_ALT1:        	EQU		A0h
               0378 PC_ALT2:        	EQU		A1h
               0379 PD_DR:          	EQU		A2h
               0380 PD_DDR:			EQU		A3h
               0381 PD_ALT1:		EQU		A4h
               0382 PD_ALT2:		EQU		A5h
               0383 
               0384 GPIOMODE_OUT:		EQU		0	; Output
               0385 GPIOMODE_IN:		EQU		1	; Input
               0386 GPIOMODE_DIO:		EQU		2	; Open Drain IO
               0387 GPIOMODE_SIO:		EQU		3	; Open Source IO
               0388 GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
               0389 GPIOMODE_ALTF:		EQU		5;	; Alt Function
               0390 GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
               0391 GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
               0392 GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
               0393 GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
               0394 
               0395 ; ; Originally in ram.asm
               0396 ; ;
               0397 ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
               0398 ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
               0399 ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
               0400 
               0401 ; Originally in main.asm
               0402 ;
               0403 CR:			EQU     0DH
               0404 LF:			EQU     0AH
               0405 ESC:			EQU     1BH
               0406 ; --- End equs.inc ---
               0407 
               0408 ; --- Begin init.asm ---
               0409 ;
               0410 ; Title:	BBC Basic ADL for AGON - Initialisation Code
               0411 ;		Initialisation Code
               0412 ; Author:	Dean Belfield
               0413 ; Created:	12/05/2023
               0414 ; Last Updated:	26/11/2023
               0415 ;
               0416 ; Modinfo:
               0417 ; 11/07/2023:	Fixed *BYE for ADL mode
               0418 ; 26/11/2023:	Moved the ram clear routine into here
               0419 
               0420 ; SEGMENT CODE
               0421 
               0422 ; XDEF	_end
               0423 
               0424 ; XREF	_main				; In main.asm
               0425 
               0426 ; XREF	RAM_START			; In ram.asm
               0427 ; XREF	RAM_END
               0428 
               0429 ; .ASSUME	ADL = 1
               0430 
               0431 ; INCLUDE	"equs.inc"
               0432 
               0433 argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
               0434 
               0435 ;
               0436 ; Start in ADL mode
               0437 ;
040000 C3      0438 JP	_start				; Jump to start
040001 45 
040002 00 
040003 04 
               0439 ;
               0440 ; The header stuff is from byte 64 onwards
               0441 ;
040004 42      0442 _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
040005 42 
040006 43 
040007 42 
040007 41   
040008 53 
040009 49 
04000A 43 
04000A 2E   
04000B 42 
04000C 49 
04000D 4E 
04000D 00   
               0443 
040011 FF      0444 ALIGN	64
040012 FF 
040013 FF 
040014 FF 
040014 FF   
040015 FF 
040016 FF 
040017 FF 
040017 FF   
040018 FF 
040019 FF 
04001A FF 
04001A FF   
04001B FF 
04001C FF 
04001D FF 
04001D FF   
04001E FF 
04001F FF 
040020 FF 
040020 FF   
040021 FF 
040022 FF 
040023 FF 
040023 FF   
040024 FF 
040025 FF 
040026 FF 
040026 FF   
040027 FF 
040028 FF 
040029 FF 
040029 FF   
04002A FF 
04002B FF 
04002C FF 
04002C FF   
04002D FF 
04002E FF 
04002F FF 
04002F FF   
040030 FF 
040031 FF 
040032 FF 
040032 FF   
040033 FF 
040034 FF 
               0445 
040040 4D      0446 DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040041 4F 
040042 53 
040043 00      0447 DB	00h				; MOS header version 0
040044 01      0448 DB	01h				; Flag for run mode (0: Z80, 1: ADL)
               0449 ;
               0450 ; And the code follows on immediately after the header
               0451 ;
040045 F5      0452 _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5      0453 PUSH		BC
040047 D5      0454 PUSH		DE
040048 DD      0455 PUSH		IX
040049 E5 
04004A FD      0456 PUSH		IY
04004B E5 
               0457 
04004C ED      0458 LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
04004D 73 
04004E D7 
04004F 00 
04004F 04   
               0459 
040051 DD      0460 LD		IX, _argv_ptrs		; The argv array pointer address
040052 21 
040053 DA 
040054 00 
040054 04   
040056 DD      0461 PUSH		IX
040057 E5 
040058 CD      0462 CALL		_parse_params		; Parse the parameters
040059 88 
04005A 00 
04005B 04 
04005C DD      0463 POP		IX			; IX: argv
04005D E1 
04005E 06      0464 LD		B, 0			;  C: argc
04005F 00 
040060 CD      0465 CALL		_clear_ram
040061 75 
040062 00 
040063 04 
040064 C3      0466 JP		_main			; Start user code
040065 B6 
040066 2F 
040067 04 
               0467 ;
               0468 ; This bit of code is called from STAR_BYE and returns us safely to MOS
               0469 ;
040068 ED      0470 _end:			LD		SP, (_sps)		; Restore the stack pointer
040069 7B 
04006A D7 
04006B 00 
04006B 04   
               0471 
04006D FD      0472 POP		IY			; Restore the registers
04006E E1 
04006F DD      0473 POP		IX
040070 E1 
040071 D1      0474 POP		DE
040072 C1      0475 POP		BC
040073 F1      0476 POP		AF
040074 C9      0477 RET					; Return to MOS
               0478 
               0479 ;Clear the application memory
               0480 ;
040075 C5      0481 _clear_ram:		PUSH		BC
040076 21      0482 LD		HL, RAM_START
040077 00 
040078 4A 
040079 04 
04007A 11      0483 LD		DE, RAM_START + 1
04007B 01 
04007C 4A 
04007D 04 
04007E 01      0484 LD		BC, RAM_END - RAM_START - 1
04007F 4F 
040080 03 
040081 00 
040082 AF      0485 XOR		A
040083 77      0486 LD		(HL), A
040084 ED      0487 LDIR
040085 B0 
040086 C1      0488 POP		BC
040087 C9      0489 RET
               0490 
               0491 ; Parse the parameter string into a C array
               0492 ; Parameters
               0493 ; - HL: Address of parameter string
               0494 ; - IX: Address for array pointer storage
               0495 ; Returns:
               0496 ; -  C: Number of parameters parsed
               0497 ;
040088 01      0498 _parse_params:		LD	BC, _exec_name
040089 04 
04008A 00 
04008B 04 
04008C DD      0499 LD	(IX+0), BC		; ARGV[0] = the executable name
04008D 0F 
04008E 00 
04008F DD      0500 INC	IX
040090 23 
040091 DD      0501 INC	IX
040092 23 
040093 DD      0502 INC	IX
040094 23 
040095 CD      0503 CALL	_skip_spaces		; Skip HL past any leading spaces
040096 D0 
040097 00 
040098 04 
               0504 ;
040099 01      0505 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009A 01 
04009B 00 
04009C 00 
04009D 06      0506 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009E 0F 
               0507 ;
               0508 _parse_params_1:
04009F C5      0509 PUSH	BC			; Stack ARGC
0400A0 E5      0510 PUSH	HL			; Stack start address of token
0400A1 CD      0511 CALL	_get_token		; Get the next token
0400A2 C1 
0400A3 00 
0400A4 04 
0400A5 79      0512 LD	A, C			; A: Length of the token in characters
0400A6 D1      0513 POP	DE			; Start address of token (was in HL)
0400A7 C1      0514 POP	BC			; ARGC
0400A8 B7      0515 OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8      0516 RET	Z
               0517 ;
0400AA DD      0518 LD	(IX+0), DE		; Store the pointer to the token
0400AB 1F 
0400AC 00 
0400AD E5      0519 PUSH	HL			; DE=HL
0400AE D1      0520 POP	DE
0400AF CD      0521 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B0 D0 
0400B1 00 
0400B2 04 
0400B3 AF      0522 XOR	A
0400B4 12      0523 LD	(DE), A			; Zero-terminate the token
0400B5 DD      0524 INC	IX
0400B6 23 
0400B7 DD      0525 INC	IX
0400B8 23 
0400B9 DD      0526 INC	IX			; Advance to next pointer position
0400BA 23 
0400BB 0C      0527 INC	C			; Increment ARGC
0400BC 79      0528 LD	A, C			; Check for C >= A
0400BD B8      0529 CP	B
0400BE 38      0530 JR	C, _parse_params_1	; And loop
0400BF DF 
0400C0 C9      0531 RET
               0532 
               0533 ; Get the next token
               0534 ; Parameters:
               0535 ; - HL: Address of parameter string
               0536 ; Returns:
               0537 ; - HL: Address of first character after token
               0538 ; -  C: Length of token (in characters)
               0539 ;
0400C1 0E      0540 _get_token:		LD	C, 0			; Initialise length
0400C2 00 
0400C3 7E      0541 @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7      0542 OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8      0543 RET 	Z
0400C6 FE      0544 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C7 0D 
0400C8 C8      0545 RET	Z
0400C9 FE      0546 CP	' '			; Exit if space (end of token)
0400CA 20 
0400CB C8      0547 RET	Z
0400CC 23      0548 INC	HL			; Advance to next character
0400CD 0C      0549 INC 	C			; Increment length
0400CE 18      0550 JR	@B
0400CF F3 
               0551 
               0552 ; Skip spaces in the parameter string
               0553 ; Parameters:
               0554 ; - HL: Address of parameter string
               0555 ; Returns:
               0556 ; - HL: Address of next none-space character
               0557 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0558 ;
0400D0 7E      0559 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE      0560 CP	' '			; Exit if not space
0400D2 20 
0400D3 C0      0561 RET	NZ
0400D4 23      0562 INC	HL			; Advance to next character
0400D5 18      0563 JR	_skip_spaces		; Increment length
0400D6 F9 
               0564 
               0565 ; Storage
               0566 ;
               0567 _sps:			DS	3			; Storage for the stack pointer
0400DA 00      0568 _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
0400DB 00 
0400DC 00 
0400DD 00 
0400DD 00   
0400DE 00 
0400DF 00 
0400E0 00 
0400E0 00   
0400E1 00 
0400E2 00 
0400E3 00 
0400E3 00   
0400E4 00 
0400E5 00 
0400E6 00 
0400E6 00   
0400E7 00 
0400E8 00 
0400E9 00 
0400E9 00   
0400EA 00 
0400EB 00 
0400EC 00 
0400EC 00   
0400ED 00 
0400EE 00 
0400EF 00 
0400EF 00   
0400F0 00 
0400F1 00 
0400F2 00 
0400F2 00   
0400F3 00 
0400F4 00 
0400F5 00 
0400F5 00   
0400F6 00 
0400F7 00 
0400F8 00 
0400F8 00   
0400F9 00 
0400FA 00 
0400FB 00 
0400FB 00   
0400FC 00 
0400FD 00 
0400FE 00 
               0569 
               0570 ; --- Begin eval.asm ---
               0571 ;
               0572 ; Title:	BBC Basic Interpreter - Z80 version
               0573 ;		Expression Evaluation & Arithmetic Module - "EVAL"
               0574 ; Author:	(C) Copyright  R.T.Russell  1984
               0575 ; Modified By:	Dean Belfield
               0576 ; Created:	12/05/2023
               0577 ; Last Updated:	17/08/2023
               0578 ;
               0579 ; Modinfo:
               0580 ; 07/06/2023:	Modified to run in ADL mode
               0581 ; 26/06/2023:	Fixed HEX and HEXSTR
               0582 ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
               0583 ; 17/08/2023:	Added binary constants
               0584 
               0585 ; .ASSUME	ADL = 1
               0586 
               0587 ; INCLUDE	"equs.inc"
               0588 ; INCLUDE "macros.inc"
               0589 ; INCLUDE "mos_api.inc"	; In MOS/src
               0590 
               0591 ; SEGMENT CODE
               0592 
               0593 ; XDEF	EXPR
               0594 ; XDEF	EXPRN
               0595 ; XDEF	EXPRI
               0596 ; XDEF	EXPRS
               0597 ; XDEF	ITEMI
               0598 ; XDEF	LOADN
               0599 ; XDEF	LOAD4
               0600 ; XDEF	CONS
               0601 ; XDEF	LOADS
               0602 ; XDEF	SFIX
               0603 ; XDEF	VAL0
               0604 ; XDEF	SEARCH
               0605 ; XDEF	SWAP
               0606 ; XDEF	TEST
               0607 ; XDEF	DECODE
               0608 ; XDEF	HEXSTR
               0609 ; XDEF	STR
               0610 ; XDEF	ZERO
               0611 ; XDEF	PUSHS
               0612 ; XDEF	POPS
               0613 ; XDEF	COMMA
               0614 ; XDEF	BRAKET
               0615 ; XDEF	NXT
               0616 ; XDEF	COUNT0
               0617 
               0618 ; XREF	ADVAL
               0619 ; XREF	FN_EX
               0620 ; XREF	POINT
               0621 ; XREF	USR
               0622 ; XREF	SYNTAX
               0623 ; XREF	ERROR_
               0624 ; XREF	CHECK
               0625 ; XREF	GETVAR
               0626 ; XREF	LISTON
               0627 ; XREF	RANGE
               0628 ; XREF	FPP
               0629 ; XREF	GETCSR
               0630 ; XREF	CHANEL
               0631 ; XREF	OSSTAT
               0632 ; XREF	OSBGET
               0633 ; XREF	LOMEM
               0634 ; XREF	HIMEM
               0635 ; XREF	PAGE_
               0636 ; XREF	TOP
               0637 ; XREF	ERL
               0638 ; XREF	ERR
               0639 ; XREF	COUNT
               0640 ; XREF	OSOPEN
               0641 ; XREF	GETEXT
               0642 ; XREF	GETPTR
               0643 ; XREF	GETIME
               0644 ; XREF	GETIMS
               0645 ; XREF	LEXAN2
               0646 ; XREF	RANDOM
               0647 ; XREF	STORE5
               0648 ; XREF	GETSCHR
               0649 ; XREF	OSRDCH
               0650 ; XREF	OSKEY
               0651 ; XREF	INKEY1
               0652 ; XREF	EXTERR
               0653 ;
               0654 ; BINARY FLOATING POINT REPRESENTATION:
               0655 ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               0656 ;     8 BIT EXCESS-128 SIGNED EXPONENT
               0657 ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               0658 ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               0659 ;
               0660 ; BINARY INTEGER REPRESENTATION:
               0661 ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               0662 ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
               0663 ;
               0664 ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               0665 ;                             EXPONENT - C
               0666 ;
               0667 
               0668 ;
               0669 ; Table of addresses for functions
               0670 ;
               0671 FUNTOK:			EQU	8DH			; First token number
               0672 ;
04010A E6      0673 FUNTBL:			DW24	DECODE			; Line number
04010B 08 
04010C 04 
04010D 94      0674 DW24	OPENIN			; OPENIN
04010E 05 
04010F 04 
040110 B6      0675 DW24	PTR_EV			; PTR
040111 05 
040112 04 
040113 50      0676 DW24	PAGEV			; PAGE
040114 05 
040115 04 
040116 C0      0677 DW24	TIMEV			; TIME
040117 05 
040118 04 
040119 3C      0678 DW24	LOMEMV			; LOMEM
04011A 05 
04011B 04 
04011C 46      0679 DW24	HIMEMV			; HIMEM
04011D 05 
04011E 04 
04011F 14      0680 DW24	ABSV			; ABS
040120 06 
040121 04 
040122 50      0681 DW24	ACS			; ACS
040123 06 
040124 04 
040125 B7      0682 DW24	ADVAL			; ADVAL
040126 43 
040127 04 
040128 25      0683 DW24	ASC			; ASC
040129 05 
04012A 04 
04012B 48      0684 DW24	ASN			; ASN
04012C 06 
04012D 04 
04012E 4C      0685 DW24	ATN			; ATN
04012F 06 
040130 04 
040131 EE      0686 DW24	BGET			; BGET
040132 04 
040133 04 
040134 34      0687 DW24	COS			; COS
040135 06 
040136 04 
040137 7B      0688 DW24	COUNTV			; COUNT
040138 05 
040139 04 
04013A 1C      0689 DW24	DEG			; DEG
04013B 06 
04013C 04 
04013D 6F      0690 DW24	ERLV			; ERL
04013E 05 
04013F 04 
040140 75      0691 DW24	ERRV			; ERR
040141 05 
040142 04 
040143 79      0692 DW24	EVAL_			; EVAL
040144 06 
040145 04 
040146 3C      0693 DW24	EXP			; EXP
040147 06 
040148 04 
040149 AC      0694 DW24	EXT			; EXT
04014A 05 
04014B 04 
04014C 93      0695 DW24	ZERO			; FALSE
04014D 09 
04014E 04 
04014F 7F      0696 DW24	FN_EX			; FN
040150 10 
040151 04 
040152 0C      0697 DW24	GET			; GET
040153 05 
040154 04 
040155 FB      0698 DW24	INKEY			; INKEY
040156 04 
040157 04 
040158 2B      0699 DW24	INSTR			; INSTR(
040159 07 
04015A 04 
04015B 28      0700 DW24	INT_			; INT
04015C 06 
04015D 04 
04015E 35      0701 DW24	LEN			; LEN
04015F 05 
040160 04 
040161 40      0702 DW24	LN			; LN
040162 06 
040163 04 
040164 44      0703 DW24	LOG			; LOG
040165 06 
040166 04 
040167 18      0704 DW24	NOTK			; NOT
040168 06 
040169 04 
04016A 90      0705 DW24	OPENUP			; OPENUP
04016B 05 
04016C 04 
04016D 8D      0706 DW24	OPENOT			; OPENOUT
04016E 05 
04016F 04 
040170 10      0707 DW24	PI			; PI
040171 06 
040172 04 
040173 69      0708 DW24	POINT			; POINT(
040174 44 
040175 04 
040176 CD      0709 DW24	POS			; POS
040177 04 
040178 04 
040179 20      0710 DW24	RAD			; RAD
04017A 06 
04017B 04 
04017C AD      0711 DW24	RND			; RND
04017D 06 
04017E 04 
04017F 24      0712 DW24	SGN			; SGN
040180 06 
040181 04 
040182 38      0713 DW24	SIN			; SIN
040183 06 
040184 04 
040185 2C      0714 DW24	SQR			; SQR
040186 06 
040187 04 
040188 30      0715 DW24	TAN			; TAN
040189 06 
04018A 04 
04018B 5A      0716 DW24	TOPV			; TO(P)
04018C 05 
04018D 04 
04018E 05      0717 DW24	TRUE			; TRUE
04018F 06 
040190 04 
040191 22      0718 DW24	USR			; USR
040192 15 
040193 04 
040194 6A      0719 DW24	VAL			; VAL
040195 06 
040196 04 
040197 D6      0720 DW24	VPOS			; VPOS
040198 04 
040199 04 
04019A BF      0721 DW24	CHRS			; CHRS
04019B 07 
04019C 04 
04019D C7      0722 DW24	GETS			; GETS
04019E 07 
04019F 04 
0401A0 D8      0723 DW24	INKEYS			; INKEYS
0401A1 07 
0401A2 04 
0401A3 5D      0724 DW24	LEFTS			; LEFTS(
0401A4 08 
0401A5 04 
0401A6 25      0725 DW24	MIDS			; MIDS(
0401A7 08 
0401A8 04 
0401A9 7D      0726 DW24	RIGHTS			; RIGHTS(
0401AA 08 
0401AB 04 
0401AC 4A      0727 DW24	STRS			; STR$
0401AD 09 
0401AE 04 
0401AF 9E      0728 DW24	STRING_			; STRINGS(
0401B0 08 
0401B1 04 
0401B2 DE      0729 DW24	EOF			; EOF
0401B3 04 
0401B4 04 
               0730 ;
               0731 FUNTBL_END:		EQU	$
               0732 ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
               0733 TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
               0734 
               0735 ANDK:			EQU     80H
               0736 DIVK:			EQU     81H
               0737 EORK:			EQU     82H
               0738 MODK:			EQU     83H
               0739 ORK:			EQU     84H
               0740 ;
0401B5 F0      0741 SOPTBL:			DW24	SLE			; <= (STRING)
0401B6 05 
0401B7 04 
0401B8 F9      0742 DW24	SNE			; <>
0401B9 05 
0401BA 04 
0401BB E9      0743 DW24	SGE			; >=
0401BC 05 
0401BD 04 
0401BE DA      0744 DW24	SLT			; <
0401BF 05 
0401C0 04 
0401C1 00      0745 DW24	SEQ			; =
0401C2 06 
0401C3 04 
0401C4 E1      0746 DW24	SGT			; >
0401C5 05 
0401C6 04 
               0747 ;
               0748 ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
               0749 ;     Expression type is returned in A'F':
               0750 ;        Numeric - A' bit 7=0, F' sign bit cleared.
               0751 ;         String - A' bit 7=1, F' sign bit set.
               0752 ; Floating-point or integer result returned in HLH'L'C
               0753 ; Integer result denoted by C=0 and HLH'L' non-zero.
               0754 ; String result returned in string accumulator, DE set.
               0755 ;
               0756 ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
               0757 ;               (2) ^
               0758 ;               (3) * / MOD DIV
               0759 ;               (4) + -
               0760 ;               (5) = <> <= >= > <
               0761 ;               (6) AND
               0762 ;               (7) EOR OR
               0763 
               0764 ;
               0765 ; Level 7: EOR and OR
               0766 ;
0401C7 CD      0767 EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401C8 E0 
0401C9 01 
0401CA 04 
0401CB FE      0768 EXPR0A:			CP      EORK            	; Is operator EOR?
0401CC 82 
0401CD 28      0769 JR      Z,EXPR0B		; Yes, so skip to next bit
0401CE 03 
0401CF FE      0770 CP      ORK			; Is operator OR
0401D0 84 
0401D1 C0      0771 RET     NZ			; No, so return
               0772 ;
0401D2 CD      0773 EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D3 3E 
0401D4 0A 
0401D5 04 
0401D6 CD      0774 CALL    EXPR1           	; Get second operand
0401D7 E0 
0401D8 01 
0401D9 04 
0401DA CD      0775 CALL    DOIT            	; Do the operation
0401DB 4D 
0401DC 0A 
0401DD 04 
0401DE 18      0776 JR      EXPR0A          	; And continue
0401DF EB 
               0777 ;
               0778 ; Level 6: AND
               0779 ;
0401E0 CD      0780 EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E1 F5 
0401E2 01 
0401E3 04 
0401E4 FE      0781 EXPR1A:			CP      ANDK			; Is operator AND?
0401E5 80 
0401E6 C0      0782 RET     NZ			; No, so return
0401E7 CD      0783 CALL    SAVE_EV			; Save first operand
0401E8 3E 
0401E9 0A 
0401EA 04 
0401EB CD      0784 CALL    EXPR2			; Get second operand
0401EC F5 
0401ED 01 
0401EE 04 
0401EF CD      0785 CALL    DOIT			; Do the operation
0401F0 4D 
0401F1 0A 
0401F2 04 
0401F3 18      0786 JR      EXPR1A			; And continue
0401F4 EF 
               0787 ;
               0788 ; Level 5: Comparisons
               0789 ;
0401F5 CD      0790 EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F6 67 
0401F7 02 
0401F8 04 
0401F9 CD      0791 CALL    RELOP?			; Is it ">", "=" or "<"?
0401FA 15 
0401FB 0A 
0401FC 04 
0401FD C0      0792 RET     NZ			; No, so return
0401FE 47      0793 LD      B,A			; Store the first operator in B
0401FF FD      0794 INC     IY              	; Bump over operator
040200 23 
040201 CD      0795 CALL    NXT			;
040202 70 
040203 0A 
040204 04 
040205 CD      0796 CALL    RELOP?          	; Is it a compound operator?
040206 15 
040207 0A 
040208 04 
040209 20      0797 JR      NZ,EXPR2B		; No, so skip next bit
04020A 09 
04020B FD      0798 INC     IY			; Bump over operator
04020C 23 
04020D B8      0799 CP      B			; Compare with first
04020E CA      0800 JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
04020F 97 
040210 0C 
040211 04 
040212 80      0801 ADD     A,B
040213 47      0802 LD      B,A			; B: Unique code for the compound operator
040214 78      0803 EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08      0804 EX      AF,AF'
040216 FA      0805 JP      M,EXPR2S		; If it is a string, then branch here to handle it
040217 30 
040218 02 
040219 04 
04021A 08      0806 EX      AF,AF'
04021B D6      0807 SUB     4
04021C 04 
04021D FE      0808 CP      '>'-4
04021E 3A 
04021F 20      0809 JR      NZ,EXPR2C
040220 02 
040221 C6      0810 ADD     A,2
040222 02 
040223 CD      0811 EXPR2C:			CALL    SAVE1
040224 40 
040225 0A 
040226 04 
040227 CD      0812 CALL    EXPR3
040228 67 
040229 02 
04022A 04 
04022B CD      0813 CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022C 4D 
04022D 0A 
04022E 04 
04022F C9      0814 RET
               0815 ;
040230 08      0816 EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D      0817 DEC     A
040232 E6      0818 AND     7
040233 07 
040234 CD      0819 CALL    PUSHS           	; Save string on the stack
040235 B4 
040236 09 
040237 04 
040238 F5      0820 PUSH    AF              	; Save the operator
040239 CD      0821 CALL    EXPR3           	; Get the second string
04023A 67 
04023B 02 
04023C 04 
04023D 08      0822 EX      AF,AF'
04023E F2      0823 JP      P,TYPE_EV_
04023F 36 
040240 03 
040241 04 
040242 F1      0824 POP     AF
040243 4B      0825 LD      C,E             	; Length of string #2
040244 D1      0826 POP     DE
040245 21      0827 LD      HL,0
040246 00 
040247 00 
040248 00 
040249 39      0828 ADD     HL,SP
04024A 43      0829 LD      B,E             	; Length of string #1
04024B D5      0830 PUSH    DE
04024C 11      0831 LD      DE,ACCS
04024D 00 
04024E 4A 
04024F 04 
040250 EB      0832 EX      DE,HL
040251 CD      0833 CALL    DISPT2
040252 7C 
040253 0A 
040254 04 
040255 D1      0834 POP     DE
040256 EB      0835 EX      DE,HL
040257 7D      0836 LD	A,L
040258 21      0837 LD	HL,0
040259 00 
04025A 00 
04025B 00 
04025C 6F      0838 LD	L,A
04025D 39      0839 ADD     HL,SP
04025E F9      0840 LD      SP,HL
04025F EB      0841 EX      DE,HL
040260 AF      0842 XOR     A               	; Numeric marker
040261 4F      0843 LD      C,A             	; Integer marker
040262 08      0844 EX      AF,AF'
040263 FD      0845 LD      A,(IY)
040264 7E 
040265 00 
040266 C9      0846 RET
               0847 ;
               0848 ; Level 4: + and -
               0849 ;
040267 CD      0850 EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
040268 C4 
040269 02 
04026A 04 
04026B FE      0851 EXPR3A:			CP      '-'			; Is it "-"?
04026C 2D 
04026D 28      0852 JR      Z,EXPR3B		; Yes, so skip the next bit
04026E 09 
04026F FE      0853 CP      '+'			; Is it "+"?
040270 2B 
040271 C0      0854 RET     NZ			; No, so return
040272 08      0855 EX      AF,AF'			; Get the type
040273 FA      0856 JP      M,EXPR3S		; Branch here if string
040274 86 
040275 02 
040276 04 
040277 08      0857 EX      AF,AF'
040278 CD      0858 EXPR3B:			CALL    SAVE_EV			; Save the first operator
040279 3E 
04027A 0A 
04027B 04 
04027C CD      0859 CALL    EXPR4			; Fetch the second operator
04027D C4 
04027E 02 
04027F 04 
040280 CD      0860 CALL    DOIT			; Do the operation
040281 4D 
040282 0A 
040283 04 
040284 18      0861 JR      EXPR3A			; And continue
040285 E5 
               0862 ;
040286 08      0863 EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD      0864 INC     IY              	; Bump past the "+"
040288 23 
040289 CD      0865 CALL    PUSHS           	; Save the string on the stack
04028A B4 
04028B 09 
04028C 04 
04028D CD      0866 CALL    EXPR4           	; Fetch the second operator
04028E C4 
04028F 02 
040290 04 
040291 08      0867 EX      AF,AF'
040292 F2      0868 JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040293 36 
040294 03 
040295 04 
040296 01      0869 LD	BC, 0			; Clear BC
040297 00 
040298 00 
040299 00 
04029A 4B      0870 LD      C,E             	; C: Length of the second string
04029B D1      0871 POP     DE
04029C D5      0872 PUSH    DE
04029D 21      0873 LD      HL,ACCS
04029E 00 
04029F 4A 
0402A0 04 
               0874 ; BEGIN MISSING FROM BINARY
               0875 ; LD	A,E			;  E: Length of the first string
               0876 ; LD      DE,ACCS
               0877 ; LD	E,A 			; DE: Pointer to the end of the first string
               0878 ; END MISSING FROM BINARY
0402A1 54      0879 LD		D,H ; ADDED FROM BINARY
0402A2 79      0880 LD      A,C
0402A3 B7      0881 OR      A
0402A4 28      0882 JR      Z,EXP3S3
0402A5 0F 
0402A6 6F      0883 LD      L,A             	; Source
0402A7 83      0884 ADD     A,E
0402A8 5F      0885 LD      E,A             	; Destination
0402A9 3E      0886 LD      A,19
0402AA 13 
0402AB DA      0887 JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402AC 60 
0402AD 37 
0402AE 04 
0402AF D5      0888 PUSH    DE
0402B0 1D      0889 DEC     E
0402B1 2D      0890 DEC     L
0402B2 ED      0891 LDDR                    	; Copy
0402B3 B8 
0402B4 D1      0892 POP     DE
0402B5 D9      0893 EXP3S3:			EXX
0402B6 C1      0894 POP     BC
0402B7 CD      0895 CALL    POPS            	; Restore from stack
0402B8 DE 
0402B9 09 
0402BA 04 
0402BB D9      0896 EXX
0402BC F6      0897 OR      80H             	; Flag as a string
0402BD 80 
0402BE 08      0898 EX      AF,AF'
0402BF FD      0899 LD      A,(IY)			; Fetch the next character
0402C0 7E 
0402C1 00 
0402C2 18      0900 JR      EXPR3A			; And continue
0402C3 A7 
               0901 ;
               0902 ; Level 3: * / MOD DIV
               0903 ;
0402C4 CD      0904 EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402C5 E5 
0402C6 02 
0402C7 04 
0402C8 FE      0905 EXPR4A:			CP      '*'			; "*" is valid
0402C9 2A 
0402CA 28      0906 JR      Z,EXPR4B
0402CB 0B 
0402CC FE      0907 CP      '/'			; "/" is valid
0402CD 2F 
0402CE 28      0908 JR      Z,EXPR4B
0402CF 07 
0402D0 FE      0909 CP      MODK			; MOD token is valid
0402D1 83 
0402D2 28      0910 JR      Z,EXPR4B
0402D3 03 
0402D4 FE      0911 CP      DIVK			; DIV token is valid
0402D5 81 
0402D6 C0      0912 RET     NZ			; And return if it is anything else
0402D7 CD      0913 EXPR4B:			CALL    SAVE_EV
0402D8 3E 
0402D9 0A 
0402DA 04 
0402DB CD      0914 CALL    EXPR5
0402DC E5 
0402DD 02 
0402DE 04 
0402DF CD      0915 CALL    DOIT
0402E0 4D 
0402E1 0A 
0402E2 04 
0402E3 18      0916 JR      EXPR4A
0402E4 E3 
               0917 ;
               0918 ; Level 2: ^
               0919 ;
0402E5 CD      0920 EXPR5:			CALL    ITEM			; Get variable
0402E6 C5 
0402E7 03 
0402E8 04 
0402E9 B7      0921 OR      A               	; Test type
0402EA 08      0922 EX      AF,AF'          	; Save type
0402EB CD      0923 EXPR5A:			CALL    NXT			; Skip spaces
0402EC 70 
0402ED 0A 
0402EE 04 
0402EF FE      0924 CP      '^'			; Is the operator "^"?
0402F0 5E 
0402F1 C0      0925 RET     NZ			; No, so return
0402F2 CD      0926 CALL    SAVE_EV			; Save first operand
0402F3 3E 
0402F4 0A 
0402F5 04 
0402F6 CD      0927 CALL    ITEM			; Get second operand
0402F7 C5 
0402F8 03 
0402F9 04 
0402FA B7      0928 OR      A			; Test type
0402FB 08      0929 EX      AF,AF'			; Save type
0402FC CD      0930 CALL    DOIT			; Do the operation
0402FD 4D 
0402FE 0A 
0402FF 04 
040300 18      0931 JR      EXPR5A			; And continue
040301 E9 
               0932 ;
               0933 ; Evaluate a numeric expression
               0934 ;
040302 CD      0935 EXPRN:			CALL    EXPR			; Evaluate expression
040303 C7 
040304 01 
040305 04 
040306 08      0936 EX      AF,AF'			; Get the type
040307 F0      0937 RET     P			; And return if it is a number
040308 18      0938 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040309 2C 
               0939 ;
               0940 ; Evaluate a fixed-point expression
               0941 ;
04030A CD      0942 EXPRI:			CALL    EXPR			; Evaluate the expression
04030B C7 
04030C 01 
04030D 04 
04030E 08      0943 EX      AF,AF'			; Get the type
04030F F2      0944 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040310 62 
040311 06 
040312 04 
040313 18      0945 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040314 21 
               0946 ;
               0947 ; Evaluate a string expression
               0948 ;
040315 CD      0949 EXPRS:			CALL    EXPR			; Evaluate the expression
040316 C7 
040317 01 
040318 04 
040319 08      0950 EX      AF,AF'			; Get the type
04031A F8      0951 RET     M			; And return if it is a string
04031B 18      0952 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031C 19 
               0953 ;
               0954 ; Get a numeric variable
               0955 ;
04031D CD      0956 ITEMN:			CALL    ITEM			; Get the variable
04031E C5 
04031F 03 
040320 04 
040321 B7      0957 OR      A			; Test the type
040322 F0      0958 RET     P			; And return if it is a number
040323 18      0959 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040324 11 
               0960 ;
               0961 ; Get a fixed-point variable
               0962 ;
040325 CD      0963 ITEMI:			CALL    ITEM			; Get the variable
040326 C5 
040327 03 
040328 04 
040329 B7      0964 OR      A			; Test the type
04032A F2      0965 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04032B 62 
04032C 06 
04032D 04 
04032E 18      0966 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032F 06 
               0967 ;
               0968 ; Get a string variable
               0969 ;
040330 CD      0970 ITEMS:			CALL    ITEM			; Get the variable
040331 C5 
040332 03 
040333 04 
040334 B7      0971 OR      A			; Test the type
040335 F8      0972 RET     M			; If it is a string, then return
               0973 ;							; Otherwise
040336 3E      0974 TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040337 06 
040338 C3      0975 JP      ERROR_
040339 60 
04033A 37 
04033B 04 
               0976 ;
               0977 ; Evaluate a bracketed expression
               0978 ;
04033C CD      0979 ITEM1:			CALL    EXPR            	; Evaluate the expression
04033D C7 
04033E 01 
04033F 04 
040340 CD      0980 CALL    BRAKET			; Check for closing bracket
040341 2F 
040342 0A 
040343 04 
040344 08      0981 EX      AF,AF'
040345 C9      0982 RET
               0983 ;
               0984 ; HEX - Get hexadecimal constant.
               0985 ;   Inputs: ASCII string at (IY)
               0986 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               0987 ;           IY updated (points to delimiter)
               0988 ;
040346 CD      0989 HEX:			CALL    ZERO			; Set result to 0
040347 93 
040348 09 
040349 04 
04034A CD      0990 CALL    HEXDIG			; Fetch the character from IY
04034B F8 
04034C 09 
04034D 04 
04034E 38      0991 JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
04034F 1B 
040350 FD      0992 HEX1:			INC     IY			; Move pointer to next character
040351 23 
040352 E6      0993 AND     0FH			; Clear the top nibble
040353 0F 
040354 06      0994 LD      B,4			; Loop counter
040355 04 
               0995 ;
040356 D9      0996 HEX2:			EXX				; Shift the result left B (4) times. This makes
040357 52      0997 ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040358 29 
040359 D9      0998 EXX				; .
04035A 52      0999 ADC.S   HL,HL			; .
04035B ED 
04035C 6A 
04035D 10      1000 DJNZ    HEX2			; And loop
04035E F7 
04035F D9      1001 EXX
040360 B5      1002 OR      L			; OR in the digit
040361 6F      1003 LD      L,A
040362 D9      1004 EXX
               1005 ;
040363 CD      1006 CALL    HEXDIG			; Fetch the next character
040364 F8 
040365 09 
040366 04 
040367 30      1007 JR      NC,HEX1			; If it is a HEX digit then loop
040368 E7 
040369 AF      1008 XOR     A			; Clear A
04036A C9      1009 RET
               1010 ;
04036B 3E      1011 BADHEX:			LD      A,28
04036C 1C 
04036D C3      1012 JP      ERROR_          	; Error: "Bad HEX"
04036E 60 
04036F 37 
040370 04 
               1013 ;
               1014 ; BIN - Get binary constant.
               1015 ;   Inputs: ASCII string at (IY)
               1016 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               1017 ;           IY updated (points to delimiter)
               1018 ;
040371 CD      1019 BIN:			CALL    ZERO			; Set result to 0
040372 93 
040373 09 
040374 04 
040375 CD      1020 CALL	BINDIG			; Fetch the character from IY
040376 0B 
040377 0A 
040378 04 
040379 38      1021 JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037A 13 
04037B FD      1022 BIN1:			INC	IY			; Move pointer to next character
04037C 23 
04037D 0F      1023 RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04037E D9      1024 EXX				;
04037F 52      1025 ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040380 ED 
040381 6A 
040382 D9      1026 EXX
040383 52      1027 ADC.S	HL,HL
040384 ED 
040385 6A 
040386 CD      1028 CALL	BINDIG			; Fetch the next character
040387 0B 
040388 0A 
040389 04 
04038A 30      1029 JR	NC,BIN1
04038B EF 
04038C AF      1030 XOR	A			; Clear A
04038D C9      1031 RET
               1032 ;
04038E 3E      1033 BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
04038F 1C 
040390 CD      1034 CALL	EXTERR
040391 77 
040392 37 
040393 04 
040394 42      1035 DB	"Bad Binary", 0
040395 61 
040396 64 
040397 20 
040397 42   
040398 69 
040399 6E 
04039A 61 
04039A 72   
04039B 79 
04039C 00 
               1036 ;
               1037 ; MINUS - Unary minus.
               1038 ;   Inputs: IY = text pointer
               1039 ;  Outputs: Numeric result, same type as argument.
               1040 ;           Result in H'L'HLC
               1041 ;
04039F CD      1042 MINUS:			CALL    ITEMN			; Get the numeric argument
0403A0 1D 
0403A1 03 
0403A2 04 
0403A3 0D      1043 MINUS0:			DEC     C			; Check exponent (C)
0403A4 0C      1044 INC     C			; If it is zero, then it's either a FP zero or an integer
0403A5 28      1045 JR      Z,NEGATE_EV        	; So do an integer negation
0403A6 06 
               1046 ;
0403A7 7C      1047 LD      A,H			; Do a FP negation by
0403A8 EE      1048 XOR     80H             	; Toggling the sign bit (H)
0403A9 80 
0403AA 67      1049 LD      H,A
0403AB AF      1050 XOR     A               	; Numeric marker
0403AC C9      1051 RET
               1052 ;
0403AD D9      1053 NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403AE 7C      1054 LD      A,H			; First do a one's complement by negating all the bytes
0403AF 2F      1055 CPL
0403B0 67      1056 LD      H,A
0403B1 7D      1057 LD      A,L
0403B2 2F      1058 CPL
0403B3 6F      1059 LD      L,A
0403B4 D9      1060 EXX
0403B5 7C      1061 LD      A,H
0403B6 2F      1062 CPL
0403B7 67      1063 LD      H,A
0403B8 7D      1064 LD      A,L
0403B9 2F      1065 CPL
0403BA 6F      1066 LD      L,A
0403BB D9      1067 ADD1:			EXX				; Then add 1
0403BC 23      1068 INC     HL
0403BD 7C      1069 LD      A,H
0403BE B5      1070 OR      L
0403BF D9      1071 EXX
0403C0 3E      1072 LD      A,0             	; Numeric marker
0403C1 00 
0403C2 C0      1073 RET     NZ
0403C3 23      1074 INC     HL
0403C4 C9      1075 RET
               1076 ;
               1077 ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
               1078 ; Item type is returned in A:  Bit 7=0 numeric.
               1079 ;                              Bit 7=1 string.
               1080 ; Numeric item returned in HLH'L'C.
               1081 ; String item returned in string accumulator,
               1082 ;   DE addresses byte after last (E=length).
               1083 ;
0403C5 CD      1084 ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403C6 4F 
0403C7 16 
0403C8 04 
0403C9 CD      1085 CALL    NXT			; Skip spaces
0403CA 70 
0403CB 0A 
0403CC 04 
0403CD FD      1086 INC     IY			; Move to the prefix character
0403CE 23 
0403CF FE      1087 CP      '&'			; If `&`
0403D0 26 
0403D1 CA      1088 JP      Z,HEX           	; Then get a HEX constant
0403D2 46 
0403D3 03 
0403D4 04 
0403D5 FE      1089 CP	'%'			; If '%'
0403D6 25 
0403D7 28      1090 JR	Z,BIN			; Then get a BINARY constant
0403D8 98 
0403D9 FE      1091 CP      '-'			; If `-`
0403DA 2D 
0403DB 28      1092 JR      Z,MINUS         	; Then get a negative number
0403DC C2 
0403DD FE      1093 CP      '+'			; If `+`
0403DE 2B 
0403DF CA      1094 JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E0 1D 
0403E1 03 
0403E2 04 
0403E3 FE      1095 CP      '('			; If `(`
0403E4 28 
0403E5 CA      1096 JP      Z,ITEM1         	; Start of a bracketed expression
0403E6 3C 
0403E7 03 
0403E8 04 
0403E9 FE      1097 CP      34			; If `"`
0403EA 22 
0403EB 28      1098 JR      Z,CONS          	; Start of a string constant
0403EC 7A 
0403ED FE      1099 CP      TCMD_EV			; Is it out of range of the function table?
0403EE C6 
0403EF D2      1100 JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F0 97 
0403F1 0C 
0403F2 04 
0403F3 FE      1101 CP      FUNTOK			; If it is in range, then
0403F4 8D 
0403F5 D2      1102 JP      NC,DISPAT       	; It's a function
0403F6 83 
0403F7 0A 
0403F8 04 
0403F9 FD      1103 DEC     IY
0403FA 2B 
0403FB FE      1104 CP      ':'
0403FC 3A 
0403FD 30      1105 JR      NC,ITEM2		; VARIABLE?
0403FE 0C 
0403FF FE      1106 CP      '0'
040400 30 
040401 D2      1107 JP      NC,CON			; NUMERIC CONSTANT
040402 8E 
040403 04 
040404 04 
040405 FE      1108 CP      '.'
040406 2E 
040407 CA      1109 JP      Z,CON			; NUMERIC CONSTANT
040408 8E 
040409 04 
04040A 04 
04040B CD      1110 ITEM2:			CALL    GETVAR			; VARIABLE
04040C 3A 
04040D 3A 
04040E 04 
04040F 20      1111 JR      NZ,NOSUCH
040410 37 
040411 B7      1112 OR      A
040412 FA      1113 JP      M,LOADS			; STRING VARIABLE
040413 A0 
040414 04 
040415 04 
040416 B7      1114 LOADN:			OR      A
040417 28      1115 JR      Z,LOAD1			; BYTE VARIABLE
040418 20 
040419 0E      1116 LD      C,0
04041A 00 
04041B CB      1117 BIT     0,A
04041C 47 
04041D 28      1118 JR      Z,LOAD4			; INTEGER VARIABLE
04041E 03 
04041F DD      1119 LOAD5:			LD      C,(IX+4)
040420 4E 
040421 04 
040422 D9      1120 LOAD4:			EXX
040423 21      1121 LD	HL, 0			; TODO: Optimise
040424 00 
040425 00 
040426 00 
040427 DD      1122 LD      L,(IX+0)
040428 6E 
040429 00 
04042A DD      1123 LD      H,(IX+1)
04042B 66 
04042C 01 
04042D D9      1124 EXX
04042E 21      1125 LD	HL, 0			; TODO: Optimise
04042F 00 
040430 00 
040431 00 
040432 DD      1126 LD      L,(IX+2)
040433 6E 
040434 02 
040435 DD      1127 LD      H,(IX+3)
040436 66 
040437 03 
040438 C9      1128 RET
               1129 ;
040439 21      1130 LOAD1:			LD      HL,0
04043A 00 
04043B 00 
04043C 00 
04043D D9      1131 EXX
04043E 21      1132 LD      HL,0			; TODO: Optimise
04043F 00 
040440 00 
040441 00 
040442 DD      1133 LD      L,(IX+0)
040443 6E 
040444 00 
040445 D9      1134 EXX
040446 4C      1135 LD      C,H
040447 C9      1136 RET
               1137 ;
040448 DA      1138 NOSUCH:			JP      C,SYNTAX
040449 97 
04044A 0C 
04044B 04 
04044C 3A      1139 LD      A,(LISTON)
04044D 40 
04044E 4D 
04044F 04 
040450 CB      1140 BIT     5,A
040451 6F 
040452 3E      1141 LD      A,26
040453 1A 
040454 20      1142 JR      NZ,ERROR0_EV		; Throw "No such variable"
040455 26 
040456 FD      1143 NOS1:			INC     IY
040457 23 
040458 CD      1144 CALL    RANGE
040459 6F 
04045A 3C 
04045B 04 
04045C 30      1145 JR      NC,NOS1
04045D F8 
04045E DD      1146 LD      IX,PC
04045F 21 
040460 40 
040461 4C 
040461 04   
040463 AF      1147 XOR     A
040464 4F      1148 LD      C,A
040465 18      1149 JR      LOAD4
040466 BB 
               1150 ;
               1151 ;CONS - Get string constant from ASCII string.
               1152 ;   Inputs: ASCII string at (IY)
               1153 ;  Outputs: Result in string accumulator.
               1154 ;           D = MS byte of ACCS, E = string length
               1155 ;           A7 = 1 (string marker)
               1156 ;           IY updated
               1157 ;
040467 11      1158 CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040468 00 
040469 4A 
04046A 04 
04046B FD      1159 CONS3:			LD      A,(IY)			; Fetch the first character and
04046C 7E 
04046D 00 
04046E FD      1160 INC     IY			; Increment the pointer
04046F 23 
040470 FE      1161 CP      '"'			; Check for start quote
040471 22 
040472 28      1162 JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040473 0C 
               1163 ;
040474 12      1164 CONS1:			LD      (DE),A			; Store the character in the string accumulator
040475 1C      1165 INC     E			; Increment the string accumulator pointer
040476 FE      1166 CP      CR			; Is it CR
040477 0D 
040478 20      1167 JR      NZ,CONS3		; No, so keep looping
040479 F1 
               1168 ;
04047A 3E      1169 LD      A,9
04047B 09 
04047C C3      1170 ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
04047D 60 
04047E 37 
04047F 04 
               1171 ;
040480 FD      1172 CONS2:			LD      A,(IY)			; Fetch the next character
040481 7E 
040482 00 
040483 FE      1173 CP      '"'			; Check for end quote?
040484 22 
040485 FD      1174 INC     IY			; Increment the pointer
040486 23 
040487 28      1175 JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040488 EB 
040489 FD      1176 DEC     IY			;
04048A 2B 
04048B 3E      1177 LD      A,80H           	; String marker
04048C 80 
04048D C9      1178 RET
               1179 ;
               1180 ;CON - Get unsigned numeric constant from ASCII string.
               1181 ;   Inputs: ASCII string at (IY).
               1182 ;  Outputs: Variable-type result in HLH'L'C
               1183 ;           IY updated (points to delimiter)
               1184 ;           A7 = 0 (numeric marker)
               1185 ;
04048E FD      1186 CON:			PUSH    IY
04048F E5 
040490 DD      1187 POP     IX
040491 E1 
040492 3E      1188 LD      A,36
040493 24 
040494 CD      1189 CALL    FPP
040495 6A 
040496 20 
040497 04 
040498 38      1190 JR      C,ERROR0_EV
040499 E2 
04049A DD      1191 PUSH    IX
04049B E5 
04049C FD      1192 POP     IY
04049D E1 
04049E AF      1193 XOR     A
04049F C9      1194 RET
               1195 ;
0404A0 11      1196 LOADS:			LD      DE,ACCS			; Where to store the string
0404A1 00 
0404A2 4A 
0404A3 04 
0404A4 1F      1197 RRA
0404A5 30      1198 JR      NC,LOADS2       	; Skip if it is a fixed string
0404A6 1A 
               1199 ;
0404A7 D9      1200 EXX				; This block was a call to LOAD4
0404A8 DD      1201 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404A9 6E 
0404AA 00 
0404AB DD      1202 LD      H,(IX+1)		; The maximum original string length
0404AC 66 
0404AD 01 
0404AE D9      1203 EXX
0404AF DD      1204 LD	HL,(IX+2)		; Address of the string (24-bit)
0404B0 27 
0404B1 02 
               1205 ;
0404B2 D9      1206 EXX
0404B3 7D      1207 LD      A,L
0404B4 D9      1208 EXX
0404B5 B7      1209 OR      A
0404B6 01      1210 LD	BC,0			; BC: Number of bytes to copy
0404B7 00 
0404B8 00 
0404B9 00 
0404BA 4F      1211 LD      C,A
0404BB 3E      1212 LD      A,80H           	; String marker
0404BC 80 
0404BD C8      1213 RET     Z
0404BE ED      1214 LDIR
0404BF B0 
0404C0 C9      1215 RET
0404C1 7E      1216 LOADS2:			LD      A,(HL)
0404C2 12      1217 LD      (DE),A
0404C3 23      1218 INC     HL
0404C4 FE      1219 CP      CR
0404C5 0D 
0404C6 3E      1220 LD      A,80H           	; String marker
0404C7 80 
0404C8 C8      1221 RET     Z
0404C9 1C      1222 INC     E
0404CA 20      1223 JR      NZ,LOADS2
0404CB F5 
0404CC C9      1224 RET                     	; Return null string
               1225 ;
               1226 ;VARIABLE-TYPE FUNCTIONS:
               1227 ;
               1228 ;Result returned in HLH'L'C (floating point)
               1229 ;Result returned in HLH'L' (C=0) (integer)
               1230 ;Result returned in string accumulator & DE (string)
               1231 ;All registers destroyed.
               1232 ;IY (text pointer) updated.
               1233 ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
               1234 ;
               1235 ;POS - horizontal cursor position.
               1236 ;VPOS - vertical cursor position.
               1237 ;EOF - return status of file.
               1238 ;BGET - read byte from file.
               1239 ;INKEY - as GET but wait only n centiseconds.
               1240 ;GET - wait for keypress and return ASCII value.
               1241 ;GET(n) - input from Z80 port n.
               1242 ;ASC - ASCII value of string.
               1243 ;LEN - length of string.
               1244 ;LOMEM - location of dynamic variables.
               1245 ;HIMEM - top of available RAM.
               1246 ;PAGE - start of current text page.
               1247 ;TOP - address of first free byte after program.
               1248 ;ERL - line number where last error occurred.
               1249 ;ERR - number of last error.
               1250 ;COUNT - number of printing characters since CR.
               1251 ;Results are integer numeric.
               1252 ;
0404CD CD      1253 POS:			CALL    GETCSR			; Return the horizontal cursor position
0404CE CC 
0404CF 3E 
0404D0 04 
0404D1 EB      1254 EX      DE,HL			;  L: The X cursor position
0404D2 C3      1255 JP      COUNT1			; Return an 8-bit value
0404D3 81 
0404D4 05 
0404D5 04 
               1256 ;
0404D6 CD      1257 VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404D7 CC 
0404D8 3E 
0404D9 04 
0404DA C3      1258 JP      COUNT1			; Return an 8-bit value
0404DB 81 
0404DC 05 
0404DD 04 
               1259 ;
0404DE CD      1260 EOF:			CALL    CHANEL			; Check for EOF
0404DF 86 
0404E0 18 
0404E1 04 
0404E2 CD      1261 CALL    OSSTAT
0404E3 44 
0404E4 43 
0404E5 04 
0404E6 CA      1262 JP      Z,TRUE			; Yes, so return true
0404E7 05 
0404E8 06 
0404E9 04 
0404EA C3      1263 JP      ZERO			; Otherwise return false (zero)
0404EB 93 
0404EC 09 
0404ED 04 
               1264 ;
0404EE CD      1265 BGET:			CALL    CHANEL          	; Channel number
0404EF 86 
0404F0 18 
0404F1 04 
0404F2 CD      1266 CALL    OSBGET
0404F3 33 
0404F4 43 
0404F5 04 
0404F6 6F      1267 LD      L,A
0404F7 C3      1268 JP      COUNT0			; Return an 8-bit value
0404F8 7F 
0404F9 05 
0404FA 04 
               1269 ;
0404FB CD      1270 INKEY:			CALL    ITEMI			; Get the argument
0404FC 25 
0404FD 03 
0404FE 04 
0404FF CB      1271 BIT	7, H			; Check the sign
040500 7C 
040501 D9      1272 EXX				; HL: The argument
040502 C2      1273 JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040503 EB 
040504 07 
040505 04 
040506 CD      1274 CALL	INKEY0 			; Do INKEY(n)
040507 DD 
040508 07 
040509 04 
04050A 18      1275 JR      ASC0			; Return a numeric value
04050B 1D 
               1276 ;
04050C CD      1277 GET:			CALL    NXT			; Skip whitespace
04050D 70 
04050E 0A 
04050F 04 
040510 FE      1278 CP      '('			; Is it GET(
040511 28 
040512 20      1279 JR      NZ,GET0			; No, so get a keyboard character
040513 0B 
040514 CD      1280 CALL    ITEMI           	; Yes, so fetch the port address
040515 25 
040516 03 
040517 04 
040518 D9      1281 EXX
040519 44      1282 LD      B,H			; BC: The port address
04051A 4D      1283 LD      C,L
04051B ED      1284 IN      L,(C)           	;  L: Input from port BC
04051C 68 
04051D 18      1285 JR      COUNT0			; Return an 8-bit value
04051E 60 
               1286 ;
04051F CD      1287 GET0:			CALL    GETS			; Read the keyboard character
040520 C7 
040521 07 
040522 04 
040523 18      1288 JR      ASC1			; And return the value
040524 0A 
               1289 ;
040525 CD      1290 ASC:			CALL    ITEMS			; Get the string argument argument
040526 30 
040527 03 
040528 04 
040529 AF      1291 ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052A BB      1292 CP      E			; Is the pointer 0
04052B CA      1293 JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04052C 05 
04052D 06 
04052E 04 
04052F 2A      1294 ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040530 00 
040531 4A 
040532 04 
040533 18      1295 JR      COUNT0			; An 8-bit value
040534 4A 
               1296 ;
040535 CD      1297 LEN:			CALL    ITEMS			; Get the string argument
040536 30 
040537 03 
040538 04 
040539 EB      1298 EX      DE,HL			; HL: Pointer into ACCS
04053A 18      1299 JR      COUNT0			; Return L
04053B 43 
               1300 ;
04053C 2A      1301 LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
04053D 1A 
04053E 4D 
04053F 04 
040540 3A      1302 LD	A, (LOMEM+2)
040541 1C 
040542 4D 
040543 04 
040544 18      1303 JR      COUNT2			; A 24-bit value
040545 41 
               1304 ;
040546 2A      1305 HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
040547 20 
040548 4D 
040549 04 
04054A 3A      1306 LD	A, (HIMEM+2)
04054B 22 
04054C 4D 
04054D 04 
04054E 18      1307 JR      COUNT2			; A 24-bit value
04054F 37 
               1308 ;
040550 2A      1309 PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040551 14 
040552 4D 
040553 04 
040554 3A      1310 LD	A, (PAGE_+2)		; A 24-bit value
040555 16 
040556 4D 
040557 04 
040558 18      1311 JR      COUNT2
040559 2D 
               1312 ;
04055A FD      1313 TOPV:			LD      A,(IY)			; Return the TOP system variable
04055B 7E 
04055C 00 
04055D FD      1314 INC     IY              	; Skip "P"
04055E 23 
04055F FE      1315 CP      'P'
040560 50 
040561 C2      1316 JP      NZ,SYNTAX       	; Throw "Syntax Error"
040562 97 
040563 0C 
040564 04 
040565 2A      1317 LD      HL,(TOP)
040566 17 
040567 4D 
040568 04 
040569 3A      1318 LD	A, (TOP+2)
04056A 19 
04056B 4D 
04056C 04 
04056D 18      1319 JR      COUNT2
04056E 18 
               1320 ;
04056F 2A      1321 ERLV:			LD      HL,(ERL)		; Return the error line
040570 33 
040571 4D 
040572 04 
040573 18      1322 JR      COUNT1			; A 16-bit value
040574 0C 
               1323 ;
040575 2A      1324 ERRV:			LD      HL,(ERR)		; Return the error value
040576 3F 
040577 4D 
040578 04 
040579 18      1325 JR      COUNT0			; An 8-bit value
04057A 04 
               1326 ;
04057B 2A      1327 COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04057C 3D 
04057D 4D 
04057E 04 
               1328 
04057F 26      1329 COUNT0:			LD      H,0			; Return L
040580 00 
040581 D9      1330 COUNT1:			EXX				; Return HL
040582 AF      1331 XOR     A
040583 4F      1332 LD      C,A             	; Integer marker
040584 67      1333 LD      H,A
040585 6F      1334 LD      L,A
040586 C9      1335 RET
040587 D9      1336 COUNT2:			EXX
040588 6F      1337 LD	L,A
040589 AF      1338 XOR	A
04058A 4F      1339 LD	C,A			; Integer marker
04058B 67      1340 LD	H,A
04058C C9      1341 RET
               1342 ;
               1343 ;OPENIN - Open a file for reading.
               1344 ;OPENOT - Open a file for writing.
               1345 ;OPENUP - Open a file for reading or writing.
               1346 ;Result is integer channel number (0 if error)
               1347 ;
04058D AF      1348 OPENOT:			XOR     A			; Open for writing
04058E 18      1349 JR	OPENIN_1
04058F 06 
               1350 ;
040590 3E      1351 OPENUP:			LD      A,2			; Open for reading / writing
040591 02 
040592 18      1352 JR	OPENIN_1
040593 02 
               1353 ;
040594 3E      1354 OPENIN:			LD      A,1			; Open for reading
040595 01 
               1355 ;
040596 F5      1356 OPENIN_1:		PUSH    AF              	; Save OPEN type
040597 CD      1357 CALL    ITEMS           	; Fetch the filename
040598 30 
040599 03 
04059A 04 
04059B 3E      1358 LD      A,CR
04059C 0D 
04059D 12      1359 LD      (DE),A
04059E F1      1360 POP     AF              	; Restore the OPEN type
04059F C6      1361 ADD     A,-1            	; Affect the flags
0405A0 FF 
0405A1 21      1362 LD      HL,ACCS
0405A2 00 
0405A3 4A 
0405A4 04 
0405A5 CD      1363 CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405A6 1C 
0405A7 43 
0405A8 04 
0405A9 6F      1364 LD      L,A			; L: Channel number
0405AA 18      1365 JR      COUNT0			; Return channel number to BASIC
0405AB D3 
               1366 ;
               1367 ;EXT - Return length of file.
               1368 ;PTR_EV - Return current file pointer.
               1369 ;Results are integer numeric.
               1370 ;
0405AC CD      1371 EXT:			CALL    CHANEL
0405AD 86 
0405AE 18 
0405AF 04 
0405B0 CD      1372 CALL    GETEXT
0405B1 7A 
0405B2 43 
0405B3 04 
0405B4 18      1373 JR      TIME0
0405B5 15 
               1374 ;
0405B6 CD      1375 PTR_EV:			CALL    CHANEL
0405B7 86 
0405B8 18 
0405B9 04 
0405BA CD      1376 CALL    GETPTR
0405BB 4E 
0405BC 43 
0405BD 04 
0405BE 18      1377 JR      TIME0
0405BF 0B 
               1378 ;
               1379 ;TIME - Return current value of elapsed time.
               1380 ;Result is integer numeric.
               1381 ;
0405C0 FD      1382 TIMEV:			LD      A,(IY)
0405C1 7E 
0405C2 00 
0405C3 FE      1383 CP      '$'
0405C4 24 
0405C5 28      1384 JR      Z,TIMEVS
0405C6 0A 
0405C7 CD      1385 CALL    GETIME
0405C8 AC 
0405C9 3E 
0405CA 04 
0405CB D5      1386 TIME0:			PUSH    DE
0405CC D9      1387 EXX
0405CD E1      1388 POP     HL
0405CE AF      1389 XOR     A
0405CF 4F      1390 LD      C,A
0405D0 C9      1391 RET
               1392 ;
               1393 ;TIME$ - Return date/time string.
               1394 ;Result is string
               1395 ;
0405D1 FD      1396 TIMEVS:			INC     IY              ;SKIP $
0405D2 23 
0405D3 CD      1397 CALL    GETIMS
0405D4 93 
0405D5 43 
0405D6 04 
0405D7 3E      1398 LD      A,80H           ;MARK STRING
0405D8 80 
0405D9 C9      1399 RET
               1400 ;
               1401 ;String comparison:
               1402 ;
0405DA CD      1403 SLT:			CALL    SCP
0405DB 8F 
0405DC 09 
0405DD 04 
0405DE D0      1404 RET     NC
0405DF 18      1405 JR      TRUE
0405E0 24 
               1406 ;
0405E1 CD      1407 SGT:			CALL    SCP
0405E2 8F 
0405E3 09 
0405E4 04 
0405E5 C8      1408 RET     Z
0405E6 D8      1409 RET     C
0405E7 18      1410 JR      TRUE
0405E8 1C 
               1411 ;
0405E9 CD      1412 SGE:			CALL    SCP
0405EA 8F 
0405EB 09 
0405EC 04 
0405ED D8      1413 RET     C
0405EE 18      1414 JR      TRUE
0405EF 15 
               1415 ;
0405F0 CD      1416 SLE:			CALL    SCP
0405F1 8F 
0405F2 09 
0405F3 04 
0405F4 28      1417 JR      Z,TRUE
0405F5 0F 
0405F6 D0      1418 RET     NC
0405F7 18      1419 JR      TRUE
0405F8 0C 
               1420 ;
0405F9 CD      1421 SNE:			CALL    SCP
0405FA 8F 
0405FB 09 
0405FC 04 
0405FD C8      1422 RET     Z
0405FE 18      1423 JR      TRUE
0405FF 05 
               1424 ;
040600 CD      1425 SEQ:			CALL    SCP
040601 8F 
040602 09 
040603 04 
040604 C0      1426 RET     NZ
040605 3E      1427 TRUE:			LD      A,-1
040606 FF 
040607 D9      1428 EXX
040608 67      1429 LD      H,A
040609 6F      1430 LD      L,A
04060A D9      1431 EXX
04060B 67      1432 LD      H,A
04060C 6F      1433 LD      L,A
04060D 3C      1434 INC     A
04060E 4F      1435 LD      C,A
04060F C9      1436 RET
               1437 ;
               1438 ;PI - Return PI (3.141592654)
               1439 ;Result is floating-point numeric.
               1440 ;
040610 3E      1441 PI:			LD      A,35
040611 23 
040612 18      1442 JR      FPP1
040613 44 
               1443 ;
               1444 ;ABS - Absolute value
               1445 ;Result is numeric, variable type.
               1446 ;
040614 3E      1447 ABSV:			LD      A,16
040615 10 
040616 18      1448 JR      FPPN
040617 3A 
               1449 ;
               1450 ;NOT - Complement integer.
               1451 ;Result is integer numeric.
               1452 ;
040618 3E      1453 NOTK:			LD      A,26
040619 1A 
04061A 18      1454 JR      FPPN
04061B 36 
               1455 ;
               1456 ;DEG - Convert radians to degrees
               1457 ;Result is floating-point numeric.
               1458 ;
04061C 3E      1459 DEG:			LD      A,21
04061D 15 
04061E 18      1460 JR      FPPN
04061F 32 
               1461 ;
               1462 ;RAD - Convert degrees to radians
               1463 ;Result is floating-point numeric.
               1464 ;
040620 3E      1465 RAD:			LD      A,27
040621 1B 
040622 18      1466 JR      FPPN
040623 2E 
               1467 ;
               1468 ;SGN - Return -1, 0 or +1
               1469 ;Result is integer numeric.
               1470 ;
040624 3E      1471 SGN:			LD      A,28
040625 1C 
040626 18      1472 JR      FPPN
040627 2A 
               1473 ;
               1474 ;INT - Floor function
               1475 ;Result is integer numeric.
               1476 ;
040628 3E      1477 INT_:			LD      A,23
040629 17 
04062A 18      1478 JR      FPPN
04062B 26 
               1479 ;
               1480 ;SQR - square root
               1481 ;Result is floating-point numeric.
               1482 ;
04062C 3E      1483 SQR:			LD      A,30
04062D 1E 
04062E 18      1484 JR      FPPN
04062F 22 
               1485 ;
               1486 ;TAN - Tangent function
               1487 ;Result is floating-point numeric.
               1488 ;
040630 3E      1489 TAN:			LD      A,31
040631 1F 
040632 18      1490 JR      FPPN
040633 1E 
               1491 ;
               1492 ;COS - Cosine function
               1493 ;Result is floating-point numeric.
               1494 ;
040634 3E      1495 COS:			LD      A,20
040635 14 
040636 18      1496 JR      FPPN
040637 1A 
               1497 ;
               1498 ;SIN - Sine function
               1499 ;Result is floating-point numeric.
               1500 ;
040638 3E      1501 SIN:			LD      A,29
040639 1D 
04063A 18      1502 JR      FPPN
04063B 16 
               1503 ;
               1504 ;EXP - Exponential function
               1505 ;Result is floating-point numeric.
               1506 ;
04063C 3E      1507 EXP:			LD      A,22
04063D 16 
04063E 18      1508 JR      FPPN
04063F 12 
               1509 ;
               1510 ;LN - Natural log.
               1511 ;Result is floating-point numeric.
               1512 ;
040640 3E      1513 LN:			LD      A,24
040641 18 
040642 18      1514 JR      FPPN
040643 0E 
               1515 ;
               1516 ;LOG - base-10 logarithm.
               1517 ;Result is floating-point numeric.
               1518 ;
040644 3E      1519 LOG:			LD      A,25
040645 19 
040646 18      1520 JR      FPPN
040647 0A 
               1521 ;
               1522 ;ASN - Arc-sine
               1523 ;Result is floating-point numeric.
               1524 ;
040648 3E      1525 ASN:			LD      A,18
040649 12 
04064A 18      1526 JR      FPPN
04064B 06 
               1527 ;
               1528 ;ATN - arc-tangent
               1529 ;Result is floating-point numeric.
               1530 ;
04064C 3E      1531 ATN:			LD      A,19
04064D 13 
04064E 18      1532 JR      FPPN
04064F 02 
               1533 ;
               1534 ;ACS - arc-cosine
               1535 ;Result is floating point numeric.
               1536 ;
040650 3E      1537 ACS:			LD      A,17
040651 11 
040652 F5      1538 FPPN:			PUSH    AF
040653 CD      1539 CALL    ITEMN
040654 1D 
040655 03 
040656 04 
040657 F1      1540 POP     AF
040658 CD      1541 FPP1:			CALL    FPP
040659 6A 
04065A 20 
04065B 04 
04065C DA      1542 JP      C,ERROR_
04065D 60 
04065E 37 
04065F 04 
040660 AF      1543 XOR     A
040661 C9      1544 RET
               1545 ;
               1546 ;SFIX - Convert to fixed-point notation
               1547 ;
040662 3E      1548 SFIX:			LD      A,38
040663 26 
040664 18      1549 JR      FPP1
040665 F2 
               1550 ;
               1551 ;SFLOAT - Convert to floating-point notation
               1552 ;
040666 3E      1553 SFLOAT:			LD      A,39
040667 27 
040668 18      1554 JR      FPP1
040669 EE 
               1555 ;
               1556 ;VAL - Return numeric value of string.
               1557 ;Result is variable type numeric.
               1558 ;
04066A CD      1559 VAL:			CALL    ITEMS
04066B 30 
04066C 03 
04066D 04 
04066E AF      1560 VAL0:			XOR     A
04066F 12      1561 LD      (DE),A
040670 DD      1562 LD      IX,ACCS
040671 21 
040672 00 
040673 4A 
040673 04   
040675 3E      1563 LD      A,36
040676 24 
040677 18      1564 JR      FPP1
040678 DF 
               1565 ;
               1566 ;EVAL - Pass string to expression evaluator.
               1567 ;Result is variable type (numeric or string).
               1568 ;
040679 CD      1569 EVAL_:			CALL    ITEMS
04067A 30 
04067B 03 
04067C 04 
04067D 3E      1570 LD      A,CR
04067E 0D 
04067F 12      1571 LD      (DE),A
040680 FD      1572 PUSH    IY
040681 E5 
040682 11      1573 LD      DE,ACCS
040683 00 
040684 4A 
040685 04 
040686 FD      1574 LD      IY,ACCS
040687 21 
040688 00 
040689 4A 
040689 04   
04068B 0E      1575 LD      C,0
04068C 00 
04068D CD      1576 CALL    LEXAN2          ;TOKENISE
04068E 9F 
04068F 3C 
040690 04 
040691 12      1577 LD      (DE),A
040692 13      1578 INC     DE
040693 AF      1579 XOR     A
040694 CD      1580 CALL    PUSHS           ;PUT ON STACK
040695 B4 
040696 09 
040697 04 
040698 FD      1581 LD      IY,SIZEW	;WAS 2
040699 21 
04069A 03 
04069B 00 
04069B 00   
04069D FD      1582 ADD     IY,SP
04069E 39 
04069F CD      1583 CALL    EXPR
0406A0 C7 
0406A1 01 
0406A2 04 
0406A3 FD      1584 POP     IY
0406A4 E1 
0406A5 FD      1585 ADD     IY,SP
0406A6 39 
0406A7 FD      1586 LD      SP,IY           ;ADJUST STACK POINTER
0406A8 F9 
0406A9 FD      1587 POP     IY
0406AA E1 
0406AB 08      1588 EX      AF,AF'
0406AC C9      1589 RET
               1590 ;
               1591 ;RND - Random number function.
               1592 ; RND gives random integer 0-&FFFFFFFF
               1593 ; RND(-n) seeds random number & returns -n.
               1594 ; RND(0) returns last value in RND(1) form.
               1595 ; RND(1) returns floating-point 0-0.99999999.
               1596 ; RND(n) returns random integer 1-n.
               1597 ;
0406AD DD      1598 RND:			LD      IX,RANDOM
0406AE 21 
0406AF 38 
0406B0 4D 
0406B0 04   
0406B2 CD      1599 CALL    NXT
0406B3 70 
0406B4 0A 
0406B5 04 
0406B6 FE      1600 CP      '('
0406B7 28 
0406B8 28      1601 JR      Z,RND5          ;ARGUMENT FOLLOWS
0406B9 20 
0406BA CD      1602 CALL    LOAD5
0406BB 1F 
0406BC 04 
0406BD 04 
0406BE CB      1603 RND1:			RR      C
0406BF 19 
0406C0 06      1604 LD      B,32
0406C1 20 
0406C2 D9      1605 RND2:			EXX                     ;CALCULATE NEXT
0406C3 52      1606 ADC.S   HL,HL
0406C4 ED 
0406C5 6A 
0406C6 D9      1607 EXX
0406C7 52      1608 ADC.S   HL,HL
0406C8 ED 
0406C9 6A 
0406CA CB      1609 BIT     3,L
0406CB 5D 
0406CC 28      1610 JR      Z,RND3
0406CD 01 
0406CE 3F      1611 CCF
0406CF 10      1612 RND3:			DJNZ    RND2
0406D0 F1 
0406D1 CB      1613 RND4:			RL      C               ;SAVE CARRY
0406D2 11 
0406D3 CD      1614 CALL    STORE5          ;STORE NEW NUMBER
0406D4 DB 
0406D5 15 
0406D6 04 
0406D7 AF      1615 XOR     A
0406D8 4F      1616 LD      C,A
0406D9 C9      1617 RET
0406DA CD      1618 RND5:			CALL    ITEMI
0406DB 25 
0406DC 03 
0406DD 04 
0406DE DD      1619 LD      IX,RANDOM
0406DF 21 
0406E0 38 
0406E1 4D 
0406E1 04   
0406E3 CB      1620 BIT     7,H             ;NEGATIVE?
0406E4 7C 
0406E5 37      1621 SCF
0406E6 20      1622 JR      NZ,RND4         ;SEED
0406E7 E9 
0406E8 CD      1623 CALL    TEST
0406E9 DF 
0406EA 08 
0406EB 04 
0406EC F5      1624 PUSH    AF
0406ED CD      1625 CALL    SWAP
0406EE D7 
0406EF 08 
0406F0 04 
0406F1 D9      1626 EXX
0406F2 CD      1627 CALL    LOAD5
0406F3 1F 
0406F4 04 
0406F5 04 
0406F6 C4      1628 CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406F7 BE 
0406F8 06 
0406F9 04 
0406FA D9      1629 EXX                     ;SCRAMBLE (CARE!)
0406FB 0E      1630 LD      C,7FH
0406FC 7F 
0406FD CB      1631 RND6:			BIT     7,H             ;FLOAT
0406FE 7C 
0406FF 20      1632 JR      NZ,RND7
040700 0A 
040701 D9      1633 EXX
040702 52      1634 ADD.S   HL,HL
040703 29 
040704 D9      1635 EXX
040705 52      1636 ADC.S   HL,HL
040706 ED 
040707 6A 
040708 0D      1637 DEC     C
040709 20      1638 JR      NZ,RND6
04070A F2 
04070B CB      1639 RND7:			RES     7,H             ;POSITIVE 0-0.999999
04070C BC 
04070D F1      1640 POP     AF
04070E C8      1641 RET     Z               ;ZERO ARGUMENT
04070F D9      1642 EXX
040710 7B      1643 LD      A,E
040711 3D      1644 DEC     A
040712 B2      1645 OR      D
040713 D9      1646 EXX
040714 B3      1647 OR      E
040715 B2      1648 OR      D
040716 C8      1649 RET     Z               ;ARGUMENT=1
040717 06      1650 LD      B,0             ;INTEGER MARKER
040718 00 
040719 3E      1651 LD      A,10
04071A 0A 
04071B CD      1652 CALL    FPP             ;MULTIPLY
04071C 6A 
04071D 20 
04071E 04 
04071F DA      1653 JP      C,ERROR_
040720 60 
040721 37 
040722 04 
040723 CD      1654 CALL    SFIX
040724 62 
040725 06 
040726 04 
040727 C3      1655 JP      ADD1
040728 BB 
040729 03 
04072A 04 
               1656 ;
               1657 ; INSTR - String search.
               1658 ; Result is integer numeric.
               1659 ;
04072B CD      1660 INSTR:			CALL    EXPRSC			; Get the first string expression
04072C 1E 
04072D 0A 
04072E 04 
04072F CD      1661 CALL    PUSHS           	; Push the string onto the stack
040730 B4 
040731 09 
040732 04 
040733 CD      1662 CALL    EXPRS           	; Get the second string expression
040734 15 
040735 03 
040736 04 
040737 C1      1663 POP     BC			;  C: String length, B: Value of A before PUSHS was called
040738 21      1664 LD      HL,0
040739 00 
04073A 00 
04073B 00 
04073C 39      1665 ADD     HL,SP           	; HL: Pointer to main string
04073D C5      1666 PUSH    BC              	;  C: Main string length
04073E 43      1667 LD      B,E             	;  B: Sub-string length
04073F CD      1668 CALL    NXT			; Skip whitespace
040740 70 
040741 0A 
040742 04 
040743 FE      1669 CP      ','			; Check if there is a comma for the third parameter
040744 2C 
040745 3E      1670 LD      A,0			;  A: Default start position in string
040746 00 
040747 20      1671 JR      NZ,INSTR1		; No, so skip the next bit
040748 1A 
040749 FD      1672 INC     IY              	; Skip the comma
04074A 23 
04074B C5      1673 PUSH    BC              	; Save the lengths
04074C E5      1674 PUSH    HL              	; Save the pointer to the main string
04074D CD      1675 CALL    PUSHS			; Push the string onto the stack
04074E B4 
04074F 09 
040750 04 
040751 CD      1676 CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040752 0A 
040753 03 
040754 04 
040755 C1      1677 POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040756 CD      1678 CALL    POPS			; Pop the string off the stack
040757 DE 
040758 09 
040759 04 
04075A E1      1679 POP     HL              	; Restore the pointer to the main string
04075B C1      1680 POP     BC              	; Restore the lengths
04075C D9      1681 EXX
04075D 7D      1682 LD      A,L			; A: The start position in the  string
04075E D9      1683 EXX
04075F B7      1684 OR      A			; Set the flags
040760 28      1685 JR      Z,INSTR1		; If it is zero, then skip
040761 01 
040762 3D      1686 DEC     A
040763 11      1687 INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040764 00 
040765 4A 
040766 04 
040767 CD      1688 CALL    SEARCH			; Do the search
040768 85 
040769 07 
04076A 04 
04076B D1      1689 POP     DE
04076C 28      1690 JR      Z,INSTR2        	; NB: Carry cleared
04076D 03 
04076E ED      1691 SBC     HL,HL
04076F 62 
040770 39      1692 ADD     HL,SP
040771 ED      1693 INSTR2:			SBC     HL,SP
040772 72 
040773 EB      1694 EX      DE,HL
040774 7D      1695 LD	A,L
040775 21      1696 LD      HL,0
040776 00 
040777 00 
040778 00 
040779 6F      1697 LD	L,A
04077A 39      1698 ADD     HL,SP
04077B F9      1699 LD      SP,HL
04077C EB      1700 EX      DE,HL
04077D CD      1701 CALL    BRAKET			; Check for closing bracket
04077E 2F 
04077F 0A 
040780 04 
040781 C3      1702 JP      COUNT1			; Return a numeric integer
040782 81 
040783 05 
040784 04 
               1703 ;
               1704 ; SEARCH - Search string for sub-string
               1705 ;    Inputs: Main string at HL length C
               1706 ;            Sub-string  at DE length B
               1707 ;            Starting offset A
               1708 ;   Outputs: NZ - not found
               1709 ;            Z - found at location HL-1
               1710 ;            Carry always cleared
               1711 ;
040785 C5      1712 SEARCH:			PUSH    BC			; Add the starting offset to HL
040786 01      1713 LD      BC,0
040787 00 
040788 00 
040789 00 
04078A 4F      1714 LD      C,A
04078B 09      1715 ADD     HL,BC           	; New start address
04078C C1      1716 POP     BC
04078D 91      1717 SUB     C			; If the starting offset > main string length, then do nothing
04078E 30      1718 JR      NC,SRCH4
04078F 2C 
040790 ED      1719 NEG
040791 44 
040792 4F      1720 LD      C,A             	; Remaining length
               1721 ;
040793 C5      1722 SRCH1:			PUSH    BC
040794 79      1723 LD	A,C
040795 01      1724 LD	BC,0
040796 00 
040797 00 
040798 00 
040799 4F      1725 LD	C,A
04079A 1A      1726 LD      A,(DE)
04079B ED      1727 CPIR                    	; Find the first character
04079C B1 
04079D 79      1728 LD      A,C
04079E C1      1729 POP     BC
04079F 20      1730 JR      NZ,SRCH4
0407A0 1B 
0407A1 4F      1731 LD      C,A
               1732 ;
               1733 ; This block of four instructions was commented as a bug fix by R.T.Russell
               1734 ;
0407A2 05      1735 DEC     B			; Bug fix
0407A3 B8      1736 CP      B			; Bug fix
0407A4 04      1737 INC     B			; Bug fix
0407A5 38      1738 JR      C,SRCH4			; Bug fix
0407A6 15 
               1739 ;
0407A7 C5      1740 PUSH    BC
0407A8 D5      1741 PUSH    DE
0407A9 E5      1742 PUSH    HL
0407AA 05      1743 DEC     B
0407AB 28      1744 JR      Z,SRCH3         	; Found!
0407AC 08 
0407AD 13      1745 SRCH2:			INC     DE
0407AE 1A      1746 LD      A,(DE)
0407AF BE      1747 CP      (HL)
0407B0 20      1748 JR      NZ,SRCH3
0407B1 03 
0407B2 23      1749 INC     HL
0407B3 10      1750 DJNZ    SRCH2
0407B4 F8 
0407B5 E1      1751 SRCH3:			POP     HL
0407B6 D1      1752 POP     DE
0407B7 C1      1753 POP     BC
0407B8 20      1754 JR      NZ,SRCH1
0407B9 D9 
0407BA AF      1755 XOR     A               	; Flags: Z, NC
0407BB C9      1756 RET                     	; Found
               1757 ;
0407BC F6      1758 SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407BD FF 
0407BE C9      1759 RET                     	; Not found
               1760 ;
               1761 ;CHRS - Return character with given ASCII value.
               1762 ;Result is string.
               1763 ;
0407BF CD      1764 CHRS:			CALL    ITEMI
0407C0 25 
0407C1 03 
0407C2 04 
0407C3 D9      1765 EXX
0407C4 7D      1766 LD      A,L
0407C5 18      1767 JR      GET1
0407C6 0E 
               1768 ;
               1769 ;GETS - Return key pressed as stringor character at position (X,Y).
               1770 ;Result is string.
               1771 ;
0407C7 CD      1772 GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407C8 70 
0407C9 0A 
0407CA 04 
0407CB FE      1773 CP	'('
0407CC 28 
0407CD CA      1774 JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407CE FC 
0407CF 43 
0407D0 04 
0407D1 CD      1775 CALL    OSRDCH
0407D2 29 
0407D3 3F 
0407D4 04 
0407D5 37      1776 GET1:			SCF
0407D6 18      1777 JR      INKEY1
0407D7 09 
               1778 ;
               1779 ; INKEYS - Wait up to n centiseconds for keypress.
               1780 ;          Return key pressed as string or null
               1781 ;          string if time elapsed.
               1782 ; Result is string.
               1783 ;
0407D8 CD      1784 INKEYS:			CALL    ITEMI			; Fetch the argument
0407D9 25 
0407DA 03 
0407DB 04 
0407DC D9      1785 EXX
0407DD CD      1786 INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407DE 32 
0407DF 3F 
0407E0 04 
0407E1 11      1787 INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E2 00 
0407E3 4A 
0407E4 04 
0407E5 12      1788 LD      (DE),A
0407E6 3E      1789 LD      A,80H
0407E7 80 
0407E8 D0      1790 RET     NC
0407E9 1C      1791 INC     E
0407EA C9      1792 RET
               1793 ;
               1794 ; INKEYM - Check immediately whether a given key is being pressed
               1795 ; Result is integer numeric
               1796 ;
               1797 INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407EB 3E     0001M LD	A, function
0407EC 1E 
0407ED 49     0002M RST.LIS	08h
0407EE CF 
0407EF 23      1798 INC	HL			; Index from 0
0407F0 7D      1799 LD	A, L			; Negate the LSB of the answer
0407F1 ED      1800 NEG
0407F2 44 
0407F3 4F      1801 LD	C, A			;  E: The positive keycode value
0407F4 3E      1802 LD	A, 1			; Throw an "Out of range" error
0407F5 01 
0407F6 FA      1803 JP	M, ERROR_		; if the argument < - 128
0407F7 60 
0407F8 37 
0407F9 04 
               1804 ;
0407FA 21      1805 LD	HL, BITLOOKUP		; HL: The bit lookup table
0407FB 1D 
0407FC 08 
0407FD 04 
0407FE 11      1806 LD	DE, 0
0407FF 00 
040800 00 
040801 00 
040802 79      1807 LD	A, C
040803 E6      1808 AND	00000111b		; Just need the first three bits
040804 07 
040805 5F      1809 LD	E, A			; DE: The bit number
040806 19      1810 ADD	HL, DE
040807 46      1811 LD	B, (HL)			;  B: The mask
               1812 ;
040808 79      1813 LD	A, C			; Fetch the keycode again
040809 E6      1814 AND	01111000b		; And divide by 8
04080A 78 
04080B 0F      1815 RRCA
04080C 0F      1816 RRCA
04080D 0F      1817 RRCA
04080E 5F      1818 LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04080F DD      1819 ADD	IX, DE			; IX: The address
040810 19 
040811 78      1820 LD	A, B			;  B: The mask
040812 DD      1821 AND	(IX+0)			; Check whether the bit is set
040813 A6 
040814 00 
040815 CA      1822 JP	Z, ZERO			; No, so return 0
040816 93 
040817 09 
040818 04 
040819 C3      1823 JP	TRUE			; Otherwise return -1
04081A 05 
04081B 06 
04081C 04 
               1824 ;
               1825 ; A bit lookup table
               1826 ;
04081D 01      1827 BITLOOKUP:		DB	01h, 02h, 04h, 08h
04081E 02 
04081F 04 
040820 08 
040821 10      1828 DB	10h, 20h, 40h, 80h
040822 20 
040823 40 
040824 80 
               1829 ;
               1830 ; MID$ - Return sub-string.
               1831 ; Result is string.
               1832 ;
040825 CD      1833 MIDS:			CALL    EXPRSC			; Get the first string expression
040826 1E 
040827 0A 
040828 04 
040829 CD      1834 CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082A B4 
04082B 09 
04082C 04 
04082D CD      1835 CALL    EXPRI			; Get the second expression
04082E 0A 
04082F 03 
040830 04 
040831 C1      1836 POP     BC			; C: String length, B: Value of A before PUSHS was called
040832 CD      1837 CALL    POPS			; Pop the string back off the stack to the string accumulator
040833 DE 
040834 09 
040835 04 
040836 D9      1838 EXX
040837 7D      1839 LD      A,L			; A: The start index
040838 D9      1840 EXX
040839 B7      1841 OR      A			; If the start index is 0, then we don't need to do the next bit
04083A 28      1842 JR      Z,MIDS1
04083B 0E 
04083C 3D      1843 DEC     A
04083D 6F      1844 LD      L,A			; L: The start index - 1
04083E 93      1845 SUB     E			; Subtract from the string length
04083F 1E      1846 LD      E,0			; Preemptively set the string length to 0
040840 00 
040841 30      1847 JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040842 07 
040843 ED      1848 NEG				; Negate the answer and
040844 44 
040845 4F      1849 LD      C,A			; C: Number of bytes to copy
040846 CD      1850 CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
040847 89 
040848 08 
040849 04 
04084A CD      1851 MIDS1:			CALL    NXT			; Skip whitespace
04084B 70 
04084C 0A 
04084D 04 
04084E FE      1852 CP      ','			; Check for a comma
04084F 2C 
040850 FD      1853 INC     IY			; Advance to the next character in the BASIC line
040851 23 
040852 28      1854 JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040853 0D 
040854 FD      1855 DEC     IY			; Restore the BASIC program pointer
040855 2B 
040856 CD      1856 CALL    BRAKET			; Check for a bracket
040857 2F 
040858 0A 
040859 04 
04085A 3E      1857 LD      A,80H			; String marker
04085B 80 
04085C C9      1858 RET
               1859 ;
               1860 ; LEFT$ - Return left part of string.
               1861 ; Carry cleared if entire string returned.
               1862 ; Result is string.
               1863 ;
04085D CD      1864 LEFTS:			CALL    EXPRSC			; Get the first string expression
04085E 1E 
04085F 0A 
040860 04 
040861 CD      1865 LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040862 B4 
040863 09 
040864 04 
040865 CD      1866 CALL    EXPRI			; Get the second expression
040866 0A 
040867 03 
040868 04 
040869 C1      1867 POP     BC			; C: String length, B: Value of A before PUSHS was called
04086A CD      1868 CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04086B DE 
04086C 09 
04086D 04 
04086E CD      1869 CALL    BRAKET			; Check for closing bracket
04086F 2F 
040870 0A 
040871 04 
040872 D9      1870 EXX
040873 7D      1871 LD      A,L			; L: The second parameter
040874 D9      1872 EXX
040875 BB      1873 CP      E			; Compare with the string length
040876 30      1874 JR      NC,LEFT3		; If it is greater than or equal then do nothing
040877 02 
040878 6B      1875 LD      L,E             	; For RIGHTS, no effect in LEFTS
040879 5F      1876 LEFT2:			LD      E,A			; E: The new length of string
04087A 3E      1877 LEFT3:			LD      A,80H           	; String marker
04087B 80 
04087C C9      1878 RET
               1879 ;
               1880 ; RIGHT$ - Return right part of string.
               1881 ; Result is string.
               1882 ;
04087D CD      1883 RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
04087E 5D 
04087F 08 
040880 04 
040881 D0      1884 RET     NC			; Do nothing if the second parameter is >= string length
040882 1C      1885 INC     E			; Check for a zero length string
040883 1D      1886 DEC     E
040884 C8      1887 RET     Z			; Yes, so do nothing
040885 4B      1888 LD      C,E			;  C: Number of bytes to copy
040886 7D      1889 LD      A,L
040887 93      1890 SUB     E
040888 6F      1891 LD      L,A			;  L: Index into the string
040889 79      1892 RIGHT1:			LD	A,C
04088A 01      1893 LD	BC,0
04088B 00 
04088C 00 
04088D 00 
04088E 4F      1894 LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04088F 7D      1895 LD	A,L
040890 21      1896 LD	HL,ACCS
040891 00 
040892 4A 
040893 04 
040894 6F      1897 LD	L,A			; HL: Source (in ACCS)
040895 11      1898 LD      DE,ACCS			; DE: Destination (start of ACCS)
040896 00 
040897 4A 
040898 04 
040899 ED      1899 LDIR                    	; Copy
04089A B0 
04089B 3E      1900 LD      A,80H			; String marker
04089C 80 
04089D C9      1901 RET
               1902 ;
               1903 ; STRINGS - Return n concatenations of a string.
               1904 ; Result is string.
               1905 ;
04089E CD      1906 STRING_:		CALL    EXPRI			; Get number of times to replicate
04089F 0A 
0408A0 03 
0408A1 04 
0408A2 CD      1907 CALL    COMMA			; Check for comma
0408A3 22 
0408A4 0A 
0408A5 04 
0408A6 D9      1908 EXX
0408A7 7D      1909 LD      A,L			; L: Number of iterations of string
0408A8 D9      1910 EXX
0408A9 F5      1911 PUSH    AF
0408AA CD      1912 CALL    EXPRS			; Get the string
0408AB 15 
0408AC 03 
0408AD 04 
0408AE CD      1913 CALL    BRAKET			; Check for closing bracket
0408AF 2F 
0408B0 0A 
0408B1 04 
0408B2 F1      1914 POP     AF			; A: Number of iterations of string
0408B3 B7      1915 OR      A			; Set flags
0408B4 28      1916 JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408B5 C3 
0408B6 3D      1917 DEC     A
0408B7 4F      1918 LD      C,A			; C: Loop counter
0408B8 3E      1919 LD      A,80H			; String marker
0408B9 80 
0408BA C8      1920 RET     Z
0408BB 1C      1921 INC     E			; Check for empty string
0408BC 1D      1922 DEC     E
0408BD C8      1923 RET     Z              		; And return
0408BE 43      1924 LD      B,E			; B: String length tally
0408BF 21      1925 LD	HL,ACCS
0408C0 00 
0408C1 4A 
0408C2 04 
0408C3 C5      1926 STRIN1:			PUSH    BC
0408C4 7E      1927 STRIN2:			LD      A,(HL)
0408C5 23      1928 INC     HL
0408C6 12      1929 LD      (DE),A
0408C7 1C      1930 INC     E
0408C8 3E      1931 LD      A,19
0408C9 13 
0408CA CA      1932 JP      Z,ERROR_         	; Throw a "String too long" error
0408CB 60 
0408CC 37 
0408CD 04 
0408CE 10      1933 DJNZ    STRIN2
0408CF F4 
0408D0 C1      1934 POP     BC
0408D1 0D      1935 DEC     C
0408D2 20      1936 JR      NZ,STRIN1
0408D3 EF 
0408D4 3E      1937 LD      A,80H
0408D5 80 
0408D6 C9      1938 RET
               1939 ;
               1940 ;SUBROUTINES
               1941 ;
               1942 ;SWAP - Swap arguments
               1943 ;Exchanges DE,HL D'E',H'L' and B,C
               1944 ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
               1945 ;
0408D7 79      1946 SWAP:			LD      A,C
0408D8 48      1947 LD      C,B
0408D9 47      1948 LD      B,A
0408DA EB      1949 EX      DE,HL
0408DB D9      1950 EXX
0408DC EB      1951 EX      DE,HL
0408DD D9      1952 EXX
0408DE C9      1953 RET
               1954 ;
               1955 ;TEST - Test HLH'L' for zero
               1956 ;Outputs: Z-flag set & A=0 if zero
               1957 ;Destroys: A,F
               1958 ;
0408DF 7C      1959 TEST:			LD      A,H
0408E0 B5      1960 OR      L
0408E1 D9      1961 EXX
0408E2 B4      1962 OR      H
0408E3 B5      1963 OR      L
0408E4 D9      1964 EXX
0408E5 C9      1965 RET
               1966 ;
               1967 ;DECODE - Decode line number in pseudo-binary.
               1968 ;   Inputs: IY = Text pointer.
               1969 ;   Outputs: HL=0, H'L'=line number, C=0.
               1970 ;   Destroys: A,C,H,L,H',L',IY,F
               1971 ;
0408E6 D9      1972 DECODE:			EXX
0408E7 21      1973 LD	HL, 0
0408E8 00 
0408E9 00 
0408EA 00 
0408EB FD      1974 LD      A,(IY)
0408EC 7E 
0408ED 00 
0408EE FD      1975 INC     IY
0408EF 23 
0408F0 17      1976 RLA
0408F1 17      1977 RLA
0408F2 67      1978 LD      H,A
0408F3 E6      1979 AND     0C0H
0408F4 C0 
0408F5 FD      1980 XOR     (IY)
0408F6 AE 
0408F7 00 
0408F8 FD      1981 INC     IY
0408F9 23 
0408FA 6F      1982 LD      L,A
0408FB 7C      1983 LD      A,H
0408FC 17      1984 RLA
0408FD 17      1985 RLA
0408FE E6      1986 AND     0C0H
0408FF C0 
040900 FD      1987 XOR     (IY)
040901 AE 
040902 00 
040903 FD      1988 INC     IY
040904 23 
040905 67      1989 LD      H,A
040906 D9      1990 EXX
               1991 ;			XOR     A
               1992 ;			LD      C,A
               1993 ;			LD      H,A
               1994 ;			LD      L,A
040907 21      1995 LD	HL, 0
040908 00 
040909 00 
04090A 00 
04090B 4D      1996 LD	C, L
04090C C9      1997 RET
               1998 ;
               1999 ;HEXSTR - convert numeric value to HEX string.
               2000 ;   Inputs: HLH'L'C = integer or floating-point number
               2001 ;  Outputs: String in string accumulator.
               2002 ;           E = string length.  D = ACCS/256
               2003 ;
04090D FD      2004 HEXSTS:			INC     IY              ;SKIP TILDE
04090E 23 
04090F CD      2005 CALL    ITEMN
040910 1D 
040911 03 
040912 04 
040913 CD      2006 CALL    HEXSTR
040914 1A 
040915 09 
040916 04 
040917 3E      2007 LD      A,80H
040918 80 
040919 C9      2008 RET
               2009 ;
04091A CD      2010 HEXSTR:			CALL    SFIX
04091B 62 
04091C 06 
04091D 04 
04091E 01      2011 LD      BC,8
04091F 08 
040920 00 
040921 00 
040922 11      2012 LD      DE,ACCS
040923 00 
040924 4A 
040925 04 
040926 C5      2013 HEXST1:			PUSH    BC
040927 06      2014 LD      B,4
040928 04 
040929 AF      2015 XOR     A
04092A D9      2016 HEXST2:			EXX
04092B 52      2017 ADD.S	HL,HL
04092C 29 
04092D D9      2018 EXX
04092E 52      2019 ADC.S	HL,HL
04092F ED 
040930 6A 
040931 17      2020 RLA
040932 10      2021 DJNZ    HEXST2
040933 F6 
040934 C1      2022 POP     BC
040935 0D      2023 DEC     C
040936 F8      2024 RET     M
040937 28      2025 JR      Z,HEXST3
040938 06 
040939 B7      2026 OR      A
04093A 20      2027 JR      NZ,HEXST3
04093B 03 
04093C B8      2028 CP      B
04093D 28      2029 JR      Z,HEXST1
04093E E7 
04093F C6      2030 HEXST3:			ADD     A,90H
040940 90 
040941 27      2031 DAA
040942 CE      2032 ADC     A,40H
040943 40 
040944 27      2033 DAA
040945 12      2034 LD      (DE),A
040946 13      2035 INC     DE
040947 47      2036 LD      B,A
040948 18      2037 JR      HEXST1
040949 DC 
               2038 ;
               2039 ;Function STR - convert numeric value to ASCII string.
               2040 ;   Inputs: HLH'L'C = integer or floating-point number.
               2041 ;  Outputs: String in string accumulator.
               2042 ;           E = length, D = ACCS/256
               2043 ;           A = 80H (type=string)
               2044 ;
               2045 ;First normalise for decimal output:
               2046 ;
04094A CD      2047 STRS:			CALL    NXT
04094B 70 
04094C 0A 
04094D 04 
04094E FE      2048 CP      '~'
04094F 7E 
040950 28      2049 JR      Z,HEXSTS
040951 BB 
040952 CD      2050 CALL    ITEMN
040953 1D 
040954 03 
040955 04 
040956 DD      2051 LD      IX,STAVAR
040957 21 
040958 00 
040959 4C 
040959 04   
04095B DD      2052 LD      A,(IX+3)
04095C 7E 
04095D 03 
04095E B7      2053 OR      A
04095F DD      2054 LD      IX,G9-1         ;G9 FORMAT
040960 21 
040961 8C 
040962 09 
040962 04   
040964 28      2055 JR      Z,STR0
040965 05 
040966 DD      2056 STR:			LD      IX,STAVAR
040967 21 
040968 00 
040969 4C 
040969 04   
04096B 11      2057 STR0:			LD      DE,ACCS
04096C 00 
04096D 4A 
04096E 04 
04096F 3E      2058 LD      A,37
040970 25 
040971 CD      2059 CALL    FPP
040972 6A 
040973 20 
040974 04 
040975 DA      2060 JP      C,ERROR_
040976 60 
040977 37 
040978 04 
040979 DD      2061 BIT     0,(IX+2)
04097A CB 
04097B 02 
04097C 46 
04097D 3E      2062 STR1:			LD      A,80H           ;STRING MARKER
04097E 80 
04097F C8      2063 RET     Z
040980 79      2064 LD      A,C
040981 C6      2065 ADD     A,4
040982 04 
040983 BB      2066 STR2:			CP      E
040984 28      2067 JR      Z,STR1
040985 F7 
040986 EB      2068 EX      DE,HL
040987 36      2069 LD      (HL),' '        ;TRAILING SPACE
040988 20 
040989 23      2070 INC     HL
04098A EB      2071 EX      DE,HL
04098B 18      2072 JR      STR2
04098C F6 
               2073 ;
04098D 09      2074 G9:			DW    9
04098E 00 
               2075 ;
               2076 ;STRING COMPARE
               2077 ;Compare string (DE) length B with string (HL) length C.
               2078 ;Result preset to false.
               2079 ;
04098F CD      2080 SCP:			CALL	SCP0
040990 9D 
040991 09 
040992 04 
               2081 ;
040993 3E      2082 ZERO:			LD      A,0
040994 00 
040995 D9      2083 EXX
040996 67      2084 LD      H,A
040997 6F      2085 LD      L,A
040998 D9      2086 EXX
040999 67      2087 LD      H,A
04099A 6F      2088 LD      L,A
04099B 4F      2089 LD      C,A
04099C C9      2090 RET
               2091 ;
04099D 04      2092 SCP0:			INC     B
04099E 0C      2093 INC     C
04099F 05      2094 SCP1:			DEC     B
0409A0 28      2095 JR      Z,SCP2
0409A1 0A 
0409A2 0D      2096 DEC     C
0409A3 28      2097 JR      Z,SCP3
0409A4 0C 
0409A5 1A      2098 LD      A,(DE)
0409A6 BE      2099 CP      (HL)
0409A7 C0      2100 RET     NZ
0409A8 13      2101 INC     DE
0409A9 23      2102 INC     HL
0409AA 18      2103 JR      SCP1
0409AB F3 
0409AC B7      2104 SCP2:			OR      A
0409AD 0D      2105 DEC     C
0409AE C8      2106 RET     Z
0409AF 37      2107 SCF
0409B0 C9      2108 RET
0409B1 B7      2109 SCP3:			OR      A
0409B2 0C      2110 INC     C
0409B3 C9      2111 RET
               2112 ;
               2113 ; PUSHS - SAVE STRING ON STACK.
               2114 ;     Inputs: String in string accumulator.
               2115 ;             E = string length.
               2116 ;             A - saved on stack.
               2117 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2118 ;
0409B4 CD      2119 PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409B5 4F 
0409B6 16 
0409B7 04 
0409B8 DD      2120 POP     IX              	; IX: Return address
0409B9 E1 
0409BA B7      2121 OR      A               	; Clear the carry flag
0409BB 01      2122 LD	BC,0			; BC: Length of the string
0409BC 00 
0409BD 00 
0409BE 00 
0409BF 4B      2123 LD	C,E
0409C0 21      2124 LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C1 00 
0409C2 4A 
0409C3 04 
0409C4 11      2125 LD	DE,ACCS
0409C5 00 
0409C6 4A 
0409C7 04 
0409C8 59      2126 LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409C9 ED      2127 SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CA 52 
0409CB 39      2128 ADD     HL,SP			; Grow the stack
0409CC F9      2129 LD      SP,HL
0409CD 57      2130 LD      D,A			;  D: This needs to be set to A for some functions
               2131 ; BEGIN MISSING FROM BINARY
               2132 ; LD	B,A			; Stack A and C (the string length)
               2133 ; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
               2134 ; LD	B,0			; Reset B to 0 for the LDIR in this function
               2135 ; END MISSING FROM BINARY
0409CE D5      2136 PUSH 	DE ; ADDED FROM BINARY
0409CF 28      2137 JR      Z,PUSHS1        	; Is it zero length?
0409D0 0B 
0409D1 11      2138 LD      DE,ACCS			; DE: Destination
0409D2 00 
0409D3 4A 
0409D4 04 
0409D5 EB      2139 EX      DE,HL			; HL: Destination, DE: Address on stack
0409D6 ED      2140 LDIR	                    	; Copy to stack
0409D7 B0 
0409D8 CD      2141 CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409D9 4F 
0409DA 16 
0409DB 04 
0409DC DD      2142 PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409DD E9 
               2143 ;
               2144 ; POPS - RESTORE STRING FROM STACK.
               2145 ;     Inputs: C = string length.
               2146 ;    Outputs: String in string accumulator.
               2147 ;             E = string length.
               2148 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2149 ;
0409DE DD      2150 POPS:			POP     IX              	; IX: Return address
0409DF E1 
0409E0 69      2151 LD	L,C			; Temporarily store string length in L
0409E1 01      2152 LD	BC,0
0409E2 00 
0409E3 00 
0409E4 00 
0409E5 4D      2153 LD	C,L			; BC: Number of bytes to copy
0409E6 21      2154 LD      HL,0			; HL: 0
0409E7 00 
0409E8 00 
0409E9 00 
0409EA 39      2155 ADD     HL,SP			; HL: Stack address
0409EB 11      2156 LD      DE,ACCS			; DE: Destination
0409EC 00 
0409ED 4A 
0409EE 04 
0409EF 0C      2157 INC     C			; Quick check to see if this is a zero length string
0409F0 0D      2158 DEC     C
0409F1 28      2159 JR      Z,POPS1         	; Yes it is, so skip
0409F2 02 
0409F3 ED      2160 LDIR                    	; No, so copy from the stack
0409F4 B0 
0409F5 F9      2161 POPS1:			LD      SP,HL			; Shrink the stack
0409F6 DD      2162 JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F7 E9 
               2163 ;
0409F8 FD      2164 HEXDIG:			LD      A,(IY)
0409F9 7E 
0409FA 00 
0409FB FE      2165 CP      '0'
0409FC 30 
0409FD D8      2166 RET     C
0409FE FE      2167 CP      '9'+1
0409FF 3A 
040A00 3F      2168 CCF
040A01 D0      2169 RET     NC
040A02 FE      2170 CP      'A'
040A03 41 
040A04 D8      2171 RET     C
040A05 D6      2172 SUB     'A'-10
040A06 37 
040A07 FE      2173 CP      16
040A08 10 
040A09 3F      2174 CCF
040A0A C9      2175 RET
               2176 ;
040A0B FD      2177 BINDIG:			LD	A,(IY)
040A0C 7E 
040A0D 00 
040A0E FE      2178 CP	'0'
040A0F 30 
040A10 D8      2179 RET	C
040A11 FE      2180 CP	'1'+1
040A12 32 
040A13 3F      2181 CCF
040A14 C9      2182 RET
               2183 ;
040A15 FE      2184 RELOP?:			CP      '>'
040A16 3E 
040A17 D0      2185 RET     NC
040A18 FE      2186 CP      '='
040A19 3D 
040A1A D0      2187 RET     NC
040A1B FE      2188 CP      '<'
040A1C 3C 
040A1D C9      2189 RET
               2190 ;
040A1E CD      2191 EXPRSC:			CALL    EXPRS
040A1F 15 
040A20 03 
040A21 04 
040A22 CD      2192 COMMA:			CALL    NXT
040A23 70 
040A24 0A 
040A25 04 
040A26 FD      2193 INC     IY
040A27 23 
040A28 FE      2194 CP      ','
040A29 2C 
040A2A C8      2195 RET     Z
040A2B 3E      2196 LD      A,5
040A2C 05 
040A2D 18      2197 JR      ERROR1_EV          ;"Missing ,"
040A2E 0B 
               2198 ;
040A2F CD      2199 BRAKET:			CALL    NXT
040A30 70 
040A31 0A 
040A32 04 
040A33 FD      2200 INC     IY
040A34 23 
040A35 FE      2201 CP      ')'
040A36 29 
040A37 C8      2202 RET     Z
040A38 3E      2203 LD      A,27
040A39 1B 
040A3A C3      2204 ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A3B 60 
040A3C 37 
040A3D 04 
               2205 ;
040A3E FD      2206 SAVE_EV:			INC     IY
040A3F 23 
040A40 08      2207 SAVE1:			EX      AF,AF'
040A41 FA      2208 JP      M,TYPE_EV_
040A42 36 
040A43 03 
040A44 04 
040A45 08      2209 EX      AF,AF'
040A46 E3      2210 EX      (SP),HL
040A47 D9      2211 EXX
040A48 E5      2212 PUSH    HL
040A49 D9      2213 EXX
040A4A F5      2214 PUSH    AF
040A4B C5      2215 PUSH    BC
040A4C E9      2216 JP      (HL)
               2217 ;
040A4D 08      2218 DOIT:			EX      AF,AF'
040A4E FA      2219 JP      M,TYPE_EV_
040A4F 36 
040A50 03 
040A51 04 
040A52 D9      2220 EXX
040A53 C1      2221 POP     BC              ;RETURN ADDRESS
040A54 D9      2222 EXX
040A55 79      2223 LD      A,C
040A56 C1      2224 POP     BC
040A57 47      2225 LD      B,A
040A58 F1      2226 POP     AF              ;OPERATOR
040A59 D9      2227 EXX
040A5A EB      2228 EX      DE,HL
040A5B E1      2229 POP     HL
040A5C D9      2230 EXX
040A5D EB      2231 EX      DE,HL
040A5E E1      2232 POP     HL
040A5F D9      2233 EXX
040A60 C5      2234 PUSH    BC
040A61 D9      2235 EXX
040A62 E6      2236 AND     0FH
040A63 0F 
040A64 CD      2237 CALL    FPP
040A65 6A 
040A66 20 
040A67 04 
040A68 38      2238 JR      C,ERROR1_EV
040A69 D0 
040A6A AF      2239 XOR     A
040A6B 08      2240 EX      AF,AF'          ;TYPE
040A6C FD      2241 LD      A,(IY)
040A6D 7E 
040A6E 00 
040A6F C9      2242 RET
               2243 ;
               2244 ; Skip spaces
               2245 ; - IY: String pointer
               2246 ; Returns:
               2247 ;  - A: The non-space character found
               2248 ; - IY: Points to the character before that
               2249 ;
040A70 FD      2250 NXT:			LD      A,(IY)			; Fetch the character
040A71 7E 
040A72 00 
040A73 FE      2251 CP      ' '			; If it is space, then return
040A74 20 
040A75 C0      2252 RET     NZ
040A76 FD      2253 INC     IY			; Increment the pointer and
040A77 23 
040A78 C3      2254 JP      NXT			; Loop
040A79 70 
040A7A 0A 
040A7B 04 
               2255 ;
040A7C E5      2256 DISPT2:			PUSH    HL
040A7D 21      2257 LD      HL,SOPTBL
040A7E B5 
040A7F 01 
040A80 04 
040A81 18      2258 JR      DISPT0
040A82 07 
               2259 ;
040A83 E5      2260 DISPAT:			PUSH    HL
040A84 D6      2261 SUB     FUNTOK
040A85 8D 
040A86 21      2262 LD      HL,FUNTBL
040A87 0A 
040A88 01 
040A89 04 
040A8A C5      2263 DISPT0:			PUSH    BC
               2264 
040A8B 01      2265 LD	BC, 3
040A8C 03 
040A8D 00 
040A8E 00 
040A8F 47      2266 LD	B, A
040A90 ED      2267 MLT	BC
040A91 4C 
040A92 09      2268 ADD	HL, BC
040A93 ED      2269 LD	HL, (HL)
040A94 27 
               2270 
               2271 ;			ADD     A,A
               2272 ;			LD      C,A
               2273 ;			LD      B,0
               2274 ;			ADD     HL,BC
               2275 ;			LD      A,(HL)
               2276 ;			INC     HL
               2277 ;			LD      H,(HL)
               2278 ;			LD      L,A
               2279 
040A95 C1      2280 POP     BC
040A96 E3      2281 EX      (SP),HL
040A97 C9      2282 RET                     ;OFF TO ROUTINE
               2283 
               2284 ; --- End eval.asm ---
               2285 
               2286 ; --- Begin exec.asm ---
               2287 ;
               2288 ; Title:	BBC Basic Interpreter - Z80 version
               2289 ;		Statement Execution & Assembler Module - "EXEC"
               2290 ; Author:	(C) Copyright  R.T.Russell  1984
               2291 ; Modified By:	Dean Belfield
               2292 ; Created:	12/05/2023
               2293 ; Last Updated:	26/06/2023
               2294 ;
               2295 ; Modinfo:
               2296 ; 27/01/1984:	Version 2.1
               2297 ; 02/03/1987:	Version 3.0
               2298 ; 11/06/1987:	Version 3.1
               2299 ; 12/05/2023:	Modified by Dean Belfield
               2300 ; 07/06/2023:	Modified to run in ADL mode
               2301 ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
               2302 
               2303 ; .ASSUME	ADL = 1
               2304 
               2305 ; INCLUDE	"equs.inc"
               2306 
               2307 ; SEGMENT CODE
               2308 
               2309 ; XDEF	XEQ
               2310 ; XDEF	CHAIN0
               2311 ; XDEF	RUN
               2312 ; XDEF	SYNTAX
               2313 ; XDEF	ESCAPE
               2314 ; XDEF	FN_EX
               2315 ; XDEF	USR
               2316 ; XDEF	STORE5
               2317 ; XDEF	STORE4
               2318 ; XDEF	CHECK
               2319 ; XDEF	TERMQ
               2320 ; XDEF	FILL
               2321 ; XDEF	X4OR5
               2322 ; XDEF	MUL16
               2323 ; XDEF	CHANEL
               2324 ; XDEF	ASSEM
               2325 
               2326 ; XREF	AUTO
               2327 ; XREF	DELETE
               2328 ; XREF	LOAD
               2329 ; XREF	LIST_
               2330 ; XREF	NEW
               2331 ; XREF	OLD
               2332 ; XREF	RENUM
               2333 ; XREF	SAVE
               2334 ; XREF	SOUND
               2335 ; XREF	CLG
               2336 ; XREF	DRAW
               2337 ; XREF	ENVEL
               2338 ; XREF	GCOL
               2339 ; XREF	MODE
               2340 ; XREF	MOVE
               2341 ; XREF	PLOT
               2342 ; XREF	COLOUR
               2343 ; XREF	EXPRS
               2344 ; XREF	HIMEM
               2345 ; XREF	LOAD0
               2346 ; XREF	RANDOM
               2347 ; XREF	CLEAR
               2348 ; XREF	ERRTRP
               2349 ; XREF	PAGE_
               2350 ; XREF	DATAPTR
               2351 ; XREF	ERRLIN
               2352 ; XREF	TRAP
               2353 ; XREF	NXT
               2354 ; XREF	SETLIN
               2355 ; XREF	CLOOP
               2356 ; XREF	OSSHUT
               2357 ; XREF	WARM
               2358 ; XREF	TRACEN
               2359 ; XREF	OUTCHR
               2360 ; XREF	PBCDL
               2361 ; XREF	OSCLI
               2362 ; XREF	LISTON
               2363 ; XREF	GETVAR
               2364 ; XREF	PUTVAR
               2365 ; XREF	DATPTR
               2366 ; XREF	ERROR_
               2367 ; XREF	EXPR
               2368 ; XREF	CREATE
               2369 ; XREF	EXPRI
               2370 ; XREF	BRAKET
               2371 ; XREF	FREE
               2372 ; XREF	OSBPUT
               2373 ; XREF	COUNT
               2374 ; XREF	STR
               2375 ; XREF	HEXSTR
               2376 ; XREF	CRLF
               2377 ; XREF	ITEMI
               2378 ; XREF	FINDL
               2379 ; XREF	TEST
               2380 ; XREF	EXPRN
               2381 ; XREF	DLOAD5
               2382 ; XREF	DLOAD5_SPL
               2383 ; XREF	LOADN
               2384 ; XREF	FPP
               2385 ; XREF	SWAP
               2386 ; XREF	GETDEF
               2387 ; XREF	ZERO
               2388 ; XREF	OSBGET
               2389 ; XREF	BUFFER
               2390 ; XREF	CONS
               2391 ; XREF	VAL0
               2392 ; XREF	OSLINE
               2393 ; XREF	CLRSCN
               2394 ; XREF	TELL
               2395 ; XREF	SAYLN
               2396 ; XREF	REPORT
               2397 ; XREF	PUTPTR
               2398 ; XREF	PUTIME
               2399 ; XREF	PUTIMS
               2400 ; XREF	LOMEM
               2401 ; XREF	WIDTH
               2402 ; XREF	OSWRCH
               2403 ; XREF	COMMA
               2404 ; XREF	OSCALL
               2405 ; XREF	SFIX
               2406 ; XREF	LOAD4
               2407 ; XREF	PUSHS
               2408 ; XREF	POPS
               2409 ; XREF	LOADS
               2410 ; XREF	PUTCSR
               2411 ; XREF	OUT_
               2412 ; XREF	R0
               2413 ;
               2414 ; List of token values used in this module
               2415 ;
               2416 TAND:			EQU     80H
               2417 TOR:			EQU     84H
               2418 TERROR_EX:			EQU     85H
               2419 LINE_EX_:			EQU     86H
               2420 OFF_:			EQU     87H
               2421 STEP:			EQU     88H
               2422 SPC:			EQU     89H
               2423 TAB:			EQU     8AH
               2424 ELSE_EX_:			EQU     8BH
               2425 THEN_EX_:			EQU     8CH
               2426 LINO_EX:			EQU     8DH
               2427 TO_EX:			EQU     B8H
               2428 TCMD_EX:			EQU     C6H
               2429 TCALL:			EQU     D6H
               2430 DATA_EX_:			EQU     DCH
               2431 DEF_:			EQU     DDH
               2432 TGOSUB:			EQU     E4H
               2433 TGOTO:			EQU     E5H
               2434 TON:			EQU     EEH
               2435 TPROC:			EQU     F2H
               2436 TSTOP:			EQU     FAH
               2437 
               2438 ; The command table
               2439 ; Commands are tokens from C6H onwards; this lookup table is used to
               2440 ; run the corresponding function; Note that DATA and DEF both use the same
               2441 ; code as REM
               2442 ;
040A98 E9      2443 CMDTAB:			DW24  AUTO			; C6H
040A99 36 
040A9A 04 
040A9B 4C      2444 DW24  DELETE			; C7H
040A9C 35 
040A9D 04 
040A9E 2A      2445 DW24  LOAD			; C8H
040A9F 37 
040AA0 04 
040AA1 87      2446 DW24  LIST_			; C9H
040AA2 35 
040AA3 04 
040AA4 07      2447 DW24  NEW			; CAH
040AA5 37 
040AA6 04 
040AA7 0D      2448 DW24  OLD			; CBH
040AA8 37 
040AA9 04 
040AAA 16      2449 DW24  RENUM			; CCH
040AAB 36 
040AAC 04 
040AAD 3B      2450 DW24  SAVE			; CDH
040AAE 37 
040AAF 04 
040AB0 A8      2451 DW24  PUT			; CEH
040AB1 15 
040AB2 04 
040AB3 C8      2452 DW24  PTR_EX			; CFH
040AB4 13 
040AB5 04 
040AB6 E2      2453 DW24  PAGEV_EX			; D0H
040AB7 13 
040AB8 04 
040AB9 F5      2454 DW24  TIMEV_EX			; D1H
040ABA 13 
040ABB 04 
040ABC 1E      2455 DW24  LOMEMV_EX			; D2H
040ABD 14 
040ABE 04 
040ABF 37      2456 DW24  HIMEMV_EX			; D3H
040AC0 14 
040AC1 04 
040AC2 26      2457 DW24  SOUND			; D4H
040AC3 46 
040AC4 04 
040AC5 C2      2458 DW24  BPUT			; D5H
040AC6 14 
040AC7 04 
040AC8 DA      2459 DW24  CALL_			; D6H
040AC9 14 
040ACA 04 
040ACB 4C      2460 DW24  CHAIN			; D7H
040ACC 0B 
040ACD 04 
040ACE 97      2461 DW24  CLR			; D8H
040ACF 13 
040AD0 04 
040AD1 B6      2462 DW24  CLOSE			; D9H
040AD2 14 
040AD3 04 
040AD4 C2      2463 DW24  CLG			; DAH
040AD5 43 
040AD6 04 
040AD7 6A      2464 DW24  CLS			; DBH
040AD8 13 
040AD9 04 
040ADA 2B      2465 DW24  REM_EX             		; DCH: DATA
040ADB 0C 
040ADC 04 
040ADD 2B      2466 DW24  REM_EX             		; DDH: DEF
040ADE 0C 
040ADF 04 
040AE0 F1      2467 DW24  DIM_EX			; DEH
040AE1 0C 
040AE2 04 
040AE3 EC      2468 DW24  DRAW			; DFH
040AE4 45 
040AE5 04 
040AE6 C6      2469 DW24  END_			; E0H
040AE7 0B 
040AE8 04 
040AE9 82      2470 DW24  ENDPRO			; E1H
040AEA 11 
040AEB 04 
040AEC B7      2471 DW24  ENVEL			; E2H
040AED 43 
040AEE 04 
040AEF 97      2472 DW24  FOR_EX			; E3H
040AF0 0F 
040AF1 04 
040AF2 47      2473 DW24  GOSUB_EX			; E4H
040AF3 0F 
040AF4 04 
040AF5 2B      2474 DW24  GOTO_EX			; E5H
040AF6 0F 
040AF7 04 
040AF8 80      2475 DW24  GCOL			; E6H
040AF9 45 
040AFA 04 
040AFB 36      2476 DW24  IF_			; E7H
040AFC 13 
040AFD 04 
040AFE 24      2477 DW24  INPUT			; E8H
040AFF 12 
040B00 04 
040B01 4C      2478 DW24  LET			; E9H
040B02 0C 
040B03 04 
040B04 27      2479 DW24  LOCAL_EX_			; EAH
040B05 11 
040B06 04 
040B07 D2      2480 DW24  MODE			; EBH
040B08 43 
040B09 04 
040B0A E4      2481 DW24  MOVE			; ECH
040B0B 45 
040B0C 04 
040B0D E5      2482 DW24  NEXT_EX			; EDH
040B0E 0F 
040B0F 04 
040B10 BE      2483 DW24  ON_EX_			; EEH
040B11 0E 
040B12 04 
040B13 90      2484 DW24  VDU			; EFH
040B14 14 
040B15 04 
040B16 B2      2485 DW24  PLOT			; F0H
040B17 45 
040B18 04 
040B19 C7      2486 DW24  PRINT_			; F1H
040B1A 0D 
040B1B 04 
040B1C 84      2487 DW24  PROC_EX			; F2H
040B1D 10 
040B1E 04 
040B1F D6      2488 DW24  READ			; F3H
040B20 12 
040B21 04 
040B22 2B      2489 DW24  REM_EX			; F4H
040B23 0C 
040B24 04 
040B25 67      2490 DW24  REPEAT_EX			; F5H
040B26 0F 
040B27 04 
040B28 8F      2491 DW24  REPOR			; F6H
040B29 13 
040B2A 04 
040B2B A1      2492 DW24  RESTOR_EX			; F7H
040B2C 13 
040B2D 04 
040B2E 55      2493 DW24  RETURN			; F8H
040B2F 0F 
040B30 04 
040B31 46      2494 DW24  RUN			; F9H
040B32 0B 
040B33 04 
040B34 77      2495 DW24  STOP			; FAH
040B35 13 
040B36 04 
040B37 CE      2496 DW24  COLOUR			; FBH
040B38 44 
040B39 04 
040B3A 72      2497 DW24  TRACE_EX			; FCH
040B3B 14 
040B3C 04 
040B3D 71      2498 DW24  UNTIL_EX			; FDH
040B3E 0F 
040B3F 04 
040B40 64      2499 DW24  WIDTHV			; FEH
040B41 14 
040B42 04 
040B43 11      2500 DW24  CLI             		; FFH: OSCLI
040B44 0C 
040B45 04 
               2501 
               2502 ; RUN
               2503 ; RUN "filename"
               2504 ;
040B46 CD      2505 RUN:			CALL    TERMQ			; Standalone RUN command?
040B47 7A 
040B48 17 
040B49 04 
040B4A 28      2506 JR      Z,RUN0			; Yes, so just RUN the code
040B4B 10 
               2507 
               2508 ; CHAIN "filename"
               2509 ;
040B4C CD      2510 CHAIN:			CALL    EXPRS			; Get the filename
040B4D 15 
040B4E 03 
040B4F 04 
040B50 3E      2511 LD      A,CR			; Terminate it with a CR
040B51 0D 
040B52 12      2512 LD      (DE),A
040B53 ED      2513 CHAIN0:			LD      SP,(HIMEM)		; Reset SP
040B54 7B 
040B55 20 
040B56 4D 
040B56 04   
040B58 CD      2514 CALL    LOAD0			; And load the file in
040B59 1F 
040B5A 38 
040B5B 04 
               2515 ;
040B5C ED      2516 RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
040B5D 7B 
040B5E 20 
040B5F 4D 
040B5F 04   
040B61 DD      2517 LD      IX,RANDOM		; Pointer to the RANDOM sysvar
040B62 21 
040B63 38 
040B64 4D 
040B64 04   
040B66 ED      2518 @@:			LD      A, R			; Use the R register to seed the random number generator
040B67 5F 
040B68 28      2519 JR      Z, @B			; Loop unti we get a non-zero value in A
040B69 FC 
040B6A 07      2520 RLCA				; Rotate it
040B6B 07      2521 RLCA
040B6C DD      2522 LD      (IX+3),A		; And store
040B6D 77 
040B6E 03 
040B6F 9F      2523 SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B70 DD      2524 LD      (IX+4),A		; And store
040B71 77 
040B72 04 
040B73 CD      2525 CALL    CLEAR
040B74 76 
040B75 38 
040B76 04 
040B77 21      2526 LD      HL,0			; Clear the error trap sysvar
040B78 00 
040B79 00 
040B7A 00 
040B7B 22      2527 LD      (ERRTRP),HL
040B7C 2C 
040B7D 4D 
040B7E 04 
040B7F 2A      2528 LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B80 14 
040B81 4D 
040B82 04 
040B83 3E      2529 LD      A,DATA_EX_			; The DATA token value
040B84 DC 
040B85 CD      2530 CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B86 4E 
040B87 18 
040B88 04 
040B89 22      2531 LD      (DATPTR),HL     	; Set data pointer
040B8A 31 
040B8B 4D 
040B8C 04 
040B8D FD      2532 LD      IY,(PAGE_)		; Load IY with the start of program memory
040B8E 2A 
040B8F 14 
040B90 4D 
040B90 04   
               2533 ;
040B92 CD      2534 XEQ0:			CALL    NEWLIN
040B93 DA 
040B94 0B 
040B95 04 
040B96 FD      2535 XEQ:			LD      (ERRLIN),IY     	; Error pointer
040B97 22 
040B98 35 
040B99 4D 
040B99 04   
040B9B CD      2536 CALL    TRAP           		; Check keyboard
040B9C 6D 
040B9D 3F 
040B9E 04 
040B9F CD      2537 XEQ1:			CALL    NXT
040BA0 70 
040BA1 0A 
040BA2 04 
040BA3 FD      2538 INC     IY
040BA4 23 
040BA5 FE      2539 CP      ':'             	; Seperator
040BA6 3A 
040BA7 28      2540 JR      Z,XEQ1
040BA8 F6 
040BA9 FE      2541 CP      CR
040BAA 0D 
040BAB 28      2542 JR      Z,XEQ0          	; New program line
040BAC E5 
040BAD D6      2543 SUB     TCMD_EX
040BAE C6 
040BAF DA      2544 JP      C,LET0          	; Implied "LET"
040BB0 3A 
040BB1 0C 
040BB2 04 
               2545 
040BB3 01      2546 LD	BC, 3
040BB4 03 
040BB5 00 
040BB6 00 
040BB7 47      2547 LD	B, A
040BB8 ED      2548 MLT	BC
040BB9 4C 
040BBA 21      2549 LD	HL,CMDTAB
040BBB 98 
040BBC 0A 
040BBD 04 
040BBE 09      2550 ADD	HL, BC
040BBF ED      2551 LD	HL, (HL)		; Table entry
040BC0 27 
               2552 
               2553 ;			ADD     A,A
               2554 ;			LD      C,A
               2555 ;			LD      B,0
               2556 ;			LD      HL,CMDTAB
               2557 ;			ADD     HL,BC
               2558 ;			LD      A,(HL)          	; Table entry
               2559 ;			INC     HL
               2560 ;			LD      H,(HL)
               2561 ;			LD      L,A
               2562 
040BC1 CD      2563 CALL    NXT
040BC2 70 
040BC3 0A 
040BC4 04 
040BC5 E9      2564 JP      (HL)            	; Execute the statement
               2565 
               2566 ;END
               2567 ;
040BC6 CD      2568 END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BC7 AE 
040BC8 39 
040BC9 04 
040BCA 7C      2569 LD      A,H
040BCB B5      2570 OR      L               ;DIRECT?
040BCC CA      2571 JP      Z,CLOOP
040BCD 80 
040BCE 30 
040BCF 04 
040BD0 1E      2572 LD      E,0
040BD1 00 
040BD2 CD      2573 CALL    OSSHUT          ;CLOSE ALL FILES
040BD3 2B 
040BD4 43 
040BD5 04 
040BD6 C3      2574 JP      WARM            ;"Ready"
040BD7 7F 
040BD8 30 
040BD9 04 
               2575 ;
040BDA FD      2576 NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BDB 7E 
040BDC 00 
040BDD 01      2577 LD      BC,3
040BDE 03 
040BDF 00 
040BE0 00 
040BE1 FD      2578 ADD     IY,BC
040BE2 09 
040BE3 B7      2579 OR      A
040BE4 28      2580 JR      Z,END_           ;LENGTH=0, EXIT
040BE5 E0 
040BE6 2A      2581 LD      HL,(TRACEN)
040BE7 26 
040BE8 4D 
040BE9 04 
040BEA 7C      2582 LD      A,H
040BEB B5      2583 OR      L
040BEC C8      2584 RET     Z
040BED 11      2585 LD	DE, 0		;Clear DE
040BEE 00 
040BEF 00 
040BF0 00 
040BF1 FD      2586 LD      D,(IY-1)        ;DE = LINE NUMBER
040BF2 56 
040BF3 FF 
040BF4 FD      2587 LD      E,(IY-2)
040BF5 5E 
040BF6 FE 
040BF7 ED      2588 SBC     HL,DE
040BF8 52 
040BF9 D8      2589 RET     C
040BFA EB      2590 EX      DE,HL
040BFB 3E      2591 LD      A,'['           ;TRACE
040BFC 5B 
040BFD CD      2592 CALL    OUTCHR
040BFE 4F 
040BFF 39 
040C00 04 
040C01 CD      2593 CALL    PBCDL
040C02 F7 
040C03 39 
040C04 04 
040C05 3E      2594 LD      A,']'
040C06 5D 
040C07 CD      2595 CALL    OUTCHR
040C08 4F 
040C09 39 
040C0A 04 
040C0B 3E      2596 LD      A,' '
040C0C 20 
040C0D C3      2597 JP      OUTCHR
040C0E 4F 
040C0F 39 
040C10 04 
               2598 
               2599 ; Routines for each statement -------------------------------------------------
               2600 
               2601 ; OSCLI
               2602 ;
040C11 CD      2603 CLI:			CALL    EXPRS
040C12 15 
040C13 03 
040C14 04 
040C15 3E      2604 LD      A,CR
040C16 0D 
040C17 12      2605 LD      (DE),A
040C18 21      2606 LD      HL,ACCS
040C19 00 
040C1A 4A 
040C1B 04 
040C1C CD      2607 CALL    OSCLI
040C1D 90 
040C1E 3F 
040C1F 04 
040C20 C3      2608 JP      XEQ
040C21 96 
040C22 0B 
040C23 04 
               2609 
               2610 ; REM, *
               2611 ;
040C24 FD      2612 EXT_EX:			PUSH    IY
040C25 E5 
040C26 E1      2613 POP     HL
040C27 CD      2614 CALL    OSCLI
040C28 90 
040C29 3F 
040C2A 04 
040C2B FD      2615 REM_EX:			PUSH    IY
040C2C E5 
040C2D E1      2616 POP     HL
040C2E 3E      2617 LD      A,CR
040C2F 0D 
040C30 47      2618 LD      B,A
040C31 ED      2619 CPIR                    ;FIND LINE END
040C32 B1 
040C33 E5      2620 PUSH    HL
040C34 FD      2621 POP     IY
040C35 E1 
040C36 C3      2622 JP      XEQ0
040C37 92 
040C38 0B 
040C39 04 
               2623 
               2624 ; [LET] var = expr
               2625 ;
040C3A FE      2626 LET0:			CP      ELSE_EX_-TCMD_EX
040C3B C5 
040C3C 28      2627 JR      Z,REM_EX
040C3D ED 
               2628 ; CP      ('*'-TCMD) & 0FFH
               2629 ; JR      Z,EXT_EX
               2630 ; CP      ('='-TCMD) & 0FFH
               2631 ; JR      Z,FNEND
               2632 ; CP      ('['-TCMD) & 0FFH
               2633 ; ez80asm doesn't like () in expressions
040C3E FE      2634 CP      '*'-TCMD_EX & 0FFH
040C3F 64 
040C40 28      2635 JR      Z,EXT_EX
040C41 E2 
040C42 FE      2636 CP      '='-TCMD_EX & 0FFH
040C43 77 
040C44 28      2637 JR      Z,FNEND
040C45 5B 
040C46 FE      2638 CP      '['-TCMD_EX & 0FFH
040C47 95 
040C48 28      2639 JR      Z,ASM
040C49 25 
040C4A FD      2640 DEC     IY
040C4B 2B 
040C4C CD      2641 LET:			CALL    ASSIGN			; Assign the variable
040C4D BE 
040C4E 15 
040C4F 04 
040C50 CA      2642 JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C51 96 
040C52 0B 
040C53 04 
040C54 38      2643 JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C55 41 
               2644 ;
040C56 F5      2645 PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C57 CD      2646 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C58 90 
040C59 17 
040C5A 04 
040C5B E5      2647 PUSH    HL			; HL: Address of the variable
040C5C CD      2648 CALL    EXPRS
040C5D 15 
040C5E 03 
040C5F 04 
040C60 DD      2649 POP     IX			; IX: Address of the variable
040C61 E1 
040C62 F1      2650 POP     AF			; AF: The variable type
040C63 CD      2651 CALL    STACCS			; Copy the string from ACCS to the variable area
040C64 00 
040C65 16 
040C66 04 
040C67 C3      2652 XEQR:			JP      XEQ
040C68 96 
040C69 0B 
040C6A 04 
               2653 ;
040C6B CD      2654 ASM0:			CALL    NEWLIN
040C6C DA 
040C6D 0B 
040C6E 04 
040C6F FD      2655 ASM:			LD      (ERRLIN),IY
040C70 22 
040C71 35 
040C72 4D 
040C72 04   
040C74 CD      2656 CALL    TRAP
040C75 6D 
040C76 3F 
040C77 04 
040C78 CD      2657 CALL    ASSEM
040C79 9B 
040C7A 18 
040C7B 04 
040C7C 38      2658 JR      C,SYNTAX
040C7D 19 
040C7E FE      2659 CP      CR
040C7F 0D 
040C80 28      2660 JR      Z,ASM0
040C81 E9 
040C82 21      2661 LD      HL,LISTON
040C83 40 
040C84 4D 
040C85 04 
040C86 7E      2662 LD      A,(HL)
040C87 E6      2663 AND     0FH
040C88 0F 
040C89 F6      2664 OR      B0H
040C8A B0 
040C8B 77      2665 LD      (HL),A
040C8C 18      2666 JR      XEQR
040C8D D9 
               2667 ;
040C8E CD      2668 VAR_:			CALL    GETVAR
040C8F 3A 
040C90 3A 
040C91 04 
040C92 C8      2669 RET     Z
040C93 D2      2670 JP      NC,PUTVAR
040C94 29 
040C95 3A 
040C96 04 
040C97 3E      2671 SYNTAX:			LD      A,16            ;"Syntax error"
040C98 10 
040C99 18      2672 JR	ERROR0_EX
040C9A 02 
040C9B 3E      2673 ESCAPE:			LD      A,17            ;"Escape"
040C9C 11 
040C9D C3      2674 ERROR0_EX:			JP      ERROR_
040C9E 60 
040C9F 37 
040CA0 04 
               2675 
               2676 ; =
               2677 ;
040CA1 CD      2678 FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CA2 C7 
040CA3 01 
040CA4 04 
040CA5 43      2679 LD      B,E
040CA6 EB      2680 EX      DE,HL
040CA7 D9      2681 EXX                     ;SAVE RESULT
040CA8 EB      2682 EX      DE,HL           ; IN DEB'C'D'E'
040CA9 C1      2683 FNEND5:			POP     BC
040CAA 21      2684 LD      HL,LOCCHK
040CAB 58 
040CAC 17 
040CAD 04 
040CAE B7      2685 OR      A
040CAF ED      2686 SBC     HL,BC
040CB0 42 
040CB1 28      2687 JR      Z,FNEND0        ;LOCAL VARIABLE
040CB2 1C 
040CB3 21      2688 LD      HL,FNCHK
040CB4 84 
040CB5 10 
040CB6 04 
040CB7 B7      2689 OR      A
040CB8 ED      2690 SBC     HL,BC
040CB9 42 
040CBA 3E      2691 LD      A,7
040CBB 07 
040CBC 20      2692 JR      NZ,ERROR0_EX       ;"No FN"
040CBD DF 
040CBE FD      2693 POP     IY
040CBF E1 
040CC0 FD      2694 LD      (ERRLIN),IY     ;IN CASE OF ERROR
040CC1 22 
040CC2 35 
040CC3 4D 
040CC3 04   
040CC5 EB      2695 EX      DE,HL
040CC6 D9      2696 EXX
040CC7 EB      2697 EX      DE,HL
040CC8 11      2698 LD      DE,ACCS
040CC9 00 
040CCA 4A 
040CCB 04 
040CCC 58      2699 LD      E,B
040CCD 08      2700 EX      AF,AF'
040CCE C9      2701 RET
               2702 ;
040CCF DD      2703 FNEND0:			POP     IX
040CD0 E1 
040CD1 C1      2704 POP     BC
040CD2 78      2705 LD      A,B
040CD3 B7      2706 OR      A
040CD4 FA      2707 JP      M,FNEND1        ;STRING
040CD5 E2 
040CD6 0C 
040CD7 04 
040CD8 E1      2708 POP     HL
040CD9 D9      2709 EXX
040CDA E1      2710 POP     HL
040CDB D9      2711 EXX
040CDC CD      2712 CALL    STORE
040CDD D6 
040CDE 15 
040CDF 04 
040CE0 18      2713 JR      FNEND5
040CE1 C7 
040CE2 21      2714 FNEND1:			LD      HL,0
040CE3 00 
040CE4 00 
040CE5 00 
040CE6 39      2715 ADD     HL,SP
040CE7 D5      2716 PUSH    DE
040CE8 59      2717 LD      E,C
040CE9 CD      2718 CALL    STORES
040CEA 04 
040CEB 16 
040CEC 04 
040CED D1      2719 POP     DE
040CEE F9      2720 LD      SP,HL
040CEF 18      2721 JR      FNEND5
040CF0 B8 
               2722 
               2723 ; DIM var(dim1[,dim2[,...]])[,var(...]
               2724 ; DIM var expr[,var expr...]
               2725 ;
040CF1 CD      2726 DIM_EX:			CALL    GETVAR          	; Get the variable
040CF2 3A 
040CF3 3A 
040CF4 04 
040CF5 DA      2727 JP      C,BADDIM		; Throw a "Bad Dim" error
040CF6 81 
040CF7 0D 
040CF8 04 
040CF9 CA      2728 JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040CFA 8B 
040CFB 0D 
040CFC 04 
040CFD CD      2729 CALL    CREATE			; Create a new entity
040CFE AE 
040CFF 3B 
040D00 04 
040D01 E5      2730 PUSH    HL			; HL: Address of the entity
040D02 DD      2731 POP     IX			; IX: Address of the entity
040D03 E1 
040D04 FD      2732 LD      A,(IY)			; Fetch the next character from the tokenised string
040D05 7E 
040D06 00 
040D07 FE      2733 CP      '('			; Check for opening brackets
040D08 28 
040D09 7A      2734 LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D0A 20      2735 JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D0B 7F 
               2736 ;
               2737 ; At this point we're reserving a variable array
               2738 ;
040D0C E5      2739 PUSH    HL			; HL: Address of the entity
040D0D F5      2740 PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D0E 11      2741 LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D0F 01 
040D10 00 
040D11 00 
040D12 42      2742 LD      B,D			;  B: The number of dimensions in the array
               2743 ;
040D13 FD      2744 DIM1:			INC     IY			; Skip to the next token
040D14 23 
040D15 C5      2745 PUSH    BC			; Stack the dimension counter
040D16 D5      2746 PUSH    DE			; Stack the total size of array accumulator
040D17 DD      2747 PUSH    IX			; Stack the entity address
040D18 E5 
040D19 CD      2748 CALL    EXPRI           	; Fetch the size of this dimension
040D1A 0A 
040D1B 03 
040D1C 04 
040D1D CB      2749 BIT     7,H			; If it is negative then
040D1E 7C 
040D1F 20      2750 JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D20 60 
040D21 D9      2751 EXX
040D22 23      2752 INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D23 DD      2753 POP     IX			; IX: The entity address
040D24 E1 
040D25 DD      2754 INC     IX
040D26 23 
040D27 DD      2755 LD      (IX),L          	; Save the size of this dimension in the entity
040D28 75 
040D29 00 
040D2A DD      2756 INC     IX
040D2B 23 
040D2C DD      2757 LD      (IX),H
040D2D 74 
040D2E 00 
040D2F C1      2758 POP     BC
040D30 CD      2759 CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D31 72 
040D32 18 
040D33 04 
040D34 38      2760 JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D35 4F 
040D36 EB      2761 EX      DE,HL           	; DE: The new total size of array accumulator
040D37 C1      2762 POP     BC
040D38 04      2763 INC     B               	;  B: The dimension counter; increment
040D39 FD      2764 LD      A,(IY)			; Fetch the nex token
040D3A 7E 
040D3B 00 
040D3C FE      2765 CP      ','             	; Check for another dimension in the array
040D3D 2C 
040D3E 28      2766 JR      Z,DIM1			; And loop
040D3F D3 
               2767 ;
040D40 CD      2768 CALL    BRAKET          	; Check for closing bracket
040D41 2F 
040D42 0A 
040D43 04 
040D44 F1      2769 POP     AF              	; Restore the type
040D45 DD      2770 INC     IX
040D46 23 
040D47 DD      2771 EX      (SP),IX
040D48 E3 
040D49 DD      2772 LD      (IX),B          	; Number of dimensions
040D4A 70 
040D4B 00 
040D4C CD      2773 CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D4D 65 
040D4E 18 
040D4F 04 
040D50 E1      2774 POP     HL			; Restore the entity address
040D51 38      2775 JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D52 32 
               2776 ;
               2777 ; We now allocate the memory for the array
               2778 ;
040D53 19      2779 DIM3:			ADD     HL,DE
040D54 38      2780 JR      C,NOROOM
040D55 2F 
040D56 E5      2781 PUSH    HL
040D57 24      2782 INC     H
040D58 28      2783 JR      Z,NOROOM
040D59 2B 
040D5A ED      2784 SBC     HL,SP
040D5B 72 
040D5C 30      2785 JR      NC,NOROOM       	; Throw an "Out of Space" error
040D5D 27 
040D5E E1      2786 POP     HL
040D5F 22      2787 LD      (FREE),HL
040D60 1D 
040D61 4D 
040D62 04 
040D63 7A      2788 DIM2:			LD      A,D
040D64 B3      2789 OR      E
040D65 28      2790 JR      Z,DIM5
040D66 06 
040D67 2B      2791 DEC     HL
040D68 36      2792 LD      (HL),0         		; Initialise the array
040D69 00 
040D6A 1B      2793 DEC     DE
040D6B 18      2794 JR      DIM2
040D6C F6 
040D6D CD      2795 DIM5:			CALL    NXT
040D6E 70 
040D6F 0A 
040D70 04 
040D71 FE      2796 CP      ','            		; Another variable?
040D72 2C 
040D73 C2      2797 JP      NZ,XEQ
040D74 96 
040D75 0B 
040D76 04 
040D77 FD      2798 INC     IY
040D78 23 
040D79 CD      2799 CALL    NXT
040D7A 70 
040D7B 0A 
040D7C 04 
040D7D C3      2800 JP      DIM_EX
040D7E F1 
040D7F 0C 
040D80 04 
               2801 ;
               2802 ; DIM errors
               2803 ;
040D81 3E      2804 BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D82 0A 
040D83 18      2805 JR	ERROR1_EX
040D84 02 
040D85 3E      2806 NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D86 0B 
040D87 C3      2807 ERROR1_EX:			JP      ERROR_
040D88 60 
040D89 37 
040D8A 04 
               2808 ;
               2809 ; At this point we're reserving a block of memory, i.e.
               2810 ; DIM var expr[,var expr...]
               2811 ;
040D8B B7      2812 DIM4:			OR      A			;  A: The dimension variable type
040D8C 28      2813 JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D8D F3 
040D8E FA      2814 JP      M,BADDIM        	; or a string
040D8F 81 
040D90 0D 
040D91 04 
040D92 47      2815 LD      B,A			; Temporarily store the dimension variable type in B
040D93 FD      2816 LD      A,(IY-1)		; Get the last character but one
040D94 7E 
040D95 FF 
040D96 FE      2817 CP      ')'			; Check if it is a trailing bracket
040D97 29 
040D98 28      2818 JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040D99 E7 
               2819 ;
040D9A 21      2820 LD	HL,0			; Clear HL
040D9B 00 
040D9C 00 
040D9D 00 
040D9E 3A      2821 LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040D9F 1D 
040DA0 4D 
040DA1 04 
040DA2 6F      2822 LD	L,A
040DA3 3A      2823 LD	A,(FREE+1)
040DA4 1E 
040DA5 4D 
040DA6 04 
040DA7 67      2824 LD	H,A
040DA8 78      2825 LD	A,B			; Restore the dimension variable type
040DA9 D9      2826 EXX
040DAA 21      2827 LD	HL,0			; Clear HL
040DAB 00 
040DAC 00 
040DAD 00 
040DAE 47      2828 LD	B,A			; Temporarily store the dimension variable type in B
040DAF 3A      2829 LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB0 1F 
040DB1 4D 
040DB2 04 
040DB3 6F      2830 LD	L,A
040DB4 78      2831 LD	A,B			; Restore the dimension variable type
040DB5 4C      2832 LD	C,H
040DB6 CD      2833 CALL    STORE           	; Store the address
040DB7 D6 
040DB8 15 
040DB9 04 
040DBA CD      2834 CALL    EXPRI			; Get the number of bytes to store
040DBB 0A 
040DBC 03 
040DBD 04 
040DBE D9      2835 EXX
040DBF 23      2836 INC     HL			; Add one to it
040DC0 EB      2837 EX      DE,HL
040DC1 2A      2838 LD      HL,(FREE)
040DC2 1D 
040DC3 4D 
040DC4 04 
040DC5 18      2839 JR      DIM3			; Continue with the DIM
040DC6 8C 
               2840 
               2841 ; PRINT list...
               2842 ; PRINT #channel,list...
               2843 ;
040DC7 FE      2844 PRINT_:			CP      '#'
040DC8 23 
040DC9 20      2845 JR      NZ,PRINT0
040DCA 7C 
040DCB CD      2846 CALL    CHNL            ;CHANNEL NO. = E
040DCC 92 
040DCD 18 
040DCE 04 
040DCF CD      2847 PRNTN1:			CALL    NXT
040DD0 70 
040DD1 0A 
040DD2 04 
040DD3 FE      2848 CP      ','
040DD4 2C 
040DD5 C2      2849 JP      NZ,XEQ
040DD6 96 
040DD7 0B 
040DD8 04 
040DD9 FD      2850 INC     IY
040DDA 23 
040DDB D5      2851 PUSH    DE
040DDC CD      2852 CALL    EXPR            ;ITEM TO PRINT
040DDD C7 
040DDE 01 
040DDF 04 
040DE0 08      2853 EX      AF,AF'
040DE1 FA      2854 JP      M,PRNTN2        ;STRING
040DE2 07 
040DE3 0E 
040DE4 04 
040DE5 D1      2855 POP     DE
040DE6 C5      2856 PUSH    BC
040DE7 D9      2857 EXX
040DE8 7D      2858 LD      A,L
040DE9 D9      2859 EXX
040DEA CD      2860 CALL    OSBPUT
040DEB 3B 
040DEC 43 
040DED 04 
040DEE D9      2861 EXX
040DEF 7C      2862 LD      A,H
040DF0 D9      2863 EXX
040DF1 CD      2864 CALL    OSBPUT
040DF2 3B 
040DF3 43 
040DF4 04 
040DF5 7D      2865 LD      A,L
040DF6 CD      2866 CALL    OSBPUT
040DF7 3B 
040DF8 43 
040DF9 04 
040DFA 7C      2867 LD      A,H
040DFB CD      2868 CALL    OSBPUT
040DFC 3B 
040DFD 43 
040DFE 04 
040DFF C1      2869 POP     BC
040E00 79      2870 LD      A,C
040E01 CD      2871 CALL    OSBPUT
040E02 3B 
040E03 43 
040E04 04 
040E05 18      2872 JR      PRNTN1
040E06 C8 
040E07 4B      2873 PRNTN2:			LD      C,E
040E08 D1      2874 POP     DE
040E09 21      2875 LD      HL,ACCS
040E0A 00 
040E0B 4A 
040E0C 04 
040E0D 0C      2876 INC     C
040E0E 0D      2877 PRNTN3:			DEC     C
040E0F 28      2878 JR      Z,PRNTN4
040E10 0A 
040E11 7E      2879 LD      A,(HL)
040E12 23      2880 INC     HL
040E13 C5      2881 PUSH    BC
040E14 CD      2882 CALL    OSBPUT
040E15 3B 
040E16 43 
040E17 04 
040E18 C1      2883 POP     BC
040E19 18      2884 JR      PRNTN3
040E1A F3 
040E1B 3E      2885 PRNTN4:			LD      A,CR
040E1C 0D 
040E1D CD      2886 CALL    OSBPUT
040E1E 3B 
040E1F 43 
040E20 04 
040E21 18      2887 JR      PRNTN1
040E22 AC 
               2888 ;
040E23 06      2889 PRINT6:			LD      B,2
040E24 02 
040E25 18      2890 JR      PRINTC
040E26 27 
040E27 01      2891 PRINT8:			LD      BC,100H
040E28 00 
040E29 01 
040E2A 00 
040E2B 18      2892 JR      PRINTC
040E2C 21 
040E2D 21      2893 PRINT9:			LD      HL,STAVAR
040E2E 00 
040E2F 4C 
040E30 04 
040E31 AF      2894 XOR     A
040E32 BE      2895 CP      (HL)
040E33 28      2896 JR      Z,PRINT0
040E34 12 
040E35 3A      2897 LD      A,(COUNT)
040E36 3D 
040E37 4D 
040E38 04 
040E39 B7      2898 OR      A
040E3A 28      2899 JR      Z,PRINT0
040E3B 0B 
040E3C 96      2900 PRINTA:			SUB     (HL)
040E3D 28      2901 JR      Z,PRINT0
040E3E 08 
040E3F 30      2902 JR      NC,PRINTA
040E40 FB 
040E41 ED      2903 NEG
040E42 44 
040E43 CD      2904 CALL    FILL
040E44 EF 
040E45 17 
040E46 04 
040E47 3A      2905 PRINT0:			LD      A,(STAVAR)
040E48 00 
040E49 4C 
040E4A 04 
040E4B 4F      2906 LD      C,A             ;PRINTS
040E4C 06      2907 LD      B,0             ;PRINTF
040E4D 00 
040E4E CD      2908 PRINTC:			CALL    TERMQ
040E4F 7A 
040E50 17 
040E51 04 
040E52 28      2909 JR      Z,PRINT4
040E53 3F 
040E54 CB      2910 RES     0,B
040E55 80 
040E56 FD      2911 INC     IY
040E57 23 
040E58 FE      2912 CP      '~'
040E59 7E 
040E5A 28      2913 JR      Z,PRINT6
040E5B C7 
040E5C FE      2914 CP      ';'
040E5D 3B 
040E5E 28      2915 JR      Z,PRINT8
040E5F C7 
040E60 FE      2916 CP      ','
040E61 2C 
040E62 28      2917 JR      Z,PRINT9
040E63 C9 
040E64 CD      2918 CALL    FORMAT          ;SPC, TAB, '
040E65 9F 
040E66 17 
040E67 04 
040E68 28      2919 JR      Z,PRINTC
040E69 E4 
040E6A FD      2920 DEC     IY
040E6B 2B 
040E6C C5      2921 PUSH    BC
040E6D CD      2922 CALL    EXPR            ;VARIABLE TYPE
040E6E C7 
040E6F 01 
040E70 04 
040E71 08      2923 EX      AF,AF'
040E72 FA      2924 JP      M,PRINT3        ;STRING
040E73 8C 
040E74 0E 
040E75 04 
040E76 D1      2925 POP     DE
040E77 D5      2926 PUSH    DE
040E78 CB      2927 BIT     1,D
040E79 4A 
040E7A F5      2928 PUSH    AF
040E7B CC      2929 CALL    Z,STR           ;DECIMAL
040E7C 66 
040E7D 09 
040E7E 04 
040E7F F1      2930 POP     AF
040E80 C4      2931 CALL    NZ,HEXSTR       ;HEX
040E81 1A 
040E82 09 
040E83 04 
040E84 C1      2932 POP     BC
040E85 C5      2933 PUSH    BC
040E86 79      2934 LD      A,C
040E87 93      2935 SUB     E
040E88 D4      2936 CALL    NC,FILL         ;RIGHT JUSTIFY
040E89 EF 
040E8A 17 
040E8B 04 
040E8C C1      2937 PRINT3:			POP     BC
040E8D CD      2938 CALL    PTEXT           ;PRINT
040E8E FE 
040E8F 17 
040E90 04 
040E91 18      2939 JR      PRINTC
040E92 BB 
040E93 CB      2940 PRINT4:			BIT     0,B
040E94 40 
040E95 CC      2941 CALL    Z,CRLF
040E96 47 
040E97 39 
040E98 04 
040E99 C3      2942 JP      XEQ
040E9A 96 
040E9B 0B 
040E9C 04 
               2943 
               2944 ; ON ERROR statement [:statement...]
               2945 ; ON ERROR OFF
               2946 ;
040E9D FD      2947 ONERR:			INC     IY              ;SKIP "ERROR"
040E9E 23 
040E9F 21      2948 LD      HL,0
040EA0 00 
040EA1 00 
040EA2 00 
040EA3 22      2949 LD      (ERRTRP),HL
040EA4 2C 
040EA5 4D 
040EA6 04 
040EA7 CD      2950 CALL    NXT
040EA8 70 
040EA9 0A 
040EAA 04 
040EAB FE      2951 CP      OFF_
040EAC 87 
040EAD FD      2952 INC     IY
040EAE 23 
040EAF CA      2953 JP      Z,XEQ
040EB0 96 
040EB1 0B 
040EB2 04 
040EB3 FD      2954 DEC     IY
040EB4 2B 
040EB5 FD      2955 LD      (ERRTRP),IY
040EB6 22 
040EB7 2C 
040EB8 4D 
040EB8 04   
040EBA C3      2956 JP      REM_EX
040EBB 2B 
040EBC 0C 
040EBD 04 
               2957 
               2958 ; ON expr GOTO line[,line...] [ELSE statement]
               2959 ; ON expr GOTO line[,line...] [ELSE line]
               2960 ; ON expr GOSUB line[,line...] [ELSE statement]
               2961 ; ON expr GOSUB line[,line...] [ELSE line]
               2962 ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
               2963 ;
040EBE FE      2964 ON_EX_:			CP      TERROR_EX
040EBF 85 
040EC0 28      2965 JR      Z,ONERR         ;"ON ERROR"
040EC1 DB 
040EC2 CD      2966 CALL    EXPRI
040EC3 0A 
040EC4 03 
040EC5 04 
040EC6 FD      2967 LD      A,(IY)
040EC7 7E 
040EC8 00 
040EC9 FD      2968 INC     IY
040ECA 23 
040ECB 1E      2969 LD      E,','           ;SEPARATOR
040ECC 2C 
040ECD FE      2970 CP      TGOTO
040ECE E5 
040ECF 28      2971 JR      Z,ON1
040ED0 0B 
040ED1 FE      2972 CP      TGOSUB
040ED2 E4 
040ED3 28      2973 JR      Z,ON1
040ED4 07 
040ED5 1E      2974 LD      E,TPROC
040ED6 F2 
040ED7 BB      2975 CP      E
040ED8 3E      2976 LD      A,39
040ED9 27 
040EDA 20      2977 JR      NZ,ERROR2_EX       ;"ON syntax"
040EDB 45 
040EDC 57      2978 ON1:			LD      D,A
040EDD D9      2979 EXX
040EDE E5      2980 PUSH    HL
040EDF D9      2981 EXX
040EE0 C1      2982 POP     BC              ;ON INDEX
040EE1 78      2983 LD      A,B
040EE2 B4      2984 OR      H
040EE3 B5      2985 OR      L
040EE4 20      2986 JR      NZ,ON4          ;OUT OF RANGE
040EE5 2A 
040EE6 B1      2987 OR      C
040EE7 28      2988 JR      Z,ON4
040EE8 27 
040EE9 0D      2989 DEC     C
040EEA 28      2990 JR      Z,ON3           ;INDEX=1
040EEB 0E 
040EEC CD      2991 ON2:			CALL    TERMQ
040EED 7A 
040EEE 17 
040EEF 04 
040EF0 28      2992 JR      Z,ON4           ;OUT OF RANGE
040EF1 1E 
040EF2 FD      2993 INC     IY              ;SKIP DELIMITER
040EF3 23 
040EF4 BB      2994 CP      E
040EF5 20      2995 JR      NZ,ON2
040EF6 F5 
040EF7 0D      2996 DEC     C
040EF8 20      2997 JR      NZ,ON2
040EF9 F2 
040EFA 7B      2998 ON3:			LD      A,E
040EFB FE      2999 CP      TPROC
040EFC F2 
040EFD 28      3000 JR      Z,ONPROC
040EFE 26 
040EFF D5      3001 PUSH    DE
040F00 CD      3002 CALL    ITEMI           ;LINE NUMBER
040F01 25 
040F02 03 
040F03 04 
040F04 D1      3003 POP     DE
040F05 7A      3004 LD      A,D
040F06 FE      3005 CP      TGOTO
040F07 E5 
040F08 28      3006 JR      Z,GOTO2
040F09 2D 
040F0A CD      3007 CALL    SPAN            ;SKIP REST OF LIST
040F0B 87 
040F0C 17 
040F0D 04 
040F0E 18      3008 JR      GOSUB1
040F0F 3B 
               3009 ;
040F10 FD      3010 ON4:			LD      A,(IY)
040F11 7E 
040F12 00 
040F13 FD      3011 INC     IY
040F14 23 
040F15 FE      3012 CP      ELSE_EX_
040F16 8B 
040F17 CA      3013 JP      Z,IF1           ;ELSE CLAUSE
040F18 4B 
040F19 13 
040F1A 04 
040F1B FE      3014 CP      CR
040F1C 0D 
040F1D 20      3015 JR      NZ,ON4
040F1E F1 
040F1F 3E      3016 LD      A,40
040F20 28 
040F21 C3      3017 ERROR2_EX:			JP      ERROR_           ;"ON range"
040F22 60 
040F23 37 
040F24 04 
               3018 ;
040F25 3E      3019 ONPROC:			LD      A,TON
040F26 EE 
040F27 C3      3020 JP      PROC_EX
040F28 84 
040F29 10 
040F2A 04 
               3021 
               3022 ; GOTO line
               3023 ;
040F2B CD      3024 GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F2C 25 
040F2D 03 
040F2E 04 
040F2F CD      3025 GOTO1:			CALL    TERMQ			; Check for terminator
040F30 7A 
040F31 17 
040F32 04 
040F33 C2      3026 JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F34 97 
040F35 0C 
040F36 04 
040F37 D9      3027 GOTO2:			EXX
040F38 CD      3028 CALL    FINDL			; HL: Line number - Find the line
040F39 8F 
040F3A 39 
040F3B 04 
040F3C E5      3029 PUSH    HL			; HL: Address of the line
040F3D FD      3030 POP     IY			; IY = HL
040F3E E1 
040F3F CA      3031 JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F40 92 
040F41 0B 
040F42 04 
040F43 3E      3032 LD      A,41			; Otherwise throw a "No such line" error
040F44 29 
040F45 18      3033 JR      ERROR2_EX
040F46 DA 
               3034 
               3035 ; GOSUB line
               3036 ; This pushes the following data onto the execution stack
               3037 ; - 3 bytes: Current execution address
               3038 ; - 3 bytes: Marker (the address of label GOSCHK)
               3039 ;
040F47 CD      3040 GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F48 25 
040F49 03 
040F4A 04 
040F4B FD      3041 GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F4C E5 
040F4D CD      3042 CALL    CHECK           	; Check there is enough room
040F4E 4F 
040F4F 16 
040F50 04 
040F51 CD      3043 CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F52 2F 
040F53 0F 
040F54 04 
               3044 GOSCHK:			EQU     $
               3045 
               3046 ; RETURN
               3047 ; This pops the following data off the execution stack as pushed by GOSUB
               3048 ; - 3 bytes: Marker (should be the address of label GOSCHK)
               3049 ; - 3 bytes: The return execution address
               3050 ;
040F55 D1      3051 RETURN:			POP     DE			; Pop the marker off the execution stack
040F56 21      3052 LD      HL,GOSCHK		; Compare with GOSCHK
040F57 55 
040F58 0F 
040F59 04 
040F5A B7      3053 OR      A
040F5B ED      3054 SBC     HL,DE
040F5C 52 
040F5D FD      3055 POP     IY			; Pop the return address off the execution stack
040F5E E1 
040F5F CA      3056 JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F60 96 
040F61 0B 
040F62 04 
040F63 3E      3057 LD      A,38			; Otherwise throw a "No GOSUB" error
040F64 26 
040F65 18      3058 JR      ERROR2_EX
040F66 BA 
               3059 
               3060 ; REPEAT
               3061 ; This pushes the following data onto the execution stack
               3062 ; - 3 bytes: Current execution address
               3063 ; - 3 bytes: Marker (the address of label REPCHK)
               3064 ;
040F67 FD      3065 REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F68 E5 
040F69 CD      3066 CALL    CHECK			; Check if there is enough room
040F6A 4F 
040F6B 16 
040F6C 04 
040F6D CD      3067 CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F6E 96 
040F6F 0B 
040F70 04 
               3068 REPCHK:			EQU     $
               3069 
               3070 ; UNTIL expr
               3071 ; This pops the following data off the execution stack
               3072 ; - 3 bytes: Marker (should be the address of label REPCHK)
               3073 ; - 3 bytes: The address of the REPEAT instruction
               3074 ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
               3075 ;
040F71 C1      3076 UNTIL_EX:			POP     BC			; Fetch the marker
040F72 C5      3077 PUSH    BC			; And push it back onto the execution stack
040F73 21      3078 LD      HL,REPCHK		; Compare with REPCHK
040F74 71 
040F75 0F 
040F76 04 
040F77 B7      3079 OR      A
040F78 ED      3080 SBC     HL,BC
040F79 42 
040F7A 3E      3081 LD      A,43
040F7B 2B 
040F7C 20      3082 JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F7D A3 
040F7E CD      3083 CALL    EXPRI			; Fetch the expression
040F7F 0A 
040F80 03 
040F81 04 
040F82 CD      3084 CALL    TEST			; Test if the expression evaluates to zero
040F83 DF 
040F84 08 
040F85 04 
040F86 C1      3085 POP     BC			; Pop the marker
040F87 D1      3086 POP     DE			; Pop the address of the REPEAT instruction
040F88 20      3087 JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F89 05 
040F8A D5      3088 PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F8B C5      3089 PUSH    BC			; Push the marker back on the stack
040F8C D5      3090 PUSH    DE			; IY = DE
040F8D FD      3091 POP     IY			; This sets the execution address back to the REPEAT instruction
040F8E E1 
040F8F C3      3092 XEQ2:			JP      XEQ			; Continue execution
040F90 96 
040F91 0B 
040F92 04 
               3093 
               3094 ; FOR var = expr TO expr [STEP expr]
               3095 ; This pushes the following data onto the execution stack
               3096 ; - 3 bytes: The limit value
               3097 ; - 3 bytes: The step value
               3098 ; - 3 bytes: The current execution address
               3099 ; - 3 bytes: The address of the loop variable
               3100 ; - 3 bytes: Marker (the address of FORCHK)
               3101 ;
040F93 3E      3102 FORVAR:			LD      A,34
040F94 22 
040F95 18      3103 JR      ERROR2_EX          	; Throw "FOR variable" error
040F96 8A 
               3104 ;
040F97 CD      3105 FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040F98 BE 
040F99 15 
040F9A 04 
040F9B 20      3106 JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040F9C F6 
040F9D F5      3107 PUSH    AF              	; Save the variable type
040F9E FD      3108 LD      A,(IY)			; Check the next token
040F9F 7E 
040FA0 00 
040FA1 FE      3109 CP      TO_EX			; Compare with the token value for "TO"
040FA2 B8 
040FA3 3E      3110 LD      A,36			; Set the error code to 36 ("No TO")
040FA4 24 
040FA5 C2      3111 JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FA6 21 
040FA7 0F 
040FA8 04 
040FA9 FD      3112 INC     IY			; Skip to the next token
040FAA 23 
               3113 ;
040FAB DD      3114 PUSH    IX
040FAC E5 
040FAD CD      3115 CALL    EXPRN           	; Fetch the LIMIT expression value
040FAE 02 
040FAF 03 
040FB0 04 
040FB1 DD      3116 POP     IX
040FB2 E1 
040FB3 F1      3117 POP     AF
040FB4 47      3118 LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FB5 C5      3119 PUSH    BC              	; Stack the LIMIT value
040FB6 E5      3120 PUSH    HL
040FB7 21      3121 LD      HL,0
040FB8 00 
040FB9 00 
040FBA 00 
040FBB 4C      3122 LD      C,H
040FBC D9      3123 EXX
040FBD E5      3124 PUSH    HL
               3125 ;
040FBE 21      3126 LD      HL,1            	; The preset STEP value is 1
040FBF 01 
040FC0 00 
040FC1 00 
040FC2 D9      3127 EXX
040FC3 FD      3128 LD      A,(IY)			; Fetch the next token
040FC4 7E 
040FC5 00 
040FC6 FE      3129 CP      STEP			; Compare with the token value for "STEP"
040FC7 88 
040FC8 20      3130 JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FC9 0A 
               3131 ;
040FCA FD      3132 INC     IY			; Skip past the STEP token
040FCB 23 
040FCC DD      3133 PUSH    IX
040FCD E5 
040FCE CD      3134 CALL    EXPRN          		; Fetch the STEP expression value
040FCF 02 
040FD0 03 
040FD1 04 
040FD2 DD      3135 POP     IX
040FD3 E1 
               3136 ;
040FD4 C5      3137 FOR1:			PUSH    BC			; Stack the STEP value
040FD5 E5      3138 PUSH    HL
040FD6 D9      3139 EXX
040FD7 E5      3140 PUSH    HL
040FD8 D9      3141 EXX
               3142 ;
040FD9 FD      3143 PUSH    IY              	; Stack the current execution address
040FDA E5 
040FDB DD      3144 PUSH    IX              	; Stack the loop variable
040FDC E5 
040FDD CD      3145 CALL    CHECK
040FDE 4F 
040FDF 16 
040FE0 04 
040FE1 CD      3146 CALL    XEQ
040FE2 96 
040FE3 0B 
040FE4 04 
               3147 FORCHK:			EQU     $
               3148 
               3149 ; NEXT [var[,var...]]
               3150 ; This pops the following data off the execution stack
               3151 ; - 3 bytes: Marker (the address of FORCHK)
               3152 ; - 3 bytes: The address of the loop variable
               3153 ; - 3 bytes: The current execution address
               3154 ; - 3 bytes: The step value
               3155 ; - 3 bytes: The limit value
               3156 ; It also ensures that the data is pushed back on for subsequent NEXT instructions
               3157 ;
040FE5 C1      3158 NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FE6 21      3159 LD      HL,FORCHK		; Compare with FORCHK
040FE7 E5 
040FE8 0F 
040FE9 04 
040FEA B7      3160 OR      A
040FEB ED      3161 SBC     HL,BC
040FEC 42 
040FED 3E      3162 LD      A,32
040FEE 20 
040FEF C2      3163 JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF0 7B 
040FF1 10 
040FF2 04 
040FF3 CD      3164 CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FF4 7A 
040FF5 17 
040FF6 04 
040FF7 E1      3165 POP     HL			; Pop the address of the loop variable off the execution stack
040FF8 E5      3166 PUSH    HL			; Push it back onto the execution stack
040FF9 C5      3167 PUSH    BC			; Push the marker back onto the execution stack
040FFA E5      3168 PUSH    HL			; HL: Address of the loop variable off the stack
040FFB C4      3169 CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040FFC 3A 
040FFD 3A 
040FFE 04 
040FFF D1      3170 POP     DE			; DE: Address of the loop variable off the stack
041000 EB      3171 EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041001 B7      3172 OR      A
041002 ED      3173 NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041003 52 
041004 20      3174 JR      NZ,NEXT1		; They don't, so jump to NEXT1
041005 61 
041006 D5      3175 PUSH    DE
041007 DD      3176 LD      IX,9+3			; IX: Address of the STEP value on the execution stack
041008 21 
041009 0C 
04100A 00 
04100A 00   
04100C DD      3177 ADD     IX,SP
04100D 39 
04100E CD      3178 CALL    DLOAD5_SPL      	; Load the STEP value
04100F E1 
041010 29 
041011 04 
041012 DD      3179 LD      A,(IX+16)       	; Get the STEP type
041013 7E 
041014 10 
041015 DD      3180 POP     IX
041016 E1 
041017 CD      3181 CALL    LOADN           	; Load the LOOP variable
041018 16 
041019 04 
04101A 04 
04101B CB      3182 BIT     7,D             	; Check the sign
04101C 7A 
04101D F5      3183 PUSH    AF
04101E 3E      3184 LD      A,'+' & 0FH
04101F 0B 
041020 CD      3185 CALL    FPP             	; Add the STEP
041021 6A 
041022 20 
041023 04 
041024 38      3186 JR      C,ERROR3_EX
041025 55 
041026 F1      3187 POP     AF              	; Restore TYPE
041027 F5      3188 PUSH    AF
041028 CD      3189 CALL    STORE           	; Update the variable
041029 D6 
04102A 15 
04102B 04 
04102C DD      3190 LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
04102D 21 
04102E 15 
04102F 00 
04102F 00   
041031 DD      3191 ADD     IX,SP
041032 39 
041033 CD      3192 CALL    DLOAD5_SPL      	; Load the LIMIT value
041034 E1 
041035 29 
041036 04 
041037 F1      3193 POP     AF
041038 CC      3194 CALL    Z,SWAP			; Swap the arguments if the sign is ?
041039 D7 
04103A 08 
04103B 04 
               3195 ; LD      A,0+('<'-4) & 0FH
04103C 3E      3196 LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04103D 08 
04103E CD      3197 CALL    FPP             	; Test against the limit
04103F 6A 
041040 20 
041041 04 
041042 38      3198 JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041043 37 
041044 24      3199 INC     H
041045 20      3200 JR      NZ,LOOP_        	; Keep looping
041046 14 
041047 21      3201 LD      HL,27			; Adjust the stack
041048 1B 
041049 00 
04104A 00 
04104B 39      3202 ADD     HL,SP
04104C F9      3203 LD      SP,HL
04104D CD      3204 CALL    NXT
04104E 70 
04104F 0A 
041050 04 
041051 FE      3205 CP      ','			; Check for multiple variables
041052 2C 
041053 C2      3206 JP      NZ,XEQ			; No, so we are done at ths point
041054 96 
041055 0B 
041056 04 
041057 FD      3207 INC     IY			; Increment to the next variable
041058 23 
041059 18      3208 JR      NEXT_EX			; And continue
04105A 8A 
               3209 ;
04105B C1      3210 LOOP_:			POP     BC
04105C D1      3211 POP     DE
04105D FD      3212 POP     IY
04105E E1 
04105F FD      3213 PUSH    IY
041060 E5 
041061 D5      3214 PUSH    DE
041062 C5      3215 PUSH    BC
041063 C3      3216 JP      XEQ
041064 96 
041065 0B 
041066 04 
               3217 ;
041067 21      3218 NEXT1:			LD      HL,27			; TODO: What does this do?
041068 1B 
041069 00 
04106A 00 
04106B 39      3219 ADD     HL,SP
04106C F9      3220 LD      SP,HL			; Adjust the stack
04106D C1      3221 POP     BC
04106E 21      3222 LD      HL,FORCHK
04106F E5 
041070 0F 
041071 04 
041072 ED      3223 SBC     HL,BC
041073 42 
041074 E1      3224 POP     HL              	; Variable pointer
041075 E5      3225 PUSH    HL
041076 C5      3226 PUSH    BC
041077 28      3227 JR      Z,NEXT0
041078 89 
               3228 ;
041079 3E      3229 LD      A,33
04107A 21 
04107B C3      3230 ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
04107C 60 
04107D 37 
04107E 04 
               3231 
               3232 ; FNname
               3233 ; N.B. ENTERED WITH A <> TON
               3234 ;
04107F F5      3235 FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041080 CD      3236 CALL    PROC1
041081 89 
041082 10 
041083 04 
               3237 FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3238 
               3239 ; PROCname
               3240 ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
               3241 ; This pushes the following data onto the execution stack
               3242 ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
               3243 ; - 3 bytes: Marker (the address of PROCHK)
               3244 ;
041084 F5      3245 PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041085 CD      3246 CALL    PROC1			; and is also space reserved on the stack for the return address
041086 89 
041087 10 
041088 04 
               3247 PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3248 ;
041089 CD      3249 PROC1:			CALL    CHECK			; Check there is space for this
04108A 4F 
04108B 16 
04108C 04 
04108D FD      3250 DEC     IY			; Decrement IY to the PROC token
04108E 2B 
04108F FD      3251 PUSH    IY			; Stack the pointer
041090 E5 
041091 CD      3252 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041092 FB 
041093 3A 
041094 04 
041095 C1      3253 POP     BC			; BC = IY
041096 28      3254 JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041097 41 
041098 3E      3255 LD      A,30
041099 1E 
04109A 38      3256 JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
04109B DF 
               3257 ;
               3258 ; At this point the PROC/FN has not yet been registered in the dynamic area
               3259 ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
               3260 ;
04109C C5      3261 PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
04109D 2A      3262 LD      HL,(PAGE_)		; HL: Start of program memory
04109E 14 
04109F 4D 
0410A0 04 
               3263 ;
0410A1 3E      3264 PROC2:			LD      A,DEF_			;  A: The token to search for
0410A2 DD 
0410A3 CD      3265 CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410A4 4E 
0410A5 18 
0410A6 04 
0410A7 38      3266 JR      C,PROC3			; Not found, so jump to PROC3
0410A8 26 
0410A9 E5      3267 PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410AA FD      3268 POP     IY			; IY = HL
0410AB E1 
0410AC FD      3269 INC     IY              	; Skip the DEF token
0410AD 23 
0410AE CD      3270 CALL    NXT			; And any whitespace
0410AF 70 
0410B0 0A 
0410B1 04 
0410B2 CD      3271 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410B3 FB 
0410B4 3A 
0410B5 04 
0410B6 FD      3272 PUSH    IY
0410B7 E5 
0410B8 D1      3273 POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410B9 38      3274 JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410BA 09 
0410BB C4      3275 CALL    NZ,CREATE		; Create an entity in the dynamic area
0410BC AE 
0410BD 3B 
0410BE 04 
0410BF FD      3276 PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C0 E5 
0410C1 D1      3277 POP     DE			; DE = IY
0410C2 ED      3278 LD	(HL),DE			; Save address
0410C3 1F 
               3279 ;
0410C4 EB      3280 PROC6:			EX      DE,HL			; HL: Address of the procedure
0410C5 3E      3281 LD      A,CR			; The character to search for
0410C6 0D 
0410C7 01      3282 LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410C8 00 
0410C9 01 
0410CA 00 
0410CB ED      3283 CPIR                    	; Skip to next line
0410CC B1 
0410CD 18      3284 JR      PROC2			; Rinse, lather and repeat
0410CE D2 
               3285 ;
               3286 ; At this point a DEF has not been found for the PROC/FN
               3287 ;
0410CF FD      3288 PROC3:			POP     IY              	; Restore the execution address
0410D0 E1 
0410D1 CD      3289 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410D2 FB 
0410D3 3A 
0410D4 04 
0410D5 3E      3290 LD      A,29
0410D6 1D 
0410D7 20      3291 JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410D8 A2 
               3292 ;
               3293 ; At this point we have a PROC/FN entry in the dynamic area
               3294 ;
0410D9 ED      3295 PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410DA 17 
0410DB 21      3296 LD	HL,3
0410DC 03 
0410DD 00 
0410DE 00 
0410DF 39      3297 ADD     HL,SP
0410E0 CD      3298 CALL    NXT             	; Allow space before "("
0410E1 70 
0410E2 0A 
0410E3 04 
0410E4 D5      3299 PUSH    DE              	; Exchange DE and IY
0410E5 FD      3300 EX      (SP),IY
0410E6 E3 
0410E7 FE      3301 CP      '('             	; Arguments?
0410E8 28 
0410E9 D1      3302 POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410EA 20      3303 JR      NZ,PROC5
0410EB 20 
0410EC CD      3304 CALL    NXT             	; Allow space before "("
0410ED 70 
0410EE 0A 
0410EF 04 
0410F0 FE      3305 CP      '('
0410F1 28 
0410F2 C2      3306 JP      NZ,SYNTAX       	; Throw "Syntax error"
0410F3 97 
0410F4 0C 
0410F5 04 
0410F6 FD      3307 PUSH    IY
0410F7 E5 
0410F8 C1      3308 POP     BC              	; Save IY in BC
0410F9 D9      3309 EXX
0410FA CD      3310 CALL    SAVLOC          	; Save local parameters
0410FB FA 
0410FC 16 
0410FD 04 
0410FE CD      3311 CALL    BRAKET          	; Closing bracket
0410FF 2F 
041100 0A 
041101 04 
041102 D9      3312 EXX
041103 C5      3313 PUSH    BC
041104 FD      3314 POP     IY              	; Restore IY
041105 E1 
041106 E5      3315 PUSH    HL
041107 CD      3316 CALL    ARGUE           	; Transfer arguments
041108 76 
041109 16 
04110A 04 
04110B E1      3317 POP     HL
               3318 ;
04110C 23      3319 PROC5:			INC	HL			; Increment to the ON PROC flag address
04110D 7E      3320 LD	A, (HL)			; And fetch the value
04110E 2B      3321 DEC 	HL
04110F ED      3322 LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041110 1F 
041111 FE      3323 CP	TON			; Was it "ON PROC"?
041112 EE 
041113 C2      3324 JP	NZ, XEQ			; No, so back to XEQ
041114 96 
041115 0B 
041116 04 
041117 D5      3325 PUSH    DE			; Exchange DE and IY
041118 FD      3326 EX      (SP),IY
041119 E3 
04111A CD      3327 CALL    SPAN            	; Skip rest of ON list
04111B 87 
04111C 17 
04111D 04 
04111E FD      3328 EX      (SP),IY			; Exchange DE and IY
04111F E3 
041120 D1      3329 POP     DE
041121 ED      3330 LD	(HL), DE		; Save the return address
041122 1F 
041123 C3      3331 JP      XEQ
041124 96 
041125 0B 
041126 04 
               3332 
               3333 ; LOCAL var[,var...]
               3334 ;
041127 C1      3335 LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041128 C5      3336 PUSH    BC
041129 21      3337 LD      HL,FNCHK		; Check if we are in a FN
04112A 84 
04112B 10 
04112C 04 
04112D B7      3338 OR      A
04112E ED      3339 SBC     HL,BC
04112F 42 
041130 28      3340 JR      Z,LOCAL1		; Yes, so all good, we can use local
041131 16 
041132 21      3341 LD      HL,PROCHK		; Now check if we are in a PROC
041133 89 
041134 10 
041135 04 
041136 B7      3342 OR      A
041137 ED      3343 SBC     HL,BC
041138 42 
041139 28      3344 JR      Z,LOCAL1		; Again, all good, we can use local
04113A 0D 
04113B 21      3345 LD      HL,LOCCHK		; Finally check for the local parameters marker
04113C 58 
04113D 17 
04113E 04 
04113F B7      3346 OR      A
041140 ED      3347 SBC     HL,BC			; If it is not present, then
041141 42 
041142 3E      3348 LD      A,12
041143 0C 
041144 C2      3349 JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041145 60 
041146 37 
041147 04 
               3350 ;
               3351 ; At this point we are adding a local variable into a PROC or FN
               3352 ;
041148 FD      3353 LOCAL1:			PUSH    IY			; IY: BASIC pointer
041149 E5 
04114A C1      3354 POP     BC			; BC: Copy of the BASIC pointer
04114B D9      3355 EXX
04114C FD      3356 DEC     IY
04114D 2B 
04114E CD      3357 CALL    SAVLOC
04114F FA 
041150 16 
041151 04 
041152 D9      3358 EXX
041153 C5      3359 PUSH    BC
041154 FD      3360 POP     IY
041155 E1 
               3361 ;
041156 CD      3362 LOCAL2:			CALL    GETVAR			; Get the variable location
041157 3A 
041158 3A 
041159 04 
04115A C2      3363 JP      NZ,SYNTAX
04115B 97 
04115C 0C 
04115D 04 
04115E B7      3364 OR      A               	; Check the variable type (80h = string)
04115F 08      3365 EX      AF,AF'
041160 CD      3366 CALL    ZERO			; Zero the variable anyway
041161 93 
041162 09 
041163 04 
041164 08      3367 EX      AF,AF'
041165 F5      3368 PUSH    AF
041166 F4      3369 CALL    P,STORE         	; Call STORE if it is not a string
041167 D6 
041168 15 
041169 04 
04116A F1      3370 POP     AF
04116B 59      3371 LD      E,C
04116C FC      3372 CALL    M,STORES		; Call STORES if it is a string
04116D 04 
04116E 16 
04116F 04 
041170 CD      3373 CALL    NXT			; Skip to the next character in the expression
041171 70 
041172 0A 
041173 04 
041174 FE      3374 CP      ','			; Is it a comma?
041175 2C 
041176 C2      3375 JP      NZ,XEQ			; No, so we're done, carry on executing
041177 96 
041178 0B 
041179 04 
04117A FD      3376 INC     IY			; Yes, so skip the comma
04117B 23 
04117C CD      3377 CALL    NXT			; And any whitespace
04117D 70 
04117E 0A 
04117F 04 
041180 18      3378 JR      LOCAL2			; Then loop back and handle any further local variables
041181 D4 
               3379 
               3380 ; ENDPROC
               3381 ;
041182 C1      3382 ENDPRO:			POP     BC			; Pop the check value off the stack
041183 21      3383 LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041184 58 
041185 17 
041186 04 
041187 B7      3384 OR      A
041188 ED      3385 SBC     HL,BC
041189 42 
04118A 28      3386 JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04118B 13 
               3387 ;
04118C 21      3388 LD      HL,PROCHK       	; Check if it is the PROC marker
04118D 89 
04118E 10 
04118F 04 
041190 B7      3389 OR      A
041191 ED      3390 SBC     HL,BC
041192 42 
041193 FD      3391 POP     IY
041194 E1 
041195 CA      3392 JP      Z,XEQ			; Yes, it is, so carry on, all is good
041196 96 
041197 0B 
041198 04 
041199 3E      3393 LD      A,13			; Otherwise throw the "No PROC" error
04119A 0D 
04119B C3      3394 JP      ERROR_
04119C 60 
04119D 37 
04119E 04 
               3395 ;
04119F DD      3396 UNSTK:			POP     IX			; Unstack a single local variable
0411A0 E1 
0411A1 C1      3397 POP     BC
0411A2 78      3398 LD      A,B
0411A3 B7      3399 OR      A
0411A4 FA      3400 JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411A5 B2 
0411A6 11 
0411A7 04 
0411A8 E1      3401 POP     HL			; Unstack a normal variable
0411A9 D9      3402 EXX
0411AA E1      3403 POP     HL
0411AB D9      3404 EXX
0411AC CD      3405 CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411AD D6 
0411AE 15 
0411AF 04 
0411B0 18      3406 JR      ENDPRO			; And loop back to ENDPRO
0411B1 D0 
               3407 ;
0411B2 21      3408 UNSTK1:			LD      HL,0			; Unstack a string
0411B3 00 
0411B4 00 
0411B5 00 
0411B6 39      3409 ADD     HL,SP
0411B7 59      3410 LD      E,C
0411B8 CD      3411 CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411B9 04 
0411BA 16 
0411BB 04 
0411BC F9      3412 LD      SP,HL
0411BD 18      3413 JR      ENDPRO
0411BE C3 
               3414 
               3415 ; INPUT #channel,var,var...
               3416 ;
0411BF CD      3417 INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C0 92 
0411C1 18 
0411C2 04 
0411C3 CD      3418 INPN1:			CALL    NXT
0411C4 70 
0411C5 0A 
0411C6 04 
0411C7 FE      3419 CP      ','
0411C8 2C 
0411C9 C2      3420 JP      NZ,XEQ
0411CA 96 
0411CB 0B 
0411CC 04 
0411CD FD      3421 INC     IY
0411CE 23 
0411CF CD      3422 CALL    NXT
0411D0 70 
0411D1 0A 
0411D2 04 
0411D3 D5      3423 PUSH    DE
0411D4 CD      3424 CALL    VAR_
0411D5 8E 
0411D6 0C 
0411D7 04 
0411D8 D1      3425 POP     DE
0411D9 F5      3426 PUSH    AF              ;SAVE TYPE
0411DA E5      3427 PUSH    HL              ;VARPTR
0411DB B7      3428 OR      A
0411DC FA      3429 JP      M,INPN2         ;STRING
0411DD 08 
0411DE 12 
0411DF 04 
0411E0 CD      3430 CALL    OSBGET
0411E1 33 
0411E2 43 
0411E3 04 
0411E4 D9      3431 EXX
0411E5 6F      3432 LD      L,A
0411E6 D9      3433 EXX
0411E7 CD      3434 CALL    OSBGET
0411E8 33 
0411E9 43 
0411EA 04 
0411EB D9      3435 EXX
0411EC 67      3436 LD      H,A
0411ED D9      3437 EXX
0411EE CD      3438 CALL    OSBGET
0411EF 33 
0411F0 43 
0411F1 04 
0411F2 6F      3439 LD      L,A
0411F3 CD      3440 CALL    OSBGET
0411F4 33 
0411F5 43 
0411F6 04 
0411F7 67      3441 LD      H,A
0411F8 CD      3442 CALL    OSBGET
0411F9 33 
0411FA 43 
0411FB 04 
0411FC 4F      3443 LD      C,A
0411FD DD      3444 POP     IX
0411FE E1 
0411FF F1      3445 POP     AF              ;RESTORE TYPE
041200 D5      3446 PUSH    DE              ;SAVE CHANNEL
041201 CD      3447 CALL    STORE
041202 D6 
041203 15 
041204 04 
041205 D1      3448 POP     DE
041206 18      3449 JR      INPN1
041207 BB 
041208 21      3450 INPN2:			LD      HL,ACCS
041209 00 
04120A 4A 
04120B 04 
04120C CD      3451 INPN3:			CALL    OSBGET
04120D 33 
04120E 43 
04120F 04 
041210 FE      3452 CP      CR
041211 0D 
041212 28      3453 JR      Z,INPN4
041213 04 
041214 77      3454 LD      (HL),A
041215 2C      3455 INC     L
041216 20      3456 JR      NZ,INPN3
041217 F4 
041218 DD      3457 INPN4:			POP     IX
041219 E1 
04121A F1      3458 POP     AF
04121B D5      3459 PUSH    DE
04121C EB      3460 EX      DE,HL
04121D CD      3461 CALL    STACCS
04121E 00 
04121F 16 
041220 04 
041221 D1      3462 POP     DE
041222 18      3463 JR      INPN1
041223 9F 
               3464 
               3465 ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3466 ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3467 ;
041224 FE      3468 INPUT:			CP      '#'
041225 23 
041226 28      3469 JR      Z,INPUTN
041227 97 
041228 0E      3470 LD      C,0             ;FLAG PROMPT
041229 00 
04122A FE      3471 CP      LINE_EX_
04122B 86 
04122C 20      3472 JR      NZ,INPUT0
04122D 04 
04122E FD      3473 INC     IY              ;SKIP "LINE"
04122F 23 
041230 0E      3474 LD      C,80H
041231 80 
041232 21      3475 INPUT0:			LD      HL,BUFFER
041233 00 
041234 4B 
041235 04 
041236 36      3476 LD      (HL),CR         ;INITIALISE EMPTY
041237 0D 
041238 CD      3477 INPUT1:			CALL    TERMQ
041239 7A 
04123A 17 
04123B 04 
04123C CA      3478 JP      Z,XEQ           ;DONE
04123D 96 
04123E 0B 
04123F 04 
041240 FD      3479 INC     IY
041241 23 
041242 FE      3480 CP      ','
041243 2C 
041244 28      3481 JR      Z,INPUT3        ;SKIP COMMA
041245 5C 
041246 FE      3482 CP      ';'
041247 3B 
041248 28      3483 JR      Z,INPUT3
041249 58 
04124A E5      3484 PUSH    HL              ;SAVE BUFFER POINTER
04124B FE      3485 CP      34		;ASCII ""
04124C 22 
04124D 20      3486 JR      NZ,INPUT6
04124E 0C 
04124F C5      3487 PUSH    BC
041250 CD      3488 CALL    CONS
041251 67 
041252 04 
041253 04 
041254 C1      3489 POP     BC
041255 CD      3490 CALL    PTEXT           ;PRINT PROMPT
041256 FE 
041257 17 
041258 04 
041259 18      3491 JR      INPUT9
04125A 06 
04125B CD      3492 INPUT6:			CALL    FORMAT          ;SPC, TAB, '
04125C 9F 
04125D 17 
04125E 04 
04125F 20      3493 JR      NZ,INPUT2
041260 05 
041261 E1      3494 INPUT9:			POP     HL
041262 CB      3495 SET     0,C             ;FLAG NO PROMPT
041263 C1 
041264 18      3496 JR      INPUT0
041265 CC 
041266 FD      3497 INPUT2:			DEC     IY
041267 2B 
041268 C5      3498 PUSH    BC
041269 CD      3499 CALL    VAR_
04126A 8E 
04126B 0C 
04126C 04 
04126D C1      3500 POP     BC
04126E E1      3501 POP     HL
04126F F5      3502 PUSH    AF              ;SAVE TYPE
041270 7E      3503 LD      A,(HL)
041271 23      3504 INC     HL
041272 FE      3505 CP      CR              ;BUFFER EMPTY?
041273 0D 
041274 CC      3506 CALL    Z,REFILL
041275 A6 
041276 12 
041277 04 
041278 CB      3507 BIT     7,C
041279 79 
04127A F5      3508 PUSH    AF
04127B C4      3509 CALL    NZ,LINES
04127C 20 
04127D 18 
04127E 04 
04127F F1      3510 POP     AF
041280 CC      3511 CALL    Z,FETCHS
041281 0D 
041282 18 
041283 04 
041284 F1      3512 POP     AF              ;RESTORE TYPE
041285 C5      3513 PUSH    BC
041286 E5      3514 PUSH    HL
041287 B7      3515 OR      A
041288 FA      3516 JP      M,INPUT4        ;STRING
041289 9C 
04128A 12 
04128B 04 
04128C F5      3517 PUSH    AF
04128D DD      3518 PUSH    IX
04128E E5 
04128F CD      3519 CALL    VAL0
041290 6E 
041291 06 
041292 04 
041293 DD      3520 POP     IX
041294 E1 
041295 F1      3521 POP     AF
041296 CD      3522 CALL    STORE
041297 D6 
041298 15 
041299 04 
04129A 18      3523 JR      INPUT5
04129B 04 
04129C CD      3524 INPUT4:			CALL    STACCS
04129D 00 
04129E 16 
04129F 04 
0412A0 E1      3525 INPUT5:			POP     HL
0412A1 C1      3526 POP     BC
0412A2 CB      3527 INPUT3:			RES     0,C
0412A3 81 
0412A4 18      3528 JR      INPUT1
0412A5 92 
               3529 ;
0412A6 CB      3530 REFILL:			BIT     0,C
0412A7 41 
0412A8 20      3531 JR      NZ,REFIL0       ;NO PROMPT
0412A9 0C 
0412AA 3E      3532 LD      A,'?'
0412AB 3F 
0412AC CD      3533 CALL    OUTCHR          ;PROMPT
0412AD 4F 
0412AE 39 
0412AF 04 
0412B0 3E      3534 LD      A,' '
0412B1 20 
0412B2 CD      3535 CALL    OUTCHR
0412B3 4F 
0412B4 39 
0412B5 04 
0412B6 21      3536 REFIL0:			LD      HL,BUFFER
0412B7 00 
0412B8 4B 
0412B9 04 
0412BA C5      3537 PUSH    BC
0412BB E5      3538 PUSH    HL
0412BC DD      3539 PUSH    IX
0412BD E5 
0412BE CD      3540 CALL    OSLINE
0412BF 5F 
0412C0 3E 
0412C1 04 
0412C2 DD      3541 POP     IX
0412C3 E1 
0412C4 E1      3542 POP     HL
0412C5 C1      3543 POP     BC
0412C6 47      3544 LD      B,A             ;POS AT ENTRY
0412C7 AF      3545 XOR     A
0412C8 32      3546 LD      (COUNT),A
0412C9 3D 
0412CA 4D 
0412CB 04 
0412CC B8      3547 CP      B
0412CD C8      3548 RET     Z
0412CE 7E      3549 REFIL1:			LD      A,(HL)
0412CF FE      3550 CP      CR
0412D0 0D 
0412D1 C8      3551 RET     Z
0412D2 23      3552 INC     HL
0412D3 10      3553 DJNZ    REFIL1
0412D4 F9 
0412D5 C9      3554 RET
               3555 
               3556 ; READ var[,var...]
               3557 ;
0412D6 FE      3558 READ:			CP      '#'
0412D7 23 
0412D8 CA      3559 JP      Z,INPUTN
0412D9 BF 
0412DA 11 
0412DB 04 
0412DC 2A      3560 LD      HL,(DATPTR)
0412DD 31 
0412DE 4D 
0412DF 04 
0412E0 7E      3561 READ0:			LD      A,(HL)
0412E1 23      3562 INC     HL              ;SKIP COMMA OR "DATA"
0412E2 FE      3563 CP      CR              ;END OF DATA STMT?
0412E3 0D 
0412E4 CC      3564 CALL    Z,GETDAT
0412E5 28 
0412E6 13 
0412E7 04 
0412E8 E5      3565 PUSH    HL
0412E9 CD      3566 CALL    VAR_
0412EA 8E 
0412EB 0C 
0412EC 04 
0412ED E1      3567 POP     HL
0412EE B7      3568 OR      A
0412EF FA      3569 JP      M,READ1         ;STRING
0412F0 08 
0412F1 13 
0412F2 04 
0412F3 E5      3570 PUSH    HL
0412F4 FD      3571 EX      (SP),IY
0412F5 E3 
0412F6 F5      3572 PUSH    AF              ;SAVE TYPE
0412F7 DD      3573 PUSH    IX
0412F8 E5 
0412F9 CD      3574 CALL    EXPRN
0412FA 02 
0412FB 03 
0412FC 04 
0412FD DD      3575 POP     IX
0412FE E1 
0412FF F1      3576 POP     AF
041300 CD      3577 CALL    STORE
041301 D6 
041302 15 
041303 04 
041304 FD      3578 EX      (SP),IY
041305 E3 
041306 18      3579 JR      READ2
041307 09 
041308 CD      3580 READ1:			CALL    FETCHS
041309 0D 
04130A 18 
04130B 04 
04130C E5      3581 PUSH    HL
04130D CD      3582 CALL    STACCS
04130E 00 
04130F 16 
041310 04 
041311 E1      3583 READ2:			POP     HL
041312 22      3584 LD      (DATPTR),HL
041313 31 
041314 4D 
041315 04 
041316 CD      3585 CALL    NXT
041317 70 
041318 0A 
041319 04 
04131A FE      3586 CP      ','
04131B 2C 
04131C C2      3587 JP      NZ,XEQ
04131D 96 
04131E 0B 
04131F 04 
041320 FD      3588 INC     IY
041321 23 
041322 CD      3589 CALL    NXT
041323 70 
041324 0A 
041325 04 
041326 18      3590 JR      READ0
041327 B8 
               3591 ;
041328 3E      3592 GETDAT:			LD      A,DATA_EX_
041329 DC 
04132A CD      3593 CALL    SEARCH_EX
04132B 4E 
04132C 18 
04132D 04 
04132E 23      3594 INC     HL
04132F D0      3595 RET     NC
041330 3E      3596 LD      A,42
041331 2A 
041332 C3      3597 ERROR4:			JP      ERROR_           ;"Out of DATA"
041333 60 
041334 37 
041335 04 
               3598 
               3599 ; IF expr statement
               3600 ; IF expr THEN statement [ELSE statement]
               3601 ; IF expr THEN line [ELSE line]
               3602 ;
041336 CD      3603 IF_:			CALL    EXPRI
041337 0A 
041338 03 
041339 04 
04133A CD      3604 CALL    TEST
04133B DF 
04133C 08 
04133D 04 
04133E 28      3605 JR      Z,IFNOT         ;FALSE
04133F 19 
041340 FD      3606 LD      A,(IY)
041341 7E 
041342 00 
041343 FE      3607 CP      THEN_EX_
041344 8C 
041345 C2      3608 JP      NZ,XEQ
041346 96 
041347 0B 
041348 04 
041349 FD      3609 INC     IY              ;SKIP "THEN"
04134A 23 
04134B CD      3610 IF1:			CALL    NXT
04134C 70 
04134D 0A 
04134E 04 
04134F FE      3611 CP      LINO_EX
041350 8D 
041351 C2      3612 JP      NZ,XEQ          ;STATEMENT FOLLOWS
041352 96 
041353 0B 
041354 04 
041355 C3      3613 JP      GOTO_EX            ;LINE NO. FOLLOWS
041356 2B 
041357 0F 
041358 04 
041359 FD      3614 IFNOT:			LD      A,(IY)
04135A 7E 
04135B 00 
04135C FE      3615 CP      CR
04135D 0D 
04135E FD      3616 INC     IY
04135F 23 
041360 CA      3617 JP      Z,XEQ0          ;END OF LINE
041361 92 
041362 0B 
041363 04 
041364 FE      3618 CP      ELSE_EX_
041365 8B 
041366 20      3619 JR      NZ,IFNOT
041367 F1 
041368 18      3620 JR      IF1
041369 E1 
               3621 
               3622 ; CLS
               3623 ;
04136A CD      3624 CLS:		CALL    CLRSCN
04136B CC 
04136C 43 
04136D 04 
04136E AF      3625 XOR     A
04136F 32      3626 LD      (COUNT),A
041370 3D 
041371 4D 
041372 04 
041373 C3      3627 JP      XEQ
041374 96 
041375 0B 
041376 04 
               3628 
               3629 ; STOP
               3630 ;
041377 CD      3631 STOP:			CALL    TELL
041378 90 
041379 3D 
04137A 04 
04137B 0D      3632 DB	CR
04137C 0A      3633 DB	LF
04137D FA      3634 DB	TSTOP
04137E 00      3635 DB	0
04137F CD      3636 CALL    SETLIN          ;FIND CURRENT LINE
041380 AE 
041381 39 
041382 04 
041383 CD      3637 CALL    SAYLN
041384 E2 
041385 39 
041386 04 
041387 CD      3638 CALL    CRLF
041388 47 
041389 39 
04138A 04 
04138B C3      3639 JP      CLOOP
04138C 80 
04138D 30 
04138E 04 
               3640 
               3641 ; REPORT
               3642 ;
04138F CD      3643 REPOR:			CALL    REPORT
041390 82 
041391 3D 
041392 04 
041393 C3      3644 JP      XEQ
041394 96 
041395 0B 
041396 04 
               3645 
               3646 ; CLEAR
               3647 ;
041397 CD      3648 CLR:			CALL    CLEAR
041398 76 
041399 38 
04139A 04 
04139B 2A      3649 LD      HL,(PAGE_)
04139C 14 
04139D 4D 
04139E 04 
04139F 18      3650 JR      RESTR1
0413A0 19 
               3651 
               3652 ; RESTORE [line]
               3653 ;
0413A1 2A      3654 RESTOR_EX:			LD      HL,(PAGE_)
0413A2 14 
0413A3 4D 
0413A4 04 
0413A5 CD      3655 CALL    TERMQ
0413A6 7A 
0413A7 17 
0413A8 04 
0413A9 28      3656 JR      Z,RESTR1
0413AA 0F 
0413AB CD      3657 CALL    ITEMI
0413AC 25 
0413AD 03 
0413AE 04 
0413AF D9      3658 EXX
0413B0 CD      3659 CALL    FINDL           ;SEARCH FOR LINE
0413B1 8F 
0413B2 39 
0413B3 04 
0413B4 3E      3660 LD      A,41
0413B5 29 
0413B6 C2      3661 JP      NZ,ERROR4       ;"No such line"
0413B7 32 
0413B8 13 
0413B9 04 
0413BA 3E      3662 RESTR1:			LD      A,DATA_EX_
0413BB DC 
0413BC CD      3663 CALL    SEARCH_EX
0413BD 4E 
0413BE 18 
0413BF 04 
0413C0 22      3664 LD      (DATPTR),HL
0413C1 31 
0413C2 4D 
0413C3 04 
0413C4 C3      3665 JP      XEQ
0413C5 96 
0413C6 0B 
0413C7 04 
               3666 
               3667 ; PTR#channel=expr
               3668 ; PAGE=expr
               3669 ; TIME=expr
               3670 ; LOMEM=expr
               3671 ; HIMEM=expr
               3672 ;
0413C8 CD      3673 PTR_EX:			CALL    CHANEL
0413C9 86 
0413CA 18 
0413CB 04 
0413CC CD      3674 CALL    EQUALS
0413CD 90 
0413CE 17 
0413CF 04 
0413D0 7B      3675 LD      A,E
0413D1 F5      3676 PUSH    AF
0413D2 CD      3677 CALL    EXPRI
0413D3 0A 
0413D4 03 
0413D5 04 
0413D6 E5      3678 PUSH    HL
0413D7 D9      3679 EXX
0413D8 D1      3680 POP     DE
0413D9 F1      3681 POP     AF
0413DA CD      3682 CALL    PUTPTR
0413DB 67 
0413DC 43 
0413DD 04 
0413DE C3      3683 JP      XEQ
0413DF 96 
0413E0 0B 
0413E1 04 
               3684 ;
0413E2 CD      3685 PAGEV_EX:			CALL    EQUALS
0413E3 90 
0413E4 17 
0413E5 04 
0413E6 CD      3686 CALL    EXPRI
0413E7 0A 
0413E8 03 
0413E9 04 
0413EA D9      3687 EXX
0413EB 2E      3688 LD      L,0
0413EC 00 
0413ED 22      3689 LD      (PAGE_),HL
0413EE 14 
0413EF 4D 
0413F0 04 
0413F1 C3      3690 JP      XEQ
0413F2 96 
0413F3 0B 
0413F4 04 
               3691 ;
0413F5 FE      3692 TIMEV_EX:			CP      '$'
0413F6 24 
0413F7 28      3693 JR      Z,TIMEVS_EX
0413F8 13 
0413F9 CD      3694 CALL    EQUALS
0413FA 90 
0413FB 17 
0413FC 04 
0413FD CD      3695 CALL    EXPRI
0413FE 0A 
0413FF 03 
041400 04 
041401 E5      3696 PUSH    HL
041402 D9      3697 EXX
041403 D1      3698 POP     DE
041404 CD      3699 CALL    PUTIME
041405 97 
041406 3E 
041407 04 
041408 C3      3700 JP      XEQ
041409 96 
04140A 0B 
04140B 04 
               3701 ;
04140C FD      3702 TIMEVS_EX:			INC     IY              ;SKIP '$'
04140D 23 
04140E CD      3703 CALL    EQUALS
04140F 90 
041410 17 
041411 04 
041412 CD      3704 CALL    EXPRS
041413 15 
041414 03 
041415 04 
041416 CD      3705 CALL    PUTIMS
041417 B7 
041418 43 
041419 04 
04141A C3      3706 JP      XEQ
04141B 96 
04141C 0B 
04141D 04 
               3707 ;
04141E CD      3708 LOMEMV_EX:			CALL    EQUALS
04141F 90 
041420 17 
041421 04 
041422 CD      3709 CALL    EXPRI
041423 0A 
041424 03 
041425 04 
041426 CD      3710 CALL    CLEAR
041427 76 
041428 38 
041429 04 
04142A D9      3711 EXX
04142B 22      3712 LD      (LOMEM),HL
04142C 1A 
04142D 4D 
04142E 04 
04142F 22      3713 LD      (FREE),HL
041430 1D 
041431 4D 
041432 04 
041433 C3      3714 JP      XEQ
041434 96 
041435 0B 
041436 04 
               3715 ;
041437 CD      3716 HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041438 90 
041439 17 
04143A 04 
04143B CD      3717 CALL    EXPRI			; Load the expression into registers
04143C 0A 
04143D 03 
04143E 04 
               3718 ; BEGIN MISSING FROM BINARY
               3719 ; LD	A,L			;  A: The MSB of the 24-bit value
               3720 ; EXX				; HL: The LSW of the 24-bit value
               3721 ; LD	(R0),HL
               3722 ; LD	(R0+2),A
               3723 ; LD	HL,(FREE)
               3724 ; LD      DE,256
               3725 ; ADD	HL,DE
               3726 ; EX	DE,HL			; DE: FREE + 256
               3727 ; LD	HL,(R0)			; HL: The passed expression
               3728 ; END MISSING FROM BINARY
               3729 ; BEGIN ADDED FROM BINARY
04143F D9      3730 exx
041440 ED      3731 ld de,(FREE)
041441 5B 
041442 1D 
041443 4D 
041443 04   
041445 14      3732 inc d
               3733 ; END ADDED FROM BINARY
041446 AF      3734 XOR     A
041447 ED      3735 SBC     HL,DE
041448 52 
041449 19      3736 ADD     HL,DE			; Do a bounds check
04144A DA      3737 JP      C,ERROR_         	; Throw the error: "No room"
04144B 60 
04144C 37 
04144D 04 
04144E ED      3738 LD      DE,(HIMEM)
04144F 5B 
041450 20 
041451 4D 
041451 04   
041453 22      3739 LD      (HIMEM),HL
041454 20 
041455 4D 
041456 04 
041457 EB      3740 EX      DE,HL
041458 ED      3741 SBC     HL,SP			; Adjust the stack
041459 72 
04145A C2      3742 JP      NZ,XEQ
04145B 96 
04145C 0B 
04145D 04 
04145E EB      3743 EX      DE,HL
04145F F9      3744 LD      SP,HL           	; Load the SP
041460 C3      3745 JP      XEQ
041461 96 
041462 0B 
041463 04 
               3746 
               3747 ; WIDTH expr
               3748 ;
041464 CD      3749 WIDTHV:			CALL    EXPRI
041465 0A 
041466 03 
041467 04 
041468 D9      3750 EXX
041469 7D      3751 LD      A,L
04146A 32      3752 LD      (WIDTH),A
04146B 3E 
04146C 4D 
04146D 04 
04146E C3      3753 JP      XEQ
04146F 96 
041470 0B 
041471 04 
               3754 
               3755 ; TRACE ON
               3756 ; TRACE OFF
               3757 ; TRACE line
               3758 ;
041472 FD      3759 TRACE_EX:			INC     IY
041473 23 
041474 21      3760 LD      HL,0
041475 00 
041476 00 
041477 00 
041478 FE      3761 CP      TON
041479 EE 
04147A 28      3762 JR      Z,TRACE0
04147B 0B 
04147C FE      3763 CP      OFF_
04147D 87 
04147E 28      3764 JR      Z,TRACE1
04147F 08 
041480 FD      3765 DEC     IY
041481 2B 
041482 CD      3766 CALL    EXPRI
041483 0A 
041484 03 
041485 04 
041486 D9      3767 EXX
041487 2B      3768 TRACE0:			DEC     HL
041488 22      3769 TRACE1:			LD      (TRACEN),HL
041489 26 
04148A 4D 
04148B 04 
04148C C3      3770 JP      XEQ
04148D 96 
04148E 0B 
04148F 04 
               3771 
               3772 ; VDU expr,expr;....
               3773 ;
               3774 ; BEGIN MISSING FROM BINARY
               3775 ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
               3776 ; VDU1:			PUSH	IX
               3777 ; 			CALL    EXPRI			; Fetch the VDU character
               3778 ; 			POP	IX
               3779 ; 			EXX
               3780 ; 			LD	(IX+0),L		; Write out the character to the buffer
               3781 ; 			INC	IX
               3782 ; 			LD      A,(IY)			;  A: The separator character
               3783 ; 			CP      ','			; Is it a comma?
               3784 ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
               3785 ; 			CP      ';'			; Is it a semicolon?
               3786 ; 			JR      NZ,VDU3			; No, so skip to the next expression
               3787 ; 			LD	(IX+0),H		; Write out the high byte to the buffer
               3788 ; 			INC	IX
               3789 ; VDU2:			INC     IY			; Skip to the next character
               3790 ; VDU3:			CALL    TERMQ			; Skip past white space
               3791 ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
               3792 ; 			LD	A,IXL			;  A: Number of bytes to write out
               3793 ; 			OR	A
               3794 ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
               3795 ; 			LD	HL,BUFFER		; HL: Start of stream
               3796 ; 			LD	BC,0
               3797 ; 			LD	C,A			; BC: Number of bytes to write out
               3798 ; 			RST.LIL	18h			; Output the buffer to MOS
               3799 ; END MISSING FROM BINARY
               3800 ; BEGIN ADDED FROM BINARY
               3801 VDU:
041490 CD      3802 call EXPRI
041491 0A 
041492 03 
041493 04 
041494 D9      3803 exx
041495 7D      3804 ld a,l
041496 CD      3805 call OSWRCH
041497 00 
041498 3F 
041499 04 
04149A FD      3806 ld a,(iy)
04149B 7E 
04149C 00 
04149D FE      3807 cp $2c
04149E 2C 
04149F 28      3808 jr z,$+$0b
0414A0 09 
0414A1 FE      3809 cp $3b
0414A2 3B 
0414A3 20      3810 jr nz,$+$09
0414A4 07 
0414A5 7C      3811 ld a,h
0414A6 CD      3812 call OSWRCH
0414A7 00 
0414A8 3F 
0414A9 04 
0414AA FD      3813 inc iy
0414AB 23 
0414AC CD      3814 call TERMQ
0414AD 7A 
0414AE 17 
0414AF 04 
0414B0 20      3815 jr nz,$-$20
0414B1 DE 
               3816 ; END ADDED FROM BINARY
0414B2 C3      3817 VDU4:			JP      XEQ
0414B3 96 
0414B4 0B 
0414B5 04 
               3818 
               3819 ; CLOSE channel number
               3820 ;
0414B6 CD      3821 CLOSE:			CALL    CHANEL			; Fetch the channel number
0414B7 86 
0414B8 18 
0414B9 04 
0414BA CD      3822 CALL    OSSHUT			; Close the channel
0414BB 2B 
0414BC 43 
0414BD 04 
0414BE C3      3823 JP      XEQ
0414BF 96 
0414C0 0B 
0414C1 04 
               3824 
               3825 ; BPUT channel,byte
               3826 ;
0414C2 CD      3827 BPUT:			CALL    CHANEL          	; Fetch the channel number
0414C3 86 
0414C4 18 
0414C5 04 
0414C6 D5      3828 PUSH    DE			; DE: Channel number
0414C7 CD      3829 CALL    COMMA			; Skip to the next expression
0414C8 22 
0414C9 0A 
0414CA 04 
0414CB CD      3830 CALL    EXPRI           	; Feth the data
0414CC 0A 
0414CD 03 
0414CE 04 
0414CF D9      3831 EXX
0414D0 7D      3832 LD      A,L			; A: The byte to write
0414D1 D1      3833 POP     DE
0414D2 CD      3834 CALL    OSBPUT			; Write the byte out
0414D3 3B 
0414D4 43 
0414D5 04 
0414D6 C3      3835 JP      XEQ
0414D7 96 
0414D8 0B 
0414D9 04 
               3836 
               3837 ; CALL address[,var[,var...]]
               3838 ;
               3839 ; Note that the parameter table differs from the Z80 version
               3840 ; Each entry now takes up 4 bytes, not 3, so the table is now:
               3841 ;  -1 byte:  Number of parameters
               3842 ; Then, for each parameter:
               3843 ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
               3844 ;  -3 bytes: Parameter address
               3845 ;
               3846 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
               3847 ;
0414DA CD      3848 CALL_:			CALL    EXPRI           	; Fetch the address
0414DB 0A 
0414DC 03 
0414DD 04 
0414DE 7D      3849 LD	A,L			;  A: MSB of address
0414DF D9      3850 EXX
0414E0 22      3851 LD	(R0+0),HL		; HL: LSW of address
0414E1 4A 
0414E2 4D 
0414E3 04 
0414E4 32      3852 LD	(R0+2),A
0414E5 4C 
0414E6 4D 
0414E7 04 
0414E8 06      3853 LD      B,0             	;  B: The parameter counter
0414E9 00 
0414EA 11      3854 LD      DE,BUFFER       	; DE: Vector
0414EB 00 
0414EC 4B 
0414ED 04 
               3855 ;
0414EE CD      3856 CALL1:			CALL    NXT			; Skip whitespace
0414EF 70 
0414F0 0A 
0414F1 04 
0414F2 FE      3857 CP      ','			; Check for comma
0414F3 2C 
0414F4 20      3858 JR      NZ,CALL2		; If no more parameters, then jump here
0414F5 1B 
0414F6 FD      3859 INC     IY			; Skip to the next character
0414F7 23 
0414F8 04      3860 INC     B			; Increment the parameter count
0414F9 CD      3861 CALL    NXT			; Skip whitespace
0414FA 70 
0414FB 0A 
0414FC 04 
0414FD C5      3862 PUSH    BC
0414FE D5      3863 PUSH    DE
0414FF CD      3864 CALL    VAR_
041500 8E 
041501 0C 
041502 04 
041503 D1      3865 POP     DE
041504 C1      3866 POP     BC
041505 13      3867 INC     DE
041506 12      3868 LD      (DE),A			; Save the parameter type
041507 13      3869 INC     DE
041508 EB      3870 EX      DE,HL
041509 ED      3871 LD	(HL),DE			; Save the parameter address (3 bytes)
04150A 1F 
04150B 23      3872 INC	HL
04150C 23      3873 INC	HL
04150D 23      3874 INC	HL
04150E EB      3875 EX      DE,HL
04150F 18      3876 JR      CALL1
041510 DD 
               3877 ;
041511 78      3878 CALL2:			LD      A,B
041512 32      3879 LD      (BUFFER),A      	; Save the parameter count
041513 00 
041514 4B 
041515 04 
041516 2A      3880 LD	HL,(R0)			; HL: Address of the code
041517 4A 
041518 4D 
041519 04 
04151A CD      3881 CALL    USR1			; And call it
04151B 34 
04151C 15 
04151D 04 
04151E C3      3882 JP      XEQ
04151F 96 
041520 0B 
041521 04 
               3883 
               3884 ; USR(address)
               3885 ;
041522 CD      3886 USR:			CALL    ITEMI			; Evaluate the expression
041523 25 
041524 03 
041525 04 
041526 7D      3887 LD	A,L			;  A: MSB of address
041527 D9      3888 EXX
041528 22      3889 LD	(R0+0),HL		; HL: LSW of address
041529 4A 
04152A 4D 
04152B 04 
04152C 32      3890 LD	(R0+2),A
04152D 4C 
04152E 4D 
04152F 04 
041530 2A      3891 LD	HL,(R0)			; Get the 24-bit address in HL
041531 4A 
041532 4D 
041533 04 
               3892 ;
041534 E5      3893 USR1:			PUSH    HL              	; Address on stack
041535 FD      3894 EX      (SP),IY
041536 E3 
041537 24      3895 INC     H               	; Check for PAGE &00FFxx
041538 B4      3896 OR	H
041539 21      3897 LD      HL,USR2         	; Return address
04153A A3 
04153B 15 
04153C 04 
04153D E5      3898 PUSH    HL
04153E DD      3899 LD      IX,STAVAR
04153F 21 
041540 00 
041541 4C 
041541 04   
041543 CC      3900 CALL    Z,OSCALL        	; Intercept &00FFxx
041544 F1 
041545 42 
041546 04 
               3901 ;
041547 DD      3902 LD      C, (IX+24)		; F%
041548 4E 
041549 18 
04154A C5      3903 PUSH    BC
               3904 ;
04154B DD      3905 LD	A, (IX+8)		; B% -> MSW
04154C 7E 
04154D 08 
04154E 32      3906 LD	(R0+1), A
04154F 4B 
041550 4D 
041551 04 
041552 DD      3907 LD	A, (IX+9)
041553 7E 
041554 09 
041555 32      3908 LD	(R0+2), A
041556 4C 
041557 4D 
041558 04 
041559 DD      3909 LD	A, (IX+12)		; C% -> LSB
04155A 7E 
04155B 0C 
04155C 32      3910 LD	(R0+0), A
04155D 4A 
04155E 4D 
04155F 04 
041560 ED      3911 LD	BC, (R0)
041561 4B 
041562 4A 
041563 4D 
041563 04   
               3912 ;
041565 DD      3913 LD	A, (IX+16)		; D% -> MSW
041566 7E 
041567 10 
041568 32      3914 LD	(R0+1), A
041569 4B 
04156A 4D 
04156B 04 
04156C DD      3915 LD	A, (IX+17)
04156D 7E 
04156E 11 
04156F 32      3916 LD	(R0+2), A
041570 4C 
041571 4D 
041572 04 
041573 DD      3917 LD	A, (IX+20)		; E% -> LSB
041574 7E 
041575 14 
041576 32      3918 LD	(R0+0), A
041577 4A 
041578 4D 
041579 04 
04157A ED      3919 LD	DE, (R0)
04157B 5B 
04157C 4A 
04157D 4D 
04157D 04   
               3920 ;
04157F DD      3921 LD	A, (IX+32)		; H% -> MSW
041580 7E 
041581 20 
041582 32      3922 LD	(R0+1), A
041583 4B 
041584 4D 
041585 04 
041586 DD      3923 LD	A, (IX+33)
041587 7E 
041588 21 
041589 32      3924 LD	(R0+2), A
04158A 4C 
04158B 4D 
04158C 04 
04158D DD      3925 LD	A, (IX+48)		; L% -> LSB
04158E 7E 
04158F 30 
041590 32      3926 LD	(R0+0), A
041591 4A 
041592 4D 
041593 04 
041594 2A      3927 LD	HL, (R0)
041595 4A 
041596 4D 
041597 04 
               3928 ;
041598 F1      3929 POP     AF			; F%
041599 DD      3930 LD      A, (IX+4)        	; A%
04159A 7E 
04159B 04 
               3931 
04159C DD      3932 LD      IX,BUFFER
04159D 21 
04159E 00 
04159F 4B 
04159F 04   
0415A1 FD      3933 JP      (IY)            	; Off to user routine
0415A2 E9 
               3934 ;
0415A3 FD      3935 USR2:			POP     IY
0415A4 E1 
0415A5 AF      3936 XOR     A
0415A6 4F      3937 LD      C,A
0415A7 C9      3938 RET
               3939 
               3940 ; PUT port,data
               3941 ;
0415A8 CD      3942 PUT:			CALL    EXPRI           ;PORT ADDRESS
0415A9 0A 
0415AA 03 
0415AB 04 
0415AC D9      3943 EXX
0415AD E5      3944 PUSH    HL
0415AE CD      3945 CALL    COMMA
0415AF 22 
0415B0 0A 
0415B1 04 
0415B2 CD      3946 CALL    EXPRI           ;DATA
0415B3 0A 
0415B4 03 
0415B5 04 
0415B6 D9      3947 EXX
0415B7 C1      3948 POP     BC
0415B8 ED      3949 OUT     (C),L           ;OUTPUT TO PORT BC
0415B9 69 
0415BA C3      3950 JP      XEQ
0415BB 96 
0415BC 0B 
0415BD 04 
               3951 
               3952 ; SUBROUTINES -----------------------------------------------------------------
               3953 
               3954 ; ASSIGN - Assign a numeric value to a variable.
               3955 ; Outputs: NC,  Z - OK, numeric.
               3956 ;          NC, NZ - OK, string.
               3957 ;           C, NZ - illegal
               3958 ;
0415BE CD      3959 ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415BF 3A 
0415C0 3A 
0415C1 04 
0415C2 D8      3960 RET     C               	; Return with C if it is an illegal variable
0415C3 C4      3961 CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415C4 29 
0415C5 3A 
0415C6 04 
0415C7 B7      3962 OR      A
0415C8 F8      3963 RET     M               	; Return if type is string (81h)
0415C9 F5      3964 PUSH    AF              	; It's a numeric type from this point on
0415CA CD      3965 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415CB 90 
0415CC 17 
0415CD 04 
0415CE E5      3966 PUSH    HL
0415CF CD      3967 CALL    EXPRN
0415D0 02 
0415D1 03 
0415D2 04 
0415D3 DD      3968 POP     IX
0415D4 E1 
0415D5 F1      3969 POP     AF
0415D6 CB      3970 STORE:			BIT     0,A
0415D7 47 
0415D8 28      3971 JR      Z,STOREI
0415D9 13 
0415DA BF      3972 CP      A               	; Set the variable to 0
0415DB DD      3973 STORE5:			LD      (IX+4),C
0415DC 71 
0415DD 04 
0415DE D9      3974 STORE4:			EXX
0415DF DD      3975 LD      (IX+0),L
0415E0 75 
0415E1 00 
0415E2 DD      3976 LD      (IX+1),H
0415E3 74 
0415E4 01 
0415E5 D9      3977 EXX
0415E6 DD      3978 LD      (IX+2),L
0415E7 75 
0415E8 02 
0415E9 DD      3979 LD      (IX+3),H
0415EA 74 
0415EB 03 
0415EC C9      3980 RET
0415ED F5      3981 STOREI:			PUSH    AF
0415EE 0C      3982 INC     C               ;SPEED - & PRESERVE F'
0415EF 0D      3983 DEC     C               ; WHEN CALLED BY FNEND0
0415F0 C4      3984 CALL    NZ,SFIX         ;CONVERT TO INTEGER
0415F1 62 
0415F2 06 
0415F3 04 
0415F4 F1      3985 POP     AF
0415F5 FE      3986 CP      4
0415F6 04 
0415F7 28      3987 JR      Z,STORE4
0415F8 E5 
0415F9 BF      3988 CP      A               ;SET ZERO
0415FA D9      3989 STORE1:			EXX
0415FB DD      3990 LD      (IX+0),L
0415FC 75 
0415FD 00 
0415FE D9      3991 EXX
0415FF C9      3992 RET
               3993 ;
               3994 ; Copy a string from the string accumulator to variable storage on the stack
               3995 ; Parameters:
               3996 ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
               3997 ; - IX: Address of the variable storage on the stack
               3998 ;
041600 21      3999 STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041601 00 
041602 4A 
041603 04 
               4000 ;
               4001 ; Parameters:
               4002 ; As above, but:
               4003 ; - HL: Address of the string to be stored
               4004 ; -  E: The string length
               4005 ; NB:
               4006 ; Strings are mutable
               4007 ; Strings are stored in the following format in the variable:
               4008 ; - Address of the next variable (3 bytes)
               4009 ; - The rest of the variable name - this is zero terminated
               4010 ; - Current string length (byte)
               4011 ; - Maximum (original) string length (byte)
               4012 ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
               4013 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
               4014 ;
041604 1F      4015 STORES:			RRA				; Rotate right to shift bit 0 into carry
041605 30      4016 JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041606 5D 
041607 E5      4017 PUSH    HL			; Stack ACCS
               4018 ;
               4019 ; Load the string pointer and lengths into registers - these are all zeroed for new strings
               4020 ;
041608 D9      4021 EXX				; This block was a call to LOAD4
041609 DD      4022 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04160A 6E 
04160B 00 
04160C DD      4023 LD      H,(IX+1)		; The maximum original string length
04160D 66 
04160E 01 
04160F D9      4024 EXX
041610 DD      4025 LD	HL,(IX+2)		; Address of the string (24-bit)
041611 27 
041612 02 
               4026 ;
041613 7B      4027 LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041614 D9      4028 EXX
041615 6F      4029 LD      L,A			; L': Length of string currently stored on the stack
041616 7C      4030 LD      A,H             	; H': The maximum (original) string length
041617 D9      4031 EXX
041618 BB      4032 CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041619 30      4033 JR      NC,STORS1       	; Yes there is, so skip the next bit
04161A 17 
               4034 ;
               4035 ; At this point we're either initialising a new string or assigning more memory to an existing string
               4036 ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
               4037 ; then the existing and new strings may both exist in memory.
               4038 ;
04161B D9      4039 EXX
04161C 65      4040 LD      H,L			; H: Set the maximum string length to the string length
04161D D9      4041 EXX
04161E E5      4042 PUSH    HL
04161F 01      4043 LD	BC, 0
041620 00 
041621 00 
041622 00 
041623 4F      4044 LD      C,A			; BC: The maximum (original) string length
041624 09      4045 ADD     HL,BC			; Work out whether this is the last string in memory
041625 ED      4046 LD      BC,(FREE)
041626 4B 
041627 1D 
041628 4D 
041628 04   
04162A ED      4047 SBC     HL,BC			; Is string last?
04162B 42 
04162C E1      4048 POP     HL
04162D 37      4049 SCF
04162E 28      4050 JR      Z,STORS1
04162F 02 
               4051 ; LD	HL, BC			; HL=BC
041630 C5      4052 push bc
041631 E1      4053 pop hl
               4054 ;
               4055 ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
               4056 ; - H': The maximum (original) string length
               4057 ; - L': The actual string length (must be less than H')
               4058 ; - HL: Address of the string in memory
               4059 ;
041632 D9      4060 STORS1:			EXX				; This block was a call to STORE4
041633 DD      4061 LD      (IX+0),L		; The actual string length (must be less then H')
041634 75 
041635 00 
041636 DD      4062 LD      (IX+1),H		; The maximum (original) string length
041637 74 
041638 01 
041639 D9      4063 EXX
04163A DD      4064 LD	(IX+2),HL		; The pointer to the original string
04163B 2F 
04163C 02 
               4065 ;
04163D 01      4066 LD	BC, 0
04163E 00 
04163F 00 
041640 00 
041641 4B      4067 LD      C,E			; BC: The new string length
041642 EB      4068 EX      DE,HL
041643 E1      4069 POP     HL
041644 0D      4070 DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041645 0C      4071 INC     C			; check whether BC is 0 without affecting the carry flag
041646 C8      4072 RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041647 ED      4073 LDIR				; Replace the string in memory
041648 B0 
041649 D0      4074 RET     NC
04164A ED      4075 LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
04164B 53 
04164C 1D 
04164D 4D 
04164D 04   
               4076 ;
               4077 ; Check whether the stack is full
               4078 ;
04164F E5      4079 CHECK:			PUSH    HL
041650 C5      4080 PUSH	BC
041651 2A      4081 LD      HL,(FREE)		; HL: Address of first free space byte
041652 1D 
041653 4D 
041654 04 
041655 01      4082 LD	BC,100h			; BC: One page of memory
041656 00 
041657 01 
041658 00 
041659 09      4083 ADD	HL,BC			; Add a page to FREE
04165A ED      4084 SBC     HL,SP			; And subtract the current SP
04165B 72 
04165C C1      4085 POP	BC
04165D E1      4086 POP     HL
04165E D8      4087 RET     C			; The SP is not in the same page, so just return
04165F AF      4088 XOR     A			; Otherwise
041660 C3      4089 JP      ERROR_			; Throw error "No room"
041661 60 
041662 37 
041663 04 
               4090 ;
041664 01      4091 STORS3:			LD	BC,0
041665 00 
041666 00 
041667 00 
041668 4B      4092 LD      C,E			; BC: String length
041669 DD      4093 PUSH    IX
04166A E5 
04166B D1      4094 POP     DE			; DE: Destination
04166C AF      4095 XOR     A			; Check if string length is 0
04166D B9      4096 CP      C
04166E 28      4097 JR      Z,STORS5		; Yes, so don't copy
04166F 02 
041670 ED      4098 LDIR
041671 B0 
041672 3E      4099 STORS5:			LD      A,CR			; Finally add the terminator
041673 0D 
041674 12      4100 LD      (DE),A
041675 C9      4101 RET
               4102 
               4103 ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
               4104 ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
               4105 ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
               4106 ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
               4107 ;    Inputs: DE addresses parameter list
               4108 ;            IY addresses dummy variable list
               4109 ;   Outputs: DE,IY updated
               4110 ;  Destroys: Everything
               4111 ;
041676 3E      4112 ARGUE:			LD      A,-1
041677 FF 
041678 F5      4113 PUSH    AF              	; Put marker on the stack
041679 FD      4114 ARGUE1:			INC     IY              	; Bump past '(' or ',''
04167A 23 
04167B 13      4115 INC     DE
04167C D5      4116 PUSH    DE
04167D CD      4117 CALL    NXT			; Skip any whitespace
04167E 70 
04167F 0A 
041680 04 
041681 CD      4118 CALL    GETVAR			; Get the location of the variable in HL/IX
041682 3A 
041683 3A 
041684 04 
041685 38      4119 JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
041686 3F 
041687 C4      4120 CALL    NZ,PUTVAR
041688 29 
041689 3A 
04168A 04 
04168B D1      4121 POP     DE
04168C E5      4122 PUSH    HL              	; VARPTR
04168D B7      4123 OR      A               	; Check the variable type
04168E F5      4124 PUSH    AF
04168F D5      4125 PUSH    DE
041690 FD      4126 EX      (SP),IY
041691 E3 
041692 FA      4127 JP      M,ARGUE2        	; Jump here if it is a string
041693 AA 
041694 16 
041695 04 
               4128 ;
041696 CD      4129 CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
041697 02 
041698 03 
041699 04 
04169A FD      4130 EX      (SP),IY
04169B E3 
04169C D1      4131 POP     DE
04169D F1      4132 POP     AF
04169E D9      4133 EXX
04169F E5      4134 PUSH    HL
0416A0 D9      4135 EXX
0416A1 E5      4136 PUSH    HL
0416A2 47      4137 LD      B,A
0416A3 C5      4138 PUSH    BC
0416A4 CD      4139 CALL    CHECK           	; Check room
0416A5 4F 
0416A6 16 
0416A7 04 
0416A8 18      4140 JR      ARGUE4
0416A9 0F 
               4141 ;
0416AA CD      4142 ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416AB 15 
0416AC 03 
0416AD 04 
0416AE FD      4143 EX      (SP),IY
0416AF E3 
0416B0 D9      4144 EXX
0416B1 D1      4145 POP     DE
0416B2 D9      4146 EXX
0416B3 F1      4147 POP     AF
0416B4 CD      4148 CALL    PUSHS
0416B5 B4 
0416B6 09 
0416B7 04 
0416B8 D9      4149 EXX
               4150 ;
0416B9 CD      4151 ARGUE4:			CALL    NXT			; Skip whitespace
0416BA 70 
0416BB 0A 
0416BC 04 
0416BD FE      4152 CP      ','			; Check to see if the next value is a comma
0416BE 2C 
0416BF 20      4153 JR      NZ,ARGUE5		; No, so jump here
0416C0 0B 
0416C1 1A      4154 LD      A,(DE)
0416C2 FE      4155 CP      ','			; Are there any more arguments?
0416C3 2C 
0416C4 28      4156 JR      Z,ARGUE1        	; Yes, so loop
0416C5 B3 
               4157 ;
0416C6 3E      4158 ARGERR:			LD      A,31
0416C7 1F 
0416C8 C3      4159 JP      ERROR_           	; Throw error "Arguments"
0416C9 60 
0416CA 37 
0416CB 04 
               4160 ;
0416CC CD      4161 ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416CD 2F 
0416CE 0A 
0416CF 04 
0416D0 1A      4162 LD      A,(DE)
0416D1 FE      4163 CP      ')'
0416D2 29 
0416D3 20      4164 JR      NZ,ARGERR
0416D4 F1 
0416D5 13      4165 INC     DE
0416D6 D9      4166 EXX
0416D7 C1      4167 ARGUE6:			POP     BC
0416D8 78      4168 LD      A,B
0416D9 3C      4169 INC     A
0416DA D9      4170 EXX
0416DB C8      4171 RET     Z               	; Marker popped
0416DC D9      4172 EXX
0416DD 3D      4173 DEC     A
0416DE FA      4174 JP      M,ARGUE7        	; If it is a string, then jump here
0416DF EE 
0416E0 16 
0416E1 04 
0416E2 E1      4175 POP     HL
0416E3 D9      4176 EXX
0416E4 E1      4177 POP     HL
0416E5 D9      4178 EXX
0416E6 DD      4179 POP     IX
0416E7 E1 
0416E8 CD      4180 CALL    STORE	           	; Write to dummy variable
0416E9 D6 
0416EA 15 
0416EB 04 
0416EC 18      4181 JR      ARGUE6
0416ED E9 
               4182 ;
0416EE CD      4183 ARGUE7:			CALL    POPS
0416EF DE 
0416F0 09 
0416F1 04 
0416F2 DD      4184 POP     IX
0416F3 E1 
0416F4 CD      4185 CALL    STACCS
0416F5 00 
0416F6 16 
0416F7 04 
0416F8 18      4186 JR      ARGUE6
0416F9 DD 
               4187 
               4188 ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
               4189 ;   OF A FUNCTION OR PROCEDURE.
               4190 ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
               4191 ;    Inputs: IY is parameters pointer
               4192 ;   Outputs: IY updated
               4193 ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
               4194 ;
0416FA D1      4195 SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
               4196 ;
0416FB FD      4197 SAVLO1:			INC     IY              	; Bump past '(' or ','
0416FC 23 
0416FD CD      4198 CALL    NXT			; And also any whitespace
0416FE 70 
0416FF 0A 
041700 04 
041701 D5      4199 PUSH    DE			; Push the return address back onto the stack
041702 D9      4200 EXX
041703 C5      4201 PUSH    BC
041704 D5      4202 PUSH    DE
041705 E5      4203 PUSH    HL
041706 D9      4204 EXX
041707 CD      4205 CALL    VAR_             	; Dummy variable
041708 8E 
041709 0C 
04170A 04 
04170B D9      4206 EXX
04170C E1      4207 POP     HL
04170D D1      4208 POP     DE
04170E C1      4209 POP     BC
04170F D9      4210 EXX
041710 D1      4211 POP     DE
041711 B7      4212 OR      A               	; Check the variable type
041712 FA      4213 JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041713 25 
041714 17 
041715 04 
041716 D9      4214 EXX
041717 E5      4215 PUSH    HL              	; Save H'L'
041718 D9      4216 EXX
041719 47      4217 LD      B,A             	;  B: Variable type
04171A CD      4218 CALL    LOADN
04171B 16 
04171C 04 
04171D 04 
04171E D9      4219 EXX
04171F E3      4220 EX      (SP),HL
041720 D9      4221 EXX
041721 E5      4222 PUSH    HL
041722 C5      4223 PUSH    BC
041723 18      4224 JR      SAVLO4
041724 2D 
               4225 ;
041725 F5      4226 SAVLO2:			PUSH    AF              	; Save the type (string)
041726 D5      4227 PUSH    DE
041727 D9      4228 EXX
041728 E5      4229 PUSH    HL
041729 D9      4230 EXX
04172A CD      4231 CALL    LOADS
04172B A0 
04172C 04 
04172D 04 
04172E D9      4232 EXX
04172F E1      4233 POP     HL
041730 D9      4234 EXX
041731 01      4235 LD	BC,0
041732 00 
041733 00 
041734 00 
041735 4B      4236 LD      C,E			; BC: String length
041736 D1      4237 POP     DE
041737 CD      4238 CALL    CHECK			; Check if there is space on the stack
041738 4F 
041739 16 
04173A 04 
04173B F1      4239 POP     AF              	; Level stack
04173C 21      4240 LD      HL,0
04173D 00 
04173E 00 
04173F 00 
041740 ED      4241 SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041741 42 
041742 39      4242 ADD     HL,SP			; Make space for the string on the stack
041743 F9      4243 LD      SP,HL
041744 47      4244 LD      B,A             	;  B: Variable type
041745 C5      4245 PUSH    BC
041746 28      4246 JR      Z,SAVLO4
041747 0A 
041748 D5      4247 PUSH    DE
041749 11      4248 LD      DE,ACCS
04174A 00 
04174B 4A 
04174C 04 
04174D EB      4249 EX      DE,HL
04174E 45      4250 LD      B,L
04174F ED      4251 LDIR                    	; Save the string onto the stack
041750 B0 
041751 D1      4252 POP     DE
               4253 ;
041752 DD      4254 SAVLO4:			PUSH    IX			; VARPTR
041753 E5 
041754 CD      4255 CALL    SAVLO5
041755 58 
041756 17 
041757 04 
               4256 LOCCHK:			EQU     $
041758 CD      4257 SAVLO5:			CALL    CHECK
041759 4F 
04175A 16 
04175B 04 
04175C CD      4258 CALL    NXT
04175D 70 
04175E 0A 
04175F 04 
041760 FE      4259 CP      ','             	; Are there any more local variables?
041761 2C 
041762 28      4260 JR      Z,SAVLO1		; Yes, so loop
041763 97 
041764 EB      4261 EX      DE,HL			; DE -> HL: The return address
041765 E9      4262 JP      (HL)            	; And effectvely return
               4263 ;
041766 FD      4264 DELIM:			LD      A,(IY)          	; Assembler delimiter
041767 7E 
041768 00 
041769 FE      4265 CP      ' '
04176A 20 
04176B C8      4266 RET     Z
04176C FE      4267 CP      ','
04176D 2C 
04176E C8      4268 RET     Z
04176F FE      4269 CP      ')'
041770 29 
041771 C8      4270 RET     Z
041772 FE      4271 TERM:			CP      ';'             	; Assembler terminator
041773 3B 
041774 C8      4272 RET     Z
041775 FE      4273 CP      '\'
041776 5C 
041777 C8      4274 RET     Z
041778 18      4275 JR      TERM0
041779 07 
               4276 ;
04177A CD      4277 TERMQ:			CALL    NXT
04177B 70 
04177C 0A 
04177D 04 
04177E FE      4278 CP      ELSE_EX_
04177F 8B 
041780 D0      4279 RET     NC
041781 FE      4280 TERM0:			CP      ':'             	; Assembler seperator
041782 3A 
041783 D0      4281 RET     NC
041784 FE      4282 CP      CR
041785 0D 
041786 C9      4283 RET
               4284 ;
041787 CD      4285 SPAN:			CALL    TERMQ
041788 7A 
041789 17 
04178A 04 
04178B C8      4286 RET     Z
04178C FD      4287 INC     IY
04178D 23 
04178E 18      4288 JR      SPAN
04178F F7 
               4289 ;
               4290 ; This snippet is used to check whether an expression is followed by an '=' symbol
               4291 ;
041790 CD      4292 EQUALS:			CALL    NXT			; Skip whitespace
041791 70 
041792 0A 
041793 04 
041794 FD      4293 INC     IY			; Skip past the character in question
041795 23 
041796 FE      4294 CP      '='			; Is it '='
041797 3D 
041798 C8      4295 RET     Z			; Yes, so return
041799 3E      4296 LD      A,4			; Otherwise
04179A 04 
04179B C3      4297 JP      ERROR_           	; Throw error "Mistake"
04179C 60 
04179D 37 
04179E 04 
               4298 ;
04179F FE      4299 FORMAT:			CP      TAB
0417A0 8A 
0417A1 28      4300 JR      Z,DOTAB
0417A2 0D 
0417A3 FE      4301 CP      SPC
0417A4 89 
0417A5 28      4302 JR      Z,DOSPC
0417A6 40 
0417A7 FE      4303 CP      '''
0417A8 27 
0417A9 C0      4304 RET     NZ
0417AA CD      4305 CALL    CRLF
0417AB 47 
0417AC 39 
0417AD 04 
0417AE AF      4306 XOR     A
0417AF C9      4307 RET
               4308 ;
0417B0 C5      4309 DOTAB:			PUSH    BC
0417B1 CD      4310 CALL    EXPRI
0417B2 0A 
0417B3 03 
0417B4 04 
0417B5 D9      4311 EXX
0417B6 C1      4312 POP     BC
0417B7 FD      4313 LD      A,(IY)
0417B8 7E 
0417B9 00 
0417BA FE      4314 CP      ','
0417BB 2C 
0417BC 28      4315 JR      Z,DOTAB1
0417BD 14 
0417BE CD      4316 CALL    BRAKET
0417BF 2F 
0417C0 0A 
0417C1 04 
0417C2 7D      4317 LD      A,L
0417C3 21      4318 TABIT:			LD      HL,COUNT
0417C4 3D 
0417C5 4D 
0417C6 04 
0417C7 BE      4319 CP      (HL)
0417C8 C8      4320 RET     Z
0417C9 F5      4321 PUSH    AF
0417CA DC      4322 CALL    C,CRLF
0417CB 47 
0417CC 39 
0417CD 04 
0417CE F1      4323 POP     AF
0417CF 96      4324 SUB     (HL)
0417D0 18      4325 JR      FILL
0417D1 1D 
0417D2 FD      4326 DOTAB1:			INC     IY
0417D3 23 
0417D4 C5      4327 PUSH    BC
0417D5 E5      4328 PUSH    HL
0417D6 CD      4329 CALL    EXPRI
0417D7 0A 
0417D8 03 
0417D9 04 
0417DA D9      4330 EXX
0417DB D1      4331 POP     DE
0417DC C1      4332 POP     BC
0417DD CD      4333 CALL    BRAKET
0417DE 2F 
0417DF 0A 
0417E0 04 
0417E1 CD      4334 CALL    PUTCSR
0417E2 C1 
0417E3 3E 
0417E4 04 
0417E5 AF      4335 XOR     A
0417E6 C9      4336 RET
               4337 ;
0417E7 C5      4338 DOSPC:			PUSH    BC
0417E8 CD      4339 CALL    ITEMI
0417E9 25 
0417EA 03 
0417EB 04 
0417EC D9      4340 EXX
0417ED 7D      4341 LD      A,L
0417EE C1      4342 POP     BC
0417EF B7      4343 FILL:			OR      A
0417F0 C8      4344 RET     Z
0417F1 C5      4345 PUSH    BC
0417F2 47      4346 LD      B,A
0417F3 3E      4347 FILL1:			LD      A,' '
0417F4 20 
0417F5 CD      4348 CALL    OUTCHR
0417F6 4F 
0417F7 39 
0417F8 04 
0417F9 10      4349 DJNZ    FILL1
0417FA F8 
0417FB C1      4350 POP     BC
0417FC AF      4351 XOR     A
0417FD C9      4352 RET
               4353 ;
0417FE 21      4354 PTEXT:			LD      HL,ACCS
0417FF 00 
041800 4A 
041801 04 
041802 1C      4355 INC     E
041803 1D      4356 PTEXT1:			DEC     E
041804 C8      4357 RET     Z
041805 7E      4358 LD      A,(HL)
041806 23      4359 INC     HL
041807 CD      4360 CALL    OUTCHR
041808 4F 
041809 39 
04180A 04 
04180B 18      4361 JR      PTEXT1
04180C F6 
               4362 ;
04180D F5      4363 FETCHS:			PUSH    AF
04180E C5      4364 PUSH    BC
04180F E5      4365 PUSH    HL
041810 FD      4366 EX      (SP),IY
041811 E3 
041812 CD      4367 CALL    XTRACT
041813 2D 
041814 18 
041815 04 
041816 CD      4368 CALL    NXT
041817 70 
041818 0A 
041819 04 
04181A FD      4369 EX      (SP),IY
04181B E3 
04181C E1      4370 POP     HL
04181D C1      4371 POP     BC
04181E F1      4372 POP     AF
04181F C9      4373 RET
               4374 ;
041820 11      4375 LINES:			LD      DE,ACCS
041821 00 
041822 4A 
041823 04 
041824 7E      4376 LINE1S:			LD      A,(HL)
041825 12      4377 LD      (DE),A
041826 FE      4378 CP      CR
041827 0D 
041828 C8      4379 RET     Z
041829 23      4380 INC     HL
04182A 1C      4381 INC     E
04182B 18      4382 JR      LINE1S
04182C F7 
               4383 ;
04182D CD      4384 XTRACT:			CALL    NXT
04182E 70 
04182F 0A 
041830 04 
041831 FE      4385 CP      '"'
041832 22 
041833 FD      4386 INC     IY
041834 23 
041835 CA      4387 JP      Z,CONS
041836 67 
041837 04 
041838 04 
041839 FD      4388 DEC     IY
04183A 2B 
04183B 11      4389 LD      DE,ACCS
04183C 00 
04183D 4A 
04183E 04 
04183F FD      4390 XTRAC1:			LD      A,(IY)
041840 7E 
041841 00 
041842 12      4391 LD      (DE),A
041843 FE      4392 CP      ','
041844 2C 
041845 C8      4393 RET     Z
041846 FE      4394 CP      CR
041847 0D 
041848 C8      4395 RET     Z
041849 FD      4396 INC     IY
04184A 23 
04184B 1C      4397 INC     E
04184C 18      4398 JR      XTRAC1
04184D F1 
               4399 
               4400 ; Search for a token at the start of a program line
               4401 ; - HL: Pointer to the start of a tokenised line in the program area
               4402 ; Returns:
               4403 ; - HL: Pointer to the
               4404 ; -  F: Carry set if not found
               4405 ; Corrupts:
               4406 ; - BC
               4407 ;
04184E 01      4408 SEARCH_EX:			LD      BC,0			; Clear BC
04184F 00 
041850 00 
041851 00 
               4409 ;
041852 4E      4410 SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041853 0C      4411 INC     C			; Check for 0, i.e. end of program marker
041854 0D      4412 DEC     C
041855 28      4413 JR      Z,SRCH2_EX         	; Not found the token, so end
041856 0B 
041857 23      4414 INC     HL			; Skip the line length and line number
041858 23      4415 INC     HL
041859 23      4416 INC     HL
04185A BE      4417 CP      (HL)			; Compare with the token
04185B C8      4418 RET     Z			; Found it, so return with carry not set
04185C 0D      4419 DEC     C			; Skip to the next line
04185D 0D      4420 DEC     C
04185E 0D      4421 DEC     C
04185F 09      4422 ADD     HL,BC
041860 18      4423 JR      SRCH1_EX			; Rinse, lather and repeat
041861 F0 
               4424 ;
041862 2B      4425 SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041863 37      4426 SCF				; And set the carry flag
041864 C9      4427 RET
               4428 
               4429 ; Multiply by 4 or 5
               4430 ; This function is used to allocate space for dimensioned variables
               4431 ; This is a 24-bit operation
               4432 ; - DE: Number to multiple
               4433 ; -  A: 04h (Integer) - takes up 4 bytes
               4434 ;       05h (Float)   - takes up 5 bytes
               4435 ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
               4436 ; Returns:
               4437 ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
               4438 ; -  F: Carry if overflow
               4439 ; Corrupts:
               4440 ; - HL
041865 FE      4441 X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041866 04 
               4442 ; LD	HL,DE
041867 D5      4443 push de
041868 E1      4444 pop hl
041869 29      4445 ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04186A D8      4446 RET     C			; Exit if overflow
04186B 29      4447 ADD     HL,HL			; Multiply by 2 again
04186C D8      4448 RET     C			; Exit if overflow
04186D EB      4449 EX      DE,HL			; DE: Product
04186E C8      4450 RET     Z			; Exit if A = 4
04186F 19      4451 ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
041870 EB      4452 EX      DE,HL			; DE: Product
041871 C9      4453 RET
               4454 
               4455 ; 16-bit unsigned multiply
               4456 ; - HL: Operand 1
               4457 ; - BC: Operand 2
               4458 ; Returns:
               4459 ; - HL: Result
               4460 ; -  F: C if overflow
               4461 ;
041872 C5      4462 MUL16:			PUSH	BC
041873 51      4463 LD	D, C			; Set up the registers for the multiplies
041874 5D      4464 LD	E, L
041875 69      4465 LD	L, C
041876 4B      4466 LD	C, E
041877 ED      4467 MLT	HL			; HL = H * C (*256)
041878 6C 
041879 ED      4468 MLT	DE			; DE = L * C
04187A 5C 
04187B ED      4469 MLT	BC			; BC = B * L (*256)
04187C 4C 
04187D 09      4470 ADD	HL, BC			; HL = The sum of the two most significant multiplications
04187E C1      4471 POP	BC
04187F AF      4472 XOR	A
041880 9C      4473 SBC	H			; If H is not zero then it's an overflow
041881 D8      4474 RET	C
041882 65      4475 LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
041883 6F      4476 LD	L, A
041884 19      4477 ADD	HL, DE
041885 C9      4478 RET
               4479 ;
041886 CD      4480 CHANEL:			CALL    NXT			; Skip whitespace
041887 70 
041888 0A 
041889 04 
04188A FE      4481 CP      '#'			; Check for the '#' symbol
04188B 23 
04188C 3E      4482 LD      A,45
04188D 2D 
04188E C2      4483 JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
04188F 60 
041890 37 
041891 04 
041892 FD      4484 CHNL:			INC     IY             		; Bump past the '#'
041893 23 
041894 CD      4485 CALL    ITEMI			; Get the channel number
041895 25 
041896 03 
041897 04 
041898 D9      4486 EXX
041899 EB      4487 EX      DE,HL			; DE: The channel number
04189A C9      4488 RET
               4489 
               4490 ; ASSEMBLER -------------------------------------------------------------------
               4491 
               4492 ; Language independant control section:
               4493 ;  Outputs: A=delimiter, carry set if syntax error.
               4494 ;
04189B CD      4495 ASSEM:			CALL    SKIP
04189C B5 
04189D 1D 
04189E 04 
04189F FD      4496 INC     IY
0418A0 23 
0418A1 FE      4497 CP      ':'
0418A2 3A 
0418A3 28      4498 JR      Z,ASSEM
0418A4 F6 
0418A5 FE      4499 CP      ']'
0418A6 5D 
0418A7 C8      4500 RET     Z
0418A8 FE      4501 CP      CR
0418A9 0D 
0418AA C8      4502 RET     Z
0418AB FD      4503 DEC     IY
0418AC 2B 
0418AD DD      4504 LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
0418AE 2A 
0418AF 40 
0418B0 4C 
0418B0 04   
0418B2 21      4505 LD      HL,LISTON
0418B3 40 
0418B4 4D 
0418B5 04 
0418B6 CB      4506 BIT     6,(HL)
0418B7 76 
0418B8 28      4507 JR      Z,ASSEM0
0418B9 05 
0418BA DD      4508 LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
0418BB 2A 
0418BC 3C 
0418BD 4C 
0418BD 04   
0418BF DD      4509 ASSEM0:			PUSH    IX
0418C0 E5 
0418C1 FD      4510 PUSH    IY
0418C2 E5 
0418C3 CD      4511 CALL    ASMB
0418C4 73 
0418C5 19 
0418C6 04 
0418C7 C1      4512 POP     BC
0418C8 D1      4513 POP     DE
0418C9 D8      4514 RET     C
0418CA CD      4515 CALL    SKIP
0418CB B5 
0418CC 1D 
0418CD 04 
0418CE 37      4516 SCF
0418CF C0      4517 RET     NZ
0418D0 FD      4518 DEC     IY
0418D1 2B 
0418D2 FD      4519 ASSEM3:			INC     IY
0418D3 23 
0418D4 FD      4520 LD      A,(IY)
0418D5 7E 
0418D6 00 
0418D7 CD      4521 CALL    TERM0
0418D8 81 
0418D9 17 
0418DA 04 
0418DB 20      4522 JR      NZ,ASSEM3
0418DC F5 
0418DD 3A      4523 LD      A,(LISTON)
0418DE 40 
0418DF 4D 
0418E0 04 
0418E1 DD      4524 PUSH    IX
0418E2 E5 
0418E3 E1      4525 POP     HL
0418E4 B7      4526 OR      A
0418E5 ED      4527 SBC     HL,DE
0418E6 52 
0418E7 EB      4528 EX      DE,HL           	; DE: Number of bytes
0418E8 E5      4529 PUSH    HL
0418E9 2A      4530 LD      HL,(PC)
0418EA 40 
0418EB 4C 
0418EC 04 
0418ED E5      4531 PUSH    HL
0418EE 19      4532 ADD     HL,DE
0418EF 22      4533 LD      (PC),HL         	; Update PC
0418F0 40 
0418F1 4C 
0418F2 04 
0418F3 CB      4534 BIT     6,A
0418F4 77 
0418F5 28      4535 JR      Z,ASSEM5
0418F6 09 
0418F7 2A      4536 LD      HL,(OC)
0418F8 3C 
0418F9 4C 
0418FA 04 
0418FB 19      4537 ADD     HL,DE
0418FC 22      4538 LD      (OC),HL         	; Update OC
0418FD 3C 
0418FE 4C 
0418FF 04 
041900 E1      4539 ASSEM5:			POP     HL              	; Old PC
041901 DD      4540 POP     IX              	; Code here
041902 E1 
041903 CB      4541 BIT     4,A
041904 67 
041905 28      4542 JR      Z,ASSEM
041906 94 
041907 22      4543 LD	(R0),HL			; Store HL in R0 so we can access the MSB
041908 4A 
041909 4D 
04190A 04 
04190B 3A      4544 LD	A,(R0+2)		; Print out the address
04190C 4C 
04190D 4D 
04190E 04 
04190F CD      4545 CALL	HEX_EX
041910 5D 
041911 19 
041912 04 
041913 7C      4546 LD      A,H
041914 CD      4547 CALL    HEX_EX
041915 5D 
041916 19 
041917 04 
041918 7D      4548 LD      A,L
041919 CD      4549 CALL    HEXSP
04191A 55 
04191B 19 
04191C 04 
04191D AF      4550 XOR     A
04191E BB      4551 CP      E
04191F 28      4552 JR      Z,ASSEM2
041920 18 
               4553 ;
041921 3A      4554 ASSEM1:			LD      A,(COUNT)
041922 3D 
041923 4D 
041924 04 
041925 FE      4555 CP      20
041926 14 
041927 3E      4556 LD      A,7
041928 07 
041929 D4      4557 CALL    NC,TABIT        	; Next line
04192A C3 
04192B 17 
04192C 04 
04192D DD      4558 LD      A,(IX)
04192E 7E 
04192F 00 
041930 CD      4559 CALL    HEXSP
041931 55 
041932 19 
041933 04 
041934 DD      4560 INC     IX
041935 23 
041936 1D      4561 DEC     E
041937 20      4562 JR      NZ,ASSEM1
041938 E8 
               4563 ;
041939 3E      4564 ASSEM2:			LD      A,22			; Tab to the disassembly field
04193A 16 
04193B CD      4565 CALL    TABIT
04193C C3 
04193D 17 
04193E 04 
04193F FD      4566 PUSH    IY
041940 E5 
041941 E1      4567 POP     HL
041942 ED      4568 SBC     HL,BC
041943 42 
041944 0A      4569 ASSEM4:			LD      A,(BC)
041945 CD      4570 CALL    OUT_
041946 6C 
041947 39 
041948 04 
041949 03      4571 INC     BC
04194A 2D      4572 DEC     L
04194B 20      4573 JR      NZ,ASSEM4
04194C F7 
04194D CD      4574 CALL    CRLF
04194E 47 
04194F 39 
041950 04 
041951 C3      4575 JP      ASSEM
041952 9B 
041953 18 
041954 04 
               4576 ;
041955 CD      4577 HEXSP:			CALL    HEX_EX
041956 5D 
041957 19 
041958 04 
041959 3E      4578 LD      A,' '
04195A 20 
04195B 18      4579 JR      OUTCH1
04195C 12 
04195D F5      4580 HEX_EX:			PUSH    AF
04195E 0F      4581 RRCA
04195F 0F      4582 RRCA
041960 0F      4583 RRCA
041961 0F      4584 RRCA
041962 CD      4585 CALL    HEXOUT
041963 67 
041964 19 
041965 04 
041966 F1      4586 POP     AF
041967 E6      4587 HEXOUT:			AND     0FH
041968 0F 
041969 C6      4588 ADD     A,90H
04196A 90 
04196B 27      4589 DAA
04196C CE      4590 ADC     A,40H
04196D 40 
04196E 27      4591 DAA
04196F C3      4592 OUTCH1:			JP      OUT_
041970 6C 
041971 39 
041972 04 
               4593 
               4594 ; Processor Specific Translation Section:
               4595 ;
               4596 ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
               4597 ;                 C: Opcode beig built
               4598 ;                 D: Flags
               4599 ;			Bit 7: Set to 1 if the instruction uses long addressing
               4600 ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
               4601 ;                 E: Offset from IX or IY
               4602 ;                HL: Numeric operand value
               4603 ;                IX: Code destination pointer
               4604 ;                IY: Source text pointer
               4605 ;    Inputs: A = initial character
               4606 ;   Outputs: Carry set if syntax error.
               4607 ;
041973 FE      4608 ASMB:			CP      '.'			; Check for a dot; this indicates a label
041974 2E 
041975 20      4609 JR      NZ,ASMB1		; No, so just process the instruction
041976 1F 
041977 FD      4610 INC     IY			; Skip past the dot to the label name
041978 23 
041979 DD      4611 PUSH    IX			; Store the code destination pointer
04197A E5 
04197B CD      4612 CALL    VAR_			; Create a variable
04197C 8E 
04197D 0C 
04197E 04 
04197F F5      4613 PUSH    AF
041980 CD      4614 CALL    ZERO			; Zero it
041981 93 
041982 09 
041983 04 
041984 3A      4615 LD	A,(PC+2)
041985 42 
041986 4C 
041987 04 
041988 6F      4616 LD	L,A			; The MSB of the 24-bit address
041989 D9      4617 EXX
04198A 2A      4618 LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
04198B 40 
04198C 4C 
04198D 04 
04198E D9      4619 EXX
04198F F1      4620 POP     AF
041990 CD      4621 CALL    STORE			; Store the program counter
041991 D6 
041992 15 
041993 04 
041994 DD      4622 POP     IX			; Restore the code destination pointer
041995 E1 
               4623 ;
041996 3A      4624 ASMB1:			LD	A,(LISTON)		; Get the OPT flags
041997 40 
041998 4D 
041999 04 
04199A E6      4625 AND	80H
04199B 80 
04199C 57      4626 LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
04199D CD      4627 CALL    SKIP			; Skip any whitespace
04199E B5 
04199F 1D 
0419A0 04 
0419A1 C8      4628 RET     Z			; And return if there is nothing further to process
0419A2 FE      4629 CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419A3 D6 
0419A4 0E      4630 LD      C,0C4H			;  A: The base operand
0419A5 C4 
0419A6 FD      4631 INC     IY			; Skip past the token
0419A7 23 
0419A8 CA      4632 JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419A9 EA 
0419AA 1A 
0419AB 04 
0419AC FD      4633 DEC     IY			; Skip back, as we're not doing the above at this point
0419AD 2B 
0419AE 21      4634 LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419AF CC 
0419B0 1D 
0419B1 04 
0419B2 CD      4635 CALL    FIND			; Find the opcode
0419B3 64 
0419B4 1D 
0419B5 04 
0419B6 D8      4636 RET     C			; If not found, then return; carry indicates an error condition
0419B7 48      4637 LD      C,B     		;  C: A copy of the opcode
               4638 ;
               4639 ; GROUP 0: Trivial cases requiring no computation
               4640 ; GROUP 1: As Group 0, but with "ED" prefix
               4641 ;
0419B8 D6      4642 SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419B9 44 
0419BA 30      4643 JR      NC,GROUP02		; If not in that range, then check GROUP2
0419BB 08 
0419BC FE      4644 CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419BD CB 
0419BE D4      4645 CALL    NC,ED			; Needs to be prefixed with ED
0419BF BD 
0419C0 1C 
0419C1 04 
0419C2 18      4646 JR      BYTE0			; Then write the opcode byte
0419C3 76 
               4647 ;
               4648 ; GROUP 2: BIT, RES, SET
               4649 ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
               4650 ;
0419C4 D6      4651 GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419C5 0A 
0419C6 30      4652 JR      NC,GROUP04		; If not in that range, then check GROUP4
0419C7 12 
0419C8 FE      4653 CP      3-10			;
0419C9 F9 
0419CA DC      4654 CALL    C,BIT_
0419CB 52 
0419CC 1D 
0419CD 04 
0419CE D8      4655 RET     C
0419CF CD      4656 CALL    REGLO
0419D0 23 
0419D1 1D 
0419D2 04 
0419D3 D8      4657 RET     C
0419D4 CD      4658 CALL    CB
0419D5 C1 
0419D6 1C 
0419D7 04 
0419D8 18      4659 JR      BYTE0
0419D9 60 
               4660 ;
               4661 ; GROUP 4 - PUSH, POP, EX (SP)
               4662 ;
0419DA D6      4663 GROUP04:		SUB     3			; The number of opcodes in GROUP4
0419DB 03 
0419DC 30      4664 JR      NC,GROUP05		; If not in that range, then check GROUP5
0419DD 07 
0419DE CD      4665 GROUP04_1:		CALL    PAIR_EX
0419DF 45 
0419E0 1D 
0419E1 04 
0419E2 D8      4666 RET     C
0419E3 18      4667 JR      BYTE0
0419E4 55 
               4668 ;
               4669 ; GROUP 5 - SUB, AND, XOR, OR, CP
               4670 ; GROUP 6 - ADD, ADC, SBC
               4671 ;
0419E5 D6      4672 GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0419E6 0A 
0419E7 30      4673 JR      NC,GROUP07
0419E8 39 
0419E9 FE      4674 CP      5-8
0419EA FD 
0419EB 06      4675 LD      B,7
0419EC 07 
0419ED D4      4676 CALL    NC,OPND			; Get the first operand
0419EE D1 
0419EF 1C 
0419F0 04 
0419F1 78      4677 LD      A,B
0419F2 FE      4678 CP      7			; Is the operand 'A'?
0419F3 07 
0419F4 20      4679 JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0419F5 15 
               4680 ;
0419F6 CD      4681 GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0419F7 23 
0419F8 1D 
0419F9 04 
0419FA 79      4682 LD      A,C
0419FB 30      4683 JR      NC,BIND1		; If it is a register, then write that out
0419FC 2E 
0419FD EE      4684 XOR     46H			; Handle ADD A,n
0419FE 46 
0419FF CD      4685 CALL    BIND
041A00 C3 
041A01 1C 
041A02 04 
041A03 CD      4686 DB_:			CALL    NUMBER
041A04 03 
041A05 1D 
041A06 04 
041A07 C3      4687 JP      VAL8
041A08 BC 
041A09 1A 
041A0A 04 
               4688 ;
041A0B E6      4689 GROUP05_HL:		AND     3FH
041A0C 3F 
041A0D FE      4690 CP      12
041A0E 0C 
041A0F 37      4691 SCF
041A10 C0      4692 RET     NZ
041A11 79      4693 LD      A,C
041A12 FE      4694 CP      80H
041A13 80 
041A14 0E      4695 LD      C,9
041A15 09 
041A16 28      4696 JR      Z,GROUP04_1
041A17 C6 
041A18 EE      4697 XOR     1CH
041A19 1C 
041A1A 0F      4698 RRCA
041A1B 4F      4699 LD      C,A
041A1C CD      4700 CALL    ED
041A1D BD 
041A1E 1C 
041A1F 04 
041A20 18      4701 JR      GROUP04_1
041A21 BC 
               4702 ;
               4703 ; GROUP 7 - INC, DEC
               4704 ;
041A22 D6      4705 GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A23 02 
041A24 30      4706 JR      NC,GROUP08
041A25 19 
041A26 CD      4707 CALL    REGHI
041A27 2A 
041A28 1D 
041A29 04 
041A2A 79      4708 LD      A,C
041A2B D2      4709 BIND1:			JP      NC,BIND
041A2C C3 
041A2D 1C 
041A2E 04 
041A2F EE      4710 XOR     64H
041A30 64 
041A31 07      4711 RLCA
041A32 07      4712 RLCA
041A33 07      4713 RLCA
041A34 4F      4714 LD      C,A
041A35 CD      4715 CALL    PAIR1_EX
041A36 4A 
041A37 1D 
041A38 04 
041A39 D8      4716 RET     C
041A3A 79      4717 BYTE0:			LD      A,C
041A3B C3      4718 JP      BYTE_
041A3C F2 
041A3D 1C 
041A3E 04 
               4719 ;
               4720 ; Group 8: IN0, OUT0
               4721 ;
041A3F D6      4722 GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A40 02 
041A41 30      4723 JR	NC,GROUP09
041A42 26 
041A43 FE      4724 CP	1-2
041A44 FF 
041A45 CC      4725 CALL    Z,NUMBER		; Fetch number first if OUT
041A46 03 
041A47 1D 
041A48 04 
041A49 08      4726 EX      AF,AF'			; Save flags
041A4A CD      4727 CALL    REG			; Get the register value regardless
041A4B 17 
041A4C 1D 
041A4D 04 
041A4E D8      4728 RET     C			; Return if not a register
041A4F 08      4729 EX      AF,AF'			; Restore the flags
041A50 DC      4730 CALL    C,NUMBER		; Fetch number last if IN
041A51 03 
041A52 1D 
041A53 04 
041A54 78      4731 LD	A,B			; Get the register number
041A55 FE      4732 CP	6			; Fail on (HL)
041A56 06 
041A57 37      4733 SCF
041A58 C8      4734 RET	Z
041A59 FE      4735 CP	8			; Check it is just single pairs only
041A5A 08 
041A5B 3F      4736 CCF
041A5C D8      4737 RET	C			; And return if it is an invalid register
041A5D 07      4738 RLCA				; Bind with the operand
041A5E 07      4739 RLCA
041A5F 07      4740 RLCA
041A60 81      4741 ADD	A,C
               4742 ; BEGIN NOT IN BINARY
               4743 ; LD	C,A
               4744 ; CALL	ED			; Prefix with ED
               4745 ; LD	A,C
               4746 ; END NOT IN BINARY
041A61 CD      4747 CALL	BYTE_			; Write out the operand
041A62 F2 
041A63 1C 
041A64 04 
041A65 C3      4748 JP	VAL8			; Write out the value
041A66 BC 
041A67 1A 
041A68 04 
               4749 ;
               4750 ; GROUP 9 - IN
               4751 ; GROUP 10 - OUT
               4752 ;
041A69 D6      4753 GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041A6A 02 
041A6B 30      4754 JR      NC,GROUP11
041A6C 25 
041A6D FE      4755 CP      1-2			; Check if Group 9 or Group 1
041A6E FF 
041A6F CC      4756 CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041A70 B1 
041A71 1C 
041A72 04 
041A73 08      4757 EX      AF,AF'			; Save flags
041A74 CD      4758 CALL    REGHI			; Get the register value regardless
041A75 2A 
041A76 1D 
041A77 04 
041A78 D8      4759 RET     C			; Return if not a register
041A79 08      4760 EX      AF,AF'			; Restore the flags
041A7A DC      4761 CALL    C,CORN			; Call CORN if Group 9 (IN)
041A7B B1 
041A7C 1C 
041A7D 04 
041A7E 24      4762 INC     H			; If it is IN r,(C) or OUT (C),r then
041A7F 28      4763 JR      Z,BYTE0			; Just write the operand out
041A80 B9 
               4764 ;
041A81 78      4765 LD      A,B			; Check the register
041A82 FE      4766 CP      7
041A83 07 
041A84 37      4767 SCF
041A85 C0      4768 RET     NZ			; If it is not A, then return
               4769 ;
041A86 79      4770 LD      A,C			; Bind the register with the operand
041A87 EE      4771 XOR     3
041A88 03 
041A89 07      4772 RLCA
041A8A 07      4773 RLCA
041A8B 07      4774 RLCA
041A8C CD      4775 CALL    BYTE_			; Write out the operand
041A8D F2 
041A8E 1C 
041A8F 04 
041A90 18      4776 JR      VAL8			; And the value
041A91 2A 
               4777 ;
               4778 ; GROUP 11 - JR, DJNZ
               4779 ;
041A92 D6      4780 GROUP11:		SUB     2			; The number of opcodes in GROUP11
041A93 02 
041A94 30      4781 JR      NC,GROUP12
041A95 2B 
041A96 FE      4782 CP      1-2
041A97 FF 
041A98 C4      4783 CALL    NZ,COND_
041A99 31 
041A9A 1D 
041A9B 04 
041A9C 79      4784 LD      A,C
041A9D 30      4785 JR      NC,@F
041A9E 02 
041A9F 3E      4786 LD      A,18H
041AA0 18 
041AA1 CD      4787 @@:			CALL    BYTE_
041AA2 F2 
041AA3 1C 
041AA4 04 
041AA5 CD      4788 CALL    NUMBER
041AA6 03 
041AA7 1D 
041AA8 04 
041AA9 ED      4789 LD      DE,(PC)
041AAA 5B 
041AAB 40 
041AAC 4C 
041AAC 04   
041AAE 13      4790 INC     DE
041AAF 37      4791 SCF
041AB0 ED      4792 SBC     HL,DE
041AB1 52 
041AB2 7D      4793 LD      A,L
041AB3 17      4794 RLA
041AB4 9F      4795 SBC     A,A
041AB5 BC      4796 CP      H
041AB6 3E      4797 TOOFAR:			LD      A,1
041AB7 01 
041AB8 C2      4798 JP      NZ,ERROR_		; Throw an "Out of range" error
041AB9 60 
041ABA 37 
041ABB 04 
041ABC 7D      4799 VAL8:			LD      A,L
041ABD C3      4800 JP      BYTE_
041ABE F2 
041ABF 1C 
041AC0 04 
               4801 ;
               4802 ; GROUP 12 - JP
               4803 ;
041AC1 D6      4804 GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AC2 01 
041AC3 30      4805 JR	NC,GROUP13
041AC4 21 
041AC5 CD      4806 CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AC6 17 
041AC7 1C 
041AC8 04 
041AC9 D8      4807 RET	C			; Exit if an invalid suffix is provided
041ACA CD      4808 CALL    COND_			; Evaluate the conditions
041ACB 31 
041ACC 1D 
041ACD 04 
041ACE 79      4809 LD      A,C
041ACF 30      4810 JR      NC,GROUP12_1
041AD0 0D 
041AD1 78      4811 LD      A,B
041AD2 E6      4812 AND     3FH
041AD3 3F 
041AD4 FE      4813 CP      6
041AD5 06 
041AD6 3E      4814 LD      A,0E9H
041AD7 E9 
041AD8 CA      4815 JP      Z,BYTE_
041AD9 F2 
041ADA 1C 
041ADB 04 
041ADC 3E      4816 LD      A,0C3H
041ADD C3 
041ADE CD      4817 GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041ADF F2 
041AE0 1C 
041AE1 04 
041AE2 C3      4818 JP	ADDR_			; Output the address
041AE3 6C 
041AE4 1C 
041AE5 04 
               4819 ;
               4820 ; GROUP 13 - CALL
               4821 ;
041AE6 D6      4822 GROUP13:		SUB	1			; The number of opcodes in GROUP13
041AE7 01 
041AE8 30      4823 JR	NC,GROUP14
041AE9 0C 
041AEA CD      4824 GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041AEB 2F 
041AEC 1C 
041AED 04 
041AEE CD      4825 CALL    GROUP15_1		; Output the opcode (with conditions)
041AEF 11 
041AF0 1B 
041AF1 04 
041AF2 C3      4826 JP	ADDR_			; Output the address
041AF3 6C 
041AF4 1C 
041AF5 04 
               4827 ;
               4828 ; GROUP 14 - RST
               4829 ;
041AF6 D6      4830 GROUP14:		SUB	1			; The number of opcodes in GROUP14
041AF7 01 
041AF8 30      4831 JR	NC,GROUP15
041AF9 13 
041AFA CD      4832 CALL	EZ80SF_FULL		; Evaluate the suffix
041AFB 2F 
041AFC 1C 
041AFD 04 
041AFE D8      4833 RET	C			; Exit if an invalid suffix provided
041AFF CD      4834 CALL    NUMBER
041B00 03 
041B01 1D 
041B02 04 
041B03 A1      4835 AND     C
041B04 B4      4836 OR      H
041B05 20      4837 JR      NZ,TOOFAR
041B06 AF 
041B07 7D      4838 LD      A,L
041B08 B1      4839 OR      C
041B09 C3      4840 JP      BYTE_
041B0A F2 
041B0B 1C 
041B0C 04 
               4841 ;
               4842 ; GROUP 15 - RET
               4843 ;
041B0D D6      4844 GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B0E 01 
041B0F 30      4845 JR	NC,GROUP16
041B10 0F 
041B11 CD      4846 GROUP15_1:		CALL    COND_
041B12 31 
041B13 1D 
041B14 04 
041B15 79      4847 LD      A,C
041B16 D2      4848 JP      NC,BYTE_
041B17 F2 
041B18 1C 
041B19 04 
041B1A F6      4849 OR      9
041B1B 09 
041B1C C3      4850 JP      BYTE_
041B1D F2 
041B1E 1C 
041B1F 04 
               4851 ;
               4852 ; GROUP 16 - LD
               4853 ;
041B20 D6      4854 GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B21 01 
041B22 30      4855 JR	NC,GROUP17
041B23 74 
041B24 CD      4856 CALL	EZ80SF_FULL		; Evaluate the suffix
041B25 2F 
041B26 1C 
041B27 04 
041B28 CD      4857 CALL    LDOP			; Check for accumulator loads
041B29 60 
041B2A 1D 
041B2B 04 
041B2C D2      4858 JP      NC,LDA			; Yes, so jump here
041B2D 8C 
041B2E 1C 
041B2F 04 
041B30 CD      4859 CALL    REGHI
041B31 2A 
041B32 1D 
041B33 04 
041B34 08      4860 EX      AF,AF'
041B35 CD      4861 CALL    SKIP
041B36 B5 
041B37 1D 
041B38 04 
041B39 FE      4862 CP      '('			; Check for bracket
041B3A 28 
041B3B 28      4863 JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B3C 24 
041B3D 08      4864 EX      AF,AF'
041B3E D2      4865 JP      NC,GROUP05_1		; Load single register direct; go here
041B3F F6 
041B40 19 
041B41 04 
041B42 0E      4866 LD      C,1
041B43 01 
041B44 CD      4867 CALL    PAIR1_EX
041B45 4A 
041B46 1D 
041B47 04 
041B48 D8      4868 RET     C
041B49 3E      4869 LD      A,14
041B4A 0E 
041B4B B8      4870 CP      B
041B4C 47      4871 LD      B,A
041B4D CC      4872 CALL    Z,PAIR_EX
041B4E 45 
041B4F 1D 
041B50 04 
041B51 78      4873 LD      A,B
041B52 E6      4874 AND     3FH
041B53 3F 
041B54 FE      4875 CP      12
041B55 0C 
041B56 79      4876 LD      A,C
041B57 C2      4877 JP      NZ,GROUP12_1		; Load register pair direct; go here
041B58 DE 
041B59 1A 
041B5A 04 
041B5B 3E      4878 LD      A,0F9H
041B5C F9 
041B5D C3      4879 JP      BYTE_
041B5E F2 
041B5F 1C 
041B60 04 
               4880 ;
041B61 08      4881 LDIN:			EX      AF,AF'
041B62 C5      4882 PUSH    BC
041B63 D4      4883 CALL    NC,REGLO
041B64 23 
041B65 1D 
041B66 04 
041B67 79      4884 LD      A,C
041B68 C1      4885 POP     BC
041B69 D2      4886 JP      NC,BIND
041B6A C3 
041B6B 1C 
041B6C 04 
041B6D 0E      4887 LD      C,0AH
041B6E 0A 
041B6F CD      4888 CALL    PAIR1_EX
041B70 4A 
041B71 1D 
041B72 04 
041B73 CD      4889 CALL    LD16
041B74 97 
041B75 1C 
041B76 04 
041B77 D2      4890 JP      NC,GROUP12_1
041B78 DE 
041B79 1A 
041B7A 04 
041B7B CD      4891 CALL    NUMBER
041B7C 03 
041B7D 1D 
041B7E 04 
041B7F 0E      4892 LD      C,2
041B80 02 
041B81 CD      4893 CALL    PAIR_EX
041B82 45 
041B83 1D 
041B84 04 
041B85 CD      4894 CALL    LD16
041B86 97 
041B87 1C 
041B88 04 
041B89 D8      4895 RET     C
041B8A CD      4896 CALL    BYTE_
041B8B F2 
041B8C 1C 
041B8D 04 
041B8E CB      4897 BIT	7,D			; Check the ADL flag
041B8F 7A 
041B90 C2      4898 JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041B91 81 
041B92 1C 
041B93 04 
041B94 C3      4899 JP      VAL16			; Otherwise use 16-bit addresses
041B95 74 
041B96 1C 
041B97 04 
               4900 ;
               4901 ; Group 17 - TST
               4902 ;
041B98 D6      4903 GROUP17:		SUB	1			; The number of opcodes in GROUP17
041B99 01 
041B9A 30      4904 JR	NC,OPTS
041B9B 25 
041B9C CD      4905 CALL	ED			; Needs to be prefixed with ED
041B9D BD 
041B9E 1C 
041B9F 04 
041BA0 CD      4906 CALL	REG			; Fetch the register
041BA1 17 
041BA2 1D 
041BA3 04 
041BA4 30      4907 JR	NC,GROUP17_1		; It's just a register
041BA5 0E 
               4908 ;
041BA6 3E      4909 LD	A,64H			; Opcode for TST n
041BA7 64 
041BA8 CD      4910 CALL	BYTE_			; Write out the opcode
041BA9 F2 
041BAA 1C 
041BAB 04 
041BAC CD      4911 CALL	NUMBER			; Get the number
041BAD 03 
041BAE 1D 
041BAF 04 
041BB0 C3      4912 JP	VAL8			; And write that out
041BB1 BC 
041BB2 1A 
041BB3 04 
               4913 ;
041BB4 78      4914 GROUP17_1:		LD	A,B			; Check the register rangs
041BB5 FE      4915 CP	8
041BB6 08 
041BB7 3F      4916 CCF
041BB8 D8      4917 RET	C			; Ret with carry flag set for error if out of range
041BB9 07      4918 RLCA				; Get the opcode value
041BBA 07      4919 RLCA
041BBB 07      4920 RLCA
041BBC 81      4921 ADD	A,C			; Add the opcode base in
041BBD C3      4922 JP	BYTE_
041BBE F2 
041BBF 1C 
041BC0 04 
               4923 
               4924 ;
               4925 ; Assembler directives - OPT, ADL
               4926 ;
041BC1 D6      4927 OPTS:			SUB	2
041BC2 02 
041BC3 30      4928 JR	NC, DEFS
041BC4 2B 
041BC5 FE      4929 CP	1-2			; Check for ADL opcode
041BC6 FF 
041BC7 28      4930 JR	Z, ADL_
041BC8 13 
               4931 ;
041BC9 CD      4932 OPT:			CALL    NUMBER			; Fetch the OPT value
041BCA 03 
041BCB 1D 
041BCC 04 
041BCD 21      4933 LD      HL,LISTON		; Address of the LISTON/OPT flag
041BCE 40 
041BCF 4D 
041BD0 04 
041BD1 E6      4934 AND	7			; Only interested in the first three bits
041BD2 07 
041BD3 4F      4935 LD      C,A			; Store the new OPT value in C
041BD4 ED      4936 RLD				; Shift the top nibble of LISTON (OPT) into A
041BD5 6F 
041BD6 E6      4937 AND	8			; Clear the bottom three bits, preserving the ADL bit
041BD7 08 
041BD8 B1      4938 OR	C			; OR in the new value
041BD9 ED      4939 RRD				; And shift the nibble back in
041BDA 67 
041BDB C9      4940 RET
               4941 ;
041BDC CD      4942 ADL_:			CALL	NUMBER			; Fetch the ADL value
041BDD 03 
041BDE 1D 
041BDF 04 
041BE0 E6      4943 AND	1			; Only interested if it is 0 or 1
041BE1 01 
041BE2 0F      4944 RRCA				; Rotate to bit 7
041BE3 4F      4945 LD	C,A			; Store in C
041BE4 3A      4946 LD	A,(LISTON)		; Get the LISTON system variable
041BE5 40 
041BE6 4D 
041BE7 04 
041BE8 E6      4947 AND	7Fh			; Clear bit 7
041BE9 7F 
041BEA B1      4948 OR	C			; OR in the ADL value
041BEB 32      4949 LD	(LISTON),A		; Store
041BEC 40 
041BED 4D 
041BEE 04 
041BEF C9      4950 RET
               4951 ;
               4952 ; DEFB, DEFW, DEFL, DEFM
               4953 ;
041BF0 B7      4954 DEFS:			OR	A			; Handle DEFB
041BF1 CA      4955 JP	Z, DB_
041BF2 03 
041BF3 1A 
041BF4 04 
041BF5 3D      4956 DEC	A			; Handle DEFW
041BF6 CA      4957 JP	Z, ADDR16
041BF7 70 
041BF8 1C 
041BF9 04 
041BFA 3D      4958 DEC	A			; Handle DEFL
041BFB CA      4959 JP	Z, ADDR24
041BFC 7D 
041BFD 1C 
041BFE 04 
               4960 ;
041BFF DD      4961 PUSH    IX			; Handle DEFM
041C00 E5 
041C01 CD      4962 CALL    EXPRS
041C02 15 
041C03 03 
041C04 04 
041C05 DD      4963 POP     IX
041C06 E1 
041C07 21      4964 LD      HL,ACCS
041C08 00 
041C09 4A 
041C0A 04 
041C0B AF      4965 @@:			XOR     A
041C0C BB      4966 CP      E
041C0D C8      4967 RET     Z
041C0E 7E      4968 LD      A,(HL)
041C0F 23      4969 INC     HL
041C10 CD      4970 CALL    BYTE_
041C11 F2 
041C12 1C 
041C13 04 
041C14 1D      4971 DEC     E
041C15 18      4972 JR      @B
041C16 F4 
               4973 
               4974 ;
               4975 ;SUBROUTINES:
               4976 ;
041C17 FD      4977 EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C18 7E 
041C19 00 
041C1A FE      4978 CP	'.'
041C1B 2E 
041C1C 28      4979 JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C1D 02 
041C1E B7      4980 OR	A			; Reset the carry flag (no error)
041C1F C9      4981 RET				; And return
041C20 FD      4982 @@:			INC	IY			; Skip the dot
041C21 23 
041C22 C5      4983 PUSH	BC			; Push the operand
041C23 21      4984 LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C24 4B 
041C25 20 
041C26 04 
041C27 CD      4985 CALL	FIND			; Look up the operand
041C28 64 
041C29 1D 
041C2A 04 
041C2B 30      4986 JR	NC,EZ80SF_OK
041C2C 24 
041C2D C1      4987 POP	BC			; Not found at this point, so will return with a C (error)
041C2E C9      4988 RET
               4989 ;
041C2F FD      4990 EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C30 7E 
041C31 00 
041C32 FE      4991 CP	'.'
041C33 2E 
041C34 28      4992 JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C35 02 
041C36 B7      4993 OR	A			; Reset the carry flag (no error)
041C37 C9      4994 RET				; And return
041C38 FD      4995 @@:			INC	IY 			; Skip the dot
041C39 23 
041C3A C5      4996 PUSH	BC			; Push the operand
041C3B 21      4997 LD	HL,EZ80SFS_1		; First check the fully qualified table
041C3C 43 
041C3D 20 
041C3E 04 
041C3F CD      4998 CALL	FIND 			; Look up the operand
041C40 64 
041C41 1D 
041C42 04 
041C43 30      4999 JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C44 0C 
041C45 CD      5000 CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C46 60 
041C47 1C 
041C48 04 
041C49 CD      5001 CALL	FIND
041C4A 64 
041C4B 1D 
041C4C 04 
041C4D 30      5002 JR	NC,EZ80SF_OK
041C4E 02 
041C4F C1      5003 POP	BC			; Not found at this point, so will return with a C (error)
041C50 C9      5004 RET
               5005 ;
041C51 78      5006 EZ80SF_OK:		LD	A,B			; The operand value
041C52 D4      5007 CALL	NC,BYTE_ 		; Write it out if found
041C53 F2 
041C54 1C 
041C55 04 
041C56 CB      5008 RES	7,D			; Clear the default ADL mode from the flags
041C57 BA 
041C58 E6      5009 AND	2			; Check the second half of the suffix (.xxL)
041C59 02 
041C5A 0F      5010 RRCA				; Shift into bit 7
041C5B 0F      5011 RRCA
041C5C B2      5012 OR	D			; Or into bit 7 of D
041C5D 57      5013 LD	D,A
041C5E C1      5014 POP	BC 			; Restore the operand
041C5F C9      5015 RET
               5016 ;
041C60 21      5017 EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C61 54 
041C62 20 
041C63 04 
041C64 CB      5018 BIT 	7,D			; if bit 7 of D is 0
041C65 7A 
041C66 C8      5019 RET	Z
041C67 21      5020 LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041C68 5F 
041C69 20 
041C6A 04 
041C6B C9      5021 RET
               5022 ;
041C6C CB      5023 ADDR_:			BIT	7,D			; Check the ADL flag
041C6D 7A 
041C6E 20      5024 JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041C6F 0D 
               5025 ;
041C70 CD      5026 ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041C71 03 
041C72 1D 
041C73 04 
041C74 CD      5027 VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041C75 BC 
041C76 1A 
041C77 04 
041C78 7C      5028 LD      A,H
041C79 C3      5029 JP      BYTE_
041C7A F2 
041C7B 1C 
041C7C 04 
               5030 ;
041C7D CD      5031 ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041C7E 03 
041C7F 1D 
041C80 04 
041C81 CD      5032 VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041C82 74 
041C83 1C 
041C84 04 
041C85 D9      5033 EXX
041C86 7D      5034 LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041C87 D9      5035 EXX
041C88 C3      5036 JP	BYTE_
041C89 F2 
041C8A 1C 
041C8B 04 
               5037 ;
041C8C FE      5038 LDA:			CP      4
041C8D 04 
041C8E DC      5039 CALL    C,ED
041C8F BD 
041C90 1C 
041C91 04 
041C92 78      5040 LD      A,B
041C93 C3      5041 JP      BYTE_
041C94 F2 
041C95 1C 
041C96 04 
               5042 ;
041C97 78      5043 LD16:			LD      A,B
041C98 38      5044 JR      C,LD8
041C99 0F 
041C9A 78      5045 LD      A,B
041C9B E6      5046 AND     3FH
041C9C 3F 
041C9D FE      5047 CP      12
041C9E 0C 
041C9F 79      5048 LD      A,C
041CA0 C8      5049 RET     Z
041CA1 CD      5050 CALL    ED
041CA2 BD 
041CA3 1C 
041CA4 04 
041CA5 79      5051 LD      A,C
041CA6 F6      5052 OR      43H
041CA7 43 
041CA8 C9      5053 RET
               5054 ;
041CA9 FE      5055 LD8:			CP      7
041CAA 07 
041CAB 37      5056 SCF
041CAC C0      5057 RET     NZ
041CAD 79      5058 LD      A,C
041CAE F6      5059 OR      30H
041CAF 30 
041CB0 C9      5060 RET
               5061 ;
               5062 ; Used in IN and OUT to handle whether the operand is C or a number
               5063 ;
041CB1 C5      5064 CORN:			PUSH    BC
041CB2 CD      5065 CALL    OPND			; Get the operand
041CB3 D1 
041CB4 1C 
041CB5 04 
041CB6 CB      5066 BIT     5,B
041CB7 68 
041CB8 C1      5067 POP     BC
041CB9 28      5068 JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CBA 48 
041CBB 26      5069 LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CBC FF 
               5070 ;
041CBD 3E      5071 ED:			LD      A,0EDH			; Write an ED prefix out
041CBE ED 
041CBF 18      5072 JR      BYTE_
041CC0 31 
               5073 ;
041CC1 3E      5074 CB:			LD      A,0CBH
041CC2 CB 
041CC3 FE      5075 BIND:			CP      76H
041CC4 76 
041CC5 37      5076 SCF
041CC6 C8      5077 RET     Z               	; Reject LD (HL),(HL)
041CC7 CD      5078 CALL    BYTE_
041CC8 F2 
041CC9 1C 
041CCA 04 
041CCB CB      5079 BIT	6,D			; Check the index bit in flags
041CCC 72 
041CCD C8      5080 RET     Z
041CCE 7B      5081 LD      A,E			; If there is an index, output the offset
041CCF 18      5082 JR      BYTE_
041CD0 21 
               5083 ;
               5084 ; Search through the operand table
               5085 ; Returns:
               5086 ; - B: The operand type
               5087 ; - D: Bit 7: 0 = no prefix, 1 = prefix
               5088 ; - E: The IX/IY offset
               5089 ; - F: Carry if not found
               5090 ;
041CD1 E5      5091 OPND:			PUSH    HL			; Preserve HL
041CD2 21      5092 LD      HL,OPRNDS		; The operands table
041CD3 D5 
041CD4 1F 
041CD5 04 
041CD6 CD      5093 CALL    FIND			; Find the operand
041CD7 64 
041CD8 1D 
041CD9 04 
041CDA E1      5094 POP     HL
041CDB D8      5095 RET     C			; Return if not found
041CDC CB      5096 BIT     7,B			; Check if it is an index register (IX, IY)
041CDD 78 
041CDE C8      5097 RET     Z			; Return if it isn't
041CDF CB      5098 SET	6,D			; Set flag to indicate we've got an index
041CE0 F2 
041CE1 CB      5099 BIT     3,B			; Check if an offset is required
041CE2 58 
041CE3 E5      5100 PUSH    HL
041CE4 CC      5101 CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041CE5 F9 
041CE6 1C 
041CE7 04 
041CE8 5D      5102 LD      E,L			; E: The offset
041CE9 E1      5103 POP     HL
041CEA 3E      5104 LD	A,DDH			; IX prefix
041CEB DD 
041CEC CB      5105 BIT     6,B			; If bit 6 is reset then
041CED 70 
041CEE 28      5106 JR      Z,BYTE_			; It's an IX instruction, otherwise set
041CEF 02 
041CF0 3E      5107 LD	A,FDH			; IY prefix
041CF1 FD 
               5108 ;
041CF2 DD      5109 BYTE_:			LD      (IX),A			; Write a byte out
041CF3 77 
041CF4 00 
041CF5 DD      5110 INC     IX
041CF6 23 
041CF7 B7      5111 OR      A
041CF8 C9      5112 RET
               5113 ;
041CF9 FD      5114 OFFSET_EX:			LD      A,(IY)
041CFA 7E 
041CFB 00 
041CFC FE      5115 CP      ')'
041CFD 29 
041CFE 21      5116 LD      HL,0
041CFF 00 
041D00 00 
041D01 00 
041D02 C8      5117 RET     Z
041D03 CD      5118 NUMBER:			CALL    SKIP
041D04 B5 
041D05 1D 
041D06 04 
041D07 C5      5119 PUSH    BC
041D08 D5      5120 PUSH    DE
041D09 DD      5121 PUSH    IX
041D0A E5 
041D0B CD      5122 CALL    EXPRI
041D0C 0A 
041D0D 03 
041D0E 04 
041D0F DD      5123 POP     IX
041D10 E1 
041D11 D9      5124 EXX
041D12 D1      5125 POP     DE
041D13 C1      5126 POP     BC
041D14 7D      5127 LD      A,L
041D15 B7      5128 OR      A
041D16 C9      5129 RET
               5130 ;
041D17 CD      5131 REG:			CALL    OPND
041D18 D1 
041D19 1C 
041D1A 04 
041D1B D8      5132 RET     C
041D1C 78      5133 LD      A,B
041D1D E6      5134 AND     3FH
041D1E 3F 
041D1F FE      5135 CP      8
041D20 08 
041D21 3F      5136 CCF
041D22 C9      5137 RET
               5138 ;
041D23 CD      5139 REGLO:			CALL    REG
041D24 17 
041D25 1D 
041D26 04 
041D27 D8      5140 RET     C
041D28 18      5141 JR      ORC
041D29 33 
               5142 ;
041D2A CD      5143 REGHI:			CALL    REG
041D2B 17 
041D2C 1D 
041D2D 04 
041D2E D8      5144 RET     C
041D2F 18      5145 JR      SHL3
041D30 29 
               5146 ;
041D31 CD      5147 COND_:			CALL    OPND
041D32 D1 
041D33 1C 
041D34 04 
041D35 D8      5148 RET     C
041D36 78      5149 LD      A,B
041D37 E6      5150 AND     1FH
041D38 1F 
041D39 D6      5151 SUB     16
041D3A 10 
041D3B 30      5152 JR      NC,SHL3
041D3C 1D 
041D3D FE      5153 CP      -15
041D3E F1 
041D3F 37      5154 SCF
041D40 C0      5155 RET     NZ
041D41 3E      5156 LD      A,3
041D42 03 
041D43 18      5157 JR      SHL3
041D44 15 
               5158 ;
041D45 CD      5159 PAIR_EX:			CALL    OPND
041D46 D1 
041D47 1C 
041D48 04 
041D49 D8      5160 RET     C
041D4A 78      5161 PAIR1_EX:			LD      A,B
041D4B E6      5162 AND     0FH
041D4C 0F 
041D4D D6      5163 SUB     8
041D4E 08 
041D4F D8      5164 RET     C
041D50 18      5165 JR      SHL3
041D51 08 
               5166 ;
041D52 CD      5167 BIT_:			CALL    NUMBER
041D53 03 
041D54 1D 
041D55 04 
041D56 FE      5168 CP      8
041D57 08 
041D58 3F      5169 CCF
041D59 D8      5170 RET     C
041D5A 07      5171 SHL3:			RLCA
041D5B 07      5172 RLCA
041D5C 07      5173 RLCA
041D5D B1      5174 ORC:			OR      C
041D5E 4F      5175 LD      C,A
041D5F C9      5176 RET
               5177 ;
041D60 21      5178 LDOP:			LD      HL,LDOPS
041D61 1A 
041D62 20 
041D63 04 
               5179 
               5180 ;
               5181 ; Look up a value in a table
               5182 ; Parameters:
               5183 ; - IY: Address of the assembly language line in the BASIC program area
               5184 ; - HL: Address of the table
               5185 ; Returns:
               5186 ; - B: The operand code
               5187 ; - F: Carry set if not found
               5188 ;
041D64 CD      5189 FIND:			CALL    SKIP			; Skip delimiters
041D65 B5 
041D66 1D 
041D67 04 
               5190 ;
041D68 06      5191 EXIT_:			LD      B,0			; Set B to 0
041D69 00 
041D6A 37      5192 SCF				; Set the carry flag
041D6B C8      5193 RET     Z			; Returns if Z
               5194 ;
041D6C FE      5195 CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041D6D DD 
041D6E 28      5196 JR      Z,FIND0
041D6F 04 
041D70 FE      5197 CP      TOR+1			; Special case for tokens AND and OR
041D71 85 
041D72 3F      5198 CCF
041D73 D8      5199 RET     C
041D74 7E      5200 FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041D75 B7      5201 OR      A
041D76 28      5202 JR      Z,EXIT_			; Exit
041D77 F0 
041D78 FD      5203 XOR     (IY)
041D79 AE 
041D7A 00 
041D7B E6      5204 AND     01011111B
041D7C 5F 
041D7D 28      5205 JR      Z,FIND2
041D7E 09 
041D7F CB      5206 FIND1:			BIT     7,(HL)
041D80 7E 
041D81 23      5207 INC     HL
041D82 28      5208 JR      Z,FIND1
041D83 FB 
041D84 23      5209 INC     HL
041D85 04      5210 INC     B
041D86 18      5211 JR      FIND0
041D87 EC 
               5212 ;
041D88 FD      5213 FIND2:			PUSH    IY
041D89 E5 
041D8A CB      5214 FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041D8B 7E 
041D8C FD      5215 INC     IY
041D8D 23 
041D8E 23      5216 INC     HL
041D8F 20      5217 JR      NZ,FIND5		; Yes
041D90 11 
041D91 BE      5218 CP      (HL)
041D92 CC      5219 CALL    Z,SKIP0
041D93 B4 
041D94 1D 
041D95 04 
041D96 7E      5220 LD      A,(HL)
041D97 FD      5221 XOR     (IY)
041D98 AE 
041D99 00 
041D9A E6      5222 AND     01011111B
041D9B 5F 
041D9C 28      5223 JR      Z,FIND3
041D9D EC 
041D9E FD      5224 FIND4:			POP     IY
041D9F E1 
041DA0 18      5225 JR      FIND1
041DA1 DD 
               5226 ;
041DA2 CD      5227 FIND5:			CALL    DELIM			; Is it a delimiter?
041DA3 66 
041DA4 17 
041DA5 04 
041DA6 C4      5228 CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DA7 C9 
041DA8 1D 
041DA9 04 
041DAA C4      5229 CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DAB C3 
041DAC 1D 
041DAD 04 
041DAE 20      5230 JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DAF EE 
               5231 ;
041DB0 78      5232 FIND6:			LD      A,B			; At this point we have a token
041DB1 46      5233 LD      B,(HL)			; Fetch the token type code
041DB2 E1      5234 POP     HL			; Restore the stack
041DB3 C9      5235 RET
               5236 ;
041DB4 23      5237 SKIP0:			INC     HL
041DB5 CD      5238 SKIP:			CALL    DELIM			; Is it a delimiter?
041DB6 66 
041DB7 17 
041DB8 04 
041DB9 C0      5239 RET     NZ			; No, so return
041DBA CD      5240 CALL    TERM			; Is it a terminator?
041DBB 72 
041DBC 17 
041DBD 04 
041DBE C8      5241 RET     Z			; Yes, so return
041DBF FD      5242 INC     IY			; Increment the basic program counter
041DC0 23 
041DC1 18      5243 JR      SKIP			; And loop
041DC2 F2 
               5244 ;
041DC3 FE      5245 SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DC4 2B 
041DC5 C8      5246 RET     Z
041DC6 FE      5247 CP      '-'
041DC7 2D 
041DC8 C9      5248 RET
               5249 ;
041DC9 FE      5250 DOT:			CP	'.'			; Check if it is a dot character
041DCA 2E 
041DCB C9      5251 RET
               5252 ; Z80 opcode list
               5253 ;
               5254 ; Group 0: (15 opcodes)
               5255 ; Trivial cases requiring no computation
               5256 ;
               5257 ; BEGIN REFACTOR FROM BINARY
               5258 ; OPCODS:
               5259 ; 			DB	"NO","P"+80H,00h	; # 00h
               5260 ; 			DB	"RLC","A"+80H,07h
               5261 ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
               5262 ; 			DB	"RRC","A"+80H,0FH
               5263 ; 			DB	"RL","A"+80H,17H
               5264 ; 			DB	"RR","A"+80H,1FH
               5265 ; 			DB	"DA","A"+80H,27H
               5266 ; 			DB	"CP","L"+80H,2FH
               5267 ; 			DB	"SC","F"+80H,37H
               5268 ; 			DB	"CC","F"+80H,3FH
               5269 ; 			DB	"HAL","T"+80H,76H
               5270 ; 			DB	"EX","X"+80H,D9H
               5271 ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
               5272 ; 			DB	"D","I"+80H,F3H
               5273 ; 			DB	"E","I"+80H,FBH
               5274 ; ;
               5275 ; ; Group 1: (53 opcodes)
               5276 ; ; As Group 0, but with an ED prefix
               5277 ; ;
               5278 ; 			DB	"NE","G"+80H,44H	; 0Fh
               5279 ; 			DB	"IM",0,"0"+80H,46H
               5280 ; 			DB	"RET","N"+80H,45H
               5281 ; 			DB	"MLT",0,"B","C"+80H,4CH
               5282 ; 			DB	"RET","I"+80H,4DH
               5283 ; 			DB	"IM",0,"1"+80H,56H
               5284 ; 			DB	"MLT",0,"D","E"+80H,5CH
               5285 ; 			DB	"IM",0,"2"+80H,5EH
               5286 ; 			DB	"RR","D"+80H,67H
               5287 ; 			DB	"MLT",0,"H","L"+80H,6CH
               5288 ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
               5289 ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
               5290 ; 			DB	"RL","D"+80H,6FH
               5291 ; 			DB	"SL","P"+80H,76H
               5292 ; 			DB	"MLT",0,"S","P"+80H,7CH
               5293 ; 			DB	"STMI","X"+80H,7DH
               5294 ; 			DB	"RSMI","X"+80H,7EH
               5295 ; 			DB	"INI","M"+80H,82H
               5296 ; 			DB	"OTI","M"+80H,83H
               5297 ; 			DB	"INI","2"+80H,84H
               5298 ; 			DB	"IND","M"+80H,8AH
               5299 ; 			DB	"OTD","M"+80H,8BH
               5300 ; 			DB	"IND","2"+80H,8CH
               5301 ; 			DB	"INIM","R"+80H,92H
               5302 ; 			DB	"OTIM","R"+80H,93H
               5303 ; 			DB	"INI2","R"+80H,94H
               5304 ; 			DB	"INDM","R"+80H,9AH
               5305 ; 			DB	"OTDM","R"+80H,9BH
               5306 ; 			DB	"IND2","R"+80H,9CH
               5307 ; 			DB	"LD","I"+80H,A0H
               5308 ; 			DB	"CP","I"+80H,A1H
               5309 ; 			DB	"IN","I"+80H,A2H
               5310 ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
               5311 ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
               5312 ; 			DB	"LD","D"+80H,A8H
               5313 ; 			DB	"CP","D"+80H,A9H
               5314 ; 			DB	"IN","D"+80H,AAH
               5315 ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
               5316 ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
               5317 ; 			DB	"LDI","R"+80H,B0H
               5318 ; 			DB	"CPI","R"+80H,B1H
               5319 ; 			DB	"INI","R"+80H,B2H
               5320 ; 			DB	"OTI","R"+80H,B3H
               5321 ; 			DB	"OTI2","R"+80H,B4H
               5322 ; 			DB	"LDD","R"+80H,B8H
               5323 ; 			DB	"CPD","R"+80H,B9H
               5324 ; 			DB	"IND","R"+80H,BAH
               5325 ; 			DB	"OTD","R"+80H,BBH
               5326 ; 			DB	"OTD2","R"+80H,BCH
               5327 ; 			DB	"INIR","X"+80H,C2H
               5328 ; 			DB	"OTIR","X"+80H,C3H
               5329 ; 			DB	"INDR","X"+80H,CAH
               5330 ; 			DB	"OTDR","X"+80H,CBH
               5331 ; ;
               5332 ; ; Group 2: (3 opcodes)
               5333 ; ;
               5334 ; 			DB	"BI","T"+80H,40H	; 44h
               5335 ; 			DB	"RE","S"+80H,80H
               5336 ; 			DB	"SE","T"+80H,C0H
               5337 ; ;
               5338 ; ; Group 3: (7 opcodes)
               5339 ; ;
               5340 ; 			DB	"RL","C"+80H,00H	; 47h
               5341 ; 			DB	"RR","C"+80H,08H
               5342 ; 			DB	"R","L"+80H,10H
               5343 ; 			DB	"R","R"+80H,18H
               5344 ; 			DB	"SL","A"+80H,20H
               5345 ; 			DB	"SR","A"+80H,28H
               5346 ; 			DB	"SR","L"+80H,38H
               5347 ; ;
               5348 ; ; Group 4: (3 opcodes)
               5349 ; ;
               5350 ; 			DB	"PO","P"+80H,C1H	; 4Eh
               5351 ; 			DB	"PUS","H"+80H,C5H
               5352 ; 			DB	"EX",0,"(S","P"+80H,E3H
               5353 ; ;
               5354 ; ; Group 5: (7 opcodes)
               5355 ; ;
               5356 ; 			DB	"SU","B"+80H,90H	; 51h
               5357 ; 			DB	"AN","D"+80H,A0H
               5358 ; 			DB	"XO","R"+80H,A8H
               5359 ; 			DB	"O","R"+80H,B0H
               5360 ; 			DB	"C","P"+80H,B8H
               5361 ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
               5362 ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
               5363 ; ;
               5364 ; ; Group 6 (3 opcodes)
               5365 ; ;
               5366 ; 			DB	"AD","D"+80H,80H	; 58h
               5367 ; 			DB	"AD","C"+80H,88H
               5368 ; 			DB	"SB","C"+80H,98H
               5369 ; ;
               5370 ; ; Group 7: (2 opcodes)
               5371 ; ;
               5372 ; 			DB	"IN","C"+80H,04H	; 5Bh
               5373 ; 			DB	"DE","C"+80H,05H
               5374 ; ;
               5375 ; ; Group 8: (2 opcodes)
               5376 ; ;
               5377 ; 			DB	"IN","0"+80H,00H	; 5Dh
               5378 ; 			DB	"OUT","0"+80H,01H
               5379 ; ;
               5380 ; ; Group 9: (1 opcode)
               5381 ; ;
               5382 ; 			DB	"I","N"+80H,40H		; 5Fh
               5383 ; ;
               5384 ; ; Group 10: (1 opcode)
               5385 ; ;
               5386 ; 			DB	"OU","T"+80H,41H	; 60h
               5387 ; ;
               5388 ; ; Group 11: (2 opcodes)
               5389 ; ;
               5390 ; 			DB	"J","R"+80H,20H		; 61h
               5391 ; 			DB	"DJN","Z"+80H,10H
               5392 ; ;
               5393 ; ; Group 12: (1 opcode)
               5394 ; ;
               5395 ; 			DB	"J","P"+80H,C2H		; 63h
               5396 ; ;
               5397 ; ; Group 13: (1 opcode)
               5398 ; ;
               5399 ; 			DB	"CAL","L"+80H,C4H	; 64h
               5400 ; ;
               5401 ; ; Group 14: (1 opcode)
               5402 ; ;
               5403 ; 			DB	"RS","T"+80H,C7H	; 65h
               5404 ; ;
               5405 ; ; Group 15: (1 opcode)
               5406 ; ;
               5407 ; 			DB	"RE","T"+80H,C0H	; 66h
               5408 ; ;
               5409 ; ; Group 16: (1 opcode)
               5410 ; ;
               5411 ; 			DB	"L","D"+80H,40H		; 67h
               5412 ; ;
               5413 ; ; Group 17: (1 opcode)
               5414 ; ;
               5415 ; 			DB	"TS","T"+80H,04H	; 68h
               5416 
               5417 ; ;
               5418 ; ; Assembler Directives
               5419 ; ;
               5420 ; 			DB	"OP","T"+80H,00H	; 69h OPT
               5421 ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
               5422 ; ;
               5423 ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
               5424 ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
               5425 ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
               5426 ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
               5427 ; ;
               5428 ; 			DB	0
               5429 ; ;
               5430 ; ; Operands
               5431 ; ;
               5432 ; OPRNDS:			DB	"B"+80H, 00H
               5433 ; 			DB	"C"+80H, 01H
               5434 ; 			DB	"D"+80H, 02H
               5435 ; 			DB	"E"+80H, 03H
               5436 ; 			DB	"H"+80H, 04H
               5437 ; 			DB	"L"+80H, 05H
               5438 ; 			DB	"(H","L"+80H,06H
               5439 ; 			DB	"A"+80H, 07H
               5440 ; 			DB	"(I","X"+80H,86H
               5441 ; 			DB	"(I","Y"+80H,C6H
               5442 ; ;
               5443 ; 			DB	"B","C"+80H,08H
               5444 ; 			DB	"D","E"+80H,0AH
               5445 ; 			DB	"H","L"+80H,0CH
               5446 ; 			DB	"I","X"+80H,8CH
               5447 ; 			DB	"I","Y"+80H,CCH
               5448 ; 			DB	"A","F"+80H,0EH
               5449 ; 			DB	"S","P"+80H,0EH
               5450 ; ;
               5451 ; 			DB	"N","Z"+80H,10H
               5452 ; 			DB	"Z"+80H,11H
               5453 ; 			DB	"N","C"+80H,12H
               5454 ; 			DB	"P","O"+80H,14H
               5455 ; 			DB	"P","E"+80H,15H
               5456 ; 			DB	"P"+80H,16H
               5457 ; 			DB	"M"+80H,17H
               5458 ; ;
               5459 ; 			DB	"(","C"+80H,20H
               5460 ; ;
               5461 ; 			DB	0
               5462 ; ;
               5463 ; ; Load operations
               5464 ; ;
               5465 ; LDOPS:			DB	"I",0,"A"+80H,47H
               5466 ; 			DB	"R",0,"A"+80H,4FH
               5467 ; 			DB	"A",0,"I"+80H,57H
               5468 ; 			DB	"A",0,"R"+80H,5FH
               5469 ; 			DB	"(BC",0,"A"+80H,02h
               5470 ; 			DB	"(DE",0,"A"+80H,12H
               5471 ; 			DB	"A",0,"(B","C"+80H,0AH
               5472 ; 			DB	"A",0,"(D","E"+80H,1AH
               5473 ; ;
               5474 ; 			DB	0
               5475 ; ;
               5476 ; ; eZ80 addressing mode suffixes
               5477 ; ;
               5478 ; ; Fully qualified suffixes
               5479 ; ;
               5480 ; EZ80SFS_1:		DB	"LI","S"+80H,49H
               5481 ; 			DB	"SI","L"+80H,52H
               5482 ; EZ80SFS_2:		DB	"SI","S"+80H,40H
               5483 ; 			DB	"LI","L"+80H,5BH
               5484 ; ;
               5485 ; 			DB	0
               5486 ; ;
               5487 ; ; Shortcuts when ADL mode is 0
               5488 ; ;
               5489 ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
               5490 ; 			DB	"L"+80H,49H		; Equivalent to .LIS
               5491 ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
               5492 ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
               5493 ; ;
               5494 ; 			DB	0
               5495 ; ;
               5496 ; ; Shortcuts when ADL mode is 1
               5497 ; ;
               5498 ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
               5499 ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
               5500 ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
               5501 ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
               5502 ; ;
               5503 ; 			DB	0
               5504 ; END REFACTOR FROM BINARY
               5505 ; BEGIN INSERT FROM BINARY
               5506 ;
               5507 ; Trivial cases requiring no computation
               5508 OPCODS:
041DCC 4E      5509 db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
041DCD 4F      5510 db 0x4f ; 041DCD
041DCE D0      5511 db 0xd0 ; 041DCE
041DCF 00      5512 db 0x00 ; 041DCF
041DD0 52      5513 db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
041DD1 4C      5514 db 0x4c ; 041DD1
041DD2 43      5515 db 0x43 ; 041DD2
041DD3 C1      5516 db 0xc1 ; 041DD3
041DD4 07      5517 db 0x07 ; 041DD4
041DD5 45      5518 db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
041DD6 58      5519 db 0x58 ; 041DD6
041DD7 00      5520 db 0x00 ; 041DD7
041DD8 41      5521 db 0x41 ; 041DD8
041DD9 46      5522 db 0x46 ; 041DD9
041DDA 00      5523 db 0x00 ; 041DDA
041DDB 41      5524 db 0x41 ; 041DDB
041DDC 46      5525 db 0x46 ; 041DDC
041DDD A7      5526 db 0xa7 ; 041DDD
041DDE 08      5527 db 0x08 ; 041DDE
041DDF 52      5528 db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
041DE0 52      5529 db 0x52 ; 041DE0
041DE1 43      5530 db 0x43 ; 041DE1
041DE2 C1      5531 db 0xc1 ; 041DE2
041DE3 0F      5532 db 0x0f ; 041DE3
041DE4 52      5533 db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
041DE5 4C      5534 db 0x4c ; 041DE5
041DE6 C1      5535 db 0xc1 ; 041DE6
041DE7 17      5536 db 0x17 ; 041DE7
041DE8 52      5537 db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
041DE9 52      5538 db 0x52 ; 041DE9
041DEA C1      5539 db 0xc1 ; 041DEA
041DEB 1F      5540 db 0x1f ; 041DEB
041DEC 44      5541 db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
041DED 41      5542 db 0x41 ; 041DED
041DEE C1      5543 db 0xc1 ; 041DEE
041DEF 27      5544 db 0x27 ; 041DEF
041DF0 43      5545 db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
041DF1 50      5546 db 0x50 ; 041DF1
041DF2 CC      5547 db 0xcc ; 041DF2
041DF3 2F      5548 db 0x2f ; 041DF3
041DF4 53      5549 db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
041DF5 43      5550 db 0x43 ; 041DF5
041DF6 C6      5551 db 0xc6 ; 041DF6
041DF7 37      5552 db 0x37 ; 041DF7
041DF8 43      5553 db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
041DF9 43      5554 db 0x43 ; 041DF9
041DFA C6      5555 db 0xc6 ; 041DFA
041DFB 3F      5556 db 0x3f ; 041DFB
041DFC 48      5557 db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
041DFD 41      5558 db 0x41 ; 041DFD
041DFE 4C      5559 db 0x4c ; 041DFE
041DFF D4      5560 db 0xd4 ; 041DFF
041E00 76      5561 db 0x76 ; 041E00
041E01 45      5562 db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
041E02 58      5563 db 0x58 ; 041E02
041E03 D8      5564 db 0xd8 ; 041E03
041E04 D9      5565 db 0xd9 ; 041E04
041E05 45      5566 db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
041E06 58      5567 db 0x58 ; 041E06
041E07 00      5568 db 0x00 ; 041E07
041E08 44      5569 db 0x44 ; 041E08
041E09 45      5570 db 0x45 ; 041E09
041E0A 00      5571 db 0x00 ; 041E0A
041E0B 48      5572 db 0x48 ; 041E0B
041E0C CC      5573 db 0xcc ; 041E0C
041E0D EB      5574 db 0xeb ; 041E0D
041E0E 44      5575 db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
041E0F C9      5576 db 0xc9 ; 041E0F
041E10 F3      5577 db 0xf3 ; 041E10
041E11 45      5578 db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
041E12 C9      5579 db 0xc9 ; 041E12
041E13 FB      5580 db 0xfb ; 041E13
               5581 ;
               5582 ; Group 1: (53 opcodes)
               5583 ; As Group 0, but with an ED prefix
               5584 ;
041E14 4E      5585 db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
041E15 45      5586 db 0x45 ; 041E15
041E16 C7      5587 db 0xc7 ; 041E16
041E17 44      5588 db 0x44 ; 041E17
041E18 49      5589 db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
041E19 4D      5590 db 0x4d ; 041E19
041E1A 00      5591 db 0x00 ; 041E1A
041E1B B0      5592 db 0xb0 ; 041E1B
041E1C 46      5593 db 0x46 ; 041E1C
041E1D 52      5594 db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
041E1E 45      5595 db 0x45 ; 041E1E
041E1F 54      5596 db 0x54 ; 041E1F
041E20 CE      5597 db 0xce ; 041E20
041E21 45      5598 db 0x45 ; 041E21
041E22 4D      5599 db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
041E23 4C      5600 db 0x4c ; 041E23
041E24 54      5601 db 0x54 ; 041E24
041E25 00      5602 db 0x00 ; 041E25
041E26 42      5603 db 0x42 ; 041E26
041E27 C3      5604 db 0xc3 ; 041E27
041E28 4C      5605 db 0x4c ; 041E28
041E29 52      5606 db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
041E2A 45      5607 db 0x45 ; 041E2A
041E2B 54      5608 db 0x54 ; 041E2B
041E2C C9      5609 db 0xc9 ; 041E2C
041E2D 4D      5610 db 0x4d ; 041E2D
041E2E 49      5611 db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
041E2F 4D      5612 db 0x4d ; 041E2F
041E30 00      5613 db 0x00 ; 041E30
041E31 B1      5614 db 0xb1 ; 041E31
041E32 56      5615 db 0x56 ; 041E32
041E33 4D      5616 db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
041E34 4C      5617 db 0x4c ; 041E34
041E35 54      5618 db 0x54 ; 041E35
041E36 00      5619 db 0x00 ; 041E36
041E37 44      5620 db 0x44 ; 041E37
041E38 C5      5621 db 0xc5 ; 041E38
041E39 5C      5622 db 0x5c ; 041E39
041E3A 49      5623 db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
041E3B 4D      5624 db 0x4d ; 041E3B
041E3C 00      5625 db 0x00 ; 041E3C
041E3D B2      5626 db 0xb2 ; 041E3D
041E3E 5E      5627 db 0x5e ; 041E3E
041E3F 52      5628 db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
041E40 52      5629 db 0x52 ; 041E40
041E41 C4      5630 db 0xc4 ; 041E41
041E42 67      5631 db 0x67 ; 041E42
041E43 4D      5632 db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
041E44 4C      5633 db 0x4c ; 041E44
041E45 54      5634 db 0x54 ; 041E45
041E46 00      5635 db 0x00 ; 041E46
041E47 48      5636 db 0x48 ; 041E47
041E48 CC      5637 db 0xcc ; 041E48
041E49 6C      5638 db 0x6c ; 041E49
041E4A 4C      5639 db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
041E4B 44      5640 db 0x44 ; 041E4B
041E4C 00      5641 db 0x00 ; 041E4C
041E4D 4D      5642 db 0x4d ; 041E4D
041E4E 42      5643 db 0x42 ; 041E4E
041E4F 00      5644 db 0x00 ; 041E4F
041E50 C1      5645 db 0xc1 ; 041E50
041E51 6D      5646 db 0x6d ; 041E51
041E52 4C      5647 db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
041E53 44      5648 db 0x44 ; 041E53
041E54 00      5649 db 0x00 ; 041E54
041E55 41      5650 db 0x41 ; 041E55
041E56 00      5651 db 0x00 ; 041E56
041E57 4D      5652 db 0x4d ; 041E57
041E58 C2      5653 db 0xc2 ; 041E58
041E59 6E      5654 db 0x6e ; 041E59
041E5A 52      5655 db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
041E5B 4C      5656 db 0x4c ; 041E5B
041E5C C4      5657 db 0xc4 ; 041E5C
041E5D 6F      5658 db 0x6f ; 041E5D
041E5E 53      5659 db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
041E5F 4C      5660 db 0x4c ; 041E5F
041E60 D0      5661 db 0xd0 ; 041E60
041E61 76      5662 db 0x76 ; 041E61
041E62 4D      5663 db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
041E63 4C      5664 db 0x4c ; 041E63
041E64 54      5665 db 0x54 ; 041E64
041E65 00      5666 db 0x00 ; 041E65
041E66 53      5667 db 0x53 ; 041E66
041E67 D0      5668 db 0xd0 ; 041E67
041E68 7C      5669 db 0x7c ; 041E68
041E69 53      5670 db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
041E6A 54      5671 db 0x54 ; 041E6A
041E6B 4D      5672 db 0x4d ; 041E6B
041E6C 49      5673 db 0x49 ; 041E6C
041E6D D8      5674 db 0xd8 ; 041E6D
041E6E 7D      5675 db 0x7d ; 041E6E
041E6F 52      5676 db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
041E70 53      5677 db 0x53 ; 041E70
041E71 4D      5678 db 0x4d ; 041E71
041E72 49      5679 db 0x49 ; 041E72
041E73 D8      5680 db 0xd8 ; 041E73
041E74 7E      5681 db 0x7e ; 041E74
041E75 49      5682 db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
041E76 4E      5683 db 0x4e ; 041E76
041E77 49      5684 db 0x49 ; 041E77
041E78 CD      5685 db 0xcd ; 041E78
041E79 82      5686 db 0x82 ; 041E79
041E7A 4F      5687 db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
041E7B 54      5688 db 0x54 ; 041E7B
041E7C 49      5689 db 0x49 ; 041E7C
041E7D CD      5690 db 0xcd ; 041E7D
041E7E 83      5691 db 0x83 ; 041E7E
041E7F 49      5692 db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
041E80 4E      5693 db 0x4e ; 041E80
041E81 49      5694 db 0x49 ; 041E81
041E82 B2      5695 db 0xb2 ; 041E82
041E83 84      5696 db 0x84 ; 041E83
041E84 49      5697 db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
041E85 4E      5698 db 0x4e ; 041E85
041E86 44      5699 db 0x44 ; 041E86
041E87 CD      5700 db 0xcd ; 041E87
041E88 8A      5701 db 0x8a ; 041E88
041E89 4F      5702 db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
041E8A 54      5703 db 0x54 ; 041E8A
041E8B 44      5704 db 0x44 ; 041E8B
041E8C CD      5705 db 0xcd ; 041E8C
041E8D 8B      5706 db 0x8b ; 041E8D
041E8E 49      5707 db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
041E8F 4E      5708 db 0x4e ; 041E8F
041E90 44      5709 db 0x44 ; 041E90
041E91 B2      5710 db 0xb2 ; 041E91
041E92 8C      5711 db 0x8c ; 041E92
041E93 49      5712 db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
041E94 4E      5713 db 0x4e ; 041E94
041E95 49      5714 db 0x49 ; 041E95
041E96 4D      5715 db 0x4d ; 041E96
041E97 D2      5716 db 0xd2 ; 041E97
041E98 92      5717 db 0x92 ; 041E98
041E99 4F      5718 db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
041E9A 54      5719 db 0x54 ; 041E9A
041E9B 49      5720 db 0x49 ; 041E9B
041E9C 4D      5721 db 0x4d ; 041E9C
041E9D D2      5722 db 0xd2 ; 041E9D
041E9E 93      5723 db 0x93 ; 041E9E
041E9F 49      5724 db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
041EA0 4E      5725 db 0x4e ; 041EA0
041EA1 49      5726 db 0x49 ; 041EA1
041EA2 32      5727 db 0x32 ; 041EA2
041EA3 D2      5728 db 0xd2 ; 041EA3
041EA4 94      5729 db 0x94 ; 041EA4
041EA5 49      5730 db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
041EA6 4E      5731 db 0x4e ; 041EA6
041EA7 44      5732 db 0x44 ; 041EA7
041EA8 4D      5733 db 0x4d ; 041EA8
041EA9 D2      5734 db 0xd2 ; 041EA9
041EAA 9A      5735 db 0x9a ; 041EAA
041EAB 4F      5736 db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
041EAC 54      5737 db 0x54 ; 041EAC
041EAD 44      5738 db 0x44 ; 041EAD
041EAE 4D      5739 db 0x4d ; 041EAE
041EAF D2      5740 db 0xd2 ; 041EAF
041EB0 9B      5741 db 0x9b ; 041EB0
041EB1 49      5742 db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
041EB2 4E      5743 db 0x4e ; 041EB2
041EB3 44      5744 db 0x44 ; 041EB3
041EB4 32      5745 db 0x32 ; 041EB4
041EB5 D2      5746 db 0xd2 ; 041EB5
041EB6 9C      5747 db 0x9c ; 041EB6
041EB7 4C      5748 db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
041EB8 44      5749 db 0x44 ; 041EB8
041EB9 C9      5750 db 0xc9 ; 041EB9
041EBA A0      5751 db 0xa0 ; 041EBA
041EBB 43      5752 db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
041EBC 50      5753 db 0x50 ; 041EBC
041EBD C9      5754 db 0xc9 ; 041EBD
041EBE A1      5755 db 0xa1 ; 041EBE
041EBF 49      5756 db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
041EC0 4E      5757 db 0x4e ; 041EC0
041EC1 C9      5758 db 0xc9 ; 041EC1
041EC2 A2      5759 db 0xa2 ; 041EC2
041EC3 4F      5760 db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041EC4 55      5761 db 0x55 ; 041EC4
041EC5 54      5762 db 0x54 ; 041EC5
041EC6 49      5763 db 0x49 ; 041EC6
041EC7 B2      5764 db 0xb2 ; 041EC7
041EC8 A4      5765 db 0xa4 ; 041EC8
041EC9 4F      5766 db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041ECA 55      5767 db 0x55 ; 041ECA
041ECB 54      5768 db 0x54 ; 041ECB
041ECC C9      5769 db 0xc9 ; 041ECC
041ECD A3      5770 db 0xa3 ; 041ECD
041ECE 4C      5771 db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
041ECF 44      5772 db 0x44 ; 041ECF
041ED0 C4      5773 db 0xc4 ; 041ED0
041ED1 A8      5774 db 0xa8 ; 041ED1
041ED2 43      5775 db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
041ED3 50      5776 db 0x50 ; 041ED3
041ED4 C4      5777 db 0xc4 ; 041ED4
041ED5 A9      5778 db 0xa9 ; 041ED5
041ED6 49      5779 db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
041ED7 4E      5780 db 0x4e ; 041ED7
041ED8 C4      5781 db 0xc4 ; 041ED8
041ED9 AA      5782 db 0xaa ; 041ED9
041EDA 4F      5783 db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041EDB 55      5784 db 0x55 ; 041EDB
041EDC 54      5785 db 0x54 ; 041EDC
041EDD 44      5786 db 0x44 ; 041EDD
041EDE B2      5787 db 0xb2 ; 041EDE
041EDF AC      5788 db 0xac ; 041EDF
041EE0 4F      5789 db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041EE1 55      5790 db 0x55 ; 041EE1
041EE2 54      5791 db 0x54 ; 041EE2
041EE3 C4      5792 db 0xc4 ; 041EE3
041EE4 AB      5793 db 0xab ; 041EE4
041EE5 4C      5794 db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
041EE6 44      5795 db 0x44 ; 041EE6
041EE7 49      5796 db 0x49 ; 041EE7
041EE8 D2      5797 db 0xd2 ; 041EE8
041EE9 B0      5798 db 0xb0 ; 041EE9
041EEA 43      5799 db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
041EEB 50      5800 db 0x50 ; 041EEB
041EEC 49      5801 db 0x49 ; 041EEC
041EED D2      5802 db 0xd2 ; 041EED
041EEE B1      5803 db 0xb1 ; 041EEE
041EEF 49      5804 db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
041EF0 4E      5805 db 0x4e ; 041EF0
041EF1 49      5806 db 0x49 ; 041EF1
041EF2 D2      5807 db 0xd2 ; 041EF2
041EF3 B2      5808 db 0xb2 ; 041EF3
041EF4 4F      5809 db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
041EF5 54      5810 db 0x54 ; 041EF5
041EF6 49      5811 db 0x49 ; 041EF6
041EF7 D2      5812 db 0xd2 ; 041EF7
041EF8 B3      5813 db 0xb3 ; 041EF8
041EF9 4F      5814 db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
041EFA 54      5815 db 0x54 ; 041EFA
041EFB 49      5816 db 0x49 ; 041EFB
041EFC 32      5817 db 0x32 ; 041EFC
041EFD D2      5818 db 0xd2 ; 041EFD
041EFE B4      5819 db 0xb4 ; 041EFE
041EFF 4C      5820 db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
041F00 44      5821 db 0x44 ; 041F00
041F01 44      5822 db 0x44 ; 041F01
041F02 D2      5823 db 0xd2 ; 041F02
041F03 B8      5824 db 0xb8 ; 041F03
041F04 43      5825 db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
041F05 50      5826 db 0x50 ; 041F05
041F06 44      5827 db 0x44 ; 041F06
041F07 D2      5828 db 0xd2 ; 041F07
041F08 B9      5829 db 0xb9 ; 041F08
041F09 49      5830 db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
041F0A 4E      5831 db 0x4e ; 041F0A
041F0B 44      5832 db 0x44 ; 041F0B
041F0C D2      5833 db 0xd2 ; 041F0C
041F0D BA      5834 db 0xba ; 041F0D
041F0E 4F      5835 db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
041F0F 54      5836 db 0x54 ; 041F0F
041F10 44      5837 db 0x44 ; 041F10
041F11 D2      5838 db 0xd2 ; 041F11
041F12 BB      5839 db 0xbb ; 041F12
041F13 4F      5840 db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
041F14 54      5841 db 0x54 ; 041F14
041F15 44      5842 db 0x44 ; 041F15
041F16 32      5843 db 0x32 ; 041F16
041F17 D2      5844 db 0xd2 ; 041F17
041F18 BC      5845 db 0xbc ; 041F18
041F19 49      5846 db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
041F1A 4E      5847 db 0x4e ; 041F1A
041F1B 49      5848 db 0x49 ; 041F1B
041F1C 52      5849 db 0x52 ; 041F1C
041F1D D8      5850 db 0xd8 ; 041F1D
041F1E C2      5851 db 0xc2 ; 041F1E
041F1F 4F      5852 db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
041F20 54      5853 db 0x54 ; 041F20
041F21 49      5854 db 0x49 ; 041F21
041F22 52      5855 db 0x52 ; 041F22
041F23 D8      5856 db 0xd8 ; 041F23
041F24 C3      5857 db 0xc3 ; 041F24
041F25 49      5858 db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
041F26 4E      5859 db 0x4e ; 041F26
041F27 44      5860 db 0x44 ; 041F27
041F28 52      5861 db 0x52 ; 041F28
041F29 D8      5862 db 0xd8 ; 041F29
041F2A CA      5863 db 0xca ; 041F2A
041F2B 4F      5864 db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
041F2C 54      5865 db 0x54 ; 041F2C
041F2D 44      5866 db 0x44 ; 041F2D
041F2E 52      5867 db 0x52 ; 041F2E
041F2F D8      5868 db 0xd8 ; 041F2F
041F30 CB      5869 db 0xcb ; 041F30
               5870 ;
               5871 ; Group 2: (3 opcodes)
               5872 ;
041F31 42      5873 db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
041F32 49      5874 db 0x49 ; 041F32
041F33 D4      5875 db 0xd4 ; 041F33
041F34 40      5876 db 0x40 ; 041F34
041F35 52      5877 db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
041F36 45      5878 db 0x45 ; 041F36
041F37 D3      5879 db 0xd3 ; 041F37
041F38 80      5880 db 0x80 ; 041F38
041F39 53      5881 db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
041F3A 45      5882 db 0x45 ; 041F3A
041F3B D4      5883 db 0xd4 ; 041F3B
041F3C C0      5884 db 0xc0 ; 041F3C
               5885 ;
               5886 ; Group 3: (7 opcodes)
               5887 ;
041F3D 52      5888 db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
041F3E 4C      5889 db 0x4c ; 041F3E
041F3F C3      5890 db 0xc3 ; 041F3F
041F40 00      5891 db 0x00 ; 041F40
041F41 52      5892 db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
041F42 52      5893 db 0x52 ; 041F42
041F43 C3      5894 db 0xc3 ; 041F43
041F44 08      5895 db 0x08 ; 041F44
041F45 52      5896 db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
041F46 CC      5897 db 0xcc ; 041F46
041F47 10      5898 db 0x10 ; 041F47
041F48 52      5899 db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
041F49 D2      5900 db 0xd2 ; 041F49
041F4A 18      5901 db 0x18 ; 041F4A
041F4B 53      5902 db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
041F4C 4C      5903 db 0x4c ; 041F4C
041F4D C1      5904 db 0xc1 ; 041F4D
041F4E 20      5905 db 0x20 ; 041F4E
041F4F 53      5906 db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
041F50 52      5907 db 0x52 ; 041F50
041F51 C1      5908 db 0xc1 ; 041F51
041F52 28      5909 db 0x28 ; 041F52
041F53 53      5910 db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
041F54 52      5911 db 0x52 ; 041F54
041F55 CC      5912 db 0xcc ; 041F55
041F56 38      5913 db 0x38 ; 041F56
               5914 ;
               5915 ; Group 4: (3 opcodes)
               5916 ;
041F57 50      5917 db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
041F58 4F      5918 db 0x4f ; 041F58
041F59 D0      5919 db 0xd0 ; 041F59
041F5A C1      5920 db 0xc1 ; 041F5A
041F5B 50      5921 db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
041F5C 55      5922 db 0x55 ; 041F5C
041F5D 53      5923 db 0x53 ; 041F5D
041F5E C8      5924 db 0xc8 ; 041F5E
041F5F C5      5925 db 0xc5 ; 041F5F
041F60 45      5926 db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
041F61 58      5927 db 0x58 ; 041F61
041F62 00      5928 db 0x00 ; 041F62
041F63 28      5929 db 0x28 ; 041F63
041F64 53      5930 db 0x53 ; 041F64
041F65 D0      5931 db 0xd0 ; 041F65
041F66 E3      5932 db 0xe3 ; 041F66
               5933 ;
               5934 ; Group 5: (7 opcodes)
               5935 ;
041F67 53      5936 db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
041F68 55      5937 db 0x55 ; 041F68
041F69 C2      5938 db 0xc2 ; 041F69
041F6A 90      5939 db 0x90 ; 041F6A
041F6B 41      5940 db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
041F6C 4E      5941 db 0x4e ; 041F6C
041F6D C4      5942 db 0xc4 ; 041F6D
041F6E A0      5943 db 0xa0 ; 041F6E
041F6F 58      5944 db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
041F70 4F      5945 db 0x4f ; 041F70
041F71 D2      5946 db 0xd2 ; 041F71
041F72 A8      5947 db 0xa8 ; 041F72
041F73 4F      5948 db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
041F74 D2      5949 db 0xd2 ; 041F74
041F75 B0      5950 db 0xb0 ; 041F75
041F76 43      5951 db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
041F77 D0      5952 db 0xd0 ; 041F77
041F78 B8      5953 db 0xb8 ; 041F78
041F79 80      5954 db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
041F7A A0      5955 db 0xa0 ; 041F7A
041F7B 84      5956 db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
041F7C B0      5957 db 0xb0 ; 041F7C
               5958 ;
               5959 ; Group 6 (3 opcodes)
               5960 ;
041F7D 41      5961 db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
041F7E 44      5962 db 0x44 ; 041F7E
041F7F C4      5963 db 0xc4 ; 041F7F
041F80 80      5964 db 0x80 ; 041F80
041F81 41      5965 db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
041F82 44      5966 db 0x44 ; 041F82
041F83 C3      5967 db 0xc3 ; 041F83
041F84 88      5968 db 0x88 ; 041F84
041F85 53      5969 db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
041F86 42      5970 db 0x42 ; 041F86
041F87 C3      5971 db 0xc3 ; 041F87
041F88 98      5972 db 0x98 ; 041F88
               5973 ;
               5974 ; Group 7: (2 opcodes)
               5975 ;
041F89 49      5976 db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
041F8A 4E      5977 db 0x4e ; 041F8A
041F8B C3      5978 db 0xc3 ; 041F8B
041F8C 04      5979 db 0x04 ; 041F8C
041F8D 44      5980 db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
041F8E 45      5981 db 0x45 ; 041F8E
041F8F C3      5982 db 0xc3 ; 041F8F
041F90 05      5983 db 0x05 ; 041F90
               5984 ;
               5985 ; Group 8: (2 opcodes)
               5986 ;
041F91 49      5987 db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
041F92 4E      5988 db 0x4e ; 041F92
041F93 B0      5989 db 0xb0 ; 041F93
041F94 00      5990 db 0x00 ; 041F94
041F95 4F      5991 db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
041F96 55      5992 db 0x55 ; 041F96
041F97 54      5993 db 0x54 ; 041F97
041F98 B0      5994 db 0xb0 ; 041F98
041F99 01      5995 db 0x01 ; 041F99
               5996 ;
               5997 ; Group 9: (1 opcode)
               5998 ;
041F9A 49      5999 db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
041F9B CE      6000 db 0xce ; 041F9B
041F9C 40      6001 db 0x40 ; 041F9C
               6002 ;
               6003 ; Group 10: (1 opcode)
               6004 ;
041F9D 4F      6005 db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
041F9E 55      6006 db 0x55 ; 041F9E
041F9F D4      6007 db 0xd4 ; 041F9F
041FA0 41      6008 db 0x41 ; 041FA0
               6009 ;
               6010 ; Group 11: (2 opcodes)
               6011 ;
041FA1 4A      6012 db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
041FA2 D2      6013 db 0xd2 ; 041FA2
041FA3 20      6014 db 0x20 ; 041FA3
041FA4 44      6015 db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
041FA5 4A      6016 db 0x4a ; 041FA5
041FA6 4E      6017 db 0x4e ; 041FA6
041FA7 DA      6018 db 0xda ; 041FA7
041FA8 10      6019 db 0x10 ; 041FA8
               6020 ;
               6021 ; Group 12: (1 opcode)
               6022 ;
041FA9 4A      6023 db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
041FAA D0      6024 db 0xd0 ; 041FAA
041FAB C2      6025 db 0xc2 ; 041FAB
               6026 ;
               6027 ; Group 13: (1 opcode)
               6028 ;
041FAC 43      6029 db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
041FAD 41      6030 db 0x41 ; 041FAD
041FAE 4C      6031 db 0x4c ; 041FAE
041FAF CC      6032 db 0xcc ; 041FAF
041FB0 C4      6033 db 0xc4 ; 041FB0
               6034 ;
               6035 ; Group 14: (1 opcode)
               6036 ;
041FB1 52      6037 db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
041FB2 53      6038 db 0x53 ; 041FB2
041FB3 D4      6039 db 0xd4 ; 041FB3
041FB4 C7      6040 db 0xc7 ; 041FB4
               6041 ;
               6042 ; Group 15: (1 opcode)
               6043 ;
041FB5 52      6044 db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
041FB6 45      6045 db 0x45 ; 041FB6
041FB7 D4      6046 db 0xd4 ; 041FB7
041FB8 C0      6047 db 0xc0 ; 041FB8
               6048 ;
               6049 ; Group 16: (1 opcode)
               6050 ;
041FB9 4C      6051 db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
041FBA C4      6052 db 0xc4 ; 041FBA
041FBB 40      6053 db 0x40 ; 041FBB
               6054 ;
               6055 ; Group 17: (1 opcode)
               6056 ;
041FBC 54      6057 db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
041FBD 53      6058 db 0x53 ; 041FBD
041FBE D4      6059 db 0xd4 ; 041FBE
041FBF 04      6060 db 0x04 ; 041FBF
               6061 ;
               6062 ; Assembler Directives
               6063 ;
041FC0 4F      6064 db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
041FC1 50      6065 db 0x50 ; 041FC1
041FC2 D4      6066 db 0xd4 ; 041FC2
041FC3 00      6067 db 0x00 ; 041FC3
041FC4 41      6068 db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
041FC5 44      6069 db 0x44 ; 041FC5
041FC6 CC      6070 db 0xcc ; 041FC6
041FC7 00      6071 db 0x00 ; 041FC7
041FC8 5D      6072 db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041FC9 C2      6073 db 0xc2 ; 041FC9
041FCA 00      6074 db 0x00 ; 041FCA
041FCB 5D      6075 db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041FCC D7      6076 db 0xd7 ; 041FCC
041FCD 00      6077 db 0x00 ; 041FCD
041FCE 5D      6078 db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041FCF CC      6079 db 0xcc ; 041FCF
041FD0 00      6080 db 0x00 ; 041FD0
041FD1 5D      6081 db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
041FD2 CD      6082 db 0xcd ; 041FD2
041FD3 00      6083 db 0x00 ; 041FD3
041FD4 00      6084 db 0x00 ; 041FD4 00      5426 DB	0
               6085 ;
               6086 ; Operands
               6087 ;
               6088 OPRNDS:
041FD5 C2      6089 db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
041FD6 00      6090 db 0x00 ; 041FD6
041FD7 C3      6091 db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
041FD8 01      6092 db 0x01 ; 041FD8
041FD9 C4      6093 db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
041FDA 02      6094 db 0x02 ; 041FDA
041FDB C5      6095 db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
041FDC 03      6096 db 0x03 ; 041FDC
041FDD C8      6097 db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
041FDE 04      6098 db 0x04 ; 041FDE
041FDF CC      6099 db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
041FE0 05      6100 db 0x05 ; 041FE0
041FE1 28      6101 db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
041FE2 48      6102 db 0x48 ; 041FE2
041FE3 CC      6103 db 0xcc ; 041FE3
041FE4 06      6104 db 0x06 ; 041FE4
041FE5 C1      6105 db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
041FE6 07      6106 db 0x07 ; 041FE6
041FE7 28      6107 db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
041FE8 49      6108 db 0x49 ; 041FE8
041FE9 D8      6109 db 0xd8 ; 041FE9
041FEA 86      6110 db 0x86 ; 041FEA
041FEB 28      6111 db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
041FEC 49      6112 db 0x49 ; 041FEC
041FED D9      6113 db 0xd9 ; 041FED
041FEE C6      6114 db 0xc6 ; 041FEE
041FEF 42      6115 db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
041FF0 C3      6116 db 0xc3 ; 041FF0
041FF1 08      6117 db 0x08 ; 041FF1
041FF2 44      6118 db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
041FF3 C5      6119 db 0xc5 ; 041FF3
041FF4 0A      6120 db 0x0a ; 041FF4
041FF5 48      6121 db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
041FF6 CC      6122 db 0xcc ; 041FF6
041FF7 0C      6123 db 0x0c ; 041FF7
041FF8 49      6124 db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
041FF9 D8      6125 db 0xd8 ; 041FF9
041FFA 8C      6126 db 0x8c ; 041FFA
041FFB 49      6127 db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
041FFC D9      6128 db 0xd9 ; 041FFC
041FFD CC      6129 db 0xcc ; 041FFD
041FFE 41      6130 db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
041FFF C6      6131 db 0xc6 ; 041FFF
042000 0E      6132 db 0x0e ; 042000
042001 53      6133 db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
042002 D0      6134 db 0xd0 ; 042002
042003 0E      6135 db 0x0e ; 042003
042004 4E      6136 db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
042005 DA      6137 db 0xda ; 042005
042006 10      6138 db 0x10 ; 042006
042007 DA      6139 db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
042008 11      6140 db 0x11 ; 042008
042009 4E      6141 db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
04200A C3      6142 db 0xc3 ; 04200A
04200B 12      6143 db 0x12 ; 04200B
04200C 50      6144 db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
04200D CF      6145 db 0xcf ; 04200D
04200E 14      6146 db 0x14 ; 04200E
04200F 50      6147 db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
042010 C5      6148 db 0xc5 ; 042010
042011 15      6149 db 0x15 ; 042011
042012 D0      6150 db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
042013 16      6151 db 0x16 ; 042013
042014 CD      6152 db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
042015 17      6153 db 0x17 ; 042015
042016 28      6154 db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
042017 C3      6155 db 0xc3 ; 042017
042018 20      6156 db 0x20 ; 042018
042019 00      6157 db 0x00 ; 042019 00      5459 DB	0
               6158 ;
               6159 ; Load operations
               6160 ;
               6161 LDOPS:
04201A 49      6162 db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
04201B 00      6163 db 0x00 ; 04201B
04201C C1      6164 db 0xc1 ; 04201C
04201D 47      6165 db 0x47 ; 04201D
04201E 52      6166 db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
04201F 00      6167 db 0x00 ; 04201F
042020 C1      6168 db 0xc1 ; 042020
042021 4F      6169 db 0x4f ; 042021
042022 41      6170 db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
042023 00      6171 db 0x00 ; 042023
042024 C9      6172 db 0xc9 ; 042024
042025 57      6173 db 0x57 ; 042025
042026 41      6174 db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
042027 00      6175 db 0x00 ; 042027
042028 D2      6176 db 0xd2 ; 042028
042029 5F      6177 db 0x5f ; 042029
04202A 28      6178 db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
04202B 42      6179 db 0x42 ; 04202B
04202C 43      6180 db 0x43 ; 04202C
04202D 00      6181 db 0x00 ; 04202D
04202E C1      6182 db 0xc1 ; 04202E
04202F 02      6183 db 0x02 ; 04202F
042030 28      6184 db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
042031 44      6185 db 0x44 ; 042031
042032 45      6186 db 0x45 ; 042032
042033 00      6187 db 0x00 ; 042033
042034 C1      6188 db 0xc1 ; 042034
042035 12      6189 db 0x12 ; 042035
042036 41      6190 db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
042037 00      6191 db 0x00 ; 042037
042038 28      6192 db 0x28 ; 042038
042039 42      6193 db 0x42 ; 042039
04203A C3      6194 db 0xc3 ; 04203A
04203B 0A      6195 db 0x0a ; 04203B
04203C 41      6196 db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
04203D 00      6197 db 0x00 ; 04203D
04203E 28      6198 db 0x28 ; 04203E
04203F 44      6199 db 0x44 ; 04203F
042040 C5      6200 db 0xc5 ; 042040
042041 1A      6201 db 0x1a ; 042041
042042 00      6202 db 0x00 ; 042042 00      5472 DB	0
               6203 ;
               6204 ; eZ80 addressing mode suffixes
               6205 ;
               6206 ; Fully qualified suffixes
               6207 ;
               6208 EZ80SFS_1:
042043 4C      6209 db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
042044 49      6210 db 0x49 ; 042044
042045 D3      6211 db 0xd3 ; 042045
042046 49      6212 db 0x49 ; 042046
042047 53      6213 db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
042048 49      6214 db 0x49 ; 042048
042049 CC      6215 db 0xcc ; 042049
04204A 52      6216 db 0x52 ; 04204A
               6217 
               6218 EZ80SFS_2:
04204B 53      6219 db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
04204C 49      6220 db 0x49 ; 04204C
04204D D3      6221 db 0xd3 ; 04204D
04204E 40      6222 db 0x40 ; 04204E
04204F 4C      6223 db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
042050 49      6224 db 0x49 ; 042050
042051 CC      6225 db 0xcc ; 042051
042052 5B      6226 db 0x5b ; 042052
042053 00      6227 db 0x00 ; 042053 00      5483 DB	0
               6228 ;
               6229 ; Shortcuts when ADL mode is 0
               6230 ;
               6231 EZ80SFS_ADL0:
042054 D3      6232 db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042055 40      6233 db 0x40 ; 042055
042056 CC      6234 db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
042057 49      6235 db 0x49 ; 042057
042058 49      6236 db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
042059 D3      6237 db 0xd3 ; 042059
04205A 40      6238 db 0x40 ; 04205A
04205B 49      6239 db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
04205C CC      6240 db 0xcc ; 04205C
04205D 52      6241 db 0x52 ; 04205D
04205E 00      6242 db 0x00 ; 04205E 00      5492 DB	0
               6243 ;
               6244 ; Shortcuts when ADL mode is 1
               6245 ;
               6246 EZ80SFS_ADL1:
04205F D3      6247 db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042060 52      6248 db 0x52 ; 042060
042061 CC      6249 db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
042062 5B      6250 db 0x5b ; 042062
042063 49      6251 db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
042064 D3      6252 db 0xd3 ; 042064
042065 49      6253 db 0x49 ; 042065
042066 49      6254 db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
042067 CC      6255 db 0xcc ; 042067
042068 5B      6256 db 0x5b ; 042068
042069 00      6257 db 0x00 ; 042069 00      5501 DB	0
               6258 ; END INSERT FROM BINARY
               6259 ;
               6260 ; .LIST
               6261 ;
               6262 ; already defined in equs.inc
               6263 ; LF:			EQU     0AH
               6264 ; CR:			EQU     0DH; --- End exec.asm ---
               6265 
               6266 ; --- Begin fpp.asm ---
               6267 ;
               6268 ; Title:	BBC Basic Interpreter - Z80 version
               6269 ;		Z80 Floating Point Package
               6270 ; Author:	(C) Copyright  R.T.Russell  1986
               6271 ; Modified By:	Dean Belfield
               6272 ; Created:	03/05/2022
               6273 ; Last Updated:	07/06/2023
               6274 ;
               6275 ; Modinfo:
               6276 ; 26/10/1986:	Version 0.0
               6277 ; 14/12/1988:	Vesion 0.1 (Bug Fix)
               6278 ; 12/05/2023:	Modified by Dean Belfield
               6279 ; 07/06/2023:	Modified to run in ADL mode
               6280 
               6281 ; .ASSUME	ADL = 1
               6282 
               6283 ; SEGMENT CODE
               6284 
               6285 ; XDEF	FPP
               6286 ; XDEF	DLOAD5
               6287 ; XDEF	DLOAD5_SPL
               6288 ;
               6289 ;BINARY FLOATING POINT REPRESENTATION:
               6290 ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               6291 ;    8 BIT EXCESS-128 SIGNED EXPONENT
               6292 ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               6293 ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               6294 ;
               6295 ;BINARY INTEGER REPRESENTATION:
               6296 ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               6297 ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
               6298 ;
               6299 ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               6300 ;                            EXPONENT - C
               6301 ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
               6302 ;                               EXPONENT - B
               6303 
               6304 ;
               6305 ;Error codes:
               6306 ;
               6307 
               6308 BADOP:			EQU     1               ;Bad operation code
               6309 DIVBY0:			EQU     18              ;Division by zero
               6310 TOOBIG_FP:			EQU     20              ;Too big
               6311 NGROOT:			EQU     21              ;Negative root
               6312 LOGRNG:			EQU     22              ;Log range
               6313 ACLOST:			EQU     23              ;Accuracy lost
               6314 EXPRNG:			EQU     24              ;Exp range
               6315 ;
               6316 ;Call entry and despatch code:
               6317 ;
04206A FD      6318 FPP:			PUSH    IY              ;Save IY
04206B E5 
04206C FD      6319 LD      IY,0
04206D 21 
04206E 00 
04206F 00 
04206F 00   
042071 FD      6320 ADD     IY,SP           ;Save SP in IY
042072 39 
042073 CD      6321 CALL    OP              ;Perform operation
042074 83 
042075 20 
042076 04 
042077 BF      6322 CP      A               ;Good return (Z, NC)
042078 FD      6323 EXIT_FP_:			POP     IY              ;Restore IY
042079 E1 
04207A C9      6324 RET                     ;Return to caller
               6325 ;
               6326 ;Error exit:
               6327 ;
04207B 3E      6328 BAD_FP:			LD      A,BADOP         ;"Bad operation code"
04207C 01 
04207D FD      6329 ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
04207E F9 
04207F B7      6330 OR      A               ;Set NZ
042080 37      6331 SCF                     ;Set C
042081 18      6332 JR      EXIT_FP_
042082 F5 
               6333 ;
               6334 ;Perform operation or function:
               6335 ;
               6336 ; OP:			CP      (RTABLE-DTABLE)/3
042083 FE      6337 OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042084 2A 
               6338 
042085 30      6339 JR      NC,BAD_FP
042086 F4 
               6340 ; CP      (FTABLE-DTABLE)/3
042087 FE      6341 CP      FTABLE-DTABLE/3 ; ditto
042088 10 
042089 30      6342 JR      NC,DISPAT_FP
04208A 08 
04208B 08      6343 EX      AF,AF'
04208C 78      6344 LD      A,B
04208D B1      6345 OR      C               ;Both integer?
04208E C4      6346 CALL    NZ,FLOATA       ;No, so float both
04208F 96 
042090 2B 
042091 04 
042092 08      6347 EX      AF,AF'
042093 E5      6348 DISPAT_FP:			PUSH    HL
042094 21      6349 LD      HL,DTABLE
042095 A6 
042096 20 
042097 04 
042098 C5      6350 PUSH    BC
042099 01      6351 LD	BC, 3		; C = 3
04209A 03 
04209B 00 
04209C 00 
04209D 47      6352 LD	B, A 		; B = op-code
04209E ED      6353 MLT 	BC 		;BC = op-code * 3
04209F 4C 
0420A0 09      6354 ADD	HL, BC 		;Add to table base
0420A1 ED      6355 LD	HL, (HL)	;Get the routine address (24-bit)
0420A2 27 
               6356 
               6357 ;        		ADD     A, A            ;A = op-code * 2
               6358 ;        		LD      C,A
               6359 ;        		LD      B,0             ;BC = op-code * 2
               6360 ;        		ADD     HL,BC
               6361 ;        		LD      A,(HL)          ;Get low byte
               6362 ;        		INC     HL
               6363 ;        		LD      H,(HL)          ;Get high byte
               6364 ;        		LD      L,A
               6365 
0420A3 C1      6366 POP     BC
0420A4 E3      6367 EX      (SP),HL
0420A5 C9      6368 RET                     ;Off to routine
               6369 ;
               6370 ;Despatch table:
               6371 ;
0420A6 58      6372 DTABLE:			DW24  IAND            ;AND (INTEGER)
0420A7 21 
0420A8 04 
0420A9 C6      6373 DW24  IBDIV           ;DIV
0420AA 21 
0420AB 04 
0420AC 6B      6374 DW24  IEOR            ;EOR
0420AD 21 
0420AE 04 
0420AF 91      6375 DW24  IMOD            ;MOD
0420B0 21 
0420B1 04 
0420B2 7E      6376 DW24  IOR             ;OR
0420B3 21 
0420B4 04 
0420B5 4C      6377 DW24  ILE             ;<=
0420B6 24 
0420B7 04 
0420B8 5B      6378 DW24  INE             ;<>
0420B9 24 
0420BA 04 
0420BB 3F      6379 DW24  IGE             ;>=
0420BC 24 
0420BD 04 
0420BE 24      6380 DW24  ILT             ;<
0420BF 24 
0420C0 04 
0420C1 68      6381 DW24  IEQ             ;=
0420C2 24 
0420C3 04 
0420C4 B4      6382 DW24  IMUL            ;*
0420C5 22 
0420C6 04 
0420C7 EF      6383 DW24  IADD            ;+
0420C8 21 
0420C9 04 
0420CA 31      6384 DW24  IGT             ;>
0420CB 24 
0420CC 04 
0420CD D6      6385 DW24  ISUB            ;-
0420CE 21 
0420CF 04 
0420D0 6B      6386 DW24  IPOW            ;^
0420D1 23 
0420D2 04 
0420D3 61      6387 DW24  IDIV            ;/
0420D4 22 
0420D5 04 
               6388 ;
               6389 FTABLE:
0420D6 7A      6390 DW24  ABSV_FP            ;ABS
0420D7 24 
0420D8 04 
0420D9 60      6391 DW24  ACS_FP             ;ACS
0420DA 28 
0420DB 04 
0420DC 9E      6392 DW24  ASN_FP             ;ASN
0420DD 27 
0420DE 04 
0420DF CE      6393 DW24  ATN_FP             ;ATN
0420E0 27 
0420E1 04 
0420E2 99      6394 DW24  COS_FP             ;COS
0420E3 25 
0420E4 04 
0420E5 A8      6395 DW24  DEG_FP             ;DEG
0420E6 24 
0420E7 04 
0420E8 55      6396 DW24  EXP_FP             ;EXP
0420E9 26 
0420EA 04 
0420EB FC      6397 DW24  INT_FP_            ;INT
0420EC 24 
0420ED 04 
0420EE F3      6398 DW24  LN_FP              ;LN
0420EF 26 
0420F0 04 
0420F1 88      6399 DW24  LOG_FP             ;LOG
0420F2 27 
0420F3 04 
0420F4 86      6400 DW24  NOTK_FP            ;NOT
0420F5 24 
0420F6 04 
0420F7 B2      6401 DW24  RAD_FP             ;RAD
0420F8 24 
0420F9 04 
0420FA CD      6402 DW24  SGN_FP             ;SGN
0420FB 24 
0420FC 04 
0420FD A6      6403 DW24  SIN_FP             ;SIN
0420FE 25 
0420FF 04 
042100 15      6404 DW24  SQR_FP             ;SQR
042101 25 
042102 04 
042103 73      6405 DW24  TAN_FP             ;TAN
042104 25 
042105 04 
               6406 ;
042106 23      6407 DW24  ZERO_FP            ;ZERO
042107 2C 
042108 04 
042109 2E      6408 DW24  FONE_FP            ;FONE
04210A 26 
04210B 04 
04210C 6D      6409 DW24  TRUE_FP            ;TRUE
04210D 24 
04210E 04 
04210F 9A      6410 DW24  PI_FP              ;PI
042110 24 
042111 04 
               6411 ;
042112 E1      6412 DW24  VAL_FP             ;VAL
042113 24 
042114 04 
042115 69      6413 DW24  STR_FP             ;STR$
042116 28 
042117 04 
               6414 ;
042118 CA      6415 DW24  SFIX_FP            ;FIX
042119 2A 
04211A 04 
04211B A6      6416 DW24  SFLOAT_FP          ;FLOAT
04211C 2B 
04211D 04 
               6417 ;
04211E F4      6418 DW24  FTEST_FP           ;TEST
04211F 2B 
042120 04 
042121 06      6419 DW24  FCOMP_FP           ;COMPARE
042122 2C 
042123 04 
               6420 ;
042124 54      6421 RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042125 21 
042126 04 
042127 C2      6422 DW24  FBDIV           ;DIV
042128 21 
042129 04 
04212A 67      6423 DW24  FEOR            ;EOR
04212B 21 
04212C 04 
04212D 8D      6424 DW24  FMOD            ;MOD
04212E 21 
04212F 04 
042130 7A      6425 DW24  FFOR             ;OR
042131 21 
042132 04 
042133 46      6426 DW24  FLE             ;<=
042134 24 
042135 04 
042136 55      6427 DW24  FNE             ;<>
042137 24 
042138 04 
042139 39      6428 DW24  FGE             ;>=
04213A 24 
04213B 04 
04213C 1E      6429 DW24  FLT             ;<
04213D 24 
04213E 04 
04213F 62      6430 DW24  FEQ             ;=
042140 24 
042141 04 
042142 0E      6431 DW24  FMUL            ;*
042143 23 
042144 04 
042145 FC      6432 DW24  FADD            ;+
042146 21 
042147 04 
042148 2B      6433 DW24  FGT             ;>
042149 24 
04214A 04 
04214B E3      6434 DW24  FSUB            ;-
04214C 21 
04214D 04 
04214E EB      6435 DW24  FPOW            ;^
04214F 23 
042150 04 
042151 65      6436 DW24  FDIV            ;/
042152 22 
042153 04 
               6437 ;
               6438 ;       PAGE
               6439 ;
               6440 ;ARITHMETIC AND LOGICAL OPERATORS:
               6441 ;All take two arguments, in HLH'L'C & DED'E'B.
               6442 ;Output in HLH'L'C
               6443 ;All registers except IX, IY destroyed.
               6444 ; (N.B. FPOW destroys IX).
               6445 ;
               6446 ;FAND - Floating-point AND.
               6447 ;IAND - Integer AND.
               6448 ;
042154 CD      6449 FAND:			CALL    FIX2
042155 BE 
042156 2A 
042157 04 
042158 7C      6450 IAND:			LD      A,H
042159 A2      6451 AND     D
04215A 67      6452 LD      H,A
04215B 7D      6453 LD      A,L
04215C A3      6454 AND     E
04215D 6F      6455 LD      L,A
04215E D9      6456 EXX
04215F 7C      6457 LD      A,H
042160 A2      6458 AND     D
042161 67      6459 LD      H,A
042162 7D      6460 LD      A,L
042163 A3      6461 AND     E
042164 6F      6462 LD      L,A
042165 D9      6463 EXX
042166 C9      6464 RET
               6465 ;
               6466 ;FEOR - Floating-point exclusive-OR.
               6467 ;IEOR - Integer exclusive-OR.
               6468 ;
042167 CD      6469 FEOR:			CALL    FIX2
042168 BE 
042169 2A 
04216A 04 
04216B 7C      6470 IEOR:			LD      A,H
04216C AA      6471 XOR     D
04216D 67      6472 LD      H,A
04216E 7D      6473 LD      A,L
04216F AB      6474 XOR     E
042170 6F      6475 LD      L,A
042171 D9      6476 EXX
042172 7C      6477 LD      A,H
042173 AA      6478 XOR     D
042174 67      6479 LD      H,A
042175 7D      6480 LD      A,L
042176 AB      6481 XOR     E
042177 6F      6482 LD      L,A
042178 D9      6483 EXX
042179 C9      6484 RET
               6485 ;
               6486 ;FOR - Floating-point OR.
               6487 ;IOR - Integer OR.
               6488 ;
04217A CD      6489 FFOR:			CALL    FIX2
04217B BE 
04217C 2A 
04217D 04 
04217E 7C      6490 IOR:			LD      A,H
04217F B2      6491 OR      D
042180 67      6492 LD      H,A
042181 7D      6493 LD      A,L
042182 B3      6494 OR      E
042183 6F      6495 LD      L,A
042184 D9      6496 EXX
042185 7C      6497 LD      A,H
042186 B2      6498 OR      D
042187 67      6499 LD      H,A
042188 7D      6500 LD      A,L
042189 B3      6501 OR      E
04218A 6F      6502 LD      L,A
04218B D9      6503 EXX
04218C C9      6504 RET
               6505 ;
               6506 ;FMOD - Floating-point remainder.
               6507 ;IMOD - Integer remainder.
               6508 ;
04218D CD      6509 FMOD:			CALL    FIX2
04218E BE 
04218F 2A 
042190 04 
042191 7C      6510 IMOD:			LD      A,H
042192 AA      6511 XOR     D               ;DIV RESULT SIGN
042193 CB      6512 BIT     7,H
042194 7C 
042195 08      6513 EX      AF,AF'
042196 CB      6514 BIT     7,H
042197 7C 
042198 C4      6515 CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
042199 DA 
04219A 2A 
04219B 04 
04219C CD      6516 CALL    SWAP_FP
04219D D7 
04219E 2B 
04219F 04 
0421A0 CB      6517 BIT     7,H
0421A1 7C 
0421A2 C4      6518 CALL    NZ,NEGATE
0421A3 DA 
0421A4 2A 
0421A5 04 
0421A6 44      6519 LD      B,H
0421A7 4D      6520 LD      C,L
0421A8 21      6521 LD      HL,0
0421A9 00 
0421AA 00 
0421AB 00 
0421AC D9      6522 EXX
0421AD 44      6523 LD      B,H
0421AE 4D      6524 LD      C,L
0421AF 21      6525 LD      HL,0
0421B0 00 
0421B1 00 
0421B2 00 
0421B3 3E      6526 LD      A,-33
0421B4 DF 
0421B5 CD      6527 CALL    DIVA            ;DIVIDE
0421B6 64 
0421B7 2D 
0421B8 04 
0421B9 D9      6528 EXX
0421BA 0E      6529 LD      C,0             ;INTEGER MARKER
0421BB 00 
0421BC 08      6530 EX      AF,AF'
0421BD C8      6531 RET     Z
0421BE C3      6532 JP      NEGATE
0421BF DA 
0421C0 2A 
0421C1 04 
               6533 ;
               6534 ;BDIV - Integer division.
               6535 ;
0421C2 CD      6536 FBDIV:			CALL    FIX2
0421C3 BE 
0421C4 2A 
0421C5 04 
0421C6 CD      6537 IBDIV:			CALL    IMOD
0421C7 91 
0421C8 21 
0421C9 04 
0421CA B7      6538 OR      A
0421CB CD      6539 CALL    SWAP_FP
0421CC D7 
0421CD 2B 
0421CE 04 
0421CF 0E      6540 LD      C,0
0421D0 00 
0421D1 F0      6541 RET     P
0421D2 C3      6542 JP      NEGATE
0421D3 DA 
0421D4 2A 
0421D5 04 
               6543 ;
               6544 ;ISUB - Integer subtraction.
               6545 ;FSUB - Floating point subtraction with rounding.
               6546 ;
0421D6 CD      6547 ISUB:			CALL    SUB_
0421D7 72 
0421D8 2C 
0421D9 04 
0421DA E0      6548 RET     PO
0421DB CD      6549 CALL    ADD_
0421DC 6A 
0421DD 2C 
0421DE 04 
0421DF CD      6550 CALL    FLOAT2
0421E0 9A 
0421E1 2B 
0421E2 04 
0421E3 7A      6551 FSUB:			LD      A,D
0421E4 EE      6552 XOR     80H             ;CHANGE SIGN THEN ADD
0421E5 80 
0421E6 57      6553 LD      D,A
0421E7 18      6554 JR      FADD
0421E8 13 
               6555 ;
               6556 ;Reverse subtract.
               6557 ;
0421E9 7C      6558 RSUB:			LD      A,H
0421EA EE      6559 XOR     80H
0421EB 80 
0421EC 67      6560 LD      H,A
0421ED 18      6561 JR      FADD
0421EE 0D 
               6562 ;
               6563 ;IADD - Integer addition.
               6564 ;FADD - Floating point addition with rounding.
               6565 ;
0421EF CD      6566 IADD:			CALL    ADD_
0421F0 6A 
0421F1 2C 
0421F2 04 
0421F3 E0      6567 RET     PO
0421F4 CD      6568 CALL    SUB_
0421F5 72 
0421F6 2C 
0421F7 04 
0421F8 CD      6569 CALL    FLOAT2
0421F9 9A 
0421FA 2B 
0421FB 04 
0421FC 05      6570 FADD:			DEC     B
0421FD 04      6571 INC     B
0421FE C8      6572 RET     Z               ;ARG 2 ZERO
0421FF 0D      6573 DEC     C
042200 0C      6574 INC     C
042201 CA      6575 JP      Z,SWAP_FP          ;ARG 1 ZERO
042202 D7 
042203 2B 
042204 04 
042205 D9      6576 EXX
042206 01      6577 LD      BC,0            ;INITIALISE
042207 00 
042208 00 
042209 00 
04220A D9      6578 EXX
04220B 7C      6579 LD      A,H
04220C AA      6580 XOR     D               ;XOR SIGNS
04220D F5      6581 PUSH    AF
04220E 78      6582 LD      A,B
04220F B9      6583 CP      C               ;COMPARE EXPONENTS
042210 DC      6584 CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042211 D7 
042212 2B 
042213 04 
042214 78      6585 LD      A,B
042215 CB      6586 SET     7,H             ;IMPLIED 1
042216 FC 
042217 C4      6587 CALL    NZ,FIX          ;ALIGN
042218 AB 
042219 2A 
04221A 04 
04221B F1      6588 POP     AF
04221C 7A      6589 LD      A,D             ;SIGN OF LARGER
04221D CB      6590 SET     7,D             ;IMPLIED 1
04221E FA 
04221F FA      6591 JP      M,FADD3         ;SIGNS DIFFERENT
042220 2F 
042221 22 
042222 04 
042223 CD      6592 CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
042224 6A 
042225 2C 
042226 04 
042227 DC      6593 CALL    C,DIV2          ;NORMALISE
042228 DF 
042229 2B 
04222A 04 
04222B CB      6594 SET     7,H
04222C FC 
04222D 18      6595 JR      FADD4
04222E 0D 
               6596 ;
04222F CD      6597 FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042230 72 
042231 2C 
042232 04 
042233 DC      6598 CALL    C,NEG_           ;NEGATE HLH'L'B'C'
042234 F2 
042235 2A 
042236 04 
042237 CD      6599 CALL    FLO48
042238 71 
042239 2B 
04223A 04 
04223B 2F      6600 CPL                     ;CHANGE RESULT SIGN
04223C D9      6601 FADD4:			EXX
04223D EB      6602 EX      DE,HL
04223E 21      6603 LD      HL,8000H
04223F 00 
042240 80 
042241 00 
042242 B7      6604 OR      A               ;CLEAR CARRY
042243 52      6605 SBC.S   HL,BC
042244 ED 
042245 42 
042246 EB      6606 EX      DE,HL
042247 D9      6607 EXX
042248 CC      6608 CALL    Z,ODD           ;ROUND UNBIASSED
042249 D1 
04224A 2B 
04224B 04 
04224C DC      6609 CALL    C,ADD1_FP          ;ROUND UP
04224D BF 
04224E 2B 
04224F 04 
042250 DC      6610 CALL    C,INCC
042251 EC 
042252 2B 
042253 04 
042254 CB      6611 RES     7,H
042255 BC 
042256 0D      6612 DEC     C
042257 0C      6613 INC     C
042258 CA      6614 JP      Z,ZERO_FP
042259 23 
04225A 2C 
04225B 04 
04225C B7      6615 OR      A               ;RESULT SIGNQ
04225D F0      6616 RET     P               ;POSITIVE
04225E CB      6617 SET     7,H             ;NEGATIVE
04225F FC 
042260 C9      6618 RET
               6619 ;
               6620 ;IDIV - Integer division.
               6621 ;FDIV - Floating point division with rounding.
               6622 ;
042261 CD      6623 IDIV:			CALL    FLOAT2
042262 9A 
042263 2B 
042264 04 
042265 05      6624 FDIV:			DEC     B               ;TEST FOR ZERO
042266 04      6625 INC     B
042267 3E      6626 LD      A,DIVBY0
042268 12 
042269 CA      6627 JP      Z,ERROR_FP_         ;"Division by zero"
04226A 7D 
04226B 20 
04226C 04 
04226D 0D      6628 DEC     C               ;TEST FOR ZERO
04226E 0C      6629 INC     C
04226F C8      6630 RET     Z
042270 7C      6631 LD      A,H
042271 AA      6632 XOR     D               ;CALC. RESULT SIGN
042272 08      6633 EX      AF,AF'          ;SAVE SIGN
042273 CB      6634 SET     7,D             ;REPLACE IMPLIED 1's
042274 FA 
042275 CB      6635 SET     7,H
042276 FC 
042277 C5      6636 PUSH    BC              ;SAVE EXPONENTS
042278 42      6637 LD      B,D             ;LOAD REGISTERS
042279 4B      6638 LD      C,E
04227A 11      6639 LD      DE,0
04227B 00 
04227C 00 
04227D 00 
04227E D9      6640 EXX
04227F 42      6641 LD      B,D
042280 4B      6642 LD      C,E
042281 11      6643 LD      DE,0
042282 00 
042283 00 
042284 00 
042285 3E      6644 LD      A,-32           ;LOOP COUNTER
042286 E0 
042287 CD      6645 CALL    DIVA            ;DIVIDE
042288 64 
042289 2D 
04228A 04 
04228B D9      6646 EXX
04228C CB      6647 BIT     7,D
04228D 7A 
04228E D9      6648 EXX
04228F CC      6649 CALL    Z,DIVB          ;NORMALISE & INC A
042290 83 
042291 2D 
042292 04 
042293 EB      6650 EX      DE,HL
042294 D9      6651 EXX
042295 CB      6652 SRL     B               ;DIVISOR/2
042296 38 
042297 CB      6653 RR      C
042298 19 
042299 B7      6654 OR      A               ;CLEAR CARRY
04229A 52      6655 SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
04229B ED 
04229C 42 
04229D 3F      6656 CCF
04229E EB      6657 EX      DE,HL           ;RESULT IN HLH'L'
04229F CC      6658 CALL    Z,ODD           ;ROUND UNBIASSED
0422A0 D1 
0422A1 2B 
0422A2 04 
0422A3 DC      6659 CALL    C,ADD1_FP          ;ROUND UP
0422A4 BF 
0422A5 2B 
0422A6 04 
0422A7 C1      6660 POP     BC              ;RESTORE EXPONENTS
0422A8 DC      6661 CALL    C,INCC
0422A9 EC 
0422AA 2B 
0422AB 04 
0422AC 1F      6662 RRA                     ;LSB OF A TO CARRY
0422AD 79      6663 LD      A,C             ;COMPUTE NEW EXPONENT
0422AE 98      6664 SBC     A,B
0422AF 3F      6665 CCF
0422B0 C3      6666 JP      CHKOVF
0422B1 51 
0422B2 23 
0422B3 04 
               6667 ;
               6668 ;IMUL - Integer multiplication.
               6669 ;
0422B4 7C      6670 IMUL:			LD      A,H
0422B5 AA      6671 XOR     D
0422B6 08      6672 EX      AF,AF'          ;SAVE RESULT SIGN
0422B7 CB      6673 BIT     7,H
0422B8 7C 
0422B9 C4      6674 CALL    NZ,NEGATE
0422BA DA 
0422BB 2A 
0422BC 04 
0422BD CD      6675 CALL    SWAP_FP
0422BE D7 
0422BF 2B 
0422C0 04 
0422C1 CB      6676 BIT     7,H
0422C2 7C 
0422C3 C4      6677 CALL    NZ,NEGATE
0422C4 DA 
0422C5 2A 
0422C6 04 
0422C7 44      6678 LD      B,H
0422C8 4D      6679 LD      C,L
0422C9 21      6680 LD      HL,0
0422CA 00 
0422CB 00 
0422CC 00 
0422CD D9      6681 EXX
0422CE 44      6682 LD      B,H
0422CF 4D      6683 LD      C,L
0422D0 21      6684 LD      HL,0
0422D1 00 
0422D2 00 
0422D3 00 
0422D4 3E      6685 LD      A,-33
0422D5 DF 
0422D6 CD      6686 CALL    MULA            ;MULTIPLY
0422D7 9B 
0422D8 2D 
0422D9 04 
0422DA D9      6687 EXX
0422DB 0E      6688 LD      C,191           ;PRESET EXPONENT
0422DC BF 
0422DD CD      6689 CALL    TEST_FP            ;TEST RANGE
0422DE FF 
0422DF 2B 
0422E0 04 
0422E1 20      6690 JR      NZ,IMUL1        ;TOO BIG
0422E2 0F 
0422E3 CB      6691 BIT     7,D
0422E4 7A 
0422E5 20      6692 JR      NZ,IMUL1
0422E6 0B 
0422E7 CD      6693 CALL    SWAP_FP
0422E8 D7 
0422E9 2B 
0422EA 04 
0422EB 4A      6694 LD      C,D             ;INTEGER MARKER
0422EC 08      6695 EX      AF,AF'
0422ED F0      6696 RET     P
0422EE C3      6697 JP      NEGATE
0422EF DA 
0422F0 2A 
0422F1 04 
               6698 ;
0422F2 0D      6699 IMUL1:			DEC     C
0422F3 D9      6700 EXX
0422F4 CB      6701 SLA     E
0422F5 23 
0422F6 CB      6702 RL      D
0422F7 12 
0422F8 D9      6703 EXX
0422F9 CB      6704 RL      E
0422FA 13 
0422FB CB      6705 RL      D
0422FC 12 
0422FD D9      6706 EXX
0422FE 52      6707 ADC.S   HL,HL
0422FF ED 
042300 6A 
042301 D9      6708 EXX
042302 52      6709 ADC.S   HL,HL
042303 ED 
042304 6A 
042305 F2      6710 JP      P,IMUL1         ;NORMALISE
042306 F2 
042307 22 
042308 04 
042309 08      6711 EX      AF,AF'
04230A F8      6712 RET     M
04230B CB      6713 RES     7,H             ;POSITIVE
04230C BC 
04230D C9      6714 RET
               6715 ;
               6716 ;FMUL - Floating point multiplication with rounding.
               6717 ;
04230E 05      6718 FMUL:			DEC     B               ;TEST FOR ZERO
04230F 04      6719 INC     B
042310 CA      6720 JP      Z,ZERO_FP
042311 23 
042312 2C 
042313 04 
042314 0D      6721 DEC     C               ;TEST FOR ZERO
042315 0C      6722 INC     C
042316 C8      6723 RET     Z
042317 7C      6724 LD      A,H
042318 AA      6725 XOR     D               ;CALC. RESULT SIGN
042319 08      6726 EX      AF,AF'
04231A CB      6727 SET     7,D             ;REPLACE IMPLIED 1's
04231B FA 
04231C CB      6728 SET     7,H
04231D FC 
04231E C5      6729 PUSH    BC              ;SAVE EXPONENTS
04231F 44      6730 LD      B,H             ;LOAD REGISTERS
042320 4D      6731 LD      C,L
042321 21      6732 LD      HL,0
042322 00 
042323 00 
042324 00 
042325 D9      6733 EXX
042326 44      6734 LD      B,H
042327 4D      6735 LD      C,L
042328 21      6736 LD      HL,0
042329 00 
04232A 00 
04232B 00 
04232C 3E      6737 LD      A,-32           ;LOOP COUNTER
04232D E0 
04232E CD      6738 CALL    MULA            ;MULTIPLY
04232F 9B 
042330 2D 
042331 04 
042332 DC      6739 CALL    C,MULB          ;NORMALISE & INC A
042333 B1 
042334 2D 
042335 04 
042336 D9      6740 EXX
042337 E5      6741 PUSH    HL
042338 21      6742 LD      HL,8000H
042339 00 
04233A 80 
04233B 00 
04233C B7      6743 OR      A               ;CLEAR CARRY
04233D 52      6744 SBC.S   HL,DE
04233E ED 
04233F 52 
042340 E1      6745 POP     HL
042341 CC      6746 CALL    Z,ODD           ;ROUND UNBIASSED
042342 D1 
042343 2B 
042344 04 
042345 DC      6747 CALL    C,ADD1_FP          ;ROUND UP
042346 BF 
042347 2B 
042348 04 
042349 C1      6748 POP     BC              ;RESTORE EXPONENTS
04234A DC      6749 CALL    C,INCC
04234B EC 
04234C 2B 
04234D 04 
04234E 1F      6750 RRA                     ;LSB OF A TO CARRY
04234F 79      6751 LD      A,C             ;COMPUTE NEW EXPONENT
042350 88      6752 ADC     A,B
042351 38      6753 CHKOVF:			JR      C,CHKO1
042352 06 
042353 F2      6754 JP      P,ZERO_FP          ;UNDERFLOW
042354 23 
042355 2C 
042356 04 
042357 18      6755 JR      CHKO2
042358 04 
042359 FA      6756 CHKO1:			JP      M,OFLOW         ;OVERFLOW
04235A EE 
04235B 2B 
04235C 04 
04235D C6      6757 CHKO2:			ADD     A,80H
04235E 80 
04235F 4F      6758 LD      C,A
042360 CA      6759 JP      Z,ZERO_FP
042361 23 
042362 2C 
042363 04 
042364 08      6760 EX      AF,AF'          ;RESTORE SIGN BIT
042365 CB      6761 RES     7,H
042366 BC 
042367 F0      6762 RET     P
042368 CB      6763 SET     7,H
042369 FC 
04236A C9      6764 RET
               6765 ;
               6766 ;IPOW - Integer involution.
               6767 ;
04236B CD      6768 IPOW:			CALL    SWAP_FP
04236C D7 
04236D 2B 
04236E 04 
04236F CB      6769 BIT     7,H
042370 7C 
042371 F5      6770 PUSH    AF              ;SAVE SIGN
042372 C4      6771 CALL    NZ,NEGATE
042373 DA 
042374 2A 
042375 04 
042376 48      6772 IPOW0:			LD      C,B
042377 06      6773 LD      B,32            ;LOOP COUNTER
042378 20 
042379 CD      6774 IPOW1:			CALL    X2
04237A 8F 
04237B 2C 
04237C 04 
04237D 38      6775 JR      C,IPOW2
04237E 08 
04237F 10      6776 DJNZ    IPOW1
042380 F8 
042381 F1      6777 POP     AF
042382 D9      6778 EXX
042383 2C      6779 INC     L               ;RESULT=1
042384 D9      6780 EXX
042385 4C      6781 LD      C,H
042386 C9      6782 RET
               6783 ;
042387 F1      6784 IPOW2:			POP     AF
042388 C5      6785 PUSH    BC
042389 EB      6786 EX      DE,HL
04238A E5      6787 PUSH    HL
04238B D9      6788 EXX
04238C EB      6789 EX      DE,HL
04238D E5      6790 PUSH    HL
04238E D9      6791 EXX
04238F DD      6792 LD      IX,0
042390 21 
042391 00 
042392 00 
042392 00   
042394 DD      6793 ADD     IX,SP
042395 39 
042396 28      6794 JR      Z,IPOW4
042397 48 
042398 C5      6795 PUSH    BC
042399 D9      6796 EXX
04239A D5      6797 PUSH    DE
04239B D9      6798 EXX
04239C D5      6799 PUSH    DE
04239D CD      6800 CALL    SFLOAT_FP
04239E A6 
04239F 2B 
0423A0 04 
0423A1 CD      6801 CALL    RECIP
0423A2 DA 
0423A3 26 
0423A4 04 
0423A5 DD      6802 LD      (IX+4),C
0423A6 71 
0423A7 04 
0423A8 D9      6803 EXX
0423A9 DD      6804 LD      (IX+0),L
0423AA 75 
0423AB 00 
0423AC DD      6805 LD      (IX+1),H
0423AD 74 
0423AE 01 
0423AF D9      6806 EXX
0423B0 DD      6807 LD      (IX+2),L
0423B1 75 
0423B2 02 
0423B3 DD      6808 LD      (IX+3),H
0423B4 74 
0423B5 03 
0423B6 18      6809 JR      IPOW5
0423B7 21 
               6810 ;
0423B8 C5      6811 IPOW3:			PUSH    BC
0423B9 D9      6812 EXX
0423BA CB      6813 SLA     E
0423BB 23 
0423BC CB      6814 RL      D
0423BD 12 
0423BE D5      6815 PUSH    DE
0423BF D9      6816 EXX
0423C0 CB      6817 RL      E
0423C1 13 
0423C2 CB      6818 RL      D
0423C3 12 
0423C4 D5      6819 PUSH    DE
0423C5 3E      6820 LD      A,'*' & 0FH
0423C6 0A 
0423C7 F5      6821 PUSH    AF
0423C8 CD      6822 CALL    COPY_
0423C9 A3 
0423CA 2C 
0423CB 04 
0423CC CD      6823 CALL    OP              ;SQUARE
0423CD 83 
0423CE 20 
0423CF 04 
0423D0 F1      6824 POP     AF
0423D1 CD      6825 CALL    DLOAD5
0423D2 CF 
0423D3 29 
0423D4 04 
0423D5 DC      6826 CALL    C,OP            ;MULTIPLY BY X
0423D6 83 
0423D7 20 
0423D8 04 
0423D9 D1      6827 IPOW5:			POP     DE
0423DA D9      6828 EXX
0423DB D1      6829 POP     DE
0423DC D9      6830 EXX
0423DD 79      6831 LD      A,C
0423DE C1      6832 POP     BC
0423DF 4F      6833 LD      C,A
0423E0 10      6834 IPOW4:			DJNZ    IPOW3
0423E1 D6 
0423E2 F1      6835 POP     AF
0423E3 F1      6836 POP     AF
0423E4 F1      6837 POP     AF
0423E5 C9      6838 RET
               6839 ;
0423E6 F1      6840 FPOW0:			POP     AF
0423E7 F1      6841 POP     AF
0423E8 F1      6842 POP     AF
0423E9 18      6843 JR      IPOW0
0423EA 8B 
               6844 ;
               6845 ;FPOW - Floating-point involution.
               6846 ;
0423EB CB      6847 FPOW:			BIT     7,D
0423EC 7A 
0423ED F5      6848 PUSH    AF
0423EE CD      6849 CALL    SWAP_FP
0423EF D7 
0423F0 2B 
0423F1 04 
0423F2 CD      6850 CALL    PUSH5
0423F3 B3 
0423F4 2C 
0423F5 04 
0423F6 0D      6851 DEC     C
0423F7 0C      6852 INC     C
0423F8 28      6853 JR      Z,FPOW0
0423F9 EC 
0423FA 3E      6854 LD      A,158
0423FB 9E 
0423FC B9      6855 CP      C
0423FD 38      6856 JR      C,FPOW1
0423FE 0A 
0423FF 3C      6857 INC     A
042400 CD      6858 CALL    FIX
042401 AB 
042402 2A 
042403 04 
042404 08      6859 EX      AF,AF'
042405 F2      6860 JP      P,FPOW0
042406 E6 
042407 23 
042408 04 
042409 CD      6861 FPOW1:			CALL    SWAP_FP
04240A D7 
04240B 2B 
04240C 04 
04240D CD      6862 CALL    LN0
04240E F7 
04240F 26 
042410 04 
042411 CD      6863 CALL    POP5
042412 BC 
042413 2C 
042414 04 
042415 F1      6864 POP     AF
042416 CD      6865 CALL    FMUL
042417 0E 
042418 23 
042419 04 
04241A C3      6866 JP      EXP0
04241B 59 
04241C 26 
04241D 04 
               6867 ;
               6868 ;Integer and floating-point compare.
               6869 ;Result is TRUE (-1) or FALSE (0).
               6870 ;
04241E CD      6871 FLT:			CALL    FCP
04241F 2D 
042420 2C 
042421 04 
042422 18      6872 JR      ILT1
042423 04 
042424 CD      6873 ILT:			CALL    ICP
042425 1F 
042426 2C 
042427 04 
042428 D0      6874 ILT1:			RET     NC
042429 18      6875 JR      TRUE_FP
04242A 42 
               6876 ;
04242B CD      6877 FGT:			CALL    FCP
04242C 2D 
04242D 2C 
04242E 04 
04242F 18      6878 JR      IGT1
042430 04 
042431 CD      6879 IGT:			CALL    ICP
042432 1F 
042433 2C 
042434 04 
042435 C8      6880 IGT1:			RET     Z
042436 D8      6881 RET     C
042437 18      6882 JR      TRUE_FP
042438 34 
               6883 ;
042439 CD      6884 FGE:			CALL    FCP
04243A 2D 
04243B 2C 
04243C 04 
04243D 18      6885 JR      IGE1
04243E 04 
04243F CD      6886 IGE:			CALL    ICP
042440 1F 
042441 2C 
042442 04 
042443 D8      6887 IGE1:			RET     C
042444 18      6888 JR      TRUE_FP
042445 27 
               6889 ;
042446 CD      6890 FLE:			CALL    FCP
042447 2D 
042448 2C 
042449 04 
04244A 18      6891 JR      ILE1
04244B 04 
04244C CD      6892 ILE:			CALL    ICP
04244D 1F 
04244E 2C 
04244F 04 
042450 28      6893 ILE1:			JR      Z,TRUE_FP
042451 1B 
042452 D0      6894 RET     NC
042453 18      6895 JR      TRUE_FP
042454 18 
               6896 ;
042455 CD      6897 FNE:			CALL    FCP
042456 2D 
042457 2C 
042458 04 
042459 18      6898 JR      INE1
04245A 04 
04245B CD      6899 INE:			CALL    ICP
04245C 1F 
04245D 2C 
04245E 04 
04245F C8      6900 INE1:			RET     Z
042460 18      6901 JR      TRUE_FP
042461 0B 
               6902 ;
042462 CD      6903 FEQ:			CALL    FCP
042463 2D 
042464 2C 
042465 04 
042466 18      6904 JR      IEQ1
042467 04 
042468 CD      6905 IEQ:			CALL    ICP
042469 1F 
04246A 2C 
04246B 04 
04246C C0      6906 IEQ1:			RET     NZ
04246D 21      6907 TRUE_FP:			LD      HL,-1
04246E FF 
04246F FF 
042470 FF 
042471 D9      6908 EXX
042472 21      6909 LD      HL,-1
042473 FF 
042474 FF 
042475 FF 
042476 D9      6910 EXX
042477 AF      6911 XOR     A
042478 4F      6912 LD      C,A
042479 C9      6913 RET
               6914 ;
               6915 ;FUNCTIONS:
               6916 ;
               6917 ;Result returned in HLH'L'C (floating point)
               6918 ;Result returned in HLH'L' (C=0) (integer)
               6919 ;All registers except IY destroyed.
               6920 ;
               6921 ;ABS - Absolute value
               6922 ;Result is numeric, variable type.
               6923 ;
04247A CB      6924 ABSV_FP:			BIT     7,H
04247B 7C 
04247C C8      6925 RET     Z               ;POSITIVE/ZERO
04247D 0D      6926 DEC     C
04247E 0C      6927 INC     C
04247F CA      6928 JP      Z,NEGATE        ;INTEGER
042480 DA 
042481 2A 
042482 04 
042483 CB      6929 RES     7,H
042484 BC 
042485 C9      6930 RET
               6931 ;
               6932 ;NOT - Complement integer.
               6933 ;Result is integer numeric.
               6934 ;
042486 CD      6935 NOTK_FP:			CALL    SFIX_FP
042487 CA 
042488 2A 
042489 04 
04248A 7C      6936 LD      A,H
04248B 2F      6937 CPL
04248C 67      6938 LD      H,A
04248D 7D      6939 LD      A,L
04248E 2F      6940 CPL
04248F 6F      6941 LD      L,A
042490 D9      6942 EXX
042491 7C      6943 LD      A,H
042492 2F      6944 CPL
042493 67      6945 LD      H,A
042494 7D      6946 LD      A,L
042495 2F      6947 CPL
042496 6F      6948 LD      L,A
042497 D9      6949 EXX
042498 AF      6950 XOR     A               ;NUMERIC MARKER
042499 C9      6951 RET
               6952 ;
               6953 ;PI - Return PI (3.141592654)
               6954 ;Result is floating-point numeric.
               6955 ;
04249A 21      6956 PI_FP:			LD      HL,490FH
04249B 0F 
04249C 49 
04249D 00 
04249E D9      6957 EXX
04249F 21      6958 LD      HL,0DAA2H
0424A0 A2 
0424A1 DA 
0424A2 00 
0424A3 D9      6959 EXX
0424A4 0E      6960 LD      C,81H
0424A5 81 
0424A6 AF      6961 XOR     A               ;NUMERIC MARKER
0424A7 C9      6962 RET
               6963 ;
               6964 ;DEG - Convert radians to degrees
               6965 ;Result is floating-point numeric.
               6966 ;
0424A8 CD      6967 DEG_FP:			CALL    FPI180
0424A9 BC 
0424AA 24 
0424AB 04 
0424AC CD      6968 CALL    FMUL
0424AD 0E 
0424AE 23 
0424AF 04 
0424B0 AF      6969 XOR     A
0424B1 C9      6970 RET
               6971 ;
               6972 ;RAD - Convert degrees to radians
               6973 ;Result is floating-point numeric.
               6974 ;
0424B2 CD      6975 RAD_FP:			CALL    FPI180
0424B3 BC 
0424B4 24 
0424B5 04 
0424B6 CD      6976 CALL    FDIV
0424B7 65 
0424B8 22 
0424B9 04 
0424BA AF      6977 XOR     A
0424BB C9      6978 RET
               6979 ;
               6980 ;180/PI
               6981 ;
0424BC CD      6982 FPI180:			CALL    SFLOAT_FP
0424BD A6 
0424BE 2B 
0424BF 04 
0424C0 11      6983 LD      DE,652EH
0424C1 2E 
0424C2 65 
0424C3 00 
0424C4 D9      6984 EXX
0424C5 11      6985 LD      DE,0E0D3H
0424C6 D3 
0424C7 E0 
0424C8 00 
0424C9 D9      6986 EXX
0424CA 06      6987 LD      B,85H
0424CB 85 
0424CC C9      6988 RET
               6989 ;
               6990 ;SGN - Return -1, 0 or +1
               6991 ;Result is integer numeric.
               6992 ;
0424CD CD      6993 SGN_FP:			CALL    TEST_FP
0424CE FF 
0424CF 2B 
0424D0 04 
0424D1 B1      6994 OR      C
0424D2 C8      6995 RET     Z               ;ZERO
0424D3 CB      6996 BIT     7,H
0424D4 7C 
0424D5 C2      6997 JP      NZ,TRUE_FP         ;-1
0424D6 6D 
0424D7 24 
0424D8 04 
0424D9 CD      6998 CALL    ZERO_FP
0424DA 23 
0424DB 2C 
0424DC 04 
0424DD C3      6999 JP      ADD1_FP            ;1
0424DE BF 
0424DF 2B 
0424E0 04 
               7000 ;
               7001 ;VAL - Return numeric value of string.
               7002 ;Input: ASCII string at IX
               7003 ;Result is variable type numeric.
               7004 ;
0424E1 CD      7005 VAL_FP:			CALL    SIGNQ
0424E2 3D 
0424E3 2E 
0424E4 04 
0424E5 F5      7006 PUSH    AF
0424E6 CD      7007 CALL    CON_FP
0424E7 ED 
0424E8 29 
0424E9 04 
0424EA F1      7008 POP     AF
0424EB FE      7009 CP      '-'
0424EC 2D 
0424ED 3E      7010 LD      A,0             ;NUMERIC MARKER
0424EE 00 
0424EF C0      7011 RET     NZ
0424F0 0D      7012 DEC     C
0424F1 0C      7013 INC     C
0424F2 CA      7014 JP      Z,NEGATE        ;ZERO/INTEGER
0424F3 DA 
0424F4 2A 
0424F5 04 
0424F6 7C      7015 LD      A,H
0424F7 EE      7016 XOR     80H             ;CHANGE SIGN (FP)
0424F8 80 
0424F9 67      7017 LD      H,A
0424FA AF      7018 XOR     A
0424FB C9      7019 RET
               7020 ;
               7021 ;INT - Floor function
               7022 ;Result is integer numeric.
               7023 ;
0424FC 0D      7024 INT_FP_:			DEC     C
0424FD 0C      7025 INC     C
0424FE C8      7026 RET     Z               ;ZERO/INTEGER
0424FF 3E      7027 LD      A,159
042500 9F 
042501 44      7028 LD      B,H             ;B7=SIGN BIT
042502 CD      7029 CALL    FIX
042503 AB 
042504 2A 
042505 04 
042506 08      7030 EX      AF,AF'
042507 A0      7031 AND     B
042508 FC      7032 CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042509 BF 
04250A 2B 
04250B 04 
04250C 78      7033 LD      A,B
04250D B7      7034 OR      A
04250E FC      7035 CALL    M,NEGATE
04250F DA 
042510 2A 
042511 04 
042512 AF      7036 XOR     A
042513 4F      7037 LD      C,A
042514 C9      7038 RET
               7039 ;
               7040 ;SQR - square root
               7041 ;Result is floating-point numeric.
               7042 ;
042515 CD      7043 SQR_FP:			CALL    SFLOAT_FP
042516 A6 
042517 2B 
042518 04 
042519 CB      7044 SQR0:			BIT     7,H
04251A 7C 
04251B 3E      7045 LD      A,NGROOT
04251C 15 
04251D C2      7046 JP      NZ,ERROR_FP_        ;"-ve root"
04251E 7D 
04251F 20 
042520 04 
042521 0D      7047 DEC     C
042522 0C      7048 INC     C
042523 C8      7049 RET     Z               ;ZERO
042524 CB      7050 SET     7,H             ;IMPLIED 1
042525 FC 
042526 CB      7051 BIT     0,C
042527 41 
042528 CC      7052 CALL    Z,DIV2          ;MAKE EXPONENT ODD
042529 DF 
04252A 2B 
04252B 04 
04252C 79      7053 LD      A,C
04252D D6      7054 SUB     80H
04252E 80 
04252F CB      7055 SRA     A               ;HALVE EXPONENT
042530 2F 
042531 C6      7056 ADD     A,80H
042532 80 
042533 4F      7057 LD      C,A
042534 C5      7058 PUSH    BC              ;SAVE EXPONENT
042535 EB      7059 EX      DE,HL
042536 21      7060 LD      HL,0
042537 00 
042538 00 
042539 00 
04253A 44      7061 LD      B,H
04253B 4D      7062 LD      C,L
04253C D9      7063 EXX
04253D EB      7064 EX      DE,HL
04253E 21      7065 LD      HL,0
04253F 00 
042540 00 
042541 00 
042542 44      7066 LD      B,H
042543 4D      7067 LD      C,L
042544 3E      7068 LD      A,-31
042545 E1 
042546 CD      7069 CALL    SQRA            ;ROOT
042547 D5 
042548 2D 
042549 04 
04254A D9      7070 EXX
04254B CB      7071 BIT     7,B
04254C 78 
04254D D9      7072 EXX
04254E CC      7073 CALL    Z,SQRA          ;NORMALISE & INC A
04254F D5 
042550 2D 
042551 04 
042552 CD      7074 CALL    SQRB
042553 16 
042554 2E 
042555 04 
042556 B7      7075 OR      A               ;CLEAR CARRY
042557 CD      7076 CALL    DIVB
042558 83 
042559 2D 
04255A 04 
04255B CB      7077 RR      E               ;LSB TO CARRY
04255C 1B 
04255D 60      7078 LD      H,B
04255E 69      7079 LD      L,C
04255F D9      7080 EXX
042560 60      7081 LD      H,B
042561 69      7082 LD      L,C
042562 DC      7083 CALL    C,ADD1_FP          ;ROUND UP
042563 BF 
042564 2B 
042565 04 
042566 C1      7084 POP     BC              ;RESTORE EXPONENT
042567 DC      7085 CALL    C,INCC
042568 EC 
042569 2B 
04256A 04 
04256B 1F      7086 RRA
04256C 9F      7087 SBC     A,A
04256D 81      7088 ADD     A,C
04256E 4F      7089 LD      C,A
04256F CB      7090 RES     7,H             ;POSITIVE
042570 BC 
042571 AF      7091 XOR     A
042572 C9      7092 RET
               7093 ;
               7094 ;TAN - Tangent function
               7095 ;Result is floating-point numeric.
               7096 ;
042573 CD      7097 TAN_FP:			CALL    SFLOAT_FP
042574 A6 
042575 2B 
042576 04 
042577 CD      7098 CALL    PUSH5
042578 B3 
042579 2C 
04257A 04 
04257B CD      7099 CALL    COS0
04257C 9D 
04257D 25 
04257E 04 
04257F CD      7100 CALL    POP5
042580 BC 
042581 2C 
042582 04 
042583 CD      7101 CALL    PUSH5
042584 B3 
042585 2C 
042586 04 
042587 CD      7102 CALL    SWAP_FP
042588 D7 
042589 2B 
04258A 04 
04258B CD      7103 CALL    SIN0
04258C AA 
04258D 25 
04258E 04 
04258F CD      7104 CALL    POP5
042590 BC 
042591 2C 
042592 04 
042593 CD      7105 CALL    FDIV
042594 65 
042595 22 
042596 04 
042597 AF      7106 XOR     A               ;NUMERIC MARKER
042598 C9      7107 RET
               7108 ;
               7109 ;COS - Cosine function
               7110 ;Result is floating-point numeric.
               7111 ;
042599 CD      7112 COS_FP:			CALL    SFLOAT_FP
04259A A6 
04259B 2B 
04259C 04 
04259D CD      7113 COS0:			CALL    SCALE
04259E 02 
04259F 2B 
0425A0 04 
0425A1 1C      7114 INC     E
0425A2 1C      7115 INC     E
0425A3 7B      7116 LD      A,E
0425A4 18      7117 JR      SIN1
0425A5 10 
               7118 ;
               7119 ;SIN - Sine function
               7120 ;Result is floating-point numeric.
               7121 ;
0425A6 CD      7122 SIN_FP:			CALL    SFLOAT_FP
0425A7 A6 
0425A8 2B 
0425A9 04 
0425AA E5      7123 SIN0:			PUSH    HL              ;H7=SIGN
0425AB CD      7124 CALL    SCALE
0425AC 02 
0425AD 2B 
0425AE 04 
0425AF F1      7125 POP     AF
0425B0 07      7126 RLCA
0425B1 07      7127 RLCA
0425B2 07      7128 RLCA
0425B3 E6      7129 AND     4
0425B4 04 
0425B5 AB      7130 XOR     E
0425B6 F5      7131 SIN1:			PUSH    AF              ;OCTANT
0425B7 CB      7132 RES     7,H
0425B8 BC 
0425B9 1F      7133 RRA
0425BA CD      7134 CALL    PIBY4
0425BB 48 
0425BC 26 
0425BD 04 
0425BE DC      7135 CALL    C,RSUB          ;X=(PI/4)-X
0425BF E9 
0425C0 21 
0425C1 04 
0425C2 F1      7136 POP     AF
0425C3 F5      7137 PUSH    AF
0425C4 E6      7138 AND     3
0425C5 03 
0425C6 E2      7139 JP      PO,SIN2         ;USE COSINE APPROX.
0425C7 FF 
0425C8 25 
0425C9 04 
0425CA CD      7140 CALL    PUSH5           ;SAVE X
0425CB B3 
0425CC 2C 
0425CD 04 
0425CE CD      7141 CALL    SQUARE          ;PUSH X*X
0425CF AB 
0425D0 2C 
0425D1 04 
0425D2 CD      7142 CALL    POLY
0425D3 F0 
0425D4 2C 
0425D5 04 
0425D6 B7      7143 DW	0A8B7H          ;a(8)
0425D7 A8 
0425D8 11      7144 DW	3611H
0425D9 36 
0425DA 6D      7145 DB	6DH
0425DB 26      7146 DW	0DE26H          ;a(6)
0425DC DE 
0425DD 05      7147 DW	0D005H
0425DE D0 
0425DF 73      7148 DB	73H
0425E0 C0      7149 DW	80C0H           ;a(4)
0425E1 80 
0425E2 88      7150 DW	888H
0425E3 08 
0425E4 79      7151 DB	79H
0425E5 9D      7152 DW	0AA9DH          ;a(2)
0425E6 AA 
0425E7 AA      7153 DW	0AAAAH
0425E8 AA 
0425E9 7D      7154 DB	7DH
0425EA 00      7155 DW	0               ;a(0)
0425EB 00 
0425EC 00      7156 DW	0
0425ED 00 
0425EE 80      7157 DB	80H
0425EF CD      7158 CALL    POP5
0425F0 BC 
0425F1 2C 
0425F2 04 
0425F3 CD      7159 CALL    POP5
0425F4 BC 
0425F5 2C 
0425F6 04 
0425F7 CD      7160 CALL    FMUL
0425F8 0E 
0425F9 23 
0425FA 04 
0425FB C3      7161 JP      SIN3
0425FC 24 
0425FD 26 
0425FE 04 
               7162 ;
0425FF CD      7163 SIN2:			CALL    SQUARE          ;PUSH X*X
042600 AB 
042601 2C 
042602 04 
042603 CD      7164 CALL    POLY
042604 F0 
042605 2C 
042606 04 
042607 71      7165 DW	0D571H          ;b(8)
042608 D5 
042609 78      7166 DW	4C78H
04260A 4C 
04260B 70      7167 DB	70H
04260C AF      7168 DW	94AFH           ;b(6)
04260D 94 
04260E 03      7169 DW	0B603H
04260F B6 
042610 76      7170 DB	76H
042611 C8      7171 DW	9CC8H           ;b(4)
042612 9C 
042613 AA      7172 DW	2AAAH
042614 2A 
042615 7B      7173 DB	7BH
042616 DD      7174 DW	0FFDDH          ;b(2)
042617 FF 
042618 FF      7175 DW	0FFFFH
042619 FF 
04261A 7E      7176 DB	7EH
04261B 00      7177 DW	0               ;b(0)
04261C 00 
04261D 00      7178 DW	0
04261E 00 
04261F 80      7179 DB	80H
042620 CD      7180 CALL    POP5
042621 BC 
042622 2C 
042623 04 
042624 F1      7181 SIN3:			POP     AF
042625 E6      7182 AND     4
042626 04 
042627 C8      7183 RET     Z
042628 0D      7184 DEC     C
042629 0C      7185 INC     C
04262A C8      7186 RET     Z               ;ZERO
04262B CB      7187 SET     7,H             ;MAKE NEGATIVE
04262C FC 
04262D C9      7188 RET
               7189 ;
               7190 ;Floating-point one:
               7191 ;
04262E 21      7192 FONE_FP:			LD      HL,0
04262F 00 
042630 00 
042631 00 
042632 D9      7193 EXX
042633 21      7194 LD      HL,0
042634 00 
042635 00 
042636 00 
042637 D9      7195 EXX
042638 0E      7196 LD      C,80H
042639 80 
04263A C9      7197 RET
               7198 ;
04263B 11      7199 DONE:			LD      DE,0
04263C 00 
04263D 00 
04263E 00 
04263F D9      7200 EXX
042640 11      7201 LD      DE,0
042641 00 
042642 00 
042643 00 
042644 D9      7202 EXX
042645 06      7203 LD      B,80H
042646 80 
042647 C9      7204 RET
               7205 ;
042648 11      7206 PIBY4:			LD      DE,490FH
042649 0F 
04264A 49 
04264B 00 
04264C D9      7207 EXX
04264D 11      7208 LD      DE,0DAA2H
04264E A2 
04264F DA 
042650 00 
042651 D9      7209 EXX
042652 06      7210 LD      B,7FH
042653 7F 
042654 C9      7211 RET
               7212 ;
               7213 ;EXP - Exponential function
               7214 ;Result is floating-point numeric.
               7215 ;
042655 CD      7216 EXP_FP:			CALL    SFLOAT_FP
042656 A6 
042657 2B 
042658 04 
042659 CD      7217 EXP0:			CALL    LN2             ;LN(2)
04265A E6 
04265B 26 
04265C 04 
04265D D9      7218 EXX
04265E 1D      7219 DEC     E
04265F 01      7220 LD      BC,0D1CFH       ;0.6931471805599453
042660 CF 
042661 D1 
042662 00 
042663 D9      7221 EXX
042664 E5      7222 PUSH    HL              ;H7=SIGN
042665 CD      7223 CALL    MOD48           ;"MODULUS"
042666 15 
042667 2B 
042668 04 
042669 F1      7224 POP     AF
04266A CB      7225 BIT     7,E
04266B 7B 
04266C 28      7226 JR      Z,EXP1
04266D 0B 
04266E 17      7227 RLA
04266F DA      7228 JP      C,ZERO_FP
042670 23 
042671 2C 
042672 04 
042673 3E      7229 LD      A,EXPRNG
042674 18 
042675 C3      7230 JP      ERROR_FP_           ;"Exp range"
042676 7D 
042677 20 
042678 04 
               7231 ;
042679 E6      7232 EXP1:			AND     80H
04267A 80 
04267B B3      7233 OR      E
04267C F5      7234 PUSH    AF              ;INTEGER PART
04267D CB      7235 RES     7,H
04267E BC 
04267F CD      7236 CALL    PUSH5           ;PUSH X*LN(2)
042680 B3 
042681 2C 
042682 04 
042683 CD      7237 CALL    POLY
042684 F0 
042685 2C 
042686 04 
042687 72      7238 DW	4072H           ;a(7)
042688 40 
042689 2E      7239 DW	942EH
04268A 94 
04268B 73      7240 DB	73H
04268C 65      7241 DW	6F65H           ;a(6)
04268D 6F 
04268E 4F      7242 DW	2E4FH
04268F 2E 
042690 76      7243 DB	76H
042691 37      7244 DW	6D37H           ;a(5)
042692 6D 
042693 02      7245 DW	8802H
042694 88 
042695 79      7246 DB	79H
042696 12      7247 DW	0E512H          ;a(4)
042697 E5 
042698 A0      7248 DW	2AA0H
042699 2A 
04269A 7B      7249 DB	7BH
04269B 14      7250 DW	4F14H           ;a(3)
04269C 4F 
04269D AA      7251 DW	0AAAAH
04269E AA 
04269F 7D      7252 DB	7DH
0426A0 56      7253 DW	0FD56H          ;a(2)
0426A1 FD 
0426A2 FF      7254 DW	7FFFH
0426A3 7F 
0426A4 7E      7255 DB	7EH
0426A5 FE      7256 DW	0FFFEH          ;a(1)
0426A6 FF 
0426A7 FF      7257 DW	0FFFFH
0426A8 FF 
0426A9 7F      7258 DB	7FH
0426AA 00      7259 DW	0               ;a(0)
0426AB 00 
0426AC 00      7260 DW	0
0426AD 00 
0426AE 80      7261 DB	80H
0426AF CD      7262 CALL    POP5
0426B0 BC 
0426B1 2C 
0426B2 04 
0426B3 F1      7263 POP     AF
0426B4 F5      7264 PUSH    AF
0426B5 F4      7265 CALL    P,RECIP         ;X=1/X
0426B6 DA 
0426B7 26 
0426B8 04 
0426B9 F1      7266 POP     AF
0426BA F2      7267 JP      P,EXP4
0426BB C2 
0426BC 26 
0426BD 04 
0426BE E6      7268 AND     7FH
0426BF 7F 
0426C0 ED      7269 NEG
0426C1 44 
0426C2 C6      7270 EXP4:			ADD     A,80H
0426C3 80 
0426C4 81      7271 ADD     A,C
0426C5 38      7272 JR      C,EXP2
0426C6 06 
0426C7 F2      7273 JP      P,ZERO_FP          ;UNDERFLOW
0426C8 23 
0426C9 2C 
0426CA 04 
0426CB 18      7274 JR      EXP3
0426CC 04 
0426CD FA      7275 EXP2:			JP      M,OFLOW         ;OVERFLOW
0426CE EE 
0426CF 2B 
0426D0 04 
0426D1 C6      7276 EXP3:			ADD     A,80H
0426D2 80 
0426D3 CA      7277 JP      Z,ZERO_FP
0426D4 23 
0426D5 2C 
0426D6 04 
0426D7 4F      7278 LD      C,A
0426D8 AF      7279 XOR     A               ;NUMERIC MARKER
0426D9 C9      7280 RET
               7281 ;
0426DA CD      7282 RECIP:			CALL    DONE
0426DB 3B 
0426DC 26 
0426DD 04 
0426DE CD      7283 RDIV:			CALL    SWAP_FP
0426DF D7 
0426E0 2B 
0426E1 04 
0426E2 C3      7284 JP      FDIV            ;RECIPROCAL
0426E3 65 
0426E4 22 
0426E5 04 
               7285 ;
0426E6 11      7286 LN2:			LD      DE,3172H        ;LN(2)
0426E7 72 
0426E8 31 
0426E9 00 
0426EA D9      7287 EXX
0426EB 11      7288 LD      DE,17F8H
0426EC F8 
0426ED 17 
0426EE 00 
0426EF D9      7289 EXX
0426F0 06      7290 LD      B,7FH
0426F1 7F 
0426F2 C9      7291 RET
               7292 ;
               7293 ;LN - Natural log.
               7294 ;Result is floating-point numeric.
               7295 ;
0426F3 CD      7296 LN_FP:			CALL    SFLOAT_FP
0426F4 A6 
0426F5 2B 
0426F6 04 
0426F7 3E      7297 LN0:			LD      A,LOGRNG
0426F8 16 
0426F9 CB      7298 BIT     7,H
0426FA 7C 
0426FB C2      7299 JP      NZ,ERROR_FP_        ;"Log range"
0426FC 7D 
0426FD 20 
0426FE 04 
0426FF 0C      7300 INC     C
042700 0D      7301 DEC     C
042701 CA      7302 JP      Z,ERROR_FP_
042702 7D 
042703 20 
042704 04 
042705 11      7303 LD      DE,3504H        ;SQR(2)
042706 04 
042707 35 
042708 00 
042709 D9      7304 EXX
04270A 11      7305 LD      DE,0F333H       ;1.41421356237
04270B 33 
04270C F3 
04270D 00 
04270E D9      7306 EXX
04270F CD      7307 CALL    ICP0            ;MANTISSA>SQR(2)?
042710 36 
042711 2C 
042712 04 
042713 79      7308 LD      A,C             ;EXPONENT
042714 0E      7309 LD      C,80H           ;1 <= X < 2
042715 80 
042716 38      7310 JR      C,LN4
042717 02 
042718 0D      7311 DEC     C
042719 3C      7312 INC     A
04271A F5      7313 LN4:			PUSH    AF              ;SAVE EXPONENT
04271B CD      7314 CALL    RATIO           ;X=(X-1)/(X+1)
04271C C8 
04271D 2C 
04271E 04 
04271F CD      7315 CALL    PUSH5
042720 B3 
042721 2C 
042722 04 
042723 CD      7316 CALL    SQUARE          ;PUSH X*X
042724 AB 
042725 2C 
042726 04 
042727 CD      7317 CALL    POLY
042728 F0 
042729 2C 
04272A 04 
04272B 48      7318 DW	0CC48H          ;a(9)
04272C CC 
04272D FB      7319 DW	74FBH
04272E 74 
04272F 7D      7320 DB	7DH
042730 AF      7321 DW	0AEAFH          ;a(7)
042731 AE 
042732 FF      7322 DW	11FFH
042733 11 
042734 7E      7323 DB	7EH
042735 8C      7324 DW	0D98CH          ;a(5)
042736 D9 
042737 CD      7325 DW	4CCDH
042738 4C 
042739 7E      7326 DB	7EH
04273A E3      7327 DW	0A9E3H          ;a(3)
04273B A9 
04273C AA      7328 DW	2AAAH
04273D 2A 
04273E 7F      7329 DB	7FH
04273F 00      7330 DW	0               ;a(1)
042740 00 
042741 00      7331 DW	0
042742 00 
042743 81      7332 DB	81H
042744 CD      7333 CALL    POP5
042745 BC 
042746 2C 
042747 04 
042748 CD      7334 CALL    POP5
042749 BC 
04274A 2C 
04274B 04 
04274C CD      7335 CALL    FMUL
04274D 0E 
04274E 23 
04274F 04 
042750 F1      7336 POP     AF              ;EXPONENT
042751 CD      7337 CALL    PUSH5
042752 B3 
042753 2C 
042754 04 
042755 08      7338 EX      AF,AF'
042756 CD      7339 CALL    ZERO_FP
042757 23 
042758 2C 
042759 04 
04275A 08      7340 EX      AF,AF'
04275B D6      7341 SUB     80H
04275C 80 
04275D 28      7342 JR      Z,LN3
04275E 1F 
04275F 30      7343 JR      NC,LN1
042760 02 
042761 2F      7344 CPL
042762 3C      7345 INC     A
042763 67      7346 LN1:			LD      H,A
042764 0E      7347 LD      C,87H
042765 87 
042766 F5      7348 PUSH    AF
042767 CD      7349 CALL    FLOAT_
042768 86 
042769 2B 
04276A 04 
04276B CB      7350 RES     7,H
04276C BC 
04276D CD      7351 CALL    LN2
04276E E6 
04276F 26 
042770 04 
042771 CD      7352 CALL    FMUL
042772 0E 
042773 23 
042774 04 
042775 F1      7353 POP     AF
042776 30      7354 JR      NC,LN3
042777 06 
042778 FA      7355 JP      M,LN3
042779 7E 
04277A 27 
04277B 04 
04277C CB      7356 SET     7,H
04277D FC 
04277E CD      7357 LN3:			CALL    POP5
04277F BC 
042780 2C 
042781 04 
042782 CD      7358 CALL    FADD
042783 FC 
042784 21 
042785 04 
042786 AF      7359 XOR     A
042787 C9      7360 RET
               7361 ;
               7362 ;LOG - base-10 logarithm.
               7363 ;Result is floating-point numeric.
               7364 ;
042788 CD      7365 LOG_FP:			CALL    LN_FP
042789 F3 
04278A 26 
04278B 04 
04278C 11      7366 LD      DE,5E5BH        ;LOG(e)
04278D 5B 
04278E 5E 
04278F 00 
042790 D9      7367 EXX
042791 11      7368 LD      DE,0D8A9H
042792 A9 
042793 D8 
042794 00 
042795 D9      7369 EXX
042796 06      7370 LD      B,7EH
042797 7E 
042798 CD      7371 CALL    FMUL
042799 0E 
04279A 23 
04279B 04 
04279C AF      7372 XOR     A
04279D C9      7373 RET
               7374 ;
               7375 ;ASN - Arc-sine
               7376 ;Result is floating-point numeric.
               7377 ;
04279E CD      7378 ASN_FP:			CALL    SFLOAT_FP
04279F A6 
0427A0 2B 
0427A1 04 
0427A2 CD      7379 CALL    PUSH5
0427A3 B3 
0427A4 2C 
0427A5 04 
0427A6 CD      7380 CALL    COPY_
0427A7 A3 
0427A8 2C 
0427A9 04 
0427AA CD      7381 CALL    FMUL
0427AB 0E 
0427AC 23 
0427AD 04 
0427AE CD      7382 CALL    DONE
0427AF 3B 
0427B0 26 
0427B1 04 
0427B2 CD      7383 CALL    RSUB
0427B3 E9 
0427B4 21 
0427B5 04 
0427B6 CD      7384 CALL    SQR0
0427B7 19 
0427B8 25 
0427B9 04 
0427BA CD      7385 CALL    POP5
0427BB BC 
0427BC 2C 
0427BD 04 
0427BE 0C      7386 INC     C
0427BF 0D      7387 DEC     C
0427C0 3E      7388 LD      A,2
0427C1 02 
0427C2 D5      7389 PUSH    DE
0427C3 CA      7390 JP      Z,ACS1
0427C4 48 
0427C5 28 
0427C6 04 
0427C7 D1      7391 POP     DE
0427C8 CD      7392 CALL    RDIV
0427C9 DE 
0427CA 26 
0427CB 04 
0427CC 18      7393 JR      ATN0
0427CD 04 
               7394 ;
               7395 ;ATN - arc-tangent
               7396 ;Result is floating-point numeric.
               7397 ;
0427CE CD      7398 ATN_FP:			CALL    SFLOAT_FP
0427CF A6 
0427D0 2B 
0427D1 04 
0427D2 E5      7399 ATN0:			PUSH    HL              ;SAVE SIGN
0427D3 CB      7400 RES     7,H
0427D4 BC 
0427D5 11      7401 LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0427D6 13 
0427D7 54 
0427D8 00 
0427D9 D9      7402 EXX
0427DA 11      7403 LD      DE,0CCD0H
0427DB D0 
0427DC CC 
0427DD 00 
0427DE D9      7404 EXX
0427DF 06      7405 LD      B,7EH
0427E0 7E 
0427E1 CD      7406 CALL    FCP0            ;COMPARE
0427E2 33 
0427E3 2C 
0427E4 04 
0427E5 06      7407 LD      B,0
0427E6 00 
0427E7 38      7408 JR      C,ATN2
0427E8 22 
0427E9 11      7409 LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0427EA 82 
0427EB 1A 
0427EC 00 
0427ED D9      7410 EXX
0427EE 11      7411 LD      DE,799AH
0427EF 9A 
0427F0 79 
0427F1 00 
0427F2 D9      7412 EXX
0427F3 06      7413 LD      B,81H
0427F4 81 
0427F5 CD      7414 CALL    FCP0            ;COMPARE
0427F6 33 
0427F7 2C 
0427F8 04 
0427F9 38      7415 JR      C,ATN1
0427FA 0A 
0427FB CD      7416 CALL    RECIP           ;X=1/X
0427FC DA 
0427FD 26 
0427FE 04 
0427FF 06      7417 LD      B,2
042800 02 
042801 C3      7418 JP      ATN2
042802 0B 
042803 28 
042804 04 
042805 CD      7419 ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042806 C8 
042807 2C 
042808 04 
042809 06      7420 LD      B,1
04280A 01 
04280B C5      7421 ATN2:			PUSH    BC              ;SAVE FLAG
04280C CD      7422 CALL    PUSH5
04280D B3 
04280E 2C 
04280F 04 
042810 CD      7423 CALL    SQUARE          ;PUSH X*X
042811 AB 
042812 2C 
042813 04 
042814 CD      7424 CALL    POLY
042815 F0 
042816 2C 
042817 04 
042818 35      7425 DW	0F335H          ;a(13)
042819 F3 
04281A D8      7426 DW	37D8H
04281B 37 
04281C 7B      7427 DB	7BH
04281D 91      7428 DW	6B91H           ;a(11)
04281E 6B 
04281F B9      7429 DW	0AAB9H
042820 AA 
042821 7C      7430 DB	7CH
042822 DE      7431 DW	41DEH           ;a(9)
042823 41 
042824 97      7432 DW	6197H
042825 61 
042826 7C      7433 DB	7CH
042827 7B      7434 DW	9D7BH           ;a(7)
042828 9D 
042829 37      7435 DW	9237H
04282A 92 
04282B 7D      7436 DB	7DH
04282C 5A      7437 DW	2A5AH           ;a(5)
04282D 2A 
04282E CC      7438 DW	4CCCH
04282F 4C 
042830 7D      7439 DB	7DH
042831 5C      7440 DW	0A95CH          ;a(3)
042832 A9 
042833 AA      7441 DW	0AAAAH
042834 AA 
042835 7E      7442 DB	7EH
042836 00      7443 DW	0               ;a(1)
042837 00 
042838 00      7444 DW	0
042839 00 
04283A 80      7445 DB	80H
04283B CD      7446 CALL    POP5
04283C BC 
04283D 2C 
04283E 04 
04283F CD      7447 CALL    POP5
042840 BC 
042841 2C 
042842 04 
042843 CD      7448 CALL    FMUL
042844 0E 
042845 23 
042846 04 
042847 F1      7449 POP     AF
042848 CD      7450 ACS1:			CALL    PIBY4           ;PI/4
042849 48 
04284A 26 
04284B 04 
04284C 1F      7451 RRA
04284D F5      7452 PUSH    AF
04284E DC      7453 CALL    C,FADD
04284F FC 
042850 21 
042851 04 
042852 F1      7454 POP     AF
042853 04      7455 INC     B
042854 1F      7456 RRA
042855 DC      7457 CALL    C,RSUB
042856 E9 
042857 21 
042858 04 
042859 F1      7458 POP     AF
04285A B7      7459 OR      A
04285B F0      7460 RET     P
04285C CB      7461 SET     7,H             ;MAKE NEGATIVE
04285D FC 
04285E AF      7462 XOR     A
04285F C9      7463 RET
               7464 ;
               7465 ;ACS - Arc cosine=PI/2-ASN.
               7466 ;Result is floating point numeric.
               7467 ;
042860 CD      7468 ACS_FP:			CALL    ASN_FP
042861 9E 
042862 27 
042863 04 
042864 3E      7469 LD      A,2
042865 02 
042866 F5      7470 PUSH    AF
042867 18      7471 JR      ACS1
042868 DF 
               7472 ;
               7473 ;Function STR - convert numeric value to ASCII string.
               7474 ;   Inputs: HLH'L'C = integer or floating-point number
               7475 ;           DE = address at which to store string
               7476 ;           IX = address of @% format control
               7477 ;  Outputs: String stored, with NUL terminator
               7478 ;
               7479 ;First normalise for decimal output:
               7480 ;
042869 CD      7481 STR_FP:			CALL    SFLOAT_FP
04286A A6 
04286B 2B 
04286C 04 
04286D 06      7482 LD      B,0             ;DEFAULT PT. POSITION
04286E 00 
04286F CB      7483 BIT     7,H             ;NEGATIVE?
042870 7C 
042871 28      7484 JR      Z,STR10
042872 06 
042873 CB      7485 RES     7,H
042874 BC 
042875 3E      7486 LD      A,'-'
042876 2D 
042877 12      7487 LD      (DE),A          ;STORE SIGN
042878 13      7488 INC     DE
042879 AF      7489 STR10:			XOR     A               ;CLEAR A
04287A B9      7490 CP      C
04287B 28      7491 JR      Z,STR02          ;ZERO
04287C 4E 
04287D D5      7492 PUSH    DE              ;SAVE TEXT POINTER
04287E 78      7493 LD      A,B
04287F F5      7494 STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
042880 79      7495 LD      A,C             ;BINARY EXPONENT
042881 FE      7496 CP      161
042882 A1 
042883 30      7497 JR      NC,STR14
042884 1C 
042885 FE      7498 CP      155
042886 9B 
042887 30      7499 JR      NC,STR15
042888 29 
042889 2F      7500 CPL
04288A FE      7501 CP      225
04288B E1 
04288C 38      7502 JR      C,STR13
04288D 02 
04288E 3E      7503 LD      A,-8
04288F F8 
042890 C6      7504 STR13:			ADD     A,28
042891 1C 
042892 CD      7505 CALL    POWR10
042893 1F 
042894 2D 
042895 04 
042896 F5      7506 PUSH    AF
042897 CD      7507 CALL    FMUL
042898 0E 
042899 23 
04289A 04 
04289B F1      7508 POP     AF
04289C 47      7509 LD      B,A
04289D F1      7510 POP     AF
04289E 90      7511 SUB     B
04289F 18      7512 JR      STR11
0428A0 DE 
0428A1 D6      7513 STR14:			SUB     32
0428A2 20 
0428A3 CD      7514 CALL    POWR10
0428A4 1F 
0428A5 2D 
0428A6 04 
0428A7 F5      7515 PUSH    AF
0428A8 CD      7516 CALL    FDIV
0428A9 65 
0428AA 22 
0428AB 04 
0428AC F1      7517 POP     AF
0428AD 47      7518 LD      B,A
0428AE F1      7519 POP     AF
0428AF 80      7520 ADD     A,B
0428B0 18      7521 JR      STR11
0428B1 CD 
0428B2 3E      7522 STR15:			LD      A,9
0428B3 09 
0428B4 CD      7523 CALL    POWR10          ;10^9
0428B5 1F 
0428B6 2D 
0428B7 04 
0428B8 CD      7524 CALL    FCP0
0428B9 33 
0428BA 2C 
0428BB 04 
0428BC 79      7525 LD      A,C
0428BD C1      7526 POP     BC
0428BE 4F      7527 LD      C,A
0428BF CB      7528 SET     7,H             ;IMPLIED 1
0428C0 FC 
0428C1 DC      7529 CALL    C,X10B          ;X10, DEC B
0428C2 5B 
0428C3 2C 
0428C4 04 
0428C5 D1      7530 POP     DE              ;RESTORE TEXT POINTER
0428C6 CB      7531 RES     7,C
0428C7 B9 
0428C8 3E      7532 LD      A,0
0428C9 00 
0428CA 17      7533 RLA                     ;PUT CARRY IN LSB
               7534 ;
               7535 ;At this point decimal normalisation has been done,
               7536 ;now convert to decimal digits:
               7537 ;      AHLH'L' = number in normalised integer form
               7538 ;            B = decimal place adjustment
               7539 ;            C = binary place adjustment (29-33)
               7540 ;
0428CB 0C      7541 STR02:			INC     C
0428CC 08      7542 EX      AF,AF'          ;SAVE A
0428CD 78      7543 LD      A,B
0428CE DD      7544 BIT     1,(IX+2)
0428CF CB 
0428D0 02 
0428D1 4E 
0428D2 20      7545 JR      NZ,STR20
0428D3 08 
0428D4 AF      7546 XOR     A
0428D5 DD      7547 CP      (IX+1)
0428D6 BE 
0428D7 01 
0428D8 28      7548 JR      Z,STR21
0428D9 0B 
0428DA 3E      7549 LD      A,-10
0428DB F6 
0428DC DD      7550 STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0428DD 86 
0428DE 01 
0428DF B7      7551 OR      A               ;CLEAR CARRY
0428E0 FA      7552 JP      M,STR21
0428E1 E5 
0428E2 28 
0428E3 04 
0428E4 AF      7553 XOR     A
0428E5 F5      7554 STR21:			PUSH    AF
0428E6 08      7555 EX      AF,AF'          ;RESTORE A
0428E7 CD      7556 STR22:			CALL    X2              ;RL AHLH'L'
0428E8 8F 
0428E9 2C 
0428EA 04 
0428EB 8F      7557 ADC     A,A
0428EC FE      7558 CP      10
0428ED 0A 
0428EE 38      7559 JR      C,STR23
0428EF 05 
0428F0 D6      7560 SUB     10
0428F1 0A 
0428F2 D9      7561 EXX
0428F3 2C      7562 INC     L               ;SET RESULT BIT
0428F4 D9      7563 EXX
0428F5 0D      7564 STR23:			DEC     C
0428F6 20      7565 JR      NZ,STR22        ;32 TIMES
0428F7 EF 
0428F8 4F      7566 LD      C,A             ;REMAINDER
0428F9 7C      7567 LD      A,H
0428FA E6      7568 AND     3FH             ;CLEAR OUT JUNK
0428FB 3F 
0428FC 67      7569 LD      H,A
0428FD F1      7570 POP     AF
0428FE F2      7571 JP      P,STR24
0428FF 0C 
042900 29 
042901 04 
042902 3C      7572 INC     A
042903 20      7573 JR      NZ,STR26
042904 1C 
042905 3E      7574 LD      A,4
042906 04 
042907 B9      7575 CP      C               ;ROUND UP?
042908 3E      7576 LD      A,0
042909 00 
04290A 18      7577 JR      STR26
04290B 15 
04290C F5      7578 STR24:			PUSH    AF
04290D 79      7579 LD      A,C
04290E CE      7580 ADC     A,'0'           ;ADD CARRY
04290F 30 
042910 FE      7581 CP      '0'
042911 30 
042912 28      7582 JR      Z,STR25         ;SUPPRESS ZERO
042913 05 
042914 FE      7583 CP      '9'+1
042915 3A 
042916 3F      7584 CCF
042917 30      7585 JR      NC,STR26
042918 08 
042919 E3      7586 STR25:			EX      (SP),HL
04291A CB      7587 BIT     6,L             ;ZERO FLAG
04291B 75 
04291C E3      7588 EX      (SP),HL
04291D 20      7589 JR      NZ,STR27
04291E 05 
04291F 3E      7590 LD      A,'0'
042920 30 
042921 3C      7591 STR26:			INC     A               ;SET +VE
042922 3D      7592 DEC     A
042923 F5      7593 PUSH    AF              ;PUT ON STACK + CARRY
042924 04      7594 STR27:			INC     B
042925 CD      7595 CALL    TEST_FP            ;IS HLH'L' ZERO?
042926 FF 
042927 2B 
042928 04 
042929 0E      7596 LD      C,32
04292A 20 
04292B 3E      7597 LD      A,0
04292C 00 
04292D 20      7598 JR      NZ,STR22
04292E B8 
04292F F1      7599 POP     AF
042930 F5      7600 PUSH    AF
042931 3E      7601 LD      A,0
042932 00 
042933 38      7602 JR      C,STR22
042934 B2 
               7603 ;
               7604 ;At this point, the decimal character string is stored
               7605 ; on the stack. Trailing zeroes are suppressed and may
               7606 ; need to be replaced.
               7607 ;B register holds decimal point position.
               7608 ;Now format number and store as ASCII string:
               7609 ;
042935 EB      7610 STR3:			EX      DE,HL           ;STRING POINTER
042936 0E      7611 LD      C,-1            ;FLAG "E"
042937 FF 
042938 16      7612 LD      D,1
042939 01 
04293A DD      7613 LD      E,(IX+1)        ;f2
04293B 5E 
04293C 01 
04293D DD      7614 BIT     0,(IX+2)
04293E CB 
04293F 02 
042940 46 
042941 20      7615 JR      NZ,STR34        ;E MODE
042942 35 
042943 DD      7616 BIT     1,(IX+2)
042944 CB 
042945 02 
042946 4E 
042947 28      7617 JR      Z,STR31
042948 12 
042949 78      7618 LD      A,B             ;F MODE
04294A B7      7619 OR      A
04294B 28      7620 JR      Z,STR30
04294C 05 
04294D FA      7621 JP      M,STR30
04294E 52 
04294F 29 
042950 04 
042951 50      7622 LD      D,B
042952 7A      7623 STR30:			LD      A,D
042953 DD      7624 ADD     A,(IX+1)
042954 86 
042955 01 
042956 5F      7625 LD      E,A
042957 FE      7626 CP      11
042958 0B 
042959 38      7627 JR      C,STR32
04295A 19 
04295B 78      7628 STR31:			LD      A,B             ;G MODE
04295C 11      7629 LD      DE,101H
04295D 01 
04295E 01 
04295F 00 
042960 B7      7630 OR      A
042961 FA      7631 JP      M,STR34
042962 78 
042963 29 
042964 04 
042965 28      7632 JR      Z,STR32
042966 0D 
042967 DD      7633 LD      A,(IX+1)
042968 7E 
042969 01 
04296A B7      7634 OR      A
04296B 20      7635 JR      NZ,STR3A
04296C 02 
04296D 3E      7636 LD      A,10
04296E 0A 
04296F B8      7637 STR3A:			CP      B
042970 38      7638 JR      C,STR34
042971 06 
042972 50      7639 LD      D,B
042973 58      7640 LD      E,B
042974 78      7641 STR32:			LD      A,B
042975 C6      7642 ADD     A,129
042976 81 
042977 4F      7643 LD      C,A
042978 CB      7644 STR34:			SET     7,D
042979 FA 
04297A 1D      7645 DEC     E
04297B 7A      7646 STR35:			LD      A,D
04297C B9      7647 CP      C
04297D 30      7648 JR      NC,STR33
04297E 0E 
04297F F1      7649 STR36:			POP     AF
042980 28      7650 JR      Z,STR37
042981 04 
042982 F2      7651 JP      P,STR38
042983 8F 
042984 29 
042985 04 
042986 F5      7652 STR37:			PUSH    AF
042987 1C      7653 INC     E
042988 1D      7654 DEC     E
042989 FA      7655 JP      M,STR4
04298A A0 
04298B 29 
04298C 04 
04298D 3E      7656 STR33:			LD      A,'0'
04298E 30 
04298F 15      7657 STR38:			DEC     D
042990 E2      7658 JP      PO,STR39
042991 97 
042992 29 
042993 04 
042994 36      7659 LD      (HL),'.'
042995 2E 
042996 23      7660 INC     HL
042997 77      7661 STR39:			LD      (HL),A
042998 23      7662 INC     HL
042999 1D      7663 DEC     E
04299A F2      7664 JP      P,STR35
04299B 7B 
04299C 29 
04299D 04 
04299E 18      7665 JR      STR36
04299F DF 
               7666 ;
0429A0 F1      7667 STR4:			POP     AF
0429A1 0C      7668 STR40:			INC     C
0429A2 4D      7669 LD      C,L
0429A3 20      7670 JR      NZ,STR44
0429A4 28 
0429A5 36      7671 LD      (HL),'E'        ;EXPONENT
0429A6 45 
0429A7 23      7672 INC     HL
0429A8 78      7673 LD      A,B
0429A9 3D      7674 DEC     A
0429AA F2      7675 JP      P,STR41
0429AB B3 
0429AC 29 
0429AD 04 
0429AE 36      7676 LD      (HL),'-'
0429AF 2D 
0429B0 23      7677 INC     HL
0429B1 ED      7678 NEG
0429B2 44 
0429B3 36      7679 STR41:			LD      (HL),'0'
0429B4 30 
0429B5 28      7680 JR      Z,STR47
0429B6 15 
0429B7 FE      7681 CP      10
0429B8 0A 
0429B9 47      7682 LD      B,A
0429BA 3E      7683 LD      A,':'
0429BB 3A 
0429BC 38      7684 JR      C,STR42
0429BD 03 
0429BE 23      7685 INC     HL
0429BF 36      7686 LD      (HL),'0'
0429C0 30 
0429C1 34      7687 STR42:			INC     (HL)
0429C2 BE      7688 CP      (HL)
0429C3 20      7689 JR      NZ,STR43
0429C4 05 
0429C5 36      7690 LD      (HL),'0'
0429C6 30 
0429C7 2B      7691 DEC     HL
0429C8 34      7692 INC     (HL)
0429C9 23      7693 INC     HL
0429CA 10      7694 STR43:			DJNZ    STR42
0429CB F5 
0429CC 23      7695 STR47:			INC     HL
0429CD EB      7696 STR44:			EX      DE,HL
0429CE C9      7697 RET
               7698 ;
               7699 ;Support subroutines:
               7700 ;
0429CF DD      7701 DLOAD5:			LD      B,(IX+4)
0429D0 46 
0429D1 04 
0429D2 D9      7702 EXX
0429D3 DD      7703 LD      E,(IX+0)
0429D4 5E 
0429D5 00 
0429D6 DD      7704 LD      D,(IX+1)
0429D7 56 
0429D8 01 
0429D9 D9      7705 EXX
0429DA DD      7706 LD      E,(IX+2)
0429DB 5E 
0429DC 02 
0429DD DD      7707 LD      D,(IX+3)
0429DE 56 
0429DF 03 
0429E0 C9      7708 RET
               7709 ;
0429E1 DD      7710 DLOAD5_SPL:		LD      B,(IX+6)
0429E2 46 
0429E3 06 
0429E4 D9      7711 EXX
0429E5 DD      7712 LD	DE, (IX+0)
0429E6 17 
0429E7 00 
0429E8 D9      7713 EXX
0429E9 DD      7714 LD	DE, (IX+3)
0429EA 17 
0429EB 03 
0429EC C9      7715 RET
               7716 ;
               7717 ;CON_FP - Get unsigned numeric constant from ASCII string.
               7718 ;   Inputs: ASCII string at (IX).
               7719 ;  Outputs: Variable-type result in HLH'L'C
               7720 ;           IX updated (points to delimiter)
               7721 ;           A7 = 0 (numeric marker)
               7722 ;
0429ED CD      7723 CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0429EE 23 
0429EF 2C 
0429F0 04 
0429F1 0E      7724 LD      C,0             ;TRUNCATION COUNTER
0429F2 00 
0429F3 CD      7725 CALL    UINT          ;GET INTEGER PART
0429F4 81 
0429F5 2A 
0429F6 04 
0429F7 FE      7726 CP      '.'
0429F8 2E 
0429F9 06      7727 LD      B,0             ;DECL. PLACE COUNTER
0429FA 00 
0429FB CC      7728 CALL    Z,NUMBIX        ;GET FRACTION PART
0429FC 7F 
0429FD 2A 
0429FE 04 
0429FF FE      7729 CP      'E'
042A00 45 
042A01 3E      7730 LD      A,0             ;INITIALISE EXPONENT
042A02 00 
042A03 CC      7731 CALL    Z,GETEXP        ;GET EXPONENT
042A04 4D 
042A05 2A 
042A06 04 
042A07 CB      7732 BIT     7,H
042A08 7C 
042A09 20      7733 JR      NZ,CON0         ;INTEGER OVERFLOW
042A0A 08 
042A0B B7      7734 OR      A
042A0C 20      7735 JR      NZ,CON0         ;EXPONENT NON-ZERO
042A0D 05 
042A0E B8      7736 CP      B
042A0F 20      7737 JR      NZ,CON0         ;DECIMAL POINT
042A10 02 
042A11 B9      7738 CP      C
042A12 C8      7739 RET     Z               ;INTEGER
042A13 90      7740 CON0:			SUB     B
042A14 81      7741 ADD     A,C
042A15 0E      7742 LD      C,159
042A16 9F 
042A17 CD      7743 CALL    FLOAT_
042A18 86 
042A19 2B 
042A1A 04 
042A1B CB      7744 RES     7,H             ;DITCH IMPLIED 1
042A1C BC 
042A1D B7      7745 OR      A
042A1E C8      7746 RET     Z               ;DONE
042A1F FA      7747 JP      M,CON2          ;NEGATIVE EXPONENT
042A20 2D 
042A21 2A 
042A22 04 
042A23 CD      7748 CALL    POWR10
042A24 1F 
042A25 2D 
042A26 04 
042A27 CD      7749 CALL    FMUL            ;SCALE
042A28 0E 
042A29 23 
042A2A 04 
042A2B AF      7750 XOR     A
042A2C C9      7751 RET
042A2D FE      7752 CON2:			CP      -38
042A2E DA 
042A2F 38      7753 JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A30 0C 
042A31 ED      7754 NEG
042A32 44 
042A33 CD      7755 CALL    POWR10
042A34 1F 
042A35 2D 
042A36 04 
042A37 CD      7756 CALL    FDIV            ;SCALE
042A38 65 
042A39 22 
042A3A 04 
042A3B AF      7757 XOR     A
042A3C C9      7758 RET
042A3D F5      7759 CON3:			PUSH    AF
042A3E 3E      7760 LD      A,38
042A3F 26 
042A40 CD      7761 CALL    POWR10
042A41 1F 
042A42 2D 
042A43 04 
042A44 CD      7762 CALL    FDIV
042A45 65 
042A46 22 
042A47 04 
042A48 F1      7763 POP     AF
042A49 C6      7764 ADD     A,38
042A4A 26 
042A4B 18      7765 JR      CON2
042A4C E0 
               7766 ;
               7767 ;GETEXP - Get decimal exponent from string
               7768 ;     Inputs: ASCII string at (IX)
               7769 ;             (IX points at 'E')
               7770 ;             A = initial value
               7771 ;    Outputs: A = new exponent
               7772 ;             IX updated.
               7773 ;   Destroys: A,A',IX,F,F'
               7774 ;
042A4D C5      7775 GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A4E 47      7776 LD      B,A             ;INITIAL VALUE
042A4F 0E      7777 LD      C,2             ;2 DIGITS MAX
042A50 02 
042A51 DD      7778 INC     IX              ;BUMP PAST 'E'
042A52 23 
042A53 CD      7779 CALL    SIGNQ
042A54 3D 
042A55 2E 
042A56 04 
042A57 08      7780 EX      AF,AF'          ;SAVE EXPONENT SIGN
042A58 CD      7781 GETEX1:			CALL    DIGITQ
042A59 33 
042A5A 2E 
042A5B 04 
042A5C 38      7782 JR      C,GETEX2
042A5D 18 
042A5E 78      7783 LD      A,B             ;B=B*10
042A5F 87      7784 ADD     A,A
042A60 87      7785 ADD     A,A
042A61 80      7786 ADD     A,B
042A62 87      7787 ADD     A,A
042A63 47      7788 LD      B,A
042A64 DD      7789 LD      A,(IX)          ;GET BACK DIGIT
042A65 7E 
042A66 00 
042A67 DD      7790 INC     IX
042A68 23 
042A69 E6      7791 AND     0FH             ;MASK UNWANTED BITS
042A6A 0F 
042A6B 80      7792 ADD     A,B             ;ADD IN DIGIT
042A6C 47      7793 LD      B,A
042A6D 0D      7794 DEC     C
042A6E F2      7795 JP      P,GETEX1
042A6F 58 
042A70 2A 
042A71 04 
042A72 06      7796 LD      B,100           ;FORCE OVERFLOW
042A73 64 
042A74 18      7797 JR      GETEX1
042A75 E2 
042A76 08      7798 GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042A77 FE      7799 CP      '-'
042A78 2D 
042A79 78      7800 LD      A,B
042A7A C1      7801 POP     BC              ;RESTORE
042A7B C0      7802 RET     NZ
042A7C ED      7803 NEG                     ;NEGATE EXPONENT
042A7D 44 
042A7E C9      7804 RET
               7805 ;
               7806 ;UINT: Get unsigned integer from string.
               7807 ;    Inputs: string at (IX)
               7808 ;            C = truncated digit count
               7809 ;                (initially zero)
               7810 ;            B = total digit count
               7811 ;            HLH'L' = initial value
               7812 ;   Outputs: HLH'L' = number (binary integer)
               7813 ;            A = delimiter.
               7814 ;            B, C & IX updated
               7815 ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7816 ;
042A7F DD      7817 NUMBIX:			INC     IX
042A80 23 
042A81 CD      7818 UINT:			CALL    DIGITQ
042A82 33 
042A83 2E 
042A84 04 
042A85 D8      7819 RET     C
042A86 04      7820 INC     B               ;INCREMENT DIGIT COUNT
042A87 DD      7821 INC     IX
042A88 23 
042A89 CD      7822 CALL    X10             ;*10 & COPY OLD VALUE
042A8A 7C 
042A8B 2C 
042A8C 04 
042A8D 38      7823 JR      C,NUMB1         ;OVERFLOW
042A8E 15 
042A8F 0D      7824 DEC     C               ;SEE IF TRUNCATED
042A90 0C      7825 INC     C
042A91 20      7826 JR      NZ,NUMB1        ;IMPORTANT!
042A92 11 
042A93 E6      7827 AND     0FH
042A94 0F 
042A95 D9      7828 EXX
042A96 06      7829 LD      B,0
042A97 00 
042A98 4F      7830 LD      C,A
042A99 52      7831 ADD.S   HL,BC           ;ADD IN DIGIT
042A9A 09 
042A9B D9      7832 EXX
042A9C 30      7833 JR      NC,UINT
042A9D E3 
042A9E 52      7834 INC.S   HL              ;CARRY
042A9F 23 
042AA0 7C      7835 LD      A,H
042AA1 B5      7836 OR      L
042AA2 20      7837 JR      NZ,UINT
042AA3 DD 
042AA4 0C      7838 NUMB1:			INC     C               ;TRUNCATION COUNTER
042AA5 CD      7839 CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AA6 DA 
042AA7 2B 
042AA8 04 
042AA9 18      7840 JR      UINT
042AAA D6 
               7841 ;
               7842 ;FIX - Fix number to specified exponent value.
               7843 ;    Inputs: HLH'L'C = +ve non-zero number (floated)
               7844 ;            A = desired exponent (A>C)
               7845 ;   Outputs: HLH'L'C = fixed number (unsigned)
               7846 ;            fraction shifted into B'C'
               7847 ;            A'F' positive if integer input
               7848 ;  Destroys: C,H,L,A',B',C',H',L',F,F'
               7849 ;
042AAB 08      7850 FIX:			EX      AF,AF'
042AAC AF      7851 XOR     A
042AAD 08      7852 EX      AF,AF'
042AAE CB      7853 SET     7,H             ;IMPLIED 1
042AAF FC 
042AB0 CD      7854 FIX1:			CALL    DIV2
042AB1 DF 
042AB2 2B 
042AB3 04 
042AB4 B9      7855 CP      C
042AB5 C8      7856 RET     Z
042AB6 D2      7857 JP      NC,FIX1
042AB7 B0 
042AB8 2A 
042AB9 04 
042ABA C3      7858 JP      OFLOW
042ABB EE 
042ABC 2B 
042ABD 04 
               7859 ;
               7860 ;SFIX - Convert to integer if necessary.
               7861 ;    Input: Variable-type number in HLH'L'C
               7862 ;   Output: Integer in HLH'L', C=0
               7863 ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
               7864 ;
               7865 ;NEGATE - Negate HLH'L'
               7866 ;    Destroys: H,L,H',L',F
               7867 ;
042ABE CD      7868 FIX2:			CALL    SWAP_FP
042ABF D7 
042AC0 2B 
042AC1 04 
042AC2 CD      7869 CALL    SFIX_FP
042AC3 CA 
042AC4 2A 
042AC5 04 
042AC6 CD      7870 CALL    SWAP_FP
042AC7 D7 
042AC8 2B 
042AC9 04 
042ACA 0D      7871 SFIX_FP:			DEC     C
042ACB 0C      7872 INC     C
042ACC C8      7873 RET     Z               ;INTEGER/ZERO
042ACD CB      7874 BIT     7,H             ;SIGN
042ACE 7C 
042ACF F5      7875 PUSH    AF
042AD0 3E      7876 LD      A,159
042AD1 9F 
042AD2 CD      7877 CALL    FIX
042AD3 AB 
042AD4 2A 
042AD5 04 
042AD6 F1      7878 POP     AF
042AD7 0E      7879 LD      C,0
042AD8 00 
042AD9 C8      7880 RET     Z
042ADA B7      7881 NEGATE:			OR      A               ;CLEAR CARRY
042ADB D9      7882 EXX
042ADC D5      7883 NEG0:			PUSH    DE
042ADD EB      7884 EX      DE,HL
042ADE 21      7885 LD      HL,0
042ADF 00 
042AE0 00 
042AE1 00 
042AE2 52      7886 SBC.S   HL,DE
042AE3 ED 
042AE4 52 
042AE5 D1      7887 POP     DE
042AE6 D9      7888 EXX
042AE7 D5      7889 PUSH    DE
042AE8 EB      7890 EX      DE,HL
042AE9 21      7891 LD      HL,0
042AEA 00 
042AEB 00 
042AEC 00 
042AED 52      7892 SBC.S   HL,DE
042AEE ED 
042AEF 52 
042AF0 D1      7893 POP     DE
042AF1 C9      7894 RET
               7895 ;
               7896 ;NEG - Negate HLH'L'B'C'
               7897 ;    Also complements A (used in FADD)
               7898 ;    Destroys: A,H,L,B',C',H',L',F
               7899 ;
042AF2 D9      7900 NEG_:			EXX
042AF3 2F      7901 CPL
042AF4 E5      7902 PUSH    HL
042AF5 B7      7903 OR      A               ;CLEAR CARRY
042AF6 21      7904 LD      HL,0
042AF7 00 
042AF8 00 
042AF9 00 
042AFA 52      7905 SBC.S   HL,BC
042AFB ED 
042AFC 42 
042AFD 44      7906 LD      B,H
042AFE 4D      7907 LD      C,L
042AFF E1      7908 POP     HL
042B00 18      7909 JR      NEG0
042B01 DA 
               7910 ;
               7911 ;SCALE - Trig scaling.
               7912 ;MOD48 - 48-bit floating-point "modulus" (remainder).
               7913 ;   Inputs: HLH'L'C unsigned floating-point dividend
               7914 ;           DED'E'B'C'B unsigned 48-bit FP divisor
               7915 ;  Outputs: HLH'L'C floating point remainder (H7=1)
               7916 ;           E = quotient (bit 7 is sticky)
               7917 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7918 ;FLO48 - Float unsigned number (48 bits)
               7919 ;    Input/output in HLH'L'B'C'C
               7920 ;   Destroys: C,H,L,B',C',H',L',F
               7921 ;
042B02 3E      7922 SCALE:			LD      A,150
042B03 96 
042B04 B9      7923 CP      C
042B05 3E      7924 LD      A,ACLOST
042B06 17 
042B07 DA      7925 JP      C,ERROR_FP_         ;"Accuracy lost"
042B08 7D 
042B09 20 
042B0A 04 
042B0B CD      7926 CALL    PIBY4
042B0C 48 
042B0D 26 
042B0E 04 
042B0F D9      7927 EXX
042B10 01      7928 LD      BC,2169H        ;3.141592653589793238
042B11 69 
042B12 21 
042B13 00 
042B14 D9      7929 EXX
042B15 CB      7930 MOD48:			SET     7,D             ;IMPLIED 1
042B16 FA 
042B17 CB      7931 SET     7,H
042B18 FC 
042B19 79      7932 LD      A,C
042B1A 0E      7933 LD      C,0             ;INIT QUOTIENT
042B1B 00 
042B1C DD      7934 LD      IX,0
042B1D 21 
042B1E 00 
042B1F 00 
042B1F 00   
042B21 DD      7935 PUSH    IX              ;PUT ZERO ON STACK
042B22 E5 
042B23 B8      7936 CP      B
042B24 38      7937 JR      C,MOD485        ;DIVIDEND<DIVISOR
042B25 46 
042B26 D9      7938 MOD481:			EXX                     ;CARRY=0 HERE
042B27 E3      7939 EX      (SP),HL
042B28 52      7940 SBC.S   HL,BC
042B29 ED 
042B2A 42 
042B2B E3      7941 EX      (SP),HL
042B2C 52      7942 SBC.S   HL,DE
042B2D ED 
042B2E 52 
042B2F D9      7943 EXX
042B30 52      7944 SBC.S   HL,DE
042B31 ED 
042B32 52 
042B33 30      7945 JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B34 0C 
042B35 D9      7946 EXX
042B36 E3      7947 EX      (SP),HL
042B37 52      7948 ADD.S   HL,BC
042B38 09 
042B39 E3      7949 EX      (SP),HL
042B3A 52      7950 ADC.S   HL,DE
042B3B ED 
042B3C 5A 
042B3D D9      7951 EXX
042B3E 52      7952 ADC.S   HL,DE
042B3F ED 
042B40 5A 
042B41 3F      7953 MOD482:			CCF
042B42 CB      7954 RL      C               ;QUOTIENT
042B43 11 
042B44 30      7955 JR      NC,MOD483
042B45 02 
042B46 CB      7956 SET     7,C             ;STICKY BIT
042B47 F9 
042B48 3D      7957 MOD483:			DEC     A
042B49 B8      7958 CP      B
042B4A 38      7959 JR      C,MOD484        ;DIVIDEND<DIVISOR
042B4B 1F 
042B4C E3      7960 EX      (SP),HL
042B4D 52      7961 ADD.S   HL,HL           ;DIVIDEND * 2
042B4E 29 
042B4F E3      7962 EX      (SP),HL
042B50 D9      7963 EXX
042B51 52      7964 ADC.S   HL,HL
042B52 ED 
042B53 6A 
042B54 D9      7965 EXX
042B55 52      7966 ADC.S   HL,HL
042B56 ED 
042B57 6A 
042B58 30      7967 JR      NC,MOD481       ;AGAIN
042B59 CC 
042B5A B7      7968 OR      A
042B5B D9      7969 EXX
042B5C E3      7970 EX      (SP),HL
042B5D 52      7971 SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B5E ED 
042B5F 42 
042B60 E3      7972 EX      (SP),HL
042B61 52      7973 SBC.S   HL,DE
042B62 ED 
042B63 52 
042B64 D9      7974 EXX
042B65 52      7975 SBC.S   HL,DE
042B66 ED 
042B67 52 
042B68 B7      7976 OR      A
042B69 18      7977 JR      MOD482
042B6A D6 
               7978 ;
042B6B 3C      7979 MOD484:			INC     A
042B6C 59      7980 MOD485:			LD      E,C             ;QUOTIENT
042B6D 4F      7981 LD      C,A             ;REMAINDER EXPONENT
042B6E D9      7982 EXX
042B6F C1      7983 POP     BC
042B70 D9      7984 EXX
042B71 CB      7985 FLO48:			BIT     7,H
042B72 7C 
042B73 C0      7986 RET     NZ
042B74 D9      7987 EXX
042B75 CB      7988 SLA     C
042B76 21 
042B77 CB      7989 RL      B
042B78 10 
042B79 52      7990 ADC.S   HL,HL
042B7A ED 
042B7B 6A 
042B7C D9      7991 EXX
042B7D 52      7992 ADC.S   HL,HL
042B7E ED 
042B7F 6A 
042B80 0D      7993 DEC     C
042B81 C2      7994 JP      NZ,FLO48
042B82 71 
042B83 2B 
042B84 04 
042B85 C9      7995 RET
               7996 ;
               7997 ;Float unsigned number
               7998 ;    Input/output in HLH'L'C
               7999 ;   Destroys: C,H,L,H',L',F
               8000 ;
042B86 CB      8001 FLOAT_:			BIT     7,H
042B87 7C 
042B88 C0      8002 RET     NZ
042B89 D9      8003 EXX                     ;SAME AS "X2"
042B8A 52      8004 ADD.S   HL,HL           ;TIME-CRITICAL
042B8B 29 
042B8C D9      8005 EXX                     ;REGION
042B8D 52      8006 ADC.S   HL,HL           ;(BENCHMARKS)
042B8E ED 
042B8F 6A 
042B90 0D      8007 DEC     C
042B91 C2      8008 JP      NZ,FLOAT_
042B92 86 
042B93 2B 
042B94 04 
042B95 C9      8009 RET
               8010 ;
               8011 ;SFLOAT - Convert to floating-point if necessary.
               8012 ;    Input: Variable-type number in HLH'L'C
               8013 ;    Output: Floating-point in HLH'L'C
               8014 ;    Destroys: A,C,H,L,H',L',F
               8015 ;
042B96 08      8016 FLOATA:			EX      AF,AF'
               8017 ; ADD     A,(RTABLE-DTABLE)/3
042B97 C6      8018 ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042B98 2A 
042B99 08      8019 EX      AF,AF'
042B9A CD      8020 FLOAT2:			CALL    SWAP_FP
042B9B D7 
042B9C 2B 
042B9D 04 
042B9E CD      8021 CALL    SFLOAT_FP
042B9F A6 
042BA0 2B 
042BA1 04 
042BA2 CD      8022 CALL    SWAP_FP
042BA3 D7 
042BA4 2B 
042BA5 04 
042BA6 0D      8023 SFLOAT_FP:			DEC     C
042BA7 0C      8024 INC     C
042BA8 C0      8025 RET     NZ              ;ALREADY FLOATING-POINT
042BA9 CD      8026 CALL    TEST_FP
042BAA FF 
042BAB 2B 
042BAC 04 
042BAD C8      8027 RET     Z               ;ZERO
042BAE 7C      8028 LD      A,H
042BAF B7      8029 OR      A
042BB0 FC      8030 CALL    M,NEGATE
042BB1 DA 
042BB2 2A 
042BB3 04 
042BB4 0E      8031 LD      C,159
042BB5 9F 
042BB6 CD      8032 CALL    FLOAT_
042BB7 86 
042BB8 2B 
042BB9 04 
042BBA B7      8033 OR      A
042BBB F8      8034 RET     M               ;NEGATIVE
042BBC CB      8035 RES     7,H
042BBD BC 
042BBE C9      8036 RET
               8037 ;
               8038 ;ROUND UP
               8039 ;Return with carry set if 32-bit overflow
               8040 ;   Destroys: H,L,B',C',H',L',F
               8041 ;
042BBF D9      8042 ADD1_FP:			EXX
042BC0 01      8043 LD      BC,1
042BC1 01 
042BC2 00 
042BC3 00 
042BC4 52      8044 ADD.S   HL,BC
042BC5 09 
042BC6 D9      8045 EXX
042BC7 D0      8046 RET     NC
042BC8 C5      8047 PUSH    BC
042BC9 01      8048 LD      BC,1
042BCA 01 
042BCB 00 
042BCC 00 
042BCD 52      8049 ADD.S   HL,BC
042BCE 09 
042BCF C1      8050 POP     BC
042BD0 C9      8051 RET
               8052 ;
               8053 ;ODD - Add one if even, leave alone if odd.
               8054 ; (Used to perform unbiassed rounding, i.e.
               8055 ;  number is rounded up half the time)
               8056 ;    Destroys: L',F (carry cleared)
               8057 ;
042BD1 B7      8058 ODD:			OR      A               ;CLEAR CARRY
042BD2 D9      8059 EXX
042BD3 CB      8060 SET     0,L             ;MAKE ODD
042BD4 C5 
042BD5 D9      8061 EXX
042BD6 C9      8062 RET
               8063 ;
               8064 ;SWAP_FP - Swap arguments.
               8065 ;    Exchanges DE,HL D'E',H'L' and B,C
               8066 ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
               8067 ;SWAP1 - Swap DEHL with D'E'H'L'
               8068 ;    Destroys: D,E,H,L,D',E',H',L'
               8069 ;
042BD7 79      8070 SWAP_FP:			LD      A,C
042BD8 48      8071 LD      C,B
042BD9 47      8072 LD      B,A
042BDA EB      8073 SWAP1:			EX      DE,HL
042BDB D9      8074 EXX
042BDC EB      8075 EX      DE,HL
042BDD D9      8076 EXX
042BDE C9      8077 RET
               8078 ;
               8079 ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
               8080 ; INCC - destroys C,F
               8081 ; OFLOW
               8082 ;
042BDF CD      8083 DIV2:			CALL    D2
042BE0 98 
042BE1 2C 
042BE2 04 
042BE3 D9      8084 EXX
042BE4 CB      8085 RR      B
042BE5 18 
042BE6 CB      8086 RR      C
042BE7 19 
042BE8 08      8087 EX      AF,AF'
042BE9 B0      8088 OR      B
042BEA 08      8089 EX      AF,AF'
042BEB D9      8090 EXX
042BEC 0C      8091 INCC:			INC     C
042BED C0      8092 RET     NZ
042BEE 3E      8093 OFLOW:			LD      A,TOOBIG_FP
042BEF 14 
042BF0 C3      8094 JP      ERROR_FP_           ;"Too big"
042BF1 7D 
042BF2 20 
042BF3 04 
               8095 ;
               8096 ; FTEST - Test for zero & sign
               8097 ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
               8098 ;
042BF4 CD      8099 FTEST_FP:			CALL    TEST_FP
042BF5 FF 
042BF6 2B 
042BF7 04 
042BF8 C8      8100 RET     Z
042BF9 7C      8101 LD      A,H
042BFA E6      8102 AND     10000000B
042BFB 80 
042BFC F6      8103 OR      01000000B
042BFD 40 
042BFE C9      8104 RET
               8105 ;
               8106 ; TEST_FP - Test HLH'L' for zero.
               8107 ;     Output: Z-flag set & A=0 if HLH'L'=0
               8108 ;     Destroys: A,F
               8109 ;
042BFF 7C      8110 TEST_FP:			LD      A,H
042C00 B5      8111 OR      L
042C01 D9      8112 EXX
042C02 B4      8113 OR      H
042C03 B5      8114 OR      L
042C04 D9      8115 EXX
042C05 C9      8116 RET
               8117 ;
               8118 ; FCOMP - Compare two numbers
               8119 ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
               8120 ;
042C06 78      8121 FCOMP_FP:			LD      A,B
042C07 B1      8122 OR      C               ;Both integer?
042C08 20      8123 JR      NZ,FCOMP1
042C09 0B 
042C0A CD      8124 CALL    ICP
042C0B 1F 
042C0C 2C 
042C0D 04 
042C0E 3E      8125 FCOMP0:			LD      A,0
042C0F 00 
042C10 C8      8126 RET     Z               ;Equal
042C11 3E      8127 LD      A,80H
042C12 80 
042C13 1F      8128 RRA
042C14 C9      8129 RET
               8130 ;
042C15 CD      8131 FCOMP1:			CALL    FLOAT2          ;Float both
042C16 9A 
042C17 2B 
042C18 04 
042C19 CD      8132 CALL    FCP
042C1A 2D 
042C1B 2C 
042C1C 04 
042C1D 18      8133 JR      FCOMP0
042C1E EF 
               8134 ;
               8135 ; Integer and floating point compare.
               8136 ; Sets carry & zero flags according to HLH'L'C-DED'E'B
               8137 ; Result pre-set to FALSE
               8138 ; ICP1, FCP1 destroy A,F
               8139 ;
               8140 ; ZERO - Return zero.
               8141 ;  Destroys: A,C,H,L,H',L'
               8142 ;
042C1F CD      8143 ICP:			CALL    ICP1
042C20 52 
042C21 2C 
042C22 04 
042C23 3E      8144 ZERO_FP:			LD      A,0
042C24 00 
042C25 D9      8145 EXX
042C26 67      8146 LD      H,A
042C27 6F      8147 LD      L,A
042C28 D9      8148 EXX
042C29 67      8149 LD      H,A
042C2A 6F      8150 LD      L,A
042C2B 4F      8151 LD      C,A
042C2C C9      8152 RET
               8153 ;
042C2D CD      8154 FCP:			CALL    FCP1
042C2E 44 
042C2F 2C 
042C30 04 
042C31 18      8155 JR      ZERO_FP            ;PRESET FALSE
042C32 F0 
               8156 ;
042C33 79      8157 FCP0:			LD      A,C
042C34 B8      8158 CP      B               ;COMPARE EXPONENTS
042C35 C0      8159 RET     NZ
               8160 ICP0:
042C36 52      8161 SBC.S   HL,DE           ;COMP MANTISSA MSB
042C37 ED 
042C38 52 
042C39 52      8162 ADD.S   HL,DE
042C3A 19 
042C3B C0      8163 RET     NZ
042C3C D9      8164 EXX
042C3D 52      8165 SBC.S   HL,DE           ;COMP MANTISSA LSB
042C3E ED 
042C3F 52 
042C40 52      8166 ADD.S   HL,DE
042C41 19 
042C42 D9      8167 EXX
042C43 C9      8168 RET
               8169 ;
042C44 7C      8170 FCP1:			LD      A,H
042C45 AA      8171 XOR     D
042C46 7C      8172 LD      A,H
042C47 17      8173 RLA
042C48 F8      8174 RET     M
042C49 30      8175 JR      NC,FCP0
042C4A E8 
042C4B CD      8176 CALL    FCP0
042C4C 33 
042C4D 2C 
042C4E 04 
042C4F C8      8177 RET     Z               ;** V0.1 BUG FIX
042C50 3F      8178 CCF
042C51 C9      8179 RET
               8180 ;
042C52 7C      8181 ICP1:			LD      A,H
042C53 AA      8182 XOR     D
042C54 F2      8183 JP      P,ICP0
042C55 36 
042C56 2C 
042C57 04 
042C58 7C      8184 LD      A,H
042C59 17      8185 RLA
042C5A C9      8186 RET
               8187 ;
               8188 ; ADD - Integer add.
               8189 ; Carry, sign & zero flags valid on exit
               8190 ;     Destroys: H,L,H',L',F
               8191 ;
042C5B 05      8192 X10B:			DEC     B
042C5C 0C      8193 INC     C
042C5D CD      8194 X5:			CALL    COPY0
042C5E A4 
042C5F 2C 
042C60 04 
042C61 CD      8195 CALL    D2C
042C62 97 
042C63 2C 
042C64 04 
042C65 CD      8196 CALL    D2C
042C66 97 
042C67 2C 
042C68 04 
042C69 08      8197 EX      AF,AF'          ;SAVE CARRY
042C6A D9      8198 ADD_:			EXX
042C6B 52      8199 ADD.S   HL,DE
042C6C 19 
042C6D D9      8200 EXX
042C6E 52      8201 ADC.S   HL,DE
042C6F ED 
042C70 5A 
042C71 C9      8202 RET
               8203 ;
               8204 ; SUB - Integer subtract.
               8205 ; Carry, sign & zero flags valid on exit
               8206 ;     Destroys: H,L,H',L',F
               8207 ;
042C72 D9      8208 SUB_:			EXX
042C73 B7      8209 OR      A
042C74 52      8210 SBC.S   HL,DE
042C75 ED 
042C76 52 
042C77 D9      8211 EXX
042C78 52      8212 SBC.S   HL,DE
042C79 ED 
042C7A 52 
042C7B C9      8213 RET
               8214 ;
               8215 ; X10 - unsigned integer * 10
               8216 ;    Inputs: HLH'L' initial value
               8217 ;   Outputs: DED'E' = initial HLH'L'
               8218 ;            Carry bit set if overflow
               8219 ;            If carry not set HLH'L'=result
               8220 ;  Destroys: D,E,H,L,D',E',H',L',F
               8221 ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
               8222 ;     Carry set if MSB=1 before shift.
               8223 ;     Sign set if MSB=1 after shift.
               8224 ;     Destroys: H,L,H',L',F
               8225 ;
042C7C CD      8226 X10:			CALL    COPY0           ;DED'E'=HLH'L'
042C7D A4 
042C7E 2C 
042C7F 04 
042C80 CD      8227 CALL    X2
042C81 8F 
042C82 2C 
042C83 04 
042C84 D8      8228 RET     C               ;TOO BIG
042C85 CD      8229 CALL    X2
042C86 8F 
042C87 2C 
042C88 04 
042C89 D8      8230 RET     C
042C8A CD      8231 CALL    ADD_
042C8B 6A 
042C8C 2C 
042C8D 04 
042C8E D8      8232 RET     C
042C8F D9      8233 X2:			EXX
042C90 52      8234 ADD.S   HL,HL
042C91 29 
042C92 D9      8235 EXX
042C93 52      8236 ADC.S   HL,HL
042C94 ED 
042C95 6A 
042C96 C9      8237 RET
               8238 ;
               8239 ; D2 - Divide HLH'L' by 2 as 32-bit integer.
               8240 ;     Carry set if LSB=1 before shift.
               8241 ;     Destroys: H,L,H',L',F
               8242 ;
042C97 0C      8243 D2C:			INC     C
042C98 CB      8244 D2:			SRL     H
042C99 3C 
042C9A CB      8245 RR      L
042C9B 1D 
042C9C D9      8246 EXX
042C9D CB      8247 RR      H
042C9E 1C 
042C9F CB      8248 RR      L
042CA0 1D 
042CA1 D9      8249 EXX
042CA2 C9      8250 RET
               8251 ;
               8252 ; COPY - COPY HLH'L'C INTO DED'E'B
               8253 ;   Destroys: B,C,D,E,H,L,D',E',H',L'
               8254 ;
042CA3 41      8255 COPY_:			LD      B,C
042CA4 54      8256 COPY0:			LD      D,H
042CA5 5D      8257 LD      E,L
042CA6 D9      8258 EXX
042CA7 54      8259 LD      D,H
042CA8 5D      8260 LD      E,L
042CA9 D9      8261 EXX
042CAA C9      8262 RET
               8263 ;
               8264 ; SQUARE - PUSH X*X
               8265 ; PUSH5 - PUSH HLH'L'C ONTO STACK.
               8266 ;   Destroys: SP,IX
               8267 ;
042CAB CD      8268 SQUARE:			CALL    COPY_
042CAC A3 
042CAD 2C 
042CAE 04 
042CAF CD      8269 CALL    FMUL
042CB0 0E 
042CB1 23 
042CB2 04 
042CB3 DD      8270 PUSH5:			POP     IX              ;RETURN ADDRESS
042CB4 E1 
042CB5 C5      8271 PUSH    BC
042CB6 E5      8272 PUSH    HL
042CB7 D9      8273 EXX
042CB8 E5      8274 PUSH    HL
042CB9 D9      8275 EXX
042CBA DD      8276 JP      (IX)            ;"RETURN"
042CBB E9 
               8277 ;
               8278 ; POP5 - POP DED'E'B OFF STACK.
               8279 ;   Destroys: A,B,D,E,D',E',SP,IX
               8280 ;
042CBC DD      8281 POP5:			POP     IX              ;RETURN ADDRESS
042CBD E1 
042CBE D9      8282 EXX
042CBF D1      8283 POP     DE
042CC0 D9      8284 EXX
042CC1 D1      8285 POP     DE
042CC2 79      8286 LD      A,C
042CC3 C1      8287 POP     BC
042CC4 41      8288 LD      B,C
042CC5 4F      8289 LD      C,A
042CC6 DD      8290 JP      (IX)            ;"RETURN"
042CC7 E9 
               8291 ;
               8292 ; RATIO - Calculate (X-1)/(X+1)
               8293 ;     Inputs: X in HLH'L'C
               8294 ;    Outputs: (X-1)/(X+1) in HLH'L'C
               8295 ;   Destroys: Everything except IY,SP,I
               8296 ;
042CC8 CD      8297 RATIO:			CALL    PUSH5           ;SAVE X
042CC9 B3 
042CCA 2C 
042CCB 04 
042CCC CD      8298 CALL    DONE
042CCD 3B 
042CCE 26 
042CCF 04 
042CD0 CD      8299 CALL    FADD
042CD1 FC 
042CD2 21 
042CD3 04 
042CD4 CD      8300 CALL    POP5            ;RESTORE X
042CD5 BC 
042CD6 2C 
042CD7 04 
042CD8 CD      8301 CALL    PUSH5           ;SAVE X+1
042CD9 B3 
042CDA 2C 
042CDB 04 
042CDC CD      8302 CALL    SWAP_FP
042CDD D7 
042CDE 2B 
042CDF 04 
042CE0 CD      8303 CALL    DONE
042CE1 3B 
042CE2 26 
042CE3 04 
042CE4 CD      8304 CALL    FSUB
042CE5 E3 
042CE6 21 
042CE7 04 
042CE8 CD      8305 CALL    POP5            ;RESTORE X+1
042CE9 BC 
042CEA 2C 
042CEB 04 
042CEC C3      8306 JP      FDIV
042CED 65 
042CEE 22 
042CEF 04 
               8307 ;
               8308 ; POLY - Evaluate a polynomial.
               8309 ;     Inputs: X in HLH'L'C and also stored at (SP+2)
               8310 ;             Polynomial coefficients follow call.
               8311 ;    Outputs: Result in HLH'L'C
               8312 ;   Destroys: Everything except IY,SP,I
               8313 ; Routine terminates on finding a coefficient >=1.
               8314 ; Note: The last coefficient is EXECUTED on return
               8315 ;       so must contain only innocuous bytes!
               8316 ;
042CF0 DD      8317 POLY:			LD      IX, 3				; Advance the SP to the return address
042CF1 21 
042CF2 03 
042CF3 00 
042CF3 00   
042CF5 DD      8318 ADD     IX, SP
042CF6 39 
042CF7 DD      8319 EX      (SP), IX			; IX: Points to the inline list of coefficients
042CF8 E3 
               8320 ;
042CF9 CD      8321 CALL    DLOAD5          		; Load the first coefficient from (IX)
042CFA CF 
042CFB 29 
042CFC 04 
042CFD CD      8322 POLY1:			CALL    FMUL
042CFE 0E 
042CFF 23 
042D00 04 
042D01 11      8323 LD      DE, 5				; Skip to the next coefficient
042D02 05 
042D03 00 
042D04 00 
042D05 DD      8324 ADD     IX, DE
042D06 19 
042D07 CD      8325 CALL    DLOAD5          		; Load the second coefficient from (IX)
042D08 CF 
042D09 29 
042D0A 04 
042D0B DD      8326 EX      (SP), IX			; Restore the SP just in case we need to return
042D0C E3 
042D0D 04      8327 INC     B
042D0E 05      8328 DEC     B               		; Test B for end byte (80h)
042D0F FA      8329 JP      M,FADD				; Yes, so add and return
042D10 FC 
042D11 21 
042D12 04 
042D13 CD      8330 CALL    FADD				; No, so add
042D14 FC 
042D15 21 
042D16 04 
042D17 CD      8331 CALL    DLOAD5_SPL			; Load X from SP
042D18 E1 
042D19 29 
042D1A 04 
042D1B DD      8332 EX      (SP), IX			; IX: Points to the inline list of coefficients
042D1C E3 
042D1D 18      8333 JR      POLY1				; And loop
042D1E DE 
               8334 ;
               8335 ; POWR10 - Calculate power of ten.
               8336 ;     Inputs: A=power of 10 required (A<128)
               8337 ;             A=binary exponent to be exceeded (A>=128)
               8338 ;    Outputs: DED'E'B = result
               8339 ;             A = actual power of ten returned
               8340 ;   Destroys: A,B,D,E,A',D',E',F,F'
               8341 ;
042D1F 3C      8342 POWR10:			INC     A
042D20 08      8343 EX      AF,AF'
042D21 E5      8344 PUSH    HL
042D22 D9      8345 EXX
042D23 E5      8346 PUSH    HL
042D24 D9      8347 EXX
042D25 CD      8348 CALL    DONE
042D26 3B 
042D27 26 
042D28 04 
042D29 CD      8349 CALL    SWAP_FP
042D2A D7 
042D2B 2B 
042D2C 04 
042D2D AF      8350 XOR     A
042D2E 08      8351 POWR11:			EX      AF,AF'
042D2F 3D      8352 DEC     A
042D30 28      8353 JR      Z,POWR14        ;EXIT TYPE 1
042D31 26 
042D32 F2      8354 JP      P,POWR13
042D33 3A 
042D34 2D 
042D35 04 
042D36 B9      8355 CP      C
042D37 38      8356 JR      C,POWR14        ;EXIT TYPE 2
042D38 1F 
042D39 3C      8357 INC     A
042D3A 08      8358 POWR13:			EX      AF,AF'
042D3B 3C      8359 INC     A
042D3C CB      8360 SET     7,H
042D3D FC 
042D3E CD      8361 CALL    X5
042D3F 5D 
042D40 2C 
042D41 04 
042D42 30      8362 JR      NC,POWR12
042D43 06 
042D44 08      8363 EX      AF,AF'
042D45 CD      8364 CALL    D2C
042D46 97 
042D47 2C 
042D48 04 
042D49 08      8365 EX      AF,AF'
042D4A 08      8366 POWR12:			EX      AF,AF'
042D4B DC      8367 CALL    C,ADD1_FP          ;ROUND UP
042D4C BF 
042D4D 2B 
042D4E 04 
042D4F 0C      8368 INC     C
042D50 FA      8369 JP      M,POWR11
042D51 2E 
042D52 2D 
042D53 04 
042D54 C3      8370 JP      OFLOW
042D55 EE 
042D56 2B 
042D57 04 
042D58 CD      8371 POWR14:			CALL    SWAP_FP
042D59 D7 
042D5A 2B 
042D5B 04 
042D5C CB      8372 RES     7,D
042D5D BA 
042D5E D9      8373 EXX
042D5F E1      8374 POP     HL
042D60 D9      8375 EXX
042D61 E1      8376 POP     HL
042D62 08      8377 EX      AF,AF'
042D63 C9      8378 RET
               8379 ;
               8380 ; DIVA, DIVB - DIVISION PRIMITIVE.
               8381 ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
               8382 ;               Remainder in H'L'HL
               8383 ;     Inputs: A = loop counter (normally -32)
               8384 ;     Destroys: A,D,E,H,L,D',E',H',L',F
               8385 ;
042D64 B7      8386 DIVA:			OR      A               ;CLEAR CARRY
               8387 DIV0:
042D65 52      8388 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D66 ED 
042D67 42 
042D68 D9      8389 EXX
042D69 52      8390 SBC.S   HL,BC
042D6A ED 
042D6B 42 
042D6C D9      8391 EXX
042D6D 30      8392 JR      NC,DIV1
042D6E 07 
042D6F 52      8393 ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042D70 09 
042D71 D9      8394 EXX
042D72 52      8395 ADC.S   HL,BC
042D73 ED 
042D74 4A 
042D75 D9      8396 EXX
042D76 3F      8397 DIV1:			CCF
042D77 CB      8398 DIVC:			RL      E               ;SHIFT RESULT INTO DE
042D78 13 
042D79 CB      8399 RL      D
042D7A 12 
042D7B D9      8400 EXX
042D7C CB      8401 RL      E
042D7D 13 
042D7E CB      8402 RL      D
042D7F 12 
042D80 D9      8403 EXX
042D81 3C      8404 INC     A
042D82 F0      8405 RET     P
               8406 DIVB:
042D83 52      8407 ADC.S   HL,HL           ;DIVIDEND*2
042D84 ED 
042D85 6A 
042D86 D9      8408 EXX
042D87 52      8409 ADC.S   HL,HL
042D88 ED 
042D89 6A 
042D8A D9      8410 EXX
042D8B 30      8411 JR      NC,DIV0
042D8C D8 
042D8D B7      8412 OR      A
042D8E 52      8413 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D8F ED 
042D90 42 
042D91 D9      8414 EXX
042D92 52      8415 SBC.S   HL,BC
042D93 ED 
042D94 42 
042D95 D9      8416 EXX
042D96 37      8417 SCF
042D97 C3      8418 JP      DIVC
042D98 77 
042D99 2D 
042D9A 04 
               8419 ;
               8420 ;MULA, MULB - MULTIPLICATION PRIMITIVE.
               8421 ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
               8422 ;    Inputs: A = loop counter (usually -32)
               8423 ;            H'L'HL = 0
               8424 ;    Destroys: D,E,H,L,D',E',H',L',A,F
               8425 ;
042D9B B7      8426 MULA:			OR      A               ;CLEAR CARRY
042D9C D9      8427 MUL0:			EXX
042D9D CB      8428 RR      D               ;MULTIPLIER/2
042D9E 1A 
042D9F CB      8429 RR      E
042DA0 1B 
042DA1 D9      8430 EXX
042DA2 CB      8431 RR      D
042DA3 1A 
042DA4 CB      8432 RR      E
042DA5 1B 
042DA6 30      8433 JR      NC,MUL1
042DA7 07 
042DA8 52      8434 ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DA9 09 
042DAA D9      8435 EXX
042DAB 52      8436 ADC.S   HL,BC
042DAC ED 
042DAD 4A 
042DAE D9      8437 EXX
042DAF 3C      8438 MUL1:			INC     A
042DB0 F0      8439 RET     P
042DB1 D9      8440 MULB:			EXX
042DB2 CB      8441 RR      H               ;PRODUCT/2
042DB3 1C 
042DB4 CB      8442 RR      L
042DB5 1D 
042DB6 D9      8443 EXX
042DB7 CB      8444 RR      H
042DB8 1C 
042DB9 CB      8445 RR      L
042DBA 1D 
042DBB C3      8446 JP      MUL0
042DBC 9C 
042DBD 2D 
042DBE 04 
               8447 ;
               8448 ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
               8449 ;     Function: B'C'BC = SQR (D'E'DE)
               8450 ;     Inputs: A = loop counter (normally -31)
               8451 ;             B'C'BCH'L'HL initialised to 0
               8452 ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
               8453 ;
               8454 SQR1:
042DBF 52      8455 SBC.S   HL,BC
042DC0 ED 
042DC1 42 
042DC2 D9      8456 EXX
042DC3 52      8457 SBC.S   HL,BC
042DC4 ED 
042DC5 42 
042DC6 D9      8458 EXX
042DC7 0C      8459 INC     C
042DC8 30      8460 JR      NC,SQR2
042DC9 09 
042DCA 0D      8461 DEC     C
042DCB 52      8462 ADD.S   HL,BC
042DCC 09 
042DCD D9      8463 EXX
042DCE 52      8464 ADC.S   HL,BC
042DCF ED 
042DD0 4A 
042DD1 D9      8465 EXX
042DD2 0D      8466 DEC     C
042DD3 3C      8467 SQR2:			INC     A
042DD4 F0      8468 RET     P
042DD5 CB      8469 SQRA:			SLA     C
042DD6 21 
042DD7 CB      8470 RL      B
042DD8 10 
042DD9 D9      8471 EXX
042DDA CB      8472 RL      C
042DDB 11 
042DDC CB      8473 RL      B
042DDD 10 
042DDE D9      8474 EXX
042DDF 0C      8475 INC     C
042DE0 CB      8476 SLA     E
042DE1 23 
042DE2 CB      8477 RL      D
042DE3 12 
042DE4 D9      8478 EXX
042DE5 CB      8479 RL      E
042DE6 13 
042DE7 CB      8480 RL      D
042DE8 12 
042DE9 D9      8481 EXX
042DEA 52      8482 ADC.S   HL,HL
042DEB ED 
042DEC 6A 
042DED D9      8483 EXX
042DEE 52      8484 ADC.S   HL,HL
042DEF ED 
042DF0 6A 
042DF1 D9      8485 EXX
042DF2 CB      8486 SLA     E
042DF3 23 
042DF4 CB      8487 RL      D
042DF5 12 
042DF6 D9      8488 EXX
042DF7 CB      8489 RL      E
042DF8 13 
042DF9 CB      8490 RL      D
042DFA 12 
042DFB D9      8491 EXX
042DFC 52      8492 ADC.S   HL,HL
042DFD ED 
042DFE 6A 
042DFF D9      8493 EXX
042E00 52      8494 ADC.S   HL,HL
042E01 ED 
042E02 6A 
042E03 D9      8495 EXX
042E04 D2      8496 JP      NC,SQR1
042E05 BF 
042E06 2D 
042E07 04 
042E08 B7      8497 SQR3:			OR      A
042E09 52      8498 SBC.S   HL,BC
042E0A ED 
042E0B 42 
042E0C D9      8499 EXX
042E0D 52      8500 SBC.S   HL,BC
042E0E ED 
042E0F 42 
042E10 D9      8501 EXX
042E11 0C      8502 INC     C
042E12 C3      8503 JP      SQR2
042E13 D3 
042E14 2D 
042E15 04 
               8504 ;
               8505 SQRB:
042E16 52      8506 ADD.S   HL,HL
042E17 29 
042E18 D9      8507 EXX
042E19 52      8508 ADC.S   HL,HL
042E1A ED 
042E1B 6A 
042E1C D9      8509 EXX
042E1D 38      8510 JR      C,SQR3
042E1E E9 
042E1F 3C      8511 INC     A
042E20 0C      8512 INC     C
042E21 52      8513 SBC.S   HL,BC
042E22 ED 
042E23 42 
042E24 D9      8514 EXX
042E25 52      8515 SBC.S   HL,BC
042E26 ED 
042E27 42 
042E28 D9      8516 EXX
042E29 D0      8517 RET     NC
042E2A 52      8518 ADD.S   HL,BC
042E2B 09 
042E2C D9      8519 EXX
042E2D 52      8520 ADC.S   HL,BC
042E2E ED 
042E2F 4A 
042E30 D9      8521 EXX
042E31 0D      8522 DEC     C
042E32 C9      8523 RET
               8524 ;
042E33 DD      8525 DIGITQ:			LD      A,(IX)
042E34 7E 
042E35 00 
042E36 FE      8526 CP      '9'+1
042E37 3A 
042E38 3F      8527 CCF
042E39 D8      8528 RET     C
042E3A FE      8529 CP      '0'
042E3B 30 
042E3C C9      8530 RET
               8531 ;
042E3D DD      8532 SIGNQ:			LD      A,(IX)
042E3E 7E 
042E3F 00 
042E40 DD      8533 INC     IX
042E41 23 
042E42 FE      8534 CP      ' '
042E43 20 
042E44 28      8535 JR      Z,SIGNQ
042E45 F7 
042E46 FE      8536 CP      '+'
042E47 2B 
042E48 C8      8537 RET     Z
042E49 FE      8538 CP      '-'
042E4A 2D 
042E4B C8      8539 RET     Z
042E4C DD      8540 DEC     IX
042E4D 2B 
042E4E C9      8541 RET; --- End fpp.asm ---
               8542 
               8543 ; --- Begin gpio.asm ---
               8544 ;
               8545 ; Title:	BBC Basic for AGON - GPIO functions
               8546 ; Author:	Dean Belfield
               8547 ; Created:	12/05/2023
               8548 ; Last Updated:	12/05/2023
               8549 ;
               8550 ; Modinfo:
               8551 
               8552 ; INCLUDE	"macros.inc"
               8553 ; INCLUDE	"equs.inc"
               8554 
               8555 ; .ASSUME	ADL = 1
               8556 
               8557 ; SEGMENT CODE
               8558 
               8559 ; XDEF	GPIOB_SETMODE
               8560 
               8561 ; XREF	SWITCH_A
               8562 
               8563 ;  A: Mode
               8564 ;  B: Pins
               8565 ;
042E4F CD      8566 GPIOB_SETMODE:		CALL	SWITCH_A
042E50 F4 
042E51 3D 
042E52 04 
042E53 67      8567 DW	GPIOB_M0	; Output
042E54 2E 
042E55 8C      8568 DW	GPIOB_M1	; Input
042E56 2E 
042E57 AC      8569 DW	GPIOB_M2	; Open Drain IO
042E58 2E 
042E59 CC      8570 DW	GPIOB_M3	; Open Source IO
042E5A 2E 
042E5B E7      8571 DW	GPIOB_M4	; Interrupt, Dual Edge
042E5C 2E 
042E5D 13      8572 DW	GPIOB_M5	; Alt Function
042E5E 2F 
042E5F 2E      8573 DW	GPIOB_M6	; Interrupt, Active Low
042E60 2F 
042E61 55      8574 DW	GPIOB_M7	; Interrupt, Active High
042E62 2F 
042E63 77      8575 DW	GPIOB_M8	; Interrupt, Falling Edge
042E64 2F 
042E65 99      8576 DW	GPIOB_M9	; Interrupt, Rising Edge
042E66 2F 
               8577 
               8578 ; Output
               8579 ;
               8580 GPIOB_M0:		RES_GPIO PB_DDR,  B
042E67 C5     0001M PUSH	BC
042E68 78     0002M LD	A, val
042E69 2F     0003M CPL
042E6A 4F     0004M LD	C, A
042E6B ED     0005M IN0	A, (reg)
042E6C 38 
042E6D 9B 
042E6E A1     0006M AND	C
042E6F ED     0007M OUT0	(reg), A
042E70 39 
042E71 9B 
042E72 C1     0008M POP	BC
               8581 RES_GPIO PB_ALT1, B
042E73 C5     0001M PUSH	BC
042E74 78     0002M LD	A, val
042E75 2F     0003M CPL
042E76 4F     0004M LD	C, A
042E77 ED     0005M IN0	A, (reg)
042E78 38 
042E79 9C 
042E7A A1     0006M AND	C
042E7B ED     0007M OUT0	(reg), A
042E7C 39 
042E7D 9C 
042E7E C1     0008M POP	BC
               8582 RES_GPIO PB_ALT2, B
042E7F C5     0001M PUSH	BC
042E80 78     0002M LD	A, val
042E81 2F     0003M CPL
042E82 4F     0004M LD	C, A
042E83 ED     0005M IN0	A, (reg)
042E84 38 
042E85 9D 
042E86 A1     0006M AND	C
042E87 ED     0007M OUT0	(reg), A
042E88 39 
042E89 9D 
042E8A C1     0008M POP	BC
042E8B C9      8583 RET
               8584 
               8585 ; Input
               8586 ;
               8587 GPIOB_M1:		SET_GPIO PB_DDR,  B
042E8C ED     0001M IN0	A, (reg)
042E8D 38 
042E8E 9B 
042E8F B0     0002M OR	val
042E90 ED     0003M OUT0	(reg), A
042E91 39 
042E92 9B 
               8588 RES_GPIO PB_ALT1, B
042E93 C5     0001M PUSH	BC
042E94 78     0002M LD	A, val
042E95 2F     0003M CPL
042E96 4F     0004M LD	C, A
042E97 ED     0005M IN0	A, (reg)
042E98 38 
042E99 9C 
042E9A A1     0006M AND	C
042E9B ED     0007M OUT0	(reg), A
042E9C 39 
042E9D 9C 
042E9E C1     0008M POP	BC
               8589 RES_GPIO PB_ALT2, B
042E9F C5     0001M PUSH	BC
042EA0 78     0002M LD	A, val
042EA1 2F     0003M CPL
042EA2 4F     0004M LD	C, A
042EA3 ED     0005M IN0	A, (reg)
042EA4 38 
042EA5 9D 
042EA6 A1     0006M AND	C
042EA7 ED     0007M OUT0	(reg), A
042EA8 39 
042EA9 9D 
042EAA C1     0008M POP	BC
042EAB C9      8590 RET
               8591 
               8592 ; Open Drain IO
               8593 ;
               8594 GPIOB_M2:		RES_GPIO PB_DDR,  B
042EAC C5     0001M PUSH	BC
042EAD 78     0002M LD	A, val
042EAE 2F     0003M CPL
042EAF 4F     0004M LD	C, A
042EB0 ED     0005M IN0	A, (reg)
042EB1 38 
042EB2 9B 
042EB3 A1     0006M AND	C
042EB4 ED     0007M OUT0	(reg), A
042EB5 39 
042EB6 9B 
042EB7 C1     0008M POP	BC
               8595 SET_GPIO PB_ALT1, B
042EB8 ED     0001M IN0	A, (reg)
042EB9 38 
042EBA 9C 
042EBB B0     0002M OR	val
042EBC ED     0003M OUT0	(reg), A
042EBD 39 
042EBE 9C 
               8596 RES_GPIO PB_ALT2, B
042EBF C5     0001M PUSH	BC
042EC0 78     0002M LD	A, val
042EC1 2F     0003M CPL
042EC2 4F     0004M LD	C, A
042EC3 ED     0005M IN0	A, (reg)
042EC4 38 
042EC5 9D 
042EC6 A1     0006M AND	C
042EC7 ED     0007M OUT0	(reg), A
042EC8 39 
042EC9 9D 
042ECA C1     0008M POP	BC
042ECB C9      8597 RET
               8598 
               8599 ; Open Source IO
               8600 ;
               8601 GPIOB_M3:		SET_GPIO PB_DDR,  B
042ECC ED     0001M IN0	A, (reg)
042ECD 38 
042ECE 9B 
042ECF B0     0002M OR	val
042ED0 ED     0003M OUT0	(reg), A
042ED1 39 
042ED2 9B 
               8602 SET_GPIO PB_ALT1, B
042ED3 ED     0001M IN0	A, (reg)
042ED4 38 
042ED5 9C 
042ED6 B0     0002M OR	val
042ED7 ED     0003M OUT0	(reg), A
042ED8 39 
042ED9 9C 
               8603 RES_GPIO PB_ALT2, B
042EDA C5     0001M PUSH	BC
042EDB 78     0002M LD	A, val
042EDC 2F     0003M CPL
042EDD 4F     0004M LD	C, A
042EDE ED     0005M IN0	A, (reg)
042EDF 38 
042EE0 9D 
042EE1 A1     0006M AND	C
042EE2 ED     0007M OUT0	(reg), A
042EE3 39 
042EE4 9D 
042EE5 C1     0008M POP	BC
042EE6 C9      8604 RET
               8605 
               8606 ; Interrupt, Dual Edge
               8607 ;
               8608 GPIOB_M4:		SET_GPIO PB_DR,   B
042EE7 ED     0001M IN0	A, (reg)
042EE8 38 
042EE9 9A 
042EEA B0     0002M OR	val
042EEB ED     0003M OUT0	(reg), A
042EEC 39 
042EED 9A 
               8609 RES_GPIO PB_DDR,  B
042EEE C5     0001M PUSH	BC
042EEF 78     0002M LD	A, val
042EF0 2F     0003M CPL
042EF1 4F     0004M LD	C, A
042EF2 ED     0005M IN0	A, (reg)
042EF3 38 
042EF4 9B 
042EF5 A1     0006M AND	C
042EF6 ED     0007M OUT0	(reg), A
042EF7 39 
042EF8 9B 
042EF9 C1     0008M POP	BC
               8610 RES_GPIO PB_ALT1, B
042EFA C5     0001M PUSH	BC
042EFB 78     0002M LD	A, val
042EFC 2F     0003M CPL
042EFD 4F     0004M LD	C, A
042EFE ED     0005M IN0	A, (reg)
042EFF 38 
042F00 9C 
042F01 A1     0006M AND	C
042F02 ED     0007M OUT0	(reg), A
042F03 39 
042F04 9C 
042F05 C1     0008M POP	BC
               8611 RES_GPIO PB_ALT2, B
042F06 C5     0001M PUSH	BC
042F07 78     0002M LD	A, val
042F08 2F     0003M CPL
042F09 4F     0004M LD	C, A
042F0A ED     0005M IN0	A, (reg)
042F0B 38 
042F0C 9D 
042F0D A1     0006M AND	C
042F0E ED     0007M OUT0	(reg), A
042F0F 39 
042F10 9D 
042F11 C1     0008M POP	BC
042F12 C9      8612 RET
               8613 
               8614 ; Alt Function
               8615 ;
               8616 GPIOB_M5:		SET_GPIO PB_DDR,  B
042F13 ED     0001M IN0	A, (reg)
042F14 38 
042F15 9B 
042F16 B0     0002M OR	val
042F17 ED     0003M OUT0	(reg), A
042F18 39 
042F19 9B 
               8617 RES_GPIO PB_ALT1, B
042F1A C5     0001M PUSH	BC
042F1B 78     0002M LD	A, val
042F1C 2F     0003M CPL
042F1D 4F     0004M LD	C, A
042F1E ED     0005M IN0	A, (reg)
042F1F 38 
042F20 9C 
042F21 A1     0006M AND	C
042F22 ED     0007M OUT0	(reg), A
042F23 39 
042F24 9C 
042F25 C1     0008M POP	BC
               8618 SET_GPIO PB_ALT2, B
042F26 ED     0001M IN0	A, (reg)
042F27 38 
042F28 9D 
042F29 B0     0002M OR	val
042F2A ED     0003M OUT0	(reg), A
042F2B 39 
042F2C 9D 
042F2D C9      8619 RET
               8620 
               8621 ; Interrupt, Active Low
               8622 ;
               8623 GPIOB_M6:		RES_GPIO PB_DR,   B
042F2E C5     0001M PUSH	BC
042F2F 78     0002M LD	A, val
042F30 2F     0003M CPL
042F31 4F     0004M LD	C, A
042F32 ED     0005M IN0	A, (reg)
042F33 38 
042F34 9A 
042F35 A1     0006M AND	C
042F36 ED     0007M OUT0	(reg), A
042F37 39 
042F38 9A 
042F39 C1     0008M POP	BC
               8624 RES_GPIO PB_DDR,  B
042F3A C5     0001M PUSH	BC
042F3B 78     0002M LD	A, val
042F3C 2F     0003M CPL
042F3D 4F     0004M LD	C, A
042F3E ED     0005M IN0	A, (reg)
042F3F 38 
042F40 9B 
042F41 A1     0006M AND	C
042F42 ED     0007M OUT0	(reg), A
042F43 39 
042F44 9B 
042F45 C1     0008M POP	BC
               8625 SET_GPIO PB_ALT1, B
042F46 ED     0001M IN0	A, (reg)
042F47 38 
042F48 9C 
042F49 B0     0002M OR	val
042F4A ED     0003M OUT0	(reg), A
042F4B 39 
042F4C 9C 
               8626 SET_GPIO PB_ALT2, B
042F4D ED     0001M IN0	A, (reg)
042F4E 38 
042F4F 9D 
042F50 B0     0002M OR	val
042F51 ED     0003M OUT0	(reg), A
042F52 39 
042F53 9D 
042F54 C9      8627 RET
               8628 
               8629 
               8630 ; Interrupt, Active High
               8631 ;
               8632 GPIOB_M7:		SET_GPIO PB_DR,   B
042F55 ED     0001M IN0	A, (reg)
042F56 38 
042F57 9A 
042F58 B0     0002M OR	val
042F59 ED     0003M OUT0	(reg), A
042F5A 39 
042F5B 9A 
               8633 RES_GPIO PB_DDR,  B
042F5C C5     0001M PUSH	BC
042F5D 78     0002M LD	A, val
042F5E 2F     0003M CPL
042F5F 4F     0004M LD	C, A
042F60 ED     0005M IN0	A, (reg)
042F61 38 
042F62 9B 
042F63 A1     0006M AND	C
042F64 ED     0007M OUT0	(reg), A
042F65 39 
042F66 9B 
042F67 C1     0008M POP	BC
               8634 SET_GPIO PB_ALT1, B
042F68 ED     0001M IN0	A, (reg)
042F69 38 
042F6A 9C 
042F6B B0     0002M OR	val
042F6C ED     0003M OUT0	(reg), A
042F6D 39 
042F6E 9C 
               8635 SET_GPIO PB_ALT2, B
042F6F ED     0001M IN0	A, (reg)
042F70 38 
042F71 9D 
042F72 B0     0002M OR	val
042F73 ED     0003M OUT0	(reg), A
042F74 39 
042F75 9D 
042F76 C9      8636 RET
               8637 
               8638 
               8639 ; Interrupt, Falling Edge
               8640 ;
               8641 GPIOB_M8:		RES_GPIO PB_DR,   B
042F77 C5     0001M PUSH	BC
042F78 78     0002M LD	A, val
042F79 2F     0003M CPL
042F7A 4F     0004M LD	C, A
042F7B ED     0005M IN0	A, (reg)
042F7C 38 
042F7D 9A 
042F7E A1     0006M AND	C
042F7F ED     0007M OUT0	(reg), A
042F80 39 
042F81 9A 
042F82 C1     0008M POP	BC
               8642 SET_GPIO PB_DDR,  B
042F83 ED     0001M IN0	A, (reg)
042F84 38 
042F85 9B 
042F86 B0     0002M OR	val
042F87 ED     0003M OUT0	(reg), A
042F88 39 
042F89 9B 
               8643 SET_GPIO PB_ALT1, B
042F8A ED     0001M IN0	A, (reg)
042F8B 38 
042F8C 9C 
042F8D B0     0002M OR	val
042F8E ED     0003M OUT0	(reg), A
042F8F 39 
042F90 9C 
               8644 SET_GPIO PB_ALT2, B
042F91 ED     0001M IN0	A, (reg)
042F92 38 
042F93 9D 
042F94 B0     0002M OR	val
042F95 ED     0003M OUT0	(reg), A
042F96 39 
042F97 9D 
042F98 C9      8645 RET
               8646 
               8647 ; Interrupt, Rising Edge
               8648 ;
               8649 GPIOB_M9:		SET_GPIO PB_DR,   B
042F99 ED     0001M IN0	A, (reg)
042F9A 38 
042F9B 9A 
042F9C B0     0002M OR	val
042F9D ED     0003M OUT0	(reg), A
042F9E 39 
042F9F 9A 
               8650 SET_GPIO PB_DDR,  B
042FA0 ED     0001M IN0	A, (reg)
042FA1 38 
042FA2 9B 
042FA3 B0     0002M OR	val
042FA4 ED     0003M OUT0	(reg), A
042FA5 39 
042FA6 9B 
               8651 SET_GPIO PB_ALT1, B
042FA7 ED     0001M IN0	A, (reg)
042FA8 38 
042FA9 9C 
042FAA B0     0002M OR	val
042FAB ED     0003M OUT0	(reg), A
042FAC 39 
042FAD 9C 
               8652 SET_GPIO PB_ALT2, B
042FAE ED     0001M IN0	A, (reg)
042FAF 38 
042FB0 9D 
042FB1 B0     0002M OR	val
042FB2 ED     0003M OUT0	(reg), A
042FB3 39 
042FB4 9D 
042FB5 C9      8653 RET	; --- End gpio.asm ---
               8654 
               8655 ; --- Begin main.asm ---
               8656 ;
               8657 ; Title:	BBC Basic Interpreter - Z80 version
               8658 ;		Command, Error and Lexical Analysis Module - "MAIN"
               8659 ; Author:	(C) Copyright  R.T.Russell  1984
               8660 ; Modified By:	Dean Belfield
               8661 ; Created:	12/05/2023
               8662 ; Last Updated:	26/11/2023
               8663 ;
               8664 ; Modinfo:
               8665 ; 07/05/1984:	Version 2.3
               8666 ; 01/03/1987:	Version 3.0
               8667 ; 03/05/2022:	Modified by Dean Belfield
               8668 ; 06/06/2023:	Modified to run in ADL mode
               8669 ; 26/06/2023:	Fixed binary and unary indirection
               8670 ; 17/08/2023:	Added binary constants
               8671 ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
               8672 ; 26/11/2023:	Fixed bug in AUTOLOAD
               8673 
               8674 ; .ASSUME	ADL = 1
               8675 
               8676 ; INCLUDE	"equs.inc"
               8677 
               8678 ; SEGMENT CODE
               8679 
               8680 ; XDEF	_main
               8681 
               8682 ; XDEF	COLD
               8683 ; XDEF	WARM
               8684 ; XDEF	CLOOP
               8685 ; XDEF	DELETE
               8686 ; XDEF	LIST_
               8687 ; XDEF	RENUM
               8688 ; XDEF	AUTO
               8689 ; XDEF	NEW
               8690 ; XDEF	OLD
               8691 ; XDEF	LOAD
               8692 ; XDEF	SAVE
               8693 ; XDEF	ERROR_
               8694 ; XDEF	EXTERR
               8695 ; XDEF	LOAD0
               8696 ; XDEF	CLEAR
               8697 ; XDEF	CRLF
               8698 ; XDEF	OUTCHR
               8699 ; XDEF	OUT_
               8700 ; XDEF	FINDL
               8701 ; XDEF	SETLIN
               8702 ; XDEF	PBCDL
               8703 ; XDEF	SAYLN
               8704 ; XDEF	PUTVAR
               8705 ; XDEF	GETVAR
               8706 ; XDEF	GETDEF
               8707 ; XDEF	CREATE
               8708 ; XDEF	RANGE
               8709 ; XDEF	LEXAN2
               8710 ; XDEF	REPORT
               8711 ; XDEF	TELL
               8712 ; XDEF	SPACE_
               8713 ; XDEF	KEYWDS
               8714 ; XDEF	KEYWDL
               8715 ; XDEF	ONEDIT
               8716 ; XDEF	ONEDIT1
               8717 ; XDEF	LISTIT
               8718 ; XDEF	CLEAN
               8719 
               8720 ; XREF	LISTON
               8721 ; XREF	ERRTXT
               8722 ; XREF	OSINIT
               8723 ; XREF	HIMEM
               8724 ; XREF	PAGE_
               8725 ; XREF	CHAIN0
               8726 ; XREF	PROMPT
               8727 ; XREF	ERRTRP
               8728 ; XREF	ERRLIN
               8729 ; XREF	AUTONO
               8730 ; XREF	LINENO
               8731 ; XREF	INCREM
               8732 ; XREF	OSLINE
               8733 ; XREF	COUNT
               8734 ; XREF	NXT
               8735 ; XREF	BUFFER
               8736 ; XREF	XEQ
               8737 ; XREF	TOP
               8738 ; XREF	EXPRI
               8739 ; XREF	SEARCH
               8740 ; XREF	LTRAP
               8741 ; XREF	LOMEM
               8742 ; XREF	DECODE
               8743 ; XREF	EXPRS
               8744 ; XREF	OSSAVE
               8745 ; XREF	ERR
               8746 ; XREF	ERL
               8747 ; XREF	TRACEN
               8748 ; XREF	RESET
               8749 ; XREF	OSSHUT
               8750 ; XREF	OSLOAD
               8751 ; XREF	FREE
               8752 ; XREF	DYNVAR
               8753 ; XREF	FILL
               8754 ; XREF	OSWRCH
               8755 ; XREF	WIDTH
               8756 ; XREF	COMMA
               8757 ; XREF	MUL16
               8758 ; XREF	BRAKET
               8759 ; XREF	X4OR5
               8760 ; XREF	LOADN
               8761 ; XREF	SFIX
               8762 ; XREF	ITEMI
               8763 ; XREF	FNPTR
               8764 ; XREF	PROPTR
               8765 ; XREF	CHECK
               8766 ; XREF	TERMQ
               8767 ; XREF	OSWRCHCH
               8768 ; XREF	NEWIT
               8769 ; XREF	BAD
               8770 ; XREF	RAM_START
               8771 ; XREF	RAM_END
               8772 ; XREF	R0
               8773 ; XREF	STAR_VERSION
               8774 
               8775 ; XREF	_end			; In init.asm
               8776 ;
               8777 ; A handful of common token IDs
               8778 ;
               8779 TERROR_MN:			EQU     85H
               8780 LINE_MN_:			EQU     86H
               8781 ELSE_MN_:			EQU     8BH
               8782 THEN_MN_:			EQU     8CH
               8783 LINO_MN:			EQU     8DH
               8784 FN:			EQU     A4H
               8785 TO_MN:			EQU     B8H
               8786 REN:			EQU     CCH
               8787 DATA_MN_:			EQU     DCH
               8788 DIM:			EQU     DEH
               8789 FOR:			EQU     E3H
               8790 GOSUB:			EQU     E4H
               8791 GOTO:			EQU     E5H
               8792 TIF:			EQU     E7H
               8793 LOCAL_:			EQU     EAH
               8794 NEXT:			EQU     EDH
               8795 ON_:			EQU     EEH
               8796 PROC:			EQU     F2H
               8797 REM:			EQU     F4H
               8798 REPEAT:			EQU     F5H
               8799 RESTOR:			EQU     F7H
               8800 TRACE:			EQU     FCH
               8801 UNTIL:			EQU     FDH
               8802 ;
               8803 ; This defines the block of tokens that are pseudo-variables.
               8804 ; There are two versions of each token, a GET and a SET
               8805 
               8806 ; Name  : GET : SET
               8807 ; ------:-----:----
               8808 ; PTR   : 8Fh : CFh
               8809 ; PAGE  : 90h : D0h
               8810 ; TIME  : 91h : D1h
               8811 ; LOMEM : 92h : D2h
               8812 ; HIMEM : 93h : D3h
               8813 ;
               8814 ; Examples:
               8815 ;   LET A% = PAGE : REM This is the GET version
               8816 ;   PAGE = 40000  : REM This is the SET version
               8817 ;
               8818 TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
               8819 TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
               8820 OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
               8821 
               8822 ; The main routine
               8823 ; IXU: argv - pointer to array of parameters
               8824 ;   C: argc - number of parameters
               8825 ; Returns:
               8826 ;  HL: Error code, or 0 if OK
               8827 ;
042FB6 21      8828 _main:			LD	HL, ACCS		; Clear the ACCS
042FB7 00 
042FB8 4A 
042FB9 04 
042FBA 36      8829 LD	(HL), 0
042FBB 00 
042FBC 79      8830 LD	A, C
042FBD FE      8831 CP	2
042FBE 02 
042FBF 28      8832 JR	Z, AUTOLOAD		; 2 parameters = autoload
042FC0 2D 
042FC1 38      8833 JR	C, COLD			; 1 parameter = normal start
042FC2 3F 
042FC3 CD      8834 CALL	STAR_VERSION
042FC4 38 
042FC5 40 
042FC6 04 
042FC7 CD      8835 CALL	TELL
042FC8 90 
042FC9 3D 
042FCA 04 
042FCB 55      8836 DB	"Usage:\n\r"
042FCC 73 
042FCD 61 
042FCE 67 
042FCE 65   
042FCF 3A 
042FD0 0A 
042FD1 0D 
042FD3 52      8837 DB	"RUN . <filename>\n\r", 0
042FD4 55 
042FD5 4E 
042FD6 20 
042FD6 2E   
042FD7 20 
042FD8 3C 
042FD9 66 
042FD9 69   
042FDA 6C 
042FDB 65 
042FDC 6E 
042FDC 61   
042FDD 6D 
042FDE 65 
042FDF 3E 
042FDF 0A   
042FE0 0D 
042FE1 00 
042FE6 21      8838 LD	HL, 0			; The error code
042FE7 00 
042FE8 00 
042FE9 00 
042FEA C3      8839 JP	_end
042FEB 68 
042FEC 00 
042FED 04 
               8840 ;
042FEE DD      8841 AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
042FEF 27 
042FF0 03 
042FF1 11      8842 LD	DE, ACCS		;  DE: Destination address
042FF2 00 
042FF3 4A 
042FF4 04 
042FF5 7E      8843 AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
042FF6 12      8844 LD	(DE), A			;
042FF7 23      8845 INC	HL			; Increase the source pointer
042FF8 1C      8846 INC	E			; We only need to increase E as ACCS is on a page boundary
042FF9 28      8847 JR	Z, AUTOLOAD_2		; End if we hit the page boundary
042FFA 03 
042FFB B7      8848 OR	A
042FFC 20      8849 JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
042FFD F7 
042FFE 1D      8850 AUTOLOAD_2:		DEC	E
042FFF 3E      8851 LD	A, CR
043000 0D 
043001 12      8852 LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
               8853 ;
043002 E1      8854 COLD:			POP	HL			; Pop the return address to init off SPS
043003 E5      8855 PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043004 21      8856 LD	HL, STAVAR		; Cold start
043005 00 
043006 4C 
043007 04 
043008 F9      8857 LD	SP, HL
043009 36      8858 LD	(HL), 10
04300A 0A 
04300B 23      8859 INC	HL
04300C 36      8860 LD	(HL),9
04300D 09 
04300E CD      8861 CALL    OSINIT			; Call the machine specific OS initialisation routines
04300F 81 
043010 3F 
043011 04 
043012 ED      8862 LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
043013 53 
043014 20 
043015 4D 
043015 04   
043017 22      8863 LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043018 14 
043019 4D 
04301A 04 
04301B 3E      8864 LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
04301C B7 
04301D 32      8865 LD      (LISTON),A
04301E 40 
04301F 4D 
043020 04 
043021 21      8866 LD      HL,NOTICE
043022 5C 
043023 30 
043024 04 
043025 22      8867 LD      (ERRTXT),HL
043026 2F 
043027 4D 
043028 04 
043029 CD      8868 CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
04302A 6C 
04302B 38 
04302C 04 
04302D 3A      8869 LD	A,(ACCS)		; Check if there is a filename in ACCS
04302E 00 
04302F 4A 
043030 04 
043031 B7      8870 OR	A
043032 C2      8871 JP	NZ,CHAIN0		; Yes, so load and run
043033 53 
043034 0B 
043035 04 
043036 CD      8872 CALL	STAR_VERSION		;
043037 38 
043038 40 
043039 04 
04303A CD      8873 CALL    TELL			; Output the welcome message
04303B 90 
04303C 3D 
04303D 04 
04303E 42      8874 DB    	"BBC BASIC (Z80) Version 3.00\n\r"
04303F 42 
043040 43 
043041 20 
043041 42   
043042 41 
043043 53 
043044 49 
043044 43   
043045 20 
043046 28 
043047 5A 
043047 38   
043048 30 
043049 29 
04304A 20 
04304A 56   
04304B 65 
04304C 72 
04304D 73 
04304D 69   
04304E 6F 
04304F 6E 
043050 20 
043050 33   
043051 2E 
043052 30 
043053 30 
043053 0A   
043054 0D 
04305C 28      8875 NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
04305D 43 
04305E 29 
04305F 20 
04305F 43   
043060 6F 
043061 70 
043062 79 
043062 72   
043063 69 
043064 67 
043065 68 
043065 74   
043066 20 
043067 52 
043068 2E 
043068 54   
043069 2E 
04306A 52 
04306B 75 
04306B 73   
04306C 73 
04306D 65 
04306E 6C 
04306E 6C   
04306F 20 
043070 31 
043071 39 
043071 38   
043072 37 
043073 0A 
043074 0D 
04307C 0A      8876 DB	"\n\r", 0
04307D 0D 
04307E 00 
               8877 ;
04307F F6      8878 WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
               8879 ;
               8880 ; This is the main entry point for BASIC
               8881 ;
043080 37      8882 CLOOP:			SCF				; See above - not sure why this is here!
043081 ED      8883 LD      SP,(HIMEM)
043082 7B 
043083 20 
043084 4D 
043084 04   
043086 CD      8884 CALL    PROMPT          	; Prompt user
043087 FA 
043088 3E 
043089 04 
04308A 21      8885 LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
04308B 40 
04308C 4D 
04308D 04 
04308E 7E      8886 LD      A,(HL)			; Fetch the value
04308F E6      8887 AND     0FH             	; Bottom nibble: LISTO
043090 0F 
043091 F6      8888 OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
043092 B0 
043093 77      8889 LD      (HL),A			; Store back in
043094 ED      8890 SBC     HL,HL           	; HL: 0
043095 62 
043096 22      8891 LD      (ERRTRP),HL		; Clear ERRTRP sysvar
043097 2C 
043098 4D 
043099 04 
04309A 22      8892 LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
04309B 35 
04309C 4D 
04309D 04 
               8893 ;
04309E 2A      8894 LD      HL,(AUTONO)		; Get the auto line number
04309F 29 
0430A0 4D 
0430A1 04 
0430A2 22      8895 LD      (LINENO),HL		; Store in line number
0430A3 23 
0430A4 4D 
0430A5 04 
0430A6 7C      8896 LD      A,H			; If the auto line number is zero then
0430A7 B5      8897 OR      L
0430A8 28      8898 JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430A9 1E 
               8899 ;
               8900 ; This section handles auto line numbering
               8901 ;
0430AA E5      8902 PUSH    HL			; Stack the line number
0430AB CD      8903 CALL    PBCD           	 	; Output the line number
0430AC FB 
0430AD 39 
0430AE 04 
0430AF E1      8904 POP     HL			; Pop the line number back off the stack
               8905 ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
               8906 ;			LD      B,0			; So clear B
0430B0 01      8907 LD	BC, 0			; Load BC with Increment
0430B1 00 
0430B2 00 
0430B3 00 
0430B4 3A      8908 LD	A,(INCREM)
0430B5 41 
0430B6 4D 
0430B7 04 
0430B8 4F      8909 LD	C, A
0430B9 09      8910 ADD     HL,BC			; Add the increment to the line number
0430BA DA      8911 JP      C,TOOBIG		; And error if we wrap
0430BB 25 
0430BC 3C 
0430BD 04 
0430BE 22      8912 LD      (AUTONO),HL		; Store the new auto line number
0430BF 29 
0430C0 4D 
0430C1 04 
0430C2 3E      8913 LD      A,' '			; Print a space
0430C3 20 
0430C4 CD      8914 CALL    OUTCHR
0430C5 4F 
0430C6 39 
0430C7 04 
               8915 ;
               8916 ; This section invokes the line editor
               8917 ;
0430C8 21      8918 NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0430C9 00 
0430CA 4A 
0430CB 04 
0430CC CD      8919 CALL    OSLINE          	; Call the line editor in MOS
0430CD 5F 
0430CE 3E 
0430CF 04 
0430D0 CD      8920 ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0430D1 DC 
0430D2 30 
0430D3 04 
0430D4 DC      8921 CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0430D5 3F 
0430D6 38 
0430D7 04 
0430D8 C3      8922 JP      CLOOP			; Jump back to immediate mode
0430D9 80 
0430DA 30 
0430DB 04 
               8923 ;
               8924 ; This bit enters the line into memory
               8925 ; Also called from OSLOAD_TXT
               8926 ; Returns:
               8927 ; F: C if a new line has been entered (CLEAN will need to be called)
               8928 ;
0430DC AF      8929 ONEDIT1:		XOR     A			; Entry point after *EDIT
0430DD 32      8930 LD      (COUNT),A
0430DE 3D 
0430DF 4D 
0430E0 04 
0430E1 FD      8931 LD      IY,ACCS
0430E2 21 
0430E3 00 
0430E4 4A 
0430E4 04   
0430E6 CD      8932 CALL    LINNUM			; HL: The line number from the input buffer
0430E7 F9 
0430E8 3B 
0430E9 04 
0430EA CD      8933 CALL    NXT			; Skip spaces
0430EB 70 
0430EC 0A 
0430ED 04 
0430EE 7C      8934 LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0430EF B5      8935 OR      L
0430F0 28      8936 JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0430F1 04 
0430F2 22      8937 LD      (LINENO),HL		; Otherwise store it
0430F3 23 
0430F4 4D 
0430F5 04 
               8938 ;
               8939 ; This bit does the lexical analysis and tokenisation
               8940 ;
0430F6 0E      8941 LNZERO:			LD	C,1			; Left mode
0430F7 01 
0430F8 11      8942 LD      DE,BUFFER		; Buffer for tokenised BASIC
0430F9 00 
0430FA 4B 
0430FB 04 
0430FC CD      8943 CALL    LEXAN2          	; Lexical analysis on the user input
0430FD 9F 
0430FE 3C 
0430FF 04 
043100 12      8944 LD      (DE),A          	; Terminator
043101 AF      8945 XOR     A
               8946 ;			LD      B,A
               8947 ;			LD      C,E             	; BC: Line length
043102 01      8948 LD	BC,0
043103 00 
043104 00 
043105 00 
043106 4B      8949 LD	C,E			; BC: Line length
043107 13      8950 INC     DE
043108 12      8951 LD      (DE),A          	; Zero next
043109 2A      8952 LD      HL,(LINENO)		; Get the line number
04310A 23 
04310B 4D 
04310C 04 
04310D 7C      8953 LD      A,H			; Is it zero, i.e. a command with no line number?
04310E B5      8954 OR      L
04310F FD      8955 LD      IY,BUFFER       	; Yes, so we're in immediate mode
043110 21 
043111 00 
043112 4B 
043112 04   
043114 CA      8956 JP      Z,XEQ           	; Execute it
043115 96 
043116 0B 
043117 04 
               8957 ;
               8958 ; This section stores the BASIC line in memory
               8959 ;
043118 C5      8960 PUSH    BC
043119 E5      8961 PUSH    HL
04311A CD      8962 CALL    SETTOP          	; Set TOP sysvar
04311B 4B 
04311C 38 
04311D 04 
04311E E1      8963 POP     HL
04311F CD      8964 CALL    FINDL			; Find the address of the line
043120 8F 
043121 39 
043122 04 
043123 CC      8965 CALL    Z,DEL			; Delete the existing line if found
043124 02 
043125 38 
043126 04 
043127 C1      8966 POP     BC
043128 79      8967 LD      A,C			; Check for the line length being zero, i.e.
043129 B7      8968 OR      A			; the user has just entered a line number in the command line
04312A C8      8969 RET	Z 	         	; If so, then don't do anything else
04312B C6      8970 ADD     A,4
04312C 04 
04312D 4F      8971 LD      C,A             	; Length inclusive
04312E D5      8972 PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
04312F C5      8973 PUSH    BC              	; BC: Line length
043130 EB      8974 EX      DE,HL			; DE: Address of the line in memory
043131 2A      8975 LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043132 17 
043133 4D 
043134 04 
043135 E5      8976 PUSH    HL			; Stack TOP (current TOP value)
043136 09      8977 ADD     HL,BC			; Add the line length to HL, the new TOP value
043137 E5      8978 PUSH    HL			; Stack HL (new TOP value)
043138 24      8979 INC     H			; Add 256 to HL
043139 AF      8980 XOR     A
04313A ED      8981 SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04313B 72 
04313C E1      8982 POP     HL			; Pop HL (new TOP value)
04313D D2      8983 JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
04313E 60 
04313F 37 
043140 04 
043141 22      8984 LD      (TOP),HL		; Store new value of TOP
043142 17 
043143 4D 
043144 04 
043145 E3      8985 EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043146 E5      8986 PUSH    HL			; PUSH current TOP value
043147 23      8987 INC     HL
043148 B7      8988 OR      A
043149 ED      8989 SBC     HL,DE			; DE: Address of the line in memory
04314A 52 
04314B 44      8990 LD      B,H             	; BC: Amount to move
04314C 4D      8991 LD      C,L
04314D E1      8992 POP     HL			; HL: Destination (current TOP value)
04314E D1      8993 POP     DE			; DE: Source (new TOP value)
04314F 28      8994 JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043150 02 
043151 ED      8995 LDDR                    	; Otherwise, make space for the new line in the program
043152 B8 
043153 C1      8996 ATEND:			POP     BC              	; BC: Line length
043154 D1      8997 POP     DE              	; DE: Line number
043155 23      8998 INC     HL			; HL: Destination address
043156 71      8999 LD      (HL),C          	; Store length
043157 23      9000 INC     HL
043158 73      9001 LD      (HL),E          	; Store line number
043159 23      9002 INC     HL
04315A 72      9003 LD      (HL),D
04315B 23      9004 INC     HL
04315C 11      9005 LD      DE,BUFFER		; DE: Location of the new, tokenised line
04315D 00 
04315E 4B 
04315F 04 
043160 EB      9006 EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043161 0D      9007 DEC     C			; Subtract 3 from the number of bytes to copy to
043162 0D      9008 DEC     C			; compensate for the 3 bytes stored above (length and line number)
043163 0D      9009 DEC     C
043164 ED      9010 LDIR                    	; Add the line to the BASIC program
043165 B0 
043166 37      9011 SCF				; To flag we need to call CLEAN
043167 C9      9012 RET
               9013 ;
               9014 ; List of tokens and keywords. If a keyword is followed by 0 then
               9015 ; it will only match with the keyword followed immediately by
               9016 ; a delimiter
               9017 ;
043168 80      9018 KEYWDS:			DB    80H, "AND"
043169 41 
04316A 4E 
04316B 44 
04316C 94      9019 DB    94H, "ABS"
04316D 41 
04316E 42 
04316F 53 
043170 95      9020 DB    95H, "ACS"
043171 41 
043172 43 
043173 53 
043174 96      9021 DB    96H, "ADVAL"
043175 41 
043176 44 
043177 56 
043177 41   
043178 4C 
04317A 97      9022 DB    97H, "ASC"
04317B 41 
04317C 53 
04317D 43 
04317E 98      9023 DB    98H, "ASN"
04317F 41 
043180 53 
043181 4E 
043182 99      9024 DB    99H, "ATN"
043183 41 
043184 54 
043185 4E 
043186 C6      9025 DB    C6H, "AUTO"
043187 41 
043188 55 
043189 54 
043189 4F   
04318B 9A      9026 DB    9AH, "BGET", 0
04318C 42 
04318D 47 
04318E 45 
04318E 54   
04318F 00 
043191 D5      9027 DB    D5H, "BPUT", 0
043192 42 
043193 50 
043194 55 
043194 54   
043195 00 
043197 FB      9028 DB    FBH, "COLOUR"
043198 43 
043199 4F 
04319A 4C 
04319A 4F   
04319B 55 
04319C 52 
04319E FB      9029 DB    FBH, "COLOR"
04319F 43 
0431A0 4F 
0431A1 4C 
0431A1 4F   
0431A2 52 
0431A4 D6      9030 DB    D6H, "CALL"
0431A5 43 
0431A6 41 
0431A7 4C 
0431A7 4C   
0431A9 D7      9031 DB    D7H, "CHAIN"
0431AA 43 
0431AB 48 
0431AC 41 
0431AC 49   
0431AD 4E 
0431AF BD      9032 DB    BDH, "CHR$"
0431B0 43 
0431B1 48 
0431B2 52 
0431B2 24   
0431B4 D8      9033 DB    D8H, "CLEAR", 0
0431B5 43 
0431B6 4C 
0431B7 45 
0431B7 41   
0431B8 52 
0431B9 00 
0431BB D9      9034 DB    D9H, "CLOSE", 0
0431BC 43 
0431BD 4C 
0431BE 4F 
0431BE 53   
0431BF 45 
0431C0 00 
0431C2 DA      9035 DB    DAH, "CLG", 0
0431C3 43 
0431C4 4C 
0431C5 47 
0431C5 00   
0431C7 DB      9036 DB    DBH, "CLS", 0
0431C8 43 
0431C9 4C 
0431CA 53 
0431CA 00   
0431CC 9B      9037 DB    9BH, "COS"
0431CD 43 
0431CE 4F 
0431CF 53 
0431D0 9C      9038 DB    9CH, "COUNT", 0
0431D1 43 
0431D2 4F 
0431D3 55 
0431D3 4E   
0431D4 54 
0431D5 00 
0431D7 DC      9039 DB    DCH, "DATA"
0431D8 44 
0431D9 41 
0431DA 54 
0431DA 41   
0431DC 9D      9040 DB    9DH, "DEG"
0431DD 44 
0431DE 45 
0431DF 47 
0431E0 DD      9041 DB    DDH, "DEF"
0431E1 44 
0431E2 45 
0431E3 46 
0431E4 C7      9042 DB    C7H, "DELETE"
0431E5 44 
0431E6 45 
0431E7 4C 
0431E7 45   
0431E8 54 
0431E9 45 
0431EB 81      9043 DB    81H, "DIV"
0431EC 44 
0431ED 49 
0431EE 56 
0431EF DE      9044 DB    DEH, "DIM"
0431F0 44 
0431F1 49 
0431F2 4D 
0431F3 DF      9045 DB    DFH, "DRAW"
0431F4 44 
0431F5 52 
0431F6 41 
0431F6 57   
0431F8 E1      9046 DB    E1H, "ENDPROC", 0
0431F9 45 
0431FA 4E 
0431FB 44 
0431FB 50   
0431FC 52 
0431FD 4F 
0431FE 43 
0431FE 00   
043201 E0      9047 DB    E0H, "END", 0
043202 45 
043203 4E 
043204 44 
043204 00   
043206 E2      9048 DB    E2H, "ENVELOPE"
043207 45 
043208 4E 
043209 56 
043209 45   
04320A 4C 
04320B 4F 
04320C 50 
04320C 45   
04320F 8B      9049 DB    8BH, "ELSE"
043210 45 
043211 4C 
043212 53 
043212 45   
043214 A0      9050 DB    A0H, "EVAL"
043215 45 
043216 56 
043217 41 
043217 4C   
043219 9E      9051 DB    9EH, "ERL", 0
04321A 45 
04321B 52 
04321C 4C 
04321C 00   
04321E 85      9052 DB    85H, "ERROR"
04321F 45 
043220 52 
043221 52 
043221 4F   
043222 52 
043224 C5      9053 DB    C5H, "EOF", 0
043225 45 
043226 4F 
043227 46 
043227 00   
043229 82      9054 DB    82H, "EOR"
04322A 45 
04322B 4F 
04322C 52 
04322D 9F      9055 DB    9FH, "ERR", 0
04322E 45 
04322F 52 
043230 52 
043230 00   
043232 A1      9056 DB    A1H, "EXP"
043233 45 
043234 58 
043235 50 
043236 A2      9057 DB    A2H, "EXT", 0
043237 45 
043238 58 
043239 54 
043239 00   
04323B E3      9058 DB    E3H, "FOR"
04323C 46 
04323D 4F 
04323E 52 
04323F A3      9059 DB    A3H, "FALSE", 0
043240 46 
043241 41 
043242 4C 
043242 53   
043243 45 
043244 00 
043246 A4      9060 DB    A4H, "FN"
043247 46 
043248 4E 
043249 E5      9061 DB    E5H, "GOTO"
04324A 47 
04324B 4F 
04324C 54 
04324C 4F   
04324E BE      9062 DB    BEH, "GET$"
04324F 47 
043250 45 
043251 54 
043251 24   
043253 A5      9063 DB    A5H, "GET"
043254 47 
043255 45 
043256 54 
043257 E4      9064 DB    E4H, "GOSUB"
043258 47 
043259 4F 
04325A 53 
04325A 55   
04325B 42 
04325D E6      9065 DB    E6H, "GCOL"
04325E 47 
04325F 43 
043260 4F 
043260 4C   
043262 93      9066 DB    93H, "HIMEM", 0
043263 48 
043264 49 
043265 4D 
043265 45   
043266 4D 
043267 00 
043269 E8      9067 DB    E8H, "INPUT"
04326A 49 
04326B 4E 
04326C 50 
04326C 55   
04326D 54 
04326F E7      9068 DB    E7H, "IF"
043270 49 
043271 46 
043272 BF      9069 DB    BFH, "INKEY$"
043273 49 
043274 4E 
043275 4B 
043275 45   
043276 59 
043277 24 
043279 A6      9070 DB    A6H, "INKEY"
04327A 49 
04327B 4E 
04327C 4B 
04327C 45   
04327D 59 
04327F A8      9071 DB    A8H, "INT"
043280 49 
043281 4E 
043282 54 
043283 A7      9072 DB    A7H, "INSTR("
043284 49 
043285 4E 
043286 53 
043286 54   
043287 52 
043288 28 
04328A C9      9073 DB    C9H, "LIST"
04328B 4C 
04328C 49 
04328D 53 
04328D 54   
04328F 86      9074 DB    86H, "LINE"
043290 4C 
043291 49 
043292 4E 
043292 45   
043294 C8      9075 DB    C8H, "LOAD"
043295 4C 
043296 4F 
043297 41 
043297 44   
043299 92      9076 DB    92H, "LOMEM", 0
04329A 4C 
04329B 4F 
04329C 4D 
04329C 45   
04329D 4D 
04329E 00 
0432A0 EA      9077 DB    EAH, "LOCAL"
0432A1 4C 
0432A2 4F 
0432A3 43 
0432A3 41   
0432A4 4C 
0432A6 C0      9078 DB    C0H, "LEFT$("
0432A7 4C 
0432A8 45 
0432A9 46 
0432A9 54   
0432AA 24 
0432AB 28 
0432AD A9      9079 DB    A9H, "LEN"
0432AE 4C 
0432AF 45 
0432B0 4E 
0432B1 E9      9080 DB    E9H, "LET"
0432B2 4C 
0432B3 45 
0432B4 54 
0432B5 AB      9081 DB    ABH, "LOG"
0432B6 4C 
0432B7 4F 
0432B8 47 
0432B9 AA      9082 DB    AAH, "LN"
0432BA 4C 
0432BB 4E 
0432BC C1      9083 DB    C1H, "MID$("
0432BD 4D 
0432BE 49 
0432BF 44 
0432BF 24   
0432C0 28 
0432C2 EB      9084 DB    EBH, "MODE"
0432C3 4D 
0432C4 4F 
0432C5 44 
0432C5 45   
0432C7 83      9085 DB    83H, "MOD"
0432C8 4D 
0432C9 4F 
0432CA 44 
0432CB EC      9086 DB    ECH, "MOVE"
0432CC 4D 
0432CD 4F 
0432CE 56 
0432CE 45   
0432D0 ED      9087 DB    EDH, "NEXT"
0432D1 4E 
0432D2 45 
0432D3 58 
0432D3 54   
0432D5 CA      9088 DB    CAH, "NEW", 0
0432D6 4E 
0432D7 45 
0432D8 57 
0432D8 00   
0432DA AC      9089 DB    ACH, "NOT"
0432DB 4E 
0432DC 4F 
0432DD 54 
0432DE CB      9090 DB    CBH, "OLD", 0
0432DF 4F 
0432E0 4C 
0432E1 44 
0432E1 00   
0432E3 EE      9091 DB    EEH, "ON"
0432E4 4F 
0432E5 4E 
0432E6 87      9092 DB    87H, "OFF"
0432E7 4F 
0432E8 46 
0432E9 46 
0432EA 84      9093 DB    84H, "OR"
0432EB 4F 
0432EC 52 
0432ED 8E      9094 DB    8EH, "OPENIN"
0432EE 4F 
0432EF 50 
0432F0 45 
0432F0 4E   
0432F1 49 
0432F2 4E 
0432F4 AE      9095 DB    AEH, "OPENOUT"
0432F5 4F 
0432F6 50 
0432F7 45 
0432F7 4E   
0432F8 4F 
0432F9 55 
0432FA 54 
0432FC AD      9096 DB    ADH, "OPENUP"
0432FD 4F 
0432FE 50 
0432FF 45 
0432FF 4E   
043300 55 
043301 50 
043303 FF      9097 DB    FFH, "OSCLI"
043304 4F 
043305 53 
043306 43 
043306 4C   
043307 49 
043309 F1      9098 DB    F1H, "PRINT"
04330A 50 
04330B 52 
04330C 49 
04330C 4E   
04330D 54 
04330F 90      9099 DB    90H, "PAGE", 0
043310 50 
043311 41 
043312 47 
043312 45   
043313 00 
043315 8F      9100 DB    8FH, "PTR", 0
043316 50 
043317 54 
043318 52 
043318 00   
04331A AF      9101 DB    AFH, "PI", 0
04331B 50 
04331C 49 
04331D 00 
04331E F0      9102 DB    F0H, "PLOT"
04331F 50 
043320 4C 
043321 4F 
043321 54   
043323 B0      9103 DB    B0H, "POINT("
043324 50 
043325 4F 
043326 49 
043326 4E   
043327 54 
043328 28 
04332A F2      9104 DB    F2H, "PROC"
04332B 50 
04332C 52 
04332D 4F 
04332D 43   
04332F B1      9105 DB    B1H, "POS", 0
043330 50 
043331 4F 
043332 53 
043332 00   
043334 CE      9106 DB    CEH, "PUT"
043335 50 
043336 55 
043337 54 
043338 F8      9107 DB    F8H, "RETURN", 0
043339 52 
04333A 45 
04333B 54 
04333B 55   
04333C 52 
04333D 4E 
04333E 00 
043340 F5      9108 DB    F5H, "REPEAT"
043341 52 
043342 45 
043343 50 
043343 45   
043344 41 
043345 54 
043347 F6      9109 DB    F6H, "REPORT", 0
043348 52 
043349 45 
04334A 50 
04334A 4F   
04334B 52 
04334C 54 
04334D 00 
04334F F3      9110 DB    F3H, "READ"
043350 52 
043351 45 
043352 41 
043352 44   
043354 F4      9111 DB    F4H, "REM"
043355 52 
043356 45 
043357 4D 
043358 F9      9112 DB    F9H, "RUN", 0
043359 52 
04335A 55 
04335B 4E 
04335B 00   
04335D B2      9113 DB    B2H, "RAD"
04335E 52 
04335F 41 
043360 44 
043361 F7      9114 DB    F7H, "RESTORE"
043362 52 
043363 45 
043364 53 
043364 54   
043365 4F 
043366 52 
043367 45 
043369 C2      9115 DB    C2H, "RIGHT$("
04336A 52 
04336B 49 
04336C 47 
04336C 48   
04336D 54 
04336E 24 
04336F 28 
043371 B3      9116 DB    B3H, "RND", 0
043372 52 
043373 4E 
043374 44 
043374 00   
043376 CC      9117 DB    CCH, "RENUMBER"
043377 52 
043378 45 
043379 4E 
043379 55   
04337A 4D 
04337B 42 
04337C 45 
04337C 52   
04337F 88      9118 DB    88H, "STEP"
043380 53 
043381 54 
043382 45 
043382 50   
043384 CD      9119 DB    CDH, "SAVE"
043385 53 
043386 41 
043387 56 
043387 45   
043389 B4      9120 DB    B4H, "SGN"
04338A 53 
04338B 47 
04338C 4E 
04338D B5      9121 DB    B5H, "SIN"
04338E 53 
04338F 49 
043390 4E 
043391 B6      9122 DB    B6H, "SQR"
043392 53 
043393 51 
043394 52 
043395 89      9123 DB    89H, "SPC"
043396 53 
043397 50 
043398 43 
043399 C3      9124 DB    C3H, "STR$"
04339A 53 
04339B 54 
04339C 52 
04339C 24   
04339E C4      9125 DB    C4H, "STRING$("
04339F 53 
0433A0 54 
0433A1 52 
0433A1 49   
0433A2 4E 
0433A3 47 
0433A4 24 
0433A4 28   
0433A7 D4      9126 DB    D4H, "SOUND"
0433A8 53 
0433A9 4F 
0433AA 55 
0433AA 4E   
0433AB 44 
0433AD FA      9127 DB    FAH, "STOP", 0
0433AE 53 
0433AF 54 
0433B0 4F 
0433B0 50   
0433B1 00 
0433B3 B7      9128 DB    B7H, "TAN"
0433B4 54 
0433B5 41 
0433B6 4E 
0433B7 8C      9129 DB    8CH, "THEN"
0433B8 54 
0433B9 48 
0433BA 45 
0433BA 4E   
0433BC B8      9130 DB    B8H, "TO"
0433BD 54 
0433BE 4F 
0433BF 8A      9131 DB    8AH, "TAB("
0433C0 54 
0433C1 41 
0433C2 42 
0433C2 28   
0433C4 FC      9132 DB    FCH, "TRACE"
0433C5 54 
0433C6 52 
0433C7 41 
0433C7 43   
0433C8 45 
0433CA 91      9133 DB    91H, "TIME", 0
0433CB 54 
0433CC 49 
0433CD 4D 
0433CD 45   
0433CE 00 
0433D0 B9      9134 DB    B9H, "TRUE", 0
0433D1 54 
0433D2 52 
0433D3 55 
0433D3 45   
0433D4 00 
0433D6 FD      9135 DB    FDH, "UNTIL"
0433D7 55 
0433D8 4E 
0433D9 54 
0433D9 49   
0433DA 4C 
0433DC BA      9136 DB    BAH, "USR"
0433DD 55 
0433DE 53 
0433DF 52 
0433E0 EF      9137 DB    EFH, "VDU"
0433E1 56 
0433E2 44 
0433E3 55 
0433E4 BB      9138 DB    BBH, "VAL"
0433E5 56 
0433E6 41 
0433E7 4C 
0433E8 BC      9139 DB    BCH, "VPOS", 0
0433E9 56 
0433EA 50 
0433EB 4F 
0433EB 53   
0433EC 00 
0433EE FE      9140 DB    FEH, "WIDTH"
0433EF 57 
0433F0 49 
0433F1 44 
0433F1 54   
0433F2 48 
0433F4 D3      9141 DB    D3H, "HIMEM"
0433F5 48 
0433F6 49 
0433F7 4D 
0433F7 45   
0433F8 4D 
0433FA D2      9142 DB    D2H, "LOMEM"
0433FB 4C 
0433FC 4F 
0433FD 4D 
0433FD 45   
0433FE 4D 
043400 D0      9143 DB    D0H, "PAGE"
043401 50 
043402 41 
043403 47 
043403 45   
043405 CF      9144 DB    CFH, "PTR"
043406 50 
043407 54 
043408 52 
043409 D1      9145 DB    D1H, "TIME"
04340A 54 
04340B 49 
04340C 4D 
04340C 45   
               9146 ;
               9147 ; These are indexed from the ERRWDS table
               9148 ;
04340E 01      9149 DB    01H, "Missing "
04340F 4D 
043410 69 
043411 73 
043411 73   
043412 69 
043413 6E 
043414 67 
043414 20   
043417 02      9150 DB    02H, "No such "
043418 4E 
043419 6F 
04341A 20 
04341A 73   
04341B 75 
04341C 63 
04341D 68 
04341D 20   
043420 03      9151 DB    03H, "Bad "
043421 42 
043422 61 
043423 64 
043423 20   
043425 04      9152 DB    04H, " range"
043426 20 
043427 72 
043428 61 
043428 6E   
043429 67 
04342A 65 
04342C 05      9153 DB    05H, "variable"
04342D 76 
04342E 61 
04342F 72 
04342F 69   
043430 61 
043431 62 
043432 6C 
043432 65   
043435 06      9154 DB    06H, "Out of"
043436 4F 
043437 75 
043438 74 
043438 20   
043439 6F 
04343A 66 
04343C 07      9155 DB    07H, "No "
04343D 4E 
04343E 6F 
04343F 20 
043440 08      9156 DB    08H, " space"
043441 20 
043442 73 
043443 70 
043443 61   
043444 63 
043445 65 
               9157 
               9158 KEYWDL:			EQU     $-KEYWDS
043447 FF      9159 DW    -1
043448 FF 
               9160 ;
               9161 ; Error messages
               9162 ;
043449 07      9163 ERRWDS:			DB    7, "room", 0		;  0: No room
04344A 72 
04344B 6F 
04344C 6F 
04344C 6D   
04344D 00 
04344F 06      9164 DB    6, 4, 0			;  1: Out of range
043450 04 
043451 00 
043452 00      9165 DB    0				;  2: *
043453 00      9166 DB    0				;  3: *
043454 4D      9167 DB    "Mistake", 0		;  4: Mistake
043455 69 
043456 73 
043457 74 
043457 61   
043458 6B 
043459 65 
04345A 00 
04345C 01      9168 DB    1, ",", 0			;  5: Missing ,
04345D 2C 
04345E 00 
04345F 54      9169 DB    "Type mismatch", 0	;  6: Type mismatch
043460 79 
043461 70 
043462 65 
043462 20   
043463 6D 
043464 69 
043465 73 
043465 6D   
043466 61 
043467 74 
043468 63 
043468 68   
043469 00 
04346D 07      9170 DB    7, FN, 0			;  7: No FN
04346E A4 
04346F 00 
043470 00      9171 DB    0				;  8: *
043471 01      9172 DB    1, 34, 0			;  9: Missing "
043472 22 
043473 00 
043474 03      9173 DB    3, DIM, 0			; 10: Bad DIM
043475 DE 
043476 00 
043477 DE      9174 DB    DIM, 8, 0			; 11: DIM space
043478 08 
043479 00 
04347A 4E      9175 DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
04347B 6F 
04347C 74 
04347D 20 
04347D EA   
04347E 00 
043480 07      9176 DB    7, PROC, 0		; 13: No PROC
043481 F2 
043482 00 
043483 41      9177 DB    "Array", 0		; 14: Array
043484 72 
043485 72 
043486 61 
043486 79   
043487 00 
043489 53      9178 DB    "Subscript", 0		; 15: Subscript
04348A 75 
04348B 62 
04348C 73 
04348C 63   
04348D 72 
04348E 69 
04348F 70 
04348F 74   
043490 00 
043493 53      9179 DB    "Syntax error", 0		; 16: Syntax error
043494 79 
043495 6E 
043496 74 
043496 61   
043497 78 
043498 20 
043499 65 
043499 72   
04349A 72 
04349B 6F 
04349C 72 
04349C 00   
0434A0 45      9180 DB    "Escape", 0		; 17: Escape
0434A1 73 
0434A2 63 
0434A3 61 
0434A3 70   
0434A4 65 
0434A5 00 
0434A7 44      9181 DB    "Division by zero", 0	; 18: Division by zero
0434A8 69 
0434A9 76 
0434AA 69 
0434AA 73   
0434AB 69 
0434AC 6F 
0434AD 6E 
0434AD 20   
0434AE 62 
0434AF 79 
0434B0 20 
0434B0 7A   
0434B1 65 
0434B2 72 
0434B3 6F 
0434B3 00   
0434B8 53      9182 DB    "String too long", 0	; 19: String too long
0434B9 74 
0434BA 72 
0434BB 69 
0434BB 6E   
0434BC 67 
0434BD 20 
0434BE 74 
0434BE 6F   
0434BF 6F 
0434C0 20 
0434C1 6C 
0434C1 6F   
0434C2 6E 
0434C3 67 
0434C4 00 
0434C8 54      9183 DB    "Too big", 0		; 20: Too big
0434C9 6F 
0434CA 6F 
0434CB 20 
0434CB 62   
0434CC 69 
0434CD 67 
0434CE 00 
0434D0 2D      9184 DB    "-ve root", 0		; 21: -ve root
0434D1 76 
0434D2 65 
0434D3 20 
0434D3 72   
0434D4 6F 
0434D5 6F 
0434D6 74 
0434D6 00   
0434D9 4C      9185 DB    "Log", 4, 0		; 22: Log range
0434DA 6F 
0434DB 67 
0434DC 04 
0434DC 00   
0434DE 41      9186 DB    "Accuracy lost", 0	; 23: Accuracy lost
0434DF 63 
0434E0 63 
0434E1 75 
0434E1 72   
0434E2 61 
0434E3 63 
0434E4 79 
0434E4 20   
0434E5 6C 
0434E6 6F 
0434E7 73 
0434E7 74   
0434E8 00 
0434EC 45      9187 DB    "Exp", 4, 0		; 24: Exp range
0434ED 78 
0434EE 70 
0434EF 04 
0434EF 00   
0434F1 00      9188 DB    0				; 25: *
0434F2 02      9189 DB    2, 5, 0			; 26: No such variable
0434F3 05 
0434F4 00 
0434F5 01      9190 DB    1, ")", 0			; 27: Missing )
0434F6 29 
0434F7 00 
0434F8 03      9191 DB    3, "HEX", 0		; 28: Bad HEX
0434F9 48 
0434FA 45 
0434FB 58 
0434FB 00   
0434FD 02      9192 DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
0434FE A4 
0434FF 2F 
043500 F2 
043500 00   
043502 03      9193 DB    3, "call", 0		; 30: Bad call
043503 63 
043504 61 
043505 6C 
043505 6C   
043506 00 
043508 41      9194 DB    "Arguments", 0		; 31: Arguments
043509 72 
04350A 67 
04350B 75 
04350B 6D   
04350C 65 
04350D 6E 
04350E 74 
04350E 73   
04350F 00 
043512 07      9195 DB    7, FOR, 0			; 32: No FOR
043513 E3 
043514 00 
043515 43      9196 DB    "Can't match ", FOR, 0	; 33: Can't match FOR
043516 61 
043517 6E 
043518 27 
043518 74   
043519 20 
04351A 6D 
04351B 61 
04351B 74   
04351C 63 
04351D 68 
04351E 20 
04351E E3   
04351F 00 
043523 E3      9197 DB    FOR, " ", 5, 0		; 34: FOR variable
043524 20 
043525 05 
043526 00 
043527 00      9198 DB    0				; 35: *
043528 07      9199 DB    7, TO_MN, 0			; 36: No TO
043529 B8 
04352A 00 
04352B 00      9200 DB    0				; 37: *
04352C 07      9201 DB    7, GOSUB, 0		; 38: No GOSUB
04352D E4 
04352E 00 
04352F EE      9202 DB    ON_, " syntax", 0		; 39: ON syntax
043530 20 
043531 73 
043532 79 
043532 6E   
043533 74 
043534 61 
043535 78 
043535 00   
043538 EE      9203 DB    ON_, 4, 0			; 40: ON range
043539 04 
04353A 00 
04353B 02      9204 DB    2, "line", 0		; 41: No such line
04353C 6C 
04353D 69 
04353E 6E 
04353E 65   
04353F 00 
043541 06      9205 DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
043542 20 
043543 DC 
043544 00 
043545 07      9206 DB    7, REPEAT, 0		; 43: No REPEAT
043546 F5 
043547 00 
043548 00      9207 DB    0				; 44: *
043549 01      9208 DB    1, "#", 0			; 45: Missing #
04354A 23 
04354B 00 
               9209 ;
               9210 ; COMMANDS:
               9211 ;
               9212 ; DELETE line,line
               9213 ;
04354C CD      9214 DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
04354D 4B 
04354E 38 
04354F 04 
043550 CD      9215 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043551 53 
043552 3C 
043553 04 
043554 7E      9216 DELET1:			LD      A,(HL)			; Check whether it's the last line
043555 B7      9217 OR      A
043556 CA      9218 JP      Z,WARMNC		; Yes, so do nothing
043557 DD 
043558 35 
043559 04 
04355A 23      9219 INC     HL			; Skip the line length byte
04355B 11      9220 LD	DE, 0			; Clear DE
04355C 00 
04355D 00 
04355E 00 
04355F 5E      9221 LD      E,(HL)			; Fetch the line number in DE
043560 23      9222 INC     HL
043561 56      9223 LD      D,(HL)
043562 7A      9224 LD      A,D			; If the line number is zero then
043563 B3      9225 OR      E
043564 28      9226 JR      Z,CLOOP1        	; Do nothing
043565 1D 
043566 2B      9227 DEC     HL			; Decrement BASIC program pointer back to length
043567 2B      9228 DEC     HL
043568 EB      9229 EX      DE,HL			; Check if we've gone past the terminating line
043569 37      9230 SCF
04356A ED      9231 SBC     HL,BC
04356B 42 
04356C EB      9232 EX      DE,HL
04356D 30      9233 JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04356E 6E 
04356F C5      9234 PUSH    BC
043570 CD      9235 CALL    DEL			; Delete the line pointed to by HL
043571 02 
043572 38 
043573 04 
043574 C1      9236 POP     BC
043575 18      9237 JR      DELET1			; And loop round to the next line
043576 DD 
               9238 ;
               9239 ; LISTO expr
               9240 ;
043577 FD      9241 LISTO:			INC     IY              	; Skip "O" byte
043578 23 
043579 CD      9242 CALL    EXPRI			; Get expr
04357A 0A 
04357B 03 
04357C 04 
04357D D9      9243 EXX
04357E 7D      9244 LD      A,L
04357F 32      9245 LD      (LISTON),A		; Store in LISTON sysvar
043580 40 
043581 4D 
043582 04 
043583 C3      9246 CLOOP1:			JP      CLOOP
043584 80 
043585 30 
043586 04 
               9247 ;
               9248 ; LIST
               9249 ; LIST line
               9250 ; LIST line,line [IF string]
               9251 ; LIST ,line
               9252 ; LIST line,
               9253 ;
043587 FE      9254 LIST_:			CP      'O'			; Check for O (LISTO)
043588 4F 
043589 28      9255 JR      Z,LISTO			; and jump to LISTO if zero
04358A EC 
04358B CD      9256 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04358C 53 
04358D 3C 
04358E 04 
04358F CD      9257 CALL    NXT			; Skip space
043590 70 
043591 0A 
043592 04 
043593 FE      9258 CP      TIF             	; Check for IF clause (token IF)
043594 E7 
043595 3E      9259 LD      A,0             	; Initialise the IF clause string length
043596 00 
043597 20      9260 JR      NZ,LISTB		; If there is no IF clause, skip the next bit
043598 17 
               9261 ;
043599 FD      9262 INC     IY              	; Skip the IF token
04359A 23 
04359B CD      9263 CALL    NXT             	; And skip any spaces
04359C 70 
04359D 0A 
04359E 04 
04359F EB      9264 EX      DE,HL			; DE: Address in memory
0435A0 FD      9265 PUSH    IY			; LD IY, HL
0435A1 E5 
0435A2 E1      9266 POP     HL              	; HL is now the address of the tokenised line
0435A3 3E      9267 LD      A,CR
0435A4 0D 
0435A5 C5      9268 PUSH    BC			; Stack the second line number arg
0435A6 01      9269 LD      BC,256
0435A7 00 
0435A8 01 
0435A9 00 
0435AA ED      9270 CPIR                    	; Locate CR byte
0435AB B1 
0435AC 79      9271 LD      A,C
0435AD 2F      9272 CPL                    	 	; A: Substring length (of IF clause)
0435AE C1      9273 POP     BC			; Restore the second line number arg
0435AF EB      9274 EX      DE,HL			; HL: Address in memory
               9275 ;
0435B0 5F      9276 LISTB:			LD      E,A             	; E: IF clause string length
0435B1 78      9277 LD      A,B			; Check whether a second line number was passed (BC!=0)
0435B2 B1      9278 OR      C
0435B3 20      9279 JR      NZ,LISTA		; If there isn't a second line number
0435B4 01 
0435B5 0B      9280 DEC     BC			; then we set it to the maximum of 65535
               9281 ;
0435B6 D9      9282 LISTA:			EXX
0435B7 DD      9283 LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
0435B8 21 
0435B9 40 
0435BA 4D 
0435BA 04   
0435BC 01      9284 LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435BD 00 
0435BE 00 
0435BF 00 
0435C0 D9      9285 EXX
0435C1 3E      9286 LD      A,20			; Number of lines to list
0435C2 14 
               9287 ;
0435C3 C5      9288 LISTC:			PUSH    BC              	; Save second line number
0435C4 D5      9289 PUSH    DE              	; Save IF clause length
0435C5 E5      9290 PUSH    HL              	; Save BASIC program counter
0435C6 08      9291 EX      AF,AF'
               9292 ;
               9293 ; BBC BASIC for Z80 lines are stored as follows:
               9294 ;
               9295 ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
               9296 ; - [&00] [&FF] [&FF]: End of program marker
               9297 ;
               9298 ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
               9299 ;
0435C7 7E      9300 LD      A,(HL)			; Check for end of program marker
0435C8 B7      9301 OR      A			; If found
0435C9 28      9302 JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0435CA 12 
               9303 ;
               9304 ; Check if past terminating line number
               9305 ;
0435CB 7B      9306 LD      A,E             	; A: IF clause length
0435CC 23      9307 INC     HL			; Skip the length byte
0435CD 11      9308 LD	DE,0			; Clear DE
0435CE 00 
0435CF 00 
0435D0 00 
0435D1 5E      9309 LD      E,(HL)			; Fetch the line number in DE
0435D2 23      9310 INC     HL
0435D3 56      9311 LD      D,(HL)
0435D4 2B      9312 DEC     HL			; Step HL back to the length byte
0435D5 2B      9313 DEC     HL
0435D6 D5      9314 PUSH    DE             	 	; Push the line number on the stack
0435D7 EB      9315 EX      DE,HL			; HL: line number
0435D8 37      9316 SCF				; Do a 16-bit compare of HL and DE
0435D9 ED      9317 SBC     HL,BC
0435DA 42 
0435DB EB      9318 EX      DE,HL
0435DC D1      9319 POP     DE              	; Restore the line number
0435DD D2      9320 WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0435DE 7F 
0435DF 30 
0435E0 04 
0435E1 4E      9321 LD      C,(HL)          	; C: Line length + 4
0435E2 47      9322 LD      B,A             	; B: IF clause length
               9323 ;
               9324 ; Check if "UNLISTABLE":
               9325 ;
0435E3 7A      9326 LD      A,D			; TODO: What is "UNLISTABLE?"
0435E4 B3      9327 OR      E
0435E5 CA      9328 JP      Z,CLOOP
0435E6 80 
0435E7 30 
0435E8 04 
               9329 ;
               9330 ; Check for IF clause:
               9331 ;
0435E9 23      9332 INC     HL			; Skip the length
0435EA 23      9333 INC     HL			; Skip the line number
0435EB 23      9334 INC     HL              	; HL: Address of the tokenised BASIC line
0435EC 0D      9335 DEC     C			;  C: Line length
0435ED 0D      9336 DEC     C
0435EE 0D      9337 DEC     C
0435EF 0D      9338 DEC     C
0435F0 D5      9339 PUSH    DE              	; Save the line number
0435F1 E5      9340 PUSH    HL              	; Save the BASIC program address
0435F2 AF      9341 XOR     A               	;
0435F3 B8      9342 CP      B              	 	; Check for an IF clause (B!=0)
0435F4 FD      9343 PUSH    IY			; LD IY, DE
0435F5 E5 
0435F6 D1      9344 POP     DE              	; DE: Address of the IF clause string in the input buffer
0435F7 C4      9345 CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0435F8 85 
0435F9 07 
0435FA 04 
0435FB E1      9346 POP     HL              	; Restore BASIC program address
0435FC D1      9347 POP     DE              	; Restore line number
0435FD FD      9348 PUSH    IY
0435FE E5 
0435FF CC      9349 CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043600 92 
043601 38 
043602 04 
043603 FD      9350 POP     IY
043604 E1 
               9351 ;
043605 08      9352 EX      AF,AF'
043606 3D      9353 DEC     A			; Decrement line list counter
043607 CD      9354 CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043608 71 
043609 3F 
04360A 04 
04360B E1      9355 POP     HL             	 	; Restore BASIC program address to beginning of line
04360C 11      9356 LD	DE,0
04360D 00 
04360E 00 
04360F 00 
043610 5E      9357 LD      E,(HL)			; Fetch the length of line in DE
043611 19      9358 ADD     HL,DE           	; Go to the next line
043612 D1      9359 POP     DE              	; Restore IF clause length
043613 C1      9360 POP     BC              	; Restore second line number
043614 18      9361 JR      LISTC			; Loop back to do next line
043615 AD 
               9362 ;
               9363 ; RENUMBER
               9364 ; RENUMBER start
               9365 ; RENUMBER start,increment
               9366 ; RENUMBER ,increment
               9367 ;
043616 CD      9368 RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
043617 76 
043618 38 
043619 04 
04361A CD      9369 CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04361B 2B 
04361C 3C 
04361D 04 
04361E D9      9370 EXX
04361F 2A      9371 LD      HL,(PAGE_)		; HL: Top of program
043620 14 
043621 4D 
043622 04 
043623 ED      9372 LD      DE,(LOMEM)		; DE: Start address of the heap
043624 5B 
043625 1A 
043626 4D 
043626 04   
               9373 ;
               9374 ; Build the table
               9375 ;
043628 7E      9376 RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043629 B7      9377 OR      A			; Is it zero, i.e. the end of program marker?
04362A 28      9378 JR      Z,RENUM2		; Yes, so skip to the next part
04362B 36 
04362C 23      9379 INC     HL
04362D 4E      9380 LD      C,(HL)          	; BC: The OLD line number
04362E 23      9381 INC     HL
04362F 46      9382 LD      B,(HL)
043630 78      9383 LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043631 B1      9384 OR      C
043632 CA      9385 JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043633 80 
043634 30 
043635 04 
043636 EB      9386 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043637 71      9387 LD      (HL),C			; Store the OLD line number in the heap
043638 23      9388 INC     HL
043639 70      9389 LD      (HL),B
04363A 23      9390 INC     HL
04363B D9      9391 EXX				; HL: line number, BC: increment (16-bit values)
04363C E5      9392 PUSH    HL			; HL: Stack the NEW line number value
04363D 52      9393 ADD.S   HL,BC           	; Add the increment
04363E 09 
04363F DA      9394 JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043640 25 
043641 3C 
043642 04 
043643 D9      9395 EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
043644 C1      9396 POP     BC			; BC: Pop the NEW line number value off the stack
043645 71      9397 LD      (HL),C			; Store the NEW line number in the heap
043646 23      9398 INC     HL
043647 70      9399 LD      (HL),B
043648 23      9400 INC     HL
043649 EB      9401 EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
04364A 2B      9402 DEC     HL			; Back up to the line length byte
04364B 2B      9403 DEC     HL
04364C 01      9404 LD	BC, 0
04364D 00 
04364E 00 
04364F 00 
043650 4E      9405 LD      C,(HL)			; BC: Line length
043651 09      9406 ADD	HL,BC           	; Advance HL to next line
043652 EB      9407 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043653 E5      9408 PUSH    HL
043654 24      9409 INC     H			; Increment to next page
043655 ED      9410 SBC     HL,SP			; Subtract from SP
043656 72 
043657 E1      9411 POP     HL
043658 EB      9412 EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043659 38      9413 JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
04365A CD 
04365B CD      9414 CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04365C 77 
04365D 37 
04365E 04 
04365F CC      9415 DB    	REN
043660 08      9416 DB    	8
043661 00      9417 DB    	0
               9418 ;
               9419 ; At this point a list of BASIC line numbers have been written to the heap
               9420 ; as word pairs:
               9421 ; - DW: The OLD line number
               9422 ; - DW: The NEW line number
               9423 ;
043662 EB      9424 RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
043663 36      9425 LD      (HL),-1			; Mark the end with FFFFh
043664 FF 
043665 23      9426 INC     HL
043666 36      9427 LD      (HL),-1
043667 FF 
043668 ED      9428 LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
043669 5B 
04366A 1A 
04366B 4D 
04366B 04   
04366D D9      9429 EXX
04366E 2A      9430 LD      HL,(PAGE_)		; HL: Start of the BASIC program area
04366F 14 
043670 4D 
043671 04 
043672 4E      9431 RENUM3:			LD      C,(HL)			; Fetch the first line length byte
043673 79      9432 LD      A,C			; If it is zero, then no program, so...
043674 B7      9433 OR      A
043675 CA      9434 JP      Z,WARM			; Jump to warm start
043676 7F 
043677 30 
043678 04 
043679 D9      9435 EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
04367A EB      9436 EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
04367B 23      9437 INC     HL			; Skip to the NEW line number
04367C 23      9438 INC     HL
04367D 5E      9439 LD      E,(HL)			; DE: The NEW line number
04367E 23      9440 INC     HL
04367F 56      9441 LD      D,(HL)
043680 23      9442 INC     HL
043681 D5      9443 PUSH    DE			; Stack the NEW line number
043682 EB      9444 EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
043683 22      9445 LD      (LINENO),HL		; Store the line number in LINENO
043684 23 
043685 4D 
043686 04 
043687 D9      9446 EXX				; HL: Pointer to the BASIC program area
043688 D1      9447 POP     DE			; DE: The NEW line number
043689 23      9448 INC     HL
04368A 73      9449 LD      (HL),E          	; Write out the NEW line number to the BASIC program
04368B 23      9450 INC     HL
04368C 72      9451 LD      (HL),D
04368D 23      9452 INC     HL
04368E 0D      9453 DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
04368F 0D      9454 DEC     C
043690 0D      9455 DEC     C
043691 79      9456 LD	A,C
043692 01      9457 LD	BC,0
043693 00 
043694 00 
043695 00 
043696 4F      9458 LD	C,A			; BC: Line length
               9459 ;
043697 3E      9460 RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
043698 8D 
043699 ED      9461 CPIR                    	; Search for the token
04369A B1 
04369B 20      9462 JR      NZ,RENUM3		; If not found, then loop to process the next line
04369C D5 
               9463 ;
               9464 ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
               9465 ;
04369D C5      9466 PUSH    BC			; Stack everything
04369E E5      9467 PUSH    HL
04369F E5      9468 PUSH    HL			; HL: Pointer to encoded line number
0436A0 FD      9469 POP     IY			; IY: Pointer to encoded line number
0436A1 E1 
0436A2 D9      9470 EXX
0436A3 CD      9471 CALL    DECODE			; Decode the encoded line number (in HL')
0436A4 E6 
0436A5 08 
0436A6 04 
0436A7 D9      9472 EXX				; HL: Decoded line number
0436A8 44      9473 LD      B,H			; BC: Decoded line number
0436A9 4D      9474 LD      C,L
0436AA 2A      9475 LD      HL,(LOMEM)		; HL: Pointer to heap
0436AB 1A 
0436AC 4D 
0436AD 04 
               9476 ;
               9477 ; This section of code cross-references the decoded (OLD) line number with the list
               9478 ; created previously in the global heap
               9479 ;
0436AE 5E      9480 RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436AF 23      9481 INC     HL
0436B0 56      9482 LD      D,(HL)
0436B1 23      9483 INC     HL
0436B2 EB      9484 EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436B3 B7      9485 OR      A               	; Clear the carry and...
0436B4 52      9486 SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436B5 ED 
0436B6 42 
0436B7 EB      9487 EX      DE,HL			; HL: Pointer in the global heap
0436B8 5E      9488 LD      E,(HL)          	; DE: The NEW line number
0436B9 23      9489 INC     HL
0436BA 56      9490 LD      D,(HL)
0436BB 23      9491 INC     HL
0436BC 38      9492 JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436BD F0 
0436BE EB      9493 EX      DE,HL			; DE: Pointer in the global heap
0436BF 28      9494 JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436C0 1D 
               9495 ;
0436C1 CD      9496 CALL    TELL			; Display this error if the line number is not found
0436C2 90 
0436C3 3D 
0436C4 04 
0436C5 46      9497 DB    	"Failed at "
0436C6 61 
0436C7 69 
0436C8 6C 
0436C8 65   
0436C9 64 
0436CA 20 
0436CB 61 
0436CB 74   
0436CC 20 
0436CF 00      9498 DB    	0
0436D0 2A      9499 LD      HL,(LINENO)
0436D1 23 
0436D2 4D 
0436D3 04 
0436D4 CD      9500 CALL    PBCDL
0436D5 F7 
0436D6 39 
0436D7 04 
0436D8 CD      9501 CALL    CRLF
0436D9 47 
0436DA 39 
0436DB 04 
0436DC 18      9502 JR      RENUM6			; And carry on renumbering
0436DD 07 
               9503 ;
               9504 ; This snippet re-encodes the line number in the BASIC program
               9505 ;
0436DE D1      9506 RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0436DF D5      9507 PUSH    DE
0436E0 1B      9508 DEC     DE			; Back up a byte to the LINO token
0436E1 CD      9509 CALL    ENCODE          	; Re-write the new line number out
0436E2 5C 
0436E3 3D 
0436E4 04 
0436E5 E1      9510 RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0436E6 C1      9511 POP     BC			; BC: The remaining line length
0436E7 18      9512 JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0436E8 AE 
               9513 ;
               9514 ; AUTO
               9515 ; AUTO start,increment
               9516 ; AUTO start
               9517 ; AUTO ,increment
               9518 ;
0436E9 CD      9519 AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0436EA 2B 
0436EB 3C 
0436EC 04 
0436ED 22      9520 LD      (AUTONO),HL		; Store the start in AUTONO
0436EE 29 
0436EF 4D 
0436F0 04 
0436F1 79      9521 LD      A,C			; Increment is 8 bit (0-255)
0436F2 32      9522 LD      (INCREM),A		; Store that in INCREM
0436F3 41 
0436F4 4D 
0436F5 04 
0436F6 18      9523 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0436F7 2E 
               9524 ;
               9525 ; BAD
               9526 ; NEW
               9527 ;
0436F8 CD      9528 BAD:			CALL    TELL            	; Output "Bad program" error
0436F9 90 
0436FA 3D 
0436FB 04 
0436FC 03      9529 DB    3				; Token for "BAD"
0436FD 70      9530 DB    "program"
0436FE 72 
0436FF 6F 
043700 67 
043700 72   
043701 61 
043702 6D 
043704 0D      9531 DB    CR
043705 0A      9532 DB    LF
043706 00      9533 DB    0				; Falls through to NEW
               9534 ;
043707 CD      9535 NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043708 6C 
043709 38 
04370A 04 
04370B 18      9536 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04370C 19 
               9537 ;
               9538 ; OLD
               9539 ;
04370D 2A      9540 OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
04370E 14 
04370F 4D 
043710 04 
043711 E5      9541 PUSH    HL			; Stack it
043712 23      9542 INC     HL			; Skip the potential length byte of first line of code
043713 23      9543 INC     HL			; And the line number word
043714 23      9544 INC     HL
043715 01      9545 LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043716 FC 
043717 00 
043718 00 
043719 3E      9546 LD      A,CR
04371A 0D 
04371B ED      9547 CPIR
04371C B1 
04371D 20      9548 JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04371E D9 
04371F 7D      9549 LD      A,L			; It could still be garbage though! Store the position in A; this requires
043720 E1      9550 POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043721 77      9551 LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043722 CD      9552 CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043723 3F 
043724 38 
043725 04 
043726 C3      9553 CLOOP0:			JP      CLOOP			; Jump back to the command loop
043727 80 
043728 30 
043729 04 
               9554 ;
               9555 ; LOAD filename
               9556 ;
04372A CD      9557 LOAD:			CALL    EXPRS           	; Get the filename
04372B 15 
04372C 03 
04372D 04 
04372E 3E      9558 LD      A,CR			; DE points to the last byte of filename in ACCS
04372F 0D 
043730 12      9559 LD      (DE),A			; Terminate filename with a CR
043731 CD      9560 CALL    LOAD0			; Load the file in, then CLEAN
043732 1F 
043733 38 
043734 04 
043735 CD      9561 CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043736 76 
043737 38 
043738 04 
043739 18      9562 JR      WARM0			; Jump back to the command loop
04373A 21 
               9563 ;
               9564 ; SAVE filename
               9565 ;
04373B CD      9566 SAVE:			CALL    SETTOP          	; Set TOP sysvar
04373C 4B 
04373D 38 
04373E 04 
04373F CD      9567 CALL    EXPRS           	; Get the filename
043740 15 
043741 03 
043742 04 
043743 3E      9568 LD      A,CR			; Terminate the filename with a CR
043744 0D 
043745 12      9569 LD      (DE),A
043746 ED      9570 LD      DE,(PAGE_)		; DE: Start of program memory
043747 5B 
043748 14 
043749 4D 
043749 04   
04374B 2A      9571 LD      HL,(TOP)		; HL: Top of program memory
04374C 17 
04374D 4D 
04374E 04 
04374F B7      9572 OR      A			; Calculate program size (TOP-PAGE)
043750 ED      9573 SBC     HL,DE
043751 52 
043752 44      9574 LD      B,H             	; BC: Length of program in bytes
043753 4D      9575 LD      C,L
043754 21      9576 LD      HL,ACCS			; HL: Address of the filename
043755 00 
043756 4A 
043757 04 
043758 CD      9577 CALL    OSSAVE			; Call the SAVE routine in patch.asm
043759 2D 
04375A 42 
04375B 04 
04375C C3      9578 WARM0:			JP      WARM			; Jump back to the command loop
04375D 7F 
04375E 30 
04375F 04 
               9579 
               9580 ;
               9581 ; ERROR
               9582 ; Called whenever BASIC needs to halt with an error
               9583 ; Error messages are indexed from 0
               9584 ; Inputs:
               9585 ;  A: Error number
               9586 ;
043760 ED      9587 ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
043761 7B 
043762 20 
043763 4D 
043763 04   
043765 21      9588 LD      HL,ERRWDS		; Index into the error string table
043766 49 
043767 34 
043768 04 
043769 B7      9589 OR      A			; We don't need to search for the first error
04376A 28      9590 JR      Z,ERROR1		; So skip the search routine
04376B 0A 
               9591 ;
               9592 ; Search the error table for error #A
               9593 ; HL will end up being the pointer into the correct error
               9594 ; There is no bounds checking on this, so invalid error numbers will probably output garbage
               9595 ;
04376C 47      9596 LD      B,A             	; Store error number in B
04376D 08      9597 EX      AF,AF'			; Store error number in AF'
04376E AF      9598 XOR     A
04376F BE      9599 ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
043770 23      9600 INC     HL			; Increment the string pointer
043771 20      9601 JR      NZ,ERROR0		; Loop until with hit a 0
043772 FC 
043773 10      9602 DJNZ    ERROR0			; Decrements the error number and loop until 0
043774 FA 
043775 08      9603 EX      AF,AF'			; Restore the error number from AF'
               9604 ;
               9605 ; At this point HL points to the tokenised error string
               9606 ;
043776 E5      9607 ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
               9608 
               9609 ;
               9610 ; EXTERR
               9611 ; Inputs:
               9612 ;  A: Error number
               9613 ;
               9614 ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
               9615 ; The error text immediately follows the CALL to EXTERR, for example:
               9616 ; > CALL  EXTERR
               9617 ; > DB    "Silly", 0
               9618 ; So we can get the address of the string by popping the return address off the stack
               9619 ;
043777 E1      9620 EXTERR:			POP     HL			; Pop the error string pointer
043778 22      9621 LD      (ERRTXT),HL		; Store in ERRTXT sysvar
043779 2F 
04377A 4D 
04377B 04 
04377C ED      9622 LD      SP,(HIMEM)		; Set SP to HIMEM
04377D 7B 
04377E 20 
04377F 4D 
04377F 04   
043781 32      9623 LD      (ERR),A			; Store error number in ERR sysvar
043782 3F 
043783 4D 
043784 04 
043785 CD      9624 CALL    SETLIN			; Get line number
043786 AE 
043787 39 
043788 04 
043789 22      9625 LD      (ERL),HL		; Store in ERL sysvar
04378A 33 
04378B 4D 
04378C 04 
04378D B7      9626 OR      A			; Is error number 0?
04378E 28      9627 JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
04378F 0D 
               9628 ;
043790 2A      9629 LD      HL,(ERRTRP)		; Check whether the error is trapped
043791 2C 
043792 4D 
043793 04 
043794 7C      9630 LD      A,H
043795 B5      9631 OR      L
043796 E5      9632 PUSH    HL			; HL: Error line
043797 FD      9633 POP     IY			; IY: HL
043798 E1 
043799 C2      9634 JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
04379A 96 
04379B 0B 
04379C 04 
               9635 ;
04379D 21      9636 ERROR2:			LD      HL,0
04379E 00 
04379F 00 
0437A0 00 
0437A1 22      9637 LD      (AUTONO),HL		; Cancel AUTO
0437A2 29 
0437A3 4D 
0437A4 04 
0437A5 22      9638 LD      (TRACEN),HL     	; Cancel TRACE
0437A6 26 
0437A7 4D 
0437A8 04 
0437A9 CD      9639 CALL    RESET           	; Reset OPSYS
0437AA B6 
0437AB 43 
0437AC 04 
0437AD CD      9640 CALL    CRLF			; Output newline
0437AE 47 
0437AF 39 
0437B0 04 
0437B1 CD      9641 CALL    REPORT          	; Output the error message
0437B2 82 
0437B3 3D 
0437B4 04 
0437B5 CD      9642 CALL    SAYLN			; Output " at line nnnn" message.
0437B6 E2 
0437B7 39 
0437B8 04 
0437B9 1E      9643 LD      E,0			; Close all files
0437BA 00 
0437BB DC      9644 CALL    C,OSSHUT
0437BC 2B 
0437BD 43 
0437BE 04 
0437BF CD      9645 CALL    CRLF			; Output newline
0437C0 47 
0437C1 39 
0437C2 04 
0437C3 C3      9646 JP      CLOOP			; Back to CLOOP
0437C4 80 
0437C5 30 
0437C6 04 
               9647 ;
               9648 ; SUBROUTINES:
               9649 ;
               9650 ; LEX - SEARCH FOR KEYWORDS
               9651 ;   Inputs: HL = start of keyword table
               9652 ;           IY = start of match text
               9653 ;  Outputs: If found, Z-flag set, A=token.
               9654 ;           If not found, Z-flag reset, A=(IY).
               9655 ;           IY updated (if NZ, IY unchanged).
               9656 ; Destroys: A,B,H,L,IY,F
               9657 ;
0437C7 21      9658 LEX:			LD      HL,KEYWDS		; Address of the keywords table
0437C8 68 
0437C9 31 
0437CA 04 
               9659 ;
0437CB FD      9660 LEX0:			LD      A,(IY)			; Fetch the character to match
0437CC 7E 
0437CD 00 
0437CE 46      9661 LD      B,(HL)			; B: The token from the keywords table
0437CF 23      9662 INC     HL			; Increment the pointer in the keywords table
0437D0 BE      9663 CP      (HL)			; Compare the first characters
0437D1 28      9664 JR      Z,LEX2			; If there is a match, then skip to LEX2
0437D2 08 
0437D3 D8      9665 RET     C               	; No match, so fail
               9666 ;
               9667 ; This snippet of code skips to the next token in the KEYWDS table
               9668 ;
0437D4 23      9669 LEX1:			INC     HL			; Increment the pointer
0437D5 CB      9670 BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0437D6 7E 
0437D7 28      9671 JR      Z,LEX1			; No, so loop
0437D8 FB 
0437D9 18      9672 JR      LEX0			; At this point HL is pointing to the start of the next keyword
0437DA F0 
               9673 ;
0437DB FD      9674 LEX2:			PUSH    IY              	; Save the input pointer
0437DC E5 
0437DD 23      9675 LEX3:			INC     HL			; Increment the keyword pointer
0437DE CB      9676 BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0437DF 7E 
0437E0 20      9677 JR      NZ,LEX6         	; Jump to here as we've found a token
0437E1 1C 
0437E2 FD      9678 INC     IY			; Increment the text pointer
0437E3 23 
0437E4 FD      9679 LD      A,(IY)			; Fetch the character
0437E5 7E 
0437E6 00 
0437E7 FE      9680 CP      '.'			; Is it an abbreviated keyword?
0437E8 2E 
0437E9 28      9681 JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0437EA 13 
0437EB BE      9682 CP      (HL)			; Compare with the keywords list
0437EC 28      9683 JR      Z,LEX3			; It's a match, so continue checking this keyword
0437ED EF 
0437EE CD      9684 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0437EF 7B 
0437F0 3C 
0437F1 04 
0437F2 38      9685 JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0437F3 04 
               9686 ;
0437F4 FD      9687 LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0437F5 E1 
0437F6 18      9688 JR      LEX1			; And loop back to start again
0437F7 DC 
               9689 ;
               9690 ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
               9691 ; immediately delimited
               9692 ;
0437F8 7E      9693 LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0437F9 B7      9694 OR      A			; If it is not zero, then...
0437FA 20      9695 JR      NZ,LEX4			; Keep searching
0437FB F8 
0437FC FD      9696 DEC     IY			; If it is zero, then skip the input pointer back one byte
0437FD 2B 
               9697 ;
               9698 ; We've found a token at this point
               9699 ;
0437FE F1      9700 LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0437FF AF      9701 XOR     A			; Set the Z flag
043800 78      9702 LD      A,B			; A: The token
043801 C9      9703 RET
               9704 ;
               9705 ; DEL - DELETE A PROGRAM LINE.
               9706 ;   Inputs: HL addresses program line.
               9707 ; Destroys: B,C,F
               9708 ;
               9709 ; This simply erases the line by moving all of the code after the line to be deleted back over
               9710 ; it using an LDIR
               9711 ;
043802 D5      9712 DEL:			PUSH    DE
043803 E5      9713 PUSH    HL
043804 E5      9714 PUSH    HL			; HL: Address of the program line
043805 06      9715 LD      B,0			; BC: Length of the line
043806 00 
043807 4E      9716 LD      C,(HL)
043808 09      9717 ADD     HL,BC			; HL: Advanced to the start of the next line
043809 E5      9718 PUSH    HL
04380A EB      9719 EX      DE,HL			; DE: Pointer to the next line
04380B 2A      9720 LD      HL,(TOP)		; HL: Pointer to the end of the program
04380C 17 
04380D 4D 
04380E 04 
04380F ED      9721 SBC     HL,DE
043810 52 
043811 44      9722 LD      B,H			; BC: Size of block to move
043812 4D      9723 LD      C,L
043813 E1      9724 POP     HL			; HL: Pointer to next line
043814 D1      9725 POP     DE			; DE: Pointer to this line
043815 ED      9726 LDIR                    	; Delete the line
043816 B0 
043817 ED      9727 LD      (TOP),DE		; Adjust TOP
043818 53 
043819 17 
04381A 4D 
04381A 04   
04381C E1      9728 POP     HL
04381D D1      9729 POP     DE
04381E C9      9730 RET
               9731 ;
               9732 ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
               9733 ;   Inputs: Filename in ACCS (term CR)
               9734 ; Destroys: A,B,C,D,E,H,L,F
               9735 ;
               9736 ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
               9737 ; AND WRITE FF FF, THEN LOAD (TOP).
               9738 ; Destroys: A,B,C,H,L,F
               9739 ;
04381F ED      9740 LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
043820 5B 
043821 14 
043822 4D 
043822 04   
043824 21      9741 LD      HL,-256
043825 00 
043826 FF 
043827 FF 
043828 39      9742 ADD     HL,SP
043829 ED      9743 SBC     HL,DE           	; Find available space
04382A 52 
04382B 44      9744 LD      B,H
04382C 4D      9745 LD      C,L
04382D 21      9746 LD      HL,ACCS
04382E 00 
04382F 4A 
043830 04 
043831 CD      9747 CALL    OSLOAD          	; Call the OSLOAD function in patch
043832 94 
043833 41 
043834 04 
043835 D4      9748 CALL    NC,NEWIT		; If NC then NEW
043836 6C 
043837 38 
043838 04 
043839 3E      9749 LD      A,0
04383A 00 
04383B D2      9750 JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04383C 60 
04383D 37 
04383E 04 
               9751 ;
04383F CD      9752 CLEAN:			CALL    SETTOP			; Set TOP sysvar
043840 4B 
043841 38 
043842 04 
043843 2B      9753 DEC     HL			; Write out the end of program markers
043844 36      9754 LD      (HL),-1
043845 FF 
043846 2B      9755 DEC     HL
043847 36      9756 LD      (HL),-1
043848 FF 
043849 18      9757 JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
04384A 2B 
               9758 ;
               9759 ; Set the TOP sysvar; the first free location after the end of the current program
               9760 ; Returns:
               9761 ; - HL: TOP
               9762 ;
04384B 2A      9763 SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04384C 14 
04384D 4D 
04384E 04 
04384F 01      9764 LD	BC, 0			; BC: 0
043850 00 
043851 00 
043852 00 
043853 3E      9765 LD      A,CR			; End of line marker
043854 0D 
043855 4E      9766 SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
043856 0C      9767 INC     C			; Check for zero
043857 0D      9768 DEC     C
043858 28      9769 JR      Z,SETOP2		; If it is zero, we've reached the end
043859 0A 
04385A 09      9770 ADD     HL,BC			; Skip to next line
04385B 2B      9771 DEC     HL			; Check end of previous line
04385C BE      9772 CP      (HL)
04385D 23      9773 INC     HL
04385E 28      9774 JR      Z,SETOP1		; If CR then loop
04385F F5 
043860 C3      9775 JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043861 F8 
043862 36 
043863 04 
               9776 ;
043864 23      9777 SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
043865 23      9778 INC     HL			; NB: Called from NEWIT
043866 23      9779 INC     HL
043867 22      9780 LD      (TOP),HL		; Store in TOP sysvar
043868 17 
043869 4D 
04386A 04 
04386B C9      9781 RET
               9782 ;
               9783 ; NEWIT - NEW PROGRAM THEN CLEAR
               9784 ;   Destroys: H,L
               9785 ;
               9786 ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
               9787 ; FUNCTION AND PROCEDURE POINTERS.
               9788 ;   Destroys: Nothing
               9789 ;
04386C 2A      9790 NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
04386D 14 
04386E 4D 
04386F 04 
043870 36      9791 LD      (HL),0			; Stick a 0 in there
043871 00 
043872 CD      9792 CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
043873 64 
043874 38 
043875 04 
               9793 ;
043876 E5      9794 CLEAR:			PUSH    HL			; Stack the BASIC program pointer
043877 2A      9795 LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
043878 17 
043879 4D 
04387A 04 
04387B 22      9796 LD      (LOMEM),HL		; Set the LOMEM sysvar
04387C 1A 
04387D 4D 
04387E 04 
04387F 22      9797 LD      (FREE),HL		; And the FREE sysvar with that value
043880 1D 
043881 4D 
043882 04 
043883 21      9798 LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
043884 6C 
043885 4C 
043886 04 
043887 C5      9799 PUSH    BC
               9800 ; LD      B,3*(54+2)		; Loop counter
043888 06      9801 LD      B,54+2*3		; ez80asm doesn't do () in expressions
043889 A8 
04388A 36      9802 CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
04388B 00 
04388C 23      9803 INC     HL
04388D 10      9804 DJNZ    CLEAR1
04388E FB 
04388F C1      9805 POP     BC
043890 E1      9806 POP     HL			; Restore the BASIC program pointer
043891 C9      9807 RET
               9808 ;
               9809 ;LISTIT - LIST A PROGRAM LINE.
               9810 ;    Inputs: HL addresses line
               9811 ;            DE = line number (binary)
               9812 ;            IX = Pointer to LISTON
               9813 ;             B = FOR/NEXT indent level
               9814 ;             C = REPEAT/UNTIL indent level
               9815 ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
               9816 ;
043892 E5      9817 LISTIT:			PUSH    HL			; Stack the address of the line
043893 EB      9818 EX      DE,HL			; HL: Line number
043894 C5      9819 PUSH    BC
043895 CD      9820 CALL    PBCD			; Print the line number
043896 FB 
043897 39 
043898 04 
043899 C1      9821 POP     BC
04389A E1      9822 POP     HL			; HL: Address of the first token/character
04389B 7E      9823 LD      A,(HL)			; Fetch the token
04389C FE      9824 CP      NEXT			; Is it NEXT...
04389D ED 
04389E CC      9825 CALL    Z,INDENT		; Yes, so indent in
04389F 28 
0438A0 39 
0438A1 04 
0438A2 FE      9826 CP      UNTIL			; Or is it UNTIL...
0438A3 FD 
0438A4 CC      9827 CALL    Z,INDENT		; Yes, so indent in
0438A5 28 
0438A6 39 
0438A7 04 
0438A8 D9      9828 EXX
0438A9 3E      9829 LD      A,' '
0438AA 20 
0438AB DD      9830 BIT     0,(IX)			; If BIT 0 of LISTON is set
0438AC CB 
0438AD 00 
0438AE 46 
0438AF C4      9831 CALL    NZ,OUTCHR		; Then print a space after the line number
0438B0 4F 
0438B1 39 
0438B2 04 
0438B3 78      9832 LD      A,B			; Fetch the FOR/NEXT indent level
0438B4 87      9833 ADD     A,A			; Multiply by 2
0438B5 DD      9834 BIT     1,(IX)			; If BIT 1 of LISTON is set
0438B6 CB 
0438B7 00 
0438B8 4E 
0438B9 C4      9835 CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438BA EF 
0438BB 17 
0438BC 04 
0438BD 79      9836 LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438BE 87      9837 ADD     A,A			; Multiply by 2
0438BF DD      9838 BIT     2,(IX)			; If BIT 2 of LISTON is set
0438C0 CB 
0438C1 00 
0438C2 56 
0438C3 C4      9839 CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438C4 EF 
0438C5 17 
0438C6 04 
0438C7 D9      9840 EXX
0438C8 7E      9841 LD      A,(HL)			; Fetch the token
0438C9 FE      9842 CP      FOR			; Is it FOR?
0438CA E3 
0438CB CC      9843 CALL    Z,INDENT		; Yes, so indent
0438CC 28 
0438CD 39 
0438CE 04 
0438CF FE      9844 CP      REPEAT			; Is it REPEAT?
0438D0 F5 
0438D1 CC      9845 CALL    Z,INDENT		; Yes, so indent
0438D2 28 
0438D3 39 
0438D4 04 
0438D5 1E      9846 LD      E,0			; E: The quote counter - reset to 0
0438D6 00 
0438D7 7E      9847 LIST8:			LD      A,(HL)			; Fetch a character / token byte
0438D8 23      9848 INC     HL
0438D9 FE      9849 CP      CR			; Is it end of line?
0438DA 0D 
0438DB 28      9850 JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0438DC 0B 
0438DD FE      9851 CP      34			; Is it a quote character?
0438DE 22 
0438DF 20      9852 JR      NZ,LIST7		; No, so skip to next bit
0438E0 01 
0438E1 1C      9853 INC     E			; Otherwise increment quote counter
0438E2 CD      9854 LIST7:			CALL    LOUT			; Output the character / token
0438E3 17 
0438E4 39 
0438E5 04 
0438E6 18      9855 JR      LIST8			; And repeat
0438E7 EF 
               9856 ;
               9857 ; DB: Modification for *EDIT
               9858 ; Terminate the line with either a CRLF or a NUL character
               9859 ;
0438E8 DD      9860 LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0438E9 CB 
0438EA 00 
0438EB 5E 
0438EC 28      9861 JR	Z, CRLF			; Yes, so print a CRLF
0438ED 59 
0438EE AF      9862 XOR	A			; Otherwise print a NUL (0)
0438EF C3      9863 JP	OSWRCH
0438F0 00 
0438F1 3F 
0438F2 04 
               9864 ;
               9865 ; Decode the 3 byte GOTO type line number
               9866 ;
0438F3 E5      9867 PRLINO:			PUSH    HL			; Swap HL and IY
0438F4 FD      9868 POP     IY			; IY: Pointer to the line number
0438F5 E1 
0438F6 C5      9869 PUSH    BC
0438F7 CD      9870 CALL    DECODE			; Decode
0438F8 E6 
0438F9 08 
0438FA 04 
0438FB C1      9871 POP     BC
0438FC D9      9872 EXX
0438FD C5      9873 PUSH    BC
0438FE CD      9874 CALL    PBCDL			; Output the line number
0438FF F7 
043900 39 
043901 04 
043902 C1      9875 POP     BC
043903 D9      9876 EXX
043904 FD      9877 PUSH    IY			; Swap HL and IY
043905 E5 
043906 E1      9878 POP     HL			; HL: Pointer to the next character in the line
043907 C9      9879 RET
               9880 ;
               9881 ; DB: Modification for internationalisation
               9882 ;
043908 CD      9883 PRREM:			CALL	OUT_			; Output the REM token
043909 6C 
04390A 39 
04390B 04 
04390C 7E      9884 @@:			LD	A, (HL)			; Fetch the character
04390D FE      9885 CP	CR			; If it is end of line, then
04390E 0D 
04390F C8      9886 RET	Z			; we have finished
043910 CD      9887 CALL	OUTCHR			; Ouput the character
043911 4F 
043912 39 
043913 04 
043914 23      9888 INC	HL
043915 18      9889 JR	@B			; And loop
043916 F5 
               9890 ;
               9891 ; DB: End of modification
               9892 ;
043917 CB      9893 LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043918 43 
043919 20      9894 JR      NZ,OUTCHR		; don't tokenise, just output the character
04391A 34 
04391B FE      9895 CP	REM			; DB: Is it REM
04391C F4 
04391D 28      9896 JR	Z, PRREM		; DB: Yes so jump to the special case for REM
04391E E9 
04391F FE      9897 CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043920 8D 
043921 28      9898 JR      Z,PRLINO		; Yes, so decode and print the line number
043922 D0 
043923 CD      9899 CALL    OUT_			; Output a character / keyword
043924 6C 
043925 39 
043926 04 
043927 7E      9900 LD      A,(HL)			; Fetch the next character
               9901 ;
               9902 ; This block of code handles the indentation
               9903 ; B: Counter for FOR/NEXT indent
               9904 ; C: Counter for REPEAT/UNTIL indent
               9905 ;
043928 D9      9906 INDENT:			EXX
043929 FE      9907 CP      FOR			; If the token is FOR
04392A E3 
04392B 28      9908 JR      Z,IND1			; Then INC B
04392C 09 
04392D FE      9909 CP      NEXT			; If it is NEXT
04392E ED 
04392F 20      9910 JR      NZ,IND2_		; Then...
043930 06 
043931 05      9911 DEC     B			; DEC B
043932 F2      9912 JP      P,IND2_			; If we have gone below 0 then
043933 37 
043934 39 
043935 04 
043936 04      9913 IND1:			INC     B			; Increment back to 0
               9914 ;
043937 FE      9915 IND2_:			CP      REPEAT			; If the token is REPEAT
043938 F5 
043939 28      9916 JR      Z,IND3			; Then INC C
04393A 09 
04393B FE      9917 CP      UNTIL			; If it is UNTIL
04393C FD 
04393D 20      9918 JR      NZ,IND4			; Then...
04393E 06 
04393F 0D      9919 DEC     C			; DEC C
043940 F2      9920 JP      P,IND4			; If we have gone below 0 then
043941 45 
043942 39 
043943 04 
043944 0C      9921 IND3:			INC     C			; Incremet back to 0
043945 D9      9922 IND4:			EXX
043946 C9      9923 RET
               9924 ;
               9925 ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
               9926 ;  Destroys: A,F
               9927 ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
               9928 ;    Inputs: A = character
               9929 ;  Destroys: A,F
               9930 ;
043947 3E      9931 CRLF:			LD      A,CR			; Output CR
043948 0D 
043949 CD      9932 CALL    OUTCHR
04394A 4F 
04394B 39 
04394C 04 
04394D 3E      9933 LD      A,LF			; Output LF
04394E 0A 
               9934 ;
04394F CD      9935 OUTCHR:			CALL    OSWRCH			; Output the character in A
043950 00 
043951 3F 
043952 04 
043953 D6      9936 SUB     CR			; Check for CR
043954 0D 
043955 28      9937 JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
043956 06 
043957 D8      9938 RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043958 3A      9939 LD      A,(COUNT)		; Increment the count
043959 3D 
04395A 4D 
04395B 04 
04395C 3C      9940 INC     A
               9941 ;
04395D 32      9942 CARRET:			LD      (COUNT),A		; Store the new count value
04395E 3D 
04395F 4D 
043960 04 
043961 C8      9943 RET     Z			; Return if the count has wrapped to 0
043962 E5      9944 PUSH    HL			; Now check if count = print width
043963 2A      9945 LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
043964 3E 
043965 4D 
043966 04 
043967 BD      9946 CP      L			; L is the width. Compare it with count.
043968 E1      9947 POP     HL
043969 C0      9948 RET     NZ			; If we've not hit print width, then just return
04396A 18      9949 JR      CRLF			; Otherwise output CRLF
04396B DB 
               9950 ;
               9951 ; OUT - SEND CHARACTER OR KEYWORD
               9952 ;   Inputs: A = character (>=10, <128)
               9953 ;           A = Token (<10, >=128)
               9954 ;  Destroys: A,F
               9955 ;
04396C FE      9956 OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04396D 8A 
04396E EA      9957 JP      PE,OUTCHR		; If so, then it's a character, so just output it
04396F 4F 
043970 39 
043971 04 
               9958 ;
               9959 ; This bit looks up the character in the KEYWDS token table and expands it
               9960 ; Note the CP 138; this sets the overflow flag as follows:
               9961 ;
               9962 ; NB:
               9963 ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
               9964 ;  2. CP is effectively a SUB; sets the flags without affecting A
               9965 ;  3. The operation n - -118 ~ n + 118
               9966 ;
               9967 ; So:
               9968 ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
               9969 ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
               9970 ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
               9971 ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
               9972 ;
043972 C5      9973 PUSH    BC			; Preserve BC and HL
043973 E5      9974 PUSH    HL
043974 21      9975 LD      HL,KEYWDS		; The list of tokens and keywords
043975 68 
043976 31 
043977 04 
043978 01      9976 LD      BC,KEYWDL		; The length of the keyword list
043979 DF 
04397A 02 
04397B 00 
04397C ED      9977 CPIR				; We can just do a straight CPIR as the token characters are unique in the list
04397D B1 
               9978 ;							; At this point HL points to the next byte, the first character of the token
04397E 7E      9979 TOKEN1:			LD      A,(HL)			; Fetch the character
04397F 23      9980 INC     HL			; Increment to the next byte in the token table
043980 FE      9981 CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
043981 8A 
043982 F5      9982 PUSH    AF			; Then...
043983 EC      9983 CALL    PE,OUTCHR		; Output the character...
043984 4F 
043985 39 
043986 04 
043987 F1      9984 POP     AF			;
043988 EA      9985 JP      PE,TOKEN1		; And loop to the next character
043989 7E 
04398A 39 
04398B 04 
04398C E1      9986 POP     HL			; Done, so tidy up the stack and exit
04398D C1      9987 POP     BC
04398E C9      9988 RET
               9989 ;
               9990 ; FINDL - FIND PROGRAM LINE
               9991 ;   Inputs: HL = line number (binary)
               9992 ;  Outputs: HL addresses line (if found)
               9993 ;           DE = line number
               9994 ;           Z-flag set if found.
               9995 ; Destroys: A,B,C,D,E,H,L,F
               9996 ;
04398F EB      9997 FINDL:			EX      DE,HL			; DE: Line number (binary)
043990 2A      9998 LD      HL,(PAGE_)		; HL: Top of BASIC program area
043991 14 
043992 4D 
043993 04 
043994 AF      9999 XOR     A               	;  A: 0
043995 BE     10000 CP      (HL)			; Check for end of program marker
043996 3C     10001 INC     A			;  A: 1
043997 D0     10002 RET     NC			; Return with 1 if 0
043998 AF     10003 XOR     A               	; Clear the carry flag
              10004 ;			LD      B,A			;  B: 0
043999 01     10005 LD	BC, 0			; BC: 0
04399A 00 
04399B 00 
04399C 00 
              10006 ;
04399D 4E     10007 FINDL1:			LD      C,(HL)			;  C: The line length
04399E E5     10008 PUSH    HL			; Stack the current program counter
04399F 23     10009 INC     HL			; Skip to the line number bytes
0439A0 7E     10010 LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439A1 23     10011 INC     HL
0439A2 66     10012 LD      H,(HL)
0439A3 6F     10013 LD      L,A
0439A4 52     10014 SBC.S   HL,DE			; Compare with the line number we're searching for
0439A5 ED 
0439A6 52 
0439A7 E1     10015 POP     HL			; Get the current program counter
0439A8 D0     10016 RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439A9 09     10017 ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439AA C3     10018 JP      FINDL1			; And loop
0439AB 9D 
0439AC 39 
0439AD 04 
              10019 ;
              10020 ; SETLIN - Search program for line containing address
              10021 ;          Update (LINENO)
              10022 ;   Inputs: Address in (ERRLIN)
              10023 ;  Outputs: Line number in HL and (LINENO)
              10024 ; Destroys: B,C,D,E,H,L,F
              10025 ;
0439AE 01     10026 SETLIN:			LD	BC, 0			; Zero BC for later
0439AF 00 
0439B0 00 
0439B1 00 
              10027 ;			LD      B, 0			; Zero B for later
0439B2 ED     10028 LD      DE, (ERRLIN)		; DE: Address of line
0439B3 5B 
0439B4 35 
0439B5 4D 
0439B5 04   
0439B7 2A     10029 LD      HL, (PAGE_)		; HL: Start of user program area
0439B8 14 
0439B9 4D 
0439BA 04 
0439BB B7     10030 OR      A			; Do a 24 bit compare without destroying HL
0439BC ED     10031 SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439BD 52 
0439BE 19     10032 ADD     HL, DE			;  C: DE > HL
0439BF 30     10033 JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439C0 1B 
              10034 ;
0439C1 4E     10035 SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439C2 0C     10036 INC     C			; This is a way to check for zero without using the accumulator
0439C3 0D     10037 DEC     C			; If it is zero, then...
0439C4 28     10038 JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439C5 16 
0439C6 09     10039 ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439C7 ED     10040 SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0439C8 52 
0439C9 19     10041 ADD     HL, DE
0439CA 38     10042 JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0439CB F5 
0439CC ED     10043 SBC     HL, BC			; We've found it, so back up to the beginning of the line
0439CD 42 
0439CE 23     10044 INC     HL			; Skip the length counter
0439CF 11     10045 LD	DE, 0			; Zero DE
0439D0 00 
0439D1 00 
0439D2 00 
0439D3 5E     10046 LD      E, (HL)          	; Fetch the line number
0439D4 23     10047 INC     HL
0439D5 56     10048 LD      D, (HL)
0439D6 EB     10049 EX      DE, HL			; HL: The line number
0439D7 22     10050 SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0439D8 23 
0439D9 4D 
0439DA 04 
0439DB C9     10051 RET
              10052 ;
0439DC 21     10053 SET3:			LD      HL, 0			; We've not found the line at this point so
0439DD 00 
0439DE 00 
0439DF 00 
0439E0 18     10054 JR      SET2			; Set LINENO to 0
0439E1 F5 
              10055 ;
              10056 ;SAYLN - PRINT " at line nnnn" MESSAGE.
              10057 ;  Outputs: Carry=0 if line number is zero.
              10058 ;           Carry=1 if line number is non-zero.
              10059 ; Destroys: A,B,C,D,E,H,L,F
              10060 ;
0439E2 2A     10061 SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0439E3 23 
0439E4 4D 
0439E5 04 
0439E6 7C     10062 LD      A,H			; If it is zero then
0439E7 B5     10063 OR      L
0439E8 C8     10064 RET     Z			; Don't need to do anything; return with F:C set to 0
0439E9 CD     10065 CALL    TELL			; Output the error message
0439EA 90 
0439EB 3D 
0439EC 04 
0439ED 20     10066 DB    	" at line ", 0
0439EE 61 
0439EF 74 
0439F0 20 
0439F0 6C   
0439F1 69 
0439F2 6E 
0439F3 65 
0439F3 20   
0439F4 00 
0439F7 0E     10067 PBCDL:			LD      C,0			; C: Leading character (NUL)
0439F8 00 
0439F9 18     10068 JR      PBCD0			; Output the line number; return with F:C set to 1
0439FA 02 
              10069 ;
              10070 ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
              10071 ;   Inputs: HL = number (binary).
              10072 ;  Outputs: Carry = 1
              10073 ; Destroys: A,B,C,D,E,H,L,F
              10074 ;
0439FB 0E     10075 PBCD:			LD      C,' '			; C: Leading character (" ")
0439FC 20 
0439FD 06     10076 PBCD0:			LD      B,5			; Number of digits in result
0439FE 05 
0439FF 11     10077 LD      DE,10000		; Start off with the 10,000 column
043A00 10 
043A01 27 
043A02 00 
043A03 AF     10078 PBCD1:			XOR     A			; Counter
043A04 ED     10079 PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A05 52 
043A06 3C     10080 INC     A
043A07 30     10081 JR      NC,PBCD2
043A08 FB 
043A09 19     10082 ADD     HL,DE			; The loop overruns by one, so adjust here
043A0A 3D     10083 DEC     A			; A: Number of 10,000s
043A0B 28     10084 JR      Z,PBCD3			; If it is 0, then skip the next bit
043A0C 04 
043A0D CB     10085 SET     4,C			; C: Set to '0' ASCII (30h)
043A0E E1 
043A0F CB     10086 SET     5,C
043A10 E9 
043A11 B1     10087 PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A12 C4     10088 CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A13 4F 
043A14 39 
043A15 04 
043A16 78     10089 LD      A,B			; If on first transition, skip this
043A17 FE     10090 CP      5			; TODO: Need to find out why
043A18 05 
043A19 28     10091 JR      Z,PBCD4
043A1A 06 
043A1B 29     10092 ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A1C 54     10093 LD      D,H			;         : rather than shifting DE right
043A1D 5D     10094 LD      E,L			;         : This makes a lot of sense
043A1E 29     10095 ADD     HL,HL			; HL x  4
043A1F 29     10096 ADD     HL,HL			; HL x  8
043A20 19     10097 ADD     HL,DE			; HL x 10
043A21 11     10098 PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A22 E8 
043A23 03 
043A24 00 
043A25 10     10099 DJNZ    PBCD1			; Loop until done
043A26 DC 
043A27 37     10100 SCF				; SCF set for SAYLN in this module
043A28 C9     10101 RET
              10102 ;
              10103 ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
              10104 ;   Inputs: HL, IY as returned from GETVAR (NZ).
              10105 ;  Outputs: As GETVAR.
              10106 ; Destroys: everything
              10107 ;
043A29 CD     10108 PUTVAR:			CALL    CREATE			; Create the variable
043A2A AE 
043A2B 3B 
043A2C 04 
043A2D FD     10109 LD      A,(IY)			; Fetch the next character
043A2E 7E 
043A2F 00 
043A30 FE     10110 CP      '('			; Check for bad use of array
043A31 28 
043A32 20     10111 JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A33 70 
043A34 3E     10112 ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A35 0E 
043A36 C3     10113 ERROR3:			JP      ERROR_
043A37 60 
043A38 37 
043A39 04 
              10114 ;
              10115 ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
              10116 ;   Inputs: IY addresses first character.
              10117 ;  Outputs: Carry set and NZ if illegal character.
              10118 ;           Z-flag set if variable found, then:
              10119 ;            A = variable type (0,4,5,128 or 129)
              10120 ;            HL = IX = variable pointer.
              10121 ;            IY updated
              10122 ;           If Z-flag & carry reset, then:
              10123 ;            HL, IY set for subsequent PUTVAR call.
              10124 ; Destroys: everything
              10125 ;
043A3A FD     10126 GETVAR:			LD      A,(IY)			; Get the first character
043A3B 7E 
043A3C 00 
043A3D FE     10127 CP      '$'			; Is it a string?
043A3E 24 
043A3F 28     10128 JR      Z,GETV4			; Yes, so branch here
043A40 69 
043A41 FE     10129 CP      '!'			; Is it indirection (32-bit)?
043A42 21 
043A43 28     10130 JR      Z,GETV5			; Yes, so branch here
043A44 69 
043A45 FE     10131 CP      '?'			; Is it indirection (8-bit)?
043A46 3F 
043A47 28     10132 JR      Z,GETV6			; Yes, so branch here
043A48 69 
              10133 ;
043A49 CD     10134 CALL    LOCATE			; Locate the variable
043A4A 18 
043A4B 3B 
043A4C 04 
043A4D C0     10135 RET     NZ			; And exit here if not found
              10136 ;
              10137 ; At this point:
              10138 ;  HL: Address of variable in memory
              10139 ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
              10140 ;
043A4E FD     10141 LD      A,(IY)			; Further checks
043A4F 7E 
043A50 00 
043A51 FE     10142 CP      '('             	; Is it an array?
043A52 28 
043A53 20     10143 JR      NZ,GETVX        	; No, so exit
043A54 47 
              10144 ;
              10145 ; We are processing an array at this point
              10146 ;
043A55 D5     10147 PUSH    DE              	; Save the variable type (in D)
043A56 7E     10148 LD      A,(HL)          	; Fetch the number of dimensions
043A57 B7     10149 OR      A
043A58 28     10150 JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A59 DA 
043A5A 23     10151 INC     HL			;
043A5B 11     10152 LD      DE,0            	; Accumulator
043A5C 00 
043A5D 00 
043A5E 00 
043A5F F5     10153 PUSH    AF
043A60 FD     10154 INC     IY              	; Skip "("
043A61 23 
043A62 18     10155 JR      GETV3
043A63 05 
              10156 ;
043A64 F5     10157 GETV2:			PUSH    AF
043A65 CD     10158 CALL    COMMA
043A66 22 
043A67 0A 
043A68 04 
043A69 E5     10159 GETV3:			PUSH    HL
043A6A D5     10160 PUSH    DE
043A6B CD     10161 CALL    EXPRI			; Get the subscript
043A6C 0A 
043A6D 03 
043A6E 04 
043A6F D9     10162 EXX
043A70 D1     10163 POP     DE
043A71 E3     10164 EX      (SP),HL
043A72 4E     10165 LD      C,(HL)
043A73 23     10166 INC     HL
043A74 46     10167 LD      B,(HL)
043A75 23     10168 INC     HL
043A76 E3     10169 EX      (SP),HL
043A77 EB     10170 EX      DE,HL
043A78 D5     10171 PUSH    DE
043A79 CD     10172 CALL    MUL16			; HL=HL*BC
043A7A 72 
043A7B 18 
043A7C 04 
043A7D D1     10173 POP     DE
043A7E 19     10174 ADD     HL,DE
043A7F EB     10175 EX      DE,HL
043A80 B7     10176 OR      A
043A81 ED     10177 SBC     HL,BC
043A82 42 
043A83 3E     10178 LD      A,15
043A84 0F 
043A85 30     10179 JR      NC,ERROR3		; Throw a "Subscript" error
043A86 AF 
043A87 E1     10180 POP     HL
043A88 F1     10181 POP     AF
043A89 3D     10182 DEC     A               	; Dimension counter
043A8A 20     10183 JR      NZ,GETV2
043A8B D8 
043A8C CD     10184 CALL    BRAKET          	; Check for closing bracket
043A8D 2F 
043A8E 0A 
043A8F 04 
043A90 F1     10185 POP     AF              	; Restore the type
043A91 E5     10186 PUSH    HL
043A92 CD     10187 CALL    X4OR5           	; DE=DE*n
043A93 65 
043A94 18 
043A95 04 
043A96 E1     10188 POP     HL
043A97 19     10189 ADD     HL,DE
043A98 57     10190 LD      D,A             	; The type
043A99 FD     10191 LD      A,(IY)
043A9A 7E 
043A9B 00 
043A9C FE     10192 GETVX:			CP      '?'
043A9D 3F 
043A9E 28     10193 JR      Z,GETV9
043A9F 1E 
043AA0 FE     10194 CP      '!'
043AA1 21 
043AA2 28     10195 JR      Z,GETV8
043AA3 16 
043AA4 E5     10196 GETVZ:			PUSH    HL              	; Set exit conditions
043AA5 DD     10197 POP     IX
043AA6 E1 
043AA7 7A     10198 LD      A,D
043AA8 BF     10199 CP      A
043AA9 C9     10200 RET
              10201 ;
              10202 ; Process strings, unary & binary indirection:
              10203 ;
043AAA 3E     10204 GETV4:			LD      A,128           	; Static strings
043AAB 80 
043AAC 18     10205 JR      GETV7
043AAD 05 
              10206 ;
043AAE 3E     10207 GETV5:			LD      A,4             	; Unary 32-bit indirection
043AAF 04 
043AB0 18     10208 JR      GETV7
043AB1 01 
              10209 ;
043AB2 AF     10210 GETV6:			XOR     A               	; Unary 8-bit indirection
              10211 ;
043AB3 21     10212 GETV7:			LD      HL,0
043AB4 00 
043AB5 00 
043AB6 00 
043AB7 F5     10213 PUSH    AF
043AB8 18     10214 JR      GETV0
043AB9 24 
              10215 ;
043ABA 06     10216 GETV8:			LD      B,4             	; Binary 32-bt indirection
043ABB 04 
043ABC 18     10217 JR      GETVA
043ABD 02 
              10218 ;
043ABE 06     10219 GETV9:			LD      B,0             	; Binary 8-bit indirection
043ABF 00 
              10220 ;
043AC0 E5     10221 GETVA:			PUSH    HL
043AC1 DD     10222 POP     IX
043AC2 E1 
043AC3 7A     10223 LD      A,D            		; Fetch the variable type
043AC4 FE     10224 CP      129			; Is it a string?
043AC5 81 
043AC6 C8     10225 RET     Z               	; Yes, so exit here
043AC7 C5     10226 PUSH    BC
043AC8 CD     10227 CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043AC9 16 
043ACA 04 
043ACB 04 
043ACC CD     10228 CALL    SFIX
043ACD 62 
043ACE 06 
043ACF 04 
043AD0 7D     10229 LD	A,L
043AD1 D9     10230 EXX
043AD2 22     10231 LD	(R0+0),HL
043AD3 4A 
043AD4 4D 
043AD5 04 
043AD6 32     10232 LD	(R0+2),A
043AD7 4C 
043AD8 4D 
043AD9 04 
043ADA 2A     10233 LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043ADB 4A 
043ADC 4D 
043ADD 04 
              10234 ;
043ADE E5     10235 GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043ADF FD     10236 INC     IY
043AE0 23 
043AE1 CD     10237 CALL    ITEMI
043AE2 25 
043AE3 03 
043AE4 04 
043AE5 7D     10238 LD	A,L			;  A: The MSB of the address
043AE6 D9     10239 EXX
043AE7 22     10240 LD	(R0+0),HL		; HL: The LSW of the address
043AE8 4A 
043AE9 4D 
043AEA 04 
043AEB 32     10241 LD	(R0+2),A		; R0: L'HL or the 24-bit address
043AEC 4C 
043AED 4D 
043AEE 04 
043AEF D1     10242 POP     DE
043AF0 F1     10243 POP     AF
043AF1 2A     10244 LD	HL,(R0)			; HL: L'HL
043AF2 4A 
043AF3 4D 
043AF4 04 
043AF5 19     10245 ADD     HL,DE
043AF6 E5     10246 PUSH    HL
043AF7 DD     10247 POP     IX
043AF8 E1 
043AF9 BF     10248 CP      A
043AFA C9     10249 RET
              10250 ;
              10251 ;GETDEF - Find entry for FN or PROC in dynamic area.
              10252 ;   Inputs: IY addresses byte following "DEF" token.
              10253 ;  Outputs: Z flag set if found
              10254 ;           Carry set if neither FN or PROC first.
              10255 ;           If Z: HL points to entry
              10256 ;                 IY addresses delimiter
              10257 ; Destroys: A,D,E,H,L,IY,F
              10258 ;
043AFB FD     10259 GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043AFC 7E 
043AFD 01 
043AFE CD     10260 CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043AFF 7B 
043B00 3C 
043B01 04 
043B02 D8     10261 RET     C			; No so return with C set
043B03 FD     10262 LD      A,(IY)			; Fetch the current character from the tokenised line
043B04 7E 
043B05 00 
043B06 21     10263 LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B07 0E 
043B08 4D 
043B09 04 
043B0A FE     10264 CP      FN			; Is it the token FN?
043B0B A4 
043B0C 28     10265 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B0D 4A 
043B0E 21     10266 LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B0F 11 
043B10 4D 
043B11 04 
043B12 FE     10267 CP      PROC			; Is it the token PROC?
043B13 F2 
043B14 28     10268 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B15 42 
043B16 37     10269 SCF				; No, so just return with C set
043B17 C9     10270 RET
              10271 ;
              10272 ; LOCATE - Try to locate variable name in static or dynamic variables.
              10273 ; If illegal first character return carry, non-zero.
              10274 ; If found, return no-carry, zero.
              10275 ; If not found, return no-carry, non-zero.
              10276 ;   Inputs: IY=Addresses first character of name.
              10277 ;            A=(IY)
              10278 ;  Outputs:  F=Z set if found, then:
              10279 ;           IY=addresses terminator
              10280 ;           HL=addresses location of variable
              10281 ;            D=type of variable: 4 = integer
              10282 ;                                5 = floating point
              10283 ;                              129 = string
              10284 ; Destroys: A,D,E,H,L,IY,F
              10285 ;
              10286 ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
              10287 ; They can contain any alphanumeric character and underscore (_)
              10288 ; String variables are postfixed with the dollar ($) character
              10289 ; Integer variables are postfixed with the percent (%) character
              10290 ; Static integer variables are named @%, A% to Z%
              10291 ; All other variables are dynamic
              10292 ;
043B18 D6     10293 LOCATE:			SUB     '@'			; Check for valid range
043B19 40 
043B1A D8     10294 RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B1B 21     10295 LD      HL, 0			; Clear HL
043B1C 00 
043B1D 00 
043B1E 00 
043B1F FE     10296 CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B20 1B 
043B21 30     10297 JR      NC,LOC0         	; Then branch here
043B22 1E 
043B23 6F     10298 LD	L, A			; HL = A
043B24 FD     10299 LD      A,(IY+1)        	; Check the 2nd character
043B25 7E 
043B26 01 
043B27 FE     10300 CP      '%'			; If not "%" then it is not static...
043B28 25 
043B29 20     10301 JR      NZ,LOC1         	; Branch here
043B2A 21 
043B2B FD     10302 LD      A,(IY+2)		; Check the 3rd character
043B2C 7E 
043B2D 02 
043B2E FE     10303 CP      '('			; If it is "(" (array) then it is not static...
043B2F 28 
043B30 28     10304 JR      Z,LOC1          	; Branch here
043B31 1A 
              10305 ;
              10306 ; At this point we're dealing with a static variable
              10307 ;
043B32 29     10308 ADD     HL,HL			; HL: Variable index * 4
043B33 29     10309 ADD	HL,HL
043B34 11     10310 LD      DE,STAVAR       	; The static variable area in memory
043B35 00 
043B36 4C 
043B37 04 
043B38 19     10311 ADD     HL,DE			; HL: The address of the static variable
043B39 FD     10312 INC     IY			; Skip the program pointer past the static variable name
043B3A 23 
043B3B FD     10313 INC     IY
043B3C 23 
043B3D 16     10314 LD      D,4             	; Set the type to be integer
043B3E 04 
043B3F AF     10315 XOR     A			; Set the Z flag
043B40 C9     10316 RET
              10317 ;
              10318 ; At this point it's potentially a dynamic variable, just need to do a few more checks
              10319 ;
043B41 FE     10320 LOC0:			CP      '_'-'@'			; Check the first character is in
043B42 1F 
043B43 D8     10321 RET     C			; the range "_" to
043B44 FE     10322 CP      'z'-'@'+1		; "z" (lowercase characters only)
043B45 3B 
043B46 3F     10323 CCF				; If it is not in range then
043B47 3D     10324 DEC     A               	; Set NZ flag and
043B48 D8     10325 RET     C			; Exit here
043B49 D6     10326 SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B4A 03 
043B4B 6F     10327 LD	L, A			; HL = A
              10328 ;
              10329 ; Yes, it's definitely a dynamic variable at this point...
              10330 ;
043B4C 7D     10331 LOC1:			LD	A, L			; Fetch variable index
043B4D 87     10332 ADD	A, A			; x 2
043B4E 85     10333 ADD	A, L			; x 3
043B4F D6     10334 SUB	3			; Subtract 2 TODO: Should be 3
043B50 03 
043B51 6F     10335 LD	L, A
043B52 11     10336 LD      DE, DYNVAR       	; The dynamic variable storage
043B53 6C 
043B54 4C 
043B55 04 
043B56 D8     10337 RET	C			; Bounds check to trap for variable '@'
043B57 19     10338 ADD     HL, DE			; HL: Address of first entry
              10339 ;
              10340 ; Loop through the linked list of variables to find a match
              10341 ;
043B58 ED     10342 LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B59 17 
043B5A E5     10343 PUSH	HL			; Need to preserve HL for LOC6
043B5B AF     10344 XOR	A			; Reset carry flag
043B5C ED     10345 SBC	HL, HL			; Set HL to 0
043B5D 62 
043B5E ED     10346 SBC	HL, DE			; Compare with 0
043B5F 52 
043B60 E1     10347 POP	HL			; Restore the original pointer
043B61 28     10348 JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B62 49 
              10349 ; LD	HL, DE			; Make a copy of this pointer in HL
043B63 D5     10350 push de
043B64 E1     10351 pop hl ; how was that even possible?
043B65 23     10352 INC     HL              	; Skip the link (24-bits)
043B66 23     10353 INC     HL
043B67 23     10354 INC	HL			; HL: Address of the variable name in DYNVARS
043B68 FD     10355 PUSH    IY			; IY: Address of the variable name in the program
043B69 E5 
              10356 ;
043B6A 7E     10357 LOC3:			LD      A,(HL)         		; Compare
043B6B 23     10358 INC     HL
043B6C FD     10359 INC     IY
043B6D 23 
043B6E FD     10360 CP      (IY)
043B6F BE 
043B70 00 
043B71 28     10361 JR      Z, LOC3			; Keep looping whilst we've got a match...
043B72 F7 
043B73 B7     10362 OR      A               	; Have we hit a terminator?
043B74 28     10363 JR      Z,LOC5          	; Yes, so maybe we've found a variable
043B75 07 
              10364 ;
043B76 FD     10365 LOC4:			POP     IY			; Restore the pointer in the program
043B77 E1 
043B78 EB     10366 EX      DE, HL			; HL: New pointer in DYNVARS
043B79 C3     10367 JP      LOC2            	; Loop round and try again
043B7A 58 
043B7B 3B 
043B7C 04 
              10368 ;
              10369 ; We might have located a variable at this point, just need to do a few more tests
              10370 ;
043B7D FD     10371 LOC5:			DEC     IY
043B7E 2B 
043B7F FD     10372 LD      A,(IY)
043B80 7E 
043B81 00 
043B82 FE     10373 CP      '('
043B83 28 
043B84 28     10374 JR      Z,LOC5A         	; FOUND
043B85 15 
043B86 FD     10375 INC     IY
043B87 23 
043B88 CD     10376 CALL    RANGE
043B89 6F 
043B8A 3C 
043B8B 04 
043B8C 38     10377 JR      C,LOC5A         	; FOUND
043B8D 0D 
043B8E FE     10378 CP      '('
043B8F 28 
043B90 28     10379 JR      Z,LOC4          	; KEEP LOOKING
043B91 E4 
043B92 FD     10380 LD      A,(IY-1)
043B93 7E 
043B94 FF 
043B95 CD     10381 CALL    RANGE1
043B96 7B 
043B97 3C 
043B98 04 
043B99 30     10382 JR      NC,LOC4         	; KEEP LOOKING
043B9A DB 
043B9B D1     10383 LOC5A:			POP     DE
043B9C FD     10384 TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043B9D 7E 
043B9E FF 
043B9F FE     10385 CP      '$'			; Is it a string?
043BA0 24 
043BA1 16     10386 LD      D,129			; Yes, so return D = 129
043BA2 81 
043BA3 C8     10387 RET     Z
043BA4 FE     10388 CP      '%'			; Is it an integer?
043BA5 25 
043BA6 16     10389 LD      D,4			; Yes, so return D = 4
043BA7 04 
043BA8 C8     10390 RET     Z
043BA9 14     10391 INC     D			; At this point it must be a float
043BAA BF     10392 CP      A			; Set the flags
043BAB C9     10393 RET
              10394 ;
              10395 ; The variable is undefined at this point; HL will be zero
              10396 ;
043BAC 3C     10397 LOC6:			INC     A               	; Set NZ flag
043BAD C9     10398 RET
              10399 ;
              10400 ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
              10401 ;   Inputs: HL, IY as returned from LOCATE (NZ).
              10402 ;  Outputs: As LOCATE, GETDEF.
              10403 ; Destroys: As LOCATE, GETDEF.
              10404 ;
043BAE AF     10405 CREATE:			XOR     A
043BAF ED     10406 LD      DE,(FREE)		; Get the last byte of available RAM
043BB0 5B 
043BB1 1D 
043BB2 4D 
043BB2 04   
043BB4 ED     10407 LD	(HL), DE		; Store
043BB5 1F 
043BB6 EB     10408 EX      DE,HL
043BB7 77     10409 LD      (HL),A			; Clear the link of the new entity
043BB8 23     10410 INC     HL
043BB9 77     10411 LD      (HL),A
043BBA 23     10412 INC     HL
043BBB 77     10413 LD      (HL),A
043BBC 23     10414 INC     HL
043BBD FD     10415 LOC7:			INC     IY
043BBE 23 
043BBF CD     10416 CALL    RANGE           	; END OF VARIABLE?
043BC0 6F 
043BC1 3C 
043BC2 04 
043BC3 38     10417 JR      C,LOC8
043BC4 15 
043BC5 77     10418 LD      (HL),A
043BC6 23     10419 INC     HL
043BC7 CD     10420 CALL    RANGE1
043BC8 7B 
043BC9 3C 
043BCA 04 
043BCB 30     10421 JR      NC,LOC7
043BCC F0 
043BCD FE     10422 CP      '('
043BCE 28 
043BCF 28     10423 JR      Z,LOC8
043BD0 09 
043BD1 FD     10424 LD      A,(IY+1)
043BD2 7E 
043BD3 01 
043BD4 FE     10425 CP      '('
043BD5 28 
043BD6 28     10426 JR      Z,LOC7
043BD7 E5 
043BD8 FD     10427 INC     IY
043BD9 23 
043BDA 36     10428 LOC8:			LD      (HL),0          	; TERMINATOR
043BDB 00 
043BDC 23     10429 INC     HL
043BDD E5     10430 PUSH    HL
043BDE CD     10431 CALL    TYPE_			; Get the variable type in D
043BDF 9C 
043BE0 3B 
043BE1 04 
043BE2 3E     10432 LD      A,4			; If it is an integer then it takes up 4 bytes
043BE3 04 
043BE4 BA     10433 CP      D
043BE5 28     10434 JR      Z,LOC9			; So skip the next bit
043BE6 01 
043BE7 3C     10435 INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043BE8 36     10436 LOC9:			LD      (HL),0          	; Initialise the memory to zero
043BE9 00 
043BEA 23     10437 INC     HL
043BEB 3D     10438 DEC     A
043BEC 20     10439 JR      NZ,LOC9
043BED FA 
043BEE 22     10440 LD      (FREE),HL		; Adjust the stack
043BEF 1D 
043BF0 4D 
043BF1 04 
043BF2 CD     10441 CALL    CHECK			; Check whether we are out of space
043BF3 4F 
043BF4 16 
043BF5 04 
043BF6 E1     10442 POP     HL
043BF7 AF     10443 XOR     A
043BF8 C9     10444 RET
              10445 ;
              10446 ; LINNUM - GET LINE NUMBER FROM TEXT STRING
              10447 ;   Inputs: IY = Text Pointer
              10448 ;  Outputs: HL = Line number (zero if none)
              10449 ;           IY updated
              10450 ; Destroys: A,D,E,H,L,IY,F
              10451 ;
              10452 ; This bit of code performs a BASE 10 shift to build up the number
              10453 ; So if the string passed is "345", the algorithm does this:
              10454 ;
              10455 ;    HL : Digit	: Operation
              10456 ; ----- : ----- : ---------
              10457 ; 00000 :	:
              10458 ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
              10459 ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
              10460 ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
              10461 ;
              10462 ; The multiply by 10 is done by an unrolled shift and add loop
              10463 ;
043BF9 CD     10464 LINNUM:			CALL    NXT			; Skip whitespace to the first character
043BFA 70 
043BFB 0A 
043BFC 04 
043BFD 40     10465 LD.SIS  HL,0			; The running total
043BFE 21 
043BFF 00 
043C00 00 
043C01 FD     10466 LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C02 7E 
043C03 00 
043C04 D6     10467 SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C05 30 
043C06 D8     10468 RET     C			; And return if less than 0
043C07 FE     10469 CP      10			; Or greater than or equal to 10
043C08 0A 
043C09 D0     10470 RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C0A FD     10471 INC     IY			; Increment the string pointer
043C0B 23 
043C0C 54     10472 LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C0D 5D     10473 LD      E,L			; Store the original number in DE
043C0E 52     10474 ADD.S   HL,HL           	; *2
043C0F 29 
043C10 38     10475 JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C11 13 
043C12 52     10476 ADD.S   HL,HL           	; *4S
043C13 29 
043C14 38     10477 JR      C,TOOBIG
043C15 0F 
043C16 52     10478 ADD.S   HL,DE           	; *5
043C17 19 
043C18 38     10479 JR      C,TOOBIG
043C19 0B 
043C1A 52     10480 ADD.S   HL,HL           	; *10
043C1B 29 
043C1C 38     10481 JR      C,TOOBIG
043C1D 07 
043C1E 5F     10482 LD      E,A			; A->DE: the digit to add in
043C1F 16     10483 LD      D,0
043C20 00 
043C21 52     10484 ADD.S   HL,DE           	; Add in the digit to the running total
043C22 19 
043C23 30     10485 JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C24 DC 
              10486 ;
043C25 3E     10487 TOOBIG:			LD      A,20
043C26 14 
043C27 C3     10488 JP      ERROR_           	; Error: "Too big"
043C28 60 
043C29 37 
043C2A 04 
              10489 ;
              10490 ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
              10491 ;   Inputs: IY = text pointer
              10492 ;  Outputs: HL = first number (10 by default)
              10493 ;           BC = second number (10 by default)
              10494 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
              10495 ;
043C2B CD     10496 PAIR:			CALL    LINNUM          	; Parse the first line number
043C2C F9 
043C2D 3B 
043C2E 04 
043C2F 7C     10497 LD      A,H			; If it is not zero, then...
043C30 B5     10498 OR      L
043C31 20     10499 JR      NZ,PAIR1		; Skip...
043C32 02 
043C33 2E     10500 LD      L,10			; HL: the default value (10)
043C34 0A 
              10501 ;
043C35 CD     10502 PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C36 7A 
043C37 17 
043C38 04 
043C39 FD     10503 INC     IY			; Skip to next character
043C3A 23 
043C3B E5     10504 PUSH    HL			; Stack the first line number
043C3C 21     10505 LD      HL,10			; HL: the second default (10)
043C3D 0A 
043C3E 00 
043C3F 00 
043C40 C4     10506 CALL    NZ,LINNUM       	; Parse the second line number
043C41 F9 
043C42 3B 
043C43 04 
043C44 E3     10507 EX      (SP),HL			; HL: The first line number (off the stack)
043C45 C1     10508 POP     BC			; BC: Second line number
043C46 78     10509 LD      A,B			; If the second line number is not zero then...
043C47 B1     10510 OR      C			; We're good...
043C48 C0     10511 RET     NZ			; Exit, otherwise...
043C49 CD     10512 CALL    EXTERR			; Throw error: "Silly"
043C4A 77 
043C4B 37 
043C4C 04 
043C4D 53     10513 DB    	"Silly", 0
043C4E 69 
043C4F 6C 
043C50 6C 
043C50 79   
043C51 00 
              10514 ;
              10515 ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
              10516 ;   Inputs: IY = text pointer
              10517 ;  Outputs: HL = points to program text
              10518 ;           BC = second number (0 by default)
              10519 ; Destroys: A,B,C,D,E,H,L,IY,F
              10520 ;
043C53 CD     10521 DLPAIR:			CALL    LINNUM			; Parse the first line number
043C54 F9 
043C55 3B 
043C56 04 
043C57 E5     10522 PUSH    HL			; Stack it
043C58 CD     10523 CALL    TERMQ			; Check for ELSE, : or CR
043C59 7A 
043C5A 17 
043C5B 04 
043C5C 28     10524 JR      Z,DLP1			; And exit if so
043C5D 0A 
043C5E FE     10525 CP      TIF			; Is the token IF?
043C5F E7 
043C60 28     10526 JR      Z,DLP1			; Yes, so skip the next bit...
043C61 06 
043C62 FD     10527 INC     IY			; Otherwise...
043C63 23 
043C64 CD     10528 CALL    LINNUM			; Fetch the second line number
043C65 F9 
043C66 3B 
043C67 04 
043C68 E3     10529 DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043C69 CD     10530 CALL    FINDL			; HL: Find the address of the line
043C6A 8F 
043C6B 39 
043C6C 04 
043C6D C1     10531 POP     BC			; BC: The second number
043C6E C9     10532 RET
              10533 ;
              10534 ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
              10535 ;   Inputs: IY addresses character
              10536 ;  Outputs: Carry set if out-of-range.
              10537 ; Destroys: A,F
              10538 ;
              10539 ; It is called here to check the following
              10540 ; In range: "$", "%" and "("
              10541 ;   Plus all characters in RANGE1 and RANGE2
              10542 ;
043C6F FD     10543 RANGE:			LD      A,(IY)			; Fetch the character
043C70 7E 
043C71 00 
043C72 FE     10544 CP      '$'			; Postfix for string variable is valid
043C73 24 
043C74 C8     10545 RET     Z
043C75 FE     10546 CP      '%'			; Postfix for integer variable is valid
043C76 25 
043C77 C8     10547 RET     Z
043C78 FE     10548 CP      '('			; Postfix for array is valid
043C79 28 
043C7A C8     10549 RET     Z
              10550 ;
              10551 ; It is called here to check the following
              10552 ; In range: "0" to "9" and "@"
              10553 ;   Plus all characters in RANGE2
              10554 ;
043C7B FE     10555 RANGE1:			CP      '0'			; If it is between '0'...
043C7C 30 
043C7D D8     10556 RET     C
043C7E FE     10557 CP      '9'+1			; And '9'...
043C7F 3A 
043C80 3F     10558 CCF
043C81 D0     10559 RET     NC			; Then it is valid
043C82 FE     10560 CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043C83 40 
043C84 C8     10561 RET     Z
              10562 ;
              10563 ; It is called here to check the following
              10564 ; In range: "A" to "Z", "a' to "z", "_" and "`"
              10565 ;
043C85 FE     10566 RANGE2:			CP      'A'			; If it is between 'A'...
043C86 41 
043C87 D8     10567 RET     C
043C88 FE     10568 CP      'Z'+1			; And 'Z'...
043C89 5B 
043C8A 3F     10569 CCF
043C8B D0     10570 RET     NC			; Then it is valid
043C8C FE     10571 CP      '_'			; If it is underscore, grave, or between 'a'
043C8D 5F 
043C8E D8     10572 RET     C
043C8F FE     10573 CP      'z'+1			; And 'z'
043C90 7B 
043C91 3F     10574 CCF				; Then it is valid
043C92 C9     10575 RET
              10576 ;
              10577 ; Throw a 'LINE space' error (line too long)
              10578 ; This is called from LEXAN
              10579 ;
043C93 AF     10580 SPACE_: 		XOR     A
043C94 CD     10581 CALL    EXTERR          	; "LINE space"
043C95 77 
043C96 37 
043C97 04 
043C98 86     10582 DB    	LINE_MN_, 8, 0
043C99 08 
043C9A 00 
              10583 ;
              10584 ; LEXAN - LEXICAL ANALYSIS.
              10585 ;  Bit 0,C: 1=left, 0=right
              10586 ;  Bit 2,C: 1=in BINARY
              10587 ;  Bit 3,C: 1=in HEX
              10588 ;  Bit 4,C: 1=accept line number
              10589 ;  Bit 5,C: 1=in variable, FN, PROC
              10590 ;  Bit 6,C: 1=in REM, DATA, *
              10591 ;  Bit 7,C: 1=in quotes
              10592 ;   Inputs: IY addresses source string
              10593 ;           DE addresses destination string (must be page boundary)
              10594 ;            C sets initial mode
              10595 ;  Outputs: DE, IY updated
              10596 ;            A holds carriage return
              10597 ;
043C9B 12     10598 LEXAN1:			LD      (DE),A          	; Transfer to buffer
043C9C 13     10599 INC     DE              	; Increment the pointers
043C9D FD     10600 INC     IY			; And fall through to the main function
043C9E 23 
              10601 ;
              10602 ; This is the main entry point
              10603 ;
043C9F 7B     10604 LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CA0 FE     10605 CP      252             	; If it is >= 252 bytes, then...
043CA1 FC 
043CA2 30     10606 JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CA3 EF 
043CA4 FD     10607 LD      A,(IY)			; Fetch character from source string
043CA5 7E 
043CA6 00 
043CA7 FE     10608 CP      CR			; If it is a CR
043CA8 0D 
043CA9 C8     10609 RET     Z               	; Then it is end of line; we're done parsing
043CAA CD     10610 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CAB 7B 
043CAC 3C 
043CAD 04 
043CAE 30     10611 JR      NC,LEXAN3		; Yes, so skip
043CAF 06 
043CB0 CB     10612 RES     5,C             	; FLAG: NOT IN VARIABLE
043CB1 A9 
043CB2 CB     10613 RES     3,C             	; FLAG: NOT IN HEX
043CB3 99 
043CB4 CB     10614 RES	2,C			; FLAG: NOT IN BINARY
043CB5 91 
              10615 ;
043CB6 FE     10616 LEXAN3:			CP      ' '			; Ignore spaces
043CB7 20 
043CB8 28     10617 JR      Z,LEXAN1
043CB9 E1 
043CBA FE     10618 CP      ','			; Ignore commas
043CBB 2C 
043CBC 28     10619 JR      Z,LEXAN1
043CBD DD 
043CBE FE     10620 CP	'2'			; If less than '2'
043CBF 32 
043CC0 30     10621 JR	NC, @F			; No, so skip
043CC1 02 
043CC2 CB     10622 RES	2,C			; FLAG: NOT IN BINARY
043CC3 91 
043CC4 FE     10623 @@:			CP      'G'			; If less then 'G'
043CC5 47 
043CC6 38     10624 JR      C,LEXAN4		; Yes, so skip
043CC7 02 
043CC8 CB     10625 RES     3,C             	; FLAG: NOT IN HEX
043CC9 99 
              10626 ;
043CCA FE     10627 LEXAN4:			CP      34			; Is it a quote character?
043CCB 22 
043CCC 20     10628 JR      NZ,LEXAN5		; No, so skip
043CCD 05 
043CCE CB     10629 RL      C			; Toggle bit 7 of C by shifting it into carry flag
043CCF 11 
043CD0 3F     10630 CCF                     	; Toggle the carry
043CD1 CB     10631 RR      C			; And then shifting it back into bit 7 of C
043CD2 19 
              10632 ;
043CD3 CB     10633 LEXAN5:			BIT     4,C			; Accept line number?
043CD4 61 
043CD5 28     10634 JR      Z,LEXAN6		; No, so skip
043CD6 12 
043CD7 CB     10635 RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043CD8 A1 
043CD9 C5     10636 PUSH    BC
043CDA D5     10637 PUSH    DE
043CDB CD     10638 CALL    LINNUM         		; Parse the line number to HL
043CDC F9 
043CDD 3B 
043CDE 04 
043CDF D1     10639 POP     DE
043CE0 C1     10640 POP     BC
043CE1 7C     10641 LD      A,H			; If it is not zero
043CE2 B5     10642 OR      L
043CE3 C4     10643 CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043CE4 5C 
043CE5 3D 
043CE6 04 
043CE7 18     10644 JR      LEXAN2          	; And loop
043CE8 B6 
              10645 ;
043CE9 0D     10646 LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043CEA 28     10647 JR      Z,LEXAN7        	; If so, skip
043CEB 0A 
043CEC 0C     10648 INC     C			; Otherwise restore C
043CED 20     10649 JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043CEE AC 
043CEF B7     10650 OR      A			; Set the flags based on the character
043CF0 F4     10651 CALL    P,LEX           	; Tokenise if A < 128
043CF1 C7 
043CF2 37 
043CF3 04 
043CF4 18     10652 JR      LEXAN8			; And skip
043CF5 13 
              10653 ;
              10654 ; Processing the LEFT hand side here
              10655 ;
043CF6 FE     10656 LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043CF7 2A 
043CF8 28     10657 JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043CF9 17 
043CFA B7     10658 OR      A			; Set the flags based on the character
043CFB F4     10659 CALL    P,LEX           	; Tokenise if A < 128
043CFC C7 
043CFD 37 
043CFE 04 
              10660 ;
              10661 ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
              10662 ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
              10663 ; Examples:
              10664 ;   LET A% = PAGE : REM This is the GET version
              10665 ;   PAGE = 40000  : REM This is the SET version
              10666 ;
043CFF FE     10667 CP      TOKLO			; TOKLO is 8Fh
043D00 8F 
043D01 38     10668 JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D02 06 
043D03 FE     10669 CP      TOKHI+1			; TOKHI is 93h
043D04 94 
043D05 30     10670 JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D06 02 
043D07 C6     10671 ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D08 40 
              10672 ;
043D09 FE     10673 LEXAN8:			CP      REM			; If the token is REM
043D0A F4 
043D0B 28     10674 JR      Z,LEXAN9		; Then stop tokenising
043D0C 04 
043D0D FE     10675 CP      DATA_MN_			; If it is not DATA then
043D0E DC 
043D0F 20     10676 JR      NZ,LEXANA		; Skip
043D10 02 
043D11 CB     10677 LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D12 F1 
              10678 ;
043D13 FE     10679 LEXANA:			CP      FN			; If the token is FN
043D14 A4 
043D15 28     10680 JR      Z,LEXANB
043D16 0A 
043D17 FE     10681 CP      PROC			; Or the token is PROC
043D18 F2 
043D19 28     10682 JR      Z,LEXANB		; Then jump to here
043D1A 06 
043D1B CD     10683 CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D1C 85 
043D1D 3C 
043D1E 04 
043D1F 38     10684 JR      C,LEXANC		; Jump here if out of range
043D20 02 
              10685 ;
043D21 CB     10686 LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D22 E9 
043D23 FE     10687 LEXANC:			CP      '&'			; Check for hex prefix
043D24 26 
043D25 20     10688 JR      NZ,LEXAND		; If not, skip
043D26 02 
043D27 CB     10689 SET     3,C             	; FLAG: IN HEX
043D28 D9 
              10690 ;
043D29 FE     10691 LEXAND:			CP	'%'			; Check for binary prefix
043D2A 25 
043D2B 20     10692 JR	NZ,LEXANE		; If not, skip
043D2C 02 
043D2D CB     10693 SET	2,C			; FLAG: IN BINARY
043D2E D1 
              10694 ;
043D2F 21     10695 LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D30 53 
043D31 3D 
043D32 04 
043D33 C5     10696 PUSH    BC
043D34 01     10697 LD      BC,LIST1L		; The list length
043D35 06 
043D36 00 
043D37 00 
043D38 ED     10698 CPIR				; Check if the token is in this list
043D39 B1 
043D3A C1     10699 POP     BC
043D3B 20     10700 JR      NZ,LEXANF		; If not, then skip
043D3C 02 
043D3D CB     10701 SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D3E E1 
              10702 ;
043D3F 21     10703 LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D40 57 
043D41 3D 
043D42 04 
043D43 C5     10704 PUSH    BC
043D44 01     10705 LD      BC,LIST2L		; The list length
043D45 05 
043D46 00 
043D47 00 
043D48 ED     10706 CPIR				; Check if the token is in this list
043D49 B1 
043D4A C1     10707 POP     BC
043D4B 20     10708 JR      NZ,LEXANG		; If not, then skip
043D4C 02 
043D4D CB     10709 SET     0,C             	; FLAG: ENTER LEFT MODE
043D4E C1 
043D4F C3     10710 LEXANG:			JP      LEXAN1			; And loop
043D50 9B 
043D51 3C 
043D52 04 
              10711 
              10712 ;
              10713 ; LIST1: List of tokens that must be followed by line numbers
              10714 ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
              10715 ;
043D53 E5     10716 LIST1:			DB	GOTO
043D54 E4     10717 DB	GOSUB
043D55 F7     10718 DB	RESTOR
043D56 FC     10719 DB	TRACE
043D57 8C     10720 LIST2:			DB	THEN_MN_
043D58 8B     10721 DB	ELSE_MN_
              10722 LIST1L:			EQU     $-LIST1
043D59 F5     10723 DB	REPEAT
043D5A 85     10724 DB	TERROR_MN
043D5B 3A     10725 DB    	':'
              10726 LIST2L:			EQU     $-LIST2
              10727 ;
              10728 ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
              10729 ;   Inputs: HL=line number, DE=string pointer
              10730 ;  Outputs: DE updated, BIT 4,C set.
              10731 ; Destroys: A,B,C,D,E,F
              10732 ;
              10733 ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
              10734 ;
              10735 ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
              10736 ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
              10737 ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
              10738 ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
              10739 ; each byte are then stored, in LO/HI order, ORred with 0x40.
              10740 ;
043D5C CB     10741 ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D5D E1 
043D5E EB     10742 EX      DE, HL			; HL: string pointer, DE: line number
043D5F 36     10743 LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D60 8D 
043D61 23     10744 INC     HL
043D62 7A     10745 LD      A,D			; Get the high byte
043D63 E6     10746 AND     0C0H			; Get the top two bits	DD000000
043D64 C0 
043D65 0F     10747 RRCA				; Shift right		00DD0000
043D66 0F     10748 RRCA
043D67 47     10749 LD      B,A			; Store in B
043D68 7B     10750 LD      A,E			; Get the low byte
043D69 E6     10751 AND     0C0H			; Get the top two bits	EE000000
043D6A C0 
043D6B B0     10752 OR      B			; Combine with D	EEDD0000
043D6C 0F     10753 RRCA				; Shift right		00EEDD00
043D6D 0F     10754 RRCA
043D6E EE     10755 XOR     01010100B		; XOR with 54h
043D6F 54 
043D70 77     10756 LD      (HL),A			; Store this as the second byte
043D71 23     10757 INC     HL
043D72 7B     10758 LD      A,E			; Get the low byte
043D73 E6     10759 AND     3FH			; Strip the top two bits off
043D74 3F 
043D75 F6     10760 OR      '@'			; OR with 40h
043D76 40 
043D77 77     10761 LD      (HL),A			; Store
043D78 23     10762 INC     HL
043D79 7A     10763 LD      A,D			; Get the high byte
043D7A E6     10764 AND     3FH			; Strip the top two bits off
043D7B 3F 
043D7C F6     10765 OR      '@'			; OR with 40h
043D7D 40 
043D7E 77     10766 LD      (HL),A			; Store
043D7F 23     10767 INC     HL
043D80 EB     10768 EX      DE,HL			; DE: string pointer, HL: line number
043D81 C9     10769 RET
              10770 ;
              10771 ; TEXT - OUTPUT MESSAGE.
              10772 ;   Inputs: HL addresses text (terminated by nul)
              10773 ;  Outputs: HL addresses character following nul.
              10774 ; Destroys: A,H,L,F
              10775 ;
043D82 2A     10776 REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043D83 2F 
043D84 4D 
043D85 04 
              10777 ;
043D86 7E     10778 TEXT_:			LD      A, (HL)			; Fetch the character
043D87 23     10779 INC     HL			; Increment pointer to next character
043D88 B7     10780 OR      A			; Check for the nul (0) string terminator
043D89 C8     10781 RET     Z			; And return if so
043D8A CD     10782 CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043D8B 6C 
043D8C 39 
043D8D 04 
043D8E 18     10783 JR      TEXT_			; And loop
043D8F F6 
              10784 ;
              10785 ; TELL - OUTPUT MESSAGE.
              10786 ;   Inputs: Text follows subroutine call (term=nul)
              10787 ; Destroys: A,F
              10788 ;
              10789 ; Example usage:
              10790 ;
              10791 ;	CALL	TELL			Call the function
              10792 ;	DB	"Hello World", 0	Followed by a zero terminated string
              10793 ;	LD	A, (1234H)		Program execution will carry on here after the message is output
              10794 ;
043D90 E3     10795 TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043D91 CD     10796 CALL    TEXT_			; first byte of the string that follows it. Print it, then
043D92 86 
043D93 3D 
043D94 04 
043D95 E3     10797 EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043D96 C9     10798 RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
              10799 
              10800 ; --- Begin misc.asm ---
              10801 ;
              10802 ; Title:	BBC Basic for AGON - Miscellaneous helper functions
              10803 ; Author:	Dean Belfield
              10804 ; Created:	12/05/2023
              10805 ; Last Updated:	12/05/2023
              10806 ;
              10807 ; Modinfo:
              10808 
              10809 ; INCLUDE	"equs.inc"
              10810 ; INCLUDE	"macros.inc"
              10811 
              10812 ; .ASSUME	ADL = 1
              10813 
              10814 ; SEGMENT CODE
              10815 
              10816 ; XDEF	ASC_TO_NUMBER
              10817 ; XDEF	SWITCH_A
              10818 ; XDEF	NULLTOCR
              10819 ; XDEF	CRTONULL
              10820 ; XDEF	CSTR_FNAME
              10821 ; XDEF	CSTR_LINE
              10822 ; XDEF	CSTR_FINDCH
              10823 ; XDEF	CSTR_ENDSWITH
              10824 ; XDEF	CSTR_CAT
              10825 
              10826 ; XREF	OSWRCH
              10827 ; XREF	KEYWDS
              10828 ; XREF	KEYWDL
              10829 
              10830 ; Read a number and convert to binary
              10831 ; If prefixed with &, will read as hex, otherwise decimal
              10832 ;   Inputs: HL: Pointer in string buffer
              10833 ;  Outputs: HL: Updated text pointer
              10834 ;           DE: Value
              10835 ;            A: Terminator (spaces skipped)
              10836 ; Destroys: A,D,E,H,L,F
              10837 ;
043D97 C5     10838 ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043D98 11     10839 LD	DE, 0			; Initialise DE
043D99 00 
043D9A 00 
043D9B 00 
043D9C CD     10840 CALL	SKIPSPC			; Skip whitespace
043D9D DE 
043D9E 3D 
043D9F 04 
043DA0 7E     10841 LD	A, (HL)			; Read first character
043DA1 FE     10842 CP	'&'			; Is it prefixed with '&' (HEX number)?
043DA2 26 
043DA3 20     10843 JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DA4 1F 
043DA5 23     10844 INC	HL			; Otherwise fall through to ASC_TO_HEX
              10845 ;
043DA6 7E     10846 ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DA7 CD     10847 CALL    UPPERC			; Convert to uppercase
043DA8 EC 
043DA9 3D 
043DAA 04 
043DAB D6     10848 SUB	'0'			; Normalise to 0
043DAC 30 
043DAD 38     10849 JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DAE 2E 
043DAF FE     10850 CP 	10			; Check if >= 10
043DB0 0A 
043DB1 38     10851 JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DB2 06 
043DB3 D6     10852 SUB 	7			; Adjust ASCII A-F to nibble
043DB4 07 
043DB5 FE     10853 CP 	16			; Check for > F
043DB6 10 
043DB7 30     10854 JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DB8 24 
043DB9 EB     10855 ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DBA 29     10856 ADD	HL, HL
043DBB 29     10857 ADD	HL, HL
043DBC 29     10858 ADD	HL, HL
043DBD 29     10859 ADD	HL, HL
043DBE EB     10860 EX	DE, HL
043DBF B3     10861 OR      E			; OR the new digit in to the least significant nibble
043DC0 5F     10862 LD      E, A
043DC1 23     10863 INC     HL			; Onto the next character
043DC2 18     10864 JR      ASC_TO_NUMBER1		; And loop
043DC3 E2 
              10865 ;
043DC4 7E     10866 ASC_TO_NUMBER3:		LD	A, (HL)
043DC5 D6     10867 SUB	'0'			; Normalise to 0
043DC6 30 
043DC7 38     10868 JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DC8 14 
043DC9 FE     10869 CP	10			; Check if >= 10
043DCA 0A 
043DCB 30     10870 JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043DCC 10 
043DCD EB     10871 EX 	DE, HL 			; Stick DE in HL
043DCE 44     10872 LD	B, H 			; And copy HL into BC
043DCF 4D     10873 LD	C, L
043DD0 29     10874 ADD	HL, HL 			; x 2
043DD1 29     10875 ADD	HL, HL 			; x 4
043DD2 09     10876 ADD	HL, BC 			; x 5
043DD3 29     10877 ADD	HL, HL 			; x 10
043DD4 EB     10878 EX	DE, HL
              10879 ADD8U_DE 			; Add A to DE (macro)
043DD5 83     0001M ADD	A, E
043DD6 5F     0002M LD	E, A
043DD7 8A     0003M ADC	A, D
043DD8 93     0004M SUB	E
043DD9 57     0005M LD	D, A
043DDA 23     10880 INC	HL
043DDB 18     10881 JR	ASC_TO_NUMBER3
043DDC E7 
043DDD C1     10882 ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
              10883 
              10884 ; Skip a space
              10885 ; HL: Pointer in string buffer
              10886 ;
043DDE 7E     10887 SKIPSPC:			LD      A, (HL)
043DDF FE     10888 CP      ' '
043DE0 20 
043DE1 C0     10889 RET     NZ
043DE2 23     10890 INC     HL
043DE3 18     10891 JR      SKIPSPC
043DE4 F9 
              10892 
              10893 ; Skip a string
              10894 ; HL: Pointer in string buffer
              10895 ;
043DE5 7E     10896 SKIPNOTSP:		LD	A, (HL)
043DE6 FE     10897 CP	' '
043DE7 20 
043DE8 C8     10898 RET	Z
043DE9 23     10899 INC	HL
043DEA 18     10900 JR	SKIPNOTSP
043DEB F9 
              10901 
              10902 ; Convert a character to upper case
              10903 ;  A: Character to convert
              10904 ;
043DEC E6     10905 UPPERC:  		AND     7FH
043DED 7F 
043DEE FE     10906 CP      '`'
043DEF 60 
043DF0 D8     10907 RET     C
043DF1 E6     10908 AND     5FH			; Convert to upper case
043DF2 5F 
043DF3 C9     10909 RET
              10910 
              10911 ; Switch on A - lookup table immediately after call
              10912 ;  A: Index into lookup table
              10913 ;
043DF4 E3     10914 SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043DF5 87     10915 ADD	A, A			; Multiply A by two
              10916 ADD8U_HL 			; Add to HL (macro)
043DF6 85     0001M ADD	A, L
043DF7 6F     0002M LD	L, A
043DF8 8C     0003M ADC	A, H
043DF9 95     0004M SUB	L
043DFA 67     0005M LD	H, A
043DFB 7E     10917 LD	A, (HL)			; follow the call. Fetch an address from the
043DFC 23     10918 INC	HL 			; table.
043DFD 66     10919 LD	H, (HL)
043DFE 6F     10920 LD	L, A
043DFF E3     10921 EX	(SP), HL		; Swap this new address back, restores HL
043E00 C9     10922 RET				; Return program control to this new address
              10923 
              10924 ; Convert the buffer to a null terminated string and back
              10925 ; HL: Buffer address
              10926 ;
043E01 C5     10927 NULLTOCR:		PUSH 	BC
043E02 06     10928 LD	B, 0
043E03 00 
043E04 0E     10929 LD	C, CR
043E05 0D 
043E06 18     10930 JR	CRTONULL0
043E07 05 
              10931 ;
043E08 C5     10932 CRTONULL:		PUSH	BC
043E09 06     10933 LD	B, CR
043E0A 0D 
043E0B 0E     10934 LD	C, 0
043E0C 00 
              10935 ;
043E0D E5     10936 CRTONULL0:		PUSH	HL
043E0E 7E     10937 CRTONULL1:		LD	A, (HL)
043E0F B8     10938 CP 	B
043E10 28     10939 JR	Z, CRTONULL2
043E11 03 
043E12 23     10940 INC	HL
043E13 18     10941 JR	CRTONULL1
043E14 F9 
043E15 71     10942 CRTONULL2:		LD	(HL), C
043E16 E1     10943 POP 	HL
043E17 C1     10944 POP	BC
043E18 C9     10945 RET
              10946 
              10947 ; Copy a filename to DE and zero terminate it
              10948 ; HL: Source
              10949 ; DE: Destination (ACCS)
              10950 ;
043E19 7E     10951 CSTR_FNAME:		LD	A, (HL)			; Get source
043E1A FE     10952 CP	32			; Is it space
043E1B 20 
043E1C 28     10953 JR	Z, @F
043E1D 09 
043E1E FE     10954 CP	CR			; Or is it CR
043E1F 0D 
043E20 28     10955 JR	Z, @F
043E21 05 
043E22 12     10956 LD	(DE), A			; No, so store
043E23 23     10957 INC	HL			; Increment
043E24 13     10958 INC	DE
043E25 18     10959 JR	CSTR_FNAME		; And loop
043E26 F2 
043E27 AF     10960 @@:			XOR	A			; Zero terminate the target string
043E28 12     10961 LD	(DE), A
043E29 13     10962 INC	DE			; And point to next free address
043E2A C9     10963 RET
              10964 
              10965 ; Copy a CR terminated line to DE and zero terminate it
              10966 ; HL: Source
              10967 ; DE: Destination (ACCS)
              10968 ;
043E2B 7E     10969 CSTR_LINE:		LD	A, (HL)			; Get source
043E2C FE     10970 CP	CR			; Is it CR
043E2D 0D 
043E2E 28     10971 JR	Z, @F
043E2F 05 
043E30 12     10972 LD	(DE), A			; No, so store
043E31 23     10973 INC	HL			; Increment
043E32 13     10974 INC	DE
043E33 18     10975 JR	CSTR_LINE		; And loop
043E34 F6 
043E35 AF     10976 @@:			XOR	A			; Zero terminate the target string
043E36 12     10977 LD	(DE), A
043E37 13     10978 INC	DE			; And point to next free address
043E38 C9     10979 RET
              10980 
              10981 ; Find the first occurrence of a character (case sensitive)
              10982 ; HL: Source
              10983 ;  C: Character to find
              10984 ; Returns:
              10985 ; HL: Pointer to character, or end of string marker
              10986 ;
043E39 7E     10987 CSTR_FINDCH:		LD	A, (HL)			; Get source
043E3A B9     10988 CP	C			; Is it our character?
043E3B C8     10989 RET	Z			; Yes, so exit
043E3C B7     10990 OR	A			; Is it the end of string?
043E3D C8     10991 RET	Z			; Yes, so exit
043E3E 23     10992 INC	HL
043E3F 18     10993 JR	CSTR_FINDCH
043E40 F8 
              10994 
              10995 ; Check whether a string ends with another string (case insensitive)
              10996 ; HL: Source
              10997 ; DE: The substring we want to test with
              10998 ; Returns:
              10999 ;  F: Z if HL ends with DE, otherwise NZ
              11000 ;
043E41 7E     11001 CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E42 CD     11002 CALL	UPPERC			; Convert to upper case
043E43 EC 
043E44 3D 
043E45 04 
043E46 4F     11003 LD	C, A
043E47 1A     11004 LD	A, (DE)			; Get the substring byte
043E48 B9     11005 CP	C
043E49 C0     11006 RET	NZ			; Return NZ if at any point the strings don't match
043E4A B1     11007 OR	C			; Check whether both bytes are zero
043E4B C8     11008 RET	Z			; If so, return, as we have reached the end of both strings
043E4C 23     11009 INC	HL
043E4D 13     11010 INC	DE
043E4E 18     11011 JR	CSTR_ENDSWITH		; And loop
043E4F F1 
              11012 
              11013 ; Concatenate a string onto the end of another string
              11014 ; HL: Source
              11015 ; DE: Second string
              11016 ;
043E50 7E     11017 CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E51 B7     11018 OR	A
043E52 28     11019 JR	Z, CSTR_CAT_1
043E53 03 
043E54 23     11020 INC	HL
043E55 18     11021 JR	CSTR_CAT
043E56 F9 
              11022 ;
043E57 1A     11023 CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E58 77     11024 LD	(HL), A
043E59 B7     11025 OR	A			; Check for end of string
043E5A C8     11026 RET	Z			; And return
043E5B 23     11027 INC	HL
043E5C 13     11028 INC	DE
043E5D 18     11029 JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E5E F8 
              11030 
              11031 ; --- Begin patch.asm ---
              11032 ;
              11033 ; Title:	BBC Basic for AGON
              11034 ; Author:	Dean Belfield
              11035 ; Created:	12/05/2023
              11036 ; Last Updated:	15/11/2023
              11037 ;
              11038 ; Modinfo:
              11039 ; 11/07/2023:	Fixed *BYE for ADL mode
              11040 ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
              11041 
              11042 ; .ASSUME	ADL = 1
              11043 
              11044 ; INCLUDE	"equs.inc"
              11045 ; INCLUDE "macros.inc"
              11046 ; INCLUDE "mos_api.inc"	; In MOS/src
              11047 
              11048 ; SEGMENT CODE
              11049 
              11050 ; XDEF	OSWRCH
              11051 ; XDEF	OSLINE
              11052 ; XDEF	ESCSET
              11053 ; XDEF	PUTIME
              11054 ; XDEF	GETIME
              11055 ; XDEF	PUTCSR
              11056 ; XDEF 	GETCSR
              11057 ; XDEF	OSRDCH
              11058 ; XDEF	PROMPT
              11059 ; XDEF	OSKEY
              11060 ; XDEF	TRAP
              11061 ; XDEF	LTRAP
              11062 ; XDEF	OSINIT
              11063 ; XDEF	OSCLI
              11064 ; XDEF	OSBPUT
              11065 ; XDEF	OSBGET
              11066 ; XDEF	OSSTAT
              11067 ; XDEF	OSSHUT
              11068 ; XDEF	OSOPEN
              11069 ; XDEF	OSCALL
              11070 ; XDEF	GETPTR
              11071 ; XDEF	PUTPTR
              11072 ; XDEF	GETEXT
              11073 ; XDEF	GETIMS
              11074 ; XDEF	RESET
              11075 ; XDEF	OSLOAD
              11076 ; XDEF	OSSAVE
              11077 ; XDEF	EXPR_W2
              11078 ; XDEF	STAR_VERSION
              11079 
              11080 ; XREF	_end			; In init.asm
              11081 
              11082 ; XREF	ASC_TO_NUMBER
              11083 ; XREF	RAM_START
              11084 ; XREF	RAM_END
              11085 ; XREF	FLAGS
              11086 ; XREF	ESCAPE
              11087 ; XREF	USER
              11088 ; XREF	RAM_Top
              11089 ; XREF	EXTERR
              11090 ; XREF	COUNT0
              11091 ; XREF	EXPRI
              11092 ; XREF	COMMA
              11093 ; XREF	XEQ
              11094 ; XREF	NXT
              11095 ; XREF	NULLTOCR
              11096 ; XREF	CRLF
              11097 ; XREF	CSTR_FNAME
              11098 ; XREF	CSTR_LINE
              11099 ; XREF	CSTR_FINDCH
              11100 ; XREF	CSTR_ENDSWITH
              11101 ; XREF	CSTR_CAT
              11102 ; XREF	FINDL
              11103 ; XREF	OUT_
              11104 ; XREF	ERROR_
              11105 ; XREF	ONEDIT
              11106 ; XREF	TELL
              11107 ; XREF	OSWRCHPT
              11108 ; XREF	OSWRCHCH
              11109 ; XREF	OSWRCHFH
              11110 ; XREF	LISTON
              11111 ; XREF	LISTIT
              11112 ; XREF	PAGE_
              11113 ; XREF	ONEDIT1
              11114 ; XREF	CLEAN
              11115 ; XREF	NEWIT
              11116 ; XREF	BAD
              11117 ; XREF	VBLANK_INIT
              11118 ; XREF	VBLANK_STOP
              11119 ; XREF	KEYDOWN
              11120 ; XREF	KEYASCII
              11121 ; XREF	WIDTH
              11122 ; XREF	ASSEM
              11123 
              11124 ; OSLINE: Invoke the line editor
              11125 ;
043E5F 1E     11126 OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E60 01 
              11127 
              11128 ; Entry point to line editor that does not clear the buffer
              11129 ;
043E61 FD     11130 OSLINE1:		PUSH	IY
043E62 E5 
043E63 E5     11131 PUSH	HL			; Buffer address
043E64 01     11132 LD	BC, 256			; Buffer length
043E65 00 
043E66 01 
043E67 00 
              11133 MOSCALL	mos_editline		; Call the MOS line editor
043E68 3E     0001M LD	A, function
043E69 09 
043E6A 49     0002M RST.LIS	08h
043E6B CF 
043E6C E1     11134 POP	HL			; Pop the address
043E6D FD     11135 POP	IY
043E6E E1 
043E6F F5     11136 PUSH	AF			; Stack the return value (key pressed)
043E70 CD     11137 CALL	NULLTOCR		; Turn the 0 character to a CR
043E71 01 
043E72 3E 
043E73 04 
043E74 CD     11138 CALL	CRLF			; Display CRLF
043E75 47 
043E76 39 
043E77 04 
043E78 F1     11139 POP	AF
043E79 FE     11140 CP	1Bh 			; Check if ESC terminated the input
043E7A 1B 
043E7B CA     11141 JP	Z, LTRAP1 		; Yes, so do the ESC thing
043E7C 77 
043E7D 3F 
043E7E 04 
043E7F 3A     11142 LD	A, (FLAGS)		; Otherwise
043E80 42 
043E81 4D 
043E82 04 
043E83 CB     11143 RES	7, A 			; Clear the escape flag
043E84 BF 
043E85 32     11144 LD	(FLAGS), A
043E86 42 
043E87 4D 
043E88 04 
043E89 CD     11145 CALL	WAIT_VBLANK 		; Wait a frame
043E8A 3D 
043E8B 41 
043E8C 04 
043E8D AF     11146 XOR	A			; Return A = 0
043E8E 32     11147 LD	(KEYDOWN), A
043E8F 47 
043E90 4D 
043E91 04 
043E92 32     11148 LD	(KEYASCII), A
043E93 48 
043E94 4D 
043E95 04 
043E96 C9     11149 RET
              11150 
              11151 ; PUTIME: set current time to DE:HL, in centiseconds.
              11152 ;
043E97 DD     11153 PUTIME:			PUSH 	IX
043E98 E5 
              11154 MOSCALL	mos_sysvars
043E99 3E     0001M LD	A, function
043E9A 08 
043E9B 49     0002M RST.LIS	08h
043E9C CF 
043E9D DD     11155 LD	(IX + sysvar_time + 0), L
043E9E 75 
043E9F 00 
043EA0 DD     11156 LD	(IX + sysvar_time + 1), H
043EA1 74 
043EA2 01 
043EA3 DD     11157 LD	(IX + sysvar_time + 2), E
043EA4 73 
043EA5 02 
043EA6 DD     11158 LD	(IX + sysvar_time + 3), D
043EA7 72 
043EA8 03 
043EA9 DD     11159 POP	IX
043EAA E1 
043EAB C9     11160 RET
              11161 
              11162 ; GETIME: return current time in DE:HL, in centiseconds
              11163 ;
043EAC DD     11164 GETIME:			PUSH 	IX
043EAD E5 
              11165 MOSCALL	mos_sysvars
043EAE 3E     0001M LD	A, function
043EAF 08 
043EB0 49     0002M RST.LIS	08h
043EB1 CF 
043EB2 DD     11166 LD	L, (IX + sysvar_time + 0)
043EB3 6E 
043EB4 00 
043EB5 DD     11167 LD	H, (IX + sysvar_time + 1)
043EB6 66 
043EB7 01 
043EB8 DD     11168 LD	E, (IX + sysvar_time + 2)
043EB9 5E 
043EBA 02 
043EBB DD     11169 LD	D, (IX + sysvar_time + 3)
043EBC 56 
043EBD 03 
043EBE DD     11170 POP	IX
043EBF E1 
043EC0 C9     11171 RET
              11172 
              11173 ; PUTCSR: move to cursor to x=DE, y=HL
              11174 ;
043EC1 3E     11175 PUTCSR:			LD	A, 1Fh			; TAB
043EC2 1F 
043EC3 5B     11176 RST.LIL	10h
043EC4 D7 
043EC5 7B     11177 LD	A, E			; X
043EC6 5B     11178 RST.LIL 10h
043EC7 D7 
043EC8 7D     11179 LD	A, L			; Y
043EC9 5B     11180 RST.LIL 10h
043ECA D7 
043ECB C9     11181 RET
              11182 
              11183 ; GETCSR: return cursor position in x=DE, y=HL
              11184 ;
043ECC DD     11185 GETCSR:			PUSH	IX			; Get the system vars in IX
043ECD E5 
              11186 MOSCALL	mos_sysvars		; Reset the semaphore
043ECE 3E     0001M LD	A, function
043ECF 08 
043ED0 49     0002M RST.LIS	08h
043ED1 CF 
043ED2 DD     11187 RES	0, (IX+sysvar_vpd_pflags)
043ED3 CB 
043ED4 04 
043ED5 86 
              11188 VDU	23
043ED6 3E     0001M LD	A, val
043ED7 17 
043ED8 CD     0002M CALL	OSWRCH
043ED9 00 
043EDA 3F 
043EDB 04 
              11189 VDU	0
043EDC 3E     0001M LD	A, val
043EDD 00 
043EDE CD     0002M CALL	OSWRCH
043EDF 00 
043EE0 3F 
043EE1 04 
              11190 VDU	vdp_cursor
043EE2 3E     0001M LD	A, val
043EE3 82 
043EE4 CD     0002M CALL	OSWRCH
043EE5 00 
043EE6 3F 
043EE7 04 
043EE8 DD     11191 @@:			BIT	0, (IX+sysvar_vpd_pflags)
043EE9 CB 
043EEA 04 
043EEB 46 
043EEC 28     11192 JR	Z, @B			; Wait for the result
043EED FA 
043EEE 16     11193 LD 	D, 0
043EEF 00 
043EF0 62     11194 LD	H, D
043EF1 DD     11195 LD	E, (IX + sysvar_cursorX)
043EF2 5E 
043EF3 07 
043EF4 DD     11196 LD	L, (IX + sysvar_cursorY)
043EF5 6E 
043EF6 08 
043EF7 DD     11197 POP	IX
043EF8 E1 
043EF9 C9     11198 RET
              11199 
              11200 ; PROMPT: output the input prompt
              11201 ;
043EFA 3E     11202 PROMPT: 		LD	A,'>'
043EFB 3E 
043EFC C3     11203 JP	OSWRCH
043EFD 00 
043EFE 3F 
043EFF 04 
              11204 
              11205 ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
              11206 ; A: Character to write
              11207 ;
043F00 E5     11208 OSWRCH:			PUSH	HL
043F01 21     11209 LD	HL, LISTON		; Fetch the LISTON variable
043F02 40 
043F03 4D 
043F04 04 
043F05 CB     11210 BIT	3, (HL)			; Check whether we are in *EDIT mode
043F06 5E 
043F07 20     11211 JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F08 0B 
              11212 ;
043F09 2A     11213 LD	HL, (OSWRCHCH)		; L: Channel #
043F0A 45 
043F0B 4D 
043F0C 04 
043F0D 2D     11214 DEC	L			; If it is 1
043F0E 28     11215 JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F0F 10 
              11216 ;
043F10 E1     11217 POP	HL			; Otherwise
043F11 5B     11218 RST.LIL	10h			; Output the character to MOS
043F12 D7 
043F13 C9     11219 RET
              11220 ;
043F14 2A     11221 OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F15 43 
043F16 4D 
043F17 04 
043F18 77     11222 LD	(HL), A			; Echo the character into the buffer
043F19 23     11223 INC	HL			; Increment pointer
043F1A 22     11224 LD	(OSWRCHPT), HL		; Write pointer back
043F1B 43 
043F1C 4D 
043F1D 04 
043F1E E1     11225 POP	HL
043F1F C9     11226 RET
              11227 ;
043F20 D5     11228 OSWRCH_FILE:		PUSH	DE
043F21 5C     11229 LD	E, H			; Filehandle to E
043F22 CD     11230 CALL	OSBPUT			; Write the byte out
043F23 3B 
043F24 43 
043F25 04 
043F26 D1     11231 POP	DE
043F27 E1     11232 POP	HL
043F28 C9     11233 RET
              11234 
              11235 ; OSRDCH: Read a character in from the ESP32 keyboard handler
              11236 ; This is only called in GETS (eval.asm)
              11237 ;
              11238 OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F29 3E     0001M LD	A, function
043F2A 00 
043F2B 49     0002M RST.LIS	08h
043F2C CF 
043F2D FE     11239 CP	1Bh
043F2E 1B 
043F2F 28     11240 JR	Z, LTRAP1
043F30 46 
043F31 C9     11241 RET
              11242 
              11243 
              11244 ;OSKEY - Read key with time-limit, test for ESCape.
              11245 ;Main function is carried out in user patch.
              11246 ;   Inputs: HL = time limit (centiseconds)
              11247 ;  Outputs: Carry reset if time-out
              11248 ;           If carry set A = character
              11249 ; Destroys: A,H,L,F
              11250 ;
043F32 CD     11251 OSKEY:			CALL	READKEY			; Read the keyboard
043F33 63 
043F34 3F 
043F35 04 
043F36 28     11252 JR	Z, @F 			; Skip if we have a key
043F37 0A 
043F38 7C     11253 LD	A, H 			; Check loop counter
043F39 B5     11254 OR 	L
043F3A C8     11255 RET 	Z 			; Return, we've not got a key at this point
043F3B CD     11256 CALL	WAIT_VBLANK 		; Wait a frame
043F3C 3D 
043F3D 41 
043F3E 04 
043F3F 2B     11257 DEC 	HL			; Decrement
043F40 18     11258 JR	OSKEY 			; And loop
043F41 F0 
              11259 ;
043F42 21     11260 @@:			LD	HL, KEYDOWN		; We have a key, so
043F43 47 
043F44 4D 
043F45 04 
043F46 36     11261 LD	(HL), 0			; clear the keydown flag
043F47 00 
043F48 FE     11262 CP	1BH			; If we are not pressing ESC,
043F49 1B 
043F4A 37     11263 SCF 				; then flag we've got a character
043F4B C0     11264 RET	NZ
              11265 ;
              11266 ; ESCSET
              11267 ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
              11268 ;
043F4C E5     11269 ESCSET: 		PUSH    HL
043F4D 21     11270 LD      HL,FLAGS		; Pointer to FLAGS
043F4E 42 
043F4F 4D 
043F50 04 
043F51 CB     11271 BIT     6,(HL)			; If bit 6 is set, then
043F52 76 
043F53 20     11272 JR      NZ,ESCDIS		; escape is disabled, so skip
043F54 02 
043F55 CB     11273 SET     7,(HL)			; Set bit 7, the escape flag
043F56 FE 
043F57 E1     11274 ESCDIS: 		POP     HL
043F58 C9     11275 RET
              11276 ;
              11277 ; ESCTEST
              11278 ; Test for ESC key
              11279 ;
043F59 CD     11280 ESCTEST:		CALL	READKEY			; Read the keyboard
043F5A 63 
043F5B 3F 
043F5C 04 
043F5D C0     11281 RET	NZ			; Skip if no key is pressed
043F5E FE     11282 CP	1BH			; If ESC pressed then
043F5F 1B 
043F60 28     11283 JR	Z,ESCSET		; jump to the escape set routine
043F61 EA 
043F62 C9     11284 RET
              11285 
              11286 ; Read the keyboard
              11287 ; Returns:
              11288 ; - A: ASCII of the pressed key
              11289 ; - F: Z if the key is pressed, otherwise NZ
              11290 ;
043F63 3A     11291 READKEY:		LD	A, (KEYDOWN)		; Get key down
043F64 47 
043F65 4D 
043F66 04 
043F67 3D     11292 DEC	A 			; Set Z flag if keydown is 1
043F68 3A     11293 LD	A, (KEYASCII)		; Get key ASCII value
043F69 48 
043F6A 4D 
043F6B 04 
043F6C C9     11294 RET
              11295 ;
              11296 ; TRAP
              11297 ; This is called whenever BASIC needs to check for ESC
              11298 ;
043F6D CD     11299 TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043F6E 59 
043F6F 3F 
043F70 04 
              11300 ;
043F71 3A     11301 LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043F72 42 
043F73 4D 
043F74 04 
043F75 B7     11302 OR	A			; This checks for bit 7; if it is not set then the result will
043F76 F0     11303 RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043F77 21     11304 LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043F78 42 
043F79 4D 
043F7A 04 
043F7B CB     11305 RES	7,(HL)			; Clear the escape pressed flag and
043F7C BE 
043F7D C3     11306 JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043F7E 9B 
043F7F 0C 
043F80 04 
              11307 
              11308 ;OSINIT - Initialise RAM mapping etc.
              11309 ;If BASIC is entered by BBCBASIC FILENAME then file
              11310 ;FILENAME.BBC is automatically CHAINed.
              11311 ;   Outputs: DE = initial value of HIMEM (top of RAM)
              11312 ;            HL = initial value of PAGE (user program)
              11313 ;            Z-flag reset indicates AUTO-RUN.
              11314 ;  Destroys: A,D,E,H,L,F
              11315 ;
043F81 CD     11316 OSINIT:			CALL	VBLANK_INIT
043F82 E0 
043F83 48 
043F84 04 
043F85 AF     11317 XOR	A
043F86 21     11318 LD 	HL, USER
043F87 00 
043F88 4E 
043F89 04 
043F8A 11     11319 LD	DE, RAM_Top
043F8B 00 
043F8C 00 
043F8D 0B 
043F8E 5F     11320 LD	E, A			; Page boundary
043F8F C9     11321 RET
              11322 
              11323 ;
              11324 ;OSCLI - Process a MOS command
              11325 ;
043F90 CD     11326 OSCLI: 			CALL    SKIPSP
043F91 04 
043F92 40 
043F93 04 
043F94 FE     11327 CP      CR
043F95 0D 
043F96 C8     11328 RET     Z
043F97 FE     11329 CP      '|'
043F98 7C 
043F99 C8     11330 RET     Z
043F9A EB     11331 EX      DE,HL
043F9B 21     11332 LD      HL,COMDS
043F9C 13 
043F9D 40 
043F9E 04 
043F9F 1A     11333 OSCLI0:			LD      A,(DE)
043FA0 CD     11334 CALL    UPPRC
043FA1 0B 
043FA2 40 
043FA3 04 
043FA4 BE     11335 CP      (HL)
043FA5 28     11336 JR      Z,OSCLI2
043FA6 0B 
043FA7 38     11337 JR      C,OSCLI6
043FA8 30 
043FA9 CB     11338 OSCLI1:			BIT     7,(HL)
043FAA 7E 
043FAB 23     11339 INC     HL
043FAC 28     11340 JR      Z,OSCLI1
043FAD FB 
043FAE 23     11341 INC     HL
043FAF 23     11342 INC     HL
043FB0 18     11343 JR      OSCLI0
043FB1 ED 
              11344 ;
043FB2 D5     11345 OSCLI2:			PUSH    DE
043FB3 13     11346 OSCLI3:			INC     DE
043FB4 23     11347 INC     HL
043FB5 1A     11348 LD      A,(DE)
043FB6 CD     11349 CALL    UPPRC
043FB7 0B 
043FB8 40 
043FB9 04 
043FBA FE     11350 CP      '.'			; ABBREVIATED?
043FBB 2E 
043FBC 28     11351 JR      Z,OSCLI4
043FBD 0A 
043FBE AE     11352 XOR     (HL)
043FBF 28     11353 JR      Z,OSCLI3
043FC0 F2 
043FC1 FE     11354 CP      80H
043FC2 80 
043FC3 28     11355 JR      Z,OSCLI4
043FC4 03 
043FC5 D1     11356 POP     DE
043FC6 18     11357 JR      OSCLI1
043FC7 E1 
              11358 ;
043FC8 F1     11359 OSCLI4:			POP     AF
043FC9 13     11360 INC     DE
043FCA CB     11361 OSCLI5:			BIT     7,(HL)
043FCB 7E 
043FCC 23     11362 INC     HL
043FCD 28     11363 JR      Z,OSCLI5
043FCE FB 
043FCF 7E     11364 LD      A,(HL)
043FD0 23     11365 INC     HL
043FD1 66     11366 LD      H,(HL)
043FD2 6F     11367 LD      L,A
043FD3 E5     11368 PUSH    HL
043FD4 EB     11369 EX      DE,HL
043FD5 C3     11370 JP      SKIPSP
043FD6 04 
043FD7 40 
043FD8 04 
              11371 ;
043FD9 EB     11372 OSCLI6:			EX	DE, HL			; HL: Buffer for command
043FDA 11     11373 LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
043FDB 00 
043FDC 4A 
043FDD 04 
043FDE D5     11374 PUSH	DE			; Store buffer address
043FDF CD     11375 CALL	CSTR_LINE		; Fetch the line
043FE0 2B 
043FE1 3E 
043FE2 04 
043FE3 E1     11376 POP	HL			; HL: Pointer to command string in ACCS
043FE4 FD     11377 PUSH	IY
043FE5 E5 
              11378 MOSCALL	mos_oscli		; Returns OSCLI error in A
043FE6 3E     0001M LD	A, function
043FE7 10 
043FE8 49     0002M RST.LIS	08h
043FE9 CF 
043FEA FD     11379 POP	IY
043FEB E1 
043FEC B7     11380 OR	A			; 0 means MOS returned OK
043FED C8     11381 RET	Z			; So don't do anything
043FEE C3     11382 JP 	OSERROR			; Otherwise it's a MOS error
043FEF 17 
043FF0 42 
043FF1 04 
              11383 
043FF2 3E     11384 HUH:    		LD      A,254			; Bad command error
043FF3 FE 
043FF4 CD     11385 CALL    EXTERR
043FF5 77 
043FF6 37 
043FF7 04 
043FF8 42     11386 DB    	"Bad command"
043FF9 61 
043FFA 64 
043FFB 20 
043FFB 63   
043FFC 6F 
043FFD 6D 
043FFE 6D 
043FFE 61   
043FFF 6E 
044000 64 
044003 00     11387 DEFB    0
              11388 
044004 7E     11389 SKIPSP:			LD      A,(HL)
044005 FE     11390 CP      ' '
044006 20 
044007 C0     11391 RET     NZ
044008 23     11392 INC     HL
044009 18     11393 JR      SKIPSP
04400A F9 
              11394 
04400B E6     11395 UPPRC:  		AND     7FH
04400C 7F 
04400D FE     11396 CP      '`'
04400E 60 
04400F D8     11397 RET     C
044010 E6     11398 AND     5FH			; CONVERT TO UPPER CASE
044011 5F 
044012 C9     11399 RET
              11400 
              11401 ; Each command has bit 7 of the last character set, and is followed by the address of the handler
              11402 ; These must be in alphabetical order
              11403 ;
              11404 ; BEGIN NOT FOUND IN BINARY
              11405 ; COMDS:  		DB	"AS","M"+80h		; ASM
              11406 ; 			DW	STAR_ASM
              11407 ; 			DB	"BY","E"+80h		; BYE
              11408 ; 			DW	STAR_BYE
              11409 ; 			DB	"EDI","T"+80h		; EDIT
              11410 ; 			DW	STAR_EDIT
              11411 ; 			DB	"F","X"+80h		; FX
              11412 ; 			DW	STAR_FX
              11413 ; 			DB	"VERSIO","N"+80h	; VERSION
              11414 ; 			DW	STAR_VERSION
              11415 ; 			DB	FFh
              11416 ; END NOT FOUND IN BINARY
              11417 ; BEGIN INSERTED FROM BINARY
              11418 ; Each command has bit 7 of the last character set, and is followed by the address of the handler
              11419 ; These must be in alphabetical order
              11420 ;
              11421 COMDS:
044013 42     11422 db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
044014 59     11423 db 0x59 ; 044014
044015 C5     11424 db 0xc5 ; 044015
044016 2C     11425 db 0x2c ; 044016 31     11405 DW	STAR_ASM
044017 40     11426 db 0x40 ; 044017
044018 45     11427 db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
044019 44     11428 db 0x44 ; 044019
04401A 49     11429 db 0x49 ; 04401A
04401B D4     11430 db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
04401C 61     11431 db 0x61 ; 04401C
04401D 40     11432 db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
04401E 46     11433 db 0x46 ; 04401E
04401F D8     11434 db 0xd8 ; 04401F
044020 A1     11435 db 0xa1 ; 044020
044021 40     11436 db 0x40 ; 044021 72     11409 DW	STAR_EDIT
044022 56     11437 db 0x56 ; 044022
044023 45     11438 db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
044024 52     11439 db 0x52 ; 044024
044025 53     11440 db 0x53 ; 044025 B2     11411 DW	STAR_FX
044026 49     11441 db 0x49 ; 044026
044027 4F     11442 db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
044028 CE     11443 db 0xce ; 044028
044029 38     11444 db 0x38 ; 044029
04402A 40     11445 db 0x40 ; 04402A
04402B FF     11446 db 0xff ; 04402B
              11447 ; END INSERTED FROM BINARY
              11448 
              11449 ; BEGIN NOT FOUND IN BINARY
              11450 ; ; *ASM string
              11451 ; ;
              11452 ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
              11453 ; 			PUSH	HL			; HL = IY
              11454 ; 			POP	IY
              11455 ; 			CALL	ASSEM			; Invoke the assembler
              11456 ; 			POP	IY
              11457 ; 			RET
              11458 ; END NOT FOUND IN BINARY
              11459 
              11460 ; *BYE
              11461 ;
04402C CD     11462 STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
04402D F4 
04402E 48 
04402F 04 
044030 21     11463 LD	HL, 0			; The return value
044031 00 
044032 00 
044033 00 
044034 C3     11464 JP	_end 			; Jump back to the end routine in init.asm
044035 68 
044036 00 
044037 04 
              11465 
              11466 ; *VERSION
              11467 ;
044038 CD     11468 STAR_VERSION:		CALL    TELL			; Output the welcome message
044039 90 
04403A 3D 
04403B 04 
04403C 42     11469 DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
04403D 42 
04403E 43 
04403F 20 
04403F 42   
044040 41 
044041 53 
044042 49 
044042 43   
044043 20 
044044 28 
044045 41 
044045 67   
044046 6F 
044047 6E 
044048 20 
044048 41   
044049 44 
04404A 4C 
04404B 29 
04404B 20   
04404C 56 
04404D 65 
04404E 72 
04404E 73   
04404F 69 
044050 6F 
044051 6E 
044051 20   
044052 31 
044053 2E 
044054 30 
044054 33   
044055 0A 
044056 0D 
044057 00 
044060 C9     11470 RET
              11471 
              11472 ; *EDIT linenum
              11473 ;
044061 CD     11474 STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
044062 97 
044063 3D 
044064 04 
044065 EB     11475 EX	DE, HL			; HL: Line number
044066 CD     11476 CALL	FINDL			; HL: Address in RAM of tokenised line
044067 8F 
044068 39 
044069 04 
04406A 3E     11477 LD	A, 41			; F:NZ If the line is not found
04406B 29 
04406C C2     11478 JP	NZ, ERROR_		; Do error 41: No such line in that case
04406D 60 
04406E 37 
04406F 04 
              11479 ;
              11480 ; Use LISTIT to output the line to the ACCS buffer
              11481 ;
044070 23     11482 INC	HL			; Skip the length byte
044071 5E     11483 LD	E, (HL)			; Fetch the line number
044072 23     11484 INC	HL
044073 56     11485 LD	D, (HL)
044074 23     11486 INC	HL
044075 DD     11487 LD	IX, ACCS		; Pointer to where the copy is to be stored
044076 21 
044077 00 
044078 4A 
044078 04   
04407A DD     11488 LD	(OSWRCHPT), IX
04407B 22 
04407C 43 
04407D 4D 
04407D 04   
04407F DD     11489 LD	IX, LISTON		; Pointer to LISTON variable in RAM
044080 21 
044081 40 
044082 4D 
044082 04   
044084 DD     11490 LD	A, (IX)			; Store that variable
044085 7E 
044086 00 
044087 F5     11491 PUSH	AF
044088 DD     11492 LD	(IX), 09h		; Set to echo to buffer
044089 36 
04408A 00 
04408B 09 
04408C CD     11493 CALL	LISTIT
04408D 92 
04408E 38 
04408F 04 
044090 F1     11494 POP	AF
044091 DD     11495 LD	(IX), A			; Restore the original LISTON variable
044092 77 
044093 00 
044094 21     11496 LD	HL, ACCS		; HL: ACCS
044095 00 
044096 4A 
044097 04 
044098 5D     11497 LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044099 CD     11498 CALL	OSLINE1			; Invoke the editor
04409A 61 
04409B 3E 
04409C 04 
04409D C3     11499 JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
04409E D0 
04409F 30 
0440A0 04 
              11500 
              11501 ; OSCLI FX n
              11502 ;
0440A1 CD     11503 STAR_FX:		CALL	ASC_TO_NUMBER
0440A2 97 
0440A3 3D 
0440A4 04 
0440A5 4B     11504 LD	C, E			; C: Save FX #
0440A6 CD     11505 CALL	ASC_TO_NUMBER
0440A7 97 
0440A8 3D 
0440A9 04 
0440AA 7A     11506 LD	A, D  			; Is first parameter > 255?
0440AB B7     11507 OR 	A
0440AC 28     11508 JR	Z, STAR_FX1		; Yes, so skip next bit
0440AD 03 
0440AE EB     11509 EX	DE, HL 			; Parameter is 16-bit
0440AF 18     11510 JR	STAR_FX2
0440B0 07 
              11511 ;
0440B1 43     11512 STAR_FX1:		LD	B, E 			; B: Save First parameter
0440B2 CD     11513 CALL	ASC_TO_NUMBER		; Fetch second parameter
0440B3 97 
0440B4 3D 
0440B5 04 
0440B6 68     11514 LD	L, B 			; L: First parameter
0440B7 63     11515 LD	H, E 			; H: Second parameter
              11516 ;
0440B8 79     11517 STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
              11518 ;
              11519 ; OSBYTE
              11520 ;  A: FX #
              11521 ;  L: First parameter
              11522 ;  H: Second parameter
              11523 ;
0440B9 FE     11524 OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0440BA 0B 
0440BB 28     11525 JR	Z, OSBYTE_0B
0440BC 18 
0440BD FE     11526 CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0440BE 0C 
0440BF 28     11527 JR	Z, OSBYTE_0C
0440C0 43 
0440C1 FE     11528 CP	13H			; *FX 19: Wait for vblank
0440C2 13 
0440C3 28     11529 JR	Z, OSBYTE_13
0440C4 6E 
0440C5 FE     11530 CP	76H			; *FX 118, n: Set keyboard LED
0440C6 76 
0440C7 CA     11531 JP	Z, OSBYTE_76
0440C8 4E 
0440C9 41 
0440CA 04 
0440CB FE     11532 CP	A0H
0440CC A0 
0440CD CA     11533 JP	Z, OSBYTE_A0
0440CE 7E 
0440CF 41 
0440D0 04 
0440D1 C3     11534 JP	HUH			; Anything else trips an error
0440D2 F2 
0440D3 3F 
0440D4 04 
              11535 
              11536 ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
              11537 ; Parameters:
              11538 ; - HL: Repeat delay
              11539 ;
              11540 OSBYTE_0B:		VDU	23
0440D5 3E     0001M LD	A, val
0440D6 17 
0440D7 CD     0002M CALL	OSWRCH
0440D8 00 
0440D9 3F 
0440DA 04 
              11541 VDU	0
0440DB 3E     0001M LD	A, val
0440DC 00 
0440DD CD     0002M CALL	OSWRCH
0440DE 00 
0440DF 3F 
0440E0 04 
              11542 VDU	vdp_keystate
0440E1 3E     0001M LD	A, val
0440E2 88 
0440E3 CD     0002M CALL	OSWRCH
0440E4 00 
0440E5 3F 
0440E6 04 
              11543 VDU	L
0440E7 7D     0001M LD	A, val
0440E8 CD     0002M CALL	OSWRCH
0440E9 00 
0440EA 3F 
0440EB 04 
              11544 VDU	H
0440EC 7C     0001M LD	A, val
0440ED CD     0002M CALL	OSWRCH
0440EE 00 
0440EF 3F 
0440F0 04 
              11545 VDU	0
0440F1 3E     0001M LD	A, val
0440F2 00 
0440F3 CD     0002M CALL	OSWRCH
0440F4 00 
0440F5 3F 
0440F6 04 
              11546 VDU 	0
0440F7 3E     0001M LD	A, val
0440F8 00 
0440F9 CD     0002M CALL	OSWRCH
0440FA 00 
0440FB 3F 
0440FC 04 
              11547 VDU	255
0440FD 3E     0001M LD	A, val
0440FE FF 
0440FF CD     0002M CALL	OSWRCH
044100 00 
044101 3F 
044102 04 
044103 C9     11548 RET
              11549 
              11550 ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
              11551 ; Parameters:
              11552 ; - HL: Repeat rate
              11553 ;
              11554 OSBYTE_0C:		VDU	23
044104 3E     0001M LD	A, val
044105 17 
044106 CD     0002M CALL	OSWRCH
044107 00 
044108 3F 
044109 04 
              11555 VDU	0
04410A 3E     0001M LD	A, val
04410B 00 
04410C CD     0002M CALL	OSWRCH
04410D 00 
04410E 3F 
04410F 04 
              11556 VDU	vdp_keystate
044110 3E     0001M LD	A, val
044111 88 
044112 CD     0002M CALL	OSWRCH
044113 00 
044114 3F 
044115 04 
              11557 VDU	0
044116 3E     0001M LD	A, val
044117 00 
044118 CD     0002M CALL	OSWRCH
044119 00 
04411A 3F 
04411B 04 
              11558 VDU 	0
04411C 3E     0001M LD	A, val
04411D 00 
04411E CD     0002M CALL	OSWRCH
04411F 00 
044120 3F 
044121 04 
              11559 VDU	L
044122 7D     0001M LD	A, val
044123 CD     0002M CALL	OSWRCH
044124 00 
044125 3F 
044126 04 
              11560 VDU	H
044127 7C     0001M LD	A, val
044128 CD     0002M CALL	OSWRCH
044129 00 
04412A 3F 
04412B 04 
              11561 VDU	255
04412C 3E     0001M LD	A, val
04412D FF 
04412E CD     0002M CALL	OSWRCH
04412F 00 
044130 3F 
044131 04 
044132 C9     11562 RET
              11563 
              11564 ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
              11565 ;
044133 CD     11566 OSBYTE_13:		CALL	WAIT_VBLANK
044134 3D 
044135 41 
044136 04 
044137 2E     11567 LD	L, 0			; Returns 0
044138 00 
044139 C3     11568 JP	COUNT0
04413A 7F 
04413B 05 
04413C 04 
              11569 ;
04413D DD     11570 WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
04413E E5 
              11571 MOSCALL	mos_sysvars		; Fetch pointer to system variables
04413F 3E     0001M LD	A, function
044140 08 
044141 49     0002M RST.LIS	08h
044142 CF 
044143 DD     11572 LD	A, (IX + sysvar_time + 0)
044144 7E 
044145 00 
044146 DD     11573 @@:			CP 	A, (IX + sysvar_time + 0)
044147 BE 
044148 00 
044149 28     11574 JR	Z, @B
04414A FB 
04414B DD     11575 POP	IX
04414C E1 
04414D C9     11576 RET
              11577 
              11578 ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
              11579 ; Parameters:
              11580 ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
              11581 ;
              11582 OSBYTE_76:		VDU	23
04414E 3E     0001M LD	A, val
04414F 17 
044150 CD     0002M CALL	OSWRCH
044151 00 
044152 3F 
044153 04 
              11583 VDU	0
044154 3E     0001M LD	A, val
044155 00 
044156 CD     0002M CALL	OSWRCH
044157 00 
044158 3F 
044159 04 
              11584 VDU	vdp_keystate
04415A 3E     0001M LD	A, val
04415B 88 
04415C CD     0002M CALL	OSWRCH
04415D 00 
04415E 3F 
04415F 04 
              11585 VDU	0
044160 3E     0001M LD	A, val
044161 00 
044162 CD     0002M CALL	OSWRCH
044163 00 
044164 3F 
044165 04 
              11586 VDU 	0
044166 3E     0001M LD	A, val
044167 00 
044168 CD     0002M CALL	OSWRCH
044169 00 
04416A 3F 
04416B 04 
              11587 VDU	0
04416C 3E     0001M LD	A, val
04416D 00 
04416E CD     0002M CALL	OSWRCH
04416F 00 
044170 3F 
044171 04 
              11588 VDU	0
044172 3E     0001M LD	A, val
044173 00 
044174 CD     0002M CALL	OSWRCH
044175 00 
044176 3F 
044177 04 
              11589 VDU	L
044178 7D     0001M LD	A, val
044179 CD     0002M CALL	OSWRCH
04417A 00 
04417B 3F 
04417C 04 
04417D C9     11590 RET
              11591 
              11592 ; OSBYTE 0xA0: Fetch system variable
              11593 ; Parameters:
              11594 ; - L: The system variable to fetch
              11595 ;
04417E DD     11596 OSBYTE_A0:		PUSH	IX
04417F E5 
              11597 MOSCALL	mos_sysvars		; Fetch pointer to system variables
044180 3E     0001M LD	A, function
044181 08 
044182 49     0002M RST.LIS	08h
044183 CF 
044184 01     11598 LD	BC, 0
044185 00 
044186 00 
044187 00 
044188 4D     11599 LD	C, L			; BCU = L
044189 DD     11600 ADD	IX, BC			; Add to IX
04418A 09 
04418B DD     11601 LD	L, (IX + 0)		; Fetch the return value
04418C 6E 
04418D 00 
04418E DD     11602 POP	IX
04418F E1 
044190 C3     11603 JP 	COUNT0
044191 7F 
044192 05 
044193 04 
              11604 
              11605 ;OSLOAD - Load an area of memory from a file.
              11606 ;   Inputs: HL addresses filename (CR terminated)
              11607 ;           DE = address at which to load
              11608 ;           BC = maximum allowed size (bytes)
              11609 ;  Outputs: Carry reset indicates no room for file.
              11610 ; Destroys: A,B,C,D,E,H,L,F
              11611 ;
044194 C5     11612 OSLOAD:			PUSH	BC			; Stack the size
044195 D5     11613 PUSH	DE			; Stack the load address
044196 11     11614 LD	DE, ACCS		; Buffer address for filename
044197 00 
044198 4A 
044199 04 
04419A CD     11615 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04419B 19 
04419C 3E 
04419D 04 
04419E 21     11616 LD	HL, ACCS		; HL: Filename
04419F 00 
0441A0 4A 
0441A1 04 
0441A2 CD     11617 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441A3 94 
0441A4 42 
0441A5 04 
0441A6 CD     11618 CALL	EXT_HANDLER		; Get the default handler
0441A7 A8 
0441A8 42 
0441A9 04 
0441AA D1     11619 POP	DE			; Restore the load address
0441AB C1     11620 POP	BC			; Restore the size
0441AC B7     11621 OR	A
0441AD 28     11622 JR 	Z, OSLOAD_BBC
0441AE 60 
              11623 ;
              11624 ; Load the file in as a text file
              11625 ;
0441AF AF     11626 OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441B0 CD     11627 CALL	OSOPEN			; Open the file
0441B1 1C 
0441B2 43 
0441B3 04 
0441B4 5F     11628 LD 	E, A 			; The filehandle
0441B5 B7     11629 OR	A
0441B6 3E     11630 LD	A, 4			; File not found error
0441B7 04 
0441B8 28     11631 JR	Z, OSERROR		; Jump to error handler
0441B9 5D 
0441BA CD     11632 CALL	NEWIT			; Call NEW to clear the program space
0441BB 6C 
0441BC 38 
0441BD 04 
              11633 ;
0441BE 21     11634 OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0441BF 00 
0441C0 4A 
0441C1 04 
              11635 ;
              11636 ; First skip any whitespace (indents) at the beginning of the input
              11637 ;
0441C2 CD     11638 @@:			CALL	OSBGET			; Read the byte into A
0441C3 33 
0441C4 43 
0441C5 04 
0441C6 38     11639 JR	C, OSLOAD_TXT3		; Is it EOF?
0441C7 1E 
0441C8 FE     11640 CP	LF 			; Is it LF?
0441C9 0A 
0441CA 28     11641 JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0441CB 1A 
0441CC FE     11642 CP	21h			; Is it less than or equal to ASCII space?
0441CD 21 
0441CE 38     11643 JR	C, @B 			; Yes, so keep looping
0441CF F2 
0441D0 77     11644 LD	(HL), A 		; Store the first character
0441D1 2C     11645 INC	L
              11646 ;
              11647 ; Now read the rest of the line in
              11648 ;
0441D2 CD     11649 OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0441D3 33 
0441D4 43 
0441D5 04 
0441D6 38     11650 JR	C, OSLOAD_TXT4		; Is it EOF?
0441D7 2B 
0441D8 FE     11651 CP	20h			; Skip if not an ASCII character
0441D9 20 
0441DA 38     11652 JR	C, @F
0441DB 06 
0441DC 77     11653 LD	(HL), A 		; Store in the input buffer
0441DD 2C     11654 INC	L			; Increment the buffer pointer
0441DE CA     11655 JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0441DF F8 
0441E0 36 
0441E1 04 
0441E2 FE     11656 @@:			CP	LF			; Check for LF
0441E3 0A 
0441E4 20     11657 JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0441E5 EC 
              11658 ;
              11659 ; Finally, handle EOL/EOF
              11660 ;
0441E6 36     11661 OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0441E7 0D 
0441E8 7D     11662 LD	A, L			; Check for minimum line length
0441E9 FE     11663 CP	2			; If it is 2 characters or less (including CR)
0441EA 02 
0441EB 38     11664 JR	C, @F			; Then don't bother entering it
0441EC 0A 
0441ED D5     11665 PUSH	DE			; Preserve the filehandle
0441EE CD     11666 CALL	ONEDIT1			; Enter the line in memory
0441EF DC 
0441F0 30 
0441F1 04 
0441F2 DC     11667 CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0441F3 3F 
0441F4 38 
0441F5 04 
0441F6 D1     11668 POP	DE
0441F7 CD     11669 @@:			CALL	OSSTAT			; End of file?
0441F8 44 
0441F9 43 
0441FA 04 
0441FB 20     11670 JR	NZ, OSLOAD_TXT1		; No, so loop
0441FC C1 
0441FD CD     11671 CALL	OSSHUT			; Close the file
0441FE 2B 
0441FF 43 
044200 04 
044201 37     11672 SCF				; Flag to BASIC that we're good
044202 C9     11673 RET
              11674 ;
              11675 ; Special case for BASIC programs with no blank line at the end
              11676 ;
044203 FE     11677 OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044204 20 
044205 38     11678 JR	C, @F
044206 06 
044207 77     11679 LD	(HL), A			; Store the character
044208 2C     11680 INC	L
044209 CA     11681 JP	Z, BAD
04420A F8 
04420B 36 
04420C 04 
04420D 18     11682 @@:			JR	OSLOAD_TXT3
04420E D7 
              11683 
              11684 ;
              11685 ; Load the file in as a tokenised binary blob
              11686 ;
              11687 OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
04420F 3E     0001M LD	A, function
044210 01 
044211 49     0002M RST.LIS	08h
044212 CF 
044213 D0     11688 RET	NC			; If load returns with carry reset - NO ROOM
044214 B7     11689 OR	A			; If there is no error (A=0)
044215 37     11690 SCF				; Need to set carry indicating there was room
044216 C8     11691 RET	Z			; Return
              11692 ;
044217 F5     11693 OSERROR:		PUSH	AF			; Handle the MOS error
044218 21     11694 LD	HL, ACCS		; Address of the buffer
044219 00 
04421A 4A 
04421B 04 
04421C 01     11695 LD	BC, 256			; Length of the buffer
04421D 00 
04421E 01 
04421F 00 
044220 5F     11696 LD	E, A			; The error code
              11697 MOSCALL	mos_getError		; Copy the error message into the buffer
044221 3E     0001M LD	A, function
044222 0F 
044223 49     0002M RST.LIS	08h
044224 CF 
044225 F1     11698 POP	AF
044226 E5     11699 PUSH	HL			; Stack the address of the error (now in ACCS)
044227 C6     11700 ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044228 7F 
044229 C3     11701 JP	EXTERR			; Trigger an external error
04422A 77 
04422B 37 
04422C 04 
              11702 
              11703 ;OSSAVE - Save an area of memory to a file.
              11704 ;   Inputs: HL addresses filename (term CR)
              11705 ;           DE = start address of data to save
              11706 ;           BC = length of data to save (bytes)
              11707 ; Destroys: A,B,C,D,E,H,L,F
              11708 ;
04422D C5     11709 OSSAVE:			PUSH	BC			; Stack the size
04422E D5     11710 PUSH	DE			; Stack the save address
04422F 11     11711 LD	DE, ACCS		; Buffer address for filename
044230 00 
044231 4A 
044232 04 
044233 CD     11712 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044234 19 
044235 3E 
044236 04 
044237 21     11713 LD	HL, ACCS		; HL: Filename
044238 00 
044239 4A 
04423A 04 
04423B CD     11714 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04423C 94 
04423D 42 
04423E 04 
04423F CD     11715 CALL	EXT_HANDLER		; Get the default handler
044240 A8 
044241 42 
044242 04 
044243 D1     11716 POP	DE			; Restore the save address
044244 C1     11717 POP	BC			; Restore the size
044245 B7     11718 OR	A			; Is the extension .BBC
044246 28     11719 JR	Z, OSSAVE_BBC		; Yes, so use that
044247 44 
              11720 ;
              11721 ; Save the file out as a text file
              11722 ;
044248 3A     11723 OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
044249 45 
04424A 4D 
04424B 04 
04424C F5     11724 PUSH	AF
04424D AF     11725 XOR	A
04424E 3C     11726 INC	A			; Make sure C is clear, A is 1, for OPENOUT
04424F 32     11727 LD	(OSWRCHCH), A
044250 45 
044251 4D 
044252 04 
044253 CD     11728 CALL	OSOPEN			; Open the file
044254 1C 
044255 43 
044256 04 
044257 32     11729 LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
044258 46 
044259 4D 
04425A 04 
04425B DD     11730 LD	IX, LISTON		; Required for LISTIT
04425C 21 
04425D 40 
04425E 4D 
04425E 04   
044260 2A     11731 LD	HL, (PAGE_)		; Get start of program area
044261 14 
044262 4D 
044263 04 
044264 D9     11732 EXX
044265 01     11733 LD	BC, 0			; Set the initial indent counters
044266 00 
044267 00 
044268 00 
044269 D9     11734 EXX
04426A 7E     11735 OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
04426B B7     11736 OR	A
04426C 28     11737 JR	Z, OSSAVE_TXT2
04426D 0F 
04426E 23     11738 INC	HL			; Skip the length byte
04426F 11     11739 LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
044270 00 
044271 00 
044272 00 
044273 5E     11740 LD	E, (HL)			; Get the line number
044274 23     11741 INC	HL
044275 56     11742 LD	D, (HL)
044276 23     11743 INC	HL
044277 CD     11744 CALL	LISTIT			; List the line
044278 92 
044279 38 
04427A 04 
04427B 18     11745 JR	OSSAVE_TXT1
04427C ED 
04427D 3A     11746 OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
04427E 46 
04427F 4D 
044280 04 
044281 5F     11747 LD	E, A
044282 CD     11748 CALL	OSSHUT			; Close it
044283 2B 
044284 43 
044285 04 
044286 F1     11749 POP	AF			; Restore the channel
044287 32     11750 LD	(OSWRCHCH), A
044288 45 
044289 4D 
04428A 04 
04428B C9     11751 RET
              11752 ;
              11753 ; Save the file out as a tokenised binary blob
              11754 ;
              11755 OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
04428C 3E     0001M LD	A, function
04428D 02 
04428E 49     0002M RST.LIS	08h
04428F CF 
044290 B7     11756 OR	A			; If there is no error (A=0)
044291 C8     11757 RET	Z			; Just return
044292 18     11758 JR	OSERROR			; Trip an error
044293 83 
              11759 
              11760 ; Check if an extension is specified in the filename
              11761 ; Add a default if not specified
              11762 ; HL: Filename (CSTR format)
              11763 ;
044294 E5     11764 EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044295 0E     11765 LD	C, '.'			; Search for dot (marks start of extension)
044296 2E 
044297 CD     11766 CALL	CSTR_FINDCH
044298 39 
044299 3E 
04429A 04 
04429B B7     11767 OR	A			; Check for end of string marker
04429C 20     11768 JR	NZ, @F			; No, so skip as we have an extension at this point
04429D 08 
04429E 11     11769 LD	DE, EXT_LOOKUP		; Get the first (default extension)
04429F D8 
0442A0 42 
0442A1 04 
0442A2 CD     11770 CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442A3 50 
0442A4 3E 
0442A5 04 
0442A6 E1     11771 @@:			POP	HL			; Restore the filename pointer
0442A7 C9     11772 RET
              11773 
              11774 ; Check if an extension is valid and, if so, provide a pointer to a handler
              11775 ; HL: Filename (CSTR format)
              11776 ; Returns:
              11777 ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
              11778 ;
0442A8 E5     11779 EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442A9 0E     11780 LD	C, '.'			; Find the '.'
0442AA 2E 
0442AB CD     11781 CALL	CSTR_FINDCH
0442AC 39 
0442AD 3E 
0442AE 04 
0442AF 11     11782 LD	DE, EXT_LOOKUP		; The lookup table
0442B0 D8 
0442B1 42 
0442B2 04 
              11783 ;
0442B3 E5     11784 EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442B4 CD     11785 CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442B5 41 
0442B6 3E 
0442B7 04 
0442B8 E1     11786 POP	HL			; Restore the pointer to the extension
0442B9 28     11787 JR	Z, EXT_HANDLER_2	; We have a match!
0442BA 19 
              11788 ;
0442BB 1A     11789 @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0442BC 13     11790 INC	DE
0442BD B7     11791 OR	A
0442BE 20     11792 JR	NZ, @B
0442BF FB 
0442C0 13     11793 INC	DE			; Skip the file extension # byte
              11794 ;
0442C1 1A     11795 LD	A, (DE)			; Are we at the end of the table?
0442C2 B7     11796 OR	A
0442C3 20     11797 JR	NZ, EXT_HANDLER_1	; No, so loop
0442C4 EE 
              11798 ;
0442C5 3E     11799 LD      A,204			; Throw a "Bad name" error
0442C6 CC 
0442C7 CD     11800 CALL    EXTERR
0442C8 77 
0442C9 37 
0442CA 04 
0442CB 42     11801 DB    	"Bad name", 0
0442CC 61 
0442CD 64 
0442CE 20 
0442CE 6E   
0442CF 61 
0442D0 6D 
0442D1 65 
0442D1 00   
              11802 ;
0442D4 13     11803 EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0442D5 1A     11804 LD	A, (DE)
0442D6 E1     11805 POP	HL			; Restore the filename pointer
0442D7 C9     11806 RET
              11807 ;
              11808 
              11809 
              11810 ; Extension lookup table
              11811 ; CSTR, TYPE
              11812 ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
              11813 ; 	- 1: Human readable plain text
              11814 ;
0442D8 2E     11815 EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
0442D9 42 
0442DA 42 
0442DB 43 
0442DB 00   
0442DC 00 
0442DE 2E     11816 DB	".TXT", 0, 1
0442DF 54 
0442E0 58 
0442E1 54 
0442E1 00   
0442E2 01 
0442E4 2E     11817 DB	".ASC", 0, 1
0442E5 41 
0442E6 53 
0442E7 43 
0442E7 00   
0442E8 01 
0442EA 2E     11818 DB	".BAS", 0, 1
0442EB 42 
0442EC 41 
0442ED 53 
0442ED 00   
0442EE 01 
0442F0 00     11819 DB	0			; End of table
              11820 
              11821 ;OSCALL - Intercept page &FF calls and provide an alternative address
              11822 ;
              11823 ;&FFF7:	OSCLI	Execute *command.
              11824 ;&FFF4:	OSBYTE	Various byte-wide functions.
              11825 ;&FFF1:	OSWORD	Various control block functions.
              11826 ;&FFEE:	OSWRCH	Write character to output stream.
              11827 ;&FFE7:	OSNEWL	Write NewLine to output stream.
              11828 ;&FFE3:	OSASCI	Write character or NewLine to output stream.
              11829 ;&FFE0:	OSRDCH	Wait for character from input stream.
              11830 ;&FFDD:	OSFILE	Perform actions on whole files or directories.
              11831 ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
              11832 ;&FFD7:	OSBGET	Read a byte from an a channel.
              11833 ;&FFD4:	OSBPUT	Write a byte to a channel.
              11834 ;&FFD1:	OSGBPB	Read and write blocks of data.
              11835 ;&FFCE:	OSFIND	Open or close a file.
              11836 ;
0442F1 21     11837 OSCALL:			LD	HL, OSCALL_TABLE
0442F2 07 
0442F3 43 
0442F4 04 
0442F5 7E     11838 OSCALL_1:		LD	A, (HL)
0442F6 23     11839 INC	HL
0442F7 FE     11840 CP	FFh
0442F8 FF 
0442F9 C8     11841 RET	Z
0442FA FD     11842 CP	A, IYL
0442FB BD 
0442FC 28     11843 JR	Z, OSCALL_2
0442FD 06 
0442FE D0     11844 RET	NC
0442FF 23     11845 INC	HL
044300 23     11846 INC	HL
044301 23     11847 INC	HL
044302 18     11848 JR	OSCALL_1
044303 F1 
044304 ED     11849 OSCALL_2:		LD	IY,(HL)
044305 31 
044306 C9     11850 RET
044307 D4     11851 OSCALL_TABLE:		DB 	D4h
044308 3B     11852 DW24 	OSBPUT
044309 43 
04430A 04 
04430B D7     11853 DB 	D7h
04430C 33     11854 DW24 	OSBGET
04430D 43 
04430E 04 
04430F EE     11855 DB 	EEh
044310 00     11856 DW24 	OSWRCH
044311 3F 
044312 04 
044313 F4     11857 DB	F4h
044314 B9     11858 DW24 	OSBYTE
044315 40 
044316 04 
044317 F7     11859 DB	F7h
044318 90     11860 DW24	OSCLI
044319 3F 
04431A 04 
04431B FF     11861 DB	FFh
              11862 
              11863 ; OSOPEN
              11864 ; HL: Pointer to path
              11865 ;  F: C Z
              11866 ;     x x OPENIN
              11867 ; 	  OPENOUT
              11868 ;     x	  OPENUP
              11869 ; Returns:
              11870 ;  A: Filehandle, 0 if cannot open
              11871 ;
04431C 0E     11872 OSOPEN:			LD	C, fa_read
04431D 01 
04431E 28     11873 JR	Z, @F
04431F 06 
044320 0E     11874 LD	C, fa_write | fa_open_append
044321 32 
044322 38     11875 JR	C, @F
044323 02 
044324 0E     11876 LD	C, fa_write | fa_create_always
044325 0A 
              11877 @@:			MOSCALL	mos_fopen
044326 3E     0001M LD	A, function
044327 0A 
044328 49     0002M RST.LIS	08h
044329 CF 
04432A C9     11878 RET
              11879 
              11880 ;OSSHUT - Close disk file(s).
              11881 ; E = file channel
              11882 ;  If E=0 all files are closed (except SPOOL)
              11883 ; Destroys: A,B,C,D,E,H,L,F
              11884 ;
04432B C5     11885 OSSHUT:			PUSH	BC
04432C 4B     11886 LD	C, E
              11887 MOSCALL	mos_fclose
04432D 3E     0001M LD	A, function
04432E 0B 
04432F 49     0002M RST.LIS	08h
044330 CF 
044331 C1     11888 POP	BC
044332 C9     11889 RET
              11890 
              11891 ; OSBGET - Read a byte from a random disk file.
              11892 ;  E = file channel
              11893 ; Returns
              11894 ;  A = byte read
              11895 ;  Carry set if LAST BYTE of file
              11896 ; Destroys: A,B,C,F
              11897 ;
044333 C5     11898 OSBGET:			PUSH	BC
044334 4B     11899 LD	C, E
              11900 MOSCALL	mos_fgetc
044335 3E     0001M LD	A, function
044336 0C 
044337 49     0002M RST.LIS	08h
044338 CF 
044339 C1     11901 POP	BC
04433A C9     11902 RET
              11903 
              11904 ; OSBPUT - Write a byte to a random disk file.
              11905 ;  E = file channel
              11906 ;  A = byte to write
              11907 ; Destroys: A,B,C,F
              11908 ;
04433B C5     11909 OSBPUT:			PUSH	BC
04433C 4B     11910 LD	C, E
04433D 47     11911 LD	B, A
              11912 MOSCALL	mos_fputc
04433E 3E     0001M LD	A, function
04433F 0D 
044340 49     0002M RST.LIS	08h
044341 CF 
044342 C1     11913 POP	BC
044343 C9     11914 RET
              11915 
              11916 ; OSSTAT - Read file status
              11917 ;  E = file channel
              11918 ; Returns
              11919 ;  F: Z flag set - EOF
              11920 ;  A: If Z then A = 0
              11921 ; Destroys: A,D,E,H,L,F
              11922 ;
044344 C5     11923 OSSTAT:			PUSH	BC
044345 4B     11924 LD	C, E
              11925 MOSCALL	mos_feof
044346 3E     0001M LD	A, function
044347 0E 
044348 49     0002M RST.LIS	08h
044349 CF 
04434A C1     11926 POP	BC
04434B FE     11927 CP	1
04434C 01 
04434D C9     11928 RET
              11929 
              11930 ; GETPTR - Return file pointer.
              11931 ;    E = file channel
              11932 ; Returns:
              11933 ; DEHL = pointer (0-&7FFFFF)
              11934 ; Destroys: A,B,C,D,E,H,L,F
              11935 ;
04434E FD     11936 GETPTR:			PUSH		IY
04434F E5 
044350 4B     11937 LD		C, E
              11938 MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044351 3E     0001M LD	A, function
044352 19 
044353 49     0002M RST.LIS	08h
044354 CF 
044355 E5     11939 PUSH		HL
044356 FD     11940 POP		IY		; IYU: Pointer to FIL structure
044357 E1 
044358 FD     11941 LD		L, (IY + FIL.fptr + 0)
044359 6E 
04435A 11 
04435B FD     11942 LD		H, (IY + FIL.fptr + 1)
04435C 66 
04435D 12 
04435E FD     11943 LD		E, (IY + FIL.fptr + 2)
04435F 5E 
044360 13 
044361 FD     11944 LD		D, (IY + FIL.fptr + 3)
044362 56 
044363 14 
044364 FD     11945 POP		IY
044365 E1 
044366 C9     11946 RET
              11947 
              11948 ; PUTPTR - Update file pointer.
              11949 ;    A = file channel
              11950 ; DEHL = new pointer (0-&7FFFFF)
              11951 ; Destroys: A,B,C,D,E,H,L,F
              11952 ;
044367 FD     11953 PUTPTR:			PUSH		IY
044368 E5 
044369 4F     11954 LD		C, A  		; C: Filehandle
04436A E5     11955 PUSH		HL
04436B 21     11956 LD		HL, 2
04436C 02 
04436D 00 
04436E 00 
04436F 39     11957 ADD		HL, SP
044370 73     11958 LD		(HL), E 	; 3rd byte of DWORD set to E
044371 E1     11959 POP		HL
044372 5A     11960 LD		E, D  		; 4th byte passed as E
              11961 MOSCALL		mos_flseek
044373 3E     0001M LD	A, function
044374 1C 
044375 49     0002M RST.LIS	08h
044376 CF 
044377 FD     11962 POP		IY
044378 E1 
044379 C9     11963 RET
              11964 
              11965 ; GETEXT - Find file size.
              11966 ;    E = file channel
              11967 ; Returns:
              11968 ; DEHL = file size (0-&800000)
              11969 ; Destroys: A,B,C,D,E,H,L,F
              11970 ;
04437A FD     11971 GETEXT:         PUSH    IY
04437B E5 
04437C 4B     11972 LD      C, E
              11973 MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
04437D 3E     0001M LD	A, function
04437E 19 
04437F 49     0002M RST.LIS	08h
044380 CF 
044381 E5     11974 PUSH    HL
044382 FD     11975 POP     IY          ; IYU: Pointer to FIL structure
044383 E1 
              11976 ; Access the obj.objsize field using the offset values
044384 FD     11977 LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
044385 6E 
044386 0B 
044387 FD     11978 LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
044388 66 
044389 0C 
04438A FD     11979 LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
04438B 5E 
04438C 0D 
04438D FD     11980 LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
04438E 56 
04438F 0E 
              11981 
044390 FD     11982 POP     IY
044391 E1 
044392 C9     11983 RET
              11984 
              11985 ; GETIMS - Get time from RTC
              11986 ;
044393 FD     11987 GETIMS:			PUSH	IY
044394 E5 
044395 21     11988 LD	HL, ACCS 		; Where to store the time string
044396 00 
044397 4A 
044398 04 
              11989 MOSCALL	mos_getrtc
044399 3E     0001M LD	A, function
04439A 12 
04439B 49     0002M RST.LIS	08h
04439C CF 
04439D 11     11990 LD	DE, ACCS		; DE: pointer to start of string accumulator
04439E 00 
04439F 4A 
0443A0 04 
0443A1 5F     11991 LD	E, A 			;  E: now points to the end of the string
0443A2 FD     11992 POP	IY
0443A3 E1 
0443A4 C9     11993 RET
              11994 
              11995 ; Get two word values from EXPR in DE, HL
              11996 ; IY: Pointer to expression string
              11997 ; Returns:
              11998 ; DE: P1
              11999 ; HL: P2
              12000 ;
0443A5 CD     12001 EXPR_W2:		CALL	EXPRI			; Get first parameter
0443A6 0A 
0443A7 03 
0443A8 04 
0443A9 D9     12002 EXX
0443AA E5     12003 PUSH	HL
0443AB CD     12004 CALL	COMMA
0443AC 22 
0443AD 0A 
0443AE 04 
0443AF CD     12005 CALL	EXPRI			; Get second parameter
0443B0 0A 
0443B1 03 
0443B2 04 
0443B3 D9     12006 EXX
0443B4 D1     12007 POP	DE
0443B5 C9     12008 RET
              12009 
              12010 ; Stuff not implemented yet
              12011 ;
0443B6 C9     12012 RESET:			RET; --- End patch.asm ---
              12013 
              12014 ; --- Begin sorry.asm ---
              12015 ;
              12016 ; Title:	BBC Basic Interpreter - Z80 version
              12017 ;		Catch-all for unimplemented functionality
              12018 ; Author:	Dean Belfield
              12019 ; Created:	12/05/2023
              12020 ; Last Updated:	12/05/2023
              12021 ;
              12022 ; Modinfo:
              12023 
              12024 ; .ASSUME	ADL = 1
              12025 
              12026 ; SEGMENT CODE
              12027 
              12028 ; XDEF	ENVEL
              12029 ; XDEF	ADVAL
              12030 ; XDEF	PUTIMS
              12031 
              12032 ; XREF	EXTERR
              12033 
              12034 ENVEL:
              12035 ADVAL:
              12036 PUTIMS:
0443B7 AF     12037 XOR     A
0443B8 CD     12038 CALL    EXTERR
0443B9 77 
0443BA 37 
0443BB 04 
0443BC 53     12039 DEFB    "Sorry"
0443BD 6F 
0443BE 72 
0443BF 72 
0443BF 79   
0443C1 00     12040 DEFB    0
              12041 ; --- End sorry.asm ---
              12042 
              12043 ; --- Begin agon_graphics.asm ---
              12044 ;
              12045 ; Title:	BBC Basic for AGON - Graphics stuff
              12046 ; Author:	Dean Belfield
              12047 ; Created:	12/05/2023
              12048 ; Last Updated:	07/06/2023
              12049 ;
              12050 ; Modinfo:
              12051 ; 07/06/2023:	Modified to run in ADL mode
              12052 
              12053 ; .ASSUME	ADL = 1
              12054 
              12055 ; INCLUDE	"equs.inc"
              12056 ; INCLUDE "macros.inc"
              12057 ; INCLUDE "mos_api.inc"	; In MOS/src
              12058 
              12059 ; SEGMENT CODE
              12060 
              12061 ; XDEF	CLG
              12062 ; XDEF	CLRSCN
              12063 ; XDEF	MODE
              12064 ; XDEF	COLOUR
              12065 ; XDEF	GCOL
              12066 ; XDEF	MOVE
              12067 ; XDEF	PLOT
              12068 ; XDEF	DRAW
              12069 ; XDEF	POINT
              12070 ; XDEF	GETSCHR
              12071 
              12072 ; XREF	OSWRCH
              12073 ; XREF	ASC_TO_NUMBER
              12074 ; XREF	EXTERR
              12075 ; XREF	EXPRI
              12076 ; XREF	COMMA
              12077 ; XREF	XEQ
              12078 ; XREF	NXT
              12079 ; XREF	BRAKET
              12080 ; XREF	COUNT0
              12081 ; XREF	CRTONULL
              12082 ; XREF	NULLTOCR
              12083 ; XREF	CRLF
              12084 ; XREF	EXPR_W2
              12085 ; XREF	INKEY1
              12086 
              12087 ; CLG: clears the graphics area
              12088 ;
              12089 CLG:
              12090 
              12091 VDU	10h
0443C2 3E     0001M LD	A, val
0443C3 10 
0443C4 CD     0002M CALL	OSWRCH
0443C5 00 
0443C6 3F 
0443C7 04 
0443C8 C3     12092 JP	XEQ
0443C9 96 
0443CA 0B 
0443CB 04 
              12093 
              12094 ; CLS: clears the text area
              12095 ;
0443CC 3E     12096 CLRSCN:			LD	A, 0Ch
0443CD 0C 
0443CE C3     12097 JP	OSWRCH
0443CF 00 
0443D0 3F 
0443D1 04 
              12098 
              12099 ; MODE n: Set video mode
              12100 ;
0443D2 DD     12101 MODE:			PUSH	IX			; Get the system vars in IX
0443D3 E5 
              12102 MOSCALL	mos_sysvars		; Reset the semaphore
0443D4 3E     0001M LD	A, function
0443D5 08 
0443D6 49     0002M RST.LIS	08h
0443D7 CF 
0443D8 DD     12103 RES	4, (IX+sysvar_vpd_pflags)
0443D9 CB 
0443DA 04 
0443DB A6 
0443DC CD     12104 CALL    EXPRI
0443DD 0A 
0443DE 03 
0443DF 04 
0443E0 D9     12105 EXX
              12106 VDU	16H			; Mode change
0443E1 3E     0001M LD	A, val
0443E2 16 
0443E3 CD     0002M CALL	OSWRCH
0443E4 00 
0443E5 3F 
0443E6 04 
              12107 VDU	L
0443E7 7D     0001M LD	A, val
0443E8 CD     0002M CALL	OSWRCH
0443E9 00 
0443EA 3F 
0443EB 04 
              12108 MOSCALL	mos_sysvars
0443EC 3E     0001M LD	A, function
0443ED 08 
0443EE 49     0002M RST.LIS	08h
0443EF CF 
0443F0 DD     12109 @@:			BIT	4, (IX+sysvar_vpd_pflags)
0443F1 CB 
0443F2 04 
0443F3 66 
0443F4 28     12110 JR	Z, @B			; Wait for the result
0443F5 FA 
0443F6 DD     12111 POP	IX
0443F7 E1 
0443F8 C3     12112 JP	XEQ
0443F9 96 
0443FA 0B 
0443FB 04 
              12113 
              12114 ; GET(x,y): Get the ASCII code of a character on screen
              12115 ;
0443FC FD     12116 GETSCHR:		INC	IY
0443FD 23 
0443FE CD     12117 CALL    EXPRI      		; Get X coordinate
0443FF 0A 
044400 03 
044401 04 
044402 D9     12118 EXX
044403 22     12119 LD	(VDU_BUFFER+0), HL
044404 00 
044405 4A 
044406 04 
044407 CD     12120 CALL	COMMA
044408 22 
044409 0A 
04440A 04 
04440B CD     12121 CALL	EXPRI			; Get Y coordinate
04440C 0A 
04440D 03 
04440E 04 
04440F D9     12122 EXX
044410 22     12123 LD	(VDU_BUFFER+2), HL
044411 02 
044412 4A 
044413 04 
044414 CD     12124 CALL	BRAKET			; Closing bracket
044415 2F 
044416 0A 
044417 04 
              12125 ;
044418 DD     12126 PUSH	IX			; Get the system vars in IX
044419 E5 
              12127 MOSCALL	mos_sysvars		; Reset the semaphore
04441A 3E     0001M LD	A, function
04441B 08 
04441C 49     0002M RST.LIS	08h
04441D CF 
04441E DD     12128 RES	1, (IX+sysvar_vpd_pflags)
04441F CB 
044420 04 
044421 8E 
              12129 VDU	23
044422 3E     0001M LD	A, val
044423 17 
044424 CD     0002M CALL	OSWRCH
044425 00 
044426 3F 
044427 04 
              12130 VDU	0
044428 3E     0001M LD	A, val
044429 00 
04442A CD     0002M CALL	OSWRCH
04442B 00 
04442C 3F 
04442D 04 
              12131 VDU	vdp_scrchar
04442E 3E     0001M LD	A, val
04442F 83 
044430 CD     0002M CALL	OSWRCH
044431 00 
044432 3F 
044433 04 
              12132 VDU	(VDU_BUFFER+0)
044434 3A     0001M LD	A, val
044435 00 
044436 4A 
044437 04 
044438 CD     0002M CALL	OSWRCH
044439 00 
04443A 3F 
04443B 04 
              12133 VDU	(VDU_BUFFER+1)
04443C 3A     0001M LD	A, val
04443D 01 
04443E 4A 
04443F 04 
044440 CD     0002M CALL	OSWRCH
044441 00 
044442 3F 
044443 04 
              12134 VDU	(VDU_BUFFER+2)
044444 3A     0001M LD	A, val
044445 02 
044446 4A 
044447 04 
044448 CD     0002M CALL	OSWRCH
044449 00 
04444A 3F 
04444B 04 
              12135 VDU	(VDU_BUFFER+3)
04444C 3A     0001M LD	A, val
04444D 03 
04444E 4A 
04444F 04 
044450 CD     0002M CALL	OSWRCH
044451 00 
044452 3F 
044453 04 
044454 DD     12136 @@:			BIT	1, (IX+sysvar_vpd_pflags)
044455 CB 
044456 04 
044457 4E 
044458 28     12137 JR	Z, @B			; Wait for the result
044459 FA 
04445A DD     12138 LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
04445B 7E 
04445C 09 
04445D B7     12139 OR	A			; Check for 00h
04445E 37     12140 SCF				; C = character map
04445F 20     12141 JR	NZ, @F			; We have a character, so skip next bit
044460 02 
044461 AF     12142 XOR	A			; Clear carry
044462 3D     12143 DEC	A			; Set A to FFh
044463 DD     12144 @@:			POP	IX
044464 E1 
044465 C3     12145 JP	INKEY1			; Jump back to the GET command
044466 E1 
044467 07 
044468 04 
              12146 
              12147 ; POINT(x,y): Get the pixel colour of a point on screen
              12148 ;
044469 CD     12149 POINT:			CALL    EXPRI      		; Get X coordinate
04446A 0A 
04446B 03 
04446C 04 
04446D D9     12150 EXX
04446E 22     12151 LD	(VDU_BUFFER+0), HL
04446F 00 
044470 4A 
044471 04 
044472 CD     12152 CALL	COMMA
044473 22 
044474 0A 
044475 04 
044476 CD     12153 CALL	EXPRI			; Get Y coordinate
044477 0A 
044478 03 
044479 04 
04447A D9     12154 EXX
04447B 22     12155 LD	(VDU_BUFFER+2), HL
04447C 02 
04447D 4A 
04447E 04 
04447F CD     12156 CALL	BRAKET			; Closing bracket
044480 2F 
044481 0A 
044482 04 
              12157 ;
044483 DD     12158 PUSH	IX			; Get the system vars in IX
044484 E5 
              12159 MOSCALL	mos_sysvars		; Reset the semaphore
044485 3E     0001M LD	A, function
044486 08 
044487 49     0002M RST.LIS	08h
044488 CF 
044489 DD     12160 RES	2, (IX+sysvar_vpd_pflags)
04448A CB 
04448B 04 
04448C 96 
              12161 VDU	23
04448D 3E     0001M LD	A, val
04448E 17 
04448F CD     0002M CALL	OSWRCH
044490 00 
044491 3F 
044492 04 
              12162 VDU	0
044493 3E     0001M LD	A, val
044494 00 
044495 CD     0002M CALL	OSWRCH
044496 00 
044497 3F 
044498 04 
              12163 VDU	vdp_scrpixel
044499 3E     0001M LD	A, val
04449A 84 
04449B CD     0002M CALL	OSWRCH
04449C 00 
04449D 3F 
04449E 04 
              12164 VDU	(VDU_BUFFER+0)
04449F 3A     0001M LD	A, val
0444A0 00 
0444A1 4A 
0444A2 04 
0444A3 CD     0002M CALL	OSWRCH
0444A4 00 
0444A5 3F 
0444A6 04 
              12165 VDU	(VDU_BUFFER+1)
0444A7 3A     0001M LD	A, val
0444A8 01 
0444A9 4A 
0444AA 04 
0444AB CD     0002M CALL	OSWRCH
0444AC 00 
0444AD 3F 
0444AE 04 
              12166 VDU	(VDU_BUFFER+2)
0444AF 3A     0001M LD	A, val
0444B0 02 
0444B1 4A 
0444B2 04 
0444B3 CD     0002M CALL	OSWRCH
0444B4 00 
0444B5 3F 
0444B6 04 
              12167 VDU	(VDU_BUFFER+3)
0444B7 3A     0001M LD	A, val
0444B8 03 
0444B9 4A 
0444BA 04 
0444BB CD     0002M CALL	OSWRCH
0444BC 00 
0444BD 3F 
0444BE 04 
0444BF DD     12168 @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444C0 CB 
0444C1 04 
0444C2 56 
0444C3 28     12169 JR	Z, @B			; Wait for the result
0444C4 FA 
              12170 ;
              12171 ; Return the data as a 1 byte index
              12172 ;
0444C5 DD     12173 LD	L, (IX+sysvar_scrpixelIndex)
0444C6 6E 
0444C7 16 
0444C8 DD     12174 POP	IX
0444C9 E1 
0444CA C3     12175 JP	COUNT0
0444CB 7F 
0444CC 05 
0444CD 04 
              12176 
              12177 
              12178 ; COLOUR colour
              12179 ; COLOUR L,P
              12180 ; COLOUR L,R,G,B
              12181 ;
0444CE CD     12182 COLOUR:			CALL	EXPRI			; The colour / mode
0444CF 0A 
0444D0 03 
0444D1 04 
0444D2 D9     12183 EXX
0444D3 7D     12184 LD	A, L
0444D4 32     12185 LD	(VDU_BUFFER+0), A	; Store first parameter
0444D5 00 
0444D6 4A 
0444D7 04 
0444D8 CD     12186 CALL	NXT			; Are there any more parameters?
0444D9 70 
0444DA 0A 
0444DB 04 
0444DC FE     12187 CP	','
0444DD 2C 
0444DE 28     12188 JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0444DF 12 
              12189 ;
              12190 VDU	11h			; Just set the colour
0444E0 3E     0001M LD	A, val
0444E1 11 
0444E2 CD     0002M CALL	OSWRCH
0444E3 00 
0444E4 3F 
0444E5 04 
              12191 VDU	(VDU_BUFFER+0)
0444E6 3A     0001M LD	A, val
0444E7 00 
0444E8 4A 
0444E9 04 
0444EA CD     0002M CALL	OSWRCH
0444EB 00 
0444EC 3F 
0444ED 04 
0444EE C3     12192 JP	XEQ
0444EF 96 
0444F0 0B 
0444F1 04 
              12193 ;
0444F2 CD     12194 COLOUR_1:		CALL	COMMA
0444F3 22 
0444F4 0A 
0444F5 04 
0444F6 CD     12195 CALL	EXPRI			; Parse R (OR P)
0444F7 0A 
0444F8 03 
0444F9 04 
0444FA D9     12196 EXX
0444FB 7D     12197 LD	A, L
0444FC 32     12198 LD	(VDU_BUFFER+1), A
0444FD 01 
0444FE 4A 
0444FF 04 
044500 CD     12199 CALL	NXT			; Are there any more parameters?
044501 70 
044502 0A 
044503 04 
044504 FE     12200 CP	','
044505 2C 
044506 28     12201 JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044507 2C 
              12202 ;
              12203 VDU	13h			; VDU:COLOUR
044508 3E     0001M LD	A, val
044509 13 
04450A CD     0002M CALL	OSWRCH
04450B 00 
04450C 3F 
04450D 04 
              12204 VDU	(VDU_BUFFER+0)		; Logical Colour
04450E 3A     0001M LD	A, val
04450F 00 
044510 4A 
044511 04 
044512 CD     0002M CALL	OSWRCH
044513 00 
044514 3F 
044515 04 
              12205 VDU	(VDU_BUFFER+1)		; Palette Colour
044516 3A     0001M LD	A, val
044517 01 
044518 4A 
044519 04 
04451A CD     0002M CALL	OSWRCH
04451B 00 
04451C 3F 
04451D 04 
              12206 VDU	0			; RGB set to 0
04451E 3E     0001M LD	A, val
04451F 00 
044520 CD     0002M CALL	OSWRCH
044521 00 
044522 3F 
044523 04 
              12207 VDU	0
044524 3E     0001M LD	A, val
044525 00 
044526 CD     0002M CALL	OSWRCH
044527 00 
044528 3F 
044529 04 
              12208 VDU	0
04452A 3E     0001M LD	A, val
04452B 00 
04452C CD     0002M CALL	OSWRCH
04452D 00 
04452E 3F 
04452F 04 
044530 C3     12209 JP	XEQ
044531 96 
044532 0B 
044533 04 
              12210 ;
044534 CD     12211 COLOUR_2:		CALL	COMMA
044535 22 
044536 0A 
044537 04 
044538 CD     12212 CALL	EXPRI			; Parse G
044539 0A 
04453A 03 
04453B 04 
04453C D9     12213 EXX
04453D 7D     12214 LD	A, L
04453E 32     12215 LD	(VDU_BUFFER+2), A
04453F 02 
044540 4A 
044541 04 
044542 CD     12216 CALL	COMMA
044543 22 
044544 0A 
044545 04 
044546 CD     12217 CALL	EXPRI			; Parse B
044547 0A 
044548 03 
044549 04 
04454A D9     12218 EXX
04454B 7D     12219 LD	A, L
04454C 32     12220 LD	(VDU_BUFFER+3), A
04454D 03 
04454E 4A 
04454F 04 
              12221 VDU	13h			; VDU:COLOUR
044550 3E     0001M LD	A, val
044551 13 
044552 CD     0002M CALL	OSWRCH
044553 00 
044554 3F 
044555 04 
              12222 VDU	(VDU_BUFFER+0)		; Logical Colour
044556 3A     0001M LD	A, val
044557 00 
044558 4A 
044559 04 
04455A CD     0002M CALL	OSWRCH
04455B 00 
04455C 3F 
04455D 04 
              12223 VDU	FFh			; Physical Colour (-1 for RGB mode)
04455E 3E     0001M LD	A, val
04455F FF 
044560 CD     0002M CALL	OSWRCH
044561 00 
044562 3F 
044563 04 
              12224 VDU	(VDU_BUFFER+1)		; R
044564 3A     0001M LD	A, val
044565 01 
044566 4A 
044567 04 
044568 CD     0002M CALL	OSWRCH
044569 00 
04456A 3F 
04456B 04 
              12225 VDU	(VDU_BUFFER+2)		; G
04456C 3A     0001M LD	A, val
04456D 02 
04456E 4A 
04456F 04 
044570 CD     0002M CALL	OSWRCH
044571 00 
044572 3F 
044573 04 
              12226 VDU	(VDU_BUFFER+3)		; B
044574 3A     0001M LD	A, val
044575 03 
044576 4A 
044577 04 
044578 CD     0002M CALL	OSWRCH
044579 00 
04457A 3F 
04457B 04 
04457C C3     12227 JP	XEQ
04457D 96 
04457E 0B 
04457F 04 
              12228 
              12229 ; GCOL mode,colour
              12230 ;
044580 CD     12231 GCOL:			CALL	EXPRI			; Parse MODE
044581 0A 
044582 03 
044583 04 
044584 D9     12232 EXX
044585 7D     12233 LD	A, L
044586 32     12234 LD	(VDU_BUFFER+0), A
044587 00 
044588 4A 
044589 04 
04458A CD     12235 CALL	COMMA
04458B 22 
04458C 0A 
04458D 04 
              12236 ;
04458E CD     12237 CALL	EXPRI			; Parse Colour
04458F 0A 
044590 03 
044591 04 
044592 D9     12238 EXX
044593 7D     12239 LD	A, L
044594 32     12240 LD	(VDU_BUFFER+1), A
044595 01 
044596 4A 
044597 04 
              12241 ;
              12242 VDU	12h			; VDU:GCOL
044598 3E     0001M LD	A, val
044599 12 
04459A CD     0002M CALL	OSWRCH
04459B 00 
04459C 3F 
04459D 04 
              12243 VDU	(VDU_BUFFER+0)		; Mode
04459E 3A     0001M LD	A, val
04459F 00 
0445A0 4A 
0445A1 04 
0445A2 CD     0002M CALL	OSWRCH
0445A3 00 
0445A4 3F 
0445A5 04 
              12244 VDU	(VDU_BUFFER+1)		; Colour
0445A6 3A     0001M LD	A, val
0445A7 01 
0445A8 4A 
0445A9 04 
0445AA CD     0002M CALL	OSWRCH
0445AB 00 
0445AC 3F 
0445AD 04 
0445AE C3     12245 JP	XEQ
0445AF 96 
0445B0 0B 
0445B1 04 
              12246 
              12247 ; PLOT mode,x,y
              12248 ;
0445B2 CD     12249 PLOT:			CALL	EXPRI		; Parse mode
0445B3 0A 
0445B4 03 
0445B5 04 
0445B6 D9     12250 EXX
0445B7 E5     12251 PUSH	HL		; Push mode (L) onto stack
0445B8 CD     12252 CALL	COMMA
0445B9 22 
0445BA 0A 
0445BB 04 
0445BC CD     12253 CALL	EXPR_W2		; Parse X and Y
0445BD A5 
0445BE 43 
0445BF 04 
0445C0 C1     12254 POP	BC		; Pop mode (C) off stack
              12255 PLOT_1:			VDU	19H		; VDU code for PLOT
0445C1 3E     0001M LD	A, val
0445C2 19 
0445C3 CD     0002M CALL	OSWRCH
0445C4 00 
0445C5 3F 
0445C6 04 
              12256 VDU	C		;  C: Mode
0445C7 79     0001M LD	A, val
0445C8 CD     0002M CALL	OSWRCH
0445C9 00 
0445CA 3F 
0445CB 04 
              12257 VDU	E		; DE: X
0445CC 7B     0001M LD	A, val
0445CD CD     0002M CALL	OSWRCH
0445CE 00 
0445CF 3F 
0445D0 04 
              12258 VDU	D
0445D1 7A     0001M LD	A, val
0445D2 CD     0002M CALL	OSWRCH
0445D3 00 
0445D4 3F 
0445D5 04 
              12259 VDU	L		; HL: Y
0445D6 7D     0001M LD	A, val
0445D7 CD     0002M CALL	OSWRCH
0445D8 00 
0445D9 3F 
0445DA 04 
              12260 VDU	H
0445DB 7C     0001M LD	A, val
0445DC CD     0002M CALL	OSWRCH
0445DD 00 
0445DE 3F 
0445DF 04 
0445E0 C3     12261 JP	XEQ
0445E1 96 
0445E2 0B 
0445E3 04 
              12262 
              12263 ; MOVE x,y
              12264 ;
0445E4 CD     12265 MOVE:			CALL	EXPR_W2		; Parse X and Y
0445E5 A5 
0445E6 43 
0445E7 04 
0445E8 0E     12266 LD	C, 04H		; Plot mode 04H (Move)
0445E9 04 
0445EA 18     12267 JR	PLOT_1		; Plot
0445EB D5 
              12268 
              12269 ; DRAW x1,y1
              12270 ; DRAW x1,y1,x2,y2
              12271 ;
0445EC CD     12272 DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0445ED A5 
0445EE 43 
0445EF 04 
0445F0 CD     12273 CALL	NXT		; Are there any more parameters?
0445F1 70 
0445F2 0A 
0445F3 04 
0445F4 FE     12274 CP	','
0445F5 2C 
0445F6 0E     12275 LD	C, 05h		; Code for LINE
0445F7 05 
0445F8 20     12276 JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0445F9 C7 
              12277 VDU	19h		; Move to the first coordinates
0445FA 3E     0001M LD	A, val
0445FB 19 
0445FC CD     0002M CALL	OSWRCH
0445FD 00 
0445FE 3F 
0445FF 04 
              12278 VDU	04h
044600 3E     0001M LD	A, val
044601 04 
044602 CD     0002M CALL	OSWRCH
044603 00 
044604 3F 
044605 04 
              12279 VDU	E
044606 7B     0001M LD	A, val
044607 CD     0002M CALL	OSWRCH
044608 00 
044609 3F 
04460A 04 
              12280 VDU	D
04460B 7A     0001M LD	A, val
04460C CD     0002M CALL	OSWRCH
04460D 00 
04460E 3F 
04460F 04 
              12281 VDU	L
044610 7D     0001M LD	A, val
044611 CD     0002M CALL	OSWRCH
044612 00 
044613 3F 
044614 04 
              12282 VDU	H
044615 7C     0001M LD	A, val
044616 CD     0002M CALL	OSWRCH
044617 00 
044618 3F 
044619 04 
04461A CD     12283 CALL	COMMA
04461B 22 
04461C 0A 
04461D 04 
04461E C5     12284 PUSH	BC
04461F CD     12285 CALL	EXPR_W2		; Get X2 and Y2
044620 A5 
044621 43 
044622 04 
044623 C1     12286 POP	BC
044624 18     12287 JR	PLOT_1		; Now DRAW the line to those positions
044625 9B 
              12288 
              12289 
              12290 
              12291 ; --- End agon_graphics.asm ---
              12292 
              12293 ; --- Begin agon_sound.asm ---
              12294 ;
              12295 ; Title:	BBC Basic for AGON - Audio stuff
              12296 ; Author:	Dean Belfield
              12297 ; Created:	12/05/2023
              12298 ; Last Updated:	12/05/2023
              12299 ;
              12300 ; Modinfo:
              12301 
              12302 ; .ASSUME	ADL = 1
              12303 
              12304 ; INCLUDE	"equs.inc"
              12305 ; INCLUDE "macros.inc"
              12306 ; INCLUDE "mos_api.inc"	; In MOS/src
              12307 
              12308 ; SEGMENT CODE
              12309 
              12310 ; XDEF	SOUND
              12311 
              12312 ; XREF	COMMA
              12313 ; XREF	EXPR_W2
              12314 ; XREF	XEQ
              12315 ; XREF	LTRAP
              12316 ; XREF	OSWRCH
              12317 ; XREF	VDU_BUFFER
              12318 
              12319 
              12320 ; SOUND channel,volume,pitch,duration
              12321 ; volume: 0 (off) to -15 (full volume)
              12322 ; pitch: 0 - 255
              12323 ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
              12324 ;
044626 CD     12325 SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044627 A5 
044628 43 
044629 04 
04462A 7D     12326 LD	A, L 			;  A: Volume
04462B F5     12327 PUSH	AF
04462C D5     12328 PUSH	DE
04462D CD     12329 CALL	COMMA
04462E 22 
04462F 0A 
044630 04 
044631 CD     12330 CALL	EXPR_W2			; DE: Pitch, HL: Duration
044632 A5 
044633 43 
044634 04 
044635 53     12331 LD	D, E			;  D: Pitch
044636 5D     12332 LD	E, L 			;  E: Duration
044637 E1     12333 POP	HL 			; HL: Channel/Control
044638 F1     12334 POP	AF
044639 ED     12335 NEG
04463A 44 
04463B FE     12336 CP	16			; Check volume is in bounds
04463C 10 
04463D D2     12337 JP	NC, XEQ			; Out of bounds, do nothing
04463E 96 
04463F 0B 
044640 04 
              12338 ;
              12339 ; Store	in VDU vars
              12340 ;
044641 4F     12341 LD	C, A			; Store Volume in C
044642 7D     12342 LD	A, L
044643 32     12343 LD	(VDU_BUFFER+0), A	; Channel
044644 00 
044645 4A 
044646 04 
044647 AF     12344 XOR	A
044648 32     12345 LD	(VDU_BUFFER+1), A	; Waveform
044649 01 
04464A 4A 
04464B 04 
              12346 ;
              12347 ; Calculate the volume
              12348 ;
04464C 06     12349 LD	B, 6			; C already contains the volume
04464D 06 
04464E ED     12350 MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
04464F 4C 
044650 79     12351 LD	A, C
044651 32     12352 LD	(VDU_BUFFER+2), A
044652 02 
044653 4A 
044654 04 
              12353 ;
              12354 ; And the frequency
              12355 ;
044655 4B     12356 LD	C, E			; Store duration in C
044656 26     12357 LD	H, 0			; Lookup the frequency
044657 00 
044658 6A     12358 LD	L, D
044659 11     12359 LD	DE, SOUND_FREQ_LOOKUP
04465A E0 
04465B 46 
04465C 04 
04465D 29     12360 ADD	HL, HL
04465E 19     12361 ADD	HL, DE
04465F 7E     12362 LD	A, (HL)
044660 32     12363 LD	(VDU_BUFFER+3), A
044661 03 
044662 4A 
044663 04 
044664 23     12364 INC	HL
044665 7E     12365 LD	A, (HL)
044666 32     12366 LD	(VDU_BUFFER+4), A
044667 04 
044668 4A 
044669 04 
              12367 ;
              12368 ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
              12369 ;
04466A 06     12370 LD	B, 50			; C contains the duration, so MLT by 50
04466B 32 
04466C ED     12371 MLT	BC
04466D 4C 
04466E ED     12372 LD	(VDU_BUFFER+5), BC
04466F 43 
044670 05 
044671 4A 
044671 04   
              12373 ;
044673 DD     12374 PUSH	IX			; Get the system vars in IX
044674 E5 
              12375 MOSCALL	mos_sysvars		; Reset the semaphore
044675 3E     0001M LD	A, function
044676 08 
044677 49     0002M RST.LIS	08h
044678 CF 
044679 5B     12376 SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
04467A DD 
04467B CB 
04467C 04 
04467C 9E   
              12377 ;
              12378 VDU	23			; Send the sound command
04467E 3E     0001M LD	A, val
04467F 17 
044680 CD     0002M CALL	OSWRCH
044681 00 
044682 3F 
044683 04 
              12379 VDU	0
044684 3E     0001M LD	A, val
044685 00 
044686 CD     0002M CALL	OSWRCH
044687 00 
044688 3F 
044689 04 
              12380 VDU	vdp_audio
04468A 3E     0001M LD	A, val
04468B 85 
04468C CD     0002M CALL	OSWRCH
04468D 00 
04468E 3F 
04468F 04 
              12381 VDU	(VDU_BUFFER+0)		; 0: Channel
044690 3A     0001M LD	A, val
044691 00 
044692 4A 
044693 04 
044694 CD     0002M CALL	OSWRCH
044695 00 
044696 3F 
044697 04 
              12382 VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
044698 3A     0001M LD	A, val
044699 01 
04469A 4A 
04469B 04 
04469C CD     0002M CALL	OSWRCH
04469D 00 
04469E 3F 
04469F 04 
              12383 VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446A0 3A     0001M LD	A, val
0446A1 02 
0446A2 4A 
0446A3 04 
0446A4 CD     0002M CALL	OSWRCH
0446A5 00 
0446A6 3F 
0446A7 04 
              12384 VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446A8 3A     0001M LD	A, val
0446A9 03 
0446AA 4A 
0446AB 04 
0446AC CD     0002M CALL	OSWRCH
0446AD 00 
0446AE 3F 
0446AF 04 
              12385 VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446B0 3A     0001M LD	A, val
0446B1 04 
0446B2 4A 
0446B3 04 
0446B4 CD     0002M CALL	OSWRCH
0446B5 00 
0446B6 3F 
0446B7 04 
              12386 VDU	(VDU_BUFFER+5)		; 5: Duration L
0446B8 3A     0001M LD	A, val
0446B9 05 
0446BA 4A 
0446BB 04 
0446BC CD     0002M CALL	OSWRCH
0446BD 00 
0446BE 3F 
0446BF 04 
              12387 VDU	(VDU_BUFFER+6)		; 6: Duration H
0446C0 3A     0001M LD	A, val
0446C1 06 
0446C2 4A 
0446C3 04 
0446C4 CD     0002M CALL	OSWRCH
0446C5 00 
0446C6 3F 
0446C7 04 
              12388 ;
              12389 ; Wait for acknowledgement
              12390 ;
0446C8 5B     12391 @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
0446C9 DD 
0446CA CB 
0446CB 04 
0446CB 5E   
0446CD 28     12392 JR	Z, @B			; Wait for the result
0446CE F9 
0446CF CD     12393 CALL	LTRAP			; Check for ESC
0446D0 71 
0446D1 3F 
0446D2 04 
0446D3 5B     12394 LD.LIL	A, (IX+sysvar_audioSuccess)
0446D4 DD 
0446D5 7E 
0446D6 0E 
0446D7 A7     12395 AND	A			; Check if VDP has queued the note
0446D8 28     12396 JR	Z, SOUND0		; No, so loop back and send again
0446D9 9F 
              12397 ;
0446DA DD     12398 POP	IX
0446DB E1 
0446DC C3     12399 JP	XEQ
0446DD 96 
0446DE 0B 
0446DF 04 
              12400 
              12401 ; Frequency Lookup Table
              12402 ; Set up to replicate the BBC Micro audio frequencies
              12403 ;
              12404 ; Split over 5 complete octaves, with 53 being middle C
              12405 ; * C4: 262hz
              12406 ; + A4: 440hz
              12407 ;
              12408 ;	2	3	4	5	6	7	8
              12409 ;
              12410 ; B	1	49	97	145	193	241
              12411 ; A#	0	45	93	141	189	237
              12412 ; A		41	89+	137	185	233
              12413 ; G#		37	85	133	181	229
              12414 ; G		33	81	129	177	225
              12415 ; F#		29	77	125	173	221
              12416 ; F		25	73	121	169	217
              12417 ; E		21	69	117	165	213
              12418 ; D#		17	65	113	161	209
              12419 ; D		13	61	109	157	205	253
              12420 ; C#		9	57	105	153	201	249
              12421 ; C		5	53*	101	149	197	245
              12422 ;
0446E0 75     12423 SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
0446E1 00 
0446E2 76 
0446E3 00 
0446E3 78   
0446E4 00 
0446E5 7A 
0446E6 00 
0446E6 7B   
0446E7 00 
0446E8 83 
0446E9 00 
0446E9 85   
0446EA 00 
0446EB 87 
0446EC 00 
0446F0 89     12424 DW	 137,  139,  141,  143,  145,  147,  149,  151
0446F1 00 
0446F2 8B 
0446F3 00 
0446F3 8D   
0446F4 00 
0446F5 8F 
0446F6 00 
0446F6 91   
0446F7 00 
0446F8 93 
0446F9 00 
0446F9 95   
0446FA 00 
0446FB 97 
0446FC 00 
044700 99     12425 DW	 153,  156,  158,  160,  162,  165,  167,  170
044701 00 
044702 9C 
044703 00 
044703 9E   
044704 00 
044705 A0 
044706 00 
044706 A2   
044707 00 
044708 A5 
044709 00 
044709 A7   
04470A 00 
04470B AA 
04470C 00 
044710 AC     12426 DW	 172,  175,  177,  180,  182,  185,  188,  190
044711 00 
044712 AF 
044713 00 
044713 B1   
044714 00 
044715 B4 
044716 00 
044716 B6   
044717 00 
044718 B9 
044719 00 
044719 BC   
04471A 00 
04471B BE 
04471C 00 
044720 C1     12427 DW	 193,  196,  199,  202,  205,  208,  211,  214
044721 00 
044722 C4 
044723 00 
044723 C7   
044724 00 
044725 CA 
044726 00 
044726 CD   
044727 00 
044728 D0 
044729 00 
044729 D3   
04472A 00 
04472B D6 
04472C 00 
044730 D9     12428 DW	 217,  220,  223,  226,  230,  233,  236,  240
044731 00 
044732 DC 
044733 00 
044733 DF   
044734 00 
044735 E2 
044736 00 
044736 E6   
044737 00 
044738 E9 
044739 00 
044739 EC   
04473A 00 
04473B F0 
04473C 00 
044740 F3     12429 DW	 243,  247,  251,  254,  258,  262,  265,  269
044741 00 
044742 F7 
044743 00 
044743 FB   
044744 00 
044745 FE 
044746 00 
044746 02   
044747 01 
044748 06 
044749 01 
044749 09   
04474A 01 
04474B 0D 
04474C 01 
044750 11     12430 DW	 273,  277,  281,  285,  289,  294,  298,  302
044751 01 
044752 15 
044753 01 
044753 19   
044754 01 
044755 1D 
044756 01 
044756 21   
044757 01 
044758 26 
044759 01 
044759 2A   
04475A 01 
04475B 2E 
04475C 01 
044760 33     12431 DW	 307,  311,  316,  320,  325,  330,  334,  339
044761 01 
044762 37 
044763 01 
044763 3C   
044764 01 
044765 40 
044766 01 
044766 45   
044767 01 
044768 4A 
044769 01 
044769 4E   
04476A 01 
04476B 53 
04476C 01 
044770 58     12432 DW	 344,  349,  354,  359,  365,  370,  375,  381
044771 01 
044772 5D 
044773 01 
044773 62   
044774 01 
044775 67 
044776 01 
044776 6D   
044777 01 
044778 72 
044779 01 
044779 77   
04477A 01 
04477B 7D 
04477C 01 
044780 82     12433 DW	 386,  392,  398,  403,  409,  415,  421,  427
044781 01 
044782 88 
044783 01 
044783 8E   
044784 01 
044785 93 
044786 01 
044786 99   
044787 01 
044788 9F 
044789 01 
044789 A5   
04478A 01 
04478B AB 
04478C 01 
044790 B2     12434 DW	 434,  440,  446,  453,  459,  466,  473,  480
044791 01 
044792 B8 
044793 01 
044793 BE   
044794 01 
044795 C5 
044796 01 
044796 CB   
044797 01 
044798 D2 
044799 01 
044799 D9   
04479A 01 
04479B E0 
04479C 01 
0447A0 E7     12435 DW	 487,  494,  501,  508,  516,  523,  531,  539
0447A1 01 
0447A2 EE 
0447A3 01 
0447A3 F5   
0447A4 01 
0447A5 FC 
0447A6 01 
0447A6 04   
0447A7 02 
0447A8 0B 
0447A9 02 
0447A9 13   
0447AA 02 
0447AB 1B 
0447AC 02 
0447B0 22     12436 DW	 546,  554,  562,  571,  579,  587,  596,  605
0447B1 02 
0447B2 2A 
0447B3 02 
0447B3 32   
0447B4 02 
0447B5 3B 
0447B6 02 
0447B6 43   
0447B7 02 
0447B8 4B 
0447B9 02 
0447B9 54   
0447BA 02 
0447BB 5D 
0447BC 02 
0447C0 65     12437 DW	 613,  622,  631,  641,  650,  659,  669,  679
0447C1 02 
0447C2 6E 
0447C3 02 
0447C3 77   
0447C4 02 
0447C5 81 
0447C6 02 
0447C6 8A   
0447C7 02 
0447C8 93 
0447C9 02 
0447C9 9D   
0447CA 02 
0447CB A7 
0447CC 02 
0447D0 B1     12438 DW	 689,  699,  709,  719,  729,  740,  751,  762
0447D1 02 
0447D2 BB 
0447D3 02 
0447D3 C5   
0447D4 02 
0447D5 CF 
0447D6 02 
0447D6 D9   
0447D7 02 
0447D8 E4 
0447D9 02 
0447D9 EF   
0447DA 02 
0447DB FA 
0447DC 02 
0447E0 05     12439 DW	 773,  784,  795,  807,  819,  831,  843,  855
0447E1 03 
0447E2 10 
0447E3 03 
0447E3 1B   
0447E4 03 
0447E5 27 
0447E6 03 
0447E6 33   
0447E7 03 
0447E8 3F 
0447E9 03 
0447E9 4B   
0447EA 03 
0447EB 57 
0447EC 03 
0447F0 63     12440 DW	 867,  880,  893,  906,  919,  932,  946,  960
0447F1 03 
0447F2 70 
0447F3 03 
0447F3 7D   
0447F4 03 
0447F5 8A 
0447F6 03 
0447F6 97   
0447F7 03 
0447F8 A4 
0447F9 03 
0447F9 B2   
0447FA 03 
0447FB C0 
0447FC 03 
044800 CE     12441 DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
044801 03 
044802 DC 
044803 03 
044803 EA   
044804 03 
044805 F9 
044806 03 
044806 08   
044807 04 
044808 17 
044809 04 
044809 26   
04480A 04 
04480B 36 
04480C 04 
044810 45     12442 DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
044811 04 
044812 55 
044813 04 
044813 65   
044814 04 
044815 76 
044816 04 
044816 86   
044817 04 
044818 97 
044819 04 
044819 A8   
04481A 04 
04481B BA 
04481C 04 
044820 CB     12443 DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
044821 04 
044822 DD 
044823 04 
044823 EF   
044824 04 
044825 02 
044826 05 
044826 14   
044827 05 
044828 27 
044829 05 
044829 3A   
04482A 05 
04482B 4E 
04482C 05 
044830 62     12444 DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
044831 05 
044832 76 
044833 05 
044833 8A   
044834 05 
044835 9F 
044836 05 
044836 B3   
044837 05 
044838 C9 
044839 05 
044839 DE   
04483A 05 
04483B F4 
04483C 05 
044840 0A     12445 DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
044841 06 
044842 21 
044843 06 
044843 38   
044844 06 
044845 4F 
044846 06 
044846 66   
044847 06 
044848 7E 
044849 06 
044849 96   
04484A 06 
04484B AF 
04484C 06 
044850 C8     12446 DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
044851 06 
044852 E1 
044853 06 
044853 FA   
044854 06 
044855 14 
044856 07 
044856 2F   
044857 07 
044858 4A 
044859 07 
044859 65   
04485A 07 
04485B 80 
04485C 07 
044860 9C     12447 DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
044861 07 
044862 B8 
044863 07 
044863 D5   
044864 07 
044865 F2 
044866 07 
044866 10   
044867 08 
044868 2D 
044869 08 
044869 4B   
04486A 08 
04486B 6A 
04486C 08 
044870 8A     12448 DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
044871 08 
044872 A9 
044873 08 
044873 CA   
044874 08 
044875 EA 
044876 08 
044876 0C   
044877 09 
044878 2D 
044879 09 
044879 4F   
04487A 09 
04487B 72 
04487C 09 
044880 95     12449 DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
044881 09 
044882 B9 
044883 09 
044883 DD   
044884 09 
044885 02 
044886 0A 
044886 27   
044887 0A 
044888 4D 
044889 0A 
044889 73   
04488A 0A 
04488B 9A 
04488C 0A 
044890 C2     12450 DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
044891 0A 
044892 EA 
044893 0A 
044893 12   
044894 0B 
044895 3C 
044896 0B 
044896 66   
044897 0B 
044898 90 
044899 0B 
044899 BB   
04489A 0B 
04489B E7 
04489C 0B 
0448A0 13     12451 DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
0448A1 0C 
0448A2 40 
0448A3 0C 
0448A3 6E   
0448A4 0C 
0448A5 9C 
0448A6 0C 
0448A6 CB   
0448A7 0C 
0448A8 FA 
0448A9 0C 
0448A9 2B   
0448AA 0D 
0448AB 5C 
0448AC 0D 
0448B0 8E     12452 DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
0448B1 0D 
0448B2 C0 
0448B3 0D 
0448B3 F3   
0448B4 0D 
0448B5 27 
0448B6 0E 
0448B6 5C   
0448B7 0E 
0448B8 91 
0448B9 0E 
0448B9 C8   
0448BA 0E 
0448BB FF 
0448BC 0E 
0448C0 36     12453 DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
0448C1 0F 
0448C2 6F 
0448C3 0F 
0448C3 A9   
0448C4 0F 
0448C5 E3 
0448C6 0F 
0448C6 1E   
0448C7 10 
0448C8 5A 
0448C9 10 
0448C9 97   
0448CA 10 
0448CB D5 
0448CC 10 
0448D0 13     12454 DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
0448D1 11 
0448D2 53 
0448D3 11 
0448D3 93   
0448D4 11 
0448D5 D5 
0448D6 11 
0448D6 17   
0448D7 12 
0448D8 5B 
0448D9 12 
0448D9 9F   
0448DA 12 
0448DB E4 
0448DC 12 
              12455 
              12456 
              12457 ; --- End agon_sound.asm ---
              12458 
              12459 ; --- Begin interrupts.asm ---
              12460 ;
              12461 ; Title:	BBC Basic for AGON - Interrupts
              12462 ; Author:	Dean Belfield
              12463 ; Created:	12/05/2023
              12464 ; Last Updated:	07/06/2023
              12465 ;
              12466 ; Modinfo:
              12467 ; 07/06/2023:	Modified to run in ADL mode
              12468 
              12469 ; .ASSUME	ADL = 1
              12470 
              12471 ; INCLUDE	"macros.inc"
              12472 ; INCLUDE	"equs.inc"
              12473 ; INCLUDE "mos_api.inc"	; In MOS/src
              12474 
              12475 ; SEGMENT CODE
              12476 
              12477 ; XDEF	VBLANK_INIT
              12478 ; XDEF	VBLANK_STOP
              12479 ; XDEF	VBLANK_HANDLER
              12480 
              12481 ; XREF	ESCSET
              12482 ; XREF	KEYDOWN		; In ram.asm
              12483 ; XREF	KEYASCII 	; In ram.asm
              12484 ; XREF	KEYCOUNT	; In ram.asm
              12485 
              12486 ; Hook into the MOS VBLANK interrupt
              12487 ;
0448E0 F3     12488 VBLANK_INIT:		DI
0448E1 21     12489 LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0448E2 35 
0448E3 49 
0448E4 04 
0448E5 1E     12490 LD		E, 32h				; Set up the VBlank Interrupt Vector
0448E6 32 
              12491 MOSCALL		mos_setintvector
0448E7 3E     0001M LD	A, function
0448E8 14 
0448E9 49     0002M RST.LIS	08h
0448EA CF 
              12492 ; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0448EB EB     12493 ex de,hl
0448EC 21     12494 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448ED 43 
0448EE 49 
0448EF 04 
0448F0 ED     12495 LD		(HL), DE			; Self-modify the code
0448F1 1F 
0448F2 FB     12496 EI
0448F3 C9     12497 RET
              12498 
              12499 ; Unhook the custom VBLANK interrupt
              12500 ;
0448F4 F3     12501 VBLANK_STOP:		DI
0448F5 21     12502 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448F6 43 
0448F7 49 
0448F8 04 
0448F9 ED     12503 LD		DE, (HL)
0448FA 17 
0448FB EB     12504 EX		DE, HL 				; HLU: Address of MOS interrupt vector
0448FC 1E     12505 LD		E, 32h
0448FD 32 
              12506 MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0448FE 3E     0001M LD	A, function
0448FF 14 
044900 49     0002M RST.LIS	08h
044901 CF 
044902 FB     12507 EI
044903 C9     12508 RET
              12509 
              12510 ; A safe LIS call to ESCSET
              12511 ;
              12512 DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044904 3E     0001M LD	A, function
044905 08 
044906 49     0002M RST.LIS	08h
044907 CF 
044908 21     12513 LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044909 49 
04490A 4D 
04490B 04 
04490C DD     12514 LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04490D 7E 
04490E 19 
04490F BE     12515 CP 		(HL)				; with our local copy
044910 20     12516 JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044911 0A 
              12517 ;
044912 AF     12518 DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044913 32     12519 LD		(KEYASCII), A
044914 48 
044915 4D 
044916 04 
044917 32     12520 LD		(KEYDOWN), A
044918 47 
044919 4D 
04491A 04 
04491B C9     12521 RET	 					; And return
              12522 ;
04491C 77     12523 DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04491D DD     12524 LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
04491E 7E 
04491F 18 
044920 B7     12525 OR		A
044921 28     12526 JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044922 EF 
              12527 ;
044923 32     12528 LD		(KEYDOWN), A 			; Store the keydown value
044924 47 
044925 4D 
044926 04 
044927 DD     12529 LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044928 7E 
044929 05 
04492A 32     12530 LD		(KEYASCII), A 			; Store locally
04492B 48 
04492C 4D 
04492D 04 
04492E FE     12531 CP		1Bh				; Is it escape?
04492F 1B 
044930 CC     12532 CALL		Z, ESCSET			; Yes, so set the escape flags
044931 4C 
044932 3F 
044933 04 
044934 C9     12533 RET						; Return to the interrupt handler
              12534 
044935 F3     12535 VBLANK_HANDLER:		DI
044936 F5     12536 PUSH		AF
044937 E5     12537 PUSH		HL
044938 DD     12538 PUSH		IX
044939 E5 
04493A CD     12539 CALL		DO_KEYBOARD
04493B 04 
04493C 49 
04493D 04 
04493E DD     12540 POP		IX
04493F E1 
044940 E1     12541 POP		HL
044941 F1     12542 POP		AF
              12543 ;
              12544 ; Finally jump to the MOS interrupt
              12545 ;
044942 C3     12546 VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044943 00 
044944 00 
044945 00 
              12547 
              12548 ; --- Begin ram.asm ---
              12549 ;
              12550 ; Title:	BBC Basic Interpreter - Z80 version
              12551 ;		RAM Module for BBC Basic Interpreter
              12552 ;		For use with Version 2.0 of BBC BASIC
              12553 ;		Standard CP/M Distribution Version
              12554 ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              12555 ; Modified By:	Dean Belfield
              12556 ; Created:	12/05/2023
              12557 ; Last Updated:	26/06/2023
              12558 ;
              12559 ; Modinfo:
              12560 ; 06/06/2023:	Modified to run in ADL mode
              12561 ; 26/06/2023:	Added temporary stores R0 and R1
              12562 
              12563 ; .ASSUME	ADL = 1
              12564 
              12565 ; DEFINE	LORAM, SPACE = ROM
              12566 ; SEGMENT LORAM
              12567 
              12568 ; XDEF	ACCS
              12569 ; XDEF	BUFFER
              12570 ; XDEF	STAVAR
              12571 ; XDEF	DYNVAR
              12572 ; XDEF	FNPTR
              12573 ; XDEF	PROPTR
              12574 ; XDEF	PAGE_
              12575 ; XDEF	TOP
              12576 ; XDEF	LOMEM
              12577 ; XDEF 	FREE
              12578 ; XDEF	HIMEM
              12579 ; XDEF	LINENO
              12580 ; XDEF	TRACEN
              12581 ; XDEF	AUTONO
              12582 ; XDEF	ERRTRP
              12583 ; XDEF	ERRTXT
              12584 ; XDEF	DATPTR
              12585 ; XDEF	ERL
              12586 ; XDEF	ERRLIN
              12587 ; XDEF	RANDOM
              12588 ; XDEF	COUNT
              12589 ; XDEF	WIDTH
              12590 ; XDEF	ERR
              12591 ; XDEF	LISTON
              12592 ; XDEF	INCREM
              12593 
              12594 ; XDEF	FLAGS
              12595 ; XDEF	OSWRCHPT
              12596 ; XDEF	OSWRCHCH
              12597 ; XDEF	OSWRCHFH
              12598 ; XDEF	KEYDOWN
              12599 ; XDEF	KEYASCII
              12600 ; XDEF	KEYCOUNT
              12601 
              12602 ; XDEF	R0
              12603 ; XDEF	R1
              12604 
              12605 ; XDEF	RAM_START
              12606 ; XDEF	RAM_END
              12607 ; XDEF	USER
              12608 
              12609 end_binary: ;  for assemble.py to know where to truncate the binary file
044946 FF     12610 ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
044947 FF 
044948 FF 
044949 FF 
044949 FF   
04494A FF 
04494B FF 
04494C FF 
04494C FF   
04494D FF 
04494E FF 
04494F FF 
04494F FF   
044950 FF 
044951 FF 
044952 FF 
044952 FF   
044953 FF 
044954 FF 
044955 FF 
044955 FF   
044956 FF 
044957 FF 
044958 FF 
044958 FF   
044959 FF 
04495A FF 
04495B FF 
04495B FF   
04495C FF 
04495D FF 
04495E FF 
04495E FF   
04495F FF 
044960 FF 
044961 FF 
044961 FF   
044962 FF 
044963 FF 
044964 FF 
044964 FF   
044965 FF 
044966 FF 
044967 FF 
044967 FF   
044968 FF 
044969 FF 
04496A FF 
04496A FF   
04496B FF 
04496C FF 
04496D FF 
04496D FF   
04496E FF 
04496F FF 
044970 FF 
044970 FF   
044971 FF 
044972 FF 
044973 FF 
044973 FF   
044974 FF 
044975 FF 
044976 FF 
044976 FF   
044977 FF 
044978 FF 
044979 FF 
044979 FF   
04497A FF 
04497B FF 
04497C FF 
04497C FF   
04497D FF 
04497E FF 
04497F FF 
04497F FF   
044980 FF 
044981 FF 
044982 FF 
044982 FF   
044983 FF 
044984 FF 
044985 FF 
044985 FF   
044986 FF 
044987 FF 
044988 FF 
044988 FF   
044989 FF 
04498A FF 
04498B FF 
04498B FF   
04498C FF 
04498D FF 
04498E FF 
04498E FF   
04498F FF 
044990 FF 
044991 FF 
044991 FF   
044992 FF 
044993 FF 
044994 FF 
044994 FF   
044995 FF 
044996 FF 
044997 FF 
044997 FF   
044998 FF 
044999 FF 
04499A FF 
04499A FF   
04499B FF 
04499C FF 
04499D FF 
04499D FF   
04499E FF 
04499F FF 
0449A0 FF 
0449A0 FF   
0449A1 FF 
0449A2 FF 
0449A3 FF 
0449A3 FF   
0449A4 FF 
0449A5 FF 
0449A6 FF 
0449A6 FF   
0449A7 FF 
0449A8 FF 
0449A9 FF 
0449A9 FF   
0449AA FF 
0449AB FF 
0449AC FF 
0449AC FF   
0449AD FF 
0449AE FF 
0449AF FF 
0449AF FF   
0449B0 FF 
0449B1 FF 
0449B2 FF 
0449B2 FF   
0449B3 FF 
0449B4 FF 
0449B5 FF 
0449B5 FF   
0449B6 FF 
0449B7 FF 
0449B8 FF 
0449B8 FF   
0449B9 FF 
0449BA FF 
0449BB FF 
0449BB FF   
0449BC FF 
0449BD FF 
0449BE FF 
0449BE FF   
0449BF FF 
0449C0 FF 
0449C1 FF 
0449C1 FF   
0449C2 FF 
0449C3 FF 
0449C4 FF 
0449C4 FF   
0449C5 FF 
0449C6 FF 
0449C7 FF 
0449C7 FF   
0449C8 FF 
0449C9 FF 
0449CA FF 
0449CA FF   
0449CB FF 
0449CC FF 
0449CD FF 
0449CD FF   
0449CE FF 
0449CF FF 
0449D0 FF 
0449D0 FF   
0449D1 FF 
              12611 RAM_START:
              12612 ;
044A00 00     12613 ACCS:           BLKB    256,0             ; String Accumulator
044A01 00 
044A02 00 
044A03 00 
044A03 00   
044A04 00 
044A05 00 
044A06 00 
044A06 00   
044A07 00 
044A08 00 
044A09 00 
044A09 00   
044A0A 00 
044A0B 00 
044A0C 00 
044A0C 00   
044A0D 00 
044A0E 00 
044A0F 00 
044A0F 00   
044A10 00 
044A11 00 
044A12 00 
044A12 00   
044A13 00 
044A14 00 
044A15 00 
044A15 00   
044A16 00 
044A17 00 
044A18 00 
044A18 00   
044A19 00 
044A1A 00 
044A1B 00 
044A1B 00   
044A1C 00 
044A1D 00 
044A1E 00 
044A1E 00   
044A1F 00 
044A20 00 
044A21 00 
044A21 00   
044A22 00 
044A23 00 
044A24 00 
044A24 00   
044A25 00 
044A26 00 
044A27 00 
044A27 00   
044A28 00 
044A29 00 
044A2A 00 
044A2A 00   
044A2B 00 
044A2C 00 
044A2D 00 
044A2D 00   
044A2E 00 
044A2F 00 
044A30 00 
044A30 00   
044A31 00 
044A32 00 
044A33 00 
044A33 00   
044A34 00 
044A35 00 
044A36 00 
044A36 00   
044A37 00 
044A38 00 
044A39 00 
044A39 00   
044A3A 00 
044A3B 00 
044A3C 00 
044A3C 00   
044A3D 00 
044A3E 00 
044A3F 00 
044A3F 00   
044A40 00 
044A41 00 
044A42 00 
044A42 00   
044A43 00 
044A44 00 
044A45 00 
044A45 00   
044A46 00 
044A47 00 
044A48 00 
044A48 00   
044A49 00 
044A4A 00 
044A4B 00 
044A4B 00   
044A4C 00 
044A4D 00 
044A4E 00 
044A4E 00   
044A4F 00 
044A50 00 
044A51 00 
044A51 00   
044A52 00 
044A53 00 
044A54 00 
044A54 00   
044A55 00 
044A56 00 
044A57 00 
044A57 00   
044A58 00 
044A59 00 
044A5A 00 
044A5A 00   
044A5B 00 
044A5C 00 
044A5D 00 
044A5D 00   
044A5E 00 
044A5F 00 
044A60 00 
044A60 00   
044A61 00 
044A62 00 
044A63 00 
044A63 00   
044A64 00 
044A65 00 
044A66 00 
044A66 00   
044A67 00 
044A68 00 
044A69 00 
044A69 00   
044A6A 00 
044A6B 00 
044A6C 00 
044A6C 00   
044A6D 00 
044A6E 00 
044A6F 00 
044A6F 00   
044A70 00 
044A71 00 
044A72 00 
044A72 00   
044A73 00 
044A74 00 
044A75 00 
044A75 00   
044A76 00 
044A77 00 
044A78 00 
044A78 00   
044A79 00 
044A7A 00 
044A7B 00 
044A7B 00   
044A7C 00 
044A7D 00 
044A7E 00 
044A7E 00   
044A7F 00 
044A80 00 
044A81 00 
044A81 00   
044A82 00 
044A83 00 
044A84 00 
044A84 00   
044A85 00 
044A86 00 
044A87 00 
044A87 00   
044A88 00 
044A89 00 
044A8A 00 
044A8A 00   
044A8B 00 
044A8C 00 
044A8D 00 
044A8D 00   
044A8E 00 
044A8F 00 
044A90 00 
044A90 00   
044A91 00 
044A92 00 
044A93 00 
044A93 00   
044A94 00 
044A95 00 
044A96 00 
044A96 00   
044A97 00 
044A98 00 
044A99 00 
044A99 00   
044A9A 00 
044A9B 00 
044A9C 00 
044A9C 00   
044A9D 00 
044A9E 00 
044A9F 00 
044A9F 00   
044AA0 00 
044AA1 00 
044AA2 00 
044AA2 00   
044AA3 00 
044AA4 00 
044AA5 00 
044AA5 00   
044AA6 00 
044AA7 00 
044AA8 00 
044AA8 00   
044AA9 00 
044AAA 00 
044AAB 00 
044AAB 00   
044AAC 00 
044AAD 00 
044AAE 00 
044AAE 00   
044AAF 00 
044AB0 00 
044AB1 00 
044AB1 00   
044AB2 00 
044AB3 00 
044AB4 00 
044AB4 00   
044AB5 00 
044AB6 00 
044AB7 00 
044AB7 00   
044AB8 00 
044AB9 00 
044ABA 00 
044ABA 00   
044ABB 00 
044ABC 00 
044ABD 00 
044ABD 00   
044ABE 00 
044ABF 00 
044AC0 00 
044B00 00     12614 BUFFER:         BLKB    256,0             ; String Input Buffer
044B01 00 
044B02 00 
044B03 00 
044B03 00   
044B04 00 
044B05 00 
044B06 00 
044B06 00   
044B07 00 
044B08 00 
044B09 00 
044B09 00   
044B0A 00 
044B0B 00 
044B0C 00 
044B0C 00   
044B0D 00 
044B0E 00 
044B0F 00 
044B0F 00   
044B10 00 
044B11 00 
044B12 00 
044B12 00   
044B13 00 
044B14 00 
044B15 00 
044B15 00   
044B16 00 
044B17 00 
044B18 00 
044B18 00   
044B19 00 
044B1A 00 
044B1B 00 
044B1B 00   
044B1C 00 
044B1D 00 
044B1E 00 
044B1E 00   
044B1F 00 
044B20 00 
044B21 00 
044B21 00   
044B22 00 
044B23 00 
044B24 00 
044B24 00   
044B25 00 
044B26 00 
044B27 00 
044B27 00   
044B28 00 
044B29 00 
044B2A 00 
044B2A 00   
044B2B 00 
044B2C 00 
044B2D 00 
044B2D 00   
044B2E 00 
044B2F 00 
044B30 00 
044B30 00   
044B31 00 
044B32 00 
044B33 00 
044B33 00   
044B34 00 
044B35 00 
044B36 00 
044B36 00   
044B37 00 
044B38 00 
044B39 00 
044B39 00   
044B3A 00 
044B3B 00 
044B3C 00 
044B3C 00   
044B3D 00 
044B3E 00 
044B3F 00 
044B3F 00   
044B40 00 
044B41 00 
044B42 00 
044B42 00   
044B43 00 
044B44 00 
044B45 00 
044B45 00   
044B46 00 
044B47 00 
044B48 00 
044B48 00   
044B49 00 
044B4A 00 
044B4B 00 
044B4B 00   
044B4C 00 
044B4D 00 
044B4E 00 
044B4E 00   
044B4F 00 
044B50 00 
044B51 00 
044B51 00   
044B52 00 
044B53 00 
044B54 00 
044B54 00   
044B55 00 
044B56 00 
044B57 00 
044B57 00   
044B58 00 
044B59 00 
044B5A 00 
044B5A 00   
044B5B 00 
044B5C 00 
044B5D 00 
044B5D 00   
044B5E 00 
044B5F 00 
044B60 00 
044B60 00   
044B61 00 
044B62 00 
044B63 00 
044B63 00   
044B64 00 
044B65 00 
044B66 00 
044B66 00   
044B67 00 
044B68 00 
044B69 00 
044B69 00   
044B6A 00 
044B6B 00 
044B6C 00 
044B6C 00   
044B6D 00 
044B6E 00 
044B6F 00 
044B6F 00   
044B70 00 
044B71 00 
044B72 00 
044B72 00   
044B73 00 
044B74 00 
044B75 00 
044B75 00   
044B76 00 
044B77 00 
044B78 00 
044B78 00   
044B79 00 
044B7A 00 
044B7B 00 
044B7B 00   
044B7C 00 
044B7D 00 
044B7E 00 
044B7E 00   
044B7F 00 
044B80 00 
044B81 00 
044B81 00   
044B82 00 
044B83 00 
044B84 00 
044B84 00   
044B85 00 
044B86 00 
044B87 00 
044B87 00   
044B88 00 
044B89 00 
044B8A 00 
044B8A 00   
044B8B 00 
044B8C 00 
044B8D 00 
044B8D 00   
044B8E 00 
044B8F 00 
044B90 00 
044B90 00   
044B91 00 
044B92 00 
044B93 00 
044B93 00   
044B94 00 
044B95 00 
044B96 00 
044B96 00   
044B97 00 
044B98 00 
044B99 00 
044B99 00   
044B9A 00 
044B9B 00 
044B9C 00 
044B9C 00   
044B9D 00 
044B9E 00 
044B9F 00 
044B9F 00   
044BA0 00 
044BA1 00 
044BA2 00 
044BA2 00   
044BA3 00 
044BA4 00 
044BA5 00 
044BA5 00   
044BA6 00 
044BA7 00 
044BA8 00 
044BA8 00   
044BA9 00 
044BAA 00 
044BAB 00 
044BAB 00   
044BAC 00 
044BAD 00 
044BAE 00 
044BAE 00   
044BAF 00 
044BB0 00 
044BB1 00 
044BB1 00   
044BB2 00 
044BB3 00 
044BB4 00 
044BB4 00   
044BB5 00 
044BB6 00 
044BB7 00 
044BB7 00   
044BB8 00 
044BB9 00 
044BBA 00 
044BBA 00   
044BBB 00 
044BBC 00 
044BBD 00 
044BBD 00   
044BBE 00 
044BBF 00 
044BC0 00 
044C00 00     12615 STAVAR:         BLKB    27*4,0            ; Static Variables
044C01 00 
044C02 00 
044C03 00 
044C03 00   
044C04 00 
044C05 00 
044C06 00 
044C06 00   
044C07 00 
044C08 00 
044C09 00 
044C09 00   
044C0A 00 
044C0B 00 
044C0C 00 
044C0C 00   
044C0D 00 
044C0E 00 
044C0F 00 
044C0F 00   
044C10 00 
044C11 00 
044C12 00 
044C12 00   
044C13 00 
044C14 00 
044C15 00 
044C15 00   
044C16 00 
044C17 00 
044C18 00 
044C18 00   
044C19 00 
044C1A 00 
044C1B 00 
044C1B 00   
044C1C 00 
044C1D 00 
044C1E 00 
044C1E 00   
044C1F 00 
044C20 00 
044C21 00 
044C21 00   
044C22 00 
044C23 00 
044C24 00 
044C24 00   
044C25 00 
044C26 00 
044C27 00 
044C27 00   
044C28 00 
044C29 00 
044C2A 00 
044C2A 00   
044C2B 00 
044C2C 00 
044C2D 00 
044C2D 00   
044C2E 00 
044C2F 00 
044C30 00 
044C30 00   
044C31 00 
044C32 00 
044C33 00 
044C33 00   
044C34 00 
044C35 00 
044C36 00 
044C36 00   
044C37 00 
044C38 00 
044C39 00 
044C39 00   
044C3A 00 
044C3B 00 
044C3C 00 
044C3C 00   
044C3D 00 
044C3E 00 
044C3F 00 
044C3F 00   
044C40 00 
044C41 00 
044C42 00 
044C42 00   
044C43 00 
044C44 00 
044C45 00 
044C45 00   
044C46 00 
044C47 00 
044C48 00 
044C48 00   
044C49 00 
044C4A 00 
044C4B 00 
044C4B 00   
044C4C 00 
044C4D 00 
044C4E 00 
044C4E 00   
044C4F 00 
044C50 00 
044C51 00 
044C6C 00     12616 DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
044C6D 00 
044C6E 00 
044C6F 00 
044C6F 00   
044C70 00 
044C71 00 
044C72 00 
044C72 00   
044C73 00 
044C74 00 
044C75 00 
044C75 00   
044C76 00 
044C77 00 
044C78 00 
044C78 00   
044C79 00 
044C7A 00 
044C7B 00 
044C7B 00   
044C7C 00 
044C7D 00 
044C7E 00 
044C7E 00   
044C7F 00 
044C80 00 
044C81 00 
044C81 00   
044C82 00 
044C83 00 
044C84 00 
044C84 00   
044C85 00 
044C86 00 
044C87 00 
044C87 00   
044C88 00 
044C89 00 
044C8A 00 
044C8A 00   
044C8B 00 
044C8C 00 
044C8D 00 
044C8D 00   
044C8E 00 
044C8F 00 
044C90 00 
044C90 00   
044C91 00 
044C92 00 
044C93 00 
044C93 00   
044C94 00 
044C95 00 
044C96 00 
044C96 00   
044C97 00 
044C98 00 
044C99 00 
044C99 00   
044C9A 00 
044C9B 00 
044C9C 00 
044C9C 00   
044C9D 00 
044C9E 00 
044C9F 00 
044C9F 00   
044CA0 00 
044CA1 00 
044CA2 00 
044CA2 00   
044CA3 00 
044CA4 00 
044CA5 00 
044CA5 00   
044CA6 00 
044CA7 00 
044CA8 00 
044CA8 00   
044CA9 00 
044CAA 00 
044CAB 00 
044CAB 00   
044CAC 00 
044CAD 00 
044CAE 00 
044CAE 00   
044CAF 00 
044CB0 00 
044CB1 00 
044CB1 00   
044CB2 00 
044CB3 00 
044CB4 00 
044CB4 00   
044CB5 00 
044CB6 00 
044CB7 00 
044CB7 00   
044CB8 00 
044CB9 00 
044CBA 00 
044CBA 00   
044CBB 00 
044CBC 00 
044CBD 00 
044CBD 00   
044CBE 00 
044CBF 00 
044CC0 00 
044CC0 00   
044CC1 00 
044CC2 00 
044CC3 00 
044CC3 00   
044CC4 00 
044CC5 00 
044CC6 00 
044CC6 00   
044CC7 00 
044CC8 00 
044CC9 00 
044CC9 00   
044CCA 00 
044CCB 00 
044CCC 00 
044CCC 00   
044CCD 00 
044CCE 00 
044CCF 00 
044CCF 00   
044CD0 00 
044CD1 00 
044CD2 00 
044CD2 00   
044CD3 00 
044CD4 00 
044CD5 00 
044CD5 00   
044CD6 00 
044CD7 00 
044CD8 00 
044CD8 00   
044CD9 00 
044CDA 00 
044CDB 00 
044CDB 00   
044CDC 00 
044CDD 00 
044CDE 00 
044CDE 00   
044CDF 00 
044CE0 00 
044CE1 00 
044CE1 00   
044CE2 00 
044CE3 00 
044CE4 00 
044CE4 00   
044CE5 00 
044D0E 00     12617 FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D0F 00 
044D10 00 
044D11 00     12618 PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D12 00 
044D13 00 
              12619 ;
044D14 00     12620 PAGE_:          BLKB    3,0               ; Start of User Program
044D15 00 
044D16 00 
044D17 00     12621 TOP:            BLKB    3,0               ; First Location after User Program
044D18 00 
044D19 00 
044D1A 00     12622 LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1B 00 
044D1C 00 
044D1D 00     12623 FREE:           BLKB    3,0               ; First Free Space Byte
044D1E 00 
044D1F 00 
044D20 00     12624 HIMEM:          BLKB    3,0               ; First Protected Byte
044D21 00 
044D22 00 
              12625 ;
044D23 00     12626 LINENO:         BLKB    3,0               ; Line Number
044D24 00 
044D25 00 
044D26 00     12627 TRACEN:         BLKB    3,0               ; Trace Flag
044D27 00 
044D28 00 
044D29 00     12628 AUTONO:         BLKB    3,0               ; Auto Flag
044D2A 00 
044D2B 00 
044D2C 00     12629 ERRTRP:         BLKB    3,0               ; Error Trap
044D2D 00 
044D2E 00 
044D2F 00     12630 ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D30 00 
044D31 00     12631 DATPTR:         BLKB    2,0               ; Data Pointer
044D32 00 
044D33 00     12632 ERL:            BLKB    2,0               ; Error Line
044D34 00 
044D35 00     12633 ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D36 00 
044D37 00 
044D38 00     12634 RANDOM:         BLKB    5,0               ; Random Number
044D39 00 
044D3A 00 
044D3B 00 
044D3B 00   
044D3D 00     12635 COUNT:          BLKB    1,0               ; Print Position
044D3E 00     12636 WIDTH:          BLKB    1,0               ; Print Width
044D3F 00     12637 ERR:            BLKB    1,0               ; Error Number
044D40 00     12638 LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              12639 ; - BIT 0: If set, output a space after the line number
              12640 ; - BIT 1: If set, then indent FOR/NEXT loops
              12641 ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              12642 ; - BIT 3: If set, then output to buffer for *EDIT
              12643 ; OPT FLAG (top nibble)
              12644 ; - BIT 4: If set, then list whilst assembling
              12645 ; - BIT 5: If set, then assembler errors are reported
              12646 ; - BIT 6: If set, then place the code starting at address pointed to by O%
              12647 ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00     12648 INCREM:         BLKB    1,0               ; Auto-Increment Value
              12649 ;
              12650 ; --------------------------------------------------------------------------------------------
              12651 ; BEGIN MODIFIED CODE
              12652 ; --------------------------------------------------------------------------------------------
              12653 ; Originally in equs.inc
              12654 ;
              12655 OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
              12656 PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
              12657 VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              12658 ; --------------------------------------------------------------------------------------------
              12659 ; END MODIFIED CODE
              12660 ; --------------------------------------------------------------------------------------------
              12661 
              12662 ; Extra Agon-implementation specific system variables
              12663 ;
044D42 00     12664 FLAGS:          BLKB    1,0       ; Miscellaneous flags
              12665 ; - BIT 7: Set if ESC pressed
              12666 ; - BIT 6: Set to disable ESC
044D43 00     12667 OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D44 00 
044D45 00     12668 OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              12669 ; - 0: Console
              12670 ; - 1: File
044D46 00     12671 OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00     12672 KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00     12673 KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00     12674 KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00     12675 R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4B 00 
044D4C 00 
044D4D 00     12676 R1:             BLKB    3,0
044D4E 00 
044D4F 00 
              12677 
              12678 ;
              12679 ; This must be at the end
              12680 ;
              12681 RAM_END:
044D50 FF     12682 ALIGN	256
044D51 FF 
044D52 FF 
044D53 FF 
044D53 FF   
044D54 FF 
044D55 FF 
044D56 FF 
044D56 FF   
044D57 FF 
044D58 FF 
044D59 FF 
044D59 FF   
044D5A FF 
044D5B FF 
044D5C FF 
044D5C FF   
044D5D FF 
044D5E FF 
044D5F FF 
044D5F FF   
044D60 FF 
044D61 FF 
044D62 FF 
044D62 FF   
044D63 FF 
044D64 FF 
044D65 FF 
044D65 FF   
044D66 FF 
044D67 FF 
044D68 FF 
044D68 FF   
044D69 FF 
044D6A FF 
044D6B FF 
044D6B FF   
044D6C FF 
044D6D FF 
044D6E FF 
044D6E FF   
044D6F FF 
044D70 FF 
044D71 FF 
044D71 FF   
044D72 FF 
044D73 FF 
044D74 FF 
044D74 FF   
044D75 FF 
044D76 FF 
044D77 FF 
044D77 FF   
044D78 FF 
044D79 FF 
044D7A FF 
044D7A FF   
044D7B FF 
044D7C FF 
044D7D FF 
044D7D FF   
044D7E FF 
044D7F FF 
044D80 FF 
044D80 FF   
044D81 FF 
044D82 FF 
044D83 FF 
044D83 FF   
044D84 FF 
044D85 FF 
044D86 FF 
044D86 FF   
044D87 FF 
044D88 FF 
044D89 FF 
044D89 FF   
044D8A FF 
044D8B FF 
044D8C FF 
044D8C FF   
044D8D FF 
044D8E FF 
044D8F FF 
044D8F FF   
044D90 FF 
044D91 FF 
044D92 FF 
044D92 FF   
044D93 FF 
044D94 FF 
044D95 FF 
044D95 FF   
044D96 FF 
044D97 FF 
044D98 FF 
044D98 FF   
044D99 FF 
044D9A FF 
044D9B FF 
044D9B FF   
044D9C FF 
044D9D FF 
044D9E FF 
044D9E FF   
044D9F FF 
044DA0 FF 
044DA1 FF 
044DA1 FF   
044DA2 FF 
044DA3 FF 
044DA4 FF 
044DA4 FF   
044DA5 FF 
044DA6 FF 
044DA7 FF 
044DA7 FF   
044DA8 FF 
044DA9 FF 
044DAA FF 
044DAA FF   
044DAB FF 
044DAC FF 
044DAD FF 
044DAD FF   
044DAE FF 
044DAF FF 
044DB0 FF 
044DB0 FF   
044DB1 FF 
044DB2 FF 
044DB3 FF 
044DB3 FF   
044DB4 FF 
044DB5 FF 
044DB6 FF 
044DB6 FF   
044DB7 FF 
044DB8 FF 
044DB9 FF 
044DB9 FF   
044DBA FF 
044DBB FF 
044DBC FF 
044DBC FF   
044DBD FF 
044DBE FF 
044DBF FF 
044DBF FF   
044DC0 FF 
044DC1 FF 
044DC2 FF 
044DC2 FF   
044DC3 FF 
044DC4 FF 
044DC5 FF 
044DC5 FF   
044DC6 FF 
044DC7 FF 
044DC8 FF 
044DC8 FF   
044DC9 FF 
044DCA FF 
044DCB FF 
044DCB FF   
044DCC FF 
044DCD FF 
044DCE FF 
044DCE FF   
044DCF FF 
044DD0 FF 
044DD1 FF 
044DD1 FF   
044DD2 FF 
044DD3 FF 
044DD4 FF 
              12683 USER:							; Must be aligned on a page boundary
              12684 ; --- End ram.asm ---
              12685 
