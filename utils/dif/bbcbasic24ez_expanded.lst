        Output     Line 
       
               0001 ; --- Begin mos_api.inc ---
               0002 ;
               0003 ; Title:	AGON MOS - API for user projects
               0004 ; Author:	Dean Belfield
               0005 ; Created:	03/08/2022
               0006 ; Last Updated:	11/11/2023
               0007 ;
               0008 ; Modinfo:
               0009 ; 05/08/2022:	Added mos_feof
               0010 ; 09/08/2022:	Added system variables: cursorX, cursorY
               0011 ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
               0012 ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
               0013 ; 24/09/2022:	Added mos_getError, mos_mkdir
               0014 ; 13/10/2022:	Added mos_oscli
               0015 ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
               0016 ; 04/03/2023:	Added sysvar_scrpixelIndex
               0017 ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
               0018 ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
               0019 ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
               0020 ; 22/03/2023:	The VDP commands are now indexed from 0x80
               0021 ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
               0022 ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
               0023 ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
               0024 ; 19/05/2023:	Added sysvar_scrMode
               0025 ; 05/06/2023:	Added sysvar_rtcEnable
               0026 ; 03/08/2023:	Added mos_setkbvector
               0027 ; 10/08/2023:	Added mos_getkbmap
               0028 ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
               0029 
               0030 ; VDP control (VDU 23, 0, n)
               0031 ;
               0032 vdp_gp:			EQU 	80h
               0033 vdp_keycode:		EQU 	81h
               0034 vdp_cursor:		EQU	82h
               0035 vdp_scrchar:		EQU	83h
               0036 vdp_scrpixel:		EQU	84h
               0037 vdp_audio:		EQU	85h
               0038 vdp_mode:		EQU	86h
               0039 vdp_rtc:		EQU	87h
               0040 vdp_keystate:		EQU	88h
               0041 vdp_logicalcoords:	EQU	C0h
               0042 vdp_terminalmode:	EQU	FFh
               0043 
               0044 ; MOS high level functions
               0045 ;
               0046 mos_getkey:		EQU	00h
               0047 mos_load:		EQU	01h
               0048 mos_save:		EQU	02h
               0049 mos_cd:			EQU	03h
               0050 mos_dir:		EQU	04h
               0051 mos_del:		EQU	05h
               0052 mos_ren:		EQU	06h
               0053 mos_mkdir:		EQU	07h
               0054 mos_sysvars:		EQU	08h
               0055 mos_editline:		EQU	09h
               0056 mos_fopen:		EQU	0Ah
               0057 mos_fclose:		EQU	0Bh
               0058 mos_fgetc:		EQU	0Ch
               0059 mos_fputc:		EQU	0Dh
               0060 mos_feof:		EQU	0Eh
               0061 mos_getError:		EQU	0Fh
               0062 mos_oscli:		EQU	10h
               0063 mos_copy:		EQU	11h
               0064 mos_getrtc:		EQU	12h
               0065 mos_setrtc:		EQU	13h
               0066 mos_setintvector:	EQU	14h
               0067 mos_uopen:		EQU	15h
               0068 mos_uclose:		EQU	16h
               0069 mos_ugetc:		EQU	17h
               0070 mos_uputc:		EQU 	18h
               0071 mos_getfil:		EQU	19h
               0072 mos_fread:		EQU	1Ah
               0073 mos_fwrite:		EQU	1Bh
               0074 mos_flseek:		EQU	1Ch
               0075 mos_setkbvector:	EQU	1Dh
               0076 mos_getkbmap:		EQU	1Eh
               0077 mos_i2c_open:		EQU	1Fh
               0078 mos_i2c_close:		EQU	20h
               0079 mos_i2c_write:		EQU	21h
               0080 mos_i2c_read:		EQU	22h
               0081 
               0082 
               0083 ; FatFS file access functions
               0084 ;
               0085 ffs_fopen:		EQU	80h
               0086 ffs_fclose:		EQU	81h
               0087 ffs_fread:		EQU	82h
               0088 ffs_fwrite:		EQU	83h
               0089 ffs_flseek:		EQU	84h
               0090 ffs_ftruncate:		EQU	85h
               0091 ffs_fsync:		EQU	86h
               0092 ffs_fforward:		EQU	87h
               0093 ffs_fexpand:		EQU	88h
               0094 ffs_fgets:		EQU	89h
               0095 ffs_fputc:		EQU	8Ah
               0096 ffs_fputs:		EQU	8Bh
               0097 ffs_fprintf:		EQU	8Ch
               0098 ffs_ftell:		EQU	8Dh
               0099 ffs_feof:		EQU	8Eh
               0100 ffs_fsize:		EQU	8Fh
               0101 ffs_ferror:		EQU	90h
               0102 
               0103 ; FatFS directory access functions
               0104 ;
               0105 ffs_dopen:		EQU	91h
               0106 ffs_dclose:		EQU	92h
               0107 ffs_dread:		EQU	93h
               0108 ffs_dfindfirst:		EQU	94h
               0109 ffs_dfindnext:		EQU	95h
               0110 
               0111 ; FatFS file and directory management functions
               0112 ;
               0113 ffs_stat:		EQU	96h
               0114 ffs_unlink:		EQU	97h
               0115 ffs_rename:		EQU	98h
               0116 ffs_chmod:		EQU	99h
               0117 ffs_utime:		EQU	9Ah
               0118 ffs_mkdir:		EQU	9Bh
               0119 ffs_chdir:		EQU	9Ch
               0120 ffs_chdrive:		EQU	9Dh
               0121 ffs_getcwd:		EQU	9Eh
               0122 
               0123 ; FatFS volume management and system configuration functions
               0124 ;
               0125 ffs_mount:		EQU	9Fh
               0126 ffs_mkfs:		EQU	A0h
               0127 ffs_fdisk:		EQU	A1h
               0128 ffs_getfree:		EQU	A2h
               0129 ffs_getlabel:		EQU	A3h
               0130 ffs_setlabel:		EQU	A4h
               0131 ffs_setcp:		EQU	A5h
               0132 
               0133 ; File access modes
               0134 ;
               0135 fa_read:		EQU	01h
               0136 fa_write:		EQU	02h
               0137 fa_open_existing:	EQU	00h
               0138 fa_create_new:		EQU	04h
               0139 fa_create_always:	EQU	08h
               0140 fa_open_always:		EQU	10h
               0141 fa_open_append:		EQU	30h
               0142 
               0143 ; System variable indexes for api_sysvars
               0144 ; Index into _sysvars in globals.asm
               0145 ;
               0146 sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
               0147 sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
               0148 sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
               0149 sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
               0150 sysvar_cursorX:		EQU	07h	; 1: Cursor X position
               0151 sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
               0152 sysvar_scrchar:		EQU	09h	; 1: Character read from screen
               0153 sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
               0154 sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
               0155 sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
               0156 sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
               0157 sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
               0158 sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
               0159 sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
               0160 sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
               0161 sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
               0162 sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
               0163 sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
               0164 sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
               0165 sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
               0166 sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
               0167 sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
               0168 sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
               0169 sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
               0170 sysvar_scrMode:		EQU	27h	; 1: Screen mode
               0171 sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
               0172 sysvar_mouseX:		EQU	29h	; 2: Mouse X position
               0173 sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
               0174 sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
               0175 sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
               0176 sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
               0177 sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
               0178 
               0179 ; Flags for the VPD protocol
               0180 ;
               0181 vdp_pflag_cursor:	EQU	00000001b
               0182 vdp_pflag_scrchar:	EQU	00000010b
               0183 vdp_pflag_point:	EQU	00000100b
               0184 vdp_pflag_audio:	EQU	00001000b
               0185 vdp_pflag_mode:		EQU	00010000b
               0186 vdp_pflag_rtc:		EQU	00100000b
               0187 vdp_pflag_mouse:	EQU	01000000b
               0188 ; vdp_pflag_buffered:	EQU	10000000b
               0189 
               0190 ;
               0191 ; FatFS structures
               0192 ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
               0193 ;
               0194 ; Object ID and allocation information (FFOBJID)
               0195 ;
               0196 ; FFOBJID	.STRUCT
               0197 ; 	fs:		DS	3	; Pointer to the hosting volume of this object
               0198 ; 	id:		DS	2	; Hosting volume mount ID
               0199 ; 	attr:		DS	1	; Object attribute
               0200 ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
               0201 ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
               0202 ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
               0203 ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
               0204 ; ;
               0205 ; ; File object structure (FIL)
               0206 ; ;
               0207 ; FIL .STRUCT
               0208 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0209 ; 	flag:		DS	1	; File status flags
               0210 ; 	err:		DS	1	; Abort flag (error code)
               0211 ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
               0212 ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
               0213 ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
               0214 ; 	dir_sect:	DS	4	; Sector number containing the directory entry
               0215 ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
               0216 ; FIL_SIZE .ENDSTRUCT FIL
               0217 ; ;
               0218 ; ; Directory object structure (DIR)
               0219 ; ;
               0220 ; DIR .STRUCT
               0221 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0222 ; 	dptr:		DS	4	; Current read/write offset
               0223 ; 	clust:		DS	4	; Current cluster
               0224 ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
               0225 ; 	dir:		DS	3	; Pointer to the directory item in the win[]
               0226 ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
               0227 ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
               0228 ; DIR_SIZE .ENDSTRUCT DIR
               0229 ; ;
               0230 ; ; File information structure (FILINFO)
               0231 ; ;
               0232 ; FILINFO .STRUCT
               0233 ; 	fsize:		DS 	4	; File size
               0234 ; 	fdate:		DS	2	; Modified date
               0235 ; 	ftime:		DS	2	; Modified time
               0236 ; 	fattrib:	DS	1	; File attribute
               0237 ; 	altname:	DS	13	; Alternative file name
               0238 ; 	fname:		DS	256	; Primary file name
               0239 ; FILINFO_SIZE .ENDSTRUCT FILINFO
               0240 
               0241 ; FFOBJID offsets
               0242 FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
               0243 FFOBJID.id:       EQU 3    ; Hosting volume mount ID
               0244 FFOBJID.attr:     EQU 5    ; Object attribute
               0245 FFOBJID.stat:     EQU 6    ; Object chain status
               0246 FFOBJID.sclust:   EQU 7    ; Object data start cluster
               0247 FFOBJID.objsize:  EQU 11   ; Object size
               0248 FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
               0249 
               0250 ; FIL offsets (including FFOBJID fields)
               0251 FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0252 FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
               0253 FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
               0254 FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
               0255 FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
               0256 FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
               0257 FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
               0258 FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
               0259 FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
               0260 
               0261 ; DIR offsets (including FFOBJID fields)
               0262 DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0263 DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
               0264 DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
               0265 DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
               0266 DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
               0267 DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
               0268 DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
               0269 DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
               0270 
               0271 ; FILINFO offsets
               0272 FILINFO.fsize:    EQU 0    ; File size
               0273 FILINFO.fdate:    EQU 4    ; Modified date
               0274 FILINFO.ftime:    EQU 6    ; Modified time
               0275 FILINFO.fattrib:  EQU 8    ; File attribute
               0276 FILINFO.altname:  EQU 9    ; Alternative file name
               0277 FILINFO.fname:    EQU 22   ; Primary file name
               0278 FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
               0279 
               0280 ;
               0281 ; Macro for calling the API
               0282 ; Parameters:
               0283 ; - function: One of the function numbers listed above
               0284 ;
               0285 MACRO MOSCALL	function
               0286 LD	A, function
               0287 RST.LIS	08h
               0288 ENDMACRO 	; --- End mos_api.inc ---
               0289 
               0290 ; --- Begin macros.inc ---
               0291 ; Title:	BBC Basic Interpreter - Z80 version
               0292 ;		Useful macros
               0293 ; Author:	Dean Belfield
               0294 ; Created:	12/05/2023
               0295 ; Last Updated:	11/06/2023
               0296 ;
               0297 ; Modinfo:
               0298 ; 11/06/2023:	Modified to run in ADL mode
               0299 ; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
               0300 
               0301 MACRO EXREG	rp1, rp2
               0302 PUSH	rp1
               0303 POP	rp2
               0304 ENDMACRO
               0305 
               0306 ; MACRO ADD8U_DE	reg
               0307 MACRO ADD8U_DE
               0308 ADD	A, E
               0309 LD	E, A
               0310 ADC	A, D
               0311 SUB	E
               0312 LD	D, A
               0313 ENDMACRO
               0314 
               0315 ; MACRO ADD8U_HL	reg
               0316 MACRO ADD8U_HL
               0317 ADD	A, L
               0318 LD	L, A
               0319 ADC	A, H
               0320 SUB	L
               0321 LD	H, A
               0322 ENDMACRO
               0323 
               0324 MACRO VDU	val
               0325 LD	A, val
               0326 CALL	OSWRCH
               0327 ENDMACRO
               0328 
               0329 MACRO SET_GPIO	reg, val
               0330 IN0	A, (reg)
               0331 OR	val
               0332 OUT0	(reg), A
               0333 ENDMACRO
               0334 
               0335 MACRO RES_GPIO	reg, val
               0336 PUSH	BC
               0337 LD	A, val
               0338 CPL
               0339 LD	C, A
               0340 IN0	A, (reg)
               0341 AND	C
               0342 OUT0	(reg), A
               0343 POP	BC
               0344 ENDMACRO
               0345 ; --- End macros.inc ---
               0346 
               0347 ; --- Begin equs.inc ---
               0348 ;
               0349 ; Title:	BBC Basic for AGON - Equs
               0350 ; Author:	Dean Belfield
               0351 ; Created:	12/05/2023
               0352 ; Last Updated:	08/06/2023
               0353 ;
               0354 ; Modinfo:
               0355 ; 08/06/2023:	Added SIZEW
               0356 
               0357 ; XREF		STAVAR
               0358 ; XREF		ACCS
               0359 
               0360 RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
               0361 ;Stack_Top:		EQU		0000h	; Stack at top
               0362 SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
               0363 
               0364 ; For GPIO
               0365 ; PA not available on eZ80L92
               0366 ;
               0367 PA_DR:			EQU		96h
               0368 PA_DDR:			EQU		97h
               0369 PA_ALT1:		EQU		98h
               0370 PA_ALT2:		EQU		99h
               0371 PB_DR:          	EQU		9Ah
               0372 PB_DDR:        	 	EQU		9Bh
               0373 PB_ALT1:        	EQU		9Ch
               0374 PB_ALT2:        	EQU		9Dh
               0375 PC_DR:          	EQU		9Eh
               0376 PC_DDR:         	EQU		9Fh
               0377 PC_ALT1:        	EQU		A0h
               0378 PC_ALT2:        	EQU		A1h
               0379 PD_DR:          	EQU		A2h
               0380 PD_DDR:			EQU		A3h
               0381 PD_ALT1:		EQU		A4h
               0382 PD_ALT2:		EQU		A5h
               0383 
               0384 GPIOMODE_OUT:		EQU		0	; Output
               0385 GPIOMODE_IN:		EQU		1	; Input
               0386 GPIOMODE_DIO:		EQU		2	; Open Drain IO
               0387 GPIOMODE_SIO:		EQU		3	; Open Source IO
               0388 GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
               0389 GPIOMODE_ALTF:		EQU		5;	; Alt Function
               0390 GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
               0391 GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
               0392 GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
               0393 GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
               0394 
               0395 ; ; Originally in ram.asm
               0396 ; ;
               0397 ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
               0398 ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
               0399 ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
               0400 
               0401 ; Originally in main.asm
               0402 ;
               0403 CR:			EQU     0DH
               0404 LF:			EQU     0AH
               0405 ESC:			EQU     1BH
               0406 ; --- End equs.inc ---
               0407 
               0408 ; --- Begin init.asm ---
               0409 ;
               0410 ; Title:	BBC Basic ADL for AGON - Initialisation Code
               0411 ;		Initialisation Code
               0412 ; Author:	Dean Belfield
               0413 ; Created:	12/05/2023
               0414 ; Last Updated:	26/11/2023
               0415 ;
               0416 ; Modinfo:
               0417 ; 11/07/2023:	Fixed *BYE for ADL mode
               0418 ; 26/11/2023:	Moved the ram clear routine into here
               0419 
               0420 ; SEGMENT CODE
               0421 
               0422 ; XDEF	_end
               0423 
               0424 ; XREF	_main				; In main.asm
               0425 
               0426 ; XREF	RAM_START			; In ram.asm
               0427 ; XREF	RAM_END
               0428 
               0429 ; .ASSUME	ADL = 1
               0430 
               0431 ; INCLUDE	"equs.inc"
               0432 
               0433 argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
               0434 
               0435 ;
               0436 ; Start in ADL mode
               0437 ;
040000 C3      0438 JP	_start				; Jump to start
040001 45 
040002 00 
040003 04 
               0439 ;
               0440 ; The header stuff is from byte 64 onwards
               0441 ;
040004 42      0442 _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
040005 42 
040006 43 
040007 42 
040007 41   
040008 53 
040009 49 
04000A 43 
04000A 2E   
04000B 42 
04000C 49 
04000D 4E 
04000D 00   
               0443 
040011 FF      0444 ALIGN	64
040012 FF 
040013 FF 
040014 FF 
040014 FF   
040015 FF 
040016 FF 
040017 FF 
040017 FF   
040018 FF 
040019 FF 
04001A FF 
04001A FF   
04001B FF 
04001C FF 
04001D FF 
04001D FF   
04001E FF 
04001F FF 
040020 FF 
040020 FF   
040021 FF 
040022 FF 
040023 FF 
040023 FF   
040024 FF 
040025 FF 
040026 FF 
040026 FF   
040027 FF 
040028 FF 
040029 FF 
040029 FF   
04002A FF 
04002B FF 
04002C FF 
04002C FF   
04002D FF 
04002E FF 
04002F FF 
04002F FF   
040030 FF 
040031 FF 
040032 FF 
040032 FF   
040033 FF 
040034 FF 
               0445 
040040 4D      0446 DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040041 4F 
040042 53 
040043 00      0447 DB	00h				; MOS header version 0
040044 01      0448 DB	01h				; Flag for run mode (0: Z80, 1: ADL)
               0449 ;
               0450 ; And the code follows on immediately after the header
               0451 ;
040045 F5      0452 _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5      0453 PUSH		BC
040047 D5      0454 PUSH		DE
040048 DD      0455 PUSH		IX
040049 E5 
04004A FD      0456 PUSH		IY
04004B E5 
               0457 
04004C ED      0458 LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
04004D 73 
04004E D7 
04004F 00 
04004F 04   
               0459 
040051 DD      0460 LD		IX, _argv_ptrs		; The argv array pointer address
040052 21 
040053 DA 
040054 00 
040054 04   
040056 DD      0461 PUSH		IX
040057 E5 
040058 CD      0462 CALL		_parse_params		; Parse the parameters
040059 88 
04005A 00 
04005B 04 
04005C DD      0463 POP		IX			; IX: argv
04005D E1 
04005E 06      0464 LD		B, 0			;  C: argc
04005F 00 
040060 CD      0465 CALL		_clear_ram
040061 75 
040062 00 
040063 04 
040064 C3      0466 JP		_main			; Start user code
040065 E6 
040066 2F 
040067 04 
               0467 ;
               0468 ; This bit of code is called from STAR_BYE and returns us safely to MOS
               0469 ;
040068 ED      0470 _end:			LD		SP, (_sps)		; Restore the stack pointer
040069 7B 
04006A D7 
04006B 00 
04006B 04   
               0471 
04006D FD      0472 POP		IY			; Restore the registers
04006E E1 
04006F DD      0473 POP		IX
040070 E1 
040071 D1      0474 POP		DE
040072 C1      0475 POP		BC
040073 F1      0476 POP		AF
040074 C9      0477 RET					; Return to MOS
               0478 
               0479 ;Clear the application memory
               0480 ;
040075 C5      0481 _clear_ram:		PUSH		BC
040076 21      0482 LD		HL, RAM_START
040077 00 
040078 4A 
040079 04 
04007A 11      0483 LD		DE, RAM_START + 1
04007B 01 
04007C 4A 
04007D 04 
04007E 01      0484 LD		BC, RAM_END - RAM_START - 1
04007F 4F 
040080 03 
040081 00 
040082 AF      0485 XOR		A
040083 77      0486 LD		(HL), A
040084 ED      0487 LDIR
040085 B0 
040086 C1      0488 POP		BC
040087 C9      0489 RET
               0490 
               0491 ; Parse the parameter string into a C array
               0492 ; Parameters
               0493 ; - HL: Address of parameter string
               0494 ; - IX: Address for array pointer storage
               0495 ; Returns:
               0496 ; -  C: Number of parameters parsed
               0497 ;
040088 01      0498 _parse_params:		LD	BC, _exec_name
040089 04 
04008A 00 
04008B 04 
04008C DD      0499 LD	(IX+0), BC		; ARGV[0] = the executable name
04008D 0F 
04008E 00 
04008F DD      0500 INC	IX
040090 23 
040091 DD      0501 INC	IX
040092 23 
040093 DD      0502 INC	IX
040094 23 
040095 CD      0503 CALL	_skip_spaces		; Skip HL past any leading spaces
040096 D0 
040097 00 
040098 04 
               0504 ;
040099 01      0505 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009A 01 
04009B 00 
04009C 00 
04009D 06      0506 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009E 0F 
               0507 ;
               0508 _parse_params_1:
04009F C5      0509 PUSH	BC			; Stack ARGC
0400A0 E5      0510 PUSH	HL			; Stack start address of token
0400A1 CD      0511 CALL	_get_token		; Get the next token
0400A2 C1 
0400A3 00 
0400A4 04 
0400A5 79      0512 LD	A, C			; A: Length of the token in characters
0400A6 D1      0513 POP	DE			; Start address of token (was in HL)
0400A7 C1      0514 POP	BC			; ARGC
0400A8 B7      0515 OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8      0516 RET	Z
               0517 ;
0400AA DD      0518 LD	(IX+0), DE		; Store the pointer to the token
0400AB 1F 
0400AC 00 
0400AD E5      0519 PUSH	HL			; DE=HL
0400AE D1      0520 POP	DE
0400AF CD      0521 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B0 D0 
0400B1 00 
0400B2 04 
0400B3 AF      0522 XOR	A
0400B4 12      0523 LD	(DE), A			; Zero-terminate the token
0400B5 DD      0524 INC	IX
0400B6 23 
0400B7 DD      0525 INC	IX
0400B8 23 
0400B9 DD      0526 INC	IX			; Advance to next pointer position
0400BA 23 
0400BB 0C      0527 INC	C			; Increment ARGC
0400BC 79      0528 LD	A, C			; Check for C >= A
0400BD B8      0529 CP	B
0400BE 38      0530 JR	C, _parse_params_1	; And loop
0400BF DF 
0400C0 C9      0531 RET
               0532 
               0533 ; Get the next token
               0534 ; Parameters:
               0535 ; - HL: Address of parameter string
               0536 ; Returns:
               0537 ; - HL: Address of first character after token
               0538 ; -  C: Length of token (in characters)
               0539 ;
0400C1 0E      0540 _get_token:		LD	C, 0			; Initialise length
0400C2 00 
0400C3 7E      0541 @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7      0542 OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8      0543 RET 	Z
0400C6 FE      0544 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C7 0D 
0400C8 C8      0545 RET	Z
0400C9 FE      0546 CP	' '			; Exit if space (end of token)
0400CA 20 
0400CB C8      0547 RET	Z
0400CC 23      0548 INC	HL			; Advance to next character
0400CD 0C      0549 INC 	C			; Increment length
0400CE 18      0550 JR	@B
0400CF F3 
               0551 
               0552 ; Skip spaces in the parameter string
               0553 ; Parameters:
               0554 ; - HL: Address of parameter string
               0555 ; Returns:
               0556 ; - HL: Address of next none-space character
               0557 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0558 ;
0400D0 7E      0559 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE      0560 CP	' '			; Exit if not space
0400D2 20 
0400D3 C0      0561 RET	NZ
0400D4 23      0562 INC	HL			; Advance to next character
0400D5 18      0563 JR	_skip_spaces		; Increment length
0400D6 F9 
               0564 
               0565 ; Storage
               0566 ;
               0567 _sps:			DS	3			; Storage for the stack pointer
0400DA 00      0568 _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
0400DB 00 
0400DC 00 
0400DD 00 
0400DD 00   
0400DE 00 
0400DF 00 
0400E0 00 
0400E0 00   
0400E1 00 
0400E2 00 
0400E3 00 
0400E3 00   
0400E4 00 
0400E5 00 
0400E6 00 
0400E6 00   
0400E7 00 
0400E8 00 
0400E9 00 
0400E9 00   
0400EA 00 
0400EB 00 
0400EC 00 
0400EC 00   
0400ED 00 
0400EE 00 
0400EF 00 
0400EF 00   
0400F0 00 
0400F1 00 
0400F2 00 
0400F2 00   
0400F3 00 
0400F4 00 
0400F5 00 
0400F5 00   
0400F6 00 
0400F7 00 
0400F8 00 
0400F8 00   
0400F9 00 
0400FA 00 
0400FB 00 
0400FB 00   
0400FC 00 
0400FD 00 
0400FE 00 
               0569 
               0570 ; --- Begin eval.asm ---
               0571 ;
               0572 ; Title:	BBC Basic Interpreter - Z80 version
               0573 ;		Expression Evaluation & Arithmetic Module - "EVAL"
               0574 ; Author:	(C) Copyright  R.T.Russell  1984
               0575 ; Modified By:	Dean Belfield
               0576 ; Created:	12/05/2023
               0577 ; Last Updated:	17/08/2023
               0578 ;
               0579 ; Modinfo:
               0580 ; 07/06/2023:	Modified to run in ADL mode
               0581 ; 26/06/2023:	Fixed HEX and HEXSTR
               0582 ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
               0583 ; 17/08/2023:	Added binary constants
               0584 
               0585 ; .ASSUME	ADL = 1
               0586 
               0587 ; INCLUDE	"equs.inc"
               0588 ; INCLUDE "macros.inc"
               0589 ; INCLUDE "mos_api.inc"	; In MOS/src
               0590 
               0591 ; SEGMENT CODE
               0592 
               0593 ; XDEF	EXPR
               0594 ; XDEF	EXPRN
               0595 ; XDEF	EXPRI
               0596 ; XDEF	EXPRS
               0597 ; XDEF	ITEMI
               0598 ; XDEF	LOADN
               0599 ; XDEF	LOAD4
               0600 ; XDEF	CONS
               0601 ; XDEF	LOADS
               0602 ; XDEF	SFIX
               0603 ; XDEF	VAL0
               0604 ; XDEF	SEARCH
               0605 ; XDEF	SWAP
               0606 ; XDEF	TEST
               0607 ; XDEF	DECODE
               0608 ; XDEF	HEXSTR
               0609 ; XDEF	STR
               0610 ; XDEF	ZERO
               0611 ; XDEF	PUSHS
               0612 ; XDEF	POPS
               0613 ; XDEF	COMMA
               0614 ; XDEF	BRAKET
               0615 ; XDEF	NXT
               0616 ; XDEF	COUNT0
               0617 
               0618 ; XREF	ADVAL
               0619 ; XREF	FN_EX
               0620 ; XREF	POINT
               0621 ; XREF	USR
               0622 ; XREF	SYNTAX
               0623 ; XREF	ERROR_
               0624 ; XREF	CHECK
               0625 ; XREF	GETVAR
               0626 ; XREF	LISTON
               0627 ; XREF	RANGE
               0628 ; XREF	FPP
               0629 ; XREF	GETCSR
               0630 ; XREF	CHANEL
               0631 ; XREF	OSSTAT
               0632 ; XREF	OSBGET
               0633 ; XREF	LOMEM
               0634 ; XREF	HIMEM
               0635 ; XREF	PAGE_
               0636 ; XREF	TOP
               0637 ; XREF	ERL
               0638 ; XREF	ERR
               0639 ; XREF	COUNT
               0640 ; XREF	OSOPEN
               0641 ; XREF	GETEXT
               0642 ; XREF	GETPTR
               0643 ; XREF	GETIME
               0644 ; XREF	GETIMS
               0645 ; XREF	LEXAN2
               0646 ; XREF	RANDOM
               0647 ; XREF	STORE5
               0648 ; XREF	GETSCHR
               0649 ; XREF	OSRDCH
               0650 ; XREF	OSKEY
               0651 ; XREF	INKEY1
               0652 ; XREF	EXTERR
               0653 ;
               0654 ; BINARY FLOATING POINT REPRESENTATION:
               0655 ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               0656 ;     8 BIT EXCESS-128 SIGNED EXPONENT
               0657 ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               0658 ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               0659 ;
               0660 ; BINARY INTEGER REPRESENTATION:
               0661 ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               0662 ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
               0663 ;
               0664 ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               0665 ;                             EXPONENT - C
               0666 ;
               0667 
               0668 ;
               0669 ; Table of addresses for functions
               0670 ;
               0671 FUNTOK:			EQU	8DH			; First token number
               0672 ;
04010A E6      0673 FUNTBL:			DW24	DECODE			; Line number
04010B 08 
04010C 04 
04010D 94      0674 DW24	OPENIN			; OPENIN
04010E 05 
04010F 04 
040110 B6      0675 DW24	PTR_EV			; PTR
040111 05 
040112 04 
040113 50      0676 DW24	PAGEV			; PAGE
040114 05 
040115 04 
040116 C0      0677 DW24	TIMEV			; TIME
040117 05 
040118 04 
040119 3C      0678 DW24	LOMEMV			; LOMEM
04011A 05 
04011B 04 
04011C 46      0679 DW24	HIMEMV			; HIMEM
04011D 05 
04011E 04 
04011F 14      0680 DW24	ABSV			; ABS
040120 06 
040121 04 
040122 50      0681 DW24	ACS			; ACS
040123 06 
040124 04 
040125 7C      0682 DW24	ADVAL			; ADVAL
040126 49 
040127 04 
040128 25      0683 DW24	ASC			; ASC
040129 05 
04012A 04 
04012B 48      0684 DW24	ASN			; ASN
04012C 06 
04012D 04 
04012E 4C      0685 DW24	ATN			; ATN
04012F 06 
040130 04 
040131 EE      0686 DW24	BGET			; BGET
040132 04 
040133 04 
040134 34      0687 DW24	COS			; COS
040135 06 
040136 04 
040137 7B      0688 DW24	COUNTV			; COUNT
040138 05 
040139 04 
04013A 1C      0689 DW24	DEG			; DEG
04013B 06 
04013C 04 
04013D 6F      0690 DW24	ERLV			; ERL
04013E 05 
04013F 04 
040140 75      0691 DW24	ERRV			; ERR
040141 05 
040142 04 
040143 79      0692 DW24	EVAL_			; EVAL
040144 06 
040145 04 
040146 3C      0693 DW24	EXP			; EXP
040147 06 
040148 04 
040149 AC      0694 DW24	EXT			; EXT
04014A 05 
04014B 04 
04014C 93      0695 DW24	ZERO			; FALSE
04014D 09 
04014E 04 
04014F 7F      0696 DW24	FN_EX			; FN
040150 10 
040151 04 
040152 0C      0697 DW24	GET			; GET
040153 05 
040154 04 
040155 FB      0698 DW24	INKEY			; INKEY
040156 04 
040157 04 
040158 2B      0699 DW24	INSTR			; INSTR(
040159 07 
04015A 04 
04015B 28      0700 DW24	INT_			; INT
04015C 06 
04015D 04 
04015E 35      0701 DW24	LEN			; LEN
04015F 05 
040160 04 
040161 40      0702 DW24	LN			; LN
040162 06 
040163 04 
040164 44      0703 DW24	LOG			; LOG
040165 06 
040166 04 
040167 18      0704 DW24	NOTK			; NOT
040168 06 
040169 04 
04016A 90      0705 DW24	OPENUP			; OPENUP
04016B 05 
04016C 04 
04016D 8D      0706 DW24	OPENOT			; OPENOUT
04016E 05 
04016F 04 
040170 10      0707 DW24	PI			; PI
040171 06 
040172 04 
040173 9F      0708 DW24	POINT			; POINT(
040174 44 
040175 04 
040176 CD      0709 DW24	POS			; POS
040177 04 
040178 04 
040179 20      0710 DW24	RAD			; RAD
04017A 06 
04017B 04 
04017C AD      0711 DW24	RND			; RND
04017D 06 
04017E 04 
04017F 24      0712 DW24	SGN			; SGN
040180 06 
040181 04 
040182 38      0713 DW24	SIN			; SIN
040183 06 
040184 04 
040185 2C      0714 DW24	SQR			; SQR
040186 06 
040187 04 
040188 30      0715 DW24	TAN			; TAN
040189 06 
04018A 04 
04018B 5A      0716 DW24	TOPV			; TO(P)
04018C 05 
04018D 04 
04018E 05      0717 DW24	TRUE			; TRUE
04018F 06 
040190 04 
040191 4C      0718 DW24	USR			; USR
040192 15 
040193 04 
040194 6A      0719 DW24	VAL			; VAL
040195 06 
040196 04 
040197 D6      0720 DW24	VPOS			; VPOS
040198 04 
040199 04 
04019A BF      0721 DW24	CHRS			; CHRS
04019B 07 
04019C 04 
04019D C7      0722 DW24	GETS			; GETS
04019E 07 
04019F 04 
0401A0 D8      0723 DW24	INKEYS			; INKEYS
0401A1 07 
0401A2 04 
0401A3 5D      0724 DW24	LEFTS			; LEFTS(
0401A4 08 
0401A5 04 
0401A6 25      0725 DW24	MIDS			; MIDS(
0401A7 08 
0401A8 04 
0401A9 7D      0726 DW24	RIGHTS			; RIGHTS(
0401AA 08 
0401AB 04 
0401AC 4A      0727 DW24	STRS			; STR$
0401AD 09 
0401AE 04 
0401AF 9E      0728 DW24	STRING_			; STRINGS(
0401B0 08 
0401B1 04 
0401B2 DE      0729 DW24	EOF			; EOF
0401B3 04 
0401B4 04 
               0730 ;
               0731 FUNTBL_END:		EQU	$
               0732 ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
               0733 TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
               0734 
               0735 ANDK:			EQU     80H
               0736 DIVK:			EQU     81H
               0737 EORK:			EQU     82H
               0738 MODK:			EQU     83H
               0739 ORK:			EQU     84H
               0740 ;
0401B5 F0      0741 SOPTBL:			DW24	SLE			; <= (STRING)
0401B6 05 
0401B7 04 
0401B8 F9      0742 DW24	SNE			; <>
0401B9 05 
0401BA 04 
0401BB E9      0743 DW24	SGE			; >=
0401BC 05 
0401BD 04 
0401BE DA      0744 DW24	SLT			; <
0401BF 05 
0401C0 04 
0401C1 00      0745 DW24	SEQ			; =
0401C2 06 
0401C3 04 
0401C4 E1      0746 DW24	SGT			; >
0401C5 05 
0401C6 04 
               0747 ;
               0748 ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
               0749 ;     Expression type is returned in A'F':
               0750 ;        Numeric - A' bit 7=0, F' sign bit cleared.
               0751 ;         String - A' bit 7=1, F' sign bit set.
               0752 ; Floating-point or integer result returned in HLH'L'C
               0753 ; Integer result denoted by C=0 and HLH'L' non-zero.
               0754 ; String result returned in string accumulator, DE set.
               0755 ;
               0756 ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
               0757 ;               (2) ^
               0758 ;               (3) * / MOD DIV
               0759 ;               (4) + -
               0760 ;               (5) = <> <= >= > <
               0761 ;               (6) AND
               0762 ;               (7) EOR OR
               0763 
               0764 ;
               0765 ; Level 7: EOR and OR
               0766 ;
0401C7 CD      0767 EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401C8 E0 
0401C9 01 
0401CA 04 
0401CB FE      0768 EXPR0A:			CP      EORK            	; Is operator EOR?
0401CC 82 
0401CD 28      0769 JR      Z,EXPR0B		; Yes, so skip to next bit
0401CE 03 
0401CF FE      0770 CP      ORK			; Is operator OR
0401D0 84 
0401D1 C0      0771 RET     NZ			; No, so return
               0772 ;
0401D2 CD      0773 EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D3 3E 
0401D4 0A 
0401D5 04 
0401D6 CD      0774 CALL    EXPR1           	; Get second operand
0401D7 E0 
0401D8 01 
0401D9 04 
0401DA CD      0775 CALL    DOIT            	; Do the operation
0401DB 4D 
0401DC 0A 
0401DD 04 
0401DE 18      0776 JR      EXPR0A          	; And continue
0401DF EB 
               0777 ;
               0778 ; Level 6: AND
               0779 ;
0401E0 CD      0780 EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E1 F5 
0401E2 01 
0401E3 04 
0401E4 FE      0781 EXPR1A:			CP      ANDK			; Is operator AND?
0401E5 80 
0401E6 C0      0782 RET     NZ			; No, so return
0401E7 CD      0783 CALL    SAVE_EV			; Save first operand
0401E8 3E 
0401E9 0A 
0401EA 04 
0401EB CD      0784 CALL    EXPR2			; Get second operand
0401EC F5 
0401ED 01 
0401EE 04 
0401EF CD      0785 CALL    DOIT			; Do the operation
0401F0 4D 
0401F1 0A 
0401F2 04 
0401F3 18      0786 JR      EXPR1A			; And continue
0401F4 EF 
               0787 ;
               0788 ; Level 5: Comparisons
               0789 ;
0401F5 CD      0790 EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F6 67 
0401F7 02 
0401F8 04 
0401F9 CD      0791 CALL    RELOP?			; Is it ">", "=" or "<"?
0401FA 15 
0401FB 0A 
0401FC 04 
0401FD C0      0792 RET     NZ			; No, so return
0401FE 47      0793 LD      B,A			; Store the first operator in B
0401FF FD      0794 INC     IY              	; Bump over operator
040200 23 
040201 CD      0795 CALL    NXT			;
040202 70 
040203 0A 
040204 04 
040205 CD      0796 CALL    RELOP?          	; Is it a compound operator?
040206 15 
040207 0A 
040208 04 
040209 20      0797 JR      NZ,EXPR2B		; No, so skip next bit
04020A 09 
04020B FD      0798 INC     IY			; Bump over operator
04020C 23 
04020D B8      0799 CP      B			; Compare with first
04020E CA      0800 JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
04020F 97 
040210 0C 
040211 04 
040212 80      0801 ADD     A,B
040213 47      0802 LD      B,A			; B: Unique code for the compound operator
040214 78      0803 EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08      0804 EX      AF,AF'
040216 FA      0805 JP      M,EXPR2S		; If it is a string, then branch here to handle it
040217 30 
040218 02 
040219 04 
04021A 08      0806 EX      AF,AF'
04021B D6      0807 SUB     4
04021C 04 
04021D FE      0808 CP      '>'-4
04021E 3A 
04021F 20      0809 JR      NZ,EXPR2C
040220 02 
040221 C6      0810 ADD     A,2
040222 02 
040223 CD      0811 EXPR2C:			CALL    SAVE1
040224 40 
040225 0A 
040226 04 
040227 CD      0812 CALL    EXPR3
040228 67 
040229 02 
04022A 04 
04022B CD      0813 CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022C 4D 
04022D 0A 
04022E 04 
04022F C9      0814 RET
               0815 ;
040230 08      0816 EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D      0817 DEC     A
040232 E6      0818 AND     7
040233 07 
040234 CD      0819 CALL    PUSHS           	; Save string on the stack
040235 B4 
040236 09 
040237 04 
040238 F5      0820 PUSH    AF              	; Save the operator
040239 CD      0821 CALL    EXPR3           	; Get the second string
04023A 67 
04023B 02 
04023C 04 
04023D 08      0822 EX      AF,AF'
04023E F2      0823 JP      P,TYPE_EV_
04023F 36 
040240 03 
040241 04 
040242 F1      0824 POP     AF
040243 4B      0825 LD      C,E             	; Length of string #2
040244 D1      0826 POP     DE
040245 21      0827 LD      HL,0
040246 00 
040247 00 
040248 00 
040249 39      0828 ADD     HL,SP
04024A 43      0829 LD      B,E             	; Length of string #1
04024B D5      0830 PUSH    DE
04024C 11      0831 LD      DE,ACCS
04024D 00 
04024E 4A 
04024F 04 
040250 EB      0832 EX      DE,HL
040251 CD      0833 CALL    DISPT2
040252 7C 
040253 0A 
040254 04 
040255 D1      0834 POP     DE
040256 EB      0835 EX      DE,HL
040257 7D      0836 LD	A,L
040258 21      0837 LD	HL,0
040259 00 
04025A 00 
04025B 00 
04025C 6F      0838 LD	L,A
04025D 39      0839 ADD     HL,SP
04025E F9      0840 LD      SP,HL
04025F EB      0841 EX      DE,HL
040260 AF      0842 XOR     A               	; Numeric marker
040261 4F      0843 LD      C,A             	; Integer marker
040262 08      0844 EX      AF,AF'
040263 FD      0845 LD      A,(IY)
040264 7E 
040265 00 
040266 C9      0846 RET
               0847 ;
               0848 ; Level 4: + and -
               0849 ;
040267 CD      0850 EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
040268 C4 
040269 02 
04026A 04 
04026B FE      0851 EXPR3A:			CP      '-'			; Is it "-"?
04026C 2D 
04026D 28      0852 JR      Z,EXPR3B		; Yes, so skip the next bit
04026E 09 
04026F FE      0853 CP      '+'			; Is it "+"?
040270 2B 
040271 C0      0854 RET     NZ			; No, so return
040272 08      0855 EX      AF,AF'			; Get the type
040273 FA      0856 JP      M,EXPR3S		; Branch here if string
040274 86 
040275 02 
040276 04 
040277 08      0857 EX      AF,AF'
040278 CD      0858 EXPR3B:			CALL    SAVE_EV			; Save the first operator
040279 3E 
04027A 0A 
04027B 04 
04027C CD      0859 CALL    EXPR4			; Fetch the second operator
04027D C4 
04027E 02 
04027F 04 
040280 CD      0860 CALL    DOIT			; Do the operation
040281 4D 
040282 0A 
040283 04 
040284 18      0861 JR      EXPR3A			; And continue
040285 E5 
               0862 ;
040286 08      0863 EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD      0864 INC     IY              	; Bump past the "+"
040288 23 
040289 CD      0865 CALL    PUSHS           	; Save the string on the stack
04028A B4 
04028B 09 
04028C 04 
04028D CD      0866 CALL    EXPR4           	; Fetch the second operator
04028E C4 
04028F 02 
040290 04 
040291 08      0867 EX      AF,AF'
040292 F2      0868 JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040293 36 
040294 03 
040295 04 
040296 01      0869 LD	BC, 0			; Clear BC
040297 00 
040298 00 
040299 00 
04029A 4B      0870 LD      C,E             	; C: Length of the second string
04029B D1      0871 POP     DE
04029C D5      0872 PUSH    DE
04029D 21      0873 LD      HL,ACCS
04029E 00 
04029F 4A 
0402A0 04 
               0874 ; BEGIN MISSING FROM BINARY
               0875 ; LD	A,E			;  E: Length of the first string
               0876 ; LD      DE,ACCS
               0877 ; LD	E,A 			; DE: Pointer to the end of the first string
               0878 ; END MISSING FROM BINARY
0402A1 54      0879 LD		D,H ; ADDED FROM BINARY
0402A2 79      0880 LD      A,C
0402A3 B7      0881 OR      A
0402A4 28      0882 JR      Z,EXP3S3
0402A5 0F 
0402A6 6F      0883 LD      L,A             	; Source
0402A7 83      0884 ADD     A,E
0402A8 5F      0885 LD      E,A             	; Destination
0402A9 3E      0886 LD      A,19
0402AA 13 
0402AB DA      0887 JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402AC 90 
0402AD 37 
0402AE 04 
0402AF D5      0888 PUSH    DE
0402B0 1D      0889 DEC     E
0402B1 2D      0890 DEC     L
0402B2 ED      0891 LDDR                    	; Copy
0402B3 B8 
0402B4 D1      0892 POP     DE
0402B5 D9      0893 EXP3S3:			EXX
0402B6 C1      0894 POP     BC
0402B7 CD      0895 CALL    POPS            	; Restore from stack
0402B8 DE 
0402B9 09 
0402BA 04 
0402BB D9      0896 EXX
0402BC F6      0897 OR      80H             	; Flag as a string
0402BD 80 
0402BE 08      0898 EX      AF,AF'
0402BF FD      0899 LD      A,(IY)			; Fetch the next character
0402C0 7E 
0402C1 00 
0402C2 18      0900 JR      EXPR3A			; And continue
0402C3 A7 
               0901 ;
               0902 ; Level 3: * / MOD DIV
               0903 ;
0402C4 CD      0904 EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402C5 E5 
0402C6 02 
0402C7 04 
0402C8 FE      0905 EXPR4A:			CP      '*'			; "*" is valid
0402C9 2A 
0402CA 28      0906 JR      Z,EXPR4B
0402CB 0B 
0402CC FE      0907 CP      '/'			; "/" is valid
0402CD 2F 
0402CE 28      0908 JR      Z,EXPR4B
0402CF 07 
0402D0 FE      0909 CP      MODK			; MOD token is valid
0402D1 83 
0402D2 28      0910 JR      Z,EXPR4B
0402D3 03 
0402D4 FE      0911 CP      DIVK			; DIV token is valid
0402D5 81 
0402D6 C0      0912 RET     NZ			; And return if it is anything else
0402D7 CD      0913 EXPR4B:			CALL    SAVE_EV
0402D8 3E 
0402D9 0A 
0402DA 04 
0402DB CD      0914 CALL    EXPR5
0402DC E5 
0402DD 02 
0402DE 04 
0402DF CD      0915 CALL    DOIT
0402E0 4D 
0402E1 0A 
0402E2 04 
0402E3 18      0916 JR      EXPR4A
0402E4 E3 
               0917 ;
               0918 ; Level 2: ^
               0919 ;
0402E5 CD      0920 EXPR5:			CALL    ITEM			; Get variable
0402E6 C5 
0402E7 03 
0402E8 04 
0402E9 B7      0921 OR      A               	; Test type
0402EA 08      0922 EX      AF,AF'          	; Save type
0402EB CD      0923 EXPR5A:			CALL    NXT			; Skip spaces
0402EC 70 
0402ED 0A 
0402EE 04 
0402EF FE      0924 CP      '^'			; Is the operator "^"?
0402F0 5E 
0402F1 C0      0925 RET     NZ			; No, so return
0402F2 CD      0926 CALL    SAVE_EV			; Save first operand
0402F3 3E 
0402F4 0A 
0402F5 04 
0402F6 CD      0927 CALL    ITEM			; Get second operand
0402F7 C5 
0402F8 03 
0402F9 04 
0402FA B7      0928 OR      A			; Test type
0402FB 08      0929 EX      AF,AF'			; Save type
0402FC CD      0930 CALL    DOIT			; Do the operation
0402FD 4D 
0402FE 0A 
0402FF 04 
040300 18      0931 JR      EXPR5A			; And continue
040301 E9 
               0932 ;
               0933 ; Evaluate a numeric expression
               0934 ;
040302 CD      0935 EXPRN:			CALL    EXPR			; Evaluate expression
040303 C7 
040304 01 
040305 04 
040306 08      0936 EX      AF,AF'			; Get the type
040307 F0      0937 RET     P			; And return if it is a number
040308 18      0938 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040309 2C 
               0939 ;
               0940 ; Evaluate a fixed-point expression
               0941 ;
04030A CD      0942 EXPRI:			CALL    EXPR			; Evaluate the expression
04030B C7 
04030C 01 
04030D 04 
04030E 08      0943 EX      AF,AF'			; Get the type
04030F F2      0944 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040310 62 
040311 06 
040312 04 
040313 18      0945 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040314 21 
               0946 ;
               0947 ; Evaluate a string expression
               0948 ;
040315 CD      0949 EXPRS:			CALL    EXPR			; Evaluate the expression
040316 C7 
040317 01 
040318 04 
040319 08      0950 EX      AF,AF'			; Get the type
04031A F8      0951 RET     M			; And return if it is a string
04031B 18      0952 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031C 19 
               0953 ;
               0954 ; Get a numeric variable
               0955 ;
04031D CD      0956 ITEMN:			CALL    ITEM			; Get the variable
04031E C5 
04031F 03 
040320 04 
040321 B7      0957 OR      A			; Test the type
040322 F0      0958 RET     P			; And return if it is a number
040323 18      0959 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040324 11 
               0960 ;
               0961 ; Get a fixed-point variable
               0962 ;
040325 CD      0963 ITEMI:			CALL    ITEM			; Get the variable
040326 C5 
040327 03 
040328 04 
040329 B7      0964 OR      A			; Test the type
04032A F2      0965 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04032B 62 
04032C 06 
04032D 04 
04032E 18      0966 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032F 06 
               0967 ;
               0968 ; Get a string variable
               0969 ;
040330 CD      0970 ITEMS:			CALL    ITEM			; Get the variable
040331 C5 
040332 03 
040333 04 
040334 B7      0971 OR      A			; Test the type
040335 F8      0972 RET     M			; If it is a string, then return
               0973 ;							; Otherwise
040336 3E      0974 TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040337 06 
040338 C3      0975 JP      ERROR_
040339 90 
04033A 37 
04033B 04 
               0976 ;
               0977 ; Evaluate a bracketed expression
               0978 ;
04033C CD      0979 ITEM1:			CALL    EXPR            	; Evaluate the expression
04033D C7 
04033E 01 
04033F 04 
040340 CD      0980 CALL    BRAKET			; Check for closing bracket
040341 2F 
040342 0A 
040343 04 
040344 08      0981 EX      AF,AF'
040345 C9      0982 RET
               0983 ;
               0984 ; HEX - Get hexadecimal constant.
               0985 ;   Inputs: ASCII string at (IY)
               0986 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               0987 ;           IY updated (points to delimiter)
               0988 ;
040346 CD      0989 HEX:			CALL    ZERO			; Set result to 0
040347 93 
040348 09 
040349 04 
04034A CD      0990 CALL    HEXDIG			; Fetch the character from IY
04034B F8 
04034C 09 
04034D 04 
04034E 38      0991 JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
04034F 1B 
040350 FD      0992 HEX1:			INC     IY			; Move pointer to next character
040351 23 
040352 E6      0993 AND     0FH			; Clear the top nibble
040353 0F 
040354 06      0994 LD      B,4			; Loop counter
040355 04 
               0995 ;
040356 D9      0996 HEX2:			EXX				; Shift the result left B (4) times. This makes
040357 52      0997 ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040358 29 
040359 D9      0998 EXX				; .
04035A 52      0999 ADC.S   HL,HL			; .
04035B ED 
04035C 6A 
04035D 10      1000 DJNZ    HEX2			; And loop
04035E F7 
04035F D9      1001 EXX
040360 B5      1002 OR      L			; OR in the digit
040361 6F      1003 LD      L,A
040362 D9      1004 EXX
               1005 ;
040363 CD      1006 CALL    HEXDIG			; Fetch the next character
040364 F8 
040365 09 
040366 04 
040367 30      1007 JR      NC,HEX1			; If it is a HEX digit then loop
040368 E7 
040369 AF      1008 XOR     A			; Clear A
04036A C9      1009 RET
               1010 ;
04036B 3E      1011 BADHEX:			LD      A,28
04036C 1C 
04036D C3      1012 JP      ERROR_          	; Error: "Bad HEX"
04036E 90 
04036F 37 
040370 04 
               1013 ;
               1014 ; BIN - Get binary constant.
               1015 ;   Inputs: ASCII string at (IY)
               1016 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               1017 ;           IY updated (points to delimiter)
               1018 ;
040371 CD      1019 BIN:			CALL    ZERO			; Set result to 0
040372 93 
040373 09 
040374 04 
040375 CD      1020 CALL	BINDIG			; Fetch the character from IY
040376 0B 
040377 0A 
040378 04 
040379 38      1021 JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037A 13 
04037B FD      1022 BIN1:			INC	IY			; Move pointer to next character
04037C 23 
04037D 0F      1023 RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04037E D9      1024 EXX				;
04037F 52      1025 ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040380 ED 
040381 6A 
040382 D9      1026 EXX
040383 52      1027 ADC.S	HL,HL
040384 ED 
040385 6A 
040386 CD      1028 CALL	BINDIG			; Fetch the next character
040387 0B 
040388 0A 
040389 04 
04038A 30      1029 JR	NC,BIN1
04038B EF 
04038C AF      1030 XOR	A			; Clear A
04038D C9      1031 RET
               1032 ;
04038E 3E      1033 BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
04038F 1C 
040390 CD      1034 CALL	EXTERR
040391 A7 
040392 37 
040393 04 
040394 42      1035 DB	"Bad Binary", 0
040395 61 
040396 64 
040397 20 
040397 42   
040398 69 
040399 6E 
04039A 61 
04039A 72   
04039B 79 
04039C 00 
               1036 ;
               1037 ; MINUS - Unary minus.
               1038 ;   Inputs: IY = text pointer
               1039 ;  Outputs: Numeric result, same type as argument.
               1040 ;           Result in H'L'HLC
               1041 ;
04039F CD      1042 MINUS:			CALL    ITEMN			; Get the numeric argument
0403A0 1D 
0403A1 03 
0403A2 04 
0403A3 0D      1043 MINUS0:			DEC     C			; Check exponent (C)
0403A4 0C      1044 INC     C			; If it is zero, then it's either a FP zero or an integer
0403A5 28      1045 JR      Z,NEGATE_EV        	; So do an integer negation
0403A6 06 
               1046 ;
0403A7 7C      1047 LD      A,H			; Do a FP negation by
0403A8 EE      1048 XOR     80H             	; Toggling the sign bit (H)
0403A9 80 
0403AA 67      1049 LD      H,A
0403AB AF      1050 XOR     A               	; Numeric marker
0403AC C9      1051 RET
               1052 ;
0403AD D9      1053 NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403AE 7C      1054 LD      A,H			; First do a one's complement by negating all the bytes
0403AF 2F      1055 CPL
0403B0 67      1056 LD      H,A
0403B1 7D      1057 LD      A,L
0403B2 2F      1058 CPL
0403B3 6F      1059 LD      L,A
0403B4 D9      1060 EXX
0403B5 7C      1061 LD      A,H
0403B6 2F      1062 CPL
0403B7 67      1063 LD      H,A
0403B8 7D      1064 LD      A,L
0403B9 2F      1065 CPL
0403BA 6F      1066 LD      L,A
0403BB D9      1067 ADD1:			EXX				; Then add 1
0403BC 23      1068 INC     HL
0403BD 7C      1069 LD      A,H
0403BE B5      1070 OR      L
0403BF D9      1071 EXX
0403C0 3E      1072 LD      A,0             	; Numeric marker
0403C1 00 
0403C2 C0      1073 RET     NZ
0403C3 23      1074 INC     HL
0403C4 C9      1075 RET
               1076 ;
               1077 ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
               1078 ; Item type is returned in A:  Bit 7=0 numeric.
               1079 ;                              Bit 7=1 string.
               1080 ; Numeric item returned in HLH'L'C.
               1081 ; String item returned in string accumulator,
               1082 ;   DE addresses byte after last (E=length).
               1083 ;
0403C5 CD      1084 ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403C6 79 
0403C7 16 
0403C8 04 
0403C9 CD      1085 CALL    NXT			; Skip spaces
0403CA 70 
0403CB 0A 
0403CC 04 
0403CD FD      1086 INC     IY			; Move to the prefix character
0403CE 23 
0403CF FE      1087 CP      '&'			; If `&`
0403D0 26 
0403D1 CA      1088 JP      Z,HEX           	; Then get a HEX constant
0403D2 46 
0403D3 03 
0403D4 04 
0403D5 FE      1089 CP	'%'			; If '%'
0403D6 25 
0403D7 28      1090 JR	Z,BIN			; Then get a BINARY constant
0403D8 98 
0403D9 FE      1091 CP      '-'			; If `-`
0403DA 2D 
0403DB 28      1092 JR      Z,MINUS         	; Then get a negative number
0403DC C2 
0403DD FE      1093 CP      '+'			; If `+`
0403DE 2B 
0403DF CA      1094 JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E0 1D 
0403E1 03 
0403E2 04 
0403E3 FE      1095 CP      '('			; If `(`
0403E4 28 
0403E5 CA      1096 JP      Z,ITEM1         	; Start of a bracketed expression
0403E6 3C 
0403E7 03 
0403E8 04 
0403E9 FE      1097 CP      34			; If `"`
0403EA 22 
0403EB 28      1098 JR      Z,CONS          	; Start of a string constant
0403EC 7A 
0403ED FE      1099 CP      TCMD_EV			; Is it out of range of the function table?
0403EE C6 
0403EF D2      1100 JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F0 97 
0403F1 0C 
0403F2 04 
0403F3 FE      1101 CP      FUNTOK			; If it is in range, then
0403F4 8D 
0403F5 D2      1102 JP      NC,DISPAT       	; It's a function
0403F6 83 
0403F7 0A 
0403F8 04 
0403F9 FD      1103 DEC     IY
0403FA 2B 
0403FB FE      1104 CP      ':'
0403FC 3A 
0403FD 30      1105 JR      NC,ITEM2		; VARIABLE?
0403FE 0C 
0403FF FE      1106 CP      '0'
040400 30 
040401 D2      1107 JP      NC,CON			; NUMERIC CONSTANT
040402 8E 
040403 04 
040404 04 
040405 FE      1108 CP      '.'
040406 2E 
040407 CA      1109 JP      Z,CON			; NUMERIC CONSTANT
040408 8E 
040409 04 
04040A 04 
04040B CD      1110 ITEM2:			CALL    GETVAR			; VARIABLE
04040C 6A 
04040D 3A 
04040E 04 
04040F 20      1111 JR      NZ,NOSUCH
040410 37 
040411 B7      1112 OR      A
040412 FA      1113 JP      M,LOADS			; STRING VARIABLE
040413 A0 
040414 04 
040415 04 
040416 B7      1114 LOADN:			OR      A
040417 28      1115 JR      Z,LOAD1			; BYTE VARIABLE
040418 20 
040419 0E      1116 LD      C,0
04041A 00 
04041B CB      1117 BIT     0,A
04041C 47 
04041D 28      1118 JR      Z,LOAD4			; INTEGER VARIABLE
04041E 03 
04041F DD      1119 LOAD5:			LD      C,(IX+4)
040420 4E 
040421 04 
040422 D9      1120 LOAD4:			EXX
040423 21      1121 LD	HL, 0			; TODO: Optimise
040424 00 
040425 00 
040426 00 
040427 DD      1122 LD      L,(IX+0)
040428 6E 
040429 00 
04042A DD      1123 LD      H,(IX+1)
04042B 66 
04042C 01 
04042D D9      1124 EXX
04042E 21      1125 LD	HL, 0			; TODO: Optimise
04042F 00 
040430 00 
040431 00 
040432 DD      1126 LD      L,(IX+2)
040433 6E 
040434 02 
040435 DD      1127 LD      H,(IX+3)
040436 66 
040437 03 
040438 C9      1128 RET
               1129 ;
040439 21      1130 LOAD1:			LD      HL,0
04043A 00 
04043B 00 
04043C 00 
04043D D9      1131 EXX
04043E 21      1132 LD      HL,0			; TODO: Optimise
04043F 00 
040440 00 
040441 00 
040442 DD      1133 LD      L,(IX+0)
040443 6E 
040444 00 
040445 D9      1134 EXX
040446 4C      1135 LD      C,H
040447 C9      1136 RET
               1137 ;
040448 DA      1138 NOSUCH:			JP      C,SYNTAX
040449 97 
04044A 0C 
04044B 04 
04044C 3A      1139 LD      A,(LISTON)
04044D 40 
04044E 4D 
04044F 04 
040450 CB      1140 BIT     5,A
040451 6F 
040452 3E      1141 LD      A,26
040453 1A 
040454 20      1142 JR      NZ,ERROR0_EV		; Throw "No such variable"
040455 26 
040456 FD      1143 NOS1:			INC     IY
040457 23 
040458 CD      1144 CALL    RANGE
040459 9F 
04045A 3C 
04045B 04 
04045C 30      1145 JR      NC,NOS1
04045D F8 
04045E DD      1146 LD      IX,PC
04045F 21 
040460 40 
040461 30 
040461 11   
040463 AF      1147 XOR     A
040464 4F      1148 LD      C,A
040465 18      1149 JR      LOAD4
040466 BB 
               1150 ;
               1151 ;CONS - Get string constant from ASCII string.
               1152 ;   Inputs: ASCII string at (IY)
               1153 ;  Outputs: Result in string accumulator.
               1154 ;           D = MS byte of ACCS, E = string length
               1155 ;           A7 = 1 (string marker)
               1156 ;           IY updated
               1157 ;
040467 11      1158 CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040468 00 
040469 4A 
04046A 04 
04046B FD      1159 CONS3:			LD      A,(IY)			; Fetch the first character and
04046C 7E 
04046D 00 
04046E FD      1160 INC     IY			; Increment the pointer
04046F 23 
040470 FE      1161 CP      '"'			; Check for start quote
040471 22 
040472 28      1162 JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040473 0C 
               1163 ;
040474 12      1164 CONS1:			LD      (DE),A			; Store the character in the string accumulator
040475 1C      1165 INC     E			; Increment the string accumulator pointer
040476 FE      1166 CP      CR			; Is it CR
040477 0D 
040478 20      1167 JR      NZ,CONS3		; No, so keep looping
040479 F1 
               1168 ;
04047A 3E      1169 LD      A,9
04047B 09 
04047C C3      1170 ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
04047D 90 
04047E 37 
04047F 04 
               1171 ;
040480 FD      1172 CONS2:			LD      A,(IY)			; Fetch the next character
040481 7E 
040482 00 
040483 FE      1173 CP      '"'			; Check for end quote?
040484 22 
040485 FD      1174 INC     IY			; Increment the pointer
040486 23 
040487 28      1175 JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040488 EB 
040489 FD      1176 DEC     IY			;
04048A 2B 
04048B 3E      1177 LD      A,80H           	; String marker
04048C 80 
04048D C9      1178 RET
               1179 ;
               1180 ;CON - Get unsigned numeric constant from ASCII string.
               1181 ;   Inputs: ASCII string at (IY).
               1182 ;  Outputs: Variable-type result in HLH'L'C
               1183 ;           IY updated (points to delimiter)
               1184 ;           A7 = 0 (numeric marker)
               1185 ;
04048E FD      1186 CON:			PUSH    IY
04048F E5 
040490 DD      1187 POP     IX
040491 E1 
040492 3E      1188 LD      A,36
040493 24 
040494 CD      1189 CALL    FPP
040495 9A 
040496 20 
040497 04 
040498 38      1190 JR      C,ERROR0_EV
040499 E2 
04049A DD      1191 PUSH    IX
04049B E5 
04049C FD      1192 POP     IY
04049D E1 
04049E AF      1193 XOR     A
04049F C9      1194 RET
               1195 ;
0404A0 11      1196 LOADS:			LD      DE,ACCS			; Where to store the string
0404A1 00 
0404A2 4A 
0404A3 04 
0404A4 1F      1197 RRA
0404A5 30      1198 JR      NC,LOADS2       	; Skip if it is a fixed string
0404A6 1A 
               1199 ;
0404A7 D9      1200 EXX				; This block was a call to LOAD4
0404A8 DD      1201 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404A9 6E 
0404AA 00 
0404AB DD      1202 LD      H,(IX+1)		; The maximum original string length
0404AC 66 
0404AD 01 
0404AE D9      1203 EXX
0404AF DD      1204 LD	HL,(IX+2)		; Address of the string (24-bit)
0404B0 27 
0404B1 02 
               1205 ;
0404B2 D9      1206 EXX
0404B3 7D      1207 LD      A,L
0404B4 D9      1208 EXX
0404B5 B7      1209 OR      A
0404B6 01      1210 LD	BC,0			; BC: Number of bytes to copy
0404B7 00 
0404B8 00 
0404B9 00 
0404BA 4F      1211 LD      C,A
0404BB 3E      1212 LD      A,80H           	; String marker
0404BC 80 
0404BD C8      1213 RET     Z
0404BE ED      1214 LDIR
0404BF B0 
0404C0 C9      1215 RET
0404C1 7E      1216 LOADS2:			LD      A,(HL)
0404C2 12      1217 LD      (DE),A
0404C3 23      1218 INC     HL
0404C4 FE      1219 CP      CR
0404C5 0D 
0404C6 3E      1220 LD      A,80H           	; String marker
0404C7 80 
0404C8 C8      1221 RET     Z
0404C9 1C      1222 INC     E
0404CA 20      1223 JR      NZ,LOADS2
0404CB F5 
0404CC C9      1224 RET                     	; Return null string
               1225 ;
               1226 ;VARIABLE-TYPE FUNCTIONS:
               1227 ;
               1228 ;Result returned in HLH'L'C (floating point)
               1229 ;Result returned in HLH'L' (C=0) (integer)
               1230 ;Result returned in string accumulator & DE (string)
               1231 ;All registers destroyed.
               1232 ;IY (text pointer) updated.
               1233 ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
               1234 ;
               1235 ;POS - horizontal cursor position.
               1236 ;VPOS - vertical cursor position.
               1237 ;EOF - return status of file.
               1238 ;BGET - read byte from file.
               1239 ;INKEY - as GET but wait only n centiseconds.
               1240 ;GET - wait for keypress and return ASCII value.
               1241 ;GET(n) - input from Z80 port n.
               1242 ;ASC - ASCII value of string.
               1243 ;LEN - length of string.
               1244 ;LOMEM - location of dynamic variables.
               1245 ;HIMEM - top of available RAM.
               1246 ;PAGE - start of current text page.
               1247 ;TOP - address of first free byte after program.
               1248 ;ERL - line number where last error occurred.
               1249 ;ERR - number of last error.
               1250 ;COUNT - number of printing characters since CR.
               1251 ;Results are integer numeric.
               1252 ;
0404CD CD      1253 POS:			CALL    GETCSR			; Return the horizontal cursor position
0404CE FC 
0404CF 3E 
0404D0 04 
0404D1 EB      1254 EX      DE,HL			;  L: The X cursor position
0404D2 C3      1255 JP      COUNT1			; Return an 8-bit value
0404D3 81 
0404D4 05 
0404D5 04 
               1256 ;
0404D6 CD      1257 VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404D7 FC 
0404D8 3E 
0404D9 04 
0404DA C3      1258 JP      COUNT1			; Return an 8-bit value
0404DB 81 
0404DC 05 
0404DD 04 
               1259 ;
0404DE CD      1260 EOF:			CALL    CHANEL			; Check for EOF
0404DF B0 
0404E0 18 
0404E1 04 
0404E2 CD      1261 CALL    OSSTAT
0404E3 85 
0404E4 43 
0404E5 04 
0404E6 CA      1262 JP      Z,TRUE			; Yes, so return true
0404E7 05 
0404E8 06 
0404E9 04 
0404EA C3      1263 JP      ZERO			; Otherwise return false (zero)
0404EB 93 
0404EC 09 
0404ED 04 
               1264 ;
0404EE CD      1265 BGET:			CALL    CHANEL          	; Channel number
0404EF B0 
0404F0 18 
0404F1 04 
0404F2 CD      1266 CALL    OSBGET
0404F3 74 
0404F4 43 
0404F5 04 
0404F6 6F      1267 LD      L,A
0404F7 C3      1268 JP      COUNT0			; Return an 8-bit value
0404F8 7F 
0404F9 05 
0404FA 04 
               1269 ;
0404FB CD      1270 INKEY:			CALL    ITEMI			; Get the argument
0404FC 25 
0404FD 03 
0404FE 04 
0404FF CB      1271 BIT	7, H			; Check the sign
040500 7C 
040501 D9      1272 EXX				; HL: The argument
040502 C2      1273 JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040503 EB 
040504 07 
040505 04 
040506 CD      1274 CALL	INKEY0 			; Do INKEY(n)
040507 DD 
040508 07 
040509 04 
04050A 18      1275 JR      ASC0			; Return a numeric value
04050B 1D 
               1276 ;
04050C CD      1277 GET:			CALL    NXT			; Skip whitespace
04050D 70 
04050E 0A 
04050F 04 
040510 FE      1278 CP      '('			; Is it GET(
040511 28 
040512 20      1279 JR      NZ,GET0			; No, so get a keyboard character
040513 0B 
040514 CD      1280 CALL    ITEMI           	; Yes, so fetch the port address
040515 25 
040516 03 
040517 04 
040518 D9      1281 EXX
040519 44      1282 LD      B,H			; BC: The port address
04051A 4D      1283 LD      C,L
04051B ED      1284 IN      L,(C)           	;  L: Input from port BC
04051C 68 
04051D 18      1285 JR      COUNT0			; Return an 8-bit value
04051E 60 
               1286 ;
04051F CD      1287 GET0:			CALL    GETS			; Read the keyboard character
040520 C7 
040521 07 
040522 04 
040523 18      1288 JR      ASC1			; And return the value
040524 0A 
               1289 ;
040525 CD      1290 ASC:			CALL    ITEMS			; Get the string argument argument
040526 30 
040527 03 
040528 04 
040529 AF      1291 ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052A BB      1292 CP      E			; Is the pointer 0
04052B CA      1293 JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04052C 05 
04052D 06 
04052E 04 
04052F 2A      1294 ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040530 00 
040531 4A 
040532 04 
040533 18      1295 JR      COUNT0			; An 8-bit value
040534 4A 
               1296 ;
040535 CD      1297 LEN:			CALL    ITEMS			; Get the string argument
040536 30 
040537 03 
040538 04 
040539 EB      1298 EX      DE,HL			; HL: Pointer into ACCS
04053A 18      1299 JR      COUNT0			; Return L
04053B 43 
               1300 ;
04053C 2A      1301 LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
04053D 1A 
04053E 4D 
04053F 04 
040540 3A      1302 LD	A, (LOMEM+2)
040541 1C 
040542 4D 
040543 04 
040544 18      1303 JR      COUNT2			; A 24-bit value
040545 41 
               1304 ;
040546 2A      1305 HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
040547 20 
040548 4D 
040549 04 
04054A 3A      1306 LD	A, (HIMEM+2)
04054B 22 
04054C 4D 
04054D 04 
04054E 18      1307 JR      COUNT2			; A 24-bit value
04054F 37 
               1308 ;
040550 2A      1309 PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040551 14 
040552 4D 
040553 04 
040554 3A      1310 LD	A, (PAGE_+2)		; A 24-bit value
040555 16 
040556 4D 
040557 04 
040558 18      1311 JR      COUNT2
040559 2D 
               1312 ;
04055A FD      1313 TOPV:			LD      A,(IY)			; Return the TOP system variable
04055B 7E 
04055C 00 
04055D FD      1314 INC     IY              	; Skip "P"
04055E 23 
04055F FE      1315 CP      'P'
040560 50 
040561 C2      1316 JP      NZ,SYNTAX       	; Throw "Syntax Error"
040562 97 
040563 0C 
040564 04 
040565 2A      1317 LD      HL,(TOP)
040566 17 
040567 4D 
040568 04 
040569 3A      1318 LD	A, (TOP+2)
04056A 19 
04056B 4D 
04056C 04 
04056D 18      1319 JR      COUNT2
04056E 18 
               1320 ;
04056F 2A      1321 ERLV:			LD      HL,(ERL)		; Return the error line
040570 33 
040571 4D 
040572 04 
040573 18      1322 JR      COUNT1			; A 16-bit value
040574 0C 
               1323 ;
040575 2A      1324 ERRV:			LD      HL,(ERR)		; Return the error value
040576 3F 
040577 4D 
040578 04 
040579 18      1325 JR      COUNT0			; An 8-bit value
04057A 04 
               1326 ;
04057B 2A      1327 COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04057C 3D 
04057D 4D 
04057E 04 
               1328 
04057F 26      1329 COUNT0:			LD      H,0			; Return L
040580 00 
040581 D9      1330 COUNT1:			EXX				; Return HL
040582 AF      1331 XOR     A
040583 4F      1332 LD      C,A             	; Integer marker
040584 67      1333 LD      H,A
040585 6F      1334 LD      L,A
040586 C9      1335 RET
040587 D9      1336 COUNT2:			EXX
040588 6F      1337 LD	L,A
040589 AF      1338 XOR	A
04058A 4F      1339 LD	C,A			; Integer marker
04058B 67      1340 LD	H,A
04058C C9      1341 RET
               1342 ;
               1343 ;OPENIN - Open a file for reading.
               1344 ;OPENOT - Open a file for writing.
               1345 ;OPENUP - Open a file for reading or writing.
               1346 ;Result is integer channel number (0 if error)
               1347 ;
04058D AF      1348 OPENOT:			XOR     A			; Open for writing
04058E 18      1349 JR	OPENIN_1
04058F 06 
               1350 ;
040590 3E      1351 OPENUP:			LD      A,2			; Open for reading / writing
040591 02 
040592 18      1352 JR	OPENIN_1
040593 02 
               1353 ;
040594 3E      1354 OPENIN:			LD      A,1			; Open for reading
040595 01 
               1355 ;
040596 F5      1356 OPENIN_1:		PUSH    AF              	; Save OPEN type
040597 CD      1357 CALL    ITEMS           	; Fetch the filename
040598 30 
040599 03 
04059A 04 
04059B 3E      1358 LD      A,CR
04059C 0D 
04059D 12      1359 LD      (DE),A
04059E F1      1360 POP     AF              	; Restore the OPEN type
04059F C6      1361 ADD     A,-1            	; Affect the flags
0405A0 FF 
0405A1 21      1362 LD      HL,ACCS
0405A2 00 
0405A3 4A 
0405A4 04 
0405A5 CD      1363 CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405A6 5D 
0405A7 43 
0405A8 04 
0405A9 6F      1364 LD      L,A			; L: Channel number
0405AA 18      1365 JR      COUNT0			; Return channel number to BASIC
0405AB D3 
               1366 ;
               1367 ;EXT - Return length of file.
               1368 ;PTR_EV - Return current file pointer.
               1369 ;Results are integer numeric.
               1370 ;
0405AC CD      1371 EXT:			CALL    CHANEL
0405AD B0 
0405AE 18 
0405AF 04 
0405B0 CD      1372 CALL    GETEXT
0405B1 BB 
0405B2 43 
0405B3 04 
0405B4 18      1373 JR      TIME0
0405B5 15 
               1374 ;
0405B6 CD      1375 PTR_EV:			CALL    CHANEL
0405B7 B0 
0405B8 18 
0405B9 04 
0405BA CD      1376 CALL    GETPTR
0405BB 8F 
0405BC 43 
0405BD 04 
0405BE 18      1377 JR      TIME0
0405BF 0B 
               1378 ;
               1379 ;TIME - Return current value of elapsed time.
               1380 ;Result is integer numeric.
               1381 ;
0405C0 FD      1382 TIMEV:			LD      A,(IY)
0405C1 7E 
0405C2 00 
0405C3 FE      1383 CP      '$'
0405C4 24 
0405C5 28      1384 JR      Z,TIMEVS
0405C6 0A 
0405C7 CD      1385 CALL    GETIME
0405C8 DC 
0405C9 3E 
0405CA 04 
0405CB D5      1386 TIME0:			PUSH    DE
0405CC D9      1387 EXX
0405CD E1      1388 POP     HL
0405CE AF      1389 XOR     A
0405CF 4F      1390 LD      C,A
0405D0 C9      1391 RET
               1392 ;
               1393 ;TIME$ - Return date/time string.
               1394 ;Result is string
               1395 ;
0405D1 FD      1396 TIMEVS:			INC     IY              ;SKIP $
0405D2 23 
0405D3 CD      1397 CALL    GETIMS
0405D4 D4 
0405D5 43 
0405D6 04 
0405D7 3E      1398 LD      A,80H           ;MARK STRING
0405D8 80 
0405D9 C9      1399 RET
               1400 ;
               1401 ;String comparison:
               1402 ;
0405DA CD      1403 SLT:			CALL    SCP
0405DB 8F 
0405DC 09 
0405DD 04 
0405DE D0      1404 RET     NC
0405DF 18      1405 JR      TRUE
0405E0 24 
               1406 ;
0405E1 CD      1407 SGT:			CALL    SCP
0405E2 8F 
0405E3 09 
0405E4 04 
0405E5 C8      1408 RET     Z
0405E6 D8      1409 RET     C
0405E7 18      1410 JR      TRUE
0405E8 1C 
               1411 ;
0405E9 CD      1412 SGE:			CALL    SCP
0405EA 8F 
0405EB 09 
0405EC 04 
0405ED D8      1413 RET     C
0405EE 18      1414 JR      TRUE
0405EF 15 
               1415 ;
0405F0 CD      1416 SLE:			CALL    SCP
0405F1 8F 
0405F2 09 
0405F3 04 
0405F4 28      1417 JR      Z,TRUE
0405F5 0F 
0405F6 D0      1418 RET     NC
0405F7 18      1419 JR      TRUE
0405F8 0C 
               1420 ;
0405F9 CD      1421 SNE:			CALL    SCP
0405FA 8F 
0405FB 09 
0405FC 04 
0405FD C8      1422 RET     Z
0405FE 18      1423 JR      TRUE
0405FF 05 
               1424 ;
040600 CD      1425 SEQ:			CALL    SCP
040601 8F 
040602 09 
040603 04 
040604 C0      1426 RET     NZ
040605 3E      1427 TRUE:			LD      A,-1
040606 FF 
040607 D9      1428 EXX
040608 67      1429 LD      H,A
040609 6F      1430 LD      L,A
04060A D9      1431 EXX
04060B 67      1432 LD      H,A
04060C 6F      1433 LD      L,A
04060D 3C      1434 INC     A
04060E 4F      1435 LD      C,A
04060F C9      1436 RET
               1437 ;
               1438 ;PI - Return PI (3.141592654)
               1439 ;Result is floating-point numeric.
               1440 ;
040610 3E      1441 PI:			LD      A,35
040611 23 
040612 18      1442 JR      FPP1
040613 44 
               1443 ;
               1444 ;ABS - Absolute value
               1445 ;Result is numeric, variable type.
               1446 ;
040614 3E      1447 ABSV:			LD      A,16
040615 10 
040616 18      1448 JR      FPPN
040617 3A 
               1449 ;
               1450 ;NOT - Complement integer.
               1451 ;Result is integer numeric.
               1452 ;
040618 3E      1453 NOTK:			LD      A,26
040619 1A 
04061A 18      1454 JR      FPPN
04061B 36 
               1455 ;
               1456 ;DEG - Convert radians to degrees
               1457 ;Result is floating-point numeric.
               1458 ;
04061C 3E      1459 DEG:			LD      A,21
04061D 15 
04061E 18      1460 JR      FPPN
04061F 32 
               1461 ;
               1462 ;RAD - Convert degrees to radians
               1463 ;Result is floating-point numeric.
               1464 ;
040620 3E      1465 RAD:			LD      A,27
040621 1B 
040622 18      1466 JR      FPPN
040623 2E 
               1467 ;
               1468 ;SGN - Return -1, 0 or +1
               1469 ;Result is integer numeric.
               1470 ;
040624 3E      1471 SGN:			LD      A,28
040625 1C 
040626 18      1472 JR      FPPN
040627 2A 
               1473 ;
               1474 ;INT - Floor function
               1475 ;Result is integer numeric.
               1476 ;
040628 3E      1477 INT_:			LD      A,23
040629 17 
04062A 18      1478 JR      FPPN
04062B 26 
               1479 ;
               1480 ;SQR - square root
               1481 ;Result is floating-point numeric.
               1482 ;
04062C 3E      1483 SQR:			LD      A,30
04062D 1E 
04062E 18      1484 JR      FPPN
04062F 22 
               1485 ;
               1486 ;TAN - Tangent function
               1487 ;Result is floating-point numeric.
               1488 ;
040630 3E      1489 TAN:			LD      A,31
040631 1F 
040632 18      1490 JR      FPPN
040633 1E 
               1491 ;
               1492 ;COS - Cosine function
               1493 ;Result is floating-point numeric.
               1494 ;
040634 3E      1495 COS:			LD      A,20
040635 14 
040636 18      1496 JR      FPPN
040637 1A 
               1497 ;
               1498 ;SIN - Sine function
               1499 ;Result is floating-point numeric.
               1500 ;
040638 3E      1501 SIN:			LD      A,29
040639 1D 
04063A 18      1502 JR      FPPN
04063B 16 
               1503 ;
               1504 ;EXP - Exponential function
               1505 ;Result is floating-point numeric.
               1506 ;
04063C 3E      1507 EXP:			LD      A,22
04063D 16 
04063E 18      1508 JR      FPPN
04063F 12 
               1509 ;
               1510 ;LN - Natural log.
               1511 ;Result is floating-point numeric.
               1512 ;
040640 3E      1513 LN:			LD      A,24
040641 18 
040642 18      1514 JR      FPPN
040643 0E 
               1515 ;
               1516 ;LOG - base-10 logarithm.
               1517 ;Result is floating-point numeric.
               1518 ;
040644 3E      1519 LOG:			LD      A,25
040645 19 
040646 18      1520 JR      FPPN
040647 0A 
               1521 ;
               1522 ;ASN - Arc-sine
               1523 ;Result is floating-point numeric.
               1524 ;
040648 3E      1525 ASN:			LD      A,18
040649 12 
04064A 18      1526 JR      FPPN
04064B 06 
               1527 ;
               1528 ;ATN - arc-tangent
               1529 ;Result is floating-point numeric.
               1530 ;
04064C 3E      1531 ATN:			LD      A,19
04064D 13 
04064E 18      1532 JR      FPPN
04064F 02 
               1533 ;
               1534 ;ACS - arc-cosine
               1535 ;Result is floating point numeric.
               1536 ;
040650 3E      1537 ACS:			LD      A,17
040651 11 
040652 F5      1538 FPPN:			PUSH    AF
040653 CD      1539 CALL    ITEMN
040654 1D 
040655 03 
040656 04 
040657 F1      1540 POP     AF
040658 CD      1541 FPP1:			CALL    FPP
040659 9A 
04065A 20 
04065B 04 
04065C DA      1542 JP      C,ERROR_
04065D 90 
04065E 37 
04065F 04 
040660 AF      1543 XOR     A
040661 C9      1544 RET
               1545 ;
               1546 ;SFIX - Convert to fixed-point notation
               1547 ;
040662 3E      1548 SFIX:			LD      A,38
040663 26 
040664 18      1549 JR      FPP1
040665 F2 
               1550 ;
               1551 ;SFLOAT - Convert to floating-point notation
               1552 ;
040666 3E      1553 SFLOAT:			LD      A,39
040667 27 
040668 18      1554 JR      FPP1
040669 EE 
               1555 ;
               1556 ;VAL - Return numeric value of string.
               1557 ;Result is variable type numeric.
               1558 ;
04066A CD      1559 VAL:			CALL    ITEMS
04066B 30 
04066C 03 
04066D 04 
04066E AF      1560 VAL0:			XOR     A
04066F 12      1561 LD      (DE),A
040670 DD      1562 LD      IX,ACCS
040671 21 
040672 00 
040673 4A 
040673 04   
040675 3E      1563 LD      A,36
040676 24 
040677 18      1564 JR      FPP1
040678 DF 
               1565 ;
               1566 ;EVAL - Pass string to expression evaluator.
               1567 ;Result is variable type (numeric or string).
               1568 ;
040679 CD      1569 EVAL_:			CALL    ITEMS
04067A 30 
04067B 03 
04067C 04 
04067D 3E      1570 LD      A,CR
04067E 0D 
04067F 12      1571 LD      (DE),A
040680 FD      1572 PUSH    IY
040681 E5 
040682 11      1573 LD      DE,ACCS
040683 00 
040684 4A 
040685 04 
040686 FD      1574 LD      IY,ACCS
040687 21 
040688 00 
040689 4A 
040689 04   
04068B 0E      1575 LD      C,0
04068C 00 
04068D CD      1576 CALL    LEXAN2          ;TOKENISE
04068E CF 
04068F 3C 
040690 04 
040691 12      1577 LD      (DE),A
040692 13      1578 INC     DE
040693 AF      1579 XOR     A
040694 CD      1580 CALL    PUSHS           ;PUT ON STACK
040695 B4 
040696 09 
040697 04 
040698 FD      1581 LD      IY,SIZEW	;WAS 2
040699 21 
04069A 03 
04069B 00 
04069B 00   
04069D FD      1582 ADD     IY,SP
04069E 39 
04069F CD      1583 CALL    EXPR
0406A0 C7 
0406A1 01 
0406A2 04 
0406A3 FD      1584 POP     IY
0406A4 E1 
0406A5 FD      1585 ADD     IY,SP
0406A6 39 
0406A7 FD      1586 LD      SP,IY           ;ADJUST STACK POINTER
0406A8 F9 
0406A9 FD      1587 POP     IY
0406AA E1 
0406AB 08      1588 EX      AF,AF'
0406AC C9      1589 RET
               1590 ;
               1591 ;RND - Random number function.
               1592 ; RND gives random integer 0-&FFFFFFFF
               1593 ; RND(-n) seeds random number & returns -n.
               1594 ; RND(0) returns last value in RND(1) form.
               1595 ; RND(1) returns floating-point 0-0.99999999.
               1596 ; RND(n) returns random integer 1-n.
               1597 ;
0406AD DD      1598 RND:			LD      IX,RANDOM
0406AE 21 
0406AF 38 
0406B0 4D 
0406B0 04   
0406B2 CD      1599 CALL    NXT
0406B3 70 
0406B4 0A 
0406B5 04 
0406B6 FE      1600 CP      '('
0406B7 28 
0406B8 28      1601 JR      Z,RND5          ;ARGUMENT FOLLOWS
0406B9 20 
0406BA CD      1602 CALL    LOAD5
0406BB 1F 
0406BC 04 
0406BD 04 
0406BE CB      1603 RND1:			RR      C
0406BF 19 
0406C0 06      1604 LD      B,32
0406C1 20 
0406C2 D9      1605 RND2:			EXX                     ;CALCULATE NEXT
0406C3 52      1606 ADC.S   HL,HL
0406C4 ED 
0406C5 6A 
0406C6 D9      1607 EXX
0406C7 52      1608 ADC.S   HL,HL
0406C8 ED 
0406C9 6A 
0406CA CB      1609 BIT     3,L
0406CB 5D 
0406CC 28      1610 JR      Z,RND3
0406CD 01 
0406CE 3F      1611 CCF
0406CF 10      1612 RND3:			DJNZ    RND2
0406D0 F1 
0406D1 CB      1613 RND4:			RL      C               ;SAVE CARRY
0406D2 11 
0406D3 CD      1614 CALL    STORE5          ;STORE NEW NUMBER
0406D4 05 
0406D5 16 
0406D6 04 
0406D7 AF      1615 XOR     A
0406D8 4F      1616 LD      C,A
0406D9 C9      1617 RET
0406DA CD      1618 RND5:			CALL    ITEMI
0406DB 25 
0406DC 03 
0406DD 04 
0406DE DD      1619 LD      IX,RANDOM
0406DF 21 
0406E0 38 
0406E1 4D 
0406E1 04   
0406E3 CB      1620 BIT     7,H             ;NEGATIVE?
0406E4 7C 
0406E5 37      1621 SCF
0406E6 20      1622 JR      NZ,RND4         ;SEED
0406E7 E9 
0406E8 CD      1623 CALL    TEST
0406E9 DF 
0406EA 08 
0406EB 04 
0406EC F5      1624 PUSH    AF
0406ED CD      1625 CALL    SWAP
0406EE D7 
0406EF 08 
0406F0 04 
0406F1 D9      1626 EXX
0406F2 CD      1627 CALL    LOAD5
0406F3 1F 
0406F4 04 
0406F5 04 
0406F6 C4      1628 CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406F7 BE 
0406F8 06 
0406F9 04 
0406FA D9      1629 EXX                     ;SCRAMBLE (CARE!)
0406FB 0E      1630 LD      C,7FH
0406FC 7F 
0406FD CB      1631 RND6:			BIT     7,H             ;FLOAT
0406FE 7C 
0406FF 20      1632 JR      NZ,RND7
040700 0A 
040701 D9      1633 EXX
040702 52      1634 ADD.S   HL,HL
040703 29 
040704 D9      1635 EXX
040705 52      1636 ADC.S   HL,HL
040706 ED 
040707 6A 
040708 0D      1637 DEC     C
040709 20      1638 JR      NZ,RND6
04070A F2 
04070B CB      1639 RND7:			RES     7,H             ;POSITIVE 0-0.999999
04070C BC 
04070D F1      1640 POP     AF
04070E C8      1641 RET     Z               ;ZERO ARGUMENT
04070F D9      1642 EXX
040710 7B      1643 LD      A,E
040711 3D      1644 DEC     A
040712 B2      1645 OR      D
040713 D9      1646 EXX
040714 B3      1647 OR      E
040715 B2      1648 OR      D
040716 C8      1649 RET     Z               ;ARGUMENT=1
040717 06      1650 LD      B,0             ;INTEGER MARKER
040718 00 
040719 3E      1651 LD      A,10
04071A 0A 
04071B CD      1652 CALL    FPP             ;MULTIPLY
04071C 9A 
04071D 20 
04071E 04 
04071F DA      1653 JP      C,ERROR_
040720 90 
040721 37 
040722 04 
040723 CD      1654 CALL    SFIX
040724 62 
040725 06 
040726 04 
040727 C3      1655 JP      ADD1
040728 BB 
040729 03 
04072A 04 
               1656 ;
               1657 ; INSTR - String search.
               1658 ; Result is integer numeric.
               1659 ;
04072B CD      1660 INSTR:			CALL    EXPRSC			; Get the first string expression
04072C 1E 
04072D 0A 
04072E 04 
04072F CD      1661 CALL    PUSHS           	; Push the string onto the stack
040730 B4 
040731 09 
040732 04 
040733 CD      1662 CALL    EXPRS           	; Get the second string expression
040734 15 
040735 03 
040736 04 
040737 C1      1663 POP     BC			;  C: String length, B: Value of A before PUSHS was called
040738 21      1664 LD      HL,0
040739 00 
04073A 00 
04073B 00 
04073C 39      1665 ADD     HL,SP           	; HL: Pointer to main string
04073D C5      1666 PUSH    BC              	;  C: Main string length
04073E 43      1667 LD      B,E             	;  B: Sub-string length
04073F CD      1668 CALL    NXT			; Skip whitespace
040740 70 
040741 0A 
040742 04 
040743 FE      1669 CP      ','			; Check if there is a comma for the third parameter
040744 2C 
040745 3E      1670 LD      A,0			;  A: Default start position in string
040746 00 
040747 20      1671 JR      NZ,INSTR1		; No, so skip the next bit
040748 1A 
040749 FD      1672 INC     IY              	; Skip the comma
04074A 23 
04074B C5      1673 PUSH    BC              	; Save the lengths
04074C E5      1674 PUSH    HL              	; Save the pointer to the main string
04074D CD      1675 CALL    PUSHS			; Push the string onto the stack
04074E B4 
04074F 09 
040750 04 
040751 CD      1676 CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040752 0A 
040753 03 
040754 04 
040755 C1      1677 POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040756 CD      1678 CALL    POPS			; Pop the string off the stack
040757 DE 
040758 09 
040759 04 
04075A E1      1679 POP     HL              	; Restore the pointer to the main string
04075B C1      1680 POP     BC              	; Restore the lengths
04075C D9      1681 EXX
04075D 7D      1682 LD      A,L			; A: The start position in the  string
04075E D9      1683 EXX
04075F B7      1684 OR      A			; Set the flags
040760 28      1685 JR      Z,INSTR1		; If it is zero, then skip
040761 01 
040762 3D      1686 DEC     A
040763 11      1687 INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040764 00 
040765 4A 
040766 04 
040767 CD      1688 CALL    SEARCH			; Do the search
040768 85 
040769 07 
04076A 04 
04076B D1      1689 POP     DE
04076C 28      1690 JR      Z,INSTR2        	; NB: Carry cleared
04076D 03 
04076E ED      1691 SBC     HL,HL
04076F 62 
040770 39      1692 ADD     HL,SP
040771 ED      1693 INSTR2:			SBC     HL,SP
040772 72 
040773 EB      1694 EX      DE,HL
040774 7D      1695 LD	A,L
040775 21      1696 LD      HL,0
040776 00 
040777 00 
040778 00 
040779 6F      1697 LD	L,A
04077A 39      1698 ADD     HL,SP
04077B F9      1699 LD      SP,HL
04077C EB      1700 EX      DE,HL
04077D CD      1701 CALL    BRAKET			; Check for closing bracket
04077E 2F 
04077F 0A 
040780 04 
040781 C3      1702 JP      COUNT1			; Return a numeric integer
040782 81 
040783 05 
040784 04 
               1703 ;
               1704 ; SEARCH - Search string for sub-string
               1705 ;    Inputs: Main string at HL length C
               1706 ;            Sub-string  at DE length B
               1707 ;            Starting offset A
               1708 ;   Outputs: NZ - not found
               1709 ;            Z - found at location HL-1
               1710 ;            Carry always cleared
               1711 ;
040785 C5      1712 SEARCH:			PUSH    BC			; Add the starting offset to HL
040786 01      1713 LD      BC,0
040787 00 
040788 00 
040789 00 
04078A 4F      1714 LD      C,A
04078B 09      1715 ADD     HL,BC           	; New start address
04078C C1      1716 POP     BC
04078D 91      1717 SUB     C			; If the starting offset > main string length, then do nothing
04078E 30      1718 JR      NC,SRCH4
04078F 2C 
040790 ED      1719 NEG
040791 44 
040792 4F      1720 LD      C,A             	; Remaining length
               1721 ;
040793 C5      1722 SRCH1:			PUSH    BC
040794 79      1723 LD	A,C
040795 01      1724 LD	BC,0
040796 00 
040797 00 
040798 00 
040799 4F      1725 LD	C,A
04079A 1A      1726 LD      A,(DE)
04079B ED      1727 CPIR                    	; Find the first character
04079C B1 
04079D 79      1728 LD      A,C
04079E C1      1729 POP     BC
04079F 20      1730 JR      NZ,SRCH4
0407A0 1B 
0407A1 4F      1731 LD      C,A
               1732 ;
               1733 ; This block of four instructions was commented as a bug fix by R.T.Russell
               1734 ;
0407A2 05      1735 DEC     B			; Bug fix
0407A3 B8      1736 CP      B			; Bug fix
0407A4 04      1737 INC     B			; Bug fix
0407A5 38      1738 JR      C,SRCH4			; Bug fix
0407A6 15 
               1739 ;
0407A7 C5      1740 PUSH    BC
0407A8 D5      1741 PUSH    DE
0407A9 E5      1742 PUSH    HL
0407AA 05      1743 DEC     B
0407AB 28      1744 JR      Z,SRCH3         	; Found!
0407AC 08 
0407AD 13      1745 SRCH2:			INC     DE
0407AE 1A      1746 LD      A,(DE)
0407AF BE      1747 CP      (HL)
0407B0 20      1748 JR      NZ,SRCH3
0407B1 03 
0407B2 23      1749 INC     HL
0407B3 10      1750 DJNZ    SRCH2
0407B4 F8 
0407B5 E1      1751 SRCH3:			POP     HL
0407B6 D1      1752 POP     DE
0407B7 C1      1753 POP     BC
0407B8 20      1754 JR      NZ,SRCH1
0407B9 D9 
0407BA AF      1755 XOR     A               	; Flags: Z, NC
0407BB C9      1756 RET                     	; Found
               1757 ;
0407BC F6      1758 SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407BD FF 
0407BE C9      1759 RET                     	; Not found
               1760 ;
               1761 ;CHRS - Return character with given ASCII value.
               1762 ;Result is string.
               1763 ;
0407BF CD      1764 CHRS:			CALL    ITEMI
0407C0 25 
0407C1 03 
0407C2 04 
0407C3 D9      1765 EXX
0407C4 7D      1766 LD      A,L
0407C5 18      1767 JR      GET1
0407C6 0E 
               1768 ;
               1769 ;GETS - Return key pressed as stringor character at position (X,Y).
               1770 ;Result is string.
               1771 ;
0407C7 CD      1772 GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407C8 70 
0407C9 0A 
0407CA 04 
0407CB FE      1773 CP	'('
0407CC 28 
0407CD CA      1774 JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407CE 32 
0407CF 44 
0407D0 04 
0407D1 CD      1775 CALL    OSRDCH
0407D2 59 
0407D3 3F 
0407D4 04 
0407D5 37      1776 GET1:			SCF
0407D6 18      1777 JR      INKEY1
0407D7 09 
               1778 ;
               1779 ; INKEYS - Wait up to n centiseconds for keypress.
               1780 ;          Return key pressed as string or null
               1781 ;          string if time elapsed.
               1782 ; Result is string.
               1783 ;
0407D8 CD      1784 INKEYS:			CALL    ITEMI			; Fetch the argument
0407D9 25 
0407DA 03 
0407DB 04 
0407DC D9      1785 EXX
0407DD CD      1786 INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407DE 62 
0407DF 3F 
0407E0 04 
0407E1 11      1787 INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E2 00 
0407E3 4A 
0407E4 04 
0407E5 12      1788 LD      (DE),A
0407E6 3E      1789 LD      A,80H
0407E7 80 
0407E8 D0      1790 RET     NC
0407E9 1C      1791 INC     E
0407EA C9      1792 RET
               1793 ;
               1794 ; INKEYM - Check immediately whether a given key is being pressed
               1795 ; Result is integer numeric
               1796 ;
               1797 INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407EB 3E     0001M LD	A, function
0407EC 1E 
0407ED 49     0002M RST.LIS	08h
0407EE CF 
0407EF 23      1798 INC	HL			; Index from 0
0407F0 7D      1799 LD	A, L			; Negate the LSB of the answer
0407F1 ED      1800 NEG
0407F2 44 
0407F3 4F      1801 LD	C, A			;  E: The positive keycode value
0407F4 3E      1802 LD	A, 1			; Throw an "Out of range" error
0407F5 01 
0407F6 FA      1803 JP	M, ERROR_		; if the argument < - 128
0407F7 90 
0407F8 37 
0407F9 04 
               1804 ;
0407FA 21      1805 LD	HL, BITLOOKUP		; HL: The bit lookup table
0407FB 1D 
0407FC 08 
0407FD 04 
0407FE 11      1806 LD	DE, 0
0407FF 00 
040800 00 
040801 00 
040802 79      1807 LD	A, C
040803 E6      1808 AND	00000111b		; Just need the first three bits
040804 07 
040805 5F      1809 LD	E, A			; DE: The bit number
040806 19      1810 ADD	HL, DE
040807 46      1811 LD	B, (HL)			;  B: The mask
               1812 ;
040808 79      1813 LD	A, C			; Fetch the keycode again
040809 E6      1814 AND	01111000b		; And divide by 8
04080A 78 
04080B 0F      1815 RRCA
04080C 0F      1816 RRCA
04080D 0F      1817 RRCA
04080E 5F      1818 LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04080F DD      1819 ADD	IX, DE			; IX: The address
040810 19 
040811 78      1820 LD	A, B			;  B: The mask
040812 DD      1821 AND	(IX+0)			; Check whether the bit is set
040813 A6 
040814 00 
040815 CA      1822 JP	Z, ZERO			; No, so return 0
040816 93 
040817 09 
040818 04 
040819 C3      1823 JP	TRUE			; Otherwise return -1
04081A 05 
04081B 06 
04081C 04 
               1824 ;
               1825 ; A bit lookup table
               1826 ;
04081D 01      1827 BITLOOKUP:		DB	01h, 02h, 04h, 08h
04081E 02 
04081F 04 
040820 08 
040821 10      1828 DB	10h, 20h, 40h, 80h
040822 20 
040823 40 
040824 80 
               1829 ;
               1830 ; MID$ - Return sub-string.
               1831 ; Result is string.
               1832 ;
040825 CD      1833 MIDS:			CALL    EXPRSC			; Get the first string expression
040826 1E 
040827 0A 
040828 04 
040829 CD      1834 CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082A B4 
04082B 09 
04082C 04 
04082D CD      1835 CALL    EXPRI			; Get the second expression
04082E 0A 
04082F 03 
040830 04 
040831 C1      1836 POP     BC			; C: String length, B: Value of A before PUSHS was called
040832 CD      1837 CALL    POPS			; Pop the string back off the stack to the string accumulator
040833 DE 
040834 09 
040835 04 
040836 D9      1838 EXX
040837 7D      1839 LD      A,L			; A: The start index
040838 D9      1840 EXX
040839 B7      1841 OR      A			; If the start index is 0, then we don't need to do the next bit
04083A 28      1842 JR      Z,MIDS1
04083B 0E 
04083C 3D      1843 DEC     A
04083D 6F      1844 LD      L,A			; L: The start index - 1
04083E 93      1845 SUB     E			; Subtract from the string length
04083F 1E      1846 LD      E,0			; Preemptively set the string length to 0
040840 00 
040841 30      1847 JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040842 07 
040843 ED      1848 NEG				; Negate the answer and
040844 44 
040845 4F      1849 LD      C,A			; C: Number of bytes to copy
040846 CD      1850 CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
040847 89 
040848 08 
040849 04 
04084A CD      1851 MIDS1:			CALL    NXT			; Skip whitespace
04084B 70 
04084C 0A 
04084D 04 
04084E FE      1852 CP      ','			; Check for a comma
04084F 2C 
040850 FD      1853 INC     IY			; Advance to the next character in the BASIC line
040851 23 
040852 28      1854 JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040853 0D 
040854 FD      1855 DEC     IY			; Restore the BASIC program pointer
040855 2B 
040856 CD      1856 CALL    BRAKET			; Check for a bracket
040857 2F 
040858 0A 
040859 04 
04085A 3E      1857 LD      A,80H			; String marker
04085B 80 
04085C C9      1858 RET
               1859 ;
               1860 ; LEFT$ - Return left part of string.
               1861 ; Carry cleared if entire string returned.
               1862 ; Result is string.
               1863 ;
04085D CD      1864 LEFTS:			CALL    EXPRSC			; Get the first string expression
04085E 1E 
04085F 0A 
040860 04 
040861 CD      1865 LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040862 B4 
040863 09 
040864 04 
040865 CD      1866 CALL    EXPRI			; Get the second expression
040866 0A 
040867 03 
040868 04 
040869 C1      1867 POP     BC			; C: String length, B: Value of A before PUSHS was called
04086A CD      1868 CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04086B DE 
04086C 09 
04086D 04 
04086E CD      1869 CALL    BRAKET			; Check for closing bracket
04086F 2F 
040870 0A 
040871 04 
040872 D9      1870 EXX
040873 7D      1871 LD      A,L			; L: The second parameter
040874 D9      1872 EXX
040875 BB      1873 CP      E			; Compare with the string length
040876 30      1874 JR      NC,LEFT3		; If it is greater than or equal then do nothing
040877 02 
040878 6B      1875 LD      L,E             	; For RIGHTS, no effect in LEFTS
040879 5F      1876 LEFT2:			LD      E,A			; E: The new length of string
04087A 3E      1877 LEFT3:			LD      A,80H           	; String marker
04087B 80 
04087C C9      1878 RET
               1879 ;
               1880 ; RIGHT$ - Return right part of string.
               1881 ; Result is string.
               1882 ;
04087D CD      1883 RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
04087E 5D 
04087F 08 
040880 04 
040881 D0      1884 RET     NC			; Do nothing if the second parameter is >= string length
040882 1C      1885 INC     E			; Check for a zero length string
040883 1D      1886 DEC     E
040884 C8      1887 RET     Z			; Yes, so do nothing
040885 4B      1888 LD      C,E			;  C: Number of bytes to copy
040886 7D      1889 LD      A,L
040887 93      1890 SUB     E
040888 6F      1891 LD      L,A			;  L: Index into the string
040889 79      1892 RIGHT1:			LD	A,C
04088A 01      1893 LD	BC,0
04088B 00 
04088C 00 
04088D 00 
04088E 4F      1894 LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04088F 7D      1895 LD	A,L
040890 21      1896 LD	HL,ACCS
040891 00 
040892 4A 
040893 04 
040894 6F      1897 LD	L,A			; HL: Source (in ACCS)
040895 11      1898 LD      DE,ACCS			; DE: Destination (start of ACCS)
040896 00 
040897 4A 
040898 04 
040899 ED      1899 LDIR                    	; Copy
04089A B0 
04089B 3E      1900 LD      A,80H			; String marker
04089C 80 
04089D C9      1901 RET
               1902 ;
               1903 ; STRINGS - Return n concatenations of a string.
               1904 ; Result is string.
               1905 ;
04089E CD      1906 STRING_:		CALL    EXPRI			; Get number of times to replicate
04089F 0A 
0408A0 03 
0408A1 04 
0408A2 CD      1907 CALL    COMMA			; Check for comma
0408A3 22 
0408A4 0A 
0408A5 04 
0408A6 D9      1908 EXX
0408A7 7D      1909 LD      A,L			; L: Number of iterations of string
0408A8 D9      1910 EXX
0408A9 F5      1911 PUSH    AF
0408AA CD      1912 CALL    EXPRS			; Get the string
0408AB 15 
0408AC 03 
0408AD 04 
0408AE CD      1913 CALL    BRAKET			; Check for closing bracket
0408AF 2F 
0408B0 0A 
0408B1 04 
0408B2 F1      1914 POP     AF			; A: Number of iterations of string
0408B3 B7      1915 OR      A			; Set flags
0408B4 28      1916 JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408B5 C3 
0408B6 3D      1917 DEC     A
0408B7 4F      1918 LD      C,A			; C: Loop counter
0408B8 3E      1919 LD      A,80H			; String marker
0408B9 80 
0408BA C8      1920 RET     Z
0408BB 1C      1921 INC     E			; Check for empty string
0408BC 1D      1922 DEC     E
0408BD C8      1923 RET     Z              		; And return
0408BE 43      1924 LD      B,E			; B: String length tally
0408BF 21      1925 LD	HL,ACCS
0408C0 00 
0408C1 4A 
0408C2 04 
0408C3 C5      1926 STRIN1:			PUSH    BC
0408C4 7E      1927 STRIN2:			LD      A,(HL)
0408C5 23      1928 INC     HL
0408C6 12      1929 LD      (DE),A
0408C7 1C      1930 INC     E
0408C8 3E      1931 LD      A,19
0408C9 13 
0408CA CA      1932 JP      Z,ERROR_         	; Throw a "String too long" error
0408CB 90 
0408CC 37 
0408CD 04 
0408CE 10      1933 DJNZ    STRIN2
0408CF F4 
0408D0 C1      1934 POP     BC
0408D1 0D      1935 DEC     C
0408D2 20      1936 JR      NZ,STRIN1
0408D3 EF 
0408D4 3E      1937 LD      A,80H
0408D5 80 
0408D6 C9      1938 RET
               1939 ;
               1940 ;SUBROUTINES
               1941 ;
               1942 ;SWAP - Swap arguments
               1943 ;Exchanges DE,HL D'E',H'L' and B,C
               1944 ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
               1945 ;
0408D7 79      1946 SWAP:			LD      A,C
0408D8 48      1947 LD      C,B
0408D9 47      1948 LD      B,A
0408DA EB      1949 EX      DE,HL
0408DB D9      1950 EXX
0408DC EB      1951 EX      DE,HL
0408DD D9      1952 EXX
0408DE C9      1953 RET
               1954 ;
               1955 ;TEST - Test HLH'L' for zero
               1956 ;Outputs: Z-flag set & A=0 if zero
               1957 ;Destroys: A,F
               1958 ;
0408DF 7C      1959 TEST:			LD      A,H
0408E0 B5      1960 OR      L
0408E1 D9      1961 EXX
0408E2 B4      1962 OR      H
0408E3 B5      1963 OR      L
0408E4 D9      1964 EXX
0408E5 C9      1965 RET
               1966 ;
               1967 ;DECODE - Decode line number in pseudo-binary.
               1968 ;   Inputs: IY = Text pointer.
               1969 ;   Outputs: HL=0, H'L'=line number, C=0.
               1970 ;   Destroys: A,C,H,L,H',L',IY,F
               1971 ;
0408E6 D9      1972 DECODE:			EXX
0408E7 21      1973 LD	HL, 0
0408E8 00 
0408E9 00 
0408EA 00 
0408EB FD      1974 LD      A,(IY)
0408EC 7E 
0408ED 00 
0408EE FD      1975 INC     IY
0408EF 23 
0408F0 17      1976 RLA
0408F1 17      1977 RLA
0408F2 67      1978 LD      H,A
0408F3 E6      1979 AND     0C0H
0408F4 C0 
0408F5 FD      1980 XOR     (IY)
0408F6 AE 
0408F7 00 
0408F8 FD      1981 INC     IY
0408F9 23 
0408FA 6F      1982 LD      L,A
0408FB 7C      1983 LD      A,H
0408FC 17      1984 RLA
0408FD 17      1985 RLA
0408FE E6      1986 AND     0C0H
0408FF C0 
040900 FD      1987 XOR     (IY)
040901 AE 
040902 00 
040903 FD      1988 INC     IY
040904 23 
040905 67      1989 LD      H,A
040906 D9      1990 EXX
               1991 ;			XOR     A
               1992 ;			LD      C,A
               1993 ;			LD      H,A
               1994 ;			LD      L,A
040907 21      1995 LD	HL, 0
040908 00 
040909 00 
04090A 00 
04090B 4D      1996 LD	C, L
04090C C9      1997 RET
               1998 ;
               1999 ;HEXSTR - convert numeric value to HEX string.
               2000 ;   Inputs: HLH'L'C = integer or floating-point number
               2001 ;  Outputs: String in string accumulator.
               2002 ;           E = string length.  D = ACCS/256
               2003 ;
04090D FD      2004 HEXSTS:			INC     IY              ;SKIP TILDE
04090E 23 
04090F CD      2005 CALL    ITEMN
040910 1D 
040911 03 
040912 04 
040913 CD      2006 CALL    HEXSTR
040914 1A 
040915 09 
040916 04 
040917 3E      2007 LD      A,80H
040918 80 
040919 C9      2008 RET
               2009 ;
04091A CD      2010 HEXSTR:			CALL    SFIX
04091B 62 
04091C 06 
04091D 04 
04091E 01      2011 LD      BC,8
04091F 08 
040920 00 
040921 00 
040922 11      2012 LD      DE,ACCS
040923 00 
040924 4A 
040925 04 
040926 C5      2013 HEXST1:			PUSH    BC
040927 06      2014 LD      B,4
040928 04 
040929 AF      2015 XOR     A
04092A D9      2016 HEXST2:			EXX
04092B 52      2017 ADD.S	HL,HL
04092C 29 
04092D D9      2018 EXX
04092E 52      2019 ADC.S	HL,HL
04092F ED 
040930 6A 
040931 17      2020 RLA
040932 10      2021 DJNZ    HEXST2
040933 F6 
040934 C1      2022 POP     BC
040935 0D      2023 DEC     C
040936 F8      2024 RET     M
040937 28      2025 JR      Z,HEXST3
040938 06 
040939 B7      2026 OR      A
04093A 20      2027 JR      NZ,HEXST3
04093B 03 
04093C B8      2028 CP      B
04093D 28      2029 JR      Z,HEXST1
04093E E7 
04093F C6      2030 HEXST3:			ADD     A,90H
040940 90 
040941 27      2031 DAA
040942 CE      2032 ADC     A,40H
040943 40 
040944 27      2033 DAA
040945 12      2034 LD      (DE),A
040946 13      2035 INC     DE
040947 47      2036 LD      B,A
040948 18      2037 JR      HEXST1
040949 DC 
               2038 ;
               2039 ;Function STR - convert numeric value to ASCII string.
               2040 ;   Inputs: HLH'L'C = integer or floating-point number.
               2041 ;  Outputs: String in string accumulator.
               2042 ;           E = length, D = ACCS/256
               2043 ;           A = 80H (type=string)
               2044 ;
               2045 ;First normalise for decimal output:
               2046 ;
04094A CD      2047 STRS:			CALL    NXT
04094B 70 
04094C 0A 
04094D 04 
04094E FE      2048 CP      '~'
04094F 7E 
040950 28      2049 JR      Z,HEXSTS
040951 BB 
040952 CD      2050 CALL    ITEMN
040953 1D 
040954 03 
040955 04 
040956 DD      2051 LD      IX,STAVAR
040957 21 
040958 00 
040959 4C 
040959 04   
04095B DD      2052 LD      A,(IX+3)
04095C 7E 
04095D 03 
04095E B7      2053 OR      A
04095F DD      2054 LD      IX,G9-1         ;G9 FORMAT
040960 21 
040961 8C 
040962 09 
040962 04   
040964 28      2055 JR      Z,STR0
040965 05 
040966 DD      2056 STR:			LD      IX,STAVAR
040967 21 
040968 00 
040969 4C 
040969 04   
04096B 11      2057 STR0:			LD      DE,ACCS
04096C 00 
04096D 4A 
04096E 04 
04096F 3E      2058 LD      A,37
040970 25 
040971 CD      2059 CALL    FPP
040972 9A 
040973 20 
040974 04 
040975 DA      2060 JP      C,ERROR_
040976 90 
040977 37 
040978 04 
040979 DD      2061 BIT     0,(IX+2)
04097A CB 
04097B 02 
04097C 46 
04097D 3E      2062 STR1:			LD      A,80H           ;STRING MARKER
04097E 80 
04097F C8      2063 RET     Z
040980 79      2064 LD      A,C
040981 C6      2065 ADD     A,4
040982 04 
040983 BB      2066 STR2:			CP      E
040984 28      2067 JR      Z,STR1
040985 F7 
040986 EB      2068 EX      DE,HL
040987 36      2069 LD      (HL),' '        ;TRAILING SPACE
040988 20 
040989 23      2070 INC     HL
04098A EB      2071 EX      DE,HL
04098B 18      2072 JR      STR2
04098C F6 
               2073 ;
04098D 09      2074 G9:			DW    9
04098E 00 
               2075 ;
               2076 ;STRING COMPARE
               2077 ;Compare string (DE) length B with string (HL) length C.
               2078 ;Result preset to false.
               2079 ;
04098F CD      2080 SCP:			CALL	SCP0
040990 9D 
040991 09 
040992 04 
               2081 ;
040993 3E      2082 ZERO:			LD      A,0
040994 00 
040995 D9      2083 EXX
040996 67      2084 LD      H,A
040997 6F      2085 LD      L,A
040998 D9      2086 EXX
040999 67      2087 LD      H,A
04099A 6F      2088 LD      L,A
04099B 4F      2089 LD      C,A
04099C C9      2090 RET
               2091 ;
04099D 04      2092 SCP0:			INC     B
04099E 0C      2093 INC     C
04099F 05      2094 SCP1:			DEC     B
0409A0 28      2095 JR      Z,SCP2
0409A1 0A 
0409A2 0D      2096 DEC     C
0409A3 28      2097 JR      Z,SCP3
0409A4 0C 
0409A5 1A      2098 LD      A,(DE)
0409A6 BE      2099 CP      (HL)
0409A7 C0      2100 RET     NZ
0409A8 13      2101 INC     DE
0409A9 23      2102 INC     HL
0409AA 18      2103 JR      SCP1
0409AB F3 
0409AC B7      2104 SCP2:			OR      A
0409AD 0D      2105 DEC     C
0409AE C8      2106 RET     Z
0409AF 37      2107 SCF
0409B0 C9      2108 RET
0409B1 B7      2109 SCP3:			OR      A
0409B2 0C      2110 INC     C
0409B3 C9      2111 RET
               2112 ;
               2113 ; PUSHS - SAVE STRING ON STACK.
               2114 ;     Inputs: String in string accumulator.
               2115 ;             E = string length.
               2116 ;             A - saved on stack.
               2117 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2118 ;
0409B4 CD      2119 PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409B5 79 
0409B6 16 
0409B7 04 
0409B8 DD      2120 POP     IX              	; IX: Return address
0409B9 E1 
0409BA B7      2121 OR      A               	; Clear the carry flag
0409BB 01      2122 LD	BC,0			; BC: Length of the string
0409BC 00 
0409BD 00 
0409BE 00 
0409BF 4B      2123 LD	C,E
0409C0 21      2124 LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C1 00 
0409C2 4A 
0409C3 04 
0409C4 11      2125 LD	DE,ACCS
0409C5 00 
0409C6 4A 
0409C7 04 
0409C8 59      2126 LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409C9 ED      2127 SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CA 52 
0409CB 39      2128 ADD     HL,SP			; Grow the stack
0409CC F9      2129 LD      SP,HL
0409CD 57      2130 LD      D,A			;  D: This needs to be set to A for some functions
               2131 ; BEGIN MISSING FROM BINARY
               2132 ; LD	B,A			; Stack A and C (the string length)
               2133 ; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
               2134 ; LD	B,0			; Reset B to 0 for the LDIR in this function
               2135 ; END MISSING FROM BINARY
0409CE D5      2136 PUSH 	DE ; ADDED FROM BINARY
0409CF 28      2137 JR      Z,PUSHS1        	; Is it zero length?
0409D0 0B 
0409D1 11      2138 LD      DE,ACCS			; DE: Destination
0409D2 00 
0409D3 4A 
0409D4 04 
0409D5 EB      2139 EX      DE,HL			; HL: Destination, DE: Address on stack
0409D6 ED      2140 LDIR	                    	; Copy to stack
0409D7 B0 
0409D8 CD      2141 CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409D9 79 
0409DA 16 
0409DB 04 
0409DC DD      2142 PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409DD E9 
               2143 ;
               2144 ; POPS - RESTORE STRING FROM STACK.
               2145 ;     Inputs: C = string length.
               2146 ;    Outputs: String in string accumulator.
               2147 ;             E = string length.
               2148 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2149 ;
0409DE DD      2150 POPS:			POP     IX              	; IX: Return address
0409DF E1 
0409E0 69      2151 LD	L,C			; Temporarily store string length in L
0409E1 01      2152 LD	BC,0
0409E2 00 
0409E3 00 
0409E4 00 
0409E5 4D      2153 LD	C,L			; BC: Number of bytes to copy
0409E6 21      2154 LD      HL,0			; HL: 0
0409E7 00 
0409E8 00 
0409E9 00 
0409EA 39      2155 ADD     HL,SP			; HL: Stack address
0409EB 11      2156 LD      DE,ACCS			; DE: Destination
0409EC 00 
0409ED 4A 
0409EE 04 
0409EF 0C      2157 INC     C			; Quick check to see if this is a zero length string
0409F0 0D      2158 DEC     C
0409F1 28      2159 JR      Z,POPS1         	; Yes it is, so skip
0409F2 02 
0409F3 ED      2160 LDIR                    	; No, so copy from the stack
0409F4 B0 
0409F5 F9      2161 POPS1:			LD      SP,HL			; Shrink the stack
0409F6 DD      2162 JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F7 E9 
               2163 ;
0409F8 FD      2164 HEXDIG:			LD      A,(IY)
0409F9 7E 
0409FA 00 
0409FB FE      2165 CP      '0'
0409FC 30 
0409FD D8      2166 RET     C
0409FE FE      2167 CP      '9'+1
0409FF 3A 
040A00 3F      2168 CCF
040A01 D0      2169 RET     NC
040A02 FE      2170 CP      'A'
040A03 41 
040A04 D8      2171 RET     C
040A05 D6      2172 SUB     'A'-10
040A06 37 
040A07 FE      2173 CP      16
040A08 10 
040A09 3F      2174 CCF
040A0A C9      2175 RET
               2176 ;
040A0B FD      2177 BINDIG:			LD	A,(IY)
040A0C 7E 
040A0D 00 
040A0E FE      2178 CP	'0'
040A0F 30 
040A10 D8      2179 RET	C
040A11 FE      2180 CP	'1'+1
040A12 32 
040A13 3F      2181 CCF
040A14 C9      2182 RET
               2183 ;
040A15 FE      2184 RELOP?:			CP      '>'
040A16 3E 
040A17 D0      2185 RET     NC
040A18 FE      2186 CP      '='
040A19 3D 
040A1A D0      2187 RET     NC
040A1B FE      2188 CP      '<'
040A1C 3C 
040A1D C9      2189 RET
               2190 ;
040A1E CD      2191 EXPRSC:			CALL    EXPRS
040A1F 15 
040A20 03 
040A21 04 
040A22 CD      2192 COMMA:			CALL    NXT
040A23 70 
040A24 0A 
040A25 04 
040A26 FD      2193 INC     IY
040A27 23 
040A28 FE      2194 CP      ','
040A29 2C 
040A2A C8      2195 RET     Z
040A2B 3E      2196 LD      A,5
040A2C 05 
040A2D 18      2197 JR      ERROR1_EV          ;"Missing ,"
040A2E 0B 
               2198 ;
040A2F CD      2199 BRAKET:			CALL    NXT
040A30 70 
040A31 0A 
040A32 04 
040A33 FD      2200 INC     IY
040A34 23 
040A35 FE      2201 CP      ')'
040A36 29 
040A37 C8      2202 RET     Z
040A38 3E      2203 LD      A,27
040A39 1B 
040A3A C3      2204 ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A3B 90 
040A3C 37 
040A3D 04 
               2205 ;
040A3E FD      2206 SAVE_EV:			INC     IY
040A3F 23 
040A40 08      2207 SAVE1:			EX      AF,AF'
040A41 FA      2208 JP      M,TYPE_EV_
040A42 36 
040A43 03 
040A44 04 
040A45 08      2209 EX      AF,AF'
040A46 E3      2210 EX      (SP),HL
040A47 D9      2211 EXX
040A48 E5      2212 PUSH    HL
040A49 D9      2213 EXX
040A4A F5      2214 PUSH    AF
040A4B C5      2215 PUSH    BC
040A4C E9      2216 JP      (HL)
               2217 ;
040A4D 08      2218 DOIT:			EX      AF,AF'
040A4E FA      2219 JP      M,TYPE_EV_
040A4F 36 
040A50 03 
040A51 04 
040A52 D9      2220 EXX
040A53 C1      2221 POP     BC              ;RETURN ADDRESS
040A54 D9      2222 EXX
040A55 79      2223 LD      A,C
040A56 C1      2224 POP     BC
040A57 47      2225 LD      B,A
040A58 F1      2226 POP     AF              ;OPERATOR
040A59 D9      2227 EXX
040A5A EB      2228 EX      DE,HL
040A5B E1      2229 POP     HL
040A5C D9      2230 EXX
040A5D EB      2231 EX      DE,HL
040A5E E1      2232 POP     HL
040A5F D9      2233 EXX
040A60 C5      2234 PUSH    BC
040A61 D9      2235 EXX
040A62 E6      2236 AND     0FH
040A63 0F 
040A64 CD      2237 CALL    FPP
040A65 9A 
040A66 20 
040A67 04 
040A68 38      2238 JR      C,ERROR1_EV
040A69 D0 
040A6A AF      2239 XOR     A
040A6B 08      2240 EX      AF,AF'          ;TYPE
040A6C FD      2241 LD      A,(IY)
040A6D 7E 
040A6E 00 
040A6F C9      2242 RET
               2243 ;
               2244 ; Skip spaces
               2245 ; - IY: String pointer
               2246 ; Returns:
               2247 ;  - A: The non-space character found
               2248 ; - IY: Points to the character before that
               2249 ;
040A70 FD      2250 NXT:			LD      A,(IY)			; Fetch the character
040A71 7E 
040A72 00 
040A73 FE      2251 CP      ' '			; If it is space, then return
040A74 20 
040A75 C0      2252 RET     NZ
040A76 FD      2253 INC     IY			; Increment the pointer and
040A77 23 
040A78 C3      2254 JP      NXT			; Loop
040A79 70 
040A7A 0A 
040A7B 04 
               2255 ;
040A7C E5      2256 DISPT2:			PUSH    HL
040A7D 21      2257 LD      HL,SOPTBL
040A7E B5 
040A7F 01 
040A80 04 
040A81 18      2258 JR      DISPT0
040A82 07 
               2259 ;
040A83 E5      2260 DISPAT:			PUSH    HL
040A84 D6      2261 SUB     FUNTOK
040A85 8D 
040A86 21      2262 LD      HL,FUNTBL
040A87 0A 
040A88 01 
040A89 04 
040A8A C5      2263 DISPT0:			PUSH    BC
               2264 
040A8B 01      2265 LD	BC, 3
040A8C 03 
040A8D 00 
040A8E 00 
040A8F 47      2266 LD	B, A
040A90 ED      2267 MLT	BC
040A91 4C 
040A92 09      2268 ADD	HL, BC
040A93 ED      2269 LD	HL, (HL)
040A94 27 
               2270 
               2271 ;			ADD     A,A
               2272 ;			LD      C,A
               2273 ;			LD      B,0
               2274 ;			ADD     HL,BC
               2275 ;			LD      A,(HL)
               2276 ;			INC     HL
               2277 ;			LD      H,(HL)
               2278 ;			LD      L,A
               2279 
040A95 C1      2280 POP     BC
040A96 E3      2281 EX      (SP),HL
040A97 C9      2282 RET                     ;OFF TO ROUTINE
               2283 
               2284 ; --- End eval.asm ---
               2285 
               2286 ; --- Begin exec.asm ---
               2287 ;
               2288 ; Title:	BBC Basic Interpreter - Z80 version
               2289 ;		Statement Execution & Assembler Module - "EXEC"
               2290 ; Author:	(C) Copyright  R.T.Russell  1984
               2291 ; Modified By:	Dean Belfield
               2292 ; Created:	12/05/2023
               2293 ; Last Updated:	26/06/2023
               2294 ;
               2295 ; Modinfo:
               2296 ; 27/01/1984:	Version 2.1
               2297 ; 02/03/1987:	Version 3.0
               2298 ; 11/06/1987:	Version 3.1
               2299 ; 12/05/2023:	Modified by Dean Belfield
               2300 ; 07/06/2023:	Modified to run in ADL mode
               2301 ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
               2302 
               2303 ; .ASSUME	ADL = 1
               2304 
               2305 ; INCLUDE	"equs.inc"
               2306 
               2307 ; SEGMENT CODE
               2308 
               2309 ; XDEF	XEQ
               2310 ; XDEF	CHAIN0
               2311 ; XDEF	RUN
               2312 ; XDEF	SYNTAX
               2313 ; XDEF	ESCAPE
               2314 ; XDEF	FN_EX
               2315 ; XDEF	USR
               2316 ; XDEF	STORE5
               2317 ; XDEF	STORE4
               2318 ; XDEF	CHECK
               2319 ; XDEF	TERMQ
               2320 ; XDEF	FILL
               2321 ; XDEF	X4OR5
               2322 ; XDEF	MUL16
               2323 ; XDEF	CHANEL
               2324 ; XDEF	ASSEM
               2325 
               2326 ; XREF	AUTO
               2327 ; XREF	DELETE
               2328 ; XREF	LOAD
               2329 ; XREF	LIST_
               2330 ; XREF	NEW
               2331 ; XREF	OLD
               2332 ; XREF	RENUM
               2333 ; XREF	SAVE
               2334 ; XREF	SOUND
               2335 ; XREF	CLG
               2336 ; XREF	DRAW
               2337 ; XREF	ENVEL
               2338 ; XREF	GCOL
               2339 ; XREF	MODE
               2340 ; XREF	MOVE
               2341 ; XREF	PLOT
               2342 ; XREF	COLOUR
               2343 ; XREF	EXPRS
               2344 ; XREF	HIMEM
               2345 ; XREF	LOAD0
               2346 ; XREF	RANDOM
               2347 ; XREF	CLEAR
               2348 ; XREF	ERRTRP
               2349 ; XREF	PAGE_
               2350 ; XREF	DATAPTR
               2351 ; XREF	ERRLIN
               2352 ; XREF	TRAP
               2353 ; XREF	NXT
               2354 ; XREF	SETLIN
               2355 ; XREF	CLOOP
               2356 ; XREF	OSSHUT
               2357 ; XREF	WARM
               2358 ; XREF	TRACEN
               2359 ; XREF	OUTCHR
               2360 ; XREF	PBCDL
               2361 ; XREF	OSCLI
               2362 ; XREF	LISTON
               2363 ; XREF	GETVAR
               2364 ; XREF	PUTVAR
               2365 ; XREF	DATPTR
               2366 ; XREF	ERROR_
               2367 ; XREF	EXPR
               2368 ; XREF	CREATE
               2369 ; XREF	EXPRI
               2370 ; XREF	BRAKET
               2371 ; XREF	FREE
               2372 ; XREF	OSBPUT
               2373 ; XREF	COUNT
               2374 ; XREF	STR
               2375 ; XREF	HEXSTR
               2376 ; XREF	CRLF
               2377 ; XREF	ITEMI
               2378 ; XREF	FINDL
               2379 ; XREF	TEST
               2380 ; XREF	EXPRN
               2381 ; XREF	DLOAD5
               2382 ; XREF	DLOAD5_SPL
               2383 ; XREF	LOADN
               2384 ; XREF	FPP
               2385 ; XREF	SWAP
               2386 ; XREF	GETDEF
               2387 ; XREF	ZERO
               2388 ; XREF	OSBGET
               2389 ; XREF	BUFFER
               2390 ; XREF	CONS
               2391 ; XREF	VAL0
               2392 ; XREF	OSLINE
               2393 ; XREF	CLRSCN
               2394 ; XREF	TELL
               2395 ; XREF	SAYLN
               2396 ; XREF	REPORT
               2397 ; XREF	PUTPTR
               2398 ; XREF	PUTIME
               2399 ; XREF	PUTIMS
               2400 ; XREF	LOMEM
               2401 ; XREF	WIDTH
               2402 ; XREF	OSWRCH
               2403 ; XREF	COMMA
               2404 ; XREF	OSCALL
               2405 ; XREF	SFIX
               2406 ; XREF	LOAD4
               2407 ; XREF	PUSHS
               2408 ; XREF	POPS
               2409 ; XREF	LOADS
               2410 ; XREF	PUTCSR
               2411 ; XREF	OUT_
               2412 ; XREF	R0
               2413 ;
               2414 ; List of token values used in this module
               2415 ;
               2416 TAND:			EQU     80H
               2417 TOR:			EQU     84H
               2418 TERROR_EX:			EQU     85H
               2419 LINE_EX_:			EQU     86H
               2420 OFF_:			EQU     87H
               2421 STEP:			EQU     88H
               2422 SPC:			EQU     89H
               2423 TAB:			EQU     8AH
               2424 ELSE_EX_:			EQU     8BH
               2425 THEN_EX_:			EQU     8CH
               2426 LINO_EX:			EQU     8DH
               2427 TO_EX:			EQU     B8H
               2428 TCMD_EX:			EQU     C6H
               2429 TCALL:			EQU     D6H
               2430 DATA_EX_:			EQU     DCH
               2431 DEF_:			EQU     DDH
               2432 TGOSUB:			EQU     E4H
               2433 TGOTO:			EQU     E5H
               2434 TON:			EQU     EEH
               2435 TPROC:			EQU     F2H
               2436 TSTOP:			EQU     FAH
               2437 
               2438 ; The command table
               2439 ; Commands are tokens from C6H onwards; this lookup table is used to
               2440 ; run the corresponding function; Note that DATA and DEF both use the same
               2441 ; code as REM
               2442 ;
040A98 19      2443 CMDTAB:			DW24  AUTO			; C6H
040A99 37 
040A9A 04 
040A9B 7C      2444 DW24  DELETE			; C7H
040A9C 35 
040A9D 04 
040A9E 5A      2445 DW24  LOAD			; C8H
040A9F 37 
040AA0 04 
040AA1 B7      2446 DW24  LIST_			; C9H
040AA2 35 
040AA3 04 
040AA4 37      2447 DW24  NEW			; CAH
040AA5 37 
040AA6 04 
040AA7 3D      2448 DW24  OLD			; CBH
040AA8 37 
040AA9 04 
040AAA 46      2449 DW24  RENUM			; CCH
040AAB 36 
040AAC 04 
040AAD 6B      2450 DW24  SAVE			; CDH
040AAE 37 
040AAF 04 
040AB0 D2      2451 DW24  PUT			; CEH
040AB1 15 
040AB2 04 
040AB3 C8      2452 DW24  PTR_EX			; CFH
040AB4 13 
040AB5 04 
040AB6 E2      2453 DW24  PAGEV_EX			; D0H
040AB7 13 
040AB8 04 
040AB9 F5      2454 DW24  TIMEV_EX			; D1H
040ABA 13 
040ABB 04 
040ABC 1E      2455 DW24  LOMEMV_EX			; D2H
040ABD 14 
040ABE 04 
040ABF 37      2456 DW24  HIMEMV_EX			; D3H
040AC0 14 
040AC1 04 
040AC2 5C      2457 DW24  SOUND			; D4H
040AC3 46 
040AC4 04 
040AC5 EC      2458 DW24  BPUT			; D5H
040AC6 14 
040AC7 04 
040AC8 04      2459 DW24  CALL_			; D6H
040AC9 15 
040ACA 04 
040ACB 4C      2460 DW24  CHAIN			; D7H
040ACC 0B 
040ACD 04 
040ACE 97      2461 DW24  CLR			; D8H
040ACF 13 
040AD0 04 
040AD1 E0      2462 DW24  CLOSE			; D9H
040AD2 14 
040AD3 04 
040AD4 F8      2463 DW24  CLG			; DAH
040AD5 43 
040AD6 04 
040AD7 6A      2464 DW24  CLS			; DBH
040AD8 13 
040AD9 04 
040ADA 2B      2465 DW24  REM_EX             		; DCH: DATA
040ADB 0C 
040ADC 04 
040ADD 2B      2466 DW24  REM_EX             		; DDH: DEF
040ADE 0C 
040ADF 04 
040AE0 F1      2467 DW24  DIM_EX			; DEH
040AE1 0C 
040AE2 04 
040AE3 22      2468 DW24  DRAW			; DFH
040AE4 46 
040AE5 04 
040AE6 C6      2469 DW24  END_			; E0H
040AE7 0B 
040AE8 04 
040AE9 82      2470 DW24  ENDPRO			; E1H
040AEA 11 
040AEB 04 
040AEC 7C      2471 DW24  ENVEL			; E2H
040AED 49 
040AEE 04 
040AEF 97      2472 DW24  FOR_EX			; E3H
040AF0 0F 
040AF1 04 
040AF2 47      2473 DW24  GOSUB_EX			; E4H
040AF3 0F 
040AF4 04 
040AF5 2B      2474 DW24  GOTO_EX			; E5H
040AF6 0F 
040AF7 04 
040AF8 B6      2475 DW24  GCOL			; E6H
040AF9 45 
040AFA 04 
040AFB 36      2476 DW24  IF_			; E7H
040AFC 13 
040AFD 04 
040AFE 24      2477 DW24  INPUT			; E8H
040AFF 12 
040B00 04 
040B01 4C      2478 DW24  LET			; E9H
040B02 0C 
040B03 04 
040B04 27      2479 DW24  LOCAL_EX_			; EAH
040B05 11 
040B06 04 
040B07 08      2480 DW24  MODE			; EBH
040B08 44 
040B09 04 
040B0A 1A      2481 DW24  MOVE			; ECH
040B0B 46 
040B0C 04 
040B0D E5      2482 DW24  NEXT_EX			; EDH
040B0E 0F 
040B0F 04 
040B10 BE      2483 DW24  ON_EX_			; EEH
040B11 0E 
040B12 04 
040B13 A1      2484 DW24  VDU			; EFH
040B14 14 
040B15 04 
040B16 E8      2485 DW24  PLOT			; F0H
040B17 45 
040B18 04 
040B19 C7      2486 DW24  PRINT_			; F1H
040B1A 0D 
040B1B 04 
040B1C 84      2487 DW24  PROC_EX			; F2H
040B1D 10 
040B1E 04 
040B1F D6      2488 DW24  READ			; F3H
040B20 12 
040B21 04 
040B22 2B      2489 DW24  REM_EX			; F4H
040B23 0C 
040B24 04 
040B25 67      2490 DW24  REPEAT_EX			; F5H
040B26 0F 
040B27 04 
040B28 8F      2491 DW24  REPOR			; F6H
040B29 13 
040B2A 04 
040B2B A1      2492 DW24  RESTOR_EX			; F7H
040B2C 13 
040B2D 04 
040B2E 55      2493 DW24  RETURN			; F8H
040B2F 0F 
040B30 04 
040B31 46      2494 DW24  RUN			; F9H
040B32 0B 
040B33 04 
040B34 77      2495 DW24  STOP			; FAH
040B35 13 
040B36 04 
040B37 04      2496 DW24  COLOUR			; FBH
040B38 45 
040B39 04 
040B3A 83      2497 DW24  TRACE_EX			; FCH
040B3B 14 
040B3C 04 
040B3D 71      2498 DW24  UNTIL_EX			; FDH
040B3E 0F 
040B3F 04 
040B40 75      2499 DW24  WIDTHV			; FEH
040B41 14 
040B42 04 
040B43 11      2500 DW24  CLI             		; FFH: OSCLI
040B44 0C 
040B45 04 
               2501 
               2502 ; RUN
               2503 ; RUN "filename"
               2504 ;
040B46 CD      2505 RUN:			CALL    TERMQ			; Standalone RUN command?
040B47 A4 
040B48 17 
040B49 04 
040B4A 28      2506 JR      Z,RUN0			; Yes, so just RUN the code
040B4B 10 
               2507 
               2508 ; CHAIN "filename"
               2509 ;
040B4C CD      2510 CHAIN:			CALL    EXPRS			; Get the filename
040B4D 15 
040B4E 03 
040B4F 04 
040B50 3E      2511 LD      A,CR			; Terminate it with a CR
040B51 0D 
040B52 12      2512 LD      (DE),A
040B53 ED      2513 CHAIN0:			LD      SP,(HIMEM)		; Reset SP
040B54 7B 
040B55 20 
040B56 4D 
040B56 04   
040B58 CD      2514 CALL    LOAD0			; And load the file in
040B59 4F 
040B5A 38 
040B5B 04 
               2515 ;
040B5C ED      2516 RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
040B5D 7B 
040B5E 20 
040B5F 4D 
040B5F 04   
040B61 DD      2517 LD      IX,RANDOM		; Pointer to the RANDOM sysvar
040B62 21 
040B63 38 
040B64 4D 
040B64 04   
040B66 ED      2518 @@:			LD      A, R			; Use the R register to seed the random number generator
040B67 5F 
040B68 28      2519 JR      Z, @B			; Loop unti we get a non-zero value in A
040B69 FC 
040B6A 07      2520 RLCA				; Rotate it
040B6B 07      2521 RLCA
040B6C DD      2522 LD      (IX+3),A		; And store
040B6D 77 
040B6E 03 
040B6F 9F      2523 SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B70 DD      2524 LD      (IX+4),A		; And store
040B71 77 
040B72 04 
040B73 CD      2525 CALL    CLEAR
040B74 A6 
040B75 38 
040B76 04 
040B77 21      2526 LD      HL,0			; Clear the error trap sysvar
040B78 00 
040B79 00 
040B7A 00 
040B7B 22      2527 LD      (ERRTRP),HL
040B7C 2C 
040B7D 4D 
040B7E 04 
040B7F 2A      2528 LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B80 14 
040B81 4D 
040B82 04 
040B83 3E      2529 LD      A,DATA_EX_			; The DATA token value
040B84 DC 
040B85 CD      2530 CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B86 78 
040B87 18 
040B88 04 
040B89 22      2531 LD      (DATPTR),HL     	; Set data pointer
040B8A 31 
040B8B 4D 
040B8C 04 
040B8D FD      2532 LD      IY,(PAGE_)		; Load IY with the start of program memory
040B8E 2A 
040B8F 14 
040B90 4D 
040B90 04   
               2533 ;
040B92 CD      2534 XEQ0:			CALL    NEWLIN
040B93 DA 
040B94 0B 
040B95 04 
040B96 FD      2535 XEQ:			LD      (ERRLIN),IY     	; Error pointer
040B97 22 
040B98 35 
040B99 4D 
040B99 04   
040B9B CD      2536 CALL    TRAP           		; Check keyboard
040B9C 9D 
040B9D 3F 
040B9E 04 
040B9F CD      2537 XEQ1:			CALL    NXT
040BA0 70 
040BA1 0A 
040BA2 04 
040BA3 FD      2538 INC     IY
040BA4 23 
040BA5 FE      2539 CP      ':'             	; Seperator
040BA6 3A 
040BA7 28      2540 JR      Z,XEQ1
040BA8 F6 
040BA9 FE      2541 CP      CR
040BAA 0D 
040BAB 28      2542 JR      Z,XEQ0          	; New program line
040BAC E5 
040BAD D6      2543 SUB     TCMD_EX
040BAE C6 
040BAF DA      2544 JP      C,LET0          	; Implied "LET"
040BB0 3A 
040BB1 0C 
040BB2 04 
               2545 
040BB3 01      2546 LD	BC, 3
040BB4 03 
040BB5 00 
040BB6 00 
040BB7 47      2547 LD	B, A
040BB8 ED      2548 MLT	BC
040BB9 4C 
040BBA 21      2549 LD	HL,CMDTAB
040BBB 98 
040BBC 0A 
040BBD 04 
040BBE 09      2550 ADD	HL, BC
040BBF ED      2551 LD	HL, (HL)		; Table entry
040BC0 27 
               2552 
               2553 ;			ADD     A,A
               2554 ;			LD      C,A
               2555 ;			LD      B,0
               2556 ;			LD      HL,CMDTAB
               2557 ;			ADD     HL,BC
               2558 ;			LD      A,(HL)          	; Table entry
               2559 ;			INC     HL
               2560 ;			LD      H,(HL)
               2561 ;			LD      L,A
               2562 
040BC1 CD      2563 CALL    NXT
040BC2 70 
040BC3 0A 
040BC4 04 
040BC5 E9      2564 JP      (HL)            	; Execute the statement
               2565 
               2566 ;END
               2567 ;
040BC6 CD      2568 END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BC7 DE 
040BC8 39 
040BC9 04 
040BCA 7C      2569 LD      A,H
040BCB B5      2570 OR      L               ;DIRECT?
040BCC CA      2571 JP      Z,CLOOP
040BCD B0 
040BCE 30 
040BCF 04 
040BD0 1E      2572 LD      E,0
040BD1 00 
040BD2 CD      2573 CALL    OSSHUT          ;CLOSE ALL FILES
040BD3 6C 
040BD4 43 
040BD5 04 
040BD6 C3      2574 JP      WARM            ;"Ready"
040BD7 AF 
040BD8 30 
040BD9 04 
               2575 ;
040BDA FD      2576 NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BDB 7E 
040BDC 00 
040BDD 01      2577 LD      BC,3
040BDE 03 
040BDF 00 
040BE0 00 
040BE1 FD      2578 ADD     IY,BC
040BE2 09 
040BE3 B7      2579 OR      A
040BE4 28      2580 JR      Z,END_           ;LENGTH=0, EXIT
040BE5 E0 
040BE6 2A      2581 LD      HL,(TRACEN)
040BE7 26 
040BE8 4D 
040BE9 04 
040BEA 7C      2582 LD      A,H
040BEB B5      2583 OR      L
040BEC C8      2584 RET     Z
040BED 11      2585 LD	DE, 0		;Clear DE
040BEE 00 
040BEF 00 
040BF0 00 
040BF1 FD      2586 LD      D,(IY-1)        ;DE = LINE NUMBER
040BF2 56 
040BF3 FF 
040BF4 FD      2587 LD      E,(IY-2)
040BF5 5E 
040BF6 FE 
040BF7 ED      2588 SBC     HL,DE
040BF8 52 
040BF9 D8      2589 RET     C
040BFA EB      2590 EX      DE,HL
040BFB 3E      2591 LD      A,'['           ;TRACE
040BFC 5B 
040BFD CD      2592 CALL    OUTCHR
040BFE 7F 
040BFF 39 
040C00 04 
040C01 CD      2593 CALL    PBCDL
040C02 27 
040C03 3A 
040C04 04 
040C05 3E      2594 LD      A,']'
040C06 5D 
040C07 CD      2595 CALL    OUTCHR
040C08 7F 
040C09 39 
040C0A 04 
040C0B 3E      2596 LD      A,' '
040C0C 20 
040C0D C3      2597 JP      OUTCHR
040C0E 7F 
040C0F 39 
040C10 04 
               2598 
               2599 ; Routines for each statement -------------------------------------------------
               2600 
               2601 ; OSCLI
               2602 ;
040C11 CD      2603 CLI:			CALL    EXPRS
040C12 15 
040C13 03 
040C14 04 
040C15 3E      2604 LD      A,CR
040C16 0D 
040C17 12      2605 LD      (DE),A
040C18 21      2606 LD      HL,ACCS
040C19 00 
040C1A 4A 
040C1B 04 
040C1C CD      2607 CALL    OSCLI
040C1D C0 
040C1E 3F 
040C1F 04 
040C20 C3      2608 JP      XEQ
040C21 96 
040C22 0B 
040C23 04 
               2609 
               2610 ; REM, *
               2611 ;
040C24 FD      2612 EXT_EX:			PUSH    IY
040C25 E5 
040C26 E1      2613 POP     HL
040C27 CD      2614 CALL    OSCLI
040C28 C0 
040C29 3F 
040C2A 04 
040C2B FD      2615 REM_EX:			PUSH    IY
040C2C E5 
040C2D E1      2616 POP     HL
040C2E 3E      2617 LD      A,CR
040C2F 0D 
040C30 47      2618 LD      B,A
040C31 ED      2619 CPIR                    ;FIND LINE END
040C32 B1 
040C33 E5      2620 PUSH    HL
040C34 FD      2621 POP     IY
040C35 E1 
040C36 C3      2622 JP      XEQ0
040C37 92 
040C38 0B 
040C39 04 
               2623 
               2624 ; [LET] var = expr
               2625 ;
040C3A FE      2626 LET0:			CP      ELSE_EX_-TCMD_EX
040C3B C5 
040C3C 28      2627 JR      Z,REM_EX
040C3D ED 
               2628 ; CP      ('*'-TCMD) & 0FFH
               2629 ; JR      Z,EXT_EX
               2630 ; CP      ('='-TCMD) & 0FFH
               2631 ; JR      Z,FNEND
               2632 ; CP      ('['-TCMD) & 0FFH
               2633 ; ez80asm doesn't like () in expressions
040C3E FE      2634 CP      '*'-TCMD_EX & 0FFH
040C3F 64 
040C40 28      2635 JR      Z,EXT_EX
040C41 E2 
040C42 FE      2636 CP      '='-TCMD_EX & 0FFH
040C43 77 
040C44 28      2637 JR      Z,FNEND
040C45 5B 
040C46 FE      2638 CP      '['-TCMD_EX & 0FFH
040C47 95 
040C48 28      2639 JR      Z,ASM
040C49 25 
040C4A FD      2640 DEC     IY
040C4B 2B 
040C4C CD      2641 LET:			CALL    ASSIGN			; Assign the variable
040C4D E8 
040C4E 15 
040C4F 04 
040C50 CA      2642 JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C51 96 
040C52 0B 
040C53 04 
040C54 38      2643 JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C55 41 
               2644 ;
040C56 F5      2645 PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C57 CD      2646 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C58 BA 
040C59 17 
040C5A 04 
040C5B E5      2647 PUSH    HL			; HL: Address of the variable
040C5C CD      2648 CALL    EXPRS
040C5D 15 
040C5E 03 
040C5F 04 
040C60 DD      2649 POP     IX			; IX: Address of the variable
040C61 E1 
040C62 F1      2650 POP     AF			; AF: The variable type
040C63 CD      2651 CALL    STACCS			; Copy the string from ACCS to the variable area
040C64 2A 
040C65 16 
040C66 04 
040C67 C3      2652 XEQR:			JP      XEQ
040C68 96 
040C69 0B 
040C6A 04 
               2653 ;
040C6B CD      2654 ASM0:			CALL    NEWLIN
040C6C DA 
040C6D 0B 
040C6E 04 
040C6F FD      2655 ASM:			LD      (ERRLIN),IY
040C70 22 
040C71 35 
040C72 4D 
040C72 04   
040C74 CD      2656 CALL    TRAP
040C75 9D 
040C76 3F 
040C77 04 
040C78 CD      2657 CALL    ASSEM
040C79 C5 
040C7A 18 
040C7B 04 
040C7C 38      2658 JR      C,SYNTAX
040C7D 19 
040C7E FE      2659 CP      CR
040C7F 0D 
040C80 28      2660 JR      Z,ASM0
040C81 E9 
040C82 21      2661 LD      HL,LISTON
040C83 40 
040C84 4D 
040C85 04 
040C86 7E      2662 LD      A,(HL)
040C87 E6      2663 AND     0FH
040C88 0F 
040C89 F6      2664 OR      B0H
040C8A B0 
040C8B 77      2665 LD      (HL),A
040C8C 18      2666 JR      XEQR
040C8D D9 
               2667 ;
040C8E CD      2668 VAR_:			CALL    GETVAR
040C8F 6A 
040C90 3A 
040C91 04 
040C92 C8      2669 RET     Z
040C93 D2      2670 JP      NC,PUTVAR
040C94 59 
040C95 3A 
040C96 04 
040C97 3E      2671 SYNTAX:			LD      A,16            ;"Syntax error"
040C98 10 
040C99 18      2672 JR	ERROR0_EX
040C9A 02 
040C9B 3E      2673 ESCAPE:			LD      A,17            ;"Escape"
040C9C 11 
040C9D C3      2674 ERROR0_EX:			JP      ERROR_
040C9E 90 
040C9F 37 
040CA0 04 
               2675 
               2676 ; =
               2677 ;
040CA1 CD      2678 FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CA2 C7 
040CA3 01 
040CA4 04 
040CA5 43      2679 LD      B,E
040CA6 EB      2680 EX      DE,HL
040CA7 D9      2681 EXX                     ;SAVE RESULT
040CA8 EB      2682 EX      DE,HL           ; IN DEB'C'D'E'
040CA9 C1      2683 FNEND5:			POP     BC
040CAA 21      2684 LD      HL,LOCCHK
040CAB 82 
040CAC 17 
040CAD 04 
040CAE B7      2685 OR      A
040CAF ED      2686 SBC     HL,BC
040CB0 42 
040CB1 28      2687 JR      Z,FNEND0        ;LOCAL VARIABLE
040CB2 1C 
040CB3 21      2688 LD      HL,FNCHK
040CB4 84 
040CB5 10 
040CB6 04 
040CB7 B7      2689 OR      A
040CB8 ED      2690 SBC     HL,BC
040CB9 42 
040CBA 3E      2691 LD      A,7
040CBB 07 
040CBC 20      2692 JR      NZ,ERROR0_EX       ;"No FN"
040CBD DF 
040CBE FD      2693 POP     IY
040CBF E1 
040CC0 FD      2694 LD      (ERRLIN),IY     ;IN CASE OF ERROR
040CC1 22 
040CC2 35 
040CC3 4D 
040CC3 04   
040CC5 EB      2695 EX      DE,HL
040CC6 D9      2696 EXX
040CC7 EB      2697 EX      DE,HL
040CC8 11      2698 LD      DE,ACCS
040CC9 00 
040CCA 4A 
040CCB 04 
040CCC 58      2699 LD      E,B
040CCD 08      2700 EX      AF,AF'
040CCE C9      2701 RET
               2702 ;
040CCF DD      2703 FNEND0:			POP     IX
040CD0 E1 
040CD1 C1      2704 POP     BC
040CD2 78      2705 LD      A,B
040CD3 B7      2706 OR      A
040CD4 FA      2707 JP      M,FNEND1        ;STRING
040CD5 E2 
040CD6 0C 
040CD7 04 
040CD8 E1      2708 POP     HL
040CD9 D9      2709 EXX
040CDA E1      2710 POP     HL
040CDB D9      2711 EXX
040CDC CD      2712 CALL    STORE
040CDD 00 
040CDE 16 
040CDF 04 
040CE0 18      2713 JR      FNEND5
040CE1 C7 
040CE2 21      2714 FNEND1:			LD      HL,0
040CE3 00 
040CE4 00 
040CE5 00 
040CE6 39      2715 ADD     HL,SP
040CE7 D5      2716 PUSH    DE
040CE8 59      2717 LD      E,C
040CE9 CD      2718 CALL    STORES
040CEA 2E 
040CEB 16 
040CEC 04 
040CED D1      2719 POP     DE
040CEE F9      2720 LD      SP,HL
040CEF 18      2721 JR      FNEND5
040CF0 B8 
               2722 
               2723 ; DIM var(dim1[,dim2[,...]])[,var(...]
               2724 ; DIM var expr[,var expr...]
               2725 ;
040CF1 CD      2726 DIM_EX:			CALL    GETVAR          	; Get the variable
040CF2 6A 
040CF3 3A 
040CF4 04 
040CF5 DA      2727 JP      C,BADDIM		; Throw a "Bad Dim" error
040CF6 81 
040CF7 0D 
040CF8 04 
040CF9 CA      2728 JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040CFA 8B 
040CFB 0D 
040CFC 04 
040CFD CD      2729 CALL    CREATE			; Create a new entity
040CFE DE 
040CFF 3B 
040D00 04 
040D01 E5      2730 PUSH    HL			; HL: Address of the entity
040D02 DD      2731 POP     IX			; IX: Address of the entity
040D03 E1 
040D04 FD      2732 LD      A,(IY)			; Fetch the next character from the tokenised string
040D05 7E 
040D06 00 
040D07 FE      2733 CP      '('			; Check for opening brackets
040D08 28 
040D09 7A      2734 LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D0A 20      2735 JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D0B 7F 
               2736 ;
               2737 ; At this point we're reserving a variable array
               2738 ;
040D0C E5      2739 PUSH    HL			; HL: Address of the entity
040D0D F5      2740 PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D0E 11      2741 LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D0F 01 
040D10 00 
040D11 00 
040D12 42      2742 LD      B,D			;  B: The number of dimensions in the array
               2743 ;
040D13 FD      2744 DIM1:			INC     IY			; Skip to the next token
040D14 23 
040D15 C5      2745 PUSH    BC			; Stack the dimension counter
040D16 D5      2746 PUSH    DE			; Stack the total size of array accumulator
040D17 DD      2747 PUSH    IX			; Stack the entity address
040D18 E5 
040D19 CD      2748 CALL    EXPRI           	; Fetch the size of this dimension
040D1A 0A 
040D1B 03 
040D1C 04 
040D1D CB      2749 BIT     7,H			; If it is negative then
040D1E 7C 
040D1F 20      2750 JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D20 60 
040D21 D9      2751 EXX
040D22 23      2752 INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D23 DD      2753 POP     IX			; IX: The entity address
040D24 E1 
040D25 DD      2754 INC     IX
040D26 23 
040D27 DD      2755 LD      (IX),L          	; Save the size of this dimension in the entity
040D28 75 
040D29 00 
040D2A DD      2756 INC     IX
040D2B 23 
040D2C DD      2757 LD      (IX),H
040D2D 74 
040D2E 00 
040D2F C1      2758 POP     BC
040D30 CD      2759 CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D31 9C 
040D32 18 
040D33 04 
040D34 38      2760 JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D35 4F 
040D36 EB      2761 EX      DE,HL           	; DE: The new total size of array accumulator
040D37 C1      2762 POP     BC
040D38 04      2763 INC     B               	;  B: The dimension counter; increment
040D39 FD      2764 LD      A,(IY)			; Fetch the nex token
040D3A 7E 
040D3B 00 
040D3C FE      2765 CP      ','             	; Check for another dimension in the array
040D3D 2C 
040D3E 28      2766 JR      Z,DIM1			; And loop
040D3F D3 
               2767 ;
040D40 CD      2768 CALL    BRAKET          	; Check for closing bracket
040D41 2F 
040D42 0A 
040D43 04 
040D44 F1      2769 POP     AF              	; Restore the type
040D45 DD      2770 INC     IX
040D46 23 
040D47 DD      2771 EX      (SP),IX
040D48 E3 
040D49 DD      2772 LD      (IX),B          	; Number of dimensions
040D4A 70 
040D4B 00 
040D4C CD      2773 CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D4D 8F 
040D4E 18 
040D4F 04 
040D50 E1      2774 POP     HL			; Restore the entity address
040D51 38      2775 JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D52 32 
               2776 ;
               2777 ; We now allocate the memory for the array
               2778 ;
040D53 19      2779 DIM3:			ADD     HL,DE
040D54 38      2780 JR      C,NOROOM
040D55 2F 
040D56 E5      2781 PUSH    HL
040D57 24      2782 INC     H
040D58 28      2783 JR      Z,NOROOM
040D59 2B 
040D5A ED      2784 SBC     HL,SP
040D5B 72 
040D5C 30      2785 JR      NC,NOROOM       	; Throw an "Out of Space" error
040D5D 27 
040D5E E1      2786 POP     HL
040D5F 22      2787 LD      (FREE),HL
040D60 1D 
040D61 4D 
040D62 04 
040D63 7A      2788 DIM2:			LD      A,D
040D64 B3      2789 OR      E
040D65 28      2790 JR      Z,DIM5
040D66 06 
040D67 2B      2791 DEC     HL
040D68 36      2792 LD      (HL),0         		; Initialise the array
040D69 00 
040D6A 1B      2793 DEC     DE
040D6B 18      2794 JR      DIM2
040D6C F6 
040D6D CD      2795 DIM5:			CALL    NXT
040D6E 70 
040D6F 0A 
040D70 04 
040D71 FE      2796 CP      ','            		; Another variable?
040D72 2C 
040D73 C2      2797 JP      NZ,XEQ
040D74 96 
040D75 0B 
040D76 04 
040D77 FD      2798 INC     IY
040D78 23 
040D79 CD      2799 CALL    NXT
040D7A 70 
040D7B 0A 
040D7C 04 
040D7D C3      2800 JP      DIM_EX
040D7E F1 
040D7F 0C 
040D80 04 
               2801 ;
               2802 ; DIM errors
               2803 ;
040D81 3E      2804 BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D82 0A 
040D83 18      2805 JR	ERROR1_EX
040D84 02 
040D85 3E      2806 NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D86 0B 
040D87 C3      2807 ERROR1_EX:			JP      ERROR_
040D88 90 
040D89 37 
040D8A 04 
               2808 ;
               2809 ; At this point we're reserving a block of memory, i.e.
               2810 ; DIM var expr[,var expr...]
               2811 ;
040D8B B7      2812 DIM4:			OR      A			;  A: The dimension variable type
040D8C 28      2813 JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D8D F3 
040D8E FA      2814 JP      M,BADDIM        	; or a string
040D8F 81 
040D90 0D 
040D91 04 
040D92 47      2815 LD      B,A			; Temporarily store the dimension variable type in B
040D93 FD      2816 LD      A,(IY-1)		; Get the last character but one
040D94 7E 
040D95 FF 
040D96 FE      2817 CP      ')'			; Check if it is a trailing bracket
040D97 29 
040D98 28      2818 JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040D99 E7 
               2819 ;
040D9A 21      2820 LD	HL,0			; Clear HL
040D9B 00 
040D9C 00 
040D9D 00 
040D9E 3A      2821 LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040D9F 1D 
040DA0 4D 
040DA1 04 
040DA2 6F      2822 LD	L,A
040DA3 3A      2823 LD	A,(FREE+1)
040DA4 1E 
040DA5 4D 
040DA6 04 
040DA7 67      2824 LD	H,A
040DA8 78      2825 LD	A,B			; Restore the dimension variable type
040DA9 D9      2826 EXX
040DAA 21      2827 LD	HL,0			; Clear HL
040DAB 00 
040DAC 00 
040DAD 00 
040DAE 47      2828 LD	B,A			; Temporarily store the dimension variable type in B
040DAF 3A      2829 LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB0 1F 
040DB1 4D 
040DB2 04 
040DB3 6F      2830 LD	L,A
040DB4 78      2831 LD	A,B			; Restore the dimension variable type
040DB5 4C      2832 LD	C,H
040DB6 CD      2833 CALL    STORE           	; Store the address
040DB7 00 
040DB8 16 
040DB9 04 
040DBA CD      2834 CALL    EXPRI			; Get the number of bytes to store
040DBB 0A 
040DBC 03 
040DBD 04 
040DBE D9      2835 EXX
040DBF 23      2836 INC     HL			; Add one to it
040DC0 EB      2837 EX      DE,HL
040DC1 2A      2838 LD      HL,(FREE)
040DC2 1D 
040DC3 4D 
040DC4 04 
040DC5 18      2839 JR      DIM3			; Continue with the DIM
040DC6 8C 
               2840 
               2841 ; PRINT list...
               2842 ; PRINT #channel,list...
               2843 ;
040DC7 FE      2844 PRINT_:			CP      '#'
040DC8 23 
040DC9 20      2845 JR      NZ,PRINT0
040DCA 7C 
040DCB CD      2846 CALL    CHNL            ;CHANNEL NO. = E
040DCC BC 
040DCD 18 
040DCE 04 
040DCF CD      2847 PRNTN1:			CALL    NXT
040DD0 70 
040DD1 0A 
040DD2 04 
040DD3 FE      2848 CP      ','
040DD4 2C 
040DD5 C2      2849 JP      NZ,XEQ
040DD6 96 
040DD7 0B 
040DD8 04 
040DD9 FD      2850 INC     IY
040DDA 23 
040DDB D5      2851 PUSH    DE
040DDC CD      2852 CALL    EXPR            ;ITEM TO PRINT
040DDD C7 
040DDE 01 
040DDF 04 
040DE0 08      2853 EX      AF,AF'
040DE1 FA      2854 JP      M,PRNTN2        ;STRING
040DE2 07 
040DE3 0E 
040DE4 04 
040DE5 D1      2855 POP     DE
040DE6 C5      2856 PUSH    BC
040DE7 D9      2857 EXX
040DE8 7D      2858 LD      A,L
040DE9 D9      2859 EXX
040DEA CD      2860 CALL    OSBPUT
040DEB 7C 
040DEC 43 
040DED 04 
040DEE D9      2861 EXX
040DEF 7C      2862 LD      A,H
040DF0 D9      2863 EXX
040DF1 CD      2864 CALL    OSBPUT
040DF2 7C 
040DF3 43 
040DF4 04 
040DF5 7D      2865 LD      A,L
040DF6 CD      2866 CALL    OSBPUT
040DF7 7C 
040DF8 43 
040DF9 04 
040DFA 7C      2867 LD      A,H
040DFB CD      2868 CALL    OSBPUT
040DFC 7C 
040DFD 43 
040DFE 04 
040DFF C1      2869 POP     BC
040E00 79      2870 LD      A,C
040E01 CD      2871 CALL    OSBPUT
040E02 7C 
040E03 43 
040E04 04 
040E05 18      2872 JR      PRNTN1
040E06 C8 
040E07 4B      2873 PRNTN2:			LD      C,E
040E08 D1      2874 POP     DE
040E09 21      2875 LD      HL,ACCS
040E0A 00 
040E0B 4A 
040E0C 04 
040E0D 0C      2876 INC     C
040E0E 0D      2877 PRNTN3:			DEC     C
040E0F 28      2878 JR      Z,PRNTN4
040E10 0A 
040E11 7E      2879 LD      A,(HL)
040E12 23      2880 INC     HL
040E13 C5      2881 PUSH    BC
040E14 CD      2882 CALL    OSBPUT
040E15 7C 
040E16 43 
040E17 04 
040E18 C1      2883 POP     BC
040E19 18      2884 JR      PRNTN3
040E1A F3 
040E1B 3E      2885 PRNTN4:			LD      A,CR
040E1C 0D 
040E1D CD      2886 CALL    OSBPUT
040E1E 7C 
040E1F 43 
040E20 04 
040E21 18      2887 JR      PRNTN1
040E22 AC 
               2888 ;
040E23 06      2889 PRINT6:			LD      B,2
040E24 02 
040E25 18      2890 JR      PRINTC
040E26 27 
040E27 01      2891 PRINT8:			LD      BC,100H
040E28 00 
040E29 01 
040E2A 00 
040E2B 18      2892 JR      PRINTC
040E2C 21 
040E2D 21      2893 PRINT9:			LD      HL,STAVAR
040E2E 00 
040E2F 4C 
040E30 04 
040E31 AF      2894 XOR     A
040E32 BE      2895 CP      (HL)
040E33 28      2896 JR      Z,PRINT0
040E34 12 
040E35 3A      2897 LD      A,(COUNT)
040E36 3D 
040E37 4D 
040E38 04 
040E39 B7      2898 OR      A
040E3A 28      2899 JR      Z,PRINT0
040E3B 0B 
040E3C 96      2900 PRINTA:			SUB     (HL)
040E3D 28      2901 JR      Z,PRINT0
040E3E 08 
040E3F 30      2902 JR      NC,PRINTA
040E40 FB 
040E41 ED      2903 NEG
040E42 44 
040E43 CD      2904 CALL    FILL
040E44 19 
040E45 18 
040E46 04 
040E47 3A      2905 PRINT0:			LD      A,(STAVAR)
040E48 00 
040E49 4C 
040E4A 04 
040E4B 4F      2906 LD      C,A             ;PRINTS
040E4C 06      2907 LD      B,0             ;PRINTF
040E4D 00 
040E4E CD      2908 PRINTC:			CALL    TERMQ
040E4F A4 
040E50 17 
040E51 04 
040E52 28      2909 JR      Z,PRINT4
040E53 3F 
040E54 CB      2910 RES     0,B
040E55 80 
040E56 FD      2911 INC     IY
040E57 23 
040E58 FE      2912 CP      '~'
040E59 7E 
040E5A 28      2913 JR      Z,PRINT6
040E5B C7 
040E5C FE      2914 CP      ';'
040E5D 3B 
040E5E 28      2915 JR      Z,PRINT8
040E5F C7 
040E60 FE      2916 CP      ','
040E61 2C 
040E62 28      2917 JR      Z,PRINT9
040E63 C9 
040E64 CD      2918 CALL    FORMAT          ;SPC, TAB, '
040E65 C9 
040E66 17 
040E67 04 
040E68 28      2919 JR      Z,PRINTC
040E69 E4 
040E6A FD      2920 DEC     IY
040E6B 2B 
040E6C C5      2921 PUSH    BC
040E6D CD      2922 CALL    EXPR            ;VARIABLE TYPE
040E6E C7 
040E6F 01 
040E70 04 
040E71 08      2923 EX      AF,AF'
040E72 FA      2924 JP      M,PRINT3        ;STRING
040E73 8C 
040E74 0E 
040E75 04 
040E76 D1      2925 POP     DE
040E77 D5      2926 PUSH    DE
040E78 CB      2927 BIT     1,D
040E79 4A 
040E7A F5      2928 PUSH    AF
040E7B CC      2929 CALL    Z,STR           ;DECIMAL
040E7C 66 
040E7D 09 
040E7E 04 
040E7F F1      2930 POP     AF
040E80 C4      2931 CALL    NZ,HEXSTR       ;HEX
040E81 1A 
040E82 09 
040E83 04 
040E84 C1      2932 POP     BC
040E85 C5      2933 PUSH    BC
040E86 79      2934 LD      A,C
040E87 93      2935 SUB     E
040E88 D4      2936 CALL    NC,FILL         ;RIGHT JUSTIFY
040E89 19 
040E8A 18 
040E8B 04 
040E8C C1      2937 PRINT3:			POP     BC
040E8D CD      2938 CALL    PTEXT           ;PRINT
040E8E 28 
040E8F 18 
040E90 04 
040E91 18      2939 JR      PRINTC
040E92 BB 
040E93 CB      2940 PRINT4:			BIT     0,B
040E94 40 
040E95 CC      2941 CALL    Z,CRLF
040E96 77 
040E97 39 
040E98 04 
040E99 C3      2942 JP      XEQ
040E9A 96 
040E9B 0B 
040E9C 04 
               2943 
               2944 ; ON ERROR statement [:statement...]
               2945 ; ON ERROR OFF
               2946 ;
040E9D FD      2947 ONERR:			INC     IY              ;SKIP "ERROR"
040E9E 23 
040E9F 21      2948 LD      HL,0
040EA0 00 
040EA1 00 
040EA2 00 
040EA3 22      2949 LD      (ERRTRP),HL
040EA4 2C 
040EA5 4D 
040EA6 04 
040EA7 CD      2950 CALL    NXT
040EA8 70 
040EA9 0A 
040EAA 04 
040EAB FE      2951 CP      OFF_
040EAC 87 
040EAD FD      2952 INC     IY
040EAE 23 
040EAF CA      2953 JP      Z,XEQ
040EB0 96 
040EB1 0B 
040EB2 04 
040EB3 FD      2954 DEC     IY
040EB4 2B 
040EB5 FD      2955 LD      (ERRTRP),IY
040EB6 22 
040EB7 2C 
040EB8 4D 
040EB8 04   
040EBA C3      2956 JP      REM_EX
040EBB 2B 
040EBC 0C 
040EBD 04 
               2957 
               2958 ; ON expr GOTO line[,line...] [ELSE statement]
               2959 ; ON expr GOTO line[,line...] [ELSE line]
               2960 ; ON expr GOSUB line[,line...] [ELSE statement]
               2961 ; ON expr GOSUB line[,line...] [ELSE line]
               2962 ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
               2963 ;
040EBE FE      2964 ON_EX_:			CP      TERROR_EX
040EBF 85 
040EC0 28      2965 JR      Z,ONERR         ;"ON ERROR"
040EC1 DB 
040EC2 CD      2966 CALL    EXPRI
040EC3 0A 
040EC4 03 
040EC5 04 
040EC6 FD      2967 LD      A,(IY)
040EC7 7E 
040EC8 00 
040EC9 FD      2968 INC     IY
040ECA 23 
040ECB 1E      2969 LD      E,','           ;SEPARATOR
040ECC 2C 
040ECD FE      2970 CP      TGOTO
040ECE E5 
040ECF 28      2971 JR      Z,ON1
040ED0 0B 
040ED1 FE      2972 CP      TGOSUB
040ED2 E4 
040ED3 28      2973 JR      Z,ON1
040ED4 07 
040ED5 1E      2974 LD      E,TPROC
040ED6 F2 
040ED7 BB      2975 CP      E
040ED8 3E      2976 LD      A,39
040ED9 27 
040EDA 20      2977 JR      NZ,ERROR2_EX       ;"ON syntax"
040EDB 45 
040EDC 57      2978 ON1:			LD      D,A
040EDD D9      2979 EXX
040EDE E5      2980 PUSH    HL
040EDF D9      2981 EXX
040EE0 C1      2982 POP     BC              ;ON INDEX
040EE1 78      2983 LD      A,B
040EE2 B4      2984 OR      H
040EE3 B5      2985 OR      L
040EE4 20      2986 JR      NZ,ON4          ;OUT OF RANGE
040EE5 2A 
040EE6 B1      2987 OR      C
040EE7 28      2988 JR      Z,ON4
040EE8 27 
040EE9 0D      2989 DEC     C
040EEA 28      2990 JR      Z,ON3           ;INDEX=1
040EEB 0E 
040EEC CD      2991 ON2:			CALL    TERMQ
040EED A4 
040EEE 17 
040EEF 04 
040EF0 28      2992 JR      Z,ON4           ;OUT OF RANGE
040EF1 1E 
040EF2 FD      2993 INC     IY              ;SKIP DELIMITER
040EF3 23 
040EF4 BB      2994 CP      E
040EF5 20      2995 JR      NZ,ON2
040EF6 F5 
040EF7 0D      2996 DEC     C
040EF8 20      2997 JR      NZ,ON2
040EF9 F2 
040EFA 7B      2998 ON3:			LD      A,E
040EFB FE      2999 CP      TPROC
040EFC F2 
040EFD 28      3000 JR      Z,ONPROC
040EFE 26 
040EFF D5      3001 PUSH    DE
040F00 CD      3002 CALL    ITEMI           ;LINE NUMBER
040F01 25 
040F02 03 
040F03 04 
040F04 D1      3003 POP     DE
040F05 7A      3004 LD      A,D
040F06 FE      3005 CP      TGOTO
040F07 E5 
040F08 28      3006 JR      Z,GOTO2
040F09 2D 
040F0A CD      3007 CALL    SPAN            ;SKIP REST OF LIST
040F0B B1 
040F0C 17 
040F0D 04 
040F0E 18      3008 JR      GOSUB1
040F0F 3B 
               3009 ;
040F10 FD      3010 ON4:			LD      A,(IY)
040F11 7E 
040F12 00 
040F13 FD      3011 INC     IY
040F14 23 
040F15 FE      3012 CP      ELSE_EX_
040F16 8B 
040F17 CA      3013 JP      Z,IF1           ;ELSE CLAUSE
040F18 4B 
040F19 13 
040F1A 04 
040F1B FE      3014 CP      CR
040F1C 0D 
040F1D 20      3015 JR      NZ,ON4
040F1E F1 
040F1F 3E      3016 LD      A,40
040F20 28 
040F21 C3      3017 ERROR2_EX:			JP      ERROR_           ;"ON range"
040F22 90 
040F23 37 
040F24 04 
               3018 ;
040F25 3E      3019 ONPROC:			LD      A,TON
040F26 EE 
040F27 C3      3020 JP      PROC_EX
040F28 84 
040F29 10 
040F2A 04 
               3021 
               3022 ; GOTO line
               3023 ;
040F2B CD      3024 GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F2C 25 
040F2D 03 
040F2E 04 
040F2F CD      3025 GOTO1:			CALL    TERMQ			; Check for terminator
040F30 A4 
040F31 17 
040F32 04 
040F33 C2      3026 JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F34 97 
040F35 0C 
040F36 04 
040F37 D9      3027 GOTO2:			EXX
040F38 CD      3028 CALL    FINDL			; HL: Line number - Find the line
040F39 BF 
040F3A 39 
040F3B 04 
040F3C E5      3029 PUSH    HL			; HL: Address of the line
040F3D FD      3030 POP     IY			; IY = HL
040F3E E1 
040F3F CA      3031 JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F40 92 
040F41 0B 
040F42 04 
040F43 3E      3032 LD      A,41			; Otherwise throw a "No such line" error
040F44 29 
040F45 18      3033 JR      ERROR2_EX
040F46 DA 
               3034 
               3035 ; GOSUB line
               3036 ; This pushes the following data onto the execution stack
               3037 ; - 3 bytes: Current execution address
               3038 ; - 3 bytes: Marker (the address of label GOSCHK)
               3039 ;
040F47 CD      3040 GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F48 25 
040F49 03 
040F4A 04 
040F4B FD      3041 GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F4C E5 
040F4D CD      3042 CALL    CHECK           	; Check there is enough room
040F4E 79 
040F4F 16 
040F50 04 
040F51 CD      3043 CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F52 2F 
040F53 0F 
040F54 04 
               3044 GOSCHK:			EQU     $
               3045 
               3046 ; RETURN
               3047 ; This pops the following data off the execution stack as pushed by GOSUB
               3048 ; - 3 bytes: Marker (should be the address of label GOSCHK)
               3049 ; - 3 bytes: The return execution address
               3050 ;
040F55 D1      3051 RETURN:			POP     DE			; Pop the marker off the execution stack
040F56 21      3052 LD      HL,GOSCHK		; Compare with GOSCHK
040F57 55 
040F58 0F 
040F59 04 
040F5A B7      3053 OR      A
040F5B ED      3054 SBC     HL,DE
040F5C 52 
040F5D FD      3055 POP     IY			; Pop the return address off the execution stack
040F5E E1 
040F5F CA      3056 JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F60 96 
040F61 0B 
040F62 04 
040F63 3E      3057 LD      A,38			; Otherwise throw a "No GOSUB" error
040F64 26 
040F65 18      3058 JR      ERROR2_EX
040F66 BA 
               3059 
               3060 ; REPEAT
               3061 ; This pushes the following data onto the execution stack
               3062 ; - 3 bytes: Current execution address
               3063 ; - 3 bytes: Marker (the address of label REPCHK)
               3064 ;
040F67 FD      3065 REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F68 E5 
040F69 CD      3066 CALL    CHECK			; Check if there is enough room
040F6A 79 
040F6B 16 
040F6C 04 
040F6D CD      3067 CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F6E 96 
040F6F 0B 
040F70 04 
               3068 REPCHK:			EQU     $
               3069 
               3070 ; UNTIL expr
               3071 ; This pops the following data off the execution stack
               3072 ; - 3 bytes: Marker (should be the address of label REPCHK)
               3073 ; - 3 bytes: The address of the REPEAT instruction
               3074 ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
               3075 ;
040F71 C1      3076 UNTIL_EX:			POP     BC			; Fetch the marker
040F72 C5      3077 PUSH    BC			; And push it back onto the execution stack
040F73 21      3078 LD      HL,REPCHK		; Compare with REPCHK
040F74 71 
040F75 0F 
040F76 04 
040F77 B7      3079 OR      A
040F78 ED      3080 SBC     HL,BC
040F79 42 
040F7A 3E      3081 LD      A,43
040F7B 2B 
040F7C 20      3082 JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F7D A3 
040F7E CD      3083 CALL    EXPRI			; Fetch the expression
040F7F 0A 
040F80 03 
040F81 04 
040F82 CD      3084 CALL    TEST			; Test if the expression evaluates to zero
040F83 DF 
040F84 08 
040F85 04 
040F86 C1      3085 POP     BC			; Pop the marker
040F87 D1      3086 POP     DE			; Pop the address of the REPEAT instruction
040F88 20      3087 JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F89 05 
040F8A D5      3088 PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F8B C5      3089 PUSH    BC			; Push the marker back on the stack
040F8C D5      3090 PUSH    DE			; IY = DE
040F8D FD      3091 POP     IY			; This sets the execution address back to the REPEAT instruction
040F8E E1 
040F8F C3      3092 XEQ2:			JP      XEQ			; Continue execution
040F90 96 
040F91 0B 
040F92 04 
               3093 
               3094 ; FOR var = expr TO expr [STEP expr]
               3095 ; This pushes the following data onto the execution stack
               3096 ; - 3 bytes: The limit value
               3097 ; - 3 bytes: The step value
               3098 ; - 3 bytes: The current execution address
               3099 ; - 3 bytes: The address of the loop variable
               3100 ; - 3 bytes: Marker (the address of FORCHK)
               3101 ;
040F93 3E      3102 FORVAR:			LD      A,34
040F94 22 
040F95 18      3103 JR      ERROR2_EX          	; Throw "FOR variable" error
040F96 8A 
               3104 ;
040F97 CD      3105 FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040F98 E8 
040F99 15 
040F9A 04 
040F9B 20      3106 JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040F9C F6 
040F9D F5      3107 PUSH    AF              	; Save the variable type
040F9E FD      3108 LD      A,(IY)			; Check the next token
040F9F 7E 
040FA0 00 
040FA1 FE      3109 CP      TO_EX			; Compare with the token value for "TO"
040FA2 B8 
040FA3 3E      3110 LD      A,36			; Set the error code to 36 ("No TO")
040FA4 24 
040FA5 C2      3111 JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FA6 21 
040FA7 0F 
040FA8 04 
040FA9 FD      3112 INC     IY			; Skip to the next token
040FAA 23 
               3113 ;
040FAB DD      3114 PUSH    IX
040FAC E5 
040FAD CD      3115 CALL    EXPRN           	; Fetch the LIMIT expression value
040FAE 02 
040FAF 03 
040FB0 04 
040FB1 DD      3116 POP     IX
040FB2 E1 
040FB3 F1      3117 POP     AF
040FB4 47      3118 LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FB5 C5      3119 PUSH    BC              	; Stack the LIMIT value
040FB6 E5      3120 PUSH    HL
040FB7 21      3121 LD      HL,0
040FB8 00 
040FB9 00 
040FBA 00 
040FBB 4C      3122 LD      C,H
040FBC D9      3123 EXX
040FBD E5      3124 PUSH    HL
               3125 ;
040FBE 21      3126 LD      HL,1            	; The preset STEP value is 1
040FBF 01 
040FC0 00 
040FC1 00 
040FC2 D9      3127 EXX
040FC3 FD      3128 LD      A,(IY)			; Fetch the next token
040FC4 7E 
040FC5 00 
040FC6 FE      3129 CP      STEP			; Compare with the token value for "STEP"
040FC7 88 
040FC8 20      3130 JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FC9 0A 
               3131 ;
040FCA FD      3132 INC     IY			; Skip past the STEP token
040FCB 23 
040FCC DD      3133 PUSH    IX
040FCD E5 
040FCE CD      3134 CALL    EXPRN          		; Fetch the STEP expression value
040FCF 02 
040FD0 03 
040FD1 04 
040FD2 DD      3135 POP     IX
040FD3 E1 
               3136 ;
040FD4 C5      3137 FOR1:			PUSH    BC			; Stack the STEP value
040FD5 E5      3138 PUSH    HL
040FD6 D9      3139 EXX
040FD7 E5      3140 PUSH    HL
040FD8 D9      3141 EXX
               3142 ;
040FD9 FD      3143 PUSH    IY              	; Stack the current execution address
040FDA E5 
040FDB DD      3144 PUSH    IX              	; Stack the loop variable
040FDC E5 
040FDD CD      3145 CALL    CHECK
040FDE 79 
040FDF 16 
040FE0 04 
040FE1 CD      3146 CALL    XEQ
040FE2 96 
040FE3 0B 
040FE4 04 
               3147 FORCHK:			EQU     $
               3148 
               3149 ; NEXT [var[,var...]]
               3150 ; This pops the following data off the execution stack
               3151 ; - 3 bytes: Marker (the address of FORCHK)
               3152 ; - 3 bytes: The address of the loop variable
               3153 ; - 3 bytes: The current execution address
               3154 ; - 3 bytes: The step value
               3155 ; - 3 bytes: The limit value
               3156 ; It also ensures that the data is pushed back on for subsequent NEXT instructions
               3157 ;
040FE5 C1      3158 NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FE6 21      3159 LD      HL,FORCHK		; Compare with FORCHK
040FE7 E5 
040FE8 0F 
040FE9 04 
040FEA B7      3160 OR      A
040FEB ED      3161 SBC     HL,BC
040FEC 42 
040FED 3E      3162 LD      A,32
040FEE 20 
040FEF C2      3163 JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF0 7B 
040FF1 10 
040FF2 04 
040FF3 CD      3164 CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FF4 A4 
040FF5 17 
040FF6 04 
040FF7 E1      3165 POP     HL			; Pop the address of the loop variable off the execution stack
040FF8 E5      3166 PUSH    HL			; Push it back onto the execution stack
040FF9 C5      3167 PUSH    BC			; Push the marker back onto the execution stack
040FFA E5      3168 PUSH    HL			; HL: Address of the loop variable off the stack
040FFB C4      3169 CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040FFC 6A 
040FFD 3A 
040FFE 04 
040FFF D1      3170 POP     DE			; DE: Address of the loop variable off the stack
041000 EB      3171 EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041001 B7      3172 OR      A
041002 ED      3173 NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041003 52 
041004 20      3174 JR      NZ,NEXT1		; They don't, so jump to NEXT1
041005 61 
041006 D5      3175 PUSH    DE
041007 DD      3176 LD      IX,9+3			; IX: Address of the STEP value on the execution stack
041008 21 
041009 0C 
04100A 00 
04100A 00   
04100C DD      3177 ADD     IX,SP
04100D 39 
04100E CD      3178 CALL    DLOAD5_SPL      	; Load the STEP value
04100F 11 
041010 2A 
041011 04 
041012 DD      3179 LD      A,(IX+16)       	; Get the STEP type
041013 7E 
041014 10 
041015 DD      3180 POP     IX
041016 E1 
041017 CD      3181 CALL    LOADN           	; Load the LOOP variable
041018 16 
041019 04 
04101A 04 
04101B CB      3182 BIT     7,D             	; Check the sign
04101C 7A 
04101D F5      3183 PUSH    AF
04101E 3E      3184 LD      A,'+' & 0FH
04101F 0B 
041020 CD      3185 CALL    FPP             	; Add the STEP
041021 9A 
041022 20 
041023 04 
041024 38      3186 JR      C,ERROR3_EX
041025 55 
041026 F1      3187 POP     AF              	; Restore TYPE
041027 F5      3188 PUSH    AF
041028 CD      3189 CALL    STORE           	; Update the variable
041029 00 
04102A 16 
04102B 04 
04102C DD      3190 LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
04102D 21 
04102E 15 
04102F 00 
04102F 00   
041031 DD      3191 ADD     IX,SP
041032 39 
041033 CD      3192 CALL    DLOAD5_SPL      	; Load the LIMIT value
041034 11 
041035 2A 
041036 04 
041037 F1      3193 POP     AF
041038 CC      3194 CALL    Z,SWAP			; Swap the arguments if the sign is ?
041039 D7 
04103A 08 
04103B 04 
               3195 ; LD      A,0+('<'-4) & 0FH
04103C 3E      3196 LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04103D 08 
04103E CD      3197 CALL    FPP             	; Test against the limit
04103F 9A 
041040 20 
041041 04 
041042 38      3198 JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041043 37 
041044 24      3199 INC     H
041045 20      3200 JR      NZ,LOOP_        	; Keep looping
041046 14 
041047 21      3201 LD      HL,27			; Adjust the stack
041048 1B 
041049 00 
04104A 00 
04104B 39      3202 ADD     HL,SP
04104C F9      3203 LD      SP,HL
04104D CD      3204 CALL    NXT
04104E 70 
04104F 0A 
041050 04 
041051 FE      3205 CP      ','			; Check for multiple variables
041052 2C 
041053 C2      3206 JP      NZ,XEQ			; No, so we are done at ths point
041054 96 
041055 0B 
041056 04 
041057 FD      3207 INC     IY			; Increment to the next variable
041058 23 
041059 18      3208 JR      NEXT_EX			; And continue
04105A 8A 
               3209 ;
04105B C1      3210 LOOP_:			POP     BC
04105C D1      3211 POP     DE
04105D FD      3212 POP     IY
04105E E1 
04105F FD      3213 PUSH    IY
041060 E5 
041061 D5      3214 PUSH    DE
041062 C5      3215 PUSH    BC
041063 C3      3216 JP      XEQ
041064 96 
041065 0B 
041066 04 
               3217 ;
041067 21      3218 NEXT1:			LD      HL,27			; TODO: What does this do?
041068 1B 
041069 00 
04106A 00 
04106B 39      3219 ADD     HL,SP
04106C F9      3220 LD      SP,HL			; Adjust the stack
04106D C1      3221 POP     BC
04106E 21      3222 LD      HL,FORCHK
04106F E5 
041070 0F 
041071 04 
041072 ED      3223 SBC     HL,BC
041073 42 
041074 E1      3224 POP     HL              	; Variable pointer
041075 E5      3225 PUSH    HL
041076 C5      3226 PUSH    BC
041077 28      3227 JR      Z,NEXT0
041078 89 
               3228 ;
041079 3E      3229 LD      A,33
04107A 21 
04107B C3      3230 ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
04107C 90 
04107D 37 
04107E 04 
               3231 
               3232 ; FNname
               3233 ; N.B. ENTERED WITH A <> TON
               3234 ;
04107F F5      3235 FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041080 CD      3236 CALL    PROC1
041081 89 
041082 10 
041083 04 
               3237 FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3238 
               3239 ; PROCname
               3240 ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
               3241 ; This pushes the following data onto the execution stack
               3242 ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
               3243 ; - 3 bytes: Marker (the address of PROCHK)
               3244 ;
041084 F5      3245 PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041085 CD      3246 CALL    PROC1			; and is also space reserved on the stack for the return address
041086 89 
041087 10 
041088 04 
               3247 PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3248 ;
041089 CD      3249 PROC1:			CALL    CHECK			; Check there is space for this
04108A 79 
04108B 16 
04108C 04 
04108D FD      3250 DEC     IY			; Decrement IY to the PROC token
04108E 2B 
04108F FD      3251 PUSH    IY			; Stack the pointer
041090 E5 
041091 CD      3252 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041092 2B 
041093 3B 
041094 04 
041095 C1      3253 POP     BC			; BC = IY
041096 28      3254 JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041097 41 
041098 3E      3255 LD      A,30
041099 1E 
04109A 38      3256 JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
04109B DF 
               3257 ;
               3258 ; At this point the PROC/FN has not yet been registered in the dynamic area
               3259 ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
               3260 ;
04109C C5      3261 PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
04109D 2A      3262 LD      HL,(PAGE_)		; HL: Start of program memory
04109E 14 
04109F 4D 
0410A0 04 
               3263 ;
0410A1 3E      3264 PROC2:			LD      A,DEF_			;  A: The token to search for
0410A2 DD 
0410A3 CD      3265 CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410A4 78 
0410A5 18 
0410A6 04 
0410A7 38      3266 JR      C,PROC3			; Not found, so jump to PROC3
0410A8 26 
0410A9 E5      3267 PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410AA FD      3268 POP     IY			; IY = HL
0410AB E1 
0410AC FD      3269 INC     IY              	; Skip the DEF token
0410AD 23 
0410AE CD      3270 CALL    NXT			; And any whitespace
0410AF 70 
0410B0 0A 
0410B1 04 
0410B2 CD      3271 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410B3 2B 
0410B4 3B 
0410B5 04 
0410B6 FD      3272 PUSH    IY
0410B7 E5 
0410B8 D1      3273 POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410B9 38      3274 JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410BA 09 
0410BB C4      3275 CALL    NZ,CREATE		; Create an entity in the dynamic area
0410BC DE 
0410BD 3B 
0410BE 04 
0410BF FD      3276 PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C0 E5 
0410C1 D1      3277 POP     DE			; DE = IY
0410C2 ED      3278 LD	(HL),DE			; Save address
0410C3 1F 
               3279 ;
0410C4 EB      3280 PROC6:			EX      DE,HL			; HL: Address of the procedure
0410C5 3E      3281 LD      A,CR			; The character to search for
0410C6 0D 
0410C7 01      3282 LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410C8 00 
0410C9 01 
0410CA 00 
0410CB ED      3283 CPIR                    	; Skip to next line
0410CC B1 
0410CD 18      3284 JR      PROC2			; Rinse, lather and repeat
0410CE D2 
               3285 ;
               3286 ; At this point a DEF has not been found for the PROC/FN
               3287 ;
0410CF FD      3288 PROC3:			POP     IY              	; Restore the execution address
0410D0 E1 
0410D1 CD      3289 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410D2 2B 
0410D3 3B 
0410D4 04 
0410D5 3E      3290 LD      A,29
0410D6 1D 
0410D7 20      3291 JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410D8 A2 
               3292 ;
               3293 ; At this point we have a PROC/FN entry in the dynamic area
               3294 ;
0410D9 ED      3295 PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410DA 17 
0410DB 21      3296 LD	HL,3
0410DC 03 
0410DD 00 
0410DE 00 
0410DF 39      3297 ADD     HL,SP
0410E0 CD      3298 CALL    NXT             	; Allow space before "("
0410E1 70 
0410E2 0A 
0410E3 04 
0410E4 D5      3299 PUSH    DE              	; Exchange DE and IY
0410E5 FD      3300 EX      (SP),IY
0410E6 E3 
0410E7 FE      3301 CP      '('             	; Arguments?
0410E8 28 
0410E9 D1      3302 POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410EA 20      3303 JR      NZ,PROC5
0410EB 20 
0410EC CD      3304 CALL    NXT             	; Allow space before "("
0410ED 70 
0410EE 0A 
0410EF 04 
0410F0 FE      3305 CP      '('
0410F1 28 
0410F2 C2      3306 JP      NZ,SYNTAX       	; Throw "Syntax error"
0410F3 97 
0410F4 0C 
0410F5 04 
0410F6 FD      3307 PUSH    IY
0410F7 E5 
0410F8 C1      3308 POP     BC              	; Save IY in BC
0410F9 D9      3309 EXX
0410FA CD      3310 CALL    SAVLOC          	; Save local parameters
0410FB 24 
0410FC 17 
0410FD 04 
0410FE CD      3311 CALL    BRAKET          	; Closing bracket
0410FF 2F 
041100 0A 
041101 04 
041102 D9      3312 EXX
041103 C5      3313 PUSH    BC
041104 FD      3314 POP     IY              	; Restore IY
041105 E1 
041106 E5      3315 PUSH    HL
041107 CD      3316 CALL    ARGUE           	; Transfer arguments
041108 A0 
041109 16 
04110A 04 
04110B E1      3317 POP     HL
               3318 ;
04110C 23      3319 PROC5:			INC	HL			; Increment to the ON PROC flag address
04110D 7E      3320 LD	A, (HL)			; And fetch the value
04110E 2B      3321 DEC 	HL
04110F ED      3322 LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041110 1F 
041111 FE      3323 CP	TON			; Was it "ON PROC"?
041112 EE 
041113 C2      3324 JP	NZ, XEQ			; No, so back to XEQ
041114 96 
041115 0B 
041116 04 
041117 D5      3325 PUSH    DE			; Exchange DE and IY
041118 FD      3326 EX      (SP),IY
041119 E3 
04111A CD      3327 CALL    SPAN            	; Skip rest of ON list
04111B B1 
04111C 17 
04111D 04 
04111E FD      3328 EX      (SP),IY			; Exchange DE and IY
04111F E3 
041120 D1      3329 POP     DE
041121 ED      3330 LD	(HL), DE		; Save the return address
041122 1F 
041123 C3      3331 JP      XEQ
041124 96 
041125 0B 
041126 04 
               3332 
               3333 ; LOCAL var[,var...]
               3334 ;
041127 C1      3335 LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041128 C5      3336 PUSH    BC
041129 21      3337 LD      HL,FNCHK		; Check if we are in a FN
04112A 84 
04112B 10 
04112C 04 
04112D B7      3338 OR      A
04112E ED      3339 SBC     HL,BC
04112F 42 
041130 28      3340 JR      Z,LOCAL1		; Yes, so all good, we can use local
041131 16 
041132 21      3341 LD      HL,PROCHK		; Now check if we are in a PROC
041133 89 
041134 10 
041135 04 
041136 B7      3342 OR      A
041137 ED      3343 SBC     HL,BC
041138 42 
041139 28      3344 JR      Z,LOCAL1		; Again, all good, we can use local
04113A 0D 
04113B 21      3345 LD      HL,LOCCHK		; Finally check for the local parameters marker
04113C 82 
04113D 17 
04113E 04 
04113F B7      3346 OR      A
041140 ED      3347 SBC     HL,BC			; If it is not present, then
041141 42 
041142 3E      3348 LD      A,12
041143 0C 
041144 C2      3349 JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041145 90 
041146 37 
041147 04 
               3350 ;
               3351 ; At this point we are adding a local variable into a PROC or FN
               3352 ;
041148 FD      3353 LOCAL1:			PUSH    IY			; IY: BASIC pointer
041149 E5 
04114A C1      3354 POP     BC			; BC: Copy of the BASIC pointer
04114B D9      3355 EXX
04114C FD      3356 DEC     IY
04114D 2B 
04114E CD      3357 CALL    SAVLOC
04114F 24 
041150 17 
041151 04 
041152 D9      3358 EXX
041153 C5      3359 PUSH    BC
041154 FD      3360 POP     IY
041155 E1 
               3361 ;
041156 CD      3362 LOCAL2:			CALL    GETVAR			; Get the variable location
041157 6A 
041158 3A 
041159 04 
04115A C2      3363 JP      NZ,SYNTAX
04115B 97 
04115C 0C 
04115D 04 
04115E B7      3364 OR      A               	; Check the variable type (80h = string)
04115F 08      3365 EX      AF,AF'
041160 CD      3366 CALL    ZERO			; Zero the variable anyway
041161 93 
041162 09 
041163 04 
041164 08      3367 EX      AF,AF'
041165 F5      3368 PUSH    AF
041166 F4      3369 CALL    P,STORE         	; Call STORE if it is not a string
041167 00 
041168 16 
041169 04 
04116A F1      3370 POP     AF
04116B 59      3371 LD      E,C
04116C FC      3372 CALL    M,STORES		; Call STORES if it is a string
04116D 2E 
04116E 16 
04116F 04 
041170 CD      3373 CALL    NXT			; Skip to the next character in the expression
041171 70 
041172 0A 
041173 04 
041174 FE      3374 CP      ','			; Is it a comma?
041175 2C 
041176 C2      3375 JP      NZ,XEQ			; No, so we're done, carry on executing
041177 96 
041178 0B 
041179 04 
04117A FD      3376 INC     IY			; Yes, so skip the comma
04117B 23 
04117C CD      3377 CALL    NXT			; And any whitespace
04117D 70 
04117E 0A 
04117F 04 
041180 18      3378 JR      LOCAL2			; Then loop back and handle any further local variables
041181 D4 
               3379 
               3380 ; ENDPROC
               3381 ;
041182 C1      3382 ENDPRO:			POP     BC			; Pop the check value off the stack
041183 21      3383 LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041184 82 
041185 17 
041186 04 
041187 B7      3384 OR      A
041188 ED      3385 SBC     HL,BC
041189 42 
04118A 28      3386 JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04118B 13 
               3387 ;
04118C 21      3388 LD      HL,PROCHK       	; Check if it is the PROC marker
04118D 89 
04118E 10 
04118F 04 
041190 B7      3389 OR      A
041191 ED      3390 SBC     HL,BC
041192 42 
041193 FD      3391 POP     IY
041194 E1 
041195 CA      3392 JP      Z,XEQ			; Yes, it is, so carry on, all is good
041196 96 
041197 0B 
041198 04 
041199 3E      3393 LD      A,13			; Otherwise throw the "No PROC" error
04119A 0D 
04119B C3      3394 JP      ERROR_
04119C 90 
04119D 37 
04119E 04 
               3395 ;
04119F DD      3396 UNSTK:			POP     IX			; Unstack a single local variable
0411A0 E1 
0411A1 C1      3397 POP     BC
0411A2 78      3398 LD      A,B
0411A3 B7      3399 OR      A
0411A4 FA      3400 JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411A5 B2 
0411A6 11 
0411A7 04 
0411A8 E1      3401 POP     HL			; Unstack a normal variable
0411A9 D9      3402 EXX
0411AA E1      3403 POP     HL
0411AB D9      3404 EXX
0411AC CD      3405 CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411AD 00 
0411AE 16 
0411AF 04 
0411B0 18      3406 JR      ENDPRO			; And loop back to ENDPRO
0411B1 D0 
               3407 ;
0411B2 21      3408 UNSTK1:			LD      HL,0			; Unstack a string
0411B3 00 
0411B4 00 
0411B5 00 
0411B6 39      3409 ADD     HL,SP
0411B7 59      3410 LD      E,C
0411B8 CD      3411 CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411B9 2E 
0411BA 16 
0411BB 04 
0411BC F9      3412 LD      SP,HL
0411BD 18      3413 JR      ENDPRO
0411BE C3 
               3414 
               3415 ; INPUT #channel,var,var...
               3416 ;
0411BF CD      3417 INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C0 BC 
0411C1 18 
0411C2 04 
0411C3 CD      3418 INPN1:			CALL    NXT
0411C4 70 
0411C5 0A 
0411C6 04 
0411C7 FE      3419 CP      ','
0411C8 2C 
0411C9 C2      3420 JP      NZ,XEQ
0411CA 96 
0411CB 0B 
0411CC 04 
0411CD FD      3421 INC     IY
0411CE 23 
0411CF CD      3422 CALL    NXT
0411D0 70 
0411D1 0A 
0411D2 04 
0411D3 D5      3423 PUSH    DE
0411D4 CD      3424 CALL    VAR_
0411D5 8E 
0411D6 0C 
0411D7 04 
0411D8 D1      3425 POP     DE
0411D9 F5      3426 PUSH    AF              ;SAVE TYPE
0411DA E5      3427 PUSH    HL              ;VARPTR
0411DB B7      3428 OR      A
0411DC FA      3429 JP      M,INPN2         ;STRING
0411DD 08 
0411DE 12 
0411DF 04 
0411E0 CD      3430 CALL    OSBGET
0411E1 74 
0411E2 43 
0411E3 04 
0411E4 D9      3431 EXX
0411E5 6F      3432 LD      L,A
0411E6 D9      3433 EXX
0411E7 CD      3434 CALL    OSBGET
0411E8 74 
0411E9 43 
0411EA 04 
0411EB D9      3435 EXX
0411EC 67      3436 LD      H,A
0411ED D9      3437 EXX
0411EE CD      3438 CALL    OSBGET
0411EF 74 
0411F0 43 
0411F1 04 
0411F2 6F      3439 LD      L,A
0411F3 CD      3440 CALL    OSBGET
0411F4 74 
0411F5 43 
0411F6 04 
0411F7 67      3441 LD      H,A
0411F8 CD      3442 CALL    OSBGET
0411F9 74 
0411FA 43 
0411FB 04 
0411FC 4F      3443 LD      C,A
0411FD DD      3444 POP     IX
0411FE E1 
0411FF F1      3445 POP     AF              ;RESTORE TYPE
041200 D5      3446 PUSH    DE              ;SAVE CHANNEL
041201 CD      3447 CALL    STORE
041202 00 
041203 16 
041204 04 
041205 D1      3448 POP     DE
041206 18      3449 JR      INPN1
041207 BB 
041208 21      3450 INPN2:			LD      HL,ACCS
041209 00 
04120A 4A 
04120B 04 
04120C CD      3451 INPN3:			CALL    OSBGET
04120D 74 
04120E 43 
04120F 04 
041210 FE      3452 CP      CR
041211 0D 
041212 28      3453 JR      Z,INPN4
041213 04 
041214 77      3454 LD      (HL),A
041215 2C      3455 INC     L
041216 20      3456 JR      NZ,INPN3
041217 F4 
041218 DD      3457 INPN4:			POP     IX
041219 E1 
04121A F1      3458 POP     AF
04121B D5      3459 PUSH    DE
04121C EB      3460 EX      DE,HL
04121D CD      3461 CALL    STACCS
04121E 2A 
04121F 16 
041220 04 
041221 D1      3462 POP     DE
041222 18      3463 JR      INPN1
041223 9F 
               3464 
               3465 ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3466 ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3467 ;
041224 FE      3468 INPUT:			CP      '#'
041225 23 
041226 28      3469 JR      Z,INPUTN
041227 97 
041228 0E      3470 LD      C,0             ;FLAG PROMPT
041229 00 
04122A FE      3471 CP      LINE_EX_
04122B 86 
04122C 20      3472 JR      NZ,INPUT0
04122D 04 
04122E FD      3473 INC     IY              ;SKIP "LINE"
04122F 23 
041230 0E      3474 LD      C,80H
041231 80 
041232 21      3475 INPUT0:			LD      HL,BUFFER
041233 00 
041234 4B 
041235 04 
041236 36      3476 LD      (HL),CR         ;INITIALISE EMPTY
041237 0D 
041238 CD      3477 INPUT1:			CALL    TERMQ
041239 A4 
04123A 17 
04123B 04 
04123C CA      3478 JP      Z,XEQ           ;DONE
04123D 96 
04123E 0B 
04123F 04 
041240 FD      3479 INC     IY
041241 23 
041242 FE      3480 CP      ','
041243 2C 
041244 28      3481 JR      Z,INPUT3        ;SKIP COMMA
041245 5C 
041246 FE      3482 CP      ';'
041247 3B 
041248 28      3483 JR      Z,INPUT3
041249 58 
04124A E5      3484 PUSH    HL              ;SAVE BUFFER POINTER
04124B FE      3485 CP      34		;ASCII ""
04124C 22 
04124D 20      3486 JR      NZ,INPUT6
04124E 0C 
04124F C5      3487 PUSH    BC
041250 CD      3488 CALL    CONS
041251 67 
041252 04 
041253 04 
041254 C1      3489 POP     BC
041255 CD      3490 CALL    PTEXT           ;PRINT PROMPT
041256 28 
041257 18 
041258 04 
041259 18      3491 JR      INPUT9
04125A 06 
04125B CD      3492 INPUT6:			CALL    FORMAT          ;SPC, TAB, '
04125C C9 
04125D 17 
04125E 04 
04125F 20      3493 JR      NZ,INPUT2
041260 05 
041261 E1      3494 INPUT9:			POP     HL
041262 CB      3495 SET     0,C             ;FLAG NO PROMPT
041263 C1 
041264 18      3496 JR      INPUT0
041265 CC 
041266 FD      3497 INPUT2:			DEC     IY
041267 2B 
041268 C5      3498 PUSH    BC
041269 CD      3499 CALL    VAR_
04126A 8E 
04126B 0C 
04126C 04 
04126D C1      3500 POP     BC
04126E E1      3501 POP     HL
04126F F5      3502 PUSH    AF              ;SAVE TYPE
041270 7E      3503 LD      A,(HL)
041271 23      3504 INC     HL
041272 FE      3505 CP      CR              ;BUFFER EMPTY?
041273 0D 
041274 CC      3506 CALL    Z,REFILL
041275 A6 
041276 12 
041277 04 
041278 CB      3507 BIT     7,C
041279 79 
04127A F5      3508 PUSH    AF
04127B C4      3509 CALL    NZ,LINES
04127C 4A 
04127D 18 
04127E 04 
04127F F1      3510 POP     AF
041280 CC      3511 CALL    Z,FETCHS
041281 37 
041282 18 
041283 04 
041284 F1      3512 POP     AF              ;RESTORE TYPE
041285 C5      3513 PUSH    BC
041286 E5      3514 PUSH    HL
041287 B7      3515 OR      A
041288 FA      3516 JP      M,INPUT4        ;STRING
041289 9C 
04128A 12 
04128B 04 
04128C F5      3517 PUSH    AF
04128D DD      3518 PUSH    IX
04128E E5 
04128F CD      3519 CALL    VAL0
041290 6E 
041291 06 
041292 04 
041293 DD      3520 POP     IX
041294 E1 
041295 F1      3521 POP     AF
041296 CD      3522 CALL    STORE
041297 00 
041298 16 
041299 04 
04129A 18      3523 JR      INPUT5
04129B 04 
04129C CD      3524 INPUT4:			CALL    STACCS
04129D 2A 
04129E 16 
04129F 04 
0412A0 E1      3525 INPUT5:			POP     HL
0412A1 C1      3526 POP     BC
0412A2 CB      3527 INPUT3:			RES     0,C
0412A3 81 
0412A4 18      3528 JR      INPUT1
0412A5 92 
               3529 ;
0412A6 CB      3530 REFILL:			BIT     0,C
0412A7 41 
0412A8 20      3531 JR      NZ,REFIL0       ;NO PROMPT
0412A9 0C 
0412AA 3E      3532 LD      A,'?'
0412AB 3F 
0412AC CD      3533 CALL    OUTCHR          ;PROMPT
0412AD 7F 
0412AE 39 
0412AF 04 
0412B0 3E      3534 LD      A,' '
0412B1 20 
0412B2 CD      3535 CALL    OUTCHR
0412B3 7F 
0412B4 39 
0412B5 04 
0412B6 21      3536 REFIL0:			LD      HL,BUFFER
0412B7 00 
0412B8 4B 
0412B9 04 
0412BA C5      3537 PUSH    BC
0412BB E5      3538 PUSH    HL
0412BC DD      3539 PUSH    IX
0412BD E5 
0412BE CD      3540 CALL    OSLINE
0412BF 8F 
0412C0 3E 
0412C1 04 
0412C2 DD      3541 POP     IX
0412C3 E1 
0412C4 E1      3542 POP     HL
0412C5 C1      3543 POP     BC
0412C6 47      3544 LD      B,A             ;POS AT ENTRY
0412C7 AF      3545 XOR     A
0412C8 32      3546 LD      (COUNT),A
0412C9 3D 
0412CA 4D 
0412CB 04 
0412CC B8      3547 CP      B
0412CD C8      3548 RET     Z
0412CE 7E      3549 REFIL1:			LD      A,(HL)
0412CF FE      3550 CP      CR
0412D0 0D 
0412D1 C8      3551 RET     Z
0412D2 23      3552 INC     HL
0412D3 10      3553 DJNZ    REFIL1
0412D4 F9 
0412D5 C9      3554 RET
               3555 
               3556 ; READ var[,var...]
               3557 ;
0412D6 FE      3558 READ:			CP      '#'
0412D7 23 
0412D8 CA      3559 JP      Z,INPUTN
0412D9 BF 
0412DA 11 
0412DB 04 
0412DC 2A      3560 LD      HL,(DATPTR)
0412DD 31 
0412DE 4D 
0412DF 04 
0412E0 7E      3561 READ0:			LD      A,(HL)
0412E1 23      3562 INC     HL              ;SKIP COMMA OR "DATA"
0412E2 FE      3563 CP      CR              ;END OF DATA STMT?
0412E3 0D 
0412E4 CC      3564 CALL    Z,GETDAT
0412E5 28 
0412E6 13 
0412E7 04 
0412E8 E5      3565 PUSH    HL
0412E9 CD      3566 CALL    VAR_
0412EA 8E 
0412EB 0C 
0412EC 04 
0412ED E1      3567 POP     HL
0412EE B7      3568 OR      A
0412EF FA      3569 JP      M,READ1         ;STRING
0412F0 08 
0412F1 13 
0412F2 04 
0412F3 E5      3570 PUSH    HL
0412F4 FD      3571 EX      (SP),IY
0412F5 E3 
0412F6 F5      3572 PUSH    AF              ;SAVE TYPE
0412F7 DD      3573 PUSH    IX
0412F8 E5 
0412F9 CD      3574 CALL    EXPRN
0412FA 02 
0412FB 03 
0412FC 04 
0412FD DD      3575 POP     IX
0412FE E1 
0412FF F1      3576 POP     AF
041300 CD      3577 CALL    STORE
041301 00 
041302 16 
041303 04 
041304 FD      3578 EX      (SP),IY
041305 E3 
041306 18      3579 JR      READ2
041307 09 
041308 CD      3580 READ1:			CALL    FETCHS
041309 37 
04130A 18 
04130B 04 
04130C E5      3581 PUSH    HL
04130D CD      3582 CALL    STACCS
04130E 2A 
04130F 16 
041310 04 
041311 E1      3583 READ2:			POP     HL
041312 22      3584 LD      (DATPTR),HL
041313 31 
041314 4D 
041315 04 
041316 CD      3585 CALL    NXT
041317 70 
041318 0A 
041319 04 
04131A FE      3586 CP      ','
04131B 2C 
04131C C2      3587 JP      NZ,XEQ
04131D 96 
04131E 0B 
04131F 04 
041320 FD      3588 INC     IY
041321 23 
041322 CD      3589 CALL    NXT
041323 70 
041324 0A 
041325 04 
041326 18      3590 JR      READ0
041327 B8 
               3591 ;
041328 3E      3592 GETDAT:			LD      A,DATA_EX_
041329 DC 
04132A CD      3593 CALL    SEARCH_EX
04132B 78 
04132C 18 
04132D 04 
04132E 23      3594 INC     HL
04132F D0      3595 RET     NC
041330 3E      3596 LD      A,42
041331 2A 
041332 C3      3597 ERROR4:			JP      ERROR_           ;"Out of DATA"
041333 90 
041334 37 
041335 04 
               3598 
               3599 ; IF expr statement
               3600 ; IF expr THEN statement [ELSE statement]
               3601 ; IF expr THEN line [ELSE line]
               3602 ;
041336 CD      3603 IF_:			CALL    EXPRI
041337 0A 
041338 03 
041339 04 
04133A CD      3604 CALL    TEST
04133B DF 
04133C 08 
04133D 04 
04133E 28      3605 JR      Z,IFNOT         ;FALSE
04133F 19 
041340 FD      3606 LD      A,(IY)
041341 7E 
041342 00 
041343 FE      3607 CP      THEN_EX_
041344 8C 
041345 C2      3608 JP      NZ,XEQ
041346 96 
041347 0B 
041348 04 
041349 FD      3609 INC     IY              ;SKIP "THEN"
04134A 23 
04134B CD      3610 IF1:			CALL    NXT
04134C 70 
04134D 0A 
04134E 04 
04134F FE      3611 CP      LINO_EX
041350 8D 
041351 C2      3612 JP      NZ,XEQ          ;STATEMENT FOLLOWS
041352 96 
041353 0B 
041354 04 
041355 C3      3613 JP      GOTO_EX            ;LINE NO. FOLLOWS
041356 2B 
041357 0F 
041358 04 
041359 FD      3614 IFNOT:			LD      A,(IY)
04135A 7E 
04135B 00 
04135C FE      3615 CP      CR
04135D 0D 
04135E FD      3616 INC     IY
04135F 23 
041360 CA      3617 JP      Z,XEQ0          ;END OF LINE
041361 92 
041362 0B 
041363 04 
041364 FE      3618 CP      ELSE_EX_
041365 8B 
041366 20      3619 JR      NZ,IFNOT
041367 F1 
041368 18      3620 JR      IF1
041369 E1 
               3621 
               3622 ; CLS
               3623 ;
04136A CD      3624 CLS:		CALL    CLRSCN
04136B 02 
04136C 44 
04136D 04 
04136E AF      3625 XOR     A
04136F 32      3626 LD      (COUNT),A
041370 3D 
041371 4D 
041372 04 
041373 C3      3627 JP      XEQ
041374 96 
041375 0B 
041376 04 
               3628 
               3629 ; STOP
               3630 ;
041377 CD      3631 STOP:			CALL    TELL
041378 C0 
041379 3D 
04137A 04 
04137B 0D      3632 DB	CR
04137C 0A      3633 DB	LF
04137D FA      3634 DB	TSTOP
04137E 00      3635 DB	0
04137F CD      3636 CALL    SETLIN          ;FIND CURRENT LINE
041380 DE 
041381 39 
041382 04 
041383 CD      3637 CALL    SAYLN
041384 12 
041385 3A 
041386 04 
041387 CD      3638 CALL    CRLF
041388 77 
041389 39 
04138A 04 
04138B C3      3639 JP      CLOOP
04138C B0 
04138D 30 
04138E 04 
               3640 
               3641 ; REPORT
               3642 ;
04138F CD      3643 REPOR:			CALL    REPORT
041390 B2 
041391 3D 
041392 04 
041393 C3      3644 JP      XEQ
041394 96 
041395 0B 
041396 04 
               3645 
               3646 ; CLEAR
               3647 ;
041397 CD      3648 CLR:			CALL    CLEAR
041398 A6 
041399 38 
04139A 04 
04139B 2A      3649 LD      HL,(PAGE_)
04139C 14 
04139D 4D 
04139E 04 
04139F 18      3650 JR      RESTR1
0413A0 19 
               3651 
               3652 ; RESTORE [line]
               3653 ;
0413A1 2A      3654 RESTOR_EX:			LD      HL,(PAGE_)
0413A2 14 
0413A3 4D 
0413A4 04 
0413A5 CD      3655 CALL    TERMQ
0413A6 A4 
0413A7 17 
0413A8 04 
0413A9 28      3656 JR      Z,RESTR1
0413AA 0F 
0413AB CD      3657 CALL    ITEMI
0413AC 25 
0413AD 03 
0413AE 04 
0413AF D9      3658 EXX
0413B0 CD      3659 CALL    FINDL           ;SEARCH FOR LINE
0413B1 BF 
0413B2 39 
0413B3 04 
0413B4 3E      3660 LD      A,41
0413B5 29 
0413B6 C2      3661 JP      NZ,ERROR4       ;"No such line"
0413B7 32 
0413B8 13 
0413B9 04 
0413BA 3E      3662 RESTR1:			LD      A,DATA_EX_
0413BB DC 
0413BC CD      3663 CALL    SEARCH_EX
0413BD 78 
0413BE 18 
0413BF 04 
0413C0 22      3664 LD      (DATPTR),HL
0413C1 31 
0413C2 4D 
0413C3 04 
0413C4 C3      3665 JP      XEQ
0413C5 96 
0413C6 0B 
0413C7 04 
               3666 
               3667 ; PTR#channel=expr
               3668 ; PAGE=expr
               3669 ; TIME=expr
               3670 ; LOMEM=expr
               3671 ; HIMEM=expr
               3672 ;
0413C8 CD      3673 PTR_EX:			CALL    CHANEL
0413C9 B0 
0413CA 18 
0413CB 04 
0413CC CD      3674 CALL    EQUALS
0413CD BA 
0413CE 17 
0413CF 04 
0413D0 7B      3675 LD      A,E
0413D1 F5      3676 PUSH    AF
0413D2 CD      3677 CALL    EXPRI
0413D3 0A 
0413D4 03 
0413D5 04 
0413D6 E5      3678 PUSH    HL
0413D7 D9      3679 EXX
0413D8 D1      3680 POP     DE
0413D9 F1      3681 POP     AF
0413DA CD      3682 CALL    PUTPTR
0413DB A8 
0413DC 43 
0413DD 04 
0413DE C3      3683 JP      XEQ
0413DF 96 
0413E0 0B 
0413E1 04 
               3684 ;
0413E2 CD      3685 PAGEV_EX:			CALL    EQUALS
0413E3 BA 
0413E4 17 
0413E5 04 
0413E6 CD      3686 CALL    EXPRI
0413E7 0A 
0413E8 03 
0413E9 04 
0413EA D9      3687 EXX
0413EB 2E      3688 LD      L,0
0413EC 00 
0413ED 22      3689 LD      (PAGE_),HL
0413EE 14 
0413EF 4D 
0413F0 04 
0413F1 C3      3690 JP      XEQ
0413F2 96 
0413F3 0B 
0413F4 04 
               3691 ;
0413F5 FE      3692 TIMEV_EX:			CP      '$'
0413F6 24 
0413F7 28      3693 JR      Z,TIMEVS_EX
0413F8 13 
0413F9 CD      3694 CALL    EQUALS
0413FA BA 
0413FB 17 
0413FC 04 
0413FD CD      3695 CALL    EXPRI
0413FE 0A 
0413FF 03 
041400 04 
041401 E5      3696 PUSH    HL
041402 D9      3697 EXX
041403 D1      3698 POP     DE
041404 CD      3699 CALL    PUTIME
041405 C7 
041406 3E 
041407 04 
041408 C3      3700 JP      XEQ
041409 96 
04140A 0B 
04140B 04 
               3701 ;
04140C FD      3702 TIMEVS_EX:			INC     IY              ;SKIP '$'
04140D 23 
04140E CD      3703 CALL    EQUALS
04140F BA 
041410 17 
041411 04 
041412 CD      3704 CALL    EXPRS
041413 15 
041414 03 
041415 04 
041416 CD      3705 CALL    PUTIMS
041417 7C 
041418 49 
041419 04 
04141A C3      3706 JP      XEQ
04141B 96 
04141C 0B 
04141D 04 
               3707 ;
04141E CD      3708 LOMEMV_EX:			CALL    EQUALS
04141F BA 
041420 17 
041421 04 
041422 CD      3709 CALL    EXPRI
041423 0A 
041424 03 
041425 04 
041426 CD      3710 CALL    CLEAR
041427 A6 
041428 38 
041429 04 
04142A D9      3711 EXX
04142B 22      3712 LD      (LOMEM),HL
04142C 1A 
04142D 4D 
04142E 04 
04142F 22      3713 LD      (FREE),HL
041430 1D 
041431 4D 
041432 04 
041433 C3      3714 JP      XEQ
041434 96 
041435 0B 
041436 04 
               3715 ;
041437 CD      3716 HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041438 BA 
041439 17 
04143A 04 
04143B CD      3717 CALL    EXPRI			; Load the expression into registers
04143C 0A 
04143D 03 
04143E 04 
04143F 7D      3718 LD	A,L			;  A: The MSB of the 24-bit value
041440 D9      3719 EXX				; HL: The LSW of the 24-bit value
041441 22      3720 LD	(R0),HL
041442 4A 
041443 4D 
041444 04 
041445 32      3721 LD	(R0+2),A
041446 4C 
041447 4D 
041448 04 
041449 2A      3722 LD	HL,(FREE)
04144A 1D 
04144B 4D 
04144C 04 
04144D 11      3723 LD      DE,256
04144E 00 
04144F 01 
041450 00 
041451 19      3724 ADD	HL,DE
041452 EB      3725 EX	DE,HL			; DE: FREE + 256
041453 2A      3726 LD	HL,(R0)			; HL: The passed expression
041454 4A 
041455 4D 
041456 04 
041457 AF      3727 XOR     A
041458 ED      3728 SBC     HL,DE
041459 52 
04145A 19      3729 ADD     HL,DE			; Do a bounds check
04145B DA      3730 JP      C,ERROR_         	; Throw the error: "No room"
04145C 90 
04145D 37 
04145E 04 
04145F ED      3731 LD      DE,(HIMEM)
041460 5B 
041461 20 
041462 4D 
041462 04   
041464 22      3732 LD      (HIMEM),HL
041465 20 
041466 4D 
041467 04 
041468 EB      3733 EX      DE,HL
041469 ED      3734 SBC     HL,SP			; Adjust the stack
04146A 72 
04146B C2      3735 JP      NZ,XEQ
04146C 96 
04146D 0B 
04146E 04 
04146F EB      3736 EX      DE,HL
041470 F9      3737 LD      SP,HL           	; Load the SP
041471 C3      3738 JP      XEQ
041472 96 
041473 0B 
041474 04 
               3739 
               3740 ; WIDTH expr
               3741 ;
041475 CD      3742 WIDTHV:			CALL    EXPRI
041476 0A 
041477 03 
041478 04 
041479 D9      3743 EXX
04147A 7D      3744 LD      A,L
04147B 32      3745 LD      (WIDTH),A
04147C 3E 
04147D 4D 
04147E 04 
04147F C3      3746 JP      XEQ
041480 96 
041481 0B 
041482 04 
               3747 
               3748 ; TRACE ON
               3749 ; TRACE OFF
               3750 ; TRACE line
               3751 ;
041483 FD      3752 TRACE_EX:			INC     IY
041484 23 
041485 21      3753 LD      HL,0
041486 00 
041487 00 
041488 00 
041489 FE      3754 CP      TON
04148A EE 
04148B 28      3755 JR      Z,TRACE0
04148C 0B 
04148D FE      3756 CP      OFF_
04148E 87 
04148F 28      3757 JR      Z,TRACE1
041490 08 
041491 FD      3758 DEC     IY
041492 2B 
041493 CD      3759 CALL    EXPRI
041494 0A 
041495 03 
041496 04 
041497 D9      3760 EXX
041498 2B      3761 TRACE0:			DEC     HL
041499 22      3762 TRACE1:			LD      (TRACEN),HL
04149A 26 
04149B 4D 
04149C 04 
04149D C3      3763 JP      XEQ
04149E 96 
04149F 0B 
0414A0 04 
               3764 
               3765 ; VDU expr,expr;....
               3766 ;
0414A1 DD      3767 VDU:			LD	IX,BUFFER		; Storage for the VDU stream
0414A2 21 
0414A3 00 
0414A4 4B 
0414A4 04   
0414A6 DD      3768 VDU1:			PUSH	IX
0414A7 E5 
0414A8 CD      3769 CALL    EXPRI			; Fetch the VDU character
0414A9 0A 
0414AA 03 
0414AB 04 
0414AC DD      3770 POP	IX
0414AD E1 
0414AE D9      3771 EXX
0414AF DD      3772 LD	(IX+0),L		; Write out the character to the buffer
0414B0 75 
0414B1 00 
0414B2 DD      3773 INC	IX
0414B3 23 
0414B4 FD      3774 LD      A,(IY)			;  A: The separator character
0414B5 7E 
0414B6 00 
0414B7 FE      3775 CP      ','			; Is it a comma?
0414B8 2C 
0414B9 28      3776 JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414BA 09 
0414BB FE      3777 CP      ';'			; Is it a semicolon?
0414BC 3B 
0414BD 20      3778 JR      NZ,VDU3			; No, so skip to the next expression
0414BE 07 
0414BF DD      3779 LD	(IX+0),H		; Write out the high byte to the buffer
0414C0 74 
0414C1 00 
0414C2 DD      3780 INC	IX
0414C3 23 
0414C4 FD      3781 VDU2:			INC     IY			; Skip to the next character
0414C5 23 
0414C6 CD      3782 VDU3:			CALL    TERMQ			; Skip past white space
0414C7 A4 
0414C8 17 
0414C9 04 
0414CA 20      3783 JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414CB DA 
0414CC DD      3784 LD	A,IXL			;  A: Number of bytes to write out
0414CD 7D 
0414CE B7      3785 OR	A
0414CF 28      3786 JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D0 0B 
0414D1 21      3787 LD	HL,BUFFER		; HL: Start of stream
0414D2 00 
0414D3 4B 
0414D4 04 
0414D5 01      3788 LD	BC,0
0414D6 00 
0414D7 00 
0414D8 00 
0414D9 4F      3789 LD	C,A			; BC: Number of bytes to write out
0414DA 5B      3790 RST.LIL	18h			; Output the buffer to MOS
0414DB DF 
0414DC C3      3791 VDU4:			JP      XEQ
0414DD 96 
0414DE 0B 
0414DF 04 
               3792 
               3793 ; CLOSE channel number
               3794 ;
0414E0 CD      3795 CLOSE:			CALL    CHANEL			; Fetch the channel number
0414E1 B0 
0414E2 18 
0414E3 04 
0414E4 CD      3796 CALL    OSSHUT			; Close the channel
0414E5 6C 
0414E6 43 
0414E7 04 
0414E8 C3      3797 JP      XEQ
0414E9 96 
0414EA 0B 
0414EB 04 
               3798 
               3799 ; BPUT channel,byte
               3800 ;
0414EC CD      3801 BPUT:			CALL    CHANEL          	; Fetch the channel number
0414ED B0 
0414EE 18 
0414EF 04 
0414F0 D5      3802 PUSH    DE			; DE: Channel number
0414F1 CD      3803 CALL    COMMA			; Skip to the next expression
0414F2 22 
0414F3 0A 
0414F4 04 
0414F5 CD      3804 CALL    EXPRI           	; Feth the data
0414F6 0A 
0414F7 03 
0414F8 04 
0414F9 D9      3805 EXX
0414FA 7D      3806 LD      A,L			; A: The byte to write
0414FB D1      3807 POP     DE
0414FC CD      3808 CALL    OSBPUT			; Write the byte out
0414FD 7C 
0414FE 43 
0414FF 04 
041500 C3      3809 JP      XEQ
041501 96 
041502 0B 
041503 04 
               3810 
               3811 ; CALL address[,var[,var...]]
               3812 ;
               3813 ; Note that the parameter table differs from the Z80 version
               3814 ; Each entry now takes up 4 bytes, not 3, so the table is now:
               3815 ;  -1 byte:  Number of parameters
               3816 ; Then, for each parameter:
               3817 ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
               3818 ;  -3 bytes: Parameter address
               3819 ;
               3820 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
               3821 ;
041504 CD      3822 CALL_:			CALL    EXPRI           	; Fetch the address
041505 0A 
041506 03 
041507 04 
041508 7D      3823 LD	A,L			;  A: MSB of address
041509 D9      3824 EXX
04150A 22      3825 LD	(R0+0),HL		; HL: LSW of address
04150B 4A 
04150C 4D 
04150D 04 
04150E 32      3826 LD	(R0+2),A
04150F 4C 
041510 4D 
041511 04 
041512 06      3827 LD      B,0             	;  B: The parameter counter
041513 00 
041514 11      3828 LD      DE,BUFFER       	; DE: Vector
041515 00 
041516 4B 
041517 04 
               3829 ;
041518 CD      3830 CALL1:			CALL    NXT			; Skip whitespace
041519 70 
04151A 0A 
04151B 04 
04151C FE      3831 CP      ','			; Check for comma
04151D 2C 
04151E 20      3832 JR      NZ,CALL2		; If no more parameters, then jump here
04151F 1B 
041520 FD      3833 INC     IY			; Skip to the next character
041521 23 
041522 04      3834 INC     B			; Increment the parameter count
041523 CD      3835 CALL    NXT			; Skip whitespace
041524 70 
041525 0A 
041526 04 
041527 C5      3836 PUSH    BC
041528 D5      3837 PUSH    DE
041529 CD      3838 CALL    VAR_
04152A 8E 
04152B 0C 
04152C 04 
04152D D1      3839 POP     DE
04152E C1      3840 POP     BC
04152F 13      3841 INC     DE
041530 12      3842 LD      (DE),A			; Save the parameter type
041531 13      3843 INC     DE
041532 EB      3844 EX      DE,HL
041533 ED      3845 LD	(HL),DE			; Save the parameter address (3 bytes)
041534 1F 
041535 23      3846 INC	HL
041536 23      3847 INC	HL
041537 23      3848 INC	HL
041538 EB      3849 EX      DE,HL
041539 18      3850 JR      CALL1
04153A DD 
               3851 ;
04153B 78      3852 CALL2:			LD      A,B
04153C 32      3853 LD      (BUFFER),A      	; Save the parameter count
04153D 00 
04153E 4B 
04153F 04 
041540 2A      3854 LD	HL,(R0)			; HL: Address of the code
041541 4A 
041542 4D 
041543 04 
041544 CD      3855 CALL    USR1			; And call it
041545 5E 
041546 15 
041547 04 
041548 C3      3856 JP      XEQ
041549 96 
04154A 0B 
04154B 04 
               3857 
               3858 ; USR(address)
               3859 ;
04154C CD      3860 USR:			CALL    ITEMI			; Evaluate the expression
04154D 25 
04154E 03 
04154F 04 
041550 7D      3861 LD	A,L			;  A: MSB of address
041551 D9      3862 EXX
041552 22      3863 LD	(R0+0),HL		; HL: LSW of address
041553 4A 
041554 4D 
041555 04 
041556 32      3864 LD	(R0+2),A
041557 4C 
041558 4D 
041559 04 
04155A 2A      3865 LD	HL,(R0)			; Get the 24-bit address in HL
04155B 4A 
04155C 4D 
04155D 04 
               3866 ;
04155E E5      3867 USR1:			PUSH    HL              	; Address on stack
04155F FD      3868 EX      (SP),IY
041560 E3 
041561 24      3869 INC     H               	; Check for PAGE &00FFxx
041562 B4      3870 OR	H
041563 21      3871 LD      HL,USR2         	; Return address
041564 CD 
041565 15 
041566 04 
041567 E5      3872 PUSH    HL
041568 DD      3873 LD      IX,STAVAR
041569 21 
04156A 00 
04156B 4C 
04156B 04   
04156D CC      3874 CALL    Z,OSCALL        	; Intercept &00FFxx
04156E 32 
04156F 43 
041570 04 
               3875 ;
041571 DD      3876 LD      C, (IX+24)		; F%
041572 4E 
041573 18 
041574 C5      3877 PUSH    BC
               3878 ;
041575 DD      3879 LD	A, (IX+8)		; B% -> MSW
041576 7E 
041577 08 
041578 32      3880 LD	(R0+1), A
041579 4B 
04157A 4D 
04157B 04 
04157C DD      3881 LD	A, (IX+9)
04157D 7E 
04157E 09 
04157F 32      3882 LD	(R0+2), A
041580 4C 
041581 4D 
041582 04 
041583 DD      3883 LD	A, (IX+12)		; C% -> LSB
041584 7E 
041585 0C 
041586 32      3884 LD	(R0+0), A
041587 4A 
041588 4D 
041589 04 
04158A ED      3885 LD	BC, (R0)
04158B 4B 
04158C 4A 
04158D 4D 
04158D 04   
               3886 ;
04158F DD      3887 LD	A, (IX+16)		; D% -> MSW
041590 7E 
041591 10 
041592 32      3888 LD	(R0+1), A
041593 4B 
041594 4D 
041595 04 
041596 DD      3889 LD	A, (IX+17)
041597 7E 
041598 11 
041599 32      3890 LD	(R0+2), A
04159A 4C 
04159B 4D 
04159C 04 
04159D DD      3891 LD	A, (IX+20)		; E% -> LSB
04159E 7E 
04159F 14 
0415A0 32      3892 LD	(R0+0), A
0415A1 4A 
0415A2 4D 
0415A3 04 
0415A4 ED      3893 LD	DE, (R0)
0415A5 5B 
0415A6 4A 
0415A7 4D 
0415A7 04   
               3894 ;
0415A9 DD      3895 LD	A, (IX+32)		; H% -> MSW
0415AA 7E 
0415AB 20 
0415AC 32      3896 LD	(R0+1), A
0415AD 4B 
0415AE 4D 
0415AF 04 
0415B0 DD      3897 LD	A, (IX+33)
0415B1 7E 
0415B2 21 
0415B3 32      3898 LD	(R0+2), A
0415B4 4C 
0415B5 4D 
0415B6 04 
0415B7 DD      3899 LD	A, (IX+48)		; L% -> LSB
0415B8 7E 
0415B9 30 
0415BA 32      3900 LD	(R0+0), A
0415BB 4A 
0415BC 4D 
0415BD 04 
0415BE 2A      3901 LD	HL, (R0)
0415BF 4A 
0415C0 4D 
0415C1 04 
               3902 ;
0415C2 F1      3903 POP     AF			; F%
0415C3 DD      3904 LD      A, (IX+4)        	; A%
0415C4 7E 
0415C5 04 
               3905 
0415C6 DD      3906 LD      IX,BUFFER
0415C7 21 
0415C8 00 
0415C9 4B 
0415C9 04   
0415CB FD      3907 JP      (IY)            	; Off to user routine
0415CC E9 
               3908 ;
0415CD FD      3909 USR2:			POP     IY
0415CE E1 
0415CF AF      3910 XOR     A
0415D0 4F      3911 LD      C,A
0415D1 C9      3912 RET
               3913 
               3914 ; PUT port,data
               3915 ;
0415D2 CD      3916 PUT:			CALL    EXPRI           ;PORT ADDRESS
0415D3 0A 
0415D4 03 
0415D5 04 
0415D6 D9      3917 EXX
0415D7 E5      3918 PUSH    HL
0415D8 CD      3919 CALL    COMMA
0415D9 22 
0415DA 0A 
0415DB 04 
0415DC CD      3920 CALL    EXPRI           ;DATA
0415DD 0A 
0415DE 03 
0415DF 04 
0415E0 D9      3921 EXX
0415E1 C1      3922 POP     BC
0415E2 ED      3923 OUT     (C),L           ;OUTPUT TO PORT BC
0415E3 69 
0415E4 C3      3924 JP      XEQ
0415E5 96 
0415E6 0B 
0415E7 04 
               3925 
               3926 ; SUBROUTINES -----------------------------------------------------------------
               3927 
               3928 ; ASSIGN - Assign a numeric value to a variable.
               3929 ; Outputs: NC,  Z - OK, numeric.
               3930 ;          NC, NZ - OK, string.
               3931 ;           C, NZ - illegal
               3932 ;
0415E8 CD      3933 ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415E9 6A 
0415EA 3A 
0415EB 04 
0415EC D8      3934 RET     C               	; Return with C if it is an illegal variable
0415ED C4      3935 CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415EE 59 
0415EF 3A 
0415F0 04 
0415F1 B7      3936 OR      A
0415F2 F8      3937 RET     M               	; Return if type is string (81h)
0415F3 F5      3938 PUSH    AF              	; It's a numeric type from this point on
0415F4 CD      3939 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415F5 BA 
0415F6 17 
0415F7 04 
0415F8 E5      3940 PUSH    HL
0415F9 CD      3941 CALL    EXPRN
0415FA 02 
0415FB 03 
0415FC 04 
0415FD DD      3942 POP     IX
0415FE E1 
0415FF F1      3943 POP     AF
041600 CB      3944 STORE:			BIT     0,A
041601 47 
041602 28      3945 JR      Z,STOREI
041603 13 
041604 BF      3946 CP      A               	; Set the variable to 0
041605 DD      3947 STORE5:			LD      (IX+4),C
041606 71 
041607 04 
041608 D9      3948 STORE4:			EXX
041609 DD      3949 LD      (IX+0),L
04160A 75 
04160B 00 
04160C DD      3950 LD      (IX+1),H
04160D 74 
04160E 01 
04160F D9      3951 EXX
041610 DD      3952 LD      (IX+2),L
041611 75 
041612 02 
041613 DD      3953 LD      (IX+3),H
041614 74 
041615 03 
041616 C9      3954 RET
041617 F5      3955 STOREI:			PUSH    AF
041618 0C      3956 INC     C               ;SPEED - & PRESERVE F'
041619 0D      3957 DEC     C               ; WHEN CALLED BY FNEND0
04161A C4      3958 CALL    NZ,SFIX         ;CONVERT TO INTEGER
04161B 62 
04161C 06 
04161D 04 
04161E F1      3959 POP     AF
04161F FE      3960 CP      4
041620 04 
041621 28      3961 JR      Z,STORE4
041622 E5 
041623 BF      3962 CP      A               ;SET ZERO
041624 D9      3963 STORE1:			EXX
041625 DD      3964 LD      (IX+0),L
041626 75 
041627 00 
041628 D9      3965 EXX
041629 C9      3966 RET
               3967 ;
               3968 ; Copy a string from the string accumulator to variable storage on the stack
               3969 ; Parameters:
               3970 ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
               3971 ; - IX: Address of the variable storage on the stack
               3972 ;
04162A 21      3973 STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
04162B 00 
04162C 4A 
04162D 04 
               3974 ;
               3975 ; Parameters:
               3976 ; As above, but:
               3977 ; - HL: Address of the string to be stored
               3978 ; -  E: The string length
               3979 ; NB:
               3980 ; Strings are mutable
               3981 ; Strings are stored in the following format in the variable:
               3982 ; - Address of the next variable (3 bytes)
               3983 ; - The rest of the variable name - this is zero terminated
               3984 ; - Current string length (byte)
               3985 ; - Maximum (original) string length (byte)
               3986 ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
               3987 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
               3988 ;
04162E 1F      3989 STORES:			RRA				; Rotate right to shift bit 0 into carry
04162F 30      3990 JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041630 5D 
041631 E5      3991 PUSH    HL			; Stack ACCS
               3992 ;
               3993 ; Load the string pointer and lengths into registers - these are all zeroed for new strings
               3994 ;
041632 D9      3995 EXX				; This block was a call to LOAD4
041633 DD      3996 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
041634 6E 
041635 00 
041636 DD      3997 LD      H,(IX+1)		; The maximum original string length
041637 66 
041638 01 
041639 D9      3998 EXX
04163A DD      3999 LD	HL,(IX+2)		; Address of the string (24-bit)
04163B 27 
04163C 02 
               4000 ;
04163D 7B      4001 LD      A,E             	; E : Length of string in ACCS (as passed to the function)
04163E D9      4002 EXX
04163F 6F      4003 LD      L,A			; L': Length of string currently stored on the stack
041640 7C      4004 LD      A,H             	; H': The maximum (original) string length
041641 D9      4005 EXX
041642 BB      4006 CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041643 30      4007 JR      NC,STORS1       	; Yes there is, so skip the next bit
041644 17 
               4008 ;
               4009 ; At this point we're either initialising a new string or assigning more memory to an existing string
               4010 ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
               4011 ; then the existing and new strings may both exist in memory.
               4012 ;
041645 D9      4013 EXX
041646 65      4014 LD      H,L			; H: Set the maximum string length to the string length
041647 D9      4015 EXX
041648 E5      4016 PUSH    HL
041649 01      4017 LD	BC, 0
04164A 00 
04164B 00 
04164C 00 
04164D 4F      4018 LD      C,A			; BC: The maximum (original) string length
04164E 09      4019 ADD     HL,BC			; Work out whether this is the last string in memory
04164F ED      4020 LD      BC,(FREE)
041650 4B 
041651 1D 
041652 4D 
041652 04   
041654 ED      4021 SBC     HL,BC			; Is string last?
041655 42 
041656 E1      4022 POP     HL
041657 37      4023 SCF
041658 28      4024 JR      Z,STORS1
041659 02 
               4025 ; LD	HL, BC			; HL=BC
04165A C5      4026 push bc
04165B E1      4027 pop hl
               4028 ;
               4029 ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
               4030 ; - H': The maximum (original) string length
               4031 ; - L': The actual string length (must be less than H')
               4032 ; - HL: Address of the string in memory
               4033 ;
04165C D9      4034 STORS1:			EXX				; This block was a call to STORE4
04165D DD      4035 LD      (IX+0),L		; The actual string length (must be less then H')
04165E 75 
04165F 00 
041660 DD      4036 LD      (IX+1),H		; The maximum (original) string length
041661 74 
041662 01 
041663 D9      4037 EXX
041664 DD      4038 LD	(IX+2),HL		; The pointer to the original string
041665 2F 
041666 02 
               4039 ;
041667 01      4040 LD	BC, 0
041668 00 
041669 00 
04166A 00 
04166B 4B      4041 LD      C,E			; BC: The new string length
04166C EB      4042 EX      DE,HL
04166D E1      4043 POP     HL
04166E 0D      4044 DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
04166F 0C      4045 INC     C			; check whether BC is 0 without affecting the carry flag
041670 C8      4046 RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041671 ED      4047 LDIR				; Replace the string in memory
041672 B0 
041673 D0      4048 RET     NC
041674 ED      4049 LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
041675 53 
041676 1D 
041677 4D 
041677 04   
               4050 ;
               4051 ; Check whether the stack is full
               4052 ;
041679 E5      4053 CHECK:			PUSH    HL
04167A C5      4054 PUSH	BC
04167B 2A      4055 LD      HL,(FREE)		; HL: Address of first free space byte
04167C 1D 
04167D 4D 
04167E 04 
04167F 01      4056 LD	BC,100h			; BC: One page of memory
041680 00 
041681 01 
041682 00 
041683 09      4057 ADD	HL,BC			; Add a page to FREE
041684 ED      4058 SBC     HL,SP			; And subtract the current SP
041685 72 
041686 C1      4059 POP	BC
041687 E1      4060 POP     HL
041688 D8      4061 RET     C			; The SP is not in the same page, so just return
041689 AF      4062 XOR     A			; Otherwise
04168A C3      4063 JP      ERROR_			; Throw error "No room"
04168B 90 
04168C 37 
04168D 04 
               4064 ;
04168E 01      4065 STORS3:			LD	BC,0
04168F 00 
041690 00 
041691 00 
041692 4B      4066 LD      C,E			; BC: String length
041693 DD      4067 PUSH    IX
041694 E5 
041695 D1      4068 POP     DE			; DE: Destination
041696 AF      4069 XOR     A			; Check if string length is 0
041697 B9      4070 CP      C
041698 28      4071 JR      Z,STORS5		; Yes, so don't copy
041699 02 
04169A ED      4072 LDIR
04169B B0 
04169C 3E      4073 STORS5:			LD      A,CR			; Finally add the terminator
04169D 0D 
04169E 12      4074 LD      (DE),A
04169F C9      4075 RET
               4076 
               4077 ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
               4078 ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
               4079 ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
               4080 ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
               4081 ;    Inputs: DE addresses parameter list
               4082 ;            IY addresses dummy variable list
               4083 ;   Outputs: DE,IY updated
               4084 ;  Destroys: Everything
               4085 ;
0416A0 3E      4086 ARGUE:			LD      A,-1
0416A1 FF 
0416A2 F5      4087 PUSH    AF              	; Put marker on the stack
0416A3 FD      4088 ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416A4 23 
0416A5 13      4089 INC     DE
0416A6 D5      4090 PUSH    DE
0416A7 CD      4091 CALL    NXT			; Skip any whitespace
0416A8 70 
0416A9 0A 
0416AA 04 
0416AB CD      4092 CALL    GETVAR			; Get the location of the variable in HL/IX
0416AC 6A 
0416AD 3A 
0416AE 04 
0416AF 38      4093 JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B0 3F 
0416B1 C4      4094 CALL    NZ,PUTVAR
0416B2 59 
0416B3 3A 
0416B4 04 
0416B5 D1      4095 POP     DE
0416B6 E5      4096 PUSH    HL              	; VARPTR
0416B7 B7      4097 OR      A               	; Check the variable type
0416B8 F5      4098 PUSH    AF
0416B9 D5      4099 PUSH    DE
0416BA FD      4100 EX      (SP),IY
0416BB E3 
0416BC FA      4101 JP      M,ARGUE2        	; Jump here if it is a string
0416BD D4 
0416BE 16 
0416BF 04 
               4102 ;
0416C0 CD      4103 CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416C1 02 
0416C2 03 
0416C3 04 
0416C4 FD      4104 EX      (SP),IY
0416C5 E3 
0416C6 D1      4105 POP     DE
0416C7 F1      4106 POP     AF
0416C8 D9      4107 EXX
0416C9 E5      4108 PUSH    HL
0416CA D9      4109 EXX
0416CB E5      4110 PUSH    HL
0416CC 47      4111 LD      B,A
0416CD C5      4112 PUSH    BC
0416CE CD      4113 CALL    CHECK           	; Check room
0416CF 79 
0416D0 16 
0416D1 04 
0416D2 18      4114 JR      ARGUE4
0416D3 0F 
               4115 ;
0416D4 CD      4116 ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416D5 15 
0416D6 03 
0416D7 04 
0416D8 FD      4117 EX      (SP),IY
0416D9 E3 
0416DA D9      4118 EXX
0416DB D1      4119 POP     DE
0416DC D9      4120 EXX
0416DD F1      4121 POP     AF
0416DE CD      4122 CALL    PUSHS
0416DF B4 
0416E0 09 
0416E1 04 
0416E2 D9      4123 EXX
               4124 ;
0416E3 CD      4125 ARGUE4:			CALL    NXT			; Skip whitespace
0416E4 70 
0416E5 0A 
0416E6 04 
0416E7 FE      4126 CP      ','			; Check to see if the next value is a comma
0416E8 2C 
0416E9 20      4127 JR      NZ,ARGUE5		; No, so jump here
0416EA 0B 
0416EB 1A      4128 LD      A,(DE)
0416EC FE      4129 CP      ','			; Are there any more arguments?
0416ED 2C 
0416EE 28      4130 JR      Z,ARGUE1        	; Yes, so loop
0416EF B3 
               4131 ;
0416F0 3E      4132 ARGERR:			LD      A,31
0416F1 1F 
0416F2 C3      4133 JP      ERROR_           	; Throw error "Arguments"
0416F3 90 
0416F4 37 
0416F5 04 
               4134 ;
0416F6 CD      4135 ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416F7 2F 
0416F8 0A 
0416F9 04 
0416FA 1A      4136 LD      A,(DE)
0416FB FE      4137 CP      ')'
0416FC 29 
0416FD 20      4138 JR      NZ,ARGERR
0416FE F1 
0416FF 13      4139 INC     DE
041700 D9      4140 EXX
041701 C1      4141 ARGUE6:			POP     BC
041702 78      4142 LD      A,B
041703 3C      4143 INC     A
041704 D9      4144 EXX
041705 C8      4145 RET     Z               	; Marker popped
041706 D9      4146 EXX
041707 3D      4147 DEC     A
041708 FA      4148 JP      M,ARGUE7        	; If it is a string, then jump here
041709 18 
04170A 17 
04170B 04 
04170C E1      4149 POP     HL
04170D D9      4150 EXX
04170E E1      4151 POP     HL
04170F D9      4152 EXX
041710 DD      4153 POP     IX
041711 E1 
041712 CD      4154 CALL    STORE	           	; Write to dummy variable
041713 00 
041714 16 
041715 04 
041716 18      4155 JR      ARGUE6
041717 E9 
               4156 ;
041718 CD      4157 ARGUE7:			CALL    POPS
041719 DE 
04171A 09 
04171B 04 
04171C DD      4158 POP     IX
04171D E1 
04171E CD      4159 CALL    STACCS
04171F 2A 
041720 16 
041721 04 
041722 18      4160 JR      ARGUE6
041723 DD 
               4161 
               4162 ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
               4163 ;   OF A FUNCTION OR PROCEDURE.
               4164 ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
               4165 ;    Inputs: IY is parameters pointer
               4166 ;   Outputs: IY updated
               4167 ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
               4168 ;
041724 D1      4169 SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
               4170 ;
041725 FD      4171 SAVLO1:			INC     IY              	; Bump past '(' or ','
041726 23 
041727 CD      4172 CALL    NXT			; And also any whitespace
041728 70 
041729 0A 
04172A 04 
04172B D5      4173 PUSH    DE			; Push the return address back onto the stack
04172C D9      4174 EXX
04172D C5      4175 PUSH    BC
04172E D5      4176 PUSH    DE
04172F E5      4177 PUSH    HL
041730 D9      4178 EXX
041731 CD      4179 CALL    VAR_             	; Dummy variable
041732 8E 
041733 0C 
041734 04 
041735 D9      4180 EXX
041736 E1      4181 POP     HL
041737 D1      4182 POP     DE
041738 C1      4183 POP     BC
041739 D9      4184 EXX
04173A D1      4185 POP     DE
04173B B7      4186 OR      A               	; Check the variable type
04173C FA      4187 JP      M,SAVLO2        	; 80h = string, so jump to save a local string
04173D 4F 
04173E 17 
04173F 04 
041740 D9      4188 EXX
041741 E5      4189 PUSH    HL              	; Save H'L'
041742 D9      4190 EXX
041743 47      4191 LD      B,A             	;  B: Variable type
041744 CD      4192 CALL    LOADN
041745 16 
041746 04 
041747 04 
041748 D9      4193 EXX
041749 E3      4194 EX      (SP),HL
04174A D9      4195 EXX
04174B E5      4196 PUSH    HL
04174C C5      4197 PUSH    BC
04174D 18      4198 JR      SAVLO4
04174E 2D 
               4199 ;
04174F F5      4200 SAVLO2:			PUSH    AF              	; Save the type (string)
041750 D5      4201 PUSH    DE
041751 D9      4202 EXX
041752 E5      4203 PUSH    HL
041753 D9      4204 EXX
041754 CD      4205 CALL    LOADS
041755 A0 
041756 04 
041757 04 
041758 D9      4206 EXX
041759 E1      4207 POP     HL
04175A D9      4208 EXX
04175B 01      4209 LD	BC,0
04175C 00 
04175D 00 
04175E 00 
04175F 4B      4210 LD      C,E			; BC: String length
041760 D1      4211 POP     DE
041761 CD      4212 CALL    CHECK			; Check if there is space on the stack
041762 79 
041763 16 
041764 04 
041765 F1      4213 POP     AF              	; Level stack
041766 21      4214 LD      HL,0
041767 00 
041768 00 
041769 00 
04176A ED      4215 SBC     HL,BC			; HL: Number of bytes required on the stack for the string
04176B 42 
04176C 39      4216 ADD     HL,SP			; Make space for the string on the stack
04176D F9      4217 LD      SP,HL
04176E 47      4218 LD      B,A             	;  B: Variable type
04176F C5      4219 PUSH    BC
041770 28      4220 JR      Z,SAVLO4
041771 0A 
041772 D5      4221 PUSH    DE
041773 11      4222 LD      DE,ACCS
041774 00 
041775 4A 
041776 04 
041777 EB      4223 EX      DE,HL
041778 45      4224 LD      B,L
041779 ED      4225 LDIR                    	; Save the string onto the stack
04177A B0 
04177B D1      4226 POP     DE
               4227 ;
04177C DD      4228 SAVLO4:			PUSH    IX			; VARPTR
04177D E5 
04177E CD      4229 CALL    SAVLO5
04177F 82 
041780 17 
041781 04 
               4230 LOCCHK:			EQU     $
041782 CD      4231 SAVLO5:			CALL    CHECK
041783 79 
041784 16 
041785 04 
041786 CD      4232 CALL    NXT
041787 70 
041788 0A 
041789 04 
04178A FE      4233 CP      ','             	; Are there any more local variables?
04178B 2C 
04178C 28      4234 JR      Z,SAVLO1		; Yes, so loop
04178D 97 
04178E EB      4235 EX      DE,HL			; DE -> HL: The return address
04178F E9      4236 JP      (HL)            	; And effectvely return
               4237 ;
041790 FD      4238 DELIM:			LD      A,(IY)          	; Assembler delimiter
041791 7E 
041792 00 
041793 FE      4239 CP      ' '
041794 20 
041795 C8      4240 RET     Z
041796 FE      4241 CP      ','
041797 2C 
041798 C8      4242 RET     Z
041799 FE      4243 CP      ')'
04179A 29 
04179B C8      4244 RET     Z
04179C FE      4245 TERM:			CP      ';'             	; Assembler terminator
04179D 3B 
04179E C8      4246 RET     Z
04179F FE      4247 CP      '\'
0417A0 5C 
0417A1 C8      4248 RET     Z
0417A2 18      4249 JR      TERM0
0417A3 07 
               4250 ;
0417A4 CD      4251 TERMQ:			CALL    NXT
0417A5 70 
0417A6 0A 
0417A7 04 
0417A8 FE      4252 CP      ELSE_EX_
0417A9 8B 
0417AA D0      4253 RET     NC
0417AB FE      4254 TERM0:			CP      ':'             	; Assembler seperator
0417AC 3A 
0417AD D0      4255 RET     NC
0417AE FE      4256 CP      CR
0417AF 0D 
0417B0 C9      4257 RET
               4258 ;
0417B1 CD      4259 SPAN:			CALL    TERMQ
0417B2 A4 
0417B3 17 
0417B4 04 
0417B5 C8      4260 RET     Z
0417B6 FD      4261 INC     IY
0417B7 23 
0417B8 18      4262 JR      SPAN
0417B9 F7 
               4263 ;
               4264 ; This snippet is used to check whether an expression is followed by an '=' symbol
               4265 ;
0417BA CD      4266 EQUALS:			CALL    NXT			; Skip whitespace
0417BB 70 
0417BC 0A 
0417BD 04 
0417BE FD      4267 INC     IY			; Skip past the character in question
0417BF 23 
0417C0 FE      4268 CP      '='			; Is it '='
0417C1 3D 
0417C2 C8      4269 RET     Z			; Yes, so return
0417C3 3E      4270 LD      A,4			; Otherwise
0417C4 04 
0417C5 C3      4271 JP      ERROR_           	; Throw error "Mistake"
0417C6 90 
0417C7 37 
0417C8 04 
               4272 ;
0417C9 FE      4273 FORMAT:			CP      TAB
0417CA 8A 
0417CB 28      4274 JR      Z,DOTAB
0417CC 0D 
0417CD FE      4275 CP      SPC
0417CE 89 
0417CF 28      4276 JR      Z,DOSPC
0417D0 40 
0417D1 FE      4277 CP      '''
0417D2 27 
0417D3 C0      4278 RET     NZ
0417D4 CD      4279 CALL    CRLF
0417D5 77 
0417D6 39 
0417D7 04 
0417D8 AF      4280 XOR     A
0417D9 C9      4281 RET
               4282 ;
0417DA C5      4283 DOTAB:			PUSH    BC
0417DB CD      4284 CALL    EXPRI
0417DC 0A 
0417DD 03 
0417DE 04 
0417DF D9      4285 EXX
0417E0 C1      4286 POP     BC
0417E1 FD      4287 LD      A,(IY)
0417E2 7E 
0417E3 00 
0417E4 FE      4288 CP      ','
0417E5 2C 
0417E6 28      4289 JR      Z,DOTAB1
0417E7 14 
0417E8 CD      4290 CALL    BRAKET
0417E9 2F 
0417EA 0A 
0417EB 04 
0417EC 7D      4291 LD      A,L
0417ED 21      4292 TABIT:			LD      HL,COUNT
0417EE 3D 
0417EF 4D 
0417F0 04 
0417F1 BE      4293 CP      (HL)
0417F2 C8      4294 RET     Z
0417F3 F5      4295 PUSH    AF
0417F4 DC      4296 CALL    C,CRLF
0417F5 77 
0417F6 39 
0417F7 04 
0417F8 F1      4297 POP     AF
0417F9 96      4298 SUB     (HL)
0417FA 18      4299 JR      FILL
0417FB 1D 
0417FC FD      4300 DOTAB1:			INC     IY
0417FD 23 
0417FE C5      4301 PUSH    BC
0417FF E5      4302 PUSH    HL
041800 CD      4303 CALL    EXPRI
041801 0A 
041802 03 
041803 04 
041804 D9      4304 EXX
041805 D1      4305 POP     DE
041806 C1      4306 POP     BC
041807 CD      4307 CALL    BRAKET
041808 2F 
041809 0A 
04180A 04 
04180B CD      4308 CALL    PUTCSR
04180C F1 
04180D 3E 
04180E 04 
04180F AF      4309 XOR     A
041810 C9      4310 RET
               4311 ;
041811 C5      4312 DOSPC:			PUSH    BC
041812 CD      4313 CALL    ITEMI
041813 25 
041814 03 
041815 04 
041816 D9      4314 EXX
041817 7D      4315 LD      A,L
041818 C1      4316 POP     BC
041819 B7      4317 FILL:			OR      A
04181A C8      4318 RET     Z
04181B C5      4319 PUSH    BC
04181C 47      4320 LD      B,A
04181D 3E      4321 FILL1:			LD      A,' '
04181E 20 
04181F CD      4322 CALL    OUTCHR
041820 7F 
041821 39 
041822 04 
041823 10      4323 DJNZ    FILL1
041824 F8 
041825 C1      4324 POP     BC
041826 AF      4325 XOR     A
041827 C9      4326 RET
               4327 ;
041828 21      4328 PTEXT:			LD      HL,ACCS
041829 00 
04182A 4A 
04182B 04 
04182C 1C      4329 INC     E
04182D 1D      4330 PTEXT1:			DEC     E
04182E C8      4331 RET     Z
04182F 7E      4332 LD      A,(HL)
041830 23      4333 INC     HL
041831 CD      4334 CALL    OUTCHR
041832 7F 
041833 39 
041834 04 
041835 18      4335 JR      PTEXT1
041836 F6 
               4336 ;
041837 F5      4337 FETCHS:			PUSH    AF
041838 C5      4338 PUSH    BC
041839 E5      4339 PUSH    HL
04183A FD      4340 EX      (SP),IY
04183B E3 
04183C CD      4341 CALL    XTRACT
04183D 57 
04183E 18 
04183F 04 
041840 CD      4342 CALL    NXT
041841 70 
041842 0A 
041843 04 
041844 FD      4343 EX      (SP),IY
041845 E3 
041846 E1      4344 POP     HL
041847 C1      4345 POP     BC
041848 F1      4346 POP     AF
041849 C9      4347 RET
               4348 ;
04184A 11      4349 LINES:			LD      DE,ACCS
04184B 00 
04184C 4A 
04184D 04 
04184E 7E      4350 LINE1S:			LD      A,(HL)
04184F 12      4351 LD      (DE),A
041850 FE      4352 CP      CR
041851 0D 
041852 C8      4353 RET     Z
041853 23      4354 INC     HL
041854 1C      4355 INC     E
041855 18      4356 JR      LINE1S
041856 F7 
               4357 ;
041857 CD      4358 XTRACT:			CALL    NXT
041858 70 
041859 0A 
04185A 04 
04185B FE      4359 CP      '"'
04185C 22 
04185D FD      4360 INC     IY
04185E 23 
04185F CA      4361 JP      Z,CONS
041860 67 
041861 04 
041862 04 
041863 FD      4362 DEC     IY
041864 2B 
041865 11      4363 LD      DE,ACCS
041866 00 
041867 4A 
041868 04 
041869 FD      4364 XTRAC1:			LD      A,(IY)
04186A 7E 
04186B 00 
04186C 12      4365 LD      (DE),A
04186D FE      4366 CP      ','
04186E 2C 
04186F C8      4367 RET     Z
041870 FE      4368 CP      CR
041871 0D 
041872 C8      4369 RET     Z
041873 FD      4370 INC     IY
041874 23 
041875 1C      4371 INC     E
041876 18      4372 JR      XTRAC1
041877 F1 
               4373 
               4374 ; Search for a token at the start of a program line
               4375 ; - HL: Pointer to the start of a tokenised line in the program area
               4376 ; Returns:
               4377 ; - HL: Pointer to the
               4378 ; -  F: Carry set if not found
               4379 ; Corrupts:
               4380 ; - BC
               4381 ;
041878 01      4382 SEARCH_EX:			LD      BC,0			; Clear BC
041879 00 
04187A 00 
04187B 00 
               4383 ;
04187C 4E      4384 SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
04187D 0C      4385 INC     C			; Check for 0, i.e. end of program marker
04187E 0D      4386 DEC     C
04187F 28      4387 JR      Z,SRCH2_EX         	; Not found the token, so end
041880 0B 
041881 23      4388 INC     HL			; Skip the line length and line number
041882 23      4389 INC     HL
041883 23      4390 INC     HL
041884 BE      4391 CP      (HL)			; Compare with the token
041885 C8      4392 RET     Z			; Found it, so return with carry not set
041886 0D      4393 DEC     C			; Skip to the next line
041887 0D      4394 DEC     C
041888 0D      4395 DEC     C
041889 09      4396 ADD     HL,BC
04188A 18      4397 JR      SRCH1_EX			; Rinse, lather and repeat
04188B F0 
               4398 ;
04188C 2B      4399 SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
04188D 37      4400 SCF				; And set the carry flag
04188E C9      4401 RET
               4402 
               4403 ; Multiply by 4 or 5
               4404 ; This function is used to allocate space for dimensioned variables
               4405 ; This is a 24-bit operation
               4406 ; - DE: Number to multiple
               4407 ; -  A: 04h (Integer) - takes up 4 bytes
               4408 ;       05h (Float)   - takes up 5 bytes
               4409 ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
               4410 ; Returns:
               4411 ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
               4412 ; -  F: Carry if overflow
               4413 ; Corrupts:
               4414 ; - HL
04188F FE      4415 X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041890 04 
               4416 ; LD	HL,DE
041891 D5      4417 push de
041892 E1      4418 pop hl
041893 29      4419 ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
041894 D8      4420 RET     C			; Exit if overflow
041895 29      4421 ADD     HL,HL			; Multiply by 2 again
041896 D8      4422 RET     C			; Exit if overflow
041897 EB      4423 EX      DE,HL			; DE: Product
041898 C8      4424 RET     Z			; Exit if A = 4
041899 19      4425 ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
04189A EB      4426 EX      DE,HL			; DE: Product
04189B C9      4427 RET
               4428 
               4429 ; 16-bit unsigned multiply
               4430 ; - HL: Operand 1
               4431 ; - BC: Operand 2
               4432 ; Returns:
               4433 ; - HL: Result
               4434 ; -  F: C if overflow
               4435 ;
04189C C5      4436 MUL16:			PUSH	BC
04189D 51      4437 LD	D, C			; Set up the registers for the multiplies
04189E 5D      4438 LD	E, L
04189F 69      4439 LD	L, C
0418A0 4B      4440 LD	C, E
0418A1 ED      4441 MLT	HL			; HL = H * C (*256)
0418A2 6C 
0418A3 ED      4442 MLT	DE			; DE = L * C
0418A4 5C 
0418A5 ED      4443 MLT	BC			; BC = B * L (*256)
0418A6 4C 
0418A7 09      4444 ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418A8 C1      4445 POP	BC
0418A9 AF      4446 XOR	A
0418AA 9C      4447 SBC	H			; If H is not zero then it's an overflow
0418AB D8      4448 RET	C
0418AC 65      4449 LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418AD 6F      4450 LD	L, A
0418AE 19      4451 ADD	HL, DE
0418AF C9      4452 RET
               4453 ;
0418B0 CD      4454 CHANEL:			CALL    NXT			; Skip whitespace
0418B1 70 
0418B2 0A 
0418B3 04 
0418B4 FE      4455 CP      '#'			; Check for the '#' symbol
0418B5 23 
0418B6 3E      4456 LD      A,45
0418B7 2D 
0418B8 C2      4457 JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418B9 90 
0418BA 37 
0418BB 04 
0418BC FD      4458 CHNL:			INC     IY             		; Bump past the '#'
0418BD 23 
0418BE CD      4459 CALL    ITEMI			; Get the channel number
0418BF 25 
0418C0 03 
0418C1 04 
0418C2 D9      4460 EXX
0418C3 EB      4461 EX      DE,HL			; DE: The channel number
0418C4 C9      4462 RET
               4463 
               4464 ; ASSEMBLER -------------------------------------------------------------------
               4465 
               4466 ; Language independant control section:
               4467 ;  Outputs: A=delimiter, carry set if syntax error.
               4468 ;
0418C5 CD      4469 ASSEM:			CALL    SKIP
0418C6 E5 
0418C7 1D 
0418C8 04 
0418C9 FD      4470 INC     IY
0418CA 23 
0418CB FE      4471 CP      ':'
0418CC 3A 
0418CD 28      4472 JR      Z,ASSEM
0418CE F6 
0418CF FE      4473 CP      ']'
0418D0 5D 
0418D1 C8      4474 RET     Z
0418D2 FE      4475 CP      CR
0418D3 0D 
0418D4 C8      4476 RET     Z
0418D5 FD      4477 DEC     IY
0418D6 2B 
0418D7 DD      4478 LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
0418D8 2A 
0418D9 40 
0418DA 30 
0418DA 11   
0418DC 21      4479 LD      HL,LISTON
0418DD 40 
0418DE 4D 
0418DF 04 
0418E0 CB      4480 BIT     6,(HL)
0418E1 76 
0418E2 28      4481 JR      Z,ASSEM0
0418E3 05 
0418E4 DD      4482 LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
0418E5 2A 
0418E6 3C 
0418E7 30 
0418E7 11   
0418E9 DD      4483 ASSEM0:			PUSH    IX
0418EA E5 
0418EB FD      4484 PUSH    IY
0418EC E5 
0418ED CD      4485 CALL    ASMB
0418EE 9D 
0418EF 19 
0418F0 04 
0418F1 C1      4486 POP     BC
0418F2 D1      4487 POP     DE
0418F3 D8      4488 RET     C
0418F4 CD      4489 CALL    SKIP
0418F5 E5 
0418F6 1D 
0418F7 04 
0418F8 37      4490 SCF
0418F9 C0      4491 RET     NZ
0418FA FD      4492 DEC     IY
0418FB 2B 
0418FC FD      4493 ASSEM3:			INC     IY
0418FD 23 
0418FE FD      4494 LD      A,(IY)
0418FF 7E 
041900 00 
041901 CD      4495 CALL    TERM0
041902 AB 
041903 17 
041904 04 
041905 20      4496 JR      NZ,ASSEM3
041906 F5 
041907 3A      4497 LD      A,(LISTON)
041908 40 
041909 4D 
04190A 04 
04190B DD      4498 PUSH    IX
04190C E5 
04190D E1      4499 POP     HL
04190E B7      4500 OR      A
04190F ED      4501 SBC     HL,DE
041910 52 
041911 EB      4502 EX      DE,HL           	; DE: Number of bytes
041912 E5      4503 PUSH    HL
041913 2A      4504 LD      HL,(PC)
041914 40 
041915 30 
041916 11 
041917 E5      4505 PUSH    HL
041918 19      4506 ADD     HL,DE
041919 22      4507 LD      (PC),HL         	; Update PC
04191A 40 
04191B 30 
04191C 11 
04191D CB      4508 BIT     6,A
04191E 77 
04191F 28      4509 JR      Z,ASSEM5
041920 09 
041921 2A      4510 LD      HL,(OC)
041922 3C 
041923 30 
041924 11 
041925 19      4511 ADD     HL,DE
041926 22      4512 LD      (OC),HL         	; Update OC
041927 3C 
041928 30 
041929 11 
04192A E1      4513 ASSEM5:			POP     HL              	; Old PC
04192B DD      4514 POP     IX              	; Code here
04192C E1 
04192D CB      4515 BIT     4,A
04192E 67 
04192F 28      4516 JR      Z,ASSEM
041930 94 
041931 22      4517 LD	(R0),HL			; Store HL in R0 so we can access the MSB
041932 4A 
041933 4D 
041934 04 
041935 3A      4518 LD	A,(R0+2)		; Print out the address
041936 4C 
041937 4D 
041938 04 
041939 CD      4519 CALL	HEX_EX
04193A 87 
04193B 19 
04193C 04 
04193D 7C      4520 LD      A,H
04193E CD      4521 CALL    HEX_EX
04193F 87 
041940 19 
041941 04 
041942 7D      4522 LD      A,L
041943 CD      4523 CALL    HEXSP
041944 7F 
041945 19 
041946 04 
041947 AF      4524 XOR     A
041948 BB      4525 CP      E
041949 28      4526 JR      Z,ASSEM2
04194A 18 
               4527 ;
04194B 3A      4528 ASSEM1:			LD      A,(COUNT)
04194C 3D 
04194D 4D 
04194E 04 
04194F FE      4529 CP      20
041950 14 
041951 3E      4530 LD      A,7
041952 07 
041953 D4      4531 CALL    NC,TABIT        	; Next line
041954 ED 
041955 17 
041956 04 
041957 DD      4532 LD      A,(IX)
041958 7E 
041959 00 
04195A CD      4533 CALL    HEXSP
04195B 7F 
04195C 19 
04195D 04 
04195E DD      4534 INC     IX
04195F 23 
041960 1D      4535 DEC     E
041961 20      4536 JR      NZ,ASSEM1
041962 E8 
               4537 ;
041963 3E      4538 ASSEM2:			LD      A,22			; Tab to the disassembly field
041964 16 
041965 CD      4539 CALL    TABIT
041966 ED 
041967 17 
041968 04 
041969 FD      4540 PUSH    IY
04196A E5 
04196B E1      4541 POP     HL
04196C ED      4542 SBC     HL,BC
04196D 42 
04196E 0A      4543 ASSEM4:			LD      A,(BC)
04196F CD      4544 CALL    OUT_
041970 9C 
041971 39 
041972 04 
041973 03      4545 INC     BC
041974 2D      4546 DEC     L
041975 20      4547 JR      NZ,ASSEM4
041976 F7 
041977 CD      4548 CALL    CRLF
041978 77 
041979 39 
04197A 04 
04197B C3      4549 JP      ASSEM
04197C C5 
04197D 18 
04197E 04 
               4550 ;
04197F CD      4551 HEXSP:			CALL    HEX_EX
041980 87 
041981 19 
041982 04 
041983 3E      4552 LD      A,' '
041984 20 
041985 18      4553 JR      OUTCH1
041986 12 
041987 F5      4554 HEX_EX:			PUSH    AF
041988 0F      4555 RRCA
041989 0F      4556 RRCA
04198A 0F      4557 RRCA
04198B 0F      4558 RRCA
04198C CD      4559 CALL    HEXOUT
04198D 91 
04198E 19 
04198F 04 
041990 F1      4560 POP     AF
041991 E6      4561 HEXOUT:			AND     0FH
041992 0F 
041993 C6      4562 ADD     A,90H
041994 90 
041995 27      4563 DAA
041996 CE      4564 ADC     A,40H
041997 40 
041998 27      4565 DAA
041999 C3      4566 OUTCH1:			JP      OUT_
04199A 9C 
04199B 39 
04199C 04 
               4567 
               4568 ; Processor Specific Translation Section:
               4569 ;
               4570 ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
               4571 ;                 C: Opcode beig built
               4572 ;                 D: Flags
               4573 ;			Bit 7: Set to 1 if the instruction uses long addressing
               4574 ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
               4575 ;                 E: Offset from IX or IY
               4576 ;                HL: Numeric operand value
               4577 ;                IX: Code destination pointer
               4578 ;                IY: Source text pointer
               4579 ;    Inputs: A = initial character
               4580 ;   Outputs: Carry set if syntax error.
               4581 ;
04199D FE      4582 ASMB:			CP      '.'			; Check for a dot; this indicates a label
04199E 2E 
04199F 20      4583 JR      NZ,ASMB1		; No, so just process the instruction
0419A0 1F 
0419A1 FD      4584 INC     IY			; Skip past the dot to the label name
0419A2 23 
0419A3 DD      4585 PUSH    IX			; Store the code destination pointer
0419A4 E5 
0419A5 CD      4586 CALL    VAR_			; Create a variable
0419A6 8E 
0419A7 0C 
0419A8 04 
0419A9 F5      4587 PUSH    AF
0419AA CD      4588 CALL    ZERO			; Zero it
0419AB 93 
0419AC 09 
0419AD 04 
0419AE 3A      4589 LD	A,(PC+2)
0419AF 42 
0419B0 30 
0419B1 11 
0419B2 6F      4590 LD	L,A			; The MSB of the 24-bit address
0419B3 D9      4591 EXX
0419B4 2A      4592 LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419B5 40 
0419B6 30 
0419B7 11 
0419B8 D9      4593 EXX
0419B9 F1      4594 POP     AF
0419BA CD      4595 CALL    STORE			; Store the program counter
0419BB 00 
0419BC 16 
0419BD 04 
0419BE DD      4596 POP     IX			; Restore the code destination pointer
0419BF E1 
               4597 ;
0419C0 3A      4598 ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419C1 40 
0419C2 4D 
0419C3 04 
0419C4 E6      4599 AND	80H
0419C5 80 
0419C6 57      4600 LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419C7 CD      4601 CALL    SKIP			; Skip any whitespace
0419C8 E5 
0419C9 1D 
0419CA 04 
0419CB C8      4602 RET     Z			; And return if there is nothing further to process
0419CC FE      4603 CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419CD D6 
0419CE 0E      4604 LD      C,0C4H			;  A: The base operand
0419CF C4 
0419D0 FD      4605 INC     IY			; Skip past the token
0419D1 23 
0419D2 CA      4606 JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419D3 1A 
0419D4 1B 
0419D5 04 
0419D6 FD      4607 DEC     IY			; Skip back, as we're not doing the above at this point
0419D7 2B 
0419D8 21      4608 LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419D9 FC 
0419DA 1D 
0419DB 04 
0419DC CD      4609 CALL    FIND			; Find the opcode
0419DD 94 
0419DE 1D 
0419DF 04 
0419E0 D8      4610 RET     C			; If not found, then return; carry indicates an error condition
0419E1 48      4611 LD      C,B     		;  C: A copy of the opcode
               4612 ;
               4613 ; GROUP 0: Trivial cases requiring no computation
               4614 ; GROUP 1: As Group 0, but with "ED" prefix
               4615 ;
0419E2 D6      4616 SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419E3 44 
0419E4 30      4617 JR      NC,GROUP02		; If not in that range, then check GROUP2
0419E5 08 
0419E6 FE      4618 CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419E7 CB 
0419E8 D4      4619 CALL    NC,ED			; Needs to be prefixed with ED
0419E9 ED 
0419EA 1C 
0419EB 04 
0419EC 18      4620 JR      BYTE0			; Then write the opcode byte
0419ED 76 
               4621 ;
               4622 ; GROUP 2: BIT, RES, SET
               4623 ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
               4624 ;
0419EE D6      4625 GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419EF 0A 
0419F0 30      4626 JR      NC,GROUP04		; If not in that range, then check GROUP4
0419F1 12 
0419F2 FE      4627 CP      3-10			;
0419F3 F9 
0419F4 DC      4628 CALL    C,BIT_
0419F5 82 
0419F6 1D 
0419F7 04 
0419F8 D8      4629 RET     C
0419F9 CD      4630 CALL    REGLO
0419FA 53 
0419FB 1D 
0419FC 04 
0419FD D8      4631 RET     C
0419FE CD      4632 CALL    CB
0419FF F1 
041A00 1C 
041A01 04 
041A02 18      4633 JR      BYTE0
041A03 60 
               4634 ;
               4635 ; GROUP 4 - PUSH, POP, EX (SP)
               4636 ;
041A04 D6      4637 GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A05 03 
041A06 30      4638 JR      NC,GROUP05		; If not in that range, then check GROUP5
041A07 07 
041A08 CD      4639 GROUP04_1:		CALL    PAIR_EX
041A09 75 
041A0A 1D 
041A0B 04 
041A0C D8      4640 RET     C
041A0D 18      4641 JR      BYTE0
041A0E 55 
               4642 ;
               4643 ; GROUP 5 - SUB, AND, XOR, OR, CP
               4644 ; GROUP 6 - ADD, ADC, SBC
               4645 ;
041A0F D6      4646 GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A10 0A 
041A11 30      4647 JR      NC,GROUP07
041A12 39 
041A13 FE      4648 CP      5-8
041A14 FD 
041A15 06      4649 LD      B,7
041A16 07 
041A17 D4      4650 CALL    NC,OPND			; Get the first operand
041A18 01 
041A19 1D 
041A1A 04 
041A1B 78      4651 LD      A,B
041A1C FE      4652 CP      7			; Is the operand 'A'?
041A1D 07 
041A1E 20      4653 JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A1F 15 
               4654 ;
041A20 CD      4655 GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A21 53 
041A22 1D 
041A23 04 
041A24 79      4656 LD      A,C
041A25 30      4657 JR      NC,BIND1		; If it is a register, then write that out
041A26 2E 
041A27 EE      4658 XOR     46H			; Handle ADD A,n
041A28 46 
041A29 CD      4659 CALL    BIND
041A2A F3 
041A2B 1C 
041A2C 04 
041A2D CD      4660 DB_:			CALL    NUMBER
041A2E 33 
041A2F 1D 
041A30 04 
041A31 C3      4661 JP      VAL8
041A32 EC 
041A33 1A 
041A34 04 
               4662 ;
041A35 E6      4663 GROUP05_HL:		AND     3FH
041A36 3F 
041A37 FE      4664 CP      12
041A38 0C 
041A39 37      4665 SCF
041A3A C0      4666 RET     NZ
041A3B 79      4667 LD      A,C
041A3C FE      4668 CP      80H
041A3D 80 
041A3E 0E      4669 LD      C,9
041A3F 09 
041A40 28      4670 JR      Z,GROUP04_1
041A41 C6 
041A42 EE      4671 XOR     1CH
041A43 1C 
041A44 0F      4672 RRCA
041A45 4F      4673 LD      C,A
041A46 CD      4674 CALL    ED
041A47 ED 
041A48 1C 
041A49 04 
041A4A 18      4675 JR      GROUP04_1
041A4B BC 
               4676 ;
               4677 ; GROUP 7 - INC, DEC
               4678 ;
041A4C D6      4679 GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A4D 02 
041A4E 30      4680 JR      NC,GROUP08
041A4F 19 
041A50 CD      4681 CALL    REGHI
041A51 5A 
041A52 1D 
041A53 04 
041A54 79      4682 LD      A,C
041A55 D2      4683 BIND1:			JP      NC,BIND
041A56 F3 
041A57 1C 
041A58 04 
041A59 EE      4684 XOR     64H
041A5A 64 
041A5B 07      4685 RLCA
041A5C 07      4686 RLCA
041A5D 07      4687 RLCA
041A5E 4F      4688 LD      C,A
041A5F CD      4689 CALL    PAIR1_EX
041A60 7A 
041A61 1D 
041A62 04 
041A63 D8      4690 RET     C
041A64 79      4691 BYTE0:			LD      A,C
041A65 C3      4692 JP      BYTE_
041A66 22 
041A67 1D 
041A68 04 
               4693 ;
               4694 ; Group 8: IN0, OUT0
               4695 ;
041A69 D6      4696 GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A6A 02 
041A6B 30      4697 JR	NC,GROUP09
041A6C 2C 
041A6D FE      4698 CP	1-2
041A6E FF 
041A6F CC      4699 CALL    Z,NUMBER		; Fetch number first if OUT
041A70 33 
041A71 1D 
041A72 04 
041A73 08      4700 EX      AF,AF'			; Save flags
041A74 CD      4701 CALL    REG			; Get the register value regardless
041A75 47 
041A76 1D 
041A77 04 
041A78 D8      4702 RET     C			; Return if not a register
041A79 08      4703 EX      AF,AF'			; Restore the flags
041A7A DC      4704 CALL    C,NUMBER		; Fetch number last if IN
041A7B 33 
041A7C 1D 
041A7D 04 
041A7E 78      4705 LD	A,B			; Get the register number
041A7F FE      4706 CP	6			; Fail on (HL)
041A80 06 
041A81 37      4707 SCF
041A82 C8      4708 RET	Z
041A83 FE      4709 CP	8			; Check it is just single pairs only
041A84 08 
041A85 3F      4710 CCF
041A86 D8      4711 RET	C			; And return if it is an invalid register
041A87 07      4712 RLCA				; Bind with the operand
041A88 07      4713 RLCA
041A89 07      4714 RLCA
041A8A 81      4715 ADD	A,C
041A8B 4F      4716 LD	C,A
041A8C CD      4717 CALL	ED			; Prefix with ED
041A8D ED 
041A8E 1C 
041A8F 04 
041A90 79      4718 LD	A,C
041A91 CD      4719 CALL	BYTE_			; Write out the operand
041A92 22 
041A93 1D 
041A94 04 
041A95 C3      4720 JP	VAL8			; Write out the value
041A96 EC 
041A97 1A 
041A98 04 
               4721 ;
               4722 ; GROUP 9 - IN
               4723 ; GROUP 10 - OUT
               4724 ;
041A99 D6      4725 GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041A9A 02 
041A9B 30      4726 JR      NC,GROUP11
041A9C 25 
041A9D FE      4727 CP      1-2			; Check if Group 9 or Group 1
041A9E FF 
041A9F CC      4728 CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AA0 E1 
041AA1 1C 
041AA2 04 
041AA3 08      4729 EX      AF,AF'			; Save flags
041AA4 CD      4730 CALL    REGHI			; Get the register value regardless
041AA5 5A 
041AA6 1D 
041AA7 04 
041AA8 D8      4731 RET     C			; Return if not a register
041AA9 08      4732 EX      AF,AF'			; Restore the flags
041AAA DC      4733 CALL    C,CORN			; Call CORN if Group 9 (IN)
041AAB E1 
041AAC 1C 
041AAD 04 
041AAE 24      4734 INC     H			; If it is IN r,(C) or OUT (C),r then
041AAF 28      4735 JR      Z,BYTE0			; Just write the operand out
041AB0 B3 
               4736 ;
041AB1 78      4737 LD      A,B			; Check the register
041AB2 FE      4738 CP      7
041AB3 07 
041AB4 37      4739 SCF
041AB5 C0      4740 RET     NZ			; If it is not A, then return
               4741 ;
041AB6 79      4742 LD      A,C			; Bind the register with the operand
041AB7 EE      4743 XOR     3
041AB8 03 
041AB9 07      4744 RLCA
041ABA 07      4745 RLCA
041ABB 07      4746 RLCA
041ABC CD      4747 CALL    BYTE_			; Write out the operand
041ABD 22 
041ABE 1D 
041ABF 04 
041AC0 18      4748 JR      VAL8			; And the value
041AC1 2A 
               4749 ;
               4750 ; GROUP 11 - JR, DJNZ
               4751 ;
041AC2 D6      4752 GROUP11:		SUB     2			; The number of opcodes in GROUP11
041AC3 02 
041AC4 30      4753 JR      NC,GROUP12
041AC5 2B 
041AC6 FE      4754 CP      1-2
041AC7 FF 
041AC8 C4      4755 CALL    NZ,COND_
041AC9 61 
041ACA 1D 
041ACB 04 
041ACC 79      4756 LD      A,C
041ACD 30      4757 JR      NC,@F
041ACE 02 
041ACF 3E      4758 LD      A,18H
041AD0 18 
041AD1 CD      4759 @@:			CALL    BYTE_
041AD2 22 
041AD3 1D 
041AD4 04 
041AD5 CD      4760 CALL    NUMBER
041AD6 33 
041AD7 1D 
041AD8 04 
041AD9 ED      4761 LD      DE,(PC)
041ADA 5B 
041ADB 40 
041ADC 30 
041ADC 11   
041ADE 13      4762 INC     DE
041ADF 37      4763 SCF
041AE0 ED      4764 SBC     HL,DE
041AE1 52 
041AE2 7D      4765 LD      A,L
041AE3 17      4766 RLA
041AE4 9F      4767 SBC     A,A
041AE5 BC      4768 CP      H
041AE6 3E      4769 TOOFAR:			LD      A,1
041AE7 01 
041AE8 C2      4770 JP      NZ,ERROR_		; Throw an "Out of range" error
041AE9 90 
041AEA 37 
041AEB 04 
041AEC 7D      4771 VAL8:			LD      A,L
041AED C3      4772 JP      BYTE_
041AEE 22 
041AEF 1D 
041AF0 04 
               4773 ;
               4774 ; GROUP 12 - JP
               4775 ;
041AF1 D6      4776 GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AF2 01 
041AF3 30      4777 JR	NC,GROUP13
041AF4 21 
041AF5 CD      4778 CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AF6 47 
041AF7 1C 
041AF8 04 
041AF9 D8      4779 RET	C			; Exit if an invalid suffix is provided
041AFA CD      4780 CALL    COND_			; Evaluate the conditions
041AFB 61 
041AFC 1D 
041AFD 04 
041AFE 79      4781 LD      A,C
041AFF 30      4782 JR      NC,GROUP12_1
041B00 0D 
041B01 78      4783 LD      A,B
041B02 E6      4784 AND     3FH
041B03 3F 
041B04 FE      4785 CP      6
041B05 06 
041B06 3E      4786 LD      A,0E9H
041B07 E9 
041B08 CA      4787 JP      Z,BYTE_
041B09 22 
041B0A 1D 
041B0B 04 
041B0C 3E      4788 LD      A,0C3H
041B0D C3 
041B0E CD      4789 GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B0F 22 
041B10 1D 
041B11 04 
041B12 C3      4790 JP	ADDR_			; Output the address
041B13 9C 
041B14 1C 
041B15 04 
               4791 ;
               4792 ; GROUP 13 - CALL
               4793 ;
041B16 D6      4794 GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B17 01 
041B18 30      4795 JR	NC,GROUP14
041B19 0C 
041B1A CD      4796 GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B1B 5F 
041B1C 1C 
041B1D 04 
041B1E CD      4797 CALL    GROUP15_1		; Output the opcode (with conditions)
041B1F 41 
041B20 1B 
041B21 04 
041B22 C3      4798 JP	ADDR_			; Output the address
041B23 9C 
041B24 1C 
041B25 04 
               4799 ;
               4800 ; GROUP 14 - RST
               4801 ;
041B26 D6      4802 GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B27 01 
041B28 30      4803 JR	NC,GROUP15
041B29 13 
041B2A CD      4804 CALL	EZ80SF_FULL		; Evaluate the suffix
041B2B 5F 
041B2C 1C 
041B2D 04 
041B2E D8      4805 RET	C			; Exit if an invalid suffix provided
041B2F CD      4806 CALL    NUMBER
041B30 33 
041B31 1D 
041B32 04 
041B33 A1      4807 AND     C
041B34 B4      4808 OR      H
041B35 20      4809 JR      NZ,TOOFAR
041B36 AF 
041B37 7D      4810 LD      A,L
041B38 B1      4811 OR      C
041B39 C3      4812 JP      BYTE_
041B3A 22 
041B3B 1D 
041B3C 04 
               4813 ;
               4814 ; GROUP 15 - RET
               4815 ;
041B3D D6      4816 GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B3E 01 
041B3F 30      4817 JR	NC,GROUP16
041B40 0F 
041B41 CD      4818 GROUP15_1:		CALL    COND_
041B42 61 
041B43 1D 
041B44 04 
041B45 79      4819 LD      A,C
041B46 D2      4820 JP      NC,BYTE_
041B47 22 
041B48 1D 
041B49 04 
041B4A F6      4821 OR      9
041B4B 09 
041B4C C3      4822 JP      BYTE_
041B4D 22 
041B4E 1D 
041B4F 04 
               4823 ;
               4824 ; GROUP 16 - LD
               4825 ;
041B50 D6      4826 GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B51 01 
041B52 30      4827 JR	NC,GROUP17
041B53 74 
041B54 CD      4828 CALL	EZ80SF_FULL		; Evaluate the suffix
041B55 5F 
041B56 1C 
041B57 04 
041B58 CD      4829 CALL    LDOP			; Check for accumulator loads
041B59 90 
041B5A 1D 
041B5B 04 
041B5C D2      4830 JP      NC,LDA			; Yes, so jump here
041B5D BC 
041B5E 1C 
041B5F 04 
041B60 CD      4831 CALL    REGHI
041B61 5A 
041B62 1D 
041B63 04 
041B64 08      4832 EX      AF,AF'
041B65 CD      4833 CALL    SKIP
041B66 E5 
041B67 1D 
041B68 04 
041B69 FE      4834 CP      '('			; Check for bracket
041B6A 28 
041B6B 28      4835 JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B6C 24 
041B6D 08      4836 EX      AF,AF'
041B6E D2      4837 JP      NC,GROUP05_1		; Load single register direct; go here
041B6F 20 
041B70 1A 
041B71 04 
041B72 0E      4838 LD      C,1
041B73 01 
041B74 CD      4839 CALL    PAIR1_EX
041B75 7A 
041B76 1D 
041B77 04 
041B78 D8      4840 RET     C
041B79 3E      4841 LD      A,14
041B7A 0E 
041B7B B8      4842 CP      B
041B7C 47      4843 LD      B,A
041B7D CC      4844 CALL    Z,PAIR_EX
041B7E 75 
041B7F 1D 
041B80 04 
041B81 78      4845 LD      A,B
041B82 E6      4846 AND     3FH
041B83 3F 
041B84 FE      4847 CP      12
041B85 0C 
041B86 79      4848 LD      A,C
041B87 C2      4849 JP      NZ,GROUP12_1		; Load register pair direct; go here
041B88 0E 
041B89 1B 
041B8A 04 
041B8B 3E      4850 LD      A,0F9H
041B8C F9 
041B8D C3      4851 JP      BYTE_
041B8E 22 
041B8F 1D 
041B90 04 
               4852 ;
041B91 08      4853 LDIN:			EX      AF,AF'
041B92 C5      4854 PUSH    BC
041B93 D4      4855 CALL    NC,REGLO
041B94 53 
041B95 1D 
041B96 04 
041B97 79      4856 LD      A,C
041B98 C1      4857 POP     BC
041B99 D2      4858 JP      NC,BIND
041B9A F3 
041B9B 1C 
041B9C 04 
041B9D 0E      4859 LD      C,0AH
041B9E 0A 
041B9F CD      4860 CALL    PAIR1_EX
041BA0 7A 
041BA1 1D 
041BA2 04 
041BA3 CD      4861 CALL    LD16
041BA4 C7 
041BA5 1C 
041BA6 04 
041BA7 D2      4862 JP      NC,GROUP12_1
041BA8 0E 
041BA9 1B 
041BAA 04 
041BAB CD      4863 CALL    NUMBER
041BAC 33 
041BAD 1D 
041BAE 04 
041BAF 0E      4864 LD      C,2
041BB0 02 
041BB1 CD      4865 CALL    PAIR_EX
041BB2 75 
041BB3 1D 
041BB4 04 
041BB5 CD      4866 CALL    LD16
041BB6 C7 
041BB7 1C 
041BB8 04 
041BB9 D8      4867 RET     C
041BBA CD      4868 CALL    BYTE_
041BBB 22 
041BBC 1D 
041BBD 04 
041BBE CB      4869 BIT	7,D			; Check the ADL flag
041BBF 7A 
041BC0 C2      4870 JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BC1 B1 
041BC2 1C 
041BC3 04 
041BC4 C3      4871 JP      VAL16			; Otherwise use 16-bit addresses
041BC5 A4 
041BC6 1C 
041BC7 04 
               4872 ;
               4873 ; Group 17 - TST
               4874 ;
041BC8 D6      4875 GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BC9 01 
041BCA 30      4876 JR	NC,OPTS
041BCB 25 
041BCC CD      4877 CALL	ED			; Needs to be prefixed with ED
041BCD ED 
041BCE 1C 
041BCF 04 
041BD0 CD      4878 CALL	REG			; Fetch the register
041BD1 47 
041BD2 1D 
041BD3 04 
041BD4 30      4879 JR	NC,GROUP17_1		; It's just a register
041BD5 0E 
               4880 ;
041BD6 3E      4881 LD	A,64H			; Opcode for TST n
041BD7 64 
041BD8 CD      4882 CALL	BYTE_			; Write out the opcode
041BD9 22 
041BDA 1D 
041BDB 04 
041BDC CD      4883 CALL	NUMBER			; Get the number
041BDD 33 
041BDE 1D 
041BDF 04 
041BE0 C3      4884 JP	VAL8			; And write that out
041BE1 EC 
041BE2 1A 
041BE3 04 
               4885 ;
041BE4 78      4886 GROUP17_1:		LD	A,B			; Check the register rangs
041BE5 FE      4887 CP	8
041BE6 08 
041BE7 3F      4888 CCF
041BE8 D8      4889 RET	C			; Ret with carry flag set for error if out of range
041BE9 07      4890 RLCA				; Get the opcode value
041BEA 07      4891 RLCA
041BEB 07      4892 RLCA
041BEC 81      4893 ADD	A,C			; Add the opcode base in
041BED C3      4894 JP	BYTE_
041BEE 22 
041BEF 1D 
041BF0 04 
               4895 
               4896 ;
               4897 ; Assembler directives - OPT, ADL
               4898 ;
041BF1 D6      4899 OPTS:			SUB	2
041BF2 02 
041BF3 30      4900 JR	NC, DEFS
041BF4 2B 
041BF5 FE      4901 CP	1-2			; Check for ADL opcode
041BF6 FF 
041BF7 28      4902 JR	Z, ADL_
041BF8 13 
               4903 ;
041BF9 CD      4904 OPT:			CALL    NUMBER			; Fetch the OPT value
041BFA 33 
041BFB 1D 
041BFC 04 
041BFD 21      4905 LD      HL,LISTON		; Address of the LISTON/OPT flag
041BFE 40 
041BFF 4D 
041C00 04 
041C01 E6      4906 AND	7			; Only interested in the first three bits
041C02 07 
041C03 4F      4907 LD      C,A			; Store the new OPT value in C
041C04 ED      4908 RLD				; Shift the top nibble of LISTON (OPT) into A
041C05 6F 
041C06 E6      4909 AND	8			; Clear the bottom three bits, preserving the ADL bit
041C07 08 
041C08 B1      4910 OR	C			; OR in the new value
041C09 ED      4911 RRD				; And shift the nibble back in
041C0A 67 
041C0B C9      4912 RET
               4913 ;
041C0C CD      4914 ADL_:			CALL	NUMBER			; Fetch the ADL value
041C0D 33 
041C0E 1D 
041C0F 04 
041C10 E6      4915 AND	1			; Only interested if it is 0 or 1
041C11 01 
041C12 0F      4916 RRCA				; Rotate to bit 7
041C13 4F      4917 LD	C,A			; Store in C
041C14 3A      4918 LD	A,(LISTON)		; Get the LISTON system variable
041C15 40 
041C16 4D 
041C17 04 
041C18 E6      4919 AND	7Fh			; Clear bit 7
041C19 7F 
041C1A B1      4920 OR	C			; OR in the ADL value
041C1B 32      4921 LD	(LISTON),A		; Store
041C1C 40 
041C1D 4D 
041C1E 04 
041C1F C9      4922 RET
               4923 ;
               4924 ; DEFB, DEFW, DEFL, DEFM
               4925 ;
041C20 B7      4926 DEFS:			OR	A			; Handle DEFB
041C21 CA      4927 JP	Z, DB_
041C22 2D 
041C23 1A 
041C24 04 
041C25 3D      4928 DEC	A			; Handle DEFW
041C26 CA      4929 JP	Z, ADDR16
041C27 A0 
041C28 1C 
041C29 04 
041C2A 3D      4930 DEC	A			; Handle DEFL
041C2B CA      4931 JP	Z, ADDR24
041C2C AD 
041C2D 1C 
041C2E 04 
               4932 ;
041C2F DD      4933 PUSH    IX			; Handle DEFM
041C30 E5 
041C31 CD      4934 CALL    EXPRS
041C32 15 
041C33 03 
041C34 04 
041C35 DD      4935 POP     IX
041C36 E1 
041C37 21      4936 LD      HL,ACCS
041C38 00 
041C39 4A 
041C3A 04 
041C3B AF      4937 @@:			XOR     A
041C3C BB      4938 CP      E
041C3D C8      4939 RET     Z
041C3E 7E      4940 LD      A,(HL)
041C3F 23      4941 INC     HL
041C40 CD      4942 CALL    BYTE_
041C41 22 
041C42 1D 
041C43 04 
041C44 1D      4943 DEC     E
041C45 18      4944 JR      @B
041C46 F4 
               4945 
               4946 ;
               4947 ;SUBROUTINES:
               4948 ;
041C47 FD      4949 EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C48 7E 
041C49 00 
041C4A FE      4950 CP	'.'
041C4B 2E 
041C4C 28      4951 JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C4D 02 
041C4E B7      4952 OR	A			; Reset the carry flag (no error)
041C4F C9      4953 RET				; And return
041C50 FD      4954 @@:			INC	IY			; Skip the dot
041C51 23 
041C52 C5      4955 PUSH	BC			; Push the operand
041C53 21      4956 LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C54 7B 
041C55 20 
041C56 04 
041C57 CD      4957 CALL	FIND			; Look up the operand
041C58 94 
041C59 1D 
041C5A 04 
041C5B 30      4958 JR	NC,EZ80SF_OK
041C5C 24 
041C5D C1      4959 POP	BC			; Not found at this point, so will return with a C (error)
041C5E C9      4960 RET
               4961 ;
041C5F FD      4962 EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C60 7E 
041C61 00 
041C62 FE      4963 CP	'.'
041C63 2E 
041C64 28      4964 JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C65 02 
041C66 B7      4965 OR	A			; Reset the carry flag (no error)
041C67 C9      4966 RET				; And return
041C68 FD      4967 @@:			INC	IY 			; Skip the dot
041C69 23 
041C6A C5      4968 PUSH	BC			; Push the operand
041C6B 21      4969 LD	HL,EZ80SFS_1		; First check the fully qualified table
041C6C 73 
041C6D 20 
041C6E 04 
041C6F CD      4970 CALL	FIND 			; Look up the operand
041C70 94 
041C71 1D 
041C72 04 
041C73 30      4971 JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C74 0C 
041C75 CD      4972 CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C76 90 
041C77 1C 
041C78 04 
041C79 CD      4973 CALL	FIND
041C7A 94 
041C7B 1D 
041C7C 04 
041C7D 30      4974 JR	NC,EZ80SF_OK
041C7E 02 
041C7F C1      4975 POP	BC			; Not found at this point, so will return with a C (error)
041C80 C9      4976 RET
               4977 ;
041C81 78      4978 EZ80SF_OK:		LD	A,B			; The operand value
041C82 D4      4979 CALL	NC,BYTE_ 		; Write it out if found
041C83 22 
041C84 1D 
041C85 04 
041C86 CB      4980 RES	7,D			; Clear the default ADL mode from the flags
041C87 BA 
041C88 E6      4981 AND	2			; Check the second half of the suffix (.xxL)
041C89 02 
041C8A 0F      4982 RRCA				; Shift into bit 7
041C8B 0F      4983 RRCA
041C8C B2      4984 OR	D			; Or into bit 7 of D
041C8D 57      4985 LD	D,A
041C8E C1      4986 POP	BC 			; Restore the operand
041C8F C9      4987 RET
               4988 ;
041C90 21      4989 EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C91 84 
041C92 20 
041C93 04 
041C94 CB      4990 BIT 	7,D			; if bit 7 of D is 0
041C95 7A 
041C96 C8      4991 RET	Z
041C97 21      4992 LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041C98 8F 
041C99 20 
041C9A 04 
041C9B C9      4993 RET
               4994 ;
041C9C CB      4995 ADDR_:			BIT	7,D			; Check the ADL flag
041C9D 7A 
041C9E 20      4996 JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041C9F 0D 
               4997 ;
041CA0 CD      4998 ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CA1 33 
041CA2 1D 
041CA3 04 
041CA4 CD      4999 VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CA5 EC 
041CA6 1A 
041CA7 04 
041CA8 7C      5000 LD      A,H
041CA9 C3      5001 JP      BYTE_
041CAA 22 
041CAB 1D 
041CAC 04 
               5002 ;
041CAD CD      5003 ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CAE 33 
041CAF 1D 
041CB0 04 
041CB1 CD      5004 VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CB2 A4 
041CB3 1C 
041CB4 04 
041CB5 D9      5005 EXX
041CB6 7D      5006 LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CB7 D9      5007 EXX
041CB8 C3      5008 JP	BYTE_
041CB9 22 
041CBA 1D 
041CBB 04 
               5009 ;
041CBC FE      5010 LDA:			CP      4
041CBD 04 
041CBE DC      5011 CALL    C,ED
041CBF ED 
041CC0 1C 
041CC1 04 
041CC2 78      5012 LD      A,B
041CC3 C3      5013 JP      BYTE_
041CC4 22 
041CC5 1D 
041CC6 04 
               5014 ;
041CC7 78      5015 LD16:			LD      A,B
041CC8 38      5016 JR      C,LD8
041CC9 0F 
041CCA 78      5017 LD      A,B
041CCB E6      5018 AND     3FH
041CCC 3F 
041CCD FE      5019 CP      12
041CCE 0C 
041CCF 79      5020 LD      A,C
041CD0 C8      5021 RET     Z
041CD1 CD      5022 CALL    ED
041CD2 ED 
041CD3 1C 
041CD4 04 
041CD5 79      5023 LD      A,C
041CD6 F6      5024 OR      43H
041CD7 43 
041CD8 C9      5025 RET
               5026 ;
041CD9 FE      5027 LD8:			CP      7
041CDA 07 
041CDB 37      5028 SCF
041CDC C0      5029 RET     NZ
041CDD 79      5030 LD      A,C
041CDE F6      5031 OR      30H
041CDF 30 
041CE0 C9      5032 RET
               5033 ;
               5034 ; Used in IN and OUT to handle whether the operand is C or a number
               5035 ;
041CE1 C5      5036 CORN:			PUSH    BC
041CE2 CD      5037 CALL    OPND			; Get the operand
041CE3 01 
041CE4 1D 
041CE5 04 
041CE6 CB      5038 BIT     5,B
041CE7 68 
041CE8 C1      5039 POP     BC
041CE9 28      5040 JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CEA 48 
041CEB 26      5041 LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CEC FF 
               5042 ;
041CED 3E      5043 ED:			LD      A,0EDH			; Write an ED prefix out
041CEE ED 
041CEF 18      5044 JR      BYTE_
041CF0 31 
               5045 ;
041CF1 3E      5046 CB:			LD      A,0CBH
041CF2 CB 
041CF3 FE      5047 BIND:			CP      76H
041CF4 76 
041CF5 37      5048 SCF
041CF6 C8      5049 RET     Z               	; Reject LD (HL),(HL)
041CF7 CD      5050 CALL    BYTE_
041CF8 22 
041CF9 1D 
041CFA 04 
041CFB CB      5051 BIT	6,D			; Check the index bit in flags
041CFC 72 
041CFD C8      5052 RET     Z
041CFE 7B      5053 LD      A,E			; If there is an index, output the offset
041CFF 18      5054 JR      BYTE_
041D00 21 
               5055 ;
               5056 ; Search through the operand table
               5057 ; Returns:
               5058 ; - B: The operand type
               5059 ; - D: Bit 7: 0 = no prefix, 1 = prefix
               5060 ; - E: The IX/IY offset
               5061 ; - F: Carry if not found
               5062 ;
041D01 E5      5063 OPND:			PUSH    HL			; Preserve HL
041D02 21      5064 LD      HL,OPRNDS		; The operands table
041D03 05 
041D04 20 
041D05 04 
041D06 CD      5065 CALL    FIND			; Find the operand
041D07 94 
041D08 1D 
041D09 04 
041D0A E1      5066 POP     HL
041D0B D8      5067 RET     C			; Return if not found
041D0C CB      5068 BIT     7,B			; Check if it is an index register (IX, IY)
041D0D 78 
041D0E C8      5069 RET     Z			; Return if it isn't
041D0F CB      5070 SET	6,D			; Set flag to indicate we've got an index
041D10 F2 
041D11 CB      5071 BIT     3,B			; Check if an offset is required
041D12 58 
041D13 E5      5072 PUSH    HL
041D14 CC      5073 CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D15 29 
041D16 1D 
041D17 04 
041D18 5D      5074 LD      E,L			; E: The offset
041D19 E1      5075 POP     HL
041D1A 3E      5076 LD	A,DDH			; IX prefix
041D1B DD 
041D1C CB      5077 BIT     6,B			; If bit 6 is reset then
041D1D 70 
041D1E 28      5078 JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D1F 02 
041D20 3E      5079 LD	A,FDH			; IY prefix
041D21 FD 
               5080 ;
041D22 DD      5081 BYTE_:			LD      (IX),A			; Write a byte out
041D23 77 
041D24 00 
041D25 DD      5082 INC     IX
041D26 23 
041D27 B7      5083 OR      A
041D28 C9      5084 RET
               5085 ;
041D29 FD      5086 OFFSET_EX:			LD      A,(IY)
041D2A 7E 
041D2B 00 
041D2C FE      5087 CP      ')'
041D2D 29 
041D2E 21      5088 LD      HL,0
041D2F 00 
041D30 00 
041D31 00 
041D32 C8      5089 RET     Z
041D33 CD      5090 NUMBER:			CALL    SKIP
041D34 E5 
041D35 1D 
041D36 04 
041D37 C5      5091 PUSH    BC
041D38 D5      5092 PUSH    DE
041D39 DD      5093 PUSH    IX
041D3A E5 
041D3B CD      5094 CALL    EXPRI
041D3C 0A 
041D3D 03 
041D3E 04 
041D3F DD      5095 POP     IX
041D40 E1 
041D41 D9      5096 EXX
041D42 D1      5097 POP     DE
041D43 C1      5098 POP     BC
041D44 7D      5099 LD      A,L
041D45 B7      5100 OR      A
041D46 C9      5101 RET
               5102 ;
041D47 CD      5103 REG:			CALL    OPND
041D48 01 
041D49 1D 
041D4A 04 
041D4B D8      5104 RET     C
041D4C 78      5105 LD      A,B
041D4D E6      5106 AND     3FH
041D4E 3F 
041D4F FE      5107 CP      8
041D50 08 
041D51 3F      5108 CCF
041D52 C9      5109 RET
               5110 ;
041D53 CD      5111 REGLO:			CALL    REG
041D54 47 
041D55 1D 
041D56 04 
041D57 D8      5112 RET     C
041D58 18      5113 JR      ORC
041D59 33 
               5114 ;
041D5A CD      5115 REGHI:			CALL    REG
041D5B 47 
041D5C 1D 
041D5D 04 
041D5E D8      5116 RET     C
041D5F 18      5117 JR      SHL3
041D60 29 
               5118 ;
041D61 CD      5119 COND_:			CALL    OPND
041D62 01 
041D63 1D 
041D64 04 
041D65 D8      5120 RET     C
041D66 78      5121 LD      A,B
041D67 E6      5122 AND     1FH
041D68 1F 
041D69 D6      5123 SUB     16
041D6A 10 
041D6B 30      5124 JR      NC,SHL3
041D6C 1D 
041D6D FE      5125 CP      -15
041D6E F1 
041D6F 37      5126 SCF
041D70 C0      5127 RET     NZ
041D71 3E      5128 LD      A,3
041D72 03 
041D73 18      5129 JR      SHL3
041D74 15 
               5130 ;
041D75 CD      5131 PAIR_EX:			CALL    OPND
041D76 01 
041D77 1D 
041D78 04 
041D79 D8      5132 RET     C
041D7A 78      5133 PAIR1_EX:			LD      A,B
041D7B E6      5134 AND     0FH
041D7C 0F 
041D7D D6      5135 SUB     8
041D7E 08 
041D7F D8      5136 RET     C
041D80 18      5137 JR      SHL3
041D81 08 
               5138 ;
041D82 CD      5139 BIT_:			CALL    NUMBER
041D83 33 
041D84 1D 
041D85 04 
041D86 FE      5140 CP      8
041D87 08 
041D88 3F      5141 CCF
041D89 D8      5142 RET     C
041D8A 07      5143 SHL3:			RLCA
041D8B 07      5144 RLCA
041D8C 07      5145 RLCA
041D8D B1      5146 ORC:			OR      C
041D8E 4F      5147 LD      C,A
041D8F C9      5148 RET
               5149 ;
041D90 21      5150 LDOP:			LD      HL,LDOPS
041D91 4A 
041D92 20 
041D93 04 
               5151 
               5152 ;
               5153 ; Look up a value in a table
               5154 ; Parameters:
               5155 ; - IY: Address of the assembly language line in the BASIC program area
               5156 ; - HL: Address of the table
               5157 ; Returns:
               5158 ; - B: The operand code
               5159 ; - F: Carry set if not found
               5160 ;
041D94 CD      5161 FIND:			CALL    SKIP			; Skip delimiters
041D95 E5 
041D96 1D 
041D97 04 
               5162 ;
041D98 06      5163 EXIT_:			LD      B,0			; Set B to 0
041D99 00 
041D9A 37      5164 SCF				; Set the carry flag
041D9B C8      5165 RET     Z			; Returns if Z
               5166 ;
041D9C FE      5167 CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041D9D DD 
041D9E 28      5168 JR      Z,FIND0
041D9F 04 
041DA0 FE      5169 CP      TOR+1			; Special case for tokens AND and OR
041DA1 85 
041DA2 3F      5170 CCF
041DA3 D8      5171 RET     C
041DA4 7E      5172 FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DA5 B7      5173 OR      A
041DA6 28      5174 JR      Z,EXIT_			; Exit
041DA7 F0 
041DA8 FD      5175 XOR     (IY)
041DA9 AE 
041DAA 00 
041DAB E6      5176 AND     01011111B
041DAC 5F 
041DAD 28      5177 JR      Z,FIND2
041DAE 09 
041DAF CB      5178 FIND1:			BIT     7,(HL)
041DB0 7E 
041DB1 23      5179 INC     HL
041DB2 28      5180 JR      Z,FIND1
041DB3 FB 
041DB4 23      5181 INC     HL
041DB5 04      5182 INC     B
041DB6 18      5183 JR      FIND0
041DB7 EC 
               5184 ;
041DB8 FD      5185 FIND2:			PUSH    IY
041DB9 E5 
041DBA CB      5186 FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DBB 7E 
041DBC FD      5187 INC     IY
041DBD 23 
041DBE 23      5188 INC     HL
041DBF 20      5189 JR      NZ,FIND5		; Yes
041DC0 11 
041DC1 BE      5190 CP      (HL)
041DC2 CC      5191 CALL    Z,SKIP0
041DC3 E4 
041DC4 1D 
041DC5 04 
041DC6 7E      5192 LD      A,(HL)
041DC7 FD      5193 XOR     (IY)
041DC8 AE 
041DC9 00 
041DCA E6      5194 AND     01011111B
041DCB 5F 
041DCC 28      5195 JR      Z,FIND3
041DCD EC 
041DCE FD      5196 FIND4:			POP     IY
041DCF E1 
041DD0 18      5197 JR      FIND1
041DD1 DD 
               5198 ;
041DD2 CD      5199 FIND5:			CALL    DELIM			; Is it a delimiter?
041DD3 90 
041DD4 17 
041DD5 04 
041DD6 C4      5200 CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DD7 F9 
041DD8 1D 
041DD9 04 
041DDA C4      5201 CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DDB F3 
041DDC 1D 
041DDD 04 
041DDE 20      5202 JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DDF EE 
               5203 ;
041DE0 78      5204 FIND6:			LD      A,B			; At this point we have a token
041DE1 46      5205 LD      B,(HL)			; Fetch the token type code
041DE2 E1      5206 POP     HL			; Restore the stack
041DE3 C9      5207 RET
               5208 ;
041DE4 23      5209 SKIP0:			INC     HL
041DE5 CD      5210 SKIP:			CALL    DELIM			; Is it a delimiter?
041DE6 90 
041DE7 17 
041DE8 04 
041DE9 C0      5211 RET     NZ			; No, so return
041DEA CD      5212 CALL    TERM			; Is it a terminator?
041DEB 9C 
041DEC 17 
041DED 04 
041DEE C8      5213 RET     Z			; Yes, so return
041DEF FD      5214 INC     IY			; Increment the basic program counter
041DF0 23 
041DF1 18      5215 JR      SKIP			; And loop
041DF2 F2 
               5216 ;
041DF3 FE      5217 SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DF4 2B 
041DF5 C8      5218 RET     Z
041DF6 FE      5219 CP      '-'
041DF7 2D 
041DF8 C9      5220 RET
               5221 ;
041DF9 FE      5222 DOT:			CP	'.'			; Check if it is a dot character
041DFA 2E 
041DFB C9      5223 RET
               5224 ; Z80 opcode list
               5225 ;
               5226 ; Group 0: (15 opcodes)
               5227 ; Trivial cases requiring no computation
               5228 ;
041DFC 4E      5229 OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041DFD 4F 
041DFE 50 
041DFF 00 
041E00 52      5230 DB	"RLC","A"+80H,07h
041E01 4C 
041E02 43 
041E03 41 
041E03 07   
041E05 45      5231 DB	"EX",0,"AF",0,"AF","'"+80H,08h
041E06 58 
041E07 00 
041E08 41 
041E08 46   
041E09 00 
041E0A 41 
041E0B 46 
041E0B 27   
041E0C 08 
041E0F 52      5232 DB	"RRC","A"+80H,0FH
041E10 52 
041E11 43 
041E12 41 
041E12 0F   
041E14 52      5233 DB	"RL","A"+80H,17H
041E15 4C 
041E16 41 
041E17 17 
041E18 52      5234 DB	"RR","A"+80H,1FH
041E19 52 
041E1A 41 
041E1B 1F 
041E1C 44      5235 DB	"DA","A"+80H,27H
041E1D 41 
041E1E 41 
041E1F 27 
041E20 43      5236 DB	"CP","L"+80H,2FH
041E21 50 
041E22 4C 
041E23 2F 
041E24 53      5237 DB	"SC","F"+80H,37H
041E25 43 
041E26 46 
041E27 37 
041E28 43      5238 DB	"CC","F"+80H,3FH
041E29 43 
041E2A 46 
041E2B 3F 
041E2C 48      5239 DB	"HAL","T"+80H,76H
041E2D 41 
041E2E 4C 
041E2F 54 
041E2F 76   
041E31 45      5240 DB	"EX","X"+80H,D9H
041E32 58 
041E33 58 
041E34 D9 
041E35 45      5241 DB	"EX",0,"DE",0,"H","L"+80H,EBH
041E36 58 
041E37 00 
041E38 44 
041E38 45   
041E39 00 
041E3A 48 
041E3B 4C 
041E3B EB   
041E3E 44      5242 DB	"D","I"+80H,F3H
041E3F 49 
041E40 F3 
041E41 45      5243 DB	"E","I"+80H,FBH
041E42 49 
041E43 FB 
               5244 ;
               5245 ; Group 1: (53 opcodes)
               5246 ; As Group 0, but with an ED prefix
               5247 ;
041E44 4E      5248 DB	"NE","G"+80H,44H	; 0Fh
041E45 45 
041E46 47 
041E47 44 
041E48 49      5249 DB	"IM",0,"0"+80H,46H
041E49 4D 
041E4A 00 
041E4B 30 
041E4B 46   
041E4D 52      5250 DB	"RET","N"+80H,45H
041E4E 45 
041E4F 54 
041E50 4E 
041E50 45   
041E52 4D      5251 DB	"MLT",0,"B","C"+80H,4CH
041E53 4C 
041E54 54 
041E55 00 
041E55 42   
041E56 43 
041E57 4C 
041E59 52      5252 DB	"RET","I"+80H,4DH
041E5A 45 
041E5B 54 
041E5C 49 
041E5C 4D   
041E5E 49      5253 DB	"IM",0,"1"+80H,56H
041E5F 4D 
041E60 00 
041E61 31 
041E61 56   
041E63 4D      5254 DB	"MLT",0,"D","E"+80H,5CH
041E64 4C 
041E65 54 
041E66 00 
041E66 44   
041E67 45 
041E68 5C 
041E6A 49      5255 DB	"IM",0,"2"+80H,5EH
041E6B 4D 
041E6C 00 
041E6D 32 
041E6D 5E   
041E6F 52      5256 DB	"RR","D"+80H,67H
041E70 52 
041E71 44 
041E72 67 
041E73 4D      5257 DB	"MLT",0,"H","L"+80H,6CH
041E74 4C 
041E75 54 
041E76 00 
041E76 48   
041E77 4C 
041E78 6C 
041E7A 4C      5258 DB	"LD",0,"MB",0,"A"+80H,6DH
041E7B 44 
041E7C 00 
041E7D 4D 
041E7D 42   
041E7E 00 
041E7F 41 
041E80 6D 
041E82 4C      5259 DB	"LD",0,"A",0,"M","B"+80H,6EH
041E83 44 
041E84 00 
041E85 41 
041E85 00   
041E86 4D 
041E87 42 
041E88 6E 
041E8A 52      5260 DB	"RL","D"+80H,6FH
041E8B 4C 
041E8C 44 
041E8D 6F 
041E8E 53      5261 DB	"SL","P"+80H,76H
041E8F 4C 
041E90 50 
041E91 76 
041E92 4D      5262 DB	"MLT",0,"S","P"+80H,7CH
041E93 4C 
041E94 54 
041E95 00 
041E95 53   
041E96 50 
041E97 7C 
041E99 53      5263 DB	"STMI","X"+80H,7DH
041E9A 54 
041E9B 4D 
041E9C 49 
041E9C 58   
041E9D 7D 
041E9F 52      5264 DB	"RSMI","X"+80H,7EH
041EA0 53 
041EA1 4D 
041EA2 49 
041EA2 58   
041EA3 7E 
041EA5 49      5265 DB	"INI","M"+80H,82H
041EA6 4E 
041EA7 49 
041EA8 4D 
041EA8 82   
041EAA 4F      5266 DB	"OTI","M"+80H,83H
041EAB 54 
041EAC 49 
041EAD 4D 
041EAD 83   
041EAF 49      5267 DB	"INI","2"+80H,84H
041EB0 4E 
041EB1 49 
041EB2 32 
041EB2 84   
041EB4 49      5268 DB	"IND","M"+80H,8AH
041EB5 4E 
041EB6 44 
041EB7 4D 
041EB7 8A   
041EB9 4F      5269 DB	"OTD","M"+80H,8BH
041EBA 54 
041EBB 44 
041EBC 4D 
041EBC 8B   
041EBE 49      5270 DB	"IND","2"+80H,8CH
041EBF 4E 
041EC0 44 
041EC1 32 
041EC1 8C   
041EC3 49      5271 DB	"INIM","R"+80H,92H
041EC4 4E 
041EC5 49 
041EC6 4D 
041EC6 52   
041EC7 92 
041EC9 4F      5272 DB	"OTIM","R"+80H,93H
041ECA 54 
041ECB 49 
041ECC 4D 
041ECC 52   
041ECD 93 
041ECF 49      5273 DB	"INI2","R"+80H,94H
041ED0 4E 
041ED1 49 
041ED2 32 
041ED2 52   
041ED3 94 
041ED5 49      5274 DB	"INDM","R"+80H,9AH
041ED6 4E 
041ED7 44 
041ED8 4D 
041ED8 52   
041ED9 9A 
041EDB 4F      5275 DB	"OTDM","R"+80H,9BH
041EDC 54 
041EDD 44 
041EDE 4D 
041EDE 52   
041EDF 9B 
041EE1 49      5276 DB	"IND2","R"+80H,9CH
041EE2 4E 
041EE3 44 
041EE4 32 
041EE4 52   
041EE5 9C 
041EE7 4C      5277 DB	"LD","I"+80H,A0H
041EE8 44 
041EE9 49 
041EEA A0 
041EEB 43      5278 DB	"CP","I"+80H,A1H
041EEC 50 
041EED 49 
041EEE A1 
041EEF 49      5279 DB	"IN","I"+80H,A2H
041EF0 4E 
041EF1 49 
041EF2 A2 
041EF3 4F      5280 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041EF4 55 
041EF5 54 
041EF6 49 
041EF6 32   
041EF7 A4 
041EF9 4F      5281 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041EFA 55 
041EFB 54 
041EFC 49 
041EFC A3   
041EFE 4C      5282 DB	"LD","D"+80H,A8H
041EFF 44 
041F00 44 
041F01 A8 
041F02 43      5283 DB	"CP","D"+80H,A9H
041F03 50 
041F04 44 
041F05 A9 
041F06 49      5284 DB	"IN","D"+80H,AAH
041F07 4E 
041F08 44 
041F09 AA 
041F0A 4F      5285 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041F0B 55 
041F0C 54 
041F0D 44 
041F0D 32   
041F0E AC 
041F10 4F      5286 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041F11 55 
041F12 54 
041F13 44 
041F13 AB   
041F15 4C      5287 DB	"LDI","R"+80H,B0H
041F16 44 
041F17 49 
041F18 52 
041F18 B0   
041F1A 43      5288 DB	"CPI","R"+80H,B1H
041F1B 50 
041F1C 49 
041F1D 52 
041F1D B1   
041F1F 49      5289 DB	"INI","R"+80H,B2H
041F20 4E 
041F21 49 
041F22 52 
041F22 B2   
041F24 4F      5290 DB	"OTI","R"+80H,B3H
041F25 54 
041F26 49 
041F27 52 
041F27 B3   
041F29 4F      5291 DB	"OTI2","R"+80H,B4H
041F2A 54 
041F2B 49 
041F2C 32 
041F2C 52   
041F2D B4 
041F2F 4C      5292 DB	"LDD","R"+80H,B8H
041F30 44 
041F31 44 
041F32 52 
041F32 B8   
041F34 43      5293 DB	"CPD","R"+80H,B9H
041F35 50 
041F36 44 
041F37 52 
041F37 B9   
041F39 49      5294 DB	"IND","R"+80H,BAH
041F3A 4E 
041F3B 44 
041F3C 52 
041F3C BA   
041F3E 4F      5295 DB	"OTD","R"+80H,BBH
041F3F 54 
041F40 44 
041F41 52 
041F41 BB   
041F43 4F      5296 DB	"OTD2","R"+80H,BCH
041F44 54 
041F45 44 
041F46 32 
041F46 52   
041F47 BC 
041F49 49      5297 DB	"INIR","X"+80H,C2H
041F4A 4E 
041F4B 49 
041F4C 52 
041F4C 58   
041F4D C2 
041F4F 4F      5298 DB	"OTIR","X"+80H,C3H
041F50 54 
041F51 49 
041F52 52 
041F52 58   
041F53 C3 
041F55 49      5299 DB	"INDR","X"+80H,CAH
041F56 4E 
041F57 44 
041F58 52 
041F58 58   
041F59 CA 
041F5B 4F      5300 DB	"OTDR","X"+80H,CBH
041F5C 54 
041F5D 44 
041F5E 52 
041F5E 58   
041F5F CB 
               5301 ;
               5302 ; Group 2: (3 opcodes)
               5303 ;
041F61 42      5304 DB	"BI","T"+80H,40H	; 44h
041F62 49 
041F63 54 
041F64 40 
041F65 52      5305 DB	"RE","S"+80H,80H
041F66 45 
041F67 53 
041F68 80 
041F69 53      5306 DB	"SE","T"+80H,C0H
041F6A 45 
041F6B 54 
041F6C C0 
               5307 ;
               5308 ; Group 3: (7 opcodes)
               5309 ;
041F6D 52      5310 DB	"RL","C"+80H,00H	; 47h
041F6E 4C 
041F6F 43 
041F70 00 
041F71 52      5311 DB	"RR","C"+80H,08H
041F72 52 
041F73 43 
041F74 08 
041F75 52      5312 DB	"R","L"+80H,10H
041F76 4C 
041F77 10 
041F78 52      5313 DB	"R","R"+80H,18H
041F79 52 
041F7A 18 
041F7B 53      5314 DB	"SL","A"+80H,20H
041F7C 4C 
041F7D 41 
041F7E 20 
041F7F 53      5315 DB	"SR","A"+80H,28H
041F80 52 
041F81 41 
041F82 28 
041F83 53      5316 DB	"SR","L"+80H,38H
041F84 52 
041F85 4C 
041F86 38 
               5317 ;
               5318 ; Group 4: (3 opcodes)
               5319 ;
041F87 50      5320 DB	"PO","P"+80H,C1H	; 4Eh
041F88 4F 
041F89 50 
041F8A C1 
041F8B 50      5321 DB	"PUS","H"+80H,C5H
041F8C 55 
041F8D 53 
041F8E 48 
041F8E C5   
041F90 45      5322 DB	"EX",0,"(S","P"+80H,E3H
041F91 58 
041F92 00 
041F93 28 
041F93 53   
041F94 50 
041F95 E3 
               5323 ;
               5324 ; Group 5: (7 opcodes)
               5325 ;
041F97 53      5326 DB	"SU","B"+80H,90H	; 51h
041F98 55 
041F99 42 
041F9A 90 
041F9B 41      5327 DB	"AN","D"+80H,A0H
041F9C 4E 
041F9D 44 
041F9E A0 
041F9F 58      5328 DB	"XO","R"+80H,A8H
041FA0 4F 
041FA1 52 
041FA2 A8 
041FA3 4F      5329 DB	"O","R"+80H,B0H
041FA4 52 
041FA5 B0 
041FA6 43      5330 DB	"C","P"+80H,B8H
041FA7 50 
041FA8 B8 
041FA9 80      5331 DB	TAND,A0H		; 56h TAND: Tokenised AND
041FAA A0 
041FAB 84      5332 DB	TOR,B0H			; 57h TOR: Tokenised OR
041FAC B0 
               5333 ;
               5334 ; Group 6 (3 opcodes)
               5335 ;
041FAD 41      5336 DB	"AD","D"+80H,80H	; 58h
041FAE 44 
041FAF 44 
041FB0 80 
041FB1 41      5337 DB	"AD","C"+80H,88H
041FB2 44 
041FB3 43 
041FB4 88 
041FB5 53      5338 DB	"SB","C"+80H,98H
041FB6 42 
041FB7 43 
041FB8 98 
               5339 ;
               5340 ; Group 7: (2 opcodes)
               5341 ;
041FB9 49      5342 DB	"IN","C"+80H,04H	; 5Bh
041FBA 4E 
041FBB 43 
041FBC 04 
041FBD 44      5343 DB	"DE","C"+80H,05H
041FBE 45 
041FBF 43 
041FC0 05 
               5344 ;
               5345 ; Group 8: (2 opcodes)
               5346 ;
041FC1 49      5347 DB	"IN","0"+80H,00H	; 5Dh
041FC2 4E 
041FC3 30 
041FC4 00 
041FC5 4F      5348 DB	"OUT","0"+80H,01H
041FC6 55 
041FC7 54 
041FC8 30 
041FC8 01   
               5349 ;
               5350 ; Group 9: (1 opcode)
               5351 ;
041FCA 49      5352 DB	"I","N"+80H,40H		; 5Fh
041FCB 4E 
041FCC 40 
               5353 ;
               5354 ; Group 10: (1 opcode)
               5355 ;
041FCD 4F      5356 DB	"OU","T"+80H,41H	; 60h
041FCE 55 
041FCF 54 
041FD0 41 
               5357 ;
               5358 ; Group 11: (2 opcodes)
               5359 ;
041FD1 4A      5360 DB	"J","R"+80H,20H		; 61h
041FD2 52 
041FD3 20 
041FD4 44      5361 DB	"DJN","Z"+80H,10H
041FD5 4A 
041FD6 4E 
041FD7 5A 
041FD7 10   
               5362 ;
               5363 ; Group 12: (1 opcode)
               5364 ;
041FD9 4A      5365 DB	"J","P"+80H,C2H		; 63h
041FDA 50 
041FDB C2 
               5366 ;
               5367 ; Group 13: (1 opcode)
               5368 ;
041FDC 43      5369 DB	"CAL","L"+80H,C4H	; 64h
041FDD 41 
041FDE 4C 
041FDF 4C 
041FDF C4   
               5370 ;
               5371 ; Group 14: (1 opcode)
               5372 ;
041FE1 52      5373 DB	"RS","T"+80H,C7H	; 65h
041FE2 53 
041FE3 54 
041FE4 C7 
               5374 ;
               5375 ; Group 15: (1 opcode)
               5376 ;
041FE5 52      5377 DB	"RE","T"+80H,C0H	; 66h
041FE6 45 
041FE7 54 
041FE8 C0 
               5378 ;
               5379 ; Group 16: (1 opcode)
               5380 ;
041FE9 4C      5381 DB	"L","D"+80H,40H		; 67h
041FEA 44 
041FEB 40 
               5382 ;
               5383 ; Group 17: (1 opcode)
               5384 ;
041FEC 54      5385 DB	"TS","T"+80H,04H	; 68h
041FED 53 
041FEE 54 
041FEF 04 
               5386 
               5387 ;
               5388 ; Assembler Directives
               5389 ;
041FF0 4F      5390 DB	"OP","T"+80H,00H	; 69h OPT
041FF1 50 
041FF2 54 
041FF3 00 
041FF4 41      5391 DB	"AD","L"+80H,00H	; 6Ah ADL
041FF5 44 
041FF6 4C 
041FF7 00 
               5392 ;
041FF8 5D      5393 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041FF9 42 
041FFA 00 
041FFB 5D      5394 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041FFC 57 
041FFD 00 
041FFE 5D      5395 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041FFF 4C 
042000 00 
042001 5D      5396 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
042002 4D 
042003 00 
               5397 ;
042004 00      5398 DB	0
               5399 ;
               5400 ; Operands
               5401 ;
042005 42      5402 OPRNDS:			DB	"B"+80H, 00H
042006 00 
042007 43      5403 DB	"C"+80H, 01H
042008 01 
042009 44      5404 DB	"D"+80H, 02H
04200A 02 
04200B 45      5405 DB	"E"+80H, 03H
04200C 03 
04200D 48      5406 DB	"H"+80H, 04H
04200E 04 
04200F 4C      5407 DB	"L"+80H, 05H
042010 05 
042011 28      5408 DB	"(H","L"+80H,06H
042012 48 
042013 4C 
042014 06 
042015 41      5409 DB	"A"+80H, 07H
042016 07 
042017 28      5410 DB	"(I","X"+80H,86H
042018 49 
042019 58 
04201A 86 
04201B 28      5411 DB	"(I","Y"+80H,C6H
04201C 49 
04201D 59 
04201E C6 
               5412 ;
04201F 42      5413 DB	"B","C"+80H,08H
042020 43 
042021 08 
042022 44      5414 DB	"D","E"+80H,0AH
042023 45 
042024 0A 
042025 48      5415 DB	"H","L"+80H,0CH
042026 4C 
042027 0C 
042028 49      5416 DB	"I","X"+80H,8CH
042029 58 
04202A 8C 
04202B 49      5417 DB	"I","Y"+80H,CCH
04202C 59 
04202D CC 
04202E 41      5418 DB	"A","F"+80H,0EH
04202F 46 
042030 0E 
042031 53      5419 DB	"S","P"+80H,0EH
042032 50 
042033 0E 
               5420 ;
042034 4E      5421 DB	"N","Z"+80H,10H
042035 5A 
042036 10 
042037 5A      5422 DB	"Z"+80H,11H
042038 11 
042039 4E      5423 DB	"N","C"+80H,12H
04203A 43 
04203B 12 
04203C 50      5424 DB	"P","O"+80H,14H
04203D 4F 
04203E 14 
04203F 50      5425 DB	"P","E"+80H,15H
042040 45 
042041 15 
042042 50      5426 DB	"P"+80H,16H
042043 16 
042044 4D      5427 DB	"M"+80H,17H
042045 17 
               5428 ;
042046 28      5429 DB	"(","C"+80H,20H
042047 43 
042048 20 
               5430 ;
042049 00      5431 DB	0
               5432 ;
               5433 ; Load operations
               5434 ;
04204A 49      5435 LDOPS:			DB	"I",0,"A"+80H,47H
04204B 00 
04204C 41 
04204D 47 
04204E 52      5436 DB	"R",0,"A"+80H,4FH
04204F 00 
042050 41 
042051 4F 
042052 41      5437 DB	"A",0,"I"+80H,57H
042053 00 
042054 49 
042055 57 
042056 41      5438 DB	"A",0,"R"+80H,5FH
042057 00 
042058 52 
042059 5F 
04205A 28      5439 DB	"(BC",0,"A"+80H,02h
04205B 42 
04205C 43 
04205D 00 
04205D 41   
04205E 02 
042060 28      5440 DB	"(DE",0,"A"+80H,12H
042061 44 
042062 45 
042063 00 
042063 41   
042064 12 
042066 41      5441 DB	"A",0,"(B","C"+80H,0AH
042067 00 
042068 28 
042069 42 
042069 43   
04206A 0A 
04206C 41      5442 DB	"A",0,"(D","E"+80H,1AH
04206D 00 
04206E 28 
04206F 44 
04206F 45   
042070 1A 
               5443 ;
042072 00      5444 DB	0
               5445 ;
               5446 ; eZ80 addressing mode suffixes
               5447 ;
               5448 ; Fully qualified suffixes
               5449 ;
042073 4C      5450 EZ80SFS_1:		DB	"LI","S"+80H,49H
042074 49 
042075 53 
042076 49 
042077 53      5451 DB	"SI","L"+80H,52H
042078 49 
042079 4C 
04207A 52 
04207B 53      5452 EZ80SFS_2:		DB	"SI","S"+80H,40H
04207C 49 
04207D 53 
04207E 40 
04207F 4C      5453 DB	"LI","L"+80H,5BH
042080 49 
042081 4C 
042082 5B 
               5454 ;
042083 00      5455 DB	0
               5456 ;
               5457 ; Shortcuts when ADL mode is 0
               5458 ;
042084 53      5459 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042085 40 
042086 4C      5460 DB	"L"+80H,49H		; Equivalent to .LIS
042087 49 
042088 49      5461 DB	"I","S"+80H,40H		; Equivalent to .SIS
042089 53 
04208A 40 
04208B 49      5462 DB	"I","L"+80H,52H		; Equivalent to .SIL
04208C 4C 
04208D 52 
               5463 ;
04208E 00      5464 DB	0
               5465 ;
               5466 ; Shortcuts when ADL mode is 1
               5467 ;
04208F 53      5468 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042090 52 
042091 4C      5469 DB	"L"+80H,5BH		; Equivalent to .LIL
042092 5B 
042093 49      5470 DB	"I","S"+80H,49H		; Equivalent to .LIS
042094 53 
042095 49 
042096 49      5471 DB	"I","L"+80H,5BH		; Equivalent to .LIL
042097 4C 
042098 5B 
               5472 ;
042099 00      5473 DB	0
               5474 ;
               5475 ; .LIST
               5476 ;
               5477 ; already defined in equs.inc
               5478 ; LF:			EQU     0AH
               5479 ; CR:			EQU     0DH; --- End exec.asm ---
               5480 
               5481 ; --- Begin fpp.asm ---
               5482 ;
               5483 ; Title:	BBC Basic Interpreter - Z80 version
               5484 ;		Z80 Floating Point Package
               5485 ; Author:	(C) Copyright  R.T.Russell  1986
               5486 ; Modified By:	Dean Belfield
               5487 ; Created:	03/05/2022
               5488 ; Last Updated:	07/06/2023
               5489 ;
               5490 ; Modinfo:
               5491 ; 26/10/1986:	Version 0.0
               5492 ; 14/12/1988:	Vesion 0.1 (Bug Fix)
               5493 ; 12/05/2023:	Modified by Dean Belfield
               5494 ; 07/06/2023:	Modified to run in ADL mode
               5495 
               5496 ; .ASSUME	ADL = 1
               5497 
               5498 ; SEGMENT CODE
               5499 
               5500 ; XDEF	FPP
               5501 ; XDEF	DLOAD5
               5502 ; XDEF	DLOAD5_SPL
               5503 ;
               5504 ;BINARY FLOATING POINT REPRESENTATION:
               5505 ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               5506 ;    8 BIT EXCESS-128 SIGNED EXPONENT
               5507 ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               5508 ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               5509 ;
               5510 ;BINARY INTEGER REPRESENTATION:
               5511 ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               5512 ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
               5513 ;
               5514 ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               5515 ;                            EXPONENT - C
               5516 ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
               5517 ;                               EXPONENT - B
               5518 
               5519 ;
               5520 ;Error codes:
               5521 ;
               5522 
               5523 BADOP:			EQU     1               ;Bad operation code
               5524 DIVBY0:			EQU     18              ;Division by zero
               5525 TOOBIG_FP:			EQU     20              ;Too big
               5526 NGROOT:			EQU     21              ;Negative root
               5527 LOGRNG:			EQU     22              ;Log range
               5528 ACLOST:			EQU     23              ;Accuracy lost
               5529 EXPRNG:			EQU     24              ;Exp range
               5530 ;
               5531 ;Call entry and despatch code:
               5532 ;
04209A FD      5533 FPP:			PUSH    IY              ;Save IY
04209B E5 
04209C FD      5534 LD      IY,0
04209D 21 
04209E 00 
04209F 00 
04209F 00   
0420A1 FD      5535 ADD     IY,SP           ;Save SP in IY
0420A2 39 
0420A3 CD      5536 CALL    OP              ;Perform operation
0420A4 B3 
0420A5 20 
0420A6 04 
0420A7 BF      5537 CP      A               ;Good return (Z, NC)
0420A8 FD      5538 EXIT_FP_:			POP     IY              ;Restore IY
0420A9 E1 
0420AA C9      5539 RET                     ;Return to caller
               5540 ;
               5541 ;Error exit:
               5542 ;
0420AB 3E      5543 BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420AC 01 
0420AD FD      5544 ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420AE F9 
0420AF B7      5545 OR      A               ;Set NZ
0420B0 37      5546 SCF                     ;Set C
0420B1 18      5547 JR      EXIT_FP_
0420B2 F5 
               5548 ;
               5549 ;Perform operation or function:
               5550 ;
               5551 ; OP:			CP      (RTABLE-DTABLE)/3
0420B3 FE      5552 OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420B4 2A 
               5553 
0420B5 30      5554 JR      NC,BAD_FP
0420B6 F4 
               5555 ; CP      (FTABLE-DTABLE)/3
0420B7 FE      5556 CP      FTABLE-DTABLE/3 ; ditto
0420B8 10 
0420B9 30      5557 JR      NC,DISPAT_FP
0420BA 08 
0420BB 08      5558 EX      AF,AF'
0420BC 78      5559 LD      A,B
0420BD B1      5560 OR      C               ;Both integer?
0420BE C4      5561 CALL    NZ,FLOATA       ;No, so float both
0420BF C6 
0420C0 2B 
0420C1 04 
0420C2 08      5562 EX      AF,AF'
0420C3 E5      5563 DISPAT_FP:			PUSH    HL
0420C4 21      5564 LD      HL,DTABLE
0420C5 D6 
0420C6 20 
0420C7 04 
0420C8 C5      5565 PUSH    BC
0420C9 01      5566 LD	BC, 3		; C = 3
0420CA 03 
0420CB 00 
0420CC 00 
0420CD 47      5567 LD	B, A 		; B = op-code
0420CE ED      5568 MLT 	BC 		;BC = op-code * 3
0420CF 4C 
0420D0 09      5569 ADD	HL, BC 		;Add to table base
0420D1 ED      5570 LD	HL, (HL)	;Get the routine address (24-bit)
0420D2 27 
               5571 
               5572 ;        		ADD     A, A            ;A = op-code * 2
               5573 ;        		LD      C,A
               5574 ;        		LD      B,0             ;BC = op-code * 2
               5575 ;        		ADD     HL,BC
               5576 ;        		LD      A,(HL)          ;Get low byte
               5577 ;        		INC     HL
               5578 ;        		LD      H,(HL)          ;Get high byte
               5579 ;        		LD      L,A
               5580 
0420D3 C1      5581 POP     BC
0420D4 E3      5582 EX      (SP),HL
0420D5 C9      5583 RET                     ;Off to routine
               5584 ;
               5585 ;Despatch table:
               5586 ;
0420D6 88      5587 DTABLE:			DW24  IAND            ;AND (INTEGER)
0420D7 21 
0420D8 04 
0420D9 F6      5588 DW24  IBDIV           ;DIV
0420DA 21 
0420DB 04 
0420DC 9B      5589 DW24  IEOR            ;EOR
0420DD 21 
0420DE 04 
0420DF C1      5590 DW24  IMOD            ;MOD
0420E0 21 
0420E1 04 
0420E2 AE      5591 DW24  IOR             ;OR
0420E3 21 
0420E4 04 
0420E5 7C      5592 DW24  ILE             ;<=
0420E6 24 
0420E7 04 
0420E8 8B      5593 DW24  INE             ;<>
0420E9 24 
0420EA 04 
0420EB 6F      5594 DW24  IGE             ;>=
0420EC 24 
0420ED 04 
0420EE 54      5595 DW24  ILT             ;<
0420EF 24 
0420F0 04 
0420F1 98      5596 DW24  IEQ             ;=
0420F2 24 
0420F3 04 
0420F4 E4      5597 DW24  IMUL            ;*
0420F5 22 
0420F6 04 
0420F7 1F      5598 DW24  IADD            ;+
0420F8 22 
0420F9 04 
0420FA 61      5599 DW24  IGT             ;>
0420FB 24 
0420FC 04 
0420FD 06      5600 DW24  ISUB            ;-
0420FE 22 
0420FF 04 
042100 9B      5601 DW24  IPOW            ;^
042101 23 
042102 04 
042103 91      5602 DW24  IDIV            ;/
042104 22 
042105 04 
               5603 ;
               5604 FTABLE:
042106 AA      5605 DW24  ABSV_FP            ;ABS
042107 24 
042108 04 
042109 90      5606 DW24  ACS_FP             ;ACS
04210A 28 
04210B 04 
04210C CE      5607 DW24  ASN_FP             ;ASN
04210D 27 
04210E 04 
04210F FE      5608 DW24  ATN_FP             ;ATN
042110 27 
042111 04 
042112 C9      5609 DW24  COS_FP             ;COS
042113 25 
042114 04 
042115 D8      5610 DW24  DEG_FP             ;DEG
042116 24 
042117 04 
042118 85      5611 DW24  EXP_FP             ;EXP
042119 26 
04211A 04 
04211B 2C      5612 DW24  INT_FP_            ;INT
04211C 25 
04211D 04 
04211E 23      5613 DW24  LN_FP              ;LN
04211F 27 
042120 04 
042121 B8      5614 DW24  LOG_FP             ;LOG
042122 27 
042123 04 
042124 B6      5615 DW24  NOTK_FP            ;NOT
042125 24 
042126 04 
042127 E2      5616 DW24  RAD_FP             ;RAD
042128 24 
042129 04 
04212A FD      5617 DW24  SGN_FP             ;SGN
04212B 24 
04212C 04 
04212D D6      5618 DW24  SIN_FP             ;SIN
04212E 25 
04212F 04 
042130 45      5619 DW24  SQR_FP             ;SQR
042131 25 
042132 04 
042133 A3      5620 DW24  TAN_FP             ;TAN
042134 25 
042135 04 
               5621 ;
042136 53      5622 DW24  ZERO_FP            ;ZERO
042137 2C 
042138 04 
042139 5E      5623 DW24  FONE_FP            ;FONE
04213A 26 
04213B 04 
04213C 9D      5624 DW24  TRUE_FP            ;TRUE
04213D 24 
04213E 04 
04213F CA      5625 DW24  PI_FP              ;PI
042140 24 
042141 04 
               5626 ;
042142 11      5627 DW24  VAL_FP             ;VAL
042143 25 
042144 04 
042145 99      5628 DW24  STR_FP             ;STR$
042146 28 
042147 04 
               5629 ;
042148 FA      5630 DW24  SFIX_FP            ;FIX
042149 2A 
04214A 04 
04214B D6      5631 DW24  SFLOAT_FP          ;FLOAT
04214C 2B 
04214D 04 
               5632 ;
04214E 24      5633 DW24  FTEST_FP           ;TEST
04214F 2C 
042150 04 
042151 36      5634 DW24  FCOMP_FP           ;COMPARE
042152 2C 
042153 04 
               5635 ;
042154 84      5636 RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042155 21 
042156 04 
042157 F2      5637 DW24  FBDIV           ;DIV
042158 21 
042159 04 
04215A 97      5638 DW24  FEOR            ;EOR
04215B 21 
04215C 04 
04215D BD      5639 DW24  FMOD            ;MOD
04215E 21 
04215F 04 
042160 AA      5640 DW24  FFOR             ;OR
042161 21 
042162 04 
042163 76      5641 DW24  FLE             ;<=
042164 24 
042165 04 
042166 85      5642 DW24  FNE             ;<>
042167 24 
042168 04 
042169 69      5643 DW24  FGE             ;>=
04216A 24 
04216B 04 
04216C 4E      5644 DW24  FLT             ;<
04216D 24 
04216E 04 
04216F 92      5645 DW24  FEQ             ;=
042170 24 
042171 04 
042172 3E      5646 DW24  FMUL            ;*
042173 23 
042174 04 
042175 2C      5647 DW24  FADD            ;+
042176 22 
042177 04 
042178 5B      5648 DW24  FGT             ;>
042179 24 
04217A 04 
04217B 13      5649 DW24  FSUB            ;-
04217C 22 
04217D 04 
04217E 1B      5650 DW24  FPOW            ;^
04217F 24 
042180 04 
042181 95      5651 DW24  FDIV            ;/
042182 22 
042183 04 
               5652 ;
               5653 ;       PAGE
               5654 ;
               5655 ;ARITHMETIC AND LOGICAL OPERATORS:
               5656 ;All take two arguments, in HLH'L'C & DED'E'B.
               5657 ;Output in HLH'L'C
               5658 ;All registers except IX, IY destroyed.
               5659 ; (N.B. FPOW destroys IX).
               5660 ;
               5661 ;FAND - Floating-point AND.
               5662 ;IAND - Integer AND.
               5663 ;
042184 CD      5664 FAND:			CALL    FIX2
042185 EE 
042186 2A 
042187 04 
042188 7C      5665 IAND:			LD      A,H
042189 A2      5666 AND     D
04218A 67      5667 LD      H,A
04218B 7D      5668 LD      A,L
04218C A3      5669 AND     E
04218D 6F      5670 LD      L,A
04218E D9      5671 EXX
04218F 7C      5672 LD      A,H
042190 A2      5673 AND     D
042191 67      5674 LD      H,A
042192 7D      5675 LD      A,L
042193 A3      5676 AND     E
042194 6F      5677 LD      L,A
042195 D9      5678 EXX
042196 C9      5679 RET
               5680 ;
               5681 ;FEOR - Floating-point exclusive-OR.
               5682 ;IEOR - Integer exclusive-OR.
               5683 ;
042197 CD      5684 FEOR:			CALL    FIX2
042198 EE 
042199 2A 
04219A 04 
04219B 7C      5685 IEOR:			LD      A,H
04219C AA      5686 XOR     D
04219D 67      5687 LD      H,A
04219E 7D      5688 LD      A,L
04219F AB      5689 XOR     E
0421A0 6F      5690 LD      L,A
0421A1 D9      5691 EXX
0421A2 7C      5692 LD      A,H
0421A3 AA      5693 XOR     D
0421A4 67      5694 LD      H,A
0421A5 7D      5695 LD      A,L
0421A6 AB      5696 XOR     E
0421A7 6F      5697 LD      L,A
0421A8 D9      5698 EXX
0421A9 C9      5699 RET
               5700 ;
               5701 ;FOR - Floating-point OR.
               5702 ;IOR - Integer OR.
               5703 ;
0421AA CD      5704 FFOR:			CALL    FIX2
0421AB EE 
0421AC 2A 
0421AD 04 
0421AE 7C      5705 IOR:			LD      A,H
0421AF B2      5706 OR      D
0421B0 67      5707 LD      H,A
0421B1 7D      5708 LD      A,L
0421B2 B3      5709 OR      E
0421B3 6F      5710 LD      L,A
0421B4 D9      5711 EXX
0421B5 7C      5712 LD      A,H
0421B6 B2      5713 OR      D
0421B7 67      5714 LD      H,A
0421B8 7D      5715 LD      A,L
0421B9 B3      5716 OR      E
0421BA 6F      5717 LD      L,A
0421BB D9      5718 EXX
0421BC C9      5719 RET
               5720 ;
               5721 ;FMOD - Floating-point remainder.
               5722 ;IMOD - Integer remainder.
               5723 ;
0421BD CD      5724 FMOD:			CALL    FIX2
0421BE EE 
0421BF 2A 
0421C0 04 
0421C1 7C      5725 IMOD:			LD      A,H
0421C2 AA      5726 XOR     D               ;DIV RESULT SIGN
0421C3 CB      5727 BIT     7,H
0421C4 7C 
0421C5 08      5728 EX      AF,AF'
0421C6 CB      5729 BIT     7,H
0421C7 7C 
0421C8 C4      5730 CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421C9 0A 
0421CA 2B 
0421CB 04 
0421CC CD      5731 CALL    SWAP_FP
0421CD 07 
0421CE 2C 
0421CF 04 
0421D0 CB      5732 BIT     7,H
0421D1 7C 
0421D2 C4      5733 CALL    NZ,NEGATE
0421D3 0A 
0421D4 2B 
0421D5 04 
0421D6 44      5734 LD      B,H
0421D7 4D      5735 LD      C,L
0421D8 21      5736 LD      HL,0
0421D9 00 
0421DA 00 
0421DB 00 
0421DC D9      5737 EXX
0421DD 44      5738 LD      B,H
0421DE 4D      5739 LD      C,L
0421DF 21      5740 LD      HL,0
0421E0 00 
0421E1 00 
0421E2 00 
0421E3 3E      5741 LD      A,-33
0421E4 DF 
0421E5 CD      5742 CALL    DIVA            ;DIVIDE
0421E6 94 
0421E7 2D 
0421E8 04 
0421E9 D9      5743 EXX
0421EA 0E      5744 LD      C,0             ;INTEGER MARKER
0421EB 00 
0421EC 08      5745 EX      AF,AF'
0421ED C8      5746 RET     Z
0421EE C3      5747 JP      NEGATE
0421EF 0A 
0421F0 2B 
0421F1 04 
               5748 ;
               5749 ;BDIV - Integer division.
               5750 ;
0421F2 CD      5751 FBDIV:			CALL    FIX2
0421F3 EE 
0421F4 2A 
0421F5 04 
0421F6 CD      5752 IBDIV:			CALL    IMOD
0421F7 C1 
0421F8 21 
0421F9 04 
0421FA B7      5753 OR      A
0421FB CD      5754 CALL    SWAP_FP
0421FC 07 
0421FD 2C 
0421FE 04 
0421FF 0E      5755 LD      C,0
042200 00 
042201 F0      5756 RET     P
042202 C3      5757 JP      NEGATE
042203 0A 
042204 2B 
042205 04 
               5758 ;
               5759 ;ISUB - Integer subtraction.
               5760 ;FSUB - Floating point subtraction with rounding.
               5761 ;
042206 CD      5762 ISUB:			CALL    SUB_
042207 A2 
042208 2C 
042209 04 
04220A E0      5763 RET     PO
04220B CD      5764 CALL    ADD_
04220C 9A 
04220D 2C 
04220E 04 
04220F CD      5765 CALL    FLOAT2
042210 CA 
042211 2B 
042212 04 
042213 7A      5766 FSUB:			LD      A,D
042214 EE      5767 XOR     80H             ;CHANGE SIGN THEN ADD
042215 80 
042216 57      5768 LD      D,A
042217 18      5769 JR      FADD
042218 13 
               5770 ;
               5771 ;Reverse subtract.
               5772 ;
042219 7C      5773 RSUB:			LD      A,H
04221A EE      5774 XOR     80H
04221B 80 
04221C 67      5775 LD      H,A
04221D 18      5776 JR      FADD
04221E 0D 
               5777 ;
               5778 ;IADD - Integer addition.
               5779 ;FADD - Floating point addition with rounding.
               5780 ;
04221F CD      5781 IADD:			CALL    ADD_
042220 9A 
042221 2C 
042222 04 
042223 E0      5782 RET     PO
042224 CD      5783 CALL    SUB_
042225 A2 
042226 2C 
042227 04 
042228 CD      5784 CALL    FLOAT2
042229 CA 
04222A 2B 
04222B 04 
04222C 05      5785 FADD:			DEC     B
04222D 04      5786 INC     B
04222E C8      5787 RET     Z               ;ARG 2 ZERO
04222F 0D      5788 DEC     C
042230 0C      5789 INC     C
042231 CA      5790 JP      Z,SWAP_FP          ;ARG 1 ZERO
042232 07 
042233 2C 
042234 04 
042235 D9      5791 EXX
042236 01      5792 LD      BC,0            ;INITIALISE
042237 00 
042238 00 
042239 00 
04223A D9      5793 EXX
04223B 7C      5794 LD      A,H
04223C AA      5795 XOR     D               ;XOR SIGNS
04223D F5      5796 PUSH    AF
04223E 78      5797 LD      A,B
04223F B9      5798 CP      C               ;COMPARE EXPONENTS
042240 DC      5799 CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042241 07 
042242 2C 
042243 04 
042244 78      5800 LD      A,B
042245 CB      5801 SET     7,H             ;IMPLIED 1
042246 FC 
042247 C4      5802 CALL    NZ,FIX          ;ALIGN
042248 DB 
042249 2A 
04224A 04 
04224B F1      5803 POP     AF
04224C 7A      5804 LD      A,D             ;SIGN OF LARGER
04224D CB      5805 SET     7,D             ;IMPLIED 1
04224E FA 
04224F FA      5806 JP      M,FADD3         ;SIGNS DIFFERENT
042250 5F 
042251 22 
042252 04 
042253 CD      5807 CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
042254 9A 
042255 2C 
042256 04 
042257 DC      5808 CALL    C,DIV2          ;NORMALISE
042258 0F 
042259 2C 
04225A 04 
04225B CB      5809 SET     7,H
04225C FC 
04225D 18      5810 JR      FADD4
04225E 0D 
               5811 ;
04225F CD      5812 FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042260 A2 
042261 2C 
042262 04 
042263 DC      5813 CALL    C,NEG_           ;NEGATE HLH'L'B'C'
042264 22 
042265 2B 
042266 04 
042267 CD      5814 CALL    FLO48
042268 A1 
042269 2B 
04226A 04 
04226B 2F      5815 CPL                     ;CHANGE RESULT SIGN
04226C D9      5816 FADD4:			EXX
04226D EB      5817 EX      DE,HL
04226E 21      5818 LD      HL,8000H
04226F 00 
042270 80 
042271 00 
042272 B7      5819 OR      A               ;CLEAR CARRY
042273 52      5820 SBC.S   HL,BC
042274 ED 
042275 42 
042276 EB      5821 EX      DE,HL
042277 D9      5822 EXX
042278 CC      5823 CALL    Z,ODD           ;ROUND UNBIASSED
042279 01 
04227A 2C 
04227B 04 
04227C DC      5824 CALL    C,ADD1_FP          ;ROUND UP
04227D EF 
04227E 2B 
04227F 04 
042280 DC      5825 CALL    C,INCC
042281 1C 
042282 2C 
042283 04 
042284 CB      5826 RES     7,H
042285 BC 
042286 0D      5827 DEC     C
042287 0C      5828 INC     C
042288 CA      5829 JP      Z,ZERO_FP
042289 53 
04228A 2C 
04228B 04 
04228C B7      5830 OR      A               ;RESULT SIGNQ
04228D F0      5831 RET     P               ;POSITIVE
04228E CB      5832 SET     7,H             ;NEGATIVE
04228F FC 
042290 C9      5833 RET
               5834 ;
               5835 ;IDIV - Integer division.
               5836 ;FDIV - Floating point division with rounding.
               5837 ;
042291 CD      5838 IDIV:			CALL    FLOAT2
042292 CA 
042293 2B 
042294 04 
042295 05      5839 FDIV:			DEC     B               ;TEST FOR ZERO
042296 04      5840 INC     B
042297 3E      5841 LD      A,DIVBY0
042298 12 
042299 CA      5842 JP      Z,ERROR_FP_         ;"Division by zero"
04229A AD 
04229B 20 
04229C 04 
04229D 0D      5843 DEC     C               ;TEST FOR ZERO
04229E 0C      5844 INC     C
04229F C8      5845 RET     Z
0422A0 7C      5846 LD      A,H
0422A1 AA      5847 XOR     D               ;CALC. RESULT SIGN
0422A2 08      5848 EX      AF,AF'          ;SAVE SIGN
0422A3 CB      5849 SET     7,D             ;REPLACE IMPLIED 1's
0422A4 FA 
0422A5 CB      5850 SET     7,H
0422A6 FC 
0422A7 C5      5851 PUSH    BC              ;SAVE EXPONENTS
0422A8 42      5852 LD      B,D             ;LOAD REGISTERS
0422A9 4B      5853 LD      C,E
0422AA 11      5854 LD      DE,0
0422AB 00 
0422AC 00 
0422AD 00 
0422AE D9      5855 EXX
0422AF 42      5856 LD      B,D
0422B0 4B      5857 LD      C,E
0422B1 11      5858 LD      DE,0
0422B2 00 
0422B3 00 
0422B4 00 
0422B5 3E      5859 LD      A,-32           ;LOOP COUNTER
0422B6 E0 
0422B7 CD      5860 CALL    DIVA            ;DIVIDE
0422B8 94 
0422B9 2D 
0422BA 04 
0422BB D9      5861 EXX
0422BC CB      5862 BIT     7,D
0422BD 7A 
0422BE D9      5863 EXX
0422BF CC      5864 CALL    Z,DIVB          ;NORMALISE & INC A
0422C0 B3 
0422C1 2D 
0422C2 04 
0422C3 EB      5865 EX      DE,HL
0422C4 D9      5866 EXX
0422C5 CB      5867 SRL     B               ;DIVISOR/2
0422C6 38 
0422C7 CB      5868 RR      C
0422C8 19 
0422C9 B7      5869 OR      A               ;CLEAR CARRY
0422CA 52      5870 SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422CB ED 
0422CC 42 
0422CD 3F      5871 CCF
0422CE EB      5872 EX      DE,HL           ;RESULT IN HLH'L'
0422CF CC      5873 CALL    Z,ODD           ;ROUND UNBIASSED
0422D0 01 
0422D1 2C 
0422D2 04 
0422D3 DC      5874 CALL    C,ADD1_FP          ;ROUND UP
0422D4 EF 
0422D5 2B 
0422D6 04 
0422D7 C1      5875 POP     BC              ;RESTORE EXPONENTS
0422D8 DC      5876 CALL    C,INCC
0422D9 1C 
0422DA 2C 
0422DB 04 
0422DC 1F      5877 RRA                     ;LSB OF A TO CARRY
0422DD 79      5878 LD      A,C             ;COMPUTE NEW EXPONENT
0422DE 98      5879 SBC     A,B
0422DF 3F      5880 CCF
0422E0 C3      5881 JP      CHKOVF
0422E1 81 
0422E2 23 
0422E3 04 
               5882 ;
               5883 ;IMUL - Integer multiplication.
               5884 ;
0422E4 7C      5885 IMUL:			LD      A,H
0422E5 AA      5886 XOR     D
0422E6 08      5887 EX      AF,AF'          ;SAVE RESULT SIGN
0422E7 CB      5888 BIT     7,H
0422E8 7C 
0422E9 C4      5889 CALL    NZ,NEGATE
0422EA 0A 
0422EB 2B 
0422EC 04 
0422ED CD      5890 CALL    SWAP_FP
0422EE 07 
0422EF 2C 
0422F0 04 
0422F1 CB      5891 BIT     7,H
0422F2 7C 
0422F3 C4      5892 CALL    NZ,NEGATE
0422F4 0A 
0422F5 2B 
0422F6 04 
0422F7 44      5893 LD      B,H
0422F8 4D      5894 LD      C,L
0422F9 21      5895 LD      HL,0
0422FA 00 
0422FB 00 
0422FC 00 
0422FD D9      5896 EXX
0422FE 44      5897 LD      B,H
0422FF 4D      5898 LD      C,L
042300 21      5899 LD      HL,0
042301 00 
042302 00 
042303 00 
042304 3E      5900 LD      A,-33
042305 DF 
042306 CD      5901 CALL    MULA            ;MULTIPLY
042307 CB 
042308 2D 
042309 04 
04230A D9      5902 EXX
04230B 0E      5903 LD      C,191           ;PRESET EXPONENT
04230C BF 
04230D CD      5904 CALL    TEST_FP            ;TEST RANGE
04230E 2F 
04230F 2C 
042310 04 
042311 20      5905 JR      NZ,IMUL1        ;TOO BIG
042312 0F 
042313 CB      5906 BIT     7,D
042314 7A 
042315 20      5907 JR      NZ,IMUL1
042316 0B 
042317 CD      5908 CALL    SWAP_FP
042318 07 
042319 2C 
04231A 04 
04231B 4A      5909 LD      C,D             ;INTEGER MARKER
04231C 08      5910 EX      AF,AF'
04231D F0      5911 RET     P
04231E C3      5912 JP      NEGATE
04231F 0A 
042320 2B 
042321 04 
               5913 ;
042322 0D      5914 IMUL1:			DEC     C
042323 D9      5915 EXX
042324 CB      5916 SLA     E
042325 23 
042326 CB      5917 RL      D
042327 12 
042328 D9      5918 EXX
042329 CB      5919 RL      E
04232A 13 
04232B CB      5920 RL      D
04232C 12 
04232D D9      5921 EXX
04232E 52      5922 ADC.S   HL,HL
04232F ED 
042330 6A 
042331 D9      5923 EXX
042332 52      5924 ADC.S   HL,HL
042333 ED 
042334 6A 
042335 F2      5925 JP      P,IMUL1         ;NORMALISE
042336 22 
042337 23 
042338 04 
042339 08      5926 EX      AF,AF'
04233A F8      5927 RET     M
04233B CB      5928 RES     7,H             ;POSITIVE
04233C BC 
04233D C9      5929 RET
               5930 ;
               5931 ;FMUL - Floating point multiplication with rounding.
               5932 ;
04233E 05      5933 FMUL:			DEC     B               ;TEST FOR ZERO
04233F 04      5934 INC     B
042340 CA      5935 JP      Z,ZERO_FP
042341 53 
042342 2C 
042343 04 
042344 0D      5936 DEC     C               ;TEST FOR ZERO
042345 0C      5937 INC     C
042346 C8      5938 RET     Z
042347 7C      5939 LD      A,H
042348 AA      5940 XOR     D               ;CALC. RESULT SIGN
042349 08      5941 EX      AF,AF'
04234A CB      5942 SET     7,D             ;REPLACE IMPLIED 1's
04234B FA 
04234C CB      5943 SET     7,H
04234D FC 
04234E C5      5944 PUSH    BC              ;SAVE EXPONENTS
04234F 44      5945 LD      B,H             ;LOAD REGISTERS
042350 4D      5946 LD      C,L
042351 21      5947 LD      HL,0
042352 00 
042353 00 
042354 00 
042355 D9      5948 EXX
042356 44      5949 LD      B,H
042357 4D      5950 LD      C,L
042358 21      5951 LD      HL,0
042359 00 
04235A 00 
04235B 00 
04235C 3E      5952 LD      A,-32           ;LOOP COUNTER
04235D E0 
04235E CD      5953 CALL    MULA            ;MULTIPLY
04235F CB 
042360 2D 
042361 04 
042362 DC      5954 CALL    C,MULB          ;NORMALISE & INC A
042363 E1 
042364 2D 
042365 04 
042366 D9      5955 EXX
042367 E5      5956 PUSH    HL
042368 21      5957 LD      HL,8000H
042369 00 
04236A 80 
04236B 00 
04236C B7      5958 OR      A               ;CLEAR CARRY
04236D 52      5959 SBC.S   HL,DE
04236E ED 
04236F 52 
042370 E1      5960 POP     HL
042371 CC      5961 CALL    Z,ODD           ;ROUND UNBIASSED
042372 01 
042373 2C 
042374 04 
042375 DC      5962 CALL    C,ADD1_FP          ;ROUND UP
042376 EF 
042377 2B 
042378 04 
042379 C1      5963 POP     BC              ;RESTORE EXPONENTS
04237A DC      5964 CALL    C,INCC
04237B 1C 
04237C 2C 
04237D 04 
04237E 1F      5965 RRA                     ;LSB OF A TO CARRY
04237F 79      5966 LD      A,C             ;COMPUTE NEW EXPONENT
042380 88      5967 ADC     A,B
042381 38      5968 CHKOVF:			JR      C,CHKO1
042382 06 
042383 F2      5969 JP      P,ZERO_FP          ;UNDERFLOW
042384 53 
042385 2C 
042386 04 
042387 18      5970 JR      CHKO2
042388 04 
042389 FA      5971 CHKO1:			JP      M,OFLOW         ;OVERFLOW
04238A 1E 
04238B 2C 
04238C 04 
04238D C6      5972 CHKO2:			ADD     A,80H
04238E 80 
04238F 4F      5973 LD      C,A
042390 CA      5974 JP      Z,ZERO_FP
042391 53 
042392 2C 
042393 04 
042394 08      5975 EX      AF,AF'          ;RESTORE SIGN BIT
042395 CB      5976 RES     7,H
042396 BC 
042397 F0      5977 RET     P
042398 CB      5978 SET     7,H
042399 FC 
04239A C9      5979 RET
               5980 ;
               5981 ;IPOW - Integer involution.
               5982 ;
04239B CD      5983 IPOW:			CALL    SWAP_FP
04239C 07 
04239D 2C 
04239E 04 
04239F CB      5984 BIT     7,H
0423A0 7C 
0423A1 F5      5985 PUSH    AF              ;SAVE SIGN
0423A2 C4      5986 CALL    NZ,NEGATE
0423A3 0A 
0423A4 2B 
0423A5 04 
0423A6 48      5987 IPOW0:			LD      C,B
0423A7 06      5988 LD      B,32            ;LOOP COUNTER
0423A8 20 
0423A9 CD      5989 IPOW1:			CALL    X2
0423AA BF 
0423AB 2C 
0423AC 04 
0423AD 38      5990 JR      C,IPOW2
0423AE 08 
0423AF 10      5991 DJNZ    IPOW1
0423B0 F8 
0423B1 F1      5992 POP     AF
0423B2 D9      5993 EXX
0423B3 2C      5994 INC     L               ;RESULT=1
0423B4 D9      5995 EXX
0423B5 4C      5996 LD      C,H
0423B6 C9      5997 RET
               5998 ;
0423B7 F1      5999 IPOW2:			POP     AF
0423B8 C5      6000 PUSH    BC
0423B9 EB      6001 EX      DE,HL
0423BA E5      6002 PUSH    HL
0423BB D9      6003 EXX
0423BC EB      6004 EX      DE,HL
0423BD E5      6005 PUSH    HL
0423BE D9      6006 EXX
0423BF DD      6007 LD      IX,0
0423C0 21 
0423C1 00 
0423C2 00 
0423C2 00   
0423C4 DD      6008 ADD     IX,SP
0423C5 39 
0423C6 28      6009 JR      Z,IPOW4
0423C7 48 
0423C8 C5      6010 PUSH    BC
0423C9 D9      6011 EXX
0423CA D5      6012 PUSH    DE
0423CB D9      6013 EXX
0423CC D5      6014 PUSH    DE
0423CD CD      6015 CALL    SFLOAT_FP
0423CE D6 
0423CF 2B 
0423D0 04 
0423D1 CD      6016 CALL    RECIP
0423D2 0A 
0423D3 27 
0423D4 04 
0423D5 DD      6017 LD      (IX+4),C
0423D6 71 
0423D7 04 
0423D8 D9      6018 EXX
0423D9 DD      6019 LD      (IX+0),L
0423DA 75 
0423DB 00 
0423DC DD      6020 LD      (IX+1),H
0423DD 74 
0423DE 01 
0423DF D9      6021 EXX
0423E0 DD      6022 LD      (IX+2),L
0423E1 75 
0423E2 02 
0423E3 DD      6023 LD      (IX+3),H
0423E4 74 
0423E5 03 
0423E6 18      6024 JR      IPOW5
0423E7 21 
               6025 ;
0423E8 C5      6026 IPOW3:			PUSH    BC
0423E9 D9      6027 EXX
0423EA CB      6028 SLA     E
0423EB 23 
0423EC CB      6029 RL      D
0423ED 12 
0423EE D5      6030 PUSH    DE
0423EF D9      6031 EXX
0423F0 CB      6032 RL      E
0423F1 13 
0423F2 CB      6033 RL      D
0423F3 12 
0423F4 D5      6034 PUSH    DE
0423F5 3E      6035 LD      A,'*' & 0FH
0423F6 0A 
0423F7 F5      6036 PUSH    AF
0423F8 CD      6037 CALL    COPY_
0423F9 D3 
0423FA 2C 
0423FB 04 
0423FC CD      6038 CALL    OP              ;SQUARE
0423FD B3 
0423FE 20 
0423FF 04 
042400 F1      6039 POP     AF
042401 CD      6040 CALL    DLOAD5
042402 FF 
042403 29 
042404 04 
042405 DC      6041 CALL    C,OP            ;MULTIPLY BY X
042406 B3 
042407 20 
042408 04 
042409 D1      6042 IPOW5:			POP     DE
04240A D9      6043 EXX
04240B D1      6044 POP     DE
04240C D9      6045 EXX
04240D 79      6046 LD      A,C
04240E C1      6047 POP     BC
04240F 4F      6048 LD      C,A
042410 10      6049 IPOW4:			DJNZ    IPOW3
042411 D6 
042412 F1      6050 POP     AF
042413 F1      6051 POP     AF
042414 F1      6052 POP     AF
042415 C9      6053 RET
               6054 ;
042416 F1      6055 FPOW0:			POP     AF
042417 F1      6056 POP     AF
042418 F1      6057 POP     AF
042419 18      6058 JR      IPOW0
04241A 8B 
               6059 ;
               6060 ;FPOW - Floating-point involution.
               6061 ;
04241B CB      6062 FPOW:			BIT     7,D
04241C 7A 
04241D F5      6063 PUSH    AF
04241E CD      6064 CALL    SWAP_FP
04241F 07 
042420 2C 
042421 04 
042422 CD      6065 CALL    PUSH5
042423 E3 
042424 2C 
042425 04 
042426 0D      6066 DEC     C
042427 0C      6067 INC     C
042428 28      6068 JR      Z,FPOW0
042429 EC 
04242A 3E      6069 LD      A,158
04242B 9E 
04242C B9      6070 CP      C
04242D 38      6071 JR      C,FPOW1
04242E 0A 
04242F 3C      6072 INC     A
042430 CD      6073 CALL    FIX
042431 DB 
042432 2A 
042433 04 
042434 08      6074 EX      AF,AF'
042435 F2      6075 JP      P,FPOW0
042436 16 
042437 24 
042438 04 
042439 CD      6076 FPOW1:			CALL    SWAP_FP
04243A 07 
04243B 2C 
04243C 04 
04243D CD      6077 CALL    LN0
04243E 27 
04243F 27 
042440 04 
042441 CD      6078 CALL    POP5
042442 EC 
042443 2C 
042444 04 
042445 F1      6079 POP     AF
042446 CD      6080 CALL    FMUL
042447 3E 
042448 23 
042449 04 
04244A C3      6081 JP      EXP0
04244B 89 
04244C 26 
04244D 04 
               6082 ;
               6083 ;Integer and floating-point compare.
               6084 ;Result is TRUE (-1) or FALSE (0).
               6085 ;
04244E CD      6086 FLT:			CALL    FCP
04244F 5D 
042450 2C 
042451 04 
042452 18      6087 JR      ILT1
042453 04 
042454 CD      6088 ILT:			CALL    ICP
042455 4F 
042456 2C 
042457 04 
042458 D0      6089 ILT1:			RET     NC
042459 18      6090 JR      TRUE_FP
04245A 42 
               6091 ;
04245B CD      6092 FGT:			CALL    FCP
04245C 5D 
04245D 2C 
04245E 04 
04245F 18      6093 JR      IGT1
042460 04 
042461 CD      6094 IGT:			CALL    ICP
042462 4F 
042463 2C 
042464 04 
042465 C8      6095 IGT1:			RET     Z
042466 D8      6096 RET     C
042467 18      6097 JR      TRUE_FP
042468 34 
               6098 ;
042469 CD      6099 FGE:			CALL    FCP
04246A 5D 
04246B 2C 
04246C 04 
04246D 18      6100 JR      IGE1
04246E 04 
04246F CD      6101 IGE:			CALL    ICP
042470 4F 
042471 2C 
042472 04 
042473 D8      6102 IGE1:			RET     C
042474 18      6103 JR      TRUE_FP
042475 27 
               6104 ;
042476 CD      6105 FLE:			CALL    FCP
042477 5D 
042478 2C 
042479 04 
04247A 18      6106 JR      ILE1
04247B 04 
04247C CD      6107 ILE:			CALL    ICP
04247D 4F 
04247E 2C 
04247F 04 
042480 28      6108 ILE1:			JR      Z,TRUE_FP
042481 1B 
042482 D0      6109 RET     NC
042483 18      6110 JR      TRUE_FP
042484 18 
               6111 ;
042485 CD      6112 FNE:			CALL    FCP
042486 5D 
042487 2C 
042488 04 
042489 18      6113 JR      INE1
04248A 04 
04248B CD      6114 INE:			CALL    ICP
04248C 4F 
04248D 2C 
04248E 04 
04248F C8      6115 INE1:			RET     Z
042490 18      6116 JR      TRUE_FP
042491 0B 
               6117 ;
042492 CD      6118 FEQ:			CALL    FCP
042493 5D 
042494 2C 
042495 04 
042496 18      6119 JR      IEQ1
042497 04 
042498 CD      6120 IEQ:			CALL    ICP
042499 4F 
04249A 2C 
04249B 04 
04249C C0      6121 IEQ1:			RET     NZ
04249D 21      6122 TRUE_FP:			LD      HL,-1
04249E FF 
04249F FF 
0424A0 FF 
0424A1 D9      6123 EXX
0424A2 21      6124 LD      HL,-1
0424A3 FF 
0424A4 FF 
0424A5 FF 
0424A6 D9      6125 EXX
0424A7 AF      6126 XOR     A
0424A8 4F      6127 LD      C,A
0424A9 C9      6128 RET
               6129 ;
               6130 ;FUNCTIONS:
               6131 ;
               6132 ;Result returned in HLH'L'C (floating point)
               6133 ;Result returned in HLH'L' (C=0) (integer)
               6134 ;All registers except IY destroyed.
               6135 ;
               6136 ;ABS - Absolute value
               6137 ;Result is numeric, variable type.
               6138 ;
0424AA CB      6139 ABSV_FP:			BIT     7,H
0424AB 7C 
0424AC C8      6140 RET     Z               ;POSITIVE/ZERO
0424AD 0D      6141 DEC     C
0424AE 0C      6142 INC     C
0424AF CA      6143 JP      Z,NEGATE        ;INTEGER
0424B0 0A 
0424B1 2B 
0424B2 04 
0424B3 CB      6144 RES     7,H
0424B4 BC 
0424B5 C9      6145 RET
               6146 ;
               6147 ;NOT - Complement integer.
               6148 ;Result is integer numeric.
               6149 ;
0424B6 CD      6150 NOTK_FP:			CALL    SFIX_FP
0424B7 FA 
0424B8 2A 
0424B9 04 
0424BA 7C      6151 LD      A,H
0424BB 2F      6152 CPL
0424BC 67      6153 LD      H,A
0424BD 7D      6154 LD      A,L
0424BE 2F      6155 CPL
0424BF 6F      6156 LD      L,A
0424C0 D9      6157 EXX
0424C1 7C      6158 LD      A,H
0424C2 2F      6159 CPL
0424C3 67      6160 LD      H,A
0424C4 7D      6161 LD      A,L
0424C5 2F      6162 CPL
0424C6 6F      6163 LD      L,A
0424C7 D9      6164 EXX
0424C8 AF      6165 XOR     A               ;NUMERIC MARKER
0424C9 C9      6166 RET
               6167 ;
               6168 ;PI - Return PI (3.141592654)
               6169 ;Result is floating-point numeric.
               6170 ;
0424CA 21      6171 PI_FP:			LD      HL,490FH
0424CB 0F 
0424CC 49 
0424CD 00 
0424CE D9      6172 EXX
0424CF 21      6173 LD      HL,0DAA2H
0424D0 A2 
0424D1 DA 
0424D2 00 
0424D3 D9      6174 EXX
0424D4 0E      6175 LD      C,81H
0424D5 81 
0424D6 AF      6176 XOR     A               ;NUMERIC MARKER
0424D7 C9      6177 RET
               6178 ;
               6179 ;DEG - Convert radians to degrees
               6180 ;Result is floating-point numeric.
               6181 ;
0424D8 CD      6182 DEG_FP:			CALL    FPI180
0424D9 EC 
0424DA 24 
0424DB 04 
0424DC CD      6183 CALL    FMUL
0424DD 3E 
0424DE 23 
0424DF 04 
0424E0 AF      6184 XOR     A
0424E1 C9      6185 RET
               6186 ;
               6187 ;RAD - Convert degrees to radians
               6188 ;Result is floating-point numeric.
               6189 ;
0424E2 CD      6190 RAD_FP:			CALL    FPI180
0424E3 EC 
0424E4 24 
0424E5 04 
0424E6 CD      6191 CALL    FDIV
0424E7 95 
0424E8 22 
0424E9 04 
0424EA AF      6192 XOR     A
0424EB C9      6193 RET
               6194 ;
               6195 ;180/PI
               6196 ;
0424EC CD      6197 FPI180:			CALL    SFLOAT_FP
0424ED D6 
0424EE 2B 
0424EF 04 
0424F0 11      6198 LD      DE,652EH
0424F1 2E 
0424F2 65 
0424F3 00 
0424F4 D9      6199 EXX
0424F5 11      6200 LD      DE,0E0D3H
0424F6 D3 
0424F7 E0 
0424F8 00 
0424F9 D9      6201 EXX
0424FA 06      6202 LD      B,85H
0424FB 85 
0424FC C9      6203 RET
               6204 ;
               6205 ;SGN - Return -1, 0 or +1
               6206 ;Result is integer numeric.
               6207 ;
0424FD CD      6208 SGN_FP:			CALL    TEST_FP
0424FE 2F 
0424FF 2C 
042500 04 
042501 B1      6209 OR      C
042502 C8      6210 RET     Z               ;ZERO
042503 CB      6211 BIT     7,H
042504 7C 
042505 C2      6212 JP      NZ,TRUE_FP         ;-1
042506 9D 
042507 24 
042508 04 
042509 CD      6213 CALL    ZERO_FP
04250A 53 
04250B 2C 
04250C 04 
04250D C3      6214 JP      ADD1_FP            ;1
04250E EF 
04250F 2B 
042510 04 
               6215 ;
               6216 ;VAL - Return numeric value of string.
               6217 ;Input: ASCII string at IX
               6218 ;Result is variable type numeric.
               6219 ;
042511 CD      6220 VAL_FP:			CALL    SIGNQ
042512 6D 
042513 2E 
042514 04 
042515 F5      6221 PUSH    AF
042516 CD      6222 CALL    CON_FP
042517 1D 
042518 2A 
042519 04 
04251A F1      6223 POP     AF
04251B FE      6224 CP      '-'
04251C 2D 
04251D 3E      6225 LD      A,0             ;NUMERIC MARKER
04251E 00 
04251F C0      6226 RET     NZ
042520 0D      6227 DEC     C
042521 0C      6228 INC     C
042522 CA      6229 JP      Z,NEGATE        ;ZERO/INTEGER
042523 0A 
042524 2B 
042525 04 
042526 7C      6230 LD      A,H
042527 EE      6231 XOR     80H             ;CHANGE SIGN (FP)
042528 80 
042529 67      6232 LD      H,A
04252A AF      6233 XOR     A
04252B C9      6234 RET
               6235 ;
               6236 ;INT - Floor function
               6237 ;Result is integer numeric.
               6238 ;
04252C 0D      6239 INT_FP_:			DEC     C
04252D 0C      6240 INC     C
04252E C8      6241 RET     Z               ;ZERO/INTEGER
04252F 3E      6242 LD      A,159
042530 9F 
042531 44      6243 LD      B,H             ;B7=SIGN BIT
042532 CD      6244 CALL    FIX
042533 DB 
042534 2A 
042535 04 
042536 08      6245 EX      AF,AF'
042537 A0      6246 AND     B
042538 FC      6247 CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042539 EF 
04253A 2B 
04253B 04 
04253C 78      6248 LD      A,B
04253D B7      6249 OR      A
04253E FC      6250 CALL    M,NEGATE
04253F 0A 
042540 2B 
042541 04 
042542 AF      6251 XOR     A
042543 4F      6252 LD      C,A
042544 C9      6253 RET
               6254 ;
               6255 ;SQR - square root
               6256 ;Result is floating-point numeric.
               6257 ;
042545 CD      6258 SQR_FP:			CALL    SFLOAT_FP
042546 D6 
042547 2B 
042548 04 
042549 CB      6259 SQR0:			BIT     7,H
04254A 7C 
04254B 3E      6260 LD      A,NGROOT
04254C 15 
04254D C2      6261 JP      NZ,ERROR_FP_        ;"-ve root"
04254E AD 
04254F 20 
042550 04 
042551 0D      6262 DEC     C
042552 0C      6263 INC     C
042553 C8      6264 RET     Z               ;ZERO
042554 CB      6265 SET     7,H             ;IMPLIED 1
042555 FC 
042556 CB      6266 BIT     0,C
042557 41 
042558 CC      6267 CALL    Z,DIV2          ;MAKE EXPONENT ODD
042559 0F 
04255A 2C 
04255B 04 
04255C 79      6268 LD      A,C
04255D D6      6269 SUB     80H
04255E 80 
04255F CB      6270 SRA     A               ;HALVE EXPONENT
042560 2F 
042561 C6      6271 ADD     A,80H
042562 80 
042563 4F      6272 LD      C,A
042564 C5      6273 PUSH    BC              ;SAVE EXPONENT
042565 EB      6274 EX      DE,HL
042566 21      6275 LD      HL,0
042567 00 
042568 00 
042569 00 
04256A 44      6276 LD      B,H
04256B 4D      6277 LD      C,L
04256C D9      6278 EXX
04256D EB      6279 EX      DE,HL
04256E 21      6280 LD      HL,0
04256F 00 
042570 00 
042571 00 
042572 44      6281 LD      B,H
042573 4D      6282 LD      C,L
042574 3E      6283 LD      A,-31
042575 E1 
042576 CD      6284 CALL    SQRA            ;ROOT
042577 05 
042578 2E 
042579 04 
04257A D9      6285 EXX
04257B CB      6286 BIT     7,B
04257C 78 
04257D D9      6287 EXX
04257E CC      6288 CALL    Z,SQRA          ;NORMALISE & INC A
04257F 05 
042580 2E 
042581 04 
042582 CD      6289 CALL    SQRB
042583 46 
042584 2E 
042585 04 
042586 B7      6290 OR      A               ;CLEAR CARRY
042587 CD      6291 CALL    DIVB
042588 B3 
042589 2D 
04258A 04 
04258B CB      6292 RR      E               ;LSB TO CARRY
04258C 1B 
04258D 60      6293 LD      H,B
04258E 69      6294 LD      L,C
04258F D9      6295 EXX
042590 60      6296 LD      H,B
042591 69      6297 LD      L,C
042592 DC      6298 CALL    C,ADD1_FP          ;ROUND UP
042593 EF 
042594 2B 
042595 04 
042596 C1      6299 POP     BC              ;RESTORE EXPONENT
042597 DC      6300 CALL    C,INCC
042598 1C 
042599 2C 
04259A 04 
04259B 1F      6301 RRA
04259C 9F      6302 SBC     A,A
04259D 81      6303 ADD     A,C
04259E 4F      6304 LD      C,A
04259F CB      6305 RES     7,H             ;POSITIVE
0425A0 BC 
0425A1 AF      6306 XOR     A
0425A2 C9      6307 RET
               6308 ;
               6309 ;TAN - Tangent function
               6310 ;Result is floating-point numeric.
               6311 ;
0425A3 CD      6312 TAN_FP:			CALL    SFLOAT_FP
0425A4 D6 
0425A5 2B 
0425A6 04 
0425A7 CD      6313 CALL    PUSH5
0425A8 E3 
0425A9 2C 
0425AA 04 
0425AB CD      6314 CALL    COS0
0425AC CD 
0425AD 25 
0425AE 04 
0425AF CD      6315 CALL    POP5
0425B0 EC 
0425B1 2C 
0425B2 04 
0425B3 CD      6316 CALL    PUSH5
0425B4 E3 
0425B5 2C 
0425B6 04 
0425B7 CD      6317 CALL    SWAP_FP
0425B8 07 
0425B9 2C 
0425BA 04 
0425BB CD      6318 CALL    SIN0
0425BC DA 
0425BD 25 
0425BE 04 
0425BF CD      6319 CALL    POP5
0425C0 EC 
0425C1 2C 
0425C2 04 
0425C3 CD      6320 CALL    FDIV
0425C4 95 
0425C5 22 
0425C6 04 
0425C7 AF      6321 XOR     A               ;NUMERIC MARKER
0425C8 C9      6322 RET
               6323 ;
               6324 ;COS - Cosine function
               6325 ;Result is floating-point numeric.
               6326 ;
0425C9 CD      6327 COS_FP:			CALL    SFLOAT_FP
0425CA D6 
0425CB 2B 
0425CC 04 
0425CD CD      6328 COS0:			CALL    SCALE
0425CE 32 
0425CF 2B 
0425D0 04 
0425D1 1C      6329 INC     E
0425D2 1C      6330 INC     E
0425D3 7B      6331 LD      A,E
0425D4 18      6332 JR      SIN1
0425D5 10 
               6333 ;
               6334 ;SIN - Sine function
               6335 ;Result is floating-point numeric.
               6336 ;
0425D6 CD      6337 SIN_FP:			CALL    SFLOAT_FP
0425D7 D6 
0425D8 2B 
0425D9 04 
0425DA E5      6338 SIN0:			PUSH    HL              ;H7=SIGN
0425DB CD      6339 CALL    SCALE
0425DC 32 
0425DD 2B 
0425DE 04 
0425DF F1      6340 POP     AF
0425E0 07      6341 RLCA
0425E1 07      6342 RLCA
0425E2 07      6343 RLCA
0425E3 E6      6344 AND     4
0425E4 04 
0425E5 AB      6345 XOR     E
0425E6 F5      6346 SIN1:			PUSH    AF              ;OCTANT
0425E7 CB      6347 RES     7,H
0425E8 BC 
0425E9 1F      6348 RRA
0425EA CD      6349 CALL    PIBY4
0425EB 78 
0425EC 26 
0425ED 04 
0425EE DC      6350 CALL    C,RSUB          ;X=(PI/4)-X
0425EF 19 
0425F0 22 
0425F1 04 
0425F2 F1      6351 POP     AF
0425F3 F5      6352 PUSH    AF
0425F4 E6      6353 AND     3
0425F5 03 
0425F6 E2      6354 JP      PO,SIN2         ;USE COSINE APPROX.
0425F7 2F 
0425F8 26 
0425F9 04 
0425FA CD      6355 CALL    PUSH5           ;SAVE X
0425FB E3 
0425FC 2C 
0425FD 04 
0425FE CD      6356 CALL    SQUARE          ;PUSH X*X
0425FF DB 
042600 2C 
042601 04 
042602 CD      6357 CALL    POLY
042603 20 
042604 2D 
042605 04 
042606 B7      6358 DW	0A8B7H          ;a(8)
042607 A8 
042608 11      6359 DW	3611H
042609 36 
04260A 6D      6360 DB	6DH
04260B 26      6361 DW	0DE26H          ;a(6)
04260C DE 
04260D 05      6362 DW	0D005H
04260E D0 
04260F 73      6363 DB	73H
042610 C0      6364 DW	80C0H           ;a(4)
042611 80 
042612 88      6365 DW	888H
042613 08 
042614 79      6366 DB	79H
042615 9D      6367 DW	0AA9DH          ;a(2)
042616 AA 
042617 AA      6368 DW	0AAAAH
042618 AA 
042619 7D      6369 DB	7DH
04261A 00      6370 DW	0               ;a(0)
04261B 00 
04261C 00      6371 DW	0
04261D 00 
04261E 80      6372 DB	80H
04261F CD      6373 CALL    POP5
042620 EC 
042621 2C 
042622 04 
042623 CD      6374 CALL    POP5
042624 EC 
042625 2C 
042626 04 
042627 CD      6375 CALL    FMUL
042628 3E 
042629 23 
04262A 04 
04262B C3      6376 JP      SIN3
04262C 54 
04262D 26 
04262E 04 
               6377 ;
04262F CD      6378 SIN2:			CALL    SQUARE          ;PUSH X*X
042630 DB 
042631 2C 
042632 04 
042633 CD      6379 CALL    POLY
042634 20 
042635 2D 
042636 04 
042637 71      6380 DW	0D571H          ;b(8)
042638 D5 
042639 78      6381 DW	4C78H
04263A 4C 
04263B 70      6382 DB	70H
04263C AF      6383 DW	94AFH           ;b(6)
04263D 94 
04263E 03      6384 DW	0B603H
04263F B6 
042640 76      6385 DB	76H
042641 C8      6386 DW	9CC8H           ;b(4)
042642 9C 
042643 AA      6387 DW	2AAAH
042644 2A 
042645 7B      6388 DB	7BH
042646 DD      6389 DW	0FFDDH          ;b(2)
042647 FF 
042648 FF      6390 DW	0FFFFH
042649 FF 
04264A 7E      6391 DB	7EH
04264B 00      6392 DW	0               ;b(0)
04264C 00 
04264D 00      6393 DW	0
04264E 00 
04264F 80      6394 DB	80H
042650 CD      6395 CALL    POP5
042651 EC 
042652 2C 
042653 04 
042654 F1      6396 SIN3:			POP     AF
042655 E6      6397 AND     4
042656 04 
042657 C8      6398 RET     Z
042658 0D      6399 DEC     C
042659 0C      6400 INC     C
04265A C8      6401 RET     Z               ;ZERO
04265B CB      6402 SET     7,H             ;MAKE NEGATIVE
04265C FC 
04265D C9      6403 RET
               6404 ;
               6405 ;Floating-point one:
               6406 ;
04265E 21      6407 FONE_FP:			LD      HL,0
04265F 00 
042660 00 
042661 00 
042662 D9      6408 EXX
042663 21      6409 LD      HL,0
042664 00 
042665 00 
042666 00 
042667 D9      6410 EXX
042668 0E      6411 LD      C,80H
042669 80 
04266A C9      6412 RET
               6413 ;
04266B 11      6414 DONE:			LD      DE,0
04266C 00 
04266D 00 
04266E 00 
04266F D9      6415 EXX
042670 11      6416 LD      DE,0
042671 00 
042672 00 
042673 00 
042674 D9      6417 EXX
042675 06      6418 LD      B,80H
042676 80 
042677 C9      6419 RET
               6420 ;
042678 11      6421 PIBY4:			LD      DE,490FH
042679 0F 
04267A 49 
04267B 00 
04267C D9      6422 EXX
04267D 11      6423 LD      DE,0DAA2H
04267E A2 
04267F DA 
042680 00 
042681 D9      6424 EXX
042682 06      6425 LD      B,7FH
042683 7F 
042684 C9      6426 RET
               6427 ;
               6428 ;EXP - Exponential function
               6429 ;Result is floating-point numeric.
               6430 ;
042685 CD      6431 EXP_FP:			CALL    SFLOAT_FP
042686 D6 
042687 2B 
042688 04 
042689 CD      6432 EXP0:			CALL    LN2             ;LN(2)
04268A 16 
04268B 27 
04268C 04 
04268D D9      6433 EXX
04268E 1D      6434 DEC     E
04268F 01      6435 LD      BC,0D1CFH       ;0.6931471805599453
042690 CF 
042691 D1 
042692 00 
042693 D9      6436 EXX
042694 E5      6437 PUSH    HL              ;H7=SIGN
042695 CD      6438 CALL    MOD48           ;"MODULUS"
042696 45 
042697 2B 
042698 04 
042699 F1      6439 POP     AF
04269A CB      6440 BIT     7,E
04269B 7B 
04269C 28      6441 JR      Z,EXP1
04269D 0B 
04269E 17      6442 RLA
04269F DA      6443 JP      C,ZERO_FP
0426A0 53 
0426A1 2C 
0426A2 04 
0426A3 3E      6444 LD      A,EXPRNG
0426A4 18 
0426A5 C3      6445 JP      ERROR_FP_           ;"Exp range"
0426A6 AD 
0426A7 20 
0426A8 04 
               6446 ;
0426A9 E6      6447 EXP1:			AND     80H
0426AA 80 
0426AB B3      6448 OR      E
0426AC F5      6449 PUSH    AF              ;INTEGER PART
0426AD CB      6450 RES     7,H
0426AE BC 
0426AF CD      6451 CALL    PUSH5           ;PUSH X*LN(2)
0426B0 E3 
0426B1 2C 
0426B2 04 
0426B3 CD      6452 CALL    POLY
0426B4 20 
0426B5 2D 
0426B6 04 
0426B7 72      6453 DW	4072H           ;a(7)
0426B8 40 
0426B9 2E      6454 DW	942EH
0426BA 94 
0426BB 73      6455 DB	73H
0426BC 65      6456 DW	6F65H           ;a(6)
0426BD 6F 
0426BE 4F      6457 DW	2E4FH
0426BF 2E 
0426C0 76      6458 DB	76H
0426C1 37      6459 DW	6D37H           ;a(5)
0426C2 6D 
0426C3 02      6460 DW	8802H
0426C4 88 
0426C5 79      6461 DB	79H
0426C6 12      6462 DW	0E512H          ;a(4)
0426C7 E5 
0426C8 A0      6463 DW	2AA0H
0426C9 2A 
0426CA 7B      6464 DB	7BH
0426CB 14      6465 DW	4F14H           ;a(3)
0426CC 4F 
0426CD AA      6466 DW	0AAAAH
0426CE AA 
0426CF 7D      6467 DB	7DH
0426D0 56      6468 DW	0FD56H          ;a(2)
0426D1 FD 
0426D2 FF      6469 DW	7FFFH
0426D3 7F 
0426D4 7E      6470 DB	7EH
0426D5 FE      6471 DW	0FFFEH          ;a(1)
0426D6 FF 
0426D7 FF      6472 DW	0FFFFH
0426D8 FF 
0426D9 7F      6473 DB	7FH
0426DA 00      6474 DW	0               ;a(0)
0426DB 00 
0426DC 00      6475 DW	0
0426DD 00 
0426DE 80      6476 DB	80H
0426DF CD      6477 CALL    POP5
0426E0 EC 
0426E1 2C 
0426E2 04 
0426E3 F1      6478 POP     AF
0426E4 F5      6479 PUSH    AF
0426E5 F4      6480 CALL    P,RECIP         ;X=1/X
0426E6 0A 
0426E7 27 
0426E8 04 
0426E9 F1      6481 POP     AF
0426EA F2      6482 JP      P,EXP4
0426EB F2 
0426EC 26 
0426ED 04 
0426EE E6      6483 AND     7FH
0426EF 7F 
0426F0 ED      6484 NEG
0426F1 44 
0426F2 C6      6485 EXP4:			ADD     A,80H
0426F3 80 
0426F4 81      6486 ADD     A,C
0426F5 38      6487 JR      C,EXP2
0426F6 06 
0426F7 F2      6488 JP      P,ZERO_FP          ;UNDERFLOW
0426F8 53 
0426F9 2C 
0426FA 04 
0426FB 18      6489 JR      EXP3
0426FC 04 
0426FD FA      6490 EXP2:			JP      M,OFLOW         ;OVERFLOW
0426FE 1E 
0426FF 2C 
042700 04 
042701 C6      6491 EXP3:			ADD     A,80H
042702 80 
042703 CA      6492 JP      Z,ZERO_FP
042704 53 
042705 2C 
042706 04 
042707 4F      6493 LD      C,A
042708 AF      6494 XOR     A               ;NUMERIC MARKER
042709 C9      6495 RET
               6496 ;
04270A CD      6497 RECIP:			CALL    DONE
04270B 6B 
04270C 26 
04270D 04 
04270E CD      6498 RDIV:			CALL    SWAP_FP
04270F 07 
042710 2C 
042711 04 
042712 C3      6499 JP      FDIV            ;RECIPROCAL
042713 95 
042714 22 
042715 04 
               6500 ;
042716 11      6501 LN2:			LD      DE,3172H        ;LN(2)
042717 72 
042718 31 
042719 00 
04271A D9      6502 EXX
04271B 11      6503 LD      DE,17F8H
04271C F8 
04271D 17 
04271E 00 
04271F D9      6504 EXX
042720 06      6505 LD      B,7FH
042721 7F 
042722 C9      6506 RET
               6507 ;
               6508 ;LN - Natural log.
               6509 ;Result is floating-point numeric.
               6510 ;
042723 CD      6511 LN_FP:			CALL    SFLOAT_FP
042724 D6 
042725 2B 
042726 04 
042727 3E      6512 LN0:			LD      A,LOGRNG
042728 16 
042729 CB      6513 BIT     7,H
04272A 7C 
04272B C2      6514 JP      NZ,ERROR_FP_        ;"Log range"
04272C AD 
04272D 20 
04272E 04 
04272F 0C      6515 INC     C
042730 0D      6516 DEC     C
042731 CA      6517 JP      Z,ERROR_FP_
042732 AD 
042733 20 
042734 04 
042735 11      6518 LD      DE,3504H        ;SQR(2)
042736 04 
042737 35 
042738 00 
042739 D9      6519 EXX
04273A 11      6520 LD      DE,0F333H       ;1.41421356237
04273B 33 
04273C F3 
04273D 00 
04273E D9      6521 EXX
04273F CD      6522 CALL    ICP0            ;MANTISSA>SQR(2)?
042740 66 
042741 2C 
042742 04 
042743 79      6523 LD      A,C             ;EXPONENT
042744 0E      6524 LD      C,80H           ;1 <= X < 2
042745 80 
042746 38      6525 JR      C,LN4
042747 02 
042748 0D      6526 DEC     C
042749 3C      6527 INC     A
04274A F5      6528 LN4:			PUSH    AF              ;SAVE EXPONENT
04274B CD      6529 CALL    RATIO           ;X=(X-1)/(X+1)
04274C F8 
04274D 2C 
04274E 04 
04274F CD      6530 CALL    PUSH5
042750 E3 
042751 2C 
042752 04 
042753 CD      6531 CALL    SQUARE          ;PUSH X*X
042754 DB 
042755 2C 
042756 04 
042757 CD      6532 CALL    POLY
042758 20 
042759 2D 
04275A 04 
04275B 48      6533 DW	0CC48H          ;a(9)
04275C CC 
04275D FB      6534 DW	74FBH
04275E 74 
04275F 7D      6535 DB	7DH
042760 AF      6536 DW	0AEAFH          ;a(7)
042761 AE 
042762 FF      6537 DW	11FFH
042763 11 
042764 7E      6538 DB	7EH
042765 8C      6539 DW	0D98CH          ;a(5)
042766 D9 
042767 CD      6540 DW	4CCDH
042768 4C 
042769 7E      6541 DB	7EH
04276A E3      6542 DW	0A9E3H          ;a(3)
04276B A9 
04276C AA      6543 DW	2AAAH
04276D 2A 
04276E 7F      6544 DB	7FH
04276F 00      6545 DW	0               ;a(1)
042770 00 
042771 00      6546 DW	0
042772 00 
042773 81      6547 DB	81H
042774 CD      6548 CALL    POP5
042775 EC 
042776 2C 
042777 04 
042778 CD      6549 CALL    POP5
042779 EC 
04277A 2C 
04277B 04 
04277C CD      6550 CALL    FMUL
04277D 3E 
04277E 23 
04277F 04 
042780 F1      6551 POP     AF              ;EXPONENT
042781 CD      6552 CALL    PUSH5
042782 E3 
042783 2C 
042784 04 
042785 08      6553 EX      AF,AF'
042786 CD      6554 CALL    ZERO_FP
042787 53 
042788 2C 
042789 04 
04278A 08      6555 EX      AF,AF'
04278B D6      6556 SUB     80H
04278C 80 
04278D 28      6557 JR      Z,LN3
04278E 1F 
04278F 30      6558 JR      NC,LN1
042790 02 
042791 2F      6559 CPL
042792 3C      6560 INC     A
042793 67      6561 LN1:			LD      H,A
042794 0E      6562 LD      C,87H
042795 87 
042796 F5      6563 PUSH    AF
042797 CD      6564 CALL    FLOAT_
042798 B6 
042799 2B 
04279A 04 
04279B CB      6565 RES     7,H
04279C BC 
04279D CD      6566 CALL    LN2
04279E 16 
04279F 27 
0427A0 04 
0427A1 CD      6567 CALL    FMUL
0427A2 3E 
0427A3 23 
0427A4 04 
0427A5 F1      6568 POP     AF
0427A6 30      6569 JR      NC,LN3
0427A7 06 
0427A8 FA      6570 JP      M,LN3
0427A9 AE 
0427AA 27 
0427AB 04 
0427AC CB      6571 SET     7,H
0427AD FC 
0427AE CD      6572 LN3:			CALL    POP5
0427AF EC 
0427B0 2C 
0427B1 04 
0427B2 CD      6573 CALL    FADD
0427B3 2C 
0427B4 22 
0427B5 04 
0427B6 AF      6574 XOR     A
0427B7 C9      6575 RET
               6576 ;
               6577 ;LOG - base-10 logarithm.
               6578 ;Result is floating-point numeric.
               6579 ;
0427B8 CD      6580 LOG_FP:			CALL    LN_FP
0427B9 23 
0427BA 27 
0427BB 04 
0427BC 11      6581 LD      DE,5E5BH        ;LOG(e)
0427BD 5B 
0427BE 5E 
0427BF 00 
0427C0 D9      6582 EXX
0427C1 11      6583 LD      DE,0D8A9H
0427C2 A9 
0427C3 D8 
0427C4 00 
0427C5 D9      6584 EXX
0427C6 06      6585 LD      B,7EH
0427C7 7E 
0427C8 CD      6586 CALL    FMUL
0427C9 3E 
0427CA 23 
0427CB 04 
0427CC AF      6587 XOR     A
0427CD C9      6588 RET
               6589 ;
               6590 ;ASN - Arc-sine
               6591 ;Result is floating-point numeric.
               6592 ;
0427CE CD      6593 ASN_FP:			CALL    SFLOAT_FP
0427CF D6 
0427D0 2B 
0427D1 04 
0427D2 CD      6594 CALL    PUSH5
0427D3 E3 
0427D4 2C 
0427D5 04 
0427D6 CD      6595 CALL    COPY_
0427D7 D3 
0427D8 2C 
0427D9 04 
0427DA CD      6596 CALL    FMUL
0427DB 3E 
0427DC 23 
0427DD 04 
0427DE CD      6597 CALL    DONE
0427DF 6B 
0427E0 26 
0427E1 04 
0427E2 CD      6598 CALL    RSUB
0427E3 19 
0427E4 22 
0427E5 04 
0427E6 CD      6599 CALL    SQR0
0427E7 49 
0427E8 25 
0427E9 04 
0427EA CD      6600 CALL    POP5
0427EB EC 
0427EC 2C 
0427ED 04 
0427EE 0C      6601 INC     C
0427EF 0D      6602 DEC     C
0427F0 3E      6603 LD      A,2
0427F1 02 
0427F2 D5      6604 PUSH    DE
0427F3 CA      6605 JP      Z,ACS1
0427F4 78 
0427F5 28 
0427F6 04 
0427F7 D1      6606 POP     DE
0427F8 CD      6607 CALL    RDIV
0427F9 0E 
0427FA 27 
0427FB 04 
0427FC 18      6608 JR      ATN0
0427FD 04 
               6609 ;
               6610 ;ATN - arc-tangent
               6611 ;Result is floating-point numeric.
               6612 ;
0427FE CD      6613 ATN_FP:			CALL    SFLOAT_FP
0427FF D6 
042800 2B 
042801 04 
042802 E5      6614 ATN0:			PUSH    HL              ;SAVE SIGN
042803 CB      6615 RES     7,H
042804 BC 
042805 11      6616 LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
042806 13 
042807 54 
042808 00 
042809 D9      6617 EXX
04280A 11      6618 LD      DE,0CCD0H
04280B D0 
04280C CC 
04280D 00 
04280E D9      6619 EXX
04280F 06      6620 LD      B,7EH
042810 7E 
042811 CD      6621 CALL    FCP0            ;COMPARE
042812 63 
042813 2C 
042814 04 
042815 06      6622 LD      B,0
042816 00 
042817 38      6623 JR      C,ATN2
042818 22 
042819 11      6624 LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
04281A 82 
04281B 1A 
04281C 00 
04281D D9      6625 EXX
04281E 11      6626 LD      DE,799AH
04281F 9A 
042820 79 
042821 00 
042822 D9      6627 EXX
042823 06      6628 LD      B,81H
042824 81 
042825 CD      6629 CALL    FCP0            ;COMPARE
042826 63 
042827 2C 
042828 04 
042829 38      6630 JR      C,ATN1
04282A 0A 
04282B CD      6631 CALL    RECIP           ;X=1/X
04282C 0A 
04282D 27 
04282E 04 
04282F 06      6632 LD      B,2
042830 02 
042831 C3      6633 JP      ATN2
042832 3B 
042833 28 
042834 04 
042835 CD      6634 ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042836 F8 
042837 2C 
042838 04 
042839 06      6635 LD      B,1
04283A 01 
04283B C5      6636 ATN2:			PUSH    BC              ;SAVE FLAG
04283C CD      6637 CALL    PUSH5
04283D E3 
04283E 2C 
04283F 04 
042840 CD      6638 CALL    SQUARE          ;PUSH X*X
042841 DB 
042842 2C 
042843 04 
042844 CD      6639 CALL    POLY
042845 20 
042846 2D 
042847 04 
042848 35      6640 DW	0F335H          ;a(13)
042849 F3 
04284A D8      6641 DW	37D8H
04284B 37 
04284C 7B      6642 DB	7BH
04284D 91      6643 DW	6B91H           ;a(11)
04284E 6B 
04284F B9      6644 DW	0AAB9H
042850 AA 
042851 7C      6645 DB	7CH
042852 DE      6646 DW	41DEH           ;a(9)
042853 41 
042854 97      6647 DW	6197H
042855 61 
042856 7C      6648 DB	7CH
042857 7B      6649 DW	9D7BH           ;a(7)
042858 9D 
042859 37      6650 DW	9237H
04285A 92 
04285B 7D      6651 DB	7DH
04285C 5A      6652 DW	2A5AH           ;a(5)
04285D 2A 
04285E CC      6653 DW	4CCCH
04285F 4C 
042860 7D      6654 DB	7DH
042861 5C      6655 DW	0A95CH          ;a(3)
042862 A9 
042863 AA      6656 DW	0AAAAH
042864 AA 
042865 7E      6657 DB	7EH
042866 00      6658 DW	0               ;a(1)
042867 00 
042868 00      6659 DW	0
042869 00 
04286A 80      6660 DB	80H
04286B CD      6661 CALL    POP5
04286C EC 
04286D 2C 
04286E 04 
04286F CD      6662 CALL    POP5
042870 EC 
042871 2C 
042872 04 
042873 CD      6663 CALL    FMUL
042874 3E 
042875 23 
042876 04 
042877 F1      6664 POP     AF
042878 CD      6665 ACS1:			CALL    PIBY4           ;PI/4
042879 78 
04287A 26 
04287B 04 
04287C 1F      6666 RRA
04287D F5      6667 PUSH    AF
04287E DC      6668 CALL    C,FADD
04287F 2C 
042880 22 
042881 04 
042882 F1      6669 POP     AF
042883 04      6670 INC     B
042884 1F      6671 RRA
042885 DC      6672 CALL    C,RSUB
042886 19 
042887 22 
042888 04 
042889 F1      6673 POP     AF
04288A B7      6674 OR      A
04288B F0      6675 RET     P
04288C CB      6676 SET     7,H             ;MAKE NEGATIVE
04288D FC 
04288E AF      6677 XOR     A
04288F C9      6678 RET
               6679 ;
               6680 ;ACS - Arc cosine=PI/2-ASN.
               6681 ;Result is floating point numeric.
               6682 ;
042890 CD      6683 ACS_FP:			CALL    ASN_FP
042891 CE 
042892 27 
042893 04 
042894 3E      6684 LD      A,2
042895 02 
042896 F5      6685 PUSH    AF
042897 18      6686 JR      ACS1
042898 DF 
               6687 ;
               6688 ;Function STR - convert numeric value to ASCII string.
               6689 ;   Inputs: HLH'L'C = integer or floating-point number
               6690 ;           DE = address at which to store string
               6691 ;           IX = address of @% format control
               6692 ;  Outputs: String stored, with NUL terminator
               6693 ;
               6694 ;First normalise for decimal output:
               6695 ;
042899 CD      6696 STR_FP:			CALL    SFLOAT_FP
04289A D6 
04289B 2B 
04289C 04 
04289D 06      6697 LD      B,0             ;DEFAULT PT. POSITION
04289E 00 
04289F CB      6698 BIT     7,H             ;NEGATIVE?
0428A0 7C 
0428A1 28      6699 JR      Z,STR10
0428A2 06 
0428A3 CB      6700 RES     7,H
0428A4 BC 
0428A5 3E      6701 LD      A,'-'
0428A6 2D 
0428A7 12      6702 LD      (DE),A          ;STORE SIGN
0428A8 13      6703 INC     DE
0428A9 AF      6704 STR10:			XOR     A               ;CLEAR A
0428AA B9      6705 CP      C
0428AB 28      6706 JR      Z,STR02          ;ZERO
0428AC 4E 
0428AD D5      6707 PUSH    DE              ;SAVE TEXT POINTER
0428AE 78      6708 LD      A,B
0428AF F5      6709 STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B0 79      6710 LD      A,C             ;BINARY EXPONENT
0428B1 FE      6711 CP      161
0428B2 A1 
0428B3 30      6712 JR      NC,STR14
0428B4 1C 
0428B5 FE      6713 CP      155
0428B6 9B 
0428B7 30      6714 JR      NC,STR15
0428B8 29 
0428B9 2F      6715 CPL
0428BA FE      6716 CP      225
0428BB E1 
0428BC 38      6717 JR      C,STR13
0428BD 02 
0428BE 3E      6718 LD      A,-8
0428BF F8 
0428C0 C6      6719 STR13:			ADD     A,28
0428C1 1C 
0428C2 CD      6720 CALL    POWR10
0428C3 4F 
0428C4 2D 
0428C5 04 
0428C6 F5      6721 PUSH    AF
0428C7 CD      6722 CALL    FMUL
0428C8 3E 
0428C9 23 
0428CA 04 
0428CB F1      6723 POP     AF
0428CC 47      6724 LD      B,A
0428CD F1      6725 POP     AF
0428CE 90      6726 SUB     B
0428CF 18      6727 JR      STR11
0428D0 DE 
0428D1 D6      6728 STR14:			SUB     32
0428D2 20 
0428D3 CD      6729 CALL    POWR10
0428D4 4F 
0428D5 2D 
0428D6 04 
0428D7 F5      6730 PUSH    AF
0428D8 CD      6731 CALL    FDIV
0428D9 95 
0428DA 22 
0428DB 04 
0428DC F1      6732 POP     AF
0428DD 47      6733 LD      B,A
0428DE F1      6734 POP     AF
0428DF 80      6735 ADD     A,B
0428E0 18      6736 JR      STR11
0428E1 CD 
0428E2 3E      6737 STR15:			LD      A,9
0428E3 09 
0428E4 CD      6738 CALL    POWR10          ;10^9
0428E5 4F 
0428E6 2D 
0428E7 04 
0428E8 CD      6739 CALL    FCP0
0428E9 63 
0428EA 2C 
0428EB 04 
0428EC 79      6740 LD      A,C
0428ED C1      6741 POP     BC
0428EE 4F      6742 LD      C,A
0428EF CB      6743 SET     7,H             ;IMPLIED 1
0428F0 FC 
0428F1 DC      6744 CALL    C,X10B          ;X10, DEC B
0428F2 8B 
0428F3 2C 
0428F4 04 
0428F5 D1      6745 POP     DE              ;RESTORE TEXT POINTER
0428F6 CB      6746 RES     7,C
0428F7 B9 
0428F8 3E      6747 LD      A,0
0428F9 00 
0428FA 17      6748 RLA                     ;PUT CARRY IN LSB
               6749 ;
               6750 ;At this point decimal normalisation has been done,
               6751 ;now convert to decimal digits:
               6752 ;      AHLH'L' = number in normalised integer form
               6753 ;            B = decimal place adjustment
               6754 ;            C = binary place adjustment (29-33)
               6755 ;
0428FB 0C      6756 STR02:			INC     C
0428FC 08      6757 EX      AF,AF'          ;SAVE A
0428FD 78      6758 LD      A,B
0428FE DD      6759 BIT     1,(IX+2)
0428FF CB 
042900 02 
042901 4E 
042902 20      6760 JR      NZ,STR20
042903 08 
042904 AF      6761 XOR     A
042905 DD      6762 CP      (IX+1)
042906 BE 
042907 01 
042908 28      6763 JR      Z,STR21
042909 0B 
04290A 3E      6764 LD      A,-10
04290B F6 
04290C DD      6765 STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
04290D 86 
04290E 01 
04290F B7      6766 OR      A               ;CLEAR CARRY
042910 FA      6767 JP      M,STR21
042911 15 
042912 29 
042913 04 
042914 AF      6768 XOR     A
042915 F5      6769 STR21:			PUSH    AF
042916 08      6770 EX      AF,AF'          ;RESTORE A
042917 CD      6771 STR22:			CALL    X2              ;RL AHLH'L'
042918 BF 
042919 2C 
04291A 04 
04291B 8F      6772 ADC     A,A
04291C FE      6773 CP      10
04291D 0A 
04291E 38      6774 JR      C,STR23
04291F 05 
042920 D6      6775 SUB     10
042921 0A 
042922 D9      6776 EXX
042923 2C      6777 INC     L               ;SET RESULT BIT
042924 D9      6778 EXX
042925 0D      6779 STR23:			DEC     C
042926 20      6780 JR      NZ,STR22        ;32 TIMES
042927 EF 
042928 4F      6781 LD      C,A             ;REMAINDER
042929 7C      6782 LD      A,H
04292A E6      6783 AND     3FH             ;CLEAR OUT JUNK
04292B 3F 
04292C 67      6784 LD      H,A
04292D F1      6785 POP     AF
04292E F2      6786 JP      P,STR24
04292F 3C 
042930 29 
042931 04 
042932 3C      6787 INC     A
042933 20      6788 JR      NZ,STR26
042934 1C 
042935 3E      6789 LD      A,4
042936 04 
042937 B9      6790 CP      C               ;ROUND UP?
042938 3E      6791 LD      A,0
042939 00 
04293A 18      6792 JR      STR26
04293B 15 
04293C F5      6793 STR24:			PUSH    AF
04293D 79      6794 LD      A,C
04293E CE      6795 ADC     A,'0'           ;ADD CARRY
04293F 30 
042940 FE      6796 CP      '0'
042941 30 
042942 28      6797 JR      Z,STR25         ;SUPPRESS ZERO
042943 05 
042944 FE      6798 CP      '9'+1
042945 3A 
042946 3F      6799 CCF
042947 30      6800 JR      NC,STR26
042948 08 
042949 E3      6801 STR25:			EX      (SP),HL
04294A CB      6802 BIT     6,L             ;ZERO FLAG
04294B 75 
04294C E3      6803 EX      (SP),HL
04294D 20      6804 JR      NZ,STR27
04294E 05 
04294F 3E      6805 LD      A,'0'
042950 30 
042951 3C      6806 STR26:			INC     A               ;SET +VE
042952 3D      6807 DEC     A
042953 F5      6808 PUSH    AF              ;PUT ON STACK + CARRY
042954 04      6809 STR27:			INC     B
042955 CD      6810 CALL    TEST_FP            ;IS HLH'L' ZERO?
042956 2F 
042957 2C 
042958 04 
042959 0E      6811 LD      C,32
04295A 20 
04295B 3E      6812 LD      A,0
04295C 00 
04295D 20      6813 JR      NZ,STR22
04295E B8 
04295F F1      6814 POP     AF
042960 F5      6815 PUSH    AF
042961 3E      6816 LD      A,0
042962 00 
042963 38      6817 JR      C,STR22
042964 B2 
               6818 ;
               6819 ;At this point, the decimal character string is stored
               6820 ; on the stack. Trailing zeroes are suppressed and may
               6821 ; need to be replaced.
               6822 ;B register holds decimal point position.
               6823 ;Now format number and store as ASCII string:
               6824 ;
042965 EB      6825 STR3:			EX      DE,HL           ;STRING POINTER
042966 0E      6826 LD      C,-1            ;FLAG "E"
042967 FF 
042968 16      6827 LD      D,1
042969 01 
04296A DD      6828 LD      E,(IX+1)        ;f2
04296B 5E 
04296C 01 
04296D DD      6829 BIT     0,(IX+2)
04296E CB 
04296F 02 
042970 46 
042971 20      6830 JR      NZ,STR34        ;E MODE
042972 35 
042973 DD      6831 BIT     1,(IX+2)
042974 CB 
042975 02 
042976 4E 
042977 28      6832 JR      Z,STR31
042978 12 
042979 78      6833 LD      A,B             ;F MODE
04297A B7      6834 OR      A
04297B 28      6835 JR      Z,STR30
04297C 05 
04297D FA      6836 JP      M,STR30
04297E 82 
04297F 29 
042980 04 
042981 50      6837 LD      D,B
042982 7A      6838 STR30:			LD      A,D
042983 DD      6839 ADD     A,(IX+1)
042984 86 
042985 01 
042986 5F      6840 LD      E,A
042987 FE      6841 CP      11
042988 0B 
042989 38      6842 JR      C,STR32
04298A 19 
04298B 78      6843 STR31:			LD      A,B             ;G MODE
04298C 11      6844 LD      DE,101H
04298D 01 
04298E 01 
04298F 00 
042990 B7      6845 OR      A
042991 FA      6846 JP      M,STR34
042992 A8 
042993 29 
042994 04 
042995 28      6847 JR      Z,STR32
042996 0D 
042997 DD      6848 LD      A,(IX+1)
042998 7E 
042999 01 
04299A B7      6849 OR      A
04299B 20      6850 JR      NZ,STR3A
04299C 02 
04299D 3E      6851 LD      A,10
04299E 0A 
04299F B8      6852 STR3A:			CP      B
0429A0 38      6853 JR      C,STR34
0429A1 06 
0429A2 50      6854 LD      D,B
0429A3 58      6855 LD      E,B
0429A4 78      6856 STR32:			LD      A,B
0429A5 C6      6857 ADD     A,129
0429A6 81 
0429A7 4F      6858 LD      C,A
0429A8 CB      6859 STR34:			SET     7,D
0429A9 FA 
0429AA 1D      6860 DEC     E
0429AB 7A      6861 STR35:			LD      A,D
0429AC B9      6862 CP      C
0429AD 30      6863 JR      NC,STR33
0429AE 0E 
0429AF F1      6864 STR36:			POP     AF
0429B0 28      6865 JR      Z,STR37
0429B1 04 
0429B2 F2      6866 JP      P,STR38
0429B3 BF 
0429B4 29 
0429B5 04 
0429B6 F5      6867 STR37:			PUSH    AF
0429B7 1C      6868 INC     E
0429B8 1D      6869 DEC     E
0429B9 FA      6870 JP      M,STR4
0429BA D0 
0429BB 29 
0429BC 04 
0429BD 3E      6871 STR33:			LD      A,'0'
0429BE 30 
0429BF 15      6872 STR38:			DEC     D
0429C0 E2      6873 JP      PO,STR39
0429C1 C7 
0429C2 29 
0429C3 04 
0429C4 36      6874 LD      (HL),'.'
0429C5 2E 
0429C6 23      6875 INC     HL
0429C7 77      6876 STR39:			LD      (HL),A
0429C8 23      6877 INC     HL
0429C9 1D      6878 DEC     E
0429CA F2      6879 JP      P,STR35
0429CB AB 
0429CC 29 
0429CD 04 
0429CE 18      6880 JR      STR36
0429CF DF 
               6881 ;
0429D0 F1      6882 STR4:			POP     AF
0429D1 0C      6883 STR40:			INC     C
0429D2 4D      6884 LD      C,L
0429D3 20      6885 JR      NZ,STR44
0429D4 28 
0429D5 36      6886 LD      (HL),'E'        ;EXPONENT
0429D6 45 
0429D7 23      6887 INC     HL
0429D8 78      6888 LD      A,B
0429D9 3D      6889 DEC     A
0429DA F2      6890 JP      P,STR41
0429DB E3 
0429DC 29 
0429DD 04 
0429DE 36      6891 LD      (HL),'-'
0429DF 2D 
0429E0 23      6892 INC     HL
0429E1 ED      6893 NEG
0429E2 44 
0429E3 36      6894 STR41:			LD      (HL),'0'
0429E4 30 
0429E5 28      6895 JR      Z,STR47
0429E6 15 
0429E7 FE      6896 CP      10
0429E8 0A 
0429E9 47      6897 LD      B,A
0429EA 3E      6898 LD      A,':'
0429EB 3A 
0429EC 38      6899 JR      C,STR42
0429ED 03 
0429EE 23      6900 INC     HL
0429EF 36      6901 LD      (HL),'0'
0429F0 30 
0429F1 34      6902 STR42:			INC     (HL)
0429F2 BE      6903 CP      (HL)
0429F3 20      6904 JR      NZ,STR43
0429F4 05 
0429F5 36      6905 LD      (HL),'0'
0429F6 30 
0429F7 2B      6906 DEC     HL
0429F8 34      6907 INC     (HL)
0429F9 23      6908 INC     HL
0429FA 10      6909 STR43:			DJNZ    STR42
0429FB F5 
0429FC 23      6910 STR47:			INC     HL
0429FD EB      6911 STR44:			EX      DE,HL
0429FE C9      6912 RET
               6913 ;
               6914 ;Support subroutines:
               6915 ;
0429FF DD      6916 DLOAD5:			LD      B,(IX+4)
042A00 46 
042A01 04 
042A02 D9      6917 EXX
042A03 DD      6918 LD      E,(IX+0)
042A04 5E 
042A05 00 
042A06 DD      6919 LD      D,(IX+1)
042A07 56 
042A08 01 
042A09 D9      6920 EXX
042A0A DD      6921 LD      E,(IX+2)
042A0B 5E 
042A0C 02 
042A0D DD      6922 LD      D,(IX+3)
042A0E 56 
042A0F 03 
042A10 C9      6923 RET
               6924 ;
042A11 DD      6925 DLOAD5_SPL:		LD      B,(IX+6)
042A12 46 
042A13 06 
042A14 D9      6926 EXX
042A15 DD      6927 LD	DE, (IX+0)
042A16 17 
042A17 00 
042A18 D9      6928 EXX
042A19 DD      6929 LD	DE, (IX+3)
042A1A 17 
042A1B 03 
042A1C C9      6930 RET
               6931 ;
               6932 ;CON_FP - Get unsigned numeric constant from ASCII string.
               6933 ;   Inputs: ASCII string at (IX).
               6934 ;  Outputs: Variable-type result in HLH'L'C
               6935 ;           IX updated (points to delimiter)
               6936 ;           A7 = 0 (numeric marker)
               6937 ;
042A1D CD      6938 CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A1E 53 
042A1F 2C 
042A20 04 
042A21 0E      6939 LD      C,0             ;TRUNCATION COUNTER
042A22 00 
042A23 CD      6940 CALL    UINT          ;GET INTEGER PART
042A24 B1 
042A25 2A 
042A26 04 
042A27 FE      6941 CP      '.'
042A28 2E 
042A29 06      6942 LD      B,0             ;DECL. PLACE COUNTER
042A2A 00 
042A2B CC      6943 CALL    Z,NUMBIX        ;GET FRACTION PART
042A2C AF 
042A2D 2A 
042A2E 04 
042A2F FE      6944 CP      'E'
042A30 45 
042A31 3E      6945 LD      A,0             ;INITIALISE EXPONENT
042A32 00 
042A33 CC      6946 CALL    Z,GETEXP        ;GET EXPONENT
042A34 7D 
042A35 2A 
042A36 04 
042A37 CB      6947 BIT     7,H
042A38 7C 
042A39 20      6948 JR      NZ,CON0         ;INTEGER OVERFLOW
042A3A 08 
042A3B B7      6949 OR      A
042A3C 20      6950 JR      NZ,CON0         ;EXPONENT NON-ZERO
042A3D 05 
042A3E B8      6951 CP      B
042A3F 20      6952 JR      NZ,CON0         ;DECIMAL POINT
042A40 02 
042A41 B9      6953 CP      C
042A42 C8      6954 RET     Z               ;INTEGER
042A43 90      6955 CON0:			SUB     B
042A44 81      6956 ADD     A,C
042A45 0E      6957 LD      C,159
042A46 9F 
042A47 CD      6958 CALL    FLOAT_
042A48 B6 
042A49 2B 
042A4A 04 
042A4B CB      6959 RES     7,H             ;DITCH IMPLIED 1
042A4C BC 
042A4D B7      6960 OR      A
042A4E C8      6961 RET     Z               ;DONE
042A4F FA      6962 JP      M,CON2          ;NEGATIVE EXPONENT
042A50 5D 
042A51 2A 
042A52 04 
042A53 CD      6963 CALL    POWR10
042A54 4F 
042A55 2D 
042A56 04 
042A57 CD      6964 CALL    FMUL            ;SCALE
042A58 3E 
042A59 23 
042A5A 04 
042A5B AF      6965 XOR     A
042A5C C9      6966 RET
042A5D FE      6967 CON2:			CP      -38
042A5E DA 
042A5F 38      6968 JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A60 0C 
042A61 ED      6969 NEG
042A62 44 
042A63 CD      6970 CALL    POWR10
042A64 4F 
042A65 2D 
042A66 04 
042A67 CD      6971 CALL    FDIV            ;SCALE
042A68 95 
042A69 22 
042A6A 04 
042A6B AF      6972 XOR     A
042A6C C9      6973 RET
042A6D F5      6974 CON3:			PUSH    AF
042A6E 3E      6975 LD      A,38
042A6F 26 
042A70 CD      6976 CALL    POWR10
042A71 4F 
042A72 2D 
042A73 04 
042A74 CD      6977 CALL    FDIV
042A75 95 
042A76 22 
042A77 04 
042A78 F1      6978 POP     AF
042A79 C6      6979 ADD     A,38
042A7A 26 
042A7B 18      6980 JR      CON2
042A7C E0 
               6981 ;
               6982 ;GETEXP - Get decimal exponent from string
               6983 ;     Inputs: ASCII string at (IX)
               6984 ;             (IX points at 'E')
               6985 ;             A = initial value
               6986 ;    Outputs: A = new exponent
               6987 ;             IX updated.
               6988 ;   Destroys: A,A',IX,F,F'
               6989 ;
042A7D C5      6990 GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A7E 47      6991 LD      B,A             ;INITIAL VALUE
042A7F 0E      6992 LD      C,2             ;2 DIGITS MAX
042A80 02 
042A81 DD      6993 INC     IX              ;BUMP PAST 'E'
042A82 23 
042A83 CD      6994 CALL    SIGNQ
042A84 6D 
042A85 2E 
042A86 04 
042A87 08      6995 EX      AF,AF'          ;SAVE EXPONENT SIGN
042A88 CD      6996 GETEX1:			CALL    DIGITQ
042A89 63 
042A8A 2E 
042A8B 04 
042A8C 38      6997 JR      C,GETEX2
042A8D 18 
042A8E 78      6998 LD      A,B             ;B=B*10
042A8F 87      6999 ADD     A,A
042A90 87      7000 ADD     A,A
042A91 80      7001 ADD     A,B
042A92 87      7002 ADD     A,A
042A93 47      7003 LD      B,A
042A94 DD      7004 LD      A,(IX)          ;GET BACK DIGIT
042A95 7E 
042A96 00 
042A97 DD      7005 INC     IX
042A98 23 
042A99 E6      7006 AND     0FH             ;MASK UNWANTED BITS
042A9A 0F 
042A9B 80      7007 ADD     A,B             ;ADD IN DIGIT
042A9C 47      7008 LD      B,A
042A9D 0D      7009 DEC     C
042A9E F2      7010 JP      P,GETEX1
042A9F 88 
042AA0 2A 
042AA1 04 
042AA2 06      7011 LD      B,100           ;FORCE OVERFLOW
042AA3 64 
042AA4 18      7012 JR      GETEX1
042AA5 E2 
042AA6 08      7013 GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AA7 FE      7014 CP      '-'
042AA8 2D 
042AA9 78      7015 LD      A,B
042AAA C1      7016 POP     BC              ;RESTORE
042AAB C0      7017 RET     NZ
042AAC ED      7018 NEG                     ;NEGATE EXPONENT
042AAD 44 
042AAE C9      7019 RET
               7020 ;
               7021 ;UINT: Get unsigned integer from string.
               7022 ;    Inputs: string at (IX)
               7023 ;            C = truncated digit count
               7024 ;                (initially zero)
               7025 ;            B = total digit count
               7026 ;            HLH'L' = initial value
               7027 ;   Outputs: HLH'L' = number (binary integer)
               7028 ;            A = delimiter.
               7029 ;            B, C & IX updated
               7030 ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7031 ;
042AAF DD      7032 NUMBIX:			INC     IX
042AB0 23 
042AB1 CD      7033 UINT:			CALL    DIGITQ
042AB2 63 
042AB3 2E 
042AB4 04 
042AB5 D8      7034 RET     C
042AB6 04      7035 INC     B               ;INCREMENT DIGIT COUNT
042AB7 DD      7036 INC     IX
042AB8 23 
042AB9 CD      7037 CALL    X10             ;*10 & COPY OLD VALUE
042ABA AC 
042ABB 2C 
042ABC 04 
042ABD 38      7038 JR      C,NUMB1         ;OVERFLOW
042ABE 15 
042ABF 0D      7039 DEC     C               ;SEE IF TRUNCATED
042AC0 0C      7040 INC     C
042AC1 20      7041 JR      NZ,NUMB1        ;IMPORTANT!
042AC2 11 
042AC3 E6      7042 AND     0FH
042AC4 0F 
042AC5 D9      7043 EXX
042AC6 06      7044 LD      B,0
042AC7 00 
042AC8 4F      7045 LD      C,A
042AC9 52      7046 ADD.S   HL,BC           ;ADD IN DIGIT
042ACA 09 
042ACB D9      7047 EXX
042ACC 30      7048 JR      NC,UINT
042ACD E3 
042ACE 52      7049 INC.S   HL              ;CARRY
042ACF 23 
042AD0 7C      7050 LD      A,H
042AD1 B5      7051 OR      L
042AD2 20      7052 JR      NZ,UINT
042AD3 DD 
042AD4 0C      7053 NUMB1:			INC     C               ;TRUNCATION COUNTER
042AD5 CD      7054 CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AD6 0A 
042AD7 2C 
042AD8 04 
042AD9 18      7055 JR      UINT
042ADA D6 
               7056 ;
               7057 ;FIX - Fix number to specified exponent value.
               7058 ;    Inputs: HLH'L'C = +ve non-zero number (floated)
               7059 ;            A = desired exponent (A>C)
               7060 ;   Outputs: HLH'L'C = fixed number (unsigned)
               7061 ;            fraction shifted into B'C'
               7062 ;            A'F' positive if integer input
               7063 ;  Destroys: C,H,L,A',B',C',H',L',F,F'
               7064 ;
042ADB 08      7065 FIX:			EX      AF,AF'
042ADC AF      7066 XOR     A
042ADD 08      7067 EX      AF,AF'
042ADE CB      7068 SET     7,H             ;IMPLIED 1
042ADF FC 
042AE0 CD      7069 FIX1:			CALL    DIV2
042AE1 0F 
042AE2 2C 
042AE3 04 
042AE4 B9      7070 CP      C
042AE5 C8      7071 RET     Z
042AE6 D2      7072 JP      NC,FIX1
042AE7 E0 
042AE8 2A 
042AE9 04 
042AEA C3      7073 JP      OFLOW
042AEB 1E 
042AEC 2C 
042AED 04 
               7074 ;
               7075 ;SFIX - Convert to integer if necessary.
               7076 ;    Input: Variable-type number in HLH'L'C
               7077 ;   Output: Integer in HLH'L', C=0
               7078 ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
               7079 ;
               7080 ;NEGATE - Negate HLH'L'
               7081 ;    Destroys: H,L,H',L',F
               7082 ;
042AEE CD      7083 FIX2:			CALL    SWAP_FP
042AEF 07 
042AF0 2C 
042AF1 04 
042AF2 CD      7084 CALL    SFIX_FP
042AF3 FA 
042AF4 2A 
042AF5 04 
042AF6 CD      7085 CALL    SWAP_FP
042AF7 07 
042AF8 2C 
042AF9 04 
042AFA 0D      7086 SFIX_FP:			DEC     C
042AFB 0C      7087 INC     C
042AFC C8      7088 RET     Z               ;INTEGER/ZERO
042AFD CB      7089 BIT     7,H             ;SIGN
042AFE 7C 
042AFF F5      7090 PUSH    AF
042B00 3E      7091 LD      A,159
042B01 9F 
042B02 CD      7092 CALL    FIX
042B03 DB 
042B04 2A 
042B05 04 
042B06 F1      7093 POP     AF
042B07 0E      7094 LD      C,0
042B08 00 
042B09 C8      7095 RET     Z
042B0A B7      7096 NEGATE:			OR      A               ;CLEAR CARRY
042B0B D9      7097 EXX
042B0C D5      7098 NEG0:			PUSH    DE
042B0D EB      7099 EX      DE,HL
042B0E 21      7100 LD      HL,0
042B0F 00 
042B10 00 
042B11 00 
042B12 52      7101 SBC.S   HL,DE
042B13 ED 
042B14 52 
042B15 D1      7102 POP     DE
042B16 D9      7103 EXX
042B17 D5      7104 PUSH    DE
042B18 EB      7105 EX      DE,HL
042B19 21      7106 LD      HL,0
042B1A 00 
042B1B 00 
042B1C 00 
042B1D 52      7107 SBC.S   HL,DE
042B1E ED 
042B1F 52 
042B20 D1      7108 POP     DE
042B21 C9      7109 RET
               7110 ;
               7111 ;NEG - Negate HLH'L'B'C'
               7112 ;    Also complements A (used in FADD)
               7113 ;    Destroys: A,H,L,B',C',H',L',F
               7114 ;
042B22 D9      7115 NEG_:			EXX
042B23 2F      7116 CPL
042B24 E5      7117 PUSH    HL
042B25 B7      7118 OR      A               ;CLEAR CARRY
042B26 21      7119 LD      HL,0
042B27 00 
042B28 00 
042B29 00 
042B2A 52      7120 SBC.S   HL,BC
042B2B ED 
042B2C 42 
042B2D 44      7121 LD      B,H
042B2E 4D      7122 LD      C,L
042B2F E1      7123 POP     HL
042B30 18      7124 JR      NEG0
042B31 DA 
               7125 ;
               7126 ;SCALE - Trig scaling.
               7127 ;MOD48 - 48-bit floating-point "modulus" (remainder).
               7128 ;   Inputs: HLH'L'C unsigned floating-point dividend
               7129 ;           DED'E'B'C'B unsigned 48-bit FP divisor
               7130 ;  Outputs: HLH'L'C floating point remainder (H7=1)
               7131 ;           E = quotient (bit 7 is sticky)
               7132 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7133 ;FLO48 - Float unsigned number (48 bits)
               7134 ;    Input/output in HLH'L'B'C'C
               7135 ;   Destroys: C,H,L,B',C',H',L',F
               7136 ;
042B32 3E      7137 SCALE:			LD      A,150
042B33 96 
042B34 B9      7138 CP      C
042B35 3E      7139 LD      A,ACLOST
042B36 17 
042B37 DA      7140 JP      C,ERROR_FP_         ;"Accuracy lost"
042B38 AD 
042B39 20 
042B3A 04 
042B3B CD      7141 CALL    PIBY4
042B3C 78 
042B3D 26 
042B3E 04 
042B3F D9      7142 EXX
042B40 01      7143 LD      BC,2169H        ;3.141592653589793238
042B41 69 
042B42 21 
042B43 00 
042B44 D9      7144 EXX
042B45 CB      7145 MOD48:			SET     7,D             ;IMPLIED 1
042B46 FA 
042B47 CB      7146 SET     7,H
042B48 FC 
042B49 79      7147 LD      A,C
042B4A 0E      7148 LD      C,0             ;INIT QUOTIENT
042B4B 00 
042B4C DD      7149 LD      IX,0
042B4D 21 
042B4E 00 
042B4F 00 
042B4F 00   
042B51 DD      7150 PUSH    IX              ;PUT ZERO ON STACK
042B52 E5 
042B53 B8      7151 CP      B
042B54 38      7152 JR      C,MOD485        ;DIVIDEND<DIVISOR
042B55 46 
042B56 D9      7153 MOD481:			EXX                     ;CARRY=0 HERE
042B57 E3      7154 EX      (SP),HL
042B58 52      7155 SBC.S   HL,BC
042B59 ED 
042B5A 42 
042B5B E3      7156 EX      (SP),HL
042B5C 52      7157 SBC.S   HL,DE
042B5D ED 
042B5E 52 
042B5F D9      7158 EXX
042B60 52      7159 SBC.S   HL,DE
042B61 ED 
042B62 52 
042B63 30      7160 JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B64 0C 
042B65 D9      7161 EXX
042B66 E3      7162 EX      (SP),HL
042B67 52      7163 ADD.S   HL,BC
042B68 09 
042B69 E3      7164 EX      (SP),HL
042B6A 52      7165 ADC.S   HL,DE
042B6B ED 
042B6C 5A 
042B6D D9      7166 EXX
042B6E 52      7167 ADC.S   HL,DE
042B6F ED 
042B70 5A 
042B71 3F      7168 MOD482:			CCF
042B72 CB      7169 RL      C               ;QUOTIENT
042B73 11 
042B74 30      7170 JR      NC,MOD483
042B75 02 
042B76 CB      7171 SET     7,C             ;STICKY BIT
042B77 F9 
042B78 3D      7172 MOD483:			DEC     A
042B79 B8      7173 CP      B
042B7A 38      7174 JR      C,MOD484        ;DIVIDEND<DIVISOR
042B7B 1F 
042B7C E3      7175 EX      (SP),HL
042B7D 52      7176 ADD.S   HL,HL           ;DIVIDEND * 2
042B7E 29 
042B7F E3      7177 EX      (SP),HL
042B80 D9      7178 EXX
042B81 52      7179 ADC.S   HL,HL
042B82 ED 
042B83 6A 
042B84 D9      7180 EXX
042B85 52      7181 ADC.S   HL,HL
042B86 ED 
042B87 6A 
042B88 30      7182 JR      NC,MOD481       ;AGAIN
042B89 CC 
042B8A B7      7183 OR      A
042B8B D9      7184 EXX
042B8C E3      7185 EX      (SP),HL
042B8D 52      7186 SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B8E ED 
042B8F 42 
042B90 E3      7187 EX      (SP),HL
042B91 52      7188 SBC.S   HL,DE
042B92 ED 
042B93 52 
042B94 D9      7189 EXX
042B95 52      7190 SBC.S   HL,DE
042B96 ED 
042B97 52 
042B98 B7      7191 OR      A
042B99 18      7192 JR      MOD482
042B9A D6 
               7193 ;
042B9B 3C      7194 MOD484:			INC     A
042B9C 59      7195 MOD485:			LD      E,C             ;QUOTIENT
042B9D 4F      7196 LD      C,A             ;REMAINDER EXPONENT
042B9E D9      7197 EXX
042B9F C1      7198 POP     BC
042BA0 D9      7199 EXX
042BA1 CB      7200 FLO48:			BIT     7,H
042BA2 7C 
042BA3 C0      7201 RET     NZ
042BA4 D9      7202 EXX
042BA5 CB      7203 SLA     C
042BA6 21 
042BA7 CB      7204 RL      B
042BA8 10 
042BA9 52      7205 ADC.S   HL,HL
042BAA ED 
042BAB 6A 
042BAC D9      7206 EXX
042BAD 52      7207 ADC.S   HL,HL
042BAE ED 
042BAF 6A 
042BB0 0D      7208 DEC     C
042BB1 C2      7209 JP      NZ,FLO48
042BB2 A1 
042BB3 2B 
042BB4 04 
042BB5 C9      7210 RET
               7211 ;
               7212 ;Float unsigned number
               7213 ;    Input/output in HLH'L'C
               7214 ;   Destroys: C,H,L,H',L',F
               7215 ;
042BB6 CB      7216 FLOAT_:			BIT     7,H
042BB7 7C 
042BB8 C0      7217 RET     NZ
042BB9 D9      7218 EXX                     ;SAME AS "X2"
042BBA 52      7219 ADD.S   HL,HL           ;TIME-CRITICAL
042BBB 29 
042BBC D9      7220 EXX                     ;REGION
042BBD 52      7221 ADC.S   HL,HL           ;(BENCHMARKS)
042BBE ED 
042BBF 6A 
042BC0 0D      7222 DEC     C
042BC1 C2      7223 JP      NZ,FLOAT_
042BC2 B6 
042BC3 2B 
042BC4 04 
042BC5 C9      7224 RET
               7225 ;
               7226 ;SFLOAT - Convert to floating-point if necessary.
               7227 ;    Input: Variable-type number in HLH'L'C
               7228 ;    Output: Floating-point in HLH'L'C
               7229 ;    Destroys: A,C,H,L,H',L',F
               7230 ;
042BC6 08      7231 FLOATA:			EX      AF,AF'
               7232 ; ADD     A,(RTABLE-DTABLE)/3
042BC7 C6      7233 ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BC8 2A 
042BC9 08      7234 EX      AF,AF'
042BCA CD      7235 FLOAT2:			CALL    SWAP_FP
042BCB 07 
042BCC 2C 
042BCD 04 
042BCE CD      7236 CALL    SFLOAT_FP
042BCF D6 
042BD0 2B 
042BD1 04 
042BD2 CD      7237 CALL    SWAP_FP
042BD3 07 
042BD4 2C 
042BD5 04 
042BD6 0D      7238 SFLOAT_FP:			DEC     C
042BD7 0C      7239 INC     C
042BD8 C0      7240 RET     NZ              ;ALREADY FLOATING-POINT
042BD9 CD      7241 CALL    TEST_FP
042BDA 2F 
042BDB 2C 
042BDC 04 
042BDD C8      7242 RET     Z               ;ZERO
042BDE 7C      7243 LD      A,H
042BDF B7      7244 OR      A
042BE0 FC      7245 CALL    M,NEGATE
042BE1 0A 
042BE2 2B 
042BE3 04 
042BE4 0E      7246 LD      C,159
042BE5 9F 
042BE6 CD      7247 CALL    FLOAT_
042BE7 B6 
042BE8 2B 
042BE9 04 
042BEA B7      7248 OR      A
042BEB F8      7249 RET     M               ;NEGATIVE
042BEC CB      7250 RES     7,H
042BED BC 
042BEE C9      7251 RET
               7252 ;
               7253 ;ROUND UP
               7254 ;Return with carry set if 32-bit overflow
               7255 ;   Destroys: H,L,B',C',H',L',F
               7256 ;
042BEF D9      7257 ADD1_FP:			EXX
042BF0 01      7258 LD      BC,1
042BF1 01 
042BF2 00 
042BF3 00 
042BF4 52      7259 ADD.S   HL,BC
042BF5 09 
042BF6 D9      7260 EXX
042BF7 D0      7261 RET     NC
042BF8 C5      7262 PUSH    BC
042BF9 01      7263 LD      BC,1
042BFA 01 
042BFB 00 
042BFC 00 
042BFD 52      7264 ADD.S   HL,BC
042BFE 09 
042BFF C1      7265 POP     BC
042C00 C9      7266 RET
               7267 ;
               7268 ;ODD - Add one if even, leave alone if odd.
               7269 ; (Used to perform unbiassed rounding, i.e.
               7270 ;  number is rounded up half the time)
               7271 ;    Destroys: L',F (carry cleared)
               7272 ;
042C01 B7      7273 ODD:			OR      A               ;CLEAR CARRY
042C02 D9      7274 EXX
042C03 CB      7275 SET     0,L             ;MAKE ODD
042C04 C5 
042C05 D9      7276 EXX
042C06 C9      7277 RET
               7278 ;
               7279 ;SWAP_FP - Swap arguments.
               7280 ;    Exchanges DE,HL D'E',H'L' and B,C
               7281 ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
               7282 ;SWAP1 - Swap DEHL with D'E'H'L'
               7283 ;    Destroys: D,E,H,L,D',E',H',L'
               7284 ;
042C07 79      7285 SWAP_FP:			LD      A,C
042C08 48      7286 LD      C,B
042C09 47      7287 LD      B,A
042C0A EB      7288 SWAP1:			EX      DE,HL
042C0B D9      7289 EXX
042C0C EB      7290 EX      DE,HL
042C0D D9      7291 EXX
042C0E C9      7292 RET
               7293 ;
               7294 ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
               7295 ; INCC - destroys C,F
               7296 ; OFLOW
               7297 ;
042C0F CD      7298 DIV2:			CALL    D2
042C10 C8 
042C11 2C 
042C12 04 
042C13 D9      7299 EXX
042C14 CB      7300 RR      B
042C15 18 
042C16 CB      7301 RR      C
042C17 19 
042C18 08      7302 EX      AF,AF'
042C19 B0      7303 OR      B
042C1A 08      7304 EX      AF,AF'
042C1B D9      7305 EXX
042C1C 0C      7306 INCC:			INC     C
042C1D C0      7307 RET     NZ
042C1E 3E      7308 OFLOW:			LD      A,TOOBIG_FP
042C1F 14 
042C20 C3      7309 JP      ERROR_FP_           ;"Too big"
042C21 AD 
042C22 20 
042C23 04 
               7310 ;
               7311 ; FTEST - Test for zero & sign
               7312 ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
               7313 ;
042C24 CD      7314 FTEST_FP:			CALL    TEST_FP
042C25 2F 
042C26 2C 
042C27 04 
042C28 C8      7315 RET     Z
042C29 7C      7316 LD      A,H
042C2A E6      7317 AND     10000000B
042C2B 80 
042C2C F6      7318 OR      01000000B
042C2D 40 
042C2E C9      7319 RET
               7320 ;
               7321 ; TEST_FP - Test HLH'L' for zero.
               7322 ;     Output: Z-flag set & A=0 if HLH'L'=0
               7323 ;     Destroys: A,F
               7324 ;
042C2F 7C      7325 TEST_FP:			LD      A,H
042C30 B5      7326 OR      L
042C31 D9      7327 EXX
042C32 B4      7328 OR      H
042C33 B5      7329 OR      L
042C34 D9      7330 EXX
042C35 C9      7331 RET
               7332 ;
               7333 ; FCOMP - Compare two numbers
               7334 ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
               7335 ;
042C36 78      7336 FCOMP_FP:			LD      A,B
042C37 B1      7337 OR      C               ;Both integer?
042C38 20      7338 JR      NZ,FCOMP1
042C39 0B 
042C3A CD      7339 CALL    ICP
042C3B 4F 
042C3C 2C 
042C3D 04 
042C3E 3E      7340 FCOMP0:			LD      A,0
042C3F 00 
042C40 C8      7341 RET     Z               ;Equal
042C41 3E      7342 LD      A,80H
042C42 80 
042C43 1F      7343 RRA
042C44 C9      7344 RET
               7345 ;
042C45 CD      7346 FCOMP1:			CALL    FLOAT2          ;Float both
042C46 CA 
042C47 2B 
042C48 04 
042C49 CD      7347 CALL    FCP
042C4A 5D 
042C4B 2C 
042C4C 04 
042C4D 18      7348 JR      FCOMP0
042C4E EF 
               7349 ;
               7350 ; Integer and floating point compare.
               7351 ; Sets carry & zero flags according to HLH'L'C-DED'E'B
               7352 ; Result pre-set to FALSE
               7353 ; ICP1, FCP1 destroy A,F
               7354 ;
               7355 ; ZERO - Return zero.
               7356 ;  Destroys: A,C,H,L,H',L'
               7357 ;
042C4F CD      7358 ICP:			CALL    ICP1
042C50 82 
042C51 2C 
042C52 04 
042C53 3E      7359 ZERO_FP:			LD      A,0
042C54 00 
042C55 D9      7360 EXX
042C56 67      7361 LD      H,A
042C57 6F      7362 LD      L,A
042C58 D9      7363 EXX
042C59 67      7364 LD      H,A
042C5A 6F      7365 LD      L,A
042C5B 4F      7366 LD      C,A
042C5C C9      7367 RET
               7368 ;
042C5D CD      7369 FCP:			CALL    FCP1
042C5E 74 
042C5F 2C 
042C60 04 
042C61 18      7370 JR      ZERO_FP            ;PRESET FALSE
042C62 F0 
               7371 ;
042C63 79      7372 FCP0:			LD      A,C
042C64 B8      7373 CP      B               ;COMPARE EXPONENTS
042C65 C0      7374 RET     NZ
               7375 ICP0:
042C66 52      7376 SBC.S   HL,DE           ;COMP MANTISSA MSB
042C67 ED 
042C68 52 
042C69 52      7377 ADD.S   HL,DE
042C6A 19 
042C6B C0      7378 RET     NZ
042C6C D9      7379 EXX
042C6D 52      7380 SBC.S   HL,DE           ;COMP MANTISSA LSB
042C6E ED 
042C6F 52 
042C70 52      7381 ADD.S   HL,DE
042C71 19 
042C72 D9      7382 EXX
042C73 C9      7383 RET
               7384 ;
042C74 7C      7385 FCP1:			LD      A,H
042C75 AA      7386 XOR     D
042C76 7C      7387 LD      A,H
042C77 17      7388 RLA
042C78 F8      7389 RET     M
042C79 30      7390 JR      NC,FCP0
042C7A E8 
042C7B CD      7391 CALL    FCP0
042C7C 63 
042C7D 2C 
042C7E 04 
042C7F C8      7392 RET     Z               ;** V0.1 BUG FIX
042C80 3F      7393 CCF
042C81 C9      7394 RET
               7395 ;
042C82 7C      7396 ICP1:			LD      A,H
042C83 AA      7397 XOR     D
042C84 F2      7398 JP      P,ICP0
042C85 66 
042C86 2C 
042C87 04 
042C88 7C      7399 LD      A,H
042C89 17      7400 RLA
042C8A C9      7401 RET
               7402 ;
               7403 ; ADD - Integer add.
               7404 ; Carry, sign & zero flags valid on exit
               7405 ;     Destroys: H,L,H',L',F
               7406 ;
042C8B 05      7407 X10B:			DEC     B
042C8C 0C      7408 INC     C
042C8D CD      7409 X5:			CALL    COPY0
042C8E D4 
042C8F 2C 
042C90 04 
042C91 CD      7410 CALL    D2C
042C92 C7 
042C93 2C 
042C94 04 
042C95 CD      7411 CALL    D2C
042C96 C7 
042C97 2C 
042C98 04 
042C99 08      7412 EX      AF,AF'          ;SAVE CARRY
042C9A D9      7413 ADD_:			EXX
042C9B 52      7414 ADD.S   HL,DE
042C9C 19 
042C9D D9      7415 EXX
042C9E 52      7416 ADC.S   HL,DE
042C9F ED 
042CA0 5A 
042CA1 C9      7417 RET
               7418 ;
               7419 ; SUB - Integer subtract.
               7420 ; Carry, sign & zero flags valid on exit
               7421 ;     Destroys: H,L,H',L',F
               7422 ;
042CA2 D9      7423 SUB_:			EXX
042CA3 B7      7424 OR      A
042CA4 52      7425 SBC.S   HL,DE
042CA5 ED 
042CA6 52 
042CA7 D9      7426 EXX
042CA8 52      7427 SBC.S   HL,DE
042CA9 ED 
042CAA 52 
042CAB C9      7428 RET
               7429 ;
               7430 ; X10 - unsigned integer * 10
               7431 ;    Inputs: HLH'L' initial value
               7432 ;   Outputs: DED'E' = initial HLH'L'
               7433 ;            Carry bit set if overflow
               7434 ;            If carry not set HLH'L'=result
               7435 ;  Destroys: D,E,H,L,D',E',H',L',F
               7436 ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
               7437 ;     Carry set if MSB=1 before shift.
               7438 ;     Sign set if MSB=1 after shift.
               7439 ;     Destroys: H,L,H',L',F
               7440 ;
042CAC CD      7441 X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CAD D4 
042CAE 2C 
042CAF 04 
042CB0 CD      7442 CALL    X2
042CB1 BF 
042CB2 2C 
042CB3 04 
042CB4 D8      7443 RET     C               ;TOO BIG
042CB5 CD      7444 CALL    X2
042CB6 BF 
042CB7 2C 
042CB8 04 
042CB9 D8      7445 RET     C
042CBA CD      7446 CALL    ADD_
042CBB 9A 
042CBC 2C 
042CBD 04 
042CBE D8      7447 RET     C
042CBF D9      7448 X2:			EXX
042CC0 52      7449 ADD.S   HL,HL
042CC1 29 
042CC2 D9      7450 EXX
042CC3 52      7451 ADC.S   HL,HL
042CC4 ED 
042CC5 6A 
042CC6 C9      7452 RET
               7453 ;
               7454 ; D2 - Divide HLH'L' by 2 as 32-bit integer.
               7455 ;     Carry set if LSB=1 before shift.
               7456 ;     Destroys: H,L,H',L',F
               7457 ;
042CC7 0C      7458 D2C:			INC     C
042CC8 CB      7459 D2:			SRL     H
042CC9 3C 
042CCA CB      7460 RR      L
042CCB 1D 
042CCC D9      7461 EXX
042CCD CB      7462 RR      H
042CCE 1C 
042CCF CB      7463 RR      L
042CD0 1D 
042CD1 D9      7464 EXX
042CD2 C9      7465 RET
               7466 ;
               7467 ; COPY - COPY HLH'L'C INTO DED'E'B
               7468 ;   Destroys: B,C,D,E,H,L,D',E',H',L'
               7469 ;
042CD3 41      7470 COPY_:			LD      B,C
042CD4 54      7471 COPY0:			LD      D,H
042CD5 5D      7472 LD      E,L
042CD6 D9      7473 EXX
042CD7 54      7474 LD      D,H
042CD8 5D      7475 LD      E,L
042CD9 D9      7476 EXX
042CDA C9      7477 RET
               7478 ;
               7479 ; SQUARE - PUSH X*X
               7480 ; PUSH5 - PUSH HLH'L'C ONTO STACK.
               7481 ;   Destroys: SP,IX
               7482 ;
042CDB CD      7483 SQUARE:			CALL    COPY_
042CDC D3 
042CDD 2C 
042CDE 04 
042CDF CD      7484 CALL    FMUL
042CE0 3E 
042CE1 23 
042CE2 04 
042CE3 DD      7485 PUSH5:			POP     IX              ;RETURN ADDRESS
042CE4 E1 
042CE5 C5      7486 PUSH    BC
042CE6 E5      7487 PUSH    HL
042CE7 D9      7488 EXX
042CE8 E5      7489 PUSH    HL
042CE9 D9      7490 EXX
042CEA DD      7491 JP      (IX)            ;"RETURN"
042CEB E9 
               7492 ;
               7493 ; POP5 - POP DED'E'B OFF STACK.
               7494 ;   Destroys: A,B,D,E,D',E',SP,IX
               7495 ;
042CEC DD      7496 POP5:			POP     IX              ;RETURN ADDRESS
042CED E1 
042CEE D9      7497 EXX
042CEF D1      7498 POP     DE
042CF0 D9      7499 EXX
042CF1 D1      7500 POP     DE
042CF2 79      7501 LD      A,C
042CF3 C1      7502 POP     BC
042CF4 41      7503 LD      B,C
042CF5 4F      7504 LD      C,A
042CF6 DD      7505 JP      (IX)            ;"RETURN"
042CF7 E9 
               7506 ;
               7507 ; RATIO - Calculate (X-1)/(X+1)
               7508 ;     Inputs: X in HLH'L'C
               7509 ;    Outputs: (X-1)/(X+1) in HLH'L'C
               7510 ;   Destroys: Everything except IY,SP,I
               7511 ;
042CF8 CD      7512 RATIO:			CALL    PUSH5           ;SAVE X
042CF9 E3 
042CFA 2C 
042CFB 04 
042CFC CD      7513 CALL    DONE
042CFD 6B 
042CFE 26 
042CFF 04 
042D00 CD      7514 CALL    FADD
042D01 2C 
042D02 22 
042D03 04 
042D04 CD      7515 CALL    POP5            ;RESTORE X
042D05 EC 
042D06 2C 
042D07 04 
042D08 CD      7516 CALL    PUSH5           ;SAVE X+1
042D09 E3 
042D0A 2C 
042D0B 04 
042D0C CD      7517 CALL    SWAP_FP
042D0D 07 
042D0E 2C 
042D0F 04 
042D10 CD      7518 CALL    DONE
042D11 6B 
042D12 26 
042D13 04 
042D14 CD      7519 CALL    FSUB
042D15 13 
042D16 22 
042D17 04 
042D18 CD      7520 CALL    POP5            ;RESTORE X+1
042D19 EC 
042D1A 2C 
042D1B 04 
042D1C C3      7521 JP      FDIV
042D1D 95 
042D1E 22 
042D1F 04 
               7522 ;
               7523 ; POLY - Evaluate a polynomial.
               7524 ;     Inputs: X in HLH'L'C and also stored at (SP+2)
               7525 ;             Polynomial coefficients follow call.
               7526 ;    Outputs: Result in HLH'L'C
               7527 ;   Destroys: Everything except IY,SP,I
               7528 ; Routine terminates on finding a coefficient >=1.
               7529 ; Note: The last coefficient is EXECUTED on return
               7530 ;       so must contain only innocuous bytes!
               7531 ;
042D20 DD      7532 POLY:			LD      IX, 3				; Advance the SP to the return address
042D21 21 
042D22 03 
042D23 00 
042D23 00   
042D25 DD      7533 ADD     IX, SP
042D26 39 
042D27 DD      7534 EX      (SP), IX			; IX: Points to the inline list of coefficients
042D28 E3 
               7535 ;
042D29 CD      7536 CALL    DLOAD5          		; Load the first coefficient from (IX)
042D2A FF 
042D2B 29 
042D2C 04 
042D2D CD      7537 POLY1:			CALL    FMUL
042D2E 3E 
042D2F 23 
042D30 04 
042D31 11      7538 LD      DE, 5				; Skip to the next coefficient
042D32 05 
042D33 00 
042D34 00 
042D35 DD      7539 ADD     IX, DE
042D36 19 
042D37 CD      7540 CALL    DLOAD5          		; Load the second coefficient from (IX)
042D38 FF 
042D39 29 
042D3A 04 
042D3B DD      7541 EX      (SP), IX			; Restore the SP just in case we need to return
042D3C E3 
042D3D 04      7542 INC     B
042D3E 05      7543 DEC     B               		; Test B for end byte (80h)
042D3F FA      7544 JP      M,FADD				; Yes, so add and return
042D40 2C 
042D41 22 
042D42 04 
042D43 CD      7545 CALL    FADD				; No, so add
042D44 2C 
042D45 22 
042D46 04 
042D47 CD      7546 CALL    DLOAD5_SPL			; Load X from SP
042D48 11 
042D49 2A 
042D4A 04 
042D4B DD      7547 EX      (SP), IX			; IX: Points to the inline list of coefficients
042D4C E3 
042D4D 18      7548 JR      POLY1				; And loop
042D4E DE 
               7549 ;
               7550 ; POWR10 - Calculate power of ten.
               7551 ;     Inputs: A=power of 10 required (A<128)
               7552 ;             A=binary exponent to be exceeded (A>=128)
               7553 ;    Outputs: DED'E'B = result
               7554 ;             A = actual power of ten returned
               7555 ;   Destroys: A,B,D,E,A',D',E',F,F'
               7556 ;
042D4F 3C      7557 POWR10:			INC     A
042D50 08      7558 EX      AF,AF'
042D51 E5      7559 PUSH    HL
042D52 D9      7560 EXX
042D53 E5      7561 PUSH    HL
042D54 D9      7562 EXX
042D55 CD      7563 CALL    DONE
042D56 6B 
042D57 26 
042D58 04 
042D59 CD      7564 CALL    SWAP_FP
042D5A 07 
042D5B 2C 
042D5C 04 
042D5D AF      7565 XOR     A
042D5E 08      7566 POWR11:			EX      AF,AF'
042D5F 3D      7567 DEC     A
042D60 28      7568 JR      Z,POWR14        ;EXIT TYPE 1
042D61 26 
042D62 F2      7569 JP      P,POWR13
042D63 6A 
042D64 2D 
042D65 04 
042D66 B9      7570 CP      C
042D67 38      7571 JR      C,POWR14        ;EXIT TYPE 2
042D68 1F 
042D69 3C      7572 INC     A
042D6A 08      7573 POWR13:			EX      AF,AF'
042D6B 3C      7574 INC     A
042D6C CB      7575 SET     7,H
042D6D FC 
042D6E CD      7576 CALL    X5
042D6F 8D 
042D70 2C 
042D71 04 
042D72 30      7577 JR      NC,POWR12
042D73 06 
042D74 08      7578 EX      AF,AF'
042D75 CD      7579 CALL    D2C
042D76 C7 
042D77 2C 
042D78 04 
042D79 08      7580 EX      AF,AF'
042D7A 08      7581 POWR12:			EX      AF,AF'
042D7B DC      7582 CALL    C,ADD1_FP          ;ROUND UP
042D7C EF 
042D7D 2B 
042D7E 04 
042D7F 0C      7583 INC     C
042D80 FA      7584 JP      M,POWR11
042D81 5E 
042D82 2D 
042D83 04 
042D84 C3      7585 JP      OFLOW
042D85 1E 
042D86 2C 
042D87 04 
042D88 CD      7586 POWR14:			CALL    SWAP_FP
042D89 07 
042D8A 2C 
042D8B 04 
042D8C CB      7587 RES     7,D
042D8D BA 
042D8E D9      7588 EXX
042D8F E1      7589 POP     HL
042D90 D9      7590 EXX
042D91 E1      7591 POP     HL
042D92 08      7592 EX      AF,AF'
042D93 C9      7593 RET
               7594 ;
               7595 ; DIVA, DIVB - DIVISION PRIMITIVE.
               7596 ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
               7597 ;               Remainder in H'L'HL
               7598 ;     Inputs: A = loop counter (normally -32)
               7599 ;     Destroys: A,D,E,H,L,D',E',H',L',F
               7600 ;
042D94 B7      7601 DIVA:			OR      A               ;CLEAR CARRY
               7602 DIV0:
042D95 52      7603 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D96 ED 
042D97 42 
042D98 D9      7604 EXX
042D99 52      7605 SBC.S   HL,BC
042D9A ED 
042D9B 42 
042D9C D9      7606 EXX
042D9D 30      7607 JR      NC,DIV1
042D9E 07 
042D9F 52      7608 ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA0 09 
042DA1 D9      7609 EXX
042DA2 52      7610 ADC.S   HL,BC
042DA3 ED 
042DA4 4A 
042DA5 D9      7611 EXX
042DA6 3F      7612 DIV1:			CCF
042DA7 CB      7613 DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DA8 13 
042DA9 CB      7614 RL      D
042DAA 12 
042DAB D9      7615 EXX
042DAC CB      7616 RL      E
042DAD 13 
042DAE CB      7617 RL      D
042DAF 12 
042DB0 D9      7618 EXX
042DB1 3C      7619 INC     A
042DB2 F0      7620 RET     P
               7621 DIVB:
042DB3 52      7622 ADC.S   HL,HL           ;DIVIDEND*2
042DB4 ED 
042DB5 6A 
042DB6 D9      7623 EXX
042DB7 52      7624 ADC.S   HL,HL
042DB8 ED 
042DB9 6A 
042DBA D9      7625 EXX
042DBB 30      7626 JR      NC,DIV0
042DBC D8 
042DBD B7      7627 OR      A
042DBE 52      7628 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DBF ED 
042DC0 42 
042DC1 D9      7629 EXX
042DC2 52      7630 SBC.S   HL,BC
042DC3 ED 
042DC4 42 
042DC5 D9      7631 EXX
042DC6 37      7632 SCF
042DC7 C3      7633 JP      DIVC
042DC8 A7 
042DC9 2D 
042DCA 04 
               7634 ;
               7635 ;MULA, MULB - MULTIPLICATION PRIMITIVE.
               7636 ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
               7637 ;    Inputs: A = loop counter (usually -32)
               7638 ;            H'L'HL = 0
               7639 ;    Destroys: D,E,H,L,D',E',H',L',A,F
               7640 ;
042DCB B7      7641 MULA:			OR      A               ;CLEAR CARRY
042DCC D9      7642 MUL0:			EXX
042DCD CB      7643 RR      D               ;MULTIPLIER/2
042DCE 1A 
042DCF CB      7644 RR      E
042DD0 1B 
042DD1 D9      7645 EXX
042DD2 CB      7646 RR      D
042DD3 1A 
042DD4 CB      7647 RR      E
042DD5 1B 
042DD6 30      7648 JR      NC,MUL1
042DD7 07 
042DD8 52      7649 ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DD9 09 
042DDA D9      7650 EXX
042DDB 52      7651 ADC.S   HL,BC
042DDC ED 
042DDD 4A 
042DDE D9      7652 EXX
042DDF 3C      7653 MUL1:			INC     A
042DE0 F0      7654 RET     P
042DE1 D9      7655 MULB:			EXX
042DE2 CB      7656 RR      H               ;PRODUCT/2
042DE3 1C 
042DE4 CB      7657 RR      L
042DE5 1D 
042DE6 D9      7658 EXX
042DE7 CB      7659 RR      H
042DE8 1C 
042DE9 CB      7660 RR      L
042DEA 1D 
042DEB C3      7661 JP      MUL0
042DEC CC 
042DED 2D 
042DEE 04 
               7662 ;
               7663 ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
               7664 ;     Function: B'C'BC = SQR (D'E'DE)
               7665 ;     Inputs: A = loop counter (normally -31)
               7666 ;             B'C'BCH'L'HL initialised to 0
               7667 ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
               7668 ;
               7669 SQR1:
042DEF 52      7670 SBC.S   HL,BC
042DF0 ED 
042DF1 42 
042DF2 D9      7671 EXX
042DF3 52      7672 SBC.S   HL,BC
042DF4 ED 
042DF5 42 
042DF6 D9      7673 EXX
042DF7 0C      7674 INC     C
042DF8 30      7675 JR      NC,SQR2
042DF9 09 
042DFA 0D      7676 DEC     C
042DFB 52      7677 ADD.S   HL,BC
042DFC 09 
042DFD D9      7678 EXX
042DFE 52      7679 ADC.S   HL,BC
042DFF ED 
042E00 4A 
042E01 D9      7680 EXX
042E02 0D      7681 DEC     C
042E03 3C      7682 SQR2:			INC     A
042E04 F0      7683 RET     P
042E05 CB      7684 SQRA:			SLA     C
042E06 21 
042E07 CB      7685 RL      B
042E08 10 
042E09 D9      7686 EXX
042E0A CB      7687 RL      C
042E0B 11 
042E0C CB      7688 RL      B
042E0D 10 
042E0E D9      7689 EXX
042E0F 0C      7690 INC     C
042E10 CB      7691 SLA     E
042E11 23 
042E12 CB      7692 RL      D
042E13 12 
042E14 D9      7693 EXX
042E15 CB      7694 RL      E
042E16 13 
042E17 CB      7695 RL      D
042E18 12 
042E19 D9      7696 EXX
042E1A 52      7697 ADC.S   HL,HL
042E1B ED 
042E1C 6A 
042E1D D9      7698 EXX
042E1E 52      7699 ADC.S   HL,HL
042E1F ED 
042E20 6A 
042E21 D9      7700 EXX
042E22 CB      7701 SLA     E
042E23 23 
042E24 CB      7702 RL      D
042E25 12 
042E26 D9      7703 EXX
042E27 CB      7704 RL      E
042E28 13 
042E29 CB      7705 RL      D
042E2A 12 
042E2B D9      7706 EXX
042E2C 52      7707 ADC.S   HL,HL
042E2D ED 
042E2E 6A 
042E2F D9      7708 EXX
042E30 52      7709 ADC.S   HL,HL
042E31 ED 
042E32 6A 
042E33 D9      7710 EXX
042E34 D2      7711 JP      NC,SQR1
042E35 EF 
042E36 2D 
042E37 04 
042E38 B7      7712 SQR3:			OR      A
042E39 52      7713 SBC.S   HL,BC
042E3A ED 
042E3B 42 
042E3C D9      7714 EXX
042E3D 52      7715 SBC.S   HL,BC
042E3E ED 
042E3F 42 
042E40 D9      7716 EXX
042E41 0C      7717 INC     C
042E42 C3      7718 JP      SQR2
042E43 03 
042E44 2E 
042E45 04 
               7719 ;
               7720 SQRB:
042E46 52      7721 ADD.S   HL,HL
042E47 29 
042E48 D9      7722 EXX
042E49 52      7723 ADC.S   HL,HL
042E4A ED 
042E4B 6A 
042E4C D9      7724 EXX
042E4D 38      7725 JR      C,SQR3
042E4E E9 
042E4F 3C      7726 INC     A
042E50 0C      7727 INC     C
042E51 52      7728 SBC.S   HL,BC
042E52 ED 
042E53 42 
042E54 D9      7729 EXX
042E55 52      7730 SBC.S   HL,BC
042E56 ED 
042E57 42 
042E58 D9      7731 EXX
042E59 D0      7732 RET     NC
042E5A 52      7733 ADD.S   HL,BC
042E5B 09 
042E5C D9      7734 EXX
042E5D 52      7735 ADC.S   HL,BC
042E5E ED 
042E5F 4A 
042E60 D9      7736 EXX
042E61 0D      7737 DEC     C
042E62 C9      7738 RET
               7739 ;
042E63 DD      7740 DIGITQ:			LD      A,(IX)
042E64 7E 
042E65 00 
042E66 FE      7741 CP      '9'+1
042E67 3A 
042E68 3F      7742 CCF
042E69 D8      7743 RET     C
042E6A FE      7744 CP      '0'
042E6B 30 
042E6C C9      7745 RET
               7746 ;
042E6D DD      7747 SIGNQ:			LD      A,(IX)
042E6E 7E 
042E6F 00 
042E70 DD      7748 INC     IX
042E71 23 
042E72 FE      7749 CP      ' '
042E73 20 
042E74 28      7750 JR      Z,SIGNQ
042E75 F7 
042E76 FE      7751 CP      '+'
042E77 2B 
042E78 C8      7752 RET     Z
042E79 FE      7753 CP      '-'
042E7A 2D 
042E7B C8      7754 RET     Z
042E7C DD      7755 DEC     IX
042E7D 2B 
042E7E C9      7756 RET; --- End fpp.asm ---
               7757 
               7758 ; --- Begin gpio.asm ---
               7759 ;
               7760 ; Title:	BBC Basic for AGON - GPIO functions
               7761 ; Author:	Dean Belfield
               7762 ; Created:	12/05/2023
               7763 ; Last Updated:	12/05/2023
               7764 ;
               7765 ; Modinfo:
               7766 
               7767 ; INCLUDE	"macros.inc"
               7768 ; INCLUDE	"equs.inc"
               7769 
               7770 ; .ASSUME	ADL = 1
               7771 
               7772 ; SEGMENT CODE
               7773 
               7774 ; XDEF	GPIOB_SETMODE
               7775 
               7776 ; XREF	SWITCH_A
               7777 
               7778 ;  A: Mode
               7779 ;  B: Pins
               7780 ;
042E7F CD      7781 GPIOB_SETMODE:		CALL	SWITCH_A
042E80 24 
042E81 3E 
042E82 04 
042E83 97      7782 DW	GPIOB_M0	; Output
042E84 2E 
042E85 BC      7783 DW	GPIOB_M1	; Input
042E86 2E 
042E87 DC      7784 DW	GPIOB_M2	; Open Drain IO
042E88 2E 
042E89 FC      7785 DW	GPIOB_M3	; Open Source IO
042E8A 2E 
042E8B 17      7786 DW	GPIOB_M4	; Interrupt, Dual Edge
042E8C 2F 
042E8D 43      7787 DW	GPIOB_M5	; Alt Function
042E8E 2F 
042E8F 5E      7788 DW	GPIOB_M6	; Interrupt, Active Low
042E90 2F 
042E91 85      7789 DW	GPIOB_M7	; Interrupt, Active High
042E92 2F 
042E93 A7      7790 DW	GPIOB_M8	; Interrupt, Falling Edge
042E94 2F 
042E95 C9      7791 DW	GPIOB_M9	; Interrupt, Rising Edge
042E96 2F 
               7792 
               7793 ; Output
               7794 ;
               7795 GPIOB_M0:		RES_GPIO PB_DDR,  B
042E97 C5     0001M PUSH	BC
042E98 78     0002M LD	A, val
042E99 2F     0003M CPL
042E9A 4F     0004M LD	C, A
042E9B ED     0005M IN0	A, (reg)
042E9C 38 
042E9D 9B 
042E9E A1     0006M AND	C
042E9F ED     0007M OUT0	(reg), A
042EA0 39 
042EA1 9B 
042EA2 C1     0008M POP	BC
               7796 RES_GPIO PB_ALT1, B
042EA3 C5     0001M PUSH	BC
042EA4 78     0002M LD	A, val
042EA5 2F     0003M CPL
042EA6 4F     0004M LD	C, A
042EA7 ED     0005M IN0	A, (reg)
042EA8 38 
042EA9 9C 
042EAA A1     0006M AND	C
042EAB ED     0007M OUT0	(reg), A
042EAC 39 
042EAD 9C 
042EAE C1     0008M POP	BC
               7797 RES_GPIO PB_ALT2, B
042EAF C5     0001M PUSH	BC
042EB0 78     0002M LD	A, val
042EB1 2F     0003M CPL
042EB2 4F     0004M LD	C, A
042EB3 ED     0005M IN0	A, (reg)
042EB4 38 
042EB5 9D 
042EB6 A1     0006M AND	C
042EB7 ED     0007M OUT0	(reg), A
042EB8 39 
042EB9 9D 
042EBA C1     0008M POP	BC
042EBB C9      7798 RET
               7799 
               7800 ; Input
               7801 ;
               7802 GPIOB_M1:		SET_GPIO PB_DDR,  B
042EBC ED     0001M IN0	A, (reg)
042EBD 38 
042EBE 9B 
042EBF B0     0002M OR	val
042EC0 ED     0003M OUT0	(reg), A
042EC1 39 
042EC2 9B 
               7803 RES_GPIO PB_ALT1, B
042EC3 C5     0001M PUSH	BC
042EC4 78     0002M LD	A, val
042EC5 2F     0003M CPL
042EC6 4F     0004M LD	C, A
042EC7 ED     0005M IN0	A, (reg)
042EC8 38 
042EC9 9C 
042ECA A1     0006M AND	C
042ECB ED     0007M OUT0	(reg), A
042ECC 39 
042ECD 9C 
042ECE C1     0008M POP	BC
               7804 RES_GPIO PB_ALT2, B
042ECF C5     0001M PUSH	BC
042ED0 78     0002M LD	A, val
042ED1 2F     0003M CPL
042ED2 4F     0004M LD	C, A
042ED3 ED     0005M IN0	A, (reg)
042ED4 38 
042ED5 9D 
042ED6 A1     0006M AND	C
042ED7 ED     0007M OUT0	(reg), A
042ED8 39 
042ED9 9D 
042EDA C1     0008M POP	BC
042EDB C9      7805 RET
               7806 
               7807 ; Open Drain IO
               7808 ;
               7809 GPIOB_M2:		RES_GPIO PB_DDR,  B
042EDC C5     0001M PUSH	BC
042EDD 78     0002M LD	A, val
042EDE 2F     0003M CPL
042EDF 4F     0004M LD	C, A
042EE0 ED     0005M IN0	A, (reg)
042EE1 38 
042EE2 9B 
042EE3 A1     0006M AND	C
042EE4 ED     0007M OUT0	(reg), A
042EE5 39 
042EE6 9B 
042EE7 C1     0008M POP	BC
               7810 SET_GPIO PB_ALT1, B
042EE8 ED     0001M IN0	A, (reg)
042EE9 38 
042EEA 9C 
042EEB B0     0002M OR	val
042EEC ED     0003M OUT0	(reg), A
042EED 39 
042EEE 9C 
               7811 RES_GPIO PB_ALT2, B
042EEF C5     0001M PUSH	BC
042EF0 78     0002M LD	A, val
042EF1 2F     0003M CPL
042EF2 4F     0004M LD	C, A
042EF3 ED     0005M IN0	A, (reg)
042EF4 38 
042EF5 9D 
042EF6 A1     0006M AND	C
042EF7 ED     0007M OUT0	(reg), A
042EF8 39 
042EF9 9D 
042EFA C1     0008M POP	BC
042EFB C9      7812 RET
               7813 
               7814 ; Open Source IO
               7815 ;
               7816 GPIOB_M3:		SET_GPIO PB_DDR,  B
042EFC ED     0001M IN0	A, (reg)
042EFD 38 
042EFE 9B 
042EFF B0     0002M OR	val
042F00 ED     0003M OUT0	(reg), A
042F01 39 
042F02 9B 
               7817 SET_GPIO PB_ALT1, B
042F03 ED     0001M IN0	A, (reg)
042F04 38 
042F05 9C 
042F06 B0     0002M OR	val
042F07 ED     0003M OUT0	(reg), A
042F08 39 
042F09 9C 
               7818 RES_GPIO PB_ALT2, B
042F0A C5     0001M PUSH	BC
042F0B 78     0002M LD	A, val
042F0C 2F     0003M CPL
042F0D 4F     0004M LD	C, A
042F0E ED     0005M IN0	A, (reg)
042F0F 38 
042F10 9D 
042F11 A1     0006M AND	C
042F12 ED     0007M OUT0	(reg), A
042F13 39 
042F14 9D 
042F15 C1     0008M POP	BC
042F16 C9      7819 RET
               7820 
               7821 ; Interrupt, Dual Edge
               7822 ;
               7823 GPIOB_M4:		SET_GPIO PB_DR,   B
042F17 ED     0001M IN0	A, (reg)
042F18 38 
042F19 9A 
042F1A B0     0002M OR	val
042F1B ED     0003M OUT0	(reg), A
042F1C 39 
042F1D 9A 
               7824 RES_GPIO PB_DDR,  B
042F1E C5     0001M PUSH	BC
042F1F 78     0002M LD	A, val
042F20 2F     0003M CPL
042F21 4F     0004M LD	C, A
042F22 ED     0005M IN0	A, (reg)
042F23 38 
042F24 9B 
042F25 A1     0006M AND	C
042F26 ED     0007M OUT0	(reg), A
042F27 39 
042F28 9B 
042F29 C1     0008M POP	BC
               7825 RES_GPIO PB_ALT1, B
042F2A C5     0001M PUSH	BC
042F2B 78     0002M LD	A, val
042F2C 2F     0003M CPL
042F2D 4F     0004M LD	C, A
042F2E ED     0005M IN0	A, (reg)
042F2F 38 
042F30 9C 
042F31 A1     0006M AND	C
042F32 ED     0007M OUT0	(reg), A
042F33 39 
042F34 9C 
042F35 C1     0008M POP	BC
               7826 RES_GPIO PB_ALT2, B
042F36 C5     0001M PUSH	BC
042F37 78     0002M LD	A, val
042F38 2F     0003M CPL
042F39 4F     0004M LD	C, A
042F3A ED     0005M IN0	A, (reg)
042F3B 38 
042F3C 9D 
042F3D A1     0006M AND	C
042F3E ED     0007M OUT0	(reg), A
042F3F 39 
042F40 9D 
042F41 C1     0008M POP	BC
042F42 C9      7827 RET
               7828 
               7829 ; Alt Function
               7830 ;
               7831 GPIOB_M5:		SET_GPIO PB_DDR,  B
042F43 ED     0001M IN0	A, (reg)
042F44 38 
042F45 9B 
042F46 B0     0002M OR	val
042F47 ED     0003M OUT0	(reg), A
042F48 39 
042F49 9B 
               7832 RES_GPIO PB_ALT1, B
042F4A C5     0001M PUSH	BC
042F4B 78     0002M LD	A, val
042F4C 2F     0003M CPL
042F4D 4F     0004M LD	C, A
042F4E ED     0005M IN0	A, (reg)
042F4F 38 
042F50 9C 
042F51 A1     0006M AND	C
042F52 ED     0007M OUT0	(reg), A
042F53 39 
042F54 9C 
042F55 C1     0008M POP	BC
               7833 SET_GPIO PB_ALT2, B
042F56 ED     0001M IN0	A, (reg)
042F57 38 
042F58 9D 
042F59 B0     0002M OR	val
042F5A ED     0003M OUT0	(reg), A
042F5B 39 
042F5C 9D 
042F5D C9      7834 RET
               7835 
               7836 ; Interrupt, Active Low
               7837 ;
               7838 GPIOB_M6:		RES_GPIO PB_DR,   B
042F5E C5     0001M PUSH	BC
042F5F 78     0002M LD	A, val
042F60 2F     0003M CPL
042F61 4F     0004M LD	C, A
042F62 ED     0005M IN0	A, (reg)
042F63 38 
042F64 9A 
042F65 A1     0006M AND	C
042F66 ED     0007M OUT0	(reg), A
042F67 39 
042F68 9A 
042F69 C1     0008M POP	BC
               7839 RES_GPIO PB_DDR,  B
042F6A C5     0001M PUSH	BC
042F6B 78     0002M LD	A, val
042F6C 2F     0003M CPL
042F6D 4F     0004M LD	C, A
042F6E ED     0005M IN0	A, (reg)
042F6F 38 
042F70 9B 
042F71 A1     0006M AND	C
042F72 ED     0007M OUT0	(reg), A
042F73 39 
042F74 9B 
042F75 C1     0008M POP	BC
               7840 SET_GPIO PB_ALT1, B
042F76 ED     0001M IN0	A, (reg)
042F77 38 
042F78 9C 
042F79 B0     0002M OR	val
042F7A ED     0003M OUT0	(reg), A
042F7B 39 
042F7C 9C 
               7841 SET_GPIO PB_ALT2, B
042F7D ED     0001M IN0	A, (reg)
042F7E 38 
042F7F 9D 
042F80 B0     0002M OR	val
042F81 ED     0003M OUT0	(reg), A
042F82 39 
042F83 9D 
042F84 C9      7842 RET
               7843 
               7844 
               7845 ; Interrupt, Active High
               7846 ;
               7847 GPIOB_M7:		SET_GPIO PB_DR,   B
042F85 ED     0001M IN0	A, (reg)
042F86 38 
042F87 9A 
042F88 B0     0002M OR	val
042F89 ED     0003M OUT0	(reg), A
042F8A 39 
042F8B 9A 
               7848 RES_GPIO PB_DDR,  B
042F8C C5     0001M PUSH	BC
042F8D 78     0002M LD	A, val
042F8E 2F     0003M CPL
042F8F 4F     0004M LD	C, A
042F90 ED     0005M IN0	A, (reg)
042F91 38 
042F92 9B 
042F93 A1     0006M AND	C
042F94 ED     0007M OUT0	(reg), A
042F95 39 
042F96 9B 
042F97 C1     0008M POP	BC
               7849 SET_GPIO PB_ALT1, B
042F98 ED     0001M IN0	A, (reg)
042F99 38 
042F9A 9C 
042F9B B0     0002M OR	val
042F9C ED     0003M OUT0	(reg), A
042F9D 39 
042F9E 9C 
               7850 SET_GPIO PB_ALT2, B
042F9F ED     0001M IN0	A, (reg)
042FA0 38 
042FA1 9D 
042FA2 B0     0002M OR	val
042FA3 ED     0003M OUT0	(reg), A
042FA4 39 
042FA5 9D 
042FA6 C9      7851 RET
               7852 
               7853 
               7854 ; Interrupt, Falling Edge
               7855 ;
               7856 GPIOB_M8:		RES_GPIO PB_DR,   B
042FA7 C5     0001M PUSH	BC
042FA8 78     0002M LD	A, val
042FA9 2F     0003M CPL
042FAA 4F     0004M LD	C, A
042FAB ED     0005M IN0	A, (reg)
042FAC 38 
042FAD 9A 
042FAE A1     0006M AND	C
042FAF ED     0007M OUT0	(reg), A
042FB0 39 
042FB1 9A 
042FB2 C1     0008M POP	BC
               7857 SET_GPIO PB_DDR,  B
042FB3 ED     0001M IN0	A, (reg)
042FB4 38 
042FB5 9B 
042FB6 B0     0002M OR	val
042FB7 ED     0003M OUT0	(reg), A
042FB8 39 
042FB9 9B 
               7858 SET_GPIO PB_ALT1, B
042FBA ED     0001M IN0	A, (reg)
042FBB 38 
042FBC 9C 
042FBD B0     0002M OR	val
042FBE ED     0003M OUT0	(reg), A
042FBF 39 
042FC0 9C 
               7859 SET_GPIO PB_ALT2, B
042FC1 ED     0001M IN0	A, (reg)
042FC2 38 
042FC3 9D 
042FC4 B0     0002M OR	val
042FC5 ED     0003M OUT0	(reg), A
042FC6 39 
042FC7 9D 
042FC8 C9      7860 RET
               7861 
               7862 ; Interrupt, Rising Edge
               7863 ;
               7864 GPIOB_M9:		SET_GPIO PB_DR,   B
042FC9 ED     0001M IN0	A, (reg)
042FCA 38 
042FCB 9A 
042FCC B0     0002M OR	val
042FCD ED     0003M OUT0	(reg), A
042FCE 39 
042FCF 9A 
               7865 SET_GPIO PB_DDR,  B
042FD0 ED     0001M IN0	A, (reg)
042FD1 38 
042FD2 9B 
042FD3 B0     0002M OR	val
042FD4 ED     0003M OUT0	(reg), A
042FD5 39 
042FD6 9B 
               7866 SET_GPIO PB_ALT1, B
042FD7 ED     0001M IN0	A, (reg)
042FD8 38 
042FD9 9C 
042FDA B0     0002M OR	val
042FDB ED     0003M OUT0	(reg), A
042FDC 39 
042FDD 9C 
               7867 SET_GPIO PB_ALT2, B
042FDE ED     0001M IN0	A, (reg)
042FDF 38 
042FE0 9D 
042FE1 B0     0002M OR	val
042FE2 ED     0003M OUT0	(reg), A
042FE3 39 
042FE4 9D 
042FE5 C9      7868 RET	; --- End gpio.asm ---
               7869 
               7870 ; --- Begin main.asm ---
               7871 ;
               7872 ; Title:	BBC Basic Interpreter - Z80 version
               7873 ;		Command, Error and Lexical Analysis Module - "MAIN"
               7874 ; Author:	(C) Copyright  R.T.Russell  1984
               7875 ; Modified By:	Dean Belfield
               7876 ; Created:	12/05/2023
               7877 ; Last Updated:	26/11/2023
               7878 ;
               7879 ; Modinfo:
               7880 ; 07/05/1984:	Version 2.3
               7881 ; 01/03/1987:	Version 3.0
               7882 ; 03/05/2022:	Modified by Dean Belfield
               7883 ; 06/06/2023:	Modified to run in ADL mode
               7884 ; 26/06/2023:	Fixed binary and unary indirection
               7885 ; 17/08/2023:	Added binary constants
               7886 ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
               7887 ; 26/11/2023:	Fixed bug in AUTOLOAD
               7888 
               7889 ; .ASSUME	ADL = 1
               7890 
               7891 ; INCLUDE	"equs.inc"
               7892 
               7893 ; SEGMENT CODE
               7894 
               7895 ; XDEF	_main
               7896 
               7897 ; XDEF	COLD
               7898 ; XDEF	WARM
               7899 ; XDEF	CLOOP
               7900 ; XDEF	DELETE
               7901 ; XDEF	LIST_
               7902 ; XDEF	RENUM
               7903 ; XDEF	AUTO
               7904 ; XDEF	NEW
               7905 ; XDEF	OLD
               7906 ; XDEF	LOAD
               7907 ; XDEF	SAVE
               7908 ; XDEF	ERROR_
               7909 ; XDEF	EXTERR
               7910 ; XDEF	LOAD0
               7911 ; XDEF	CLEAR
               7912 ; XDEF	CRLF
               7913 ; XDEF	OUTCHR
               7914 ; XDEF	OUT_
               7915 ; XDEF	FINDL
               7916 ; XDEF	SETLIN
               7917 ; XDEF	PBCDL
               7918 ; XDEF	SAYLN
               7919 ; XDEF	PUTVAR
               7920 ; XDEF	GETVAR
               7921 ; XDEF	GETDEF
               7922 ; XDEF	CREATE
               7923 ; XDEF	RANGE
               7924 ; XDEF	LEXAN2
               7925 ; XDEF	REPORT
               7926 ; XDEF	TELL
               7927 ; XDEF	SPACE_
               7928 ; XDEF	KEYWDS
               7929 ; XDEF	KEYWDL
               7930 ; XDEF	ONEDIT
               7931 ; XDEF	ONEDIT1
               7932 ; XDEF	LISTIT
               7933 ; XDEF	CLEAN
               7934 
               7935 ; XREF	LISTON
               7936 ; XREF	ERRTXT
               7937 ; XREF	OSINIT
               7938 ; XREF	HIMEM
               7939 ; XREF	PAGE_
               7940 ; XREF	CHAIN0
               7941 ; XREF	PROMPT
               7942 ; XREF	ERRTRP
               7943 ; XREF	ERRLIN
               7944 ; XREF	AUTONO
               7945 ; XREF	LINENO
               7946 ; XREF	INCREM
               7947 ; XREF	OSLINE
               7948 ; XREF	COUNT
               7949 ; XREF	NXT
               7950 ; XREF	BUFFER
               7951 ; XREF	XEQ
               7952 ; XREF	TOP
               7953 ; XREF	EXPRI
               7954 ; XREF	SEARCH
               7955 ; XREF	LTRAP
               7956 ; XREF	LOMEM
               7957 ; XREF	DECODE
               7958 ; XREF	EXPRS
               7959 ; XREF	OSSAVE
               7960 ; XREF	ERR
               7961 ; XREF	ERL
               7962 ; XREF	TRACEN
               7963 ; XREF	RESET
               7964 ; XREF	OSSHUT
               7965 ; XREF	OSLOAD
               7966 ; XREF	FREE
               7967 ; XREF	DYNVAR
               7968 ; XREF	FILL
               7969 ; XREF	OSWRCH
               7970 ; XREF	WIDTH
               7971 ; XREF	COMMA
               7972 ; XREF	MUL16
               7973 ; XREF	BRAKET
               7974 ; XREF	X4OR5
               7975 ; XREF	LOADN
               7976 ; XREF	SFIX
               7977 ; XREF	ITEMI
               7978 ; XREF	FNPTR
               7979 ; XREF	PROPTR
               7980 ; XREF	CHECK
               7981 ; XREF	TERMQ
               7982 ; XREF	OSWRCHCH
               7983 ; XREF	NEWIT
               7984 ; XREF	BAD
               7985 ; XREF	RAM_START
               7986 ; XREF	RAM_END
               7987 ; XREF	R0
               7988 ; XREF	STAR_VERSION
               7989 
               7990 ; XREF	_end			; In init.asm
               7991 ;
               7992 ; A handful of common token IDs
               7993 ;
               7994 TERROR_MN:			EQU     85H
               7995 LINE_MN_:			EQU     86H
               7996 ELSE_MN_:			EQU     8BH
               7997 THEN_MN_:			EQU     8CH
               7998 LINO_MN:			EQU     8DH
               7999 FN:			EQU     A4H
               8000 TO_MN:			EQU     B8H
               8001 REN:			EQU     CCH
               8002 DATA_MN_:			EQU     DCH
               8003 DIM:			EQU     DEH
               8004 FOR:			EQU     E3H
               8005 GOSUB:			EQU     E4H
               8006 GOTO:			EQU     E5H
               8007 TIF:			EQU     E7H
               8008 LOCAL_:			EQU     EAH
               8009 NEXT:			EQU     EDH
               8010 ON_:			EQU     EEH
               8011 PROC:			EQU     F2H
               8012 REM:			EQU     F4H
               8013 REPEAT:			EQU     F5H
               8014 RESTOR:			EQU     F7H
               8015 TRACE:			EQU     FCH
               8016 UNTIL:			EQU     FDH
               8017 ;
               8018 ; This defines the block of tokens that are pseudo-variables.
               8019 ; There are two versions of each token, a GET and a SET
               8020 
               8021 ; Name  : GET : SET
               8022 ; ------:-----:----
               8023 ; PTR   : 8Fh : CFh
               8024 ; PAGE  : 90h : D0h
               8025 ; TIME  : 91h : D1h
               8026 ; LOMEM : 92h : D2h
               8027 ; HIMEM : 93h : D3h
               8028 ;
               8029 ; Examples:
               8030 ;   LET A% = PAGE : REM This is the GET version
               8031 ;   PAGE = 40000  : REM This is the SET version
               8032 ;
               8033 TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
               8034 TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
               8035 OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
               8036 
               8037 ; The main routine
               8038 ; IXU: argv - pointer to array of parameters
               8039 ;   C: argc - number of parameters
               8040 ; Returns:
               8041 ;  HL: Error code, or 0 if OK
               8042 ;
042FE6 21      8043 _main:			LD	HL, ACCS		; Clear the ACCS
042FE7 00 
042FE8 4A 
042FE9 04 
042FEA 36      8044 LD	(HL), 0
042FEB 00 
042FEC 79      8045 LD	A, C
042FED FE      8046 CP	2
042FEE 02 
042FEF 28      8047 JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF0 2D 
042FF1 38      8048 JR	C, COLD			; 1 parameter = normal start
042FF2 3F 
042FF3 CD      8049 CALL	STAR_VERSION
042FF4 79 
042FF5 40 
042FF6 04 
042FF7 CD      8050 CALL	TELL
042FF8 C0 
042FF9 3D 
042FFA 04 
042FFB 55      8051 DB	"Usage:\n\r"
042FFC 73 
042FFD 61 
042FFE 67 
042FFE 65   
042FFF 3A 
043000 0A 
043001 0D 
043003 52      8052 DB	"RUN . <filename>\n\r", 0
043004 55 
043005 4E 
043006 20 
043006 2E   
043007 20 
043008 3C 
043009 66 
043009 69   
04300A 6C 
04300B 65 
04300C 6E 
04300C 61   
04300D 6D 
04300E 65 
04300F 3E 
04300F 0A   
043010 0D 
043011 00 
043016 21      8053 LD	HL, 0			; The error code
043017 00 
043018 00 
043019 00 
04301A C3      8054 JP	_end
04301B 68 
04301C 00 
04301D 04 
               8055 ;
04301E DD      8056 AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
04301F 27 
043020 03 
043021 11      8057 LD	DE, ACCS		;  DE: Destination address
043022 00 
043023 4A 
043024 04 
043025 7E      8058 AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
043026 12      8059 LD	(DE), A			;
043027 23      8060 INC	HL			; Increase the source pointer
043028 1C      8061 INC	E			; We only need to increase E as ACCS is on a page boundary
043029 28      8062 JR	Z, AUTOLOAD_2		; End if we hit the page boundary
04302A 03 
04302B B7      8063 OR	A
04302C 20      8064 JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
04302D F7 
04302E 1D      8065 AUTOLOAD_2:		DEC	E
04302F 3E      8066 LD	A, CR
043030 0D 
043031 12      8067 LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
               8068 ;
043032 E1      8069 COLD:			POP	HL			; Pop the return address to init off SPS
043033 E5      8070 PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043034 21      8071 LD	HL, STAVAR		; Cold start
043035 00 
043036 4C 
043037 04 
043038 F9      8072 LD	SP, HL
043039 36      8073 LD	(HL), 10
04303A 0A 
04303B 23      8074 INC	HL
04303C 36      8075 LD	(HL),9
04303D 09 
04303E CD      8076 CALL    OSINIT			; Call the machine specific OS initialisation routines
04303F B1 
043040 3F 
043041 04 
043042 ED      8077 LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
043043 53 
043044 20 
043045 4D 
043045 04   
043047 22      8078 LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043048 14 
043049 4D 
04304A 04 
04304B 3E      8079 LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
04304C B7 
04304D 32      8080 LD      (LISTON),A
04304E 40 
04304F 4D 
043050 04 
043051 21      8081 LD      HL,NOTICE
043052 8C 
043053 30 
043054 04 
043055 22      8082 LD      (ERRTXT),HL
043056 2F 
043057 4D 
043058 04 
043059 CD      8083 CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
04305A 9C 
04305B 38 
04305C 04 
04305D 3A      8084 LD	A,(ACCS)		; Check if there is a filename in ACCS
04305E 00 
04305F 4A 
043060 04 
043061 B7      8085 OR	A
043062 C2      8086 JP	NZ,CHAIN0		; Yes, so load and run
043063 53 
043064 0B 
043065 04 
043066 CD      8087 CALL	STAR_VERSION		;
043067 79 
043068 40 
043069 04 
04306A CD      8088 CALL    TELL			; Output the welcome message
04306B C0 
04306C 3D 
04306D 04 
04306E 42      8089 DB    	"BBC BASIC (Z80) Version 3.00\n\r"
04306F 42 
043070 43 
043071 20 
043071 42   
043072 41 
043073 53 
043074 49 
043074 43   
043075 20 
043076 28 
043077 5A 
043077 38   
043078 30 
043079 29 
04307A 20 
04307A 56   
04307B 65 
04307C 72 
04307D 73 
04307D 69   
04307E 6F 
04307F 6E 
043080 20 
043080 33   
043081 2E 
043082 30 
043083 30 
043083 0A   
043084 0D 
04308C 28      8090 NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
04308D 43 
04308E 29 
04308F 20 
04308F 43   
043090 6F 
043091 70 
043092 79 
043092 72   
043093 69 
043094 67 
043095 68 
043095 74   
043096 20 
043097 52 
043098 2E 
043098 54   
043099 2E 
04309A 52 
04309B 75 
04309B 73   
04309C 73 
04309D 65 
04309E 6C 
04309E 6C   
04309F 20 
0430A0 31 
0430A1 39 
0430A1 38   
0430A2 37 
0430A3 0A 
0430A4 0D 
0430AC 0A      8091 DB	"\n\r", 0
0430AD 0D 
0430AE 00 
               8092 ;
0430AF F6      8093 WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
               8094 ;
               8095 ; This is the main entry point for BASIC
               8096 ;
0430B0 37      8097 CLOOP:			SCF				; See above - not sure why this is here!
0430B1 ED      8098 LD      SP,(HIMEM)
0430B2 7B 
0430B3 20 
0430B4 4D 
0430B4 04   
0430B6 CD      8099 CALL    PROMPT          	; Prompt user
0430B7 2A 
0430B8 3F 
0430B9 04 
0430BA 21      8100 LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430BB 40 
0430BC 4D 
0430BD 04 
0430BE 7E      8101 LD      A,(HL)			; Fetch the value
0430BF E6      8102 AND     0FH             	; Bottom nibble: LISTO
0430C0 0F 
0430C1 F6      8103 OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430C2 B0 
0430C3 77      8104 LD      (HL),A			; Store back in
0430C4 ED      8105 SBC     HL,HL           	; HL: 0
0430C5 62 
0430C6 22      8106 LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430C7 2C 
0430C8 4D 
0430C9 04 
0430CA 22      8107 LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430CB 35 
0430CC 4D 
0430CD 04 
               8108 ;
0430CE 2A      8109 LD      HL,(AUTONO)		; Get the auto line number
0430CF 29 
0430D0 4D 
0430D1 04 
0430D2 22      8110 LD      (LINENO),HL		; Store in line number
0430D3 23 
0430D4 4D 
0430D5 04 
0430D6 7C      8111 LD      A,H			; If the auto line number is zero then
0430D7 B5      8112 OR      L
0430D8 28      8113 JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430D9 1E 
               8114 ;
               8115 ; This section handles auto line numbering
               8116 ;
0430DA E5      8117 PUSH    HL			; Stack the line number
0430DB CD      8118 CALL    PBCD           	 	; Output the line number
0430DC 2B 
0430DD 3A 
0430DE 04 
0430DF E1      8119 POP     HL			; Pop the line number back off the stack
               8120 ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
               8121 ;			LD      B,0			; So clear B
0430E0 01      8122 LD	BC, 0			; Load BC with Increment
0430E1 00 
0430E2 00 
0430E3 00 
0430E4 3A      8123 LD	A,(INCREM)
0430E5 41 
0430E6 4D 
0430E7 04 
0430E8 4F      8124 LD	C, A
0430E9 09      8125 ADD     HL,BC			; Add the increment to the line number
0430EA DA      8126 JP      C,TOOBIG		; And error if we wrap
0430EB 55 
0430EC 3C 
0430ED 04 
0430EE 22      8127 LD      (AUTONO),HL		; Store the new auto line number
0430EF 29 
0430F0 4D 
0430F1 04 
0430F2 3E      8128 LD      A,' '			; Print a space
0430F3 20 
0430F4 CD      8129 CALL    OUTCHR
0430F5 7F 
0430F6 39 
0430F7 04 
               8130 ;
               8131 ; This section invokes the line editor
               8132 ;
0430F8 21      8133 NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0430F9 00 
0430FA 4A 
0430FB 04 
0430FC CD      8134 CALL    OSLINE          	; Call the line editor in MOS
0430FD 8F 
0430FE 3E 
0430FF 04 
043100 CD      8135 ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
043101 0C 
043102 31 
043103 04 
043104 DC      8136 CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
043105 6F 
043106 38 
043107 04 
043108 C3      8137 JP      CLOOP			; Jump back to immediate mode
043109 B0 
04310A 30 
04310B 04 
               8138 ;
               8139 ; This bit enters the line into memory
               8140 ; Also called from OSLOAD_TXT
               8141 ; Returns:
               8142 ; F: C if a new line has been entered (CLEAN will need to be called)
               8143 ;
04310C AF      8144 ONEDIT1:		XOR     A			; Entry point after *EDIT
04310D 32      8145 LD      (COUNT),A
04310E 3D 
04310F 4D 
043110 04 
043111 FD      8146 LD      IY,ACCS
043112 21 
043113 00 
043114 4A 
043114 04   
043116 CD      8147 CALL    LINNUM			; HL: The line number from the input buffer
043117 29 
043118 3C 
043119 04 
04311A CD      8148 CALL    NXT			; Skip spaces
04311B 70 
04311C 0A 
04311D 04 
04311E 7C      8149 LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
04311F B5      8150 OR      L
043120 28      8151 JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043121 04 
043122 22      8152 LD      (LINENO),HL		; Otherwise store it
043123 23 
043124 4D 
043125 04 
               8153 ;
               8154 ; This bit does the lexical analysis and tokenisation
               8155 ;
043126 0E      8156 LNZERO:			LD	C,1			; Left mode
043127 01 
043128 11      8157 LD      DE,BUFFER		; Buffer for tokenised BASIC
043129 00 
04312A 4B 
04312B 04 
04312C CD      8158 CALL    LEXAN2          	; Lexical analysis on the user input
04312D CF 
04312E 3C 
04312F 04 
043130 12      8159 LD      (DE),A          	; Terminator
043131 AF      8160 XOR     A
               8161 ;			LD      B,A
               8162 ;			LD      C,E             	; BC: Line length
043132 01      8163 LD	BC,0
043133 00 
043134 00 
043135 00 
043136 4B      8164 LD	C,E			; BC: Line length
043137 13      8165 INC     DE
043138 12      8166 LD      (DE),A          	; Zero next
043139 2A      8167 LD      HL,(LINENO)		; Get the line number
04313A 23 
04313B 4D 
04313C 04 
04313D 7C      8168 LD      A,H			; Is it zero, i.e. a command with no line number?
04313E B5      8169 OR      L
04313F FD      8170 LD      IY,BUFFER       	; Yes, so we're in immediate mode
043140 21 
043141 00 
043142 4B 
043142 04   
043144 CA      8171 JP      Z,XEQ           	; Execute it
043145 96 
043146 0B 
043147 04 
               8172 ;
               8173 ; This section stores the BASIC line in memory
               8174 ;
043148 C5      8175 PUSH    BC
043149 E5      8176 PUSH    HL
04314A CD      8177 CALL    SETTOP          	; Set TOP sysvar
04314B 7B 
04314C 38 
04314D 04 
04314E E1      8178 POP     HL
04314F CD      8179 CALL    FINDL			; Find the address of the line
043150 BF 
043151 39 
043152 04 
043153 CC      8180 CALL    Z,DEL			; Delete the existing line if found
043154 32 
043155 38 
043156 04 
043157 C1      8181 POP     BC
043158 79      8182 LD      A,C			; Check for the line length being zero, i.e.
043159 B7      8183 OR      A			; the user has just entered a line number in the command line
04315A C8      8184 RET	Z 	         	; If so, then don't do anything else
04315B C6      8185 ADD     A,4
04315C 04 
04315D 4F      8186 LD      C,A             	; Length inclusive
04315E D5      8187 PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
04315F C5      8188 PUSH    BC              	; BC: Line length
043160 EB      8189 EX      DE,HL			; DE: Address of the line in memory
043161 2A      8190 LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043162 17 
043163 4D 
043164 04 
043165 E5      8191 PUSH    HL			; Stack TOP (current TOP value)
043166 09      8192 ADD     HL,BC			; Add the line length to HL, the new TOP value
043167 E5      8193 PUSH    HL			; Stack HL (new TOP value)
043168 24      8194 INC     H			; Add 256 to HL
043169 AF      8195 XOR     A
04316A ED      8196 SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04316B 72 
04316C E1      8197 POP     HL			; Pop HL (new TOP value)
04316D D2      8198 JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
04316E 90 
04316F 37 
043170 04 
043171 22      8199 LD      (TOP),HL		; Store new value of TOP
043172 17 
043173 4D 
043174 04 
043175 E3      8200 EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043176 E5      8201 PUSH    HL			; PUSH current TOP value
043177 23      8202 INC     HL
043178 B7      8203 OR      A
043179 ED      8204 SBC     HL,DE			; DE: Address of the line in memory
04317A 52 
04317B 44      8205 LD      B,H             	; BC: Amount to move
04317C 4D      8206 LD      C,L
04317D E1      8207 POP     HL			; HL: Destination (current TOP value)
04317E D1      8208 POP     DE			; DE: Source (new TOP value)
04317F 28      8209 JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043180 02 
043181 ED      8210 LDDR                    	; Otherwise, make space for the new line in the program
043182 B8 
043183 C1      8211 ATEND:			POP     BC              	; BC: Line length
043184 D1      8212 POP     DE              	; DE: Line number
043185 23      8213 INC     HL			; HL: Destination address
043186 71      8214 LD      (HL),C          	; Store length
043187 23      8215 INC     HL
043188 73      8216 LD      (HL),E          	; Store line number
043189 23      8217 INC     HL
04318A 72      8218 LD      (HL),D
04318B 23      8219 INC     HL
04318C 11      8220 LD      DE,BUFFER		; DE: Location of the new, tokenised line
04318D 00 
04318E 4B 
04318F 04 
043190 EB      8221 EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043191 0D      8222 DEC     C			; Subtract 3 from the number of bytes to copy to
043192 0D      8223 DEC     C			; compensate for the 3 bytes stored above (length and line number)
043193 0D      8224 DEC     C
043194 ED      8225 LDIR                    	; Add the line to the BASIC program
043195 B0 
043196 37      8226 SCF				; To flag we need to call CLEAN
043197 C9      8227 RET
               8228 ;
               8229 ; List of tokens and keywords. If a keyword is followed by 0 then
               8230 ; it will only match with the keyword followed immediately by
               8231 ; a delimiter
               8232 ;
043198 80      8233 KEYWDS:			DB    80H, "AND"
043199 41 
04319A 4E 
04319B 44 
04319C 94      8234 DB    94H, "ABS"
04319D 41 
04319E 42 
04319F 53 
0431A0 95      8235 DB    95H, "ACS"
0431A1 41 
0431A2 43 
0431A3 53 
0431A4 96      8236 DB    96H, "ADVAL"
0431A5 41 
0431A6 44 
0431A7 56 
0431A7 41   
0431A8 4C 
0431AA 97      8237 DB    97H, "ASC"
0431AB 41 
0431AC 53 
0431AD 43 
0431AE 98      8238 DB    98H, "ASN"
0431AF 41 
0431B0 53 
0431B1 4E 
0431B2 99      8239 DB    99H, "ATN"
0431B3 41 
0431B4 54 
0431B5 4E 
0431B6 C6      8240 DB    C6H, "AUTO"
0431B7 41 
0431B8 55 
0431B9 54 
0431B9 4F   
0431BB 9A      8241 DB    9AH, "BGET", 0
0431BC 42 
0431BD 47 
0431BE 45 
0431BE 54   
0431BF 00 
0431C1 D5      8242 DB    D5H, "BPUT", 0
0431C2 42 
0431C3 50 
0431C4 55 
0431C4 54   
0431C5 00 
0431C7 FB      8243 DB    FBH, "COLOUR"
0431C8 43 
0431C9 4F 
0431CA 4C 
0431CA 4F   
0431CB 55 
0431CC 52 
0431CE FB      8244 DB    FBH, "COLOR"
0431CF 43 
0431D0 4F 
0431D1 4C 
0431D1 4F   
0431D2 52 
0431D4 D6      8245 DB    D6H, "CALL"
0431D5 43 
0431D6 41 
0431D7 4C 
0431D7 4C   
0431D9 D7      8246 DB    D7H, "CHAIN"
0431DA 43 
0431DB 48 
0431DC 41 
0431DC 49   
0431DD 4E 
0431DF BD      8247 DB    BDH, "CHR$"
0431E0 43 
0431E1 48 
0431E2 52 
0431E2 24   
0431E4 D8      8248 DB    D8H, "CLEAR", 0
0431E5 43 
0431E6 4C 
0431E7 45 
0431E7 41   
0431E8 52 
0431E9 00 
0431EB D9      8249 DB    D9H, "CLOSE", 0
0431EC 43 
0431ED 4C 
0431EE 4F 
0431EE 53   
0431EF 45 
0431F0 00 
0431F2 DA      8250 DB    DAH, "CLG", 0
0431F3 43 
0431F4 4C 
0431F5 47 
0431F5 00   
0431F7 DB      8251 DB    DBH, "CLS", 0
0431F8 43 
0431F9 4C 
0431FA 53 
0431FA 00   
0431FC 9B      8252 DB    9BH, "COS"
0431FD 43 
0431FE 4F 
0431FF 53 
043200 9C      8253 DB    9CH, "COUNT", 0
043201 43 
043202 4F 
043203 55 
043203 4E   
043204 54 
043205 00 
043207 DC      8254 DB    DCH, "DATA"
043208 44 
043209 41 
04320A 54 
04320A 41   
04320C 9D      8255 DB    9DH, "DEG"
04320D 44 
04320E 45 
04320F 47 
043210 DD      8256 DB    DDH, "DEF"
043211 44 
043212 45 
043213 46 
043214 C7      8257 DB    C7H, "DELETE"
043215 44 
043216 45 
043217 4C 
043217 45   
043218 54 
043219 45 
04321B 81      8258 DB    81H, "DIV"
04321C 44 
04321D 49 
04321E 56 
04321F DE      8259 DB    DEH, "DIM"
043220 44 
043221 49 
043222 4D 
043223 DF      8260 DB    DFH, "DRAW"
043224 44 
043225 52 
043226 41 
043226 57   
043228 E1      8261 DB    E1H, "ENDPROC", 0
043229 45 
04322A 4E 
04322B 44 
04322B 50   
04322C 52 
04322D 4F 
04322E 43 
04322E 00   
043231 E0      8262 DB    E0H, "END", 0
043232 45 
043233 4E 
043234 44 
043234 00   
043236 E2      8263 DB    E2H, "ENVELOPE"
043237 45 
043238 4E 
043239 56 
043239 45   
04323A 4C 
04323B 4F 
04323C 50 
04323C 45   
04323F 8B      8264 DB    8BH, "ELSE"
043240 45 
043241 4C 
043242 53 
043242 45   
043244 A0      8265 DB    A0H, "EVAL"
043245 45 
043246 56 
043247 41 
043247 4C   
043249 9E      8266 DB    9EH, "ERL", 0
04324A 45 
04324B 52 
04324C 4C 
04324C 00   
04324E 85      8267 DB    85H, "ERROR"
04324F 45 
043250 52 
043251 52 
043251 4F   
043252 52 
043254 C5      8268 DB    C5H, "EOF", 0
043255 45 
043256 4F 
043257 46 
043257 00   
043259 82      8269 DB    82H, "EOR"
04325A 45 
04325B 4F 
04325C 52 
04325D 9F      8270 DB    9FH, "ERR", 0
04325E 45 
04325F 52 
043260 52 
043260 00   
043262 A1      8271 DB    A1H, "EXP"
043263 45 
043264 58 
043265 50 
043266 A2      8272 DB    A2H, "EXT", 0
043267 45 
043268 58 
043269 54 
043269 00   
04326B E3      8273 DB    E3H, "FOR"
04326C 46 
04326D 4F 
04326E 52 
04326F A3      8274 DB    A3H, "FALSE", 0
043270 46 
043271 41 
043272 4C 
043272 53   
043273 45 
043274 00 
043276 A4      8275 DB    A4H, "FN"
043277 46 
043278 4E 
043279 E5      8276 DB    E5H, "GOTO"
04327A 47 
04327B 4F 
04327C 54 
04327C 4F   
04327E BE      8277 DB    BEH, "GET$"
04327F 47 
043280 45 
043281 54 
043281 24   
043283 A5      8278 DB    A5H, "GET"
043284 47 
043285 45 
043286 54 
043287 E4      8279 DB    E4H, "GOSUB"
043288 47 
043289 4F 
04328A 53 
04328A 55   
04328B 42 
04328D E6      8280 DB    E6H, "GCOL"
04328E 47 
04328F 43 
043290 4F 
043290 4C   
043292 93      8281 DB    93H, "HIMEM", 0
043293 48 
043294 49 
043295 4D 
043295 45   
043296 4D 
043297 00 
043299 E8      8282 DB    E8H, "INPUT"
04329A 49 
04329B 4E 
04329C 50 
04329C 55   
04329D 54 
04329F E7      8283 DB    E7H, "IF"
0432A0 49 
0432A1 46 
0432A2 BF      8284 DB    BFH, "INKEY$"
0432A3 49 
0432A4 4E 
0432A5 4B 
0432A5 45   
0432A6 59 
0432A7 24 
0432A9 A6      8285 DB    A6H, "INKEY"
0432AA 49 
0432AB 4E 
0432AC 4B 
0432AC 45   
0432AD 59 
0432AF A8      8286 DB    A8H, "INT"
0432B0 49 
0432B1 4E 
0432B2 54 
0432B3 A7      8287 DB    A7H, "INSTR("
0432B4 49 
0432B5 4E 
0432B6 53 
0432B6 54   
0432B7 52 
0432B8 28 
0432BA C9      8288 DB    C9H, "LIST"
0432BB 4C 
0432BC 49 
0432BD 53 
0432BD 54   
0432BF 86      8289 DB    86H, "LINE"
0432C0 4C 
0432C1 49 
0432C2 4E 
0432C2 45   
0432C4 C8      8290 DB    C8H, "LOAD"
0432C5 4C 
0432C6 4F 
0432C7 41 
0432C7 44   
0432C9 92      8291 DB    92H, "LOMEM", 0
0432CA 4C 
0432CB 4F 
0432CC 4D 
0432CC 45   
0432CD 4D 
0432CE 00 
0432D0 EA      8292 DB    EAH, "LOCAL"
0432D1 4C 
0432D2 4F 
0432D3 43 
0432D3 41   
0432D4 4C 
0432D6 C0      8293 DB    C0H, "LEFT$("
0432D7 4C 
0432D8 45 
0432D9 46 
0432D9 54   
0432DA 24 
0432DB 28 
0432DD A9      8294 DB    A9H, "LEN"
0432DE 4C 
0432DF 45 
0432E0 4E 
0432E1 E9      8295 DB    E9H, "LET"
0432E2 4C 
0432E3 45 
0432E4 54 
0432E5 AB      8296 DB    ABH, "LOG"
0432E6 4C 
0432E7 4F 
0432E8 47 
0432E9 AA      8297 DB    AAH, "LN"
0432EA 4C 
0432EB 4E 
0432EC C1      8298 DB    C1H, "MID$("
0432ED 4D 
0432EE 49 
0432EF 44 
0432EF 24   
0432F0 28 
0432F2 EB      8299 DB    EBH, "MODE"
0432F3 4D 
0432F4 4F 
0432F5 44 
0432F5 45   
0432F7 83      8300 DB    83H, "MOD"
0432F8 4D 
0432F9 4F 
0432FA 44 
0432FB EC      8301 DB    ECH, "MOVE"
0432FC 4D 
0432FD 4F 
0432FE 56 
0432FE 45   
043300 ED      8302 DB    EDH, "NEXT"
043301 4E 
043302 45 
043303 58 
043303 54   
043305 CA      8303 DB    CAH, "NEW", 0
043306 4E 
043307 45 
043308 57 
043308 00   
04330A AC      8304 DB    ACH, "NOT"
04330B 4E 
04330C 4F 
04330D 54 
04330E CB      8305 DB    CBH, "OLD", 0
04330F 4F 
043310 4C 
043311 44 
043311 00   
043313 EE      8306 DB    EEH, "ON"
043314 4F 
043315 4E 
043316 87      8307 DB    87H, "OFF"
043317 4F 
043318 46 
043319 46 
04331A 84      8308 DB    84H, "OR"
04331B 4F 
04331C 52 
04331D 8E      8309 DB    8EH, "OPENIN"
04331E 4F 
04331F 50 
043320 45 
043320 4E   
043321 49 
043322 4E 
043324 AE      8310 DB    AEH, "OPENOUT"
043325 4F 
043326 50 
043327 45 
043327 4E   
043328 4F 
043329 55 
04332A 54 
04332C AD      8311 DB    ADH, "OPENUP"
04332D 4F 
04332E 50 
04332F 45 
04332F 4E   
043330 55 
043331 50 
043333 FF      8312 DB    FFH, "OSCLI"
043334 4F 
043335 53 
043336 43 
043336 4C   
043337 49 
043339 F1      8313 DB    F1H, "PRINT"
04333A 50 
04333B 52 
04333C 49 
04333C 4E   
04333D 54 
04333F 90      8314 DB    90H, "PAGE", 0
043340 50 
043341 41 
043342 47 
043342 45   
043343 00 
043345 8F      8315 DB    8FH, "PTR", 0
043346 50 
043347 54 
043348 52 
043348 00   
04334A AF      8316 DB    AFH, "PI", 0
04334B 50 
04334C 49 
04334D 00 
04334E F0      8317 DB    F0H, "PLOT"
04334F 50 
043350 4C 
043351 4F 
043351 54   
043353 B0      8318 DB    B0H, "POINT("
043354 50 
043355 4F 
043356 49 
043356 4E   
043357 54 
043358 28 
04335A F2      8319 DB    F2H, "PROC"
04335B 50 
04335C 52 
04335D 4F 
04335D 43   
04335F B1      8320 DB    B1H, "POS", 0
043360 50 
043361 4F 
043362 53 
043362 00   
043364 CE      8321 DB    CEH, "PUT"
043365 50 
043366 55 
043367 54 
043368 F8      8322 DB    F8H, "RETURN", 0
043369 52 
04336A 45 
04336B 54 
04336B 55   
04336C 52 
04336D 4E 
04336E 00 
043370 F5      8323 DB    F5H, "REPEAT"
043371 52 
043372 45 
043373 50 
043373 45   
043374 41 
043375 54 
043377 F6      8324 DB    F6H, "REPORT", 0
043378 52 
043379 45 
04337A 50 
04337A 4F   
04337B 52 
04337C 54 
04337D 00 
04337F F3      8325 DB    F3H, "READ"
043380 52 
043381 45 
043382 41 
043382 44   
043384 F4      8326 DB    F4H, "REM"
043385 52 
043386 45 
043387 4D 
043388 F9      8327 DB    F9H, "RUN", 0
043389 52 
04338A 55 
04338B 4E 
04338B 00   
04338D B2      8328 DB    B2H, "RAD"
04338E 52 
04338F 41 
043390 44 
043391 F7      8329 DB    F7H, "RESTORE"
043392 52 
043393 45 
043394 53 
043394 54   
043395 4F 
043396 52 
043397 45 
043399 C2      8330 DB    C2H, "RIGHT$("
04339A 52 
04339B 49 
04339C 47 
04339C 48   
04339D 54 
04339E 24 
04339F 28 
0433A1 B3      8331 DB    B3H, "RND", 0
0433A2 52 
0433A3 4E 
0433A4 44 
0433A4 00   
0433A6 CC      8332 DB    CCH, "RENUMBER"
0433A7 52 
0433A8 45 
0433A9 4E 
0433A9 55   
0433AA 4D 
0433AB 42 
0433AC 45 
0433AC 52   
0433AF 88      8333 DB    88H, "STEP"
0433B0 53 
0433B1 54 
0433B2 45 
0433B2 50   
0433B4 CD      8334 DB    CDH, "SAVE"
0433B5 53 
0433B6 41 
0433B7 56 
0433B7 45   
0433B9 B4      8335 DB    B4H, "SGN"
0433BA 53 
0433BB 47 
0433BC 4E 
0433BD B5      8336 DB    B5H, "SIN"
0433BE 53 
0433BF 49 
0433C0 4E 
0433C1 B6      8337 DB    B6H, "SQR"
0433C2 53 
0433C3 51 
0433C4 52 
0433C5 89      8338 DB    89H, "SPC"
0433C6 53 
0433C7 50 
0433C8 43 
0433C9 C3      8339 DB    C3H, "STR$"
0433CA 53 
0433CB 54 
0433CC 52 
0433CC 24   
0433CE C4      8340 DB    C4H, "STRING$("
0433CF 53 
0433D0 54 
0433D1 52 
0433D1 49   
0433D2 4E 
0433D3 47 
0433D4 24 
0433D4 28   
0433D7 D4      8341 DB    D4H, "SOUND"
0433D8 53 
0433D9 4F 
0433DA 55 
0433DA 4E   
0433DB 44 
0433DD FA      8342 DB    FAH, "STOP", 0
0433DE 53 
0433DF 54 
0433E0 4F 
0433E0 50   
0433E1 00 
0433E3 B7      8343 DB    B7H, "TAN"
0433E4 54 
0433E5 41 
0433E6 4E 
0433E7 8C      8344 DB    8CH, "THEN"
0433E8 54 
0433E9 48 
0433EA 45 
0433EA 4E   
0433EC B8      8345 DB    B8H, "TO"
0433ED 54 
0433EE 4F 
0433EF 8A      8346 DB    8AH, "TAB("
0433F0 54 
0433F1 41 
0433F2 42 
0433F2 28   
0433F4 FC      8347 DB    FCH, "TRACE"
0433F5 54 
0433F6 52 
0433F7 41 
0433F7 43   
0433F8 45 
0433FA 91      8348 DB    91H, "TIME", 0
0433FB 54 
0433FC 49 
0433FD 4D 
0433FD 45   
0433FE 00 
043400 B9      8349 DB    B9H, "TRUE", 0
043401 54 
043402 52 
043403 55 
043403 45   
043404 00 
043406 FD      8350 DB    FDH, "UNTIL"
043407 55 
043408 4E 
043409 54 
043409 49   
04340A 4C 
04340C BA      8351 DB    BAH, "USR"
04340D 55 
04340E 53 
04340F 52 
043410 EF      8352 DB    EFH, "VDU"
043411 56 
043412 44 
043413 55 
043414 BB      8353 DB    BBH, "VAL"
043415 56 
043416 41 
043417 4C 
043418 BC      8354 DB    BCH, "VPOS", 0
043419 56 
04341A 50 
04341B 4F 
04341B 53   
04341C 00 
04341E FE      8355 DB    FEH, "WIDTH"
04341F 57 
043420 49 
043421 44 
043421 54   
043422 48 
043424 D3      8356 DB    D3H, "HIMEM"
043425 48 
043426 49 
043427 4D 
043427 45   
043428 4D 
04342A D2      8357 DB    D2H, "LOMEM"
04342B 4C 
04342C 4F 
04342D 4D 
04342D 45   
04342E 4D 
043430 D0      8358 DB    D0H, "PAGE"
043431 50 
043432 41 
043433 47 
043433 45   
043435 CF      8359 DB    CFH, "PTR"
043436 50 
043437 54 
043438 52 
043439 D1      8360 DB    D1H, "TIME"
04343A 54 
04343B 49 
04343C 4D 
04343C 45   
               8361 ;
               8362 ; These are indexed from the ERRWDS table
               8363 ;
04343E 01      8364 DB    01H, "Missing "
04343F 4D 
043440 69 
043441 73 
043441 73   
043442 69 
043443 6E 
043444 67 
043444 20   
043447 02      8365 DB    02H, "No such "
043448 4E 
043449 6F 
04344A 20 
04344A 73   
04344B 75 
04344C 63 
04344D 68 
04344D 20   
043450 03      8366 DB    03H, "Bad "
043451 42 
043452 61 
043453 64 
043453 20   
043455 04      8367 DB    04H, " range"
043456 20 
043457 72 
043458 61 
043458 6E   
043459 67 
04345A 65 
04345C 05      8368 DB    05H, "variable"
04345D 76 
04345E 61 
04345F 72 
04345F 69   
043460 61 
043461 62 
043462 6C 
043462 65   
043465 06      8369 DB    06H, "Out of"
043466 4F 
043467 75 
043468 74 
043468 20   
043469 6F 
04346A 66 
04346C 07      8370 DB    07H, "No "
04346D 4E 
04346E 6F 
04346F 20 
043470 08      8371 DB    08H, " space"
043471 20 
043472 73 
043473 70 
043473 61   
043474 63 
043475 65 
               8372 
               8373 KEYWDL:			EQU     $-KEYWDS
043477 FF      8374 DW    -1
043478 FF 
               8375 ;
               8376 ; Error messages
               8377 ;
043479 07      8378 ERRWDS:			DB    7, "room", 0		;  0: No room
04347A 72 
04347B 6F 
04347C 6F 
04347C 6D   
04347D 00 
04347F 06      8379 DB    6, 4, 0			;  1: Out of range
043480 04 
043481 00 
043482 00      8380 DB    0				;  2: *
043483 00      8381 DB    0				;  3: *
043484 4D      8382 DB    "Mistake", 0		;  4: Mistake
043485 69 
043486 73 
043487 74 
043487 61   
043488 6B 
043489 65 
04348A 00 
04348C 01      8383 DB    1, ",", 0			;  5: Missing ,
04348D 2C 
04348E 00 
04348F 54      8384 DB    "Type mismatch", 0	;  6: Type mismatch
043490 79 
043491 70 
043492 65 
043492 20   
043493 6D 
043494 69 
043495 73 
043495 6D   
043496 61 
043497 74 
043498 63 
043498 68   
043499 00 
04349D 07      8385 DB    7, FN, 0			;  7: No FN
04349E A4 
04349F 00 
0434A0 00      8386 DB    0				;  8: *
0434A1 01      8387 DB    1, 34, 0			;  9: Missing "
0434A2 22 
0434A3 00 
0434A4 03      8388 DB    3, DIM, 0			; 10: Bad DIM
0434A5 DE 
0434A6 00 
0434A7 DE      8389 DB    DIM, 8, 0			; 11: DIM space
0434A8 08 
0434A9 00 
0434AA 4E      8390 DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
0434AB 6F 
0434AC 74 
0434AD 20 
0434AD EA   
0434AE 00 
0434B0 07      8391 DB    7, PROC, 0		; 13: No PROC
0434B1 F2 
0434B2 00 
0434B3 41      8392 DB    "Array", 0		; 14: Array
0434B4 72 
0434B5 72 
0434B6 61 
0434B6 79   
0434B7 00 
0434B9 53      8393 DB    "Subscript", 0		; 15: Subscript
0434BA 75 
0434BB 62 
0434BC 73 
0434BC 63   
0434BD 72 
0434BE 69 
0434BF 70 
0434BF 74   
0434C0 00 
0434C3 53      8394 DB    "Syntax error", 0		; 16: Syntax error
0434C4 79 
0434C5 6E 
0434C6 74 
0434C6 61   
0434C7 78 
0434C8 20 
0434C9 65 
0434C9 72   
0434CA 72 
0434CB 6F 
0434CC 72 
0434CC 00   
0434D0 45      8395 DB    "Escape", 0		; 17: Escape
0434D1 73 
0434D2 63 
0434D3 61 
0434D3 70   
0434D4 65 
0434D5 00 
0434D7 44      8396 DB    "Division by zero", 0	; 18: Division by zero
0434D8 69 
0434D9 76 
0434DA 69 
0434DA 73   
0434DB 69 
0434DC 6F 
0434DD 6E 
0434DD 20   
0434DE 62 
0434DF 79 
0434E0 20 
0434E0 7A   
0434E1 65 
0434E2 72 
0434E3 6F 
0434E3 00   
0434E8 53      8397 DB    "String too long", 0	; 19: String too long
0434E9 74 
0434EA 72 
0434EB 69 
0434EB 6E   
0434EC 67 
0434ED 20 
0434EE 74 
0434EE 6F   
0434EF 6F 
0434F0 20 
0434F1 6C 
0434F1 6F   
0434F2 6E 
0434F3 67 
0434F4 00 
0434F8 54      8398 DB    "Too big", 0		; 20: Too big
0434F9 6F 
0434FA 6F 
0434FB 20 
0434FB 62   
0434FC 69 
0434FD 67 
0434FE 00 
043500 2D      8399 DB    "-ve root", 0		; 21: -ve root
043501 76 
043502 65 
043503 20 
043503 72   
043504 6F 
043505 6F 
043506 74 
043506 00   
043509 4C      8400 DB    "Log", 4, 0		; 22: Log range
04350A 6F 
04350B 67 
04350C 04 
04350C 00   
04350E 41      8401 DB    "Accuracy lost", 0	; 23: Accuracy lost
04350F 63 
043510 63 
043511 75 
043511 72   
043512 61 
043513 63 
043514 79 
043514 20   
043515 6C 
043516 6F 
043517 73 
043517 74   
043518 00 
04351C 45      8402 DB    "Exp", 4, 0		; 24: Exp range
04351D 78 
04351E 70 
04351F 04 
04351F 00   
043521 00      8403 DB    0				; 25: *
043522 02      8404 DB    2, 5, 0			; 26: No such variable
043523 05 
043524 00 
043525 01      8405 DB    1, ")", 0			; 27: Missing )
043526 29 
043527 00 
043528 03      8406 DB    3, "HEX", 0		; 28: Bad HEX
043529 48 
04352A 45 
04352B 58 
04352B 00   
04352D 02      8407 DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
04352E A4 
04352F 2F 
043530 F2 
043530 00   
043532 03      8408 DB    3, "call", 0		; 30: Bad call
043533 63 
043534 61 
043535 6C 
043535 6C   
043536 00 
043538 41      8409 DB    "Arguments", 0		; 31: Arguments
043539 72 
04353A 67 
04353B 75 
04353B 6D   
04353C 65 
04353D 6E 
04353E 74 
04353E 73   
04353F 00 
043542 07      8410 DB    7, FOR, 0			; 32: No FOR
043543 E3 
043544 00 
043545 43      8411 DB    "Can't match ", FOR, 0	; 33: Can't match FOR
043546 61 
043547 6E 
043548 27 
043548 74   
043549 20 
04354A 6D 
04354B 61 
04354B 74   
04354C 63 
04354D 68 
04354E 20 
04354E E3   
04354F 00 
043553 E3      8412 DB    FOR, " ", 5, 0		; 34: FOR variable
043554 20 
043555 05 
043556 00 
043557 00      8413 DB    0				; 35: *
043558 07      8414 DB    7, TO_MN, 0			; 36: No TO
043559 B8 
04355A 00 
04355B 00      8415 DB    0				; 37: *
04355C 07      8416 DB    7, GOSUB, 0		; 38: No GOSUB
04355D E4 
04355E 00 
04355F EE      8417 DB    ON_, " syntax", 0		; 39: ON syntax
043560 20 
043561 73 
043562 79 
043562 6E   
043563 74 
043564 61 
043565 78 
043565 00   
043568 EE      8418 DB    ON_, 4, 0			; 40: ON range
043569 04 
04356A 00 
04356B 02      8419 DB    2, "line", 0		; 41: No such line
04356C 6C 
04356D 69 
04356E 6E 
04356E 65   
04356F 00 
043571 06      8420 DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
043572 20 
043573 DC 
043574 00 
043575 07      8421 DB    7, REPEAT, 0		; 43: No REPEAT
043576 F5 
043577 00 
043578 00      8422 DB    0				; 44: *
043579 01      8423 DB    1, "#", 0			; 45: Missing #
04357A 23 
04357B 00 
               8424 ;
               8425 ; COMMANDS:
               8426 ;
               8427 ; DELETE line,line
               8428 ;
04357C CD      8429 DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
04357D 7B 
04357E 38 
04357F 04 
043580 CD      8430 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043581 83 
043582 3C 
043583 04 
043584 7E      8431 DELET1:			LD      A,(HL)			; Check whether it's the last line
043585 B7      8432 OR      A
043586 CA      8433 JP      Z,WARMNC		; Yes, so do nothing
043587 0D 
043588 36 
043589 04 
04358A 23      8434 INC     HL			; Skip the line length byte
04358B 11      8435 LD	DE, 0			; Clear DE
04358C 00 
04358D 00 
04358E 00 
04358F 5E      8436 LD      E,(HL)			; Fetch the line number in DE
043590 23      8437 INC     HL
043591 56      8438 LD      D,(HL)
043592 7A      8439 LD      A,D			; If the line number is zero then
043593 B3      8440 OR      E
043594 28      8441 JR      Z,CLOOP1        	; Do nothing
043595 1D 
043596 2B      8442 DEC     HL			; Decrement BASIC program pointer back to length
043597 2B      8443 DEC     HL
043598 EB      8444 EX      DE,HL			; Check if we've gone past the terminating line
043599 37      8445 SCF
04359A ED      8446 SBC     HL,BC
04359B 42 
04359C EB      8447 EX      DE,HL
04359D 30      8448 JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04359E 6E 
04359F C5      8449 PUSH    BC
0435A0 CD      8450 CALL    DEL			; Delete the line pointed to by HL
0435A1 32 
0435A2 38 
0435A3 04 
0435A4 C1      8451 POP     BC
0435A5 18      8452 JR      DELET1			; And loop round to the next line
0435A6 DD 
               8453 ;
               8454 ; LISTO expr
               8455 ;
0435A7 FD      8456 LISTO:			INC     IY              	; Skip "O" byte
0435A8 23 
0435A9 CD      8457 CALL    EXPRI			; Get expr
0435AA 0A 
0435AB 03 
0435AC 04 
0435AD D9      8458 EXX
0435AE 7D      8459 LD      A,L
0435AF 32      8460 LD      (LISTON),A		; Store in LISTON sysvar
0435B0 40 
0435B1 4D 
0435B2 04 
0435B3 C3      8461 CLOOP1:			JP      CLOOP
0435B4 B0 
0435B5 30 
0435B6 04 
               8462 ;
               8463 ; LIST
               8464 ; LIST line
               8465 ; LIST line,line [IF string]
               8466 ; LIST ,line
               8467 ; LIST line,
               8468 ;
0435B7 FE      8469 LIST_:			CP      'O'			; Check for O (LISTO)
0435B8 4F 
0435B9 28      8470 JR      Z,LISTO			; and jump to LISTO if zero
0435BA EC 
0435BB CD      8471 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435BC 83 
0435BD 3C 
0435BE 04 
0435BF CD      8472 CALL    NXT			; Skip space
0435C0 70 
0435C1 0A 
0435C2 04 
0435C3 FE      8473 CP      TIF             	; Check for IF clause (token IF)
0435C4 E7 
0435C5 3E      8474 LD      A,0             	; Initialise the IF clause string length
0435C6 00 
0435C7 20      8475 JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435C8 17 
               8476 ;
0435C9 FD      8477 INC     IY              	; Skip the IF token
0435CA 23 
0435CB CD      8478 CALL    NXT             	; And skip any spaces
0435CC 70 
0435CD 0A 
0435CE 04 
0435CF EB      8479 EX      DE,HL			; DE: Address in memory
0435D0 FD      8480 PUSH    IY			; LD IY, HL
0435D1 E5 
0435D2 E1      8481 POP     HL              	; HL is now the address of the tokenised line
0435D3 3E      8482 LD      A,CR
0435D4 0D 
0435D5 C5      8483 PUSH    BC			; Stack the second line number arg
0435D6 01      8484 LD      BC,256
0435D7 00 
0435D8 01 
0435D9 00 
0435DA ED      8485 CPIR                    	; Locate CR byte
0435DB B1 
0435DC 79      8486 LD      A,C
0435DD 2F      8487 CPL                    	 	; A: Substring length (of IF clause)
0435DE C1      8488 POP     BC			; Restore the second line number arg
0435DF EB      8489 EX      DE,HL			; HL: Address in memory
               8490 ;
0435E0 5F      8491 LISTB:			LD      E,A             	; E: IF clause string length
0435E1 78      8492 LD      A,B			; Check whether a second line number was passed (BC!=0)
0435E2 B1      8493 OR      C
0435E3 20      8494 JR      NZ,LISTA		; If there isn't a second line number
0435E4 01 
0435E5 0B      8495 DEC     BC			; then we set it to the maximum of 65535
               8496 ;
0435E6 D9      8497 LISTA:			EXX
0435E7 DD      8498 LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
0435E8 21 
0435E9 40 
0435EA 4D 
0435EA 04   
0435EC 01      8499 LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435ED 00 
0435EE 00 
0435EF 00 
0435F0 D9      8500 EXX
0435F1 3E      8501 LD      A,20			; Number of lines to list
0435F2 14 
               8502 ;
0435F3 C5      8503 LISTC:			PUSH    BC              	; Save second line number
0435F4 D5      8504 PUSH    DE              	; Save IF clause length
0435F5 E5      8505 PUSH    HL              	; Save BASIC program counter
0435F6 08      8506 EX      AF,AF'
               8507 ;
               8508 ; BBC BASIC for Z80 lines are stored as follows:
               8509 ;
               8510 ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
               8511 ; - [&00] [&FF] [&FF]: End of program marker
               8512 ;
               8513 ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
               8514 ;
0435F7 7E      8515 LD      A,(HL)			; Check for end of program marker
0435F8 B7      8516 OR      A			; If found
0435F9 28      8517 JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0435FA 12 
               8518 ;
               8519 ; Check if past terminating line number
               8520 ;
0435FB 7B      8521 LD      A,E             	; A: IF clause length
0435FC 23      8522 INC     HL			; Skip the length byte
0435FD 11      8523 LD	DE,0			; Clear DE
0435FE 00 
0435FF 00 
043600 00 
043601 5E      8524 LD      E,(HL)			; Fetch the line number in DE
043602 23      8525 INC     HL
043603 56      8526 LD      D,(HL)
043604 2B      8527 DEC     HL			; Step HL back to the length byte
043605 2B      8528 DEC     HL
043606 D5      8529 PUSH    DE             	 	; Push the line number on the stack
043607 EB      8530 EX      DE,HL			; HL: line number
043608 37      8531 SCF				; Do a 16-bit compare of HL and DE
043609 ED      8532 SBC     HL,BC
04360A 42 
04360B EB      8533 EX      DE,HL
04360C D1      8534 POP     DE              	; Restore the line number
04360D D2      8535 WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
04360E AF 
04360F 30 
043610 04 
043611 4E      8536 LD      C,(HL)          	; C: Line length + 4
043612 47      8537 LD      B,A             	; B: IF clause length
               8538 ;
               8539 ; Check if "UNLISTABLE":
               8540 ;
043613 7A      8541 LD      A,D			; TODO: What is "UNLISTABLE?"
043614 B3      8542 OR      E
043615 CA      8543 JP      Z,CLOOP
043616 B0 
043617 30 
043618 04 
               8544 ;
               8545 ; Check for IF clause:
               8546 ;
043619 23      8547 INC     HL			; Skip the length
04361A 23      8548 INC     HL			; Skip the line number
04361B 23      8549 INC     HL              	; HL: Address of the tokenised BASIC line
04361C 0D      8550 DEC     C			;  C: Line length
04361D 0D      8551 DEC     C
04361E 0D      8552 DEC     C
04361F 0D      8553 DEC     C
043620 D5      8554 PUSH    DE              	; Save the line number
043621 E5      8555 PUSH    HL              	; Save the BASIC program address
043622 AF      8556 XOR     A               	;
043623 B8      8557 CP      B              	 	; Check for an IF clause (B!=0)
043624 FD      8558 PUSH    IY			; LD IY, DE
043625 E5 
043626 D1      8559 POP     DE              	; DE: Address of the IF clause string in the input buffer
043627 C4      8560 CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
043628 85 
043629 07 
04362A 04 
04362B E1      8561 POP     HL              	; Restore BASIC program address
04362C D1      8562 POP     DE              	; Restore line number
04362D FD      8563 PUSH    IY
04362E E5 
04362F CC      8564 CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043630 C2 
043631 38 
043632 04 
043633 FD      8565 POP     IY
043634 E1 
               8566 ;
043635 08      8567 EX      AF,AF'
043636 3D      8568 DEC     A			; Decrement line list counter
043637 CD      8569 CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043638 A1 
043639 3F 
04363A 04 
04363B E1      8570 POP     HL             	 	; Restore BASIC program address to beginning of line
04363C 11      8571 LD	DE,0
04363D 00 
04363E 00 
04363F 00 
043640 5E      8572 LD      E,(HL)			; Fetch the length of line in DE
043641 19      8573 ADD     HL,DE           	; Go to the next line
043642 D1      8574 POP     DE              	; Restore IF clause length
043643 C1      8575 POP     BC              	; Restore second line number
043644 18      8576 JR      LISTC			; Loop back to do next line
043645 AD 
               8577 ;
               8578 ; RENUMBER
               8579 ; RENUMBER start
               8580 ; RENUMBER start,increment
               8581 ; RENUMBER ,increment
               8582 ;
043646 CD      8583 RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
043647 A6 
043648 38 
043649 04 
04364A CD      8584 CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04364B 5B 
04364C 3C 
04364D 04 
04364E D9      8585 EXX
04364F 2A      8586 LD      HL,(PAGE_)		; HL: Top of program
043650 14 
043651 4D 
043652 04 
043653 ED      8587 LD      DE,(LOMEM)		; DE: Start address of the heap
043654 5B 
043655 1A 
043656 4D 
043656 04   
               8588 ;
               8589 ; Build the table
               8590 ;
043658 7E      8591 RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043659 B7      8592 OR      A			; Is it zero, i.e. the end of program marker?
04365A 28      8593 JR      Z,RENUM2		; Yes, so skip to the next part
04365B 36 
04365C 23      8594 INC     HL
04365D 4E      8595 LD      C,(HL)          	; BC: The OLD line number
04365E 23      8596 INC     HL
04365F 46      8597 LD      B,(HL)
043660 78      8598 LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043661 B1      8599 OR      C
043662 CA      8600 JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043663 B0 
043664 30 
043665 04 
043666 EB      8601 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043667 71      8602 LD      (HL),C			; Store the OLD line number in the heap
043668 23      8603 INC     HL
043669 70      8604 LD      (HL),B
04366A 23      8605 INC     HL
04366B D9      8606 EXX				; HL: line number, BC: increment (16-bit values)
04366C E5      8607 PUSH    HL			; HL: Stack the NEW line number value
04366D 52      8608 ADD.S   HL,BC           	; Add the increment
04366E 09 
04366F DA      8609 JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043670 55 
043671 3C 
043672 04 
043673 D9      8610 EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
043674 C1      8611 POP     BC			; BC: Pop the NEW line number value off the stack
043675 71      8612 LD      (HL),C			; Store the NEW line number in the heap
043676 23      8613 INC     HL
043677 70      8614 LD      (HL),B
043678 23      8615 INC     HL
043679 EB      8616 EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
04367A 2B      8617 DEC     HL			; Back up to the line length byte
04367B 2B      8618 DEC     HL
04367C 01      8619 LD	BC, 0
04367D 00 
04367E 00 
04367F 00 
043680 4E      8620 LD      C,(HL)			; BC: Line length
043681 09      8621 ADD	HL,BC           	; Advance HL to next line
043682 EB      8622 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043683 E5      8623 PUSH    HL
043684 24      8624 INC     H			; Increment to next page
043685 ED      8625 SBC     HL,SP			; Subtract from SP
043686 72 
043687 E1      8626 POP     HL
043688 EB      8627 EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043689 38      8628 JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
04368A CD 
04368B CD      8629 CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04368C A7 
04368D 37 
04368E 04 
04368F CC      8630 DB    	REN
043690 08      8631 DB    	8
043691 00      8632 DB    	0
               8633 ;
               8634 ; At this point a list of BASIC line numbers have been written to the heap
               8635 ; as word pairs:
               8636 ; - DW: The OLD line number
               8637 ; - DW: The NEW line number
               8638 ;
043692 EB      8639 RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
043693 36      8640 LD      (HL),-1			; Mark the end with FFFFh
043694 FF 
043695 23      8641 INC     HL
043696 36      8642 LD      (HL),-1
043697 FF 
043698 ED      8643 LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
043699 5B 
04369A 1A 
04369B 4D 
04369B 04   
04369D D9      8644 EXX
04369E 2A      8645 LD      HL,(PAGE_)		; HL: Start of the BASIC program area
04369F 14 
0436A0 4D 
0436A1 04 
0436A2 4E      8646 RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436A3 79      8647 LD      A,C			; If it is zero, then no program, so...
0436A4 B7      8648 OR      A
0436A5 CA      8649 JP      Z,WARM			; Jump to warm start
0436A6 AF 
0436A7 30 
0436A8 04 
0436A9 D9      8650 EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436AA EB      8651 EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436AB 23      8652 INC     HL			; Skip to the NEW line number
0436AC 23      8653 INC     HL
0436AD 5E      8654 LD      E,(HL)			; DE: The NEW line number
0436AE 23      8655 INC     HL
0436AF 56      8656 LD      D,(HL)
0436B0 23      8657 INC     HL
0436B1 D5      8658 PUSH    DE			; Stack the NEW line number
0436B2 EB      8659 EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436B3 22      8660 LD      (LINENO),HL		; Store the line number in LINENO
0436B4 23 
0436B5 4D 
0436B6 04 
0436B7 D9      8661 EXX				; HL: Pointer to the BASIC program area
0436B8 D1      8662 POP     DE			; DE: The NEW line number
0436B9 23      8663 INC     HL
0436BA 73      8664 LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436BB 23      8665 INC     HL
0436BC 72      8666 LD      (HL),D
0436BD 23      8667 INC     HL
0436BE 0D      8668 DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436BF 0D      8669 DEC     C
0436C0 0D      8670 DEC     C
0436C1 79      8671 LD	A,C
0436C2 01      8672 LD	BC,0
0436C3 00 
0436C4 00 
0436C5 00 
0436C6 4F      8673 LD	C,A			; BC: Line length
               8674 ;
0436C7 3E      8675 RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436C8 8D 
0436C9 ED      8676 CPIR                    	; Search for the token
0436CA B1 
0436CB 20      8677 JR      NZ,RENUM3		; If not found, then loop to process the next line
0436CC D5 
               8678 ;
               8679 ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
               8680 ;
0436CD C5      8681 PUSH    BC			; Stack everything
0436CE E5      8682 PUSH    HL
0436CF E5      8683 PUSH    HL			; HL: Pointer to encoded line number
0436D0 FD      8684 POP     IY			; IY: Pointer to encoded line number
0436D1 E1 
0436D2 D9      8685 EXX
0436D3 CD      8686 CALL    DECODE			; Decode the encoded line number (in HL')
0436D4 E6 
0436D5 08 
0436D6 04 
0436D7 D9      8687 EXX				; HL: Decoded line number
0436D8 44      8688 LD      B,H			; BC: Decoded line number
0436D9 4D      8689 LD      C,L
0436DA 2A      8690 LD      HL,(LOMEM)		; HL: Pointer to heap
0436DB 1A 
0436DC 4D 
0436DD 04 
               8691 ;
               8692 ; This section of code cross-references the decoded (OLD) line number with the list
               8693 ; created previously in the global heap
               8694 ;
0436DE 5E      8695 RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436DF 23      8696 INC     HL
0436E0 56      8697 LD      D,(HL)
0436E1 23      8698 INC     HL
0436E2 EB      8699 EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436E3 B7      8700 OR      A               	; Clear the carry and...
0436E4 52      8701 SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436E5 ED 
0436E6 42 
0436E7 EB      8702 EX      DE,HL			; HL: Pointer in the global heap
0436E8 5E      8703 LD      E,(HL)          	; DE: The NEW line number
0436E9 23      8704 INC     HL
0436EA 56      8705 LD      D,(HL)
0436EB 23      8706 INC     HL
0436EC 38      8707 JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436ED F0 
0436EE EB      8708 EX      DE,HL			; DE: Pointer in the global heap
0436EF 28      8709 JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436F0 1D 
               8710 ;
0436F1 CD      8711 CALL    TELL			; Display this error if the line number is not found
0436F2 C0 
0436F3 3D 
0436F4 04 
0436F5 46      8712 DB    	"Failed at "
0436F6 61 
0436F7 69 
0436F8 6C 
0436F8 65   
0436F9 64 
0436FA 20 
0436FB 61 
0436FB 74   
0436FC 20 
0436FF 00      8713 DB    	0
043700 2A      8714 LD      HL,(LINENO)
043701 23 
043702 4D 
043703 04 
043704 CD      8715 CALL    PBCDL
043705 27 
043706 3A 
043707 04 
043708 CD      8716 CALL    CRLF
043709 77 
04370A 39 
04370B 04 
04370C 18      8717 JR      RENUM6			; And carry on renumbering
04370D 07 
               8718 ;
               8719 ; This snippet re-encodes the line number in the BASIC program
               8720 ;
04370E D1      8721 RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
04370F D5      8722 PUSH    DE
043710 1B      8723 DEC     DE			; Back up a byte to the LINO token
043711 CD      8724 CALL    ENCODE          	; Re-write the new line number out
043712 8C 
043713 3D 
043714 04 
043715 E1      8725 RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
043716 C1      8726 POP     BC			; BC: The remaining line length
043717 18      8727 JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
043718 AE 
               8728 ;
               8729 ; AUTO
               8730 ; AUTO start,increment
               8731 ; AUTO start
               8732 ; AUTO ,increment
               8733 ;
043719 CD      8734 AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
04371A 5B 
04371B 3C 
04371C 04 
04371D 22      8735 LD      (AUTONO),HL		; Store the start in AUTONO
04371E 29 
04371F 4D 
043720 04 
043721 79      8736 LD      A,C			; Increment is 8 bit (0-255)
043722 32      8737 LD      (INCREM),A		; Store that in INCREM
043723 41 
043724 4D 
043725 04 
043726 18      8738 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043727 2E 
               8739 ;
               8740 ; BAD
               8741 ; NEW
               8742 ;
043728 CD      8743 BAD:			CALL    TELL            	; Output "Bad program" error
043729 C0 
04372A 3D 
04372B 04 
04372C 03      8744 DB    3				; Token for "BAD"
04372D 70      8745 DB    "program"
04372E 72 
04372F 6F 
043730 67 
043730 72   
043731 61 
043732 6D 
043734 0D      8746 DB    CR
043735 0A      8747 DB    LF
043736 00      8748 DB    0				; Falls through to NEW
               8749 ;
043737 CD      8750 NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043738 9C 
043739 38 
04373A 04 
04373B 18      8751 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04373C 19 
               8752 ;
               8753 ; OLD
               8754 ;
04373D 2A      8755 OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
04373E 14 
04373F 4D 
043740 04 
043741 E5      8756 PUSH    HL			; Stack it
043742 23      8757 INC     HL			; Skip the potential length byte of first line of code
043743 23      8758 INC     HL			; And the line number word
043744 23      8759 INC     HL
043745 01      8760 LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043746 FC 
043747 00 
043748 00 
043749 3E      8761 LD      A,CR
04374A 0D 
04374B ED      8762 CPIR
04374C B1 
04374D 20      8763 JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04374E D9 
04374F 7D      8764 LD      A,L			; It could still be garbage though! Store the position in A; this requires
043750 E1      8765 POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043751 77      8766 LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043752 CD      8767 CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043753 6F 
043754 38 
043755 04 
043756 C3      8768 CLOOP0:			JP      CLOOP			; Jump back to the command loop
043757 B0 
043758 30 
043759 04 
               8769 ;
               8770 ; LOAD filename
               8771 ;
04375A CD      8772 LOAD:			CALL    EXPRS           	; Get the filename
04375B 15 
04375C 03 
04375D 04 
04375E 3E      8773 LD      A,CR			; DE points to the last byte of filename in ACCS
04375F 0D 
043760 12      8774 LD      (DE),A			; Terminate filename with a CR
043761 CD      8775 CALL    LOAD0			; Load the file in, then CLEAN
043762 4F 
043763 38 
043764 04 
043765 CD      8776 CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043766 A6 
043767 38 
043768 04 
043769 18      8777 JR      WARM0			; Jump back to the command loop
04376A 21 
               8778 ;
               8779 ; SAVE filename
               8780 ;
04376B CD      8781 SAVE:			CALL    SETTOP          	; Set TOP sysvar
04376C 7B 
04376D 38 
04376E 04 
04376F CD      8782 CALL    EXPRS           	; Get the filename
043770 15 
043771 03 
043772 04 
043773 3E      8783 LD      A,CR			; Terminate the filename with a CR
043774 0D 
043775 12      8784 LD      (DE),A
043776 ED      8785 LD      DE,(PAGE_)		; DE: Start of program memory
043777 5B 
043778 14 
043779 4D 
043779 04   
04377B 2A      8786 LD      HL,(TOP)		; HL: Top of program memory
04377C 17 
04377D 4D 
04377E 04 
04377F B7      8787 OR      A			; Calculate program size (TOP-PAGE)
043780 ED      8788 SBC     HL,DE
043781 52 
043782 44      8789 LD      B,H             	; BC: Length of program in bytes
043783 4D      8790 LD      C,L
043784 21      8791 LD      HL,ACCS			; HL: Address of the filename
043785 00 
043786 4A 
043787 04 
043788 CD      8792 CALL    OSSAVE			; Call the SAVE routine in patch.asm
043789 6E 
04378A 42 
04378B 04 
04378C C3      8793 WARM0:			JP      WARM			; Jump back to the command loop
04378D AF 
04378E 30 
04378F 04 
               8794 
               8795 ;
               8796 ; ERROR
               8797 ; Called whenever BASIC needs to halt with an error
               8798 ; Error messages are indexed from 0
               8799 ; Inputs:
               8800 ;  A: Error number
               8801 ;
043790 ED      8802 ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
043791 7B 
043792 20 
043793 4D 
043793 04   
043795 21      8803 LD      HL,ERRWDS		; Index into the error string table
043796 79 
043797 34 
043798 04 
043799 B7      8804 OR      A			; We don't need to search for the first error
04379A 28      8805 JR      Z,ERROR1		; So skip the search routine
04379B 0A 
               8806 ;
               8807 ; Search the error table for error #A
               8808 ; HL will end up being the pointer into the correct error
               8809 ; There is no bounds checking on this, so invalid error numbers will probably output garbage
               8810 ;
04379C 47      8811 LD      B,A             	; Store error number in B
04379D 08      8812 EX      AF,AF'			; Store error number in AF'
04379E AF      8813 XOR     A
04379F BE      8814 ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437A0 23      8815 INC     HL			; Increment the string pointer
0437A1 20      8816 JR      NZ,ERROR0		; Loop until with hit a 0
0437A2 FC 
0437A3 10      8817 DJNZ    ERROR0			; Decrements the error number and loop until 0
0437A4 FA 
0437A5 08      8818 EX      AF,AF'			; Restore the error number from AF'
               8819 ;
               8820 ; At this point HL points to the tokenised error string
               8821 ;
0437A6 E5      8822 ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
               8823 
               8824 ;
               8825 ; EXTERR
               8826 ; Inputs:
               8827 ;  A: Error number
               8828 ;
               8829 ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
               8830 ; The error text immediately follows the CALL to EXTERR, for example:
               8831 ; > CALL  EXTERR
               8832 ; > DB    "Silly", 0
               8833 ; So we can get the address of the string by popping the return address off the stack
               8834 ;
0437A7 E1      8835 EXTERR:			POP     HL			; Pop the error string pointer
0437A8 22      8836 LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437A9 2F 
0437AA 4D 
0437AB 04 
0437AC ED      8837 LD      SP,(HIMEM)		; Set SP to HIMEM
0437AD 7B 
0437AE 20 
0437AF 4D 
0437AF 04   
0437B1 32      8838 LD      (ERR),A			; Store error number in ERR sysvar
0437B2 3F 
0437B3 4D 
0437B4 04 
0437B5 CD      8839 CALL    SETLIN			; Get line number
0437B6 DE 
0437B7 39 
0437B8 04 
0437B9 22      8840 LD      (ERL),HL		; Store in ERL sysvar
0437BA 33 
0437BB 4D 
0437BC 04 
0437BD B7      8841 OR      A			; Is error number 0?
0437BE 28      8842 JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437BF 0D 
               8843 ;
0437C0 2A      8844 LD      HL,(ERRTRP)		; Check whether the error is trapped
0437C1 2C 
0437C2 4D 
0437C3 04 
0437C4 7C      8845 LD      A,H
0437C5 B5      8846 OR      L
0437C6 E5      8847 PUSH    HL			; HL: Error line
0437C7 FD      8848 POP     IY			; IY: HL
0437C8 E1 
0437C9 C2      8849 JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437CA 96 
0437CB 0B 
0437CC 04 
               8850 ;
0437CD 21      8851 ERROR2:			LD      HL,0
0437CE 00 
0437CF 00 
0437D0 00 
0437D1 22      8852 LD      (AUTONO),HL		; Cancel AUTO
0437D2 29 
0437D3 4D 
0437D4 04 
0437D5 22      8853 LD      (TRACEN),HL     	; Cancel TRACE
0437D6 26 
0437D7 4D 
0437D8 04 
0437D9 CD      8854 CALL    RESET           	; Reset OPSYS
0437DA F7 
0437DB 43 
0437DC 04 
0437DD CD      8855 CALL    CRLF			; Output newline
0437DE 77 
0437DF 39 
0437E0 04 
0437E1 CD      8856 CALL    REPORT          	; Output the error message
0437E2 B2 
0437E3 3D 
0437E4 04 
0437E5 CD      8857 CALL    SAYLN			; Output " at line nnnn" message.
0437E6 12 
0437E7 3A 
0437E8 04 
0437E9 1E      8858 LD      E,0			; Close all files
0437EA 00 
0437EB DC      8859 CALL    C,OSSHUT
0437EC 6C 
0437ED 43 
0437EE 04 
0437EF CD      8860 CALL    CRLF			; Output newline
0437F0 77 
0437F1 39 
0437F2 04 
0437F3 C3      8861 JP      CLOOP			; Back to CLOOP
0437F4 B0 
0437F5 30 
0437F6 04 
               8862 ;
               8863 ; SUBROUTINES:
               8864 ;
               8865 ; LEX - SEARCH FOR KEYWORDS
               8866 ;   Inputs: HL = start of keyword table
               8867 ;           IY = start of match text
               8868 ;  Outputs: If found, Z-flag set, A=token.
               8869 ;           If not found, Z-flag reset, A=(IY).
               8870 ;           IY updated (if NZ, IY unchanged).
               8871 ; Destroys: A,B,H,L,IY,F
               8872 ;
0437F7 21      8873 LEX:			LD      HL,KEYWDS		; Address of the keywords table
0437F8 98 
0437F9 31 
0437FA 04 
               8874 ;
0437FB FD      8875 LEX0:			LD      A,(IY)			; Fetch the character to match
0437FC 7E 
0437FD 00 
0437FE 46      8876 LD      B,(HL)			; B: The token from the keywords table
0437FF 23      8877 INC     HL			; Increment the pointer in the keywords table
043800 BE      8878 CP      (HL)			; Compare the first characters
043801 28      8879 JR      Z,LEX2			; If there is a match, then skip to LEX2
043802 08 
043803 D8      8880 RET     C               	; No match, so fail
               8881 ;
               8882 ; This snippet of code skips to the next token in the KEYWDS table
               8883 ;
043804 23      8884 LEX1:			INC     HL			; Increment the pointer
043805 CB      8885 BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
043806 7E 
043807 28      8886 JR      Z,LEX1			; No, so loop
043808 FB 
043809 18      8887 JR      LEX0			; At this point HL is pointing to the start of the next keyword
04380A F0 
               8888 ;
04380B FD      8889 LEX2:			PUSH    IY              	; Save the input pointer
04380C E5 
04380D 23      8890 LEX3:			INC     HL			; Increment the keyword pointer
04380E CB      8891 BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
04380F 7E 
043810 20      8892 JR      NZ,LEX6         	; Jump to here as we've found a token
043811 1C 
043812 FD      8893 INC     IY			; Increment the text pointer
043813 23 
043814 FD      8894 LD      A,(IY)			; Fetch the character
043815 7E 
043816 00 
043817 FE      8895 CP      '.'			; Is it an abbreviated keyword?
043818 2E 
043819 28      8896 JR      Z,LEX6          	; Yes, so we'll return with the token we've found
04381A 13 
04381B BE      8897 CP      (HL)			; Compare with the keywords list
04381C 28      8898 JR      Z,LEX3			; It's a match, so continue checking this keyword
04381D EF 
04381E CD      8899 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
04381F AB 
043820 3C 
043821 04 
043822 38      8900 JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
043823 04 
               8901 ;
043824 FD      8902 LEX4:			POP     IY              	; Restore the input pointer ready for the next search
043825 E1 
043826 18      8903 JR      LEX1			; And loop back to start again
043827 DC 
               8904 ;
               8905 ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
               8906 ; immediately delimited
               8907 ;
043828 7E      8908 LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
043829 B7      8909 OR      A			; If it is not zero, then...
04382A 20      8910 JR      NZ,LEX4			; Keep searching
04382B F8 
04382C FD      8911 DEC     IY			; If it is zero, then skip the input pointer back one byte
04382D 2B 
               8912 ;
               8913 ; We've found a token at this point
               8914 ;
04382E F1      8915 LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
04382F AF      8916 XOR     A			; Set the Z flag
043830 78      8917 LD      A,B			; A: The token
043831 C9      8918 RET
               8919 ;
               8920 ; DEL - DELETE A PROGRAM LINE.
               8921 ;   Inputs: HL addresses program line.
               8922 ; Destroys: B,C,F
               8923 ;
               8924 ; This simply erases the line by moving all of the code after the line to be deleted back over
               8925 ; it using an LDIR
               8926 ;
043832 D5      8927 DEL:			PUSH    DE
043833 E5      8928 PUSH    HL
043834 E5      8929 PUSH    HL			; HL: Address of the program line
043835 06      8930 LD      B,0			; BC: Length of the line
043836 00 
043837 4E      8931 LD      C,(HL)
043838 09      8932 ADD     HL,BC			; HL: Advanced to the start of the next line
043839 E5      8933 PUSH    HL
04383A EB      8934 EX      DE,HL			; DE: Pointer to the next line
04383B 2A      8935 LD      HL,(TOP)		; HL: Pointer to the end of the program
04383C 17 
04383D 4D 
04383E 04 
04383F ED      8936 SBC     HL,DE
043840 52 
043841 44      8937 LD      B,H			; BC: Size of block to move
043842 4D      8938 LD      C,L
043843 E1      8939 POP     HL			; HL: Pointer to next line
043844 D1      8940 POP     DE			; DE: Pointer to this line
043845 ED      8941 LDIR                    	; Delete the line
043846 B0 
043847 ED      8942 LD      (TOP),DE		; Adjust TOP
043848 53 
043849 17 
04384A 4D 
04384A 04   
04384C E1      8943 POP     HL
04384D D1      8944 POP     DE
04384E C9      8945 RET
               8946 ;
               8947 ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
               8948 ;   Inputs: Filename in ACCS (term CR)
               8949 ; Destroys: A,B,C,D,E,H,L,F
               8950 ;
               8951 ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
               8952 ; AND WRITE FF FF, THEN LOAD (TOP).
               8953 ; Destroys: A,B,C,H,L,F
               8954 ;
04384F ED      8955 LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
043850 5B 
043851 14 
043852 4D 
043852 04   
043854 21      8956 LD      HL,-256
043855 00 
043856 FF 
043857 FF 
043858 39      8957 ADD     HL,SP
043859 ED      8958 SBC     HL,DE           	; Find available space
04385A 52 
04385B 44      8959 LD      B,H
04385C 4D      8960 LD      C,L
04385D 21      8961 LD      HL,ACCS
04385E 00 
04385F 4A 
043860 04 
043861 CD      8962 CALL    OSLOAD          	; Call the OSLOAD function in patch
043862 D5 
043863 41 
043864 04 
043865 D4      8963 CALL    NC,NEWIT		; If NC then NEW
043866 9C 
043867 38 
043868 04 
043869 3E      8964 LD      A,0
04386A 00 
04386B D2      8965 JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04386C 90 
04386D 37 
04386E 04 
               8966 ;
04386F CD      8967 CLEAN:			CALL    SETTOP			; Set TOP sysvar
043870 7B 
043871 38 
043872 04 
043873 2B      8968 DEC     HL			; Write out the end of program markers
043874 36      8969 LD      (HL),-1
043875 FF 
043876 2B      8970 DEC     HL
043877 36      8971 LD      (HL),-1
043878 FF 
043879 18      8972 JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
04387A 2B 
               8973 ;
               8974 ; Set the TOP sysvar; the first free location after the end of the current program
               8975 ; Returns:
               8976 ; - HL: TOP
               8977 ;
04387B 2A      8978 SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04387C 14 
04387D 4D 
04387E 04 
04387F 01      8979 LD	BC, 0			; BC: 0
043880 00 
043881 00 
043882 00 
043883 3E      8980 LD      A,CR			; End of line marker
043884 0D 
043885 4E      8981 SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
043886 0C      8982 INC     C			; Check for zero
043887 0D      8983 DEC     C
043888 28      8984 JR      Z,SETOP2		; If it is zero, we've reached the end
043889 0A 
04388A 09      8985 ADD     HL,BC			; Skip to next line
04388B 2B      8986 DEC     HL			; Check end of previous line
04388C BE      8987 CP      (HL)
04388D 23      8988 INC     HL
04388E 28      8989 JR      Z,SETOP1		; If CR then loop
04388F F5 
043890 C3      8990 JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043891 28 
043892 37 
043893 04 
               8991 ;
043894 23      8992 SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
043895 23      8993 INC     HL			; NB: Called from NEWIT
043896 23      8994 INC     HL
043897 22      8995 LD      (TOP),HL		; Store in TOP sysvar
043898 17 
043899 4D 
04389A 04 
04389B C9      8996 RET
               8997 ;
               8998 ; NEWIT - NEW PROGRAM THEN CLEAR
               8999 ;   Destroys: H,L
               9000 ;
               9001 ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
               9002 ; FUNCTION AND PROCEDURE POINTERS.
               9003 ;   Destroys: Nothing
               9004 ;
04389C 2A      9005 NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
04389D 14 
04389E 4D 
04389F 04 
0438A0 36      9006 LD      (HL),0			; Stick a 0 in there
0438A1 00 
0438A2 CD      9007 CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438A3 94 
0438A4 38 
0438A5 04 
               9008 ;
0438A6 E5      9009 CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438A7 2A      9010 LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438A8 17 
0438A9 4D 
0438AA 04 
0438AB 22      9011 LD      (LOMEM),HL		; Set the LOMEM sysvar
0438AC 1A 
0438AD 4D 
0438AE 04 
0438AF 22      9012 LD      (FREE),HL		; And the FREE sysvar with that value
0438B0 1D 
0438B1 4D 
0438B2 04 
0438B3 21      9013 LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438B4 6C 
0438B5 4C 
0438B6 04 
0438B7 C5      9014 PUSH    BC
               9015 ; LD      B,3*(54+2)		; Loop counter
0438B8 06      9016 LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438B9 A8 
0438BA 36      9017 CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438BB 00 
0438BC 23      9018 INC     HL
0438BD 10      9019 DJNZ    CLEAR1
0438BE FB 
0438BF C1      9020 POP     BC
0438C0 E1      9021 POP     HL			; Restore the BASIC program pointer
0438C1 C9      9022 RET
               9023 ;
               9024 ;LISTIT - LIST A PROGRAM LINE.
               9025 ;    Inputs: HL addresses line
               9026 ;            DE = line number (binary)
               9027 ;            IX = Pointer to LISTON
               9028 ;             B = FOR/NEXT indent level
               9029 ;             C = REPEAT/UNTIL indent level
               9030 ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
               9031 ;
0438C2 E5      9032 LISTIT:			PUSH    HL			; Stack the address of the line
0438C3 EB      9033 EX      DE,HL			; HL: Line number
0438C4 C5      9034 PUSH    BC
0438C5 CD      9035 CALL    PBCD			; Print the line number
0438C6 2B 
0438C7 3A 
0438C8 04 
0438C9 C1      9036 POP     BC
0438CA E1      9037 POP     HL			; HL: Address of the first token/character
0438CB 7E      9038 LD      A,(HL)			; Fetch the token
0438CC FE      9039 CP      NEXT			; Is it NEXT...
0438CD ED 
0438CE CC      9040 CALL    Z,INDENT		; Yes, so indent in
0438CF 58 
0438D0 39 
0438D1 04 
0438D2 FE      9041 CP      UNTIL			; Or is it UNTIL...
0438D3 FD 
0438D4 CC      9042 CALL    Z,INDENT		; Yes, so indent in
0438D5 58 
0438D6 39 
0438D7 04 
0438D8 D9      9043 EXX
0438D9 3E      9044 LD      A,' '
0438DA 20 
0438DB DD      9045 BIT     0,(IX)			; If BIT 0 of LISTON is set
0438DC CB 
0438DD 00 
0438DE 46 
0438DF C4      9046 CALL    NZ,OUTCHR		; Then print a space after the line number
0438E0 7F 
0438E1 39 
0438E2 04 
0438E3 78      9047 LD      A,B			; Fetch the FOR/NEXT indent level
0438E4 87      9048 ADD     A,A			; Multiply by 2
0438E5 DD      9049 BIT     1,(IX)			; If BIT 1 of LISTON is set
0438E6 CB 
0438E7 00 
0438E8 4E 
0438E9 C4      9050 CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438EA 19 
0438EB 18 
0438EC 04 
0438ED 79      9051 LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438EE 87      9052 ADD     A,A			; Multiply by 2
0438EF DD      9053 BIT     2,(IX)			; If BIT 2 of LISTON is set
0438F0 CB 
0438F1 00 
0438F2 56 
0438F3 C4      9054 CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438F4 19 
0438F5 18 
0438F6 04 
0438F7 D9      9055 EXX
0438F8 7E      9056 LD      A,(HL)			; Fetch the token
0438F9 FE      9057 CP      FOR			; Is it FOR?
0438FA E3 
0438FB CC      9058 CALL    Z,INDENT		; Yes, so indent
0438FC 58 
0438FD 39 
0438FE 04 
0438FF FE      9059 CP      REPEAT			; Is it REPEAT?
043900 F5 
043901 CC      9060 CALL    Z,INDENT		; Yes, so indent
043902 58 
043903 39 
043904 04 
043905 1E      9061 LD      E,0			; E: The quote counter - reset to 0
043906 00 
043907 7E      9062 LIST8:			LD      A,(HL)			; Fetch a character / token byte
043908 23      9063 INC     HL
043909 FE      9064 CP      CR			; Is it end of line?
04390A 0D 
04390B 28      9065 JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
04390C 0B 
04390D FE      9066 CP      34			; Is it a quote character?
04390E 22 
04390F 20      9067 JR      NZ,LIST7		; No, so skip to next bit
043910 01 
043911 1C      9068 INC     E			; Otherwise increment quote counter
043912 CD      9069 LIST7:			CALL    LOUT			; Output the character / token
043913 47 
043914 39 
043915 04 
043916 18      9070 JR      LIST8			; And repeat
043917 EF 
               9071 ;
               9072 ; DB: Modification for *EDIT
               9073 ; Terminate the line with either a CRLF or a NUL character
               9074 ;
043918 DD      9075 LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
043919 CB 
04391A 00 
04391B 5E 
04391C 28      9076 JR	Z, CRLF			; Yes, so print a CRLF
04391D 59 
04391E AF      9077 XOR	A			; Otherwise print a NUL (0)
04391F C3      9078 JP	OSWRCH
043920 30 
043921 3F 
043922 04 
               9079 ;
               9080 ; Decode the 3 byte GOTO type line number
               9081 ;
043923 E5      9082 PRLINO:			PUSH    HL			; Swap HL and IY
043924 FD      9083 POP     IY			; IY: Pointer to the line number
043925 E1 
043926 C5      9084 PUSH    BC
043927 CD      9085 CALL    DECODE			; Decode
043928 E6 
043929 08 
04392A 04 
04392B C1      9086 POP     BC
04392C D9      9087 EXX
04392D C5      9088 PUSH    BC
04392E CD      9089 CALL    PBCDL			; Output the line number
04392F 27 
043930 3A 
043931 04 
043932 C1      9090 POP     BC
043933 D9      9091 EXX
043934 FD      9092 PUSH    IY			; Swap HL and IY
043935 E5 
043936 E1      9093 POP     HL			; HL: Pointer to the next character in the line
043937 C9      9094 RET
               9095 ;
               9096 ; DB: Modification for internationalisation
               9097 ;
043938 CD      9098 PRREM:			CALL	OUT_			; Output the REM token
043939 9C 
04393A 39 
04393B 04 
04393C 7E      9099 @@:			LD	A, (HL)			; Fetch the character
04393D FE      9100 CP	CR			; If it is end of line, then
04393E 0D 
04393F C8      9101 RET	Z			; we have finished
043940 CD      9102 CALL	OUTCHR			; Ouput the character
043941 7F 
043942 39 
043943 04 
043944 23      9103 INC	HL
043945 18      9104 JR	@B			; And loop
043946 F5 
               9105 ;
               9106 ; DB: End of modification
               9107 ;
043947 CB      9108 LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043948 43 
043949 20      9109 JR      NZ,OUTCHR		; don't tokenise, just output the character
04394A 34 
04394B FE      9110 CP	REM			; DB: Is it REM
04394C F4 
04394D 28      9111 JR	Z, PRREM		; DB: Yes so jump to the special case for REM
04394E E9 
04394F FE      9112 CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043950 8D 
043951 28      9113 JR      Z,PRLINO		; Yes, so decode and print the line number
043952 D0 
043953 CD      9114 CALL    OUT_			; Output a character / keyword
043954 9C 
043955 39 
043956 04 
043957 7E      9115 LD      A,(HL)			; Fetch the next character
               9116 ;
               9117 ; This block of code handles the indentation
               9118 ; B: Counter for FOR/NEXT indent
               9119 ; C: Counter for REPEAT/UNTIL indent
               9120 ;
043958 D9      9121 INDENT:			EXX
043959 FE      9122 CP      FOR			; If the token is FOR
04395A E3 
04395B 28      9123 JR      Z,IND1			; Then INC B
04395C 09 
04395D FE      9124 CP      NEXT			; If it is NEXT
04395E ED 
04395F 20      9125 JR      NZ,IND2_		; Then...
043960 06 
043961 05      9126 DEC     B			; DEC B
043962 F2      9127 JP      P,IND2_			; If we have gone below 0 then
043963 67 
043964 39 
043965 04 
043966 04      9128 IND1:			INC     B			; Increment back to 0
               9129 ;
043967 FE      9130 IND2_:			CP      REPEAT			; If the token is REPEAT
043968 F5 
043969 28      9131 JR      Z,IND3			; Then INC C
04396A 09 
04396B FE      9132 CP      UNTIL			; If it is UNTIL
04396C FD 
04396D 20      9133 JR      NZ,IND4			; Then...
04396E 06 
04396F 0D      9134 DEC     C			; DEC C
043970 F2      9135 JP      P,IND4			; If we have gone below 0 then
043971 75 
043972 39 
043973 04 
043974 0C      9136 IND3:			INC     C			; Incremet back to 0
043975 D9      9137 IND4:			EXX
043976 C9      9138 RET
               9139 ;
               9140 ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
               9141 ;  Destroys: A,F
               9142 ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
               9143 ;    Inputs: A = character
               9144 ;  Destroys: A,F
               9145 ;
043977 3E      9146 CRLF:			LD      A,CR			; Output CR
043978 0D 
043979 CD      9147 CALL    OUTCHR
04397A 7F 
04397B 39 
04397C 04 
04397D 3E      9148 LD      A,LF			; Output LF
04397E 0A 
               9149 ;
04397F CD      9150 OUTCHR:			CALL    OSWRCH			; Output the character in A
043980 30 
043981 3F 
043982 04 
043983 D6      9151 SUB     CR			; Check for CR
043984 0D 
043985 28      9152 JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
043986 06 
043987 D8      9153 RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043988 3A      9154 LD      A,(COUNT)		; Increment the count
043989 3D 
04398A 4D 
04398B 04 
04398C 3C      9155 INC     A
               9156 ;
04398D 32      9157 CARRET:			LD      (COUNT),A		; Store the new count value
04398E 3D 
04398F 4D 
043990 04 
043991 C8      9158 RET     Z			; Return if the count has wrapped to 0
043992 E5      9159 PUSH    HL			; Now check if count = print width
043993 2A      9160 LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
043994 3E 
043995 4D 
043996 04 
043997 BD      9161 CP      L			; L is the width. Compare it with count.
043998 E1      9162 POP     HL
043999 C0      9163 RET     NZ			; If we've not hit print width, then just return
04399A 18      9164 JR      CRLF			; Otherwise output CRLF
04399B DB 
               9165 ;
               9166 ; OUT - SEND CHARACTER OR KEYWORD
               9167 ;   Inputs: A = character (>=10, <128)
               9168 ;           A = Token (<10, >=128)
               9169 ;  Destroys: A,F
               9170 ;
04399C FE      9171 OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04399D 8A 
04399E EA      9172 JP      PE,OUTCHR		; If so, then it's a character, so just output it
04399F 7F 
0439A0 39 
0439A1 04 
               9173 ;
               9174 ; This bit looks up the character in the KEYWDS token table and expands it
               9175 ; Note the CP 138; this sets the overflow flag as follows:
               9176 ;
               9177 ; NB:
               9178 ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
               9179 ;  2. CP is effectively a SUB; sets the flags without affecting A
               9180 ;  3. The operation n - -118 ~ n + 118
               9181 ;
               9182 ; So:
               9183 ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
               9184 ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
               9185 ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
               9186 ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
               9187 ;
0439A2 C5      9188 PUSH    BC			; Preserve BC and HL
0439A3 E5      9189 PUSH    HL
0439A4 21      9190 LD      HL,KEYWDS		; The list of tokens and keywords
0439A5 98 
0439A6 31 
0439A7 04 
0439A8 01      9191 LD      BC,KEYWDL		; The length of the keyword list
0439A9 DF 
0439AA 02 
0439AB 00 
0439AC ED      9192 CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439AD B1 
               9193 ;							; At this point HL points to the next byte, the first character of the token
0439AE 7E      9194 TOKEN1:			LD      A,(HL)			; Fetch the character
0439AF 23      9195 INC     HL			; Increment to the next byte in the token table
0439B0 FE      9196 CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439B1 8A 
0439B2 F5      9197 PUSH    AF			; Then...
0439B3 EC      9198 CALL    PE,OUTCHR		; Output the character...
0439B4 7F 
0439B5 39 
0439B6 04 
0439B7 F1      9199 POP     AF			;
0439B8 EA      9200 JP      PE,TOKEN1		; And loop to the next character
0439B9 AE 
0439BA 39 
0439BB 04 
0439BC E1      9201 POP     HL			; Done, so tidy up the stack and exit
0439BD C1      9202 POP     BC
0439BE C9      9203 RET
               9204 ;
               9205 ; FINDL - FIND PROGRAM LINE
               9206 ;   Inputs: HL = line number (binary)
               9207 ;  Outputs: HL addresses line (if found)
               9208 ;           DE = line number
               9209 ;           Z-flag set if found.
               9210 ; Destroys: A,B,C,D,E,H,L,F
               9211 ;
0439BF EB      9212 FINDL:			EX      DE,HL			; DE: Line number (binary)
0439C0 2A      9213 LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439C1 14 
0439C2 4D 
0439C3 04 
0439C4 AF      9214 XOR     A               	;  A: 0
0439C5 BE      9215 CP      (HL)			; Check for end of program marker
0439C6 3C      9216 INC     A			;  A: 1
0439C7 D0      9217 RET     NC			; Return with 1 if 0
0439C8 AF      9218 XOR     A               	; Clear the carry flag
               9219 ;			LD      B,A			;  B: 0
0439C9 01      9220 LD	BC, 0			; BC: 0
0439CA 00 
0439CB 00 
0439CC 00 
               9221 ;
0439CD 4E      9222 FINDL1:			LD      C,(HL)			;  C: The line length
0439CE E5      9223 PUSH    HL			; Stack the current program counter
0439CF 23      9224 INC     HL			; Skip to the line number bytes
0439D0 7E      9225 LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439D1 23      9226 INC     HL
0439D2 66      9227 LD      H,(HL)
0439D3 6F      9228 LD      L,A
0439D4 52      9229 SBC.S   HL,DE			; Compare with the line number we're searching for
0439D5 ED 
0439D6 52 
0439D7 E1      9230 POP     HL			; Get the current program counter
0439D8 D0      9231 RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439D9 09      9232 ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439DA C3      9233 JP      FINDL1			; And loop
0439DB CD 
0439DC 39 
0439DD 04 
               9234 ;
               9235 ; SETLIN - Search program for line containing address
               9236 ;          Update (LINENO)
               9237 ;   Inputs: Address in (ERRLIN)
               9238 ;  Outputs: Line number in HL and (LINENO)
               9239 ; Destroys: B,C,D,E,H,L,F
               9240 ;
0439DE 01      9241 SETLIN:			LD	BC, 0			; Zero BC for later
0439DF 00 
0439E0 00 
0439E1 00 
               9242 ;			LD      B, 0			; Zero B for later
0439E2 ED      9243 LD      DE, (ERRLIN)		; DE: Address of line
0439E3 5B 
0439E4 35 
0439E5 4D 
0439E5 04   
0439E7 2A      9244 LD      HL, (PAGE_)		; HL: Start of user program area
0439E8 14 
0439E9 4D 
0439EA 04 
0439EB B7      9245 OR      A			; Do a 24 bit compare without destroying HL
0439EC ED      9246 SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439ED 52 
0439EE 19      9247 ADD     HL, DE			;  C: DE > HL
0439EF 30      9248 JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439F0 1B 
               9249 ;
0439F1 4E      9250 SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439F2 0C      9251 INC     C			; This is a way to check for zero without using the accumulator
0439F3 0D      9252 DEC     C			; If it is zero, then...
0439F4 28      9253 JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439F5 16 
0439F6 09      9254 ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439F7 ED      9255 SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0439F8 52 
0439F9 19      9256 ADD     HL, DE
0439FA 38      9257 JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0439FB F5 
0439FC ED      9258 SBC     HL, BC			; We've found it, so back up to the beginning of the line
0439FD 42 
0439FE 23      9259 INC     HL			; Skip the length counter
0439FF 11      9260 LD	DE, 0			; Zero DE
043A00 00 
043A01 00 
043A02 00 
043A03 5E      9261 LD      E, (HL)          	; Fetch the line number
043A04 23      9262 INC     HL
043A05 56      9263 LD      D, (HL)
043A06 EB      9264 EX      DE, HL			; HL: The line number
043A07 22      9265 SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A08 23 
043A09 4D 
043A0A 04 
043A0B C9      9266 RET
               9267 ;
043A0C 21      9268 SET3:			LD      HL, 0			; We've not found the line at this point so
043A0D 00 
043A0E 00 
043A0F 00 
043A10 18      9269 JR      SET2			; Set LINENO to 0
043A11 F5 
               9270 ;
               9271 ;SAYLN - PRINT " at line nnnn" MESSAGE.
               9272 ;  Outputs: Carry=0 if line number is zero.
               9273 ;           Carry=1 if line number is non-zero.
               9274 ; Destroys: A,B,C,D,E,H,L,F
               9275 ;
043A12 2A      9276 SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A13 23 
043A14 4D 
043A15 04 
043A16 7C      9277 LD      A,H			; If it is zero then
043A17 B5      9278 OR      L
043A18 C8      9279 RET     Z			; Don't need to do anything; return with F:C set to 0
043A19 CD      9280 CALL    TELL			; Output the error message
043A1A C0 
043A1B 3D 
043A1C 04 
043A1D 20      9281 DB    	" at line ", 0
043A1E 61 
043A1F 74 
043A20 20 
043A20 6C   
043A21 69 
043A22 6E 
043A23 65 
043A23 20   
043A24 00 
043A27 0E      9282 PBCDL:			LD      C,0			; C: Leading character (NUL)
043A28 00 
043A29 18      9283 JR      PBCD0			; Output the line number; return with F:C set to 1
043A2A 02 
               9284 ;
               9285 ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
               9286 ;   Inputs: HL = number (binary).
               9287 ;  Outputs: Carry = 1
               9288 ; Destroys: A,B,C,D,E,H,L,F
               9289 ;
043A2B 0E      9290 PBCD:			LD      C,' '			; C: Leading character (" ")
043A2C 20 
043A2D 06      9291 PBCD0:			LD      B,5			; Number of digits in result
043A2E 05 
043A2F 11      9292 LD      DE,10000		; Start off with the 10,000 column
043A30 10 
043A31 27 
043A32 00 
043A33 AF      9293 PBCD1:			XOR     A			; Counter
043A34 ED      9294 PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A35 52 
043A36 3C      9295 INC     A
043A37 30      9296 JR      NC,PBCD2
043A38 FB 
043A39 19      9297 ADD     HL,DE			; The loop overruns by one, so adjust here
043A3A 3D      9298 DEC     A			; A: Number of 10,000s
043A3B 28      9299 JR      Z,PBCD3			; If it is 0, then skip the next bit
043A3C 04 
043A3D CB      9300 SET     4,C			; C: Set to '0' ASCII (30h)
043A3E E1 
043A3F CB      9301 SET     5,C
043A40 E9 
043A41 B1      9302 PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A42 C4      9303 CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A43 7F 
043A44 39 
043A45 04 
043A46 78      9304 LD      A,B			; If on first transition, skip this
043A47 FE      9305 CP      5			; TODO: Need to find out why
043A48 05 
043A49 28      9306 JR      Z,PBCD4
043A4A 06 
043A4B 29      9307 ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A4C 54      9308 LD      D,H			;         : rather than shifting DE right
043A4D 5D      9309 LD      E,L			;         : This makes a lot of sense
043A4E 29      9310 ADD     HL,HL			; HL x  4
043A4F 29      9311 ADD     HL,HL			; HL x  8
043A50 19      9312 ADD     HL,DE			; HL x 10
043A51 11      9313 PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A52 E8 
043A53 03 
043A54 00 
043A55 10      9314 DJNZ    PBCD1			; Loop until done
043A56 DC 
043A57 37      9315 SCF				; SCF set for SAYLN in this module
043A58 C9      9316 RET
               9317 ;
               9318 ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
               9319 ;   Inputs: HL, IY as returned from GETVAR (NZ).
               9320 ;  Outputs: As GETVAR.
               9321 ; Destroys: everything
               9322 ;
043A59 CD      9323 PUTVAR:			CALL    CREATE			; Create the variable
043A5A DE 
043A5B 3B 
043A5C 04 
043A5D FD      9324 LD      A,(IY)			; Fetch the next character
043A5E 7E 
043A5F 00 
043A60 FE      9325 CP      '('			; Check for bad use of array
043A61 28 
043A62 20      9326 JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A63 70 
043A64 3E      9327 ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A65 0E 
043A66 C3      9328 ERROR3:			JP      ERROR_
043A67 90 
043A68 37 
043A69 04 
               9329 ;
               9330 ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
               9331 ;   Inputs: IY addresses first character.
               9332 ;  Outputs: Carry set and NZ if illegal character.
               9333 ;           Z-flag set if variable found, then:
               9334 ;            A = variable type (0,4,5,128 or 129)
               9335 ;            HL = IX = variable pointer.
               9336 ;            IY updated
               9337 ;           If Z-flag & carry reset, then:
               9338 ;            HL, IY set for subsequent PUTVAR call.
               9339 ; Destroys: everything
               9340 ;
043A6A FD      9341 GETVAR:			LD      A,(IY)			; Get the first character
043A6B 7E 
043A6C 00 
043A6D FE      9342 CP      '$'			; Is it a string?
043A6E 24 
043A6F 28      9343 JR      Z,GETV4			; Yes, so branch here
043A70 69 
043A71 FE      9344 CP      '!'			; Is it indirection (32-bit)?
043A72 21 
043A73 28      9345 JR      Z,GETV5			; Yes, so branch here
043A74 69 
043A75 FE      9346 CP      '?'			; Is it indirection (8-bit)?
043A76 3F 
043A77 28      9347 JR      Z,GETV6			; Yes, so branch here
043A78 69 
               9348 ;
043A79 CD      9349 CALL    LOCATE			; Locate the variable
043A7A 48 
043A7B 3B 
043A7C 04 
043A7D C0      9350 RET     NZ			; And exit here if not found
               9351 ;
               9352 ; At this point:
               9353 ;  HL: Address of variable in memory
               9354 ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
               9355 ;
043A7E FD      9356 LD      A,(IY)			; Further checks
043A7F 7E 
043A80 00 
043A81 FE      9357 CP      '('             	; Is it an array?
043A82 28 
043A83 20      9358 JR      NZ,GETVX        	; No, so exit
043A84 47 
               9359 ;
               9360 ; We are processing an array at this point
               9361 ;
043A85 D5      9362 PUSH    DE              	; Save the variable type (in D)
043A86 7E      9363 LD      A,(HL)          	; Fetch the number of dimensions
043A87 B7      9364 OR      A
043A88 28      9365 JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A89 DA 
043A8A 23      9366 INC     HL			;
043A8B 11      9367 LD      DE,0            	; Accumulator
043A8C 00 
043A8D 00 
043A8E 00 
043A8F F5      9368 PUSH    AF
043A90 FD      9369 INC     IY              	; Skip "("
043A91 23 
043A92 18      9370 JR      GETV3
043A93 05 
               9371 ;
043A94 F5      9372 GETV2:			PUSH    AF
043A95 CD      9373 CALL    COMMA
043A96 22 
043A97 0A 
043A98 04 
043A99 E5      9374 GETV3:			PUSH    HL
043A9A D5      9375 PUSH    DE
043A9B CD      9376 CALL    EXPRI			; Get the subscript
043A9C 0A 
043A9D 03 
043A9E 04 
043A9F D9      9377 EXX
043AA0 D1      9378 POP     DE
043AA1 E3      9379 EX      (SP),HL
043AA2 4E      9380 LD      C,(HL)
043AA3 23      9381 INC     HL
043AA4 46      9382 LD      B,(HL)
043AA5 23      9383 INC     HL
043AA6 E3      9384 EX      (SP),HL
043AA7 EB      9385 EX      DE,HL
043AA8 D5      9386 PUSH    DE
043AA9 CD      9387 CALL    MUL16			; HL=HL*BC
043AAA 9C 
043AAB 18 
043AAC 04 
043AAD D1      9388 POP     DE
043AAE 19      9389 ADD     HL,DE
043AAF EB      9390 EX      DE,HL
043AB0 B7      9391 OR      A
043AB1 ED      9392 SBC     HL,BC
043AB2 42 
043AB3 3E      9393 LD      A,15
043AB4 0F 
043AB5 30      9394 JR      NC,ERROR3		; Throw a "Subscript" error
043AB6 AF 
043AB7 E1      9395 POP     HL
043AB8 F1      9396 POP     AF
043AB9 3D      9397 DEC     A               	; Dimension counter
043ABA 20      9398 JR      NZ,GETV2
043ABB D8 
043ABC CD      9399 CALL    BRAKET          	; Check for closing bracket
043ABD 2F 
043ABE 0A 
043ABF 04 
043AC0 F1      9400 POP     AF              	; Restore the type
043AC1 E5      9401 PUSH    HL
043AC2 CD      9402 CALL    X4OR5           	; DE=DE*n
043AC3 8F 
043AC4 18 
043AC5 04 
043AC6 E1      9403 POP     HL
043AC7 19      9404 ADD     HL,DE
043AC8 57      9405 LD      D,A             	; The type
043AC9 FD      9406 LD      A,(IY)
043ACA 7E 
043ACB 00 
043ACC FE      9407 GETVX:			CP      '?'
043ACD 3F 
043ACE 28      9408 JR      Z,GETV9
043ACF 1E 
043AD0 FE      9409 CP      '!'
043AD1 21 
043AD2 28      9410 JR      Z,GETV8
043AD3 16 
043AD4 E5      9411 GETVZ:			PUSH    HL              	; Set exit conditions
043AD5 DD      9412 POP     IX
043AD6 E1 
043AD7 7A      9413 LD      A,D
043AD8 BF      9414 CP      A
043AD9 C9      9415 RET
               9416 ;
               9417 ; Process strings, unary & binary indirection:
               9418 ;
043ADA 3E      9419 GETV4:			LD      A,128           	; Static strings
043ADB 80 
043ADC 18      9420 JR      GETV7
043ADD 05 
               9421 ;
043ADE 3E      9422 GETV5:			LD      A,4             	; Unary 32-bit indirection
043ADF 04 
043AE0 18      9423 JR      GETV7
043AE1 01 
               9424 ;
043AE2 AF      9425 GETV6:			XOR     A               	; Unary 8-bit indirection
               9426 ;
043AE3 21      9427 GETV7:			LD      HL,0
043AE4 00 
043AE5 00 
043AE6 00 
043AE7 F5      9428 PUSH    AF
043AE8 18      9429 JR      GETV0
043AE9 24 
               9430 ;
043AEA 06      9431 GETV8:			LD      B,4             	; Binary 32-bt indirection
043AEB 04 
043AEC 18      9432 JR      GETVA
043AED 02 
               9433 ;
043AEE 06      9434 GETV9:			LD      B,0             	; Binary 8-bit indirection
043AEF 00 
               9435 ;
043AF0 E5      9436 GETVA:			PUSH    HL
043AF1 DD      9437 POP     IX
043AF2 E1 
043AF3 7A      9438 LD      A,D            		; Fetch the variable type
043AF4 FE      9439 CP      129			; Is it a string?
043AF5 81 
043AF6 C8      9440 RET     Z               	; Yes, so exit here
043AF7 C5      9441 PUSH    BC
043AF8 CD      9442 CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043AF9 16 
043AFA 04 
043AFB 04 
043AFC CD      9443 CALL    SFIX
043AFD 62 
043AFE 06 
043AFF 04 
043B00 7D      9444 LD	A,L
043B01 D9      9445 EXX
043B02 22      9446 LD	(R0+0),HL
043B03 4A 
043B04 4D 
043B05 04 
043B06 32      9447 LD	(R0+2),A
043B07 4C 
043B08 4D 
043B09 04 
043B0A 2A      9448 LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B0B 4A 
043B0C 4D 
043B0D 04 
               9449 ;
043B0E E5      9450 GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B0F FD      9451 INC     IY
043B10 23 
043B11 CD      9452 CALL    ITEMI
043B12 25 
043B13 03 
043B14 04 
043B15 7D      9453 LD	A,L			;  A: The MSB of the address
043B16 D9      9454 EXX
043B17 22      9455 LD	(R0+0),HL		; HL: The LSW of the address
043B18 4A 
043B19 4D 
043B1A 04 
043B1B 32      9456 LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B1C 4C 
043B1D 4D 
043B1E 04 
043B1F D1      9457 POP     DE
043B20 F1      9458 POP     AF
043B21 2A      9459 LD	HL,(R0)			; HL: L'HL
043B22 4A 
043B23 4D 
043B24 04 
043B25 19      9460 ADD     HL,DE
043B26 E5      9461 PUSH    HL
043B27 DD      9462 POP     IX
043B28 E1 
043B29 BF      9463 CP      A
043B2A C9      9464 RET
               9465 ;
               9466 ;GETDEF - Find entry for FN or PROC in dynamic area.
               9467 ;   Inputs: IY addresses byte following "DEF" token.
               9468 ;  Outputs: Z flag set if found
               9469 ;           Carry set if neither FN or PROC first.
               9470 ;           If Z: HL points to entry
               9471 ;                 IY addresses delimiter
               9472 ; Destroys: A,D,E,H,L,IY,F
               9473 ;
043B2B FD      9474 GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B2C 7E 
043B2D 01 
043B2E CD      9475 CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B2F AB 
043B30 3C 
043B31 04 
043B32 D8      9476 RET     C			; No so return with C set
043B33 FD      9477 LD      A,(IY)			; Fetch the current character from the tokenised line
043B34 7E 
043B35 00 
043B36 21      9478 LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B37 0E 
043B38 4D 
043B39 04 
043B3A FE      9479 CP      FN			; Is it the token FN?
043B3B A4 
043B3C 28      9480 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B3D 4A 
043B3E 21      9481 LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B3F 11 
043B40 4D 
043B41 04 
043B42 FE      9482 CP      PROC			; Is it the token PROC?
043B43 F2 
043B44 28      9483 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B45 42 
043B46 37      9484 SCF				; No, so just return with C set
043B47 C9      9485 RET
               9486 ;
               9487 ; LOCATE - Try to locate variable name in static or dynamic variables.
               9488 ; If illegal first character return carry, non-zero.
               9489 ; If found, return no-carry, zero.
               9490 ; If not found, return no-carry, non-zero.
               9491 ;   Inputs: IY=Addresses first character of name.
               9492 ;            A=(IY)
               9493 ;  Outputs:  F=Z set if found, then:
               9494 ;           IY=addresses terminator
               9495 ;           HL=addresses location of variable
               9496 ;            D=type of variable: 4 = integer
               9497 ;                                5 = floating point
               9498 ;                              129 = string
               9499 ; Destroys: A,D,E,H,L,IY,F
               9500 ;
               9501 ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
               9502 ; They can contain any alphanumeric character and underscore (_)
               9503 ; String variables are postfixed with the dollar ($) character
               9504 ; Integer variables are postfixed with the percent (%) character
               9505 ; Static integer variables are named @%, A% to Z%
               9506 ; All other variables are dynamic
               9507 ;
043B48 D6      9508 LOCATE:			SUB     '@'			; Check for valid range
043B49 40 
043B4A D8      9509 RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B4B 21      9510 LD      HL, 0			; Clear HL
043B4C 00 
043B4D 00 
043B4E 00 
043B4F FE      9511 CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B50 1B 
043B51 30      9512 JR      NC,LOC0         	; Then branch here
043B52 1E 
043B53 6F      9513 LD	L, A			; HL = A
043B54 FD      9514 LD      A,(IY+1)        	; Check the 2nd character
043B55 7E 
043B56 01 
043B57 FE      9515 CP      '%'			; If not "%" then it is not static...
043B58 25 
043B59 20      9516 JR      NZ,LOC1         	; Branch here
043B5A 21 
043B5B FD      9517 LD      A,(IY+2)		; Check the 3rd character
043B5C 7E 
043B5D 02 
043B5E FE      9518 CP      '('			; If it is "(" (array) then it is not static...
043B5F 28 
043B60 28      9519 JR      Z,LOC1          	; Branch here
043B61 1A 
               9520 ;
               9521 ; At this point we're dealing with a static variable
               9522 ;
043B62 29      9523 ADD     HL,HL			; HL: Variable index * 4
043B63 29      9524 ADD	HL,HL
043B64 11      9525 LD      DE,STAVAR       	; The static variable area in memory
043B65 00 
043B66 4C 
043B67 04 
043B68 19      9526 ADD     HL,DE			; HL: The address of the static variable
043B69 FD      9527 INC     IY			; Skip the program pointer past the static variable name
043B6A 23 
043B6B FD      9528 INC     IY
043B6C 23 
043B6D 16      9529 LD      D,4             	; Set the type to be integer
043B6E 04 
043B6F AF      9530 XOR     A			; Set the Z flag
043B70 C9      9531 RET
               9532 ;
               9533 ; At this point it's potentially a dynamic variable, just need to do a few more checks
               9534 ;
043B71 FE      9535 LOC0:			CP      '_'-'@'			; Check the first character is in
043B72 1F 
043B73 D8      9536 RET     C			; the range "_" to
043B74 FE      9537 CP      'z'-'@'+1		; "z" (lowercase characters only)
043B75 3B 
043B76 3F      9538 CCF				; If it is not in range then
043B77 3D      9539 DEC     A               	; Set NZ flag and
043B78 D8      9540 RET     C			; Exit here
043B79 D6      9541 SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B7A 03 
043B7B 6F      9542 LD	L, A			; HL = A
               9543 ;
               9544 ; Yes, it's definitely a dynamic variable at this point...
               9545 ;
043B7C 7D      9546 LOC1:			LD	A, L			; Fetch variable index
043B7D 87      9547 ADD	A, A			; x 2
043B7E 85      9548 ADD	A, L			; x 3
043B7F D6      9549 SUB	3			; Subtract 2 TODO: Should be 3
043B80 03 
043B81 6F      9550 LD	L, A
043B82 11      9551 LD      DE, DYNVAR       	; The dynamic variable storage
043B83 6C 
043B84 4C 
043B85 04 
043B86 D8      9552 RET	C			; Bounds check to trap for variable '@'
043B87 19      9553 ADD     HL, DE			; HL: Address of first entry
               9554 ;
               9555 ; Loop through the linked list of variables to find a match
               9556 ;
043B88 ED      9557 LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B89 17 
043B8A E5      9558 PUSH	HL			; Need to preserve HL for LOC6
043B8B AF      9559 XOR	A			; Reset carry flag
043B8C ED      9560 SBC	HL, HL			; Set HL to 0
043B8D 62 
043B8E ED      9561 SBC	HL, DE			; Compare with 0
043B8F 52 
043B90 E1      9562 POP	HL			; Restore the original pointer
043B91 28      9563 JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B92 49 
               9564 ; LD	HL, DE			; Make a copy of this pointer in HL
043B93 D5      9565 push de
043B94 E1      9566 pop hl ; how was that even possible?
043B95 23      9567 INC     HL              	; Skip the link (24-bits)
043B96 23      9568 INC     HL
043B97 23      9569 INC	HL			; HL: Address of the variable name in DYNVARS
043B98 FD      9570 PUSH    IY			; IY: Address of the variable name in the program
043B99 E5 
               9571 ;
043B9A 7E      9572 LOC3:			LD      A,(HL)         		; Compare
043B9B 23      9573 INC     HL
043B9C FD      9574 INC     IY
043B9D 23 
043B9E FD      9575 CP      (IY)
043B9F BE 
043BA0 00 
043BA1 28      9576 JR      Z, LOC3			; Keep looping whilst we've got a match...
043BA2 F7 
043BA3 B7      9577 OR      A               	; Have we hit a terminator?
043BA4 28      9578 JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BA5 07 
               9579 ;
043BA6 FD      9580 LOC4:			POP     IY			; Restore the pointer in the program
043BA7 E1 
043BA8 EB      9581 EX      DE, HL			; HL: New pointer in DYNVARS
043BA9 C3      9582 JP      LOC2            	; Loop round and try again
043BAA 88 
043BAB 3B 
043BAC 04 
               9583 ;
               9584 ; We might have located a variable at this point, just need to do a few more tests
               9585 ;
043BAD FD      9586 LOC5:			DEC     IY
043BAE 2B 
043BAF FD      9587 LD      A,(IY)
043BB0 7E 
043BB1 00 
043BB2 FE      9588 CP      '('
043BB3 28 
043BB4 28      9589 JR      Z,LOC5A         	; FOUND
043BB5 15 
043BB6 FD      9590 INC     IY
043BB7 23 
043BB8 CD      9591 CALL    RANGE
043BB9 9F 
043BBA 3C 
043BBB 04 
043BBC 38      9592 JR      C,LOC5A         	; FOUND
043BBD 0D 
043BBE FE      9593 CP      '('
043BBF 28 
043BC0 28      9594 JR      Z,LOC4          	; KEEP LOOKING
043BC1 E4 
043BC2 FD      9595 LD      A,(IY-1)
043BC3 7E 
043BC4 FF 
043BC5 CD      9596 CALL    RANGE1
043BC6 AB 
043BC7 3C 
043BC8 04 
043BC9 30      9597 JR      NC,LOC4         	; KEEP LOOKING
043BCA DB 
043BCB D1      9598 LOC5A:			POP     DE
043BCC FD      9599 TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BCD 7E 
043BCE FF 
043BCF FE      9600 CP      '$'			; Is it a string?
043BD0 24 
043BD1 16      9601 LD      D,129			; Yes, so return D = 129
043BD2 81 
043BD3 C8      9602 RET     Z
043BD4 FE      9603 CP      '%'			; Is it an integer?
043BD5 25 
043BD6 16      9604 LD      D,4			; Yes, so return D = 4
043BD7 04 
043BD8 C8      9605 RET     Z
043BD9 14      9606 INC     D			; At this point it must be a float
043BDA BF      9607 CP      A			; Set the flags
043BDB C9      9608 RET
               9609 ;
               9610 ; The variable is undefined at this point; HL will be zero
               9611 ;
043BDC 3C      9612 LOC6:			INC     A               	; Set NZ flag
043BDD C9      9613 RET
               9614 ;
               9615 ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
               9616 ;   Inputs: HL, IY as returned from LOCATE (NZ).
               9617 ;  Outputs: As LOCATE, GETDEF.
               9618 ; Destroys: As LOCATE, GETDEF.
               9619 ;
043BDE AF      9620 CREATE:			XOR     A
043BDF ED      9621 LD      DE,(FREE)		; Get the last byte of available RAM
043BE0 5B 
043BE1 1D 
043BE2 4D 
043BE2 04   
043BE4 ED      9622 LD	(HL), DE		; Store
043BE5 1F 
043BE6 EB      9623 EX      DE,HL
043BE7 77      9624 LD      (HL),A			; Clear the link of the new entity
043BE8 23      9625 INC     HL
043BE9 77      9626 LD      (HL),A
043BEA 23      9627 INC     HL
043BEB 77      9628 LD      (HL),A
043BEC 23      9629 INC     HL
043BED FD      9630 LOC7:			INC     IY
043BEE 23 
043BEF CD      9631 CALL    RANGE           	; END OF VARIABLE?
043BF0 9F 
043BF1 3C 
043BF2 04 
043BF3 38      9632 JR      C,LOC8
043BF4 15 
043BF5 77      9633 LD      (HL),A
043BF6 23      9634 INC     HL
043BF7 CD      9635 CALL    RANGE1
043BF8 AB 
043BF9 3C 
043BFA 04 
043BFB 30      9636 JR      NC,LOC7
043BFC F0 
043BFD FE      9637 CP      '('
043BFE 28 
043BFF 28      9638 JR      Z,LOC8
043C00 09 
043C01 FD      9639 LD      A,(IY+1)
043C02 7E 
043C03 01 
043C04 FE      9640 CP      '('
043C05 28 
043C06 28      9641 JR      Z,LOC7
043C07 E5 
043C08 FD      9642 INC     IY
043C09 23 
043C0A 36      9643 LOC8:			LD      (HL),0          	; TERMINATOR
043C0B 00 
043C0C 23      9644 INC     HL
043C0D E5      9645 PUSH    HL
043C0E CD      9646 CALL    TYPE_			; Get the variable type in D
043C0F CC 
043C10 3B 
043C11 04 
043C12 3E      9647 LD      A,4			; If it is an integer then it takes up 4 bytes
043C13 04 
043C14 BA      9648 CP      D
043C15 28      9649 JR      Z,LOC9			; So skip the next bit
043C16 01 
043C17 3C      9650 INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C18 36      9651 LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C19 00 
043C1A 23      9652 INC     HL
043C1B 3D      9653 DEC     A
043C1C 20      9654 JR      NZ,LOC9
043C1D FA 
043C1E 22      9655 LD      (FREE),HL		; Adjust the stack
043C1F 1D 
043C20 4D 
043C21 04 
043C22 CD      9656 CALL    CHECK			; Check whether we are out of space
043C23 79 
043C24 16 
043C25 04 
043C26 E1      9657 POP     HL
043C27 AF      9658 XOR     A
043C28 C9      9659 RET
               9660 ;
               9661 ; LINNUM - GET LINE NUMBER FROM TEXT STRING
               9662 ;   Inputs: IY = Text Pointer
               9663 ;  Outputs: HL = Line number (zero if none)
               9664 ;           IY updated
               9665 ; Destroys: A,D,E,H,L,IY,F
               9666 ;
               9667 ; This bit of code performs a BASE 10 shift to build up the number
               9668 ; So if the string passed is "345", the algorithm does this:
               9669 ;
               9670 ;    HL : Digit	: Operation
               9671 ; ----- : ----- : ---------
               9672 ; 00000 :	:
               9673 ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
               9674 ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
               9675 ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
               9676 ;
               9677 ; The multiply by 10 is done by an unrolled shift and add loop
               9678 ;
043C29 CD      9679 LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C2A 70 
043C2B 0A 
043C2C 04 
043C2D 40      9680 LD.SIS  HL,0			; The running total
043C2E 21 
043C2F 00 
043C30 00 
043C31 FD      9681 LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C32 7E 
043C33 00 
043C34 D6      9682 SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C35 30 
043C36 D8      9683 RET     C			; And return if less than 0
043C37 FE      9684 CP      10			; Or greater than or equal to 10
043C38 0A 
043C39 D0      9685 RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C3A FD      9686 INC     IY			; Increment the string pointer
043C3B 23 
043C3C 54      9687 LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C3D 5D      9688 LD      E,L			; Store the original number in DE
043C3E 52      9689 ADD.S   HL,HL           	; *2
043C3F 29 
043C40 38      9690 JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C41 13 
043C42 52      9691 ADD.S   HL,HL           	; *4S
043C43 29 
043C44 38      9692 JR      C,TOOBIG
043C45 0F 
043C46 52      9693 ADD.S   HL,DE           	; *5
043C47 19 
043C48 38      9694 JR      C,TOOBIG
043C49 0B 
043C4A 52      9695 ADD.S   HL,HL           	; *10
043C4B 29 
043C4C 38      9696 JR      C,TOOBIG
043C4D 07 
043C4E 5F      9697 LD      E,A			; A->DE: the digit to add in
043C4F 16      9698 LD      D,0
043C50 00 
043C51 52      9699 ADD.S   HL,DE           	; Add in the digit to the running total
043C52 19 
043C53 30      9700 JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C54 DC 
               9701 ;
043C55 3E      9702 TOOBIG:			LD      A,20
043C56 14 
043C57 C3      9703 JP      ERROR_           	; Error: "Too big"
043C58 90 
043C59 37 
043C5A 04 
               9704 ;
               9705 ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
               9706 ;   Inputs: IY = text pointer
               9707 ;  Outputs: HL = first number (10 by default)
               9708 ;           BC = second number (10 by default)
               9709 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
               9710 ;
043C5B CD      9711 PAIR:			CALL    LINNUM          	; Parse the first line number
043C5C 29 
043C5D 3C 
043C5E 04 
043C5F 7C      9712 LD      A,H			; If it is not zero, then...
043C60 B5      9713 OR      L
043C61 20      9714 JR      NZ,PAIR1		; Skip...
043C62 02 
043C63 2E      9715 LD      L,10			; HL: the default value (10)
043C64 0A 
               9716 ;
043C65 CD      9717 PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C66 A4 
043C67 17 
043C68 04 
043C69 FD      9718 INC     IY			; Skip to next character
043C6A 23 
043C6B E5      9719 PUSH    HL			; Stack the first line number
043C6C 21      9720 LD      HL,10			; HL: the second default (10)
043C6D 0A 
043C6E 00 
043C6F 00 
043C70 C4      9721 CALL    NZ,LINNUM       	; Parse the second line number
043C71 29 
043C72 3C 
043C73 04 
043C74 E3      9722 EX      (SP),HL			; HL: The first line number (off the stack)
043C75 C1      9723 POP     BC			; BC: Second line number
043C76 78      9724 LD      A,B			; If the second line number is not zero then...
043C77 B1      9725 OR      C			; We're good...
043C78 C0      9726 RET     NZ			; Exit, otherwise...
043C79 CD      9727 CALL    EXTERR			; Throw error: "Silly"
043C7A A7 
043C7B 37 
043C7C 04 
043C7D 53      9728 DB    	"Silly", 0
043C7E 69 
043C7F 6C 
043C80 6C 
043C80 79   
043C81 00 
               9729 ;
               9730 ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
               9731 ;   Inputs: IY = text pointer
               9732 ;  Outputs: HL = points to program text
               9733 ;           BC = second number (0 by default)
               9734 ; Destroys: A,B,C,D,E,H,L,IY,F
               9735 ;
043C83 CD      9736 DLPAIR:			CALL    LINNUM			; Parse the first line number
043C84 29 
043C85 3C 
043C86 04 
043C87 E5      9737 PUSH    HL			; Stack it
043C88 CD      9738 CALL    TERMQ			; Check for ELSE, : or CR
043C89 A4 
043C8A 17 
043C8B 04 
043C8C 28      9739 JR      Z,DLP1			; And exit if so
043C8D 0A 
043C8E FE      9740 CP      TIF			; Is the token IF?
043C8F E7 
043C90 28      9741 JR      Z,DLP1			; Yes, so skip the next bit...
043C91 06 
043C92 FD      9742 INC     IY			; Otherwise...
043C93 23 
043C94 CD      9743 CALL    LINNUM			; Fetch the second line number
043C95 29 
043C96 3C 
043C97 04 
043C98 E3      9744 DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043C99 CD      9745 CALL    FINDL			; HL: Find the address of the line
043C9A BF 
043C9B 39 
043C9C 04 
043C9D C1      9746 POP     BC			; BC: The second number
043C9E C9      9747 RET
               9748 ;
               9749 ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
               9750 ;   Inputs: IY addresses character
               9751 ;  Outputs: Carry set if out-of-range.
               9752 ; Destroys: A,F
               9753 ;
               9754 ; It is called here to check the following
               9755 ; In range: "$", "%" and "("
               9756 ;   Plus all characters in RANGE1 and RANGE2
               9757 ;
043C9F FD      9758 RANGE:			LD      A,(IY)			; Fetch the character
043CA0 7E 
043CA1 00 
043CA2 FE      9759 CP      '$'			; Postfix for string variable is valid
043CA3 24 
043CA4 C8      9760 RET     Z
043CA5 FE      9761 CP      '%'			; Postfix for integer variable is valid
043CA6 25 
043CA7 C8      9762 RET     Z
043CA8 FE      9763 CP      '('			; Postfix for array is valid
043CA9 28 
043CAA C8      9764 RET     Z
               9765 ;
               9766 ; It is called here to check the following
               9767 ; In range: "0" to "9" and "@"
               9768 ;   Plus all characters in RANGE2
               9769 ;
043CAB FE      9770 RANGE1:			CP      '0'			; If it is between '0'...
043CAC 30 
043CAD D8      9771 RET     C
043CAE FE      9772 CP      '9'+1			; And '9'...
043CAF 3A 
043CB0 3F      9773 CCF
043CB1 D0      9774 RET     NC			; Then it is valid
043CB2 FE      9775 CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CB3 40 
043CB4 C8      9776 RET     Z
               9777 ;
               9778 ; It is called here to check the following
               9779 ; In range: "A" to "Z", "a' to "z", "_" and "`"
               9780 ;
043CB5 FE      9781 RANGE2:			CP      'A'			; If it is between 'A'...
043CB6 41 
043CB7 D8      9782 RET     C
043CB8 FE      9783 CP      'Z'+1			; And 'Z'...
043CB9 5B 
043CBA 3F      9784 CCF
043CBB D0      9785 RET     NC			; Then it is valid
043CBC FE      9786 CP      '_'			; If it is underscore, grave, or between 'a'
043CBD 5F 
043CBE D8      9787 RET     C
043CBF FE      9788 CP      'z'+1			; And 'z'
043CC0 7B 
043CC1 3F      9789 CCF				; Then it is valid
043CC2 C9      9790 RET
               9791 ;
               9792 ; Throw a 'LINE space' error (line too long)
               9793 ; This is called from LEXAN
               9794 ;
043CC3 AF      9795 SPACE_: 		XOR     A
043CC4 CD      9796 CALL    EXTERR          	; "LINE space"
043CC5 A7 
043CC6 37 
043CC7 04 
043CC8 86      9797 DB    	LINE_MN_, 8, 0
043CC9 08 
043CCA 00 
               9798 ;
               9799 ; LEXAN - LEXICAL ANALYSIS.
               9800 ;  Bit 0,C: 1=left, 0=right
               9801 ;  Bit 2,C: 1=in BINARY
               9802 ;  Bit 3,C: 1=in HEX
               9803 ;  Bit 4,C: 1=accept line number
               9804 ;  Bit 5,C: 1=in variable, FN, PROC
               9805 ;  Bit 6,C: 1=in REM, DATA, *
               9806 ;  Bit 7,C: 1=in quotes
               9807 ;   Inputs: IY addresses source string
               9808 ;           DE addresses destination string (must be page boundary)
               9809 ;            C sets initial mode
               9810 ;  Outputs: DE, IY updated
               9811 ;            A holds carriage return
               9812 ;
043CCB 12      9813 LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CCC 13      9814 INC     DE              	; Increment the pointers
043CCD FD      9815 INC     IY			; And fall through to the main function
043CCE 23 
               9816 ;
               9817 ; This is the main entry point
               9818 ;
043CCF 7B      9819 LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CD0 FE      9820 CP      252             	; If it is >= 252 bytes, then...
043CD1 FC 
043CD2 30      9821 JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CD3 EF 
043CD4 FD      9822 LD      A,(IY)			; Fetch character from source string
043CD5 7E 
043CD6 00 
043CD7 FE      9823 CP      CR			; If it is a CR
043CD8 0D 
043CD9 C8      9824 RET     Z               	; Then it is end of line; we're done parsing
043CDA CD      9825 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CDB AB 
043CDC 3C 
043CDD 04 
043CDE 30      9826 JR      NC,LEXAN3		; Yes, so skip
043CDF 06 
043CE0 CB      9827 RES     5,C             	; FLAG: NOT IN VARIABLE
043CE1 A9 
043CE2 CB      9828 RES     3,C             	; FLAG: NOT IN HEX
043CE3 99 
043CE4 CB      9829 RES	2,C			; FLAG: NOT IN BINARY
043CE5 91 
               9830 ;
043CE6 FE      9831 LEXAN3:			CP      ' '			; Ignore spaces
043CE7 20 
043CE8 28      9832 JR      Z,LEXAN1
043CE9 E1 
043CEA FE      9833 CP      ','			; Ignore commas
043CEB 2C 
043CEC 28      9834 JR      Z,LEXAN1
043CED DD 
043CEE FE      9835 CP	'2'			; If less than '2'
043CEF 32 
043CF0 30      9836 JR	NC, @F			; No, so skip
043CF1 02 
043CF2 CB      9837 RES	2,C			; FLAG: NOT IN BINARY
043CF3 91 
043CF4 FE      9838 @@:			CP      'G'			; If less then 'G'
043CF5 47 
043CF6 38      9839 JR      C,LEXAN4		; Yes, so skip
043CF7 02 
043CF8 CB      9840 RES     3,C             	; FLAG: NOT IN HEX
043CF9 99 
               9841 ;
043CFA FE      9842 LEXAN4:			CP      34			; Is it a quote character?
043CFB 22 
043CFC 20      9843 JR      NZ,LEXAN5		; No, so skip
043CFD 05 
043CFE CB      9844 RL      C			; Toggle bit 7 of C by shifting it into carry flag
043CFF 11 
043D00 3F      9845 CCF                     	; Toggle the carry
043D01 CB      9846 RR      C			; And then shifting it back into bit 7 of C
043D02 19 
               9847 ;
043D03 CB      9848 LEXAN5:			BIT     4,C			; Accept line number?
043D04 61 
043D05 28      9849 JR      Z,LEXAN6		; No, so skip
043D06 12 
043D07 CB      9850 RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D08 A1 
043D09 C5      9851 PUSH    BC
043D0A D5      9852 PUSH    DE
043D0B CD      9853 CALL    LINNUM         		; Parse the line number to HL
043D0C 29 
043D0D 3C 
043D0E 04 
043D0F D1      9854 POP     DE
043D10 C1      9855 POP     BC
043D11 7C      9856 LD      A,H			; If it is not zero
043D12 B5      9857 OR      L
043D13 C4      9858 CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D14 8C 
043D15 3D 
043D16 04 
043D17 18      9859 JR      LEXAN2          	; And loop
043D18 B6 
               9860 ;
043D19 0D      9861 LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D1A 28      9862 JR      Z,LEXAN7        	; If so, skip
043D1B 0A 
043D1C 0C      9863 INC     C			; Otherwise restore C
043D1D 20      9864 JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D1E AC 
043D1F B7      9865 OR      A			; Set the flags based on the character
043D20 F4      9866 CALL    P,LEX           	; Tokenise if A < 128
043D21 F7 
043D22 37 
043D23 04 
043D24 18      9867 JR      LEXAN8			; And skip
043D25 13 
               9868 ;
               9869 ; Processing the LEFT hand side here
               9870 ;
043D26 FE      9871 LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D27 2A 
043D28 28      9872 JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D29 17 
043D2A B7      9873 OR      A			; Set the flags based on the character
043D2B F4      9874 CALL    P,LEX           	; Tokenise if A < 128
043D2C F7 
043D2D 37 
043D2E 04 
               9875 ;
               9876 ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
               9877 ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
               9878 ; Examples:
               9879 ;   LET A% = PAGE : REM This is the GET version
               9880 ;   PAGE = 40000  : REM This is the SET version
               9881 ;
043D2F FE      9882 CP      TOKLO			; TOKLO is 8Fh
043D30 8F 
043D31 38      9883 JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D32 06 
043D33 FE      9884 CP      TOKHI+1			; TOKHI is 93h
043D34 94 
043D35 30      9885 JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D36 02 
043D37 C6      9886 ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D38 40 
               9887 ;
043D39 FE      9888 LEXAN8:			CP      REM			; If the token is REM
043D3A F4 
043D3B 28      9889 JR      Z,LEXAN9		; Then stop tokenising
043D3C 04 
043D3D FE      9890 CP      DATA_MN_			; If it is not DATA then
043D3E DC 
043D3F 20      9891 JR      NZ,LEXANA		; Skip
043D40 02 
043D41 CB      9892 LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D42 F1 
               9893 ;
043D43 FE      9894 LEXANA:			CP      FN			; If the token is FN
043D44 A4 
043D45 28      9895 JR      Z,LEXANB
043D46 0A 
043D47 FE      9896 CP      PROC			; Or the token is PROC
043D48 F2 
043D49 28      9897 JR      Z,LEXANB		; Then jump to here
043D4A 06 
043D4B CD      9898 CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D4C B5 
043D4D 3C 
043D4E 04 
043D4F 38      9899 JR      C,LEXANC		; Jump here if out of range
043D50 02 
               9900 ;
043D51 CB      9901 LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D52 E9 
043D53 FE      9902 LEXANC:			CP      '&'			; Check for hex prefix
043D54 26 
043D55 20      9903 JR      NZ,LEXAND		; If not, skip
043D56 02 
043D57 CB      9904 SET     3,C             	; FLAG: IN HEX
043D58 D9 
               9905 ;
043D59 FE      9906 LEXAND:			CP	'%'			; Check for binary prefix
043D5A 25 
043D5B 20      9907 JR	NZ,LEXANE		; If not, skip
043D5C 02 
043D5D CB      9908 SET	2,C			; FLAG: IN BINARY
043D5E D1 
               9909 ;
043D5F 21      9910 LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D60 83 
043D61 3D 
043D62 04 
043D63 C5      9911 PUSH    BC
043D64 01      9912 LD      BC,LIST1L		; The list length
043D65 06 
043D66 00 
043D67 00 
043D68 ED      9913 CPIR				; Check if the token is in this list
043D69 B1 
043D6A C1      9914 POP     BC
043D6B 20      9915 JR      NZ,LEXANF		; If not, then skip
043D6C 02 
043D6D CB      9916 SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D6E E1 
               9917 ;
043D6F 21      9918 LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D70 87 
043D71 3D 
043D72 04 
043D73 C5      9919 PUSH    BC
043D74 01      9920 LD      BC,LIST2L		; The list length
043D75 05 
043D76 00 
043D77 00 
043D78 ED      9921 CPIR				; Check if the token is in this list
043D79 B1 
043D7A C1      9922 POP     BC
043D7B 20      9923 JR      NZ,LEXANG		; If not, then skip
043D7C 02 
043D7D CB      9924 SET     0,C             	; FLAG: ENTER LEFT MODE
043D7E C1 
043D7F C3      9925 LEXANG:			JP      LEXAN1			; And loop
043D80 CB 
043D81 3C 
043D82 04 
               9926 
               9927 ;
               9928 ; LIST1: List of tokens that must be followed by line numbers
               9929 ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
               9930 ;
043D83 E5      9931 LIST1:			DB	GOTO
043D84 E4      9932 DB	GOSUB
043D85 F7      9933 DB	RESTOR
043D86 FC      9934 DB	TRACE
043D87 8C      9935 LIST2:			DB	THEN_MN_
043D88 8B      9936 DB	ELSE_MN_
               9937 LIST1L:			EQU     $-LIST1
043D89 F5      9938 DB	REPEAT
043D8A 85      9939 DB	TERROR_MN
043D8B 3A      9940 DB    	':'
               9941 LIST2L:			EQU     $-LIST2
               9942 ;
               9943 ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
               9944 ;   Inputs: HL=line number, DE=string pointer
               9945 ;  Outputs: DE updated, BIT 4,C set.
               9946 ; Destroys: A,B,C,D,E,F
               9947 ;
               9948 ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
               9949 ;
               9950 ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
               9951 ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
               9952 ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
               9953 ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
               9954 ; each byte are then stored, in LO/HI order, ORred with 0x40.
               9955 ;
043D8C CB      9956 ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D8D E1 
043D8E EB      9957 EX      DE, HL			; HL: string pointer, DE: line number
043D8F 36      9958 LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D90 8D 
043D91 23      9959 INC     HL
043D92 7A      9960 LD      A,D			; Get the high byte
043D93 E6      9961 AND     0C0H			; Get the top two bits	DD000000
043D94 C0 
043D95 0F      9962 RRCA				; Shift right		00DD0000
043D96 0F      9963 RRCA
043D97 47      9964 LD      B,A			; Store in B
043D98 7B      9965 LD      A,E			; Get the low byte
043D99 E6      9966 AND     0C0H			; Get the top two bits	EE000000
043D9A C0 
043D9B B0      9967 OR      B			; Combine with D	EEDD0000
043D9C 0F      9968 RRCA				; Shift right		00EEDD00
043D9D 0F      9969 RRCA
043D9E EE      9970 XOR     01010100B		; XOR with 54h
043D9F 54 
043DA0 77      9971 LD      (HL),A			; Store this as the second byte
043DA1 23      9972 INC     HL
043DA2 7B      9973 LD      A,E			; Get the low byte
043DA3 E6      9974 AND     3FH			; Strip the top two bits off
043DA4 3F 
043DA5 F6      9975 OR      '@'			; OR with 40h
043DA6 40 
043DA7 77      9976 LD      (HL),A			; Store
043DA8 23      9977 INC     HL
043DA9 7A      9978 LD      A,D			; Get the high byte
043DAA E6      9979 AND     3FH			; Strip the top two bits off
043DAB 3F 
043DAC F6      9980 OR      '@'			; OR with 40h
043DAD 40 
043DAE 77      9981 LD      (HL),A			; Store
043DAF 23      9982 INC     HL
043DB0 EB      9983 EX      DE,HL			; DE: string pointer, HL: line number
043DB1 C9      9984 RET
               9985 ;
               9986 ; TEXT - OUTPUT MESSAGE.
               9987 ;   Inputs: HL addresses text (terminated by nul)
               9988 ;  Outputs: HL addresses character following nul.
               9989 ; Destroys: A,H,L,F
               9990 ;
043DB2 2A      9991 REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DB3 2F 
043DB4 4D 
043DB5 04 
               9992 ;
043DB6 7E      9993 TEXT_:			LD      A, (HL)			; Fetch the character
043DB7 23      9994 INC     HL			; Increment pointer to next character
043DB8 B7      9995 OR      A			; Check for the nul (0) string terminator
043DB9 C8      9996 RET     Z			; And return if so
043DBA CD      9997 CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DBB 9C 
043DBC 39 
043DBD 04 
043DBE 18      9998 JR      TEXT_			; And loop
043DBF F6 
               9999 ;
              10000 ; TELL - OUTPUT MESSAGE.
              10001 ;   Inputs: Text follows subroutine call (term=nul)
              10002 ; Destroys: A,F
              10003 ;
              10004 ; Example usage:
              10005 ;
              10006 ;	CALL	TELL			Call the function
              10007 ;	DB	"Hello World", 0	Followed by a zero terminated string
              10008 ;	LD	A, (1234H)		Program execution will carry on here after the message is output
              10009 ;
043DC0 E3     10010 TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DC1 CD     10011 CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DC2 B6 
043DC3 3D 
043DC4 04 
043DC5 E3     10012 EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DC6 C9     10013 RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
              10014 
              10015 ; --- Begin misc.asm ---
              10016 ;
              10017 ; Title:	BBC Basic for AGON - Miscellaneous helper functions
              10018 ; Author:	Dean Belfield
              10019 ; Created:	12/05/2023
              10020 ; Last Updated:	12/05/2023
              10021 ;
              10022 ; Modinfo:
              10023 
              10024 ; INCLUDE	"equs.inc"
              10025 ; INCLUDE	"macros.inc"
              10026 
              10027 ; .ASSUME	ADL = 1
              10028 
              10029 ; SEGMENT CODE
              10030 
              10031 ; XDEF	ASC_TO_NUMBER
              10032 ; XDEF	SWITCH_A
              10033 ; XDEF	NULLTOCR
              10034 ; XDEF	CRTONULL
              10035 ; XDEF	CSTR_FNAME
              10036 ; XDEF	CSTR_LINE
              10037 ; XDEF	CSTR_FINDCH
              10038 ; XDEF	CSTR_ENDSWITH
              10039 ; XDEF	CSTR_CAT
              10040 
              10041 ; XREF	OSWRCH
              10042 ; XREF	KEYWDS
              10043 ; XREF	KEYWDL
              10044 
              10045 ; Read a number and convert to binary
              10046 ; If prefixed with &, will read as hex, otherwise decimal
              10047 ;   Inputs: HL: Pointer in string buffer
              10048 ;  Outputs: HL: Updated text pointer
              10049 ;           DE: Value
              10050 ;            A: Terminator (spaces skipped)
              10051 ; Destroys: A,D,E,H,L,F
              10052 ;
043DC7 C5     10053 ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DC8 11     10054 LD	DE, 0			; Initialise DE
043DC9 00 
043DCA 00 
043DCB 00 
043DCC CD     10055 CALL	SKIPSPC			; Skip whitespace
043DCD 0E 
043DCE 3E 
043DCF 04 
043DD0 7E     10056 LD	A, (HL)			; Read first character
043DD1 FE     10057 CP	'&'			; Is it prefixed with '&' (HEX number)?
043DD2 26 
043DD3 20     10058 JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DD4 1F 
043DD5 23     10059 INC	HL			; Otherwise fall through to ASC_TO_HEX
              10060 ;
043DD6 7E     10061 ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DD7 CD     10062 CALL    UPPERC			; Convert to uppercase
043DD8 1C 
043DD9 3E 
043DDA 04 
043DDB D6     10063 SUB	'0'			; Normalise to 0
043DDC 30 
043DDD 38     10064 JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DDE 2E 
043DDF FE     10065 CP 	10			; Check if >= 10
043DE0 0A 
043DE1 38     10066 JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DE2 06 
043DE3 D6     10067 SUB 	7			; Adjust ASCII A-F to nibble
043DE4 07 
043DE5 FE     10068 CP 	16			; Check for > F
043DE6 10 
043DE7 30     10069 JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DE8 24 
043DE9 EB     10070 ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DEA 29     10071 ADD	HL, HL
043DEB 29     10072 ADD	HL, HL
043DEC 29     10073 ADD	HL, HL
043DED 29     10074 ADD	HL, HL
043DEE EB     10075 EX	DE, HL
043DEF B3     10076 OR      E			; OR the new digit in to the least significant nibble
043DF0 5F     10077 LD      E, A
043DF1 23     10078 INC     HL			; Onto the next character
043DF2 18     10079 JR      ASC_TO_NUMBER1		; And loop
043DF3 E2 
              10080 ;
043DF4 7E     10081 ASC_TO_NUMBER3:		LD	A, (HL)
043DF5 D6     10082 SUB	'0'			; Normalise to 0
043DF6 30 
043DF7 38     10083 JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DF8 14 
043DF9 FE     10084 CP	10			; Check if >= 10
043DFA 0A 
043DFB 30     10085 JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043DFC 10 
043DFD EB     10086 EX 	DE, HL 			; Stick DE in HL
043DFE 44     10087 LD	B, H 			; And copy HL into BC
043DFF 4D     10088 LD	C, L
043E00 29     10089 ADD	HL, HL 			; x 2
043E01 29     10090 ADD	HL, HL 			; x 4
043E02 09     10091 ADD	HL, BC 			; x 5
043E03 29     10092 ADD	HL, HL 			; x 10
043E04 EB     10093 EX	DE, HL
              10094 ADD8U_DE 			; Add A to DE (macro)
043E05 83     0001M ADD	A, E
043E06 5F     0002M LD	E, A
043E07 8A     0003M ADC	A, D
043E08 93     0004M SUB	E
043E09 57     0005M LD	D, A
043E0A 23     10095 INC	HL
043E0B 18     10096 JR	ASC_TO_NUMBER3
043E0C E7 
043E0D C1     10097 ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
              10098 
              10099 ; Skip a space
              10100 ; HL: Pointer in string buffer
              10101 ;
043E0E 7E     10102 SKIPSPC:			LD      A, (HL)
043E0F FE     10103 CP      ' '
043E10 20 
043E11 C0     10104 RET     NZ
043E12 23     10105 INC     HL
043E13 18     10106 JR      SKIPSPC
043E14 F9 
              10107 
              10108 ; Skip a string
              10109 ; HL: Pointer in string buffer
              10110 ;
043E15 7E     10111 SKIPNOTSP:		LD	A, (HL)
043E16 FE     10112 CP	' '
043E17 20 
043E18 C8     10113 RET	Z
043E19 23     10114 INC	HL
043E1A 18     10115 JR	SKIPNOTSP
043E1B F9 
              10116 
              10117 ; Convert a character to upper case
              10118 ;  A: Character to convert
              10119 ;
043E1C E6     10120 UPPERC:  		AND     7FH
043E1D 7F 
043E1E FE     10121 CP      '`'
043E1F 60 
043E20 D8     10122 RET     C
043E21 E6     10123 AND     5FH			; Convert to upper case
043E22 5F 
043E23 C9     10124 RET
              10125 
              10126 ; Switch on A - lookup table immediately after call
              10127 ;  A: Index into lookup table
              10128 ;
043E24 E3     10129 SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E25 87     10130 ADD	A, A			; Multiply A by two
              10131 ADD8U_HL 			; Add to HL (macro)
043E26 85     0001M ADD	A, L
043E27 6F     0002M LD	L, A
043E28 8C     0003M ADC	A, H
043E29 95     0004M SUB	L
043E2A 67     0005M LD	H, A
043E2B 7E     10132 LD	A, (HL)			; follow the call. Fetch an address from the
043E2C 23     10133 INC	HL 			; table.
043E2D 66     10134 LD	H, (HL)
043E2E 6F     10135 LD	L, A
043E2F E3     10136 EX	(SP), HL		; Swap this new address back, restores HL
043E30 C9     10137 RET				; Return program control to this new address
              10138 
              10139 ; Convert the buffer to a null terminated string and back
              10140 ; HL: Buffer address
              10141 ;
043E31 C5     10142 NULLTOCR:		PUSH 	BC
043E32 06     10143 LD	B, 0
043E33 00 
043E34 0E     10144 LD	C, CR
043E35 0D 
043E36 18     10145 JR	CRTONULL0
043E37 05 
              10146 ;
043E38 C5     10147 CRTONULL:		PUSH	BC
043E39 06     10148 LD	B, CR
043E3A 0D 
043E3B 0E     10149 LD	C, 0
043E3C 00 
              10150 ;
043E3D E5     10151 CRTONULL0:		PUSH	HL
043E3E 7E     10152 CRTONULL1:		LD	A, (HL)
043E3F B8     10153 CP 	B
043E40 28     10154 JR	Z, CRTONULL2
043E41 03 
043E42 23     10155 INC	HL
043E43 18     10156 JR	CRTONULL1
043E44 F9 
043E45 71     10157 CRTONULL2:		LD	(HL), C
043E46 E1     10158 POP 	HL
043E47 C1     10159 POP	BC
043E48 C9     10160 RET
              10161 
              10162 ; Copy a filename to DE and zero terminate it
              10163 ; HL: Source
              10164 ; DE: Destination (ACCS)
              10165 ;
043E49 7E     10166 CSTR_FNAME:		LD	A, (HL)			; Get source
043E4A FE     10167 CP	32			; Is it space
043E4B 20 
043E4C 28     10168 JR	Z, @F
043E4D 09 
043E4E FE     10169 CP	CR			; Or is it CR
043E4F 0D 
043E50 28     10170 JR	Z, @F
043E51 05 
043E52 12     10171 LD	(DE), A			; No, so store
043E53 23     10172 INC	HL			; Increment
043E54 13     10173 INC	DE
043E55 18     10174 JR	CSTR_FNAME		; And loop
043E56 F2 
043E57 AF     10175 @@:			XOR	A			; Zero terminate the target string
043E58 12     10176 LD	(DE), A
043E59 13     10177 INC	DE			; And point to next free address
043E5A C9     10178 RET
              10179 
              10180 ; Copy a CR terminated line to DE and zero terminate it
              10181 ; HL: Source
              10182 ; DE: Destination (ACCS)
              10183 ;
043E5B 7E     10184 CSTR_LINE:		LD	A, (HL)			; Get source
043E5C FE     10185 CP	CR			; Is it CR
043E5D 0D 
043E5E 28     10186 JR	Z, @F
043E5F 05 
043E60 12     10187 LD	(DE), A			; No, so store
043E61 23     10188 INC	HL			; Increment
043E62 13     10189 INC	DE
043E63 18     10190 JR	CSTR_LINE		; And loop
043E64 F6 
043E65 AF     10191 @@:			XOR	A			; Zero terminate the target string
043E66 12     10192 LD	(DE), A
043E67 13     10193 INC	DE			; And point to next free address
043E68 C9     10194 RET
              10195 
              10196 ; Find the first occurrence of a character (case sensitive)
              10197 ; HL: Source
              10198 ;  C: Character to find
              10199 ; Returns:
              10200 ; HL: Pointer to character, or end of string marker
              10201 ;
043E69 7E     10202 CSTR_FINDCH:		LD	A, (HL)			; Get source
043E6A B9     10203 CP	C			; Is it our character?
043E6B C8     10204 RET	Z			; Yes, so exit
043E6C B7     10205 OR	A			; Is it the end of string?
043E6D C8     10206 RET	Z			; Yes, so exit
043E6E 23     10207 INC	HL
043E6F 18     10208 JR	CSTR_FINDCH
043E70 F8 
              10209 
              10210 ; Check whether a string ends with another string (case insensitive)
              10211 ; HL: Source
              10212 ; DE: The substring we want to test with
              10213 ; Returns:
              10214 ;  F: Z if HL ends with DE, otherwise NZ
              10215 ;
043E71 7E     10216 CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E72 CD     10217 CALL	UPPERC			; Convert to upper case
043E73 1C 
043E74 3E 
043E75 04 
043E76 4F     10218 LD	C, A
043E77 1A     10219 LD	A, (DE)			; Get the substring byte
043E78 B9     10220 CP	C
043E79 C0     10221 RET	NZ			; Return NZ if at any point the strings don't match
043E7A B1     10222 OR	C			; Check whether both bytes are zero
043E7B C8     10223 RET	Z			; If so, return, as we have reached the end of both strings
043E7C 23     10224 INC	HL
043E7D 13     10225 INC	DE
043E7E 18     10226 JR	CSTR_ENDSWITH		; And loop
043E7F F1 
              10227 
              10228 ; Concatenate a string onto the end of another string
              10229 ; HL: Source
              10230 ; DE: Second string
              10231 ;
043E80 7E     10232 CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E81 B7     10233 OR	A
043E82 28     10234 JR	Z, CSTR_CAT_1
043E83 03 
043E84 23     10235 INC	HL
043E85 18     10236 JR	CSTR_CAT
043E86 F9 
              10237 ;
043E87 1A     10238 CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E88 77     10239 LD	(HL), A
043E89 B7     10240 OR	A			; Check for end of string
043E8A C8     10241 RET	Z			; And return
043E8B 23     10242 INC	HL
043E8C 13     10243 INC	DE
043E8D 18     10244 JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E8E F8 
              10245 
              10246 ; --- Begin patch.asm ---
              10247 ;
              10248 ; Title:	BBC Basic for AGON
              10249 ; Author:	Dean Belfield
              10250 ; Created:	12/05/2023
              10251 ; Last Updated:	15/11/2023
              10252 ;
              10253 ; Modinfo:
              10254 ; 11/07/2023:	Fixed *BYE for ADL mode
              10255 ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
              10256 
              10257 ; .ASSUME	ADL = 1
              10258 
              10259 ; INCLUDE	"equs.inc"
              10260 ; INCLUDE "macros.inc"
              10261 ; INCLUDE "mos_api.inc"	; In MOS/src
              10262 
              10263 ; SEGMENT CODE
              10264 
              10265 ; XDEF	OSWRCH
              10266 ; XDEF	OSLINE
              10267 ; XDEF	ESCSET
              10268 ; XDEF	PUTIME
              10269 ; XDEF	GETIME
              10270 ; XDEF	PUTCSR
              10271 ; XDEF 	GETCSR
              10272 ; XDEF	OSRDCH
              10273 ; XDEF	PROMPT
              10274 ; XDEF	OSKEY
              10275 ; XDEF	TRAP
              10276 ; XDEF	LTRAP
              10277 ; XDEF	OSINIT
              10278 ; XDEF	OSCLI
              10279 ; XDEF	OSBPUT
              10280 ; XDEF	OSBGET
              10281 ; XDEF	OSSTAT
              10282 ; XDEF	OSSHUT
              10283 ; XDEF	OSOPEN
              10284 ; XDEF	OSCALL
              10285 ; XDEF	GETPTR
              10286 ; XDEF	PUTPTR
              10287 ; XDEF	GETEXT
              10288 ; XDEF	GETIMS
              10289 ; XDEF	RESET
              10290 ; XDEF	OSLOAD
              10291 ; XDEF	OSSAVE
              10292 ; XDEF	EXPR_W2
              10293 ; XDEF	STAR_VERSION
              10294 
              10295 ; XREF	_end			; In init.asm
              10296 
              10297 ; XREF	ASC_TO_NUMBER
              10298 ; XREF	RAM_START
              10299 ; XREF	RAM_END
              10300 ; XREF	FLAGS
              10301 ; XREF	ESCAPE
              10302 ; XREF	USER
              10303 ; XREF	RAM_Top
              10304 ; XREF	EXTERR
              10305 ; XREF	COUNT0
              10306 ; XREF	EXPRI
              10307 ; XREF	COMMA
              10308 ; XREF	XEQ
              10309 ; XREF	NXT
              10310 ; XREF	NULLTOCR
              10311 ; XREF	CRLF
              10312 ; XREF	CSTR_FNAME
              10313 ; XREF	CSTR_LINE
              10314 ; XREF	CSTR_FINDCH
              10315 ; XREF	CSTR_ENDSWITH
              10316 ; XREF	CSTR_CAT
              10317 ; XREF	FINDL
              10318 ; XREF	OUT_
              10319 ; XREF	ERROR_
              10320 ; XREF	ONEDIT
              10321 ; XREF	TELL
              10322 ; XREF	OSWRCHPT
              10323 ; XREF	OSWRCHCH
              10324 ; XREF	OSWRCHFH
              10325 ; XREF	LISTON
              10326 ; XREF	LISTIT
              10327 ; XREF	PAGE_
              10328 ; XREF	ONEDIT1
              10329 ; XREF	CLEAN
              10330 ; XREF	NEWIT
              10331 ; XREF	BAD
              10332 ; XREF	VBLANK_INIT
              10333 ; XREF	VBLANK_STOP
              10334 ; XREF	KEYDOWN
              10335 ; XREF	KEYASCII
              10336 ; XREF	WIDTH
              10337 ; XREF	ASSEM
              10338 
              10339 ; OSLINE: Invoke the line editor
              10340 ;
043E8F 1E     10341 OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E90 01 
              10342 
              10343 ; Entry point to line editor that does not clear the buffer
              10344 ;
043E91 FD     10345 OSLINE1:		PUSH	IY
043E92 E5 
043E93 E5     10346 PUSH	HL			; Buffer address
043E94 01     10347 LD	BC, 256			; Buffer length
043E95 00 
043E96 01 
043E97 00 
              10348 MOSCALL	mos_editline		; Call the MOS line editor
043E98 3E     0001M LD	A, function
043E99 09 
043E9A 49     0002M RST.LIS	08h
043E9B CF 
043E9C E1     10349 POP	HL			; Pop the address
043E9D FD     10350 POP	IY
043E9E E1 
043E9F F5     10351 PUSH	AF			; Stack the return value (key pressed)
043EA0 CD     10352 CALL	NULLTOCR		; Turn the 0 character to a CR
043EA1 31 
043EA2 3E 
043EA3 04 
043EA4 CD     10353 CALL	CRLF			; Display CRLF
043EA5 77 
043EA6 39 
043EA7 04 
043EA8 F1     10354 POP	AF
043EA9 FE     10355 CP	1Bh 			; Check if ESC terminated the input
043EAA 1B 
043EAB CA     10356 JP	Z, LTRAP1 		; Yes, so do the ESC thing
043EAC A7 
043EAD 3F 
043EAE 04 
043EAF 3A     10357 LD	A, (FLAGS)		; Otherwise
043EB0 42 
043EB1 4D 
043EB2 04 
043EB3 CB     10358 RES	7, A 			; Clear the escape flag
043EB4 BF 
043EB5 32     10359 LD	(FLAGS), A
043EB6 42 
043EB7 4D 
043EB8 04 
043EB9 CD     10360 CALL	WAIT_VBLANK 		; Wait a frame
043EBA 7E 
043EBB 41 
043EBC 04 
043EBD AF     10361 XOR	A			; Return A = 0
043EBE 32     10362 LD	(KEYDOWN), A
043EBF 47 
043EC0 4D 
043EC1 04 
043EC2 32     10363 LD	(KEYASCII), A
043EC3 48 
043EC4 4D 
043EC5 04 
043EC6 C9     10364 RET
              10365 
              10366 ; PUTIME: set current time to DE:HL, in centiseconds.
              10367 ;
043EC7 DD     10368 PUTIME:			PUSH 	IX
043EC8 E5 
              10369 MOSCALL	mos_sysvars
043EC9 3E     0001M LD	A, function
043ECA 08 
043ECB 49     0002M RST.LIS	08h
043ECC CF 
043ECD DD     10370 LD	(IX + sysvar_time + 0), L
043ECE 75 
043ECF 00 
043ED0 DD     10371 LD	(IX + sysvar_time + 1), H
043ED1 74 
043ED2 01 
043ED3 DD     10372 LD	(IX + sysvar_time + 2), E
043ED4 73 
043ED5 02 
043ED6 DD     10373 LD	(IX + sysvar_time + 3), D
043ED7 72 
043ED8 03 
043ED9 DD     10374 POP	IX
043EDA E1 
043EDB C9     10375 RET
              10376 
              10377 ; GETIME: return current time in DE:HL, in centiseconds
              10378 ;
043EDC DD     10379 GETIME:			PUSH 	IX
043EDD E5 
              10380 MOSCALL	mos_sysvars
043EDE 3E     0001M LD	A, function
043EDF 08 
043EE0 49     0002M RST.LIS	08h
043EE1 CF 
043EE2 DD     10381 LD	L, (IX + sysvar_time + 0)
043EE3 6E 
043EE4 00 
043EE5 DD     10382 LD	H, (IX + sysvar_time + 1)
043EE6 66 
043EE7 01 
043EE8 DD     10383 LD	E, (IX + sysvar_time + 2)
043EE9 5E 
043EEA 02 
043EEB DD     10384 LD	D, (IX + sysvar_time + 3)
043EEC 56 
043EED 03 
043EEE DD     10385 POP	IX
043EEF E1 
043EF0 C9     10386 RET
              10387 
              10388 ; PUTCSR: move to cursor to x=DE, y=HL
              10389 ;
043EF1 3E     10390 PUTCSR:			LD	A, 1Fh			; TAB
043EF2 1F 
043EF3 5B     10391 RST.LIL	10h
043EF4 D7 
043EF5 7B     10392 LD	A, E			; X
043EF6 5B     10393 RST.LIL 10h
043EF7 D7 
043EF8 7D     10394 LD	A, L			; Y
043EF9 5B     10395 RST.LIL 10h
043EFA D7 
043EFB C9     10396 RET
              10397 
              10398 ; GETCSR: return cursor position in x=DE, y=HL
              10399 ;
043EFC DD     10400 GETCSR:			PUSH	IX			; Get the system vars in IX
043EFD E5 
              10401 MOSCALL	mos_sysvars		; Reset the semaphore
043EFE 3E     0001M LD	A, function
043EFF 08 
043F00 49     0002M RST.LIS	08h
043F01 CF 
043F02 DD     10402 RES	0, (IX+sysvar_vpd_pflags)
043F03 CB 
043F04 04 
043F05 86 
              10403 VDU	23
043F06 3E     0001M LD	A, val
043F07 17 
043F08 CD     0002M CALL	OSWRCH
043F09 30 
043F0A 3F 
043F0B 04 
              10404 VDU	0
043F0C 3E     0001M LD	A, val
043F0D 00 
043F0E CD     0002M CALL	OSWRCH
043F0F 30 
043F10 3F 
043F11 04 
              10405 VDU	vdp_cursor
043F12 3E     0001M LD	A, val
043F13 82 
043F14 CD     0002M CALL	OSWRCH
043F15 30 
043F16 3F 
043F17 04 
043F18 DD     10406 @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F19 CB 
043F1A 04 
043F1B 46 
043F1C 28     10407 JR	Z, @B			; Wait for the result
043F1D FA 
043F1E 16     10408 LD 	D, 0
043F1F 00 
043F20 62     10409 LD	H, D
043F21 DD     10410 LD	E, (IX + sysvar_cursorX)
043F22 5E 
043F23 07 
043F24 DD     10411 LD	L, (IX + sysvar_cursorY)
043F25 6E 
043F26 08 
043F27 DD     10412 POP	IX
043F28 E1 
043F29 C9     10413 RET
              10414 
              10415 ; PROMPT: output the input prompt
              10416 ;
043F2A 3E     10417 PROMPT: 		LD	A,'>'
043F2B 3E 
043F2C C3     10418 JP	OSWRCH
043F2D 30 
043F2E 3F 
043F2F 04 
              10419 
              10420 ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
              10421 ; A: Character to write
              10422 ;
043F30 E5     10423 OSWRCH:			PUSH	HL
043F31 21     10424 LD	HL, LISTON		; Fetch the LISTON variable
043F32 40 
043F33 4D 
043F34 04 
043F35 CB     10425 BIT	3, (HL)			; Check whether we are in *EDIT mode
043F36 5E 
043F37 20     10426 JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F38 0B 
              10427 ;
043F39 2A     10428 LD	HL, (OSWRCHCH)		; L: Channel #
043F3A 45 
043F3B 4D 
043F3C 04 
043F3D 2D     10429 DEC	L			; If it is 1
043F3E 28     10430 JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F3F 10 
              10431 ;
043F40 E1     10432 POP	HL			; Otherwise
043F41 5B     10433 RST.LIL	10h			; Output the character to MOS
043F42 D7 
043F43 C9     10434 RET
              10435 ;
043F44 2A     10436 OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F45 43 
043F46 4D 
043F47 04 
043F48 77     10437 LD	(HL), A			; Echo the character into the buffer
043F49 23     10438 INC	HL			; Increment pointer
043F4A 22     10439 LD	(OSWRCHPT), HL		; Write pointer back
043F4B 43 
043F4C 4D 
043F4D 04 
043F4E E1     10440 POP	HL
043F4F C9     10441 RET
              10442 ;
043F50 D5     10443 OSWRCH_FILE:		PUSH	DE
043F51 5C     10444 LD	E, H			; Filehandle to E
043F52 CD     10445 CALL	OSBPUT			; Write the byte out
043F53 7C 
043F54 43 
043F55 04 
043F56 D1     10446 POP	DE
043F57 E1     10447 POP	HL
043F58 C9     10448 RET
              10449 
              10450 ; OSRDCH: Read a character in from the ESP32 keyboard handler
              10451 ; This is only called in GETS (eval.asm)
              10452 ;
              10453 OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F59 3E     0001M LD	A, function
043F5A 00 
043F5B 49     0002M RST.LIS	08h
043F5C CF 
043F5D FE     10454 CP	1Bh
043F5E 1B 
043F5F 28     10455 JR	Z, LTRAP1
043F60 46 
043F61 C9     10456 RET
              10457 
              10458 
              10459 ;OSKEY - Read key with time-limit, test for ESCape.
              10460 ;Main function is carried out in user patch.
              10461 ;   Inputs: HL = time limit (centiseconds)
              10462 ;  Outputs: Carry reset if time-out
              10463 ;           If carry set A = character
              10464 ; Destroys: A,H,L,F
              10465 ;
043F62 CD     10466 OSKEY:			CALL	READKEY			; Read the keyboard
043F63 93 
043F64 3F 
043F65 04 
043F66 28     10467 JR	Z, @F 			; Skip if we have a key
043F67 0A 
043F68 7C     10468 LD	A, H 			; Check loop counter
043F69 B5     10469 OR 	L
043F6A C8     10470 RET 	Z 			; Return, we've not got a key at this point
043F6B CD     10471 CALL	WAIT_VBLANK 		; Wait a frame
043F6C 7E 
043F6D 41 
043F6E 04 
043F6F 2B     10472 DEC 	HL			; Decrement
043F70 18     10473 JR	OSKEY 			; And loop
043F71 F0 
              10474 ;
043F72 21     10475 @@:			LD	HL, KEYDOWN		; We have a key, so
043F73 47 
043F74 4D 
043F75 04 
043F76 36     10476 LD	(HL), 0			; clear the keydown flag
043F77 00 
043F78 FE     10477 CP	1BH			; If we are not pressing ESC,
043F79 1B 
043F7A 37     10478 SCF 				; then flag we've got a character
043F7B C0     10479 RET	NZ
              10480 ;
              10481 ; ESCSET
              10482 ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
              10483 ;
043F7C E5     10484 ESCSET: 		PUSH    HL
043F7D 21     10485 LD      HL,FLAGS		; Pointer to FLAGS
043F7E 42 
043F7F 4D 
043F80 04 
043F81 CB     10486 BIT     6,(HL)			; If bit 6 is set, then
043F82 76 
043F83 20     10487 JR      NZ,ESCDIS		; escape is disabled, so skip
043F84 02 
043F85 CB     10488 SET     7,(HL)			; Set bit 7, the escape flag
043F86 FE 
043F87 E1     10489 ESCDIS: 		POP     HL
043F88 C9     10490 RET
              10491 ;
              10492 ; ESCTEST
              10493 ; Test for ESC key
              10494 ;
043F89 CD     10495 ESCTEST:		CALL	READKEY			; Read the keyboard
043F8A 93 
043F8B 3F 
043F8C 04 
043F8D C0     10496 RET	NZ			; Skip if no key is pressed
043F8E FE     10497 CP	1BH			; If ESC pressed then
043F8F 1B 
043F90 28     10498 JR	Z,ESCSET		; jump to the escape set routine
043F91 EA 
043F92 C9     10499 RET
              10500 
              10501 ; Read the keyboard
              10502 ; Returns:
              10503 ; - A: ASCII of the pressed key
              10504 ; - F: Z if the key is pressed, otherwise NZ
              10505 ;
043F93 3A     10506 READKEY:		LD	A, (KEYDOWN)		; Get key down
043F94 47 
043F95 4D 
043F96 04 
043F97 3D     10507 DEC	A 			; Set Z flag if keydown is 1
043F98 3A     10508 LD	A, (KEYASCII)		; Get key ASCII value
043F99 48 
043F9A 4D 
043F9B 04 
043F9C C9     10509 RET
              10510 ;
              10511 ; TRAP
              10512 ; This is called whenever BASIC needs to check for ESC
              10513 ;
043F9D CD     10514 TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043F9E 89 
043F9F 3F 
043FA0 04 
              10515 ;
043FA1 3A     10516 LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FA2 42 
043FA3 4D 
043FA4 04 
043FA5 B7     10517 OR	A			; This checks for bit 7; if it is not set then the result will
043FA6 F0     10518 RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FA7 21     10519 LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FA8 42 
043FA9 4D 
043FAA 04 
043FAB CB     10520 RES	7,(HL)			; Clear the escape pressed flag and
043FAC BE 
043FAD C3     10521 JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FAE 9B 
043FAF 0C 
043FB0 04 
              10522 
              10523 ;OSINIT - Initialise RAM mapping etc.
              10524 ;If BASIC is entered by BBCBASIC FILENAME then file
              10525 ;FILENAME.BBC is automatically CHAINed.
              10526 ;   Outputs: DE = initial value of HIMEM (top of RAM)
              10527 ;            HL = initial value of PAGE (user program)
              10528 ;            Z-flag reset indicates AUTO-RUN.
              10529 ;  Destroys: A,D,E,H,L,F
              10530 ;
043FB1 CD     10531 OSINIT:			CALL	VBLANK_INIT
043FB2 16 
043FB3 49 
043FB4 04 
043FB5 AF     10532 XOR	A
043FB6 21     10533 LD 	HL, USER
043FB7 00 
043FB8 4E 
043FB9 04 
043FBA 11     10534 LD	DE, RAM_Top
043FBB 00 
043FBC 00 
043FBD 0B 
043FBE 5F     10535 LD	E, A			; Page boundary
043FBF C9     10536 RET
              10537 
              10538 ;
              10539 ;OSCLI - Process a MOS command
              10540 ;
043FC0 CD     10541 OSCLI: 			CALL    SKIPSP
043FC1 34 
043FC2 40 
043FC3 04 
043FC4 FE     10542 CP      CR
043FC5 0D 
043FC6 C8     10543 RET     Z
043FC7 FE     10544 CP      '|'
043FC8 7C 
043FC9 C8     10545 RET     Z
043FCA EB     10546 EX      DE,HL
043FCB 21     10547 LD      HL,COMDS
043FCC 43 
043FCD 40 
043FCE 04 
043FCF 1A     10548 OSCLI0:			LD      A,(DE)
043FD0 CD     10549 CALL    UPPRC
043FD1 3B 
043FD2 40 
043FD3 04 
043FD4 BE     10550 CP      (HL)
043FD5 28     10551 JR      Z,OSCLI2
043FD6 0B 
043FD7 38     10552 JR      C,OSCLI6
043FD8 30 
043FD9 CB     10553 OSCLI1:			BIT     7,(HL)
043FDA 7E 
043FDB 23     10554 INC     HL
043FDC 28     10555 JR      Z,OSCLI1
043FDD FB 
043FDE 23     10556 INC     HL
043FDF 23     10557 INC     HL
043FE0 18     10558 JR      OSCLI0
043FE1 ED 
              10559 ;
043FE2 D5     10560 OSCLI2:			PUSH    DE
043FE3 13     10561 OSCLI3:			INC     DE
043FE4 23     10562 INC     HL
043FE5 1A     10563 LD      A,(DE)
043FE6 CD     10564 CALL    UPPRC
043FE7 3B 
043FE8 40 
043FE9 04 
043FEA FE     10565 CP      '.'			; ABBREVIATED?
043FEB 2E 
043FEC 28     10566 JR      Z,OSCLI4
043FED 0A 
043FEE AE     10567 XOR     (HL)
043FEF 28     10568 JR      Z,OSCLI3
043FF0 F2 
043FF1 FE     10569 CP      80H
043FF2 80 
043FF3 28     10570 JR      Z,OSCLI4
043FF4 03 
043FF5 D1     10571 POP     DE
043FF6 18     10572 JR      OSCLI1
043FF7 E1 
              10573 ;
043FF8 F1     10574 OSCLI4:			POP     AF
043FF9 13     10575 INC     DE
043FFA CB     10576 OSCLI5:			BIT     7,(HL)
043FFB 7E 
043FFC 23     10577 INC     HL
043FFD 28     10578 JR      Z,OSCLI5
043FFE FB 
043FFF 7E     10579 LD      A,(HL)
044000 23     10580 INC     HL
044001 66     10581 LD      H,(HL)
044002 6F     10582 LD      L,A
044003 E5     10583 PUSH    HL
044004 EB     10584 EX      DE,HL
044005 C3     10585 JP      SKIPSP
044006 34 
044007 40 
044008 04 
              10586 ;
044009 EB     10587 OSCLI6:			EX	DE, HL			; HL: Buffer for command
04400A 11     10588 LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
04400B 00 
04400C 4A 
04400D 04 
04400E D5     10589 PUSH	DE			; Store buffer address
04400F CD     10590 CALL	CSTR_LINE		; Fetch the line
044010 5B 
044011 3E 
044012 04 
044013 E1     10591 POP	HL			; HL: Pointer to command string in ACCS
044014 FD     10592 PUSH	IY
044015 E5 
              10593 MOSCALL	mos_oscli		; Returns OSCLI error in A
044016 3E     0001M LD	A, function
044017 10 
044018 49     0002M RST.LIS	08h
044019 CF 
04401A FD     10594 POP	IY
04401B E1 
04401C B7     10595 OR	A			; 0 means MOS returned OK
04401D C8     10596 RET	Z			; So don't do anything
04401E C3     10597 JP 	OSERROR			; Otherwise it's a MOS error
04401F 58 
044020 42 
044021 04 
              10598 
044022 3E     10599 HUH:    		LD      A,254			; Bad command error
044023 FE 
044024 CD     10600 CALL    EXTERR
044025 A7 
044026 37 
044027 04 
044028 42     10601 DB    	"Bad command"
044029 61 
04402A 64 
04402B 20 
04402B 63   
04402C 6F 
04402D 6D 
04402E 6D 
04402E 61   
04402F 6E 
044030 64 
044033 00     10602 DEFB    0
              10603 
044034 7E     10604 SKIPSP:			LD      A,(HL)
044035 FE     10605 CP      ' '
044036 20 
044037 C0     10606 RET     NZ
044038 23     10607 INC     HL
044039 18     10608 JR      SKIPSP
04403A F9 
              10609 
04403B E6     10610 UPPRC:  		AND     7FH
04403C 7F 
04403D FE     10611 CP      '`'
04403E 60 
04403F D8     10612 RET     C
044040 E6     10613 AND     5FH			; CONVERT TO UPPER CASE
044041 5F 
044042 C9     10614 RET
              10615 
              10616 ; Each command has bit 7 of the last character set, and is followed by the address of the handler
              10617 ; These must be in alphabetical order
              10618 ;
044043 41     10619 COMDS:  		DB	"AS","M"+80h		; ASM
044044 53 
044045 4D 
044046 61     10620 DW	STAR_ASM
044047 40 
044048 42     10621 DB	"BY","E"+80h		; BYE
044049 59 
04404A 45 
04404B 6D     10622 DW	STAR_BYE
04404C 40 
04404D 45     10623 DB	"EDI","T"+80h		; EDIT
04404E 44 
04404F 49 
044050 54 
044051 A2     10624 DW	STAR_EDIT
044052 40 
044053 46     10625 DB	"F","X"+80h		; FX
044054 58 
044055 E2     10626 DW	STAR_FX
044056 40 
044057 56     10627 DB	"VERSIO","N"+80h	; VERSION
044058 45 
044059 52 
04405A 53 
04405A 49   
04405B 4F 
04405C 4E 
04405E 79     10628 DW	STAR_VERSION
04405F 40 
044060 FF     10629 DB	FFh
              10630 
              10631 ; *ASM string
              10632 ;
044061 FD     10633 STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044062 E5 
044063 E5     10634 PUSH	HL			; HL = IY
044064 FD     10635 POP	IY
044065 E1 
044066 CD     10636 CALL	ASSEM			; Invoke the assembler
044067 C5 
044068 18 
044069 04 
04406A FD     10637 POP	IY
04406B E1 
04406C C9     10638 RET
              10639 
              10640 ; *BYE
              10641 ;
04406D CD     10642 STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
04406E 2A 
04406F 49 
044070 04 
044071 21     10643 LD	HL, 0			; The return value
044072 00 
044073 00 
044074 00 
044075 C3     10644 JP	_end 			; Jump back to the end routine in init.asm
044076 68 
044077 00 
044078 04 
              10645 
              10646 ; *VERSION
              10647 ;
044079 CD     10648 STAR_VERSION:		CALL    TELL			; Output the welcome message
04407A C0 
04407B 3D 
04407C 04 
04407D 42     10649 DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
04407E 42 
04407F 43 
044080 20 
044080 42   
044081 41 
044082 53 
044083 49 
044083 43   
044084 20 
044085 28 
044086 41 
044086 67   
044087 6F 
044088 6E 
044089 20 
044089 41   
04408A 44 
04408B 4C 
04408C 29 
04408C 20   
04408D 56 
04408E 65 
04408F 72 
04408F 73   
044090 69 
044091 6F 
044092 6E 
044092 20   
044093 31 
044094 2E 
044095 30 
044095 33   
044096 0A 
044097 0D 
044098 00 
0440A1 C9     10650 RET
              10651 
              10652 ; *EDIT linenum
              10653 ;
0440A2 CD     10654 STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440A3 C7 
0440A4 3D 
0440A5 04 
0440A6 EB     10655 EX	DE, HL			; HL: Line number
0440A7 CD     10656 CALL	FINDL			; HL: Address in RAM of tokenised line
0440A8 BF 
0440A9 39 
0440AA 04 
0440AB 3E     10657 LD	A, 41			; F:NZ If the line is not found
0440AC 29 
0440AD C2     10658 JP	NZ, ERROR_		; Do error 41: No such line in that case
0440AE 90 
0440AF 37 
0440B0 04 
              10659 ;
              10660 ; Use LISTIT to output the line to the ACCS buffer
              10661 ;
0440B1 23     10662 INC	HL			; Skip the length byte
0440B2 5E     10663 LD	E, (HL)			; Fetch the line number
0440B3 23     10664 INC	HL
0440B4 56     10665 LD	D, (HL)
0440B5 23     10666 INC	HL
0440B6 DD     10667 LD	IX, ACCS		; Pointer to where the copy is to be stored
0440B7 21 
0440B8 00 
0440B9 4A 
0440B9 04   
0440BB DD     10668 LD	(OSWRCHPT), IX
0440BC 22 
0440BD 43 
0440BE 4D 
0440BE 04   
0440C0 DD     10669 LD	IX, LISTON		; Pointer to LISTON variable in RAM
0440C1 21 
0440C2 40 
0440C3 4D 
0440C3 04   
0440C5 DD     10670 LD	A, (IX)			; Store that variable
0440C6 7E 
0440C7 00 
0440C8 F5     10671 PUSH	AF
0440C9 DD     10672 LD	(IX), 09h		; Set to echo to buffer
0440CA 36 
0440CB 00 
0440CC 09 
0440CD CD     10673 CALL	LISTIT
0440CE C2 
0440CF 38 
0440D0 04 
0440D1 F1     10674 POP	AF
0440D2 DD     10675 LD	(IX), A			; Restore the original LISTON variable
0440D3 77 
0440D4 00 
0440D5 21     10676 LD	HL, ACCS		; HL: ACCS
0440D6 00 
0440D7 4A 
0440D8 04 
0440D9 5D     10677 LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0440DA CD     10678 CALL	OSLINE1			; Invoke the editor
0440DB 91 
0440DC 3E 
0440DD 04 
0440DE C3     10679 JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440DF 00 
0440E0 31 
0440E1 04 
              10680 
              10681 ; OSCLI FX n
              10682 ;
0440E2 CD     10683 STAR_FX:		CALL	ASC_TO_NUMBER
0440E3 C7 
0440E4 3D 
0440E5 04 
0440E6 4B     10684 LD	C, E			; C: Save FX #
0440E7 CD     10685 CALL	ASC_TO_NUMBER
0440E8 C7 
0440E9 3D 
0440EA 04 
0440EB 7A     10686 LD	A, D  			; Is first parameter > 255?
0440EC B7     10687 OR 	A
0440ED 28     10688 JR	Z, STAR_FX1		; Yes, so skip next bit
0440EE 03 
0440EF EB     10689 EX	DE, HL 			; Parameter is 16-bit
0440F0 18     10690 JR	STAR_FX2
0440F1 07 
              10691 ;
0440F2 43     10692 STAR_FX1:		LD	B, E 			; B: Save First parameter
0440F3 CD     10693 CALL	ASC_TO_NUMBER		; Fetch second parameter
0440F4 C7 
0440F5 3D 
0440F6 04 
0440F7 68     10694 LD	L, B 			; L: First parameter
0440F8 63     10695 LD	H, E 			; H: Second parameter
              10696 ;
0440F9 79     10697 STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
              10698 ;
              10699 ; OSBYTE
              10700 ;  A: FX #
              10701 ;  L: First parameter
              10702 ;  H: Second parameter
              10703 ;
0440FA FE     10704 OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0440FB 0B 
0440FC 28     10705 JR	Z, OSBYTE_0B
0440FD 18 
0440FE FE     10706 CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0440FF 0C 
044100 28     10707 JR	Z, OSBYTE_0C
044101 43 
044102 FE     10708 CP	13H			; *FX 19: Wait for vblank
044103 13 
044104 28     10709 JR	Z, OSBYTE_13
044105 6E 
044106 FE     10710 CP	76H			; *FX 118, n: Set keyboard LED
044107 76 
044108 CA     10711 JP	Z, OSBYTE_76
044109 8F 
04410A 41 
04410B 04 
04410C FE     10712 CP	A0H
04410D A0 
04410E CA     10713 JP	Z, OSBYTE_A0
04410F BF 
044110 41 
044111 04 
044112 C3     10714 JP	HUH			; Anything else trips an error
044113 22 
044114 40 
044115 04 
              10715 
              10716 ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
              10717 ; Parameters:
              10718 ; - HL: Repeat delay
              10719 ;
              10720 OSBYTE_0B:		VDU	23
044116 3E     0001M LD	A, val
044117 17 
044118 CD     0002M CALL	OSWRCH
044119 30 
04411A 3F 
04411B 04 
              10721 VDU	0
04411C 3E     0001M LD	A, val
04411D 00 
04411E CD     0002M CALL	OSWRCH
04411F 30 
044120 3F 
044121 04 
              10722 VDU	vdp_keystate
044122 3E     0001M LD	A, val
044123 88 
044124 CD     0002M CALL	OSWRCH
044125 30 
044126 3F 
044127 04 
              10723 VDU	L
044128 7D     0001M LD	A, val
044129 CD     0002M CALL	OSWRCH
04412A 30 
04412B 3F 
04412C 04 
              10724 VDU	H
04412D 7C     0001M LD	A, val
04412E CD     0002M CALL	OSWRCH
04412F 30 
044130 3F 
044131 04 
              10725 VDU	0
044132 3E     0001M LD	A, val
044133 00 
044134 CD     0002M CALL	OSWRCH
044135 30 
044136 3F 
044137 04 
              10726 VDU 	0
044138 3E     0001M LD	A, val
044139 00 
04413A CD     0002M CALL	OSWRCH
04413B 30 
04413C 3F 
04413D 04 
              10727 VDU	255
04413E 3E     0001M LD	A, val
04413F FF 
044140 CD     0002M CALL	OSWRCH
044141 30 
044142 3F 
044143 04 
044144 C9     10728 RET
              10729 
              10730 ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
              10731 ; Parameters:
              10732 ; - HL: Repeat rate
              10733 ;
              10734 OSBYTE_0C:		VDU	23
044145 3E     0001M LD	A, val
044146 17 
044147 CD     0002M CALL	OSWRCH
044148 30 
044149 3F 
04414A 04 
              10735 VDU	0
04414B 3E     0001M LD	A, val
04414C 00 
04414D CD     0002M CALL	OSWRCH
04414E 30 
04414F 3F 
044150 04 
              10736 VDU	vdp_keystate
044151 3E     0001M LD	A, val
044152 88 
044153 CD     0002M CALL	OSWRCH
044154 30 
044155 3F 
044156 04 
              10737 VDU	0
044157 3E     0001M LD	A, val
044158 00 
044159 CD     0002M CALL	OSWRCH
04415A 30 
04415B 3F 
04415C 04 
              10738 VDU 	0
04415D 3E     0001M LD	A, val
04415E 00 
04415F CD     0002M CALL	OSWRCH
044160 30 
044161 3F 
044162 04 
              10739 VDU	L
044163 7D     0001M LD	A, val
044164 CD     0002M CALL	OSWRCH
044165 30 
044166 3F 
044167 04 
              10740 VDU	H
044168 7C     0001M LD	A, val
044169 CD     0002M CALL	OSWRCH
04416A 30 
04416B 3F 
04416C 04 
              10741 VDU	255
04416D 3E     0001M LD	A, val
04416E FF 
04416F CD     0002M CALL	OSWRCH
044170 30 
044171 3F 
044172 04 
044173 C9     10742 RET
              10743 
              10744 ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
              10745 ;
044174 CD     10746 OSBYTE_13:		CALL	WAIT_VBLANK
044175 7E 
044176 41 
044177 04 
044178 2E     10747 LD	L, 0			; Returns 0
044179 00 
04417A C3     10748 JP	COUNT0
04417B 7F 
04417C 05 
04417D 04 
              10749 ;
04417E DD     10750 WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
04417F E5 
              10751 MOSCALL	mos_sysvars		; Fetch pointer to system variables
044180 3E     0001M LD	A, function
044181 08 
044182 49     0002M RST.LIS	08h
044183 CF 
044184 DD     10752 LD	A, (IX + sysvar_time + 0)
044185 7E 
044186 00 
044187 DD     10753 @@:			CP 	A, (IX + sysvar_time + 0)
044188 BE 
044189 00 
04418A 28     10754 JR	Z, @B
04418B FB 
04418C DD     10755 POP	IX
04418D E1 
04418E C9     10756 RET
              10757 
              10758 ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
              10759 ; Parameters:
              10760 ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
              10761 ;
              10762 OSBYTE_76:		VDU	23
04418F 3E     0001M LD	A, val
044190 17 
044191 CD     0002M CALL	OSWRCH
044192 30 
044193 3F 
044194 04 
              10763 VDU	0
044195 3E     0001M LD	A, val
044196 00 
044197 CD     0002M CALL	OSWRCH
044198 30 
044199 3F 
04419A 04 
              10764 VDU	vdp_keystate
04419B 3E     0001M LD	A, val
04419C 88 
04419D CD     0002M CALL	OSWRCH
04419E 30 
04419F 3F 
0441A0 04 
              10765 VDU	0
0441A1 3E     0001M LD	A, val
0441A2 00 
0441A3 CD     0002M CALL	OSWRCH
0441A4 30 
0441A5 3F 
0441A6 04 
              10766 VDU 	0
0441A7 3E     0001M LD	A, val
0441A8 00 
0441A9 CD     0002M CALL	OSWRCH
0441AA 30 
0441AB 3F 
0441AC 04 
              10767 VDU	0
0441AD 3E     0001M LD	A, val
0441AE 00 
0441AF CD     0002M CALL	OSWRCH
0441B0 30 
0441B1 3F 
0441B2 04 
              10768 VDU	0
0441B3 3E     0001M LD	A, val
0441B4 00 
0441B5 CD     0002M CALL	OSWRCH
0441B6 30 
0441B7 3F 
0441B8 04 
              10769 VDU	L
0441B9 7D     0001M LD	A, val
0441BA CD     0002M CALL	OSWRCH
0441BB 30 
0441BC 3F 
0441BD 04 
0441BE C9     10770 RET
              10771 
              10772 ; OSBYTE 0xA0: Fetch system variable
              10773 ; Parameters:
              10774 ; - L: The system variable to fetch
              10775 ;
0441BF DD     10776 OSBYTE_A0:		PUSH	IX
0441C0 E5 
              10777 MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441C1 3E     0001M LD	A, function
0441C2 08 
0441C3 49     0002M RST.LIS	08h
0441C4 CF 
0441C5 01     10778 LD	BC, 0
0441C6 00 
0441C7 00 
0441C8 00 
0441C9 4D     10779 LD	C, L			; BCU = L
0441CA DD     10780 ADD	IX, BC			; Add to IX
0441CB 09 
0441CC DD     10781 LD	L, (IX + 0)		; Fetch the return value
0441CD 6E 
0441CE 00 
0441CF DD     10782 POP	IX
0441D0 E1 
0441D1 C3     10783 JP 	COUNT0
0441D2 7F 
0441D3 05 
0441D4 04 
              10784 
              10785 ;OSLOAD - Load an area of memory from a file.
              10786 ;   Inputs: HL addresses filename (CR terminated)
              10787 ;           DE = address at which to load
              10788 ;           BC = maximum allowed size (bytes)
              10789 ;  Outputs: Carry reset indicates no room for file.
              10790 ; Destroys: A,B,C,D,E,H,L,F
              10791 ;
0441D5 C5     10792 OSLOAD:			PUSH	BC			; Stack the size
0441D6 D5     10793 PUSH	DE			; Stack the load address
0441D7 11     10794 LD	DE, ACCS		; Buffer address for filename
0441D8 00 
0441D9 4A 
0441DA 04 
0441DB CD     10795 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0441DC 49 
0441DD 3E 
0441DE 04 
0441DF 21     10796 LD	HL, ACCS		; HL: Filename
0441E0 00 
0441E1 4A 
0441E2 04 
0441E3 CD     10797 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441E4 D5 
0441E5 42 
0441E6 04 
0441E7 CD     10798 CALL	EXT_HANDLER		; Get the default handler
0441E8 E9 
0441E9 42 
0441EA 04 
0441EB D1     10799 POP	DE			; Restore the load address
0441EC C1     10800 POP	BC			; Restore the size
0441ED B7     10801 OR	A
0441EE 28     10802 JR 	Z, OSLOAD_BBC
0441EF 60 
              10803 ;
              10804 ; Load the file in as a text file
              10805 ;
0441F0 AF     10806 OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441F1 CD     10807 CALL	OSOPEN			; Open the file
0441F2 5D 
0441F3 43 
0441F4 04 
0441F5 5F     10808 LD 	E, A 			; The filehandle
0441F6 B7     10809 OR	A
0441F7 3E     10810 LD	A, 4			; File not found error
0441F8 04 
0441F9 28     10811 JR	Z, OSERROR		; Jump to error handler
0441FA 5D 
0441FB CD     10812 CALL	NEWIT			; Call NEW to clear the program space
0441FC 9C 
0441FD 38 
0441FE 04 
              10813 ;
0441FF 21     10814 OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044200 00 
044201 4A 
044202 04 
              10815 ;
              10816 ; First skip any whitespace (indents) at the beginning of the input
              10817 ;
044203 CD     10818 @@:			CALL	OSBGET			; Read the byte into A
044204 74 
044205 43 
044206 04 
044207 38     10819 JR	C, OSLOAD_TXT3		; Is it EOF?
044208 1E 
044209 FE     10820 CP	LF 			; Is it LF?
04420A 0A 
04420B 28     10821 JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
04420C 1A 
04420D FE     10822 CP	21h			; Is it less than or equal to ASCII space?
04420E 21 
04420F 38     10823 JR	C, @B 			; Yes, so keep looping
044210 F2 
044211 77     10824 LD	(HL), A 		; Store the first character
044212 2C     10825 INC	L
              10826 ;
              10827 ; Now read the rest of the line in
              10828 ;
044213 CD     10829 OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
044214 74 
044215 43 
044216 04 
044217 38     10830 JR	C, OSLOAD_TXT4		; Is it EOF?
044218 2B 
044219 FE     10831 CP	20h			; Skip if not an ASCII character
04421A 20 
04421B 38     10832 JR	C, @F
04421C 06 
04421D 77     10833 LD	(HL), A 		; Store in the input buffer
04421E 2C     10834 INC	L			; Increment the buffer pointer
04421F CA     10835 JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044220 28 
044221 37 
044222 04 
044223 FE     10836 @@:			CP	LF			; Check for LF
044224 0A 
044225 20     10837 JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
044226 EC 
              10838 ;
              10839 ; Finally, handle EOL/EOF
              10840 ;
044227 36     10841 OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
044228 0D 
044229 7D     10842 LD	A, L			; Check for minimum line length
04422A FE     10843 CP	2			; If it is 2 characters or less (including CR)
04422B 02 
04422C 38     10844 JR	C, @F			; Then don't bother entering it
04422D 0A 
04422E D5     10845 PUSH	DE			; Preserve the filehandle
04422F CD     10846 CALL	ONEDIT1			; Enter the line in memory
044230 0C 
044231 31 
044232 04 
044233 DC     10847 CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
044234 6F 
044235 38 
044236 04 
044237 D1     10848 POP	DE
044238 CD     10849 @@:			CALL	OSSTAT			; End of file?
044239 85 
04423A 43 
04423B 04 
04423C 20     10850 JR	NZ, OSLOAD_TXT1		; No, so loop
04423D C1 
04423E CD     10851 CALL	OSSHUT			; Close the file
04423F 6C 
044240 43 
044241 04 
044242 37     10852 SCF				; Flag to BASIC that we're good
044243 C9     10853 RET
              10854 ;
              10855 ; Special case for BASIC programs with no blank line at the end
              10856 ;
044244 FE     10857 OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044245 20 
044246 38     10858 JR	C, @F
044247 06 
044248 77     10859 LD	(HL), A			; Store the character
044249 2C     10860 INC	L
04424A CA     10861 JP	Z, BAD
04424B 28 
04424C 37 
04424D 04 
04424E 18     10862 @@:			JR	OSLOAD_TXT3
04424F D7 
              10863 
              10864 ;
              10865 ; Load the file in as a tokenised binary blob
              10866 ;
              10867 OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044250 3E     0001M LD	A, function
044251 01 
044252 49     0002M RST.LIS	08h
044253 CF 
044254 D0     10868 RET	NC			; If load returns with carry reset - NO ROOM
044255 B7     10869 OR	A			; If there is no error (A=0)
044256 37     10870 SCF				; Need to set carry indicating there was room
044257 C8     10871 RET	Z			; Return
              10872 ;
044258 F5     10873 OSERROR:		PUSH	AF			; Handle the MOS error
044259 21     10874 LD	HL, ACCS		; Address of the buffer
04425A 00 
04425B 4A 
04425C 04 
04425D 01     10875 LD	BC, 256			; Length of the buffer
04425E 00 
04425F 01 
044260 00 
044261 5F     10876 LD	E, A			; The error code
              10877 MOSCALL	mos_getError		; Copy the error message into the buffer
044262 3E     0001M LD	A, function
044263 0F 
044264 49     0002M RST.LIS	08h
044265 CF 
044266 F1     10878 POP	AF
044267 E5     10879 PUSH	HL			; Stack the address of the error (now in ACCS)
044268 C6     10880 ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044269 7F 
04426A C3     10881 JP	EXTERR			; Trigger an external error
04426B A7 
04426C 37 
04426D 04 
              10882 
              10883 ;OSSAVE - Save an area of memory to a file.
              10884 ;   Inputs: HL addresses filename (term CR)
              10885 ;           DE = start address of data to save
              10886 ;           BC = length of data to save (bytes)
              10887 ; Destroys: A,B,C,D,E,H,L,F
              10888 ;
04426E C5     10889 OSSAVE:			PUSH	BC			; Stack the size
04426F D5     10890 PUSH	DE			; Stack the save address
044270 11     10891 LD	DE, ACCS		; Buffer address for filename
044271 00 
044272 4A 
044273 04 
044274 CD     10892 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044275 49 
044276 3E 
044277 04 
044278 21     10893 LD	HL, ACCS		; HL: Filename
044279 00 
04427A 4A 
04427B 04 
04427C CD     10894 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04427D D5 
04427E 42 
04427F 04 
044280 CD     10895 CALL	EXT_HANDLER		; Get the default handler
044281 E9 
044282 42 
044283 04 
044284 D1     10896 POP	DE			; Restore the save address
044285 C1     10897 POP	BC			; Restore the size
044286 B7     10898 OR	A			; Is the extension .BBC
044287 28     10899 JR	Z, OSSAVE_BBC		; Yes, so use that
044288 44 
              10900 ;
              10901 ; Save the file out as a text file
              10902 ;
044289 3A     10903 OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
04428A 45 
04428B 4D 
04428C 04 
04428D F5     10904 PUSH	AF
04428E AF     10905 XOR	A
04428F 3C     10906 INC	A			; Make sure C is clear, A is 1, for OPENOUT
044290 32     10907 LD	(OSWRCHCH), A
044291 45 
044292 4D 
044293 04 
044294 CD     10908 CALL	OSOPEN			; Open the file
044295 5D 
044296 43 
044297 04 
044298 32     10909 LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
044299 46 
04429A 4D 
04429B 04 
04429C DD     10910 LD	IX, LISTON		; Required for LISTIT
04429D 21 
04429E 40 
04429F 4D 
04429F 04   
0442A1 2A     10911 LD	HL, (PAGE_)		; Get start of program area
0442A2 14 
0442A3 4D 
0442A4 04 
0442A5 D9     10912 EXX
0442A6 01     10913 LD	BC, 0			; Set the initial indent counters
0442A7 00 
0442A8 00 
0442A9 00 
0442AA D9     10914 EXX
0442AB 7E     10915 OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442AC B7     10916 OR	A
0442AD 28     10917 JR	Z, OSSAVE_TXT2
0442AE 0F 
0442AF 23     10918 INC	HL			; Skip the length byte
0442B0 11     10919 LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442B1 00 
0442B2 00 
0442B3 00 
0442B4 5E     10920 LD	E, (HL)			; Get the line number
0442B5 23     10921 INC	HL
0442B6 56     10922 LD	D, (HL)
0442B7 23     10923 INC	HL
0442B8 CD     10924 CALL	LISTIT			; List the line
0442B9 C2 
0442BA 38 
0442BB 04 
0442BC 18     10925 JR	OSSAVE_TXT1
0442BD ED 
0442BE 3A     10926 OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442BF 46 
0442C0 4D 
0442C1 04 
0442C2 5F     10927 LD	E, A
0442C3 CD     10928 CALL	OSSHUT			; Close it
0442C4 6C 
0442C5 43 
0442C6 04 
0442C7 F1     10929 POP	AF			; Restore the channel
0442C8 32     10930 LD	(OSWRCHCH), A
0442C9 45 
0442CA 4D 
0442CB 04 
0442CC C9     10931 RET
              10932 ;
              10933 ; Save the file out as a tokenised binary blob
              10934 ;
              10935 OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442CD 3E     0001M LD	A, function
0442CE 02 
0442CF 49     0002M RST.LIS	08h
0442D0 CF 
0442D1 B7     10936 OR	A			; If there is no error (A=0)
0442D2 C8     10937 RET	Z			; Just return
0442D3 18     10938 JR	OSERROR			; Trip an error
0442D4 83 
              10939 
              10940 ; Check if an extension is specified in the filename
              10941 ; Add a default if not specified
              10942 ; HL: Filename (CSTR format)
              10943 ;
0442D5 E5     10944 EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442D6 0E     10945 LD	C, '.'			; Search for dot (marks start of extension)
0442D7 2E 
0442D8 CD     10946 CALL	CSTR_FINDCH
0442D9 69 
0442DA 3E 
0442DB 04 
0442DC B7     10947 OR	A			; Check for end of string marker
0442DD 20     10948 JR	NZ, @F			; No, so skip as we have an extension at this point
0442DE 08 
0442DF 11     10949 LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442E0 19 
0442E1 43 
0442E2 04 
0442E3 CD     10950 CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442E4 80 
0442E5 3E 
0442E6 04 
0442E7 E1     10951 @@:			POP	HL			; Restore the filename pointer
0442E8 C9     10952 RET
              10953 
              10954 ; Check if an extension is valid and, if so, provide a pointer to a handler
              10955 ; HL: Filename (CSTR format)
              10956 ; Returns:
              10957 ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
              10958 ;
0442E9 E5     10959 EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442EA 0E     10960 LD	C, '.'			; Find the '.'
0442EB 2E 
0442EC CD     10961 CALL	CSTR_FINDCH
0442ED 69 
0442EE 3E 
0442EF 04 
0442F0 11     10962 LD	DE, EXT_LOOKUP		; The lookup table
0442F1 19 
0442F2 43 
0442F3 04 
              10963 ;
0442F4 E5     10964 EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442F5 CD     10965 CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442F6 71 
0442F7 3E 
0442F8 04 
0442F9 E1     10966 POP	HL			; Restore the pointer to the extension
0442FA 28     10967 JR	Z, EXT_HANDLER_2	; We have a match!
0442FB 19 
              10968 ;
0442FC 1A     10969 @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0442FD 13     10970 INC	DE
0442FE B7     10971 OR	A
0442FF 20     10972 JR	NZ, @B
044300 FB 
044301 13     10973 INC	DE			; Skip the file extension # byte
              10974 ;
044302 1A     10975 LD	A, (DE)			; Are we at the end of the table?
044303 B7     10976 OR	A
044304 20     10977 JR	NZ, EXT_HANDLER_1	; No, so loop
044305 EE 
              10978 ;
044306 3E     10979 LD      A,204			; Throw a "Bad name" error
044307 CC 
044308 CD     10980 CALL    EXTERR
044309 A7 
04430A 37 
04430B 04 
04430C 42     10981 DB    	"Bad name", 0
04430D 61 
04430E 64 
04430F 20 
04430F 6E   
044310 61 
044311 6D 
044312 65 
044312 00   
              10982 ;
044315 13     10983 EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
044316 1A     10984 LD	A, (DE)
044317 E1     10985 POP	HL			; Restore the filename pointer
044318 C9     10986 RET
              10987 ;
              10988 
              10989 
              10990 ; Extension lookup table
              10991 ; CSTR, TYPE
              10992 ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
              10993 ; 	- 1: Human readable plain text
              10994 ;
044319 2E     10995 EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
04431A 42 
04431B 42 
04431C 43 
04431C 00   
04431D 00 
04431F 2E     10996 DB	".TXT", 0, 1
044320 54 
044321 58 
044322 54 
044322 00   
044323 01 
044325 2E     10997 DB	".ASC", 0, 1
044326 41 
044327 53 
044328 43 
044328 00   
044329 01 
04432B 2E     10998 DB	".BAS", 0, 1
04432C 42 
04432D 41 
04432E 53 
04432E 00   
04432F 01 
044331 00     10999 DB	0			; End of table
              11000 
              11001 ;OSCALL - Intercept page &FF calls and provide an alternative address
              11002 ;
              11003 ;&FFF7:	OSCLI	Execute *command.
              11004 ;&FFF4:	OSBYTE	Various byte-wide functions.
              11005 ;&FFF1:	OSWORD	Various control block functions.
              11006 ;&FFEE:	OSWRCH	Write character to output stream.
              11007 ;&FFE7:	OSNEWL	Write NewLine to output stream.
              11008 ;&FFE3:	OSASCI	Write character or NewLine to output stream.
              11009 ;&FFE0:	OSRDCH	Wait for character from input stream.
              11010 ;&FFDD:	OSFILE	Perform actions on whole files or directories.
              11011 ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
              11012 ;&FFD7:	OSBGET	Read a byte from an a channel.
              11013 ;&FFD4:	OSBPUT	Write a byte to a channel.
              11014 ;&FFD1:	OSGBPB	Read and write blocks of data.
              11015 ;&FFCE:	OSFIND	Open or close a file.
              11016 ;
044332 21     11017 OSCALL:			LD	HL, OSCALL_TABLE
044333 48 
044334 43 
044335 04 
044336 7E     11018 OSCALL_1:		LD	A, (HL)
044337 23     11019 INC	HL
044338 FE     11020 CP	FFh
044339 FF 
04433A C8     11021 RET	Z
04433B FD     11022 CP	A, IYL
04433C BD 
04433D 28     11023 JR	Z, OSCALL_2
04433E 06 
04433F D0     11024 RET	NC
044340 23     11025 INC	HL
044341 23     11026 INC	HL
044342 23     11027 INC	HL
044343 18     11028 JR	OSCALL_1
044344 F1 
044345 ED     11029 OSCALL_2:		LD	IY,(HL)
044346 31 
044347 C9     11030 RET
044348 D4     11031 OSCALL_TABLE:		DB 	D4h
044349 7C     11032 DW24 	OSBPUT
04434A 43 
04434B 04 
04434C D7     11033 DB 	D7h
04434D 74     11034 DW24 	OSBGET
04434E 43 
04434F 04 
044350 EE     11035 DB 	EEh
044351 30     11036 DW24 	OSWRCH
044352 3F 
044353 04 
044354 F4     11037 DB	F4h
044355 FA     11038 DW24 	OSBYTE
044356 40 
044357 04 
044358 F7     11039 DB	F7h
044359 C0     11040 DW24	OSCLI
04435A 3F 
04435B 04 
04435C FF     11041 DB	FFh
              11042 
              11043 ; OSOPEN
              11044 ; HL: Pointer to path
              11045 ;  F: C Z
              11046 ;     x x OPENIN
              11047 ; 	  OPENOUT
              11048 ;     x	  OPENUP
              11049 ; Returns:
              11050 ;  A: Filehandle, 0 if cannot open
              11051 ;
04435D 0E     11052 OSOPEN:			LD	C, fa_read
04435E 01 
04435F 28     11053 JR	Z, @F
044360 06 
044361 0E     11054 LD	C, fa_write | fa_open_append
044362 32 
044363 38     11055 JR	C, @F
044364 02 
044365 0E     11056 LD	C, fa_write | fa_create_always
044366 0A 
              11057 @@:			MOSCALL	mos_fopen
044367 3E     0001M LD	A, function
044368 0A 
044369 49     0002M RST.LIS	08h
04436A CF 
04436B C9     11058 RET
              11059 
              11060 ;OSSHUT - Close disk file(s).
              11061 ; E = file channel
              11062 ;  If E=0 all files are closed (except SPOOL)
              11063 ; Destroys: A,B,C,D,E,H,L,F
              11064 ;
04436C C5     11065 OSSHUT:			PUSH	BC
04436D 4B     11066 LD	C, E
              11067 MOSCALL	mos_fclose
04436E 3E     0001M LD	A, function
04436F 0B 
044370 49     0002M RST.LIS	08h
044371 CF 
044372 C1     11068 POP	BC
044373 C9     11069 RET
              11070 
              11071 ; OSBGET - Read a byte from a random disk file.
              11072 ;  E = file channel
              11073 ; Returns
              11074 ;  A = byte read
              11075 ;  Carry set if LAST BYTE of file
              11076 ; Destroys: A,B,C,F
              11077 ;
044374 C5     11078 OSBGET:			PUSH	BC
044375 4B     11079 LD	C, E
              11080 MOSCALL	mos_fgetc
044376 3E     0001M LD	A, function
044377 0C 
044378 49     0002M RST.LIS	08h
044379 CF 
04437A C1     11081 POP	BC
04437B C9     11082 RET
              11083 
              11084 ; OSBPUT - Write a byte to a random disk file.
              11085 ;  E = file channel
              11086 ;  A = byte to write
              11087 ; Destroys: A,B,C,F
              11088 ;
04437C C5     11089 OSBPUT:			PUSH	BC
04437D 4B     11090 LD	C, E
04437E 47     11091 LD	B, A
              11092 MOSCALL	mos_fputc
04437F 3E     0001M LD	A, function
044380 0D 
044381 49     0002M RST.LIS	08h
044382 CF 
044383 C1     11093 POP	BC
044384 C9     11094 RET
              11095 
              11096 ; OSSTAT - Read file status
              11097 ;  E = file channel
              11098 ; Returns
              11099 ;  F: Z flag set - EOF
              11100 ;  A: If Z then A = 0
              11101 ; Destroys: A,D,E,H,L,F
              11102 ;
044385 C5     11103 OSSTAT:			PUSH	BC
044386 4B     11104 LD	C, E
              11105 MOSCALL	mos_feof
044387 3E     0001M LD	A, function
044388 0E 
044389 49     0002M RST.LIS	08h
04438A CF 
04438B C1     11106 POP	BC
04438C FE     11107 CP	1
04438D 01 
04438E C9     11108 RET
              11109 
              11110 ; GETPTR - Return file pointer.
              11111 ;    E = file channel
              11112 ; Returns:
              11113 ; DEHL = pointer (0-&7FFFFF)
              11114 ; Destroys: A,B,C,D,E,H,L,F
              11115 ;
04438F FD     11116 GETPTR:			PUSH		IY
044390 E5 
044391 4B     11117 LD		C, E
              11118 MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044392 3E     0001M LD	A, function
044393 19 
044394 49     0002M RST.LIS	08h
044395 CF 
044396 E5     11119 PUSH		HL
044397 FD     11120 POP		IY		; IYU: Pointer to FIL structure
044398 E1 
044399 FD     11121 LD		L, (IY + FIL.fptr + 0)
04439A 6E 
04439B 11 
04439C FD     11122 LD		H, (IY + FIL.fptr + 1)
04439D 66 
04439E 12 
04439F FD     11123 LD		E, (IY + FIL.fptr + 2)
0443A0 5E 
0443A1 13 
0443A2 FD     11124 LD		D, (IY + FIL.fptr + 3)
0443A3 56 
0443A4 14 
0443A5 FD     11125 POP		IY
0443A6 E1 
0443A7 C9     11126 RET
              11127 
              11128 ; PUTPTR - Update file pointer.
              11129 ;    A = file channel
              11130 ; DEHL = new pointer (0-&7FFFFF)
              11131 ; Destroys: A,B,C,D,E,H,L,F
              11132 ;
0443A8 FD     11133 PUTPTR:			PUSH		IY
0443A9 E5 
0443AA 4F     11134 LD		C, A  		; C: Filehandle
0443AB E5     11135 PUSH		HL
0443AC 21     11136 LD		HL, 2
0443AD 02 
0443AE 00 
0443AF 00 
0443B0 39     11137 ADD		HL, SP
0443B1 73     11138 LD		(HL), E 	; 3rd byte of DWORD set to E
0443B2 E1     11139 POP		HL
0443B3 5A     11140 LD		E, D  		; 4th byte passed as E
              11141 MOSCALL		mos_flseek
0443B4 3E     0001M LD	A, function
0443B5 1C 
0443B6 49     0002M RST.LIS	08h
0443B7 CF 
0443B8 FD     11142 POP		IY
0443B9 E1 
0443BA C9     11143 RET
              11144 
              11145 ; GETEXT - Find file size.
              11146 ;    E = file channel
              11147 ; Returns:
              11148 ; DEHL = file size (0-&800000)
              11149 ; Destroys: A,B,C,D,E,H,L,F
              11150 ;
0443BB FD     11151 GETEXT:         PUSH    IY
0443BC E5 
0443BD 4B     11152 LD      C, E
              11153 MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443BE 3E     0001M LD	A, function
0443BF 19 
0443C0 49     0002M RST.LIS	08h
0443C1 CF 
0443C2 E5     11154 PUSH    HL
0443C3 FD     11155 POP     IY          ; IYU: Pointer to FIL structure
0443C4 E1 
              11156 ; Access the obj.objsize field using the offset values
0443C5 FD     11157 LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443C6 6E 
0443C7 0B 
0443C8 FD     11158 LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443C9 66 
0443CA 0C 
0443CB FD     11159 LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443CC 5E 
0443CD 0D 
0443CE FD     11160 LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443CF 56 
0443D0 0E 
              11161 
0443D1 FD     11162 POP     IY
0443D2 E1 
0443D3 C9     11163 RET
              11164 
              11165 ; GETIMS - Get time from RTC
              11166 ;
0443D4 FD     11167 GETIMS:			PUSH	IY
0443D5 E5 
0443D6 21     11168 LD	HL, ACCS 		; Where to store the time string
0443D7 00 
0443D8 4A 
0443D9 04 
              11169 MOSCALL	mos_getrtc
0443DA 3E     0001M LD	A, function
0443DB 12 
0443DC 49     0002M RST.LIS	08h
0443DD CF 
0443DE 11     11170 LD	DE, ACCS		; DE: pointer to start of string accumulator
0443DF 00 
0443E0 4A 
0443E1 04 
0443E2 5F     11171 LD	E, A 			;  E: now points to the end of the string
0443E3 FD     11172 POP	IY
0443E4 E1 
0443E5 C9     11173 RET
              11174 
              11175 ; Get two word values from EXPR in DE, HL
              11176 ; IY: Pointer to expression string
              11177 ; Returns:
              11178 ; DE: P1
              11179 ; HL: P2
              11180 ;
0443E6 CD     11181 EXPR_W2:		CALL	EXPRI			; Get first parameter
0443E7 0A 
0443E8 03 
0443E9 04 
0443EA D9     11182 EXX
0443EB E5     11183 PUSH	HL
0443EC CD     11184 CALL	COMMA
0443ED 22 
0443EE 0A 
0443EF 04 
0443F0 CD     11185 CALL	EXPRI			; Get second parameter
0443F1 0A 
0443F2 03 
0443F3 04 
0443F4 D9     11186 EXX
0443F5 D1     11187 POP	DE
0443F6 C9     11188 RET
              11189 
              11190 ; Stuff not implemented yet
              11191 ;
0443F7 C9     11192 RESET:			RET
              11193 ; --- End patch.asm ---
              11194 
              11195 ; --- Begin agon_graphics.asm ---
              11196 ;
              11197 ; Title:	BBC Basic for AGON - Graphics stuff
              11198 ; Author:	Dean Belfield
              11199 ; Created:	12/05/2023
              11200 ; Last Updated:	07/06/2023
              11201 ;
              11202 ; Modinfo:
              11203 ; 07/06/2023:	Modified to run in ADL mode
              11204 
              11205 ; .ASSUME	ADL = 1
              11206 
              11207 ; INCLUDE	"equs.inc"
              11208 ; INCLUDE "macros.inc"
              11209 ; INCLUDE "mos_api.inc"	; In MOS/src
              11210 
              11211 ; SEGMENT CODE
              11212 
              11213 ; XDEF	CLG
              11214 ; XDEF	CLRSCN
              11215 ; XDEF	MODE
              11216 ; XDEF	COLOUR
              11217 ; XDEF	GCOL
              11218 ; XDEF	MOVE
              11219 ; XDEF	PLOT
              11220 ; XDEF	DRAW
              11221 ; XDEF	POINT
              11222 ; XDEF	GETSCHR
              11223 
              11224 ; XREF	OSWRCH
              11225 ; XREF	ASC_TO_NUMBER
              11226 ; XREF	EXTERR
              11227 ; XREF	EXPRI
              11228 ; XREF	COMMA
              11229 ; XREF	XEQ
              11230 ; XREF	NXT
              11231 ; XREF	BRAKET
              11232 ; XREF	COUNT0
              11233 ; XREF	CRTONULL
              11234 ; XREF	NULLTOCR
              11235 ; XREF	CRLF
              11236 ; XREF	EXPR_W2
              11237 ; XREF	INKEY1
              11238 
              11239 ; CLG: clears the graphics area
              11240 ;
              11241 CLG:			VDU	10h
0443F8 3E     0001M LD	A, val
0443F9 10 
0443FA CD     0002M CALL	OSWRCH
0443FB 30 
0443FC 3F 
0443FD 04 
0443FE C3     11242 JP	XEQ
0443FF 96 
044400 0B 
044401 04 
              11243 
              11244 ; CLS: clears the text area
              11245 ;
044402 3E     11246 CLRSCN:			LD	A, 0Ch
044403 0C 
044404 C3     11247 JP	OSWRCH
044405 30 
044406 3F 
044407 04 
              11248 
              11249 ; MODE n: Set video mode
              11250 ;
044408 DD     11251 MODE:			PUSH	IX			; Get the system vars in IX
044409 E5 
              11252 MOSCALL	mos_sysvars		; Reset the semaphore
04440A 3E     0001M LD	A, function
04440B 08 
04440C 49     0002M RST.LIS	08h
04440D CF 
04440E DD     11253 RES	4, (IX+sysvar_vpd_pflags)
04440F CB 
044410 04 
044411 A6 
044412 CD     11254 CALL    EXPRI
044413 0A 
044414 03 
044415 04 
044416 D9     11255 EXX
              11256 VDU	16H			; Mode change
044417 3E     0001M LD	A, val
044418 16 
044419 CD     0002M CALL	OSWRCH
04441A 30 
04441B 3F 
04441C 04 
              11257 VDU	L
04441D 7D     0001M LD	A, val
04441E CD     0002M CALL	OSWRCH
04441F 30 
044420 3F 
044421 04 
              11258 MOSCALL	mos_sysvars
044422 3E     0001M LD	A, function
044423 08 
044424 49     0002M RST.LIS	08h
044425 CF 
044426 DD     11259 @@:			BIT	4, (IX+sysvar_vpd_pflags)
044427 CB 
044428 04 
044429 66 
04442A 28     11260 JR	Z, @B			; Wait for the result
04442B FA 
04442C DD     11261 POP	IX
04442D E1 
04442E C3     11262 JP	XEQ
04442F 96 
044430 0B 
044431 04 
              11263 
              11264 ; GET(x,y): Get the ASCII code of a character on screen
              11265 ;
044432 FD     11266 GETSCHR:		INC	IY
044433 23 
044434 CD     11267 CALL    EXPRI      		; Get X coordinate
044435 0A 
044436 03 
044437 04 
044438 D9     11268 EXX
044439 22     11269 LD	(VDU_BUFFER+0), HL
04443A 00 
04443B 4A 
04443C 04 
04443D CD     11270 CALL	COMMA
04443E 22 
04443F 0A 
044440 04 
044441 CD     11271 CALL	EXPRI			; Get Y coordinate
044442 0A 
044443 03 
044444 04 
044445 D9     11272 EXX
044446 22     11273 LD	(VDU_BUFFER+2), HL
044447 02 
044448 4A 
044449 04 
04444A CD     11274 CALL	BRAKET			; Closing bracket
04444B 2F 
04444C 0A 
04444D 04 
              11275 ;
04444E DD     11276 PUSH	IX			; Get the system vars in IX
04444F E5 
              11277 MOSCALL	mos_sysvars		; Reset the semaphore
044450 3E     0001M LD	A, function
044451 08 
044452 49     0002M RST.LIS	08h
044453 CF 
044454 DD     11278 RES	1, (IX+sysvar_vpd_pflags)
044455 CB 
044456 04 
044457 8E 
              11279 VDU	23
044458 3E     0001M LD	A, val
044459 17 
04445A CD     0002M CALL	OSWRCH
04445B 30 
04445C 3F 
04445D 04 
              11280 VDU	0
04445E 3E     0001M LD	A, val
04445F 00 
044460 CD     0002M CALL	OSWRCH
044461 30 
044462 3F 
044463 04 
              11281 VDU	vdp_scrchar
044464 3E     0001M LD	A, val
044465 83 
044466 CD     0002M CALL	OSWRCH
044467 30 
044468 3F 
044469 04 
              11282 VDU	(VDU_BUFFER+0)
04446A 3A     0001M LD	A, val
04446B 00 
04446C 4A 
04446D 04 
04446E CD     0002M CALL	OSWRCH
04446F 30 
044470 3F 
044471 04 
              11283 VDU	(VDU_BUFFER+1)
044472 3A     0001M LD	A, val
044473 01 
044474 4A 
044475 04 
044476 CD     0002M CALL	OSWRCH
044477 30 
044478 3F 
044479 04 
              11284 VDU	(VDU_BUFFER+2)
04447A 3A     0001M LD	A, val
04447B 02 
04447C 4A 
04447D 04 
04447E CD     0002M CALL	OSWRCH
04447F 30 
044480 3F 
044481 04 
              11285 VDU	(VDU_BUFFER+3)
044482 3A     0001M LD	A, val
044483 03 
044484 4A 
044485 04 
044486 CD     0002M CALL	OSWRCH
044487 30 
044488 3F 
044489 04 
04448A DD     11286 @@:			BIT	1, (IX+sysvar_vpd_pflags)
04448B CB 
04448C 04 
04448D 4E 
04448E 28     11287 JR	Z, @B			; Wait for the result
04448F FA 
044490 DD     11288 LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
044491 7E 
044492 09 
044493 B7     11289 OR	A			; Check for 00h
044494 37     11290 SCF				; C = character map
044495 20     11291 JR	NZ, @F			; We have a character, so skip next bit
044496 02 
044497 AF     11292 XOR	A			; Clear carry
044498 3D     11293 DEC	A			; Set A to FFh
044499 DD     11294 @@:			POP	IX
04449A E1 
04449B C3     11295 JP	INKEY1			; Jump back to the GET command
04449C E1 
04449D 07 
04449E 04 
              11296 
              11297 ; POINT(x,y): Get the pixel colour of a point on screen
              11298 ;
04449F CD     11299 POINT:			CALL    EXPRI      		; Get X coordinate
0444A0 0A 
0444A1 03 
0444A2 04 
0444A3 D9     11300 EXX
0444A4 22     11301 LD	(VDU_BUFFER+0), HL
0444A5 00 
0444A6 4A 
0444A7 04 
0444A8 CD     11302 CALL	COMMA
0444A9 22 
0444AA 0A 
0444AB 04 
0444AC CD     11303 CALL	EXPRI			; Get Y coordinate
0444AD 0A 
0444AE 03 
0444AF 04 
0444B0 D9     11304 EXX
0444B1 22     11305 LD	(VDU_BUFFER+2), HL
0444B2 02 
0444B3 4A 
0444B4 04 
0444B5 CD     11306 CALL	BRAKET			; Closing bracket
0444B6 2F 
0444B7 0A 
0444B8 04 
              11307 ;
0444B9 DD     11308 PUSH	IX			; Get the system vars in IX
0444BA E5 
              11309 MOSCALL	mos_sysvars		; Reset the semaphore
0444BB 3E     0001M LD	A, function
0444BC 08 
0444BD 49     0002M RST.LIS	08h
0444BE CF 
0444BF DD     11310 RES	2, (IX+sysvar_vpd_pflags)
0444C0 CB 
0444C1 04 
0444C2 96 
              11311 VDU	23
0444C3 3E     0001M LD	A, val
0444C4 17 
0444C5 CD     0002M CALL	OSWRCH
0444C6 30 
0444C7 3F 
0444C8 04 
              11312 VDU	0
0444C9 3E     0001M LD	A, val
0444CA 00 
0444CB CD     0002M CALL	OSWRCH
0444CC 30 
0444CD 3F 
0444CE 04 
              11313 VDU	vdp_scrpixel
0444CF 3E     0001M LD	A, val
0444D0 84 
0444D1 CD     0002M CALL	OSWRCH
0444D2 30 
0444D3 3F 
0444D4 04 
              11314 VDU	(VDU_BUFFER+0)
0444D5 3A     0001M LD	A, val
0444D6 00 
0444D7 4A 
0444D8 04 
0444D9 CD     0002M CALL	OSWRCH
0444DA 30 
0444DB 3F 
0444DC 04 
              11315 VDU	(VDU_BUFFER+1)
0444DD 3A     0001M LD	A, val
0444DE 01 
0444DF 4A 
0444E0 04 
0444E1 CD     0002M CALL	OSWRCH
0444E2 30 
0444E3 3F 
0444E4 04 
              11316 VDU	(VDU_BUFFER+2)
0444E5 3A     0001M LD	A, val
0444E6 02 
0444E7 4A 
0444E8 04 
0444E9 CD     0002M CALL	OSWRCH
0444EA 30 
0444EB 3F 
0444EC 04 
              11317 VDU	(VDU_BUFFER+3)
0444ED 3A     0001M LD	A, val
0444EE 03 
0444EF 4A 
0444F0 04 
0444F1 CD     0002M CALL	OSWRCH
0444F2 30 
0444F3 3F 
0444F4 04 
0444F5 DD     11318 @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444F6 CB 
0444F7 04 
0444F8 56 
0444F9 28     11319 JR	Z, @B			; Wait for the result
0444FA FA 
              11320 ;
              11321 ; Return the data as a 1 byte index
              11322 ;
0444FB DD     11323 LD	L, (IX+sysvar_scrpixelIndex)
0444FC 6E 
0444FD 16 
0444FE DD     11324 POP	IX
0444FF E1 
044500 C3     11325 JP	COUNT0
044501 7F 
044502 05 
044503 04 
              11326 
              11327 
              11328 ; COLOUR colour
              11329 ; COLOUR L,P
              11330 ; COLOUR L,R,G,B
              11331 ;
044504 CD     11332 COLOUR:			CALL	EXPRI			; The colour / mode
044505 0A 
044506 03 
044507 04 
044508 D9     11333 EXX
044509 7D     11334 LD	A, L
04450A 32     11335 LD	(VDU_BUFFER+0), A	; Store first parameter
04450B 00 
04450C 4A 
04450D 04 
04450E CD     11336 CALL	NXT			; Are there any more parameters?
04450F 70 
044510 0A 
044511 04 
044512 FE     11337 CP	','
044513 2C 
044514 28     11338 JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
044515 12 
              11339 ;
              11340 VDU	11h			; Just set the colour
044516 3E     0001M LD	A, val
044517 11 
044518 CD     0002M CALL	OSWRCH
044519 30 
04451A 3F 
04451B 04 
              11341 VDU	(VDU_BUFFER+0)
04451C 3A     0001M LD	A, val
04451D 00 
04451E 4A 
04451F 04 
044520 CD     0002M CALL	OSWRCH
044521 30 
044522 3F 
044523 04 
044524 C3     11342 JP	XEQ
044525 96 
044526 0B 
044527 04 
              11343 ;
044528 CD     11344 COLOUR_1:		CALL	COMMA
044529 22 
04452A 0A 
04452B 04 
04452C CD     11345 CALL	EXPRI			; Parse R (OR P)
04452D 0A 
04452E 03 
04452F 04 
044530 D9     11346 EXX
044531 7D     11347 LD	A, L
044532 32     11348 LD	(VDU_BUFFER+1), A
044533 01 
044534 4A 
044535 04 
044536 CD     11349 CALL	NXT			; Are there any more parameters?
044537 70 
044538 0A 
044539 04 
04453A FE     11350 CP	','
04453B 2C 
04453C 28     11351 JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
04453D 2C 
              11352 ;
              11353 VDU	13h			; VDU:COLOUR
04453E 3E     0001M LD	A, val
04453F 13 
044540 CD     0002M CALL	OSWRCH
044541 30 
044542 3F 
044543 04 
              11354 VDU	(VDU_BUFFER+0)		; Logical Colour
044544 3A     0001M LD	A, val
044545 00 
044546 4A 
044547 04 
044548 CD     0002M CALL	OSWRCH
044549 30 
04454A 3F 
04454B 04 
              11355 VDU	(VDU_BUFFER+1)		; Palette Colour
04454C 3A     0001M LD	A, val
04454D 01 
04454E 4A 
04454F 04 
044550 CD     0002M CALL	OSWRCH
044551 30 
044552 3F 
044553 04 
              11356 VDU	0			; RGB set to 0
044554 3E     0001M LD	A, val
044555 00 
044556 CD     0002M CALL	OSWRCH
044557 30 
044558 3F 
044559 04 
              11357 VDU	0
04455A 3E     0001M LD	A, val
04455B 00 
04455C CD     0002M CALL	OSWRCH
04455D 30 
04455E 3F 
04455F 04 
              11358 VDU	0
044560 3E     0001M LD	A, val
044561 00 
044562 CD     0002M CALL	OSWRCH
044563 30 
044564 3F 
044565 04 
044566 C3     11359 JP	XEQ
044567 96 
044568 0B 
044569 04 
              11360 ;
04456A CD     11361 COLOUR_2:		CALL	COMMA
04456B 22 
04456C 0A 
04456D 04 
04456E CD     11362 CALL	EXPRI			; Parse G
04456F 0A 
044570 03 
044571 04 
044572 D9     11363 EXX
044573 7D     11364 LD	A, L
044574 32     11365 LD	(VDU_BUFFER+2), A
044575 02 
044576 4A 
044577 04 
044578 CD     11366 CALL	COMMA
044579 22 
04457A 0A 
04457B 04 
04457C CD     11367 CALL	EXPRI			; Parse B
04457D 0A 
04457E 03 
04457F 04 
044580 D9     11368 EXX
044581 7D     11369 LD	A, L
044582 32     11370 LD	(VDU_BUFFER+3), A
044583 03 
044584 4A 
044585 04 
              11371 VDU	13h			; VDU:COLOUR
044586 3E     0001M LD	A, val
044587 13 
044588 CD     0002M CALL	OSWRCH
044589 30 
04458A 3F 
04458B 04 
              11372 VDU	(VDU_BUFFER+0)		; Logical Colour
04458C 3A     0001M LD	A, val
04458D 00 
04458E 4A 
04458F 04 
044590 CD     0002M CALL	OSWRCH
044591 30 
044592 3F 
044593 04 
              11373 VDU	FFh			; Physical Colour (-1 for RGB mode)
044594 3E     0001M LD	A, val
044595 FF 
044596 CD     0002M CALL	OSWRCH
044597 30 
044598 3F 
044599 04 
              11374 VDU	(VDU_BUFFER+1)		; R
04459A 3A     0001M LD	A, val
04459B 01 
04459C 4A 
04459D 04 
04459E CD     0002M CALL	OSWRCH
04459F 30 
0445A0 3F 
0445A1 04 
              11375 VDU	(VDU_BUFFER+2)		; G
0445A2 3A     0001M LD	A, val
0445A3 02 
0445A4 4A 
0445A5 04 
0445A6 CD     0002M CALL	OSWRCH
0445A7 30 
0445A8 3F 
0445A9 04 
              11376 VDU	(VDU_BUFFER+3)		; B
0445AA 3A     0001M LD	A, val
0445AB 03 
0445AC 4A 
0445AD 04 
0445AE CD     0002M CALL	OSWRCH
0445AF 30 
0445B0 3F 
0445B1 04 
0445B2 C3     11377 JP	XEQ
0445B3 96 
0445B4 0B 
0445B5 04 
              11378 
              11379 ; GCOL mode,colour
              11380 ;
0445B6 CD     11381 GCOL:			CALL	EXPRI			; Parse MODE
0445B7 0A 
0445B8 03 
0445B9 04 
0445BA D9     11382 EXX
0445BB 7D     11383 LD	A, L
0445BC 32     11384 LD	(VDU_BUFFER+0), A
0445BD 00 
0445BE 4A 
0445BF 04 
0445C0 CD     11385 CALL	COMMA
0445C1 22 
0445C2 0A 
0445C3 04 
              11386 ;
0445C4 CD     11387 CALL	EXPRI			; Parse Colour
0445C5 0A 
0445C6 03 
0445C7 04 
0445C8 D9     11388 EXX
0445C9 7D     11389 LD	A, L
0445CA 32     11390 LD	(VDU_BUFFER+1), A
0445CB 01 
0445CC 4A 
0445CD 04 
              11391 ;
              11392 VDU	12h			; VDU:GCOL
0445CE 3E     0001M LD	A, val
0445CF 12 
0445D0 CD     0002M CALL	OSWRCH
0445D1 30 
0445D2 3F 
0445D3 04 
              11393 VDU	(VDU_BUFFER+0)		; Mode
0445D4 3A     0001M LD	A, val
0445D5 00 
0445D6 4A 
0445D7 04 
0445D8 CD     0002M CALL	OSWRCH
0445D9 30 
0445DA 3F 
0445DB 04 
              11394 VDU	(VDU_BUFFER+1)		; Colour
0445DC 3A     0001M LD	A, val
0445DD 01 
0445DE 4A 
0445DF 04 
0445E0 CD     0002M CALL	OSWRCH
0445E1 30 
0445E2 3F 
0445E3 04 
0445E4 C3     11395 JP	XEQ
0445E5 96 
0445E6 0B 
0445E7 04 
              11396 
              11397 ; PLOT mode,x,y
              11398 ;
0445E8 CD     11399 PLOT:			CALL	EXPRI		; Parse mode
0445E9 0A 
0445EA 03 
0445EB 04 
0445EC D9     11400 EXX
0445ED E5     11401 PUSH	HL		; Push mode (L) onto stack
0445EE CD     11402 CALL	COMMA
0445EF 22 
0445F0 0A 
0445F1 04 
0445F2 CD     11403 CALL	EXPR_W2		; Parse X and Y
0445F3 E6 
0445F4 43 
0445F5 04 
0445F6 C1     11404 POP	BC		; Pop mode (C) off stack
              11405 PLOT_1:			VDU	19H		; VDU code for PLOT
0445F7 3E     0001M LD	A, val
0445F8 19 
0445F9 CD     0002M CALL	OSWRCH
0445FA 30 
0445FB 3F 
0445FC 04 
              11406 VDU	C		;  C: Mode
0445FD 79     0001M LD	A, val
0445FE CD     0002M CALL	OSWRCH
0445FF 30 
044600 3F 
044601 04 
              11407 VDU	E		; DE: X
044602 7B     0001M LD	A, val
044603 CD     0002M CALL	OSWRCH
044604 30 
044605 3F 
044606 04 
              11408 VDU	D
044607 7A     0001M LD	A, val
044608 CD     0002M CALL	OSWRCH
044609 30 
04460A 3F 
04460B 04 
              11409 VDU	L		; HL: Y
04460C 7D     0001M LD	A, val
04460D CD     0002M CALL	OSWRCH
04460E 30 
04460F 3F 
044610 04 
              11410 VDU	H
044611 7C     0001M LD	A, val
044612 CD     0002M CALL	OSWRCH
044613 30 
044614 3F 
044615 04 
044616 C3     11411 JP	XEQ
044617 96 
044618 0B 
044619 04 
              11412 
              11413 ; MOVE x,y
              11414 ;
04461A CD     11415 MOVE:			CALL	EXPR_W2		; Parse X and Y
04461B E6 
04461C 43 
04461D 04 
04461E 0E     11416 LD	C, 04H		; Plot mode 04H (Move)
04461F 04 
044620 18     11417 JR	PLOT_1		; Plot
044621 D5 
              11418 
              11419 ; DRAW x1,y1
              11420 ; DRAW x1,y1,x2,y2
              11421 ;
044622 CD     11422 DRAW:			CALL	EXPR_W2		; Get X1 and Y1
044623 E6 
044624 43 
044625 04 
044626 CD     11423 CALL	NXT		; Are there any more parameters?
044627 70 
044628 0A 
044629 04 
04462A FE     11424 CP	','
04462B 2C 
04462C 0E     11425 LD	C, 05h		; Code for LINE
04462D 05 
04462E 20     11426 JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
04462F C7 
              11427 VDU	19h		; Move to the first coordinates
044630 3E     0001M LD	A, val
044631 19 
044632 CD     0002M CALL	OSWRCH
044633 30 
044634 3F 
044635 04 
              11428 VDU	04h
044636 3E     0001M LD	A, val
044637 04 
044638 CD     0002M CALL	OSWRCH
044639 30 
04463A 3F 
04463B 04 
              11429 VDU	E
04463C 7B     0001M LD	A, val
04463D CD     0002M CALL	OSWRCH
04463E 30 
04463F 3F 
044640 04 
              11430 VDU	D
044641 7A     0001M LD	A, val
044642 CD     0002M CALL	OSWRCH
044643 30 
044644 3F 
044645 04 
              11431 VDU	L
044646 7D     0001M LD	A, val
044647 CD     0002M CALL	OSWRCH
044648 30 
044649 3F 
04464A 04 
              11432 VDU	H
04464B 7C     0001M LD	A, val
04464C CD     0002M CALL	OSWRCH
04464D 30 
04464E 3F 
04464F 04 
044650 CD     11433 CALL	COMMA
044651 22 
044652 0A 
044653 04 
044654 C5     11434 PUSH	BC
044655 CD     11435 CALL	EXPR_W2		; Get X2 and Y2
044656 E6 
044657 43 
044658 04 
044659 C1     11436 POP	BC
04465A 18     11437 JR	PLOT_1		; Now DRAW the line to those positions
04465B 9B 
              11438 
              11439 
              11440 
              11441 ; --- End agon_graphics.asm ---
              11442 
              11443 ; --- Begin agon_sound.asm ---
              11444 ;
              11445 ; Title:	BBC Basic for AGON - Audio stuff
              11446 ; Author:	Dean Belfield
              11447 ; Created:	12/05/2023
              11448 ; Last Updated:	12/05/2023
              11449 ;
              11450 ; Modinfo:
              11451 
              11452 ; .ASSUME	ADL = 1
              11453 
              11454 ; INCLUDE	"equs.inc"
              11455 ; INCLUDE "macros.inc"
              11456 ; INCLUDE "mos_api.inc"	; In MOS/src
              11457 
              11458 ; SEGMENT CODE
              11459 
              11460 ; XDEF	SOUND
              11461 
              11462 ; XREF	COMMA
              11463 ; XREF	EXPR_W2
              11464 ; XREF	XEQ
              11465 ; XREF	LTRAP
              11466 ; XREF	OSWRCH
              11467 ; XREF	VDU_BUFFER
              11468 
              11469 
              11470 ; SOUND channel,volume,pitch,duration
              11471 ; volume: 0 (off) to -15 (full volume)
              11472 ; pitch: 0 - 255
              11473 ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
              11474 ;
04465C CD     11475 SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
04465D E6 
04465E 43 
04465F 04 
044660 7D     11476 LD	A, L 			;  A: Volume
044661 F5     11477 PUSH	AF
044662 D5     11478 PUSH	DE
044663 CD     11479 CALL	COMMA
044664 22 
044665 0A 
044666 04 
044667 CD     11480 CALL	EXPR_W2			; DE: Pitch, HL: Duration
044668 E6 
044669 43 
04466A 04 
04466B 53     11481 LD	D, E			;  D: Pitch
04466C 5D     11482 LD	E, L 			;  E: Duration
04466D E1     11483 POP	HL 			; HL: Channel/Control
04466E F1     11484 POP	AF
04466F ED     11485 NEG
044670 44 
044671 FE     11486 CP	16			; Check volume is in bounds
044672 10 
044673 D2     11487 JP	NC, XEQ			; Out of bounds, do nothing
044674 96 
044675 0B 
044676 04 
              11488 ;
              11489 ; Store	in VDU vars
              11490 ;
044677 4F     11491 LD	C, A			; Store Volume in C
044678 7D     11492 LD	A, L
044679 32     11493 LD	(VDU_BUFFER+0), A	; Channel
04467A 00 
04467B 4A 
04467C 04 
04467D AF     11494 XOR	A
04467E 32     11495 LD	(VDU_BUFFER+1), A	; Waveform
04467F 01 
044680 4A 
044681 04 
              11496 ;
              11497 ; Calculate the volume
              11498 ;
044682 06     11499 LD	B, 6			; C already contains the volume
044683 06 
044684 ED     11500 MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
044685 4C 
044686 79     11501 LD	A, C
044687 32     11502 LD	(VDU_BUFFER+2), A
044688 02 
044689 4A 
04468A 04 
              11503 ;
              11504 ; And the frequency
              11505 ;
04468B 4B     11506 LD	C, E			; Store duration in C
04468C 26     11507 LD	H, 0			; Lookup the frequency
04468D 00 
04468E 6A     11508 LD	L, D
04468F 11     11509 LD	DE, SOUND_FREQ_LOOKUP
044690 16 
044691 47 
044692 04 
044693 29     11510 ADD	HL, HL
044694 19     11511 ADD	HL, DE
044695 7E     11512 LD	A, (HL)
044696 32     11513 LD	(VDU_BUFFER+3), A
044697 03 
044698 4A 
044699 04 
04469A 23     11514 INC	HL
04469B 7E     11515 LD	A, (HL)
04469C 32     11516 LD	(VDU_BUFFER+4), A
04469D 04 
04469E 4A 
04469F 04 
              11517 ;
              11518 ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
              11519 ;
0446A0 06     11520 LD	B, 50			; C contains the duration, so MLT by 50
0446A1 32 
0446A2 ED     11521 MLT	BC
0446A3 4C 
0446A4 ED     11522 LD	(VDU_BUFFER+5), BC
0446A5 43 
0446A6 05 
0446A7 4A 
0446A7 04   
              11523 ;
0446A9 DD     11524 PUSH	IX			; Get the system vars in IX
0446AA E5 
              11525 MOSCALL	mos_sysvars		; Reset the semaphore
0446AB 3E     0001M LD	A, function
0446AC 08 
0446AD 49     0002M RST.LIS	08h
0446AE CF 
0446AF 5B     11526 SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
0446B0 DD 
0446B1 CB 
0446B2 04 
0446B2 9E   
              11527 ;
              11528 VDU	23			; Send the sound command
0446B4 3E     0001M LD	A, val
0446B5 17 
0446B6 CD     0002M CALL	OSWRCH
0446B7 30 
0446B8 3F 
0446B9 04 
              11529 VDU	0
0446BA 3E     0001M LD	A, val
0446BB 00 
0446BC CD     0002M CALL	OSWRCH
0446BD 30 
0446BE 3F 
0446BF 04 
              11530 VDU	vdp_audio
0446C0 3E     0001M LD	A, val
0446C1 85 
0446C2 CD     0002M CALL	OSWRCH
0446C3 30 
0446C4 3F 
0446C5 04 
              11531 VDU	(VDU_BUFFER+0)		; 0: Channel
0446C6 3A     0001M LD	A, val
0446C7 00 
0446C8 4A 
0446C9 04 
0446CA CD     0002M CALL	OSWRCH
0446CB 30 
0446CC 3F 
0446CD 04 
              11532 VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446CE 3A     0001M LD	A, val
0446CF 01 
0446D0 4A 
0446D1 04 
0446D2 CD     0002M CALL	OSWRCH
0446D3 30 
0446D4 3F 
0446D5 04 
              11533 VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446D6 3A     0001M LD	A, val
0446D7 02 
0446D8 4A 
0446D9 04 
0446DA CD     0002M CALL	OSWRCH
0446DB 30 
0446DC 3F 
0446DD 04 
              11534 VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446DE 3A     0001M LD	A, val
0446DF 03 
0446E0 4A 
0446E1 04 
0446E2 CD     0002M CALL	OSWRCH
0446E3 30 
0446E4 3F 
0446E5 04 
              11535 VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446E6 3A     0001M LD	A, val
0446E7 04 
0446E8 4A 
0446E9 04 
0446EA CD     0002M CALL	OSWRCH
0446EB 30 
0446EC 3F 
0446ED 04 
              11536 VDU	(VDU_BUFFER+5)		; 5: Duration L
0446EE 3A     0001M LD	A, val
0446EF 05 
0446F0 4A 
0446F1 04 
0446F2 CD     0002M CALL	OSWRCH
0446F3 30 
0446F4 3F 
0446F5 04 
              11537 VDU	(VDU_BUFFER+6)		; 6: Duration H
0446F6 3A     0001M LD	A, val
0446F7 06 
0446F8 4A 
0446F9 04 
0446FA CD     0002M CALL	OSWRCH
0446FB 30 
0446FC 3F 
0446FD 04 
              11538 ;
              11539 ; Wait for acknowledgement
              11540 ;
0446FE 5B     11541 @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
0446FF DD 
044700 CB 
044701 04 
044701 5E   
044703 28     11542 JR	Z, @B			; Wait for the result
044704 F9 
044705 CD     11543 CALL	LTRAP			; Check for ESC
044706 A1 
044707 3F 
044708 04 
044709 5B     11544 LD.LIL	A, (IX+sysvar_audioSuccess)
04470A DD 
04470B 7E 
04470C 0E 
04470D A7     11545 AND	A			; Check if VDP has queued the note
04470E 28     11546 JR	Z, SOUND0		; No, so loop back and send again
04470F 9F 
              11547 ;
044710 DD     11548 POP	IX
044711 E1 
044712 C3     11549 JP	XEQ
044713 96 
044714 0B 
044715 04 
              11550 
              11551 ; Frequency Lookup Table
              11552 ; Set up to replicate the BBC Micro audio frequencies
              11553 ;
              11554 ; Split over 5 complete octaves, with 53 being middle C
              11555 ; * C4: 262hz
              11556 ; + A4: 440hz
              11557 ;
              11558 ;	2	3	4	5	6	7	8
              11559 ;
              11560 ; B	1	49	97	145	193	241
              11561 ; A#	0	45	93	141	189	237
              11562 ; A		41	89+	137	185	233
              11563 ; G#		37	85	133	181	229
              11564 ; G		33	81	129	177	225
              11565 ; F#		29	77	125	173	221
              11566 ; F		25	73	121	169	217
              11567 ; E		21	69	117	165	213
              11568 ; D#		17	65	113	161	209
              11569 ; D		13	61	109	157	205	253
              11570 ; C#		9	57	105	153	201	249
              11571 ; C		5	53*	101	149	197	245
              11572 ;
044716 75     11573 SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
044717 00 
044718 76 
044719 00 
044719 78   
04471A 00 
04471B 7A 
04471C 00 
04471C 7B   
04471D 00 
04471E 83 
04471F 00 
04471F 85   
044720 00 
044721 87 
044722 00 
044726 89     11574 DW	 137,  139,  141,  143,  145,  147,  149,  151
044727 00 
044728 8B 
044729 00 
044729 8D   
04472A 00 
04472B 8F 
04472C 00 
04472C 91   
04472D 00 
04472E 93 
04472F 00 
04472F 95   
044730 00 
044731 97 
044732 00 
044736 99     11575 DW	 153,  156,  158,  160,  162,  165,  167,  170
044737 00 
044738 9C 
044739 00 
044739 9E   
04473A 00 
04473B A0 
04473C 00 
04473C A2   
04473D 00 
04473E A5 
04473F 00 
04473F A7   
044740 00 
044741 AA 
044742 00 
044746 AC     11576 DW	 172,  175,  177,  180,  182,  185,  188,  190
044747 00 
044748 AF 
044749 00 
044749 B1   
04474A 00 
04474B B4 
04474C 00 
04474C B6   
04474D 00 
04474E B9 
04474F 00 
04474F BC   
044750 00 
044751 BE 
044752 00 
044756 C1     11577 DW	 193,  196,  199,  202,  205,  208,  211,  214
044757 00 
044758 C4 
044759 00 
044759 C7   
04475A 00 
04475B CA 
04475C 00 
04475C CD   
04475D 00 
04475E D0 
04475F 00 
04475F D3   
044760 00 
044761 D6 
044762 00 
044766 D9     11578 DW	 217,  220,  223,  226,  230,  233,  236,  240
044767 00 
044768 DC 
044769 00 
044769 DF   
04476A 00 
04476B E2 
04476C 00 
04476C E6   
04476D 00 
04476E E9 
04476F 00 
04476F EC   
044770 00 
044771 F0 
044772 00 
044776 F3     11579 DW	 243,  247,  251,  254,  258,  262,  265,  269
044777 00 
044778 F7 
044779 00 
044779 FB   
04477A 00 
04477B FE 
04477C 00 
04477C 02   
04477D 01 
04477E 06 
04477F 01 
04477F 09   
044780 01 
044781 0D 
044782 01 
044786 11     11580 DW	 273,  277,  281,  285,  289,  294,  298,  302
044787 01 
044788 15 
044789 01 
044789 19   
04478A 01 
04478B 1D 
04478C 01 
04478C 21   
04478D 01 
04478E 26 
04478F 01 
04478F 2A   
044790 01 
044791 2E 
044792 01 
044796 33     11581 DW	 307,  311,  316,  320,  325,  330,  334,  339
044797 01 
044798 37 
044799 01 
044799 3C   
04479A 01 
04479B 40 
04479C 01 
04479C 45   
04479D 01 
04479E 4A 
04479F 01 
04479F 4E   
0447A0 01 
0447A1 53 
0447A2 01 
0447A6 58     11582 DW	 344,  349,  354,  359,  365,  370,  375,  381
0447A7 01 
0447A8 5D 
0447A9 01 
0447A9 62   
0447AA 01 
0447AB 67 
0447AC 01 
0447AC 6D   
0447AD 01 
0447AE 72 
0447AF 01 
0447AF 77   
0447B0 01 
0447B1 7D 
0447B2 01 
0447B6 82     11583 DW	 386,  392,  398,  403,  409,  415,  421,  427
0447B7 01 
0447B8 88 
0447B9 01 
0447B9 8E   
0447BA 01 
0447BB 93 
0447BC 01 
0447BC 99   
0447BD 01 
0447BE 9F 
0447BF 01 
0447BF A5   
0447C0 01 
0447C1 AB 
0447C2 01 
0447C6 B2     11584 DW	 434,  440,  446,  453,  459,  466,  473,  480
0447C7 01 
0447C8 B8 
0447C9 01 
0447C9 BE   
0447CA 01 
0447CB C5 
0447CC 01 
0447CC CB   
0447CD 01 
0447CE D2 
0447CF 01 
0447CF D9   
0447D0 01 
0447D1 E0 
0447D2 01 
0447D6 E7     11585 DW	 487,  494,  501,  508,  516,  523,  531,  539
0447D7 01 
0447D8 EE 
0447D9 01 
0447D9 F5   
0447DA 01 
0447DB FC 
0447DC 01 
0447DC 04   
0447DD 02 
0447DE 0B 
0447DF 02 
0447DF 13   
0447E0 02 
0447E1 1B 
0447E2 02 
0447E6 22     11586 DW	 546,  554,  562,  571,  579,  587,  596,  605
0447E7 02 
0447E8 2A 
0447E9 02 
0447E9 32   
0447EA 02 
0447EB 3B 
0447EC 02 
0447EC 43   
0447ED 02 
0447EE 4B 
0447EF 02 
0447EF 54   
0447F0 02 
0447F1 5D 
0447F2 02 
0447F6 65     11587 DW	 613,  622,  631,  641,  650,  659,  669,  679
0447F7 02 
0447F8 6E 
0447F9 02 
0447F9 77   
0447FA 02 
0447FB 81 
0447FC 02 
0447FC 8A   
0447FD 02 
0447FE 93 
0447FF 02 
0447FF 9D   
044800 02 
044801 A7 
044802 02 
044806 B1     11588 DW	 689,  699,  709,  719,  729,  740,  751,  762
044807 02 
044808 BB 
044809 02 
044809 C5   
04480A 02 
04480B CF 
04480C 02 
04480C D9   
04480D 02 
04480E E4 
04480F 02 
04480F EF   
044810 02 
044811 FA 
044812 02 
044816 05     11589 DW	 773,  784,  795,  807,  819,  831,  843,  855
044817 03 
044818 10 
044819 03 
044819 1B   
04481A 03 
04481B 27 
04481C 03 
04481C 33   
04481D 03 
04481E 3F 
04481F 03 
04481F 4B   
044820 03 
044821 57 
044822 03 
044826 63     11590 DW	 867,  880,  893,  906,  919,  932,  946,  960
044827 03 
044828 70 
044829 03 
044829 7D   
04482A 03 
04482B 8A 
04482C 03 
04482C 97   
04482D 03 
04482E A4 
04482F 03 
04482F B2   
044830 03 
044831 C0 
044832 03 
044836 CE     11591 DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
044837 03 
044838 DC 
044839 03 
044839 EA   
04483A 03 
04483B F9 
04483C 03 
04483C 08   
04483D 04 
04483E 17 
04483F 04 
04483F 26   
044840 04 
044841 36 
044842 04 
044846 45     11592 DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
044847 04 
044848 55 
044849 04 
044849 65   
04484A 04 
04484B 76 
04484C 04 
04484C 86   
04484D 04 
04484E 97 
04484F 04 
04484F A8   
044850 04 
044851 BA 
044852 04 
044856 CB     11593 DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
044857 04 
044858 DD 
044859 04 
044859 EF   
04485A 04 
04485B 02 
04485C 05 
04485C 14   
04485D 05 
04485E 27 
04485F 05 
04485F 3A   
044860 05 
044861 4E 
044862 05 
044866 62     11594 DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
044867 05 
044868 76 
044869 05 
044869 8A   
04486A 05 
04486B 9F 
04486C 05 
04486C B3   
04486D 05 
04486E C9 
04486F 05 
04486F DE   
044870 05 
044871 F4 
044872 05 
044876 0A     11595 DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
044877 06 
044878 21 
044879 06 
044879 38   
04487A 06 
04487B 4F 
04487C 06 
04487C 66   
04487D 06 
04487E 7E 
04487F 06 
04487F 96   
044880 06 
044881 AF 
044882 06 
044886 C8     11596 DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
044887 06 
044888 E1 
044889 06 
044889 FA   
04488A 06 
04488B 14 
04488C 07 
04488C 2F   
04488D 07 
04488E 4A 
04488F 07 
04488F 65   
044890 07 
044891 80 
044892 07 
044896 9C     11597 DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
044897 07 
044898 B8 
044899 07 
044899 D5   
04489A 07 
04489B F2 
04489C 07 
04489C 10   
04489D 08 
04489E 2D 
04489F 08 
04489F 4B   
0448A0 08 
0448A1 6A 
0448A2 08 
0448A6 8A     11598 DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
0448A7 08 
0448A8 A9 
0448A9 08 
0448A9 CA   
0448AA 08 
0448AB EA 
0448AC 08 
0448AC 0C   
0448AD 09 
0448AE 2D 
0448AF 09 
0448AF 4F   
0448B0 09 
0448B1 72 
0448B2 09 
0448B6 95     11599 DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
0448B7 09 
0448B8 B9 
0448B9 09 
0448B9 DD   
0448BA 09 
0448BB 02 
0448BC 0A 
0448BC 27   
0448BD 0A 
0448BE 4D 
0448BF 0A 
0448BF 73   
0448C0 0A 
0448C1 9A 
0448C2 0A 
0448C6 C2     11600 DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
0448C7 0A 
0448C8 EA 
0448C9 0A 
0448C9 12   
0448CA 0B 
0448CB 3C 
0448CC 0B 
0448CC 66   
0448CD 0B 
0448CE 90 
0448CF 0B 
0448CF BB   
0448D0 0B 
0448D1 E7 
0448D2 0B 
0448D6 13     11601 DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
0448D7 0C 
0448D8 40 
0448D9 0C 
0448D9 6E   
0448DA 0C 
0448DB 9C 
0448DC 0C 
0448DC CB   
0448DD 0C 
0448DE FA 
0448DF 0C 
0448DF 2B   
0448E0 0D 
0448E1 5C 
0448E2 0D 
0448E6 8E     11602 DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
0448E7 0D 
0448E8 C0 
0448E9 0D 
0448E9 F3   
0448EA 0D 
0448EB 27 
0448EC 0E 
0448EC 5C   
0448ED 0E 
0448EE 91 
0448EF 0E 
0448EF C8   
0448F0 0E 
0448F1 FF 
0448F2 0E 
0448F6 36     11603 DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
0448F7 0F 
0448F8 6F 
0448F9 0F 
0448F9 A9   
0448FA 0F 
0448FB E3 
0448FC 0F 
0448FC 1E   
0448FD 10 
0448FE 5A 
0448FF 10 
0448FF 97   
044900 10 
044901 D5 
044902 10 
044906 13     11604 DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
044907 11 
044908 53 
044909 11 
044909 93   
04490A 11 
04490B D5 
04490C 11 
04490C 17   
04490D 12 
04490E 5B 
04490F 12 
04490F 9F   
044910 12 
044911 E4 
044912 12 
              11605 
              11606 
              11607 ; --- End agon_sound.asm ---
              11608 
              11609 ; --- Begin interrupts.asm ---
              11610 ;
              11611 ; Title:	BBC Basic for AGON - Interrupts
              11612 ; Author:	Dean Belfield
              11613 ; Created:	12/05/2023
              11614 ; Last Updated:	07/06/2023
              11615 ;
              11616 ; Modinfo:
              11617 ; 07/06/2023:	Modified to run in ADL mode
              11618 
              11619 ; .ASSUME	ADL = 1
              11620 
              11621 ; INCLUDE	"macros.inc"
              11622 ; INCLUDE	"equs.inc"
              11623 ; INCLUDE "mos_api.inc"	; In MOS/src
              11624 
              11625 ; SEGMENT CODE
              11626 
              11627 ; XDEF	VBLANK_INIT
              11628 ; XDEF	VBLANK_STOP
              11629 ; XDEF	VBLANK_HANDLER
              11630 
              11631 ; XREF	ESCSET
              11632 ; XREF	KEYDOWN		; In ram.asm
              11633 ; XREF	KEYASCII 	; In ram.asm
              11634 ; XREF	KEYCOUNT	; In ram.asm
              11635 
              11636 ; Hook into the MOS VBLANK interrupt
              11637 ;
044916 F3     11638 VBLANK_INIT:		DI
044917 21     11639 LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044918 6B 
044919 49 
04491A 04 
04491B 1E     11640 LD		E, 32h				; Set up the VBlank Interrupt Vector
04491C 32 
              11641 MOSCALL		mos_setintvector
04491D 3E     0001M LD	A, function
04491E 14 
04491F 49     0002M RST.LIS	08h
044920 CF 
              11642 ; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044921 EB     11643 ex de,hl
044922 21     11644 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044923 79 
044924 49 
044925 04 
044926 ED     11645 LD		(HL), DE			; Self-modify the code
044927 1F 
044928 FB     11646 EI
044929 C9     11647 RET
              11648 
              11649 ; Unhook the custom VBLANK interrupt
              11650 ;
04492A F3     11651 VBLANK_STOP:		DI
04492B 21     11652 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04492C 79 
04492D 49 
04492E 04 
04492F ED     11653 LD		DE, (HL)
044930 17 
044931 EB     11654 EX		DE, HL 				; HLU: Address of MOS interrupt vector
044932 1E     11655 LD		E, 32h
044933 32 
              11656 MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
044934 3E     0001M LD	A, function
044935 14 
044936 49     0002M RST.LIS	08h
044937 CF 
044938 FB     11657 EI
044939 C9     11658 RET
              11659 
              11660 ; A safe LIS call to ESCSET
              11661 ;
              11662 DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
04493A 3E     0001M LD	A, function
04493B 08 
04493C 49     0002M RST.LIS	08h
04493D CF 
04493E 21     11663 LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04493F 49 
044940 4D 
044941 04 
044942 DD     11664 LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
044943 7E 
044944 19 
044945 BE     11665 CP 		(HL)				; with our local copy
044946 20     11666 JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044947 0A 
              11667 ;
044948 AF     11668 DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044949 32     11669 LD		(KEYASCII), A
04494A 48 
04494B 4D 
04494C 04 
04494D 32     11670 LD		(KEYDOWN), A
04494E 47 
04494F 4D 
044950 04 
044951 C9     11671 RET	 					; And return
              11672 ;
044952 77     11673 DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044953 DD     11674 LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044954 7E 
044955 18 
044956 B7     11675 OR		A
044957 28     11676 JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044958 EF 
              11677 ;
044959 32     11678 LD		(KEYDOWN), A 			; Store the keydown value
04495A 47 
04495B 4D 
04495C 04 
04495D DD     11679 LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
04495E 7E 
04495F 05 
044960 32     11680 LD		(KEYASCII), A 			; Store locally
044961 48 
044962 4D 
044963 04 
044964 FE     11681 CP		1Bh				; Is it escape?
044965 1B 
044966 CC     11682 CALL		Z, ESCSET			; Yes, so set the escape flags
044967 7C 
044968 3F 
044969 04 
04496A C9     11683 RET						; Return to the interrupt handler
              11684 
04496B F3     11685 VBLANK_HANDLER:		DI
04496C F5     11686 PUSH		AF
04496D E5     11687 PUSH		HL
04496E DD     11688 PUSH		IX
04496F E5 
044970 CD     11689 CALL		DO_KEYBOARD
044971 3A 
044972 49 
044973 04 
044974 DD     11690 POP		IX
044975 E1 
044976 E1     11691 POP		HL
044977 F1     11692 POP		AF
              11693 ;
              11694 ; Finally jump to the MOS interrupt
              11695 ;
044978 C3     11696 VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044979 00 
04497A 00 
04497B 00 
              11697 
              11698 ; --- Begin sorry.asm ---
              11699 ;
              11700 ; Title:	BBC Basic Interpreter - Z80 version
              11701 ;		Catch-all for unimplemented functionality
              11702 ; Author:	Dean Belfield
              11703 ; Created:	12/05/2023
              11704 ; Last Updated:	12/05/2023
              11705 ;
              11706 ; Modinfo:
              11707 
              11708 ; .ASSUME	ADL = 1
              11709 
              11710 ; SEGMENT CODE
              11711 
              11712 ; XDEF	ENVEL
              11713 ; XDEF	ADVAL
              11714 ; XDEF	PUTIMS
              11715 
              11716 ; XREF	EXTERR
              11717 
              11718 ENVEL:
              11719 ADVAL:
              11720 PUTIMS:
04497C AF     11721 XOR     A
04497D CD     11722 CALL    EXTERR
04497E A7 
04497F 37 
044980 04 
044981 53     11723 DEFB    "Sorry"
044982 6F 
044983 72 
044984 72 
044984 79   
044986 00     11724 DEFB    0
              11725 ; --- End sorry.asm ---
              11726 
              11727 ; --- Begin ram.asm ---
              11728 ;
              11729 ; Title:	BBC Basic Interpreter - Z80 version
              11730 ;		RAM Module for BBC Basic Interpreter
              11731 ;		For use with Version 2.0 of BBC BASIC
              11732 ;		Standard CP/M Distribution Version
              11733 ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              11734 ; Modified By:	Dean Belfield
              11735 ; Created:	12/05/2023
              11736 ; Last Updated:	26/06/2023
              11737 ;
              11738 ; Modinfo:
              11739 ; 06/06/2023:	Modified to run in ADL mode
              11740 ; 26/06/2023:	Added temporary stores R0 and R1
              11741 
              11742 ; .ASSUME	ADL = 1
              11743 
              11744 ; DEFINE	LORAM, SPACE = ROM
              11745 ; SEGMENT LORAM
              11746 
              11747 ; XDEF	ACCS
              11748 ; XDEF	BUFFER
              11749 ; XDEF	STAVAR
              11750 ; XDEF	DYNVAR
              11751 ; XDEF	FNPTR
              11752 ; XDEF	PROPTR
              11753 ; XDEF	PAGE_
              11754 ; XDEF	TOP
              11755 ; XDEF	LOMEM
              11756 ; XDEF 	FREE
              11757 ; XDEF	HIMEM
              11758 ; XDEF	LINENO
              11759 ; XDEF	TRACEN
              11760 ; XDEF	AUTONO
              11761 ; XDEF	ERRTRP
              11762 ; XDEF	ERRTXT
              11763 ; XDEF	DATPTR
              11764 ; XDEF	ERL
              11765 ; XDEF	ERRLIN
              11766 ; XDEF	RANDOM
              11767 ; XDEF	COUNT
              11768 ; XDEF	WIDTH
              11769 ; XDEF	ERR
              11770 ; XDEF	LISTON
              11771 ; XDEF	INCREM
              11772 
              11773 ; XDEF	FLAGS
              11774 ; XDEF	OSWRCHPT
              11775 ; XDEF	OSWRCHCH
              11776 ; XDEF	OSWRCHFH
              11777 ; XDEF	KEYDOWN
              11778 ; XDEF	KEYASCII
              11779 ; XDEF	KEYCOUNT
              11780 
              11781 ; XDEF	R0
              11782 ; XDEF	R1
              11783 
              11784 ; XDEF	RAM_START
              11785 ; XDEF	RAM_END
              11786 ; XDEF	USER
              11787 
044987 FF     11788 ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
044988 FF 
044989 FF 
04498A FF 
04498A FF   
04498B FF 
04498C FF 
04498D FF 
04498D FF   
04498E FF 
04498F FF 
044990 FF 
044990 FF   
044991 FF 
044992 FF 
044993 FF 
044993 FF   
044994 FF 
044995 FF 
044996 FF 
044996 FF   
044997 FF 
044998 FF 
044999 FF 
044999 FF   
04499A FF 
04499B FF 
04499C FF 
04499C FF   
04499D FF 
04499E FF 
04499F FF 
04499F FF   
0449A0 FF 
0449A1 FF 
0449A2 FF 
0449A2 FF   
0449A3 FF 
0449A4 FF 
0449A5 FF 
0449A5 FF   
0449A6 FF 
0449A7 FF 
0449A8 FF 
0449A8 FF   
0449A9 FF 
0449AA FF 
0449AB FF 
0449AB FF   
0449AC FF 
0449AD FF 
0449AE FF 
0449AE FF   
0449AF FF 
0449B0 FF 
0449B1 FF 
0449B1 FF   
0449B2 FF 
0449B3 FF 
0449B4 FF 
0449B4 FF   
0449B5 FF 
0449B6 FF 
0449B7 FF 
0449B7 FF   
0449B8 FF 
0449B9 FF 
0449BA FF 
0449BA FF   
0449BB FF 
0449BC FF 
0449BD FF 
0449BD FF   
0449BE FF 
0449BF FF 
0449C0 FF 
0449C0 FF   
0449C1 FF 
0449C2 FF 
0449C3 FF 
0449C3 FF   
0449C4 FF 
0449C5 FF 
0449C6 FF 
0449C6 FF   
0449C7 FF 
0449C8 FF 
0449C9 FF 
0449C9 FF   
0449CA FF 
0449CB FF 
0449CC FF 
0449CC FF   
0449CD FF 
0449CE FF 
0449CF FF 
0449CF FF   
0449D0 FF 
0449D1 FF 
0449D2 FF 
0449D2 FF   
0449D3 FF 
0449D4 FF 
0449D5 FF 
0449D5 FF   
0449D6 FF 
0449D7 FF 
0449D8 FF 
0449D8 FF   
0449D9 FF 
0449DA FF 
0449DB FF 
0449DB FF   
0449DC FF 
0449DD FF 
0449DE FF 
0449DE FF   
0449DF FF 
0449E0 FF 
0449E1 FF 
0449E1 FF   
              11789 RAM_START:
              11790 ;
044A00 00     11791 ACCS:           BLKB    256,0             ; String Accumulator
044A01 00 
044A02 00 
044A03 00 
044A03 00   
044A04 00 
044A05 00 
044A06 00 
044A06 00   
044A07 00 
044A08 00 
044A09 00 
044A09 00   
044A0A 00 
044A0B 00 
044A0C 00 
044A0C 00   
044A0D 00 
044A0E 00 
044A0F 00 
044A0F 00   
044A10 00 
044A11 00 
044A12 00 
044A12 00   
044A13 00 
044A14 00 
044A15 00 
044A15 00   
044A16 00 
044A17 00 
044A18 00 
044A18 00   
044A19 00 
044A1A 00 
044A1B 00 
044A1B 00   
044A1C 00 
044A1D 00 
044A1E 00 
044A1E 00   
044A1F 00 
044A20 00 
044A21 00 
044A21 00   
044A22 00 
044A23 00 
044A24 00 
044A24 00   
044A25 00 
044A26 00 
044A27 00 
044A27 00   
044A28 00 
044A29 00 
044A2A 00 
044A2A 00   
044A2B 00 
044A2C 00 
044A2D 00 
044A2D 00   
044A2E 00 
044A2F 00 
044A30 00 
044A30 00   
044A31 00 
044A32 00 
044A33 00 
044A33 00   
044A34 00 
044A35 00 
044A36 00 
044A36 00   
044A37 00 
044A38 00 
044A39 00 
044A39 00   
044A3A 00 
044A3B 00 
044A3C 00 
044A3C 00   
044A3D 00 
044A3E 00 
044A3F 00 
044A3F 00   
044A40 00 
044A41 00 
044A42 00 
044A42 00   
044A43 00 
044A44 00 
044A45 00 
044A45 00   
044A46 00 
044A47 00 
044A48 00 
044A48 00   
044A49 00 
044A4A 00 
044A4B 00 
044A4B 00   
044A4C 00 
044A4D 00 
044A4E 00 
044A4E 00   
044A4F 00 
044A50 00 
044A51 00 
044A51 00   
044A52 00 
044A53 00 
044A54 00 
044A54 00   
044A55 00 
044A56 00 
044A57 00 
044A57 00   
044A58 00 
044A59 00 
044A5A 00 
044A5A 00   
044A5B 00 
044A5C 00 
044A5D 00 
044A5D 00   
044A5E 00 
044A5F 00 
044A60 00 
044A60 00   
044A61 00 
044A62 00 
044A63 00 
044A63 00   
044A64 00 
044A65 00 
044A66 00 
044A66 00   
044A67 00 
044A68 00 
044A69 00 
044A69 00   
044A6A 00 
044A6B 00 
044A6C 00 
044A6C 00   
044A6D 00 
044A6E 00 
044A6F 00 
044A6F 00   
044A70 00 
044A71 00 
044A72 00 
044A72 00   
044A73 00 
044A74 00 
044A75 00 
044A75 00   
044A76 00 
044A77 00 
044A78 00 
044A78 00   
044A79 00 
044A7A 00 
044A7B 00 
044A7B 00   
044A7C 00 
044A7D 00 
044A7E 00 
044A7E 00   
044A7F 00 
044A80 00 
044A81 00 
044A81 00   
044A82 00 
044A83 00 
044A84 00 
044A84 00   
044A85 00 
044A86 00 
044A87 00 
044A87 00   
044A88 00 
044A89 00 
044A8A 00 
044A8A 00   
044A8B 00 
044A8C 00 
044A8D 00 
044A8D 00   
044A8E 00 
044A8F 00 
044A90 00 
044A90 00   
044A91 00 
044A92 00 
044A93 00 
044A93 00   
044A94 00 
044A95 00 
044A96 00 
044A96 00   
044A97 00 
044A98 00 
044A99 00 
044A99 00   
044A9A 00 
044A9B 00 
044A9C 00 
044A9C 00   
044A9D 00 
044A9E 00 
044A9F 00 
044A9F 00   
044AA0 00 
044AA1 00 
044AA2 00 
044AA2 00   
044AA3 00 
044AA4 00 
044AA5 00 
044AA5 00   
044AA6 00 
044AA7 00 
044AA8 00 
044AA8 00   
044AA9 00 
044AAA 00 
044AAB 00 
044AAB 00   
044AAC 00 
044AAD 00 
044AAE 00 
044AAE 00   
044AAF 00 
044AB0 00 
044AB1 00 
044AB1 00   
044AB2 00 
044AB3 00 
044AB4 00 
044AB4 00   
044AB5 00 
044AB6 00 
044AB7 00 
044AB7 00   
044AB8 00 
044AB9 00 
044ABA 00 
044ABA 00   
044ABB 00 
044ABC 00 
044ABD 00 
044ABD 00   
044ABE 00 
044ABF 00 
044AC0 00 
044B00 00     11792 BUFFER:         BLKB    256,0             ; String Input Buffer
044B01 00 
044B02 00 
044B03 00 
044B03 00   
044B04 00 
044B05 00 
044B06 00 
044B06 00   
044B07 00 
044B08 00 
044B09 00 
044B09 00   
044B0A 00 
044B0B 00 
044B0C 00 
044B0C 00   
044B0D 00 
044B0E 00 
044B0F 00 
044B0F 00   
044B10 00 
044B11 00 
044B12 00 
044B12 00   
044B13 00 
044B14 00 
044B15 00 
044B15 00   
044B16 00 
044B17 00 
044B18 00 
044B18 00   
044B19 00 
044B1A 00 
044B1B 00 
044B1B 00   
044B1C 00 
044B1D 00 
044B1E 00 
044B1E 00   
044B1F 00 
044B20 00 
044B21 00 
044B21 00   
044B22 00 
044B23 00 
044B24 00 
044B24 00   
044B25 00 
044B26 00 
044B27 00 
044B27 00   
044B28 00 
044B29 00 
044B2A 00 
044B2A 00   
044B2B 00 
044B2C 00 
044B2D 00 
044B2D 00   
044B2E 00 
044B2F 00 
044B30 00 
044B30 00   
044B31 00 
044B32 00 
044B33 00 
044B33 00   
044B34 00 
044B35 00 
044B36 00 
044B36 00   
044B37 00 
044B38 00 
044B39 00 
044B39 00   
044B3A 00 
044B3B 00 
044B3C 00 
044B3C 00   
044B3D 00 
044B3E 00 
044B3F 00 
044B3F 00   
044B40 00 
044B41 00 
044B42 00 
044B42 00   
044B43 00 
044B44 00 
044B45 00 
044B45 00   
044B46 00 
044B47 00 
044B48 00 
044B48 00   
044B49 00 
044B4A 00 
044B4B 00 
044B4B 00   
044B4C 00 
044B4D 00 
044B4E 00 
044B4E 00   
044B4F 00 
044B50 00 
044B51 00 
044B51 00   
044B52 00 
044B53 00 
044B54 00 
044B54 00   
044B55 00 
044B56 00 
044B57 00 
044B57 00   
044B58 00 
044B59 00 
044B5A 00 
044B5A 00   
044B5B 00 
044B5C 00 
044B5D 00 
044B5D 00   
044B5E 00 
044B5F 00 
044B60 00 
044B60 00   
044B61 00 
044B62 00 
044B63 00 
044B63 00   
044B64 00 
044B65 00 
044B66 00 
044B66 00   
044B67 00 
044B68 00 
044B69 00 
044B69 00   
044B6A 00 
044B6B 00 
044B6C 00 
044B6C 00   
044B6D 00 
044B6E 00 
044B6F 00 
044B6F 00   
044B70 00 
044B71 00 
044B72 00 
044B72 00   
044B73 00 
044B74 00 
044B75 00 
044B75 00   
044B76 00 
044B77 00 
044B78 00 
044B78 00   
044B79 00 
044B7A 00 
044B7B 00 
044B7B 00   
044B7C 00 
044B7D 00 
044B7E 00 
044B7E 00   
044B7F 00 
044B80 00 
044B81 00 
044B81 00   
044B82 00 
044B83 00 
044B84 00 
044B84 00   
044B85 00 
044B86 00 
044B87 00 
044B87 00   
044B88 00 
044B89 00 
044B8A 00 
044B8A 00   
044B8B 00 
044B8C 00 
044B8D 00 
044B8D 00   
044B8E 00 
044B8F 00 
044B90 00 
044B90 00   
044B91 00 
044B92 00 
044B93 00 
044B93 00   
044B94 00 
044B95 00 
044B96 00 
044B96 00   
044B97 00 
044B98 00 
044B99 00 
044B99 00   
044B9A 00 
044B9B 00 
044B9C 00 
044B9C 00   
044B9D 00 
044B9E 00 
044B9F 00 
044B9F 00   
044BA0 00 
044BA1 00 
044BA2 00 
044BA2 00   
044BA3 00 
044BA4 00 
044BA5 00 
044BA5 00   
044BA6 00 
044BA7 00 
044BA8 00 
044BA8 00   
044BA9 00 
044BAA 00 
044BAB 00 
044BAB 00   
044BAC 00 
044BAD 00 
044BAE 00 
044BAE 00   
044BAF 00 
044BB0 00 
044BB1 00 
044BB1 00   
044BB2 00 
044BB3 00 
044BB4 00 
044BB4 00   
044BB5 00 
044BB6 00 
044BB7 00 
044BB7 00   
044BB8 00 
044BB9 00 
044BBA 00 
044BBA 00   
044BBB 00 
044BBC 00 
044BBD 00 
044BBD 00   
044BBE 00 
044BBF 00 
044BC0 00 
044C00 00     11793 STAVAR:         BLKB    27*4,0            ; Static Variables
044C01 00 
044C02 00 
044C03 00 
044C03 00   
044C04 00 
044C05 00 
044C06 00 
044C06 00   
044C07 00 
044C08 00 
044C09 00 
044C09 00   
044C0A 00 
044C0B 00 
044C0C 00 
044C0C 00   
044C0D 00 
044C0E 00 
044C0F 00 
044C0F 00   
044C10 00 
044C11 00 
044C12 00 
044C12 00   
044C13 00 
044C14 00 
044C15 00 
044C15 00   
044C16 00 
044C17 00 
044C18 00 
044C18 00   
044C19 00 
044C1A 00 
044C1B 00 
044C1B 00   
044C1C 00 
044C1D 00 
044C1E 00 
044C1E 00   
044C1F 00 
044C20 00 
044C21 00 
044C21 00   
044C22 00 
044C23 00 
044C24 00 
044C24 00   
044C25 00 
044C26 00 
044C27 00 
044C27 00   
044C28 00 
044C29 00 
044C2A 00 
044C2A 00   
044C2B 00 
044C2C 00 
044C2D 00 
044C2D 00   
044C2E 00 
044C2F 00 
044C30 00 
044C30 00   
044C31 00 
044C32 00 
044C33 00 
044C33 00   
044C34 00 
044C35 00 
044C36 00 
044C36 00   
044C37 00 
044C38 00 
044C39 00 
044C39 00   
044C3A 00 
044C3B 00 
044C3C 00 
044C3C 00   
044C3D 00 
044C3E 00 
044C3F 00 
044C3F 00   
044C40 00 
044C41 00 
044C42 00 
044C42 00   
044C43 00 
044C44 00 
044C45 00 
044C45 00   
044C46 00 
044C47 00 
044C48 00 
044C48 00   
044C49 00 
044C4A 00 
044C4B 00 
044C4B 00   
044C4C 00 
044C4D 00 
044C4E 00 
044C4E 00   
044C4F 00 
044C50 00 
044C51 00 
044C6C 00     11794 DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
044C6D 00 
044C6E 00 
044C6F 00 
044C6F 00   
044C70 00 
044C71 00 
044C72 00 
044C72 00   
044C73 00 
044C74 00 
044C75 00 
044C75 00   
044C76 00 
044C77 00 
044C78 00 
044C78 00   
044C79 00 
044C7A 00 
044C7B 00 
044C7B 00   
044C7C 00 
044C7D 00 
044C7E 00 
044C7E 00   
044C7F 00 
044C80 00 
044C81 00 
044C81 00   
044C82 00 
044C83 00 
044C84 00 
044C84 00   
044C85 00 
044C86 00 
044C87 00 
044C87 00   
044C88 00 
044C89 00 
044C8A 00 
044C8A 00   
044C8B 00 
044C8C 00 
044C8D 00 
044C8D 00   
044C8E 00 
044C8F 00 
044C90 00 
044C90 00   
044C91 00 
044C92 00 
044C93 00 
044C93 00   
044C94 00 
044C95 00 
044C96 00 
044C96 00   
044C97 00 
044C98 00 
044C99 00 
044C99 00   
044C9A 00 
044C9B 00 
044C9C 00 
044C9C 00   
044C9D 00 
044C9E 00 
044C9F 00 
044C9F 00   
044CA0 00 
044CA1 00 
044CA2 00 
044CA2 00   
044CA3 00 
044CA4 00 
044CA5 00 
044CA5 00   
044CA6 00 
044CA7 00 
044CA8 00 
044CA8 00   
044CA9 00 
044CAA 00 
044CAB 00 
044CAB 00   
044CAC 00 
044CAD 00 
044CAE 00 
044CAE 00   
044CAF 00 
044CB0 00 
044CB1 00 
044CB1 00   
044CB2 00 
044CB3 00 
044CB4 00 
044CB4 00   
044CB5 00 
044CB6 00 
044CB7 00 
044CB7 00   
044CB8 00 
044CB9 00 
044CBA 00 
044CBA 00   
044CBB 00 
044CBC 00 
044CBD 00 
044CBD 00   
044CBE 00 
044CBF 00 
044CC0 00 
044CC0 00   
044CC1 00 
044CC2 00 
044CC3 00 
044CC3 00   
044CC4 00 
044CC5 00 
044CC6 00 
044CC6 00   
044CC7 00 
044CC8 00 
044CC9 00 
044CC9 00   
044CCA 00 
044CCB 00 
044CCC 00 
044CCC 00   
044CCD 00 
044CCE 00 
044CCF 00 
044CCF 00   
044CD0 00 
044CD1 00 
044CD2 00 
044CD2 00   
044CD3 00 
044CD4 00 
044CD5 00 
044CD5 00   
044CD6 00 
044CD7 00 
044CD8 00 
044CD8 00   
044CD9 00 
044CDA 00 
044CDB 00 
044CDB 00   
044CDC 00 
044CDD 00 
044CDE 00 
044CDE 00   
044CDF 00 
044CE0 00 
044CE1 00 
044CE1 00   
044CE2 00 
044CE3 00 
044CE4 00 
044CE4 00   
044CE5 00 
044D0E 00     11795 FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D0F 00 
044D10 00 
044D11 00     11796 PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D12 00 
044D13 00 
              11797 ;
044D14 00     11798 PAGE_:          BLKB    3,0               ; Start of User Program
044D15 00 
044D16 00 
044D17 00     11799 TOP:            BLKB    3,0               ; First Location after User Program
044D18 00 
044D19 00 
044D1A 00     11800 LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1B 00 
044D1C 00 
044D1D 00     11801 FREE:           BLKB    3,0               ; First Free Space Byte
044D1E 00 
044D1F 00 
044D20 00     11802 HIMEM:          BLKB    3,0               ; First Protected Byte
044D21 00 
044D22 00 
              11803 ;
044D23 00     11804 LINENO:         BLKB    3,0               ; Line Number
044D24 00 
044D25 00 
044D26 00     11805 TRACEN:         BLKB    3,0               ; Trace Flag
044D27 00 
044D28 00 
044D29 00     11806 AUTONO:         BLKB    3,0               ; Auto Flag
044D2A 00 
044D2B 00 
044D2C 00     11807 ERRTRP:         BLKB    3,0               ; Error Trap
044D2D 00 
044D2E 00 
044D2F 00     11808 ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D30 00 
044D31 00     11809 DATPTR:         BLKB    2,0               ; Data Pointer
044D32 00 
044D33 00     11810 ERL:            BLKB    2,0               ; Error Line
044D34 00 
044D35 00     11811 ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D36 00 
044D37 00 
044D38 00     11812 RANDOM:         BLKB    5,0               ; Random Number
044D39 00 
044D3A 00 
044D3B 00 
044D3B 00   
044D3D 00     11813 COUNT:          BLKB    1,0               ; Print Position
044D3E 00     11814 WIDTH:          BLKB    1,0               ; Print Width
044D3F 00     11815 ERR:            BLKB    1,0               ; Error Number
044D40 00     11816 LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              11817 ; - BIT 0: If set, output a space after the line number
              11818 ; - BIT 1: If set, then indent FOR/NEXT loops
              11819 ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              11820 ; - BIT 3: If set, then output to buffer for *EDIT
              11821 ; OPT FLAG (top nibble)
              11822 ; - BIT 4: If set, then list whilst assembling
              11823 ; - BIT 5: If set, then assembler errors are reported
              11824 ; - BIT 6: If set, then place the code starting at address pointed to by O%
              11825 ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00     11826 INCREM:         BLKB    1,0               ; Auto-Increment Value
              11827 ;
              11828 ; --------------------------------------------------------------------------------------------
              11829 ; BEGIN MODIFIED CODE
              11830 ; --------------------------------------------------------------------------------------------
              11831 ; Originally in equs.inc
              11832 ;
              11833 OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
              11834 PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
              11835 VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              11836 ; --------------------------------------------------------------------------------------------
              11837 ; END MODIFIED CODE
              11838 ; --------------------------------------------------------------------------------------------
              11839 
              11840 ; Extra Agon-implementation specific system variables
              11841 ;
044D42 00     11842 FLAGS:          BLKB    1,0       ; Miscellaneous flags
              11843 ; - BIT 7: Set if ESC pressed
              11844 ; - BIT 6: Set to disable ESC
044D43 00     11845 OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D44 00 
044D45 00     11846 OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              11847 ; - 0: Console
              11848 ; - 1: File
044D46 00     11849 OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00     11850 KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00     11851 KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00     11852 KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00     11853 R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4B 00 
044D4C 00 
044D4D 00     11854 R1:             BLKB    3,0
044D4E 00 
044D4F 00 
              11855 
              11856 ;
              11857 ; This must be at the end
              11858 ;
              11859 RAM_END:
044D50 FF     11860 ALIGN	256
044D51 FF 
044D52 FF 
044D53 FF 
044D53 FF   
044D54 FF 
044D55 FF 
044D56 FF 
044D56 FF   
044D57 FF 
044D58 FF 
044D59 FF 
044D59 FF   
044D5A FF 
044D5B FF 
044D5C FF 
044D5C FF   
044D5D FF 
044D5E FF 
044D5F FF 
044D5F FF   
044D60 FF 
044D61 FF 
044D62 FF 
044D62 FF   
044D63 FF 
044D64 FF 
044D65 FF 
044D65 FF   
044D66 FF 
044D67 FF 
044D68 FF 
044D68 FF   
044D69 FF 
044D6A FF 
044D6B FF 
044D6B FF   
044D6C FF 
044D6D FF 
044D6E FF 
044D6E FF   
044D6F FF 
044D70 FF 
044D71 FF 
044D71 FF   
044D72 FF 
044D73 FF 
044D74 FF 
044D74 FF   
044D75 FF 
044D76 FF 
044D77 FF 
044D77 FF   
044D78 FF 
044D79 FF 
044D7A FF 
044D7A FF   
044D7B FF 
044D7C FF 
044D7D FF 
044D7D FF   
044D7E FF 
044D7F FF 
044D80 FF 
044D80 FF   
044D81 FF 
044D82 FF 
044D83 FF 
044D83 FF   
044D84 FF 
044D85 FF 
044D86 FF 
044D86 FF   
044D87 FF 
044D88 FF 
044D89 FF 
044D89 FF   
044D8A FF 
044D8B FF 
044D8C FF 
044D8C FF   
044D8D FF 
044D8E FF 
044D8F FF 
044D8F FF   
044D90 FF 
044D91 FF 
044D92 FF 
044D92 FF   
044D93 FF 
044D94 FF 
044D95 FF 
044D95 FF   
044D96 FF 
044D97 FF 
044D98 FF 
044D98 FF   
044D99 FF 
044D9A FF 
044D9B FF 
044D9B FF   
044D9C FF 
044D9D FF 
044D9E FF 
044D9E FF   
044D9F FF 
044DA0 FF 
044DA1 FF 
044DA1 FF   
044DA2 FF 
044DA3 FF 
044DA4 FF 
044DA4 FF   
044DA5 FF 
044DA6 FF 
044DA7 FF 
044DA7 FF   
044DA8 FF 
044DA9 FF 
044DAA FF 
044DAA FF   
044DAB FF 
044DAC FF 
044DAD FF 
044DAD FF   
044DAE FF 
044DAF FF 
044DB0 FF 
044DB0 FF   
044DB1 FF 
044DB2 FF 
044DB3 FF 
044DB3 FF   
044DB4 FF 
044DB5 FF 
044DB6 FF 
044DB6 FF   
044DB7 FF 
044DB8 FF 
044DB9 FF 
044DB9 FF   
044DBA FF 
044DBB FF 
044DBC FF 
044DBC FF   
044DBD FF 
044DBE FF 
044DBF FF 
044DBF FF   
044DC0 FF 
044DC1 FF 
044DC2 FF 
044DC2 FF   
044DC3 FF 
044DC4 FF 
044DC5 FF 
044DC5 FF   
044DC6 FF 
044DC7 FF 
044DC8 FF 
044DC8 FF   
044DC9 FF 
044DCA FF 
044DCB FF 
044DCB FF   
044DCC FF 
044DCD FF 
044DCE FF 
044DCE FF   
044DCF FF 
044DD0 FF 
044DD1 FF 
044DD1 FF   
044DD2 FF 
044DD3 FF 
044DD4 FF 
              11861 USER:							; Must be aligned on a page boundary
              11862 ; --- End ram.asm ---
              11863 
