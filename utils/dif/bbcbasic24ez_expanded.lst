        Output     Line 
       
               0001 ; --- Begin mos_api.inc ---
               0002 ;
               0003 ; Title:	AGON MOS - API for user projects
               0004 ; Author:	Dean Belfield
               0005 ; Created:	03/08/2022
               0006 ; Last Updated:	11/11/2023
               0007 ;
               0008 ; Modinfo:
               0009 ; 05/08/2022:	Added mos_feof
               0010 ; 09/08/2022:	Added system variables: cursorX, cursorY
               0011 ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
               0012 ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
               0013 ; 24/09/2022:	Added mos_getError, mos_mkdir
               0014 ; 13/10/2022:	Added mos_oscli
               0015 ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
               0016 ; 04/03/2023:	Added sysvar_scrpixelIndex
               0017 ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
               0018 ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
               0019 ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
               0020 ; 22/03/2023:	The VDP commands are now indexed from 0x80
               0021 ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
               0022 ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
               0023 ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
               0024 ; 19/05/2023:	Added sysvar_scrMode
               0025 ; 05/06/2023:	Added sysvar_rtcEnable
               0026 ; 03/08/2023:	Added mos_setkbvector
               0027 ; 10/08/2023:	Added mos_getkbmap
               0028 ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
               0029 
               0030 ; VDP control (VDU 23, 0, n)
               0031 ;
               0032 vdp_gp:			EQU 	80h
               0033 vdp_keycode:		EQU 	81h
               0034 vdp_cursor:		EQU	82h
               0035 vdp_scrchar:		EQU	83h
               0036 vdp_scrpixel:		EQU	84h
               0037 vdp_audio:		EQU	85h
               0038 vdp_mode:		EQU	86h
               0039 vdp_rtc:		EQU	87h
               0040 vdp_keystate:		EQU	88h
               0041 vdp_logicalcoords:	EQU	C0h
               0042 vdp_terminalmode:	EQU	FFh
               0043 
               0044 ; MOS high level functions
               0045 ;
               0046 mos_getkey:		EQU	00h
               0047 mos_load:		EQU	01h
               0048 mos_save:		EQU	02h
               0049 mos_cd:			EQU	03h
               0050 mos_dir:		EQU	04h
               0051 mos_del:		EQU	05h
               0052 mos_ren:		EQU	06h
               0053 mos_mkdir:		EQU	07h
               0054 mos_sysvars:		EQU	08h
               0055 mos_editline:		EQU	09h
               0056 mos_fopen:		EQU	0Ah
               0057 mos_fclose:		EQU	0Bh
               0058 mos_fgetc:		EQU	0Ch
               0059 mos_fputc:		EQU	0Dh
               0060 mos_feof:		EQU	0Eh
               0061 mos_getError:		EQU	0Fh
               0062 mos_oscli:		EQU	10h
               0063 mos_copy:		EQU	11h
               0064 mos_getrtc:		EQU	12h
               0065 mos_setrtc:		EQU	13h
               0066 mos_setintvector:	EQU	14h
               0067 mos_uopen:		EQU	15h
               0068 mos_uclose:		EQU	16h
               0069 mos_ugetc:		EQU	17h
               0070 mos_uputc:		EQU 	18h
               0071 mos_getfil:		EQU	19h
               0072 mos_fread:		EQU	1Ah
               0073 mos_fwrite:		EQU	1Bh
               0074 mos_flseek:		EQU	1Ch
               0075 mos_setkbvector:	EQU	1Dh
               0076 mos_getkbmap:		EQU	1Eh
               0077 mos_i2c_open:		EQU	1Fh
               0078 mos_i2c_close:		EQU	20h
               0079 mos_i2c_write:		EQU	21h
               0080 mos_i2c_read:		EQU	22h
               0081 
               0082 
               0083 ; FatFS file access functions
               0084 ;
               0085 ffs_fopen:		EQU	80h
               0086 ffs_fclose:		EQU	81h
               0087 ffs_fread:		EQU	82h
               0088 ffs_fwrite:		EQU	83h
               0089 ffs_flseek:		EQU	84h
               0090 ffs_ftruncate:		EQU	85h
               0091 ffs_fsync:		EQU	86h
               0092 ffs_fforward:		EQU	87h
               0093 ffs_fexpand:		EQU	88h
               0094 ffs_fgets:		EQU	89h
               0095 ffs_fputc:		EQU	8Ah
               0096 ffs_fputs:		EQU	8Bh
               0097 ffs_fprintf:		EQU	8Ch
               0098 ffs_ftell:		EQU	8Dh
               0099 ffs_feof:		EQU	8Eh
               0100 ffs_fsize:		EQU	8Fh
               0101 ffs_ferror:		EQU	90h
               0102 
               0103 ; FatFS directory access functions
               0104 ;
               0105 ffs_dopen:		EQU	91h
               0106 ffs_dclose:		EQU	92h
               0107 ffs_dread:		EQU	93h
               0108 ffs_dfindfirst:		EQU	94h
               0109 ffs_dfindnext:		EQU	95h
               0110 
               0111 ; FatFS file and directory management functions
               0112 ;
               0113 ffs_stat:		EQU	96h
               0114 ffs_unlink:		EQU	97h
               0115 ffs_rename:		EQU	98h
               0116 ffs_chmod:		EQU	99h
               0117 ffs_utime:		EQU	9Ah
               0118 ffs_mkdir:		EQU	9Bh
               0119 ffs_chdir:		EQU	9Ch
               0120 ffs_chdrive:		EQU	9Dh
               0121 ffs_getcwd:		EQU	9Eh
               0122 
               0123 ; FatFS volume management and system configuration functions
               0124 ;
               0125 ffs_mount:		EQU	9Fh
               0126 ffs_mkfs:		EQU	A0h
               0127 ffs_fdisk:		EQU	A1h
               0128 ffs_getfree:		EQU	A2h
               0129 ffs_getlabel:		EQU	A3h
               0130 ffs_setlabel:		EQU	A4h
               0131 ffs_setcp:		EQU	A5h
               0132 
               0133 ; File access modes
               0134 ;
               0135 fa_read:		EQU	01h
               0136 fa_write:		EQU	02h
               0137 fa_open_existing:	EQU	00h
               0138 fa_create_new:		EQU	04h
               0139 fa_create_always:	EQU	08h
               0140 fa_open_always:		EQU	10h
               0141 fa_open_append:		EQU	30h
               0142 
               0143 ; System variable indexes for api_sysvars
               0144 ; Index into _sysvars in globals.asm
               0145 ;
               0146 sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
               0147 sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
               0148 sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
               0149 sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
               0150 sysvar_cursorX:		EQU	07h	; 1: Cursor X position
               0151 sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
               0152 sysvar_scrchar:		EQU	09h	; 1: Character read from screen
               0153 sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
               0154 sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
               0155 sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
               0156 sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
               0157 sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
               0158 sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
               0159 sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
               0160 sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
               0161 sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
               0162 sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
               0163 sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
               0164 sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
               0165 sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
               0166 sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
               0167 sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
               0168 sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
               0169 sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
               0170 sysvar_scrMode:		EQU	27h	; 1: Screen mode
               0171 sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
               0172 sysvar_mouseX:		EQU	29h	; 2: Mouse X position
               0173 sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
               0174 sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
               0175 sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
               0176 sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
               0177 sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
               0178 
               0179 ; Flags for the VPD protocol
               0180 ;
               0181 vdp_pflag_cursor:	EQU	00000001b
               0182 vdp_pflag_scrchar:	EQU	00000010b
               0183 vdp_pflag_point:	EQU	00000100b
               0184 vdp_pflag_audio:	EQU	00001000b
               0185 vdp_pflag_mode:		EQU	00010000b
               0186 vdp_pflag_rtc:		EQU	00100000b
               0187 vdp_pflag_mouse:	EQU	01000000b
               0188 ; vdp_pflag_buffered:	EQU	10000000b
               0189 
               0190 ;
               0191 ; FatFS structures
               0192 ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
               0193 ;
               0194 ; Object ID and allocation information (FFOBJID)
               0195 ;
               0196 ; FFOBJID	.STRUCT
               0197 ; 	fs:		DS	3	; Pointer to the hosting volume of this object
               0198 ; 	id:		DS	2	; Hosting volume mount ID
               0199 ; 	attr:		DS	1	; Object attribute
               0200 ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
               0201 ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
               0202 ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
               0203 ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
               0204 ; ;
               0205 ; ; File object structure (FIL)
               0206 ; ;
               0207 ; FIL .STRUCT
               0208 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0209 ; 	flag:		DS	1	; File status flags
               0210 ; 	err:		DS	1	; Abort flag (error code)
               0211 ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
               0212 ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
               0213 ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
               0214 ; 	dir_sect:	DS	4	; Sector number containing the directory entry
               0215 ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
               0216 ; FIL_SIZE .ENDSTRUCT FIL
               0217 ; ;
               0218 ; ; Directory object structure (DIR)
               0219 ; ;
               0220 ; DIR .STRUCT
               0221 ; 	obj:		.TAG	FFOBJID	; Object identifier
               0222 ; 	dptr:		DS	4	; Current read/write offset
               0223 ; 	clust:		DS	4	; Current cluster
               0224 ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
               0225 ; 	dir:		DS	3	; Pointer to the directory item in the win[]
               0226 ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
               0227 ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
               0228 ; DIR_SIZE .ENDSTRUCT DIR
               0229 ; ;
               0230 ; ; File information structure (FILINFO)
               0231 ; ;
               0232 ; FILINFO .STRUCT
               0233 ; 	fsize:		DS 	4	; File size
               0234 ; 	fdate:		DS	2	; Modified date
               0235 ; 	ftime:		DS	2	; Modified time
               0236 ; 	fattrib:	DS	1	; File attribute
               0237 ; 	altname:	DS	13	; Alternative file name
               0238 ; 	fname:		DS	256	; Primary file name
               0239 ; FILINFO_SIZE .ENDSTRUCT FILINFO
               0240 
               0241 ; FFOBJID offsets
               0242 FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
               0243 FFOBJID.id:       EQU 3    ; Hosting volume mount ID
               0244 FFOBJID.attr:     EQU 5    ; Object attribute
               0245 FFOBJID.stat:     EQU 6    ; Object chain status
               0246 FFOBJID.sclust:   EQU 7    ; Object data start cluster
               0247 FFOBJID.objsize:  EQU 11   ; Object size
               0248 FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
               0249 
               0250 ; FIL offsets (including FFOBJID fields)
               0251 FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0252 FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
               0253 FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
               0254 FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
               0255 FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
               0256 FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
               0257 FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
               0258 FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
               0259 FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
               0260 
               0261 ; DIR offsets (including FFOBJID fields)
               0262 DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
               0263 DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
               0264 DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
               0265 DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
               0266 DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
               0267 DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
               0268 DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
               0269 DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
               0270 
               0271 ; FILINFO offsets
               0272 FILINFO.fsize:    EQU 0    ; File size
               0273 FILINFO.fdate:    EQU 4    ; Modified date
               0274 FILINFO.ftime:    EQU 6    ; Modified time
               0275 FILINFO.fattrib:  EQU 8    ; File attribute
               0276 FILINFO.altname:  EQU 9    ; Alternative file name
               0277 FILINFO.fname:    EQU 22   ; Primary file name
               0278 FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
               0279 
               0280 ;
               0281 ; Macro for calling the API
               0282 ; Parameters:
               0283 ; - function: One of the function numbers listed above
               0284 ;
               0285 MACRO MOSCALL	function
               0286 LD	A, function
               0287 RST.LIS	08h
               0288 ENDMACRO 	; --- End mos_api.inc ---
               0289 
               0290 ; --- Begin macros.inc ---
               0291 ; Title:	BBC Basic Interpreter - Z80 version
               0292 ;		Useful macros
               0293 ; Author:	Dean Belfield
               0294 ; Created:	12/05/2023
               0295 ; Last Updated:	11/06/2023
               0296 ;
               0297 ; Modinfo:
               0298 ; 11/06/2023:	Modified to run in ADL mode
               0299 ; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
               0300 
               0301 MACRO EXREG	rp1, rp2
               0302 PUSH	rp1
               0303 POP	rp2
               0304 ENDMACRO
               0305 
               0306 ; MACRO ADD8U_DE	reg
               0307 MACRO ADD8U_DE
               0308 ADD	A, E
               0309 LD	E, A
               0310 ADC	A, D
               0311 SUB	E
               0312 LD	D, A
               0313 ENDMACRO
               0314 
               0315 ; MACRO ADD8U_HL	reg
               0316 MACRO ADD8U_HL
               0317 ADD	A, L
               0318 LD	L, A
               0319 ADC	A, H
               0320 SUB	L
               0321 LD	H, A
               0322 ENDMACRO
               0323 
               0324 MACRO VDU	val
               0325 LD	A, val
               0326 CALL	OSWRCH
               0327 ENDMACRO
               0328 
               0329 MACRO SET_GPIO	reg, val
               0330 IN0	A, (reg)
               0331 OR	val
               0332 OUT0	(reg), A
               0333 ENDMACRO
               0334 
               0335 MACRO RES_GPIO	reg, val
               0336 PUSH	BC
               0337 LD	A, val
               0338 CPL
               0339 LD	C, A
               0340 IN0	A, (reg)
               0341 AND	C
               0342 OUT0	(reg), A
               0343 POP	BC
               0344 ENDMACRO
               0345 ; --- End macros.inc ---
               0346 
               0347 ; --- Begin equs.inc ---
               0348 ;
               0349 ; Title:	BBC Basic for AGON - Equs
               0350 ; Author:	Dean Belfield
               0351 ; Created:	12/05/2023
               0352 ; Last Updated:	08/06/2023
               0353 ;
               0354 ; Modinfo:
               0355 ; 08/06/2023:	Added SIZEW
               0356 
               0357 ; XREF		STAVAR
               0358 ; XREF		ACCS
               0359 
               0360 RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
               0361 ;Stack_Top:		EQU		0000h	; Stack at top
               0362 SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
               0363 
               0364 ; For GPIO
               0365 ; PA not available on eZ80L92
               0366 ;
               0367 PA_DR:			EQU		96h
               0368 PA_DDR:			EQU		97h
               0369 PA_ALT1:		EQU		98h
               0370 PA_ALT2:		EQU		99h
               0371 PB_DR:          	EQU		9Ah
               0372 PB_DDR:        	 	EQU		9Bh
               0373 PB_ALT1:        	EQU		9Ch
               0374 PB_ALT2:        	EQU		9Dh
               0375 PC_DR:          	EQU		9Eh
               0376 PC_DDR:         	EQU		9Fh
               0377 PC_ALT1:        	EQU		A0h
               0378 PC_ALT2:        	EQU		A1h
               0379 PD_DR:          	EQU		A2h
               0380 PD_DDR:			EQU		A3h
               0381 PD_ALT1:		EQU		A4h
               0382 PD_ALT2:		EQU		A5h
               0383 
               0384 GPIOMODE_OUT:		EQU		0	; Output
               0385 GPIOMODE_IN:		EQU		1	; Input
               0386 GPIOMODE_DIO:		EQU		2	; Open Drain IO
               0387 GPIOMODE_SIO:		EQU		3	; Open Source IO
               0388 GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
               0389 GPIOMODE_ALTF:		EQU		5;	; Alt Function
               0390 GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
               0391 GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
               0392 GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
               0393 GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
               0394 
               0395 ; ; Originally in ram.asm
               0396 ; ;
               0397 ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
               0398 ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
               0399 ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
               0400 
               0401 ; Originally in main.asm
               0402 ;
               0403 CR:			EQU     0DH
               0404 LF:			EQU     0AH
               0405 ESC:			EQU     1BH
               0406 ; --- End equs.inc ---
               0407 
               0408 ; --- Begin init.asm ---
               0409 ;
               0410 ; Title:	BBC Basic ADL for AGON - Initialisation Code
               0411 ;		Initialisation Code
               0412 ; Author:	Dean Belfield
               0413 ; Created:	12/05/2023
               0414 ; Last Updated:	26/11/2023
               0415 ;
               0416 ; Modinfo:
               0417 ; 11/07/2023:	Fixed *BYE for ADL mode
               0418 ; 26/11/2023:	Moved the ram clear routine into here
               0419 
               0420 ; SEGMENT CODE
               0421 
               0422 ; XDEF	_end
               0423 
               0424 ; XREF	_main				; In main.asm
               0425 
               0426 ; XREF	RAM_START			; In ram.asm
               0427 ; XREF	RAM_END
               0428 
               0429 ; .ASSUME	ADL = 1
               0430 
               0431 ; INCLUDE	"equs.inc"
               0432 
               0433 argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
               0434 
               0435 ;
               0436 ; Start in ADL mode
               0437 ;
040000 C3      0438 JP	_start				; Jump to start
040001 45 
040002 00 
040003 04 
               0439 ;
               0440 ; The header stuff is from byte 64 onwards
               0441 ;
040004 42      0442 _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
040005 42 
040006 43 
040007 42 
040007 41   
040008 53 
040009 49 
04000A 43 
04000A 2E   
04000B 42 
04000C 49 
04000D 4E 
04000D 00   
               0443 
040011 FF      0444 ALIGN	64
040012 FF 
040013 FF 
040014 FF 
040014 FF   
040015 FF 
040016 FF 
040017 FF 
040017 FF   
040018 FF 
040019 FF 
04001A FF 
04001A FF   
04001B FF 
04001C FF 
04001D FF 
04001D FF   
04001E FF 
04001F FF 
040020 FF 
040020 FF   
040021 FF 
040022 FF 
040023 FF 
040023 FF   
040024 FF 
040025 FF 
040026 FF 
040026 FF   
040027 FF 
040028 FF 
040029 FF 
040029 FF   
04002A FF 
04002B FF 
04002C FF 
04002C FF   
04002D FF 
04002E FF 
04002F FF 
04002F FF   
040030 FF 
040031 FF 
040032 FF 
040032 FF   
040033 FF 
040034 FF 
               0445 
040040 4D      0446 DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040041 4F 
040042 53 
040043 00      0447 DB	00h				; MOS header version 0
040044 01      0448 DB	01h				; Flag for run mode (0: Z80, 1: ADL)
               0449 ;
               0450 ; And the code follows on immediately after the header
               0451 ;
040045 F5      0452 _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5      0453 PUSH		BC
040047 D5      0454 PUSH		DE
040048 DD      0455 PUSH		IX
040049 E5 
04004A FD      0456 PUSH		IY
04004B E5 
               0457 
04004C ED      0458 LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
04004D 73 
04004E D7 
04004F 00 
04004F 04   
               0459 
040051 DD      0460 LD		IX, _argv_ptrs		; The argv array pointer address
040052 21 
040053 DA 
040054 00 
040054 04   
040056 DD      0461 PUSH		IX
040057 E5 
040058 CD      0462 CALL		_parse_params		; Parse the parameters
040059 88 
04005A 00 
04005B 04 
04005C DD      0463 POP		IX			; IX: argv
04005D E1 
04005E 06      0464 LD		B, 0			;  C: argc
04005F 00 
040060 CD      0465 CALL		_clear_ram
040061 75 
040062 00 
040063 04 
040064 C3      0466 JP		_main			; Start user code
040065 EE 
040066 2F 
040067 04 
               0467 ;
               0468 ; This bit of code is called from STAR_BYE and returns us safely to MOS
               0469 ;
040068 ED      0470 _end:			LD		SP, (_sps)		; Restore the stack pointer
040069 7B 
04006A D7 
04006B 00 
04006B 04   
               0471 
04006D FD      0472 POP		IY			; Restore the registers
04006E E1 
04006F DD      0473 POP		IX
040070 E1 
040071 D1      0474 POP		DE
040072 C1      0475 POP		BC
040073 F1      0476 POP		AF
040074 C9      0477 RET					; Return to MOS
               0478 
               0479 ;Clear the application memory
               0480 ;
040075 C5      0481 _clear_ram:		PUSH		BC
040076 21      0482 LD		HL, RAM_START
040077 00 
040078 4A 
040079 04 
04007A 11      0483 LD		DE, RAM_START + 1
04007B 01 
04007C 4A 
04007D 04 
04007E 01      0484 LD		BC, RAM_END - RAM_START - 1
04007F 4F 
040080 03 
040081 00 
040082 AF      0485 XOR		A
040083 77      0486 LD		(HL), A
040084 ED      0487 LDIR
040085 B0 
040086 C1      0488 POP		BC
040087 C9      0489 RET
               0490 
               0491 ; Parse the parameter string into a C array
               0492 ; Parameters
               0493 ; - HL: Address of parameter string
               0494 ; - IX: Address for array pointer storage
               0495 ; Returns:
               0496 ; -  C: Number of parameters parsed
               0497 ;
040088 01      0498 _parse_params:		LD	BC, _exec_name
040089 04 
04008A 00 
04008B 04 
04008C DD      0499 LD	(IX+0), BC		; ARGV[0] = the executable name
04008D 0F 
04008E 00 
04008F DD      0500 INC	IX
040090 23 
040091 DD      0501 INC	IX
040092 23 
040093 DD      0502 INC	IX
040094 23 
040095 CD      0503 CALL	_skip_spaces		; Skip HL past any leading spaces
040096 D0 
040097 00 
040098 04 
               0504 ;
040099 01      0505 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009A 01 
04009B 00 
04009C 00 
04009D 06      0506 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009E 0F 
               0507 ;
               0508 _parse_params_1:
04009F C5      0509 PUSH	BC			; Stack ARGC
0400A0 E5      0510 PUSH	HL			; Stack start address of token
0400A1 CD      0511 CALL	_get_token		; Get the next token
0400A2 C1 
0400A3 00 
0400A4 04 
0400A5 79      0512 LD	A, C			; A: Length of the token in characters
0400A6 D1      0513 POP	DE			; Start address of token (was in HL)
0400A7 C1      0514 POP	BC			; ARGC
0400A8 B7      0515 OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8      0516 RET	Z
               0517 ;
0400AA DD      0518 LD	(IX+0), DE		; Store the pointer to the token
0400AB 1F 
0400AC 00 
0400AD E5      0519 PUSH	HL			; DE=HL
0400AE D1      0520 POP	DE
0400AF CD      0521 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B0 D0 
0400B1 00 
0400B2 04 
0400B3 AF      0522 XOR	A
0400B4 12      0523 LD	(DE), A			; Zero-terminate the token
0400B5 DD      0524 INC	IX
0400B6 23 
0400B7 DD      0525 INC	IX
0400B8 23 
0400B9 DD      0526 INC	IX			; Advance to next pointer position
0400BA 23 
0400BB 0C      0527 INC	C			; Increment ARGC
0400BC 79      0528 LD	A, C			; Check for C >= A
0400BD B8      0529 CP	B
0400BE 38      0530 JR	C, _parse_params_1	; And loop
0400BF DF 
0400C0 C9      0531 RET
               0532 
               0533 ; Get the next token
               0534 ; Parameters:
               0535 ; - HL: Address of parameter string
               0536 ; Returns:
               0537 ; - HL: Address of first character after token
               0538 ; -  C: Length of token (in characters)
               0539 ;
0400C1 0E      0540 _get_token:		LD	C, 0			; Initialise length
0400C2 00 
0400C3 7E      0541 @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7      0542 OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8      0543 RET 	Z
0400C6 FE      0544 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C7 0D 
0400C8 C8      0545 RET	Z
0400C9 FE      0546 CP	' '			; Exit if space (end of token)
0400CA 20 
0400CB C8      0547 RET	Z
0400CC 23      0548 INC	HL			; Advance to next character
0400CD 0C      0549 INC 	C			; Increment length
0400CE 18      0550 JR	@B
0400CF F3 
               0551 
               0552 ; Skip spaces in the parameter string
               0553 ; Parameters:
               0554 ; - HL: Address of parameter string
               0555 ; Returns:
               0556 ; - HL: Address of next none-space character
               0557 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0558 ;
0400D0 7E      0559 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE      0560 CP	' '			; Exit if not space
0400D2 20 
0400D3 C0      0561 RET	NZ
0400D4 23      0562 INC	HL			; Advance to next character
0400D5 18      0563 JR	_skip_spaces		; Increment length
0400D6 F9 
               0564 
               0565 ; Storage
               0566 ;
               0567 _sps:			DS	3			; Storage for the stack pointer
0400DA 00      0568 _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
0400DB 00 
0400DC 00 
0400DD 00 
0400DD 00   
0400DE 00 
0400DF 00 
0400E0 00 
0400E0 00   
0400E1 00 
0400E2 00 
0400E3 00 
0400E3 00   
0400E4 00 
0400E5 00 
0400E6 00 
0400E6 00   
0400E7 00 
0400E8 00 
0400E9 00 
0400E9 00   
0400EA 00 
0400EB 00 
0400EC 00 
0400EC 00   
0400ED 00 
0400EE 00 
0400EF 00 
0400EF 00   
0400F0 00 
0400F1 00 
0400F2 00 
0400F2 00   
0400F3 00 
0400F4 00 
0400F5 00 
0400F5 00   
0400F6 00 
0400F7 00 
0400F8 00 
0400F8 00   
0400F9 00 
0400FA 00 
0400FB 00 
0400FB 00   
0400FC 00 
0400FD 00 
0400FE 00 
               0569 
               0570 ; --- Begin eval.asm ---
               0571 ;
               0572 ; Title:	BBC Basic Interpreter - Z80 version
               0573 ;		Expression Evaluation & Arithmetic Module - "EVAL"
               0574 ; Author:	(C) Copyright  R.T.Russell  1984
               0575 ; Modified By:	Dean Belfield
               0576 ; Created:	12/05/2023
               0577 ; Last Updated:	17/08/2023
               0578 ;
               0579 ; Modinfo:
               0580 ; 07/06/2023:	Modified to run in ADL mode
               0581 ; 26/06/2023:	Fixed HEX and HEXSTR
               0582 ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
               0583 ; 17/08/2023:	Added binary constants
               0584 
               0585 ; .ASSUME	ADL = 1
               0586 
               0587 ; INCLUDE	"equs.inc"
               0588 ; INCLUDE "macros.inc"
               0589 ; INCLUDE "mos_api.inc"	; In MOS/src
               0590 
               0591 ; SEGMENT CODE
               0592 
               0593 ; XDEF	EXPR
               0594 ; XDEF	EXPRN
               0595 ; XDEF	EXPRI
               0596 ; XDEF	EXPRS
               0597 ; XDEF	ITEMI
               0598 ; XDEF	LOADN
               0599 ; XDEF	LOAD4
               0600 ; XDEF	CONS
               0601 ; XDEF	LOADS
               0602 ; XDEF	SFIX
               0603 ; XDEF	VAL0
               0604 ; XDEF	SEARCH
               0605 ; XDEF	SWAP
               0606 ; XDEF	TEST
               0607 ; XDEF	DECODE
               0608 ; XDEF	HEXSTR
               0609 ; XDEF	STR
               0610 ; XDEF	ZERO
               0611 ; XDEF	PUSHS
               0612 ; XDEF	POPS
               0613 ; XDEF	COMMA
               0614 ; XDEF	BRAKET
               0615 ; XDEF	NXT
               0616 ; XDEF	COUNT0
               0617 
               0618 ; XREF	ADVAL
               0619 ; XREF	FN_EX
               0620 ; XREF	POINT
               0621 ; XREF	USR
               0622 ; XREF	SYNTAX
               0623 ; XREF	ERROR_
               0624 ; XREF	CHECK
               0625 ; XREF	GETVAR
               0626 ; XREF	LISTON
               0627 ; XREF	RANGE
               0628 ; XREF	FPP
               0629 ; XREF	GETCSR
               0630 ; XREF	CHANEL
               0631 ; XREF	OSSTAT
               0632 ; XREF	OSBGET
               0633 ; XREF	LOMEM
               0634 ; XREF	HIMEM
               0635 ; XREF	PAGE_
               0636 ; XREF	TOP
               0637 ; XREF	ERL
               0638 ; XREF	ERR
               0639 ; XREF	COUNT
               0640 ; XREF	OSOPEN
               0641 ; XREF	GETEXT
               0642 ; XREF	GETPTR
               0643 ; XREF	GETIME
               0644 ; XREF	GETIMS
               0645 ; XREF	LEXAN2
               0646 ; XREF	RANDOM
               0647 ; XREF	STORE5
               0648 ; XREF	GETSCHR
               0649 ; XREF	OSRDCH
               0650 ; XREF	OSKEY
               0651 ; XREF	INKEY1
               0652 ; XREF	EXTERR
               0653 ;
               0654 ; BINARY FLOATING POINT REPRESENTATION:
               0655 ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               0656 ;     8 BIT EXCESS-128 SIGNED EXPONENT
               0657 ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               0658 ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               0659 ;
               0660 ; BINARY INTEGER REPRESENTATION:
               0661 ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               0662 ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
               0663 ;
               0664 ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               0665 ;                             EXPONENT - C
               0666 ;
               0667 
               0668 ;
               0669 ; Table of addresses for functions
               0670 ;
               0671 FUNTOK:			EQU	8DH			; First token number
               0672 ;
04010A EB      0673 FUNTBL:			DW24	DECODE			; Line number
04010B 08 
04010C 04 
04010D 99      0674 DW24	OPENIN			; OPENIN
04010E 05 
04010F 04 
040110 BB      0675 DW24	PTR_EV			; PTR
040111 05 
040112 04 
040113 55      0676 DW24	PAGEV			; PAGE
040114 05 
040115 04 
040116 C5      0677 DW24	TIMEV			; TIME
040117 05 
040118 04 
040119 41      0678 DW24	LOMEMV			; LOMEM
04011A 05 
04011B 04 
04011C 4B      0679 DW24	HIMEMV			; HIMEM
04011D 05 
04011E 04 
04011F 19      0680 DW24	ABSV			; ABS
040120 06 
040121 04 
040122 55      0681 DW24	ACS			; ACS
040123 06 
040124 04 
040125 84      0682 DW24	ADVAL			; ADVAL
040126 49 
040127 04 
040128 2A      0683 DW24	ASC			; ASC
040129 05 
04012A 04 
04012B 4D      0684 DW24	ASN			; ASN
04012C 06 
04012D 04 
04012E 51      0685 DW24	ATN			; ATN
04012F 06 
040130 04 
040131 F3      0686 DW24	BGET			; BGET
040132 04 
040133 04 
040134 39      0687 DW24	COS			; COS
040135 06 
040136 04 
040137 80      0688 DW24	COUNTV			; COUNT
040138 05 
040139 04 
04013A 21      0689 DW24	DEG			; DEG
04013B 06 
04013C 04 
04013D 74      0690 DW24	ERLV			; ERL
04013E 05 
04013F 04 
040140 7A      0691 DW24	ERRV			; ERR
040141 05 
040142 04 
040143 7E      0692 DW24	EVAL_			; EVAL
040144 06 
040145 04 
040146 41      0693 DW24	EXP			; EXP
040147 06 
040148 04 
040149 B1      0694 DW24	EXT			; EXT
04014A 05 
04014B 04 
04014C 98      0695 DW24	ZERO			; FALSE
04014D 09 
04014E 04 
04014F 87      0696 DW24	FN_EX			; FN
040150 10 
040151 04 
040152 11      0697 DW24	GET			; GET
040153 05 
040154 04 
040155 00      0698 DW24	INKEY			; INKEY
040156 05 
040157 04 
040158 30      0699 DW24	INSTR			; INSTR(
040159 07 
04015A 04 
04015B 2D      0700 DW24	INT_			; INT
04015C 06 
04015D 04 
04015E 3A      0701 DW24	LEN			; LEN
04015F 05 
040160 04 
040161 45      0702 DW24	LN			; LN
040162 06 
040163 04 
040164 49      0703 DW24	LOG			; LOG
040165 06 
040166 04 
040167 1D      0704 DW24	NOTK			; NOT
040168 06 
040169 04 
04016A 95      0705 DW24	OPENUP			; OPENUP
04016B 05 
04016C 04 
04016D 92      0706 DW24	OPENOT			; OPENOUT
04016E 05 
04016F 04 
040170 15      0707 DW24	PI			; PI
040171 06 
040172 04 
040173 A7      0708 DW24	POINT			; POINT(
040174 44 
040175 04 
040176 D2      0709 DW24	POS			; POS
040177 04 
040178 04 
040179 25      0710 DW24	RAD			; RAD
04017A 06 
04017B 04 
04017C B2      0711 DW24	RND			; RND
04017D 06 
04017E 04 
04017F 29      0712 DW24	SGN			; SGN
040180 06 
040181 04 
040182 3D      0713 DW24	SIN			; SIN
040183 06 
040184 04 
040185 31      0714 DW24	SQR			; SQR
040186 06 
040187 04 
040188 35      0715 DW24	TAN			; TAN
040189 06 
04018A 04 
04018B 5F      0716 DW24	TOPV			; TO(P)
04018C 05 
04018D 04 
04018E 0A      0717 DW24	TRUE			; TRUE
04018F 06 
040190 04 
040191 54      0718 DW24	USR			; USR
040192 15 
040193 04 
040194 6F      0719 DW24	VAL			; VAL
040195 06 
040196 04 
040197 DB      0720 DW24	VPOS			; VPOS
040198 04 
040199 04 
04019A C4      0721 DW24	CHRS			; CHRS
04019B 07 
04019C 04 
04019D CC      0722 DW24	GETS			; GETS
04019E 07 
04019F 04 
0401A0 DD      0723 DW24	INKEYS			; INKEYS
0401A1 07 
0401A2 04 
0401A3 62      0724 DW24	LEFTS			; LEFTS(
0401A4 08 
0401A5 04 
0401A6 2A      0725 DW24	MIDS			; MIDS(
0401A7 08 
0401A8 04 
0401A9 82      0726 DW24	RIGHTS			; RIGHTS(
0401AA 08 
0401AB 04 
0401AC 4F      0727 DW24	STRS			; STR$
0401AD 09 
0401AE 04 
0401AF A3      0728 DW24	STRING_			; STRINGS(
0401B0 08 
0401B1 04 
0401B2 E3      0729 DW24	EOF			; EOF
0401B3 04 
0401B4 04 
               0730 ;
               0731 FUNTBL_END:		EQU	$
               0732 ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
               0733 TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
               0734 
               0735 ANDK:			EQU     80H
               0736 DIVK:			EQU     81H
               0737 EORK:			EQU     82H
               0738 MODK:			EQU     83H
               0739 ORK:			EQU     84H
               0740 ;
0401B5 F5      0741 SOPTBL:			DW24	SLE			; <= (STRING)
0401B6 05 
0401B7 04 
0401B8 FE      0742 DW24	SNE			; <>
0401B9 05 
0401BA 04 
0401BB EE      0743 DW24	SGE			; >=
0401BC 05 
0401BD 04 
0401BE DF      0744 DW24	SLT			; <
0401BF 05 
0401C0 04 
0401C1 05      0745 DW24	SEQ			; =
0401C2 06 
0401C3 04 
0401C4 E6      0746 DW24	SGT			; >
0401C5 05 
0401C6 04 
               0747 ;
               0748 ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
               0749 ;     Expression type is returned in A'F':
               0750 ;        Numeric - A' bit 7=0, F' sign bit cleared.
               0751 ;         String - A' bit 7=1, F' sign bit set.
               0752 ; Floating-point or integer result returned in HLH'L'C
               0753 ; Integer result denoted by C=0 and HLH'L' non-zero.
               0754 ; String result returned in string accumulator, DE set.
               0755 ;
               0756 ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
               0757 ;               (2) ^
               0758 ;               (3) * / MOD DIV
               0759 ;               (4) + -
               0760 ;               (5) = <> <= >= > <
               0761 ;               (6) AND
               0762 ;               (7) EOR OR
               0763 
               0764 ;
               0765 ; Level 7: EOR and OR
               0766 ;
0401C7 CD      0767 EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401C8 E0 
0401C9 01 
0401CA 04 
0401CB FE      0768 EXPR0A:			CP      EORK            	; Is operator EOR?
0401CC 82 
0401CD 28      0769 JR      Z,EXPR0B		; Yes, so skip to next bit
0401CE 03 
0401CF FE      0770 CP      ORK			; Is operator OR
0401D0 84 
0401D1 C0      0771 RET     NZ			; No, so return
               0772 ;
0401D2 CD      0773 EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D3 46 
0401D4 0A 
0401D5 04 
0401D6 CD      0774 CALL    EXPR1           	; Get second operand
0401D7 E0 
0401D8 01 
0401D9 04 
0401DA CD      0775 CALL    DOIT            	; Do the operation
0401DB 55 
0401DC 0A 
0401DD 04 
0401DE 18      0776 JR      EXPR0A          	; And continue
0401DF EB 
               0777 ;
               0778 ; Level 6: AND
               0779 ;
0401E0 CD      0780 EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E1 F5 
0401E2 01 
0401E3 04 
0401E4 FE      0781 EXPR1A:			CP      ANDK			; Is operator AND?
0401E5 80 
0401E6 C0      0782 RET     NZ			; No, so return
0401E7 CD      0783 CALL    SAVE_EV			; Save first operand
0401E8 46 
0401E9 0A 
0401EA 04 
0401EB CD      0784 CALL    EXPR2			; Get second operand
0401EC F5 
0401ED 01 
0401EE 04 
0401EF CD      0785 CALL    DOIT			; Do the operation
0401F0 55 
0401F1 0A 
0401F2 04 
0401F3 18      0786 JR      EXPR1A			; And continue
0401F4 EF 
               0787 ;
               0788 ; Level 5: Comparisons
               0789 ;
0401F5 CD      0790 EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F6 67 
0401F7 02 
0401F8 04 
0401F9 CD      0791 CALL    RELOP?			; Is it ">", "=" or "<"?
0401FA 1D 
0401FB 0A 
0401FC 04 
0401FD C0      0792 RET     NZ			; No, so return
0401FE 47      0793 LD      B,A			; Store the first operator in B
0401FF FD      0794 INC     IY              	; Bump over operator
040200 23 
040201 CD      0795 CALL    NXT			;
040202 78 
040203 0A 
040204 04 
040205 CD      0796 CALL    RELOP?          	; Is it a compound operator?
040206 1D 
040207 0A 
040208 04 
040209 20      0797 JR      NZ,EXPR2B		; No, so skip next bit
04020A 09 
04020B FD      0798 INC     IY			; Bump over operator
04020C 23 
04020D B8      0799 CP      B			; Compare with first
04020E CA      0800 JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
04020F 9F 
040210 0C 
040211 04 
040212 80      0801 ADD     A,B
040213 47      0802 LD      B,A			; B: Unique code for the compound operator
040214 78      0803 EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08      0804 EX      AF,AF'
040216 FA      0805 JP      M,EXPR2S		; If it is a string, then branch here to handle it
040217 30 
040218 02 
040219 04 
04021A 08      0806 EX      AF,AF'
04021B D6      0807 SUB     4
04021C 04 
04021D FE      0808 CP      '>'-4
04021E 3A 
04021F 20      0809 JR      NZ,EXPR2C
040220 02 
040221 C6      0810 ADD     A,2
040222 02 
040223 CD      0811 EXPR2C:			CALL    SAVE1
040224 48 
040225 0A 
040226 04 
040227 CD      0812 CALL    EXPR3
040228 67 
040229 02 
04022A 04 
04022B CD      0813 CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022C 55 
04022D 0A 
04022E 04 
04022F C9      0814 RET
               0815 ;
040230 08      0816 EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D      0817 DEC     A
040232 E6      0818 AND     7
040233 07 
040234 CD      0819 CALL    PUSHS           	; Save string on the stack
040235 B9 
040236 09 
040237 04 
040238 F5      0820 PUSH    AF              	; Save the operator
040239 CD      0821 CALL    EXPR3           	; Get the second string
04023A 67 
04023B 02 
04023C 04 
04023D 08      0822 EX      AF,AF'
04023E F2      0823 JP      P,TYPE_EV_
04023F 3B 
040240 03 
040241 04 
040242 F1      0824 POP     AF
040243 4B      0825 LD      C,E             	; Length of string #2
040244 D1      0826 POP     DE
040245 21      0827 LD      HL,0
040246 00 
040247 00 
040248 00 
040249 39      0828 ADD     HL,SP
04024A 43      0829 LD      B,E             	; Length of string #1
04024B D5      0830 PUSH    DE
04024C 11      0831 LD      DE,ACCS
04024D 00 
04024E 4A 
04024F 04 
040250 EB      0832 EX      DE,HL
040251 CD      0833 CALL    DISPT2
040252 84 
040253 0A 
040254 04 
040255 D1      0834 POP     DE
040256 EB      0835 EX      DE,HL
040257 7D      0836 LD	A,L
040258 21      0837 LD	HL,0
040259 00 
04025A 00 
04025B 00 
04025C 6F      0838 LD	L,A
04025D 39      0839 ADD     HL,SP
04025E F9      0840 LD      SP,HL
04025F EB      0841 EX      DE,HL
040260 AF      0842 XOR     A               	; Numeric marker
040261 4F      0843 LD      C,A             	; Integer marker
040262 08      0844 EX      AF,AF'
040263 FD      0845 LD      A,(IY)
040264 7E 
040265 00 
040266 C9      0846 RET
               0847 ;
               0848 ; Level 4: + and -
               0849 ;
040267 CD      0850 EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
040268 C9 
040269 02 
04026A 04 
04026B FE      0851 EXPR3A:			CP      '-'			; Is it "-"?
04026C 2D 
04026D 28      0852 JR      Z,EXPR3B		; Yes, so skip the next bit
04026E 09 
04026F FE      0853 CP      '+'			; Is it "+"?
040270 2B 
040271 C0      0854 RET     NZ			; No, so return
040272 08      0855 EX      AF,AF'			; Get the type
040273 FA      0856 JP      M,EXPR3S		; Branch here if string
040274 86 
040275 02 
040276 04 
040277 08      0857 EX      AF,AF'
040278 CD      0858 EXPR3B:			CALL    SAVE_EV			; Save the first operator
040279 46 
04027A 0A 
04027B 04 
04027C CD      0859 CALL    EXPR4			; Fetch the second operator
04027D C9 
04027E 02 
04027F 04 
040280 CD      0860 CALL    DOIT			; Do the operation
040281 55 
040282 0A 
040283 04 
040284 18      0861 JR      EXPR3A			; And continue
040285 E5 
               0862 ;
040286 08      0863 EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD      0864 INC     IY              	; Bump past the "+"
040288 23 
040289 CD      0865 CALL    PUSHS           	; Save the string on the stack
04028A B9 
04028B 09 
04028C 04 
04028D CD      0866 CALL    EXPR4           	; Fetch the second operator
04028E C9 
04028F 02 
040290 04 
040291 08      0867 EX      AF,AF'
040292 F2      0868 JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040293 3B 
040294 03 
040295 04 
040296 01      0869 LD	BC, 0			; Clear BC
040297 00 
040298 00 
040299 00 
04029A 4B      0870 LD      C,E             	; C: Length of the second string
04029B D1      0871 POP     DE
04029C D5      0872 PUSH    DE
04029D 21      0873 LD      HL,ACCS
04029E 00 
04029F 4A 
0402A0 04 
0402A1 7B      0874 LD	A,E			;  E: Length of the first string
0402A2 11      0875 LD      DE,ACCS
0402A3 00 
0402A4 4A 
0402A5 04 
0402A6 5F      0876 LD	E,A 			; DE: Pointer to the end of the first string
0402A7 79      0877 LD      A,C
0402A8 B7      0878 OR      A
0402A9 28      0879 JR      Z,EXP3S3
0402AA 0F 
0402AB 6F      0880 LD      L,A             	; Source
0402AC 83      0881 ADD     A,E
0402AD 5F      0882 LD      E,A             	; Destination
0402AE 3E      0883 LD      A,19
0402AF 13 
0402B0 DA      0884 JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402B1 98 
0402B2 37 
0402B3 04 
0402B4 D5      0885 PUSH    DE
0402B5 1D      0886 DEC     E
0402B6 2D      0887 DEC     L
0402B7 ED      0888 LDDR                    	; Copy
0402B8 B8 
0402B9 D1      0889 POP     DE
0402BA D9      0890 EXP3S3:			EXX
0402BB C1      0891 POP     BC
0402BC CD      0892 CALL    POPS            	; Restore from stack
0402BD E6 
0402BE 09 
0402BF 04 
0402C0 D9      0893 EXX
0402C1 F6      0894 OR      80H             	; Flag as a string
0402C2 80 
0402C3 08      0895 EX      AF,AF'
0402C4 FD      0896 LD      A,(IY)			; Fetch the next character
0402C5 7E 
0402C6 00 
0402C7 18      0897 JR      EXPR3A			; And continue
0402C8 A2 
               0898 ;
               0899 ; Level 3: * / MOD DIV
               0900 ;
0402C9 CD      0901 EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402CA EA 
0402CB 02 
0402CC 04 
0402CD FE      0902 EXPR4A:			CP      '*'			; "*" is valid
0402CE 2A 
0402CF 28      0903 JR      Z,EXPR4B
0402D0 0B 
0402D1 FE      0904 CP      '/'			; "/" is valid
0402D2 2F 
0402D3 28      0905 JR      Z,EXPR4B
0402D4 07 
0402D5 FE      0906 CP      MODK			; MOD token is valid
0402D6 83 
0402D7 28      0907 JR      Z,EXPR4B
0402D8 03 
0402D9 FE      0908 CP      DIVK			; DIV token is valid
0402DA 81 
0402DB C0      0909 RET     NZ			; And return if it is anything else
0402DC CD      0910 EXPR4B:			CALL    SAVE_EV
0402DD 46 
0402DE 0A 
0402DF 04 
0402E0 CD      0911 CALL    EXPR5
0402E1 EA 
0402E2 02 
0402E3 04 
0402E4 CD      0912 CALL    DOIT
0402E5 55 
0402E6 0A 
0402E7 04 
0402E8 18      0913 JR      EXPR4A
0402E9 E3 
               0914 ;
               0915 ; Level 2: ^
               0916 ;
0402EA CD      0917 EXPR5:			CALL    ITEM			; Get variable
0402EB CA 
0402EC 03 
0402ED 04 
0402EE B7      0918 OR      A               	; Test type
0402EF 08      0919 EX      AF,AF'          	; Save type
0402F0 CD      0920 EXPR5A:			CALL    NXT			; Skip spaces
0402F1 78 
0402F2 0A 
0402F3 04 
0402F4 FE      0921 CP      '^'			; Is the operator "^"?
0402F5 5E 
0402F6 C0      0922 RET     NZ			; No, so return
0402F7 CD      0923 CALL    SAVE_EV			; Save first operand
0402F8 46 
0402F9 0A 
0402FA 04 
0402FB CD      0924 CALL    ITEM			; Get second operand
0402FC CA 
0402FD 03 
0402FE 04 
0402FF B7      0925 OR      A			; Test type
040300 08      0926 EX      AF,AF'			; Save type
040301 CD      0927 CALL    DOIT			; Do the operation
040302 55 
040303 0A 
040304 04 
040305 18      0928 JR      EXPR5A			; And continue
040306 E9 
               0929 ;
               0930 ; Evaluate a numeric expression
               0931 ;
040307 CD      0932 EXPRN:			CALL    EXPR			; Evaluate expression
040308 C7 
040309 01 
04030A 04 
04030B 08      0933 EX      AF,AF'			; Get the type
04030C F0      0934 RET     P			; And return if it is a number
04030D 18      0935 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030E 2C 
               0936 ;
               0937 ; Evaluate a fixed-point expression
               0938 ;
04030F CD      0939 EXPRI:			CALL    EXPR			; Evaluate the expression
040310 C7 
040311 01 
040312 04 
040313 08      0940 EX      AF,AF'			; Get the type
040314 F2      0941 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040315 67 
040316 06 
040317 04 
040318 18      0942 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040319 21 
               0943 ;
               0944 ; Evaluate a string expression
               0945 ;
04031A CD      0946 EXPRS:			CALL    EXPR			; Evaluate the expression
04031B C7 
04031C 01 
04031D 04 
04031E 08      0947 EX      AF,AF'			; Get the type
04031F F8      0948 RET     M			; And return if it is a string
040320 18      0949 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040321 19 
               0950 ;
               0951 ; Get a numeric variable
               0952 ;
040322 CD      0953 ITEMN:			CALL    ITEM			; Get the variable
040323 CA 
040324 03 
040325 04 
040326 B7      0954 OR      A			; Test the type
040327 F0      0955 RET     P			; And return if it is a number
040328 18      0956 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040329 11 
               0957 ;
               0958 ; Get a fixed-point variable
               0959 ;
04032A CD      0960 ITEMI:			CALL    ITEM			; Get the variable
04032B CA 
04032C 03 
04032D 04 
04032E B7      0961 OR      A			; Test the type
04032F F2      0962 JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040330 67 
040331 06 
040332 04 
040333 18      0963 JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040334 06 
               0964 ;
               0965 ; Get a string variable
               0966 ;
040335 CD      0967 ITEMS:			CALL    ITEM			; Get the variable
040336 CA 
040337 03 
040338 04 
040339 B7      0968 OR      A			; Test the type
04033A F8      0969 RET     M			; If it is a string, then return
               0970 ;							; Otherwise
04033B 3E      0971 TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
04033C 06 
04033D C3      0972 JP      ERROR_
04033E 98 
04033F 37 
040340 04 
               0973 ;
               0974 ; Evaluate a bracketed expression
               0975 ;
040341 CD      0976 ITEM1:			CALL    EXPR            	; Evaluate the expression
040342 C7 
040343 01 
040344 04 
040345 CD      0977 CALL    BRAKET			; Check for closing bracket
040346 37 
040347 0A 
040348 04 
040349 08      0978 EX      AF,AF'
04034A C9      0979 RET
               0980 ;
               0981 ; HEX - Get hexadecimal constant.
               0982 ;   Inputs: ASCII string at (IY)
               0983 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               0984 ;           IY updated (points to delimiter)
               0985 ;
04034B CD      0986 HEX:			CALL    ZERO			; Set result to 0
04034C 98 
04034D 09 
04034E 04 
04034F CD      0987 CALL    HEXDIG			; Fetch the character from IY
040350 00 
040351 0A 
040352 04 
040353 38      0988 JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040354 1B 
040355 FD      0989 HEX1:			INC     IY			; Move pointer to next character
040356 23 
040357 E6      0990 AND     0FH			; Clear the top nibble
040358 0F 
040359 06      0991 LD      B,4			; Loop counter
04035A 04 
               0992 ;
04035B D9      0993 HEX2:			EXX				; Shift the result left B (4) times. This makes
04035C 52      0994 ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
04035D 29 
04035E D9      0995 EXX				; .
04035F 52      0996 ADC.S   HL,HL			; .
040360 ED 
040361 6A 
040362 10      0997 DJNZ    HEX2			; And loop
040363 F7 
040364 D9      0998 EXX
040365 B5      0999 OR      L			; OR in the digit
040366 6F      1000 LD      L,A
040367 D9      1001 EXX
               1002 ;
040368 CD      1003 CALL    HEXDIG			; Fetch the next character
040369 00 
04036A 0A 
04036B 04 
04036C 30      1004 JR      NC,HEX1			; If it is a HEX digit then loop
04036D E7 
04036E AF      1005 XOR     A			; Clear A
04036F C9      1006 RET
               1007 ;
040370 3E      1008 BADHEX:			LD      A,28
040371 1C 
040372 C3      1009 JP      ERROR_          	; Error: "Bad HEX"
040373 98 
040374 37 
040375 04 
               1010 ;
               1011 ; BIN - Get binary constant.
               1012 ;   Inputs: ASCII string at (IY)
               1013 ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
               1014 ;           IY updated (points to delimiter)
               1015 ;
040376 CD      1016 BIN:			CALL    ZERO			; Set result to 0
040377 98 
040378 09 
040379 04 
04037A CD      1017 CALL	BINDIG			; Fetch the character from IY
04037B 13 
04037C 0A 
04037D 04 
04037E 38      1018 JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037F 13 
040380 FD      1019 BIN1:			INC	IY			; Move pointer to next character
040381 23 
040382 0F      1020 RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
040383 D9      1021 EXX				;
040384 52      1022 ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040385 ED 
040386 6A 
040387 D9      1023 EXX
040388 52      1024 ADC.S	HL,HL
040389 ED 
04038A 6A 
04038B CD      1025 CALL	BINDIG			; Fetch the next character
04038C 13 
04038D 0A 
04038E 04 
04038F 30      1026 JR	NC,BIN1
040390 EF 
040391 AF      1027 XOR	A			; Clear A
040392 C9      1028 RET
               1029 ;
040393 3E      1030 BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040394 1C 
040395 CD      1031 CALL	EXTERR
040396 AF 
040397 37 
040398 04 
040399 42      1032 DB	"Bad Binary", 0
04039A 61 
04039B 64 
04039C 20 
04039C 42   
04039D 69 
04039E 6E 
04039F 61 
04039F 72   
0403A0 79 
0403A1 00 
               1033 ;
               1034 ; MINUS - Unary minus.
               1035 ;   Inputs: IY = text pointer
               1036 ;  Outputs: Numeric result, same type as argument.
               1037 ;           Result in H'L'HLC
               1038 ;
0403A4 CD      1039 MINUS:			CALL    ITEMN			; Get the numeric argument
0403A5 22 
0403A6 03 
0403A7 04 
0403A8 0D      1040 MINUS0:			DEC     C			; Check exponent (C)
0403A9 0C      1041 INC     C			; If it is zero, then it's either a FP zero or an integer
0403AA 28      1042 JR      Z,NEGATE_EV        	; So do an integer negation
0403AB 06 
               1043 ;
0403AC 7C      1044 LD      A,H			; Do a FP negation by
0403AD EE      1045 XOR     80H             	; Toggling the sign bit (H)
0403AE 80 
0403AF 67      1046 LD      H,A
0403B0 AF      1047 XOR     A               	; Numeric marker
0403B1 C9      1048 RET
               1049 ;
0403B2 D9      1050 NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403B3 7C      1051 LD      A,H			; First do a one's complement by negating all the bytes
0403B4 2F      1052 CPL
0403B5 67      1053 LD      H,A
0403B6 7D      1054 LD      A,L
0403B7 2F      1055 CPL
0403B8 6F      1056 LD      L,A
0403B9 D9      1057 EXX
0403BA 7C      1058 LD      A,H
0403BB 2F      1059 CPL
0403BC 67      1060 LD      H,A
0403BD 7D      1061 LD      A,L
0403BE 2F      1062 CPL
0403BF 6F      1063 LD      L,A
0403C0 D9      1064 ADD1:			EXX				; Then add 1
0403C1 23      1065 INC     HL
0403C2 7C      1066 LD      A,H
0403C3 B5      1067 OR      L
0403C4 D9      1068 EXX
0403C5 3E      1069 LD      A,0             	; Numeric marker
0403C6 00 
0403C7 C0      1070 RET     NZ
0403C8 23      1071 INC     HL
0403C9 C9      1072 RET
               1073 ;
               1074 ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
               1075 ; Item type is returned in A:  Bit 7=0 numeric.
               1076 ;                              Bit 7=1 string.
               1077 ; Numeric item returned in HLH'L'C.
               1078 ; String item returned in string accumulator,
               1079 ;   DE addresses byte after last (E=length).
               1080 ;
0403CA CD      1081 ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403CB 81 
0403CC 16 
0403CD 04 
0403CE CD      1082 CALL    NXT			; Skip spaces
0403CF 78 
0403D0 0A 
0403D1 04 
0403D2 FD      1083 INC     IY			; Move to the prefix character
0403D3 23 
0403D4 FE      1084 CP      '&'			; If `&`
0403D5 26 
0403D6 CA      1085 JP      Z,HEX           	; Then get a HEX constant
0403D7 4B 
0403D8 03 
0403D9 04 
0403DA FE      1086 CP	'%'			; If '%'
0403DB 25 
0403DC 28      1087 JR	Z,BIN			; Then get a BINARY constant
0403DD 98 
0403DE FE      1088 CP      '-'			; If `-`
0403DF 2D 
0403E0 28      1089 JR      Z,MINUS         	; Then get a negative number
0403E1 C2 
0403E2 FE      1090 CP      '+'			; If `+`
0403E3 2B 
0403E4 CA      1091 JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E5 22 
0403E6 03 
0403E7 04 
0403E8 FE      1092 CP      '('			; If `(`
0403E9 28 
0403EA CA      1093 JP      Z,ITEM1         	; Start of a bracketed expression
0403EB 41 
0403EC 03 
0403ED 04 
0403EE FE      1094 CP      34			; If `"`
0403EF 22 
0403F0 28      1095 JR      Z,CONS          	; Start of a string constant
0403F1 7A 
0403F2 FE      1096 CP      TCMD_EV			; Is it out of range of the function table?
0403F3 C6 
0403F4 D2      1097 JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F5 9F 
0403F6 0C 
0403F7 04 
0403F8 FE      1098 CP      FUNTOK			; If it is in range, then
0403F9 8D 
0403FA D2      1099 JP      NC,DISPAT       	; It's a function
0403FB 8B 
0403FC 0A 
0403FD 04 
0403FE FD      1100 DEC     IY
0403FF 2B 
040400 FE      1101 CP      ':'
040401 3A 
040402 30      1102 JR      NC,ITEM2		; VARIABLE?
040403 0C 
040404 FE      1103 CP      '0'
040405 30 
040406 D2      1104 JP      NC,CON			; NUMERIC CONSTANT
040407 93 
040408 04 
040409 04 
04040A FE      1105 CP      '.'
04040B 2E 
04040C CA      1106 JP      Z,CON			; NUMERIC CONSTANT
04040D 93 
04040E 04 
04040F 04 
040410 CD      1107 ITEM2:			CALL    GETVAR			; VARIABLE
040411 72 
040412 3A 
040413 04 
040414 20      1108 JR      NZ,NOSUCH
040415 37 
040416 B7      1109 OR      A
040417 FA      1110 JP      M,LOADS			; STRING VARIABLE
040418 A5 
040419 04 
04041A 04 
04041B B7      1111 LOADN:			OR      A
04041C 28      1112 JR      Z,LOAD1			; BYTE VARIABLE
04041D 20 
04041E 0E      1113 LD      C,0
04041F 00 
040420 CB      1114 BIT     0,A
040421 47 
040422 28      1115 JR      Z,LOAD4			; INTEGER VARIABLE
040423 03 
040424 DD      1116 LOAD5:			LD      C,(IX+4)
040425 4E 
040426 04 
040427 D9      1117 LOAD4:			EXX
040428 21      1118 LD	HL, 0			; TODO: Optimise
040429 00 
04042A 00 
04042B 00 
04042C DD      1119 LD      L,(IX+0)
04042D 6E 
04042E 00 
04042F DD      1120 LD      H,(IX+1)
040430 66 
040431 01 
040432 D9      1121 EXX
040433 21      1122 LD	HL, 0			; TODO: Optimise
040434 00 
040435 00 
040436 00 
040437 DD      1123 LD      L,(IX+2)
040438 6E 
040439 02 
04043A DD      1124 LD      H,(IX+3)
04043B 66 
04043C 03 
04043D C9      1125 RET
               1126 ;
04043E 21      1127 LOAD1:			LD      HL,0
04043F 00 
040440 00 
040441 00 
040442 D9      1128 EXX
040443 21      1129 LD      HL,0			; TODO: Optimise
040444 00 
040445 00 
040446 00 
040447 DD      1130 LD      L,(IX+0)
040448 6E 
040449 00 
04044A D9      1131 EXX
04044B 4C      1132 LD      C,H
04044C C9      1133 RET
               1134 ;
04044D DA      1135 NOSUCH:			JP      C,SYNTAX
04044E 9F 
04044F 0C 
040450 04 
040451 3A      1136 LD      A,(LISTON)
040452 40 
040453 4D 
040454 04 
040455 CB      1137 BIT     5,A
040456 6F 
040457 3E      1138 LD      A,26
040458 1A 
040459 20      1139 JR      NZ,ERROR0_EV		; Throw "No such variable"
04045A 26 
04045B FD      1140 NOS1:			INC     IY
04045C 23 
04045D CD      1141 CALL    RANGE
04045E A7 
04045F 3C 
040460 04 
040461 30      1142 JR      NC,NOS1
040462 F8 
040463 DD      1143 LD      IX,PC
040464 21 
040465 40 
040466 30 
040466 11   
040468 AF      1144 XOR     A
040469 4F      1145 LD      C,A
04046A 18      1146 JR      LOAD4
04046B BB 
               1147 ;
               1148 ;CONS - Get string constant from ASCII string.
               1149 ;   Inputs: ASCII string at (IY)
               1150 ;  Outputs: Result in string accumulator.
               1151 ;           D = MS byte of ACCS, E = string length
               1152 ;           A7 = 1 (string marker)
               1153 ;           IY updated
               1154 ;
04046C 11      1155 CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04046D 00 
04046E 4A 
04046F 04 
040470 FD      1156 CONS3:			LD      A,(IY)			; Fetch the first character and
040471 7E 
040472 00 
040473 FD      1157 INC     IY			; Increment the pointer
040474 23 
040475 FE      1158 CP      '"'			; Check for start quote
040476 22 
040477 28      1159 JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040478 0C 
               1160 ;
040479 12      1161 CONS1:			LD      (DE),A			; Store the character in the string accumulator
04047A 1C      1162 INC     E			; Increment the string accumulator pointer
04047B FE      1163 CP      CR			; Is it CR
04047C 0D 
04047D 20      1164 JR      NZ,CONS3		; No, so keep looping
04047E F1 
               1165 ;
04047F 3E      1166 LD      A,9
040480 09 
040481 C3      1167 ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040482 98 
040483 37 
040484 04 
               1168 ;
040485 FD      1169 CONS2:			LD      A,(IY)			; Fetch the next character
040486 7E 
040487 00 
040488 FE      1170 CP      '"'			; Check for end quote?
040489 22 
04048A FD      1171 INC     IY			; Increment the pointer
04048B 23 
04048C 28      1172 JR      Z,CONS1			; It is the end of string marker so jump to the end routine
04048D EB 
04048E FD      1173 DEC     IY			;
04048F 2B 
040490 3E      1174 LD      A,80H           	; String marker
040491 80 
040492 C9      1175 RET
               1176 ;
               1177 ;CON - Get unsigned numeric constant from ASCII string.
               1178 ;   Inputs: ASCII string at (IY).
               1179 ;  Outputs: Variable-type result in HLH'L'C
               1180 ;           IY updated (points to delimiter)
               1181 ;           A7 = 0 (numeric marker)
               1182 ;
040493 FD      1183 CON:			PUSH    IY
040494 E5 
040495 DD      1184 POP     IX
040496 E1 
040497 3E      1185 LD      A,36
040498 24 
040499 CD      1186 CALL    FPP
04049A A2 
04049B 20 
04049C 04 
04049D 38      1187 JR      C,ERROR0_EV
04049E E2 
04049F DD      1188 PUSH    IX
0404A0 E5 
0404A1 FD      1189 POP     IY
0404A2 E1 
0404A3 AF      1190 XOR     A
0404A4 C9      1191 RET
               1192 ;
0404A5 11      1193 LOADS:			LD      DE,ACCS			; Where to store the string
0404A6 00 
0404A7 4A 
0404A8 04 
0404A9 1F      1194 RRA
0404AA 30      1195 JR      NC,LOADS2       	; Skip if it is a fixed string
0404AB 1A 
               1196 ;
0404AC D9      1197 EXX				; This block was a call to LOAD4
0404AD DD      1198 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404AE 6E 
0404AF 00 
0404B0 DD      1199 LD      H,(IX+1)		; The maximum original string length
0404B1 66 
0404B2 01 
0404B3 D9      1200 EXX
0404B4 DD      1201 LD	HL,(IX+2)		; Address of the string (24-bit)
0404B5 27 
0404B6 02 
               1202 ;
0404B7 D9      1203 EXX
0404B8 7D      1204 LD      A,L
0404B9 D9      1205 EXX
0404BA B7      1206 OR      A
0404BB 01      1207 LD	BC,0			; BC: Number of bytes to copy
0404BC 00 
0404BD 00 
0404BE 00 
0404BF 4F      1208 LD      C,A
0404C0 3E      1209 LD      A,80H           	; String marker
0404C1 80 
0404C2 C8      1210 RET     Z
0404C3 ED      1211 LDIR
0404C4 B0 
0404C5 C9      1212 RET
0404C6 7E      1213 LOADS2:			LD      A,(HL)
0404C7 12      1214 LD      (DE),A
0404C8 23      1215 INC     HL
0404C9 FE      1216 CP      CR
0404CA 0D 
0404CB 3E      1217 LD      A,80H           	; String marker
0404CC 80 
0404CD C8      1218 RET     Z
0404CE 1C      1219 INC     E
0404CF 20      1220 JR      NZ,LOADS2
0404D0 F5 
0404D1 C9      1221 RET                     	; Return null string
               1222 ;
               1223 ;VARIABLE-TYPE FUNCTIONS:
               1224 ;
               1225 ;Result returned in HLH'L'C (floating point)
               1226 ;Result returned in HLH'L' (C=0) (integer)
               1227 ;Result returned in string accumulator & DE (string)
               1228 ;All registers destroyed.
               1229 ;IY (text pointer) updated.
               1230 ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
               1231 ;
               1232 ;POS - horizontal cursor position.
               1233 ;VPOS - vertical cursor position.
               1234 ;EOF - return status of file.
               1235 ;BGET - read byte from file.
               1236 ;INKEY - as GET but wait only n centiseconds.
               1237 ;GET - wait for keypress and return ASCII value.
               1238 ;GET(n) - input from Z80 port n.
               1239 ;ASC - ASCII value of string.
               1240 ;LEN - length of string.
               1241 ;LOMEM - location of dynamic variables.
               1242 ;HIMEM - top of available RAM.
               1243 ;PAGE - start of current text page.
               1244 ;TOP - address of first free byte after program.
               1245 ;ERL - line number where last error occurred.
               1246 ;ERR - number of last error.
               1247 ;COUNT - number of printing characters since CR.
               1248 ;Results are integer numeric.
               1249 ;
0404D2 CD      1250 POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D3 04 
0404D4 3F 
0404D5 04 
0404D6 EB      1251 EX      DE,HL			;  L: The X cursor position
0404D7 C3      1252 JP      COUNT1			; Return an 8-bit value
0404D8 86 
0404D9 05 
0404DA 04 
               1253 ;
0404DB CD      1254 VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DC 04 
0404DD 3F 
0404DE 04 
0404DF C3      1255 JP      COUNT1			; Return an 8-bit value
0404E0 86 
0404E1 05 
0404E2 04 
               1256 ;
0404E3 CD      1257 EOF:			CALL    CHANEL			; Check for EOF
0404E4 B8 
0404E5 18 
0404E6 04 
0404E7 CD      1258 CALL    OSSTAT
0404E8 8D 
0404E9 43 
0404EA 04 
0404EB CA      1259 JP      Z,TRUE			; Yes, so return true
0404EC 0A 
0404ED 06 
0404EE 04 
0404EF C3      1260 JP      ZERO			; Otherwise return false (zero)
0404F0 98 
0404F1 09 
0404F2 04 
               1261 ;
0404F3 CD      1262 BGET:			CALL    CHANEL          	; Channel number
0404F4 B8 
0404F5 18 
0404F6 04 
0404F7 CD      1263 CALL    OSBGET
0404F8 7C 
0404F9 43 
0404FA 04 
0404FB 6F      1264 LD      L,A
0404FC C3      1265 JP      COUNT0			; Return an 8-bit value
0404FD 84 
0404FE 05 
0404FF 04 
               1266 ;
040500 CD      1267 INKEY:			CALL    ITEMI			; Get the argument
040501 2A 
040502 03 
040503 04 
040504 CB      1268 BIT	7, H			; Check the sign
040505 7C 
040506 D9      1269 EXX				; HL: The argument
040507 C2      1270 JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040508 F0 
040509 07 
04050A 04 
04050B CD      1271 CALL	INKEY0 			; Do INKEY(n)
04050C E2 
04050D 07 
04050E 04 
04050F 18      1272 JR      ASC0			; Return a numeric value
040510 1D 
               1273 ;
040511 CD      1274 GET:			CALL    NXT			; Skip whitespace
040512 78 
040513 0A 
040514 04 
040515 FE      1275 CP      '('			; Is it GET(
040516 28 
040517 20      1276 JR      NZ,GET0			; No, so get a keyboard character
040518 0B 
040519 CD      1277 CALL    ITEMI           	; Yes, so fetch the port address
04051A 2A 
04051B 03 
04051C 04 
04051D D9      1278 EXX
04051E 44      1279 LD      B,H			; BC: The port address
04051F 4D      1280 LD      C,L
040520 ED      1281 IN      L,(C)           	;  L: Input from port BC
040521 68 
040522 18      1282 JR      COUNT0			; Return an 8-bit value
040523 60 
               1283 ;
040524 CD      1284 GET0:			CALL    GETS			; Read the keyboard character
040525 CC 
040526 07 
040527 04 
040528 18      1285 JR      ASC1			; And return the value
040529 0A 
               1286 ;
04052A CD      1287 ASC:			CALL    ITEMS			; Get the string argument argument
04052B 35 
04052C 03 
04052D 04 
04052E AF      1288 ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052F BB      1289 CP      E			; Is the pointer 0
040530 CA      1290 JP      Z,TRUE          	; Yes, so return -1 as it is a null string
040531 0A 
040532 06 
040533 04 
040534 2A      1291 ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040535 00 
040536 4A 
040537 04 
040538 18      1292 JR      COUNT0			; An 8-bit value
040539 4A 
               1293 ;
04053A CD      1294 LEN:			CALL    ITEMS			; Get the string argument
04053B 35 
04053C 03 
04053D 04 
04053E EB      1295 EX      DE,HL			; HL: Pointer into ACCS
04053F 18      1296 JR      COUNT0			; Return L
040540 43 
               1297 ;
040541 2A      1298 LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040542 1A 
040543 4D 
040544 04 
040545 3A      1299 LD	A, (LOMEM+2)
040546 1C 
040547 4D 
040548 04 
040549 18      1300 JR      COUNT2			; A 24-bit value
04054A 41 
               1301 ;
04054B 2A      1302 HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054C 20 
04054D 4D 
04054E 04 
04054F 3A      1303 LD	A, (HIMEM+2)
040550 22 
040551 4D 
040552 04 
040553 18      1304 JR      COUNT2			; A 24-bit value
040554 37 
               1305 ;
040555 2A      1306 PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040556 14 
040557 4D 
040558 04 
040559 3A      1307 LD	A, (PAGE_+2)		; A 24-bit value
04055A 16 
04055B 4D 
04055C 04 
04055D 18      1308 JR      COUNT2
04055E 2D 
               1309 ;
04055F FD      1310 TOPV:			LD      A,(IY)			; Return the TOP system variable
040560 7E 
040561 00 
040562 FD      1311 INC     IY              	; Skip "P"
040563 23 
040564 FE      1312 CP      'P'
040565 50 
040566 C2      1313 JP      NZ,SYNTAX       	; Throw "Syntax Error"
040567 9F 
040568 0C 
040569 04 
04056A 2A      1314 LD      HL,(TOP)
04056B 17 
04056C 4D 
04056D 04 
04056E 3A      1315 LD	A, (TOP+2)
04056F 19 
040570 4D 
040571 04 
040572 18      1316 JR      COUNT2
040573 18 
               1317 ;
040574 2A      1318 ERLV:			LD      HL,(ERL)		; Return the error line
040575 33 
040576 4D 
040577 04 
040578 18      1319 JR      COUNT1			; A 16-bit value
040579 0C 
               1320 ;
04057A 2A      1321 ERRV:			LD      HL,(ERR)		; Return the error value
04057B 3F 
04057C 4D 
04057D 04 
04057E 18      1322 JR      COUNT0			; An 8-bit value
04057F 04 
               1323 ;
040580 2A      1324 COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
040581 3D 
040582 4D 
040583 04 
               1325 
040584 26      1326 COUNT0:			LD      H,0			; Return L
040585 00 
040586 D9      1327 COUNT1:			EXX				; Return HL
040587 AF      1328 XOR     A
040588 4F      1329 LD      C,A             	; Integer marker
040589 67      1330 LD      H,A
04058A 6F      1331 LD      L,A
04058B C9      1332 RET
04058C D9      1333 COUNT2:			EXX
04058D 6F      1334 LD	L,A
04058E AF      1335 XOR	A
04058F 4F      1336 LD	C,A			; Integer marker
040590 67      1337 LD	H,A
040591 C9      1338 RET
               1339 ;
               1340 ;OPENIN - Open a file for reading.
               1341 ;OPENOT - Open a file for writing.
               1342 ;OPENUP - Open a file for reading or writing.
               1343 ;Result is integer channel number (0 if error)
               1344 ;
040592 AF      1345 OPENOT:			XOR     A			; Open for writing
040593 18      1346 JR	OPENIN_1
040594 06 
               1347 ;
040595 3E      1348 OPENUP:			LD      A,2			; Open for reading / writing
040596 02 
040597 18      1349 JR	OPENIN_1
040598 02 
               1350 ;
040599 3E      1351 OPENIN:			LD      A,1			; Open for reading
04059A 01 
               1352 ;
04059B F5      1353 OPENIN_1:		PUSH    AF              	; Save OPEN type
04059C CD      1354 CALL    ITEMS           	; Fetch the filename
04059D 35 
04059E 03 
04059F 04 
0405A0 3E      1355 LD      A,CR
0405A1 0D 
0405A2 12      1356 LD      (DE),A
0405A3 F1      1357 POP     AF              	; Restore the OPEN type
0405A4 C6      1358 ADD     A,-1            	; Affect the flags
0405A5 FF 
0405A6 21      1359 LD      HL,ACCS
0405A7 00 
0405A8 4A 
0405A9 04 
0405AA CD      1360 CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405AB 65 
0405AC 43 
0405AD 04 
0405AE 6F      1361 LD      L,A			; L: Channel number
0405AF 18      1362 JR      COUNT0			; Return channel number to BASIC
0405B0 D3 
               1363 ;
               1364 ;EXT - Return length of file.
               1365 ;PTR_EV - Return current file pointer.
               1366 ;Results are integer numeric.
               1367 ;
0405B1 CD      1368 EXT:			CALL    CHANEL
0405B2 B8 
0405B3 18 
0405B4 04 
0405B5 CD      1369 CALL    GETEXT
0405B6 C3 
0405B7 43 
0405B8 04 
0405B9 18      1370 JR      TIME0
0405BA 15 
               1371 ;
0405BB CD      1372 PTR_EV:			CALL    CHANEL
0405BC B8 
0405BD 18 
0405BE 04 
0405BF CD      1373 CALL    GETPTR
0405C0 97 
0405C1 43 
0405C2 04 
0405C3 18      1374 JR      TIME0
0405C4 0B 
               1375 ;
               1376 ;TIME - Return current value of elapsed time.
               1377 ;Result is integer numeric.
               1378 ;
0405C5 FD      1379 TIMEV:			LD      A,(IY)
0405C6 7E 
0405C7 00 
0405C8 FE      1380 CP      '$'
0405C9 24 
0405CA 28      1381 JR      Z,TIMEVS
0405CB 0A 
0405CC CD      1382 CALL    GETIME
0405CD E4 
0405CE 3E 
0405CF 04 
0405D0 D5      1383 TIME0:			PUSH    DE
0405D1 D9      1384 EXX
0405D2 E1      1385 POP     HL
0405D3 AF      1386 XOR     A
0405D4 4F      1387 LD      C,A
0405D5 C9      1388 RET
               1389 ;
               1390 ;TIME$ - Return date/time string.
               1391 ;Result is string
               1392 ;
0405D6 FD      1393 TIMEVS:			INC     IY              ;SKIP $
0405D7 23 
0405D8 CD      1394 CALL    GETIMS
0405D9 DC 
0405DA 43 
0405DB 04 
0405DC 3E      1395 LD      A,80H           ;MARK STRING
0405DD 80 
0405DE C9      1396 RET
               1397 ;
               1398 ;String comparison:
               1399 ;
0405DF CD      1400 SLT:			CALL    SCP
0405E0 94 
0405E1 09 
0405E2 04 
0405E3 D0      1401 RET     NC
0405E4 18      1402 JR      TRUE
0405E5 24 
               1403 ;
0405E6 CD      1404 SGT:			CALL    SCP
0405E7 94 
0405E8 09 
0405E9 04 
0405EA C8      1405 RET     Z
0405EB D8      1406 RET     C
0405EC 18      1407 JR      TRUE
0405ED 1C 
               1408 ;
0405EE CD      1409 SGE:			CALL    SCP
0405EF 94 
0405F0 09 
0405F1 04 
0405F2 D8      1410 RET     C
0405F3 18      1411 JR      TRUE
0405F4 15 
               1412 ;
0405F5 CD      1413 SLE:			CALL    SCP
0405F6 94 
0405F7 09 
0405F8 04 
0405F9 28      1414 JR      Z,TRUE
0405FA 0F 
0405FB D0      1415 RET     NC
0405FC 18      1416 JR      TRUE
0405FD 0C 
               1417 ;
0405FE CD      1418 SNE:			CALL    SCP
0405FF 94 
040600 09 
040601 04 
040602 C8      1419 RET     Z
040603 18      1420 JR      TRUE
040604 05 
               1421 ;
040605 CD      1422 SEQ:			CALL    SCP
040606 94 
040607 09 
040608 04 
040609 C0      1423 RET     NZ
04060A 3E      1424 TRUE:			LD      A,-1
04060B FF 
04060C D9      1425 EXX
04060D 67      1426 LD      H,A
04060E 6F      1427 LD      L,A
04060F D9      1428 EXX
040610 67      1429 LD      H,A
040611 6F      1430 LD      L,A
040612 3C      1431 INC     A
040613 4F      1432 LD      C,A
040614 C9      1433 RET
               1434 ;
               1435 ;PI - Return PI (3.141592654)
               1436 ;Result is floating-point numeric.
               1437 ;
040615 3E      1438 PI:			LD      A,35
040616 23 
040617 18      1439 JR      FPP1
040618 44 
               1440 ;
               1441 ;ABS - Absolute value
               1442 ;Result is numeric, variable type.
               1443 ;
040619 3E      1444 ABSV:			LD      A,16
04061A 10 
04061B 18      1445 JR      FPPN
04061C 3A 
               1446 ;
               1447 ;NOT - Complement integer.
               1448 ;Result is integer numeric.
               1449 ;
04061D 3E      1450 NOTK:			LD      A,26
04061E 1A 
04061F 18      1451 JR      FPPN
040620 36 
               1452 ;
               1453 ;DEG - Convert radians to degrees
               1454 ;Result is floating-point numeric.
               1455 ;
040621 3E      1456 DEG:			LD      A,21
040622 15 
040623 18      1457 JR      FPPN
040624 32 
               1458 ;
               1459 ;RAD - Convert degrees to radians
               1460 ;Result is floating-point numeric.
               1461 ;
040625 3E      1462 RAD:			LD      A,27
040626 1B 
040627 18      1463 JR      FPPN
040628 2E 
               1464 ;
               1465 ;SGN - Return -1, 0 or +1
               1466 ;Result is integer numeric.
               1467 ;
040629 3E      1468 SGN:			LD      A,28
04062A 1C 
04062B 18      1469 JR      FPPN
04062C 2A 
               1470 ;
               1471 ;INT - Floor function
               1472 ;Result is integer numeric.
               1473 ;
04062D 3E      1474 INT_:			LD      A,23
04062E 17 
04062F 18      1475 JR      FPPN
040630 26 
               1476 ;
               1477 ;SQR - square root
               1478 ;Result is floating-point numeric.
               1479 ;
040631 3E      1480 SQR:			LD      A,30
040632 1E 
040633 18      1481 JR      FPPN
040634 22 
               1482 ;
               1483 ;TAN - Tangent function
               1484 ;Result is floating-point numeric.
               1485 ;
040635 3E      1486 TAN:			LD      A,31
040636 1F 
040637 18      1487 JR      FPPN
040638 1E 
               1488 ;
               1489 ;COS - Cosine function
               1490 ;Result is floating-point numeric.
               1491 ;
040639 3E      1492 COS:			LD      A,20
04063A 14 
04063B 18      1493 JR      FPPN
04063C 1A 
               1494 ;
               1495 ;SIN - Sine function
               1496 ;Result is floating-point numeric.
               1497 ;
04063D 3E      1498 SIN:			LD      A,29
04063E 1D 
04063F 18      1499 JR      FPPN
040640 16 
               1500 ;
               1501 ;EXP - Exponential function
               1502 ;Result is floating-point numeric.
               1503 ;
040641 3E      1504 EXP:			LD      A,22
040642 16 
040643 18      1505 JR      FPPN
040644 12 
               1506 ;
               1507 ;LN - Natural log.
               1508 ;Result is floating-point numeric.
               1509 ;
040645 3E      1510 LN:			LD      A,24
040646 18 
040647 18      1511 JR      FPPN
040648 0E 
               1512 ;
               1513 ;LOG - base-10 logarithm.
               1514 ;Result is floating-point numeric.
               1515 ;
040649 3E      1516 LOG:			LD      A,25
04064A 19 
04064B 18      1517 JR      FPPN
04064C 0A 
               1518 ;
               1519 ;ASN - Arc-sine
               1520 ;Result is floating-point numeric.
               1521 ;
04064D 3E      1522 ASN:			LD      A,18
04064E 12 
04064F 18      1523 JR      FPPN
040650 06 
               1524 ;
               1525 ;ATN - arc-tangent
               1526 ;Result is floating-point numeric.
               1527 ;
040651 3E      1528 ATN:			LD      A,19
040652 13 
040653 18      1529 JR      FPPN
040654 02 
               1530 ;
               1531 ;ACS - arc-cosine
               1532 ;Result is floating point numeric.
               1533 ;
040655 3E      1534 ACS:			LD      A,17
040656 11 
040657 F5      1535 FPPN:			PUSH    AF
040658 CD      1536 CALL    ITEMN
040659 22 
04065A 03 
04065B 04 
04065C F1      1537 POP     AF
04065D CD      1538 FPP1:			CALL    FPP
04065E A2 
04065F 20 
040660 04 
040661 DA      1539 JP      C,ERROR_
040662 98 
040663 37 
040664 04 
040665 AF      1540 XOR     A
040666 C9      1541 RET
               1542 ;
               1543 ;SFIX - Convert to fixed-point notation
               1544 ;
040667 3E      1545 SFIX:			LD      A,38
040668 26 
040669 18      1546 JR      FPP1
04066A F2 
               1547 ;
               1548 ;SFLOAT - Convert to floating-point notation
               1549 ;
04066B 3E      1550 SFLOAT:			LD      A,39
04066C 27 
04066D 18      1551 JR      FPP1
04066E EE 
               1552 ;
               1553 ;VAL - Return numeric value of string.
               1554 ;Result is variable type numeric.
               1555 ;
04066F CD      1556 VAL:			CALL    ITEMS
040670 35 
040671 03 
040672 04 
040673 AF      1557 VAL0:			XOR     A
040674 12      1558 LD      (DE),A
040675 DD      1559 LD      IX,ACCS
040676 21 
040677 00 
040678 4A 
040678 04   
04067A 3E      1560 LD      A,36
04067B 24 
04067C 18      1561 JR      FPP1
04067D DF 
               1562 ;
               1563 ;EVAL - Pass string to expression evaluator.
               1564 ;Result is variable type (numeric or string).
               1565 ;
04067E CD      1566 EVAL_:			CALL    ITEMS
04067F 35 
040680 03 
040681 04 
040682 3E      1567 LD      A,CR
040683 0D 
040684 12      1568 LD      (DE),A
040685 FD      1569 PUSH    IY
040686 E5 
040687 11      1570 LD      DE,ACCS
040688 00 
040689 4A 
04068A 04 
04068B FD      1571 LD      IY,ACCS
04068C 21 
04068D 00 
04068E 4A 
04068E 04   
040690 0E      1572 LD      C,0
040691 00 
040692 CD      1573 CALL    LEXAN2          ;TOKENISE
040693 D7 
040694 3C 
040695 04 
040696 12      1574 LD      (DE),A
040697 13      1575 INC     DE
040698 AF      1576 XOR     A
040699 CD      1577 CALL    PUSHS           ;PUT ON STACK
04069A B9 
04069B 09 
04069C 04 
04069D FD      1578 LD      IY,SIZEW	;WAS 2
04069E 21 
04069F 03 
0406A0 00 
0406A0 00   
0406A2 FD      1579 ADD     IY,SP
0406A3 39 
0406A4 CD      1580 CALL    EXPR
0406A5 C7 
0406A6 01 
0406A7 04 
0406A8 FD      1581 POP     IY
0406A9 E1 
0406AA FD      1582 ADD     IY,SP
0406AB 39 
0406AC FD      1583 LD      SP,IY           ;ADJUST STACK POINTER
0406AD F9 
0406AE FD      1584 POP     IY
0406AF E1 
0406B0 08      1585 EX      AF,AF'
0406B1 C9      1586 RET
               1587 ;
               1588 ;RND - Random number function.
               1589 ; RND gives random integer 0-&FFFFFFFF
               1590 ; RND(-n) seeds random number & returns -n.
               1591 ; RND(0) returns last value in RND(1) form.
               1592 ; RND(1) returns floating-point 0-0.99999999.
               1593 ; RND(n) returns random integer 1-n.
               1594 ;
0406B2 DD      1595 RND:			LD      IX,RANDOM
0406B3 21 
0406B4 38 
0406B5 4D 
0406B5 04   
0406B7 CD      1596 CALL    NXT
0406B8 78 
0406B9 0A 
0406BA 04 
0406BB FE      1597 CP      '('
0406BC 28 
0406BD 28      1598 JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BE 20 
0406BF CD      1599 CALL    LOAD5
0406C0 24 
0406C1 04 
0406C2 04 
0406C3 CB      1600 RND1:			RR      C
0406C4 19 
0406C5 06      1601 LD      B,32
0406C6 20 
0406C7 D9      1602 RND2:			EXX                     ;CALCULATE NEXT
0406C8 52      1603 ADC.S   HL,HL
0406C9 ED 
0406CA 6A 
0406CB D9      1604 EXX
0406CC 52      1605 ADC.S   HL,HL
0406CD ED 
0406CE 6A 
0406CF CB      1606 BIT     3,L
0406D0 5D 
0406D1 28      1607 JR      Z,RND3
0406D2 01 
0406D3 3F      1608 CCF
0406D4 10      1609 RND3:			DJNZ    RND2
0406D5 F1 
0406D6 CB      1610 RND4:			RL      C               ;SAVE CARRY
0406D7 11 
0406D8 CD      1611 CALL    STORE5          ;STORE NEW NUMBER
0406D9 0D 
0406DA 16 
0406DB 04 
0406DC AF      1612 XOR     A
0406DD 4F      1613 LD      C,A
0406DE C9      1614 RET
0406DF CD      1615 RND5:			CALL    ITEMI
0406E0 2A 
0406E1 03 
0406E2 04 
0406E3 DD      1616 LD      IX,RANDOM
0406E4 21 
0406E5 38 
0406E6 4D 
0406E6 04   
0406E8 CB      1617 BIT     7,H             ;NEGATIVE?
0406E9 7C 
0406EA 37      1618 SCF
0406EB 20      1619 JR      NZ,RND4         ;SEED
0406EC E9 
0406ED CD      1620 CALL    TEST
0406EE E4 
0406EF 08 
0406F0 04 
0406F1 F5      1621 PUSH    AF
0406F2 CD      1622 CALL    SWAP
0406F3 DC 
0406F4 08 
0406F5 04 
0406F6 D9      1623 EXX
0406F7 CD      1624 CALL    LOAD5
0406F8 24 
0406F9 04 
0406FA 04 
0406FB C4      1625 CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FC C3 
0406FD 06 
0406FE 04 
0406FF D9      1626 EXX                     ;SCRAMBLE (CARE!)
040700 0E      1627 LD      C,7FH
040701 7F 
040702 CB      1628 RND6:			BIT     7,H             ;FLOAT
040703 7C 
040704 20      1629 JR      NZ,RND7
040705 0A 
040706 D9      1630 EXX
040707 52      1631 ADD.S   HL,HL
040708 29 
040709 D9      1632 EXX
04070A 52      1633 ADC.S   HL,HL
04070B ED 
04070C 6A 
04070D 0D      1634 DEC     C
04070E 20      1635 JR      NZ,RND6
04070F F2 
040710 CB      1636 RND7:			RES     7,H             ;POSITIVE 0-0.999999
040711 BC 
040712 F1      1637 POP     AF
040713 C8      1638 RET     Z               ;ZERO ARGUMENT
040714 D9      1639 EXX
040715 7B      1640 LD      A,E
040716 3D      1641 DEC     A
040717 B2      1642 OR      D
040718 D9      1643 EXX
040719 B3      1644 OR      E
04071A B2      1645 OR      D
04071B C8      1646 RET     Z               ;ARGUMENT=1
04071C 06      1647 LD      B,0             ;INTEGER MARKER
04071D 00 
04071E 3E      1648 LD      A,10
04071F 0A 
040720 CD      1649 CALL    FPP             ;MULTIPLY
040721 A2 
040722 20 
040723 04 
040724 DA      1650 JP      C,ERROR_
040725 98 
040726 37 
040727 04 
040728 CD      1651 CALL    SFIX
040729 67 
04072A 06 
04072B 04 
04072C C3      1652 JP      ADD1
04072D C0 
04072E 03 
04072F 04 
               1653 ;
               1654 ; INSTR - String search.
               1655 ; Result is integer numeric.
               1656 ;
040730 CD      1657 INSTR:			CALL    EXPRSC			; Get the first string expression
040731 26 
040732 0A 
040733 04 
040734 CD      1658 CALL    PUSHS           	; Push the string onto the stack
040735 B9 
040736 09 
040737 04 
040738 CD      1659 CALL    EXPRS           	; Get the second string expression
040739 1A 
04073A 03 
04073B 04 
04073C C1      1660 POP     BC			;  C: String length, B: Value of A before PUSHS was called
04073D 21      1661 LD      HL,0
04073E 00 
04073F 00 
040740 00 
040741 39      1662 ADD     HL,SP           	; HL: Pointer to main string
040742 C5      1663 PUSH    BC              	;  C: Main string length
040743 43      1664 LD      B,E             	;  B: Sub-string length
040744 CD      1665 CALL    NXT			; Skip whitespace
040745 78 
040746 0A 
040747 04 
040748 FE      1666 CP      ','			; Check if there is a comma for the third parameter
040749 2C 
04074A 3E      1667 LD      A,0			;  A: Default start position in string
04074B 00 
04074C 20      1668 JR      NZ,INSTR1		; No, so skip the next bit
04074D 1A 
04074E FD      1669 INC     IY              	; Skip the comma
04074F 23 
040750 C5      1670 PUSH    BC              	; Save the lengths
040751 E5      1671 PUSH    HL              	; Save the pointer to the main string
040752 CD      1672 CALL    PUSHS			; Push the string onto the stack
040753 B9 
040754 09 
040755 04 
040756 CD      1673 CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040757 0F 
040758 03 
040759 04 
04075A C1      1674 POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
04075B CD      1675 CALL    POPS			; Pop the string off the stack
04075C E6 
04075D 09 
04075E 04 
04075F E1      1676 POP     HL              	; Restore the pointer to the main string
040760 C1      1677 POP     BC              	; Restore the lengths
040761 D9      1678 EXX
040762 7D      1679 LD      A,L			; A: The start position in the  string
040763 D9      1680 EXX
040764 B7      1681 OR      A			; Set the flags
040765 28      1682 JR      Z,INSTR1		; If it is zero, then skip
040766 01 
040767 3D      1683 DEC     A
040768 11      1684 INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040769 00 
04076A 4A 
04076B 04 
04076C CD      1685 CALL    SEARCH			; Do the search
04076D 8A 
04076E 07 
04076F 04 
040770 D1      1686 POP     DE
040771 28      1687 JR      Z,INSTR2        	; NB: Carry cleared
040772 03 
040773 ED      1688 SBC     HL,HL
040774 62 
040775 39      1689 ADD     HL,SP
040776 ED      1690 INSTR2:			SBC     HL,SP
040777 72 
040778 EB      1691 EX      DE,HL
040779 7D      1692 LD	A,L
04077A 21      1693 LD      HL,0
04077B 00 
04077C 00 
04077D 00 
04077E 6F      1694 LD	L,A
04077F 39      1695 ADD     HL,SP
040780 F9      1696 LD      SP,HL
040781 EB      1697 EX      DE,HL
040782 CD      1698 CALL    BRAKET			; Check for closing bracket
040783 37 
040784 0A 
040785 04 
040786 C3      1699 JP      COUNT1			; Return a numeric integer
040787 86 
040788 05 
040789 04 
               1700 ;
               1701 ; SEARCH - Search string for sub-string
               1702 ;    Inputs: Main string at HL length C
               1703 ;            Sub-string  at DE length B
               1704 ;            Starting offset A
               1705 ;   Outputs: NZ - not found
               1706 ;            Z - found at location HL-1
               1707 ;            Carry always cleared
               1708 ;
04078A C5      1709 SEARCH:			PUSH    BC			; Add the starting offset to HL
04078B 01      1710 LD      BC,0
04078C 00 
04078D 00 
04078E 00 
04078F 4F      1711 LD      C,A
040790 09      1712 ADD     HL,BC           	; New start address
040791 C1      1713 POP     BC
040792 91      1714 SUB     C			; If the starting offset > main string length, then do nothing
040793 30      1715 JR      NC,SRCH4
040794 2C 
040795 ED      1716 NEG
040796 44 
040797 4F      1717 LD      C,A             	; Remaining length
               1718 ;
040798 C5      1719 SRCH1:			PUSH    BC
040799 79      1720 LD	A,C
04079A 01      1721 LD	BC,0
04079B 00 
04079C 00 
04079D 00 
04079E 4F      1722 LD	C,A
04079F 1A      1723 LD      A,(DE)
0407A0 ED      1724 CPIR                    	; Find the first character
0407A1 B1 
0407A2 79      1725 LD      A,C
0407A3 C1      1726 POP     BC
0407A4 20      1727 JR      NZ,SRCH4
0407A5 1B 
0407A6 4F      1728 LD      C,A
               1729 ;
               1730 ; This block of four instructions was commented as a bug fix by R.T.Russell
               1731 ;
0407A7 05      1732 DEC     B			; Bug fix
0407A8 B8      1733 CP      B			; Bug fix
0407A9 04      1734 INC     B			; Bug fix
0407AA 38      1735 JR      C,SRCH4			; Bug fix
0407AB 15 
               1736 ;
0407AC C5      1737 PUSH    BC
0407AD D5      1738 PUSH    DE
0407AE E5      1739 PUSH    HL
0407AF 05      1740 DEC     B
0407B0 28      1741 JR      Z,SRCH3         	; Found!
0407B1 08 
0407B2 13      1742 SRCH2:			INC     DE
0407B3 1A      1743 LD      A,(DE)
0407B4 BE      1744 CP      (HL)
0407B5 20      1745 JR      NZ,SRCH3
0407B6 03 
0407B7 23      1746 INC     HL
0407B8 10      1747 DJNZ    SRCH2
0407B9 F8 
0407BA E1      1748 SRCH3:			POP     HL
0407BB D1      1749 POP     DE
0407BC C1      1750 POP     BC
0407BD 20      1751 JR      NZ,SRCH1
0407BE D9 
0407BF AF      1752 XOR     A               	; Flags: Z, NC
0407C0 C9      1753 RET                     	; Found
               1754 ;
0407C1 F6      1755 SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407C2 FF 
0407C3 C9      1756 RET                     	; Not found
               1757 ;
               1758 ;CHRS - Return character with given ASCII value.
               1759 ;Result is string.
               1760 ;
0407C4 CD      1761 CHRS:			CALL    ITEMI
0407C5 2A 
0407C6 03 
0407C7 04 
0407C8 D9      1762 EXX
0407C9 7D      1763 LD      A,L
0407CA 18      1764 JR      GET1
0407CB 0E 
               1765 ;
               1766 ;GETS - Return key pressed as stringor character at position (X,Y).
               1767 ;Result is string.
               1768 ;
0407CC CD      1769 GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407CD 78 
0407CE 0A 
0407CF 04 
0407D0 FE      1770 CP	'('
0407D1 28 
0407D2 CA      1771 JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D3 3A 
0407D4 44 
0407D5 04 
0407D6 CD      1772 CALL    OSRDCH
0407D7 61 
0407D8 3F 
0407D9 04 
0407DA 37      1773 GET1:			SCF
0407DB 18      1774 JR      INKEY1
0407DC 09 
               1775 ;
               1776 ; INKEYS - Wait up to n centiseconds for keypress.
               1777 ;          Return key pressed as string or null
               1778 ;          string if time elapsed.
               1779 ; Result is string.
               1780 ;
0407DD CD      1781 INKEYS:			CALL    ITEMI			; Fetch the argument
0407DE 2A 
0407DF 03 
0407E0 04 
0407E1 D9      1782 EXX
0407E2 CD      1783 INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E3 6A 
0407E4 3F 
0407E5 04 
0407E6 11      1784 INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E7 00 
0407E8 4A 
0407E9 04 
0407EA 12      1785 LD      (DE),A
0407EB 3E      1786 LD      A,80H
0407EC 80 
0407ED D0      1787 RET     NC
0407EE 1C      1788 INC     E
0407EF C9      1789 RET
               1790 ;
               1791 ; INKEYM - Check immediately whether a given key is being pressed
               1792 ; Result is integer numeric
               1793 ;
               1794 INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407F0 3E     0001M LD	A, function
0407F1 1E 
0407F2 49     0002M RST.LIS	08h
0407F3 CF 
0407F4 23      1795 INC	HL			; Index from 0
0407F5 7D      1796 LD	A, L			; Negate the LSB of the answer
0407F6 ED      1797 NEG
0407F7 44 
0407F8 4F      1798 LD	C, A			;  E: The positive keycode value
0407F9 3E      1799 LD	A, 1			; Throw an "Out of range" error
0407FA 01 
0407FB FA      1800 JP	M, ERROR_		; if the argument < - 128
0407FC 98 
0407FD 37 
0407FE 04 
               1801 ;
0407FF 21      1802 LD	HL, BITLOOKUP		; HL: The bit lookup table
040800 22 
040801 08 
040802 04 
040803 11      1803 LD	DE, 0
040804 00 
040805 00 
040806 00 
040807 79      1804 LD	A, C
040808 E6      1805 AND	00000111b		; Just need the first three bits
040809 07 
04080A 5F      1806 LD	E, A			; DE: The bit number
04080B 19      1807 ADD	HL, DE
04080C 46      1808 LD	B, (HL)			;  B: The mask
               1809 ;
04080D 79      1810 LD	A, C			; Fetch the keycode again
04080E E6      1811 AND	01111000b		; And divide by 8
04080F 78 
040810 0F      1812 RRCA
040811 0F      1813 RRCA
040812 0F      1814 RRCA
040813 5F      1815 LD	E, A			; DE: The offset (the MSW has already been cleared previously)
040814 DD      1816 ADD	IX, DE			; IX: The address
040815 19 
040816 78      1817 LD	A, B			;  B: The mask
040817 DD      1818 AND	(IX+0)			; Check whether the bit is set
040818 A6 
040819 00 
04081A CA      1819 JP	Z, ZERO			; No, so return 0
04081B 98 
04081C 09 
04081D 04 
04081E C3      1820 JP	TRUE			; Otherwise return -1
04081F 0A 
040820 06 
040821 04 
               1821 ;
               1822 ; A bit lookup table
               1823 ;
040822 01      1824 BITLOOKUP:		DB	01h, 02h, 04h, 08h
040823 02 
040824 04 
040825 08 
040826 10      1825 DB	10h, 20h, 40h, 80h
040827 20 
040828 40 
040829 80 
               1826 ;
               1827 ; MID$ - Return sub-string.
               1828 ; Result is string.
               1829 ;
04082A CD      1830 MIDS:			CALL    EXPRSC			; Get the first string expression
04082B 26 
04082C 0A 
04082D 04 
04082E CD      1831 CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082F B9 
040830 09 
040831 04 
040832 CD      1832 CALL    EXPRI			; Get the second expression
040833 0F 
040834 03 
040835 04 
040836 C1      1833 POP     BC			; C: String length, B: Value of A before PUSHS was called
040837 CD      1834 CALL    POPS			; Pop the string back off the stack to the string accumulator
040838 E6 
040839 09 
04083A 04 
04083B D9      1835 EXX
04083C 7D      1836 LD      A,L			; A: The start index
04083D D9      1837 EXX
04083E B7      1838 OR      A			; If the start index is 0, then we don't need to do the next bit
04083F 28      1839 JR      Z,MIDS1
040840 0E 
040841 3D      1840 DEC     A
040842 6F      1841 LD      L,A			; L: The start index - 1
040843 93      1842 SUB     E			; Subtract from the string length
040844 1E      1843 LD      E,0			; Preemptively set the string length to 0
040845 00 
040846 30      1844 JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040847 07 
040848 ED      1845 NEG				; Negate the answer and
040849 44 
04084A 4F      1846 LD      C,A			; C: Number of bytes to copy
04084B CD      1847 CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084C 8E 
04084D 08 
04084E 04 
04084F CD      1848 MIDS1:			CALL    NXT			; Skip whitespace
040850 78 
040851 0A 
040852 04 
040853 FE      1849 CP      ','			; Check for a comma
040854 2C 
040855 FD      1850 INC     IY			; Advance to the next character in the BASIC line
040856 23 
040857 28      1851 JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040858 0D 
040859 FD      1852 DEC     IY			; Restore the BASIC program pointer
04085A 2B 
04085B CD      1853 CALL    BRAKET			; Check for a bracket
04085C 37 
04085D 0A 
04085E 04 
04085F 3E      1854 LD      A,80H			; String marker
040860 80 
040861 C9      1855 RET
               1856 ;
               1857 ; LEFT$ - Return left part of string.
               1858 ; Carry cleared if entire string returned.
               1859 ; Result is string.
               1860 ;
040862 CD      1861 LEFTS:			CALL    EXPRSC			; Get the first string expression
040863 26 
040864 0A 
040865 04 
040866 CD      1862 LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040867 B9 
040868 09 
040869 04 
04086A CD      1863 CALL    EXPRI			; Get the second expression
04086B 0F 
04086C 03 
04086D 04 
04086E C1      1864 POP     BC			; C: String length, B: Value of A before PUSHS was called
04086F CD      1865 CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
040870 E6 
040871 09 
040872 04 
040873 CD      1866 CALL    BRAKET			; Check for closing bracket
040874 37 
040875 0A 
040876 04 
040877 D9      1867 EXX
040878 7D      1868 LD      A,L			; L: The second parameter
040879 D9      1869 EXX
04087A BB      1870 CP      E			; Compare with the string length
04087B 30      1871 JR      NC,LEFT3		; If it is greater than or equal then do nothing
04087C 02 
04087D 6B      1872 LD      L,E             	; For RIGHTS, no effect in LEFTS
04087E 5F      1873 LEFT2:			LD      E,A			; E: The new length of string
04087F 3E      1874 LEFT3:			LD      A,80H           	; String marker
040880 80 
040881 C9      1875 RET
               1876 ;
               1877 ; RIGHT$ - Return right part of string.
               1878 ; Result is string.
               1879 ;
040882 CD      1880 RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040883 62 
040884 08 
040885 04 
040886 D0      1881 RET     NC			; Do nothing if the second parameter is >= string length
040887 1C      1882 INC     E			; Check for a zero length string
040888 1D      1883 DEC     E
040889 C8      1884 RET     Z			; Yes, so do nothing
04088A 4B      1885 LD      C,E			;  C: Number of bytes to copy
04088B 7D      1886 LD      A,L
04088C 93      1887 SUB     E
04088D 6F      1888 LD      L,A			;  L: Index into the string
04088E 79      1889 RIGHT1:			LD	A,C
04088F 01      1890 LD	BC,0
040890 00 
040891 00 
040892 00 
040893 4F      1891 LD	C,A			; BC: Number of bytes to copy (with top word cleared)
040894 7D      1892 LD	A,L
040895 21      1893 LD	HL,ACCS
040896 00 
040897 4A 
040898 04 
040899 6F      1894 LD	L,A			; HL: Source (in ACCS)
04089A 11      1895 LD      DE,ACCS			; DE: Destination (start of ACCS)
04089B 00 
04089C 4A 
04089D 04 
04089E ED      1896 LDIR                    	; Copy
04089F B0 
0408A0 3E      1897 LD      A,80H			; String marker
0408A1 80 
0408A2 C9      1898 RET
               1899 ;
               1900 ; STRINGS - Return n concatenations of a string.
               1901 ; Result is string.
               1902 ;
0408A3 CD      1903 STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A4 0F 
0408A5 03 
0408A6 04 
0408A7 CD      1904 CALL    COMMA			; Check for comma
0408A8 2A 
0408A9 0A 
0408AA 04 
0408AB D9      1905 EXX
0408AC 7D      1906 LD      A,L			; L: Number of iterations of string
0408AD D9      1907 EXX
0408AE F5      1908 PUSH    AF
0408AF CD      1909 CALL    EXPRS			; Get the string
0408B0 1A 
0408B1 03 
0408B2 04 
0408B3 CD      1910 CALL    BRAKET			; Check for closing bracket
0408B4 37 
0408B5 0A 
0408B6 04 
0408B7 F1      1911 POP     AF			; A: Number of iterations of string
0408B8 B7      1912 OR      A			; Set flags
0408B9 28      1913 JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408BA C3 
0408BB 3D      1914 DEC     A
0408BC 4F      1915 LD      C,A			; C: Loop counter
0408BD 3E      1916 LD      A,80H			; String marker
0408BE 80 
0408BF C8      1917 RET     Z
0408C0 1C      1918 INC     E			; Check for empty string
0408C1 1D      1919 DEC     E
0408C2 C8      1920 RET     Z              		; And return
0408C3 43      1921 LD      B,E			; B: String length tally
0408C4 21      1922 LD	HL,ACCS
0408C5 00 
0408C6 4A 
0408C7 04 
0408C8 C5      1923 STRIN1:			PUSH    BC
0408C9 7E      1924 STRIN2:			LD      A,(HL)
0408CA 23      1925 INC     HL
0408CB 12      1926 LD      (DE),A
0408CC 1C      1927 INC     E
0408CD 3E      1928 LD      A,19
0408CE 13 
0408CF CA      1929 JP      Z,ERROR_         	; Throw a "String too long" error
0408D0 98 
0408D1 37 
0408D2 04 
0408D3 10      1930 DJNZ    STRIN2
0408D4 F4 
0408D5 C1      1931 POP     BC
0408D6 0D      1932 DEC     C
0408D7 20      1933 JR      NZ,STRIN1
0408D8 EF 
0408D9 3E      1934 LD      A,80H
0408DA 80 
0408DB C9      1935 RET
               1936 ;
               1937 ;SUBROUTINES
               1938 ;
               1939 ;SWAP - Swap arguments
               1940 ;Exchanges DE,HL D'E',H'L' and B,C
               1941 ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
               1942 ;
0408DC 79      1943 SWAP:			LD      A,C
0408DD 48      1944 LD      C,B
0408DE 47      1945 LD      B,A
0408DF EB      1946 EX      DE,HL
0408E0 D9      1947 EXX
0408E1 EB      1948 EX      DE,HL
0408E2 D9      1949 EXX
0408E3 C9      1950 RET
               1951 ;
               1952 ;TEST - Test HLH'L' for zero
               1953 ;Outputs: Z-flag set & A=0 if zero
               1954 ;Destroys: A,F
               1955 ;
0408E4 7C      1956 TEST:			LD      A,H
0408E5 B5      1957 OR      L
0408E6 D9      1958 EXX
0408E7 B4      1959 OR      H
0408E8 B5      1960 OR      L
0408E9 D9      1961 EXX
0408EA C9      1962 RET
               1963 ;
               1964 ;DECODE - Decode line number in pseudo-binary.
               1965 ;   Inputs: IY = Text pointer.
               1966 ;   Outputs: HL=0, H'L'=line number, C=0.
               1967 ;   Destroys: A,C,H,L,H',L',IY,F
               1968 ;
0408EB D9      1969 DECODE:			EXX
0408EC 21      1970 LD	HL, 0
0408ED 00 
0408EE 00 
0408EF 00 
0408F0 FD      1971 LD      A,(IY)
0408F1 7E 
0408F2 00 
0408F3 FD      1972 INC     IY
0408F4 23 
0408F5 17      1973 RLA
0408F6 17      1974 RLA
0408F7 67      1975 LD      H,A
0408F8 E6      1976 AND     0C0H
0408F9 C0 
0408FA FD      1977 XOR     (IY)
0408FB AE 
0408FC 00 
0408FD FD      1978 INC     IY
0408FE 23 
0408FF 6F      1979 LD      L,A
040900 7C      1980 LD      A,H
040901 17      1981 RLA
040902 17      1982 RLA
040903 E6      1983 AND     0C0H
040904 C0 
040905 FD      1984 XOR     (IY)
040906 AE 
040907 00 
040908 FD      1985 INC     IY
040909 23 
04090A 67      1986 LD      H,A
04090B D9      1987 EXX
               1988 ;			XOR     A
               1989 ;			LD      C,A
               1990 ;			LD      H,A
               1991 ;			LD      L,A
04090C 21      1992 LD	HL, 0
04090D 00 
04090E 00 
04090F 00 
040910 4D      1993 LD	C, L
040911 C9      1994 RET
               1995 ;
               1996 ;HEXSTR - convert numeric value to HEX string.
               1997 ;   Inputs: HLH'L'C = integer or floating-point number
               1998 ;  Outputs: String in string accumulator.
               1999 ;           E = string length.  D = ACCS/256
               2000 ;
040912 FD      2001 HEXSTS:			INC     IY              ;SKIP TILDE
040913 23 
040914 CD      2002 CALL    ITEMN
040915 22 
040916 03 
040917 04 
040918 CD      2003 CALL    HEXSTR
040919 1F 
04091A 09 
04091B 04 
04091C 3E      2004 LD      A,80H
04091D 80 
04091E C9      2005 RET
               2006 ;
04091F CD      2007 HEXSTR:			CALL    SFIX
040920 67 
040921 06 
040922 04 
040923 01      2008 LD      BC,8
040924 08 
040925 00 
040926 00 
040927 11      2009 LD      DE,ACCS
040928 00 
040929 4A 
04092A 04 
04092B C5      2010 HEXST1:			PUSH    BC
04092C 06      2011 LD      B,4
04092D 04 
04092E AF      2012 XOR     A
04092F D9      2013 HEXST2:			EXX
040930 52      2014 ADD.S	HL,HL
040931 29 
040932 D9      2015 EXX
040933 52      2016 ADC.S	HL,HL
040934 ED 
040935 6A 
040936 17      2017 RLA
040937 10      2018 DJNZ    HEXST2
040938 F6 
040939 C1      2019 POP     BC
04093A 0D      2020 DEC     C
04093B F8      2021 RET     M
04093C 28      2022 JR      Z,HEXST3
04093D 06 
04093E B7      2023 OR      A
04093F 20      2024 JR      NZ,HEXST3
040940 03 
040941 B8      2025 CP      B
040942 28      2026 JR      Z,HEXST1
040943 E7 
040944 C6      2027 HEXST3:			ADD     A,90H
040945 90 
040946 27      2028 DAA
040947 CE      2029 ADC     A,40H
040948 40 
040949 27      2030 DAA
04094A 12      2031 LD      (DE),A
04094B 13      2032 INC     DE
04094C 47      2033 LD      B,A
04094D 18      2034 JR      HEXST1
04094E DC 
               2035 ;
               2036 ;Function STR - convert numeric value to ASCII string.
               2037 ;   Inputs: HLH'L'C = integer or floating-point number.
               2038 ;  Outputs: String in string accumulator.
               2039 ;           E = length, D = ACCS/256
               2040 ;           A = 80H (type=string)
               2041 ;
               2042 ;First normalise for decimal output:
               2043 ;
04094F CD      2044 STRS:			CALL    NXT
040950 78 
040951 0A 
040952 04 
040953 FE      2045 CP      '~'
040954 7E 
040955 28      2046 JR      Z,HEXSTS
040956 BB 
040957 CD      2047 CALL    ITEMN
040958 22 
040959 03 
04095A 04 
04095B DD      2048 LD      IX,STAVAR
04095C 21 
04095D 00 
04095E 4C 
04095E 04   
040960 DD      2049 LD      A,(IX+3)
040961 7E 
040962 03 
040963 B7      2050 OR      A
040964 DD      2051 LD      IX,G9-1         ;G9 FORMAT
040965 21 
040966 91 
040967 09 
040967 04   
040969 28      2052 JR      Z,STR0
04096A 05 
04096B DD      2053 STR:			LD      IX,STAVAR
04096C 21 
04096D 00 
04096E 4C 
04096E 04   
040970 11      2054 STR0:			LD      DE,ACCS
040971 00 
040972 4A 
040973 04 
040974 3E      2055 LD      A,37
040975 25 
040976 CD      2056 CALL    FPP
040977 A2 
040978 20 
040979 04 
04097A DA      2057 JP      C,ERROR_
04097B 98 
04097C 37 
04097D 04 
04097E DD      2058 BIT     0,(IX+2)
04097F CB 
040980 02 
040981 46 
040982 3E      2059 STR1:			LD      A,80H           ;STRING MARKER
040983 80 
040984 C8      2060 RET     Z
040985 79      2061 LD      A,C
040986 C6      2062 ADD     A,4
040987 04 
040988 BB      2063 STR2:			CP      E
040989 28      2064 JR      Z,STR1
04098A F7 
04098B EB      2065 EX      DE,HL
04098C 36      2066 LD      (HL),' '        ;TRAILING SPACE
04098D 20 
04098E 23      2067 INC     HL
04098F EB      2068 EX      DE,HL
040990 18      2069 JR      STR2
040991 F6 
               2070 ;
040992 09      2071 G9:			DW    9
040993 00 
               2072 ;
               2073 ;STRING COMPARE
               2074 ;Compare string (DE) length B with string (HL) length C.
               2075 ;Result preset to false.
               2076 ;
040994 CD      2077 SCP:			CALL	SCP0
040995 A2 
040996 09 
040997 04 
               2078 ;
040998 3E      2079 ZERO:			LD      A,0
040999 00 
04099A D9      2080 EXX
04099B 67      2081 LD      H,A
04099C 6F      2082 LD      L,A
04099D D9      2083 EXX
04099E 67      2084 LD      H,A
04099F 6F      2085 LD      L,A
0409A0 4F      2086 LD      C,A
0409A1 C9      2087 RET
               2088 ;
0409A2 04      2089 SCP0:			INC     B
0409A3 0C      2090 INC     C
0409A4 05      2091 SCP1:			DEC     B
0409A5 28      2092 JR      Z,SCP2
0409A6 0A 
0409A7 0D      2093 DEC     C
0409A8 28      2094 JR      Z,SCP3
0409A9 0C 
0409AA 1A      2095 LD      A,(DE)
0409AB BE      2096 CP      (HL)
0409AC C0      2097 RET     NZ
0409AD 13      2098 INC     DE
0409AE 23      2099 INC     HL
0409AF 18      2100 JR      SCP1
0409B0 F3 
0409B1 B7      2101 SCP2:			OR      A
0409B2 0D      2102 DEC     C
0409B3 C8      2103 RET     Z
0409B4 37      2104 SCF
0409B5 C9      2105 RET
0409B6 B7      2106 SCP3:			OR      A
0409B7 0C      2107 INC     C
0409B8 C9      2108 RET
               2109 ;
               2110 ; PUSHS - SAVE STRING ON STACK.
               2111 ;     Inputs: String in string accumulator.
               2112 ;             E = string length.
               2113 ;             A - saved on stack.
               2114 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2115 ;
0409B9 CD      2116 PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409BA 81 
0409BB 16 
0409BC 04 
0409BD DD      2117 POP     IX              	; IX: Return address
0409BE E1 
0409BF B7      2118 OR      A               	; Clear the carry flag
0409C0 01      2119 LD	BC,0			; BC: Length of the string
0409C1 00 
0409C2 00 
0409C3 00 
0409C4 4B      2120 LD	C,E
0409C5 21      2121 LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C6 00 
0409C7 4A 
0409C8 04 
0409C9 11      2122 LD	DE,ACCS
0409CA 00 
0409CB 4A 
0409CC 04 
0409CD 59      2123 LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409CE ED      2124 SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CF 52 
0409D0 39      2125 ADD     HL,SP			; Grow the stack
0409D1 F9      2126 LD      SP,HL
0409D2 57      2127 LD      D,A			;  D: This needs to be set to A for some functions
0409D3 47      2128 LD	B,A			; Stack A and C (the string length)
0409D4 C5      2129 PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409D5 06      2130 LD	B,0			; Reset B to 0 for the LDIR in this function
0409D6 00 
0409D7 28      2131 JR      Z,PUSHS1        	; Is it zero length?
0409D8 0B 
0409D9 11      2132 LD      DE,ACCS			; DE: Destination
0409DA 00 
0409DB 4A 
0409DC 04 
0409DD EB      2133 EX      DE,HL			; HL: Destination, DE: Address on stack
0409DE ED      2134 LDIR	                    	; Copy to stack
0409DF B0 
0409E0 CD      2135 CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409E1 81 
0409E2 16 
0409E3 04 
0409E4 DD      2136 PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409E5 E9 
               2137 ;
               2138 ; POPS - RESTORE STRING FROM STACK.
               2139 ;     Inputs: C = string length.
               2140 ;    Outputs: String in string accumulator.
               2141 ;             E = string length.
               2142 ;   Destroys: B,C,D,E,H,L,IX,SP,F
               2143 ;
0409E6 DD      2144 POPS:			POP     IX              	; IX: Return address
0409E7 E1 
0409E8 69      2145 LD	L,C			; Temporarily store string length in L
0409E9 01      2146 LD	BC,0
0409EA 00 
0409EB 00 
0409EC 00 
0409ED 4D      2147 LD	C,L			; BC: Number of bytes to copy
0409EE 21      2148 LD      HL,0			; HL: 0
0409EF 00 
0409F0 00 
0409F1 00 
0409F2 39      2149 ADD     HL,SP			; HL: Stack address
0409F3 11      2150 LD      DE,ACCS			; DE: Destination
0409F4 00 
0409F5 4A 
0409F6 04 
0409F7 0C      2151 INC     C			; Quick check to see if this is a zero length string
0409F8 0D      2152 DEC     C
0409F9 28      2153 JR      Z,POPS1         	; Yes it is, so skip
0409FA 02 
0409FB ED      2154 LDIR                    	; No, so copy from the stack
0409FC B0 
0409FD F9      2155 POPS1:			LD      SP,HL			; Shrink the stack
0409FE DD      2156 JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409FF E9 
               2157 ;
040A00 FD      2158 HEXDIG:			LD      A,(IY)
040A01 7E 
040A02 00 
040A03 FE      2159 CP      '0'
040A04 30 
040A05 D8      2160 RET     C
040A06 FE      2161 CP      '9'+1
040A07 3A 
040A08 3F      2162 CCF
040A09 D0      2163 RET     NC
040A0A FE      2164 CP      'A'
040A0B 41 
040A0C D8      2165 RET     C
040A0D D6      2166 SUB     'A'-10
040A0E 37 
040A0F FE      2167 CP      16
040A10 10 
040A11 3F      2168 CCF
040A12 C9      2169 RET
               2170 ;
040A13 FD      2171 BINDIG:			LD	A,(IY)
040A14 7E 
040A15 00 
040A16 FE      2172 CP	'0'
040A17 30 
040A18 D8      2173 RET	C
040A19 FE      2174 CP	'1'+1
040A1A 32 
040A1B 3F      2175 CCF
040A1C C9      2176 RET
               2177 ;
040A1D FE      2178 RELOP?:			CP      '>'
040A1E 3E 
040A1F D0      2179 RET     NC
040A20 FE      2180 CP      '='
040A21 3D 
040A22 D0      2181 RET     NC
040A23 FE      2182 CP      '<'
040A24 3C 
040A25 C9      2183 RET
               2184 ;
040A26 CD      2185 EXPRSC:			CALL    EXPRS
040A27 1A 
040A28 03 
040A29 04 
040A2A CD      2186 COMMA:			CALL    NXT
040A2B 78 
040A2C 0A 
040A2D 04 
040A2E FD      2187 INC     IY
040A2F 23 
040A30 FE      2188 CP      ','
040A31 2C 
040A32 C8      2189 RET     Z
040A33 3E      2190 LD      A,5
040A34 05 
040A35 18      2191 JR      ERROR1_EV          ;"Missing ,"
040A36 0B 
               2192 ;
040A37 CD      2193 BRAKET:			CALL    NXT
040A38 78 
040A39 0A 
040A3A 04 
040A3B FD      2194 INC     IY
040A3C 23 
040A3D FE      2195 CP      ')'
040A3E 29 
040A3F C8      2196 RET     Z
040A40 3E      2197 LD      A,27
040A41 1B 
040A42 C3      2198 ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A43 98 
040A44 37 
040A45 04 
               2199 ;
040A46 FD      2200 SAVE_EV:			INC     IY
040A47 23 
040A48 08      2201 SAVE1:			EX      AF,AF'
040A49 FA      2202 JP      M,TYPE_EV_
040A4A 3B 
040A4B 03 
040A4C 04 
040A4D 08      2203 EX      AF,AF'
040A4E E3      2204 EX      (SP),HL
040A4F D9      2205 EXX
040A50 E5      2206 PUSH    HL
040A51 D9      2207 EXX
040A52 F5      2208 PUSH    AF
040A53 C5      2209 PUSH    BC
040A54 E9      2210 JP      (HL)
               2211 ;
040A55 08      2212 DOIT:			EX      AF,AF'
040A56 FA      2213 JP      M,TYPE_EV_
040A57 3B 
040A58 03 
040A59 04 
040A5A D9      2214 EXX
040A5B C1      2215 POP     BC              ;RETURN ADDRESS
040A5C D9      2216 EXX
040A5D 79      2217 LD      A,C
040A5E C1      2218 POP     BC
040A5F 47      2219 LD      B,A
040A60 F1      2220 POP     AF              ;OPERATOR
040A61 D9      2221 EXX
040A62 EB      2222 EX      DE,HL
040A63 E1      2223 POP     HL
040A64 D9      2224 EXX
040A65 EB      2225 EX      DE,HL
040A66 E1      2226 POP     HL
040A67 D9      2227 EXX
040A68 C5      2228 PUSH    BC
040A69 D9      2229 EXX
040A6A E6      2230 AND     0FH
040A6B 0F 
040A6C CD      2231 CALL    FPP
040A6D A2 
040A6E 20 
040A6F 04 
040A70 38      2232 JR      C,ERROR1_EV
040A71 D0 
040A72 AF      2233 XOR     A
040A73 08      2234 EX      AF,AF'          ;TYPE
040A74 FD      2235 LD      A,(IY)
040A75 7E 
040A76 00 
040A77 C9      2236 RET
               2237 ;
               2238 ; Skip spaces
               2239 ; - IY: String pointer
               2240 ; Returns:
               2241 ;  - A: The non-space character found
               2242 ; - IY: Points to the character before that
               2243 ;
040A78 FD      2244 NXT:			LD      A,(IY)			; Fetch the character
040A79 7E 
040A7A 00 
040A7B FE      2245 CP      ' '			; If it is space, then return
040A7C 20 
040A7D C0      2246 RET     NZ
040A7E FD      2247 INC     IY			; Increment the pointer and
040A7F 23 
040A80 C3      2248 JP      NXT			; Loop
040A81 78 
040A82 0A 
040A83 04 
               2249 ;
040A84 E5      2250 DISPT2:			PUSH    HL
040A85 21      2251 LD      HL,SOPTBL
040A86 B5 
040A87 01 
040A88 04 
040A89 18      2252 JR      DISPT0
040A8A 07 
               2253 ;
040A8B E5      2254 DISPAT:			PUSH    HL
040A8C D6      2255 SUB     FUNTOK
040A8D 8D 
040A8E 21      2256 LD      HL,FUNTBL
040A8F 0A 
040A90 01 
040A91 04 
040A92 C5      2257 DISPT0:			PUSH    BC
               2258 
040A93 01      2259 LD	BC, 3
040A94 03 
040A95 00 
040A96 00 
040A97 47      2260 LD	B, A
040A98 ED      2261 MLT	BC
040A99 4C 
040A9A 09      2262 ADD	HL, BC
040A9B ED      2263 LD	HL, (HL)
040A9C 27 
               2264 
               2265 ;			ADD     A,A
               2266 ;			LD      C,A
               2267 ;			LD      B,0
               2268 ;			ADD     HL,BC
               2269 ;			LD      A,(HL)
               2270 ;			INC     HL
               2271 ;			LD      H,(HL)
               2272 ;			LD      L,A
               2273 
040A9D C1      2274 POP     BC
040A9E E3      2275 EX      (SP),HL
040A9F C9      2276 RET                     ;OFF TO ROUTINE
               2277 
               2278 ; --- End eval.asm ---
               2279 
               2280 ; --- Begin exec.asm ---
               2281 ;
               2282 ; Title:	BBC Basic Interpreter - Z80 version
               2283 ;		Statement Execution & Assembler Module - "EXEC"
               2284 ; Author:	(C) Copyright  R.T.Russell  1984
               2285 ; Modified By:	Dean Belfield
               2286 ; Created:	12/05/2023
               2287 ; Last Updated:	26/06/2023
               2288 ;
               2289 ; Modinfo:
               2290 ; 27/01/1984:	Version 2.1
               2291 ; 02/03/1987:	Version 3.0
               2292 ; 11/06/1987:	Version 3.1
               2293 ; 12/05/2023:	Modified by Dean Belfield
               2294 ; 07/06/2023:	Modified to run in ADL mode
               2295 ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
               2296 
               2297 ; .ASSUME	ADL = 1
               2298 
               2299 ; INCLUDE	"equs.inc"
               2300 
               2301 ; SEGMENT CODE
               2302 
               2303 ; XDEF	XEQ
               2304 ; XDEF	CHAIN0
               2305 ; XDEF	RUN
               2306 ; XDEF	SYNTAX
               2307 ; XDEF	ESCAPE
               2308 ; XDEF	FN_EX
               2309 ; XDEF	USR
               2310 ; XDEF	STORE5
               2311 ; XDEF	STORE4
               2312 ; XDEF	CHECK
               2313 ; XDEF	TERMQ
               2314 ; XDEF	FILL
               2315 ; XDEF	X4OR5
               2316 ; XDEF	MUL16
               2317 ; XDEF	CHANEL
               2318 ; XDEF	ASSEM
               2319 
               2320 ; XREF	AUTO
               2321 ; XREF	DELETE
               2322 ; XREF	LOAD
               2323 ; XREF	LIST_
               2324 ; XREF	NEW
               2325 ; XREF	OLD
               2326 ; XREF	RENUM
               2327 ; XREF	SAVE
               2328 ; XREF	SOUND
               2329 ; XREF	CLG
               2330 ; XREF	DRAW
               2331 ; XREF	ENVEL
               2332 ; XREF	GCOL
               2333 ; XREF	MODE
               2334 ; XREF	MOVE
               2335 ; XREF	PLOT
               2336 ; XREF	COLOUR
               2337 ; XREF	EXPRS
               2338 ; XREF	HIMEM
               2339 ; XREF	LOAD0
               2340 ; XREF	RANDOM
               2341 ; XREF	CLEAR
               2342 ; XREF	ERRTRP
               2343 ; XREF	PAGE_
               2344 ; XREF	DATAPTR
               2345 ; XREF	ERRLIN
               2346 ; XREF	TRAP
               2347 ; XREF	NXT
               2348 ; XREF	SETLIN
               2349 ; XREF	CLOOP
               2350 ; XREF	OSSHUT
               2351 ; XREF	WARM
               2352 ; XREF	TRACEN
               2353 ; XREF	OUTCHR
               2354 ; XREF	PBCDL
               2355 ; XREF	OSCLI
               2356 ; XREF	LISTON
               2357 ; XREF	GETVAR
               2358 ; XREF	PUTVAR
               2359 ; XREF	DATPTR
               2360 ; XREF	ERROR_
               2361 ; XREF	EXPR
               2362 ; XREF	CREATE
               2363 ; XREF	EXPRI
               2364 ; XREF	BRAKET
               2365 ; XREF	FREE
               2366 ; XREF	OSBPUT
               2367 ; XREF	COUNT
               2368 ; XREF	STR
               2369 ; XREF	HEXSTR
               2370 ; XREF	CRLF
               2371 ; XREF	ITEMI
               2372 ; XREF	FINDL
               2373 ; XREF	TEST
               2374 ; XREF	EXPRN
               2375 ; XREF	DLOAD5
               2376 ; XREF	DLOAD5_SPL
               2377 ; XREF	LOADN
               2378 ; XREF	FPP
               2379 ; XREF	SWAP
               2380 ; XREF	GETDEF
               2381 ; XREF	ZERO
               2382 ; XREF	OSBGET
               2383 ; XREF	BUFFER
               2384 ; XREF	CONS
               2385 ; XREF	VAL0
               2386 ; XREF	OSLINE
               2387 ; XREF	CLRSCN
               2388 ; XREF	TELL
               2389 ; XREF	SAYLN
               2390 ; XREF	REPORT
               2391 ; XREF	PUTPTR
               2392 ; XREF	PUTIME
               2393 ; XREF	PUTIMS
               2394 ; XREF	LOMEM
               2395 ; XREF	WIDTH
               2396 ; XREF	OSWRCH
               2397 ; XREF	COMMA
               2398 ; XREF	OSCALL
               2399 ; XREF	SFIX
               2400 ; XREF	LOAD4
               2401 ; XREF	PUSHS
               2402 ; XREF	POPS
               2403 ; XREF	LOADS
               2404 ; XREF	PUTCSR
               2405 ; XREF	OUT_
               2406 ; XREF	R0
               2407 ;
               2408 ; List of token values used in this module
               2409 ;
               2410 TAND:			EQU     80H
               2411 TOR:			EQU     84H
               2412 TERROR_EX:			EQU     85H
               2413 LINE_EX_:			EQU     86H
               2414 OFF_:			EQU     87H
               2415 STEP:			EQU     88H
               2416 SPC:			EQU     89H
               2417 TAB:			EQU     8AH
               2418 ELSE_EX_:			EQU     8BH
               2419 THEN_EX_:			EQU     8CH
               2420 LINO_EX:			EQU     8DH
               2421 TO_EX:			EQU     B8H
               2422 TCMD_EX:			EQU     C6H
               2423 TCALL:			EQU     D6H
               2424 DATA_EX_:			EQU     DCH
               2425 DEF_:			EQU     DDH
               2426 TGOSUB:			EQU     E4H
               2427 TGOTO:			EQU     E5H
               2428 TON:			EQU     EEH
               2429 TPROC:			EQU     F2H
               2430 TSTOP:			EQU     FAH
               2431 
               2432 ; The command table
               2433 ; Commands are tokens from C6H onwards; this lookup table is used to
               2434 ; run the corresponding function; Note that DATA and DEF both use the same
               2435 ; code as REM
               2436 ;
040AA0 21      2437 CMDTAB:			DW24  AUTO			; C6H
040AA1 37 
040AA2 04 
040AA3 84      2438 DW24  DELETE			; C7H
040AA4 35 
040AA5 04 
040AA6 62      2439 DW24  LOAD			; C8H
040AA7 37 
040AA8 04 
040AA9 BF      2440 DW24  LIST_			; C9H
040AAA 35 
040AAB 04 
040AAC 3F      2441 DW24  NEW			; CAH
040AAD 37 
040AAE 04 
040AAF 45      2442 DW24  OLD			; CBH
040AB0 37 
040AB1 04 
040AB2 4E      2443 DW24  RENUM			; CCH
040AB3 36 
040AB4 04 
040AB5 73      2444 DW24  SAVE			; CDH
040AB6 37 
040AB7 04 
040AB8 DA      2445 DW24  PUT			; CEH
040AB9 15 
040ABA 04 
040ABB D0      2446 DW24  PTR_EX			; CFH
040ABC 13 
040ABD 04 
040ABE EA      2447 DW24  PAGEV_EX			; D0H
040ABF 13 
040AC0 04 
040AC1 FD      2448 DW24  TIMEV_EX			; D1H
040AC2 13 
040AC3 04 
040AC4 26      2449 DW24  LOMEMV_EX			; D2H
040AC5 14 
040AC6 04 
040AC7 3F      2450 DW24  HIMEMV_EX			; D3H
040AC8 14 
040AC9 04 
040ACA 64      2451 DW24  SOUND			; D4H
040ACB 46 
040ACC 04 
040ACD F4      2452 DW24  BPUT			; D5H
040ACE 14 
040ACF 04 
040AD0 0C      2453 DW24  CALL_			; D6H
040AD1 15 
040AD2 04 
040AD3 54      2454 DW24  CHAIN			; D7H
040AD4 0B 
040AD5 04 
040AD6 9F      2455 DW24  CLR			; D8H
040AD7 13 
040AD8 04 
040AD9 E8      2456 DW24  CLOSE			; D9H
040ADA 14 
040ADB 04 
040ADC 00      2457 DW24  CLG			; DAH
040ADD 44 
040ADE 04 
040ADF 72      2458 DW24  CLS			; DBH
040AE0 13 
040AE1 04 
040AE2 33      2459 DW24  REM_EX             		; DCH: DATA
040AE3 0C 
040AE4 04 
040AE5 33      2460 DW24  REM_EX             		; DDH: DEF
040AE6 0C 
040AE7 04 
040AE8 F9      2461 DW24  DIM_EX			; DEH
040AE9 0C 
040AEA 04 
040AEB 2A      2462 DW24  DRAW			; DFH
040AEC 46 
040AED 04 
040AEE CE      2463 DW24  END_			; E0H
040AEF 0B 
040AF0 04 
040AF1 8A      2464 DW24  ENDPRO			; E1H
040AF2 11 
040AF3 04 
040AF4 84      2465 DW24  ENVEL			; E2H
040AF5 49 
040AF6 04 
040AF7 9F      2466 DW24  FOR_EX			; E3H
040AF8 0F 
040AF9 04 
040AFA 4F      2467 DW24  GOSUB_EX			; E4H
040AFB 0F 
040AFC 04 
040AFD 33      2468 DW24  GOTO_EX			; E5H
040AFE 0F 
040AFF 04 
040B00 BE      2469 DW24  GCOL			; E6H
040B01 45 
040B02 04 
040B03 3E      2470 DW24  IF_			; E7H
040B04 13 
040B05 04 
040B06 2C      2471 DW24  INPUT			; E8H
040B07 12 
040B08 04 
040B09 54      2472 DW24  LET			; E9H
040B0A 0C 
040B0B 04 
040B0C 2F      2473 DW24  LOCAL_EX_			; EAH
040B0D 11 
040B0E 04 
040B0F 10      2474 DW24  MODE			; EBH
040B10 44 
040B11 04 
040B12 22      2475 DW24  MOVE			; ECH
040B13 46 
040B14 04 
040B15 ED      2476 DW24  NEXT_EX			; EDH
040B16 0F 
040B17 04 
040B18 C6      2477 DW24  ON_EX_			; EEH
040B19 0E 
040B1A 04 
040B1B A9      2478 DW24  VDU			; EFH
040B1C 14 
040B1D 04 
040B1E F0      2479 DW24  PLOT			; F0H
040B1F 45 
040B20 04 
040B21 CF      2480 DW24  PRINT_			; F1H
040B22 0D 
040B23 04 
040B24 8C      2481 DW24  PROC_EX			; F2H
040B25 10 
040B26 04 
040B27 DE      2482 DW24  READ			; F3H
040B28 12 
040B29 04 
040B2A 33      2483 DW24  REM_EX			; F4H
040B2B 0C 
040B2C 04 
040B2D 6F      2484 DW24  REPEAT_EX			; F5H
040B2E 0F 
040B2F 04 
040B30 97      2485 DW24  REPOR			; F6H
040B31 13 
040B32 04 
040B33 A9      2486 DW24  RESTOR_EX			; F7H
040B34 13 
040B35 04 
040B36 5D      2487 DW24  RETURN			; F8H
040B37 0F 
040B38 04 
040B39 4E      2488 DW24  RUN			; F9H
040B3A 0B 
040B3B 04 
040B3C 7F      2489 DW24  STOP			; FAH
040B3D 13 
040B3E 04 
040B3F 0C      2490 DW24  COLOUR			; FBH
040B40 45 
040B41 04 
040B42 8B      2491 DW24  TRACE_EX			; FCH
040B43 14 
040B44 04 
040B45 79      2492 DW24  UNTIL_EX			; FDH
040B46 0F 
040B47 04 
040B48 7D      2493 DW24  WIDTHV			; FEH
040B49 14 
040B4A 04 
040B4B 19      2494 DW24  CLI             		; FFH: OSCLI
040B4C 0C 
040B4D 04 
               2495 
               2496 ; RUN
               2497 ; RUN "filename"
               2498 ;
040B4E CD      2499 RUN:			CALL    TERMQ			; Standalone RUN command?
040B4F AC 
040B50 17 
040B51 04 
040B52 28      2500 JR      Z,RUN0			; Yes, so just RUN the code
040B53 10 
               2501 
               2502 ; CHAIN "filename"
               2503 ;
040B54 CD      2504 CHAIN:			CALL    EXPRS			; Get the filename
040B55 1A 
040B56 03 
040B57 04 
040B58 3E      2505 LD      A,CR			; Terminate it with a CR
040B59 0D 
040B5A 12      2506 LD      (DE),A
040B5B ED      2507 CHAIN0:			LD      SP,(HIMEM)		; Reset SP
040B5C 7B 
040B5D 20 
040B5E 4D 
040B5E 04   
040B60 CD      2508 CALL    LOAD0			; And load the file in
040B61 57 
040B62 38 
040B63 04 
               2509 ;
040B64 ED      2510 RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
040B65 7B 
040B66 20 
040B67 4D 
040B67 04   
040B69 DD      2511 LD      IX,RANDOM		; Pointer to the RANDOM sysvar
040B6A 21 
040B6B 38 
040B6C 4D 
040B6C 04   
040B6E ED      2512 @@:			LD      A, R			; Use the R register to seed the random number generator
040B6F 5F 
040B70 28      2513 JR      Z, @B			; Loop unti we get a non-zero value in A
040B71 FC 
040B72 07      2514 RLCA				; Rotate it
040B73 07      2515 RLCA
040B74 DD      2516 LD      (IX+3),A		; And store
040B75 77 
040B76 03 
040B77 9F      2517 SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B78 DD      2518 LD      (IX+4),A		; And store
040B79 77 
040B7A 04 
040B7B CD      2519 CALL    CLEAR
040B7C AE 
040B7D 38 
040B7E 04 
040B7F 21      2520 LD      HL,0			; Clear the error trap sysvar
040B80 00 
040B81 00 
040B82 00 
040B83 22      2521 LD      (ERRTRP),HL
040B84 2C 
040B85 4D 
040B86 04 
040B87 2A      2522 LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B88 14 
040B89 4D 
040B8A 04 
040B8B 3E      2523 LD      A,DATA_EX_			; The DATA token value
040B8C DC 
040B8D CD      2524 CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B8E 80 
040B8F 18 
040B90 04 
040B91 22      2525 LD      (DATPTR),HL     	; Set data pointer
040B92 31 
040B93 4D 
040B94 04 
040B95 FD      2526 LD      IY,(PAGE_)		; Load IY with the start of program memory
040B96 2A 
040B97 14 
040B98 4D 
040B98 04   
               2527 ;
040B9A CD      2528 XEQ0:			CALL    NEWLIN
040B9B E2 
040B9C 0B 
040B9D 04 
040B9E FD      2529 XEQ:			LD      (ERRLIN),IY     	; Error pointer
040B9F 22 
040BA0 35 
040BA1 4D 
040BA1 04   
040BA3 CD      2530 CALL    TRAP           		; Check keyboard
040BA4 A5 
040BA5 3F 
040BA6 04 
040BA7 CD      2531 XEQ1:			CALL    NXT
040BA8 78 
040BA9 0A 
040BAA 04 
040BAB FD      2532 INC     IY
040BAC 23 
040BAD FE      2533 CP      ':'             	; Seperator
040BAE 3A 
040BAF 28      2534 JR      Z,XEQ1
040BB0 F6 
040BB1 FE      2535 CP      CR
040BB2 0D 
040BB3 28      2536 JR      Z,XEQ0          	; New program line
040BB4 E5 
040BB5 D6      2537 SUB     TCMD_EX
040BB6 C6 
040BB7 DA      2538 JP      C,LET0          	; Implied "LET"
040BB8 42 
040BB9 0C 
040BBA 04 
               2539 
040BBB 01      2540 LD	BC, 3
040BBC 03 
040BBD 00 
040BBE 00 
040BBF 47      2541 LD	B, A
040BC0 ED      2542 MLT	BC
040BC1 4C 
040BC2 21      2543 LD	HL,CMDTAB
040BC3 A0 
040BC4 0A 
040BC5 04 
040BC6 09      2544 ADD	HL, BC
040BC7 ED      2545 LD	HL, (HL)		; Table entry
040BC8 27 
               2546 
               2547 ;			ADD     A,A
               2548 ;			LD      C,A
               2549 ;			LD      B,0
               2550 ;			LD      HL,CMDTAB
               2551 ;			ADD     HL,BC
               2552 ;			LD      A,(HL)          	; Table entry
               2553 ;			INC     HL
               2554 ;			LD      H,(HL)
               2555 ;			LD      L,A
               2556 
040BC9 CD      2557 CALL    NXT
040BCA 78 
040BCB 0A 
040BCC 04 
040BCD E9      2558 JP      (HL)            	; Execute the statement
               2559 
               2560 ;END
               2561 ;
040BCE CD      2562 END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BCF E6 
040BD0 39 
040BD1 04 
040BD2 7C      2563 LD      A,H
040BD3 B5      2564 OR      L               ;DIRECT?
040BD4 CA      2565 JP      Z,CLOOP
040BD5 B8 
040BD6 30 
040BD7 04 
040BD8 1E      2566 LD      E,0
040BD9 00 
040BDA CD      2567 CALL    OSSHUT          ;CLOSE ALL FILES
040BDB 74 
040BDC 43 
040BDD 04 
040BDE C3      2568 JP      WARM            ;"Ready"
040BDF B7 
040BE0 30 
040BE1 04 
               2569 ;
040BE2 FD      2570 NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BE3 7E 
040BE4 00 
040BE5 01      2571 LD      BC,3
040BE6 03 
040BE7 00 
040BE8 00 
040BE9 FD      2572 ADD     IY,BC
040BEA 09 
040BEB B7      2573 OR      A
040BEC 28      2574 JR      Z,END_           ;LENGTH=0, EXIT
040BED E0 
040BEE 2A      2575 LD      HL,(TRACEN)
040BEF 26 
040BF0 4D 
040BF1 04 
040BF2 7C      2576 LD      A,H
040BF3 B5      2577 OR      L
040BF4 C8      2578 RET     Z
040BF5 11      2579 LD	DE, 0		;Clear DE
040BF6 00 
040BF7 00 
040BF8 00 
040BF9 FD      2580 LD      D,(IY-1)        ;DE = LINE NUMBER
040BFA 56 
040BFB FF 
040BFC FD      2581 LD      E,(IY-2)
040BFD 5E 
040BFE FE 
040BFF ED      2582 SBC     HL,DE
040C00 52 
040C01 D8      2583 RET     C
040C02 EB      2584 EX      DE,HL
040C03 3E      2585 LD      A,'['           ;TRACE
040C04 5B 
040C05 CD      2586 CALL    OUTCHR
040C06 87 
040C07 39 
040C08 04 
040C09 CD      2587 CALL    PBCDL
040C0A 2F 
040C0B 3A 
040C0C 04 
040C0D 3E      2588 LD      A,']'
040C0E 5D 
040C0F CD      2589 CALL    OUTCHR
040C10 87 
040C11 39 
040C12 04 
040C13 3E      2590 LD      A,' '
040C14 20 
040C15 C3      2591 JP      OUTCHR
040C16 87 
040C17 39 
040C18 04 
               2592 
               2593 ; Routines for each statement -------------------------------------------------
               2594 
               2595 ; OSCLI
               2596 ;
040C19 CD      2597 CLI:			CALL    EXPRS
040C1A 1A 
040C1B 03 
040C1C 04 
040C1D 3E      2598 LD      A,CR
040C1E 0D 
040C1F 12      2599 LD      (DE),A
040C20 21      2600 LD      HL,ACCS
040C21 00 
040C22 4A 
040C23 04 
040C24 CD      2601 CALL    OSCLI
040C25 C8 
040C26 3F 
040C27 04 
040C28 C3      2602 JP      XEQ
040C29 9E 
040C2A 0B 
040C2B 04 
               2603 
               2604 ; REM, *
               2605 ;
040C2C FD      2606 EXT_EX:			PUSH    IY
040C2D E5 
040C2E E1      2607 POP     HL
040C2F CD      2608 CALL    OSCLI
040C30 C8 
040C31 3F 
040C32 04 
040C33 FD      2609 REM_EX:			PUSH    IY
040C34 E5 
040C35 E1      2610 POP     HL
040C36 3E      2611 LD      A,CR
040C37 0D 
040C38 47      2612 LD      B,A
040C39 ED      2613 CPIR                    ;FIND LINE END
040C3A B1 
040C3B E5      2614 PUSH    HL
040C3C FD      2615 POP     IY
040C3D E1 
040C3E C3      2616 JP      XEQ0
040C3F 9A 
040C40 0B 
040C41 04 
               2617 
               2618 ; [LET] var = expr
               2619 ;
040C42 FE      2620 LET0:			CP      ELSE_EX_-TCMD_EX
040C43 C5 
040C44 28      2621 JR      Z,REM_EX
040C45 ED 
               2622 ; CP      ('*'-TCMD) & 0FFH
               2623 ; JR      Z,EXT_EX
               2624 ; CP      ('='-TCMD) & 0FFH
               2625 ; JR      Z,FNEND
               2626 ; CP      ('['-TCMD) & 0FFH
               2627 ; ez80asm doesn't like () in expressions
040C46 FE      2628 CP      '*'-TCMD_EX & 0FFH
040C47 64 
040C48 28      2629 JR      Z,EXT_EX
040C49 E2 
040C4A FE      2630 CP      '='-TCMD_EX & 0FFH
040C4B 77 
040C4C 28      2631 JR      Z,FNEND
040C4D 5B 
040C4E FE      2632 CP      '['-TCMD_EX & 0FFH
040C4F 95 
040C50 28      2633 JR      Z,ASM
040C51 25 
040C52 FD      2634 DEC     IY
040C53 2B 
040C54 CD      2635 LET:			CALL    ASSIGN			; Assign the variable
040C55 F0 
040C56 15 
040C57 04 
040C58 CA      2636 JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C59 9E 
040C5A 0B 
040C5B 04 
040C5C 38      2637 JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C5D 41 
               2638 ;
040C5E F5      2639 PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C5F CD      2640 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C60 C2 
040C61 17 
040C62 04 
040C63 E5      2641 PUSH    HL			; HL: Address of the variable
040C64 CD      2642 CALL    EXPRS
040C65 1A 
040C66 03 
040C67 04 
040C68 DD      2643 POP     IX			; IX: Address of the variable
040C69 E1 
040C6A F1      2644 POP     AF			; AF: The variable type
040C6B CD      2645 CALL    STACCS			; Copy the string from ACCS to the variable area
040C6C 32 
040C6D 16 
040C6E 04 
040C6F C3      2646 XEQR:			JP      XEQ
040C70 9E 
040C71 0B 
040C72 04 
               2647 ;
040C73 CD      2648 ASM0:			CALL    NEWLIN
040C74 E2 
040C75 0B 
040C76 04 
040C77 FD      2649 ASM:			LD      (ERRLIN),IY
040C78 22 
040C79 35 
040C7A 4D 
040C7A 04   
040C7C CD      2650 CALL    TRAP
040C7D A5 
040C7E 3F 
040C7F 04 
040C80 CD      2651 CALL    ASSEM
040C81 CD 
040C82 18 
040C83 04 
040C84 38      2652 JR      C,SYNTAX
040C85 19 
040C86 FE      2653 CP      CR
040C87 0D 
040C88 28      2654 JR      Z,ASM0
040C89 E9 
040C8A 21      2655 LD      HL,LISTON
040C8B 40 
040C8C 4D 
040C8D 04 
040C8E 7E      2656 LD      A,(HL)
040C8F E6      2657 AND     0FH
040C90 0F 
040C91 F6      2658 OR      B0H
040C92 B0 
040C93 77      2659 LD      (HL),A
040C94 18      2660 JR      XEQR
040C95 D9 
               2661 ;
040C96 CD      2662 VAR_:			CALL    GETVAR
040C97 72 
040C98 3A 
040C99 04 
040C9A C8      2663 RET     Z
040C9B D2      2664 JP      NC,PUTVAR
040C9C 61 
040C9D 3A 
040C9E 04 
040C9F 3E      2665 SYNTAX:			LD      A,16            ;"Syntax error"
040CA0 10 
040CA1 18      2666 JR	ERROR0_EX
040CA2 02 
040CA3 3E      2667 ESCAPE:			LD      A,17            ;"Escape"
040CA4 11 
040CA5 C3      2668 ERROR0_EX:			JP      ERROR_
040CA6 98 
040CA7 37 
040CA8 04 
               2669 
               2670 ; =
               2671 ;
040CA9 CD      2672 FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CAA C7 
040CAB 01 
040CAC 04 
040CAD 43      2673 LD      B,E
040CAE EB      2674 EX      DE,HL
040CAF D9      2675 EXX                     ;SAVE RESULT
040CB0 EB      2676 EX      DE,HL           ; IN DEB'C'D'E'
040CB1 C1      2677 FNEND5:			POP     BC
040CB2 21      2678 LD      HL,LOCCHK
040CB3 8A 
040CB4 17 
040CB5 04 
040CB6 B7      2679 OR      A
040CB7 ED      2680 SBC     HL,BC
040CB8 42 
040CB9 28      2681 JR      Z,FNEND0        ;LOCAL VARIABLE
040CBA 1C 
040CBB 21      2682 LD      HL,FNCHK
040CBC 8C 
040CBD 10 
040CBE 04 
040CBF B7      2683 OR      A
040CC0 ED      2684 SBC     HL,BC
040CC1 42 
040CC2 3E      2685 LD      A,7
040CC3 07 
040CC4 20      2686 JR      NZ,ERROR0_EX       ;"No FN"
040CC5 DF 
040CC6 FD      2687 POP     IY
040CC7 E1 
040CC8 FD      2688 LD      (ERRLIN),IY     ;IN CASE OF ERROR
040CC9 22 
040CCA 35 
040CCB 4D 
040CCB 04   
040CCD EB      2689 EX      DE,HL
040CCE D9      2690 EXX
040CCF EB      2691 EX      DE,HL
040CD0 11      2692 LD      DE,ACCS
040CD1 00 
040CD2 4A 
040CD3 04 
040CD4 58      2693 LD      E,B
040CD5 08      2694 EX      AF,AF'
040CD6 C9      2695 RET
               2696 ;
040CD7 DD      2697 FNEND0:			POP     IX
040CD8 E1 
040CD9 C1      2698 POP     BC
040CDA 78      2699 LD      A,B
040CDB B7      2700 OR      A
040CDC FA      2701 JP      M,FNEND1        ;STRING
040CDD EA 
040CDE 0C 
040CDF 04 
040CE0 E1      2702 POP     HL
040CE1 D9      2703 EXX
040CE2 E1      2704 POP     HL
040CE3 D9      2705 EXX
040CE4 CD      2706 CALL    STORE
040CE5 08 
040CE6 16 
040CE7 04 
040CE8 18      2707 JR      FNEND5
040CE9 C7 
040CEA 21      2708 FNEND1:			LD      HL,0
040CEB 00 
040CEC 00 
040CED 00 
040CEE 39      2709 ADD     HL,SP
040CEF D5      2710 PUSH    DE
040CF0 59      2711 LD      E,C
040CF1 CD      2712 CALL    STORES
040CF2 36 
040CF3 16 
040CF4 04 
040CF5 D1      2713 POP     DE
040CF6 F9      2714 LD      SP,HL
040CF7 18      2715 JR      FNEND5
040CF8 B8 
               2716 
               2717 ; DIM var(dim1[,dim2[,...]])[,var(...]
               2718 ; DIM var expr[,var expr...]
               2719 ;
040CF9 CD      2720 DIM_EX:			CALL    GETVAR          	; Get the variable
040CFA 72 
040CFB 3A 
040CFC 04 
040CFD DA      2721 JP      C,BADDIM		; Throw a "Bad Dim" error
040CFE 89 
040CFF 0D 
040D00 04 
040D01 CA      2722 JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040D02 93 
040D03 0D 
040D04 04 
040D05 CD      2723 CALL    CREATE			; Create a new entity
040D06 E6 
040D07 3B 
040D08 04 
040D09 E5      2724 PUSH    HL			; HL: Address of the entity
040D0A DD      2725 POP     IX			; IX: Address of the entity
040D0B E1 
040D0C FD      2726 LD      A,(IY)			; Fetch the next character from the tokenised string
040D0D 7E 
040D0E 00 
040D0F FE      2727 CP      '('			; Check for opening brackets
040D10 28 
040D11 7A      2728 LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D12 20      2729 JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D13 7F 
               2730 ;
               2731 ; At this point we're reserving a variable array
               2732 ;
040D14 E5      2733 PUSH    HL			; HL: Address of the entity
040D15 F5      2734 PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D16 11      2735 LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D17 01 
040D18 00 
040D19 00 
040D1A 42      2736 LD      B,D			;  B: The number of dimensions in the array
               2737 ;
040D1B FD      2738 DIM1:			INC     IY			; Skip to the next token
040D1C 23 
040D1D C5      2739 PUSH    BC			; Stack the dimension counter
040D1E D5      2740 PUSH    DE			; Stack the total size of array accumulator
040D1F DD      2741 PUSH    IX			; Stack the entity address
040D20 E5 
040D21 CD      2742 CALL    EXPRI           	; Fetch the size of this dimension
040D22 0F 
040D23 03 
040D24 04 
040D25 CB      2743 BIT     7,H			; If it is negative then
040D26 7C 
040D27 20      2744 JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D28 60 
040D29 D9      2745 EXX
040D2A 23      2746 INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D2B DD      2747 POP     IX			; IX: The entity address
040D2C E1 
040D2D DD      2748 INC     IX
040D2E 23 
040D2F DD      2749 LD      (IX),L          	; Save the size of this dimension in the entity
040D30 75 
040D31 00 
040D32 DD      2750 INC     IX
040D33 23 
040D34 DD      2751 LD      (IX),H
040D35 74 
040D36 00 
040D37 C1      2752 POP     BC
040D38 CD      2753 CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D39 A4 
040D3A 18 
040D3B 04 
040D3C 38      2754 JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D3D 4F 
040D3E EB      2755 EX      DE,HL           	; DE: The new total size of array accumulator
040D3F C1      2756 POP     BC
040D40 04      2757 INC     B               	;  B: The dimension counter; increment
040D41 FD      2758 LD      A,(IY)			; Fetch the nex token
040D42 7E 
040D43 00 
040D44 FE      2759 CP      ','             	; Check for another dimension in the array
040D45 2C 
040D46 28      2760 JR      Z,DIM1			; And loop
040D47 D3 
               2761 ;
040D48 CD      2762 CALL    BRAKET          	; Check for closing bracket
040D49 37 
040D4A 0A 
040D4B 04 
040D4C F1      2763 POP     AF              	; Restore the type
040D4D DD      2764 INC     IX
040D4E 23 
040D4F DD      2765 EX      (SP),IX
040D50 E3 
040D51 DD      2766 LD      (IX),B          	; Number of dimensions
040D52 70 
040D53 00 
040D54 CD      2767 CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D55 97 
040D56 18 
040D57 04 
040D58 E1      2768 POP     HL			; Restore the entity address
040D59 38      2769 JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D5A 32 
               2770 ;
               2771 ; We now allocate the memory for the array
               2772 ;
040D5B 19      2773 DIM3:			ADD     HL,DE
040D5C 38      2774 JR      C,NOROOM
040D5D 2F 
040D5E E5      2775 PUSH    HL
040D5F 24      2776 INC     H
040D60 28      2777 JR      Z,NOROOM
040D61 2B 
040D62 ED      2778 SBC     HL,SP
040D63 72 
040D64 30      2779 JR      NC,NOROOM       	; Throw an "Out of Space" error
040D65 27 
040D66 E1      2780 POP     HL
040D67 22      2781 LD      (FREE),HL
040D68 1D 
040D69 4D 
040D6A 04 
040D6B 7A      2782 DIM2:			LD      A,D
040D6C B3      2783 OR      E
040D6D 28      2784 JR      Z,DIM5
040D6E 06 
040D6F 2B      2785 DEC     HL
040D70 36      2786 LD      (HL),0         		; Initialise the array
040D71 00 
040D72 1B      2787 DEC     DE
040D73 18      2788 JR      DIM2
040D74 F6 
040D75 CD      2789 DIM5:			CALL    NXT
040D76 78 
040D77 0A 
040D78 04 
040D79 FE      2790 CP      ','            		; Another variable?
040D7A 2C 
040D7B C2      2791 JP      NZ,XEQ
040D7C 9E 
040D7D 0B 
040D7E 04 
040D7F FD      2792 INC     IY
040D80 23 
040D81 CD      2793 CALL    NXT
040D82 78 
040D83 0A 
040D84 04 
040D85 C3      2794 JP      DIM_EX
040D86 F9 
040D87 0C 
040D88 04 
               2795 ;
               2796 ; DIM errors
               2797 ;
040D89 3E      2798 BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D8A 0A 
040D8B 18      2799 JR	ERROR1_EX
040D8C 02 
040D8D 3E      2800 NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D8E 0B 
040D8F C3      2801 ERROR1_EX:			JP      ERROR_
040D90 98 
040D91 37 
040D92 04 
               2802 ;
               2803 ; At this point we're reserving a block of memory, i.e.
               2804 ; DIM var expr[,var expr...]
               2805 ;
040D93 B7      2806 DIM4:			OR      A			;  A: The dimension variable type
040D94 28      2807 JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D95 F3 
040D96 FA      2808 JP      M,BADDIM        	; or a string
040D97 89 
040D98 0D 
040D99 04 
040D9A 47      2809 LD      B,A			; Temporarily store the dimension variable type in B
040D9B FD      2810 LD      A,(IY-1)		; Get the last character but one
040D9C 7E 
040D9D FF 
040D9E FE      2811 CP      ')'			; Check if it is a trailing bracket
040D9F 29 
040DA0 28      2812 JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040DA1 E7 
               2813 ;
040DA2 21      2814 LD	HL,0			; Clear HL
040DA3 00 
040DA4 00 
040DA5 00 
040DA6 3A      2815 LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DA7 1D 
040DA8 4D 
040DA9 04 
040DAA 6F      2816 LD	L,A
040DAB 3A      2817 LD	A,(FREE+1)
040DAC 1E 
040DAD 4D 
040DAE 04 
040DAF 67      2818 LD	H,A
040DB0 78      2819 LD	A,B			; Restore the dimension variable type
040DB1 D9      2820 EXX
040DB2 21      2821 LD	HL,0			; Clear HL
040DB3 00 
040DB4 00 
040DB5 00 
040DB6 47      2822 LD	B,A			; Temporarily store the dimension variable type in B
040DB7 3A      2823 LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB8 1F 
040DB9 4D 
040DBA 04 
040DBB 6F      2824 LD	L,A
040DBC 78      2825 LD	A,B			; Restore the dimension variable type
040DBD 4C      2826 LD	C,H
040DBE CD      2827 CALL    STORE           	; Store the address
040DBF 08 
040DC0 16 
040DC1 04 
040DC2 CD      2828 CALL    EXPRI			; Get the number of bytes to store
040DC3 0F 
040DC4 03 
040DC5 04 
040DC6 D9      2829 EXX
040DC7 23      2830 INC     HL			; Add one to it
040DC8 EB      2831 EX      DE,HL
040DC9 2A      2832 LD      HL,(FREE)
040DCA 1D 
040DCB 4D 
040DCC 04 
040DCD 18      2833 JR      DIM3			; Continue with the DIM
040DCE 8C 
               2834 
               2835 ; PRINT list...
               2836 ; PRINT #channel,list...
               2837 ;
040DCF FE      2838 PRINT_:			CP      '#'
040DD0 23 
040DD1 20      2839 JR      NZ,PRINT0
040DD2 7C 
040DD3 CD      2840 CALL    CHNL            ;CHANNEL NO. = E
040DD4 C4 
040DD5 18 
040DD6 04 
040DD7 CD      2841 PRNTN1:			CALL    NXT
040DD8 78 
040DD9 0A 
040DDA 04 
040DDB FE      2842 CP      ','
040DDC 2C 
040DDD C2      2843 JP      NZ,XEQ
040DDE 9E 
040DDF 0B 
040DE0 04 
040DE1 FD      2844 INC     IY
040DE2 23 
040DE3 D5      2845 PUSH    DE
040DE4 CD      2846 CALL    EXPR            ;ITEM TO PRINT
040DE5 C7 
040DE6 01 
040DE7 04 
040DE8 08      2847 EX      AF,AF'
040DE9 FA      2848 JP      M,PRNTN2        ;STRING
040DEA 0F 
040DEB 0E 
040DEC 04 
040DED D1      2849 POP     DE
040DEE C5      2850 PUSH    BC
040DEF D9      2851 EXX
040DF0 7D      2852 LD      A,L
040DF1 D9      2853 EXX
040DF2 CD      2854 CALL    OSBPUT
040DF3 84 
040DF4 43 
040DF5 04 
040DF6 D9      2855 EXX
040DF7 7C      2856 LD      A,H
040DF8 D9      2857 EXX
040DF9 CD      2858 CALL    OSBPUT
040DFA 84 
040DFB 43 
040DFC 04 
040DFD 7D      2859 LD      A,L
040DFE CD      2860 CALL    OSBPUT
040DFF 84 
040E00 43 
040E01 04 
040E02 7C      2861 LD      A,H
040E03 CD      2862 CALL    OSBPUT
040E04 84 
040E05 43 
040E06 04 
040E07 C1      2863 POP     BC
040E08 79      2864 LD      A,C
040E09 CD      2865 CALL    OSBPUT
040E0A 84 
040E0B 43 
040E0C 04 
040E0D 18      2866 JR      PRNTN1
040E0E C8 
040E0F 4B      2867 PRNTN2:			LD      C,E
040E10 D1      2868 POP     DE
040E11 21      2869 LD      HL,ACCS
040E12 00 
040E13 4A 
040E14 04 
040E15 0C      2870 INC     C
040E16 0D      2871 PRNTN3:			DEC     C
040E17 28      2872 JR      Z,PRNTN4
040E18 0A 
040E19 7E      2873 LD      A,(HL)
040E1A 23      2874 INC     HL
040E1B C5      2875 PUSH    BC
040E1C CD      2876 CALL    OSBPUT
040E1D 84 
040E1E 43 
040E1F 04 
040E20 C1      2877 POP     BC
040E21 18      2878 JR      PRNTN3
040E22 F3 
040E23 3E      2879 PRNTN4:			LD      A,CR
040E24 0D 
040E25 CD      2880 CALL    OSBPUT
040E26 84 
040E27 43 
040E28 04 
040E29 18      2881 JR      PRNTN1
040E2A AC 
               2882 ;
040E2B 06      2883 PRINT6:			LD      B,2
040E2C 02 
040E2D 18      2884 JR      PRINTC
040E2E 27 
040E2F 01      2885 PRINT8:			LD      BC,100H
040E30 00 
040E31 01 
040E32 00 
040E33 18      2886 JR      PRINTC
040E34 21 
040E35 21      2887 PRINT9:			LD      HL,STAVAR
040E36 00 
040E37 4C 
040E38 04 
040E39 AF      2888 XOR     A
040E3A BE      2889 CP      (HL)
040E3B 28      2890 JR      Z,PRINT0
040E3C 12 
040E3D 3A      2891 LD      A,(COUNT)
040E3E 3D 
040E3F 4D 
040E40 04 
040E41 B7      2892 OR      A
040E42 28      2893 JR      Z,PRINT0
040E43 0B 
040E44 96      2894 PRINTA:			SUB     (HL)
040E45 28      2895 JR      Z,PRINT0
040E46 08 
040E47 30      2896 JR      NC,PRINTA
040E48 FB 
040E49 ED      2897 NEG
040E4A 44 
040E4B CD      2898 CALL    FILL
040E4C 21 
040E4D 18 
040E4E 04 
040E4F 3A      2899 PRINT0:			LD      A,(STAVAR)
040E50 00 
040E51 4C 
040E52 04 
040E53 4F      2900 LD      C,A             ;PRINTS
040E54 06      2901 LD      B,0             ;PRINTF
040E55 00 
040E56 CD      2902 PRINTC:			CALL    TERMQ
040E57 AC 
040E58 17 
040E59 04 
040E5A 28      2903 JR      Z,PRINT4
040E5B 3F 
040E5C CB      2904 RES     0,B
040E5D 80 
040E5E FD      2905 INC     IY
040E5F 23 
040E60 FE      2906 CP      '~'
040E61 7E 
040E62 28      2907 JR      Z,PRINT6
040E63 C7 
040E64 FE      2908 CP      ';'
040E65 3B 
040E66 28      2909 JR      Z,PRINT8
040E67 C7 
040E68 FE      2910 CP      ','
040E69 2C 
040E6A 28      2911 JR      Z,PRINT9
040E6B C9 
040E6C CD      2912 CALL    FORMAT          ;SPC, TAB, '
040E6D D1 
040E6E 17 
040E6F 04 
040E70 28      2913 JR      Z,PRINTC
040E71 E4 
040E72 FD      2914 DEC     IY
040E73 2B 
040E74 C5      2915 PUSH    BC
040E75 CD      2916 CALL    EXPR            ;VARIABLE TYPE
040E76 C7 
040E77 01 
040E78 04 
040E79 08      2917 EX      AF,AF'
040E7A FA      2918 JP      M,PRINT3        ;STRING
040E7B 94 
040E7C 0E 
040E7D 04 
040E7E D1      2919 POP     DE
040E7F D5      2920 PUSH    DE
040E80 CB      2921 BIT     1,D
040E81 4A 
040E82 F5      2922 PUSH    AF
040E83 CC      2923 CALL    Z,STR           ;DECIMAL
040E84 6B 
040E85 09 
040E86 04 
040E87 F1      2924 POP     AF
040E88 C4      2925 CALL    NZ,HEXSTR       ;HEX
040E89 1F 
040E8A 09 
040E8B 04 
040E8C C1      2926 POP     BC
040E8D C5      2927 PUSH    BC
040E8E 79      2928 LD      A,C
040E8F 93      2929 SUB     E
040E90 D4      2930 CALL    NC,FILL         ;RIGHT JUSTIFY
040E91 21 
040E92 18 
040E93 04 
040E94 C1      2931 PRINT3:			POP     BC
040E95 CD      2932 CALL    PTEXT           ;PRINT
040E96 30 
040E97 18 
040E98 04 
040E99 18      2933 JR      PRINTC
040E9A BB 
040E9B CB      2934 PRINT4:			BIT     0,B
040E9C 40 
040E9D CC      2935 CALL    Z,CRLF
040E9E 7F 
040E9F 39 
040EA0 04 
040EA1 C3      2936 JP      XEQ
040EA2 9E 
040EA3 0B 
040EA4 04 
               2937 
               2938 ; ON ERROR statement [:statement...]
               2939 ; ON ERROR OFF
               2940 ;
040EA5 FD      2941 ONERR:			INC     IY              ;SKIP "ERROR"
040EA6 23 
040EA7 21      2942 LD      HL,0
040EA8 00 
040EA9 00 
040EAA 00 
040EAB 22      2943 LD      (ERRTRP),HL
040EAC 2C 
040EAD 4D 
040EAE 04 
040EAF CD      2944 CALL    NXT
040EB0 78 
040EB1 0A 
040EB2 04 
040EB3 FE      2945 CP      OFF_
040EB4 87 
040EB5 FD      2946 INC     IY
040EB6 23 
040EB7 CA      2947 JP      Z,XEQ
040EB8 9E 
040EB9 0B 
040EBA 04 
040EBB FD      2948 DEC     IY
040EBC 2B 
040EBD FD      2949 LD      (ERRTRP),IY
040EBE 22 
040EBF 2C 
040EC0 4D 
040EC0 04   
040EC2 C3      2950 JP      REM_EX
040EC3 33 
040EC4 0C 
040EC5 04 
               2951 
               2952 ; ON expr GOTO line[,line...] [ELSE statement]
               2953 ; ON expr GOTO line[,line...] [ELSE line]
               2954 ; ON expr GOSUB line[,line...] [ELSE statement]
               2955 ; ON expr GOSUB line[,line...] [ELSE line]
               2956 ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
               2957 ;
040EC6 FE      2958 ON_EX_:			CP      TERROR_EX
040EC7 85 
040EC8 28      2959 JR      Z,ONERR         ;"ON ERROR"
040EC9 DB 
040ECA CD      2960 CALL    EXPRI
040ECB 0F 
040ECC 03 
040ECD 04 
040ECE FD      2961 LD      A,(IY)
040ECF 7E 
040ED0 00 
040ED1 FD      2962 INC     IY
040ED2 23 
040ED3 1E      2963 LD      E,','           ;SEPARATOR
040ED4 2C 
040ED5 FE      2964 CP      TGOTO
040ED6 E5 
040ED7 28      2965 JR      Z,ON1
040ED8 0B 
040ED9 FE      2966 CP      TGOSUB
040EDA E4 
040EDB 28      2967 JR      Z,ON1
040EDC 07 
040EDD 1E      2968 LD      E,TPROC
040EDE F2 
040EDF BB      2969 CP      E
040EE0 3E      2970 LD      A,39
040EE1 27 
040EE2 20      2971 JR      NZ,ERROR2_EX       ;"ON syntax"
040EE3 45 
040EE4 57      2972 ON1:			LD      D,A
040EE5 D9      2973 EXX
040EE6 E5      2974 PUSH    HL
040EE7 D9      2975 EXX
040EE8 C1      2976 POP     BC              ;ON INDEX
040EE9 78      2977 LD      A,B
040EEA B4      2978 OR      H
040EEB B5      2979 OR      L
040EEC 20      2980 JR      NZ,ON4          ;OUT OF RANGE
040EED 2A 
040EEE B1      2981 OR      C
040EEF 28      2982 JR      Z,ON4
040EF0 27 
040EF1 0D      2983 DEC     C
040EF2 28      2984 JR      Z,ON3           ;INDEX=1
040EF3 0E 
040EF4 CD      2985 ON2:			CALL    TERMQ
040EF5 AC 
040EF6 17 
040EF7 04 
040EF8 28      2986 JR      Z,ON4           ;OUT OF RANGE
040EF9 1E 
040EFA FD      2987 INC     IY              ;SKIP DELIMITER
040EFB 23 
040EFC BB      2988 CP      E
040EFD 20      2989 JR      NZ,ON2
040EFE F5 
040EFF 0D      2990 DEC     C
040F00 20      2991 JR      NZ,ON2
040F01 F2 
040F02 7B      2992 ON3:			LD      A,E
040F03 FE      2993 CP      TPROC
040F04 F2 
040F05 28      2994 JR      Z,ONPROC
040F06 26 
040F07 D5      2995 PUSH    DE
040F08 CD      2996 CALL    ITEMI           ;LINE NUMBER
040F09 2A 
040F0A 03 
040F0B 04 
040F0C D1      2997 POP     DE
040F0D 7A      2998 LD      A,D
040F0E FE      2999 CP      TGOTO
040F0F E5 
040F10 28      3000 JR      Z,GOTO2
040F11 2D 
040F12 CD      3001 CALL    SPAN            ;SKIP REST OF LIST
040F13 B9 
040F14 17 
040F15 04 
040F16 18      3002 JR      GOSUB1
040F17 3B 
               3003 ;
040F18 FD      3004 ON4:			LD      A,(IY)
040F19 7E 
040F1A 00 
040F1B FD      3005 INC     IY
040F1C 23 
040F1D FE      3006 CP      ELSE_EX_
040F1E 8B 
040F1F CA      3007 JP      Z,IF1           ;ELSE CLAUSE
040F20 53 
040F21 13 
040F22 04 
040F23 FE      3008 CP      CR
040F24 0D 
040F25 20      3009 JR      NZ,ON4
040F26 F1 
040F27 3E      3010 LD      A,40
040F28 28 
040F29 C3      3011 ERROR2_EX:			JP      ERROR_           ;"ON range"
040F2A 98 
040F2B 37 
040F2C 04 
               3012 ;
040F2D 3E      3013 ONPROC:			LD      A,TON
040F2E EE 
040F2F C3      3014 JP      PROC_EX
040F30 8C 
040F31 10 
040F32 04 
               3015 
               3016 ; GOTO line
               3017 ;
040F33 CD      3018 GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F34 2A 
040F35 03 
040F36 04 
040F37 CD      3019 GOTO1:			CALL    TERMQ			; Check for terminator
040F38 AC 
040F39 17 
040F3A 04 
040F3B C2      3020 JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F3C 9F 
040F3D 0C 
040F3E 04 
040F3F D9      3021 GOTO2:			EXX
040F40 CD      3022 CALL    FINDL			; HL: Line number - Find the line
040F41 C7 
040F42 39 
040F43 04 
040F44 E5      3023 PUSH    HL			; HL: Address of the line
040F45 FD      3024 POP     IY			; IY = HL
040F46 E1 
040F47 CA      3025 JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F48 9A 
040F49 0B 
040F4A 04 
040F4B 3E      3026 LD      A,41			; Otherwise throw a "No such line" error
040F4C 29 
040F4D 18      3027 JR      ERROR2_EX
040F4E DA 
               3028 
               3029 ; GOSUB line
               3030 ; This pushes the following data onto the execution stack
               3031 ; - 3 bytes: Current execution address
               3032 ; - 3 bytes: Marker (the address of label GOSCHK)
               3033 ;
040F4F CD      3034 GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F50 2A 
040F51 03 
040F52 04 
040F53 FD      3035 GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F54 E5 
040F55 CD      3036 CALL    CHECK           	; Check there is enough room
040F56 81 
040F57 16 
040F58 04 
040F59 CD      3037 CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F5A 37 
040F5B 0F 
040F5C 04 
               3038 GOSCHK:			EQU     $
               3039 
               3040 ; RETURN
               3041 ; This pops the following data off the execution stack as pushed by GOSUB
               3042 ; - 3 bytes: Marker (should be the address of label GOSCHK)
               3043 ; - 3 bytes: The return execution address
               3044 ;
040F5D D1      3045 RETURN:			POP     DE			; Pop the marker off the execution stack
040F5E 21      3046 LD      HL,GOSCHK		; Compare with GOSCHK
040F5F 5D 
040F60 0F 
040F61 04 
040F62 B7      3047 OR      A
040F63 ED      3048 SBC     HL,DE
040F64 52 
040F65 FD      3049 POP     IY			; Pop the return address off the execution stack
040F66 E1 
040F67 CA      3050 JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F68 9E 
040F69 0B 
040F6A 04 
040F6B 3E      3051 LD      A,38			; Otherwise throw a "No GOSUB" error
040F6C 26 
040F6D 18      3052 JR      ERROR2_EX
040F6E BA 
               3053 
               3054 ; REPEAT
               3055 ; This pushes the following data onto the execution stack
               3056 ; - 3 bytes: Current execution address
               3057 ; - 3 bytes: Marker (the address of label REPCHK)
               3058 ;
040F6F FD      3059 REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F70 E5 
040F71 CD      3060 CALL    CHECK			; Check if there is enough room
040F72 81 
040F73 16 
040F74 04 
040F75 CD      3061 CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F76 9E 
040F77 0B 
040F78 04 
               3062 REPCHK:			EQU     $
               3063 
               3064 ; UNTIL expr
               3065 ; This pops the following data off the execution stack
               3066 ; - 3 bytes: Marker (should be the address of label REPCHK)
               3067 ; - 3 bytes: The address of the REPEAT instruction
               3068 ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
               3069 ;
040F79 C1      3070 UNTIL_EX:			POP     BC			; Fetch the marker
040F7A C5      3071 PUSH    BC			; And push it back onto the execution stack
040F7B 21      3072 LD      HL,REPCHK		; Compare with REPCHK
040F7C 79 
040F7D 0F 
040F7E 04 
040F7F B7      3073 OR      A
040F80 ED      3074 SBC     HL,BC
040F81 42 
040F82 3E      3075 LD      A,43
040F83 2B 
040F84 20      3076 JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F85 A3 
040F86 CD      3077 CALL    EXPRI			; Fetch the expression
040F87 0F 
040F88 03 
040F89 04 
040F8A CD      3078 CALL    TEST			; Test if the expression evaluates to zero
040F8B E4 
040F8C 08 
040F8D 04 
040F8E C1      3079 POP     BC			; Pop the marker
040F8F D1      3080 POP     DE			; Pop the address of the REPEAT instruction
040F90 20      3081 JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F91 05 
040F92 D5      3082 PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F93 C5      3083 PUSH    BC			; Push the marker back on the stack
040F94 D5      3084 PUSH    DE			; IY = DE
040F95 FD      3085 POP     IY			; This sets the execution address back to the REPEAT instruction
040F96 E1 
040F97 C3      3086 XEQ2:			JP      XEQ			; Continue execution
040F98 9E 
040F99 0B 
040F9A 04 
               3087 
               3088 ; FOR var = expr TO expr [STEP expr]
               3089 ; This pushes the following data onto the execution stack
               3090 ; - 3 bytes: The limit value
               3091 ; - 3 bytes: The step value
               3092 ; - 3 bytes: The current execution address
               3093 ; - 3 bytes: The address of the loop variable
               3094 ; - 3 bytes: Marker (the address of FORCHK)
               3095 ;
040F9B 3E      3096 FORVAR:			LD      A,34
040F9C 22 
040F9D 18      3097 JR      ERROR2_EX          	; Throw "FOR variable" error
040F9E 8A 
               3098 ;
040F9F CD      3099 FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040FA0 F0 
040FA1 15 
040FA2 04 
040FA3 20      3100 JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040FA4 F6 
040FA5 F5      3101 PUSH    AF              	; Save the variable type
040FA6 FD      3102 LD      A,(IY)			; Check the next token
040FA7 7E 
040FA8 00 
040FA9 FE      3103 CP      TO_EX			; Compare with the token value for "TO"
040FAA B8 
040FAB 3E      3104 LD      A,36			; Set the error code to 36 ("No TO")
040FAC 24 
040FAD C2      3105 JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FAE 29 
040FAF 0F 
040FB0 04 
040FB1 FD      3106 INC     IY			; Skip to the next token
040FB2 23 
               3107 ;
040FB3 DD      3108 PUSH    IX
040FB4 E5 
040FB5 CD      3109 CALL    EXPRN           	; Fetch the LIMIT expression value
040FB6 07 
040FB7 03 
040FB8 04 
040FB9 DD      3110 POP     IX
040FBA E1 
040FBB F1      3111 POP     AF
040FBC 47      3112 LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FBD C5      3113 PUSH    BC              	; Stack the LIMIT value
040FBE E5      3114 PUSH    HL
040FBF 21      3115 LD      HL,0
040FC0 00 
040FC1 00 
040FC2 00 
040FC3 4C      3116 LD      C,H
040FC4 D9      3117 EXX
040FC5 E5      3118 PUSH    HL
               3119 ;
040FC6 21      3120 LD      HL,1            	; The preset STEP value is 1
040FC7 01 
040FC8 00 
040FC9 00 
040FCA D9      3121 EXX
040FCB FD      3122 LD      A,(IY)			; Fetch the next token
040FCC 7E 
040FCD 00 
040FCE FE      3123 CP      STEP			; Compare with the token value for "STEP"
040FCF 88 
040FD0 20      3124 JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FD1 0A 
               3125 ;
040FD2 FD      3126 INC     IY			; Skip past the STEP token
040FD3 23 
040FD4 DD      3127 PUSH    IX
040FD5 E5 
040FD6 CD      3128 CALL    EXPRN          		; Fetch the STEP expression value
040FD7 07 
040FD8 03 
040FD9 04 
040FDA DD      3129 POP     IX
040FDB E1 
               3130 ;
040FDC C5      3131 FOR1:			PUSH    BC			; Stack the STEP value
040FDD E5      3132 PUSH    HL
040FDE D9      3133 EXX
040FDF E5      3134 PUSH    HL
040FE0 D9      3135 EXX
               3136 ;
040FE1 FD      3137 PUSH    IY              	; Stack the current execution address
040FE2 E5 
040FE3 DD      3138 PUSH    IX              	; Stack the loop variable
040FE4 E5 
040FE5 CD      3139 CALL    CHECK
040FE6 81 
040FE7 16 
040FE8 04 
040FE9 CD      3140 CALL    XEQ
040FEA 9E 
040FEB 0B 
040FEC 04 
               3141 FORCHK:			EQU     $
               3142 
               3143 ; NEXT [var[,var...]]
               3144 ; This pops the following data off the execution stack
               3145 ; - 3 bytes: Marker (the address of FORCHK)
               3146 ; - 3 bytes: The address of the loop variable
               3147 ; - 3 bytes: The current execution address
               3148 ; - 3 bytes: The step value
               3149 ; - 3 bytes: The limit value
               3150 ; It also ensures that the data is pushed back on for subsequent NEXT instructions
               3151 ;
040FED C1      3152 NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FEE 21      3153 LD      HL,FORCHK		; Compare with FORCHK
040FEF ED 
040FF0 0F 
040FF1 04 
040FF2 B7      3154 OR      A
040FF3 ED      3155 SBC     HL,BC
040FF4 42 
040FF5 3E      3156 LD      A,32
040FF6 20 
040FF7 C2      3157 JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF8 83 
040FF9 10 
040FFA 04 
040FFB CD      3158 CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FFC AC 
040FFD 17 
040FFE 04 
040FFF E1      3159 POP     HL			; Pop the address of the loop variable off the execution stack
041000 E5      3160 PUSH    HL			; Push it back onto the execution stack
041001 C5      3161 PUSH    BC			; Push the marker back onto the execution stack
041002 E5      3162 PUSH    HL			; HL: Address of the loop variable off the stack
041003 C4      3163 CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041004 72 
041005 3A 
041006 04 
041007 D1      3164 POP     DE			; DE: Address of the loop variable off the stack
041008 EB      3165 EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041009 B7      3166 OR      A
04100A ED      3167 NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
04100B 52 
04100C 20      3168 JR      NZ,NEXT1		; They don't, so jump to NEXT1
04100D 61 
04100E D5      3169 PUSH    DE
04100F DD      3170 LD      IX,9+3			; IX: Address of the STEP value on the execution stack
041010 21 
041011 0C 
041012 00 
041012 00   
041014 DD      3171 ADD     IX,SP
041015 39 
041016 CD      3172 CALL    DLOAD5_SPL      	; Load the STEP value
041017 19 
041018 2A 
041019 04 
04101A DD      3173 LD      A,(IX+16)       	; Get the STEP type
04101B 7E 
04101C 10 
04101D DD      3174 POP     IX
04101E E1 
04101F CD      3175 CALL    LOADN           	; Load the LOOP variable
041020 1B 
041021 04 
041022 04 
041023 CB      3176 BIT     7,D             	; Check the sign
041024 7A 
041025 F5      3177 PUSH    AF
041026 3E      3178 LD      A,'+' & 0FH
041027 0B 
041028 CD      3179 CALL    FPP             	; Add the STEP
041029 A2 
04102A 20 
04102B 04 
04102C 38      3180 JR      C,ERROR3_EX
04102D 55 
04102E F1      3181 POP     AF              	; Restore TYPE
04102F F5      3182 PUSH    AF
041030 CD      3183 CALL    STORE           	; Update the variable
041031 08 
041032 16 
041033 04 
041034 DD      3184 LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
041035 21 
041036 15 
041037 00 
041037 00   
041039 DD      3185 ADD     IX,SP
04103A 39 
04103B CD      3186 CALL    DLOAD5_SPL      	; Load the LIMIT value
04103C 19 
04103D 2A 
04103E 04 
04103F F1      3187 POP     AF
041040 CC      3188 CALL    Z,SWAP			; Swap the arguments if the sign is ?
041041 DC 
041042 08 
041043 04 
               3189 ; LD      A,0+('<'-4) & 0FH
041044 3E      3190 LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041045 08 
041046 CD      3191 CALL    FPP             	; Test against the limit
041047 A2 
041048 20 
041049 04 
04104A 38      3192 JR      C,ERROR3_EX		; Throw an error if FPP returns bad
04104B 37 
04104C 24      3193 INC     H
04104D 20      3194 JR      NZ,LOOP_        	; Keep looping
04104E 14 
04104F 21      3195 LD      HL,27			; Adjust the stack
041050 1B 
041051 00 
041052 00 
041053 39      3196 ADD     HL,SP
041054 F9      3197 LD      SP,HL
041055 CD      3198 CALL    NXT
041056 78 
041057 0A 
041058 04 
041059 FE      3199 CP      ','			; Check for multiple variables
04105A 2C 
04105B C2      3200 JP      NZ,XEQ			; No, so we are done at ths point
04105C 9E 
04105D 0B 
04105E 04 
04105F FD      3201 INC     IY			; Increment to the next variable
041060 23 
041061 18      3202 JR      NEXT_EX			; And continue
041062 8A 
               3203 ;
041063 C1      3204 LOOP_:			POP     BC
041064 D1      3205 POP     DE
041065 FD      3206 POP     IY
041066 E1 
041067 FD      3207 PUSH    IY
041068 E5 
041069 D5      3208 PUSH    DE
04106A C5      3209 PUSH    BC
04106B C3      3210 JP      XEQ
04106C 9E 
04106D 0B 
04106E 04 
               3211 ;
04106F 21      3212 NEXT1:			LD      HL,27			; TODO: What does this do?
041070 1B 
041071 00 
041072 00 
041073 39      3213 ADD     HL,SP
041074 F9      3214 LD      SP,HL			; Adjust the stack
041075 C1      3215 POP     BC
041076 21      3216 LD      HL,FORCHK
041077 ED 
041078 0F 
041079 04 
04107A ED      3217 SBC     HL,BC
04107B 42 
04107C E1      3218 POP     HL              	; Variable pointer
04107D E5      3219 PUSH    HL
04107E C5      3220 PUSH    BC
04107F 28      3221 JR      Z,NEXT0
041080 89 
               3222 ;
041081 3E      3223 LD      A,33
041082 21 
041083 C3      3224 ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041084 98 
041085 37 
041086 04 
               3225 
               3226 ; FNname
               3227 ; N.B. ENTERED WITH A <> TON
               3228 ;
041087 F5      3229 FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041088 CD      3230 CALL    PROC1
041089 91 
04108A 10 
04108B 04 
               3231 FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3232 
               3233 ; PROCname
               3234 ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
               3235 ; This pushes the following data onto the execution stack
               3236 ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
               3237 ; - 3 bytes: Marker (the address of PROCHK)
               3238 ;
04108C F5      3239 PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
04108D CD      3240 CALL    PROC1			; and is also space reserved on the stack for the return address
04108E 91 
04108F 10 
041090 04 
               3241 PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
               3242 ;
041091 CD      3243 PROC1:			CALL    CHECK			; Check there is space for this
041092 81 
041093 16 
041094 04 
041095 FD      3244 DEC     IY			; Decrement IY to the PROC token
041096 2B 
041097 FD      3245 PUSH    IY			; Stack the pointer
041098 E5 
041099 CD      3246 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
04109A 33 
04109B 3B 
04109C 04 
04109D C1      3247 POP     BC			; BC = IY
04109E 28      3248 JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
04109F 41 
0410A0 3E      3249 LD      A,30
0410A1 1E 
0410A2 38      3250 JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0410A3 DF 
               3251 ;
               3252 ; At this point the PROC/FN has not yet been registered in the dynamic area
               3253 ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
               3254 ;
0410A4 C5      3255 PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0410A5 2A      3256 LD      HL,(PAGE_)		; HL: Start of program memory
0410A6 14 
0410A7 4D 
0410A8 04 
               3257 ;
0410A9 3E      3258 PROC2:			LD      A,DEF_			;  A: The token to search for
0410AA DD 
0410AB CD      3259 CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410AC 80 
0410AD 18 
0410AE 04 
0410AF 38      3260 JR      C,PROC3			; Not found, so jump to PROC3
0410B0 26 
0410B1 E5      3261 PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410B2 FD      3262 POP     IY			; IY = HL
0410B3 E1 
0410B4 FD      3263 INC     IY              	; Skip the DEF token
0410B5 23 
0410B6 CD      3264 CALL    NXT			; And any whitespace
0410B7 78 
0410B8 0A 
0410B9 04 
0410BA CD      3265 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410BB 33 
0410BC 3B 
0410BD 04 
0410BE FD      3266 PUSH    IY
0410BF E5 
0410C0 D1      3267 POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410C1 38      3268 JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410C2 09 
0410C3 C4      3269 CALL    NZ,CREATE		; Create an entity in the dynamic area
0410C4 E6 
0410C5 3B 
0410C6 04 
0410C7 FD      3270 PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C8 E5 
0410C9 D1      3271 POP     DE			; DE = IY
0410CA ED      3272 LD	(HL),DE			; Save address
0410CB 1F 
               3273 ;
0410CC EB      3274 PROC6:			EX      DE,HL			; HL: Address of the procedure
0410CD 3E      3275 LD      A,CR			; The character to search for
0410CE 0D 
0410CF 01      3276 LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410D0 00 
0410D1 01 
0410D2 00 
0410D3 ED      3277 CPIR                    	; Skip to next line
0410D4 B1 
0410D5 18      3278 JR      PROC2			; Rinse, lather and repeat
0410D6 D2 
               3279 ;
               3280 ; At this point a DEF has not been found for the PROC/FN
               3281 ;
0410D7 FD      3282 PROC3:			POP     IY              	; Restore the execution address
0410D8 E1 
0410D9 CD      3283 CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410DA 33 
0410DB 3B 
0410DC 04 
0410DD 3E      3284 LD      A,29
0410DE 1D 
0410DF 20      3285 JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410E0 A2 
               3286 ;
               3287 ; At this point we have a PROC/FN entry in the dynamic area
               3288 ;
0410E1 ED      3289 PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410E2 17 
0410E3 21      3290 LD	HL,3
0410E4 03 
0410E5 00 
0410E6 00 
0410E7 39      3291 ADD     HL,SP
0410E8 CD      3292 CALL    NXT             	; Allow space before "("
0410E9 78 
0410EA 0A 
0410EB 04 
0410EC D5      3293 PUSH    DE              	; Exchange DE and IY
0410ED FD      3294 EX      (SP),IY
0410EE E3 
0410EF FE      3295 CP      '('             	; Arguments?
0410F0 28 
0410F1 D1      3296 POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410F2 20      3297 JR      NZ,PROC5
0410F3 20 
0410F4 CD      3298 CALL    NXT             	; Allow space before "("
0410F5 78 
0410F6 0A 
0410F7 04 
0410F8 FE      3299 CP      '('
0410F9 28 
0410FA C2      3300 JP      NZ,SYNTAX       	; Throw "Syntax error"
0410FB 9F 
0410FC 0C 
0410FD 04 
0410FE FD      3301 PUSH    IY
0410FF E5 
041100 C1      3302 POP     BC              	; Save IY in BC
041101 D9      3303 EXX
041102 CD      3304 CALL    SAVLOC          	; Save local parameters
041103 2C 
041104 17 
041105 04 
041106 CD      3305 CALL    BRAKET          	; Closing bracket
041107 37 
041108 0A 
041109 04 
04110A D9      3306 EXX
04110B C5      3307 PUSH    BC
04110C FD      3308 POP     IY              	; Restore IY
04110D E1 
04110E E5      3309 PUSH    HL
04110F CD      3310 CALL    ARGUE           	; Transfer arguments
041110 A8 
041111 16 
041112 04 
041113 E1      3311 POP     HL
               3312 ;
041114 23      3313 PROC5:			INC	HL			; Increment to the ON PROC flag address
041115 7E      3314 LD	A, (HL)			; And fetch the value
041116 2B      3315 DEC 	HL
041117 ED      3316 LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041118 1F 
041119 FE      3317 CP	TON			; Was it "ON PROC"?
04111A EE 
04111B C2      3318 JP	NZ, XEQ			; No, so back to XEQ
04111C 9E 
04111D 0B 
04111E 04 
04111F D5      3319 PUSH    DE			; Exchange DE and IY
041120 FD      3320 EX      (SP),IY
041121 E3 
041122 CD      3321 CALL    SPAN            	; Skip rest of ON list
041123 B9 
041124 17 
041125 04 
041126 FD      3322 EX      (SP),IY			; Exchange DE and IY
041127 E3 
041128 D1      3323 POP     DE
041129 ED      3324 LD	(HL), DE		; Save the return address
04112A 1F 
04112B C3      3325 JP      XEQ
04112C 9E 
04112D 0B 
04112E 04 
               3326 
               3327 ; LOCAL var[,var...]
               3328 ;
04112F C1      3329 LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041130 C5      3330 PUSH    BC
041131 21      3331 LD      HL,FNCHK		; Check if we are in a FN
041132 8C 
041133 10 
041134 04 
041135 B7      3332 OR      A
041136 ED      3333 SBC     HL,BC
041137 42 
041138 28      3334 JR      Z,LOCAL1		; Yes, so all good, we can use local
041139 16 
04113A 21      3335 LD      HL,PROCHK		; Now check if we are in a PROC
04113B 91 
04113C 10 
04113D 04 
04113E B7      3336 OR      A
04113F ED      3337 SBC     HL,BC
041140 42 
041141 28      3338 JR      Z,LOCAL1		; Again, all good, we can use local
041142 0D 
041143 21      3339 LD      HL,LOCCHK		; Finally check for the local parameters marker
041144 8A 
041145 17 
041146 04 
041147 B7      3340 OR      A
041148 ED      3341 SBC     HL,BC			; If it is not present, then
041149 42 
04114A 3E      3342 LD      A,12
04114B 0C 
04114C C2      3343 JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
04114D 98 
04114E 37 
04114F 04 
               3344 ;
               3345 ; At this point we are adding a local variable into a PROC or FN
               3346 ;
041150 FD      3347 LOCAL1:			PUSH    IY			; IY: BASIC pointer
041151 E5 
041152 C1      3348 POP     BC			; BC: Copy of the BASIC pointer
041153 D9      3349 EXX
041154 FD      3350 DEC     IY
041155 2B 
041156 CD      3351 CALL    SAVLOC
041157 2C 
041158 17 
041159 04 
04115A D9      3352 EXX
04115B C5      3353 PUSH    BC
04115C FD      3354 POP     IY
04115D E1 
               3355 ;
04115E CD      3356 LOCAL2:			CALL    GETVAR			; Get the variable location
04115F 72 
041160 3A 
041161 04 
041162 C2      3357 JP      NZ,SYNTAX
041163 9F 
041164 0C 
041165 04 
041166 B7      3358 OR      A               	; Check the variable type (80h = string)
041167 08      3359 EX      AF,AF'
041168 CD      3360 CALL    ZERO			; Zero the variable anyway
041169 98 
04116A 09 
04116B 04 
04116C 08      3361 EX      AF,AF'
04116D F5      3362 PUSH    AF
04116E F4      3363 CALL    P,STORE         	; Call STORE if it is not a string
04116F 08 
041170 16 
041171 04 
041172 F1      3364 POP     AF
041173 59      3365 LD      E,C
041174 FC      3366 CALL    M,STORES		; Call STORES if it is a string
041175 36 
041176 16 
041177 04 
041178 CD      3367 CALL    NXT			; Skip to the next character in the expression
041179 78 
04117A 0A 
04117B 04 
04117C FE      3368 CP      ','			; Is it a comma?
04117D 2C 
04117E C2      3369 JP      NZ,XEQ			; No, so we're done, carry on executing
04117F 9E 
041180 0B 
041181 04 
041182 FD      3370 INC     IY			; Yes, so skip the comma
041183 23 
041184 CD      3371 CALL    NXT			; And any whitespace
041185 78 
041186 0A 
041187 04 
041188 18      3372 JR      LOCAL2			; Then loop back and handle any further local variables
041189 D4 
               3373 
               3374 ; ENDPROC
               3375 ;
04118A C1      3376 ENDPRO:			POP     BC			; Pop the check value off the stack
04118B 21      3377 LD      HL,LOCCHK		; Check if it is the LOCAL Marker
04118C 8A 
04118D 17 
04118E 04 
04118F B7      3378 OR      A
041190 ED      3379 SBC     HL,BC
041191 42 
041192 28      3380 JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041193 13 
               3381 ;
041194 21      3382 LD      HL,PROCHK       	; Check if it is the PROC marker
041195 91 
041196 10 
041197 04 
041198 B7      3383 OR      A
041199 ED      3384 SBC     HL,BC
04119A 42 
04119B FD      3385 POP     IY
04119C E1 
04119D CA      3386 JP      Z,XEQ			; Yes, it is, so carry on, all is good
04119E 9E 
04119F 0B 
0411A0 04 
0411A1 3E      3387 LD      A,13			; Otherwise throw the "No PROC" error
0411A2 0D 
0411A3 C3      3388 JP      ERROR_
0411A4 98 
0411A5 37 
0411A6 04 
               3389 ;
0411A7 DD      3390 UNSTK:			POP     IX			; Unstack a single local variable
0411A8 E1 
0411A9 C1      3391 POP     BC
0411AA 78      3392 LD      A,B
0411AB B7      3393 OR      A
0411AC FA      3394 JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411AD BA 
0411AE 11 
0411AF 04 
0411B0 E1      3395 POP     HL			; Unstack a normal variable
0411B1 D9      3396 EXX
0411B2 E1      3397 POP     HL
0411B3 D9      3398 EXX
0411B4 CD      3399 CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B5 08 
0411B6 16 
0411B7 04 
0411B8 18      3400 JR      ENDPRO			; And loop back to ENDPRO
0411B9 D0 
               3401 ;
0411BA 21      3402 UNSTK1:			LD      HL,0			; Unstack a string
0411BB 00 
0411BC 00 
0411BD 00 
0411BE 39      3403 ADD     HL,SP
0411BF 59      3404 LD      E,C
0411C0 CD      3405 CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411C1 36 
0411C2 16 
0411C3 04 
0411C4 F9      3406 LD      SP,HL
0411C5 18      3407 JR      ENDPRO
0411C6 C3 
               3408 
               3409 ; INPUT #channel,var,var...
               3410 ;
0411C7 CD      3411 INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C8 C4 
0411C9 18 
0411CA 04 
0411CB CD      3412 INPN1:			CALL    NXT
0411CC 78 
0411CD 0A 
0411CE 04 
0411CF FE      3413 CP      ','
0411D0 2C 
0411D1 C2      3414 JP      NZ,XEQ
0411D2 9E 
0411D3 0B 
0411D4 04 
0411D5 FD      3415 INC     IY
0411D6 23 
0411D7 CD      3416 CALL    NXT
0411D8 78 
0411D9 0A 
0411DA 04 
0411DB D5      3417 PUSH    DE
0411DC CD      3418 CALL    VAR_
0411DD 96 
0411DE 0C 
0411DF 04 
0411E0 D1      3419 POP     DE
0411E1 F5      3420 PUSH    AF              ;SAVE TYPE
0411E2 E5      3421 PUSH    HL              ;VARPTR
0411E3 B7      3422 OR      A
0411E4 FA      3423 JP      M,INPN2         ;STRING
0411E5 10 
0411E6 12 
0411E7 04 
0411E8 CD      3424 CALL    OSBGET
0411E9 7C 
0411EA 43 
0411EB 04 
0411EC D9      3425 EXX
0411ED 6F      3426 LD      L,A
0411EE D9      3427 EXX
0411EF CD      3428 CALL    OSBGET
0411F0 7C 
0411F1 43 
0411F2 04 
0411F3 D9      3429 EXX
0411F4 67      3430 LD      H,A
0411F5 D9      3431 EXX
0411F6 CD      3432 CALL    OSBGET
0411F7 7C 
0411F8 43 
0411F9 04 
0411FA 6F      3433 LD      L,A
0411FB CD      3434 CALL    OSBGET
0411FC 7C 
0411FD 43 
0411FE 04 
0411FF 67      3435 LD      H,A
041200 CD      3436 CALL    OSBGET
041201 7C 
041202 43 
041203 04 
041204 4F      3437 LD      C,A
041205 DD      3438 POP     IX
041206 E1 
041207 F1      3439 POP     AF              ;RESTORE TYPE
041208 D5      3440 PUSH    DE              ;SAVE CHANNEL
041209 CD      3441 CALL    STORE
04120A 08 
04120B 16 
04120C 04 
04120D D1      3442 POP     DE
04120E 18      3443 JR      INPN1
04120F BB 
041210 21      3444 INPN2:			LD      HL,ACCS
041211 00 
041212 4A 
041213 04 
041214 CD      3445 INPN3:			CALL    OSBGET
041215 7C 
041216 43 
041217 04 
041218 FE      3446 CP      CR
041219 0D 
04121A 28      3447 JR      Z,INPN4
04121B 04 
04121C 77      3448 LD      (HL),A
04121D 2C      3449 INC     L
04121E 20      3450 JR      NZ,INPN3
04121F F4 
041220 DD      3451 INPN4:			POP     IX
041221 E1 
041222 F1      3452 POP     AF
041223 D5      3453 PUSH    DE
041224 EB      3454 EX      DE,HL
041225 CD      3455 CALL    STACCS
041226 32 
041227 16 
041228 04 
041229 D1      3456 POP     DE
04122A 18      3457 JR      INPN1
04122B 9F 
               3458 
               3459 ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3460 ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
               3461 ;
04122C FE      3462 INPUT:			CP      '#'
04122D 23 
04122E 28      3463 JR      Z,INPUTN
04122F 97 
041230 0E      3464 LD      C,0             ;FLAG PROMPT
041231 00 
041232 FE      3465 CP      LINE_EX_
041233 86 
041234 20      3466 JR      NZ,INPUT0
041235 04 
041236 FD      3467 INC     IY              ;SKIP "LINE"
041237 23 
041238 0E      3468 LD      C,80H
041239 80 
04123A 21      3469 INPUT0:			LD      HL,BUFFER
04123B 00 
04123C 4B 
04123D 04 
04123E 36      3470 LD      (HL),CR         ;INITIALISE EMPTY
04123F 0D 
041240 CD      3471 INPUT1:			CALL    TERMQ
041241 AC 
041242 17 
041243 04 
041244 CA      3472 JP      Z,XEQ           ;DONE
041245 9E 
041246 0B 
041247 04 
041248 FD      3473 INC     IY
041249 23 
04124A FE      3474 CP      ','
04124B 2C 
04124C 28      3475 JR      Z,INPUT3        ;SKIP COMMA
04124D 5C 
04124E FE      3476 CP      ';'
04124F 3B 
041250 28      3477 JR      Z,INPUT3
041251 58 
041252 E5      3478 PUSH    HL              ;SAVE BUFFER POINTER
041253 FE      3479 CP      34		;ASCII ""
041254 22 
041255 20      3480 JR      NZ,INPUT6
041256 0C 
041257 C5      3481 PUSH    BC
041258 CD      3482 CALL    CONS
041259 6C 
04125A 04 
04125B 04 
04125C C1      3483 POP     BC
04125D CD      3484 CALL    PTEXT           ;PRINT PROMPT
04125E 30 
04125F 18 
041260 04 
041261 18      3485 JR      INPUT9
041262 06 
041263 CD      3486 INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041264 D1 
041265 17 
041266 04 
041267 20      3487 JR      NZ,INPUT2
041268 05 
041269 E1      3488 INPUT9:			POP     HL
04126A CB      3489 SET     0,C             ;FLAG NO PROMPT
04126B C1 
04126C 18      3490 JR      INPUT0
04126D CC 
04126E FD      3491 INPUT2:			DEC     IY
04126F 2B 
041270 C5      3492 PUSH    BC
041271 CD      3493 CALL    VAR_
041272 96 
041273 0C 
041274 04 
041275 C1      3494 POP     BC
041276 E1      3495 POP     HL
041277 F5      3496 PUSH    AF              ;SAVE TYPE
041278 7E      3497 LD      A,(HL)
041279 23      3498 INC     HL
04127A FE      3499 CP      CR              ;BUFFER EMPTY?
04127B 0D 
04127C CC      3500 CALL    Z,REFILL
04127D AE 
04127E 12 
04127F 04 
041280 CB      3501 BIT     7,C
041281 79 
041282 F5      3502 PUSH    AF
041283 C4      3503 CALL    NZ,LINES
041284 52 
041285 18 
041286 04 
041287 F1      3504 POP     AF
041288 CC      3505 CALL    Z,FETCHS
041289 3F 
04128A 18 
04128B 04 
04128C F1      3506 POP     AF              ;RESTORE TYPE
04128D C5      3507 PUSH    BC
04128E E5      3508 PUSH    HL
04128F B7      3509 OR      A
041290 FA      3510 JP      M,INPUT4        ;STRING
041291 A4 
041292 12 
041293 04 
041294 F5      3511 PUSH    AF
041295 DD      3512 PUSH    IX
041296 E5 
041297 CD      3513 CALL    VAL0
041298 73 
041299 06 
04129A 04 
04129B DD      3514 POP     IX
04129C E1 
04129D F1      3515 POP     AF
04129E CD      3516 CALL    STORE
04129F 08 
0412A0 16 
0412A1 04 
0412A2 18      3517 JR      INPUT5
0412A3 04 
0412A4 CD      3518 INPUT4:			CALL    STACCS
0412A5 32 
0412A6 16 
0412A7 04 
0412A8 E1      3519 INPUT5:			POP     HL
0412A9 C1      3520 POP     BC
0412AA CB      3521 INPUT3:			RES     0,C
0412AB 81 
0412AC 18      3522 JR      INPUT1
0412AD 92 
               3523 ;
0412AE CB      3524 REFILL:			BIT     0,C
0412AF 41 
0412B0 20      3525 JR      NZ,REFIL0       ;NO PROMPT
0412B1 0C 
0412B2 3E      3526 LD      A,'?'
0412B3 3F 
0412B4 CD      3527 CALL    OUTCHR          ;PROMPT
0412B5 87 
0412B6 39 
0412B7 04 
0412B8 3E      3528 LD      A,' '
0412B9 20 
0412BA CD      3529 CALL    OUTCHR
0412BB 87 
0412BC 39 
0412BD 04 
0412BE 21      3530 REFIL0:			LD      HL,BUFFER
0412BF 00 
0412C0 4B 
0412C1 04 
0412C2 C5      3531 PUSH    BC
0412C3 E5      3532 PUSH    HL
0412C4 DD      3533 PUSH    IX
0412C5 E5 
0412C6 CD      3534 CALL    OSLINE
0412C7 97 
0412C8 3E 
0412C9 04 
0412CA DD      3535 POP     IX
0412CB E1 
0412CC E1      3536 POP     HL
0412CD C1      3537 POP     BC
0412CE 47      3538 LD      B,A             ;POS AT ENTRY
0412CF AF      3539 XOR     A
0412D0 32      3540 LD      (COUNT),A
0412D1 3D 
0412D2 4D 
0412D3 04 
0412D4 B8      3541 CP      B
0412D5 C8      3542 RET     Z
0412D6 7E      3543 REFIL1:			LD      A,(HL)
0412D7 FE      3544 CP      CR
0412D8 0D 
0412D9 C8      3545 RET     Z
0412DA 23      3546 INC     HL
0412DB 10      3547 DJNZ    REFIL1
0412DC F9 
0412DD C9      3548 RET
               3549 
               3550 ; READ var[,var...]
               3551 ;
0412DE FE      3552 READ:			CP      '#'
0412DF 23 
0412E0 CA      3553 JP      Z,INPUTN
0412E1 C7 
0412E2 11 
0412E3 04 
0412E4 2A      3554 LD      HL,(DATPTR)
0412E5 31 
0412E6 4D 
0412E7 04 
0412E8 7E      3555 READ0:			LD      A,(HL)
0412E9 23      3556 INC     HL              ;SKIP COMMA OR "DATA"
0412EA FE      3557 CP      CR              ;END OF DATA STMT?
0412EB 0D 
0412EC CC      3558 CALL    Z,GETDAT
0412ED 30 
0412EE 13 
0412EF 04 
0412F0 E5      3559 PUSH    HL
0412F1 CD      3560 CALL    VAR_
0412F2 96 
0412F3 0C 
0412F4 04 
0412F5 E1      3561 POP     HL
0412F6 B7      3562 OR      A
0412F7 FA      3563 JP      M,READ1         ;STRING
0412F8 10 
0412F9 13 
0412FA 04 
0412FB E5      3564 PUSH    HL
0412FC FD      3565 EX      (SP),IY
0412FD E3 
0412FE F5      3566 PUSH    AF              ;SAVE TYPE
0412FF DD      3567 PUSH    IX
041300 E5 
041301 CD      3568 CALL    EXPRN
041302 07 
041303 03 
041304 04 
041305 DD      3569 POP     IX
041306 E1 
041307 F1      3570 POP     AF
041308 CD      3571 CALL    STORE
041309 08 
04130A 16 
04130B 04 
04130C FD      3572 EX      (SP),IY
04130D E3 
04130E 18      3573 JR      READ2
04130F 09 
041310 CD      3574 READ1:			CALL    FETCHS
041311 3F 
041312 18 
041313 04 
041314 E5      3575 PUSH    HL
041315 CD      3576 CALL    STACCS
041316 32 
041317 16 
041318 04 
041319 E1      3577 READ2:			POP     HL
04131A 22      3578 LD      (DATPTR),HL
04131B 31 
04131C 4D 
04131D 04 
04131E CD      3579 CALL    NXT
04131F 78 
041320 0A 
041321 04 
041322 FE      3580 CP      ','
041323 2C 
041324 C2      3581 JP      NZ,XEQ
041325 9E 
041326 0B 
041327 04 
041328 FD      3582 INC     IY
041329 23 
04132A CD      3583 CALL    NXT
04132B 78 
04132C 0A 
04132D 04 
04132E 18      3584 JR      READ0
04132F B8 
               3585 ;
041330 3E      3586 GETDAT:			LD      A,DATA_EX_
041331 DC 
041332 CD      3587 CALL    SEARCH_EX
041333 80 
041334 18 
041335 04 
041336 23      3588 INC     HL
041337 D0      3589 RET     NC
041338 3E      3590 LD      A,42
041339 2A 
04133A C3      3591 ERROR4:			JP      ERROR_           ;"Out of DATA"
04133B 98 
04133C 37 
04133D 04 
               3592 
               3593 ; IF expr statement
               3594 ; IF expr THEN statement [ELSE statement]
               3595 ; IF expr THEN line [ELSE line]
               3596 ;
04133E CD      3597 IF_:			CALL    EXPRI
04133F 0F 
041340 03 
041341 04 
041342 CD      3598 CALL    TEST
041343 E4 
041344 08 
041345 04 
041346 28      3599 JR      Z,IFNOT         ;FALSE
041347 19 
041348 FD      3600 LD      A,(IY)
041349 7E 
04134A 00 
04134B FE      3601 CP      THEN_EX_
04134C 8C 
04134D C2      3602 JP      NZ,XEQ
04134E 9E 
04134F 0B 
041350 04 
041351 FD      3603 INC     IY              ;SKIP "THEN"
041352 23 
041353 CD      3604 IF1:			CALL    NXT
041354 78 
041355 0A 
041356 04 
041357 FE      3605 CP      LINO_EX
041358 8D 
041359 C2      3606 JP      NZ,XEQ          ;STATEMENT FOLLOWS
04135A 9E 
04135B 0B 
04135C 04 
04135D C3      3607 JP      GOTO_EX            ;LINE NO. FOLLOWS
04135E 33 
04135F 0F 
041360 04 
041361 FD      3608 IFNOT:			LD      A,(IY)
041362 7E 
041363 00 
041364 FE      3609 CP      CR
041365 0D 
041366 FD      3610 INC     IY
041367 23 
041368 CA      3611 JP      Z,XEQ0          ;END OF LINE
041369 9A 
04136A 0B 
04136B 04 
04136C FE      3612 CP      ELSE_EX_
04136D 8B 
04136E 20      3613 JR      NZ,IFNOT
04136F F1 
041370 18      3614 JR      IF1
041371 E1 
               3615 
               3616 ; CLS
               3617 ;
041372 CD      3618 CLS:		CALL    CLRSCN
041373 0A 
041374 44 
041375 04 
041376 AF      3619 XOR     A
041377 32      3620 LD      (COUNT),A
041378 3D 
041379 4D 
04137A 04 
04137B C3      3621 JP      XEQ
04137C 9E 
04137D 0B 
04137E 04 
               3622 
               3623 ; STOP
               3624 ;
04137F CD      3625 STOP:			CALL    TELL
041380 C8 
041381 3D 
041382 04 
041383 0D      3626 DB	CR
041384 0A      3627 DB	LF
041385 FA      3628 DB	TSTOP
041386 00      3629 DB	0
041387 CD      3630 CALL    SETLIN          ;FIND CURRENT LINE
041388 E6 
041389 39 
04138A 04 
04138B CD      3631 CALL    SAYLN
04138C 1A 
04138D 3A 
04138E 04 
04138F CD      3632 CALL    CRLF
041390 7F 
041391 39 
041392 04 
041393 C3      3633 JP      CLOOP
041394 B8 
041395 30 
041396 04 
               3634 
               3635 ; REPORT
               3636 ;
041397 CD      3637 REPOR:			CALL    REPORT
041398 BA 
041399 3D 
04139A 04 
04139B C3      3638 JP      XEQ
04139C 9E 
04139D 0B 
04139E 04 
               3639 
               3640 ; CLEAR
               3641 ;
04139F CD      3642 CLR:			CALL    CLEAR
0413A0 AE 
0413A1 38 
0413A2 04 
0413A3 2A      3643 LD      HL,(PAGE_)
0413A4 14 
0413A5 4D 
0413A6 04 
0413A7 18      3644 JR      RESTR1
0413A8 19 
               3645 
               3646 ; RESTORE [line]
               3647 ;
0413A9 2A      3648 RESTOR_EX:			LD      HL,(PAGE_)
0413AA 14 
0413AB 4D 
0413AC 04 
0413AD CD      3649 CALL    TERMQ
0413AE AC 
0413AF 17 
0413B0 04 
0413B1 28      3650 JR      Z,RESTR1
0413B2 0F 
0413B3 CD      3651 CALL    ITEMI
0413B4 2A 
0413B5 03 
0413B6 04 
0413B7 D9      3652 EXX
0413B8 CD      3653 CALL    FINDL           ;SEARCH FOR LINE
0413B9 C7 
0413BA 39 
0413BB 04 
0413BC 3E      3654 LD      A,41
0413BD 29 
0413BE C2      3655 JP      NZ,ERROR4       ;"No such line"
0413BF 3A 
0413C0 13 
0413C1 04 
0413C2 3E      3656 RESTR1:			LD      A,DATA_EX_
0413C3 DC 
0413C4 CD      3657 CALL    SEARCH_EX
0413C5 80 
0413C6 18 
0413C7 04 
0413C8 22      3658 LD      (DATPTR),HL
0413C9 31 
0413CA 4D 
0413CB 04 
0413CC C3      3659 JP      XEQ
0413CD 9E 
0413CE 0B 
0413CF 04 
               3660 
               3661 ; PTR#channel=expr
               3662 ; PAGE=expr
               3663 ; TIME=expr
               3664 ; LOMEM=expr
               3665 ; HIMEM=expr
               3666 ;
0413D0 CD      3667 PTR_EX:			CALL    CHANEL
0413D1 B8 
0413D2 18 
0413D3 04 
0413D4 CD      3668 CALL    EQUALS
0413D5 C2 
0413D6 17 
0413D7 04 
0413D8 7B      3669 LD      A,E
0413D9 F5      3670 PUSH    AF
0413DA CD      3671 CALL    EXPRI
0413DB 0F 
0413DC 03 
0413DD 04 
0413DE E5      3672 PUSH    HL
0413DF D9      3673 EXX
0413E0 D1      3674 POP     DE
0413E1 F1      3675 POP     AF
0413E2 CD      3676 CALL    PUTPTR
0413E3 B0 
0413E4 43 
0413E5 04 
0413E6 C3      3677 JP      XEQ
0413E7 9E 
0413E8 0B 
0413E9 04 
               3678 ;
0413EA CD      3679 PAGEV_EX:			CALL    EQUALS
0413EB C2 
0413EC 17 
0413ED 04 
0413EE CD      3680 CALL    EXPRI
0413EF 0F 
0413F0 03 
0413F1 04 
0413F2 D9      3681 EXX
0413F3 2E      3682 LD      L,0
0413F4 00 
0413F5 22      3683 LD      (PAGE_),HL
0413F6 14 
0413F7 4D 
0413F8 04 
0413F9 C3      3684 JP      XEQ
0413FA 9E 
0413FB 0B 
0413FC 04 
               3685 ;
0413FD FE      3686 TIMEV_EX:			CP      '$'
0413FE 24 
0413FF 28      3687 JR      Z,TIMEVS_EX
041400 13 
041401 CD      3688 CALL    EQUALS
041402 C2 
041403 17 
041404 04 
041405 CD      3689 CALL    EXPRI
041406 0F 
041407 03 
041408 04 
041409 E5      3690 PUSH    HL
04140A D9      3691 EXX
04140B D1      3692 POP     DE
04140C CD      3693 CALL    PUTIME
04140D CF 
04140E 3E 
04140F 04 
041410 C3      3694 JP      XEQ
041411 9E 
041412 0B 
041413 04 
               3695 ;
041414 FD      3696 TIMEVS_EX:			INC     IY              ;SKIP '$'
041415 23 
041416 CD      3697 CALL    EQUALS
041417 C2 
041418 17 
041419 04 
04141A CD      3698 CALL    EXPRS
04141B 1A 
04141C 03 
04141D 04 
04141E CD      3699 CALL    PUTIMS
04141F 84 
041420 49 
041421 04 
041422 C3      3700 JP      XEQ
041423 9E 
041424 0B 
041425 04 
               3701 ;
041426 CD      3702 LOMEMV_EX:			CALL    EQUALS
041427 C2 
041428 17 
041429 04 
04142A CD      3703 CALL    EXPRI
04142B 0F 
04142C 03 
04142D 04 
04142E CD      3704 CALL    CLEAR
04142F AE 
041430 38 
041431 04 
041432 D9      3705 EXX
041433 22      3706 LD      (LOMEM),HL
041434 1A 
041435 4D 
041436 04 
041437 22      3707 LD      (FREE),HL
041438 1D 
041439 4D 
04143A 04 
04143B C3      3708 JP      XEQ
04143C 9E 
04143D 0B 
04143E 04 
               3709 ;
04143F CD      3710 HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041440 C2 
041441 17 
041442 04 
041443 CD      3711 CALL    EXPRI			; Load the expression into registers
041444 0F 
041445 03 
041446 04 
041447 7D      3712 LD	A,L			;  A: The MSB of the 24-bit value
041448 D9      3713 EXX				; HL: The LSW of the 24-bit value
041449 22      3714 LD	(R0),HL
04144A 4A 
04144B 4D 
04144C 04 
04144D 32      3715 LD	(R0+2),A
04144E 4C 
04144F 4D 
041450 04 
041451 2A      3716 LD	HL,(FREE)
041452 1D 
041453 4D 
041454 04 
041455 11      3717 LD      DE,256
041456 00 
041457 01 
041458 00 
041459 19      3718 ADD	HL,DE
04145A EB      3719 EX	DE,HL			; DE: FREE + 256
04145B 2A      3720 LD	HL,(R0)			; HL: The passed expression
04145C 4A 
04145D 4D 
04145E 04 
04145F AF      3721 XOR     A
041460 ED      3722 SBC     HL,DE
041461 52 
041462 19      3723 ADD     HL,DE			; Do a bounds check
041463 DA      3724 JP      C,ERROR_         	; Throw the error: "No room"
041464 98 
041465 37 
041466 04 
041467 ED      3725 LD      DE,(HIMEM)
041468 5B 
041469 20 
04146A 4D 
04146A 04   
04146C 22      3726 LD      (HIMEM),HL
04146D 20 
04146E 4D 
04146F 04 
041470 EB      3727 EX      DE,HL
041471 ED      3728 SBC     HL,SP			; Adjust the stack
041472 72 
041473 C2      3729 JP      NZ,XEQ
041474 9E 
041475 0B 
041476 04 
041477 EB      3730 EX      DE,HL
041478 F9      3731 LD      SP,HL           	; Load the SP
041479 C3      3732 JP      XEQ
04147A 9E 
04147B 0B 
04147C 04 
               3733 
               3734 ; WIDTH expr
               3735 ;
04147D CD      3736 WIDTHV:			CALL    EXPRI
04147E 0F 
04147F 03 
041480 04 
041481 D9      3737 EXX
041482 7D      3738 LD      A,L
041483 32      3739 LD      (WIDTH),A
041484 3E 
041485 4D 
041486 04 
041487 C3      3740 JP      XEQ
041488 9E 
041489 0B 
04148A 04 
               3741 
               3742 ; TRACE ON
               3743 ; TRACE OFF
               3744 ; TRACE line
               3745 ;
04148B FD      3746 TRACE_EX:			INC     IY
04148C 23 
04148D 21      3747 LD      HL,0
04148E 00 
04148F 00 
041490 00 
041491 FE      3748 CP      TON
041492 EE 
041493 28      3749 JR      Z,TRACE0
041494 0B 
041495 FE      3750 CP      OFF_
041496 87 
041497 28      3751 JR      Z,TRACE1
041498 08 
041499 FD      3752 DEC     IY
04149A 2B 
04149B CD      3753 CALL    EXPRI
04149C 0F 
04149D 03 
04149E 04 
04149F D9      3754 EXX
0414A0 2B      3755 TRACE0:			DEC     HL
0414A1 22      3756 TRACE1:			LD      (TRACEN),HL
0414A2 26 
0414A3 4D 
0414A4 04 
0414A5 C3      3757 JP      XEQ
0414A6 9E 
0414A7 0B 
0414A8 04 
               3758 
               3759 ; VDU expr,expr;....
               3760 ;
0414A9 DD      3761 VDU:			LD	IX,BUFFER		; Storage for the VDU stream
0414AA 21 
0414AB 00 
0414AC 4B 
0414AC 04   
0414AE DD      3762 VDU1:			PUSH	IX
0414AF E5 
0414B0 CD      3763 CALL    EXPRI			; Fetch the VDU character
0414B1 0F 
0414B2 03 
0414B3 04 
0414B4 DD      3764 POP	IX
0414B5 E1 
0414B6 D9      3765 EXX
0414B7 DD      3766 LD	(IX+0),L		; Write out the character to the buffer
0414B8 75 
0414B9 00 
0414BA DD      3767 INC	IX
0414BB 23 
0414BC FD      3768 LD      A,(IY)			;  A: The separator character
0414BD 7E 
0414BE 00 
0414BF FE      3769 CP      ','			; Is it a comma?
0414C0 2C 
0414C1 28      3770 JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414C2 09 
0414C3 FE      3771 CP      ';'			; Is it a semicolon?
0414C4 3B 
0414C5 20      3772 JR      NZ,VDU3			; No, so skip to the next expression
0414C6 07 
0414C7 DD      3773 LD	(IX+0),H		; Write out the high byte to the buffer
0414C8 74 
0414C9 00 
0414CA DD      3774 INC	IX
0414CB 23 
0414CC FD      3775 VDU2:			INC     IY			; Skip to the next character
0414CD 23 
0414CE CD      3776 VDU3:			CALL    TERMQ			; Skip past white space
0414CF AC 
0414D0 17 
0414D1 04 
0414D2 20      3777 JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414D3 DA 
0414D4 DD      3778 LD	A,IXL			;  A: Number of bytes to write out
0414D5 7D 
0414D6 B7      3779 OR	A
0414D7 28      3780 JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D8 0B 
0414D9 21      3781 LD	HL,BUFFER		; HL: Start of stream
0414DA 00 
0414DB 4B 
0414DC 04 
0414DD 01      3782 LD	BC,0
0414DE 00 
0414DF 00 
0414E0 00 
0414E1 4F      3783 LD	C,A			; BC: Number of bytes to write out
0414E2 5B      3784 RST.LIL	18h			; Output the buffer to MOS
0414E3 DF 
0414E4 C3      3785 VDU4:			JP      XEQ
0414E5 9E 
0414E6 0B 
0414E7 04 
               3786 
               3787 ; CLOSE channel number
               3788 ;
0414E8 CD      3789 CLOSE:			CALL    CHANEL			; Fetch the channel number
0414E9 B8 
0414EA 18 
0414EB 04 
0414EC CD      3790 CALL    OSSHUT			; Close the channel
0414ED 74 
0414EE 43 
0414EF 04 
0414F0 C3      3791 JP      XEQ
0414F1 9E 
0414F2 0B 
0414F3 04 
               3792 
               3793 ; BPUT channel,byte
               3794 ;
0414F4 CD      3795 BPUT:			CALL    CHANEL          	; Fetch the channel number
0414F5 B8 
0414F6 18 
0414F7 04 
0414F8 D5      3796 PUSH    DE			; DE: Channel number
0414F9 CD      3797 CALL    COMMA			; Skip to the next expression
0414FA 2A 
0414FB 0A 
0414FC 04 
0414FD CD      3798 CALL    EXPRI           	; Feth the data
0414FE 0F 
0414FF 03 
041500 04 
041501 D9      3799 EXX
041502 7D      3800 LD      A,L			; A: The byte to write
041503 D1      3801 POP     DE
041504 CD      3802 CALL    OSBPUT			; Write the byte out
041505 84 
041506 43 
041507 04 
041508 C3      3803 JP      XEQ
041509 9E 
04150A 0B 
04150B 04 
               3804 
               3805 ; CALL address[,var[,var...]]
               3806 ;
               3807 ; Note that the parameter table differs from the Z80 version
               3808 ; Each entry now takes up 4 bytes, not 3, so the table is now:
               3809 ;  -1 byte:  Number of parameters
               3810 ; Then, for each parameter:
               3811 ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
               3812 ;  -3 bytes: Parameter address
               3813 ;
               3814 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
               3815 ;
04150C CD      3816 CALL_:			CALL    EXPRI           	; Fetch the address
04150D 0F 
04150E 03 
04150F 04 
041510 7D      3817 LD	A,L			;  A: MSB of address
041511 D9      3818 EXX
041512 22      3819 LD	(R0+0),HL		; HL: LSW of address
041513 4A 
041514 4D 
041515 04 
041516 32      3820 LD	(R0+2),A
041517 4C 
041518 4D 
041519 04 
04151A 06      3821 LD      B,0             	;  B: The parameter counter
04151B 00 
04151C 11      3822 LD      DE,BUFFER       	; DE: Vector
04151D 00 
04151E 4B 
04151F 04 
               3823 ;
041520 CD      3824 CALL1:			CALL    NXT			; Skip whitespace
041521 78 
041522 0A 
041523 04 
041524 FE      3825 CP      ','			; Check for comma
041525 2C 
041526 20      3826 JR      NZ,CALL2		; If no more parameters, then jump here
041527 1B 
041528 FD      3827 INC     IY			; Skip to the next character
041529 23 
04152A 04      3828 INC     B			; Increment the parameter count
04152B CD      3829 CALL    NXT			; Skip whitespace
04152C 78 
04152D 0A 
04152E 04 
04152F C5      3830 PUSH    BC
041530 D5      3831 PUSH    DE
041531 CD      3832 CALL    VAR_
041532 96 
041533 0C 
041534 04 
041535 D1      3833 POP     DE
041536 C1      3834 POP     BC
041537 13      3835 INC     DE
041538 12      3836 LD      (DE),A			; Save the parameter type
041539 13      3837 INC     DE
04153A EB      3838 EX      DE,HL
04153B ED      3839 LD	(HL),DE			; Save the parameter address (3 bytes)
04153C 1F 
04153D 23      3840 INC	HL
04153E 23      3841 INC	HL
04153F 23      3842 INC	HL
041540 EB      3843 EX      DE,HL
041541 18      3844 JR      CALL1
041542 DD 
               3845 ;
041543 78      3846 CALL2:			LD      A,B
041544 32      3847 LD      (BUFFER),A      	; Save the parameter count
041545 00 
041546 4B 
041547 04 
041548 2A      3848 LD	HL,(R0)			; HL: Address of the code
041549 4A 
04154A 4D 
04154B 04 
04154C CD      3849 CALL    USR1			; And call it
04154D 66 
04154E 15 
04154F 04 
041550 C3      3850 JP      XEQ
041551 9E 
041552 0B 
041553 04 
               3851 
               3852 ; USR(address)
               3853 ;
041554 CD      3854 USR:			CALL    ITEMI			; Evaluate the expression
041555 2A 
041556 03 
041557 04 
041558 7D      3855 LD	A,L			;  A: MSB of address
041559 D9      3856 EXX
04155A 22      3857 LD	(R0+0),HL		; HL: LSW of address
04155B 4A 
04155C 4D 
04155D 04 
04155E 32      3858 LD	(R0+2),A
04155F 4C 
041560 4D 
041561 04 
041562 2A      3859 LD	HL,(R0)			; Get the 24-bit address in HL
041563 4A 
041564 4D 
041565 04 
               3860 ;
041566 E5      3861 USR1:			PUSH    HL              	; Address on stack
041567 FD      3862 EX      (SP),IY
041568 E3 
041569 24      3863 INC     H               	; Check for PAGE &00FFxx
04156A B4      3864 OR	H
04156B 21      3865 LD      HL,USR2         	; Return address
04156C D5 
04156D 15 
04156E 04 
04156F E5      3866 PUSH    HL
041570 DD      3867 LD      IX,STAVAR
041571 21 
041572 00 
041573 4C 
041573 04   
041575 CC      3868 CALL    Z,OSCALL        	; Intercept &00FFxx
041576 3A 
041577 43 
041578 04 
               3869 ;
041579 DD      3870 LD      C, (IX+24)		; F%
04157A 4E 
04157B 18 
04157C C5      3871 PUSH    BC
               3872 ;
04157D DD      3873 LD	A, (IX+8)		; B% -> MSW
04157E 7E 
04157F 08 
041580 32      3874 LD	(R0+1), A
041581 4B 
041582 4D 
041583 04 
041584 DD      3875 LD	A, (IX+9)
041585 7E 
041586 09 
041587 32      3876 LD	(R0+2), A
041588 4C 
041589 4D 
04158A 04 
04158B DD      3877 LD	A, (IX+12)		; C% -> LSB
04158C 7E 
04158D 0C 
04158E 32      3878 LD	(R0+0), A
04158F 4A 
041590 4D 
041591 04 
041592 ED      3879 LD	BC, (R0)
041593 4B 
041594 4A 
041595 4D 
041595 04   
               3880 ;
041597 DD      3881 LD	A, (IX+16)		; D% -> MSW
041598 7E 
041599 10 
04159A 32      3882 LD	(R0+1), A
04159B 4B 
04159C 4D 
04159D 04 
04159E DD      3883 LD	A, (IX+17)
04159F 7E 
0415A0 11 
0415A1 32      3884 LD	(R0+2), A
0415A2 4C 
0415A3 4D 
0415A4 04 
0415A5 DD      3885 LD	A, (IX+20)		; E% -> LSB
0415A6 7E 
0415A7 14 
0415A8 32      3886 LD	(R0+0), A
0415A9 4A 
0415AA 4D 
0415AB 04 
0415AC ED      3887 LD	DE, (R0)
0415AD 5B 
0415AE 4A 
0415AF 4D 
0415AF 04   
               3888 ;
0415B1 DD      3889 LD	A, (IX+32)		; H% -> MSW
0415B2 7E 
0415B3 20 
0415B4 32      3890 LD	(R0+1), A
0415B5 4B 
0415B6 4D 
0415B7 04 
0415B8 DD      3891 LD	A, (IX+33)
0415B9 7E 
0415BA 21 
0415BB 32      3892 LD	(R0+2), A
0415BC 4C 
0415BD 4D 
0415BE 04 
0415BF DD      3893 LD	A, (IX+48)		; L% -> LSB
0415C0 7E 
0415C1 30 
0415C2 32      3894 LD	(R0+0), A
0415C3 4A 
0415C4 4D 
0415C5 04 
0415C6 2A      3895 LD	HL, (R0)
0415C7 4A 
0415C8 4D 
0415C9 04 
               3896 ;
0415CA F1      3897 POP     AF			; F%
0415CB DD      3898 LD      A, (IX+4)        	; A%
0415CC 7E 
0415CD 04 
               3899 
0415CE DD      3900 LD      IX,BUFFER
0415CF 21 
0415D0 00 
0415D1 4B 
0415D1 04   
0415D3 FD      3901 JP      (IY)            	; Off to user routine
0415D4 E9 
               3902 ;
0415D5 FD      3903 USR2:			POP     IY
0415D6 E1 
0415D7 AF      3904 XOR     A
0415D8 4F      3905 LD      C,A
0415D9 C9      3906 RET
               3907 
               3908 ; PUT port,data
               3909 ;
0415DA CD      3910 PUT:			CALL    EXPRI           ;PORT ADDRESS
0415DB 0F 
0415DC 03 
0415DD 04 
0415DE D9      3911 EXX
0415DF E5      3912 PUSH    HL
0415E0 CD      3913 CALL    COMMA
0415E1 2A 
0415E2 0A 
0415E3 04 
0415E4 CD      3914 CALL    EXPRI           ;DATA
0415E5 0F 
0415E6 03 
0415E7 04 
0415E8 D9      3915 EXX
0415E9 C1      3916 POP     BC
0415EA ED      3917 OUT     (C),L           ;OUTPUT TO PORT BC
0415EB 69 
0415EC C3      3918 JP      XEQ
0415ED 9E 
0415EE 0B 
0415EF 04 
               3919 
               3920 ; SUBROUTINES -----------------------------------------------------------------
               3921 
               3922 ; ASSIGN - Assign a numeric value to a variable.
               3923 ; Outputs: NC,  Z - OK, numeric.
               3924 ;          NC, NZ - OK, string.
               3925 ;           C, NZ - illegal
               3926 ;
0415F0 CD      3927 ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415F1 72 
0415F2 3A 
0415F3 04 
0415F4 D8      3928 RET     C               	; Return with C if it is an illegal variable
0415F5 C4      3929 CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415F6 61 
0415F7 3A 
0415F8 04 
0415F9 B7      3930 OR      A
0415FA F8      3931 RET     M               	; Return if type is string (81h)
0415FB F5      3932 PUSH    AF              	; It's a numeric type from this point on
0415FC CD      3933 CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415FD C2 
0415FE 17 
0415FF 04 
041600 E5      3934 PUSH    HL
041601 CD      3935 CALL    EXPRN
041602 07 
041603 03 
041604 04 
041605 DD      3936 POP     IX
041606 E1 
041607 F1      3937 POP     AF
041608 CB      3938 STORE:			BIT     0,A
041609 47 
04160A 28      3939 JR      Z,STOREI
04160B 13 
04160C BF      3940 CP      A               	; Set the variable to 0
04160D DD      3941 STORE5:			LD      (IX+4),C
04160E 71 
04160F 04 
041610 D9      3942 STORE4:			EXX
041611 DD      3943 LD      (IX+0),L
041612 75 
041613 00 
041614 DD      3944 LD      (IX+1),H
041615 74 
041616 01 
041617 D9      3945 EXX
041618 DD      3946 LD      (IX+2),L
041619 75 
04161A 02 
04161B DD      3947 LD      (IX+3),H
04161C 74 
04161D 03 
04161E C9      3948 RET
04161F F5      3949 STOREI:			PUSH    AF
041620 0C      3950 INC     C               ;SPEED - & PRESERVE F'
041621 0D      3951 DEC     C               ; WHEN CALLED BY FNEND0
041622 C4      3952 CALL    NZ,SFIX         ;CONVERT TO INTEGER
041623 67 
041624 06 
041625 04 
041626 F1      3953 POP     AF
041627 FE      3954 CP      4
041628 04 
041629 28      3955 JR      Z,STORE4
04162A E5 
04162B BF      3956 CP      A               ;SET ZERO
04162C D9      3957 STORE1:			EXX
04162D DD      3958 LD      (IX+0),L
04162E 75 
04162F 00 
041630 D9      3959 EXX
041631 C9      3960 RET
               3961 ;
               3962 ; Copy a string from the string accumulator to variable storage on the stack
               3963 ; Parameters:
               3964 ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
               3965 ; - IX: Address of the variable storage on the stack
               3966 ;
041632 21      3967 STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041633 00 
041634 4A 
041635 04 
               3968 ;
               3969 ; Parameters:
               3970 ; As above, but:
               3971 ; - HL: Address of the string to be stored
               3972 ; -  E: The string length
               3973 ; NB:
               3974 ; Strings are mutable
               3975 ; Strings are stored in the following format in the variable:
               3976 ; - Address of the next variable (3 bytes)
               3977 ; - The rest of the variable name - this is zero terminated
               3978 ; - Current string length (byte)
               3979 ; - Maximum (original) string length (byte)
               3980 ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
               3981 ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
               3982 ;
041636 1F      3983 STORES:			RRA				; Rotate right to shift bit 0 into carry
041637 30      3984 JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041638 5D 
041639 E5      3985 PUSH    HL			; Stack ACCS
               3986 ;
               3987 ; Load the string pointer and lengths into registers - these are all zeroed for new strings
               3988 ;
04163A D9      3989 EXX				; This block was a call to LOAD4
04163B DD      3990 LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04163C 6E 
04163D 00 
04163E DD      3991 LD      H,(IX+1)		; The maximum original string length
04163F 66 
041640 01 
041641 D9      3992 EXX
041642 DD      3993 LD	HL,(IX+2)		; Address of the string (24-bit)
041643 27 
041644 02 
               3994 ;
041645 7B      3995 LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041646 D9      3996 EXX
041647 6F      3997 LD      L,A			; L': Length of string currently stored on the stack
041648 7C      3998 LD      A,H             	; H': The maximum (original) string length
041649 D9      3999 EXX
04164A BB      4000 CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
04164B 30      4001 JR      NC,STORS1       	; Yes there is, so skip the next bit
04164C 17 
               4002 ;
               4003 ; At this point we're either initialising a new string or assigning more memory to an existing string
               4004 ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
               4005 ; then the existing and new strings may both exist in memory.
               4006 ;
04164D D9      4007 EXX
04164E 65      4008 LD      H,L			; H: Set the maximum string length to the string length
04164F D9      4009 EXX
041650 E5      4010 PUSH    HL
041651 01      4011 LD	BC, 0
041652 00 
041653 00 
041654 00 
041655 4F      4012 LD      C,A			; BC: The maximum (original) string length
041656 09      4013 ADD     HL,BC			; Work out whether this is the last string in memory
041657 ED      4014 LD      BC,(FREE)
041658 4B 
041659 1D 
04165A 4D 
04165A 04   
04165C ED      4015 SBC     HL,BC			; Is string last?
04165D 42 
04165E E1      4016 POP     HL
04165F 37      4017 SCF
041660 28      4018 JR      Z,STORS1
041661 02 
               4019 ; LD	HL, BC			; HL=BC
041662 C5      4020 push bc
041663 E1      4021 pop hl
               4022 ;
               4023 ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
               4024 ; - H': The maximum (original) string length
               4025 ; - L': The actual string length (must be less than H')
               4026 ; - HL: Address of the string in memory
               4027 ;
041664 D9      4028 STORS1:			EXX				; This block was a call to STORE4
041665 DD      4029 LD      (IX+0),L		; The actual string length (must be less then H')
041666 75 
041667 00 
041668 DD      4030 LD      (IX+1),H		; The maximum (original) string length
041669 74 
04166A 01 
04166B D9      4031 EXX
04166C DD      4032 LD	(IX+2),HL		; The pointer to the original string
04166D 2F 
04166E 02 
               4033 ;
04166F 01      4034 LD	BC, 0
041670 00 
041671 00 
041672 00 
041673 4B      4035 LD      C,E			; BC: The new string length
041674 EB      4036 EX      DE,HL
041675 E1      4037 POP     HL
041676 0D      4038 DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041677 0C      4039 INC     C			; check whether BC is 0 without affecting the carry flag
041678 C8      4040 RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041679 ED      4041 LDIR				; Replace the string in memory
04167A B0 
04167B D0      4042 RET     NC
04167C ED      4043 LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
04167D 53 
04167E 1D 
04167F 4D 
04167F 04   
               4044 ;
               4045 ; Check whether the stack is full
               4046 ;
041681 E5      4047 CHECK:			PUSH    HL
041682 C5      4048 PUSH	BC
041683 2A      4049 LD      HL,(FREE)		; HL: Address of first free space byte
041684 1D 
041685 4D 
041686 04 
041687 01      4050 LD	BC,100h			; BC: One page of memory
041688 00 
041689 01 
04168A 00 
04168B 09      4051 ADD	HL,BC			; Add a page to FREE
04168C ED      4052 SBC     HL,SP			; And subtract the current SP
04168D 72 
04168E C1      4053 POP	BC
04168F E1      4054 POP     HL
041690 D8      4055 RET     C			; The SP is not in the same page, so just return
041691 AF      4056 XOR     A			; Otherwise
041692 C3      4057 JP      ERROR_			; Throw error "No room"
041693 98 
041694 37 
041695 04 
               4058 ;
041696 01      4059 STORS3:			LD	BC,0
041697 00 
041698 00 
041699 00 
04169A 4B      4060 LD      C,E			; BC: String length
04169B DD      4061 PUSH    IX
04169C E5 
04169D D1      4062 POP     DE			; DE: Destination
04169E AF      4063 XOR     A			; Check if string length is 0
04169F B9      4064 CP      C
0416A0 28      4065 JR      Z,STORS5		; Yes, so don't copy
0416A1 02 
0416A2 ED      4066 LDIR
0416A3 B0 
0416A4 3E      4067 STORS5:			LD      A,CR			; Finally add the terminator
0416A5 0D 
0416A6 12      4068 LD      (DE),A
0416A7 C9      4069 RET
               4070 
               4071 ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
               4072 ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
               4073 ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
               4074 ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
               4075 ;    Inputs: DE addresses parameter list
               4076 ;            IY addresses dummy variable list
               4077 ;   Outputs: DE,IY updated
               4078 ;  Destroys: Everything
               4079 ;
0416A8 3E      4080 ARGUE:			LD      A,-1
0416A9 FF 
0416AA F5      4081 PUSH    AF              	; Put marker on the stack
0416AB FD      4082 ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416AC 23 
0416AD 13      4083 INC     DE
0416AE D5      4084 PUSH    DE
0416AF CD      4085 CALL    NXT			; Skip any whitespace
0416B0 78 
0416B1 0A 
0416B2 04 
0416B3 CD      4086 CALL    GETVAR			; Get the location of the variable in HL/IX
0416B4 72 
0416B5 3A 
0416B6 04 
0416B7 38      4087 JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B8 3F 
0416B9 C4      4088 CALL    NZ,PUTVAR
0416BA 61 
0416BB 3A 
0416BC 04 
0416BD D1      4089 POP     DE
0416BE E5      4090 PUSH    HL              	; VARPTR
0416BF B7      4091 OR      A               	; Check the variable type
0416C0 F5      4092 PUSH    AF
0416C1 D5      4093 PUSH    DE
0416C2 FD      4094 EX      (SP),IY
0416C3 E3 
0416C4 FA      4095 JP      M,ARGUE2        	; Jump here if it is a string
0416C5 DC 
0416C6 16 
0416C7 04 
               4096 ;
0416C8 CD      4097 CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416C9 07 
0416CA 03 
0416CB 04 
0416CC FD      4098 EX      (SP),IY
0416CD E3 
0416CE D1      4099 POP     DE
0416CF F1      4100 POP     AF
0416D0 D9      4101 EXX
0416D1 E5      4102 PUSH    HL
0416D2 D9      4103 EXX
0416D3 E5      4104 PUSH    HL
0416D4 47      4105 LD      B,A
0416D5 C5      4106 PUSH    BC
0416D6 CD      4107 CALL    CHECK           	; Check room
0416D7 81 
0416D8 16 
0416D9 04 
0416DA 18      4108 JR      ARGUE4
0416DB 0F 
               4109 ;
0416DC CD      4110 ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416DD 1A 
0416DE 03 
0416DF 04 
0416E0 FD      4111 EX      (SP),IY
0416E1 E3 
0416E2 D9      4112 EXX
0416E3 D1      4113 POP     DE
0416E4 D9      4114 EXX
0416E5 F1      4115 POP     AF
0416E6 CD      4116 CALL    PUSHS
0416E7 B9 
0416E8 09 
0416E9 04 
0416EA D9      4117 EXX
               4118 ;
0416EB CD      4119 ARGUE4:			CALL    NXT			; Skip whitespace
0416EC 78 
0416ED 0A 
0416EE 04 
0416EF FE      4120 CP      ','			; Check to see if the next value is a comma
0416F0 2C 
0416F1 20      4121 JR      NZ,ARGUE5		; No, so jump here
0416F2 0B 
0416F3 1A      4122 LD      A,(DE)
0416F4 FE      4123 CP      ','			; Are there any more arguments?
0416F5 2C 
0416F6 28      4124 JR      Z,ARGUE1        	; Yes, so loop
0416F7 B3 
               4125 ;
0416F8 3E      4126 ARGERR:			LD      A,31
0416F9 1F 
0416FA C3      4127 JP      ERROR_           	; Throw error "Arguments"
0416FB 98 
0416FC 37 
0416FD 04 
               4128 ;
0416FE CD      4129 ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416FF 37 
041700 0A 
041701 04 
041702 1A      4130 LD      A,(DE)
041703 FE      4131 CP      ')'
041704 29 
041705 20      4132 JR      NZ,ARGERR
041706 F1 
041707 13      4133 INC     DE
041708 D9      4134 EXX
041709 C1      4135 ARGUE6:			POP     BC
04170A 78      4136 LD      A,B
04170B 3C      4137 INC     A
04170C D9      4138 EXX
04170D C8      4139 RET     Z               	; Marker popped
04170E D9      4140 EXX
04170F 3D      4141 DEC     A
041710 FA      4142 JP      M,ARGUE7        	; If it is a string, then jump here
041711 20 
041712 17 
041713 04 
041714 E1      4143 POP     HL
041715 D9      4144 EXX
041716 E1      4145 POP     HL
041717 D9      4146 EXX
041718 DD      4147 POP     IX
041719 E1 
04171A CD      4148 CALL    STORE	           	; Write to dummy variable
04171B 08 
04171C 16 
04171D 04 
04171E 18      4149 JR      ARGUE6
04171F E9 
               4150 ;
041720 CD      4151 ARGUE7:			CALL    POPS
041721 E6 
041722 09 
041723 04 
041724 DD      4152 POP     IX
041725 E1 
041726 CD      4153 CALL    STACCS
041727 32 
041728 16 
041729 04 
04172A 18      4154 JR      ARGUE6
04172B DD 
               4155 
               4156 ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
               4157 ;   OF A FUNCTION OR PROCEDURE.
               4158 ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
               4159 ;    Inputs: IY is parameters pointer
               4160 ;   Outputs: IY updated
               4161 ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
               4162 ;
04172C D1      4163 SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
               4164 ;
04172D FD      4165 SAVLO1:			INC     IY              	; Bump past '(' or ','
04172E 23 
04172F CD      4166 CALL    NXT			; And also any whitespace
041730 78 
041731 0A 
041732 04 
041733 D5      4167 PUSH    DE			; Push the return address back onto the stack
041734 D9      4168 EXX
041735 C5      4169 PUSH    BC
041736 D5      4170 PUSH    DE
041737 E5      4171 PUSH    HL
041738 D9      4172 EXX
041739 CD      4173 CALL    VAR_             	; Dummy variable
04173A 96 
04173B 0C 
04173C 04 
04173D D9      4174 EXX
04173E E1      4175 POP     HL
04173F D1      4176 POP     DE
041740 C1      4177 POP     BC
041741 D9      4178 EXX
041742 D1      4179 POP     DE
041743 B7      4180 OR      A               	; Check the variable type
041744 FA      4181 JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041745 57 
041746 17 
041747 04 
041748 D9      4182 EXX
041749 E5      4183 PUSH    HL              	; Save H'L'
04174A D9      4184 EXX
04174B 47      4185 LD      B,A             	;  B: Variable type
04174C CD      4186 CALL    LOADN
04174D 1B 
04174E 04 
04174F 04 
041750 D9      4187 EXX
041751 E3      4188 EX      (SP),HL
041752 D9      4189 EXX
041753 E5      4190 PUSH    HL
041754 C5      4191 PUSH    BC
041755 18      4192 JR      SAVLO4
041756 2D 
               4193 ;
041757 F5      4194 SAVLO2:			PUSH    AF              	; Save the type (string)
041758 D5      4195 PUSH    DE
041759 D9      4196 EXX
04175A E5      4197 PUSH    HL
04175B D9      4198 EXX
04175C CD      4199 CALL    LOADS
04175D A5 
04175E 04 
04175F 04 
041760 D9      4200 EXX
041761 E1      4201 POP     HL
041762 D9      4202 EXX
041763 01      4203 LD	BC,0
041764 00 
041765 00 
041766 00 
041767 4B      4204 LD      C,E			; BC: String length
041768 D1      4205 POP     DE
041769 CD      4206 CALL    CHECK			; Check if there is space on the stack
04176A 81 
04176B 16 
04176C 04 
04176D F1      4207 POP     AF              	; Level stack
04176E 21      4208 LD      HL,0
04176F 00 
041770 00 
041771 00 
041772 ED      4209 SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041773 42 
041774 39      4210 ADD     HL,SP			; Make space for the string on the stack
041775 F9      4211 LD      SP,HL
041776 47      4212 LD      B,A             	;  B: Variable type
041777 C5      4213 PUSH    BC
041778 28      4214 JR      Z,SAVLO4
041779 0A 
04177A D5      4215 PUSH    DE
04177B 11      4216 LD      DE,ACCS
04177C 00 
04177D 4A 
04177E 04 
04177F EB      4217 EX      DE,HL
041780 45      4218 LD      B,L
041781 ED      4219 LDIR                    	; Save the string onto the stack
041782 B0 
041783 D1      4220 POP     DE
               4221 ;
041784 DD      4222 SAVLO4:			PUSH    IX			; VARPTR
041785 E5 
041786 CD      4223 CALL    SAVLO5
041787 8A 
041788 17 
041789 04 
               4224 LOCCHK:			EQU     $
04178A CD      4225 SAVLO5:			CALL    CHECK
04178B 81 
04178C 16 
04178D 04 
04178E CD      4226 CALL    NXT
04178F 78 
041790 0A 
041791 04 
041792 FE      4227 CP      ','             	; Are there any more local variables?
041793 2C 
041794 28      4228 JR      Z,SAVLO1		; Yes, so loop
041795 97 
041796 EB      4229 EX      DE,HL			; DE -> HL: The return address
041797 E9      4230 JP      (HL)            	; And effectvely return
               4231 ;
041798 FD      4232 DELIM:			LD      A,(IY)          	; Assembler delimiter
041799 7E 
04179A 00 
04179B FE      4233 CP      ' '
04179C 20 
04179D C8      4234 RET     Z
04179E FE      4235 CP      ','
04179F 2C 
0417A0 C8      4236 RET     Z
0417A1 FE      4237 CP      ')'
0417A2 29 
0417A3 C8      4238 RET     Z
0417A4 FE      4239 TERM:			CP      ';'             	; Assembler terminator
0417A5 3B 
0417A6 C8      4240 RET     Z
0417A7 FE      4241 CP      '\'
0417A8 5C 
0417A9 C8      4242 RET     Z
0417AA 18      4243 JR      TERM0
0417AB 07 
               4244 ;
0417AC CD      4245 TERMQ:			CALL    NXT
0417AD 78 
0417AE 0A 
0417AF 04 
0417B0 FE      4246 CP      ELSE_EX_
0417B1 8B 
0417B2 D0      4247 RET     NC
0417B3 FE      4248 TERM0:			CP      ':'             	; Assembler seperator
0417B4 3A 
0417B5 D0      4249 RET     NC
0417B6 FE      4250 CP      CR
0417B7 0D 
0417B8 C9      4251 RET
               4252 ;
0417B9 CD      4253 SPAN:			CALL    TERMQ
0417BA AC 
0417BB 17 
0417BC 04 
0417BD C8      4254 RET     Z
0417BE FD      4255 INC     IY
0417BF 23 
0417C0 18      4256 JR      SPAN
0417C1 F7 
               4257 ;
               4258 ; This snippet is used to check whether an expression is followed by an '=' symbol
               4259 ;
0417C2 CD      4260 EQUALS:			CALL    NXT			; Skip whitespace
0417C3 78 
0417C4 0A 
0417C5 04 
0417C6 FD      4261 INC     IY			; Skip past the character in question
0417C7 23 
0417C8 FE      4262 CP      '='			; Is it '='
0417C9 3D 
0417CA C8      4263 RET     Z			; Yes, so return
0417CB 3E      4264 LD      A,4			; Otherwise
0417CC 04 
0417CD C3      4265 JP      ERROR_           	; Throw error "Mistake"
0417CE 98 
0417CF 37 
0417D0 04 
               4266 ;
0417D1 FE      4267 FORMAT:			CP      TAB
0417D2 8A 
0417D3 28      4268 JR      Z,DOTAB
0417D4 0D 
0417D5 FE      4269 CP      SPC
0417D6 89 
0417D7 28      4270 JR      Z,DOSPC
0417D8 40 
0417D9 FE      4271 CP      '''
0417DA 27 
0417DB C0      4272 RET     NZ
0417DC CD      4273 CALL    CRLF
0417DD 7F 
0417DE 39 
0417DF 04 
0417E0 AF      4274 XOR     A
0417E1 C9      4275 RET
               4276 ;
0417E2 C5      4277 DOTAB:			PUSH    BC
0417E3 CD      4278 CALL    EXPRI
0417E4 0F 
0417E5 03 
0417E6 04 
0417E7 D9      4279 EXX
0417E8 C1      4280 POP     BC
0417E9 FD      4281 LD      A,(IY)
0417EA 7E 
0417EB 00 
0417EC FE      4282 CP      ','
0417ED 2C 
0417EE 28      4283 JR      Z,DOTAB1
0417EF 14 
0417F0 CD      4284 CALL    BRAKET
0417F1 37 
0417F2 0A 
0417F3 04 
0417F4 7D      4285 LD      A,L
0417F5 21      4286 TABIT:			LD      HL,COUNT
0417F6 3D 
0417F7 4D 
0417F8 04 
0417F9 BE      4287 CP      (HL)
0417FA C8      4288 RET     Z
0417FB F5      4289 PUSH    AF
0417FC DC      4290 CALL    C,CRLF
0417FD 7F 
0417FE 39 
0417FF 04 
041800 F1      4291 POP     AF
041801 96      4292 SUB     (HL)
041802 18      4293 JR      FILL
041803 1D 
041804 FD      4294 DOTAB1:			INC     IY
041805 23 
041806 C5      4295 PUSH    BC
041807 E5      4296 PUSH    HL
041808 CD      4297 CALL    EXPRI
041809 0F 
04180A 03 
04180B 04 
04180C D9      4298 EXX
04180D D1      4299 POP     DE
04180E C1      4300 POP     BC
04180F CD      4301 CALL    BRAKET
041810 37 
041811 0A 
041812 04 
041813 CD      4302 CALL    PUTCSR
041814 F9 
041815 3E 
041816 04 
041817 AF      4303 XOR     A
041818 C9      4304 RET
               4305 ;
041819 C5      4306 DOSPC:			PUSH    BC
04181A CD      4307 CALL    ITEMI
04181B 2A 
04181C 03 
04181D 04 
04181E D9      4308 EXX
04181F 7D      4309 LD      A,L
041820 C1      4310 POP     BC
041821 B7      4311 FILL:			OR      A
041822 C8      4312 RET     Z
041823 C5      4313 PUSH    BC
041824 47      4314 LD      B,A
041825 3E      4315 FILL1:			LD      A,' '
041826 20 
041827 CD      4316 CALL    OUTCHR
041828 87 
041829 39 
04182A 04 
04182B 10      4317 DJNZ    FILL1
04182C F8 
04182D C1      4318 POP     BC
04182E AF      4319 XOR     A
04182F C9      4320 RET
               4321 ;
041830 21      4322 PTEXT:			LD      HL,ACCS
041831 00 
041832 4A 
041833 04 
041834 1C      4323 INC     E
041835 1D      4324 PTEXT1:			DEC     E
041836 C8      4325 RET     Z
041837 7E      4326 LD      A,(HL)
041838 23      4327 INC     HL
041839 CD      4328 CALL    OUTCHR
04183A 87 
04183B 39 
04183C 04 
04183D 18      4329 JR      PTEXT1
04183E F6 
               4330 ;
04183F F5      4331 FETCHS:			PUSH    AF
041840 C5      4332 PUSH    BC
041841 E5      4333 PUSH    HL
041842 FD      4334 EX      (SP),IY
041843 E3 
041844 CD      4335 CALL    XTRACT
041845 5F 
041846 18 
041847 04 
041848 CD      4336 CALL    NXT
041849 78 
04184A 0A 
04184B 04 
04184C FD      4337 EX      (SP),IY
04184D E3 
04184E E1      4338 POP     HL
04184F C1      4339 POP     BC
041850 F1      4340 POP     AF
041851 C9      4341 RET
               4342 ;
041852 11      4343 LINES:			LD      DE,ACCS
041853 00 
041854 4A 
041855 04 
041856 7E      4344 LINE1S:			LD      A,(HL)
041857 12      4345 LD      (DE),A
041858 FE      4346 CP      CR
041859 0D 
04185A C8      4347 RET     Z
04185B 23      4348 INC     HL
04185C 1C      4349 INC     E
04185D 18      4350 JR      LINE1S
04185E F7 
               4351 ;
04185F CD      4352 XTRACT:			CALL    NXT
041860 78 
041861 0A 
041862 04 
041863 FE      4353 CP      '"'
041864 22 
041865 FD      4354 INC     IY
041866 23 
041867 CA      4355 JP      Z,CONS
041868 6C 
041869 04 
04186A 04 
04186B FD      4356 DEC     IY
04186C 2B 
04186D 11      4357 LD      DE,ACCS
04186E 00 
04186F 4A 
041870 04 
041871 FD      4358 XTRAC1:			LD      A,(IY)
041872 7E 
041873 00 
041874 12      4359 LD      (DE),A
041875 FE      4360 CP      ','
041876 2C 
041877 C8      4361 RET     Z
041878 FE      4362 CP      CR
041879 0D 
04187A C8      4363 RET     Z
04187B FD      4364 INC     IY
04187C 23 
04187D 1C      4365 INC     E
04187E 18      4366 JR      XTRAC1
04187F F1 
               4367 
               4368 ; Search for a token at the start of a program line
               4369 ; - HL: Pointer to the start of a tokenised line in the program area
               4370 ; Returns:
               4371 ; - HL: Pointer to the
               4372 ; -  F: Carry set if not found
               4373 ; Corrupts:
               4374 ; - BC
               4375 ;
041880 01      4376 SEARCH_EX:			LD      BC,0			; Clear BC
041881 00 
041882 00 
041883 00 
               4377 ;
041884 4E      4378 SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041885 0C      4379 INC     C			; Check for 0, i.e. end of program marker
041886 0D      4380 DEC     C
041887 28      4381 JR      Z,SRCH2_EX         	; Not found the token, so end
041888 0B 
041889 23      4382 INC     HL			; Skip the line length and line number
04188A 23      4383 INC     HL
04188B 23      4384 INC     HL
04188C BE      4385 CP      (HL)			; Compare with the token
04188D C8      4386 RET     Z			; Found it, so return with carry not set
04188E 0D      4387 DEC     C			; Skip to the next line
04188F 0D      4388 DEC     C
041890 0D      4389 DEC     C
041891 09      4390 ADD     HL,BC
041892 18      4391 JR      SRCH1_EX			; Rinse, lather and repeat
041893 F0 
               4392 ;
041894 2B      4393 SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041895 37      4394 SCF				; And set the carry flag
041896 C9      4395 RET
               4396 
               4397 ; Multiply by 4 or 5
               4398 ; This function is used to allocate space for dimensioned variables
               4399 ; This is a 24-bit operation
               4400 ; - DE: Number to multiple
               4401 ; -  A: 04h (Integer) - takes up 4 bytes
               4402 ;       05h (Float)   - takes up 5 bytes
               4403 ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
               4404 ; Returns:
               4405 ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
               4406 ; -  F: Carry if overflow
               4407 ; Corrupts:
               4408 ; - HL
041897 FE      4409 X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041898 04 
               4410 ; LD	HL,DE
041899 D5      4411 push de
04189A E1      4412 pop hl
04189B 29      4413 ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04189C D8      4414 RET     C			; Exit if overflow
04189D 29      4415 ADD     HL,HL			; Multiply by 2 again
04189E D8      4416 RET     C			; Exit if overflow
04189F EB      4417 EX      DE,HL			; DE: Product
0418A0 C8      4418 RET     Z			; Exit if A = 4
0418A1 19      4419 ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0418A2 EB      4420 EX      DE,HL			; DE: Product
0418A3 C9      4421 RET
               4422 
               4423 ; 16-bit unsigned multiply
               4424 ; - HL: Operand 1
               4425 ; - BC: Operand 2
               4426 ; Returns:
               4427 ; - HL: Result
               4428 ; -  F: C if overflow
               4429 ;
0418A4 C5      4430 MUL16:			PUSH	BC
0418A5 51      4431 LD	D, C			; Set up the registers for the multiplies
0418A6 5D      4432 LD	E, L
0418A7 69      4433 LD	L, C
0418A8 4B      4434 LD	C, E
0418A9 ED      4435 MLT	HL			; HL = H * C (*256)
0418AA 6C 
0418AB ED      4436 MLT	DE			; DE = L * C
0418AC 5C 
0418AD ED      4437 MLT	BC			; BC = B * L (*256)
0418AE 4C 
0418AF 09      4438 ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418B0 C1      4439 POP	BC
0418B1 AF      4440 XOR	A
0418B2 9C      4441 SBC	H			; If H is not zero then it's an overflow
0418B3 D8      4442 RET	C
0418B4 65      4443 LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418B5 6F      4444 LD	L, A
0418B6 19      4445 ADD	HL, DE
0418B7 C9      4446 RET
               4447 ;
0418B8 CD      4448 CHANEL:			CALL    NXT			; Skip whitespace
0418B9 78 
0418BA 0A 
0418BB 04 
0418BC FE      4449 CP      '#'			; Check for the '#' symbol
0418BD 23 
0418BE 3E      4450 LD      A,45
0418BF 2D 
0418C0 C2      4451 JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418C1 98 
0418C2 37 
0418C3 04 
0418C4 FD      4452 CHNL:			INC     IY             		; Bump past the '#'
0418C5 23 
0418C6 CD      4453 CALL    ITEMI			; Get the channel number
0418C7 2A 
0418C8 03 
0418C9 04 
0418CA D9      4454 EXX
0418CB EB      4455 EX      DE,HL			; DE: The channel number
0418CC C9      4456 RET
               4457 
               4458 ; ASSEMBLER -------------------------------------------------------------------
               4459 
               4460 ; Language independant control section:
               4461 ;  Outputs: A=delimiter, carry set if syntax error.
               4462 ;
0418CD CD      4463 ASSEM:			CALL    SKIP
0418CE ED 
0418CF 1D 
0418D0 04 
0418D1 FD      4464 INC     IY
0418D2 23 
0418D3 FE      4465 CP      ':'
0418D4 3A 
0418D5 28      4466 JR      Z,ASSEM
0418D6 F6 
0418D7 FE      4467 CP      ']'
0418D8 5D 
0418D9 C8      4468 RET     Z
0418DA FE      4469 CP      CR
0418DB 0D 
0418DC C8      4470 RET     Z
0418DD FD      4471 DEC     IY
0418DE 2B 
0418DF DD      4472 LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
0418E0 2A 
0418E1 40 
0418E2 30 
0418E2 11   
0418E4 21      4473 LD      HL,LISTON
0418E5 40 
0418E6 4D 
0418E7 04 
0418E8 CB      4474 BIT     6,(HL)
0418E9 76 
0418EA 28      4475 JR      Z,ASSEM0
0418EB 05 
0418EC DD      4476 LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
0418ED 2A 
0418EE 3C 
0418EF 30 
0418EF 11   
0418F1 DD      4477 ASSEM0:			PUSH    IX
0418F2 E5 
0418F3 FD      4478 PUSH    IY
0418F4 E5 
0418F5 CD      4479 CALL    ASMB
0418F6 A5 
0418F7 19 
0418F8 04 
0418F9 C1      4480 POP     BC
0418FA D1      4481 POP     DE
0418FB D8      4482 RET     C
0418FC CD      4483 CALL    SKIP
0418FD ED 
0418FE 1D 
0418FF 04 
041900 37      4484 SCF
041901 C0      4485 RET     NZ
041902 FD      4486 DEC     IY
041903 2B 
041904 FD      4487 ASSEM3:			INC     IY
041905 23 
041906 FD      4488 LD      A,(IY)
041907 7E 
041908 00 
041909 CD      4489 CALL    TERM0
04190A B3 
04190B 17 
04190C 04 
04190D 20      4490 JR      NZ,ASSEM3
04190E F5 
04190F 3A      4491 LD      A,(LISTON)
041910 40 
041911 4D 
041912 04 
041913 DD      4492 PUSH    IX
041914 E5 
041915 E1      4493 POP     HL
041916 B7      4494 OR      A
041917 ED      4495 SBC     HL,DE
041918 52 
041919 EB      4496 EX      DE,HL           	; DE: Number of bytes
04191A E5      4497 PUSH    HL
04191B 2A      4498 LD      HL,(PC)
04191C 40 
04191D 30 
04191E 11 
04191F E5      4499 PUSH    HL
041920 19      4500 ADD     HL,DE
041921 22      4501 LD      (PC),HL         	; Update PC
041922 40 
041923 30 
041924 11 
041925 CB      4502 BIT     6,A
041926 77 
041927 28      4503 JR      Z,ASSEM5
041928 09 
041929 2A      4504 LD      HL,(OC)
04192A 3C 
04192B 30 
04192C 11 
04192D 19      4505 ADD     HL,DE
04192E 22      4506 LD      (OC),HL         	; Update OC
04192F 3C 
041930 30 
041931 11 
041932 E1      4507 ASSEM5:			POP     HL              	; Old PC
041933 DD      4508 POP     IX              	; Code here
041934 E1 
041935 CB      4509 BIT     4,A
041936 67 
041937 28      4510 JR      Z,ASSEM
041938 94 
041939 22      4511 LD	(R0),HL			; Store HL in R0 so we can access the MSB
04193A 4A 
04193B 4D 
04193C 04 
04193D 3A      4512 LD	A,(R0+2)		; Print out the address
04193E 4C 
04193F 4D 
041940 04 
041941 CD      4513 CALL	HEX_EX
041942 8F 
041943 19 
041944 04 
041945 7C      4514 LD      A,H
041946 CD      4515 CALL    HEX_EX
041947 8F 
041948 19 
041949 04 
04194A 7D      4516 LD      A,L
04194B CD      4517 CALL    HEXSP
04194C 87 
04194D 19 
04194E 04 
04194F AF      4518 XOR     A
041950 BB      4519 CP      E
041951 28      4520 JR      Z,ASSEM2
041952 18 
               4521 ;
041953 3A      4522 ASSEM1:			LD      A,(COUNT)
041954 3D 
041955 4D 
041956 04 
041957 FE      4523 CP      20
041958 14 
041959 3E      4524 LD      A,7
04195A 07 
04195B D4      4525 CALL    NC,TABIT        	; Next line
04195C F5 
04195D 17 
04195E 04 
04195F DD      4526 LD      A,(IX)
041960 7E 
041961 00 
041962 CD      4527 CALL    HEXSP
041963 87 
041964 19 
041965 04 
041966 DD      4528 INC     IX
041967 23 
041968 1D      4529 DEC     E
041969 20      4530 JR      NZ,ASSEM1
04196A E8 
               4531 ;
04196B 3E      4532 ASSEM2:			LD      A,22			; Tab to the disassembly field
04196C 16 
04196D CD      4533 CALL    TABIT
04196E F5 
04196F 17 
041970 04 
041971 FD      4534 PUSH    IY
041972 E5 
041973 E1      4535 POP     HL
041974 ED      4536 SBC     HL,BC
041975 42 
041976 0A      4537 ASSEM4:			LD      A,(BC)
041977 CD      4538 CALL    OUT_
041978 A4 
041979 39 
04197A 04 
04197B 03      4539 INC     BC
04197C 2D      4540 DEC     L
04197D 20      4541 JR      NZ,ASSEM4
04197E F7 
04197F CD      4542 CALL    CRLF
041980 7F 
041981 39 
041982 04 
041983 C3      4543 JP      ASSEM
041984 CD 
041985 18 
041986 04 
               4544 ;
041987 CD      4545 HEXSP:			CALL    HEX_EX
041988 8F 
041989 19 
04198A 04 
04198B 3E      4546 LD      A,' '
04198C 20 
04198D 18      4547 JR      OUTCH1
04198E 12 
04198F F5      4548 HEX_EX:			PUSH    AF
041990 0F      4549 RRCA
041991 0F      4550 RRCA
041992 0F      4551 RRCA
041993 0F      4552 RRCA
041994 CD      4553 CALL    HEXOUT
041995 99 
041996 19 
041997 04 
041998 F1      4554 POP     AF
041999 E6      4555 HEXOUT:			AND     0FH
04199A 0F 
04199B C6      4556 ADD     A,90H
04199C 90 
04199D 27      4557 DAA
04199E CE      4558 ADC     A,40H
04199F 40 
0419A0 27      4559 DAA
0419A1 C3      4560 OUTCH1:			JP      OUT_
0419A2 A4 
0419A3 39 
0419A4 04 
               4561 
               4562 ; Processor Specific Translation Section:
               4563 ;
               4564 ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
               4565 ;                 C: Opcode beig built
               4566 ;                 D: Flags
               4567 ;			Bit 7: Set to 1 if the instruction uses long addressing
               4568 ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
               4569 ;                 E: Offset from IX or IY
               4570 ;                HL: Numeric operand value
               4571 ;                IX: Code destination pointer
               4572 ;                IY: Source text pointer
               4573 ;    Inputs: A = initial character
               4574 ;   Outputs: Carry set if syntax error.
               4575 ;
0419A5 FE      4576 ASMB:			CP      '.'			; Check for a dot; this indicates a label
0419A6 2E 
0419A7 20      4577 JR      NZ,ASMB1		; No, so just process the instruction
0419A8 1F 
0419A9 FD      4578 INC     IY			; Skip past the dot to the label name
0419AA 23 
0419AB DD      4579 PUSH    IX			; Store the code destination pointer
0419AC E5 
0419AD CD      4580 CALL    VAR_			; Create a variable
0419AE 96 
0419AF 0C 
0419B0 04 
0419B1 F5      4581 PUSH    AF
0419B2 CD      4582 CALL    ZERO			; Zero it
0419B3 98 
0419B4 09 
0419B5 04 
0419B6 3A      4583 LD	A,(PC+2)
0419B7 42 
0419B8 30 
0419B9 11 
0419BA 6F      4584 LD	L,A			; The MSB of the 24-bit address
0419BB D9      4585 EXX
0419BC 2A      4586 LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419BD 40 
0419BE 30 
0419BF 11 
0419C0 D9      4587 EXX
0419C1 F1      4588 POP     AF
0419C2 CD      4589 CALL    STORE			; Store the program counter
0419C3 08 
0419C4 16 
0419C5 04 
0419C6 DD      4590 POP     IX			; Restore the code destination pointer
0419C7 E1 
               4591 ;
0419C8 3A      4592 ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419C9 40 
0419CA 4D 
0419CB 04 
0419CC E6      4593 AND	80H
0419CD 80 
0419CE 57      4594 LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419CF CD      4595 CALL    SKIP			; Skip any whitespace
0419D0 ED 
0419D1 1D 
0419D2 04 
0419D3 C8      4596 RET     Z			; And return if there is nothing further to process
0419D4 FE      4597 CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419D5 D6 
0419D6 0E      4598 LD      C,0C4H			;  A: The base operand
0419D7 C4 
0419D8 FD      4599 INC     IY			; Skip past the token
0419D9 23 
0419DA CA      4600 JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419DB 22 
0419DC 1B 
0419DD 04 
0419DE FD      4601 DEC     IY			; Skip back, as we're not doing the above at this point
0419DF 2B 
0419E0 21      4602 LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419E1 04 
0419E2 1E 
0419E3 04 
0419E4 CD      4603 CALL    FIND			; Find the opcode
0419E5 9C 
0419E6 1D 
0419E7 04 
0419E8 D8      4604 RET     C			; If not found, then return; carry indicates an error condition
0419E9 48      4605 LD      C,B     		;  C: A copy of the opcode
               4606 ;
               4607 ; GROUP 0: Trivial cases requiring no computation
               4608 ; GROUP 1: As Group 0, but with "ED" prefix
               4609 ;
0419EA D6      4610 SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419EB 44 
0419EC 30      4611 JR      NC,GROUP02		; If not in that range, then check GROUP2
0419ED 08 
0419EE FE      4612 CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419EF CB 
0419F0 D4      4613 CALL    NC,ED			; Needs to be prefixed with ED
0419F1 F5 
0419F2 1C 
0419F3 04 
0419F4 18      4614 JR      BYTE0			; Then write the opcode byte
0419F5 76 
               4615 ;
               4616 ; GROUP 2: BIT, RES, SET
               4617 ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
               4618 ;
0419F6 D6      4619 GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419F7 0A 
0419F8 30      4620 JR      NC,GROUP04		; If not in that range, then check GROUP4
0419F9 12 
0419FA FE      4621 CP      3-10			;
0419FB F9 
0419FC DC      4622 CALL    C,BIT_
0419FD 8A 
0419FE 1D 
0419FF 04 
041A00 D8      4623 RET     C
041A01 CD      4624 CALL    REGLO
041A02 5B 
041A03 1D 
041A04 04 
041A05 D8      4625 RET     C
041A06 CD      4626 CALL    CB
041A07 F9 
041A08 1C 
041A09 04 
041A0A 18      4627 JR      BYTE0
041A0B 60 
               4628 ;
               4629 ; GROUP 4 - PUSH, POP, EX (SP)
               4630 ;
041A0C D6      4631 GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A0D 03 
041A0E 30      4632 JR      NC,GROUP05		; If not in that range, then check GROUP5
041A0F 07 
041A10 CD      4633 GROUP04_1:		CALL    PAIR_EX
041A11 7D 
041A12 1D 
041A13 04 
041A14 D8      4634 RET     C
041A15 18      4635 JR      BYTE0
041A16 55 
               4636 ;
               4637 ; GROUP 5 - SUB, AND, XOR, OR, CP
               4638 ; GROUP 6 - ADD, ADC, SBC
               4639 ;
041A17 D6      4640 GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A18 0A 
041A19 30      4641 JR      NC,GROUP07
041A1A 39 
041A1B FE      4642 CP      5-8
041A1C FD 
041A1D 06      4643 LD      B,7
041A1E 07 
041A1F D4      4644 CALL    NC,OPND			; Get the first operand
041A20 09 
041A21 1D 
041A22 04 
041A23 78      4645 LD      A,B
041A24 FE      4646 CP      7			; Is the operand 'A'?
041A25 07 
041A26 20      4647 JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A27 15 
               4648 ;
041A28 CD      4649 GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A29 5B 
041A2A 1D 
041A2B 04 
041A2C 79      4650 LD      A,C
041A2D 30      4651 JR      NC,BIND1		; If it is a register, then write that out
041A2E 2E 
041A2F EE      4652 XOR     46H			; Handle ADD A,n
041A30 46 
041A31 CD      4653 CALL    BIND
041A32 FB 
041A33 1C 
041A34 04 
041A35 CD      4654 DB_:			CALL    NUMBER
041A36 3B 
041A37 1D 
041A38 04 
041A39 C3      4655 JP      VAL8
041A3A F4 
041A3B 1A 
041A3C 04 
               4656 ;
041A3D E6      4657 GROUP05_HL:		AND     3FH
041A3E 3F 
041A3F FE      4658 CP      12
041A40 0C 
041A41 37      4659 SCF
041A42 C0      4660 RET     NZ
041A43 79      4661 LD      A,C
041A44 FE      4662 CP      80H
041A45 80 
041A46 0E      4663 LD      C,9
041A47 09 
041A48 28      4664 JR      Z,GROUP04_1
041A49 C6 
041A4A EE      4665 XOR     1CH
041A4B 1C 
041A4C 0F      4666 RRCA
041A4D 4F      4667 LD      C,A
041A4E CD      4668 CALL    ED
041A4F F5 
041A50 1C 
041A51 04 
041A52 18      4669 JR      GROUP04_1
041A53 BC 
               4670 ;
               4671 ; GROUP 7 - INC, DEC
               4672 ;
041A54 D6      4673 GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A55 02 
041A56 30      4674 JR      NC,GROUP08
041A57 19 
041A58 CD      4675 CALL    REGHI
041A59 62 
041A5A 1D 
041A5B 04 
041A5C 79      4676 LD      A,C
041A5D D2      4677 BIND1:			JP      NC,BIND
041A5E FB 
041A5F 1C 
041A60 04 
041A61 EE      4678 XOR     64H
041A62 64 
041A63 07      4679 RLCA
041A64 07      4680 RLCA
041A65 07      4681 RLCA
041A66 4F      4682 LD      C,A
041A67 CD      4683 CALL    PAIR1_EX
041A68 82 
041A69 1D 
041A6A 04 
041A6B D8      4684 RET     C
041A6C 79      4685 BYTE0:			LD      A,C
041A6D C3      4686 JP      BYTE_
041A6E 2A 
041A6F 1D 
041A70 04 
               4687 ;
               4688 ; Group 8: IN0, OUT0
               4689 ;
041A71 D6      4690 GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A72 02 
041A73 30      4691 JR	NC,GROUP09
041A74 2C 
041A75 FE      4692 CP	1-2
041A76 FF 
041A77 CC      4693 CALL    Z,NUMBER		; Fetch number first if OUT
041A78 3B 
041A79 1D 
041A7A 04 
041A7B 08      4694 EX      AF,AF'			; Save flags
041A7C CD      4695 CALL    REG			; Get the register value regardless
041A7D 4F 
041A7E 1D 
041A7F 04 
041A80 D8      4696 RET     C			; Return if not a register
041A81 08      4697 EX      AF,AF'			; Restore the flags
041A82 DC      4698 CALL    C,NUMBER		; Fetch number last if IN
041A83 3B 
041A84 1D 
041A85 04 
041A86 78      4699 LD	A,B			; Get the register number
041A87 FE      4700 CP	6			; Fail on (HL)
041A88 06 
041A89 37      4701 SCF
041A8A C8      4702 RET	Z
041A8B FE      4703 CP	8			; Check it is just single pairs only
041A8C 08 
041A8D 3F      4704 CCF
041A8E D8      4705 RET	C			; And return if it is an invalid register
041A8F 07      4706 RLCA				; Bind with the operand
041A90 07      4707 RLCA
041A91 07      4708 RLCA
041A92 81      4709 ADD	A,C
041A93 4F      4710 LD	C,A
041A94 CD      4711 CALL	ED			; Prefix with ED
041A95 F5 
041A96 1C 
041A97 04 
041A98 79      4712 LD	A,C
041A99 CD      4713 CALL	BYTE_			; Write out the operand
041A9A 2A 
041A9B 1D 
041A9C 04 
041A9D C3      4714 JP	VAL8			; Write out the value
041A9E F4 
041A9F 1A 
041AA0 04 
               4715 ;
               4716 ; GROUP 9 - IN
               4717 ; GROUP 10 - OUT
               4718 ;
041AA1 D6      4719 GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041AA2 02 
041AA3 30      4720 JR      NC,GROUP11
041AA4 25 
041AA5 FE      4721 CP      1-2			; Check if Group 9 or Group 1
041AA6 FF 
041AA7 CC      4722 CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AA8 E9 
041AA9 1C 
041AAA 04 
041AAB 08      4723 EX      AF,AF'			; Save flags
041AAC CD      4724 CALL    REGHI			; Get the register value regardless
041AAD 62 
041AAE 1D 
041AAF 04 
041AB0 D8      4725 RET     C			; Return if not a register
041AB1 08      4726 EX      AF,AF'			; Restore the flags
041AB2 DC      4727 CALL    C,CORN			; Call CORN if Group 9 (IN)
041AB3 E9 
041AB4 1C 
041AB5 04 
041AB6 24      4728 INC     H			; If it is IN r,(C) or OUT (C),r then
041AB7 28      4729 JR      Z,BYTE0			; Just write the operand out
041AB8 B3 
               4730 ;
041AB9 78      4731 LD      A,B			; Check the register
041ABA FE      4732 CP      7
041ABB 07 
041ABC 37      4733 SCF
041ABD C0      4734 RET     NZ			; If it is not A, then return
               4735 ;
041ABE 79      4736 LD      A,C			; Bind the register with the operand
041ABF EE      4737 XOR     3
041AC0 03 
041AC1 07      4738 RLCA
041AC2 07      4739 RLCA
041AC3 07      4740 RLCA
041AC4 CD      4741 CALL    BYTE_			; Write out the operand
041AC5 2A 
041AC6 1D 
041AC7 04 
041AC8 18      4742 JR      VAL8			; And the value
041AC9 2A 
               4743 ;
               4744 ; GROUP 11 - JR, DJNZ
               4745 ;
041ACA D6      4746 GROUP11:		SUB     2			; The number of opcodes in GROUP11
041ACB 02 
041ACC 30      4747 JR      NC,GROUP12
041ACD 2B 
041ACE FE      4748 CP      1-2
041ACF FF 
041AD0 C4      4749 CALL    NZ,COND_
041AD1 69 
041AD2 1D 
041AD3 04 
041AD4 79      4750 LD      A,C
041AD5 30      4751 JR      NC,@F
041AD6 02 
041AD7 3E      4752 LD      A,18H
041AD8 18 
041AD9 CD      4753 @@:			CALL    BYTE_
041ADA 2A 
041ADB 1D 
041ADC 04 
041ADD CD      4754 CALL    NUMBER
041ADE 3B 
041ADF 1D 
041AE0 04 
041AE1 ED      4755 LD      DE,(PC)
041AE2 5B 
041AE3 40 
041AE4 30 
041AE4 11   
041AE6 13      4756 INC     DE
041AE7 37      4757 SCF
041AE8 ED      4758 SBC     HL,DE
041AE9 52 
041AEA 7D      4759 LD      A,L
041AEB 17      4760 RLA
041AEC 9F      4761 SBC     A,A
041AED BC      4762 CP      H
041AEE 3E      4763 TOOFAR:			LD      A,1
041AEF 01 
041AF0 C2      4764 JP      NZ,ERROR_		; Throw an "Out of range" error
041AF1 98 
041AF2 37 
041AF3 04 
041AF4 7D      4765 VAL8:			LD      A,L
041AF5 C3      4766 JP      BYTE_
041AF6 2A 
041AF7 1D 
041AF8 04 
               4767 ;
               4768 ; GROUP 12 - JP
               4769 ;
041AF9 D6      4770 GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AFA 01 
041AFB 30      4771 JR	NC,GROUP13
041AFC 21 
041AFD CD      4772 CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AFE 4F 
041AFF 1C 
041B00 04 
041B01 D8      4773 RET	C			; Exit if an invalid suffix is provided
041B02 CD      4774 CALL    COND_			; Evaluate the conditions
041B03 69 
041B04 1D 
041B05 04 
041B06 79      4775 LD      A,C
041B07 30      4776 JR      NC,GROUP12_1
041B08 0D 
041B09 78      4777 LD      A,B
041B0A E6      4778 AND     3FH
041B0B 3F 
041B0C FE      4779 CP      6
041B0D 06 
041B0E 3E      4780 LD      A,0E9H
041B0F E9 
041B10 CA      4781 JP      Z,BYTE_
041B11 2A 
041B12 1D 
041B13 04 
041B14 3E      4782 LD      A,0C3H
041B15 C3 
041B16 CD      4783 GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B17 2A 
041B18 1D 
041B19 04 
041B1A C3      4784 JP	ADDR_			; Output the address
041B1B A4 
041B1C 1C 
041B1D 04 
               4785 ;
               4786 ; GROUP 13 - CALL
               4787 ;
041B1E D6      4788 GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B1F 01 
041B20 30      4789 JR	NC,GROUP14
041B21 0C 
041B22 CD      4790 GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B23 67 
041B24 1C 
041B25 04 
041B26 CD      4791 CALL    GROUP15_1		; Output the opcode (with conditions)
041B27 49 
041B28 1B 
041B29 04 
041B2A C3      4792 JP	ADDR_			; Output the address
041B2B A4 
041B2C 1C 
041B2D 04 
               4793 ;
               4794 ; GROUP 14 - RST
               4795 ;
041B2E D6      4796 GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B2F 01 
041B30 30      4797 JR	NC,GROUP15
041B31 13 
041B32 CD      4798 CALL	EZ80SF_FULL		; Evaluate the suffix
041B33 67 
041B34 1C 
041B35 04 
041B36 D8      4799 RET	C			; Exit if an invalid suffix provided
041B37 CD      4800 CALL    NUMBER
041B38 3B 
041B39 1D 
041B3A 04 
041B3B A1      4801 AND     C
041B3C B4      4802 OR      H
041B3D 20      4803 JR      NZ,TOOFAR
041B3E AF 
041B3F 7D      4804 LD      A,L
041B40 B1      4805 OR      C
041B41 C3      4806 JP      BYTE_
041B42 2A 
041B43 1D 
041B44 04 
               4807 ;
               4808 ; GROUP 15 - RET
               4809 ;
041B45 D6      4810 GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B46 01 
041B47 30      4811 JR	NC,GROUP16
041B48 0F 
041B49 CD      4812 GROUP15_1:		CALL    COND_
041B4A 69 
041B4B 1D 
041B4C 04 
041B4D 79      4813 LD      A,C
041B4E D2      4814 JP      NC,BYTE_
041B4F 2A 
041B50 1D 
041B51 04 
041B52 F6      4815 OR      9
041B53 09 
041B54 C3      4816 JP      BYTE_
041B55 2A 
041B56 1D 
041B57 04 
               4817 ;
               4818 ; GROUP 16 - LD
               4819 ;
041B58 D6      4820 GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B59 01 
041B5A 30      4821 JR	NC,GROUP17
041B5B 74 
041B5C CD      4822 CALL	EZ80SF_FULL		; Evaluate the suffix
041B5D 67 
041B5E 1C 
041B5F 04 
041B60 CD      4823 CALL    LDOP			; Check for accumulator loads
041B61 98 
041B62 1D 
041B63 04 
041B64 D2      4824 JP      NC,LDA			; Yes, so jump here
041B65 C4 
041B66 1C 
041B67 04 
041B68 CD      4825 CALL    REGHI
041B69 62 
041B6A 1D 
041B6B 04 
041B6C 08      4826 EX      AF,AF'
041B6D CD      4827 CALL    SKIP
041B6E ED 
041B6F 1D 
041B70 04 
041B71 FE      4828 CP      '('			; Check for bracket
041B72 28 
041B73 28      4829 JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B74 24 
041B75 08      4830 EX      AF,AF'
041B76 D2      4831 JP      NC,GROUP05_1		; Load single register direct; go here
041B77 28 
041B78 1A 
041B79 04 
041B7A 0E      4832 LD      C,1
041B7B 01 
041B7C CD      4833 CALL    PAIR1_EX
041B7D 82 
041B7E 1D 
041B7F 04 
041B80 D8      4834 RET     C
041B81 3E      4835 LD      A,14
041B82 0E 
041B83 B8      4836 CP      B
041B84 47      4837 LD      B,A
041B85 CC      4838 CALL    Z,PAIR_EX
041B86 7D 
041B87 1D 
041B88 04 
041B89 78      4839 LD      A,B
041B8A E6      4840 AND     3FH
041B8B 3F 
041B8C FE      4841 CP      12
041B8D 0C 
041B8E 79      4842 LD      A,C
041B8F C2      4843 JP      NZ,GROUP12_1		; Load register pair direct; go here
041B90 16 
041B91 1B 
041B92 04 
041B93 3E      4844 LD      A,0F9H
041B94 F9 
041B95 C3      4845 JP      BYTE_
041B96 2A 
041B97 1D 
041B98 04 
               4846 ;
041B99 08      4847 LDIN:			EX      AF,AF'
041B9A C5      4848 PUSH    BC
041B9B D4      4849 CALL    NC,REGLO
041B9C 5B 
041B9D 1D 
041B9E 04 
041B9F 79      4850 LD      A,C
041BA0 C1      4851 POP     BC
041BA1 D2      4852 JP      NC,BIND
041BA2 FB 
041BA3 1C 
041BA4 04 
041BA5 0E      4853 LD      C,0AH
041BA6 0A 
041BA7 CD      4854 CALL    PAIR1_EX
041BA8 82 
041BA9 1D 
041BAA 04 
041BAB CD      4855 CALL    LD16
041BAC CF 
041BAD 1C 
041BAE 04 
041BAF D2      4856 JP      NC,GROUP12_1
041BB0 16 
041BB1 1B 
041BB2 04 
041BB3 CD      4857 CALL    NUMBER
041BB4 3B 
041BB5 1D 
041BB6 04 
041BB7 0E      4858 LD      C,2
041BB8 02 
041BB9 CD      4859 CALL    PAIR_EX
041BBA 7D 
041BBB 1D 
041BBC 04 
041BBD CD      4860 CALL    LD16
041BBE CF 
041BBF 1C 
041BC0 04 
041BC1 D8      4861 RET     C
041BC2 CD      4862 CALL    BYTE_
041BC3 2A 
041BC4 1D 
041BC5 04 
041BC6 CB      4863 BIT	7,D			; Check the ADL flag
041BC7 7A 
041BC8 C2      4864 JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BC9 B9 
041BCA 1C 
041BCB 04 
041BCC C3      4865 JP      VAL16			; Otherwise use 16-bit addresses
041BCD AC 
041BCE 1C 
041BCF 04 
               4866 ;
               4867 ; Group 17 - TST
               4868 ;
041BD0 D6      4869 GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BD1 01 
041BD2 30      4870 JR	NC,OPTS
041BD3 25 
041BD4 CD      4871 CALL	ED			; Needs to be prefixed with ED
041BD5 F5 
041BD6 1C 
041BD7 04 
041BD8 CD      4872 CALL	REG			; Fetch the register
041BD9 4F 
041BDA 1D 
041BDB 04 
041BDC 30      4873 JR	NC,GROUP17_1		; It's just a register
041BDD 0E 
               4874 ;
041BDE 3E      4875 LD	A,64H			; Opcode for TST n
041BDF 64 
041BE0 CD      4876 CALL	BYTE_			; Write out the opcode
041BE1 2A 
041BE2 1D 
041BE3 04 
041BE4 CD      4877 CALL	NUMBER			; Get the number
041BE5 3B 
041BE6 1D 
041BE7 04 
041BE8 C3      4878 JP	VAL8			; And write that out
041BE9 F4 
041BEA 1A 
041BEB 04 
               4879 ;
041BEC 78      4880 GROUP17_1:		LD	A,B			; Check the register rangs
041BED FE      4881 CP	8
041BEE 08 
041BEF 3F      4882 CCF
041BF0 D8      4883 RET	C			; Ret with carry flag set for error if out of range
041BF1 07      4884 RLCA				; Get the opcode value
041BF2 07      4885 RLCA
041BF3 07      4886 RLCA
041BF4 81      4887 ADD	A,C			; Add the opcode base in
041BF5 C3      4888 JP	BYTE_
041BF6 2A 
041BF7 1D 
041BF8 04 
               4889 
               4890 ;
               4891 ; Assembler directives - OPT, ADL
               4892 ;
041BF9 D6      4893 OPTS:			SUB	2
041BFA 02 
041BFB 30      4894 JR	NC, DEFS
041BFC 2B 
041BFD FE      4895 CP	1-2			; Check for ADL opcode
041BFE FF 
041BFF 28      4896 JR	Z, ADL_
041C00 13 
               4897 ;
041C01 CD      4898 OPT:			CALL    NUMBER			; Fetch the OPT value
041C02 3B 
041C03 1D 
041C04 04 
041C05 21      4899 LD      HL,LISTON		; Address of the LISTON/OPT flag
041C06 40 
041C07 4D 
041C08 04 
041C09 E6      4900 AND	7			; Only interested in the first three bits
041C0A 07 
041C0B 4F      4901 LD      C,A			; Store the new OPT value in C
041C0C ED      4902 RLD				; Shift the top nibble of LISTON (OPT) into A
041C0D 6F 
041C0E E6      4903 AND	8			; Clear the bottom three bits, preserving the ADL bit
041C0F 08 
041C10 B1      4904 OR	C			; OR in the new value
041C11 ED      4905 RRD				; And shift the nibble back in
041C12 67 
041C13 C9      4906 RET
               4907 ;
041C14 CD      4908 ADL_:			CALL	NUMBER			; Fetch the ADL value
041C15 3B 
041C16 1D 
041C17 04 
041C18 E6      4909 AND	1			; Only interested if it is 0 or 1
041C19 01 
041C1A 0F      4910 RRCA				; Rotate to bit 7
041C1B 4F      4911 LD	C,A			; Store in C
041C1C 3A      4912 LD	A,(LISTON)		; Get the LISTON system variable
041C1D 40 
041C1E 4D 
041C1F 04 
041C20 E6      4913 AND	7Fh			; Clear bit 7
041C21 7F 
041C22 B1      4914 OR	C			; OR in the ADL value
041C23 32      4915 LD	(LISTON),A		; Store
041C24 40 
041C25 4D 
041C26 04 
041C27 C9      4916 RET
               4917 ;
               4918 ; DEFB, DEFW, DEFL, DEFM
               4919 ;
041C28 B7      4920 DEFS:			OR	A			; Handle DEFB
041C29 CA      4921 JP	Z, DB_
041C2A 35 
041C2B 1A 
041C2C 04 
041C2D 3D      4922 DEC	A			; Handle DEFW
041C2E CA      4923 JP	Z, ADDR16
041C2F A8 
041C30 1C 
041C31 04 
041C32 3D      4924 DEC	A			; Handle DEFL
041C33 CA      4925 JP	Z, ADDR24
041C34 B5 
041C35 1C 
041C36 04 
               4926 ;
041C37 DD      4927 PUSH    IX			; Handle DEFM
041C38 E5 
041C39 CD      4928 CALL    EXPRS
041C3A 1A 
041C3B 03 
041C3C 04 
041C3D DD      4929 POP     IX
041C3E E1 
041C3F 21      4930 LD      HL,ACCS
041C40 00 
041C41 4A 
041C42 04 
041C43 AF      4931 @@:			XOR     A
041C44 BB      4932 CP      E
041C45 C8      4933 RET     Z
041C46 7E      4934 LD      A,(HL)
041C47 23      4935 INC     HL
041C48 CD      4936 CALL    BYTE_
041C49 2A 
041C4A 1D 
041C4B 04 
041C4C 1D      4937 DEC     E
041C4D 18      4938 JR      @B
041C4E F4 
               4939 
               4940 ;
               4941 ;SUBROUTINES:
               4942 ;
041C4F FD      4943 EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C50 7E 
041C51 00 
041C52 FE      4944 CP	'.'
041C53 2E 
041C54 28      4945 JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C55 02 
041C56 B7      4946 OR	A			; Reset the carry flag (no error)
041C57 C9      4947 RET				; And return
041C58 FD      4948 @@:			INC	IY			; Skip the dot
041C59 23 
041C5A C5      4949 PUSH	BC			; Push the operand
041C5B 21      4950 LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C5C 83 
041C5D 20 
041C5E 04 
041C5F CD      4951 CALL	FIND			; Look up the operand
041C60 9C 
041C61 1D 
041C62 04 
041C63 30      4952 JR	NC,EZ80SF_OK
041C64 24 
041C65 C1      4953 POP	BC			; Not found at this point, so will return with a C (error)
041C66 C9      4954 RET
               4955 ;
041C67 FD      4956 EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C68 7E 
041C69 00 
041C6A FE      4957 CP	'.'
041C6B 2E 
041C6C 28      4958 JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C6D 02 
041C6E B7      4959 OR	A			; Reset the carry flag (no error)
041C6F C9      4960 RET				; And return
041C70 FD      4961 @@:			INC	IY 			; Skip the dot
041C71 23 
041C72 C5      4962 PUSH	BC			; Push the operand
041C73 21      4963 LD	HL,EZ80SFS_1		; First check the fully qualified table
041C74 7B 
041C75 20 
041C76 04 
041C77 CD      4964 CALL	FIND 			; Look up the operand
041C78 9C 
041C79 1D 
041C7A 04 
041C7B 30      4965 JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C7C 0C 
041C7D CD      4966 CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C7E 98 
041C7F 1C 
041C80 04 
041C81 CD      4967 CALL	FIND
041C82 9C 
041C83 1D 
041C84 04 
041C85 30      4968 JR	NC,EZ80SF_OK
041C86 02 
041C87 C1      4969 POP	BC			; Not found at this point, so will return with a C (error)
041C88 C9      4970 RET
               4971 ;
041C89 78      4972 EZ80SF_OK:		LD	A,B			; The operand value
041C8A D4      4973 CALL	NC,BYTE_ 		; Write it out if found
041C8B 2A 
041C8C 1D 
041C8D 04 
041C8E CB      4974 RES	7,D			; Clear the default ADL mode from the flags
041C8F BA 
041C90 E6      4975 AND	2			; Check the second half of the suffix (.xxL)
041C91 02 
041C92 0F      4976 RRCA				; Shift into bit 7
041C93 0F      4977 RRCA
041C94 B2      4978 OR	D			; Or into bit 7 of D
041C95 57      4979 LD	D,A
041C96 C1      4980 POP	BC 			; Restore the operand
041C97 C9      4981 RET
               4982 ;
041C98 21      4983 EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C99 8C 
041C9A 20 
041C9B 04 
041C9C CB      4984 BIT 	7,D			; if bit 7 of D is 0
041C9D 7A 
041C9E C8      4985 RET	Z
041C9F 21      4986 LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041CA0 97 
041CA1 20 
041CA2 04 
041CA3 C9      4987 RET
               4988 ;
041CA4 CB      4989 ADDR_:			BIT	7,D			; Check the ADL flag
041CA5 7A 
041CA6 20      4990 JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CA7 0D 
               4991 ;
041CA8 CD      4992 ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CA9 3B 
041CAA 1D 
041CAB 04 
041CAC CD      4993 VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CAD F4 
041CAE 1A 
041CAF 04 
041CB0 7C      4994 LD      A,H
041CB1 C3      4995 JP      BYTE_
041CB2 2A 
041CB3 1D 
041CB4 04 
               4996 ;
041CB5 CD      4997 ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CB6 3B 
041CB7 1D 
041CB8 04 
041CB9 CD      4998 VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CBA AC 
041CBB 1C 
041CBC 04 
041CBD D9      4999 EXX
041CBE 7D      5000 LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CBF D9      5001 EXX
041CC0 C3      5002 JP	BYTE_
041CC1 2A 
041CC2 1D 
041CC3 04 
               5003 ;
041CC4 FE      5004 LDA:			CP      4
041CC5 04 
041CC6 DC      5005 CALL    C,ED
041CC7 F5 
041CC8 1C 
041CC9 04 
041CCA 78      5006 LD      A,B
041CCB C3      5007 JP      BYTE_
041CCC 2A 
041CCD 1D 
041CCE 04 
               5008 ;
041CCF 78      5009 LD16:			LD      A,B
041CD0 38      5010 JR      C,LD8
041CD1 0F 
041CD2 78      5011 LD      A,B
041CD3 E6      5012 AND     3FH
041CD4 3F 
041CD5 FE      5013 CP      12
041CD6 0C 
041CD7 79      5014 LD      A,C
041CD8 C8      5015 RET     Z
041CD9 CD      5016 CALL    ED
041CDA F5 
041CDB 1C 
041CDC 04 
041CDD 79      5017 LD      A,C
041CDE F6      5018 OR      43H
041CDF 43 
041CE0 C9      5019 RET
               5020 ;
041CE1 FE      5021 LD8:			CP      7
041CE2 07 
041CE3 37      5022 SCF
041CE4 C0      5023 RET     NZ
041CE5 79      5024 LD      A,C
041CE6 F6      5025 OR      30H
041CE7 30 
041CE8 C9      5026 RET
               5027 ;
               5028 ; Used in IN and OUT to handle whether the operand is C or a number
               5029 ;
041CE9 C5      5030 CORN:			PUSH    BC
041CEA CD      5031 CALL    OPND			; Get the operand
041CEB 09 
041CEC 1D 
041CED 04 
041CEE CB      5032 BIT     5,B
041CEF 68 
041CF0 C1      5033 POP     BC
041CF1 28      5034 JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CF2 48 
041CF3 26      5035 LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CF4 FF 
               5036 ;
041CF5 3E      5037 ED:			LD      A,0EDH			; Write an ED prefix out
041CF6 ED 
041CF7 18      5038 JR      BYTE_
041CF8 31 
               5039 ;
041CF9 3E      5040 CB:			LD      A,0CBH
041CFA CB 
041CFB FE      5041 BIND:			CP      76H
041CFC 76 
041CFD 37      5042 SCF
041CFE C8      5043 RET     Z               	; Reject LD (HL),(HL)
041CFF CD      5044 CALL    BYTE_
041D00 2A 
041D01 1D 
041D02 04 
041D03 CB      5045 BIT	6,D			; Check the index bit in flags
041D04 72 
041D05 C8      5046 RET     Z
041D06 7B      5047 LD      A,E			; If there is an index, output the offset
041D07 18      5048 JR      BYTE_
041D08 21 
               5049 ;
               5050 ; Search through the operand table
               5051 ; Returns:
               5052 ; - B: The operand type
               5053 ; - D: Bit 7: 0 = no prefix, 1 = prefix
               5054 ; - E: The IX/IY offset
               5055 ; - F: Carry if not found
               5056 ;
041D09 E5      5057 OPND:			PUSH    HL			; Preserve HL
041D0A 21      5058 LD      HL,OPRNDS		; The operands table
041D0B 0D 
041D0C 20 
041D0D 04 
041D0E CD      5059 CALL    FIND			; Find the operand
041D0F 9C 
041D10 1D 
041D11 04 
041D12 E1      5060 POP     HL
041D13 D8      5061 RET     C			; Return if not found
041D14 CB      5062 BIT     7,B			; Check if it is an index register (IX, IY)
041D15 78 
041D16 C8      5063 RET     Z			; Return if it isn't
041D17 CB      5064 SET	6,D			; Set flag to indicate we've got an index
041D18 F2 
041D19 CB      5065 BIT     3,B			; Check if an offset is required
041D1A 58 
041D1B E5      5066 PUSH    HL
041D1C CC      5067 CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D1D 31 
041D1E 1D 
041D1F 04 
041D20 5D      5068 LD      E,L			; E: The offset
041D21 E1      5069 POP     HL
041D22 3E      5070 LD	A,DDH			; IX prefix
041D23 DD 
041D24 CB      5071 BIT     6,B			; If bit 6 is reset then
041D25 70 
041D26 28      5072 JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D27 02 
041D28 3E      5073 LD	A,FDH			; IY prefix
041D29 FD 
               5074 ;
041D2A DD      5075 BYTE_:			LD      (IX),A			; Write a byte out
041D2B 77 
041D2C 00 
041D2D DD      5076 INC     IX
041D2E 23 
041D2F B7      5077 OR      A
041D30 C9      5078 RET
               5079 ;
041D31 FD      5080 OFFSET_EX:			LD      A,(IY)
041D32 7E 
041D33 00 
041D34 FE      5081 CP      ')'
041D35 29 
041D36 21      5082 LD      HL,0
041D37 00 
041D38 00 
041D39 00 
041D3A C8      5083 RET     Z
041D3B CD      5084 NUMBER:			CALL    SKIP
041D3C ED 
041D3D 1D 
041D3E 04 
041D3F C5      5085 PUSH    BC
041D40 D5      5086 PUSH    DE
041D41 DD      5087 PUSH    IX
041D42 E5 
041D43 CD      5088 CALL    EXPRI
041D44 0F 
041D45 03 
041D46 04 
041D47 DD      5089 POP     IX
041D48 E1 
041D49 D9      5090 EXX
041D4A D1      5091 POP     DE
041D4B C1      5092 POP     BC
041D4C 7D      5093 LD      A,L
041D4D B7      5094 OR      A
041D4E C9      5095 RET
               5096 ;
041D4F CD      5097 REG:			CALL    OPND
041D50 09 
041D51 1D 
041D52 04 
041D53 D8      5098 RET     C
041D54 78      5099 LD      A,B
041D55 E6      5100 AND     3FH
041D56 3F 
041D57 FE      5101 CP      8
041D58 08 
041D59 3F      5102 CCF
041D5A C9      5103 RET
               5104 ;
041D5B CD      5105 REGLO:			CALL    REG
041D5C 4F 
041D5D 1D 
041D5E 04 
041D5F D8      5106 RET     C
041D60 18      5107 JR      ORC
041D61 33 
               5108 ;
041D62 CD      5109 REGHI:			CALL    REG
041D63 4F 
041D64 1D 
041D65 04 
041D66 D8      5110 RET     C
041D67 18      5111 JR      SHL3
041D68 29 
               5112 ;
041D69 CD      5113 COND_:			CALL    OPND
041D6A 09 
041D6B 1D 
041D6C 04 
041D6D D8      5114 RET     C
041D6E 78      5115 LD      A,B
041D6F E6      5116 AND     1FH
041D70 1F 
041D71 D6      5117 SUB     16
041D72 10 
041D73 30      5118 JR      NC,SHL3
041D74 1D 
041D75 FE      5119 CP      -15
041D76 F1 
041D77 37      5120 SCF
041D78 C0      5121 RET     NZ
041D79 3E      5122 LD      A,3
041D7A 03 
041D7B 18      5123 JR      SHL3
041D7C 15 
               5124 ;
041D7D CD      5125 PAIR_EX:			CALL    OPND
041D7E 09 
041D7F 1D 
041D80 04 
041D81 D8      5126 RET     C
041D82 78      5127 PAIR1_EX:			LD      A,B
041D83 E6      5128 AND     0FH
041D84 0F 
041D85 D6      5129 SUB     8
041D86 08 
041D87 D8      5130 RET     C
041D88 18      5131 JR      SHL3
041D89 08 
               5132 ;
041D8A CD      5133 BIT_:			CALL    NUMBER
041D8B 3B 
041D8C 1D 
041D8D 04 
041D8E FE      5134 CP      8
041D8F 08 
041D90 3F      5135 CCF
041D91 D8      5136 RET     C
041D92 07      5137 SHL3:			RLCA
041D93 07      5138 RLCA
041D94 07      5139 RLCA
041D95 B1      5140 ORC:			OR      C
041D96 4F      5141 LD      C,A
041D97 C9      5142 RET
               5143 ;
041D98 21      5144 LDOP:			LD      HL,LDOPS
041D99 52 
041D9A 20 
041D9B 04 
               5145 
               5146 ;
               5147 ; Look up a value in a table
               5148 ; Parameters:
               5149 ; - IY: Address of the assembly language line in the BASIC program area
               5150 ; - HL: Address of the table
               5151 ; Returns:
               5152 ; - B: The operand code
               5153 ; - F: Carry set if not found
               5154 ;
041D9C CD      5155 FIND:			CALL    SKIP			; Skip delimiters
041D9D ED 
041D9E 1D 
041D9F 04 
               5156 ;
041DA0 06      5157 EXIT_:			LD      B,0			; Set B to 0
041DA1 00 
041DA2 37      5158 SCF				; Set the carry flag
041DA3 C8      5159 RET     Z			; Returns if Z
               5160 ;
041DA4 FE      5161 CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041DA5 DD 
041DA6 28      5162 JR      Z,FIND0
041DA7 04 
041DA8 FE      5163 CP      TOR+1			; Special case for tokens AND and OR
041DA9 85 
041DAA 3F      5164 CCF
041DAB D8      5165 RET     C
041DAC 7E      5166 FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DAD B7      5167 OR      A
041DAE 28      5168 JR      Z,EXIT_			; Exit
041DAF F0 
041DB0 FD      5169 XOR     (IY)
041DB1 AE 
041DB2 00 
041DB3 E6      5170 AND     01011111B
041DB4 5F 
041DB5 28      5171 JR      Z,FIND2
041DB6 09 
041DB7 CB      5172 FIND1:			BIT     7,(HL)
041DB8 7E 
041DB9 23      5173 INC     HL
041DBA 28      5174 JR      Z,FIND1
041DBB FB 
041DBC 23      5175 INC     HL
041DBD 04      5176 INC     B
041DBE 18      5177 JR      FIND0
041DBF EC 
               5178 ;
041DC0 FD      5179 FIND2:			PUSH    IY
041DC1 E5 
041DC2 CB      5180 FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DC3 7E 
041DC4 FD      5181 INC     IY
041DC5 23 
041DC6 23      5182 INC     HL
041DC7 20      5183 JR      NZ,FIND5		; Yes
041DC8 11 
041DC9 BE      5184 CP      (HL)
041DCA CC      5185 CALL    Z,SKIP0
041DCB EC 
041DCC 1D 
041DCD 04 
041DCE 7E      5186 LD      A,(HL)
041DCF FD      5187 XOR     (IY)
041DD0 AE 
041DD1 00 
041DD2 E6      5188 AND     01011111B
041DD3 5F 
041DD4 28      5189 JR      Z,FIND3
041DD5 EC 
041DD6 FD      5190 FIND4:			POP     IY
041DD7 E1 
041DD8 18      5191 JR      FIND1
041DD9 DD 
               5192 ;
041DDA CD      5193 FIND5:			CALL    DELIM			; Is it a delimiter?
041DDB 98 
041DDC 17 
041DDD 04 
041DDE C4      5194 CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DDF 01 
041DE0 1E 
041DE1 04 
041DE2 C4      5195 CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DE3 FB 
041DE4 1D 
041DE5 04 
041DE6 20      5196 JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DE7 EE 
               5197 ;
041DE8 78      5198 FIND6:			LD      A,B			; At this point we have a token
041DE9 46      5199 LD      B,(HL)			; Fetch the token type code
041DEA E1      5200 POP     HL			; Restore the stack
041DEB C9      5201 RET
               5202 ;
041DEC 23      5203 SKIP0:			INC     HL
041DED CD      5204 SKIP:			CALL    DELIM			; Is it a delimiter?
041DEE 98 
041DEF 17 
041DF0 04 
041DF1 C0      5205 RET     NZ			; No, so return
041DF2 CD      5206 CALL    TERM			; Is it a terminator?
041DF3 A4 
041DF4 17 
041DF5 04 
041DF6 C8      5207 RET     Z			; Yes, so return
041DF7 FD      5208 INC     IY			; Increment the basic program counter
041DF8 23 
041DF9 18      5209 JR      SKIP			; And loop
041DFA F2 
               5210 ;
041DFB FE      5211 SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DFC 2B 
041DFD C8      5212 RET     Z
041DFE FE      5213 CP      '-'
041DFF 2D 
041E00 C9      5214 RET
               5215 ;
041E01 FE      5216 DOT:			CP	'.'			; Check if it is a dot character
041E02 2E 
041E03 C9      5217 RET
               5218 ; Z80 opcode list
               5219 ;
               5220 ; Group 0: (15 opcodes)
               5221 ; Trivial cases requiring no computation
               5222 ;
041E04 4E      5223 OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E05 4F 
041E06 50 
041E07 00 
041E08 52      5224 DB	"RLC","A"+80H,07h
041E09 4C 
041E0A 43 
041E0B 41 
041E0B 07   
041E0D 45      5225 DB	"EX",0,"AF",0,"AF","'"+80H,08h
041E0E 58 
041E0F 00 
041E10 41 
041E10 46   
041E11 00 
041E12 41 
041E13 46 
041E13 27   
041E14 08 
041E17 52      5226 DB	"RRC","A"+80H,0FH
041E18 52 
041E19 43 
041E1A 41 
041E1A 0F   
041E1C 52      5227 DB	"RL","A"+80H,17H
041E1D 4C 
041E1E 41 
041E1F 17 
041E20 52      5228 DB	"RR","A"+80H,1FH
041E21 52 
041E22 41 
041E23 1F 
041E24 44      5229 DB	"DA","A"+80H,27H
041E25 41 
041E26 41 
041E27 27 
041E28 43      5230 DB	"CP","L"+80H,2FH
041E29 50 
041E2A 4C 
041E2B 2F 
041E2C 53      5231 DB	"SC","F"+80H,37H
041E2D 43 
041E2E 46 
041E2F 37 
041E30 43      5232 DB	"CC","F"+80H,3FH
041E31 43 
041E32 46 
041E33 3F 
041E34 48      5233 DB	"HAL","T"+80H,76H
041E35 41 
041E36 4C 
041E37 54 
041E37 76   
041E39 45      5234 DB	"EX","X"+80H,D9H
041E3A 58 
041E3B 58 
041E3C D9 
041E3D 45      5235 DB	"EX",0,"DE",0,"H","L"+80H,EBH
041E3E 58 
041E3F 00 
041E40 44 
041E40 45   
041E41 00 
041E42 48 
041E43 4C 
041E43 EB   
041E46 44      5236 DB	"D","I"+80H,F3H
041E47 49 
041E48 F3 
041E49 45      5237 DB	"E","I"+80H,FBH
041E4A 49 
041E4B FB 
               5238 ;
               5239 ; Group 1: (53 opcodes)
               5240 ; As Group 0, but with an ED prefix
               5241 ;
041E4C 4E      5242 DB	"NE","G"+80H,44H	; 0Fh
041E4D 45 
041E4E 47 
041E4F 44 
041E50 49      5243 DB	"IM",0,"0"+80H,46H
041E51 4D 
041E52 00 
041E53 30 
041E53 46   
041E55 52      5244 DB	"RET","N"+80H,45H
041E56 45 
041E57 54 
041E58 4E 
041E58 45   
041E5A 4D      5245 DB	"MLT",0,"B","C"+80H,4CH
041E5B 4C 
041E5C 54 
041E5D 00 
041E5D 42   
041E5E 43 
041E5F 4C 
041E61 52      5246 DB	"RET","I"+80H,4DH
041E62 45 
041E63 54 
041E64 49 
041E64 4D   
041E66 49      5247 DB	"IM",0,"1"+80H,56H
041E67 4D 
041E68 00 
041E69 31 
041E69 56   
041E6B 4D      5248 DB	"MLT",0,"D","E"+80H,5CH
041E6C 4C 
041E6D 54 
041E6E 00 
041E6E 44   
041E6F 45 
041E70 5C 
041E72 49      5249 DB	"IM",0,"2"+80H,5EH
041E73 4D 
041E74 00 
041E75 32 
041E75 5E   
041E77 52      5250 DB	"RR","D"+80H,67H
041E78 52 
041E79 44 
041E7A 67 
041E7B 4D      5251 DB	"MLT",0,"H","L"+80H,6CH
041E7C 4C 
041E7D 54 
041E7E 00 
041E7E 48   
041E7F 4C 
041E80 6C 
041E82 4C      5252 DB	"LD",0,"MB",0,"A"+80H,6DH
041E83 44 
041E84 00 
041E85 4D 
041E85 42   
041E86 00 
041E87 41 
041E88 6D 
041E8A 4C      5253 DB	"LD",0,"A",0,"M","B"+80H,6EH
041E8B 44 
041E8C 00 
041E8D 41 
041E8D 00   
041E8E 4D 
041E8F 42 
041E90 6E 
041E92 52      5254 DB	"RL","D"+80H,6FH
041E93 4C 
041E94 44 
041E95 6F 
041E96 53      5255 DB	"SL","P"+80H,76H
041E97 4C 
041E98 50 
041E99 76 
041E9A 4D      5256 DB	"MLT",0,"S","P"+80H,7CH
041E9B 4C 
041E9C 54 
041E9D 00 
041E9D 53   
041E9E 50 
041E9F 7C 
041EA1 53      5257 DB	"STMI","X"+80H,7DH
041EA2 54 
041EA3 4D 
041EA4 49 
041EA4 58   
041EA5 7D 
041EA7 52      5258 DB	"RSMI","X"+80H,7EH
041EA8 53 
041EA9 4D 
041EAA 49 
041EAA 58   
041EAB 7E 
041EAD 49      5259 DB	"INI","M"+80H,82H
041EAE 4E 
041EAF 49 
041EB0 4D 
041EB0 82   
041EB2 4F      5260 DB	"OTI","M"+80H,83H
041EB3 54 
041EB4 49 
041EB5 4D 
041EB5 83   
041EB7 49      5261 DB	"INI","2"+80H,84H
041EB8 4E 
041EB9 49 
041EBA 32 
041EBA 84   
041EBC 49      5262 DB	"IND","M"+80H,8AH
041EBD 4E 
041EBE 44 
041EBF 4D 
041EBF 8A   
041EC1 4F      5263 DB	"OTD","M"+80H,8BH
041EC2 54 
041EC3 44 
041EC4 4D 
041EC4 8B   
041EC6 49      5264 DB	"IND","2"+80H,8CH
041EC7 4E 
041EC8 44 
041EC9 32 
041EC9 8C   
041ECB 49      5265 DB	"INIM","R"+80H,92H
041ECC 4E 
041ECD 49 
041ECE 4D 
041ECE 52   
041ECF 92 
041ED1 4F      5266 DB	"OTIM","R"+80H,93H
041ED2 54 
041ED3 49 
041ED4 4D 
041ED4 52   
041ED5 93 
041ED7 49      5267 DB	"INI2","R"+80H,94H
041ED8 4E 
041ED9 49 
041EDA 32 
041EDA 52   
041EDB 94 
041EDD 49      5268 DB	"INDM","R"+80H,9AH
041EDE 4E 
041EDF 44 
041EE0 4D 
041EE0 52   
041EE1 9A 
041EE3 4F      5269 DB	"OTDM","R"+80H,9BH
041EE4 54 
041EE5 44 
041EE6 4D 
041EE6 52   
041EE7 9B 
041EE9 49      5270 DB	"IND2","R"+80H,9CH
041EEA 4E 
041EEB 44 
041EEC 32 
041EEC 52   
041EED 9C 
041EEF 4C      5271 DB	"LD","I"+80H,A0H
041EF0 44 
041EF1 49 
041EF2 A0 
041EF3 43      5272 DB	"CP","I"+80H,A1H
041EF4 50 
041EF5 49 
041EF6 A1 
041EF7 49      5273 DB	"IN","I"+80H,A2H
041EF8 4E 
041EF9 49 
041EFA A2 
041EFB 4F      5274 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041EFC 55 
041EFD 54 
041EFE 49 
041EFE 32   
041EFF A4 
041F01 4F      5275 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041F02 55 
041F03 54 
041F04 49 
041F04 A3   
041F06 4C      5276 DB	"LD","D"+80H,A8H
041F07 44 
041F08 44 
041F09 A8 
041F0A 43      5277 DB	"CP","D"+80H,A9H
041F0B 50 
041F0C 44 
041F0D A9 
041F0E 49      5278 DB	"IN","D"+80H,AAH
041F0F 4E 
041F10 44 
041F11 AA 
041F12 4F      5279 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041F13 55 
041F14 54 
041F15 44 
041F15 32   
041F16 AC 
041F18 4F      5280 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041F19 55 
041F1A 54 
041F1B 44 
041F1B AB   
041F1D 4C      5281 DB	"LDI","R"+80H,B0H
041F1E 44 
041F1F 49 
041F20 52 
041F20 B0   
041F22 43      5282 DB	"CPI","R"+80H,B1H
041F23 50 
041F24 49 
041F25 52 
041F25 B1   
041F27 49      5283 DB	"INI","R"+80H,B2H
041F28 4E 
041F29 49 
041F2A 52 
041F2A B2   
041F2C 4F      5284 DB	"OTI","R"+80H,B3H
041F2D 54 
041F2E 49 
041F2F 52 
041F2F B3   
041F31 4F      5285 DB	"OTI2","R"+80H,B4H
041F32 54 
041F33 49 
041F34 32 
041F34 52   
041F35 B4 
041F37 4C      5286 DB	"LDD","R"+80H,B8H
041F38 44 
041F39 44 
041F3A 52 
041F3A B8   
041F3C 43      5287 DB	"CPD","R"+80H,B9H
041F3D 50 
041F3E 44 
041F3F 52 
041F3F B9   
041F41 49      5288 DB	"IND","R"+80H,BAH
041F42 4E 
041F43 44 
041F44 52 
041F44 BA   
041F46 4F      5289 DB	"OTD","R"+80H,BBH
041F47 54 
041F48 44 
041F49 52 
041F49 BB   
041F4B 4F      5290 DB	"OTD2","R"+80H,BCH
041F4C 54 
041F4D 44 
041F4E 32 
041F4E 52   
041F4F BC 
041F51 49      5291 DB	"INIR","X"+80H,C2H
041F52 4E 
041F53 49 
041F54 52 
041F54 58   
041F55 C2 
041F57 4F      5292 DB	"OTIR","X"+80H,C3H
041F58 54 
041F59 49 
041F5A 52 
041F5A 58   
041F5B C3 
041F5D 49      5293 DB	"INDR","X"+80H,CAH
041F5E 4E 
041F5F 44 
041F60 52 
041F60 58   
041F61 CA 
041F63 4F      5294 DB	"OTDR","X"+80H,CBH
041F64 54 
041F65 44 
041F66 52 
041F66 58   
041F67 CB 
               5295 ;
               5296 ; Group 2: (3 opcodes)
               5297 ;
041F69 42      5298 DB	"BI","T"+80H,40H	; 44h
041F6A 49 
041F6B 54 
041F6C 40 
041F6D 52      5299 DB	"RE","S"+80H,80H
041F6E 45 
041F6F 53 
041F70 80 
041F71 53      5300 DB	"SE","T"+80H,C0H
041F72 45 
041F73 54 
041F74 C0 
               5301 ;
               5302 ; Group 3: (7 opcodes)
               5303 ;
041F75 52      5304 DB	"RL","C"+80H,00H	; 47h
041F76 4C 
041F77 43 
041F78 00 
041F79 52      5305 DB	"RR","C"+80H,08H
041F7A 52 
041F7B 43 
041F7C 08 
041F7D 52      5306 DB	"R","L"+80H,10H
041F7E 4C 
041F7F 10 
041F80 52      5307 DB	"R","R"+80H,18H
041F81 52 
041F82 18 
041F83 53      5308 DB	"SL","A"+80H,20H
041F84 4C 
041F85 41 
041F86 20 
041F87 53      5309 DB	"SR","A"+80H,28H
041F88 52 
041F89 41 
041F8A 28 
041F8B 53      5310 DB	"SR","L"+80H,38H
041F8C 52 
041F8D 4C 
041F8E 38 
               5311 ;
               5312 ; Group 4: (3 opcodes)
               5313 ;
041F8F 50      5314 DB	"PO","P"+80H,C1H	; 4Eh
041F90 4F 
041F91 50 
041F92 C1 
041F93 50      5315 DB	"PUS","H"+80H,C5H
041F94 55 
041F95 53 
041F96 48 
041F96 C5   
041F98 45      5316 DB	"EX",0,"(S","P"+80H,E3H
041F99 58 
041F9A 00 
041F9B 28 
041F9B 53   
041F9C 50 
041F9D E3 
               5317 ;
               5318 ; Group 5: (7 opcodes)
               5319 ;
041F9F 53      5320 DB	"SU","B"+80H,90H	; 51h
041FA0 55 
041FA1 42 
041FA2 90 
041FA3 41      5321 DB	"AN","D"+80H,A0H
041FA4 4E 
041FA5 44 
041FA6 A0 
041FA7 58      5322 DB	"XO","R"+80H,A8H
041FA8 4F 
041FA9 52 
041FAA A8 
041FAB 4F      5323 DB	"O","R"+80H,B0H
041FAC 52 
041FAD B0 
041FAE 43      5324 DB	"C","P"+80H,B8H
041FAF 50 
041FB0 B8 
041FB1 80      5325 DB	TAND,A0H		; 56h TAND: Tokenised AND
041FB2 A0 
041FB3 84      5326 DB	TOR,B0H			; 57h TOR: Tokenised OR
041FB4 B0 
               5327 ;
               5328 ; Group 6 (3 opcodes)
               5329 ;
041FB5 41      5330 DB	"AD","D"+80H,80H	; 58h
041FB6 44 
041FB7 44 
041FB8 80 
041FB9 41      5331 DB	"AD","C"+80H,88H
041FBA 44 
041FBB 43 
041FBC 88 
041FBD 53      5332 DB	"SB","C"+80H,98H
041FBE 42 
041FBF 43 
041FC0 98 
               5333 ;
               5334 ; Group 7: (2 opcodes)
               5335 ;
041FC1 49      5336 DB	"IN","C"+80H,04H	; 5Bh
041FC2 4E 
041FC3 43 
041FC4 04 
041FC5 44      5337 DB	"DE","C"+80H,05H
041FC6 45 
041FC7 43 
041FC8 05 
               5338 ;
               5339 ; Group 8: (2 opcodes)
               5340 ;
041FC9 49      5341 DB	"IN","0"+80H,00H	; 5Dh
041FCA 4E 
041FCB 30 
041FCC 00 
041FCD 4F      5342 DB	"OUT","0"+80H,01H
041FCE 55 
041FCF 54 
041FD0 30 
041FD0 01   
               5343 ;
               5344 ; Group 9: (1 opcode)
               5345 ;
041FD2 49      5346 DB	"I","N"+80H,40H		; 5Fh
041FD3 4E 
041FD4 40 
               5347 ;
               5348 ; Group 10: (1 opcode)
               5349 ;
041FD5 4F      5350 DB	"OU","T"+80H,41H	; 60h
041FD6 55 
041FD7 54 
041FD8 41 
               5351 ;
               5352 ; Group 11: (2 opcodes)
               5353 ;
041FD9 4A      5354 DB	"J","R"+80H,20H		; 61h
041FDA 52 
041FDB 20 
041FDC 44      5355 DB	"DJN","Z"+80H,10H
041FDD 4A 
041FDE 4E 
041FDF 5A 
041FDF 10   
               5356 ;
               5357 ; Group 12: (1 opcode)
               5358 ;
041FE1 4A      5359 DB	"J","P"+80H,C2H		; 63h
041FE2 50 
041FE3 C2 
               5360 ;
               5361 ; Group 13: (1 opcode)
               5362 ;
041FE4 43      5363 DB	"CAL","L"+80H,C4H	; 64h
041FE5 41 
041FE6 4C 
041FE7 4C 
041FE7 C4   
               5364 ;
               5365 ; Group 14: (1 opcode)
               5366 ;
041FE9 52      5367 DB	"RS","T"+80H,C7H	; 65h
041FEA 53 
041FEB 54 
041FEC C7 
               5368 ;
               5369 ; Group 15: (1 opcode)
               5370 ;
041FED 52      5371 DB	"RE","T"+80H,C0H	; 66h
041FEE 45 
041FEF 54 
041FF0 C0 
               5372 ;
               5373 ; Group 16: (1 opcode)
               5374 ;
041FF1 4C      5375 DB	"L","D"+80H,40H		; 67h
041FF2 44 
041FF3 40 
               5376 ;
               5377 ; Group 17: (1 opcode)
               5378 ;
041FF4 54      5379 DB	"TS","T"+80H,04H	; 68h
041FF5 53 
041FF6 54 
041FF7 04 
               5380 
               5381 ;
               5382 ; Assembler Directives
               5383 ;
041FF8 4F      5384 DB	"OP","T"+80H,00H	; 69h OPT
041FF9 50 
041FFA 54 
041FFB 00 
041FFC 41      5385 DB	"AD","L"+80H,00H	; 6Ah ADL
041FFD 44 
041FFE 4C 
041FFF 00 
               5386 ;
042000 5D      5387 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
042001 42 
042002 00 
042003 5D      5388 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042004 57 
042005 00 
042006 5D      5389 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042007 4C 
042008 00 
042009 5D      5390 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
04200A 4D 
04200B 00 
               5391 ;
04200C 00      5392 DB	0
               5393 ;
               5394 ; Operands
               5395 ;
04200D 42      5396 OPRNDS:			DB	"B"+80H, 00H
04200E 00 
04200F 43      5397 DB	"C"+80H, 01H
042010 01 
042011 44      5398 DB	"D"+80H, 02H
042012 02 
042013 45      5399 DB	"E"+80H, 03H
042014 03 
042015 48      5400 DB	"H"+80H, 04H
042016 04 
042017 4C      5401 DB	"L"+80H, 05H
042018 05 
042019 28      5402 DB	"(H","L"+80H,06H
04201A 48 
04201B 4C 
04201C 06 
04201D 41      5403 DB	"A"+80H, 07H
04201E 07 
04201F 28      5404 DB	"(I","X"+80H,86H
042020 49 
042021 58 
042022 86 
042023 28      5405 DB	"(I","Y"+80H,C6H
042024 49 
042025 59 
042026 C6 
               5406 ;
042027 42      5407 DB	"B","C"+80H,08H
042028 43 
042029 08 
04202A 44      5408 DB	"D","E"+80H,0AH
04202B 45 
04202C 0A 
04202D 48      5409 DB	"H","L"+80H,0CH
04202E 4C 
04202F 0C 
042030 49      5410 DB	"I","X"+80H,8CH
042031 58 
042032 8C 
042033 49      5411 DB	"I","Y"+80H,CCH
042034 59 
042035 CC 
042036 41      5412 DB	"A","F"+80H,0EH
042037 46 
042038 0E 
042039 53      5413 DB	"S","P"+80H,0EH
04203A 50 
04203B 0E 
               5414 ;
04203C 4E      5415 DB	"N","Z"+80H,10H
04203D 5A 
04203E 10 
04203F 5A      5416 DB	"Z"+80H,11H
042040 11 
042041 4E      5417 DB	"N","C"+80H,12H
042042 43 
042043 12 
042044 50      5418 DB	"P","O"+80H,14H
042045 4F 
042046 14 
042047 50      5419 DB	"P","E"+80H,15H
042048 45 
042049 15 
04204A 50      5420 DB	"P"+80H,16H
04204B 16 
04204C 4D      5421 DB	"M"+80H,17H
04204D 17 
               5422 ;
04204E 28      5423 DB	"(","C"+80H,20H
04204F 43 
042050 20 
               5424 ;
042051 00      5425 DB	0
               5426 ;
               5427 ; Load operations
               5428 ;
042052 49      5429 LDOPS:			DB	"I",0,"A"+80H,47H
042053 00 
042054 41 
042055 47 
042056 52      5430 DB	"R",0,"A"+80H,4FH
042057 00 
042058 41 
042059 4F 
04205A 41      5431 DB	"A",0,"I"+80H,57H
04205B 00 
04205C 49 
04205D 57 
04205E 41      5432 DB	"A",0,"R"+80H,5FH
04205F 00 
042060 52 
042061 5F 
042062 28      5433 DB	"(BC",0,"A"+80H,02h
042063 42 
042064 43 
042065 00 
042065 41   
042066 02 
042068 28      5434 DB	"(DE",0,"A"+80H,12H
042069 44 
04206A 45 
04206B 00 
04206B 41   
04206C 12 
04206E 41      5435 DB	"A",0,"(B","C"+80H,0AH
04206F 00 
042070 28 
042071 42 
042071 43   
042072 0A 
042074 41      5436 DB	"A",0,"(D","E"+80H,1AH
042075 00 
042076 28 
042077 44 
042077 45   
042078 1A 
               5437 ;
04207A 00      5438 DB	0
               5439 ;
               5440 ; eZ80 addressing mode suffixes
               5441 ;
               5442 ; Fully qualified suffixes
               5443 ;
04207B 4C      5444 EZ80SFS_1:		DB	"LI","S"+80H,49H
04207C 49 
04207D 53 
04207E 49 
04207F 53      5445 DB	"SI","L"+80H,52H
042080 49 
042081 4C 
042082 52 
042083 53      5446 EZ80SFS_2:		DB	"SI","S"+80H,40H
042084 49 
042085 53 
042086 40 
042087 4C      5447 DB	"LI","L"+80H,5BH
042088 49 
042089 4C 
04208A 5B 
               5448 ;
04208B 00      5449 DB	0
               5450 ;
               5451 ; Shortcuts when ADL mode is 0
               5452 ;
04208C 53      5453 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
04208D 40 
04208E 4C      5454 DB	"L"+80H,49H		; Equivalent to .LIS
04208F 49 
042090 49      5455 DB	"I","S"+80H,40H		; Equivalent to .SIS
042091 53 
042092 40 
042093 49      5456 DB	"I","L"+80H,52H		; Equivalent to .SIL
042094 4C 
042095 52 
               5457 ;
042096 00      5458 DB	0
               5459 ;
               5460 ; Shortcuts when ADL mode is 1
               5461 ;
042097 53      5462 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042098 52 
042099 4C      5463 DB	"L"+80H,5BH		; Equivalent to .LIL
04209A 5B 
04209B 49      5464 DB	"I","S"+80H,49H		; Equivalent to .LIS
04209C 53 
04209D 49 
04209E 49      5465 DB	"I","L"+80H,5BH		; Equivalent to .LIL
04209F 4C 
0420A0 5B 
               5466 ;
0420A1 00      5467 DB	0
               5468 ;
               5469 ; .LIST
               5470 ;
               5471 ; already defined in equs.inc
               5472 ; LF:			EQU     0AH
               5473 ; CR:			EQU     0DH; --- End exec.asm ---
               5474 
               5475 ; --- Begin fpp.asm ---
               5476 ;
               5477 ; Title:	BBC Basic Interpreter - Z80 version
               5478 ;		Z80 Floating Point Package
               5479 ; Author:	(C) Copyright  R.T.Russell  1986
               5480 ; Modified By:	Dean Belfield
               5481 ; Created:	03/05/2022
               5482 ; Last Updated:	07/06/2023
               5483 ;
               5484 ; Modinfo:
               5485 ; 26/10/1986:	Version 0.0
               5486 ; 14/12/1988:	Vesion 0.1 (Bug Fix)
               5487 ; 12/05/2023:	Modified by Dean Belfield
               5488 ; 07/06/2023:	Modified to run in ADL mode
               5489 
               5490 ; .ASSUME	ADL = 1
               5491 
               5492 ; SEGMENT CODE
               5493 
               5494 ; XDEF	FPP
               5495 ; XDEF	DLOAD5
               5496 ; XDEF	DLOAD5_SPL
               5497 ;
               5498 ;BINARY FLOATING POINT REPRESENTATION:
               5499 ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
               5500 ;    8 BIT EXCESS-128 SIGNED EXPONENT
               5501 ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
               5502 ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
               5503 ;
               5504 ;BINARY INTEGER REPRESENTATION:
               5505 ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
               5506 ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
               5507 ;
               5508 ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
               5509 ;                            EXPONENT - C
               5510 ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
               5511 ;                               EXPONENT - B
               5512 
               5513 ;
               5514 ;Error codes:
               5515 ;
               5516 
               5517 BADOP:			EQU     1               ;Bad operation code
               5518 DIVBY0:			EQU     18              ;Division by zero
               5519 TOOBIG_FP:			EQU     20              ;Too big
               5520 NGROOT:			EQU     21              ;Negative root
               5521 LOGRNG:			EQU     22              ;Log range
               5522 ACLOST:			EQU     23              ;Accuracy lost
               5523 EXPRNG:			EQU     24              ;Exp range
               5524 ;
               5525 ;Call entry and despatch code:
               5526 ;
0420A2 FD      5527 FPP:			PUSH    IY              ;Save IY
0420A3 E5 
0420A4 FD      5528 LD      IY,0
0420A5 21 
0420A6 00 
0420A7 00 
0420A7 00   
0420A9 FD      5529 ADD     IY,SP           ;Save SP in IY
0420AA 39 
0420AB CD      5530 CALL    OP              ;Perform operation
0420AC BB 
0420AD 20 
0420AE 04 
0420AF BF      5531 CP      A               ;Good return (Z, NC)
0420B0 FD      5532 EXIT_FP_:			POP     IY              ;Restore IY
0420B1 E1 
0420B2 C9      5533 RET                     ;Return to caller
               5534 ;
               5535 ;Error exit:
               5536 ;
0420B3 3E      5537 BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420B4 01 
0420B5 FD      5538 ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420B6 F9 
0420B7 B7      5539 OR      A               ;Set NZ
0420B8 37      5540 SCF                     ;Set C
0420B9 18      5541 JR      EXIT_FP_
0420BA F5 
               5542 ;
               5543 ;Perform operation or function:
               5544 ;
               5545 ; OP:			CP      (RTABLE-DTABLE)/3
0420BB FE      5546 OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420BC 2A 
               5547 
0420BD 30      5548 JR      NC,BAD_FP
0420BE F4 
               5549 ; CP      (FTABLE-DTABLE)/3
0420BF FE      5550 CP      FTABLE-DTABLE/3 ; ditto
0420C0 10 
0420C1 30      5551 JR      NC,DISPAT_FP
0420C2 08 
0420C3 08      5552 EX      AF,AF'
0420C4 78      5553 LD      A,B
0420C5 B1      5554 OR      C               ;Both integer?
0420C6 C4      5555 CALL    NZ,FLOATA       ;No, so float both
0420C7 CE 
0420C8 2B 
0420C9 04 
0420CA 08      5556 EX      AF,AF'
0420CB E5      5557 DISPAT_FP:			PUSH    HL
0420CC 21      5558 LD      HL,DTABLE
0420CD DE 
0420CE 20 
0420CF 04 
0420D0 C5      5559 PUSH    BC
0420D1 01      5560 LD	BC, 3		; C = 3
0420D2 03 
0420D3 00 
0420D4 00 
0420D5 47      5561 LD	B, A 		; B = op-code
0420D6 ED      5562 MLT 	BC 		;BC = op-code * 3
0420D7 4C 
0420D8 09      5563 ADD	HL, BC 		;Add to table base
0420D9 ED      5564 LD	HL, (HL)	;Get the routine address (24-bit)
0420DA 27 
               5565 
               5566 ;        		ADD     A, A            ;A = op-code * 2
               5567 ;        		LD      C,A
               5568 ;        		LD      B,0             ;BC = op-code * 2
               5569 ;        		ADD     HL,BC
               5570 ;        		LD      A,(HL)          ;Get low byte
               5571 ;        		INC     HL
               5572 ;        		LD      H,(HL)          ;Get high byte
               5573 ;        		LD      L,A
               5574 
0420DB C1      5575 POP     BC
0420DC E3      5576 EX      (SP),HL
0420DD C9      5577 RET                     ;Off to routine
               5578 ;
               5579 ;Despatch table:
               5580 ;
0420DE 90      5581 DTABLE:			DW24  IAND            ;AND (INTEGER)
0420DF 21 
0420E0 04 
0420E1 FE      5582 DW24  IBDIV           ;DIV
0420E2 21 
0420E3 04 
0420E4 A3      5583 DW24  IEOR            ;EOR
0420E5 21 
0420E6 04 
0420E7 C9      5584 DW24  IMOD            ;MOD
0420E8 21 
0420E9 04 
0420EA B6      5585 DW24  IOR             ;OR
0420EB 21 
0420EC 04 
0420ED 84      5586 DW24  ILE             ;<=
0420EE 24 
0420EF 04 
0420F0 93      5587 DW24  INE             ;<>
0420F1 24 
0420F2 04 
0420F3 77      5588 DW24  IGE             ;>=
0420F4 24 
0420F5 04 
0420F6 5C      5589 DW24  ILT             ;<
0420F7 24 
0420F8 04 
0420F9 A0      5590 DW24  IEQ             ;=
0420FA 24 
0420FB 04 
0420FC EC      5591 DW24  IMUL            ;*
0420FD 22 
0420FE 04 
0420FF 27      5592 DW24  IADD            ;+
042100 22 
042101 04 
042102 69      5593 DW24  IGT             ;>
042103 24 
042104 04 
042105 0E      5594 DW24  ISUB            ;-
042106 22 
042107 04 
042108 A3      5595 DW24  IPOW            ;^
042109 23 
04210A 04 
04210B 99      5596 DW24  IDIV            ;/
04210C 22 
04210D 04 
               5597 ;
               5598 FTABLE:
04210E B2      5599 DW24  ABSV_FP            ;ABS
04210F 24 
042110 04 
042111 98      5600 DW24  ACS_FP             ;ACS
042112 28 
042113 04 
042114 D6      5601 DW24  ASN_FP             ;ASN
042115 27 
042116 04 
042117 06      5602 DW24  ATN_FP             ;ATN
042118 28 
042119 04 
04211A D1      5603 DW24  COS_FP             ;COS
04211B 25 
04211C 04 
04211D E0      5604 DW24  DEG_FP             ;DEG
04211E 24 
04211F 04 
042120 8D      5605 DW24  EXP_FP             ;EXP
042121 26 
042122 04 
042123 34      5606 DW24  INT_FP_            ;INT
042124 25 
042125 04 
042126 2B      5607 DW24  LN_FP              ;LN
042127 27 
042128 04 
042129 C0      5608 DW24  LOG_FP             ;LOG
04212A 27 
04212B 04 
04212C BE      5609 DW24  NOTK_FP            ;NOT
04212D 24 
04212E 04 
04212F EA      5610 DW24  RAD_FP             ;RAD
042130 24 
042131 04 
042132 05      5611 DW24  SGN_FP             ;SGN
042133 25 
042134 04 
042135 DE      5612 DW24  SIN_FP             ;SIN
042136 25 
042137 04 
042138 4D      5613 DW24  SQR_FP             ;SQR
042139 25 
04213A 04 
04213B AB      5614 DW24  TAN_FP             ;TAN
04213C 25 
04213D 04 
               5615 ;
04213E 5B      5616 DW24  ZERO_FP            ;ZERO
04213F 2C 
042140 04 
042141 66      5617 DW24  FONE_FP            ;FONE
042142 26 
042143 04 
042144 A5      5618 DW24  TRUE_FP            ;TRUE
042145 24 
042146 04 
042147 D2      5619 DW24  PI_FP              ;PI
042148 24 
042149 04 
               5620 ;
04214A 19      5621 DW24  VAL_FP             ;VAL
04214B 25 
04214C 04 
04214D A1      5622 DW24  STR_FP             ;STR$
04214E 28 
04214F 04 
               5623 ;
042150 02      5624 DW24  SFIX_FP            ;FIX
042151 2B 
042152 04 
042153 DE      5625 DW24  SFLOAT_FP          ;FLOAT
042154 2B 
042155 04 
               5626 ;
042156 2C      5627 DW24  FTEST_FP           ;TEST
042157 2C 
042158 04 
042159 3E      5628 DW24  FCOMP_FP           ;COMPARE
04215A 2C 
04215B 04 
               5629 ;
04215C 8C      5630 RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04215D 21 
04215E 04 
04215F FA      5631 DW24  FBDIV           ;DIV
042160 21 
042161 04 
042162 9F      5632 DW24  FEOR            ;EOR
042163 21 
042164 04 
042165 C5      5633 DW24  FMOD            ;MOD
042166 21 
042167 04 
042168 B2      5634 DW24  FFOR             ;OR
042169 21 
04216A 04 
04216B 7E      5635 DW24  FLE             ;<=
04216C 24 
04216D 04 
04216E 8D      5636 DW24  FNE             ;<>
04216F 24 
042170 04 
042171 71      5637 DW24  FGE             ;>=
042172 24 
042173 04 
042174 56      5638 DW24  FLT             ;<
042175 24 
042176 04 
042177 9A      5639 DW24  FEQ             ;=
042178 24 
042179 04 
04217A 46      5640 DW24  FMUL            ;*
04217B 23 
04217C 04 
04217D 34      5641 DW24  FADD            ;+
04217E 22 
04217F 04 
042180 63      5642 DW24  FGT             ;>
042181 24 
042182 04 
042183 1B      5643 DW24  FSUB            ;-
042184 22 
042185 04 
042186 23      5644 DW24  FPOW            ;^
042187 24 
042188 04 
042189 9D      5645 DW24  FDIV            ;/
04218A 22 
04218B 04 
               5646 ;
               5647 ;       PAGE
               5648 ;
               5649 ;ARITHMETIC AND LOGICAL OPERATORS:
               5650 ;All take two arguments, in HLH'L'C & DED'E'B.
               5651 ;Output in HLH'L'C
               5652 ;All registers except IX, IY destroyed.
               5653 ; (N.B. FPOW destroys IX).
               5654 ;
               5655 ;FAND - Floating-point AND.
               5656 ;IAND - Integer AND.
               5657 ;
04218C CD      5658 FAND:			CALL    FIX2
04218D F6 
04218E 2A 
04218F 04 
042190 7C      5659 IAND:			LD      A,H
042191 A2      5660 AND     D
042192 67      5661 LD      H,A
042193 7D      5662 LD      A,L
042194 A3      5663 AND     E
042195 6F      5664 LD      L,A
042196 D9      5665 EXX
042197 7C      5666 LD      A,H
042198 A2      5667 AND     D
042199 67      5668 LD      H,A
04219A 7D      5669 LD      A,L
04219B A3      5670 AND     E
04219C 6F      5671 LD      L,A
04219D D9      5672 EXX
04219E C9      5673 RET
               5674 ;
               5675 ;FEOR - Floating-point exclusive-OR.
               5676 ;IEOR - Integer exclusive-OR.
               5677 ;
04219F CD      5678 FEOR:			CALL    FIX2
0421A0 F6 
0421A1 2A 
0421A2 04 
0421A3 7C      5679 IEOR:			LD      A,H
0421A4 AA      5680 XOR     D
0421A5 67      5681 LD      H,A
0421A6 7D      5682 LD      A,L
0421A7 AB      5683 XOR     E
0421A8 6F      5684 LD      L,A
0421A9 D9      5685 EXX
0421AA 7C      5686 LD      A,H
0421AB AA      5687 XOR     D
0421AC 67      5688 LD      H,A
0421AD 7D      5689 LD      A,L
0421AE AB      5690 XOR     E
0421AF 6F      5691 LD      L,A
0421B0 D9      5692 EXX
0421B1 C9      5693 RET
               5694 ;
               5695 ;FOR - Floating-point OR.
               5696 ;IOR - Integer OR.
               5697 ;
0421B2 CD      5698 FFOR:			CALL    FIX2
0421B3 F6 
0421B4 2A 
0421B5 04 
0421B6 7C      5699 IOR:			LD      A,H
0421B7 B2      5700 OR      D
0421B8 67      5701 LD      H,A
0421B9 7D      5702 LD      A,L
0421BA B3      5703 OR      E
0421BB 6F      5704 LD      L,A
0421BC D9      5705 EXX
0421BD 7C      5706 LD      A,H
0421BE B2      5707 OR      D
0421BF 67      5708 LD      H,A
0421C0 7D      5709 LD      A,L
0421C1 B3      5710 OR      E
0421C2 6F      5711 LD      L,A
0421C3 D9      5712 EXX
0421C4 C9      5713 RET
               5714 ;
               5715 ;FMOD - Floating-point remainder.
               5716 ;IMOD - Integer remainder.
               5717 ;
0421C5 CD      5718 FMOD:			CALL    FIX2
0421C6 F6 
0421C7 2A 
0421C8 04 
0421C9 7C      5719 IMOD:			LD      A,H
0421CA AA      5720 XOR     D               ;DIV RESULT SIGN
0421CB CB      5721 BIT     7,H
0421CC 7C 
0421CD 08      5722 EX      AF,AF'
0421CE CB      5723 BIT     7,H
0421CF 7C 
0421D0 C4      5724 CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421D1 12 
0421D2 2B 
0421D3 04 
0421D4 CD      5725 CALL    SWAP_FP
0421D5 0F 
0421D6 2C 
0421D7 04 
0421D8 CB      5726 BIT     7,H
0421D9 7C 
0421DA C4      5727 CALL    NZ,NEGATE
0421DB 12 
0421DC 2B 
0421DD 04 
0421DE 44      5728 LD      B,H
0421DF 4D      5729 LD      C,L
0421E0 21      5730 LD      HL,0
0421E1 00 
0421E2 00 
0421E3 00 
0421E4 D9      5731 EXX
0421E5 44      5732 LD      B,H
0421E6 4D      5733 LD      C,L
0421E7 21      5734 LD      HL,0
0421E8 00 
0421E9 00 
0421EA 00 
0421EB 3E      5735 LD      A,-33
0421EC DF 
0421ED CD      5736 CALL    DIVA            ;DIVIDE
0421EE 9C 
0421EF 2D 
0421F0 04 
0421F1 D9      5737 EXX
0421F2 0E      5738 LD      C,0             ;INTEGER MARKER
0421F3 00 
0421F4 08      5739 EX      AF,AF'
0421F5 C8      5740 RET     Z
0421F6 C3      5741 JP      NEGATE
0421F7 12 
0421F8 2B 
0421F9 04 
               5742 ;
               5743 ;BDIV - Integer division.
               5744 ;
0421FA CD      5745 FBDIV:			CALL    FIX2
0421FB F6 
0421FC 2A 
0421FD 04 
0421FE CD      5746 IBDIV:			CALL    IMOD
0421FF C9 
042200 21 
042201 04 
042202 B7      5747 OR      A
042203 CD      5748 CALL    SWAP_FP
042204 0F 
042205 2C 
042206 04 
042207 0E      5749 LD      C,0
042208 00 
042209 F0      5750 RET     P
04220A C3      5751 JP      NEGATE
04220B 12 
04220C 2B 
04220D 04 
               5752 ;
               5753 ;ISUB - Integer subtraction.
               5754 ;FSUB - Floating point subtraction with rounding.
               5755 ;
04220E CD      5756 ISUB:			CALL    SUB_
04220F AA 
042210 2C 
042211 04 
042212 E0      5757 RET     PO
042213 CD      5758 CALL    ADD_
042214 A2 
042215 2C 
042216 04 
042217 CD      5759 CALL    FLOAT2
042218 D2 
042219 2B 
04221A 04 
04221B 7A      5760 FSUB:			LD      A,D
04221C EE      5761 XOR     80H             ;CHANGE SIGN THEN ADD
04221D 80 
04221E 57      5762 LD      D,A
04221F 18      5763 JR      FADD
042220 13 
               5764 ;
               5765 ;Reverse subtract.
               5766 ;
042221 7C      5767 RSUB:			LD      A,H
042222 EE      5768 XOR     80H
042223 80 
042224 67      5769 LD      H,A
042225 18      5770 JR      FADD
042226 0D 
               5771 ;
               5772 ;IADD - Integer addition.
               5773 ;FADD - Floating point addition with rounding.
               5774 ;
042227 CD      5775 IADD:			CALL    ADD_
042228 A2 
042229 2C 
04222A 04 
04222B E0      5776 RET     PO
04222C CD      5777 CALL    SUB_
04222D AA 
04222E 2C 
04222F 04 
042230 CD      5778 CALL    FLOAT2
042231 D2 
042232 2B 
042233 04 
042234 05      5779 FADD:			DEC     B
042235 04      5780 INC     B
042236 C8      5781 RET     Z               ;ARG 2 ZERO
042237 0D      5782 DEC     C
042238 0C      5783 INC     C
042239 CA      5784 JP      Z,SWAP_FP          ;ARG 1 ZERO
04223A 0F 
04223B 2C 
04223C 04 
04223D D9      5785 EXX
04223E 01      5786 LD      BC,0            ;INITIALISE
04223F 00 
042240 00 
042241 00 
042242 D9      5787 EXX
042243 7C      5788 LD      A,H
042244 AA      5789 XOR     D               ;XOR SIGNS
042245 F5      5790 PUSH    AF
042246 78      5791 LD      A,B
042247 B9      5792 CP      C               ;COMPARE EXPONENTS
042248 DC      5793 CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042249 0F 
04224A 2C 
04224B 04 
04224C 78      5794 LD      A,B
04224D CB      5795 SET     7,H             ;IMPLIED 1
04224E FC 
04224F C4      5796 CALL    NZ,FIX          ;ALIGN
042250 E3 
042251 2A 
042252 04 
042253 F1      5797 POP     AF
042254 7A      5798 LD      A,D             ;SIGN OF LARGER
042255 CB      5799 SET     7,D             ;IMPLIED 1
042256 FA 
042257 FA      5800 JP      M,FADD3         ;SIGNS DIFFERENT
042258 67 
042259 22 
04225A 04 
04225B CD      5801 CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04225C A2 
04225D 2C 
04225E 04 
04225F DC      5802 CALL    C,DIV2          ;NORMALISE
042260 17 
042261 2C 
042262 04 
042263 CB      5803 SET     7,H
042264 FC 
042265 18      5804 JR      FADD4
042266 0D 
               5805 ;
042267 CD      5806 FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042268 AA 
042269 2C 
04226A 04 
04226B DC      5807 CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04226C 2A 
04226D 2B 
04226E 04 
04226F CD      5808 CALL    FLO48
042270 A9 
042271 2B 
042272 04 
042273 2F      5809 CPL                     ;CHANGE RESULT SIGN
042274 D9      5810 FADD4:			EXX
042275 EB      5811 EX      DE,HL
042276 21      5812 LD      HL,8000H
042277 00 
042278 80 
042279 00 
04227A B7      5813 OR      A               ;CLEAR CARRY
04227B 52      5814 SBC.S   HL,BC
04227C ED 
04227D 42 
04227E EB      5815 EX      DE,HL
04227F D9      5816 EXX
042280 CC      5817 CALL    Z,ODD           ;ROUND UNBIASSED
042281 09 
042282 2C 
042283 04 
042284 DC      5818 CALL    C,ADD1_FP          ;ROUND UP
042285 F7 
042286 2B 
042287 04 
042288 DC      5819 CALL    C,INCC
042289 24 
04228A 2C 
04228B 04 
04228C CB      5820 RES     7,H
04228D BC 
04228E 0D      5821 DEC     C
04228F 0C      5822 INC     C
042290 CA      5823 JP      Z,ZERO_FP
042291 5B 
042292 2C 
042293 04 
042294 B7      5824 OR      A               ;RESULT SIGNQ
042295 F0      5825 RET     P               ;POSITIVE
042296 CB      5826 SET     7,H             ;NEGATIVE
042297 FC 
042298 C9      5827 RET
               5828 ;
               5829 ;IDIV - Integer division.
               5830 ;FDIV - Floating point division with rounding.
               5831 ;
042299 CD      5832 IDIV:			CALL    FLOAT2
04229A D2 
04229B 2B 
04229C 04 
04229D 05      5833 FDIV:			DEC     B               ;TEST FOR ZERO
04229E 04      5834 INC     B
04229F 3E      5835 LD      A,DIVBY0
0422A0 12 
0422A1 CA      5836 JP      Z,ERROR_FP_         ;"Division by zero"
0422A2 B5 
0422A3 20 
0422A4 04 
0422A5 0D      5837 DEC     C               ;TEST FOR ZERO
0422A6 0C      5838 INC     C
0422A7 C8      5839 RET     Z
0422A8 7C      5840 LD      A,H
0422A9 AA      5841 XOR     D               ;CALC. RESULT SIGN
0422AA 08      5842 EX      AF,AF'          ;SAVE SIGN
0422AB CB      5843 SET     7,D             ;REPLACE IMPLIED 1's
0422AC FA 
0422AD CB      5844 SET     7,H
0422AE FC 
0422AF C5      5845 PUSH    BC              ;SAVE EXPONENTS
0422B0 42      5846 LD      B,D             ;LOAD REGISTERS
0422B1 4B      5847 LD      C,E
0422B2 11      5848 LD      DE,0
0422B3 00 
0422B4 00 
0422B5 00 
0422B6 D9      5849 EXX
0422B7 42      5850 LD      B,D
0422B8 4B      5851 LD      C,E
0422B9 11      5852 LD      DE,0
0422BA 00 
0422BB 00 
0422BC 00 
0422BD 3E      5853 LD      A,-32           ;LOOP COUNTER
0422BE E0 
0422BF CD      5854 CALL    DIVA            ;DIVIDE
0422C0 9C 
0422C1 2D 
0422C2 04 
0422C3 D9      5855 EXX
0422C4 CB      5856 BIT     7,D
0422C5 7A 
0422C6 D9      5857 EXX
0422C7 CC      5858 CALL    Z,DIVB          ;NORMALISE & INC A
0422C8 BB 
0422C9 2D 
0422CA 04 
0422CB EB      5859 EX      DE,HL
0422CC D9      5860 EXX
0422CD CB      5861 SRL     B               ;DIVISOR/2
0422CE 38 
0422CF CB      5862 RR      C
0422D0 19 
0422D1 B7      5863 OR      A               ;CLEAR CARRY
0422D2 52      5864 SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422D3 ED 
0422D4 42 
0422D5 3F      5865 CCF
0422D6 EB      5866 EX      DE,HL           ;RESULT IN HLH'L'
0422D7 CC      5867 CALL    Z,ODD           ;ROUND UNBIASSED
0422D8 09 
0422D9 2C 
0422DA 04 
0422DB DC      5868 CALL    C,ADD1_FP          ;ROUND UP
0422DC F7 
0422DD 2B 
0422DE 04 
0422DF C1      5869 POP     BC              ;RESTORE EXPONENTS
0422E0 DC      5870 CALL    C,INCC
0422E1 24 
0422E2 2C 
0422E3 04 
0422E4 1F      5871 RRA                     ;LSB OF A TO CARRY
0422E5 79      5872 LD      A,C             ;COMPUTE NEW EXPONENT
0422E6 98      5873 SBC     A,B
0422E7 3F      5874 CCF
0422E8 C3      5875 JP      CHKOVF
0422E9 89 
0422EA 23 
0422EB 04 
               5876 ;
               5877 ;IMUL - Integer multiplication.
               5878 ;
0422EC 7C      5879 IMUL:			LD      A,H
0422ED AA      5880 XOR     D
0422EE 08      5881 EX      AF,AF'          ;SAVE RESULT SIGN
0422EF CB      5882 BIT     7,H
0422F0 7C 
0422F1 C4      5883 CALL    NZ,NEGATE
0422F2 12 
0422F3 2B 
0422F4 04 
0422F5 CD      5884 CALL    SWAP_FP
0422F6 0F 
0422F7 2C 
0422F8 04 
0422F9 CB      5885 BIT     7,H
0422FA 7C 
0422FB C4      5886 CALL    NZ,NEGATE
0422FC 12 
0422FD 2B 
0422FE 04 
0422FF 44      5887 LD      B,H
042300 4D      5888 LD      C,L
042301 21      5889 LD      HL,0
042302 00 
042303 00 
042304 00 
042305 D9      5890 EXX
042306 44      5891 LD      B,H
042307 4D      5892 LD      C,L
042308 21      5893 LD      HL,0
042309 00 
04230A 00 
04230B 00 
04230C 3E      5894 LD      A,-33
04230D DF 
04230E CD      5895 CALL    MULA            ;MULTIPLY
04230F D3 
042310 2D 
042311 04 
042312 D9      5896 EXX
042313 0E      5897 LD      C,191           ;PRESET EXPONENT
042314 BF 
042315 CD      5898 CALL    TEST_FP            ;TEST RANGE
042316 37 
042317 2C 
042318 04 
042319 20      5899 JR      NZ,IMUL1        ;TOO BIG
04231A 0F 
04231B CB      5900 BIT     7,D
04231C 7A 
04231D 20      5901 JR      NZ,IMUL1
04231E 0B 
04231F CD      5902 CALL    SWAP_FP
042320 0F 
042321 2C 
042322 04 
042323 4A      5903 LD      C,D             ;INTEGER MARKER
042324 08      5904 EX      AF,AF'
042325 F0      5905 RET     P
042326 C3      5906 JP      NEGATE
042327 12 
042328 2B 
042329 04 
               5907 ;
04232A 0D      5908 IMUL1:			DEC     C
04232B D9      5909 EXX
04232C CB      5910 SLA     E
04232D 23 
04232E CB      5911 RL      D
04232F 12 
042330 D9      5912 EXX
042331 CB      5913 RL      E
042332 13 
042333 CB      5914 RL      D
042334 12 
042335 D9      5915 EXX
042336 52      5916 ADC.S   HL,HL
042337 ED 
042338 6A 
042339 D9      5917 EXX
04233A 52      5918 ADC.S   HL,HL
04233B ED 
04233C 6A 
04233D F2      5919 JP      P,IMUL1         ;NORMALISE
04233E 2A 
04233F 23 
042340 04 
042341 08      5920 EX      AF,AF'
042342 F8      5921 RET     M
042343 CB      5922 RES     7,H             ;POSITIVE
042344 BC 
042345 C9      5923 RET
               5924 ;
               5925 ;FMUL - Floating point multiplication with rounding.
               5926 ;
042346 05      5927 FMUL:			DEC     B               ;TEST FOR ZERO
042347 04      5928 INC     B
042348 CA      5929 JP      Z,ZERO_FP
042349 5B 
04234A 2C 
04234B 04 
04234C 0D      5930 DEC     C               ;TEST FOR ZERO
04234D 0C      5931 INC     C
04234E C8      5932 RET     Z
04234F 7C      5933 LD      A,H
042350 AA      5934 XOR     D               ;CALC. RESULT SIGN
042351 08      5935 EX      AF,AF'
042352 CB      5936 SET     7,D             ;REPLACE IMPLIED 1's
042353 FA 
042354 CB      5937 SET     7,H
042355 FC 
042356 C5      5938 PUSH    BC              ;SAVE EXPONENTS
042357 44      5939 LD      B,H             ;LOAD REGISTERS
042358 4D      5940 LD      C,L
042359 21      5941 LD      HL,0
04235A 00 
04235B 00 
04235C 00 
04235D D9      5942 EXX
04235E 44      5943 LD      B,H
04235F 4D      5944 LD      C,L
042360 21      5945 LD      HL,0
042361 00 
042362 00 
042363 00 
042364 3E      5946 LD      A,-32           ;LOOP COUNTER
042365 E0 
042366 CD      5947 CALL    MULA            ;MULTIPLY
042367 D3 
042368 2D 
042369 04 
04236A DC      5948 CALL    C,MULB          ;NORMALISE & INC A
04236B E9 
04236C 2D 
04236D 04 
04236E D9      5949 EXX
04236F E5      5950 PUSH    HL
042370 21      5951 LD      HL,8000H
042371 00 
042372 80 
042373 00 
042374 B7      5952 OR      A               ;CLEAR CARRY
042375 52      5953 SBC.S   HL,DE
042376 ED 
042377 52 
042378 E1      5954 POP     HL
042379 CC      5955 CALL    Z,ODD           ;ROUND UNBIASSED
04237A 09 
04237B 2C 
04237C 04 
04237D DC      5956 CALL    C,ADD1_FP          ;ROUND UP
04237E F7 
04237F 2B 
042380 04 
042381 C1      5957 POP     BC              ;RESTORE EXPONENTS
042382 DC      5958 CALL    C,INCC
042383 24 
042384 2C 
042385 04 
042386 1F      5959 RRA                     ;LSB OF A TO CARRY
042387 79      5960 LD      A,C             ;COMPUTE NEW EXPONENT
042388 88      5961 ADC     A,B
042389 38      5962 CHKOVF:			JR      C,CHKO1
04238A 06 
04238B F2      5963 JP      P,ZERO_FP          ;UNDERFLOW
04238C 5B 
04238D 2C 
04238E 04 
04238F 18      5964 JR      CHKO2
042390 04 
042391 FA      5965 CHKO1:			JP      M,OFLOW         ;OVERFLOW
042392 26 
042393 2C 
042394 04 
042395 C6      5966 CHKO2:			ADD     A,80H
042396 80 
042397 4F      5967 LD      C,A
042398 CA      5968 JP      Z,ZERO_FP
042399 5B 
04239A 2C 
04239B 04 
04239C 08      5969 EX      AF,AF'          ;RESTORE SIGN BIT
04239D CB      5970 RES     7,H
04239E BC 
04239F F0      5971 RET     P
0423A0 CB      5972 SET     7,H
0423A1 FC 
0423A2 C9      5973 RET
               5974 ;
               5975 ;IPOW - Integer involution.
               5976 ;
0423A3 CD      5977 IPOW:			CALL    SWAP_FP
0423A4 0F 
0423A5 2C 
0423A6 04 
0423A7 CB      5978 BIT     7,H
0423A8 7C 
0423A9 F5      5979 PUSH    AF              ;SAVE SIGN
0423AA C4      5980 CALL    NZ,NEGATE
0423AB 12 
0423AC 2B 
0423AD 04 
0423AE 48      5981 IPOW0:			LD      C,B
0423AF 06      5982 LD      B,32            ;LOOP COUNTER
0423B0 20 
0423B1 CD      5983 IPOW1:			CALL    X2
0423B2 C7 
0423B3 2C 
0423B4 04 
0423B5 38      5984 JR      C,IPOW2
0423B6 08 
0423B7 10      5985 DJNZ    IPOW1
0423B8 F8 
0423B9 F1      5986 POP     AF
0423BA D9      5987 EXX
0423BB 2C      5988 INC     L               ;RESULT=1
0423BC D9      5989 EXX
0423BD 4C      5990 LD      C,H
0423BE C9      5991 RET
               5992 ;
0423BF F1      5993 IPOW2:			POP     AF
0423C0 C5      5994 PUSH    BC
0423C1 EB      5995 EX      DE,HL
0423C2 E5      5996 PUSH    HL
0423C3 D9      5997 EXX
0423C4 EB      5998 EX      DE,HL
0423C5 E5      5999 PUSH    HL
0423C6 D9      6000 EXX
0423C7 DD      6001 LD      IX,0
0423C8 21 
0423C9 00 
0423CA 00 
0423CA 00   
0423CC DD      6002 ADD     IX,SP
0423CD 39 
0423CE 28      6003 JR      Z,IPOW4
0423CF 48 
0423D0 C5      6004 PUSH    BC
0423D1 D9      6005 EXX
0423D2 D5      6006 PUSH    DE
0423D3 D9      6007 EXX
0423D4 D5      6008 PUSH    DE
0423D5 CD      6009 CALL    SFLOAT_FP
0423D6 DE 
0423D7 2B 
0423D8 04 
0423D9 CD      6010 CALL    RECIP
0423DA 12 
0423DB 27 
0423DC 04 
0423DD DD      6011 LD      (IX+4),C
0423DE 71 
0423DF 04 
0423E0 D9      6012 EXX
0423E1 DD      6013 LD      (IX+0),L
0423E2 75 
0423E3 00 
0423E4 DD      6014 LD      (IX+1),H
0423E5 74 
0423E6 01 
0423E7 D9      6015 EXX
0423E8 DD      6016 LD      (IX+2),L
0423E9 75 
0423EA 02 
0423EB DD      6017 LD      (IX+3),H
0423EC 74 
0423ED 03 
0423EE 18      6018 JR      IPOW5
0423EF 21 
               6019 ;
0423F0 C5      6020 IPOW3:			PUSH    BC
0423F1 D9      6021 EXX
0423F2 CB      6022 SLA     E
0423F3 23 
0423F4 CB      6023 RL      D
0423F5 12 
0423F6 D5      6024 PUSH    DE
0423F7 D9      6025 EXX
0423F8 CB      6026 RL      E
0423F9 13 
0423FA CB      6027 RL      D
0423FB 12 
0423FC D5      6028 PUSH    DE
0423FD 3E      6029 LD      A,'*' & 0FH
0423FE 0A 
0423FF F5      6030 PUSH    AF
042400 CD      6031 CALL    COPY_
042401 DB 
042402 2C 
042403 04 
042404 CD      6032 CALL    OP              ;SQUARE
042405 BB 
042406 20 
042407 04 
042408 F1      6033 POP     AF
042409 CD      6034 CALL    DLOAD5
04240A 07 
04240B 2A 
04240C 04 
04240D DC      6035 CALL    C,OP            ;MULTIPLY BY X
04240E BB 
04240F 20 
042410 04 
042411 D1      6036 IPOW5:			POP     DE
042412 D9      6037 EXX
042413 D1      6038 POP     DE
042414 D9      6039 EXX
042415 79      6040 LD      A,C
042416 C1      6041 POP     BC
042417 4F      6042 LD      C,A
042418 10      6043 IPOW4:			DJNZ    IPOW3
042419 D6 
04241A F1      6044 POP     AF
04241B F1      6045 POP     AF
04241C F1      6046 POP     AF
04241D C9      6047 RET
               6048 ;
04241E F1      6049 FPOW0:			POP     AF
04241F F1      6050 POP     AF
042420 F1      6051 POP     AF
042421 18      6052 JR      IPOW0
042422 8B 
               6053 ;
               6054 ;FPOW - Floating-point involution.
               6055 ;
042423 CB      6056 FPOW:			BIT     7,D
042424 7A 
042425 F5      6057 PUSH    AF
042426 CD      6058 CALL    SWAP_FP
042427 0F 
042428 2C 
042429 04 
04242A CD      6059 CALL    PUSH5
04242B EB 
04242C 2C 
04242D 04 
04242E 0D      6060 DEC     C
04242F 0C      6061 INC     C
042430 28      6062 JR      Z,FPOW0
042431 EC 
042432 3E      6063 LD      A,158
042433 9E 
042434 B9      6064 CP      C
042435 38      6065 JR      C,FPOW1
042436 0A 
042437 3C      6066 INC     A
042438 CD      6067 CALL    FIX
042439 E3 
04243A 2A 
04243B 04 
04243C 08      6068 EX      AF,AF'
04243D F2      6069 JP      P,FPOW0
04243E 1E 
04243F 24 
042440 04 
042441 CD      6070 FPOW1:			CALL    SWAP_FP
042442 0F 
042443 2C 
042444 04 
042445 CD      6071 CALL    LN0
042446 2F 
042447 27 
042448 04 
042449 CD      6072 CALL    POP5
04244A F4 
04244B 2C 
04244C 04 
04244D F1      6073 POP     AF
04244E CD      6074 CALL    FMUL
04244F 46 
042450 23 
042451 04 
042452 C3      6075 JP      EXP0
042453 91 
042454 26 
042455 04 
               6076 ;
               6077 ;Integer and floating-point compare.
               6078 ;Result is TRUE (-1) or FALSE (0).
               6079 ;
042456 CD      6080 FLT:			CALL    FCP
042457 65 
042458 2C 
042459 04 
04245A 18      6081 JR      ILT1
04245B 04 
04245C CD      6082 ILT:			CALL    ICP
04245D 57 
04245E 2C 
04245F 04 
042460 D0      6083 ILT1:			RET     NC
042461 18      6084 JR      TRUE_FP
042462 42 
               6085 ;
042463 CD      6086 FGT:			CALL    FCP
042464 65 
042465 2C 
042466 04 
042467 18      6087 JR      IGT1
042468 04 
042469 CD      6088 IGT:			CALL    ICP
04246A 57 
04246B 2C 
04246C 04 
04246D C8      6089 IGT1:			RET     Z
04246E D8      6090 RET     C
04246F 18      6091 JR      TRUE_FP
042470 34 
               6092 ;
042471 CD      6093 FGE:			CALL    FCP
042472 65 
042473 2C 
042474 04 
042475 18      6094 JR      IGE1
042476 04 
042477 CD      6095 IGE:			CALL    ICP
042478 57 
042479 2C 
04247A 04 
04247B D8      6096 IGE1:			RET     C
04247C 18      6097 JR      TRUE_FP
04247D 27 
               6098 ;
04247E CD      6099 FLE:			CALL    FCP
04247F 65 
042480 2C 
042481 04 
042482 18      6100 JR      ILE1
042483 04 
042484 CD      6101 ILE:			CALL    ICP
042485 57 
042486 2C 
042487 04 
042488 28      6102 ILE1:			JR      Z,TRUE_FP
042489 1B 
04248A D0      6103 RET     NC
04248B 18      6104 JR      TRUE_FP
04248C 18 
               6105 ;
04248D CD      6106 FNE:			CALL    FCP
04248E 65 
04248F 2C 
042490 04 
042491 18      6107 JR      INE1
042492 04 
042493 CD      6108 INE:			CALL    ICP
042494 57 
042495 2C 
042496 04 
042497 C8      6109 INE1:			RET     Z
042498 18      6110 JR      TRUE_FP
042499 0B 
               6111 ;
04249A CD      6112 FEQ:			CALL    FCP
04249B 65 
04249C 2C 
04249D 04 
04249E 18      6113 JR      IEQ1
04249F 04 
0424A0 CD      6114 IEQ:			CALL    ICP
0424A1 57 
0424A2 2C 
0424A3 04 
0424A4 C0      6115 IEQ1:			RET     NZ
0424A5 21      6116 TRUE_FP:			LD      HL,-1
0424A6 FF 
0424A7 FF 
0424A8 FF 
0424A9 D9      6117 EXX
0424AA 21      6118 LD      HL,-1
0424AB FF 
0424AC FF 
0424AD FF 
0424AE D9      6119 EXX
0424AF AF      6120 XOR     A
0424B0 4F      6121 LD      C,A
0424B1 C9      6122 RET
               6123 ;
               6124 ;FUNCTIONS:
               6125 ;
               6126 ;Result returned in HLH'L'C (floating point)
               6127 ;Result returned in HLH'L' (C=0) (integer)
               6128 ;All registers except IY destroyed.
               6129 ;
               6130 ;ABS - Absolute value
               6131 ;Result is numeric, variable type.
               6132 ;
0424B2 CB      6133 ABSV_FP:			BIT     7,H
0424B3 7C 
0424B4 C8      6134 RET     Z               ;POSITIVE/ZERO
0424B5 0D      6135 DEC     C
0424B6 0C      6136 INC     C
0424B7 CA      6137 JP      Z,NEGATE        ;INTEGER
0424B8 12 
0424B9 2B 
0424BA 04 
0424BB CB      6138 RES     7,H
0424BC BC 
0424BD C9      6139 RET
               6140 ;
               6141 ;NOT - Complement integer.
               6142 ;Result is integer numeric.
               6143 ;
0424BE CD      6144 NOTK_FP:			CALL    SFIX_FP
0424BF 02 
0424C0 2B 
0424C1 04 
0424C2 7C      6145 LD      A,H
0424C3 2F      6146 CPL
0424C4 67      6147 LD      H,A
0424C5 7D      6148 LD      A,L
0424C6 2F      6149 CPL
0424C7 6F      6150 LD      L,A
0424C8 D9      6151 EXX
0424C9 7C      6152 LD      A,H
0424CA 2F      6153 CPL
0424CB 67      6154 LD      H,A
0424CC 7D      6155 LD      A,L
0424CD 2F      6156 CPL
0424CE 6F      6157 LD      L,A
0424CF D9      6158 EXX
0424D0 AF      6159 XOR     A               ;NUMERIC MARKER
0424D1 C9      6160 RET
               6161 ;
               6162 ;PI - Return PI (3.141592654)
               6163 ;Result is floating-point numeric.
               6164 ;
0424D2 21      6165 PI_FP:			LD      HL,490FH
0424D3 0F 
0424D4 49 
0424D5 00 
0424D6 D9      6166 EXX
0424D7 21      6167 LD      HL,0DAA2H
0424D8 A2 
0424D9 DA 
0424DA 00 
0424DB D9      6168 EXX
0424DC 0E      6169 LD      C,81H
0424DD 81 
0424DE AF      6170 XOR     A               ;NUMERIC MARKER
0424DF C9      6171 RET
               6172 ;
               6173 ;DEG - Convert radians to degrees
               6174 ;Result is floating-point numeric.
               6175 ;
0424E0 CD      6176 DEG_FP:			CALL    FPI180
0424E1 F4 
0424E2 24 
0424E3 04 
0424E4 CD      6177 CALL    FMUL
0424E5 46 
0424E6 23 
0424E7 04 
0424E8 AF      6178 XOR     A
0424E9 C9      6179 RET
               6180 ;
               6181 ;RAD - Convert degrees to radians
               6182 ;Result is floating-point numeric.
               6183 ;
0424EA CD      6184 RAD_FP:			CALL    FPI180
0424EB F4 
0424EC 24 
0424ED 04 
0424EE CD      6185 CALL    FDIV
0424EF 9D 
0424F0 22 
0424F1 04 
0424F2 AF      6186 XOR     A
0424F3 C9      6187 RET
               6188 ;
               6189 ;180/PI
               6190 ;
0424F4 CD      6191 FPI180:			CALL    SFLOAT_FP
0424F5 DE 
0424F6 2B 
0424F7 04 
0424F8 11      6192 LD      DE,652EH
0424F9 2E 
0424FA 65 
0424FB 00 
0424FC D9      6193 EXX
0424FD 11      6194 LD      DE,0E0D3H
0424FE D3 
0424FF E0 
042500 00 
042501 D9      6195 EXX
042502 06      6196 LD      B,85H
042503 85 
042504 C9      6197 RET
               6198 ;
               6199 ;SGN - Return -1, 0 or +1
               6200 ;Result is integer numeric.
               6201 ;
042505 CD      6202 SGN_FP:			CALL    TEST_FP
042506 37 
042507 2C 
042508 04 
042509 B1      6203 OR      C
04250A C8      6204 RET     Z               ;ZERO
04250B CB      6205 BIT     7,H
04250C 7C 
04250D C2      6206 JP      NZ,TRUE_FP         ;-1
04250E A5 
04250F 24 
042510 04 
042511 CD      6207 CALL    ZERO_FP
042512 5B 
042513 2C 
042514 04 
042515 C3      6208 JP      ADD1_FP            ;1
042516 F7 
042517 2B 
042518 04 
               6209 ;
               6210 ;VAL - Return numeric value of string.
               6211 ;Input: ASCII string at IX
               6212 ;Result is variable type numeric.
               6213 ;
042519 CD      6214 VAL_FP:			CALL    SIGNQ
04251A 75 
04251B 2E 
04251C 04 
04251D F5      6215 PUSH    AF
04251E CD      6216 CALL    CON_FP
04251F 25 
042520 2A 
042521 04 
042522 F1      6217 POP     AF
042523 FE      6218 CP      '-'
042524 2D 
042525 3E      6219 LD      A,0             ;NUMERIC MARKER
042526 00 
042527 C0      6220 RET     NZ
042528 0D      6221 DEC     C
042529 0C      6222 INC     C
04252A CA      6223 JP      Z,NEGATE        ;ZERO/INTEGER
04252B 12 
04252C 2B 
04252D 04 
04252E 7C      6224 LD      A,H
04252F EE      6225 XOR     80H             ;CHANGE SIGN (FP)
042530 80 
042531 67      6226 LD      H,A
042532 AF      6227 XOR     A
042533 C9      6228 RET
               6229 ;
               6230 ;INT - Floor function
               6231 ;Result is integer numeric.
               6232 ;
042534 0D      6233 INT_FP_:			DEC     C
042535 0C      6234 INC     C
042536 C8      6235 RET     Z               ;ZERO/INTEGER
042537 3E      6236 LD      A,159
042538 9F 
042539 44      6237 LD      B,H             ;B7=SIGN BIT
04253A CD      6238 CALL    FIX
04253B E3 
04253C 2A 
04253D 04 
04253E 08      6239 EX      AF,AF'
04253F A0      6240 AND     B
042540 FC      6241 CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042541 F7 
042542 2B 
042543 04 
042544 78      6242 LD      A,B
042545 B7      6243 OR      A
042546 FC      6244 CALL    M,NEGATE
042547 12 
042548 2B 
042549 04 
04254A AF      6245 XOR     A
04254B 4F      6246 LD      C,A
04254C C9      6247 RET
               6248 ;
               6249 ;SQR - square root
               6250 ;Result is floating-point numeric.
               6251 ;
04254D CD      6252 SQR_FP:			CALL    SFLOAT_FP
04254E DE 
04254F 2B 
042550 04 
042551 CB      6253 SQR0:			BIT     7,H
042552 7C 
042553 3E      6254 LD      A,NGROOT
042554 15 
042555 C2      6255 JP      NZ,ERROR_FP_        ;"-ve root"
042556 B5 
042557 20 
042558 04 
042559 0D      6256 DEC     C
04255A 0C      6257 INC     C
04255B C8      6258 RET     Z               ;ZERO
04255C CB      6259 SET     7,H             ;IMPLIED 1
04255D FC 
04255E CB      6260 BIT     0,C
04255F 41 
042560 CC      6261 CALL    Z,DIV2          ;MAKE EXPONENT ODD
042561 17 
042562 2C 
042563 04 
042564 79      6262 LD      A,C
042565 D6      6263 SUB     80H
042566 80 
042567 CB      6264 SRA     A               ;HALVE EXPONENT
042568 2F 
042569 C6      6265 ADD     A,80H
04256A 80 
04256B 4F      6266 LD      C,A
04256C C5      6267 PUSH    BC              ;SAVE EXPONENT
04256D EB      6268 EX      DE,HL
04256E 21      6269 LD      HL,0
04256F 00 
042570 00 
042571 00 
042572 44      6270 LD      B,H
042573 4D      6271 LD      C,L
042574 D9      6272 EXX
042575 EB      6273 EX      DE,HL
042576 21      6274 LD      HL,0
042577 00 
042578 00 
042579 00 
04257A 44      6275 LD      B,H
04257B 4D      6276 LD      C,L
04257C 3E      6277 LD      A,-31
04257D E1 
04257E CD      6278 CALL    SQRA            ;ROOT
04257F 0D 
042580 2E 
042581 04 
042582 D9      6279 EXX
042583 CB      6280 BIT     7,B
042584 78 
042585 D9      6281 EXX
042586 CC      6282 CALL    Z,SQRA          ;NORMALISE & INC A
042587 0D 
042588 2E 
042589 04 
04258A CD      6283 CALL    SQRB
04258B 4E 
04258C 2E 
04258D 04 
04258E B7      6284 OR      A               ;CLEAR CARRY
04258F CD      6285 CALL    DIVB
042590 BB 
042591 2D 
042592 04 
042593 CB      6286 RR      E               ;LSB TO CARRY
042594 1B 
042595 60      6287 LD      H,B
042596 69      6288 LD      L,C
042597 D9      6289 EXX
042598 60      6290 LD      H,B
042599 69      6291 LD      L,C
04259A DC      6292 CALL    C,ADD1_FP          ;ROUND UP
04259B F7 
04259C 2B 
04259D 04 
04259E C1      6293 POP     BC              ;RESTORE EXPONENT
04259F DC      6294 CALL    C,INCC
0425A0 24 
0425A1 2C 
0425A2 04 
0425A3 1F      6295 RRA
0425A4 9F      6296 SBC     A,A
0425A5 81      6297 ADD     A,C
0425A6 4F      6298 LD      C,A
0425A7 CB      6299 RES     7,H             ;POSITIVE
0425A8 BC 
0425A9 AF      6300 XOR     A
0425AA C9      6301 RET
               6302 ;
               6303 ;TAN - Tangent function
               6304 ;Result is floating-point numeric.
               6305 ;
0425AB CD      6306 TAN_FP:			CALL    SFLOAT_FP
0425AC DE 
0425AD 2B 
0425AE 04 
0425AF CD      6307 CALL    PUSH5
0425B0 EB 
0425B1 2C 
0425B2 04 
0425B3 CD      6308 CALL    COS0
0425B4 D5 
0425B5 25 
0425B6 04 
0425B7 CD      6309 CALL    POP5
0425B8 F4 
0425B9 2C 
0425BA 04 
0425BB CD      6310 CALL    PUSH5
0425BC EB 
0425BD 2C 
0425BE 04 
0425BF CD      6311 CALL    SWAP_FP
0425C0 0F 
0425C1 2C 
0425C2 04 
0425C3 CD      6312 CALL    SIN0
0425C4 E2 
0425C5 25 
0425C6 04 
0425C7 CD      6313 CALL    POP5
0425C8 F4 
0425C9 2C 
0425CA 04 
0425CB CD      6314 CALL    FDIV
0425CC 9D 
0425CD 22 
0425CE 04 
0425CF AF      6315 XOR     A               ;NUMERIC MARKER
0425D0 C9      6316 RET
               6317 ;
               6318 ;COS - Cosine function
               6319 ;Result is floating-point numeric.
               6320 ;
0425D1 CD      6321 COS_FP:			CALL    SFLOAT_FP
0425D2 DE 
0425D3 2B 
0425D4 04 
0425D5 CD      6322 COS0:			CALL    SCALE
0425D6 3A 
0425D7 2B 
0425D8 04 
0425D9 1C      6323 INC     E
0425DA 1C      6324 INC     E
0425DB 7B      6325 LD      A,E
0425DC 18      6326 JR      SIN1
0425DD 10 
               6327 ;
               6328 ;SIN - Sine function
               6329 ;Result is floating-point numeric.
               6330 ;
0425DE CD      6331 SIN_FP:			CALL    SFLOAT_FP
0425DF DE 
0425E0 2B 
0425E1 04 
0425E2 E5      6332 SIN0:			PUSH    HL              ;H7=SIGN
0425E3 CD      6333 CALL    SCALE
0425E4 3A 
0425E5 2B 
0425E6 04 
0425E7 F1      6334 POP     AF
0425E8 07      6335 RLCA
0425E9 07      6336 RLCA
0425EA 07      6337 RLCA
0425EB E6      6338 AND     4
0425EC 04 
0425ED AB      6339 XOR     E
0425EE F5      6340 SIN1:			PUSH    AF              ;OCTANT
0425EF CB      6341 RES     7,H
0425F0 BC 
0425F1 1F      6342 RRA
0425F2 CD      6343 CALL    PIBY4
0425F3 80 
0425F4 26 
0425F5 04 
0425F6 DC      6344 CALL    C,RSUB          ;X=(PI/4)-X
0425F7 21 
0425F8 22 
0425F9 04 
0425FA F1      6345 POP     AF
0425FB F5      6346 PUSH    AF
0425FC E6      6347 AND     3
0425FD 03 
0425FE E2      6348 JP      PO,SIN2         ;USE COSINE APPROX.
0425FF 37 
042600 26 
042601 04 
042602 CD      6349 CALL    PUSH5           ;SAVE X
042603 EB 
042604 2C 
042605 04 
042606 CD      6350 CALL    SQUARE          ;PUSH X*X
042607 E3 
042608 2C 
042609 04 
04260A CD      6351 CALL    POLY
04260B 28 
04260C 2D 
04260D 04 
04260E B7      6352 DW	0A8B7H          ;a(8)
04260F A8 
042610 11      6353 DW	3611H
042611 36 
042612 6D      6354 DB	6DH
042613 26      6355 DW	0DE26H          ;a(6)
042614 DE 
042615 05      6356 DW	0D005H
042616 D0 
042617 73      6357 DB	73H
042618 C0      6358 DW	80C0H           ;a(4)
042619 80 
04261A 88      6359 DW	888H
04261B 08 
04261C 79      6360 DB	79H
04261D 9D      6361 DW	0AA9DH          ;a(2)
04261E AA 
04261F AA      6362 DW	0AAAAH
042620 AA 
042621 7D      6363 DB	7DH
042622 00      6364 DW	0               ;a(0)
042623 00 
042624 00      6365 DW	0
042625 00 
042626 80      6366 DB	80H
042627 CD      6367 CALL    POP5
042628 F4 
042629 2C 
04262A 04 
04262B CD      6368 CALL    POP5
04262C F4 
04262D 2C 
04262E 04 
04262F CD      6369 CALL    FMUL
042630 46 
042631 23 
042632 04 
042633 C3      6370 JP      SIN3
042634 5C 
042635 26 
042636 04 
               6371 ;
042637 CD      6372 SIN2:			CALL    SQUARE          ;PUSH X*X
042638 E3 
042639 2C 
04263A 04 
04263B CD      6373 CALL    POLY
04263C 28 
04263D 2D 
04263E 04 
04263F 71      6374 DW	0D571H          ;b(8)
042640 D5 
042641 78      6375 DW	4C78H
042642 4C 
042643 70      6376 DB	70H
042644 AF      6377 DW	94AFH           ;b(6)
042645 94 
042646 03      6378 DW	0B603H
042647 B6 
042648 76      6379 DB	76H
042649 C8      6380 DW	9CC8H           ;b(4)
04264A 9C 
04264B AA      6381 DW	2AAAH
04264C 2A 
04264D 7B      6382 DB	7BH
04264E DD      6383 DW	0FFDDH          ;b(2)
04264F FF 
042650 FF      6384 DW	0FFFFH
042651 FF 
042652 7E      6385 DB	7EH
042653 00      6386 DW	0               ;b(0)
042654 00 
042655 00      6387 DW	0
042656 00 
042657 80      6388 DB	80H
042658 CD      6389 CALL    POP5
042659 F4 
04265A 2C 
04265B 04 
04265C F1      6390 SIN3:			POP     AF
04265D E6      6391 AND     4
04265E 04 
04265F C8      6392 RET     Z
042660 0D      6393 DEC     C
042661 0C      6394 INC     C
042662 C8      6395 RET     Z               ;ZERO
042663 CB      6396 SET     7,H             ;MAKE NEGATIVE
042664 FC 
042665 C9      6397 RET
               6398 ;
               6399 ;Floating-point one:
               6400 ;
042666 21      6401 FONE_FP:			LD      HL,0
042667 00 
042668 00 
042669 00 
04266A D9      6402 EXX
04266B 21      6403 LD      HL,0
04266C 00 
04266D 00 
04266E 00 
04266F D9      6404 EXX
042670 0E      6405 LD      C,80H
042671 80 
042672 C9      6406 RET
               6407 ;
042673 11      6408 DONE:			LD      DE,0
042674 00 
042675 00 
042676 00 
042677 D9      6409 EXX
042678 11      6410 LD      DE,0
042679 00 
04267A 00 
04267B 00 
04267C D9      6411 EXX
04267D 06      6412 LD      B,80H
04267E 80 
04267F C9      6413 RET
               6414 ;
042680 11      6415 PIBY4:			LD      DE,490FH
042681 0F 
042682 49 
042683 00 
042684 D9      6416 EXX
042685 11      6417 LD      DE,0DAA2H
042686 A2 
042687 DA 
042688 00 
042689 D9      6418 EXX
04268A 06      6419 LD      B,7FH
04268B 7F 
04268C C9      6420 RET
               6421 ;
               6422 ;EXP - Exponential function
               6423 ;Result is floating-point numeric.
               6424 ;
04268D CD      6425 EXP_FP:			CALL    SFLOAT_FP
04268E DE 
04268F 2B 
042690 04 
042691 CD      6426 EXP0:			CALL    LN2             ;LN(2)
042692 1E 
042693 27 
042694 04 
042695 D9      6427 EXX
042696 1D      6428 DEC     E
042697 01      6429 LD      BC,0D1CFH       ;0.6931471805599453
042698 CF 
042699 D1 
04269A 00 
04269B D9      6430 EXX
04269C E5      6431 PUSH    HL              ;H7=SIGN
04269D CD      6432 CALL    MOD48           ;"MODULUS"
04269E 4D 
04269F 2B 
0426A0 04 
0426A1 F1      6433 POP     AF
0426A2 CB      6434 BIT     7,E
0426A3 7B 
0426A4 28      6435 JR      Z,EXP1
0426A5 0B 
0426A6 17      6436 RLA
0426A7 DA      6437 JP      C,ZERO_FP
0426A8 5B 
0426A9 2C 
0426AA 04 
0426AB 3E      6438 LD      A,EXPRNG
0426AC 18 
0426AD C3      6439 JP      ERROR_FP_           ;"Exp range"
0426AE B5 
0426AF 20 
0426B0 04 
               6440 ;
0426B1 E6      6441 EXP1:			AND     80H
0426B2 80 
0426B3 B3      6442 OR      E
0426B4 F5      6443 PUSH    AF              ;INTEGER PART
0426B5 CB      6444 RES     7,H
0426B6 BC 
0426B7 CD      6445 CALL    PUSH5           ;PUSH X*LN(2)
0426B8 EB 
0426B9 2C 
0426BA 04 
0426BB CD      6446 CALL    POLY
0426BC 28 
0426BD 2D 
0426BE 04 
0426BF 72      6447 DW	4072H           ;a(7)
0426C0 40 
0426C1 2E      6448 DW	942EH
0426C2 94 
0426C3 73      6449 DB	73H
0426C4 65      6450 DW	6F65H           ;a(6)
0426C5 6F 
0426C6 4F      6451 DW	2E4FH
0426C7 2E 
0426C8 76      6452 DB	76H
0426C9 37      6453 DW	6D37H           ;a(5)
0426CA 6D 
0426CB 02      6454 DW	8802H
0426CC 88 
0426CD 79      6455 DB	79H
0426CE 12      6456 DW	0E512H          ;a(4)
0426CF E5 
0426D0 A0      6457 DW	2AA0H
0426D1 2A 
0426D2 7B      6458 DB	7BH
0426D3 14      6459 DW	4F14H           ;a(3)
0426D4 4F 
0426D5 AA      6460 DW	0AAAAH
0426D6 AA 
0426D7 7D      6461 DB	7DH
0426D8 56      6462 DW	0FD56H          ;a(2)
0426D9 FD 
0426DA FF      6463 DW	7FFFH
0426DB 7F 
0426DC 7E      6464 DB	7EH
0426DD FE      6465 DW	0FFFEH          ;a(1)
0426DE FF 
0426DF FF      6466 DW	0FFFFH
0426E0 FF 
0426E1 7F      6467 DB	7FH
0426E2 00      6468 DW	0               ;a(0)
0426E3 00 
0426E4 00      6469 DW	0
0426E5 00 
0426E6 80      6470 DB	80H
0426E7 CD      6471 CALL    POP5
0426E8 F4 
0426E9 2C 
0426EA 04 
0426EB F1      6472 POP     AF
0426EC F5      6473 PUSH    AF
0426ED F4      6474 CALL    P,RECIP         ;X=1/X
0426EE 12 
0426EF 27 
0426F0 04 
0426F1 F1      6475 POP     AF
0426F2 F2      6476 JP      P,EXP4
0426F3 FA 
0426F4 26 
0426F5 04 
0426F6 E6      6477 AND     7FH
0426F7 7F 
0426F8 ED      6478 NEG
0426F9 44 
0426FA C6      6479 EXP4:			ADD     A,80H
0426FB 80 
0426FC 81      6480 ADD     A,C
0426FD 38      6481 JR      C,EXP2
0426FE 06 
0426FF F2      6482 JP      P,ZERO_FP          ;UNDERFLOW
042700 5B 
042701 2C 
042702 04 
042703 18      6483 JR      EXP3
042704 04 
042705 FA      6484 EXP2:			JP      M,OFLOW         ;OVERFLOW
042706 26 
042707 2C 
042708 04 
042709 C6      6485 EXP3:			ADD     A,80H
04270A 80 
04270B CA      6486 JP      Z,ZERO_FP
04270C 5B 
04270D 2C 
04270E 04 
04270F 4F      6487 LD      C,A
042710 AF      6488 XOR     A               ;NUMERIC MARKER
042711 C9      6489 RET
               6490 ;
042712 CD      6491 RECIP:			CALL    DONE
042713 73 
042714 26 
042715 04 
042716 CD      6492 RDIV:			CALL    SWAP_FP
042717 0F 
042718 2C 
042719 04 
04271A C3      6493 JP      FDIV            ;RECIPROCAL
04271B 9D 
04271C 22 
04271D 04 
               6494 ;
04271E 11      6495 LN2:			LD      DE,3172H        ;LN(2)
04271F 72 
042720 31 
042721 00 
042722 D9      6496 EXX
042723 11      6497 LD      DE,17F8H
042724 F8 
042725 17 
042726 00 
042727 D9      6498 EXX
042728 06      6499 LD      B,7FH
042729 7F 
04272A C9      6500 RET
               6501 ;
               6502 ;LN - Natural log.
               6503 ;Result is floating-point numeric.
               6504 ;
04272B CD      6505 LN_FP:			CALL    SFLOAT_FP
04272C DE 
04272D 2B 
04272E 04 
04272F 3E      6506 LN0:			LD      A,LOGRNG
042730 16 
042731 CB      6507 BIT     7,H
042732 7C 
042733 C2      6508 JP      NZ,ERROR_FP_        ;"Log range"
042734 B5 
042735 20 
042736 04 
042737 0C      6509 INC     C
042738 0D      6510 DEC     C
042739 CA      6511 JP      Z,ERROR_FP_
04273A B5 
04273B 20 
04273C 04 
04273D 11      6512 LD      DE,3504H        ;SQR(2)
04273E 04 
04273F 35 
042740 00 
042741 D9      6513 EXX
042742 11      6514 LD      DE,0F333H       ;1.41421356237
042743 33 
042744 F3 
042745 00 
042746 D9      6515 EXX
042747 CD      6516 CALL    ICP0            ;MANTISSA>SQR(2)?
042748 6E 
042749 2C 
04274A 04 
04274B 79      6517 LD      A,C             ;EXPONENT
04274C 0E      6518 LD      C,80H           ;1 <= X < 2
04274D 80 
04274E 38      6519 JR      C,LN4
04274F 02 
042750 0D      6520 DEC     C
042751 3C      6521 INC     A
042752 F5      6522 LN4:			PUSH    AF              ;SAVE EXPONENT
042753 CD      6523 CALL    RATIO           ;X=(X-1)/(X+1)
042754 00 
042755 2D 
042756 04 
042757 CD      6524 CALL    PUSH5
042758 EB 
042759 2C 
04275A 04 
04275B CD      6525 CALL    SQUARE          ;PUSH X*X
04275C E3 
04275D 2C 
04275E 04 
04275F CD      6526 CALL    POLY
042760 28 
042761 2D 
042762 04 
042763 48      6527 DW	0CC48H          ;a(9)
042764 CC 
042765 FB      6528 DW	74FBH
042766 74 
042767 7D      6529 DB	7DH
042768 AF      6530 DW	0AEAFH          ;a(7)
042769 AE 
04276A FF      6531 DW	11FFH
04276B 11 
04276C 7E      6532 DB	7EH
04276D 8C      6533 DW	0D98CH          ;a(5)
04276E D9 
04276F CD      6534 DW	4CCDH
042770 4C 
042771 7E      6535 DB	7EH
042772 E3      6536 DW	0A9E3H          ;a(3)
042773 A9 
042774 AA      6537 DW	2AAAH
042775 2A 
042776 7F      6538 DB	7FH
042777 00      6539 DW	0               ;a(1)
042778 00 
042779 00      6540 DW	0
04277A 00 
04277B 81      6541 DB	81H
04277C CD      6542 CALL    POP5
04277D F4 
04277E 2C 
04277F 04 
042780 CD      6543 CALL    POP5
042781 F4 
042782 2C 
042783 04 
042784 CD      6544 CALL    FMUL
042785 46 
042786 23 
042787 04 
042788 F1      6545 POP     AF              ;EXPONENT
042789 CD      6546 CALL    PUSH5
04278A EB 
04278B 2C 
04278C 04 
04278D 08      6547 EX      AF,AF'
04278E CD      6548 CALL    ZERO_FP
04278F 5B 
042790 2C 
042791 04 
042792 08      6549 EX      AF,AF'
042793 D6      6550 SUB     80H
042794 80 
042795 28      6551 JR      Z,LN3
042796 1F 
042797 30      6552 JR      NC,LN1
042798 02 
042799 2F      6553 CPL
04279A 3C      6554 INC     A
04279B 67      6555 LN1:			LD      H,A
04279C 0E      6556 LD      C,87H
04279D 87 
04279E F5      6557 PUSH    AF
04279F CD      6558 CALL    FLOAT_
0427A0 BE 
0427A1 2B 
0427A2 04 
0427A3 CB      6559 RES     7,H
0427A4 BC 
0427A5 CD      6560 CALL    LN2
0427A6 1E 
0427A7 27 
0427A8 04 
0427A9 CD      6561 CALL    FMUL
0427AA 46 
0427AB 23 
0427AC 04 
0427AD F1      6562 POP     AF
0427AE 30      6563 JR      NC,LN3
0427AF 06 
0427B0 FA      6564 JP      M,LN3
0427B1 B6 
0427B2 27 
0427B3 04 
0427B4 CB      6565 SET     7,H
0427B5 FC 
0427B6 CD      6566 LN3:			CALL    POP5
0427B7 F4 
0427B8 2C 
0427B9 04 
0427BA CD      6567 CALL    FADD
0427BB 34 
0427BC 22 
0427BD 04 
0427BE AF      6568 XOR     A
0427BF C9      6569 RET
               6570 ;
               6571 ;LOG - base-10 logarithm.
               6572 ;Result is floating-point numeric.
               6573 ;
0427C0 CD      6574 LOG_FP:			CALL    LN_FP
0427C1 2B 
0427C2 27 
0427C3 04 
0427C4 11      6575 LD      DE,5E5BH        ;LOG(e)
0427C5 5B 
0427C6 5E 
0427C7 00 
0427C8 D9      6576 EXX
0427C9 11      6577 LD      DE,0D8A9H
0427CA A9 
0427CB D8 
0427CC 00 
0427CD D9      6578 EXX
0427CE 06      6579 LD      B,7EH
0427CF 7E 
0427D0 CD      6580 CALL    FMUL
0427D1 46 
0427D2 23 
0427D3 04 
0427D4 AF      6581 XOR     A
0427D5 C9      6582 RET
               6583 ;
               6584 ;ASN - Arc-sine
               6585 ;Result is floating-point numeric.
               6586 ;
0427D6 CD      6587 ASN_FP:			CALL    SFLOAT_FP
0427D7 DE 
0427D8 2B 
0427D9 04 
0427DA CD      6588 CALL    PUSH5
0427DB EB 
0427DC 2C 
0427DD 04 
0427DE CD      6589 CALL    COPY_
0427DF DB 
0427E0 2C 
0427E1 04 
0427E2 CD      6590 CALL    FMUL
0427E3 46 
0427E4 23 
0427E5 04 
0427E6 CD      6591 CALL    DONE
0427E7 73 
0427E8 26 
0427E9 04 
0427EA CD      6592 CALL    RSUB
0427EB 21 
0427EC 22 
0427ED 04 
0427EE CD      6593 CALL    SQR0
0427EF 51 
0427F0 25 
0427F1 04 
0427F2 CD      6594 CALL    POP5
0427F3 F4 
0427F4 2C 
0427F5 04 
0427F6 0C      6595 INC     C
0427F7 0D      6596 DEC     C
0427F8 3E      6597 LD      A,2
0427F9 02 
0427FA D5      6598 PUSH    DE
0427FB CA      6599 JP      Z,ACS1
0427FC 80 
0427FD 28 
0427FE 04 
0427FF D1      6600 POP     DE
042800 CD      6601 CALL    RDIV
042801 16 
042802 27 
042803 04 
042804 18      6602 JR      ATN0
042805 04 
               6603 ;
               6604 ;ATN - arc-tangent
               6605 ;Result is floating-point numeric.
               6606 ;
042806 CD      6607 ATN_FP:			CALL    SFLOAT_FP
042807 DE 
042808 2B 
042809 04 
04280A E5      6608 ATN0:			PUSH    HL              ;SAVE SIGN
04280B CB      6609 RES     7,H
04280C BC 
04280D 11      6610 LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
04280E 13 
04280F 54 
042810 00 
042811 D9      6611 EXX
042812 11      6612 LD      DE,0CCD0H
042813 D0 
042814 CC 
042815 00 
042816 D9      6613 EXX
042817 06      6614 LD      B,7EH
042818 7E 
042819 CD      6615 CALL    FCP0            ;COMPARE
04281A 6B 
04281B 2C 
04281C 04 
04281D 06      6616 LD      B,0
04281E 00 
04281F 38      6617 JR      C,ATN2
042820 22 
042821 11      6618 LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
042822 82 
042823 1A 
042824 00 
042825 D9      6619 EXX
042826 11      6620 LD      DE,799AH
042827 9A 
042828 79 
042829 00 
04282A D9      6621 EXX
04282B 06      6622 LD      B,81H
04282C 81 
04282D CD      6623 CALL    FCP0            ;COMPARE
04282E 6B 
04282F 2C 
042830 04 
042831 38      6624 JR      C,ATN1
042832 0A 
042833 CD      6625 CALL    RECIP           ;X=1/X
042834 12 
042835 27 
042836 04 
042837 06      6626 LD      B,2
042838 02 
042839 C3      6627 JP      ATN2
04283A 43 
04283B 28 
04283C 04 
04283D CD      6628 ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
04283E 00 
04283F 2D 
042840 04 
042841 06      6629 LD      B,1
042842 01 
042843 C5      6630 ATN2:			PUSH    BC              ;SAVE FLAG
042844 CD      6631 CALL    PUSH5
042845 EB 
042846 2C 
042847 04 
042848 CD      6632 CALL    SQUARE          ;PUSH X*X
042849 E3 
04284A 2C 
04284B 04 
04284C CD      6633 CALL    POLY
04284D 28 
04284E 2D 
04284F 04 
042850 35      6634 DW	0F335H          ;a(13)
042851 F3 
042852 D8      6635 DW	37D8H
042853 37 
042854 7B      6636 DB	7BH
042855 91      6637 DW	6B91H           ;a(11)
042856 6B 
042857 B9      6638 DW	0AAB9H
042858 AA 
042859 7C      6639 DB	7CH
04285A DE      6640 DW	41DEH           ;a(9)
04285B 41 
04285C 97      6641 DW	6197H
04285D 61 
04285E 7C      6642 DB	7CH
04285F 7B      6643 DW	9D7BH           ;a(7)
042860 9D 
042861 37      6644 DW	9237H
042862 92 
042863 7D      6645 DB	7DH
042864 5A      6646 DW	2A5AH           ;a(5)
042865 2A 
042866 CC      6647 DW	4CCCH
042867 4C 
042868 7D      6648 DB	7DH
042869 5C      6649 DW	0A95CH          ;a(3)
04286A A9 
04286B AA      6650 DW	0AAAAH
04286C AA 
04286D 7E      6651 DB	7EH
04286E 00      6652 DW	0               ;a(1)
04286F 00 
042870 00      6653 DW	0
042871 00 
042872 80      6654 DB	80H
042873 CD      6655 CALL    POP5
042874 F4 
042875 2C 
042876 04 
042877 CD      6656 CALL    POP5
042878 F4 
042879 2C 
04287A 04 
04287B CD      6657 CALL    FMUL
04287C 46 
04287D 23 
04287E 04 
04287F F1      6658 POP     AF
042880 CD      6659 ACS1:			CALL    PIBY4           ;PI/4
042881 80 
042882 26 
042883 04 
042884 1F      6660 RRA
042885 F5      6661 PUSH    AF
042886 DC      6662 CALL    C,FADD
042887 34 
042888 22 
042889 04 
04288A F1      6663 POP     AF
04288B 04      6664 INC     B
04288C 1F      6665 RRA
04288D DC      6666 CALL    C,RSUB
04288E 21 
04288F 22 
042890 04 
042891 F1      6667 POP     AF
042892 B7      6668 OR      A
042893 F0      6669 RET     P
042894 CB      6670 SET     7,H             ;MAKE NEGATIVE
042895 FC 
042896 AF      6671 XOR     A
042897 C9      6672 RET
               6673 ;
               6674 ;ACS - Arc cosine=PI/2-ASN.
               6675 ;Result is floating point numeric.
               6676 ;
042898 CD      6677 ACS_FP:			CALL    ASN_FP
042899 D6 
04289A 27 
04289B 04 
04289C 3E      6678 LD      A,2
04289D 02 
04289E F5      6679 PUSH    AF
04289F 18      6680 JR      ACS1
0428A0 DF 
               6681 ;
               6682 ;Function STR - convert numeric value to ASCII string.
               6683 ;   Inputs: HLH'L'C = integer or floating-point number
               6684 ;           DE = address at which to store string
               6685 ;           IX = address of @% format control
               6686 ;  Outputs: String stored, with NUL terminator
               6687 ;
               6688 ;First normalise for decimal output:
               6689 ;
0428A1 CD      6690 STR_FP:			CALL    SFLOAT_FP
0428A2 DE 
0428A3 2B 
0428A4 04 
0428A5 06      6691 LD      B,0             ;DEFAULT PT. POSITION
0428A6 00 
0428A7 CB      6692 BIT     7,H             ;NEGATIVE?
0428A8 7C 
0428A9 28      6693 JR      Z,STR10
0428AA 06 
0428AB CB      6694 RES     7,H
0428AC BC 
0428AD 3E      6695 LD      A,'-'
0428AE 2D 
0428AF 12      6696 LD      (DE),A          ;STORE SIGN
0428B0 13      6697 INC     DE
0428B1 AF      6698 STR10:			XOR     A               ;CLEAR A
0428B2 B9      6699 CP      C
0428B3 28      6700 JR      Z,STR02          ;ZERO
0428B4 4E 
0428B5 D5      6701 PUSH    DE              ;SAVE TEXT POINTER
0428B6 78      6702 LD      A,B
0428B7 F5      6703 STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B8 79      6704 LD      A,C             ;BINARY EXPONENT
0428B9 FE      6705 CP      161
0428BA A1 
0428BB 30      6706 JR      NC,STR14
0428BC 1C 
0428BD FE      6707 CP      155
0428BE 9B 
0428BF 30      6708 JR      NC,STR15
0428C0 29 
0428C1 2F      6709 CPL
0428C2 FE      6710 CP      225
0428C3 E1 
0428C4 38      6711 JR      C,STR13
0428C5 02 
0428C6 3E      6712 LD      A,-8
0428C7 F8 
0428C8 C6      6713 STR13:			ADD     A,28
0428C9 1C 
0428CA CD      6714 CALL    POWR10
0428CB 57 
0428CC 2D 
0428CD 04 
0428CE F5      6715 PUSH    AF
0428CF CD      6716 CALL    FMUL
0428D0 46 
0428D1 23 
0428D2 04 
0428D3 F1      6717 POP     AF
0428D4 47      6718 LD      B,A
0428D5 F1      6719 POP     AF
0428D6 90      6720 SUB     B
0428D7 18      6721 JR      STR11
0428D8 DE 
0428D9 D6      6722 STR14:			SUB     32
0428DA 20 
0428DB CD      6723 CALL    POWR10
0428DC 57 
0428DD 2D 
0428DE 04 
0428DF F5      6724 PUSH    AF
0428E0 CD      6725 CALL    FDIV
0428E1 9D 
0428E2 22 
0428E3 04 
0428E4 F1      6726 POP     AF
0428E5 47      6727 LD      B,A
0428E6 F1      6728 POP     AF
0428E7 80      6729 ADD     A,B
0428E8 18      6730 JR      STR11
0428E9 CD 
0428EA 3E      6731 STR15:			LD      A,9
0428EB 09 
0428EC CD      6732 CALL    POWR10          ;10^9
0428ED 57 
0428EE 2D 
0428EF 04 
0428F0 CD      6733 CALL    FCP0
0428F1 6B 
0428F2 2C 
0428F3 04 
0428F4 79      6734 LD      A,C
0428F5 C1      6735 POP     BC
0428F6 4F      6736 LD      C,A
0428F7 CB      6737 SET     7,H             ;IMPLIED 1
0428F8 FC 
0428F9 DC      6738 CALL    C,X10B          ;X10, DEC B
0428FA 93 
0428FB 2C 
0428FC 04 
0428FD D1      6739 POP     DE              ;RESTORE TEXT POINTER
0428FE CB      6740 RES     7,C
0428FF B9 
042900 3E      6741 LD      A,0
042901 00 
042902 17      6742 RLA                     ;PUT CARRY IN LSB
               6743 ;
               6744 ;At this point decimal normalisation has been done,
               6745 ;now convert to decimal digits:
               6746 ;      AHLH'L' = number in normalised integer form
               6747 ;            B = decimal place adjustment
               6748 ;            C = binary place adjustment (29-33)
               6749 ;
042903 0C      6750 STR02:			INC     C
042904 08      6751 EX      AF,AF'          ;SAVE A
042905 78      6752 LD      A,B
042906 DD      6753 BIT     1,(IX+2)
042907 CB 
042908 02 
042909 4E 
04290A 20      6754 JR      NZ,STR20
04290B 08 
04290C AF      6755 XOR     A
04290D DD      6756 CP      (IX+1)
04290E BE 
04290F 01 
042910 28      6757 JR      Z,STR21
042911 0B 
042912 3E      6758 LD      A,-10
042913 F6 
042914 DD      6759 STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042915 86 
042916 01 
042917 B7      6760 OR      A               ;CLEAR CARRY
042918 FA      6761 JP      M,STR21
042919 1D 
04291A 29 
04291B 04 
04291C AF      6762 XOR     A
04291D F5      6763 STR21:			PUSH    AF
04291E 08      6764 EX      AF,AF'          ;RESTORE A
04291F CD      6765 STR22:			CALL    X2              ;RL AHLH'L'
042920 C7 
042921 2C 
042922 04 
042923 8F      6766 ADC     A,A
042924 FE      6767 CP      10
042925 0A 
042926 38      6768 JR      C,STR23
042927 05 
042928 D6      6769 SUB     10
042929 0A 
04292A D9      6770 EXX
04292B 2C      6771 INC     L               ;SET RESULT BIT
04292C D9      6772 EXX
04292D 0D      6773 STR23:			DEC     C
04292E 20      6774 JR      NZ,STR22        ;32 TIMES
04292F EF 
042930 4F      6775 LD      C,A             ;REMAINDER
042931 7C      6776 LD      A,H
042932 E6      6777 AND     3FH             ;CLEAR OUT JUNK
042933 3F 
042934 67      6778 LD      H,A
042935 F1      6779 POP     AF
042936 F2      6780 JP      P,STR24
042937 44 
042938 29 
042939 04 
04293A 3C      6781 INC     A
04293B 20      6782 JR      NZ,STR26
04293C 1C 
04293D 3E      6783 LD      A,4
04293E 04 
04293F B9      6784 CP      C               ;ROUND UP?
042940 3E      6785 LD      A,0
042941 00 
042942 18      6786 JR      STR26
042943 15 
042944 F5      6787 STR24:			PUSH    AF
042945 79      6788 LD      A,C
042946 CE      6789 ADC     A,'0'           ;ADD CARRY
042947 30 
042948 FE      6790 CP      '0'
042949 30 
04294A 28      6791 JR      Z,STR25         ;SUPPRESS ZERO
04294B 05 
04294C FE      6792 CP      '9'+1
04294D 3A 
04294E 3F      6793 CCF
04294F 30      6794 JR      NC,STR26
042950 08 
042951 E3      6795 STR25:			EX      (SP),HL
042952 CB      6796 BIT     6,L             ;ZERO FLAG
042953 75 
042954 E3      6797 EX      (SP),HL
042955 20      6798 JR      NZ,STR27
042956 05 
042957 3E      6799 LD      A,'0'
042958 30 
042959 3C      6800 STR26:			INC     A               ;SET +VE
04295A 3D      6801 DEC     A
04295B F5      6802 PUSH    AF              ;PUT ON STACK + CARRY
04295C 04      6803 STR27:			INC     B
04295D CD      6804 CALL    TEST_FP            ;IS HLH'L' ZERO?
04295E 37 
04295F 2C 
042960 04 
042961 0E      6805 LD      C,32
042962 20 
042963 3E      6806 LD      A,0
042964 00 
042965 20      6807 JR      NZ,STR22
042966 B8 
042967 F1      6808 POP     AF
042968 F5      6809 PUSH    AF
042969 3E      6810 LD      A,0
04296A 00 
04296B 38      6811 JR      C,STR22
04296C B2 
               6812 ;
               6813 ;At this point, the decimal character string is stored
               6814 ; on the stack. Trailing zeroes are suppressed and may
               6815 ; need to be replaced.
               6816 ;B register holds decimal point position.
               6817 ;Now format number and store as ASCII string:
               6818 ;
04296D EB      6819 STR3:			EX      DE,HL           ;STRING POINTER
04296E 0E      6820 LD      C,-1            ;FLAG "E"
04296F FF 
042970 16      6821 LD      D,1
042971 01 
042972 DD      6822 LD      E,(IX+1)        ;f2
042973 5E 
042974 01 
042975 DD      6823 BIT     0,(IX+2)
042976 CB 
042977 02 
042978 46 
042979 20      6824 JR      NZ,STR34        ;E MODE
04297A 35 
04297B DD      6825 BIT     1,(IX+2)
04297C CB 
04297D 02 
04297E 4E 
04297F 28      6826 JR      Z,STR31
042980 12 
042981 78      6827 LD      A,B             ;F MODE
042982 B7      6828 OR      A
042983 28      6829 JR      Z,STR30
042984 05 
042985 FA      6830 JP      M,STR30
042986 8A 
042987 29 
042988 04 
042989 50      6831 LD      D,B
04298A 7A      6832 STR30:			LD      A,D
04298B DD      6833 ADD     A,(IX+1)
04298C 86 
04298D 01 
04298E 5F      6834 LD      E,A
04298F FE      6835 CP      11
042990 0B 
042991 38      6836 JR      C,STR32
042992 19 
042993 78      6837 STR31:			LD      A,B             ;G MODE
042994 11      6838 LD      DE,101H
042995 01 
042996 01 
042997 00 
042998 B7      6839 OR      A
042999 FA      6840 JP      M,STR34
04299A B0 
04299B 29 
04299C 04 
04299D 28      6841 JR      Z,STR32
04299E 0D 
04299F DD      6842 LD      A,(IX+1)
0429A0 7E 
0429A1 01 
0429A2 B7      6843 OR      A
0429A3 20      6844 JR      NZ,STR3A
0429A4 02 
0429A5 3E      6845 LD      A,10
0429A6 0A 
0429A7 B8      6846 STR3A:			CP      B
0429A8 38      6847 JR      C,STR34
0429A9 06 
0429AA 50      6848 LD      D,B
0429AB 58      6849 LD      E,B
0429AC 78      6850 STR32:			LD      A,B
0429AD C6      6851 ADD     A,129
0429AE 81 
0429AF 4F      6852 LD      C,A
0429B0 CB      6853 STR34:			SET     7,D
0429B1 FA 
0429B2 1D      6854 DEC     E
0429B3 7A      6855 STR35:			LD      A,D
0429B4 B9      6856 CP      C
0429B5 30      6857 JR      NC,STR33
0429B6 0E 
0429B7 F1      6858 STR36:			POP     AF
0429B8 28      6859 JR      Z,STR37
0429B9 04 
0429BA F2      6860 JP      P,STR38
0429BB C7 
0429BC 29 
0429BD 04 
0429BE F5      6861 STR37:			PUSH    AF
0429BF 1C      6862 INC     E
0429C0 1D      6863 DEC     E
0429C1 FA      6864 JP      M,STR4
0429C2 D8 
0429C3 29 
0429C4 04 
0429C5 3E      6865 STR33:			LD      A,'0'
0429C6 30 
0429C7 15      6866 STR38:			DEC     D
0429C8 E2      6867 JP      PO,STR39
0429C9 CF 
0429CA 29 
0429CB 04 
0429CC 36      6868 LD      (HL),'.'
0429CD 2E 
0429CE 23      6869 INC     HL
0429CF 77      6870 STR39:			LD      (HL),A
0429D0 23      6871 INC     HL
0429D1 1D      6872 DEC     E
0429D2 F2      6873 JP      P,STR35
0429D3 B3 
0429D4 29 
0429D5 04 
0429D6 18      6874 JR      STR36
0429D7 DF 
               6875 ;
0429D8 F1      6876 STR4:			POP     AF
0429D9 0C      6877 STR40:			INC     C
0429DA 4D      6878 LD      C,L
0429DB 20      6879 JR      NZ,STR44
0429DC 28 
0429DD 36      6880 LD      (HL),'E'        ;EXPONENT
0429DE 45 
0429DF 23      6881 INC     HL
0429E0 78      6882 LD      A,B
0429E1 3D      6883 DEC     A
0429E2 F2      6884 JP      P,STR41
0429E3 EB 
0429E4 29 
0429E5 04 
0429E6 36      6885 LD      (HL),'-'
0429E7 2D 
0429E8 23      6886 INC     HL
0429E9 ED      6887 NEG
0429EA 44 
0429EB 36      6888 STR41:			LD      (HL),'0'
0429EC 30 
0429ED 28      6889 JR      Z,STR47
0429EE 15 
0429EF FE      6890 CP      10
0429F0 0A 
0429F1 47      6891 LD      B,A
0429F2 3E      6892 LD      A,':'
0429F3 3A 
0429F4 38      6893 JR      C,STR42
0429F5 03 
0429F6 23      6894 INC     HL
0429F7 36      6895 LD      (HL),'0'
0429F8 30 
0429F9 34      6896 STR42:			INC     (HL)
0429FA BE      6897 CP      (HL)
0429FB 20      6898 JR      NZ,STR43
0429FC 05 
0429FD 36      6899 LD      (HL),'0'
0429FE 30 
0429FF 2B      6900 DEC     HL
042A00 34      6901 INC     (HL)
042A01 23      6902 INC     HL
042A02 10      6903 STR43:			DJNZ    STR42
042A03 F5 
042A04 23      6904 STR47:			INC     HL
042A05 EB      6905 STR44:			EX      DE,HL
042A06 C9      6906 RET
               6907 ;
               6908 ;Support subroutines:
               6909 ;
042A07 DD      6910 DLOAD5:			LD      B,(IX+4)
042A08 46 
042A09 04 
042A0A D9      6911 EXX
042A0B DD      6912 LD      E,(IX+0)
042A0C 5E 
042A0D 00 
042A0E DD      6913 LD      D,(IX+1)
042A0F 56 
042A10 01 
042A11 D9      6914 EXX
042A12 DD      6915 LD      E,(IX+2)
042A13 5E 
042A14 02 
042A15 DD      6916 LD      D,(IX+3)
042A16 56 
042A17 03 
042A18 C9      6917 RET
               6918 ;
042A19 DD      6919 DLOAD5_SPL:		LD      B,(IX+6)
042A1A 46 
042A1B 06 
042A1C D9      6920 EXX
042A1D DD      6921 LD	DE, (IX+0)
042A1E 17 
042A1F 00 
042A20 D9      6922 EXX
042A21 DD      6923 LD	DE, (IX+3)
042A22 17 
042A23 03 
042A24 C9      6924 RET
               6925 ;
               6926 ;CON_FP - Get unsigned numeric constant from ASCII string.
               6927 ;   Inputs: ASCII string at (IX).
               6928 ;  Outputs: Variable-type result in HLH'L'C
               6929 ;           IX updated (points to delimiter)
               6930 ;           A7 = 0 (numeric marker)
               6931 ;
042A25 CD      6932 CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A26 5B 
042A27 2C 
042A28 04 
042A29 0E      6933 LD      C,0             ;TRUNCATION COUNTER
042A2A 00 
042A2B CD      6934 CALL    UINT          ;GET INTEGER PART
042A2C B9 
042A2D 2A 
042A2E 04 
042A2F FE      6935 CP      '.'
042A30 2E 
042A31 06      6936 LD      B,0             ;DECL. PLACE COUNTER
042A32 00 
042A33 CC      6937 CALL    Z,NUMBIX        ;GET FRACTION PART
042A34 B7 
042A35 2A 
042A36 04 
042A37 FE      6938 CP      'E'
042A38 45 
042A39 3E      6939 LD      A,0             ;INITIALISE EXPONENT
042A3A 00 
042A3B CC      6940 CALL    Z,GETEXP        ;GET EXPONENT
042A3C 85 
042A3D 2A 
042A3E 04 
042A3F CB      6941 BIT     7,H
042A40 7C 
042A41 20      6942 JR      NZ,CON0         ;INTEGER OVERFLOW
042A42 08 
042A43 B7      6943 OR      A
042A44 20      6944 JR      NZ,CON0         ;EXPONENT NON-ZERO
042A45 05 
042A46 B8      6945 CP      B
042A47 20      6946 JR      NZ,CON0         ;DECIMAL POINT
042A48 02 
042A49 B9      6947 CP      C
042A4A C8      6948 RET     Z               ;INTEGER
042A4B 90      6949 CON0:			SUB     B
042A4C 81      6950 ADD     A,C
042A4D 0E      6951 LD      C,159
042A4E 9F 
042A4F CD      6952 CALL    FLOAT_
042A50 BE 
042A51 2B 
042A52 04 
042A53 CB      6953 RES     7,H             ;DITCH IMPLIED 1
042A54 BC 
042A55 B7      6954 OR      A
042A56 C8      6955 RET     Z               ;DONE
042A57 FA      6956 JP      M,CON2          ;NEGATIVE EXPONENT
042A58 65 
042A59 2A 
042A5A 04 
042A5B CD      6957 CALL    POWR10
042A5C 57 
042A5D 2D 
042A5E 04 
042A5F CD      6958 CALL    FMUL            ;SCALE
042A60 46 
042A61 23 
042A62 04 
042A63 AF      6959 XOR     A
042A64 C9      6960 RET
042A65 FE      6961 CON2:			CP      -38
042A66 DA 
042A67 38      6962 JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A68 0C 
042A69 ED      6963 NEG
042A6A 44 
042A6B CD      6964 CALL    POWR10
042A6C 57 
042A6D 2D 
042A6E 04 
042A6F CD      6965 CALL    FDIV            ;SCALE
042A70 9D 
042A71 22 
042A72 04 
042A73 AF      6966 XOR     A
042A74 C9      6967 RET
042A75 F5      6968 CON3:			PUSH    AF
042A76 3E      6969 LD      A,38
042A77 26 
042A78 CD      6970 CALL    POWR10
042A79 57 
042A7A 2D 
042A7B 04 
042A7C CD      6971 CALL    FDIV
042A7D 9D 
042A7E 22 
042A7F 04 
042A80 F1      6972 POP     AF
042A81 C6      6973 ADD     A,38
042A82 26 
042A83 18      6974 JR      CON2
042A84 E0 
               6975 ;
               6976 ;GETEXP - Get decimal exponent from string
               6977 ;     Inputs: ASCII string at (IX)
               6978 ;             (IX points at 'E')
               6979 ;             A = initial value
               6980 ;    Outputs: A = new exponent
               6981 ;             IX updated.
               6982 ;   Destroys: A,A',IX,F,F'
               6983 ;
042A85 C5      6984 GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A86 47      6985 LD      B,A             ;INITIAL VALUE
042A87 0E      6986 LD      C,2             ;2 DIGITS MAX
042A88 02 
042A89 DD      6987 INC     IX              ;BUMP PAST 'E'
042A8A 23 
042A8B CD      6988 CALL    SIGNQ
042A8C 75 
042A8D 2E 
042A8E 04 
042A8F 08      6989 EX      AF,AF'          ;SAVE EXPONENT SIGN
042A90 CD      6990 GETEX1:			CALL    DIGITQ
042A91 6B 
042A92 2E 
042A93 04 
042A94 38      6991 JR      C,GETEX2
042A95 18 
042A96 78      6992 LD      A,B             ;B=B*10
042A97 87      6993 ADD     A,A
042A98 87      6994 ADD     A,A
042A99 80      6995 ADD     A,B
042A9A 87      6996 ADD     A,A
042A9B 47      6997 LD      B,A
042A9C DD      6998 LD      A,(IX)          ;GET BACK DIGIT
042A9D 7E 
042A9E 00 
042A9F DD      6999 INC     IX
042AA0 23 
042AA1 E6      7000 AND     0FH             ;MASK UNWANTED BITS
042AA2 0F 
042AA3 80      7001 ADD     A,B             ;ADD IN DIGIT
042AA4 47      7002 LD      B,A
042AA5 0D      7003 DEC     C
042AA6 F2      7004 JP      P,GETEX1
042AA7 90 
042AA8 2A 
042AA9 04 
042AAA 06      7005 LD      B,100           ;FORCE OVERFLOW
042AAB 64 
042AAC 18      7006 JR      GETEX1
042AAD E2 
042AAE 08      7007 GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AAF FE      7008 CP      '-'
042AB0 2D 
042AB1 78      7009 LD      A,B
042AB2 C1      7010 POP     BC              ;RESTORE
042AB3 C0      7011 RET     NZ
042AB4 ED      7012 NEG                     ;NEGATE EXPONENT
042AB5 44 
042AB6 C9      7013 RET
               7014 ;
               7015 ;UINT: Get unsigned integer from string.
               7016 ;    Inputs: string at (IX)
               7017 ;            C = truncated digit count
               7018 ;                (initially zero)
               7019 ;            B = total digit count
               7020 ;            HLH'L' = initial value
               7021 ;   Outputs: HLH'L' = number (binary integer)
               7022 ;            A = delimiter.
               7023 ;            B, C & IX updated
               7024 ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7025 ;
042AB7 DD      7026 NUMBIX:			INC     IX
042AB8 23 
042AB9 CD      7027 UINT:			CALL    DIGITQ
042ABA 6B 
042ABB 2E 
042ABC 04 
042ABD D8      7028 RET     C
042ABE 04      7029 INC     B               ;INCREMENT DIGIT COUNT
042ABF DD      7030 INC     IX
042AC0 23 
042AC1 CD      7031 CALL    X10             ;*10 & COPY OLD VALUE
042AC2 B4 
042AC3 2C 
042AC4 04 
042AC5 38      7032 JR      C,NUMB1         ;OVERFLOW
042AC6 15 
042AC7 0D      7033 DEC     C               ;SEE IF TRUNCATED
042AC8 0C      7034 INC     C
042AC9 20      7035 JR      NZ,NUMB1        ;IMPORTANT!
042ACA 11 
042ACB E6      7036 AND     0FH
042ACC 0F 
042ACD D9      7037 EXX
042ACE 06      7038 LD      B,0
042ACF 00 
042AD0 4F      7039 LD      C,A
042AD1 52      7040 ADD.S   HL,BC           ;ADD IN DIGIT
042AD2 09 
042AD3 D9      7041 EXX
042AD4 30      7042 JR      NC,UINT
042AD5 E3 
042AD6 52      7043 INC.S   HL              ;CARRY
042AD7 23 
042AD8 7C      7044 LD      A,H
042AD9 B5      7045 OR      L
042ADA 20      7046 JR      NZ,UINT
042ADB DD 
042ADC 0C      7047 NUMB1:			INC     C               ;TRUNCATION COUNTER
042ADD CD      7048 CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042ADE 12 
042ADF 2C 
042AE0 04 
042AE1 18      7049 JR      UINT
042AE2 D6 
               7050 ;
               7051 ;FIX - Fix number to specified exponent value.
               7052 ;    Inputs: HLH'L'C = +ve non-zero number (floated)
               7053 ;            A = desired exponent (A>C)
               7054 ;   Outputs: HLH'L'C = fixed number (unsigned)
               7055 ;            fraction shifted into B'C'
               7056 ;            A'F' positive if integer input
               7057 ;  Destroys: C,H,L,A',B',C',H',L',F,F'
               7058 ;
042AE3 08      7059 FIX:			EX      AF,AF'
042AE4 AF      7060 XOR     A
042AE5 08      7061 EX      AF,AF'
042AE6 CB      7062 SET     7,H             ;IMPLIED 1
042AE7 FC 
042AE8 CD      7063 FIX1:			CALL    DIV2
042AE9 17 
042AEA 2C 
042AEB 04 
042AEC B9      7064 CP      C
042AED C8      7065 RET     Z
042AEE D2      7066 JP      NC,FIX1
042AEF E8 
042AF0 2A 
042AF1 04 
042AF2 C3      7067 JP      OFLOW
042AF3 26 
042AF4 2C 
042AF5 04 
               7068 ;
               7069 ;SFIX - Convert to integer if necessary.
               7070 ;    Input: Variable-type number in HLH'L'C
               7071 ;   Output: Integer in HLH'L', C=0
               7072 ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
               7073 ;
               7074 ;NEGATE - Negate HLH'L'
               7075 ;    Destroys: H,L,H',L',F
               7076 ;
042AF6 CD      7077 FIX2:			CALL    SWAP_FP
042AF7 0F 
042AF8 2C 
042AF9 04 
042AFA CD      7078 CALL    SFIX_FP
042AFB 02 
042AFC 2B 
042AFD 04 
042AFE CD      7079 CALL    SWAP_FP
042AFF 0F 
042B00 2C 
042B01 04 
042B02 0D      7080 SFIX_FP:			DEC     C
042B03 0C      7081 INC     C
042B04 C8      7082 RET     Z               ;INTEGER/ZERO
042B05 CB      7083 BIT     7,H             ;SIGN
042B06 7C 
042B07 F5      7084 PUSH    AF
042B08 3E      7085 LD      A,159
042B09 9F 
042B0A CD      7086 CALL    FIX
042B0B E3 
042B0C 2A 
042B0D 04 
042B0E F1      7087 POP     AF
042B0F 0E      7088 LD      C,0
042B10 00 
042B11 C8      7089 RET     Z
042B12 B7      7090 NEGATE:			OR      A               ;CLEAR CARRY
042B13 D9      7091 EXX
042B14 D5      7092 NEG0:			PUSH    DE
042B15 EB      7093 EX      DE,HL
042B16 21      7094 LD      HL,0
042B17 00 
042B18 00 
042B19 00 
042B1A 52      7095 SBC.S   HL,DE
042B1B ED 
042B1C 52 
042B1D D1      7096 POP     DE
042B1E D9      7097 EXX
042B1F D5      7098 PUSH    DE
042B20 EB      7099 EX      DE,HL
042B21 21      7100 LD      HL,0
042B22 00 
042B23 00 
042B24 00 
042B25 52      7101 SBC.S   HL,DE
042B26 ED 
042B27 52 
042B28 D1      7102 POP     DE
042B29 C9      7103 RET
               7104 ;
               7105 ;NEG - Negate HLH'L'B'C'
               7106 ;    Also complements A (used in FADD)
               7107 ;    Destroys: A,H,L,B',C',H',L',F
               7108 ;
042B2A D9      7109 NEG_:			EXX
042B2B 2F      7110 CPL
042B2C E5      7111 PUSH    HL
042B2D B7      7112 OR      A               ;CLEAR CARRY
042B2E 21      7113 LD      HL,0
042B2F 00 
042B30 00 
042B31 00 
042B32 52      7114 SBC.S   HL,BC
042B33 ED 
042B34 42 
042B35 44      7115 LD      B,H
042B36 4D      7116 LD      C,L
042B37 E1      7117 POP     HL
042B38 18      7118 JR      NEG0
042B39 DA 
               7119 ;
               7120 ;SCALE - Trig scaling.
               7121 ;MOD48 - 48-bit floating-point "modulus" (remainder).
               7122 ;   Inputs: HLH'L'C unsigned floating-point dividend
               7123 ;           DED'E'B'C'B unsigned 48-bit FP divisor
               7124 ;  Outputs: HLH'L'C floating point remainder (H7=1)
               7125 ;           E = quotient (bit 7 is sticky)
               7126 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
               7127 ;FLO48 - Float unsigned number (48 bits)
               7128 ;    Input/output in HLH'L'B'C'C
               7129 ;   Destroys: C,H,L,B',C',H',L',F
               7130 ;
042B3A 3E      7131 SCALE:			LD      A,150
042B3B 96 
042B3C B9      7132 CP      C
042B3D 3E      7133 LD      A,ACLOST
042B3E 17 
042B3F DA      7134 JP      C,ERROR_FP_         ;"Accuracy lost"
042B40 B5 
042B41 20 
042B42 04 
042B43 CD      7135 CALL    PIBY4
042B44 80 
042B45 26 
042B46 04 
042B47 D9      7136 EXX
042B48 01      7137 LD      BC,2169H        ;3.141592653589793238
042B49 69 
042B4A 21 
042B4B 00 
042B4C D9      7138 EXX
042B4D CB      7139 MOD48:			SET     7,D             ;IMPLIED 1
042B4E FA 
042B4F CB      7140 SET     7,H
042B50 FC 
042B51 79      7141 LD      A,C
042B52 0E      7142 LD      C,0             ;INIT QUOTIENT
042B53 00 
042B54 DD      7143 LD      IX,0
042B55 21 
042B56 00 
042B57 00 
042B57 00   
042B59 DD      7144 PUSH    IX              ;PUT ZERO ON STACK
042B5A E5 
042B5B B8      7145 CP      B
042B5C 38      7146 JR      C,MOD485        ;DIVIDEND<DIVISOR
042B5D 46 
042B5E D9      7147 MOD481:			EXX                     ;CARRY=0 HERE
042B5F E3      7148 EX      (SP),HL
042B60 52      7149 SBC.S   HL,BC
042B61 ED 
042B62 42 
042B63 E3      7150 EX      (SP),HL
042B64 52      7151 SBC.S   HL,DE
042B65 ED 
042B66 52 
042B67 D9      7152 EXX
042B68 52      7153 SBC.S   HL,DE
042B69 ED 
042B6A 52 
042B6B 30      7154 JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B6C 0C 
042B6D D9      7155 EXX
042B6E E3      7156 EX      (SP),HL
042B6F 52      7157 ADD.S   HL,BC
042B70 09 
042B71 E3      7158 EX      (SP),HL
042B72 52      7159 ADC.S   HL,DE
042B73 ED 
042B74 5A 
042B75 D9      7160 EXX
042B76 52      7161 ADC.S   HL,DE
042B77 ED 
042B78 5A 
042B79 3F      7162 MOD482:			CCF
042B7A CB      7163 RL      C               ;QUOTIENT
042B7B 11 
042B7C 30      7164 JR      NC,MOD483
042B7D 02 
042B7E CB      7165 SET     7,C             ;STICKY BIT
042B7F F9 
042B80 3D      7166 MOD483:			DEC     A
042B81 B8      7167 CP      B
042B82 38      7168 JR      C,MOD484        ;DIVIDEND<DIVISOR
042B83 1F 
042B84 E3      7169 EX      (SP),HL
042B85 52      7170 ADD.S   HL,HL           ;DIVIDEND * 2
042B86 29 
042B87 E3      7171 EX      (SP),HL
042B88 D9      7172 EXX
042B89 52      7173 ADC.S   HL,HL
042B8A ED 
042B8B 6A 
042B8C D9      7174 EXX
042B8D 52      7175 ADC.S   HL,HL
042B8E ED 
042B8F 6A 
042B90 30      7176 JR      NC,MOD481       ;AGAIN
042B91 CC 
042B92 B7      7177 OR      A
042B93 D9      7178 EXX
042B94 E3      7179 EX      (SP),HL
042B95 52      7180 SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B96 ED 
042B97 42 
042B98 E3      7181 EX      (SP),HL
042B99 52      7182 SBC.S   HL,DE
042B9A ED 
042B9B 52 
042B9C D9      7183 EXX
042B9D 52      7184 SBC.S   HL,DE
042B9E ED 
042B9F 52 
042BA0 B7      7185 OR      A
042BA1 18      7186 JR      MOD482
042BA2 D6 
               7187 ;
042BA3 3C      7188 MOD484:			INC     A
042BA4 59      7189 MOD485:			LD      E,C             ;QUOTIENT
042BA5 4F      7190 LD      C,A             ;REMAINDER EXPONENT
042BA6 D9      7191 EXX
042BA7 C1      7192 POP     BC
042BA8 D9      7193 EXX
042BA9 CB      7194 FLO48:			BIT     7,H
042BAA 7C 
042BAB C0      7195 RET     NZ
042BAC D9      7196 EXX
042BAD CB      7197 SLA     C
042BAE 21 
042BAF CB      7198 RL      B
042BB0 10 
042BB1 52      7199 ADC.S   HL,HL
042BB2 ED 
042BB3 6A 
042BB4 D9      7200 EXX
042BB5 52      7201 ADC.S   HL,HL
042BB6 ED 
042BB7 6A 
042BB8 0D      7202 DEC     C
042BB9 C2      7203 JP      NZ,FLO48
042BBA A9 
042BBB 2B 
042BBC 04 
042BBD C9      7204 RET
               7205 ;
               7206 ;Float unsigned number
               7207 ;    Input/output in HLH'L'C
               7208 ;   Destroys: C,H,L,H',L',F
               7209 ;
042BBE CB      7210 FLOAT_:			BIT     7,H
042BBF 7C 
042BC0 C0      7211 RET     NZ
042BC1 D9      7212 EXX                     ;SAME AS "X2"
042BC2 52      7213 ADD.S   HL,HL           ;TIME-CRITICAL
042BC3 29 
042BC4 D9      7214 EXX                     ;REGION
042BC5 52      7215 ADC.S   HL,HL           ;(BENCHMARKS)
042BC6 ED 
042BC7 6A 
042BC8 0D      7216 DEC     C
042BC9 C2      7217 JP      NZ,FLOAT_
042BCA BE 
042BCB 2B 
042BCC 04 
042BCD C9      7218 RET
               7219 ;
               7220 ;SFLOAT - Convert to floating-point if necessary.
               7221 ;    Input: Variable-type number in HLH'L'C
               7222 ;    Output: Floating-point in HLH'L'C
               7223 ;    Destroys: A,C,H,L,H',L',F
               7224 ;
042BCE 08      7225 FLOATA:			EX      AF,AF'
               7226 ; ADD     A,(RTABLE-DTABLE)/3
042BCF C6      7227 ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BD0 2A 
042BD1 08      7228 EX      AF,AF'
042BD2 CD      7229 FLOAT2:			CALL    SWAP_FP
042BD3 0F 
042BD4 2C 
042BD5 04 
042BD6 CD      7230 CALL    SFLOAT_FP
042BD7 DE 
042BD8 2B 
042BD9 04 
042BDA CD      7231 CALL    SWAP_FP
042BDB 0F 
042BDC 2C 
042BDD 04 
042BDE 0D      7232 SFLOAT_FP:			DEC     C
042BDF 0C      7233 INC     C
042BE0 C0      7234 RET     NZ              ;ALREADY FLOATING-POINT
042BE1 CD      7235 CALL    TEST_FP
042BE2 37 
042BE3 2C 
042BE4 04 
042BE5 C8      7236 RET     Z               ;ZERO
042BE6 7C      7237 LD      A,H
042BE7 B7      7238 OR      A
042BE8 FC      7239 CALL    M,NEGATE
042BE9 12 
042BEA 2B 
042BEB 04 
042BEC 0E      7240 LD      C,159
042BED 9F 
042BEE CD      7241 CALL    FLOAT_
042BEF BE 
042BF0 2B 
042BF1 04 
042BF2 B7      7242 OR      A
042BF3 F8      7243 RET     M               ;NEGATIVE
042BF4 CB      7244 RES     7,H
042BF5 BC 
042BF6 C9      7245 RET
               7246 ;
               7247 ;ROUND UP
               7248 ;Return with carry set if 32-bit overflow
               7249 ;   Destroys: H,L,B',C',H',L',F
               7250 ;
042BF7 D9      7251 ADD1_FP:			EXX
042BF8 01      7252 LD      BC,1
042BF9 01 
042BFA 00 
042BFB 00 
042BFC 52      7253 ADD.S   HL,BC
042BFD 09 
042BFE D9      7254 EXX
042BFF D0      7255 RET     NC
042C00 C5      7256 PUSH    BC
042C01 01      7257 LD      BC,1
042C02 01 
042C03 00 
042C04 00 
042C05 52      7258 ADD.S   HL,BC
042C06 09 
042C07 C1      7259 POP     BC
042C08 C9      7260 RET
               7261 ;
               7262 ;ODD - Add one if even, leave alone if odd.
               7263 ; (Used to perform unbiassed rounding, i.e.
               7264 ;  number is rounded up half the time)
               7265 ;    Destroys: L',F (carry cleared)
               7266 ;
042C09 B7      7267 ODD:			OR      A               ;CLEAR CARRY
042C0A D9      7268 EXX
042C0B CB      7269 SET     0,L             ;MAKE ODD
042C0C C5 
042C0D D9      7270 EXX
042C0E C9      7271 RET
               7272 ;
               7273 ;SWAP_FP - Swap arguments.
               7274 ;    Exchanges DE,HL D'E',H'L' and B,C
               7275 ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
               7276 ;SWAP1 - Swap DEHL with D'E'H'L'
               7277 ;    Destroys: D,E,H,L,D',E',H',L'
               7278 ;
042C0F 79      7279 SWAP_FP:			LD      A,C
042C10 48      7280 LD      C,B
042C11 47      7281 LD      B,A
042C12 EB      7282 SWAP1:			EX      DE,HL
042C13 D9      7283 EXX
042C14 EB      7284 EX      DE,HL
042C15 D9      7285 EXX
042C16 C9      7286 RET
               7287 ;
               7288 ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
               7289 ; INCC - destroys C,F
               7290 ; OFLOW
               7291 ;
042C17 CD      7292 DIV2:			CALL    D2
042C18 D0 
042C19 2C 
042C1A 04 
042C1B D9      7293 EXX
042C1C CB      7294 RR      B
042C1D 18 
042C1E CB      7295 RR      C
042C1F 19 
042C20 08      7296 EX      AF,AF'
042C21 B0      7297 OR      B
042C22 08      7298 EX      AF,AF'
042C23 D9      7299 EXX
042C24 0C      7300 INCC:			INC     C
042C25 C0      7301 RET     NZ
042C26 3E      7302 OFLOW:			LD      A,TOOBIG_FP
042C27 14 
042C28 C3      7303 JP      ERROR_FP_           ;"Too big"
042C29 B5 
042C2A 20 
042C2B 04 
               7304 ;
               7305 ; FTEST - Test for zero & sign
               7306 ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
               7307 ;
042C2C CD      7308 FTEST_FP:			CALL    TEST_FP
042C2D 37 
042C2E 2C 
042C2F 04 
042C30 C8      7309 RET     Z
042C31 7C      7310 LD      A,H
042C32 E6      7311 AND     10000000B
042C33 80 
042C34 F6      7312 OR      01000000B
042C35 40 
042C36 C9      7313 RET
               7314 ;
               7315 ; TEST_FP - Test HLH'L' for zero.
               7316 ;     Output: Z-flag set & A=0 if HLH'L'=0
               7317 ;     Destroys: A,F
               7318 ;
042C37 7C      7319 TEST_FP:			LD      A,H
042C38 B5      7320 OR      L
042C39 D9      7321 EXX
042C3A B4      7322 OR      H
042C3B B5      7323 OR      L
042C3C D9      7324 EXX
042C3D C9      7325 RET
               7326 ;
               7327 ; FCOMP - Compare two numbers
               7328 ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
               7329 ;
042C3E 78      7330 FCOMP_FP:			LD      A,B
042C3F B1      7331 OR      C               ;Both integer?
042C40 20      7332 JR      NZ,FCOMP1
042C41 0B 
042C42 CD      7333 CALL    ICP
042C43 57 
042C44 2C 
042C45 04 
042C46 3E      7334 FCOMP0:			LD      A,0
042C47 00 
042C48 C8      7335 RET     Z               ;Equal
042C49 3E      7336 LD      A,80H
042C4A 80 
042C4B 1F      7337 RRA
042C4C C9      7338 RET
               7339 ;
042C4D CD      7340 FCOMP1:			CALL    FLOAT2          ;Float both
042C4E D2 
042C4F 2B 
042C50 04 
042C51 CD      7341 CALL    FCP
042C52 65 
042C53 2C 
042C54 04 
042C55 18      7342 JR      FCOMP0
042C56 EF 
               7343 ;
               7344 ; Integer and floating point compare.
               7345 ; Sets carry & zero flags according to HLH'L'C-DED'E'B
               7346 ; Result pre-set to FALSE
               7347 ; ICP1, FCP1 destroy A,F
               7348 ;
               7349 ; ZERO - Return zero.
               7350 ;  Destroys: A,C,H,L,H',L'
               7351 ;
042C57 CD      7352 ICP:			CALL    ICP1
042C58 8A 
042C59 2C 
042C5A 04 
042C5B 3E      7353 ZERO_FP:			LD      A,0
042C5C 00 
042C5D D9      7354 EXX
042C5E 67      7355 LD      H,A
042C5F 6F      7356 LD      L,A
042C60 D9      7357 EXX
042C61 67      7358 LD      H,A
042C62 6F      7359 LD      L,A
042C63 4F      7360 LD      C,A
042C64 C9      7361 RET
               7362 ;
042C65 CD      7363 FCP:			CALL    FCP1
042C66 7C 
042C67 2C 
042C68 04 
042C69 18      7364 JR      ZERO_FP            ;PRESET FALSE
042C6A F0 
               7365 ;
042C6B 79      7366 FCP0:			LD      A,C
042C6C B8      7367 CP      B               ;COMPARE EXPONENTS
042C6D C0      7368 RET     NZ
               7369 ICP0:
042C6E 52      7370 SBC.S   HL,DE           ;COMP MANTISSA MSB
042C6F ED 
042C70 52 
042C71 52      7371 ADD.S   HL,DE
042C72 19 
042C73 C0      7372 RET     NZ
042C74 D9      7373 EXX
042C75 52      7374 SBC.S   HL,DE           ;COMP MANTISSA LSB
042C76 ED 
042C77 52 
042C78 52      7375 ADD.S   HL,DE
042C79 19 
042C7A D9      7376 EXX
042C7B C9      7377 RET
               7378 ;
042C7C 7C      7379 FCP1:			LD      A,H
042C7D AA      7380 XOR     D
042C7E 7C      7381 LD      A,H
042C7F 17      7382 RLA
042C80 F8      7383 RET     M
042C81 30      7384 JR      NC,FCP0
042C82 E8 
042C83 CD      7385 CALL    FCP0
042C84 6B 
042C85 2C 
042C86 04 
042C87 C8      7386 RET     Z               ;** V0.1 BUG FIX
042C88 3F      7387 CCF
042C89 C9      7388 RET
               7389 ;
042C8A 7C      7390 ICP1:			LD      A,H
042C8B AA      7391 XOR     D
042C8C F2      7392 JP      P,ICP0
042C8D 6E 
042C8E 2C 
042C8F 04 
042C90 7C      7393 LD      A,H
042C91 17      7394 RLA
042C92 C9      7395 RET
               7396 ;
               7397 ; ADD - Integer add.
               7398 ; Carry, sign & zero flags valid on exit
               7399 ;     Destroys: H,L,H',L',F
               7400 ;
042C93 05      7401 X10B:			DEC     B
042C94 0C      7402 INC     C
042C95 CD      7403 X5:			CALL    COPY0
042C96 DC 
042C97 2C 
042C98 04 
042C99 CD      7404 CALL    D2C
042C9A CF 
042C9B 2C 
042C9C 04 
042C9D CD      7405 CALL    D2C
042C9E CF 
042C9F 2C 
042CA0 04 
042CA1 08      7406 EX      AF,AF'          ;SAVE CARRY
042CA2 D9      7407 ADD_:			EXX
042CA3 52      7408 ADD.S   HL,DE
042CA4 19 
042CA5 D9      7409 EXX
042CA6 52      7410 ADC.S   HL,DE
042CA7 ED 
042CA8 5A 
042CA9 C9      7411 RET
               7412 ;
               7413 ; SUB - Integer subtract.
               7414 ; Carry, sign & zero flags valid on exit
               7415 ;     Destroys: H,L,H',L',F
               7416 ;
042CAA D9      7417 SUB_:			EXX
042CAB B7      7418 OR      A
042CAC 52      7419 SBC.S   HL,DE
042CAD ED 
042CAE 52 
042CAF D9      7420 EXX
042CB0 52      7421 SBC.S   HL,DE
042CB1 ED 
042CB2 52 
042CB3 C9      7422 RET
               7423 ;
               7424 ; X10 - unsigned integer * 10
               7425 ;    Inputs: HLH'L' initial value
               7426 ;   Outputs: DED'E' = initial HLH'L'
               7427 ;            Carry bit set if overflow
               7428 ;            If carry not set HLH'L'=result
               7429 ;  Destroys: D,E,H,L,D',E',H',L',F
               7430 ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
               7431 ;     Carry set if MSB=1 before shift.
               7432 ;     Sign set if MSB=1 after shift.
               7433 ;     Destroys: H,L,H',L',F
               7434 ;
042CB4 CD      7435 X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CB5 DC 
042CB6 2C 
042CB7 04 
042CB8 CD      7436 CALL    X2
042CB9 C7 
042CBA 2C 
042CBB 04 
042CBC D8      7437 RET     C               ;TOO BIG
042CBD CD      7438 CALL    X2
042CBE C7 
042CBF 2C 
042CC0 04 
042CC1 D8      7439 RET     C
042CC2 CD      7440 CALL    ADD_
042CC3 A2 
042CC4 2C 
042CC5 04 
042CC6 D8      7441 RET     C
042CC7 D9      7442 X2:			EXX
042CC8 52      7443 ADD.S   HL,HL
042CC9 29 
042CCA D9      7444 EXX
042CCB 52      7445 ADC.S   HL,HL
042CCC ED 
042CCD 6A 
042CCE C9      7446 RET
               7447 ;
               7448 ; D2 - Divide HLH'L' by 2 as 32-bit integer.
               7449 ;     Carry set if LSB=1 before shift.
               7450 ;     Destroys: H,L,H',L',F
               7451 ;
042CCF 0C      7452 D2C:			INC     C
042CD0 CB      7453 D2:			SRL     H
042CD1 3C 
042CD2 CB      7454 RR      L
042CD3 1D 
042CD4 D9      7455 EXX
042CD5 CB      7456 RR      H
042CD6 1C 
042CD7 CB      7457 RR      L
042CD8 1D 
042CD9 D9      7458 EXX
042CDA C9      7459 RET
               7460 ;
               7461 ; COPY - COPY HLH'L'C INTO DED'E'B
               7462 ;   Destroys: B,C,D,E,H,L,D',E',H',L'
               7463 ;
042CDB 41      7464 COPY_:			LD      B,C
042CDC 54      7465 COPY0:			LD      D,H
042CDD 5D      7466 LD      E,L
042CDE D9      7467 EXX
042CDF 54      7468 LD      D,H
042CE0 5D      7469 LD      E,L
042CE1 D9      7470 EXX
042CE2 C9      7471 RET
               7472 ;
               7473 ; SQUARE - PUSH X*X
               7474 ; PUSH5 - PUSH HLH'L'C ONTO STACK.
               7475 ;   Destroys: SP,IX
               7476 ;
042CE3 CD      7477 SQUARE:			CALL    COPY_
042CE4 DB 
042CE5 2C 
042CE6 04 
042CE7 CD      7478 CALL    FMUL
042CE8 46 
042CE9 23 
042CEA 04 
042CEB DD      7479 PUSH5:			POP     IX              ;RETURN ADDRESS
042CEC E1 
042CED C5      7480 PUSH    BC
042CEE E5      7481 PUSH    HL
042CEF D9      7482 EXX
042CF0 E5      7483 PUSH    HL
042CF1 D9      7484 EXX
042CF2 DD      7485 JP      (IX)            ;"RETURN"
042CF3 E9 
               7486 ;
               7487 ; POP5 - POP DED'E'B OFF STACK.
               7488 ;   Destroys: A,B,D,E,D',E',SP,IX
               7489 ;
042CF4 DD      7490 POP5:			POP     IX              ;RETURN ADDRESS
042CF5 E1 
042CF6 D9      7491 EXX
042CF7 D1      7492 POP     DE
042CF8 D9      7493 EXX
042CF9 D1      7494 POP     DE
042CFA 79      7495 LD      A,C
042CFB C1      7496 POP     BC
042CFC 41      7497 LD      B,C
042CFD 4F      7498 LD      C,A
042CFE DD      7499 JP      (IX)            ;"RETURN"
042CFF E9 
               7500 ;
               7501 ; RATIO - Calculate (X-1)/(X+1)
               7502 ;     Inputs: X in HLH'L'C
               7503 ;    Outputs: (X-1)/(X+1) in HLH'L'C
               7504 ;   Destroys: Everything except IY,SP,I
               7505 ;
042D00 CD      7506 RATIO:			CALL    PUSH5           ;SAVE X
042D01 EB 
042D02 2C 
042D03 04 
042D04 CD      7507 CALL    DONE
042D05 73 
042D06 26 
042D07 04 
042D08 CD      7508 CALL    FADD
042D09 34 
042D0A 22 
042D0B 04 
042D0C CD      7509 CALL    POP5            ;RESTORE X
042D0D F4 
042D0E 2C 
042D0F 04 
042D10 CD      7510 CALL    PUSH5           ;SAVE X+1
042D11 EB 
042D12 2C 
042D13 04 
042D14 CD      7511 CALL    SWAP_FP
042D15 0F 
042D16 2C 
042D17 04 
042D18 CD      7512 CALL    DONE
042D19 73 
042D1A 26 
042D1B 04 
042D1C CD      7513 CALL    FSUB
042D1D 1B 
042D1E 22 
042D1F 04 
042D20 CD      7514 CALL    POP5            ;RESTORE X+1
042D21 F4 
042D22 2C 
042D23 04 
042D24 C3      7515 JP      FDIV
042D25 9D 
042D26 22 
042D27 04 
               7516 ;
               7517 ; POLY - Evaluate a polynomial.
               7518 ;     Inputs: X in HLH'L'C and also stored at (SP+2)
               7519 ;             Polynomial coefficients follow call.
               7520 ;    Outputs: Result in HLH'L'C
               7521 ;   Destroys: Everything except IY,SP,I
               7522 ; Routine terminates on finding a coefficient >=1.
               7523 ; Note: The last coefficient is EXECUTED on return
               7524 ;       so must contain only innocuous bytes!
               7525 ;
042D28 DD      7526 POLY:			LD      IX, 3				; Advance the SP to the return address
042D29 21 
042D2A 03 
042D2B 00 
042D2B 00   
042D2D DD      7527 ADD     IX, SP
042D2E 39 
042D2F DD      7528 EX      (SP), IX			; IX: Points to the inline list of coefficients
042D30 E3 
               7529 ;
042D31 CD      7530 CALL    DLOAD5          		; Load the first coefficient from (IX)
042D32 07 
042D33 2A 
042D34 04 
042D35 CD      7531 POLY1:			CALL    FMUL
042D36 46 
042D37 23 
042D38 04 
042D39 11      7532 LD      DE, 5				; Skip to the next coefficient
042D3A 05 
042D3B 00 
042D3C 00 
042D3D DD      7533 ADD     IX, DE
042D3E 19 
042D3F CD      7534 CALL    DLOAD5          		; Load the second coefficient from (IX)
042D40 07 
042D41 2A 
042D42 04 
042D43 DD      7535 EX      (SP), IX			; Restore the SP just in case we need to return
042D44 E3 
042D45 04      7536 INC     B
042D46 05      7537 DEC     B               		; Test B for end byte (80h)
042D47 FA      7538 JP      M,FADD				; Yes, so add and return
042D48 34 
042D49 22 
042D4A 04 
042D4B CD      7539 CALL    FADD				; No, so add
042D4C 34 
042D4D 22 
042D4E 04 
042D4F CD      7540 CALL    DLOAD5_SPL			; Load X from SP
042D50 19 
042D51 2A 
042D52 04 
042D53 DD      7541 EX      (SP), IX			; IX: Points to the inline list of coefficients
042D54 E3 
042D55 18      7542 JR      POLY1				; And loop
042D56 DE 
               7543 ;
               7544 ; POWR10 - Calculate power of ten.
               7545 ;     Inputs: A=power of 10 required (A<128)
               7546 ;             A=binary exponent to be exceeded (A>=128)
               7547 ;    Outputs: DED'E'B = result
               7548 ;             A = actual power of ten returned
               7549 ;   Destroys: A,B,D,E,A',D',E',F,F'
               7550 ;
042D57 3C      7551 POWR10:			INC     A
042D58 08      7552 EX      AF,AF'
042D59 E5      7553 PUSH    HL
042D5A D9      7554 EXX
042D5B E5      7555 PUSH    HL
042D5C D9      7556 EXX
042D5D CD      7557 CALL    DONE
042D5E 73 
042D5F 26 
042D60 04 
042D61 CD      7558 CALL    SWAP_FP
042D62 0F 
042D63 2C 
042D64 04 
042D65 AF      7559 XOR     A
042D66 08      7560 POWR11:			EX      AF,AF'
042D67 3D      7561 DEC     A
042D68 28      7562 JR      Z,POWR14        ;EXIT TYPE 1
042D69 26 
042D6A F2      7563 JP      P,POWR13
042D6B 72 
042D6C 2D 
042D6D 04 
042D6E B9      7564 CP      C
042D6F 38      7565 JR      C,POWR14        ;EXIT TYPE 2
042D70 1F 
042D71 3C      7566 INC     A
042D72 08      7567 POWR13:			EX      AF,AF'
042D73 3C      7568 INC     A
042D74 CB      7569 SET     7,H
042D75 FC 
042D76 CD      7570 CALL    X5
042D77 95 
042D78 2C 
042D79 04 
042D7A 30      7571 JR      NC,POWR12
042D7B 06 
042D7C 08      7572 EX      AF,AF'
042D7D CD      7573 CALL    D2C
042D7E CF 
042D7F 2C 
042D80 04 
042D81 08      7574 EX      AF,AF'
042D82 08      7575 POWR12:			EX      AF,AF'
042D83 DC      7576 CALL    C,ADD1_FP          ;ROUND UP
042D84 F7 
042D85 2B 
042D86 04 
042D87 0C      7577 INC     C
042D88 FA      7578 JP      M,POWR11
042D89 66 
042D8A 2D 
042D8B 04 
042D8C C3      7579 JP      OFLOW
042D8D 26 
042D8E 2C 
042D8F 04 
042D90 CD      7580 POWR14:			CALL    SWAP_FP
042D91 0F 
042D92 2C 
042D93 04 
042D94 CB      7581 RES     7,D
042D95 BA 
042D96 D9      7582 EXX
042D97 E1      7583 POP     HL
042D98 D9      7584 EXX
042D99 E1      7585 POP     HL
042D9A 08      7586 EX      AF,AF'
042D9B C9      7587 RET
               7588 ;
               7589 ; DIVA, DIVB - DIVISION PRIMITIVE.
               7590 ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
               7591 ;               Remainder in H'L'HL
               7592 ;     Inputs: A = loop counter (normally -32)
               7593 ;     Destroys: A,D,E,H,L,D',E',H',L',F
               7594 ;
042D9C B7      7595 DIVA:			OR      A               ;CLEAR CARRY
               7596 DIV0:
042D9D 52      7597 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D9E ED 
042D9F 42 
042DA0 D9      7598 EXX
042DA1 52      7599 SBC.S   HL,BC
042DA2 ED 
042DA3 42 
042DA4 D9      7600 EXX
042DA5 30      7601 JR      NC,DIV1
042DA6 07 
042DA7 52      7602 ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA8 09 
042DA9 D9      7603 EXX
042DAA 52      7604 ADC.S   HL,BC
042DAB ED 
042DAC 4A 
042DAD D9      7605 EXX
042DAE 3F      7606 DIV1:			CCF
042DAF CB      7607 DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DB0 13 
042DB1 CB      7608 RL      D
042DB2 12 
042DB3 D9      7609 EXX
042DB4 CB      7610 RL      E
042DB5 13 
042DB6 CB      7611 RL      D
042DB7 12 
042DB8 D9      7612 EXX
042DB9 3C      7613 INC     A
042DBA F0      7614 RET     P
               7615 DIVB:
042DBB 52      7616 ADC.S   HL,HL           ;DIVIDEND*2
042DBC ED 
042DBD 6A 
042DBE D9      7617 EXX
042DBF 52      7618 ADC.S   HL,HL
042DC0 ED 
042DC1 6A 
042DC2 D9      7619 EXX
042DC3 30      7620 JR      NC,DIV0
042DC4 D8 
042DC5 B7      7621 OR      A
042DC6 52      7622 SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DC7 ED 
042DC8 42 
042DC9 D9      7623 EXX
042DCA 52      7624 SBC.S   HL,BC
042DCB ED 
042DCC 42 
042DCD D9      7625 EXX
042DCE 37      7626 SCF
042DCF C3      7627 JP      DIVC
042DD0 AF 
042DD1 2D 
042DD2 04 
               7628 ;
               7629 ;MULA, MULB - MULTIPLICATION PRIMITIVE.
               7630 ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
               7631 ;    Inputs: A = loop counter (usually -32)
               7632 ;            H'L'HL = 0
               7633 ;    Destroys: D,E,H,L,D',E',H',L',A,F
               7634 ;
042DD3 B7      7635 MULA:			OR      A               ;CLEAR CARRY
042DD4 D9      7636 MUL0:			EXX
042DD5 CB      7637 RR      D               ;MULTIPLIER/2
042DD6 1A 
042DD7 CB      7638 RR      E
042DD8 1B 
042DD9 D9      7639 EXX
042DDA CB      7640 RR      D
042DDB 1A 
042DDC CB      7641 RR      E
042DDD 1B 
042DDE 30      7642 JR      NC,MUL1
042DDF 07 
042DE0 52      7643 ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DE1 09 
042DE2 D9      7644 EXX
042DE3 52      7645 ADC.S   HL,BC
042DE4 ED 
042DE5 4A 
042DE6 D9      7646 EXX
042DE7 3C      7647 MUL1:			INC     A
042DE8 F0      7648 RET     P
042DE9 D9      7649 MULB:			EXX
042DEA CB      7650 RR      H               ;PRODUCT/2
042DEB 1C 
042DEC CB      7651 RR      L
042DED 1D 
042DEE D9      7652 EXX
042DEF CB      7653 RR      H
042DF0 1C 
042DF1 CB      7654 RR      L
042DF2 1D 
042DF3 C3      7655 JP      MUL0
042DF4 D4 
042DF5 2D 
042DF6 04 
               7656 ;
               7657 ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
               7658 ;     Function: B'C'BC = SQR (D'E'DE)
               7659 ;     Inputs: A = loop counter (normally -31)
               7660 ;             B'C'BCH'L'HL initialised to 0
               7661 ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
               7662 ;
               7663 SQR1:
042DF7 52      7664 SBC.S   HL,BC
042DF8 ED 
042DF9 42 
042DFA D9      7665 EXX
042DFB 52      7666 SBC.S   HL,BC
042DFC ED 
042DFD 42 
042DFE D9      7667 EXX
042DFF 0C      7668 INC     C
042E00 30      7669 JR      NC,SQR2
042E01 09 
042E02 0D      7670 DEC     C
042E03 52      7671 ADD.S   HL,BC
042E04 09 
042E05 D9      7672 EXX
042E06 52      7673 ADC.S   HL,BC
042E07 ED 
042E08 4A 
042E09 D9      7674 EXX
042E0A 0D      7675 DEC     C
042E0B 3C      7676 SQR2:			INC     A
042E0C F0      7677 RET     P
042E0D CB      7678 SQRA:			SLA     C
042E0E 21 
042E0F CB      7679 RL      B
042E10 10 
042E11 D9      7680 EXX
042E12 CB      7681 RL      C
042E13 11 
042E14 CB      7682 RL      B
042E15 10 
042E16 D9      7683 EXX
042E17 0C      7684 INC     C
042E18 CB      7685 SLA     E
042E19 23 
042E1A CB      7686 RL      D
042E1B 12 
042E1C D9      7687 EXX
042E1D CB      7688 RL      E
042E1E 13 
042E1F CB      7689 RL      D
042E20 12 
042E21 D9      7690 EXX
042E22 52      7691 ADC.S   HL,HL
042E23 ED 
042E24 6A 
042E25 D9      7692 EXX
042E26 52      7693 ADC.S   HL,HL
042E27 ED 
042E28 6A 
042E29 D9      7694 EXX
042E2A CB      7695 SLA     E
042E2B 23 
042E2C CB      7696 RL      D
042E2D 12 
042E2E D9      7697 EXX
042E2F CB      7698 RL      E
042E30 13 
042E31 CB      7699 RL      D
042E32 12 
042E33 D9      7700 EXX
042E34 52      7701 ADC.S   HL,HL
042E35 ED 
042E36 6A 
042E37 D9      7702 EXX
042E38 52      7703 ADC.S   HL,HL
042E39 ED 
042E3A 6A 
042E3B D9      7704 EXX
042E3C D2      7705 JP      NC,SQR1
042E3D F7 
042E3E 2D 
042E3F 04 
042E40 B7      7706 SQR3:			OR      A
042E41 52      7707 SBC.S   HL,BC
042E42 ED 
042E43 42 
042E44 D9      7708 EXX
042E45 52      7709 SBC.S   HL,BC
042E46 ED 
042E47 42 
042E48 D9      7710 EXX
042E49 0C      7711 INC     C
042E4A C3      7712 JP      SQR2
042E4B 0B 
042E4C 2E 
042E4D 04 
               7713 ;
               7714 SQRB:
042E4E 52      7715 ADD.S   HL,HL
042E4F 29 
042E50 D9      7716 EXX
042E51 52      7717 ADC.S   HL,HL
042E52 ED 
042E53 6A 
042E54 D9      7718 EXX
042E55 38      7719 JR      C,SQR3
042E56 E9 
042E57 3C      7720 INC     A
042E58 0C      7721 INC     C
042E59 52      7722 SBC.S   HL,BC
042E5A ED 
042E5B 42 
042E5C D9      7723 EXX
042E5D 52      7724 SBC.S   HL,BC
042E5E ED 
042E5F 42 
042E60 D9      7725 EXX
042E61 D0      7726 RET     NC
042E62 52      7727 ADD.S   HL,BC
042E63 09 
042E64 D9      7728 EXX
042E65 52      7729 ADC.S   HL,BC
042E66 ED 
042E67 4A 
042E68 D9      7730 EXX
042E69 0D      7731 DEC     C
042E6A C9      7732 RET
               7733 ;
042E6B DD      7734 DIGITQ:			LD      A,(IX)
042E6C 7E 
042E6D 00 
042E6E FE      7735 CP      '9'+1
042E6F 3A 
042E70 3F      7736 CCF
042E71 D8      7737 RET     C
042E72 FE      7738 CP      '0'
042E73 30 
042E74 C9      7739 RET
               7740 ;
042E75 DD      7741 SIGNQ:			LD      A,(IX)
042E76 7E 
042E77 00 
042E78 DD      7742 INC     IX
042E79 23 
042E7A FE      7743 CP      ' '
042E7B 20 
042E7C 28      7744 JR      Z,SIGNQ
042E7D F7 
042E7E FE      7745 CP      '+'
042E7F 2B 
042E80 C8      7746 RET     Z
042E81 FE      7747 CP      '-'
042E82 2D 
042E83 C8      7748 RET     Z
042E84 DD      7749 DEC     IX
042E85 2B 
042E86 C9      7750 RET; --- End fpp.asm ---
               7751 
               7752 ; --- Begin gpio.asm ---
               7753 ;
               7754 ; Title:	BBC Basic for AGON - GPIO functions
               7755 ; Author:	Dean Belfield
               7756 ; Created:	12/05/2023
               7757 ; Last Updated:	12/05/2023
               7758 ;
               7759 ; Modinfo:
               7760 
               7761 ; INCLUDE	"macros.inc"
               7762 ; INCLUDE	"equs.inc"
               7763 
               7764 ; .ASSUME	ADL = 1
               7765 
               7766 ; SEGMENT CODE
               7767 
               7768 ; XDEF	GPIOB_SETMODE
               7769 
               7770 ; XREF	SWITCH_A
               7771 
               7772 ;  A: Mode
               7773 ;  B: Pins
               7774 ;
042E87 CD      7775 GPIOB_SETMODE:		CALL	SWITCH_A
042E88 2C 
042E89 3E 
042E8A 04 
042E8B 9F      7776 DW	GPIOB_M0	; Output
042E8C 2E 
042E8D C4      7777 DW	GPIOB_M1	; Input
042E8E 2E 
042E8F E4      7778 DW	GPIOB_M2	; Open Drain IO
042E90 2E 
042E91 04      7779 DW	GPIOB_M3	; Open Source IO
042E92 2F 
042E93 1F      7780 DW	GPIOB_M4	; Interrupt, Dual Edge
042E94 2F 
042E95 4B      7781 DW	GPIOB_M5	; Alt Function
042E96 2F 
042E97 66      7782 DW	GPIOB_M6	; Interrupt, Active Low
042E98 2F 
042E99 8D      7783 DW	GPIOB_M7	; Interrupt, Active High
042E9A 2F 
042E9B AF      7784 DW	GPIOB_M8	; Interrupt, Falling Edge
042E9C 2F 
042E9D D1      7785 DW	GPIOB_M9	; Interrupt, Rising Edge
042E9E 2F 
               7786 
               7787 ; Output
               7788 ;
               7789 GPIOB_M0:		RES_GPIO PB_DDR,  B
042E9F C5     0001M PUSH	BC
042EA0 78     0002M LD	A, val
042EA1 2F     0003M CPL
042EA2 4F     0004M LD	C, A
042EA3 ED     0005M IN0	A, (reg)
042EA4 38 
042EA5 9B 
042EA6 A1     0006M AND	C
042EA7 ED     0007M OUT0	(reg), A
042EA8 39 
042EA9 9B 
042EAA C1     0008M POP	BC
               7790 RES_GPIO PB_ALT1, B
042EAB C5     0001M PUSH	BC
042EAC 78     0002M LD	A, val
042EAD 2F     0003M CPL
042EAE 4F     0004M LD	C, A
042EAF ED     0005M IN0	A, (reg)
042EB0 38 
042EB1 9C 
042EB2 A1     0006M AND	C
042EB3 ED     0007M OUT0	(reg), A
042EB4 39 
042EB5 9C 
042EB6 C1     0008M POP	BC
               7791 RES_GPIO PB_ALT2, B
042EB7 C5     0001M PUSH	BC
042EB8 78     0002M LD	A, val
042EB9 2F     0003M CPL
042EBA 4F     0004M LD	C, A
042EBB ED     0005M IN0	A, (reg)
042EBC 38 
042EBD 9D 
042EBE A1     0006M AND	C
042EBF ED     0007M OUT0	(reg), A
042EC0 39 
042EC1 9D 
042EC2 C1     0008M POP	BC
042EC3 C9      7792 RET
               7793 
               7794 ; Input
               7795 ;
               7796 GPIOB_M1:		SET_GPIO PB_DDR,  B
042EC4 ED     0001M IN0	A, (reg)
042EC5 38 
042EC6 9B 
042EC7 B0     0002M OR	val
042EC8 ED     0003M OUT0	(reg), A
042EC9 39 
042ECA 9B 
               7797 RES_GPIO PB_ALT1, B
042ECB C5     0001M PUSH	BC
042ECC 78     0002M LD	A, val
042ECD 2F     0003M CPL
042ECE 4F     0004M LD	C, A
042ECF ED     0005M IN0	A, (reg)
042ED0 38 
042ED1 9C 
042ED2 A1     0006M AND	C
042ED3 ED     0007M OUT0	(reg), A
042ED4 39 
042ED5 9C 
042ED6 C1     0008M POP	BC
               7798 RES_GPIO PB_ALT2, B
042ED7 C5     0001M PUSH	BC
042ED8 78     0002M LD	A, val
042ED9 2F     0003M CPL
042EDA 4F     0004M LD	C, A
042EDB ED     0005M IN0	A, (reg)
042EDC 38 
042EDD 9D 
042EDE A1     0006M AND	C
042EDF ED     0007M OUT0	(reg), A
042EE0 39 
042EE1 9D 
042EE2 C1     0008M POP	BC
042EE3 C9      7799 RET
               7800 
               7801 ; Open Drain IO
               7802 ;
               7803 GPIOB_M2:		RES_GPIO PB_DDR,  B
042EE4 C5     0001M PUSH	BC
042EE5 78     0002M LD	A, val
042EE6 2F     0003M CPL
042EE7 4F     0004M LD	C, A
042EE8 ED     0005M IN0	A, (reg)
042EE9 38 
042EEA 9B 
042EEB A1     0006M AND	C
042EEC ED     0007M OUT0	(reg), A
042EED 39 
042EEE 9B 
042EEF C1     0008M POP	BC
               7804 SET_GPIO PB_ALT1, B
042EF0 ED     0001M IN0	A, (reg)
042EF1 38 
042EF2 9C 
042EF3 B0     0002M OR	val
042EF4 ED     0003M OUT0	(reg), A
042EF5 39 
042EF6 9C 
               7805 RES_GPIO PB_ALT2, B
042EF7 C5     0001M PUSH	BC
042EF8 78     0002M LD	A, val
042EF9 2F     0003M CPL
042EFA 4F     0004M LD	C, A
042EFB ED     0005M IN0	A, (reg)
042EFC 38 
042EFD 9D 
042EFE A1     0006M AND	C
042EFF ED     0007M OUT0	(reg), A
042F00 39 
042F01 9D 
042F02 C1     0008M POP	BC
042F03 C9      7806 RET
               7807 
               7808 ; Open Source IO
               7809 ;
               7810 GPIOB_M3:		SET_GPIO PB_DDR,  B
042F04 ED     0001M IN0	A, (reg)
042F05 38 
042F06 9B 
042F07 B0     0002M OR	val
042F08 ED     0003M OUT0	(reg), A
042F09 39 
042F0A 9B 
               7811 SET_GPIO PB_ALT1, B
042F0B ED     0001M IN0	A, (reg)
042F0C 38 
042F0D 9C 
042F0E B0     0002M OR	val
042F0F ED     0003M OUT0	(reg), A
042F10 39 
042F11 9C 
               7812 RES_GPIO PB_ALT2, B
042F12 C5     0001M PUSH	BC
042F13 78     0002M LD	A, val
042F14 2F     0003M CPL
042F15 4F     0004M LD	C, A
042F16 ED     0005M IN0	A, (reg)
042F17 38 
042F18 9D 
042F19 A1     0006M AND	C
042F1A ED     0007M OUT0	(reg), A
042F1B 39 
042F1C 9D 
042F1D C1     0008M POP	BC
042F1E C9      7813 RET
               7814 
               7815 ; Interrupt, Dual Edge
               7816 ;
               7817 GPIOB_M4:		SET_GPIO PB_DR,   B
042F1F ED     0001M IN0	A, (reg)
042F20 38 
042F21 9A 
042F22 B0     0002M OR	val
042F23 ED     0003M OUT0	(reg), A
042F24 39 
042F25 9A 
               7818 RES_GPIO PB_DDR,  B
042F26 C5     0001M PUSH	BC
042F27 78     0002M LD	A, val
042F28 2F     0003M CPL
042F29 4F     0004M LD	C, A
042F2A ED     0005M IN0	A, (reg)
042F2B 38 
042F2C 9B 
042F2D A1     0006M AND	C
042F2E ED     0007M OUT0	(reg), A
042F2F 39 
042F30 9B 
042F31 C1     0008M POP	BC
               7819 RES_GPIO PB_ALT1, B
042F32 C5     0001M PUSH	BC
042F33 78     0002M LD	A, val
042F34 2F     0003M CPL
042F35 4F     0004M LD	C, A
042F36 ED     0005M IN0	A, (reg)
042F37 38 
042F38 9C 
042F39 A1     0006M AND	C
042F3A ED     0007M OUT0	(reg), A
042F3B 39 
042F3C 9C 
042F3D C1     0008M POP	BC
               7820 RES_GPIO PB_ALT2, B
042F3E C5     0001M PUSH	BC
042F3F 78     0002M LD	A, val
042F40 2F     0003M CPL
042F41 4F     0004M LD	C, A
042F42 ED     0005M IN0	A, (reg)
042F43 38 
042F44 9D 
042F45 A1     0006M AND	C
042F46 ED     0007M OUT0	(reg), A
042F47 39 
042F48 9D 
042F49 C1     0008M POP	BC
042F4A C9      7821 RET
               7822 
               7823 ; Alt Function
               7824 ;
               7825 GPIOB_M5:		SET_GPIO PB_DDR,  B
042F4B ED     0001M IN0	A, (reg)
042F4C 38 
042F4D 9B 
042F4E B0     0002M OR	val
042F4F ED     0003M OUT0	(reg), A
042F50 39 
042F51 9B 
               7826 RES_GPIO PB_ALT1, B
042F52 C5     0001M PUSH	BC
042F53 78     0002M LD	A, val
042F54 2F     0003M CPL
042F55 4F     0004M LD	C, A
042F56 ED     0005M IN0	A, (reg)
042F57 38 
042F58 9C 
042F59 A1     0006M AND	C
042F5A ED     0007M OUT0	(reg), A
042F5B 39 
042F5C 9C 
042F5D C1     0008M POP	BC
               7827 SET_GPIO PB_ALT2, B
042F5E ED     0001M IN0	A, (reg)
042F5F 38 
042F60 9D 
042F61 B0     0002M OR	val
042F62 ED     0003M OUT0	(reg), A
042F63 39 
042F64 9D 
042F65 C9      7828 RET
               7829 
               7830 ; Interrupt, Active Low
               7831 ;
               7832 GPIOB_M6:		RES_GPIO PB_DR,   B
042F66 C5     0001M PUSH	BC
042F67 78     0002M LD	A, val
042F68 2F     0003M CPL
042F69 4F     0004M LD	C, A
042F6A ED     0005M IN0	A, (reg)
042F6B 38 
042F6C 9A 
042F6D A1     0006M AND	C
042F6E ED     0007M OUT0	(reg), A
042F6F 39 
042F70 9A 
042F71 C1     0008M POP	BC
               7833 RES_GPIO PB_DDR,  B
042F72 C5     0001M PUSH	BC
042F73 78     0002M LD	A, val
042F74 2F     0003M CPL
042F75 4F     0004M LD	C, A
042F76 ED     0005M IN0	A, (reg)
042F77 38 
042F78 9B 
042F79 A1     0006M AND	C
042F7A ED     0007M OUT0	(reg), A
042F7B 39 
042F7C 9B 
042F7D C1     0008M POP	BC
               7834 SET_GPIO PB_ALT1, B
042F7E ED     0001M IN0	A, (reg)
042F7F 38 
042F80 9C 
042F81 B0     0002M OR	val
042F82 ED     0003M OUT0	(reg), A
042F83 39 
042F84 9C 
               7835 SET_GPIO PB_ALT2, B
042F85 ED     0001M IN0	A, (reg)
042F86 38 
042F87 9D 
042F88 B0     0002M OR	val
042F89 ED     0003M OUT0	(reg), A
042F8A 39 
042F8B 9D 
042F8C C9      7836 RET
               7837 
               7838 
               7839 ; Interrupt, Active High
               7840 ;
               7841 GPIOB_M7:		SET_GPIO PB_DR,   B
042F8D ED     0001M IN0	A, (reg)
042F8E 38 
042F8F 9A 
042F90 B0     0002M OR	val
042F91 ED     0003M OUT0	(reg), A
042F92 39 
042F93 9A 
               7842 RES_GPIO PB_DDR,  B
042F94 C5     0001M PUSH	BC
042F95 78     0002M LD	A, val
042F96 2F     0003M CPL
042F97 4F     0004M LD	C, A
042F98 ED     0005M IN0	A, (reg)
042F99 38 
042F9A 9B 
042F9B A1     0006M AND	C
042F9C ED     0007M OUT0	(reg), A
042F9D 39 
042F9E 9B 
042F9F C1     0008M POP	BC
               7843 SET_GPIO PB_ALT1, B
042FA0 ED     0001M IN0	A, (reg)
042FA1 38 
042FA2 9C 
042FA3 B0     0002M OR	val
042FA4 ED     0003M OUT0	(reg), A
042FA5 39 
042FA6 9C 
               7844 SET_GPIO PB_ALT2, B
042FA7 ED     0001M IN0	A, (reg)
042FA8 38 
042FA9 9D 
042FAA B0     0002M OR	val
042FAB ED     0003M OUT0	(reg), A
042FAC 39 
042FAD 9D 
042FAE C9      7845 RET
               7846 
               7847 
               7848 ; Interrupt, Falling Edge
               7849 ;
               7850 GPIOB_M8:		RES_GPIO PB_DR,   B
042FAF C5     0001M PUSH	BC
042FB0 78     0002M LD	A, val
042FB1 2F     0003M CPL
042FB2 4F     0004M LD	C, A
042FB3 ED     0005M IN0	A, (reg)
042FB4 38 
042FB5 9A 
042FB6 A1     0006M AND	C
042FB7 ED     0007M OUT0	(reg), A
042FB8 39 
042FB9 9A 
042FBA C1     0008M POP	BC
               7851 SET_GPIO PB_DDR,  B
042FBB ED     0001M IN0	A, (reg)
042FBC 38 
042FBD 9B 
042FBE B0     0002M OR	val
042FBF ED     0003M OUT0	(reg), A
042FC0 39 
042FC1 9B 
               7852 SET_GPIO PB_ALT1, B
042FC2 ED     0001M IN0	A, (reg)
042FC3 38 
042FC4 9C 
042FC5 B0     0002M OR	val
042FC6 ED     0003M OUT0	(reg), A
042FC7 39 
042FC8 9C 
               7853 SET_GPIO PB_ALT2, B
042FC9 ED     0001M IN0	A, (reg)
042FCA 38 
042FCB 9D 
042FCC B0     0002M OR	val
042FCD ED     0003M OUT0	(reg), A
042FCE 39 
042FCF 9D 
042FD0 C9      7854 RET
               7855 
               7856 ; Interrupt, Rising Edge
               7857 ;
               7858 GPIOB_M9:		SET_GPIO PB_DR,   B
042FD1 ED     0001M IN0	A, (reg)
042FD2 38 
042FD3 9A 
042FD4 B0     0002M OR	val
042FD5 ED     0003M OUT0	(reg), A
042FD6 39 
042FD7 9A 
               7859 SET_GPIO PB_DDR,  B
042FD8 ED     0001M IN0	A, (reg)
042FD9 38 
042FDA 9B 
042FDB B0     0002M OR	val
042FDC ED     0003M OUT0	(reg), A
042FDD 39 
042FDE 9B 
               7860 SET_GPIO PB_ALT1, B
042FDF ED     0001M IN0	A, (reg)
042FE0 38 
042FE1 9C 
042FE2 B0     0002M OR	val
042FE3 ED     0003M OUT0	(reg), A
042FE4 39 
042FE5 9C 
               7861 SET_GPIO PB_ALT2, B
042FE6 ED     0001M IN0	A, (reg)
042FE7 38 
042FE8 9D 
042FE9 B0     0002M OR	val
042FEA ED     0003M OUT0	(reg), A
042FEB 39 
042FEC 9D 
042FED C9      7862 RET	; --- End gpio.asm ---
               7863 
               7864 ; --- Begin main.asm ---
               7865 ;
               7866 ; Title:	BBC Basic Interpreter - Z80 version
               7867 ;		Command, Error and Lexical Analysis Module - "MAIN"
               7868 ; Author:	(C) Copyright  R.T.Russell  1984
               7869 ; Modified By:	Dean Belfield
               7870 ; Created:	12/05/2023
               7871 ; Last Updated:	26/11/2023
               7872 ;
               7873 ; Modinfo:
               7874 ; 07/05/1984:	Version 2.3
               7875 ; 01/03/1987:	Version 3.0
               7876 ; 03/05/2022:	Modified by Dean Belfield
               7877 ; 06/06/2023:	Modified to run in ADL mode
               7878 ; 26/06/2023:	Fixed binary and unary indirection
               7879 ; 17/08/2023:	Added binary constants
               7880 ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
               7881 ; 26/11/2023:	Fixed bug in AUTOLOAD
               7882 
               7883 ; .ASSUME	ADL = 1
               7884 
               7885 ; INCLUDE	"equs.inc"
               7886 
               7887 ; SEGMENT CODE
               7888 
               7889 ; XDEF	_main
               7890 
               7891 ; XDEF	COLD
               7892 ; XDEF	WARM
               7893 ; XDEF	CLOOP
               7894 ; XDEF	DELETE
               7895 ; XDEF	LIST_
               7896 ; XDEF	RENUM
               7897 ; XDEF	AUTO
               7898 ; XDEF	NEW
               7899 ; XDEF	OLD
               7900 ; XDEF	LOAD
               7901 ; XDEF	SAVE
               7902 ; XDEF	ERROR_
               7903 ; XDEF	EXTERR
               7904 ; XDEF	LOAD0
               7905 ; XDEF	CLEAR
               7906 ; XDEF	CRLF
               7907 ; XDEF	OUTCHR
               7908 ; XDEF	OUT_
               7909 ; XDEF	FINDL
               7910 ; XDEF	SETLIN
               7911 ; XDEF	PBCDL
               7912 ; XDEF	SAYLN
               7913 ; XDEF	PUTVAR
               7914 ; XDEF	GETVAR
               7915 ; XDEF	GETDEF
               7916 ; XDEF	CREATE
               7917 ; XDEF	RANGE
               7918 ; XDEF	LEXAN2
               7919 ; XDEF	REPORT
               7920 ; XDEF	TELL
               7921 ; XDEF	SPACE_
               7922 ; XDEF	KEYWDS
               7923 ; XDEF	KEYWDL
               7924 ; XDEF	ONEDIT
               7925 ; XDEF	ONEDIT1
               7926 ; XDEF	LISTIT
               7927 ; XDEF	CLEAN
               7928 
               7929 ; XREF	LISTON
               7930 ; XREF	ERRTXT
               7931 ; XREF	OSINIT
               7932 ; XREF	HIMEM
               7933 ; XREF	PAGE_
               7934 ; XREF	CHAIN0
               7935 ; XREF	PROMPT
               7936 ; XREF	ERRTRP
               7937 ; XREF	ERRLIN
               7938 ; XREF	AUTONO
               7939 ; XREF	LINENO
               7940 ; XREF	INCREM
               7941 ; XREF	OSLINE
               7942 ; XREF	COUNT
               7943 ; XREF	NXT
               7944 ; XREF	BUFFER
               7945 ; XREF	XEQ
               7946 ; XREF	TOP
               7947 ; XREF	EXPRI
               7948 ; XREF	SEARCH
               7949 ; XREF	LTRAP
               7950 ; XREF	LOMEM
               7951 ; XREF	DECODE
               7952 ; XREF	EXPRS
               7953 ; XREF	OSSAVE
               7954 ; XREF	ERR
               7955 ; XREF	ERL
               7956 ; XREF	TRACEN
               7957 ; XREF	RESET
               7958 ; XREF	OSSHUT
               7959 ; XREF	OSLOAD
               7960 ; XREF	FREE
               7961 ; XREF	DYNVAR
               7962 ; XREF	FILL
               7963 ; XREF	OSWRCH
               7964 ; XREF	WIDTH
               7965 ; XREF	COMMA
               7966 ; XREF	MUL16
               7967 ; XREF	BRAKET
               7968 ; XREF	X4OR5
               7969 ; XREF	LOADN
               7970 ; XREF	SFIX
               7971 ; XREF	ITEMI
               7972 ; XREF	FNPTR
               7973 ; XREF	PROPTR
               7974 ; XREF	CHECK
               7975 ; XREF	TERMQ
               7976 ; XREF	OSWRCHCH
               7977 ; XREF	NEWIT
               7978 ; XREF	BAD
               7979 ; XREF	RAM_START
               7980 ; XREF	RAM_END
               7981 ; XREF	R0
               7982 ; XREF	STAR_VERSION
               7983 
               7984 ; XREF	_end			; In init.asm
               7985 ;
               7986 ; A handful of common token IDs
               7987 ;
               7988 TERROR_MN:			EQU     85H
               7989 LINE_MN_:			EQU     86H
               7990 ELSE_MN_:			EQU     8BH
               7991 THEN_MN_:			EQU     8CH
               7992 LINO_MN:			EQU     8DH
               7993 FN:			EQU     A4H
               7994 TO_MN:			EQU     B8H
               7995 REN:			EQU     CCH
               7996 DATA_MN_:			EQU     DCH
               7997 DIM:			EQU     DEH
               7998 FOR:			EQU     E3H
               7999 GOSUB:			EQU     E4H
               8000 GOTO:			EQU     E5H
               8001 TIF:			EQU     E7H
               8002 LOCAL_:			EQU     EAH
               8003 NEXT:			EQU     EDH
               8004 ON_:			EQU     EEH
               8005 PROC:			EQU     F2H
               8006 REM:			EQU     F4H
               8007 REPEAT:			EQU     F5H
               8008 RESTOR:			EQU     F7H
               8009 TRACE:			EQU     FCH
               8010 UNTIL:			EQU     FDH
               8011 ;
               8012 ; This defines the block of tokens that are pseudo-variables.
               8013 ; There are two versions of each token, a GET and a SET
               8014 
               8015 ; Name  : GET : SET
               8016 ; ------:-----:----
               8017 ; PTR   : 8Fh : CFh
               8018 ; PAGE  : 90h : D0h
               8019 ; TIME  : 91h : D1h
               8020 ; LOMEM : 92h : D2h
               8021 ; HIMEM : 93h : D3h
               8022 ;
               8023 ; Examples:
               8024 ;   LET A% = PAGE : REM This is the GET version
               8025 ;   PAGE = 40000  : REM This is the SET version
               8026 ;
               8027 TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
               8028 TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
               8029 OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
               8030 
               8031 ; The main routine
               8032 ; IXU: argv - pointer to array of parameters
               8033 ;   C: argc - number of parameters
               8034 ; Returns:
               8035 ;  HL: Error code, or 0 if OK
               8036 ;
042FEE 21      8037 _main:			LD	HL, ACCS		; Clear the ACCS
042FEF 00 
042FF0 4A 
042FF1 04 
042FF2 36      8038 LD	(HL), 0
042FF3 00 
042FF4 79      8039 LD	A, C
042FF5 FE      8040 CP	2
042FF6 02 
042FF7 28      8041 JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF8 2D 
042FF9 38      8042 JR	C, COLD			; 1 parameter = normal start
042FFA 3F 
042FFB CD      8043 CALL	STAR_VERSION
042FFC 81 
042FFD 40 
042FFE 04 
042FFF CD      8044 CALL	TELL
043000 C8 
043001 3D 
043002 04 
043003 55      8045 DB	"Usage:\n\r"
043004 73 
043005 61 
043006 67 
043006 65   
043007 3A 
043008 0A 
043009 0D 
04300B 52      8046 DB	"RUN . <filename>\n\r", 0
04300C 55 
04300D 4E 
04300E 20 
04300E 2E   
04300F 20 
043010 3C 
043011 66 
043011 69   
043012 6C 
043013 65 
043014 6E 
043014 61   
043015 6D 
043016 65 
043017 3E 
043017 0A   
043018 0D 
043019 00 
04301E 21      8047 LD	HL, 0			; The error code
04301F 00 
043020 00 
043021 00 
043022 C3      8048 JP	_end
043023 68 
043024 00 
043025 04 
               8049 ;
043026 DD      8050 AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043027 27 
043028 03 
043029 11      8051 LD	DE, ACCS		;  DE: Destination address
04302A 00 
04302B 4A 
04302C 04 
04302D 7E      8052 AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
04302E 12      8053 LD	(DE), A			;
04302F 23      8054 INC	HL			; Increase the source pointer
043030 1C      8055 INC	E			; We only need to increase E as ACCS is on a page boundary
043031 28      8056 JR	Z, AUTOLOAD_2		; End if we hit the page boundary
043032 03 
043033 B7      8057 OR	A
043034 20      8058 JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043035 F7 
043036 1D      8059 AUTOLOAD_2:		DEC	E
043037 3E      8060 LD	A, CR
043038 0D 
043039 12      8061 LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
               8062 ;
04303A E1      8063 COLD:			POP	HL			; Pop the return address to init off SPS
04303B E5      8064 PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04303C 21      8065 LD	HL, STAVAR		; Cold start
04303D 00 
04303E 4C 
04303F 04 
043040 F9      8066 LD	SP, HL
043041 36      8067 LD	(HL), 10
043042 0A 
043043 23      8068 INC	HL
043044 36      8069 LD	(HL),9
043045 09 
043046 CD      8070 CALL    OSINIT			; Call the machine specific OS initialisation routines
043047 B9 
043048 3F 
043049 04 
04304A ED      8071 LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
04304B 53 
04304C 20 
04304D 4D 
04304D 04   
04304F 22      8072 LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043050 14 
043051 4D 
043052 04 
043053 3E      8073 LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043054 B7 
043055 32      8074 LD      (LISTON),A
043056 40 
043057 4D 
043058 04 
043059 21      8075 LD      HL,NOTICE
04305A 94 
04305B 30 
04305C 04 
04305D 22      8076 LD      (ERRTXT),HL
04305E 2F 
04305F 4D 
043060 04 
043061 CD      8077 CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043062 A4 
043063 38 
043064 04 
043065 3A      8078 LD	A,(ACCS)		; Check if there is a filename in ACCS
043066 00 
043067 4A 
043068 04 
043069 B7      8079 OR	A
04306A C2      8080 JP	NZ,CHAIN0		; Yes, so load and run
04306B 5B 
04306C 0B 
04306D 04 
04306E CD      8081 CALL	STAR_VERSION		;
04306F 81 
043070 40 
043071 04 
043072 CD      8082 CALL    TELL			; Output the welcome message
043073 C8 
043074 3D 
043075 04 
043076 42      8083 DB    	"BBC BASIC (Z80) Version 3.00\n\r"
043077 42 
043078 43 
043079 20 
043079 42   
04307A 41 
04307B 53 
04307C 49 
04307C 43   
04307D 20 
04307E 28 
04307F 5A 
04307F 38   
043080 30 
043081 29 
043082 20 
043082 56   
043083 65 
043084 72 
043085 73 
043085 69   
043086 6F 
043087 6E 
043088 20 
043088 33   
043089 2E 
04308A 30 
04308B 30 
04308B 0A   
04308C 0D 
043094 28      8084 NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
043095 43 
043096 29 
043097 20 
043097 43   
043098 6F 
043099 70 
04309A 79 
04309A 72   
04309B 69 
04309C 67 
04309D 68 
04309D 74   
04309E 20 
04309F 52 
0430A0 2E 
0430A0 54   
0430A1 2E 
0430A2 52 
0430A3 75 
0430A3 73   
0430A4 73 
0430A5 65 
0430A6 6C 
0430A6 6C   
0430A7 20 
0430A8 31 
0430A9 39 
0430A9 38   
0430AA 37 
0430AB 0A 
0430AC 0D 
0430B4 0A      8085 DB	"\n\r", 0
0430B5 0D 
0430B6 00 
               8086 ;
0430B7 F6      8087 WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
               8088 ;
               8089 ; This is the main entry point for BASIC
               8090 ;
0430B8 37      8091 CLOOP:			SCF				; See above - not sure why this is here!
0430B9 ED      8092 LD      SP,(HIMEM)
0430BA 7B 
0430BB 20 
0430BC 4D 
0430BC 04   
0430BE CD      8093 CALL    PROMPT          	; Prompt user
0430BF 32 
0430C0 3F 
0430C1 04 
0430C2 21      8094 LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430C3 40 
0430C4 4D 
0430C5 04 
0430C6 7E      8095 LD      A,(HL)			; Fetch the value
0430C7 E6      8096 AND     0FH             	; Bottom nibble: LISTO
0430C8 0F 
0430C9 F6      8097 OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430CA B0 
0430CB 77      8098 LD      (HL),A			; Store back in
0430CC ED      8099 SBC     HL,HL           	; HL: 0
0430CD 62 
0430CE 22      8100 LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430CF 2C 
0430D0 4D 
0430D1 04 
0430D2 22      8101 LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430D3 35 
0430D4 4D 
0430D5 04 
               8102 ;
0430D6 2A      8103 LD      HL,(AUTONO)		; Get the auto line number
0430D7 29 
0430D8 4D 
0430D9 04 
0430DA 22      8104 LD      (LINENO),HL		; Store in line number
0430DB 23 
0430DC 4D 
0430DD 04 
0430DE 7C      8105 LD      A,H			; If the auto line number is zero then
0430DF B5      8106 OR      L
0430E0 28      8107 JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430E1 1E 
               8108 ;
               8109 ; This section handles auto line numbering
               8110 ;
0430E2 E5      8111 PUSH    HL			; Stack the line number
0430E3 CD      8112 CALL    PBCD           	 	; Output the line number
0430E4 33 
0430E5 3A 
0430E6 04 
0430E7 E1      8113 POP     HL			; Pop the line number back off the stack
               8114 ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
               8115 ;			LD      B,0			; So clear B
0430E8 01      8116 LD	BC, 0			; Load BC with Increment
0430E9 00 
0430EA 00 
0430EB 00 
0430EC 3A      8117 LD	A,(INCREM)
0430ED 41 
0430EE 4D 
0430EF 04 
0430F0 4F      8118 LD	C, A
0430F1 09      8119 ADD     HL,BC			; Add the increment to the line number
0430F2 DA      8120 JP      C,TOOBIG		; And error if we wrap
0430F3 5D 
0430F4 3C 
0430F5 04 
0430F6 22      8121 LD      (AUTONO),HL		; Store the new auto line number
0430F7 29 
0430F8 4D 
0430F9 04 
0430FA 3E      8122 LD      A,' '			; Print a space
0430FB 20 
0430FC CD      8123 CALL    OUTCHR
0430FD 87 
0430FE 39 
0430FF 04 
               8124 ;
               8125 ; This section invokes the line editor
               8126 ;
043100 21      8127 NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
043101 00 
043102 4A 
043103 04 
043104 CD      8128 CALL    OSLINE          	; Call the line editor in MOS
043105 97 
043106 3E 
043107 04 
043108 CD      8129 ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
043109 14 
04310A 31 
04310B 04 
04310C DC      8130 CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
04310D 77 
04310E 38 
04310F 04 
043110 C3      8131 JP      CLOOP			; Jump back to immediate mode
043111 B8 
043112 30 
043113 04 
               8132 ;
               8133 ; This bit enters the line into memory
               8134 ; Also called from OSLOAD_TXT
               8135 ; Returns:
               8136 ; F: C if a new line has been entered (CLEAN will need to be called)
               8137 ;
043114 AF      8138 ONEDIT1:		XOR     A			; Entry point after *EDIT
043115 32      8139 LD      (COUNT),A
043116 3D 
043117 4D 
043118 04 
043119 FD      8140 LD      IY,ACCS
04311A 21 
04311B 00 
04311C 4A 
04311C 04   
04311E CD      8141 CALL    LINNUM			; HL: The line number from the input buffer
04311F 31 
043120 3C 
043121 04 
043122 CD      8142 CALL    NXT			; Skip spaces
043123 78 
043124 0A 
043125 04 
043126 7C      8143 LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043127 B5      8144 OR      L
043128 28      8145 JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043129 04 
04312A 22      8146 LD      (LINENO),HL		; Otherwise store it
04312B 23 
04312C 4D 
04312D 04 
               8147 ;
               8148 ; This bit does the lexical analysis and tokenisation
               8149 ;
04312E 0E      8150 LNZERO:			LD	C,1			; Left mode
04312F 01 
043130 11      8151 LD      DE,BUFFER		; Buffer for tokenised BASIC
043131 00 
043132 4B 
043133 04 
043134 CD      8152 CALL    LEXAN2          	; Lexical analysis on the user input
043135 D7 
043136 3C 
043137 04 
043138 12      8153 LD      (DE),A          	; Terminator
043139 AF      8154 XOR     A
               8155 ;			LD      B,A
               8156 ;			LD      C,E             	; BC: Line length
04313A 01      8157 LD	BC,0
04313B 00 
04313C 00 
04313D 00 
04313E 4B      8158 LD	C,E			; BC: Line length
04313F 13      8159 INC     DE
043140 12      8160 LD      (DE),A          	; Zero next
043141 2A      8161 LD      HL,(LINENO)		; Get the line number
043142 23 
043143 4D 
043144 04 
043145 7C      8162 LD      A,H			; Is it zero, i.e. a command with no line number?
043146 B5      8163 OR      L
043147 FD      8164 LD      IY,BUFFER       	; Yes, so we're in immediate mode
043148 21 
043149 00 
04314A 4B 
04314A 04   
04314C CA      8165 JP      Z,XEQ           	; Execute it
04314D 9E 
04314E 0B 
04314F 04 
               8166 ;
               8167 ; This section stores the BASIC line in memory
               8168 ;
043150 C5      8169 PUSH    BC
043151 E5      8170 PUSH    HL
043152 CD      8171 CALL    SETTOP          	; Set TOP sysvar
043153 83 
043154 38 
043155 04 
043156 E1      8172 POP     HL
043157 CD      8173 CALL    FINDL			; Find the address of the line
043158 C7 
043159 39 
04315A 04 
04315B CC      8174 CALL    Z,DEL			; Delete the existing line if found
04315C 3A 
04315D 38 
04315E 04 
04315F C1      8175 POP     BC
043160 79      8176 LD      A,C			; Check for the line length being zero, i.e.
043161 B7      8177 OR      A			; the user has just entered a line number in the command line
043162 C8      8178 RET	Z 	         	; If so, then don't do anything else
043163 C6      8179 ADD     A,4
043164 04 
043165 4F      8180 LD      C,A             	; Length inclusive
043166 D5      8181 PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043167 C5      8182 PUSH    BC              	; BC: Line length
043168 EB      8183 EX      DE,HL			; DE: Address of the line in memory
043169 2A      8184 LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
04316A 17 
04316B 4D 
04316C 04 
04316D E5      8185 PUSH    HL			; Stack TOP (current TOP value)
04316E 09      8186 ADD     HL,BC			; Add the line length to HL, the new TOP value
04316F E5      8187 PUSH    HL			; Stack HL (new TOP value)
043170 24      8188 INC     H			; Add 256 to HL
043171 AF      8189 XOR     A
043172 ED      8190 SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
043173 72 
043174 E1      8191 POP     HL			; Pop HL (new TOP value)
043175 D2      8192 JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043176 98 
043177 37 
043178 04 
043179 22      8193 LD      (TOP),HL		; Store new value of TOP
04317A 17 
04317B 4D 
04317C 04 
04317D E3      8194 EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
04317E E5      8195 PUSH    HL			; PUSH current TOP value
04317F 23      8196 INC     HL
043180 B7      8197 OR      A
043181 ED      8198 SBC     HL,DE			; DE: Address of the line in memory
043182 52 
043183 44      8199 LD      B,H             	; BC: Amount to move
043184 4D      8200 LD      C,L
043185 E1      8201 POP     HL			; HL: Destination (current TOP value)
043186 D1      8202 POP     DE			; DE: Source (new TOP value)
043187 28      8203 JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043188 02 
043189 ED      8204 LDDR                    	; Otherwise, make space for the new line in the program
04318A B8 
04318B C1      8205 ATEND:			POP     BC              	; BC: Line length
04318C D1      8206 POP     DE              	; DE: Line number
04318D 23      8207 INC     HL			; HL: Destination address
04318E 71      8208 LD      (HL),C          	; Store length
04318F 23      8209 INC     HL
043190 73      8210 LD      (HL),E          	; Store line number
043191 23      8211 INC     HL
043192 72      8212 LD      (HL),D
043193 23      8213 INC     HL
043194 11      8214 LD      DE,BUFFER		; DE: Location of the new, tokenised line
043195 00 
043196 4B 
043197 04 
043198 EB      8215 EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043199 0D      8216 DEC     C			; Subtract 3 from the number of bytes to copy to
04319A 0D      8217 DEC     C			; compensate for the 3 bytes stored above (length and line number)
04319B 0D      8218 DEC     C
04319C ED      8219 LDIR                    	; Add the line to the BASIC program
04319D B0 
04319E 37      8220 SCF				; To flag we need to call CLEAN
04319F C9      8221 RET
               8222 ;
               8223 ; List of tokens and keywords. If a keyword is followed by 0 then
               8224 ; it will only match with the keyword followed immediately by
               8225 ; a delimiter
               8226 ;
0431A0 80      8227 KEYWDS:			DB    80H, "AND"
0431A1 41 
0431A2 4E 
0431A3 44 
0431A4 94      8228 DB    94H, "ABS"
0431A5 41 
0431A6 42 
0431A7 53 
0431A8 95      8229 DB    95H, "ACS"
0431A9 41 
0431AA 43 
0431AB 53 
0431AC 96      8230 DB    96H, "ADVAL"
0431AD 41 
0431AE 44 
0431AF 56 
0431AF 41   
0431B0 4C 
0431B2 97      8231 DB    97H, "ASC"
0431B3 41 
0431B4 53 
0431B5 43 
0431B6 98      8232 DB    98H, "ASN"
0431B7 41 
0431B8 53 
0431B9 4E 
0431BA 99      8233 DB    99H, "ATN"
0431BB 41 
0431BC 54 
0431BD 4E 
0431BE C6      8234 DB    C6H, "AUTO"
0431BF 41 
0431C0 55 
0431C1 54 
0431C1 4F   
0431C3 9A      8235 DB    9AH, "BGET", 0
0431C4 42 
0431C5 47 
0431C6 45 
0431C6 54   
0431C7 00 
0431C9 D5      8236 DB    D5H, "BPUT", 0
0431CA 42 
0431CB 50 
0431CC 55 
0431CC 54   
0431CD 00 
0431CF FB      8237 DB    FBH, "COLOUR"
0431D0 43 
0431D1 4F 
0431D2 4C 
0431D2 4F   
0431D3 55 
0431D4 52 
0431D6 FB      8238 DB    FBH, "COLOR"
0431D7 43 
0431D8 4F 
0431D9 4C 
0431D9 4F   
0431DA 52 
0431DC D6      8239 DB    D6H, "CALL"
0431DD 43 
0431DE 41 
0431DF 4C 
0431DF 4C   
0431E1 D7      8240 DB    D7H, "CHAIN"
0431E2 43 
0431E3 48 
0431E4 41 
0431E4 49   
0431E5 4E 
0431E7 BD      8241 DB    BDH, "CHR$"
0431E8 43 
0431E9 48 
0431EA 52 
0431EA 24   
0431EC D8      8242 DB    D8H, "CLEAR", 0
0431ED 43 
0431EE 4C 
0431EF 45 
0431EF 41   
0431F0 52 
0431F1 00 
0431F3 D9      8243 DB    D9H, "CLOSE", 0
0431F4 43 
0431F5 4C 
0431F6 4F 
0431F6 53   
0431F7 45 
0431F8 00 
0431FA DA      8244 DB    DAH, "CLG", 0
0431FB 43 
0431FC 4C 
0431FD 47 
0431FD 00   
0431FF DB      8245 DB    DBH, "CLS", 0
043200 43 
043201 4C 
043202 53 
043202 00   
043204 9B      8246 DB    9BH, "COS"
043205 43 
043206 4F 
043207 53 
043208 9C      8247 DB    9CH, "COUNT", 0
043209 43 
04320A 4F 
04320B 55 
04320B 4E   
04320C 54 
04320D 00 
04320F DC      8248 DB    DCH, "DATA"
043210 44 
043211 41 
043212 54 
043212 41   
043214 9D      8249 DB    9DH, "DEG"
043215 44 
043216 45 
043217 47 
043218 DD      8250 DB    DDH, "DEF"
043219 44 
04321A 45 
04321B 46 
04321C C7      8251 DB    C7H, "DELETE"
04321D 44 
04321E 45 
04321F 4C 
04321F 45   
043220 54 
043221 45 
043223 81      8252 DB    81H, "DIV"
043224 44 
043225 49 
043226 56 
043227 DE      8253 DB    DEH, "DIM"
043228 44 
043229 49 
04322A 4D 
04322B DF      8254 DB    DFH, "DRAW"
04322C 44 
04322D 52 
04322E 41 
04322E 57   
043230 E1      8255 DB    E1H, "ENDPROC", 0
043231 45 
043232 4E 
043233 44 
043233 50   
043234 52 
043235 4F 
043236 43 
043236 00   
043239 E0      8256 DB    E0H, "END", 0
04323A 45 
04323B 4E 
04323C 44 
04323C 00   
04323E E2      8257 DB    E2H, "ENVELOPE"
04323F 45 
043240 4E 
043241 56 
043241 45   
043242 4C 
043243 4F 
043244 50 
043244 45   
043247 8B      8258 DB    8BH, "ELSE"
043248 45 
043249 4C 
04324A 53 
04324A 45   
04324C A0      8259 DB    A0H, "EVAL"
04324D 45 
04324E 56 
04324F 41 
04324F 4C   
043251 9E      8260 DB    9EH, "ERL", 0
043252 45 
043253 52 
043254 4C 
043254 00   
043256 85      8261 DB    85H, "ERROR"
043257 45 
043258 52 
043259 52 
043259 4F   
04325A 52 
04325C C5      8262 DB    C5H, "EOF", 0
04325D 45 
04325E 4F 
04325F 46 
04325F 00   
043261 82      8263 DB    82H, "EOR"
043262 45 
043263 4F 
043264 52 
043265 9F      8264 DB    9FH, "ERR", 0
043266 45 
043267 52 
043268 52 
043268 00   
04326A A1      8265 DB    A1H, "EXP"
04326B 45 
04326C 58 
04326D 50 
04326E A2      8266 DB    A2H, "EXT", 0
04326F 45 
043270 58 
043271 54 
043271 00   
043273 E3      8267 DB    E3H, "FOR"
043274 46 
043275 4F 
043276 52 
043277 A3      8268 DB    A3H, "FALSE", 0
043278 46 
043279 41 
04327A 4C 
04327A 53   
04327B 45 
04327C 00 
04327E A4      8269 DB    A4H, "FN"
04327F 46 
043280 4E 
043281 E5      8270 DB    E5H, "GOTO"
043282 47 
043283 4F 
043284 54 
043284 4F   
043286 BE      8271 DB    BEH, "GET$"
043287 47 
043288 45 
043289 54 
043289 24   
04328B A5      8272 DB    A5H, "GET"
04328C 47 
04328D 45 
04328E 54 
04328F E4      8273 DB    E4H, "GOSUB"
043290 47 
043291 4F 
043292 53 
043292 55   
043293 42 
043295 E6      8274 DB    E6H, "GCOL"
043296 47 
043297 43 
043298 4F 
043298 4C   
04329A 93      8275 DB    93H, "HIMEM", 0
04329B 48 
04329C 49 
04329D 4D 
04329D 45   
04329E 4D 
04329F 00 
0432A1 E8      8276 DB    E8H, "INPUT"
0432A2 49 
0432A3 4E 
0432A4 50 
0432A4 55   
0432A5 54 
0432A7 E7      8277 DB    E7H, "IF"
0432A8 49 
0432A9 46 
0432AA BF      8278 DB    BFH, "INKEY$"
0432AB 49 
0432AC 4E 
0432AD 4B 
0432AD 45   
0432AE 59 
0432AF 24 
0432B1 A6      8279 DB    A6H, "INKEY"
0432B2 49 
0432B3 4E 
0432B4 4B 
0432B4 45   
0432B5 59 
0432B7 A8      8280 DB    A8H, "INT"
0432B8 49 
0432B9 4E 
0432BA 54 
0432BB A7      8281 DB    A7H, "INSTR("
0432BC 49 
0432BD 4E 
0432BE 53 
0432BE 54   
0432BF 52 
0432C0 28 
0432C2 C9      8282 DB    C9H, "LIST"
0432C3 4C 
0432C4 49 
0432C5 53 
0432C5 54   
0432C7 86      8283 DB    86H, "LINE"
0432C8 4C 
0432C9 49 
0432CA 4E 
0432CA 45   
0432CC C8      8284 DB    C8H, "LOAD"
0432CD 4C 
0432CE 4F 
0432CF 41 
0432CF 44   
0432D1 92      8285 DB    92H, "LOMEM", 0
0432D2 4C 
0432D3 4F 
0432D4 4D 
0432D4 45   
0432D5 4D 
0432D6 00 
0432D8 EA      8286 DB    EAH, "LOCAL"
0432D9 4C 
0432DA 4F 
0432DB 43 
0432DB 41   
0432DC 4C 
0432DE C0      8287 DB    C0H, "LEFT$("
0432DF 4C 
0432E0 45 
0432E1 46 
0432E1 54   
0432E2 24 
0432E3 28 
0432E5 A9      8288 DB    A9H, "LEN"
0432E6 4C 
0432E7 45 
0432E8 4E 
0432E9 E9      8289 DB    E9H, "LET"
0432EA 4C 
0432EB 45 
0432EC 54 
0432ED AB      8290 DB    ABH, "LOG"
0432EE 4C 
0432EF 4F 
0432F0 47 
0432F1 AA      8291 DB    AAH, "LN"
0432F2 4C 
0432F3 4E 
0432F4 C1      8292 DB    C1H, "MID$("
0432F5 4D 
0432F6 49 
0432F7 44 
0432F7 24   
0432F8 28 
0432FA EB      8293 DB    EBH, "MODE"
0432FB 4D 
0432FC 4F 
0432FD 44 
0432FD 45   
0432FF 83      8294 DB    83H, "MOD"
043300 4D 
043301 4F 
043302 44 
043303 EC      8295 DB    ECH, "MOVE"
043304 4D 
043305 4F 
043306 56 
043306 45   
043308 ED      8296 DB    EDH, "NEXT"
043309 4E 
04330A 45 
04330B 58 
04330B 54   
04330D CA      8297 DB    CAH, "NEW", 0
04330E 4E 
04330F 45 
043310 57 
043310 00   
043312 AC      8298 DB    ACH, "NOT"
043313 4E 
043314 4F 
043315 54 
043316 CB      8299 DB    CBH, "OLD", 0
043317 4F 
043318 4C 
043319 44 
043319 00   
04331B EE      8300 DB    EEH, "ON"
04331C 4F 
04331D 4E 
04331E 87      8301 DB    87H, "OFF"
04331F 4F 
043320 46 
043321 46 
043322 84      8302 DB    84H, "OR"
043323 4F 
043324 52 
043325 8E      8303 DB    8EH, "OPENIN"
043326 4F 
043327 50 
043328 45 
043328 4E   
043329 49 
04332A 4E 
04332C AE      8304 DB    AEH, "OPENOUT"
04332D 4F 
04332E 50 
04332F 45 
04332F 4E   
043330 4F 
043331 55 
043332 54 
043334 AD      8305 DB    ADH, "OPENUP"
043335 4F 
043336 50 
043337 45 
043337 4E   
043338 55 
043339 50 
04333B FF      8306 DB    FFH, "OSCLI"
04333C 4F 
04333D 53 
04333E 43 
04333E 4C   
04333F 49 
043341 F1      8307 DB    F1H, "PRINT"
043342 50 
043343 52 
043344 49 
043344 4E   
043345 54 
043347 90      8308 DB    90H, "PAGE", 0
043348 50 
043349 41 
04334A 47 
04334A 45   
04334B 00 
04334D 8F      8309 DB    8FH, "PTR", 0
04334E 50 
04334F 54 
043350 52 
043350 00   
043352 AF      8310 DB    AFH, "PI", 0
043353 50 
043354 49 
043355 00 
043356 F0      8311 DB    F0H, "PLOT"
043357 50 
043358 4C 
043359 4F 
043359 54   
04335B B0      8312 DB    B0H, "POINT("
04335C 50 
04335D 4F 
04335E 49 
04335E 4E   
04335F 54 
043360 28 
043362 F2      8313 DB    F2H, "PROC"
043363 50 
043364 52 
043365 4F 
043365 43   
043367 B1      8314 DB    B1H, "POS", 0
043368 50 
043369 4F 
04336A 53 
04336A 00   
04336C CE      8315 DB    CEH, "PUT"
04336D 50 
04336E 55 
04336F 54 
043370 F8      8316 DB    F8H, "RETURN", 0
043371 52 
043372 45 
043373 54 
043373 55   
043374 52 
043375 4E 
043376 00 
043378 F5      8317 DB    F5H, "REPEAT"
043379 52 
04337A 45 
04337B 50 
04337B 45   
04337C 41 
04337D 54 
04337F F6      8318 DB    F6H, "REPORT", 0
043380 52 
043381 45 
043382 50 
043382 4F   
043383 52 
043384 54 
043385 00 
043387 F3      8319 DB    F3H, "READ"
043388 52 
043389 45 
04338A 41 
04338A 44   
04338C F4      8320 DB    F4H, "REM"
04338D 52 
04338E 45 
04338F 4D 
043390 F9      8321 DB    F9H, "RUN", 0
043391 52 
043392 55 
043393 4E 
043393 00   
043395 B2      8322 DB    B2H, "RAD"
043396 52 
043397 41 
043398 44 
043399 F7      8323 DB    F7H, "RESTORE"
04339A 52 
04339B 45 
04339C 53 
04339C 54   
04339D 4F 
04339E 52 
04339F 45 
0433A1 C2      8324 DB    C2H, "RIGHT$("
0433A2 52 
0433A3 49 
0433A4 47 
0433A4 48   
0433A5 54 
0433A6 24 
0433A7 28 
0433A9 B3      8325 DB    B3H, "RND", 0
0433AA 52 
0433AB 4E 
0433AC 44 
0433AC 00   
0433AE CC      8326 DB    CCH, "RENUMBER"
0433AF 52 
0433B0 45 
0433B1 4E 
0433B1 55   
0433B2 4D 
0433B3 42 
0433B4 45 
0433B4 52   
0433B7 88      8327 DB    88H, "STEP"
0433B8 53 
0433B9 54 
0433BA 45 
0433BA 50   
0433BC CD      8328 DB    CDH, "SAVE"
0433BD 53 
0433BE 41 
0433BF 56 
0433BF 45   
0433C1 B4      8329 DB    B4H, "SGN"
0433C2 53 
0433C3 47 
0433C4 4E 
0433C5 B5      8330 DB    B5H, "SIN"
0433C6 53 
0433C7 49 
0433C8 4E 
0433C9 B6      8331 DB    B6H, "SQR"
0433CA 53 
0433CB 51 
0433CC 52 
0433CD 89      8332 DB    89H, "SPC"
0433CE 53 
0433CF 50 
0433D0 43 
0433D1 C3      8333 DB    C3H, "STR$"
0433D2 53 
0433D3 54 
0433D4 52 
0433D4 24   
0433D6 C4      8334 DB    C4H, "STRING$("
0433D7 53 
0433D8 54 
0433D9 52 
0433D9 49   
0433DA 4E 
0433DB 47 
0433DC 24 
0433DC 28   
0433DF D4      8335 DB    D4H, "SOUND"
0433E0 53 
0433E1 4F 
0433E2 55 
0433E2 4E   
0433E3 44 
0433E5 FA      8336 DB    FAH, "STOP", 0
0433E6 53 
0433E7 54 
0433E8 4F 
0433E8 50   
0433E9 00 
0433EB B7      8337 DB    B7H, "TAN"
0433EC 54 
0433ED 41 
0433EE 4E 
0433EF 8C      8338 DB    8CH, "THEN"
0433F0 54 
0433F1 48 
0433F2 45 
0433F2 4E   
0433F4 B8      8339 DB    B8H, "TO"
0433F5 54 
0433F6 4F 
0433F7 8A      8340 DB    8AH, "TAB("
0433F8 54 
0433F9 41 
0433FA 42 
0433FA 28   
0433FC FC      8341 DB    FCH, "TRACE"
0433FD 54 
0433FE 52 
0433FF 41 
0433FF 43   
043400 45 
043402 91      8342 DB    91H, "TIME", 0
043403 54 
043404 49 
043405 4D 
043405 45   
043406 00 
043408 B9      8343 DB    B9H, "TRUE", 0
043409 54 
04340A 52 
04340B 55 
04340B 45   
04340C 00 
04340E FD      8344 DB    FDH, "UNTIL"
04340F 55 
043410 4E 
043411 54 
043411 49   
043412 4C 
043414 BA      8345 DB    BAH, "USR"
043415 55 
043416 53 
043417 52 
043418 EF      8346 DB    EFH, "VDU"
043419 56 
04341A 44 
04341B 55 
04341C BB      8347 DB    BBH, "VAL"
04341D 56 
04341E 41 
04341F 4C 
043420 BC      8348 DB    BCH, "VPOS", 0
043421 56 
043422 50 
043423 4F 
043423 53   
043424 00 
043426 FE      8349 DB    FEH, "WIDTH"
043427 57 
043428 49 
043429 44 
043429 54   
04342A 48 
04342C D3      8350 DB    D3H, "HIMEM"
04342D 48 
04342E 49 
04342F 4D 
04342F 45   
043430 4D 
043432 D2      8351 DB    D2H, "LOMEM"
043433 4C 
043434 4F 
043435 4D 
043435 45   
043436 4D 
043438 D0      8352 DB    D0H, "PAGE"
043439 50 
04343A 41 
04343B 47 
04343B 45   
04343D CF      8353 DB    CFH, "PTR"
04343E 50 
04343F 54 
043440 52 
043441 D1      8354 DB    D1H, "TIME"
043442 54 
043443 49 
043444 4D 
043444 45   
               8355 ;
               8356 ; These are indexed from the ERRWDS table
               8357 ;
043446 01      8358 DB    01H, "Missing "
043447 4D 
043448 69 
043449 73 
043449 73   
04344A 69 
04344B 6E 
04344C 67 
04344C 20   
04344F 02      8359 DB    02H, "No such "
043450 4E 
043451 6F 
043452 20 
043452 73   
043453 75 
043454 63 
043455 68 
043455 20   
043458 03      8360 DB    03H, "Bad "
043459 42 
04345A 61 
04345B 64 
04345B 20   
04345D 04      8361 DB    04H, " range"
04345E 20 
04345F 72 
043460 61 
043460 6E   
043461 67 
043462 65 
043464 05      8362 DB    05H, "variable"
043465 76 
043466 61 
043467 72 
043467 69   
043468 61 
043469 62 
04346A 6C 
04346A 65   
04346D 06      8363 DB    06H, "Out of"
04346E 4F 
04346F 75 
043470 74 
043470 20   
043471 6F 
043472 66 
043474 07      8364 DB    07H, "No "
043475 4E 
043476 6F 
043477 20 
043478 08      8365 DB    08H, " space"
043479 20 
04347A 73 
04347B 70 
04347B 61   
04347C 63 
04347D 65 
               8366 
               8367 KEYWDL:			EQU     $-KEYWDS
04347F FF      8368 DW    -1
043480 FF 
               8369 ;
               8370 ; Error messages
               8371 ;
043481 07      8372 ERRWDS:			DB    7, "room", 0		;  0: No room
043482 72 
043483 6F 
043484 6F 
043484 6D   
043485 00 
043487 06      8373 DB    6, 4, 0			;  1: Out of range
043488 04 
043489 00 
04348A 00      8374 DB    0				;  2: *
04348B 00      8375 DB    0				;  3: *
04348C 4D      8376 DB    "Mistake", 0		;  4: Mistake
04348D 69 
04348E 73 
04348F 74 
04348F 61   
043490 6B 
043491 65 
043492 00 
043494 01      8377 DB    1, ",", 0			;  5: Missing ,
043495 2C 
043496 00 
043497 54      8378 DB    "Type mismatch", 0	;  6: Type mismatch
043498 79 
043499 70 
04349A 65 
04349A 20   
04349B 6D 
04349C 69 
04349D 73 
04349D 6D   
04349E 61 
04349F 74 
0434A0 63 
0434A0 68   
0434A1 00 
0434A5 07      8379 DB    7, FN, 0			;  7: No FN
0434A6 A4 
0434A7 00 
0434A8 00      8380 DB    0				;  8: *
0434A9 01      8381 DB    1, 34, 0			;  9: Missing "
0434AA 22 
0434AB 00 
0434AC 03      8382 DB    3, DIM, 0			; 10: Bad DIM
0434AD DE 
0434AE 00 
0434AF DE      8383 DB    DIM, 8, 0			; 11: DIM space
0434B0 08 
0434B1 00 
0434B2 4E      8384 DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
0434B3 6F 
0434B4 74 
0434B5 20 
0434B5 EA   
0434B6 00 
0434B8 07      8385 DB    7, PROC, 0		; 13: No PROC
0434B9 F2 
0434BA 00 
0434BB 41      8386 DB    "Array", 0		; 14: Array
0434BC 72 
0434BD 72 
0434BE 61 
0434BE 79   
0434BF 00 
0434C1 53      8387 DB    "Subscript", 0		; 15: Subscript
0434C2 75 
0434C3 62 
0434C4 73 
0434C4 63   
0434C5 72 
0434C6 69 
0434C7 70 
0434C7 74   
0434C8 00 
0434CB 53      8388 DB    "Syntax error", 0		; 16: Syntax error
0434CC 79 
0434CD 6E 
0434CE 74 
0434CE 61   
0434CF 78 
0434D0 20 
0434D1 65 
0434D1 72   
0434D2 72 
0434D3 6F 
0434D4 72 
0434D4 00   
0434D8 45      8389 DB    "Escape", 0		; 17: Escape
0434D9 73 
0434DA 63 
0434DB 61 
0434DB 70   
0434DC 65 
0434DD 00 
0434DF 44      8390 DB    "Division by zero", 0	; 18: Division by zero
0434E0 69 
0434E1 76 
0434E2 69 
0434E2 73   
0434E3 69 
0434E4 6F 
0434E5 6E 
0434E5 20   
0434E6 62 
0434E7 79 
0434E8 20 
0434E8 7A   
0434E9 65 
0434EA 72 
0434EB 6F 
0434EB 00   
0434F0 53      8391 DB    "String too long", 0	; 19: String too long
0434F1 74 
0434F2 72 
0434F3 69 
0434F3 6E   
0434F4 67 
0434F5 20 
0434F6 74 
0434F6 6F   
0434F7 6F 
0434F8 20 
0434F9 6C 
0434F9 6F   
0434FA 6E 
0434FB 67 
0434FC 00 
043500 54      8392 DB    "Too big", 0		; 20: Too big
043501 6F 
043502 6F 
043503 20 
043503 62   
043504 69 
043505 67 
043506 00 
043508 2D      8393 DB    "-ve root", 0		; 21: -ve root
043509 76 
04350A 65 
04350B 20 
04350B 72   
04350C 6F 
04350D 6F 
04350E 74 
04350E 00   
043511 4C      8394 DB    "Log", 4, 0		; 22: Log range
043512 6F 
043513 67 
043514 04 
043514 00   
043516 41      8395 DB    "Accuracy lost", 0	; 23: Accuracy lost
043517 63 
043518 63 
043519 75 
043519 72   
04351A 61 
04351B 63 
04351C 79 
04351C 20   
04351D 6C 
04351E 6F 
04351F 73 
04351F 74   
043520 00 
043524 45      8396 DB    "Exp", 4, 0		; 24: Exp range
043525 78 
043526 70 
043527 04 
043527 00   
043529 00      8397 DB    0				; 25: *
04352A 02      8398 DB    2, 5, 0			; 26: No such variable
04352B 05 
04352C 00 
04352D 01      8399 DB    1, ")", 0			; 27: Missing )
04352E 29 
04352F 00 
043530 03      8400 DB    3, "HEX", 0		; 28: Bad HEX
043531 48 
043532 45 
043533 58 
043533 00   
043535 02      8401 DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
043536 A4 
043537 2F 
043538 F2 
043538 00   
04353A 03      8402 DB    3, "call", 0		; 30: Bad call
04353B 63 
04353C 61 
04353D 6C 
04353D 6C   
04353E 00 
043540 41      8403 DB    "Arguments", 0		; 31: Arguments
043541 72 
043542 67 
043543 75 
043543 6D   
043544 65 
043545 6E 
043546 74 
043546 73   
043547 00 
04354A 07      8404 DB    7, FOR, 0			; 32: No FOR
04354B E3 
04354C 00 
04354D 43      8405 DB    "Can't match ", FOR, 0	; 33: Can't match FOR
04354E 61 
04354F 6E 
043550 27 
043550 74   
043551 20 
043552 6D 
043553 61 
043553 74   
043554 63 
043555 68 
043556 20 
043556 E3   
043557 00 
04355B E3      8406 DB    FOR, " ", 5, 0		; 34: FOR variable
04355C 20 
04355D 05 
04355E 00 
04355F 00      8407 DB    0				; 35: *
043560 07      8408 DB    7, TO_MN, 0			; 36: No TO
043561 B8 
043562 00 
043563 00      8409 DB    0				; 37: *
043564 07      8410 DB    7, GOSUB, 0		; 38: No GOSUB
043565 E4 
043566 00 
043567 EE      8411 DB    ON_, " syntax", 0		; 39: ON syntax
043568 20 
043569 73 
04356A 79 
04356A 6E   
04356B 74 
04356C 61 
04356D 78 
04356D 00   
043570 EE      8412 DB    ON_, 4, 0			; 40: ON range
043571 04 
043572 00 
043573 02      8413 DB    2, "line", 0		; 41: No such line
043574 6C 
043575 69 
043576 6E 
043576 65   
043577 00 
043579 06      8414 DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
04357A 20 
04357B DC 
04357C 00 
04357D 07      8415 DB    7, REPEAT, 0		; 43: No REPEAT
04357E F5 
04357F 00 
043580 00      8416 DB    0				; 44: *
043581 01      8417 DB    1, "#", 0			; 45: Missing #
043582 23 
043583 00 
               8418 ;
               8419 ; COMMANDS:
               8420 ;
               8421 ; DELETE line,line
               8422 ;
043584 CD      8423 DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
043585 83 
043586 38 
043587 04 
043588 CD      8424 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043589 8B 
04358A 3C 
04358B 04 
04358C 7E      8425 DELET1:			LD      A,(HL)			; Check whether it's the last line
04358D B7      8426 OR      A
04358E CA      8427 JP      Z,WARMNC		; Yes, so do nothing
04358F 15 
043590 36 
043591 04 
043592 23      8428 INC     HL			; Skip the line length byte
043593 11      8429 LD	DE, 0			; Clear DE
043594 00 
043595 00 
043596 00 
043597 5E      8430 LD      E,(HL)			; Fetch the line number in DE
043598 23      8431 INC     HL
043599 56      8432 LD      D,(HL)
04359A 7A      8433 LD      A,D			; If the line number is zero then
04359B B3      8434 OR      E
04359C 28      8435 JR      Z,CLOOP1        	; Do nothing
04359D 1D 
04359E 2B      8436 DEC     HL			; Decrement BASIC program pointer back to length
04359F 2B      8437 DEC     HL
0435A0 EB      8438 EX      DE,HL			; Check if we've gone past the terminating line
0435A1 37      8439 SCF
0435A2 ED      8440 SBC     HL,BC
0435A3 42 
0435A4 EB      8441 EX      DE,HL
0435A5 30      8442 JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0435A6 6E 
0435A7 C5      8443 PUSH    BC
0435A8 CD      8444 CALL    DEL			; Delete the line pointed to by HL
0435A9 3A 
0435AA 38 
0435AB 04 
0435AC C1      8445 POP     BC
0435AD 18      8446 JR      DELET1			; And loop round to the next line
0435AE DD 
               8447 ;
               8448 ; LISTO expr
               8449 ;
0435AF FD      8450 LISTO:			INC     IY              	; Skip "O" byte
0435B0 23 
0435B1 CD      8451 CALL    EXPRI			; Get expr
0435B2 0F 
0435B3 03 
0435B4 04 
0435B5 D9      8452 EXX
0435B6 7D      8453 LD      A,L
0435B7 32      8454 LD      (LISTON),A		; Store in LISTON sysvar
0435B8 40 
0435B9 4D 
0435BA 04 
0435BB C3      8455 CLOOP1:			JP      CLOOP
0435BC B8 
0435BD 30 
0435BE 04 
               8456 ;
               8457 ; LIST
               8458 ; LIST line
               8459 ; LIST line,line [IF string]
               8460 ; LIST ,line
               8461 ; LIST line,
               8462 ;
0435BF FE      8463 LIST_:			CP      'O'			; Check for O (LISTO)
0435C0 4F 
0435C1 28      8464 JR      Z,LISTO			; and jump to LISTO if zero
0435C2 EC 
0435C3 CD      8465 CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435C4 8B 
0435C5 3C 
0435C6 04 
0435C7 CD      8466 CALL    NXT			; Skip space
0435C8 78 
0435C9 0A 
0435CA 04 
0435CB FE      8467 CP      TIF             	; Check for IF clause (token IF)
0435CC E7 
0435CD 3E      8468 LD      A,0             	; Initialise the IF clause string length
0435CE 00 
0435CF 20      8469 JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435D0 17 
               8470 ;
0435D1 FD      8471 INC     IY              	; Skip the IF token
0435D2 23 
0435D3 CD      8472 CALL    NXT             	; And skip any spaces
0435D4 78 
0435D5 0A 
0435D6 04 
0435D7 EB      8473 EX      DE,HL			; DE: Address in memory
0435D8 FD      8474 PUSH    IY			; LD IY, HL
0435D9 E5 
0435DA E1      8475 POP     HL              	; HL is now the address of the tokenised line
0435DB 3E      8476 LD      A,CR
0435DC 0D 
0435DD C5      8477 PUSH    BC			; Stack the second line number arg
0435DE 01      8478 LD      BC,256
0435DF 00 
0435E0 01 
0435E1 00 
0435E2 ED      8479 CPIR                    	; Locate CR byte
0435E3 B1 
0435E4 79      8480 LD      A,C
0435E5 2F      8481 CPL                    	 	; A: Substring length (of IF clause)
0435E6 C1      8482 POP     BC			; Restore the second line number arg
0435E7 EB      8483 EX      DE,HL			; HL: Address in memory
               8484 ;
0435E8 5F      8485 LISTB:			LD      E,A             	; E: IF clause string length
0435E9 78      8486 LD      A,B			; Check whether a second line number was passed (BC!=0)
0435EA B1      8487 OR      C
0435EB 20      8488 JR      NZ,LISTA		; If there isn't a second line number
0435EC 01 
0435ED 0B      8489 DEC     BC			; then we set it to the maximum of 65535
               8490 ;
0435EE D9      8491 LISTA:			EXX
0435EF DD      8492 LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
0435F0 21 
0435F1 40 
0435F2 4D 
0435F2 04   
0435F4 01      8493 LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435F5 00 
0435F6 00 
0435F7 00 
0435F8 D9      8494 EXX
0435F9 3E      8495 LD      A,20			; Number of lines to list
0435FA 14 
               8496 ;
0435FB C5      8497 LISTC:			PUSH    BC              	; Save second line number
0435FC D5      8498 PUSH    DE              	; Save IF clause length
0435FD E5      8499 PUSH    HL              	; Save BASIC program counter
0435FE 08      8500 EX      AF,AF'
               8501 ;
               8502 ; BBC BASIC for Z80 lines are stored as follows:
               8503 ;
               8504 ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
               8505 ; - [&00] [&FF] [&FF]: End of program marker
               8506 ;
               8507 ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
               8508 ;
0435FF 7E      8509 LD      A,(HL)			; Check for end of program marker
043600 B7      8510 OR      A			; If found
043601 28      8511 JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
043602 12 
               8512 ;
               8513 ; Check if past terminating line number
               8514 ;
043603 7B      8515 LD      A,E             	; A: IF clause length
043604 23      8516 INC     HL			; Skip the length byte
043605 11      8517 LD	DE,0			; Clear DE
043606 00 
043607 00 
043608 00 
043609 5E      8518 LD      E,(HL)			; Fetch the line number in DE
04360A 23      8519 INC     HL
04360B 56      8520 LD      D,(HL)
04360C 2B      8521 DEC     HL			; Step HL back to the length byte
04360D 2B      8522 DEC     HL
04360E D5      8523 PUSH    DE             	 	; Push the line number on the stack
04360F EB      8524 EX      DE,HL			; HL: line number
043610 37      8525 SCF				; Do a 16-bit compare of HL and DE
043611 ED      8526 SBC     HL,BC
043612 42 
043613 EB      8527 EX      DE,HL
043614 D1      8528 POP     DE              	; Restore the line number
043615 D2      8529 WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043616 B7 
043617 30 
043618 04 
043619 4E      8530 LD      C,(HL)          	; C: Line length + 4
04361A 47      8531 LD      B,A             	; B: IF clause length
               8532 ;
               8533 ; Check if "UNLISTABLE":
               8534 ;
04361B 7A      8535 LD      A,D			; TODO: What is "UNLISTABLE?"
04361C B3      8536 OR      E
04361D CA      8537 JP      Z,CLOOP
04361E B8 
04361F 30 
043620 04 
               8538 ;
               8539 ; Check for IF clause:
               8540 ;
043621 23      8541 INC     HL			; Skip the length
043622 23      8542 INC     HL			; Skip the line number
043623 23      8543 INC     HL              	; HL: Address of the tokenised BASIC line
043624 0D      8544 DEC     C			;  C: Line length
043625 0D      8545 DEC     C
043626 0D      8546 DEC     C
043627 0D      8547 DEC     C
043628 D5      8548 PUSH    DE              	; Save the line number
043629 E5      8549 PUSH    HL              	; Save the BASIC program address
04362A AF      8550 XOR     A               	;
04362B B8      8551 CP      B              	 	; Check for an IF clause (B!=0)
04362C FD      8552 PUSH    IY			; LD IY, DE
04362D E5 
04362E D1      8553 POP     DE              	; DE: Address of the IF clause string in the input buffer
04362F C4      8554 CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
043630 8A 
043631 07 
043632 04 
043633 E1      8555 POP     HL              	; Restore BASIC program address
043634 D1      8556 POP     DE              	; Restore line number
043635 FD      8557 PUSH    IY
043636 E5 
043637 CC      8558 CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043638 CA 
043639 38 
04363A 04 
04363B FD      8559 POP     IY
04363C E1 
               8560 ;
04363D 08      8561 EX      AF,AF'
04363E 3D      8562 DEC     A			; Decrement line list counter
04363F CD      8563 CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043640 A9 
043641 3F 
043642 04 
043643 E1      8564 POP     HL             	 	; Restore BASIC program address to beginning of line
043644 11      8565 LD	DE,0
043645 00 
043646 00 
043647 00 
043648 5E      8566 LD      E,(HL)			; Fetch the length of line in DE
043649 19      8567 ADD     HL,DE           	; Go to the next line
04364A D1      8568 POP     DE              	; Restore IF clause length
04364B C1      8569 POP     BC              	; Restore second line number
04364C 18      8570 JR      LISTC			; Loop back to do next line
04364D AD 
               8571 ;
               8572 ; RENUMBER
               8573 ; RENUMBER start
               8574 ; RENUMBER start,increment
               8575 ; RENUMBER ,increment
               8576 ;
04364E CD      8577 RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04364F AE 
043650 38 
043651 04 
043652 CD      8578 CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
043653 63 
043654 3C 
043655 04 
043656 D9      8579 EXX
043657 2A      8580 LD      HL,(PAGE_)		; HL: Top of program
043658 14 
043659 4D 
04365A 04 
04365B ED      8581 LD      DE,(LOMEM)		; DE: Start address of the heap
04365C 5B 
04365D 1A 
04365E 4D 
04365E 04   
               8582 ;
               8583 ; Build the table
               8584 ;
043660 7E      8585 RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043661 B7      8586 OR      A			; Is it zero, i.e. the end of program marker?
043662 28      8587 JR      Z,RENUM2		; Yes, so skip to the next part
043663 36 
043664 23      8588 INC     HL
043665 4E      8589 LD      C,(HL)          	; BC: The OLD line number
043666 23      8590 INC     HL
043667 46      8591 LD      B,(HL)
043668 78      8592 LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043669 B1      8593 OR      C
04366A CA      8594 JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
04366B B8 
04366C 30 
04366D 04 
04366E EB      8595 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04366F 71      8596 LD      (HL),C			; Store the OLD line number in the heap
043670 23      8597 INC     HL
043671 70      8598 LD      (HL),B
043672 23      8599 INC     HL
043673 D9      8600 EXX				; HL: line number, BC: increment (16-bit values)
043674 E5      8601 PUSH    HL			; HL: Stack the NEW line number value
043675 52      8602 ADD.S   HL,BC           	; Add the increment
043676 09 
043677 DA      8603 JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043678 5D 
043679 3C 
04367A 04 
04367B D9      8604 EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
04367C C1      8605 POP     BC			; BC: Pop the NEW line number value off the stack
04367D 71      8606 LD      (HL),C			; Store the NEW line number in the heap
04367E 23      8607 INC     HL
04367F 70      8608 LD      (HL),B
043680 23      8609 INC     HL
043681 EB      8610 EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043682 2B      8611 DEC     HL			; Back up to the line length byte
043683 2B      8612 DEC     HL
043684 01      8613 LD	BC, 0
043685 00 
043686 00 
043687 00 
043688 4E      8614 LD      C,(HL)			; BC: Line length
043689 09      8615 ADD	HL,BC           	; Advance HL to next line
04368A EB      8616 EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04368B E5      8617 PUSH    HL
04368C 24      8618 INC     H			; Increment to next page
04368D ED      8619 SBC     HL,SP			; Subtract from SP
04368E 72 
04368F E1      8620 POP     HL
043690 EB      8621 EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043691 38      8622 JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
043692 CD 
043693 CD      8623 CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
043694 AF 
043695 37 
043696 04 
043697 CC      8624 DB    	REN
043698 08      8625 DB    	8
043699 00      8626 DB    	0
               8627 ;
               8628 ; At this point a list of BASIC line numbers have been written to the heap
               8629 ; as word pairs:
               8630 ; - DW: The OLD line number
               8631 ; - DW: The NEW line number
               8632 ;
04369A EB      8633 RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
04369B 36      8634 LD      (HL),-1			; Mark the end with FFFFh
04369C FF 
04369D 23      8635 INC     HL
04369E 36      8636 LD      (HL),-1
04369F FF 
0436A0 ED      8637 LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
0436A1 5B 
0436A2 1A 
0436A3 4D 
0436A3 04   
0436A5 D9      8638 EXX
0436A6 2A      8639 LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436A7 14 
0436A8 4D 
0436A9 04 
0436AA 4E      8640 RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436AB 79      8641 LD      A,C			; If it is zero, then no program, so...
0436AC B7      8642 OR      A
0436AD CA      8643 JP      Z,WARM			; Jump to warm start
0436AE B7 
0436AF 30 
0436B0 04 
0436B1 D9      8644 EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436B2 EB      8645 EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436B3 23      8646 INC     HL			; Skip to the NEW line number
0436B4 23      8647 INC     HL
0436B5 5E      8648 LD      E,(HL)			; DE: The NEW line number
0436B6 23      8649 INC     HL
0436B7 56      8650 LD      D,(HL)
0436B8 23      8651 INC     HL
0436B9 D5      8652 PUSH    DE			; Stack the NEW line number
0436BA EB      8653 EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436BB 22      8654 LD      (LINENO),HL		; Store the line number in LINENO
0436BC 23 
0436BD 4D 
0436BE 04 
0436BF D9      8655 EXX				; HL: Pointer to the BASIC program area
0436C0 D1      8656 POP     DE			; DE: The NEW line number
0436C1 23      8657 INC     HL
0436C2 73      8658 LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436C3 23      8659 INC     HL
0436C4 72      8660 LD      (HL),D
0436C5 23      8661 INC     HL
0436C6 0D      8662 DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436C7 0D      8663 DEC     C
0436C8 0D      8664 DEC     C
0436C9 79      8665 LD	A,C
0436CA 01      8666 LD	BC,0
0436CB 00 
0436CC 00 
0436CD 00 
0436CE 4F      8667 LD	C,A			; BC: Line length
               8668 ;
0436CF 3E      8669 RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436D0 8D 
0436D1 ED      8670 CPIR                    	; Search for the token
0436D2 B1 
0436D3 20      8671 JR      NZ,RENUM3		; If not found, then loop to process the next line
0436D4 D5 
               8672 ;
               8673 ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
               8674 ;
0436D5 C5      8675 PUSH    BC			; Stack everything
0436D6 E5      8676 PUSH    HL
0436D7 E5      8677 PUSH    HL			; HL: Pointer to encoded line number
0436D8 FD      8678 POP     IY			; IY: Pointer to encoded line number
0436D9 E1 
0436DA D9      8679 EXX
0436DB CD      8680 CALL    DECODE			; Decode the encoded line number (in HL')
0436DC EB 
0436DD 08 
0436DE 04 
0436DF D9      8681 EXX				; HL: Decoded line number
0436E0 44      8682 LD      B,H			; BC: Decoded line number
0436E1 4D      8683 LD      C,L
0436E2 2A      8684 LD      HL,(LOMEM)		; HL: Pointer to heap
0436E3 1A 
0436E4 4D 
0436E5 04 
               8685 ;
               8686 ; This section of code cross-references the decoded (OLD) line number with the list
               8687 ; created previously in the global heap
               8688 ;
0436E6 5E      8689 RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436E7 23      8690 INC     HL
0436E8 56      8691 LD      D,(HL)
0436E9 23      8692 INC     HL
0436EA EB      8693 EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436EB B7      8694 OR      A               	; Clear the carry and...
0436EC 52      8695 SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436ED ED 
0436EE 42 
0436EF EB      8696 EX      DE,HL			; HL: Pointer in the global heap
0436F0 5E      8697 LD      E,(HL)          	; DE: The NEW line number
0436F1 23      8698 INC     HL
0436F2 56      8699 LD      D,(HL)
0436F3 23      8700 INC     HL
0436F4 38      8701 JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436F5 F0 
0436F6 EB      8702 EX      DE,HL			; DE: Pointer in the global heap
0436F7 28      8703 JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436F8 1D 
               8704 ;
0436F9 CD      8705 CALL    TELL			; Display this error if the line number is not found
0436FA C8 
0436FB 3D 
0436FC 04 
0436FD 46      8706 DB    	"Failed at "
0436FE 61 
0436FF 69 
043700 6C 
043700 65   
043701 64 
043702 20 
043703 61 
043703 74   
043704 20 
043707 00      8707 DB    	0
043708 2A      8708 LD      HL,(LINENO)
043709 23 
04370A 4D 
04370B 04 
04370C CD      8709 CALL    PBCDL
04370D 2F 
04370E 3A 
04370F 04 
043710 CD      8710 CALL    CRLF
043711 7F 
043712 39 
043713 04 
043714 18      8711 JR      RENUM6			; And carry on renumbering
043715 07 
               8712 ;
               8713 ; This snippet re-encodes the line number in the BASIC program
               8714 ;
043716 D1      8715 RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
043717 D5      8716 PUSH    DE
043718 1B      8717 DEC     DE			; Back up a byte to the LINO token
043719 CD      8718 CALL    ENCODE          	; Re-write the new line number out
04371A 94 
04371B 3D 
04371C 04 
04371D E1      8719 RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
04371E C1      8720 POP     BC			; BC: The remaining line length
04371F 18      8721 JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
043720 AE 
               8722 ;
               8723 ; AUTO
               8724 ; AUTO start,increment
               8725 ; AUTO start
               8726 ; AUTO ,increment
               8727 ;
043721 CD      8728 AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
043722 63 
043723 3C 
043724 04 
043725 22      8729 LD      (AUTONO),HL		; Store the start in AUTONO
043726 29 
043727 4D 
043728 04 
043729 79      8730 LD      A,C			; Increment is 8 bit (0-255)
04372A 32      8731 LD      (INCREM),A		; Store that in INCREM
04372B 41 
04372C 4D 
04372D 04 
04372E 18      8732 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04372F 2E 
               8733 ;
               8734 ; BAD
               8735 ; NEW
               8736 ;
043730 CD      8737 BAD:			CALL    TELL            	; Output "Bad program" error
043731 C8 
043732 3D 
043733 04 
043734 03      8738 DB    3				; Token for "BAD"
043735 70      8739 DB    "program"
043736 72 
043737 6F 
043738 67 
043738 72   
043739 61 
04373A 6D 
04373C 0D      8740 DB    CR
04373D 0A      8741 DB    LF
04373E 00      8742 DB    0				; Falls through to NEW
               8743 ;
04373F CD      8744 NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043740 A4 
043741 38 
043742 04 
043743 18      8745 JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043744 19 
               8746 ;
               8747 ; OLD
               8748 ;
043745 2A      8749 OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043746 14 
043747 4D 
043748 04 
043749 E5      8750 PUSH    HL			; Stack it
04374A 23      8751 INC     HL			; Skip the potential length byte of first line of code
04374B 23      8752 INC     HL			; And the line number word
04374C 23      8753 INC     HL
04374D 01      8754 LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
04374E FC 
04374F 00 
043750 00 
043751 3E      8755 LD      A,CR
043752 0D 
043753 ED      8756 CPIR
043754 B1 
043755 20      8757 JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
043756 D9 
043757 7D      8758 LD      A,L			; It could still be garbage though! Store the position in A; this requires
043758 E1      8759 POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043759 77      8760 LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
04375A CD      8761 CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04375B 77 
04375C 38 
04375D 04 
04375E C3      8762 CLOOP0:			JP      CLOOP			; Jump back to the command loop
04375F B8 
043760 30 
043761 04 
               8763 ;
               8764 ; LOAD filename
               8765 ;
043762 CD      8766 LOAD:			CALL    EXPRS           	; Get the filename
043763 1A 
043764 03 
043765 04 
043766 3E      8767 LD      A,CR			; DE points to the last byte of filename in ACCS
043767 0D 
043768 12      8768 LD      (DE),A			; Terminate filename with a CR
043769 CD      8769 CALL    LOAD0			; Load the file in, then CLEAN
04376A 57 
04376B 38 
04376C 04 
04376D CD      8770 CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04376E AE 
04376F 38 
043770 04 
043771 18      8771 JR      WARM0			; Jump back to the command loop
043772 21 
               8772 ;
               8773 ; SAVE filename
               8774 ;
043773 CD      8775 SAVE:			CALL    SETTOP          	; Set TOP sysvar
043774 83 
043775 38 
043776 04 
043777 CD      8776 CALL    EXPRS           	; Get the filename
043778 1A 
043779 03 
04377A 04 
04377B 3E      8777 LD      A,CR			; Terminate the filename with a CR
04377C 0D 
04377D 12      8778 LD      (DE),A
04377E ED      8779 LD      DE,(PAGE_)		; DE: Start of program memory
04377F 5B 
043780 14 
043781 4D 
043781 04   
043783 2A      8780 LD      HL,(TOP)		; HL: Top of program memory
043784 17 
043785 4D 
043786 04 
043787 B7      8781 OR      A			; Calculate program size (TOP-PAGE)
043788 ED      8782 SBC     HL,DE
043789 52 
04378A 44      8783 LD      B,H             	; BC: Length of program in bytes
04378B 4D      8784 LD      C,L
04378C 21      8785 LD      HL,ACCS			; HL: Address of the filename
04378D 00 
04378E 4A 
04378F 04 
043790 CD      8786 CALL    OSSAVE			; Call the SAVE routine in patch.asm
043791 76 
043792 42 
043793 04 
043794 C3      8787 WARM0:			JP      WARM			; Jump back to the command loop
043795 B7 
043796 30 
043797 04 
               8788 
               8789 ;
               8790 ; ERROR
               8791 ; Called whenever BASIC needs to halt with an error
               8792 ; Error messages are indexed from 0
               8793 ; Inputs:
               8794 ;  A: Error number
               8795 ;
043798 ED      8796 ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
043799 7B 
04379A 20 
04379B 4D 
04379B 04   
04379D 21      8797 LD      HL,ERRWDS		; Index into the error string table
04379E 81 
04379F 34 
0437A0 04 
0437A1 B7      8798 OR      A			; We don't need to search for the first error
0437A2 28      8799 JR      Z,ERROR1		; So skip the search routine
0437A3 0A 
               8800 ;
               8801 ; Search the error table for error #A
               8802 ; HL will end up being the pointer into the correct error
               8803 ; There is no bounds checking on this, so invalid error numbers will probably output garbage
               8804 ;
0437A4 47      8805 LD      B,A             	; Store error number in B
0437A5 08      8806 EX      AF,AF'			; Store error number in AF'
0437A6 AF      8807 XOR     A
0437A7 BE      8808 ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437A8 23      8809 INC     HL			; Increment the string pointer
0437A9 20      8810 JR      NZ,ERROR0		; Loop until with hit a 0
0437AA FC 
0437AB 10      8811 DJNZ    ERROR0			; Decrements the error number and loop until 0
0437AC FA 
0437AD 08      8812 EX      AF,AF'			; Restore the error number from AF'
               8813 ;
               8814 ; At this point HL points to the tokenised error string
               8815 ;
0437AE E5      8816 ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
               8817 
               8818 ;
               8819 ; EXTERR
               8820 ; Inputs:
               8821 ;  A: Error number
               8822 ;
               8823 ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
               8824 ; The error text immediately follows the CALL to EXTERR, for example:
               8825 ; > CALL  EXTERR
               8826 ; > DB    "Silly", 0
               8827 ; So we can get the address of the string by popping the return address off the stack
               8828 ;
0437AF E1      8829 EXTERR:			POP     HL			; Pop the error string pointer
0437B0 22      8830 LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437B1 2F 
0437B2 4D 
0437B3 04 
0437B4 ED      8831 LD      SP,(HIMEM)		; Set SP to HIMEM
0437B5 7B 
0437B6 20 
0437B7 4D 
0437B7 04   
0437B9 32      8832 LD      (ERR),A			; Store error number in ERR sysvar
0437BA 3F 
0437BB 4D 
0437BC 04 
0437BD CD      8833 CALL    SETLIN			; Get line number
0437BE E6 
0437BF 39 
0437C0 04 
0437C1 22      8834 LD      (ERL),HL		; Store in ERL sysvar
0437C2 33 
0437C3 4D 
0437C4 04 
0437C5 B7      8835 OR      A			; Is error number 0?
0437C6 28      8836 JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437C7 0D 
               8837 ;
0437C8 2A      8838 LD      HL,(ERRTRP)		; Check whether the error is trapped
0437C9 2C 
0437CA 4D 
0437CB 04 
0437CC 7C      8839 LD      A,H
0437CD B5      8840 OR      L
0437CE E5      8841 PUSH    HL			; HL: Error line
0437CF FD      8842 POP     IY			; IY: HL
0437D0 E1 
0437D1 C2      8843 JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437D2 9E 
0437D3 0B 
0437D4 04 
               8844 ;
0437D5 21      8845 ERROR2:			LD      HL,0
0437D6 00 
0437D7 00 
0437D8 00 
0437D9 22      8846 LD      (AUTONO),HL		; Cancel AUTO
0437DA 29 
0437DB 4D 
0437DC 04 
0437DD 22      8847 LD      (TRACEN),HL     	; Cancel TRACE
0437DE 26 
0437DF 4D 
0437E0 04 
0437E1 CD      8848 CALL    RESET           	; Reset OPSYS
0437E2 FF 
0437E3 43 
0437E4 04 
0437E5 CD      8849 CALL    CRLF			; Output newline
0437E6 7F 
0437E7 39 
0437E8 04 
0437E9 CD      8850 CALL    REPORT          	; Output the error message
0437EA BA 
0437EB 3D 
0437EC 04 
0437ED CD      8851 CALL    SAYLN			; Output " at line nnnn" message.
0437EE 1A 
0437EF 3A 
0437F0 04 
0437F1 1E      8852 LD      E,0			; Close all files
0437F2 00 
0437F3 DC      8853 CALL    C,OSSHUT
0437F4 74 
0437F5 43 
0437F6 04 
0437F7 CD      8854 CALL    CRLF			; Output newline
0437F8 7F 
0437F9 39 
0437FA 04 
0437FB C3      8855 JP      CLOOP			; Back to CLOOP
0437FC B8 
0437FD 30 
0437FE 04 
               8856 ;
               8857 ; SUBROUTINES:
               8858 ;
               8859 ; LEX - SEARCH FOR KEYWORDS
               8860 ;   Inputs: HL = start of keyword table
               8861 ;           IY = start of match text
               8862 ;  Outputs: If found, Z-flag set, A=token.
               8863 ;           If not found, Z-flag reset, A=(IY).
               8864 ;           IY updated (if NZ, IY unchanged).
               8865 ; Destroys: A,B,H,L,IY,F
               8866 ;
0437FF 21      8867 LEX:			LD      HL,KEYWDS		; Address of the keywords table
043800 A0 
043801 31 
043802 04 
               8868 ;
043803 FD      8869 LEX0:			LD      A,(IY)			; Fetch the character to match
043804 7E 
043805 00 
043806 46      8870 LD      B,(HL)			; B: The token from the keywords table
043807 23      8871 INC     HL			; Increment the pointer in the keywords table
043808 BE      8872 CP      (HL)			; Compare the first characters
043809 28      8873 JR      Z,LEX2			; If there is a match, then skip to LEX2
04380A 08 
04380B D8      8874 RET     C               	; No match, so fail
               8875 ;
               8876 ; This snippet of code skips to the next token in the KEYWDS table
               8877 ;
04380C 23      8878 LEX1:			INC     HL			; Increment the pointer
04380D CB      8879 BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
04380E 7E 
04380F 28      8880 JR      Z,LEX1			; No, so loop
043810 FB 
043811 18      8881 JR      LEX0			; At this point HL is pointing to the start of the next keyword
043812 F0 
               8882 ;
043813 FD      8883 LEX2:			PUSH    IY              	; Save the input pointer
043814 E5 
043815 23      8884 LEX3:			INC     HL			; Increment the keyword pointer
043816 CB      8885 BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043817 7E 
043818 20      8886 JR      NZ,LEX6         	; Jump to here as we've found a token
043819 1C 
04381A FD      8887 INC     IY			; Increment the text pointer
04381B 23 
04381C FD      8888 LD      A,(IY)			; Fetch the character
04381D 7E 
04381E 00 
04381F FE      8889 CP      '.'			; Is it an abbreviated keyword?
043820 2E 
043821 28      8890 JR      Z,LEX6          	; Yes, so we'll return with the token we've found
043822 13 
043823 BE      8891 CP      (HL)			; Compare with the keywords list
043824 28      8892 JR      Z,LEX3			; It's a match, so continue checking this keyword
043825 EF 
043826 CD      8893 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043827 B3 
043828 3C 
043829 04 
04382A 38      8894 JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
04382B 04 
               8895 ;
04382C FD      8896 LEX4:			POP     IY              	; Restore the input pointer ready for the next search
04382D E1 
04382E 18      8897 JR      LEX1			; And loop back to start again
04382F DC 
               8898 ;
               8899 ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
               8900 ; immediately delimited
               8901 ;
043830 7E      8902 LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
043831 B7      8903 OR      A			; If it is not zero, then...
043832 20      8904 JR      NZ,LEX4			; Keep searching
043833 F8 
043834 FD      8905 DEC     IY			; If it is zero, then skip the input pointer back one byte
043835 2B 
               8906 ;
               8907 ; We've found a token at this point
               8908 ;
043836 F1      8909 LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
043837 AF      8910 XOR     A			; Set the Z flag
043838 78      8911 LD      A,B			; A: The token
043839 C9      8912 RET
               8913 ;
               8914 ; DEL - DELETE A PROGRAM LINE.
               8915 ;   Inputs: HL addresses program line.
               8916 ; Destroys: B,C,F
               8917 ;
               8918 ; This simply erases the line by moving all of the code after the line to be deleted back over
               8919 ; it using an LDIR
               8920 ;
04383A D5      8921 DEL:			PUSH    DE
04383B E5      8922 PUSH    HL
04383C E5      8923 PUSH    HL			; HL: Address of the program line
04383D 06      8924 LD      B,0			; BC: Length of the line
04383E 00 
04383F 4E      8925 LD      C,(HL)
043840 09      8926 ADD     HL,BC			; HL: Advanced to the start of the next line
043841 E5      8927 PUSH    HL
043842 EB      8928 EX      DE,HL			; DE: Pointer to the next line
043843 2A      8929 LD      HL,(TOP)		; HL: Pointer to the end of the program
043844 17 
043845 4D 
043846 04 
043847 ED      8930 SBC     HL,DE
043848 52 
043849 44      8931 LD      B,H			; BC: Size of block to move
04384A 4D      8932 LD      C,L
04384B E1      8933 POP     HL			; HL: Pointer to next line
04384C D1      8934 POP     DE			; DE: Pointer to this line
04384D ED      8935 LDIR                    	; Delete the line
04384E B0 
04384F ED      8936 LD      (TOP),DE		; Adjust TOP
043850 53 
043851 17 
043852 4D 
043852 04   
043854 E1      8937 POP     HL
043855 D1      8938 POP     DE
043856 C9      8939 RET
               8940 ;
               8941 ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
               8942 ;   Inputs: Filename in ACCS (term CR)
               8943 ; Destroys: A,B,C,D,E,H,L,F
               8944 ;
               8945 ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
               8946 ; AND WRITE FF FF, THEN LOAD (TOP).
               8947 ; Destroys: A,B,C,H,L,F
               8948 ;
043857 ED      8949 LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
043858 5B 
043859 14 
04385A 4D 
04385A 04   
04385C 21      8950 LD      HL,-256
04385D 00 
04385E FF 
04385F FF 
043860 39      8951 ADD     HL,SP
043861 ED      8952 SBC     HL,DE           	; Find available space
043862 52 
043863 44      8953 LD      B,H
043864 4D      8954 LD      C,L
043865 21      8955 LD      HL,ACCS
043866 00 
043867 4A 
043868 04 
043869 CD      8956 CALL    OSLOAD          	; Call the OSLOAD function in patch
04386A DD 
04386B 41 
04386C 04 
04386D D4      8957 CALL    NC,NEWIT		; If NC then NEW
04386E A4 
04386F 38 
043870 04 
043871 3E      8958 LD      A,0
043872 00 
043873 D2      8959 JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
043874 98 
043875 37 
043876 04 
               8960 ;
043877 CD      8961 CLEAN:			CALL    SETTOP			; Set TOP sysvar
043878 83 
043879 38 
04387A 04 
04387B 2B      8962 DEC     HL			; Write out the end of program markers
04387C 36      8963 LD      (HL),-1
04387D FF 
04387E 2B      8964 DEC     HL
04387F 36      8965 LD      (HL),-1
043880 FF 
043881 18      8966 JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
043882 2B 
               8967 ;
               8968 ; Set the TOP sysvar; the first free location after the end of the current program
               8969 ; Returns:
               8970 ; - HL: TOP
               8971 ;
043883 2A      8972 SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
043884 14 
043885 4D 
043886 04 
043887 01      8973 LD	BC, 0			; BC: 0
043888 00 
043889 00 
04388A 00 
04388B 3E      8974 LD      A,CR			; End of line marker
04388C 0D 
04388D 4E      8975 SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
04388E 0C      8976 INC     C			; Check for zero
04388F 0D      8977 DEC     C
043890 28      8978 JR      Z,SETOP2		; If it is zero, we've reached the end
043891 0A 
043892 09      8979 ADD     HL,BC			; Skip to next line
043893 2B      8980 DEC     HL			; Check end of previous line
043894 BE      8981 CP      (HL)
043895 23      8982 INC     HL
043896 28      8983 JR      Z,SETOP1		; If CR then loop
043897 F5 
043898 C3      8984 JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043899 30 
04389A 37 
04389B 04 
               8985 ;
04389C 23      8986 SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
04389D 23      8987 INC     HL			; NB: Called from NEWIT
04389E 23      8988 INC     HL
04389F 22      8989 LD      (TOP),HL		; Store in TOP sysvar
0438A0 17 
0438A1 4D 
0438A2 04 
0438A3 C9      8990 RET
               8991 ;
               8992 ; NEWIT - NEW PROGRAM THEN CLEAR
               8993 ;   Destroys: H,L
               8994 ;
               8995 ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
               8996 ; FUNCTION AND PROCEDURE POINTERS.
               8997 ;   Destroys: Nothing
               8998 ;
0438A4 2A      8999 NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438A5 14 
0438A6 4D 
0438A7 04 
0438A8 36      9000 LD      (HL),0			; Stick a 0 in there
0438A9 00 
0438AA CD      9001 CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438AB 9C 
0438AC 38 
0438AD 04 
               9002 ;
0438AE E5      9003 CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438AF 2A      9004 LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438B0 17 
0438B1 4D 
0438B2 04 
0438B3 22      9005 LD      (LOMEM),HL		; Set the LOMEM sysvar
0438B4 1A 
0438B5 4D 
0438B6 04 
0438B7 22      9006 LD      (FREE),HL		; And the FREE sysvar with that value
0438B8 1D 
0438B9 4D 
0438BA 04 
0438BB 21      9007 LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438BC 6C 
0438BD 4C 
0438BE 04 
0438BF C5      9008 PUSH    BC
               9009 ; LD      B,3*(54+2)		; Loop counter
0438C0 06      9010 LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438C1 A8 
0438C2 36      9011 CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438C3 00 
0438C4 23      9012 INC     HL
0438C5 10      9013 DJNZ    CLEAR1
0438C6 FB 
0438C7 C1      9014 POP     BC
0438C8 E1      9015 POP     HL			; Restore the BASIC program pointer
0438C9 C9      9016 RET
               9017 ;
               9018 ;LISTIT - LIST A PROGRAM LINE.
               9019 ;    Inputs: HL addresses line
               9020 ;            DE = line number (binary)
               9021 ;            IX = Pointer to LISTON
               9022 ;             B = FOR/NEXT indent level
               9023 ;             C = REPEAT/UNTIL indent level
               9024 ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
               9025 ;
0438CA E5      9026 LISTIT:			PUSH    HL			; Stack the address of the line
0438CB EB      9027 EX      DE,HL			; HL: Line number
0438CC C5      9028 PUSH    BC
0438CD CD      9029 CALL    PBCD			; Print the line number
0438CE 33 
0438CF 3A 
0438D0 04 
0438D1 C1      9030 POP     BC
0438D2 E1      9031 POP     HL			; HL: Address of the first token/character
0438D3 7E      9032 LD      A,(HL)			; Fetch the token
0438D4 FE      9033 CP      NEXT			; Is it NEXT...
0438D5 ED 
0438D6 CC      9034 CALL    Z,INDENT		; Yes, so indent in
0438D7 60 
0438D8 39 
0438D9 04 
0438DA FE      9035 CP      UNTIL			; Or is it UNTIL...
0438DB FD 
0438DC CC      9036 CALL    Z,INDENT		; Yes, so indent in
0438DD 60 
0438DE 39 
0438DF 04 
0438E0 D9      9037 EXX
0438E1 3E      9038 LD      A,' '
0438E2 20 
0438E3 DD      9039 BIT     0,(IX)			; If BIT 0 of LISTON is set
0438E4 CB 
0438E5 00 
0438E6 46 
0438E7 C4      9040 CALL    NZ,OUTCHR		; Then print a space after the line number
0438E8 87 
0438E9 39 
0438EA 04 
0438EB 78      9041 LD      A,B			; Fetch the FOR/NEXT indent level
0438EC 87      9042 ADD     A,A			; Multiply by 2
0438ED DD      9043 BIT     1,(IX)			; If BIT 1 of LISTON is set
0438EE CB 
0438EF 00 
0438F0 4E 
0438F1 C4      9044 CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438F2 21 
0438F3 18 
0438F4 04 
0438F5 79      9045 LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438F6 87      9046 ADD     A,A			; Multiply by 2
0438F7 DD      9047 BIT     2,(IX)			; If BIT 2 of LISTON is set
0438F8 CB 
0438F9 00 
0438FA 56 
0438FB C4      9048 CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438FC 21 
0438FD 18 
0438FE 04 
0438FF D9      9049 EXX
043900 7E      9050 LD      A,(HL)			; Fetch the token
043901 FE      9051 CP      FOR			; Is it FOR?
043902 E3 
043903 CC      9052 CALL    Z,INDENT		; Yes, so indent
043904 60 
043905 39 
043906 04 
043907 FE      9053 CP      REPEAT			; Is it REPEAT?
043908 F5 
043909 CC      9054 CALL    Z,INDENT		; Yes, so indent
04390A 60 
04390B 39 
04390C 04 
04390D 1E      9055 LD      E,0			; E: The quote counter - reset to 0
04390E 00 
04390F 7E      9056 LIST8:			LD      A,(HL)			; Fetch a character / token byte
043910 23      9057 INC     HL
043911 FE      9058 CP      CR			; Is it end of line?
043912 0D 
043913 28      9059 JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
043914 0B 
043915 FE      9060 CP      34			; Is it a quote character?
043916 22 
043917 20      9061 JR      NZ,LIST7		; No, so skip to next bit
043918 01 
043919 1C      9062 INC     E			; Otherwise increment quote counter
04391A CD      9063 LIST7:			CALL    LOUT			; Output the character / token
04391B 4F 
04391C 39 
04391D 04 
04391E 18      9064 JR      LIST8			; And repeat
04391F EF 
               9065 ;
               9066 ; DB: Modification for *EDIT
               9067 ; Terminate the line with either a CRLF or a NUL character
               9068 ;
043920 DD      9069 LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
043921 CB 
043922 00 
043923 5E 
043924 28      9070 JR	Z, CRLF			; Yes, so print a CRLF
043925 59 
043926 AF      9071 XOR	A			; Otherwise print a NUL (0)
043927 C3      9072 JP	OSWRCH
043928 38 
043929 3F 
04392A 04 
               9073 ;
               9074 ; Decode the 3 byte GOTO type line number
               9075 ;
04392B E5      9076 PRLINO:			PUSH    HL			; Swap HL and IY
04392C FD      9077 POP     IY			; IY: Pointer to the line number
04392D E1 
04392E C5      9078 PUSH    BC
04392F CD      9079 CALL    DECODE			; Decode
043930 EB 
043931 08 
043932 04 
043933 C1      9080 POP     BC
043934 D9      9081 EXX
043935 C5      9082 PUSH    BC
043936 CD      9083 CALL    PBCDL			; Output the line number
043937 2F 
043938 3A 
043939 04 
04393A C1      9084 POP     BC
04393B D9      9085 EXX
04393C FD      9086 PUSH    IY			; Swap HL and IY
04393D E5 
04393E E1      9087 POP     HL			; HL: Pointer to the next character in the line
04393F C9      9088 RET
               9089 ;
               9090 ; DB: Modification for internationalisation
               9091 ;
043940 CD      9092 PRREM:			CALL	OUT_			; Output the REM token
043941 A4 
043942 39 
043943 04 
043944 7E      9093 @@:			LD	A, (HL)			; Fetch the character
043945 FE      9094 CP	CR			; If it is end of line, then
043946 0D 
043947 C8      9095 RET	Z			; we have finished
043948 CD      9096 CALL	OUTCHR			; Ouput the character
043949 87 
04394A 39 
04394B 04 
04394C 23      9097 INC	HL
04394D 18      9098 JR	@B			; And loop
04394E F5 
               9099 ;
               9100 ; DB: End of modification
               9101 ;
04394F CB      9102 LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043950 43 
043951 20      9103 JR      NZ,OUTCHR		; don't tokenise, just output the character
043952 34 
043953 FE      9104 CP	REM			; DB: Is it REM
043954 F4 
043955 28      9105 JR	Z, PRREM		; DB: Yes so jump to the special case for REM
043956 E9 
043957 FE      9106 CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043958 8D 
043959 28      9107 JR      Z,PRLINO		; Yes, so decode and print the line number
04395A D0 
04395B CD      9108 CALL    OUT_			; Output a character / keyword
04395C A4 
04395D 39 
04395E 04 
04395F 7E      9109 LD      A,(HL)			; Fetch the next character
               9110 ;
               9111 ; This block of code handles the indentation
               9112 ; B: Counter for FOR/NEXT indent
               9113 ; C: Counter for REPEAT/UNTIL indent
               9114 ;
043960 D9      9115 INDENT:			EXX
043961 FE      9116 CP      FOR			; If the token is FOR
043962 E3 
043963 28      9117 JR      Z,IND1			; Then INC B
043964 09 
043965 FE      9118 CP      NEXT			; If it is NEXT
043966 ED 
043967 20      9119 JR      NZ,IND2_		; Then...
043968 06 
043969 05      9120 DEC     B			; DEC B
04396A F2      9121 JP      P,IND2_			; If we have gone below 0 then
04396B 6F 
04396C 39 
04396D 04 
04396E 04      9122 IND1:			INC     B			; Increment back to 0
               9123 ;
04396F FE      9124 IND2_:			CP      REPEAT			; If the token is REPEAT
043970 F5 
043971 28      9125 JR      Z,IND3			; Then INC C
043972 09 
043973 FE      9126 CP      UNTIL			; If it is UNTIL
043974 FD 
043975 20      9127 JR      NZ,IND4			; Then...
043976 06 
043977 0D      9128 DEC     C			; DEC C
043978 F2      9129 JP      P,IND4			; If we have gone below 0 then
043979 7D 
04397A 39 
04397B 04 
04397C 0C      9130 IND3:			INC     C			; Incremet back to 0
04397D D9      9131 IND4:			EXX
04397E C9      9132 RET
               9133 ;
               9134 ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
               9135 ;  Destroys: A,F
               9136 ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
               9137 ;    Inputs: A = character
               9138 ;  Destroys: A,F
               9139 ;
04397F 3E      9140 CRLF:			LD      A,CR			; Output CR
043980 0D 
043981 CD      9141 CALL    OUTCHR
043982 87 
043983 39 
043984 04 
043985 3E      9142 LD      A,LF			; Output LF
043986 0A 
               9143 ;
043987 CD      9144 OUTCHR:			CALL    OSWRCH			; Output the character in A
043988 38 
043989 3F 
04398A 04 
04398B D6      9145 SUB     CR			; Check for CR
04398C 0D 
04398D 28      9146 JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
04398E 06 
04398F D8      9147 RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043990 3A      9148 LD      A,(COUNT)		; Increment the count
043991 3D 
043992 4D 
043993 04 
043994 3C      9149 INC     A
               9150 ;
043995 32      9151 CARRET:			LD      (COUNT),A		; Store the new count value
043996 3D 
043997 4D 
043998 04 
043999 C8      9152 RET     Z			; Return if the count has wrapped to 0
04399A E5      9153 PUSH    HL			; Now check if count = print width
04399B 2A      9154 LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
04399C 3E 
04399D 4D 
04399E 04 
04399F BD      9155 CP      L			; L is the width. Compare it with count.
0439A0 E1      9156 POP     HL
0439A1 C0      9157 RET     NZ			; If we've not hit print width, then just return
0439A2 18      9158 JR      CRLF			; Otherwise output CRLF
0439A3 DB 
               9159 ;
               9160 ; OUT - SEND CHARACTER OR KEYWORD
               9161 ;   Inputs: A = character (>=10, <128)
               9162 ;           A = Token (<10, >=128)
               9163 ;  Destroys: A,F
               9164 ;
0439A4 FE      9165 OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0439A5 8A 
0439A6 EA      9166 JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439A7 87 
0439A8 39 
0439A9 04 
               9167 ;
               9168 ; This bit looks up the character in the KEYWDS token table and expands it
               9169 ; Note the CP 138; this sets the overflow flag as follows:
               9170 ;
               9171 ; NB:
               9172 ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
               9173 ;  2. CP is effectively a SUB; sets the flags without affecting A
               9174 ;  3. The operation n - -118 ~ n + 118
               9175 ;
               9176 ; So:
               9177 ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
               9178 ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
               9179 ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
               9180 ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
               9181 ;
0439AA C5      9182 PUSH    BC			; Preserve BC and HL
0439AB E5      9183 PUSH    HL
0439AC 21      9184 LD      HL,KEYWDS		; The list of tokens and keywords
0439AD A0 
0439AE 31 
0439AF 04 
0439B0 01      9185 LD      BC,KEYWDL		; The length of the keyword list
0439B1 DF 
0439B2 02 
0439B3 00 
0439B4 ED      9186 CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439B5 B1 
               9187 ;							; At this point HL points to the next byte, the first character of the token
0439B6 7E      9188 TOKEN1:			LD      A,(HL)			; Fetch the character
0439B7 23      9189 INC     HL			; Increment to the next byte in the token table
0439B8 FE      9190 CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439B9 8A 
0439BA F5      9191 PUSH    AF			; Then...
0439BB EC      9192 CALL    PE,OUTCHR		; Output the character...
0439BC 87 
0439BD 39 
0439BE 04 
0439BF F1      9193 POP     AF			;
0439C0 EA      9194 JP      PE,TOKEN1		; And loop to the next character
0439C1 B6 
0439C2 39 
0439C3 04 
0439C4 E1      9195 POP     HL			; Done, so tidy up the stack and exit
0439C5 C1      9196 POP     BC
0439C6 C9      9197 RET
               9198 ;
               9199 ; FINDL - FIND PROGRAM LINE
               9200 ;   Inputs: HL = line number (binary)
               9201 ;  Outputs: HL addresses line (if found)
               9202 ;           DE = line number
               9203 ;           Z-flag set if found.
               9204 ; Destroys: A,B,C,D,E,H,L,F
               9205 ;
0439C7 EB      9206 FINDL:			EX      DE,HL			; DE: Line number (binary)
0439C8 2A      9207 LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439C9 14 
0439CA 4D 
0439CB 04 
0439CC AF      9208 XOR     A               	;  A: 0
0439CD BE      9209 CP      (HL)			; Check for end of program marker
0439CE 3C      9210 INC     A			;  A: 1
0439CF D0      9211 RET     NC			; Return with 1 if 0
0439D0 AF      9212 XOR     A               	; Clear the carry flag
               9213 ;			LD      B,A			;  B: 0
0439D1 01      9214 LD	BC, 0			; BC: 0
0439D2 00 
0439D3 00 
0439D4 00 
               9215 ;
0439D5 4E      9216 FINDL1:			LD      C,(HL)			;  C: The line length
0439D6 E5      9217 PUSH    HL			; Stack the current program counter
0439D7 23      9218 INC     HL			; Skip to the line number bytes
0439D8 7E      9219 LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439D9 23      9220 INC     HL
0439DA 66      9221 LD      H,(HL)
0439DB 6F      9222 LD      L,A
0439DC 52      9223 SBC.S   HL,DE			; Compare with the line number we're searching for
0439DD ED 
0439DE 52 
0439DF E1      9224 POP     HL			; Get the current program counter
0439E0 D0      9225 RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439E1 09      9226 ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439E2 C3      9227 JP      FINDL1			; And loop
0439E3 D5 
0439E4 39 
0439E5 04 
               9228 ;
               9229 ; SETLIN - Search program for line containing address
               9230 ;          Update (LINENO)
               9231 ;   Inputs: Address in (ERRLIN)
               9232 ;  Outputs: Line number in HL and (LINENO)
               9233 ; Destroys: B,C,D,E,H,L,F
               9234 ;
0439E6 01      9235 SETLIN:			LD	BC, 0			; Zero BC for later
0439E7 00 
0439E8 00 
0439E9 00 
               9236 ;			LD      B, 0			; Zero B for later
0439EA ED      9237 LD      DE, (ERRLIN)		; DE: Address of line
0439EB 5B 
0439EC 35 
0439ED 4D 
0439ED 04   
0439EF 2A      9238 LD      HL, (PAGE_)		; HL: Start of user program area
0439F0 14 
0439F1 4D 
0439F2 04 
0439F3 B7      9239 OR      A			; Do a 24 bit compare without destroying HL
0439F4 ED      9240 SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439F5 52 
0439F6 19      9241 ADD     HL, DE			;  C: DE > HL
0439F7 30      9242 JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439F8 1B 
               9243 ;
0439F9 4E      9244 SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439FA 0C      9245 INC     C			; This is a way to check for zero without using the accumulator
0439FB 0D      9246 DEC     C			; If it is zero, then...
0439FC 28      9247 JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439FD 16 
0439FE 09      9248 ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439FF ED      9249 SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
043A00 52 
043A01 19      9250 ADD     HL, DE
043A02 38      9251 JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
043A03 F5 
043A04 ED      9252 SBC     HL, BC			; We've found it, so back up to the beginning of the line
043A05 42 
043A06 23      9253 INC     HL			; Skip the length counter
043A07 11      9254 LD	DE, 0			; Zero DE
043A08 00 
043A09 00 
043A0A 00 
043A0B 5E      9255 LD      E, (HL)          	; Fetch the line number
043A0C 23      9256 INC     HL
043A0D 56      9257 LD      D, (HL)
043A0E EB      9258 EX      DE, HL			; HL: The line number
043A0F 22      9259 SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A10 23 
043A11 4D 
043A12 04 
043A13 C9      9260 RET
               9261 ;
043A14 21      9262 SET3:			LD      HL, 0			; We've not found the line at this point so
043A15 00 
043A16 00 
043A17 00 
043A18 18      9263 JR      SET2			; Set LINENO to 0
043A19 F5 
               9264 ;
               9265 ;SAYLN - PRINT " at line nnnn" MESSAGE.
               9266 ;  Outputs: Carry=0 if line number is zero.
               9267 ;           Carry=1 if line number is non-zero.
               9268 ; Destroys: A,B,C,D,E,H,L,F
               9269 ;
043A1A 2A      9270 SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A1B 23 
043A1C 4D 
043A1D 04 
043A1E 7C      9271 LD      A,H			; If it is zero then
043A1F B5      9272 OR      L
043A20 C8      9273 RET     Z			; Don't need to do anything; return with F:C set to 0
043A21 CD      9274 CALL    TELL			; Output the error message
043A22 C8 
043A23 3D 
043A24 04 
043A25 20      9275 DB    	" at line ", 0
043A26 61 
043A27 74 
043A28 20 
043A28 6C   
043A29 69 
043A2A 6E 
043A2B 65 
043A2B 20   
043A2C 00 
043A2F 0E      9276 PBCDL:			LD      C,0			; C: Leading character (NUL)
043A30 00 
043A31 18      9277 JR      PBCD0			; Output the line number; return with F:C set to 1
043A32 02 
               9278 ;
               9279 ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
               9280 ;   Inputs: HL = number (binary).
               9281 ;  Outputs: Carry = 1
               9282 ; Destroys: A,B,C,D,E,H,L,F
               9283 ;
043A33 0E      9284 PBCD:			LD      C,' '			; C: Leading character (" ")
043A34 20 
043A35 06      9285 PBCD0:			LD      B,5			; Number of digits in result
043A36 05 
043A37 11      9286 LD      DE,10000		; Start off with the 10,000 column
043A38 10 
043A39 27 
043A3A 00 
043A3B AF      9287 PBCD1:			XOR     A			; Counter
043A3C ED      9288 PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A3D 52 
043A3E 3C      9289 INC     A
043A3F 30      9290 JR      NC,PBCD2
043A40 FB 
043A41 19      9291 ADD     HL,DE			; The loop overruns by one, so adjust here
043A42 3D      9292 DEC     A			; A: Number of 10,000s
043A43 28      9293 JR      Z,PBCD3			; If it is 0, then skip the next bit
043A44 04 
043A45 CB      9294 SET     4,C			; C: Set to '0' ASCII (30h)
043A46 E1 
043A47 CB      9295 SET     5,C
043A48 E9 
043A49 B1      9296 PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A4A C4      9297 CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A4B 87 
043A4C 39 
043A4D 04 
043A4E 78      9298 LD      A,B			; If on first transition, skip this
043A4F FE      9299 CP      5			; TODO: Need to find out why
043A50 05 
043A51 28      9300 JR      Z,PBCD4
043A52 06 
043A53 29      9301 ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A54 54      9302 LD      D,H			;         : rather than shifting DE right
043A55 5D      9303 LD      E,L			;         : This makes a lot of sense
043A56 29      9304 ADD     HL,HL			; HL x  4
043A57 29      9305 ADD     HL,HL			; HL x  8
043A58 19      9306 ADD     HL,DE			; HL x 10
043A59 11      9307 PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A5A E8 
043A5B 03 
043A5C 00 
043A5D 10      9308 DJNZ    PBCD1			; Loop until done
043A5E DC 
043A5F 37      9309 SCF				; SCF set for SAYLN in this module
043A60 C9      9310 RET
               9311 ;
               9312 ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
               9313 ;   Inputs: HL, IY as returned from GETVAR (NZ).
               9314 ;  Outputs: As GETVAR.
               9315 ; Destroys: everything
               9316 ;
043A61 CD      9317 PUTVAR:			CALL    CREATE			; Create the variable
043A62 E6 
043A63 3B 
043A64 04 
043A65 FD      9318 LD      A,(IY)			; Fetch the next character
043A66 7E 
043A67 00 
043A68 FE      9319 CP      '('			; Check for bad use of array
043A69 28 
043A6A 20      9320 JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A6B 70 
043A6C 3E      9321 ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A6D 0E 
043A6E C3      9322 ERROR3:			JP      ERROR_
043A6F 98 
043A70 37 
043A71 04 
               9323 ;
               9324 ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
               9325 ;   Inputs: IY addresses first character.
               9326 ;  Outputs: Carry set and NZ if illegal character.
               9327 ;           Z-flag set if variable found, then:
               9328 ;            A = variable type (0,4,5,128 or 129)
               9329 ;            HL = IX = variable pointer.
               9330 ;            IY updated
               9331 ;           If Z-flag & carry reset, then:
               9332 ;            HL, IY set for subsequent PUTVAR call.
               9333 ; Destroys: everything
               9334 ;
043A72 FD      9335 GETVAR:			LD      A,(IY)			; Get the first character
043A73 7E 
043A74 00 
043A75 FE      9336 CP      '$'			; Is it a string?
043A76 24 
043A77 28      9337 JR      Z,GETV4			; Yes, so branch here
043A78 69 
043A79 FE      9338 CP      '!'			; Is it indirection (32-bit)?
043A7A 21 
043A7B 28      9339 JR      Z,GETV5			; Yes, so branch here
043A7C 69 
043A7D FE      9340 CP      '?'			; Is it indirection (8-bit)?
043A7E 3F 
043A7F 28      9341 JR      Z,GETV6			; Yes, so branch here
043A80 69 
               9342 ;
043A81 CD      9343 CALL    LOCATE			; Locate the variable
043A82 50 
043A83 3B 
043A84 04 
043A85 C0      9344 RET     NZ			; And exit here if not found
               9345 ;
               9346 ; At this point:
               9347 ;  HL: Address of variable in memory
               9348 ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
               9349 ;
043A86 FD      9350 LD      A,(IY)			; Further checks
043A87 7E 
043A88 00 
043A89 FE      9351 CP      '('             	; Is it an array?
043A8A 28 
043A8B 20      9352 JR      NZ,GETVX        	; No, so exit
043A8C 47 
               9353 ;
               9354 ; We are processing an array at this point
               9355 ;
043A8D D5      9356 PUSH    DE              	; Save the variable type (in D)
043A8E 7E      9357 LD      A,(HL)          	; Fetch the number of dimensions
043A8F B7      9358 OR      A
043A90 28      9359 JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A91 DA 
043A92 23      9360 INC     HL			;
043A93 11      9361 LD      DE,0            	; Accumulator
043A94 00 
043A95 00 
043A96 00 
043A97 F5      9362 PUSH    AF
043A98 FD      9363 INC     IY              	; Skip "("
043A99 23 
043A9A 18      9364 JR      GETV3
043A9B 05 
               9365 ;
043A9C F5      9366 GETV2:			PUSH    AF
043A9D CD      9367 CALL    COMMA
043A9E 2A 
043A9F 0A 
043AA0 04 
043AA1 E5      9368 GETV3:			PUSH    HL
043AA2 D5      9369 PUSH    DE
043AA3 CD      9370 CALL    EXPRI			; Get the subscript
043AA4 0F 
043AA5 03 
043AA6 04 
043AA7 D9      9371 EXX
043AA8 D1      9372 POP     DE
043AA9 E3      9373 EX      (SP),HL
043AAA 4E      9374 LD      C,(HL)
043AAB 23      9375 INC     HL
043AAC 46      9376 LD      B,(HL)
043AAD 23      9377 INC     HL
043AAE E3      9378 EX      (SP),HL
043AAF EB      9379 EX      DE,HL
043AB0 D5      9380 PUSH    DE
043AB1 CD      9381 CALL    MUL16			; HL=HL*BC
043AB2 A4 
043AB3 18 
043AB4 04 
043AB5 D1      9382 POP     DE
043AB6 19      9383 ADD     HL,DE
043AB7 EB      9384 EX      DE,HL
043AB8 B7      9385 OR      A
043AB9 ED      9386 SBC     HL,BC
043ABA 42 
043ABB 3E      9387 LD      A,15
043ABC 0F 
043ABD 30      9388 JR      NC,ERROR3		; Throw a "Subscript" error
043ABE AF 
043ABF E1      9389 POP     HL
043AC0 F1      9390 POP     AF
043AC1 3D      9391 DEC     A               	; Dimension counter
043AC2 20      9392 JR      NZ,GETV2
043AC3 D8 
043AC4 CD      9393 CALL    BRAKET          	; Check for closing bracket
043AC5 37 
043AC6 0A 
043AC7 04 
043AC8 F1      9394 POP     AF              	; Restore the type
043AC9 E5      9395 PUSH    HL
043ACA CD      9396 CALL    X4OR5           	; DE=DE*n
043ACB 97 
043ACC 18 
043ACD 04 
043ACE E1      9397 POP     HL
043ACF 19      9398 ADD     HL,DE
043AD0 57      9399 LD      D,A             	; The type
043AD1 FD      9400 LD      A,(IY)
043AD2 7E 
043AD3 00 
043AD4 FE      9401 GETVX:			CP      '?'
043AD5 3F 
043AD6 28      9402 JR      Z,GETV9
043AD7 1E 
043AD8 FE      9403 CP      '!'
043AD9 21 
043ADA 28      9404 JR      Z,GETV8
043ADB 16 
043ADC E5      9405 GETVZ:			PUSH    HL              	; Set exit conditions
043ADD DD      9406 POP     IX
043ADE E1 
043ADF 7A      9407 LD      A,D
043AE0 BF      9408 CP      A
043AE1 C9      9409 RET
               9410 ;
               9411 ; Process strings, unary & binary indirection:
               9412 ;
043AE2 3E      9413 GETV4:			LD      A,128           	; Static strings
043AE3 80 
043AE4 18      9414 JR      GETV7
043AE5 05 
               9415 ;
043AE6 3E      9416 GETV5:			LD      A,4             	; Unary 32-bit indirection
043AE7 04 
043AE8 18      9417 JR      GETV7
043AE9 01 
               9418 ;
043AEA AF      9419 GETV6:			XOR     A               	; Unary 8-bit indirection
               9420 ;
043AEB 21      9421 GETV7:			LD      HL,0
043AEC 00 
043AED 00 
043AEE 00 
043AEF F5      9422 PUSH    AF
043AF0 18      9423 JR      GETV0
043AF1 24 
               9424 ;
043AF2 06      9425 GETV8:			LD      B,4             	; Binary 32-bt indirection
043AF3 04 
043AF4 18      9426 JR      GETVA
043AF5 02 
               9427 ;
043AF6 06      9428 GETV9:			LD      B,0             	; Binary 8-bit indirection
043AF7 00 
               9429 ;
043AF8 E5      9430 GETVA:			PUSH    HL
043AF9 DD      9431 POP     IX
043AFA E1 
043AFB 7A      9432 LD      A,D            		; Fetch the variable type
043AFC FE      9433 CP      129			; Is it a string?
043AFD 81 
043AFE C8      9434 RET     Z               	; Yes, so exit here
043AFF C5      9435 PUSH    BC
043B00 CD      9436 CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043B01 1B 
043B02 04 
043B03 04 
043B04 CD      9437 CALL    SFIX
043B05 67 
043B06 06 
043B07 04 
043B08 7D      9438 LD	A,L
043B09 D9      9439 EXX
043B0A 22      9440 LD	(R0+0),HL
043B0B 4A 
043B0C 4D 
043B0D 04 
043B0E 32      9441 LD	(R0+2),A
043B0F 4C 
043B10 4D 
043B11 04 
043B12 2A      9442 LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B13 4A 
043B14 4D 
043B15 04 
               9443 ;
043B16 E5      9444 GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B17 FD      9445 INC     IY
043B18 23 
043B19 CD      9446 CALL    ITEMI
043B1A 2A 
043B1B 03 
043B1C 04 
043B1D 7D      9447 LD	A,L			;  A: The MSB of the address
043B1E D9      9448 EXX
043B1F 22      9449 LD	(R0+0),HL		; HL: The LSW of the address
043B20 4A 
043B21 4D 
043B22 04 
043B23 32      9450 LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B24 4C 
043B25 4D 
043B26 04 
043B27 D1      9451 POP     DE
043B28 F1      9452 POP     AF
043B29 2A      9453 LD	HL,(R0)			; HL: L'HL
043B2A 4A 
043B2B 4D 
043B2C 04 
043B2D 19      9454 ADD     HL,DE
043B2E E5      9455 PUSH    HL
043B2F DD      9456 POP     IX
043B30 E1 
043B31 BF      9457 CP      A
043B32 C9      9458 RET
               9459 ;
               9460 ;GETDEF - Find entry for FN or PROC in dynamic area.
               9461 ;   Inputs: IY addresses byte following "DEF" token.
               9462 ;  Outputs: Z flag set if found
               9463 ;           Carry set if neither FN or PROC first.
               9464 ;           If Z: HL points to entry
               9465 ;                 IY addresses delimiter
               9466 ; Destroys: A,D,E,H,L,IY,F
               9467 ;
043B33 FD      9468 GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B34 7E 
043B35 01 
043B36 CD      9469 CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B37 B3 
043B38 3C 
043B39 04 
043B3A D8      9470 RET     C			; No so return with C set
043B3B FD      9471 LD      A,(IY)			; Fetch the current character from the tokenised line
043B3C 7E 
043B3D 00 
043B3E 21      9472 LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B3F 0E 
043B40 4D 
043B41 04 
043B42 FE      9473 CP      FN			; Is it the token FN?
043B43 A4 
043B44 28      9474 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B45 4A 
043B46 21      9475 LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B47 11 
043B48 4D 
043B49 04 
043B4A FE      9476 CP      PROC			; Is it the token PROC?
043B4B F2 
043B4C 28      9477 JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B4D 42 
043B4E 37      9478 SCF				; No, so just return with C set
043B4F C9      9479 RET
               9480 ;
               9481 ; LOCATE - Try to locate variable name in static or dynamic variables.
               9482 ; If illegal first character return carry, non-zero.
               9483 ; If found, return no-carry, zero.
               9484 ; If not found, return no-carry, non-zero.
               9485 ;   Inputs: IY=Addresses first character of name.
               9486 ;            A=(IY)
               9487 ;  Outputs:  F=Z set if found, then:
               9488 ;           IY=addresses terminator
               9489 ;           HL=addresses location of variable
               9490 ;            D=type of variable: 4 = integer
               9491 ;                                5 = floating point
               9492 ;                              129 = string
               9493 ; Destroys: A,D,E,H,L,IY,F
               9494 ;
               9495 ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
               9496 ; They can contain any alphanumeric character and underscore (_)
               9497 ; String variables are postfixed with the dollar ($) character
               9498 ; Integer variables are postfixed with the percent (%) character
               9499 ; Static integer variables are named @%, A% to Z%
               9500 ; All other variables are dynamic
               9501 ;
043B50 D6      9502 LOCATE:			SUB     '@'			; Check for valid range
043B51 40 
043B52 D8      9503 RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B53 21      9504 LD      HL, 0			; Clear HL
043B54 00 
043B55 00 
043B56 00 
043B57 FE      9505 CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B58 1B 
043B59 30      9506 JR      NC,LOC0         	; Then branch here
043B5A 1E 
043B5B 6F      9507 LD	L, A			; HL = A
043B5C FD      9508 LD      A,(IY+1)        	; Check the 2nd character
043B5D 7E 
043B5E 01 
043B5F FE      9509 CP      '%'			; If not "%" then it is not static...
043B60 25 
043B61 20      9510 JR      NZ,LOC1         	; Branch here
043B62 21 
043B63 FD      9511 LD      A,(IY+2)		; Check the 3rd character
043B64 7E 
043B65 02 
043B66 FE      9512 CP      '('			; If it is "(" (array) then it is not static...
043B67 28 
043B68 28      9513 JR      Z,LOC1          	; Branch here
043B69 1A 
               9514 ;
               9515 ; At this point we're dealing with a static variable
               9516 ;
043B6A 29      9517 ADD     HL,HL			; HL: Variable index * 4
043B6B 29      9518 ADD	HL,HL
043B6C 11      9519 LD      DE,STAVAR       	; The static variable area in memory
043B6D 00 
043B6E 4C 
043B6F 04 
043B70 19      9520 ADD     HL,DE			; HL: The address of the static variable
043B71 FD      9521 INC     IY			; Skip the program pointer past the static variable name
043B72 23 
043B73 FD      9522 INC     IY
043B74 23 
043B75 16      9523 LD      D,4             	; Set the type to be integer
043B76 04 
043B77 AF      9524 XOR     A			; Set the Z flag
043B78 C9      9525 RET
               9526 ;
               9527 ; At this point it's potentially a dynamic variable, just need to do a few more checks
               9528 ;
043B79 FE      9529 LOC0:			CP      '_'-'@'			; Check the first character is in
043B7A 1F 
043B7B D8      9530 RET     C			; the range "_" to
043B7C FE      9531 CP      'z'-'@'+1		; "z" (lowercase characters only)
043B7D 3B 
043B7E 3F      9532 CCF				; If it is not in range then
043B7F 3D      9533 DEC     A               	; Set NZ flag and
043B80 D8      9534 RET     C			; Exit here
043B81 D6      9535 SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B82 03 
043B83 6F      9536 LD	L, A			; HL = A
               9537 ;
               9538 ; Yes, it's definitely a dynamic variable at this point...
               9539 ;
043B84 7D      9540 LOC1:			LD	A, L			; Fetch variable index
043B85 87      9541 ADD	A, A			; x 2
043B86 85      9542 ADD	A, L			; x 3
043B87 D6      9543 SUB	3			; Subtract 2 TODO: Should be 3
043B88 03 
043B89 6F      9544 LD	L, A
043B8A 11      9545 LD      DE, DYNVAR       	; The dynamic variable storage
043B8B 6C 
043B8C 4C 
043B8D 04 
043B8E D8      9546 RET	C			; Bounds check to trap for variable '@'
043B8F 19      9547 ADD     HL, DE			; HL: Address of first entry
               9548 ;
               9549 ; Loop through the linked list of variables to find a match
               9550 ;
043B90 ED      9551 LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B91 17 
043B92 E5      9552 PUSH	HL			; Need to preserve HL for LOC6
043B93 AF      9553 XOR	A			; Reset carry flag
043B94 ED      9554 SBC	HL, HL			; Set HL to 0
043B95 62 
043B96 ED      9555 SBC	HL, DE			; Compare with 0
043B97 52 
043B98 E1      9556 POP	HL			; Restore the original pointer
043B99 28      9557 JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B9A 49 
               9558 ; LD	HL, DE			; Make a copy of this pointer in HL
043B9B D5      9559 push de
043B9C E1      9560 pop hl ; how was that even possible?
043B9D 23      9561 INC     HL              	; Skip the link (24-bits)
043B9E 23      9562 INC     HL
043B9F 23      9563 INC	HL			; HL: Address of the variable name in DYNVARS
043BA0 FD      9564 PUSH    IY			; IY: Address of the variable name in the program
043BA1 E5 
               9565 ;
043BA2 7E      9566 LOC3:			LD      A,(HL)         		; Compare
043BA3 23      9567 INC     HL
043BA4 FD      9568 INC     IY
043BA5 23 
043BA6 FD      9569 CP      (IY)
043BA7 BE 
043BA8 00 
043BA9 28      9570 JR      Z, LOC3			; Keep looping whilst we've got a match...
043BAA F7 
043BAB B7      9571 OR      A               	; Have we hit a terminator?
043BAC 28      9572 JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BAD 07 
               9573 ;
043BAE FD      9574 LOC4:			POP     IY			; Restore the pointer in the program
043BAF E1 
043BB0 EB      9575 EX      DE, HL			; HL: New pointer in DYNVARS
043BB1 C3      9576 JP      LOC2            	; Loop round and try again
043BB2 90 
043BB3 3B 
043BB4 04 
               9577 ;
               9578 ; We might have located a variable at this point, just need to do a few more tests
               9579 ;
043BB5 FD      9580 LOC5:			DEC     IY
043BB6 2B 
043BB7 FD      9581 LD      A,(IY)
043BB8 7E 
043BB9 00 
043BBA FE      9582 CP      '('
043BBB 28 
043BBC 28      9583 JR      Z,LOC5A         	; FOUND
043BBD 15 
043BBE FD      9584 INC     IY
043BBF 23 
043BC0 CD      9585 CALL    RANGE
043BC1 A7 
043BC2 3C 
043BC3 04 
043BC4 38      9586 JR      C,LOC5A         	; FOUND
043BC5 0D 
043BC6 FE      9587 CP      '('
043BC7 28 
043BC8 28      9588 JR      Z,LOC4          	; KEEP LOOKING
043BC9 E4 
043BCA FD      9589 LD      A,(IY-1)
043BCB 7E 
043BCC FF 
043BCD CD      9590 CALL    RANGE1
043BCE B3 
043BCF 3C 
043BD0 04 
043BD1 30      9591 JR      NC,LOC4         	; KEEP LOOKING
043BD2 DB 
043BD3 D1      9592 LOC5A:			POP     DE
043BD4 FD      9593 TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BD5 7E 
043BD6 FF 
043BD7 FE      9594 CP      '$'			; Is it a string?
043BD8 24 
043BD9 16      9595 LD      D,129			; Yes, so return D = 129
043BDA 81 
043BDB C8      9596 RET     Z
043BDC FE      9597 CP      '%'			; Is it an integer?
043BDD 25 
043BDE 16      9598 LD      D,4			; Yes, so return D = 4
043BDF 04 
043BE0 C8      9599 RET     Z
043BE1 14      9600 INC     D			; At this point it must be a float
043BE2 BF      9601 CP      A			; Set the flags
043BE3 C9      9602 RET
               9603 ;
               9604 ; The variable is undefined at this point; HL will be zero
               9605 ;
043BE4 3C      9606 LOC6:			INC     A               	; Set NZ flag
043BE5 C9      9607 RET
               9608 ;
               9609 ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
               9610 ;   Inputs: HL, IY as returned from LOCATE (NZ).
               9611 ;  Outputs: As LOCATE, GETDEF.
               9612 ; Destroys: As LOCATE, GETDEF.
               9613 ;
043BE6 AF      9614 CREATE:			XOR     A
043BE7 ED      9615 LD      DE,(FREE)		; Get the last byte of available RAM
043BE8 5B 
043BE9 1D 
043BEA 4D 
043BEA 04   
043BEC ED      9616 LD	(HL), DE		; Store
043BED 1F 
043BEE EB      9617 EX      DE,HL
043BEF 77      9618 LD      (HL),A			; Clear the link of the new entity
043BF0 23      9619 INC     HL
043BF1 77      9620 LD      (HL),A
043BF2 23      9621 INC     HL
043BF3 77      9622 LD      (HL),A
043BF4 23      9623 INC     HL
043BF5 FD      9624 LOC7:			INC     IY
043BF6 23 
043BF7 CD      9625 CALL    RANGE           	; END OF VARIABLE?
043BF8 A7 
043BF9 3C 
043BFA 04 
043BFB 38      9626 JR      C,LOC8
043BFC 15 
043BFD 77      9627 LD      (HL),A
043BFE 23      9628 INC     HL
043BFF CD      9629 CALL    RANGE1
043C00 B3 
043C01 3C 
043C02 04 
043C03 30      9630 JR      NC,LOC7
043C04 F0 
043C05 FE      9631 CP      '('
043C06 28 
043C07 28      9632 JR      Z,LOC8
043C08 09 
043C09 FD      9633 LD      A,(IY+1)
043C0A 7E 
043C0B 01 
043C0C FE      9634 CP      '('
043C0D 28 
043C0E 28      9635 JR      Z,LOC7
043C0F E5 
043C10 FD      9636 INC     IY
043C11 23 
043C12 36      9637 LOC8:			LD      (HL),0          	; TERMINATOR
043C13 00 
043C14 23      9638 INC     HL
043C15 E5      9639 PUSH    HL
043C16 CD      9640 CALL    TYPE_			; Get the variable type in D
043C17 D4 
043C18 3B 
043C19 04 
043C1A 3E      9641 LD      A,4			; If it is an integer then it takes up 4 bytes
043C1B 04 
043C1C BA      9642 CP      D
043C1D 28      9643 JR      Z,LOC9			; So skip the next bit
043C1E 01 
043C1F 3C      9644 INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C20 36      9645 LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C21 00 
043C22 23      9646 INC     HL
043C23 3D      9647 DEC     A
043C24 20      9648 JR      NZ,LOC9
043C25 FA 
043C26 22      9649 LD      (FREE),HL		; Adjust the stack
043C27 1D 
043C28 4D 
043C29 04 
043C2A CD      9650 CALL    CHECK			; Check whether we are out of space
043C2B 81 
043C2C 16 
043C2D 04 
043C2E E1      9651 POP     HL
043C2F AF      9652 XOR     A
043C30 C9      9653 RET
               9654 ;
               9655 ; LINNUM - GET LINE NUMBER FROM TEXT STRING
               9656 ;   Inputs: IY = Text Pointer
               9657 ;  Outputs: HL = Line number (zero if none)
               9658 ;           IY updated
               9659 ; Destroys: A,D,E,H,L,IY,F
               9660 ;
               9661 ; This bit of code performs a BASE 10 shift to build up the number
               9662 ; So if the string passed is "345", the algorithm does this:
               9663 ;
               9664 ;    HL : Digit	: Operation
               9665 ; ----- : ----- : ---------
               9666 ; 00000 :	:
               9667 ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
               9668 ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
               9669 ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
               9670 ;
               9671 ; The multiply by 10 is done by an unrolled shift and add loop
               9672 ;
043C31 CD      9673 LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C32 78 
043C33 0A 
043C34 04 
043C35 40      9674 LD.SIS  HL,0			; The running total
043C36 21 
043C37 00 
043C38 00 
043C39 FD      9675 LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C3A 7E 
043C3B 00 
043C3C D6      9676 SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C3D 30 
043C3E D8      9677 RET     C			; And return if less than 0
043C3F FE      9678 CP      10			; Or greater than or equal to 10
043C40 0A 
043C41 D0      9679 RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C42 FD      9680 INC     IY			; Increment the string pointer
043C43 23 
043C44 54      9681 LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C45 5D      9682 LD      E,L			; Store the original number in DE
043C46 52      9683 ADD.S   HL,HL           	; *2
043C47 29 
043C48 38      9684 JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C49 13 
043C4A 52      9685 ADD.S   HL,HL           	; *4S
043C4B 29 
043C4C 38      9686 JR      C,TOOBIG
043C4D 0F 
043C4E 52      9687 ADD.S   HL,DE           	; *5
043C4F 19 
043C50 38      9688 JR      C,TOOBIG
043C51 0B 
043C52 52      9689 ADD.S   HL,HL           	; *10
043C53 29 
043C54 38      9690 JR      C,TOOBIG
043C55 07 
043C56 5F      9691 LD      E,A			; A->DE: the digit to add in
043C57 16      9692 LD      D,0
043C58 00 
043C59 52      9693 ADD.S   HL,DE           	; Add in the digit to the running total
043C5A 19 
043C5B 30      9694 JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C5C DC 
               9695 ;
043C5D 3E      9696 TOOBIG:			LD      A,20
043C5E 14 
043C5F C3      9697 JP      ERROR_           	; Error: "Too big"
043C60 98 
043C61 37 
043C62 04 
               9698 ;
               9699 ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
               9700 ;   Inputs: IY = text pointer
               9701 ;  Outputs: HL = first number (10 by default)
               9702 ;           BC = second number (10 by default)
               9703 ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
               9704 ;
043C63 CD      9705 PAIR:			CALL    LINNUM          	; Parse the first line number
043C64 31 
043C65 3C 
043C66 04 
043C67 7C      9706 LD      A,H			; If it is not zero, then...
043C68 B5      9707 OR      L
043C69 20      9708 JR      NZ,PAIR1		; Skip...
043C6A 02 
043C6B 2E      9709 LD      L,10			; HL: the default value (10)
043C6C 0A 
               9710 ;
043C6D CD      9711 PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C6E AC 
043C6F 17 
043C70 04 
043C71 FD      9712 INC     IY			; Skip to next character
043C72 23 
043C73 E5      9713 PUSH    HL			; Stack the first line number
043C74 21      9714 LD      HL,10			; HL: the second default (10)
043C75 0A 
043C76 00 
043C77 00 
043C78 C4      9715 CALL    NZ,LINNUM       	; Parse the second line number
043C79 31 
043C7A 3C 
043C7B 04 
043C7C E3      9716 EX      (SP),HL			; HL: The first line number (off the stack)
043C7D C1      9717 POP     BC			; BC: Second line number
043C7E 78      9718 LD      A,B			; If the second line number is not zero then...
043C7F B1      9719 OR      C			; We're good...
043C80 C0      9720 RET     NZ			; Exit, otherwise...
043C81 CD      9721 CALL    EXTERR			; Throw error: "Silly"
043C82 AF 
043C83 37 
043C84 04 
043C85 53      9722 DB    	"Silly", 0
043C86 69 
043C87 6C 
043C88 6C 
043C88 79   
043C89 00 
               9723 ;
               9724 ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
               9725 ;   Inputs: IY = text pointer
               9726 ;  Outputs: HL = points to program text
               9727 ;           BC = second number (0 by default)
               9728 ; Destroys: A,B,C,D,E,H,L,IY,F
               9729 ;
043C8B CD      9730 DLPAIR:			CALL    LINNUM			; Parse the first line number
043C8C 31 
043C8D 3C 
043C8E 04 
043C8F E5      9731 PUSH    HL			; Stack it
043C90 CD      9732 CALL    TERMQ			; Check for ELSE, : or CR
043C91 AC 
043C92 17 
043C93 04 
043C94 28      9733 JR      Z,DLP1			; And exit if so
043C95 0A 
043C96 FE      9734 CP      TIF			; Is the token IF?
043C97 E7 
043C98 28      9735 JR      Z,DLP1			; Yes, so skip the next bit...
043C99 06 
043C9A FD      9736 INC     IY			; Otherwise...
043C9B 23 
043C9C CD      9737 CALL    LINNUM			; Fetch the second line number
043C9D 31 
043C9E 3C 
043C9F 04 
043CA0 E3      9738 DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043CA1 CD      9739 CALL    FINDL			; HL: Find the address of the line
043CA2 C7 
043CA3 39 
043CA4 04 
043CA5 C1      9740 POP     BC			; BC: The second number
043CA6 C9      9741 RET
               9742 ;
               9743 ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
               9744 ;   Inputs: IY addresses character
               9745 ;  Outputs: Carry set if out-of-range.
               9746 ; Destroys: A,F
               9747 ;
               9748 ; It is called here to check the following
               9749 ; In range: "$", "%" and "("
               9750 ;   Plus all characters in RANGE1 and RANGE2
               9751 ;
043CA7 FD      9752 RANGE:			LD      A,(IY)			; Fetch the character
043CA8 7E 
043CA9 00 
043CAA FE      9753 CP      '$'			; Postfix for string variable is valid
043CAB 24 
043CAC C8      9754 RET     Z
043CAD FE      9755 CP      '%'			; Postfix for integer variable is valid
043CAE 25 
043CAF C8      9756 RET     Z
043CB0 FE      9757 CP      '('			; Postfix for array is valid
043CB1 28 
043CB2 C8      9758 RET     Z
               9759 ;
               9760 ; It is called here to check the following
               9761 ; In range: "0" to "9" and "@"
               9762 ;   Plus all characters in RANGE2
               9763 ;
043CB3 FE      9764 RANGE1:			CP      '0'			; If it is between '0'...
043CB4 30 
043CB5 D8      9765 RET     C
043CB6 FE      9766 CP      '9'+1			; And '9'...
043CB7 3A 
043CB8 3F      9767 CCF
043CB9 D0      9768 RET     NC			; Then it is valid
043CBA FE      9769 CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CBB 40 
043CBC C8      9770 RET     Z
               9771 ;
               9772 ; It is called here to check the following
               9773 ; In range: "A" to "Z", "a' to "z", "_" and "`"
               9774 ;
043CBD FE      9775 RANGE2:			CP      'A'			; If it is between 'A'...
043CBE 41 
043CBF D8      9776 RET     C
043CC0 FE      9777 CP      'Z'+1			; And 'Z'...
043CC1 5B 
043CC2 3F      9778 CCF
043CC3 D0      9779 RET     NC			; Then it is valid
043CC4 FE      9780 CP      '_'			; If it is underscore, grave, or between 'a'
043CC5 5F 
043CC6 D8      9781 RET     C
043CC7 FE      9782 CP      'z'+1			; And 'z'
043CC8 7B 
043CC9 3F      9783 CCF				; Then it is valid
043CCA C9      9784 RET
               9785 ;
               9786 ; Throw a 'LINE space' error (line too long)
               9787 ; This is called from LEXAN
               9788 ;
043CCB AF      9789 SPACE_: 		XOR     A
043CCC CD      9790 CALL    EXTERR          	; "LINE space"
043CCD AF 
043CCE 37 
043CCF 04 
043CD0 86      9791 DB    	LINE_MN_, 8, 0
043CD1 08 
043CD2 00 
               9792 ;
               9793 ; LEXAN - LEXICAL ANALYSIS.
               9794 ;  Bit 0,C: 1=left, 0=right
               9795 ;  Bit 2,C: 1=in BINARY
               9796 ;  Bit 3,C: 1=in HEX
               9797 ;  Bit 4,C: 1=accept line number
               9798 ;  Bit 5,C: 1=in variable, FN, PROC
               9799 ;  Bit 6,C: 1=in REM, DATA, *
               9800 ;  Bit 7,C: 1=in quotes
               9801 ;   Inputs: IY addresses source string
               9802 ;           DE addresses destination string (must be page boundary)
               9803 ;            C sets initial mode
               9804 ;  Outputs: DE, IY updated
               9805 ;            A holds carriage return
               9806 ;
043CD3 12      9807 LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CD4 13      9808 INC     DE              	; Increment the pointers
043CD5 FD      9809 INC     IY			; And fall through to the main function
043CD6 23 
               9810 ;
               9811 ; This is the main entry point
               9812 ;
043CD7 7B      9813 LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CD8 FE      9814 CP      252             	; If it is >= 252 bytes, then...
043CD9 FC 
043CDA 30      9815 JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CDB EF 
043CDC FD      9816 LD      A,(IY)			; Fetch character from source string
043CDD 7E 
043CDE 00 
043CDF FE      9817 CP      CR			; If it is a CR
043CE0 0D 
043CE1 C8      9818 RET     Z               	; Then it is end of line; we're done parsing
043CE2 CD      9819 CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CE3 B3 
043CE4 3C 
043CE5 04 
043CE6 30      9820 JR      NC,LEXAN3		; Yes, so skip
043CE7 06 
043CE8 CB      9821 RES     5,C             	; FLAG: NOT IN VARIABLE
043CE9 A9 
043CEA CB      9822 RES     3,C             	; FLAG: NOT IN HEX
043CEB 99 
043CEC CB      9823 RES	2,C			; FLAG: NOT IN BINARY
043CED 91 
               9824 ;
043CEE FE      9825 LEXAN3:			CP      ' '			; Ignore spaces
043CEF 20 
043CF0 28      9826 JR      Z,LEXAN1
043CF1 E1 
043CF2 FE      9827 CP      ','			; Ignore commas
043CF3 2C 
043CF4 28      9828 JR      Z,LEXAN1
043CF5 DD 
043CF6 FE      9829 CP	'2'			; If less than '2'
043CF7 32 
043CF8 30      9830 JR	NC, @F			; No, so skip
043CF9 02 
043CFA CB      9831 RES	2,C			; FLAG: NOT IN BINARY
043CFB 91 
043CFC FE      9832 @@:			CP      'G'			; If less then 'G'
043CFD 47 
043CFE 38      9833 JR      C,LEXAN4		; Yes, so skip
043CFF 02 
043D00 CB      9834 RES     3,C             	; FLAG: NOT IN HEX
043D01 99 
               9835 ;
043D02 FE      9836 LEXAN4:			CP      34			; Is it a quote character?
043D03 22 
043D04 20      9837 JR      NZ,LEXAN5		; No, so skip
043D05 05 
043D06 CB      9838 RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D07 11 
043D08 3F      9839 CCF                     	; Toggle the carry
043D09 CB      9840 RR      C			; And then shifting it back into bit 7 of C
043D0A 19 
               9841 ;
043D0B CB      9842 LEXAN5:			BIT     4,C			; Accept line number?
043D0C 61 
043D0D 28      9843 JR      Z,LEXAN6		; No, so skip
043D0E 12 
043D0F CB      9844 RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D10 A1 
043D11 C5      9845 PUSH    BC
043D12 D5      9846 PUSH    DE
043D13 CD      9847 CALL    LINNUM         		; Parse the line number to HL
043D14 31 
043D15 3C 
043D16 04 
043D17 D1      9848 POP     DE
043D18 C1      9849 POP     BC
043D19 7C      9850 LD      A,H			; If it is not zero
043D1A B5      9851 OR      L
043D1B C4      9852 CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D1C 94 
043D1D 3D 
043D1E 04 
043D1F 18      9853 JR      LEXAN2          	; And loop
043D20 B6 
               9854 ;
043D21 0D      9855 LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D22 28      9856 JR      Z,LEXAN7        	; If so, skip
043D23 0A 
043D24 0C      9857 INC     C			; Otherwise restore C
043D25 20      9858 JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D26 AC 
043D27 B7      9859 OR      A			; Set the flags based on the character
043D28 F4      9860 CALL    P,LEX           	; Tokenise if A < 128
043D29 FF 
043D2A 37 
043D2B 04 
043D2C 18      9861 JR      LEXAN8			; And skip
043D2D 13 
               9862 ;
               9863 ; Processing the LEFT hand side here
               9864 ;
043D2E FE      9865 LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D2F 2A 
043D30 28      9866 JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D31 17 
043D32 B7      9867 OR      A			; Set the flags based on the character
043D33 F4      9868 CALL    P,LEX           	; Tokenise if A < 128
043D34 FF 
043D35 37 
043D36 04 
               9869 ;
               9870 ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
               9871 ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
               9872 ; Examples:
               9873 ;   LET A% = PAGE : REM This is the GET version
               9874 ;   PAGE = 40000  : REM This is the SET version
               9875 ;
043D37 FE      9876 CP      TOKLO			; TOKLO is 8Fh
043D38 8F 
043D39 38      9877 JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D3A 06 
043D3B FE      9878 CP      TOKHI+1			; TOKHI is 93h
043D3C 94 
043D3D 30      9879 JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D3E 02 
043D3F C6      9880 ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D40 40 
               9881 ;
043D41 FE      9882 LEXAN8:			CP      REM			; If the token is REM
043D42 F4 
043D43 28      9883 JR      Z,LEXAN9		; Then stop tokenising
043D44 04 
043D45 FE      9884 CP      DATA_MN_			; If it is not DATA then
043D46 DC 
043D47 20      9885 JR      NZ,LEXANA		; Skip
043D48 02 
043D49 CB      9886 LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D4A F1 
               9887 ;
043D4B FE      9888 LEXANA:			CP      FN			; If the token is FN
043D4C A4 
043D4D 28      9889 JR      Z,LEXANB
043D4E 0A 
043D4F FE      9890 CP      PROC			; Or the token is PROC
043D50 F2 
043D51 28      9891 JR      Z,LEXANB		; Then jump to here
043D52 06 
043D53 CD      9892 CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D54 BD 
043D55 3C 
043D56 04 
043D57 38      9893 JR      C,LEXANC		; Jump here if out of range
043D58 02 
               9894 ;
043D59 CB      9895 LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D5A E9 
043D5B FE      9896 LEXANC:			CP      '&'			; Check for hex prefix
043D5C 26 
043D5D 20      9897 JR      NZ,LEXAND		; If not, skip
043D5E 02 
043D5F CB      9898 SET     3,C             	; FLAG: IN HEX
043D60 D9 
               9899 ;
043D61 FE      9900 LEXAND:			CP	'%'			; Check for binary prefix
043D62 25 
043D63 20      9901 JR	NZ,LEXANE		; If not, skip
043D64 02 
043D65 CB      9902 SET	2,C			; FLAG: IN BINARY
043D66 D1 
               9903 ;
043D67 21      9904 LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D68 8B 
043D69 3D 
043D6A 04 
043D6B C5      9905 PUSH    BC
043D6C 01      9906 LD      BC,LIST1L		; The list length
043D6D 06 
043D6E 00 
043D6F 00 
043D70 ED      9907 CPIR				; Check if the token is in this list
043D71 B1 
043D72 C1      9908 POP     BC
043D73 20      9909 JR      NZ,LEXANF		; If not, then skip
043D74 02 
043D75 CB      9910 SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D76 E1 
               9911 ;
043D77 21      9912 LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D78 8F 
043D79 3D 
043D7A 04 
043D7B C5      9913 PUSH    BC
043D7C 01      9914 LD      BC,LIST2L		; The list length
043D7D 05 
043D7E 00 
043D7F 00 
043D80 ED      9915 CPIR				; Check if the token is in this list
043D81 B1 
043D82 C1      9916 POP     BC
043D83 20      9917 JR      NZ,LEXANG		; If not, then skip
043D84 02 
043D85 CB      9918 SET     0,C             	; FLAG: ENTER LEFT MODE
043D86 C1 
043D87 C3      9919 LEXANG:			JP      LEXAN1			; And loop
043D88 D3 
043D89 3C 
043D8A 04 
               9920 
               9921 ;
               9922 ; LIST1: List of tokens that must be followed by line numbers
               9923 ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
               9924 ;
043D8B E5      9925 LIST1:			DB	GOTO
043D8C E4      9926 DB	GOSUB
043D8D F7      9927 DB	RESTOR
043D8E FC      9928 DB	TRACE
043D8F 8C      9929 LIST2:			DB	THEN_MN_
043D90 8B      9930 DB	ELSE_MN_
               9931 LIST1L:			EQU     $-LIST1
043D91 F5      9932 DB	REPEAT
043D92 85      9933 DB	TERROR_MN
043D93 3A      9934 DB    	':'
               9935 LIST2L:			EQU     $-LIST2
               9936 ;
               9937 ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
               9938 ;   Inputs: HL=line number, DE=string pointer
               9939 ;  Outputs: DE updated, BIT 4,C set.
               9940 ; Destroys: A,B,C,D,E,F
               9941 ;
               9942 ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
               9943 ;
               9944 ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
               9945 ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
               9946 ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
               9947 ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
               9948 ; each byte are then stored, in LO/HI order, ORred with 0x40.
               9949 ;
043D94 CB      9950 ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D95 E1 
043D96 EB      9951 EX      DE, HL			; HL: string pointer, DE: line number
043D97 36      9952 LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D98 8D 
043D99 23      9953 INC     HL
043D9A 7A      9954 LD      A,D			; Get the high byte
043D9B E6      9955 AND     0C0H			; Get the top two bits	DD000000
043D9C C0 
043D9D 0F      9956 RRCA				; Shift right		00DD0000
043D9E 0F      9957 RRCA
043D9F 47      9958 LD      B,A			; Store in B
043DA0 7B      9959 LD      A,E			; Get the low byte
043DA1 E6      9960 AND     0C0H			; Get the top two bits	EE000000
043DA2 C0 
043DA3 B0      9961 OR      B			; Combine with D	EEDD0000
043DA4 0F      9962 RRCA				; Shift right		00EEDD00
043DA5 0F      9963 RRCA
043DA6 EE      9964 XOR     01010100B		; XOR with 54h
043DA7 54 
043DA8 77      9965 LD      (HL),A			; Store this as the second byte
043DA9 23      9966 INC     HL
043DAA 7B      9967 LD      A,E			; Get the low byte
043DAB E6      9968 AND     3FH			; Strip the top two bits off
043DAC 3F 
043DAD F6      9969 OR      '@'			; OR with 40h
043DAE 40 
043DAF 77      9970 LD      (HL),A			; Store
043DB0 23      9971 INC     HL
043DB1 7A      9972 LD      A,D			; Get the high byte
043DB2 E6      9973 AND     3FH			; Strip the top two bits off
043DB3 3F 
043DB4 F6      9974 OR      '@'			; OR with 40h
043DB5 40 
043DB6 77      9975 LD      (HL),A			; Store
043DB7 23      9976 INC     HL
043DB8 EB      9977 EX      DE,HL			; DE: string pointer, HL: line number
043DB9 C9      9978 RET
               9979 ;
               9980 ; TEXT - OUTPUT MESSAGE.
               9981 ;   Inputs: HL addresses text (terminated by nul)
               9982 ;  Outputs: HL addresses character following nul.
               9983 ; Destroys: A,H,L,F
               9984 ;
043DBA 2A      9985 REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DBB 2F 
043DBC 4D 
043DBD 04 
               9986 ;
043DBE 7E      9987 TEXT_:			LD      A, (HL)			; Fetch the character
043DBF 23      9988 INC     HL			; Increment pointer to next character
043DC0 B7      9989 OR      A			; Check for the nul (0) string terminator
043DC1 C8      9990 RET     Z			; And return if so
043DC2 CD      9991 CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DC3 A4 
043DC4 39 
043DC5 04 
043DC6 18      9992 JR      TEXT_			; And loop
043DC7 F6 
               9993 ;
               9994 ; TELL - OUTPUT MESSAGE.
               9995 ;   Inputs: Text follows subroutine call (term=nul)
               9996 ; Destroys: A,F
               9997 ;
               9998 ; Example usage:
               9999 ;
              10000 ;	CALL	TELL			Call the function
              10001 ;	DB	"Hello World", 0	Followed by a zero terminated string
              10002 ;	LD	A, (1234H)		Program execution will carry on here after the message is output
              10003 ;
043DC8 E3     10004 TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DC9 CD     10005 CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DCA BE 
043DCB 3D 
043DCC 04 
043DCD E3     10006 EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DCE C9     10007 RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
              10008 
              10009 ; --- Begin misc.asm ---
              10010 ;
              10011 ; Title:	BBC Basic for AGON - Miscellaneous helper functions
              10012 ; Author:	Dean Belfield
              10013 ; Created:	12/05/2023
              10014 ; Last Updated:	12/05/2023
              10015 ;
              10016 ; Modinfo:
              10017 
              10018 ; INCLUDE	"equs.inc"
              10019 ; INCLUDE	"macros.inc"
              10020 
              10021 ; .ASSUME	ADL = 1
              10022 
              10023 ; SEGMENT CODE
              10024 
              10025 ; XDEF	ASC_TO_NUMBER
              10026 ; XDEF	SWITCH_A
              10027 ; XDEF	NULLTOCR
              10028 ; XDEF	CRTONULL
              10029 ; XDEF	CSTR_FNAME
              10030 ; XDEF	CSTR_LINE
              10031 ; XDEF	CSTR_FINDCH
              10032 ; XDEF	CSTR_ENDSWITH
              10033 ; XDEF	CSTR_CAT
              10034 
              10035 ; XREF	OSWRCH
              10036 ; XREF	KEYWDS
              10037 ; XREF	KEYWDL
              10038 
              10039 ; Read a number and convert to binary
              10040 ; If prefixed with &, will read as hex, otherwise decimal
              10041 ;   Inputs: HL: Pointer in string buffer
              10042 ;  Outputs: HL: Updated text pointer
              10043 ;           DE: Value
              10044 ;            A: Terminator (spaces skipped)
              10045 ; Destroys: A,D,E,H,L,F
              10046 ;
043DCF C5     10047 ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DD0 11     10048 LD	DE, 0			; Initialise DE
043DD1 00 
043DD2 00 
043DD3 00 
043DD4 CD     10049 CALL	SKIPSPC			; Skip whitespace
043DD5 16 
043DD6 3E 
043DD7 04 
043DD8 7E     10050 LD	A, (HL)			; Read first character
043DD9 FE     10051 CP	'&'			; Is it prefixed with '&' (HEX number)?
043DDA 26 
043DDB 20     10052 JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DDC 1F 
043DDD 23     10053 INC	HL			; Otherwise fall through to ASC_TO_HEX
              10054 ;
043DDE 7E     10055 ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DDF CD     10056 CALL    UPPERC			; Convert to uppercase
043DE0 24 
043DE1 3E 
043DE2 04 
043DE3 D6     10057 SUB	'0'			; Normalise to 0
043DE4 30 
043DE5 38     10058 JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DE6 2E 
043DE7 FE     10059 CP 	10			; Check if >= 10
043DE8 0A 
043DE9 38     10060 JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DEA 06 
043DEB D6     10061 SUB 	7			; Adjust ASCII A-F to nibble
043DEC 07 
043DED FE     10062 CP 	16			; Check for > F
043DEE 10 
043DEF 30     10063 JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DF0 24 
043DF1 EB     10064 ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DF2 29     10065 ADD	HL, HL
043DF3 29     10066 ADD	HL, HL
043DF4 29     10067 ADD	HL, HL
043DF5 29     10068 ADD	HL, HL
043DF6 EB     10069 EX	DE, HL
043DF7 B3     10070 OR      E			; OR the new digit in to the least significant nibble
043DF8 5F     10071 LD      E, A
043DF9 23     10072 INC     HL			; Onto the next character
043DFA 18     10073 JR      ASC_TO_NUMBER1		; And loop
043DFB E2 
              10074 ;
043DFC 7E     10075 ASC_TO_NUMBER3:		LD	A, (HL)
043DFD D6     10076 SUB	'0'			; Normalise to 0
043DFE 30 
043DFF 38     10077 JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E00 14 
043E01 FE     10078 CP	10			; Check if >= 10
043E02 0A 
043E03 30     10079 JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043E04 10 
043E05 EB     10080 EX 	DE, HL 			; Stick DE in HL
043E06 44     10081 LD	B, H 			; And copy HL into BC
043E07 4D     10082 LD	C, L
043E08 29     10083 ADD	HL, HL 			; x 2
043E09 29     10084 ADD	HL, HL 			; x 4
043E0A 09     10085 ADD	HL, BC 			; x 5
043E0B 29     10086 ADD	HL, HL 			; x 10
043E0C EB     10087 EX	DE, HL
              10088 ADD8U_DE 			; Add A to DE (macro)
043E0D 83     0001M ADD	A, E
043E0E 5F     0002M LD	E, A
043E0F 8A     0003M ADC	A, D
043E10 93     0004M SUB	E
043E11 57     0005M LD	D, A
043E12 23     10089 INC	HL
043E13 18     10090 JR	ASC_TO_NUMBER3
043E14 E7 
043E15 C1     10091 ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
              10092 
              10093 ; Skip a space
              10094 ; HL: Pointer in string buffer
              10095 ;
043E16 7E     10096 SKIPSPC:			LD      A, (HL)
043E17 FE     10097 CP      ' '
043E18 20 
043E19 C0     10098 RET     NZ
043E1A 23     10099 INC     HL
043E1B 18     10100 JR      SKIPSPC
043E1C F9 
              10101 
              10102 ; Skip a string
              10103 ; HL: Pointer in string buffer
              10104 ;
043E1D 7E     10105 SKIPNOTSP:		LD	A, (HL)
043E1E FE     10106 CP	' '
043E1F 20 
043E20 C8     10107 RET	Z
043E21 23     10108 INC	HL
043E22 18     10109 JR	SKIPNOTSP
043E23 F9 
              10110 
              10111 ; Convert a character to upper case
              10112 ;  A: Character to convert
              10113 ;
043E24 E6     10114 UPPERC:  		AND     7FH
043E25 7F 
043E26 FE     10115 CP      '`'
043E27 60 
043E28 D8     10116 RET     C
043E29 E6     10117 AND     5FH			; Convert to upper case
043E2A 5F 
043E2B C9     10118 RET
              10119 
              10120 ; Switch on A - lookup table immediately after call
              10121 ;  A: Index into lookup table
              10122 ;
043E2C E3     10123 SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E2D 87     10124 ADD	A, A			; Multiply A by two
              10125 ADD8U_HL 			; Add to HL (macro)
043E2E 85     0001M ADD	A, L
043E2F 6F     0002M LD	L, A
043E30 8C     0003M ADC	A, H
043E31 95     0004M SUB	L
043E32 67     0005M LD	H, A
043E33 7E     10126 LD	A, (HL)			; follow the call. Fetch an address from the
043E34 23     10127 INC	HL 			; table.
043E35 66     10128 LD	H, (HL)
043E36 6F     10129 LD	L, A
043E37 E3     10130 EX	(SP), HL		; Swap this new address back, restores HL
043E38 C9     10131 RET				; Return program control to this new address
              10132 
              10133 ; Convert the buffer to a null terminated string and back
              10134 ; HL: Buffer address
              10135 ;
043E39 C5     10136 NULLTOCR:		PUSH 	BC
043E3A 06     10137 LD	B, 0
043E3B 00 
043E3C 0E     10138 LD	C, CR
043E3D 0D 
043E3E 18     10139 JR	CRTONULL0
043E3F 05 
              10140 ;
043E40 C5     10141 CRTONULL:		PUSH	BC
043E41 06     10142 LD	B, CR
043E42 0D 
043E43 0E     10143 LD	C, 0
043E44 00 
              10144 ;
043E45 E5     10145 CRTONULL0:		PUSH	HL
043E46 7E     10146 CRTONULL1:		LD	A, (HL)
043E47 B8     10147 CP 	B
043E48 28     10148 JR	Z, CRTONULL2
043E49 03 
043E4A 23     10149 INC	HL
043E4B 18     10150 JR	CRTONULL1
043E4C F9 
043E4D 71     10151 CRTONULL2:		LD	(HL), C
043E4E E1     10152 POP 	HL
043E4F C1     10153 POP	BC
043E50 C9     10154 RET
              10155 
              10156 ; Copy a filename to DE and zero terminate it
              10157 ; HL: Source
              10158 ; DE: Destination (ACCS)
              10159 ;
043E51 7E     10160 CSTR_FNAME:		LD	A, (HL)			; Get source
043E52 FE     10161 CP	32			; Is it space
043E53 20 
043E54 28     10162 JR	Z, @F
043E55 09 
043E56 FE     10163 CP	CR			; Or is it CR
043E57 0D 
043E58 28     10164 JR	Z, @F
043E59 05 
043E5A 12     10165 LD	(DE), A			; No, so store
043E5B 23     10166 INC	HL			; Increment
043E5C 13     10167 INC	DE
043E5D 18     10168 JR	CSTR_FNAME		; And loop
043E5E F2 
043E5F AF     10169 @@:			XOR	A			; Zero terminate the target string
043E60 12     10170 LD	(DE), A
043E61 13     10171 INC	DE			; And point to next free address
043E62 C9     10172 RET
              10173 
              10174 ; Copy a CR terminated line to DE and zero terminate it
              10175 ; HL: Source
              10176 ; DE: Destination (ACCS)
              10177 ;
043E63 7E     10178 CSTR_LINE:		LD	A, (HL)			; Get source
043E64 FE     10179 CP	CR			; Is it CR
043E65 0D 
043E66 28     10180 JR	Z, @F
043E67 05 
043E68 12     10181 LD	(DE), A			; No, so store
043E69 23     10182 INC	HL			; Increment
043E6A 13     10183 INC	DE
043E6B 18     10184 JR	CSTR_LINE		; And loop
043E6C F6 
043E6D AF     10185 @@:			XOR	A			; Zero terminate the target string
043E6E 12     10186 LD	(DE), A
043E6F 13     10187 INC	DE			; And point to next free address
043E70 C9     10188 RET
              10189 
              10190 ; Find the first occurrence of a character (case sensitive)
              10191 ; HL: Source
              10192 ;  C: Character to find
              10193 ; Returns:
              10194 ; HL: Pointer to character, or end of string marker
              10195 ;
043E71 7E     10196 CSTR_FINDCH:		LD	A, (HL)			; Get source
043E72 B9     10197 CP	C			; Is it our character?
043E73 C8     10198 RET	Z			; Yes, so exit
043E74 B7     10199 OR	A			; Is it the end of string?
043E75 C8     10200 RET	Z			; Yes, so exit
043E76 23     10201 INC	HL
043E77 18     10202 JR	CSTR_FINDCH
043E78 F8 
              10203 
              10204 ; Check whether a string ends with another string (case insensitive)
              10205 ; HL: Source
              10206 ; DE: The substring we want to test with
              10207 ; Returns:
              10208 ;  F: Z if HL ends with DE, otherwise NZ
              10209 ;
043E79 7E     10210 CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E7A CD     10211 CALL	UPPERC			; Convert to upper case
043E7B 24 
043E7C 3E 
043E7D 04 
043E7E 4F     10212 LD	C, A
043E7F 1A     10213 LD	A, (DE)			; Get the substring byte
043E80 B9     10214 CP	C
043E81 C0     10215 RET	NZ			; Return NZ if at any point the strings don't match
043E82 B1     10216 OR	C			; Check whether both bytes are zero
043E83 C8     10217 RET	Z			; If so, return, as we have reached the end of both strings
043E84 23     10218 INC	HL
043E85 13     10219 INC	DE
043E86 18     10220 JR	CSTR_ENDSWITH		; And loop
043E87 F1 
              10221 
              10222 ; Concatenate a string onto the end of another string
              10223 ; HL: Source
              10224 ; DE: Second string
              10225 ;
043E88 7E     10226 CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E89 B7     10227 OR	A
043E8A 28     10228 JR	Z, CSTR_CAT_1
043E8B 03 
043E8C 23     10229 INC	HL
043E8D 18     10230 JR	CSTR_CAT
043E8E F9 
              10231 ;
043E8F 1A     10232 CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E90 77     10233 LD	(HL), A
043E91 B7     10234 OR	A			; Check for end of string
043E92 C8     10235 RET	Z			; And return
043E93 23     10236 INC	HL
043E94 13     10237 INC	DE
043E95 18     10238 JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E96 F8 
              10239 
              10240 ; --- Begin patch.asm ---
              10241 ;
              10242 ; Title:	BBC Basic for AGON
              10243 ; Author:	Dean Belfield
              10244 ; Created:	12/05/2023
              10245 ; Last Updated:	15/11/2023
              10246 ;
              10247 ; Modinfo:
              10248 ; 11/07/2023:	Fixed *BYE for ADL mode
              10249 ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
              10250 
              10251 ; .ASSUME	ADL = 1
              10252 
              10253 ; INCLUDE	"equs.inc"
              10254 ; INCLUDE "macros.inc"
              10255 ; INCLUDE "mos_api.inc"	; In MOS/src
              10256 
              10257 ; SEGMENT CODE
              10258 
              10259 ; XDEF	OSWRCH
              10260 ; XDEF	OSLINE
              10261 ; XDEF	ESCSET
              10262 ; XDEF	PUTIME
              10263 ; XDEF	GETIME
              10264 ; XDEF	PUTCSR
              10265 ; XDEF 	GETCSR
              10266 ; XDEF	OSRDCH
              10267 ; XDEF	PROMPT
              10268 ; XDEF	OSKEY
              10269 ; XDEF	TRAP
              10270 ; XDEF	LTRAP
              10271 ; XDEF	OSINIT
              10272 ; XDEF	OSCLI
              10273 ; XDEF	OSBPUT
              10274 ; XDEF	OSBGET
              10275 ; XDEF	OSSTAT
              10276 ; XDEF	OSSHUT
              10277 ; XDEF	OSOPEN
              10278 ; XDEF	OSCALL
              10279 ; XDEF	GETPTR
              10280 ; XDEF	PUTPTR
              10281 ; XDEF	GETEXT
              10282 ; XDEF	GETIMS
              10283 ; XDEF	RESET
              10284 ; XDEF	OSLOAD
              10285 ; XDEF	OSSAVE
              10286 ; XDEF	EXPR_W2
              10287 ; XDEF	STAR_VERSION
              10288 
              10289 ; XREF	_end			; In init.asm
              10290 
              10291 ; XREF	ASC_TO_NUMBER
              10292 ; XREF	RAM_START
              10293 ; XREF	RAM_END
              10294 ; XREF	FLAGS
              10295 ; XREF	ESCAPE
              10296 ; XREF	USER
              10297 ; XREF	RAM_Top
              10298 ; XREF	EXTERR
              10299 ; XREF	COUNT0
              10300 ; XREF	EXPRI
              10301 ; XREF	COMMA
              10302 ; XREF	XEQ
              10303 ; XREF	NXT
              10304 ; XREF	NULLTOCR
              10305 ; XREF	CRLF
              10306 ; XREF	CSTR_FNAME
              10307 ; XREF	CSTR_LINE
              10308 ; XREF	CSTR_FINDCH
              10309 ; XREF	CSTR_ENDSWITH
              10310 ; XREF	CSTR_CAT
              10311 ; XREF	FINDL
              10312 ; XREF	OUT_
              10313 ; XREF	ERROR_
              10314 ; XREF	ONEDIT
              10315 ; XREF	TELL
              10316 ; XREF	OSWRCHPT
              10317 ; XREF	OSWRCHCH
              10318 ; XREF	OSWRCHFH
              10319 ; XREF	LISTON
              10320 ; XREF	LISTIT
              10321 ; XREF	PAGE_
              10322 ; XREF	ONEDIT1
              10323 ; XREF	CLEAN
              10324 ; XREF	NEWIT
              10325 ; XREF	BAD
              10326 ; XREF	VBLANK_INIT
              10327 ; XREF	VBLANK_STOP
              10328 ; XREF	KEYDOWN
              10329 ; XREF	KEYASCII
              10330 ; XREF	WIDTH
              10331 ; XREF	ASSEM
              10332 
              10333 ; OSLINE: Invoke the line editor
              10334 ;
043E97 1E     10335 OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E98 01 
              10336 
              10337 ; Entry point to line editor that does not clear the buffer
              10338 ;
043E99 FD     10339 OSLINE1:		PUSH	IY
043E9A E5 
043E9B E5     10340 PUSH	HL			; Buffer address
043E9C 01     10341 LD	BC, 256			; Buffer length
043E9D 00 
043E9E 01 
043E9F 00 
              10342 MOSCALL	mos_editline		; Call the MOS line editor
043EA0 3E     0001M LD	A, function
043EA1 09 
043EA2 49     0002M RST.LIS	08h
043EA3 CF 
043EA4 E1     10343 POP	HL			; Pop the address
043EA5 FD     10344 POP	IY
043EA6 E1 
043EA7 F5     10345 PUSH	AF			; Stack the return value (key pressed)
043EA8 CD     10346 CALL	NULLTOCR		; Turn the 0 character to a CR
043EA9 39 
043EAA 3E 
043EAB 04 
043EAC CD     10347 CALL	CRLF			; Display CRLF
043EAD 7F 
043EAE 39 
043EAF 04 
043EB0 F1     10348 POP	AF
043EB1 FE     10349 CP	1Bh 			; Check if ESC terminated the input
043EB2 1B 
043EB3 CA     10350 JP	Z, LTRAP1 		; Yes, so do the ESC thing
043EB4 AF 
043EB5 3F 
043EB6 04 
043EB7 3A     10351 LD	A, (FLAGS)		; Otherwise
043EB8 42 
043EB9 4D 
043EBA 04 
043EBB CB     10352 RES	7, A 			; Clear the escape flag
043EBC BF 
043EBD 32     10353 LD	(FLAGS), A
043EBE 42 
043EBF 4D 
043EC0 04 
043EC1 CD     10354 CALL	WAIT_VBLANK 		; Wait a frame
043EC2 86 
043EC3 41 
043EC4 04 
043EC5 AF     10355 XOR	A			; Return A = 0
043EC6 32     10356 LD	(KEYDOWN), A
043EC7 47 
043EC8 4D 
043EC9 04 
043ECA 32     10357 LD	(KEYASCII), A
043ECB 48 
043ECC 4D 
043ECD 04 
043ECE C9     10358 RET
              10359 
              10360 ; PUTIME: set current time to DE:HL, in centiseconds.
              10361 ;
043ECF DD     10362 PUTIME:			PUSH 	IX
043ED0 E5 
              10363 MOSCALL	mos_sysvars
043ED1 3E     0001M LD	A, function
043ED2 08 
043ED3 49     0002M RST.LIS	08h
043ED4 CF 
043ED5 DD     10364 LD	(IX + sysvar_time + 0), L
043ED6 75 
043ED7 00 
043ED8 DD     10365 LD	(IX + sysvar_time + 1), H
043ED9 74 
043EDA 01 
043EDB DD     10366 LD	(IX + sysvar_time + 2), E
043EDC 73 
043EDD 02 
043EDE DD     10367 LD	(IX + sysvar_time + 3), D
043EDF 72 
043EE0 03 
043EE1 DD     10368 POP	IX
043EE2 E1 
043EE3 C9     10369 RET
              10370 
              10371 ; GETIME: return current time in DE:HL, in centiseconds
              10372 ;
043EE4 DD     10373 GETIME:			PUSH 	IX
043EE5 E5 
              10374 MOSCALL	mos_sysvars
043EE6 3E     0001M LD	A, function
043EE7 08 
043EE8 49     0002M RST.LIS	08h
043EE9 CF 
043EEA DD     10375 LD	L, (IX + sysvar_time + 0)
043EEB 6E 
043EEC 00 
043EED DD     10376 LD	H, (IX + sysvar_time + 1)
043EEE 66 
043EEF 01 
043EF0 DD     10377 LD	E, (IX + sysvar_time + 2)
043EF1 5E 
043EF2 02 
043EF3 DD     10378 LD	D, (IX + sysvar_time + 3)
043EF4 56 
043EF5 03 
043EF6 DD     10379 POP	IX
043EF7 E1 
043EF8 C9     10380 RET
              10381 
              10382 ; PUTCSR: move to cursor to x=DE, y=HL
              10383 ;
043EF9 3E     10384 PUTCSR:			LD	A, 1Fh			; TAB
043EFA 1F 
043EFB 5B     10385 RST.LIL	10h
043EFC D7 
043EFD 7B     10386 LD	A, E			; X
043EFE 5B     10387 RST.LIL 10h
043EFF D7 
043F00 7D     10388 LD	A, L			; Y
043F01 5B     10389 RST.LIL 10h
043F02 D7 
043F03 C9     10390 RET
              10391 
              10392 ; GETCSR: return cursor position in x=DE, y=HL
              10393 ;
043F04 DD     10394 GETCSR:			PUSH	IX			; Get the system vars in IX
043F05 E5 
              10395 MOSCALL	mos_sysvars		; Reset the semaphore
043F06 3E     0001M LD	A, function
043F07 08 
043F08 49     0002M RST.LIS	08h
043F09 CF 
043F0A DD     10396 RES	0, (IX+sysvar_vpd_pflags)
043F0B CB 
043F0C 04 
043F0D 86 
              10397 VDU	23
043F0E 3E     0001M LD	A, val
043F0F 17 
043F10 CD     0002M CALL	OSWRCH
043F11 38 
043F12 3F 
043F13 04 
              10398 VDU	0
043F14 3E     0001M LD	A, val
043F15 00 
043F16 CD     0002M CALL	OSWRCH
043F17 38 
043F18 3F 
043F19 04 
              10399 VDU	vdp_cursor
043F1A 3E     0001M LD	A, val
043F1B 82 
043F1C CD     0002M CALL	OSWRCH
043F1D 38 
043F1E 3F 
043F1F 04 
043F20 DD     10400 @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F21 CB 
043F22 04 
043F23 46 
043F24 28     10401 JR	Z, @B			; Wait for the result
043F25 FA 
043F26 16     10402 LD 	D, 0
043F27 00 
043F28 62     10403 LD	H, D
043F29 DD     10404 LD	E, (IX + sysvar_cursorX)
043F2A 5E 
043F2B 07 
043F2C DD     10405 LD	L, (IX + sysvar_cursorY)
043F2D 6E 
043F2E 08 
043F2F DD     10406 POP	IX
043F30 E1 
043F31 C9     10407 RET
              10408 
              10409 ; PROMPT: output the input prompt
              10410 ;
043F32 3E     10411 PROMPT: 		LD	A,'>'
043F33 3E 
043F34 C3     10412 JP	OSWRCH
043F35 38 
043F36 3F 
043F37 04 
              10413 
              10414 ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
              10415 ; A: Character to write
              10416 ;
043F38 E5     10417 OSWRCH:			PUSH	HL
043F39 21     10418 LD	HL, LISTON		; Fetch the LISTON variable
043F3A 40 
043F3B 4D 
043F3C 04 
043F3D CB     10419 BIT	3, (HL)			; Check whether we are in *EDIT mode
043F3E 5E 
043F3F 20     10420 JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F40 0B 
              10421 ;
043F41 2A     10422 LD	HL, (OSWRCHCH)		; L: Channel #
043F42 45 
043F43 4D 
043F44 04 
043F45 2D     10423 DEC	L			; If it is 1
043F46 28     10424 JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F47 10 
              10425 ;
043F48 E1     10426 POP	HL			; Otherwise
043F49 5B     10427 RST.LIL	10h			; Output the character to MOS
043F4A D7 
043F4B C9     10428 RET
              10429 ;
043F4C 2A     10430 OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F4D 43 
043F4E 4D 
043F4F 04 
043F50 77     10431 LD	(HL), A			; Echo the character into the buffer
043F51 23     10432 INC	HL			; Increment pointer
043F52 22     10433 LD	(OSWRCHPT), HL		; Write pointer back
043F53 43 
043F54 4D 
043F55 04 
043F56 E1     10434 POP	HL
043F57 C9     10435 RET
              10436 ;
043F58 D5     10437 OSWRCH_FILE:		PUSH	DE
043F59 5C     10438 LD	E, H			; Filehandle to E
043F5A CD     10439 CALL	OSBPUT			; Write the byte out
043F5B 84 
043F5C 43 
043F5D 04 
043F5E D1     10440 POP	DE
043F5F E1     10441 POP	HL
043F60 C9     10442 RET
              10443 
              10444 ; OSRDCH: Read a character in from the ESP32 keyboard handler
              10445 ; This is only called in GETS (eval.asm)
              10446 ;
              10447 OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F61 3E     0001M LD	A, function
043F62 00 
043F63 49     0002M RST.LIS	08h
043F64 CF 
043F65 FE     10448 CP	1Bh
043F66 1B 
043F67 28     10449 JR	Z, LTRAP1
043F68 46 
043F69 C9     10450 RET
              10451 
              10452 
              10453 ;OSKEY - Read key with time-limit, test for ESCape.
              10454 ;Main function is carried out in user patch.
              10455 ;   Inputs: HL = time limit (centiseconds)
              10456 ;  Outputs: Carry reset if time-out
              10457 ;           If carry set A = character
              10458 ; Destroys: A,H,L,F
              10459 ;
043F6A CD     10460 OSKEY:			CALL	READKEY			; Read the keyboard
043F6B 9B 
043F6C 3F 
043F6D 04 
043F6E 28     10461 JR	Z, @F 			; Skip if we have a key
043F6F 0A 
043F70 7C     10462 LD	A, H 			; Check loop counter
043F71 B5     10463 OR 	L
043F72 C8     10464 RET 	Z 			; Return, we've not got a key at this point
043F73 CD     10465 CALL	WAIT_VBLANK 		; Wait a frame
043F74 86 
043F75 41 
043F76 04 
043F77 2B     10466 DEC 	HL			; Decrement
043F78 18     10467 JR	OSKEY 			; And loop
043F79 F0 
              10468 ;
043F7A 21     10469 @@:			LD	HL, KEYDOWN		; We have a key, so
043F7B 47 
043F7C 4D 
043F7D 04 
043F7E 36     10470 LD	(HL), 0			; clear the keydown flag
043F7F 00 
043F80 FE     10471 CP	1BH			; If we are not pressing ESC,
043F81 1B 
043F82 37     10472 SCF 				; then flag we've got a character
043F83 C0     10473 RET	NZ
              10474 ;
              10475 ; ESCSET
              10476 ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
              10477 ;
043F84 E5     10478 ESCSET: 		PUSH    HL
043F85 21     10479 LD      HL,FLAGS		; Pointer to FLAGS
043F86 42 
043F87 4D 
043F88 04 
043F89 CB     10480 BIT     6,(HL)			; If bit 6 is set, then
043F8A 76 
043F8B 20     10481 JR      NZ,ESCDIS		; escape is disabled, so skip
043F8C 02 
043F8D CB     10482 SET     7,(HL)			; Set bit 7, the escape flag
043F8E FE 
043F8F E1     10483 ESCDIS: 		POP     HL
043F90 C9     10484 RET
              10485 ;
              10486 ; ESCTEST
              10487 ; Test for ESC key
              10488 ;
043F91 CD     10489 ESCTEST:		CALL	READKEY			; Read the keyboard
043F92 9B 
043F93 3F 
043F94 04 
043F95 C0     10490 RET	NZ			; Skip if no key is pressed
043F96 FE     10491 CP	1BH			; If ESC pressed then
043F97 1B 
043F98 28     10492 JR	Z,ESCSET		; jump to the escape set routine
043F99 EA 
043F9A C9     10493 RET
              10494 
              10495 ; Read the keyboard
              10496 ; Returns:
              10497 ; - A: ASCII of the pressed key
              10498 ; - F: Z if the key is pressed, otherwise NZ
              10499 ;
043F9B 3A     10500 READKEY:		LD	A, (KEYDOWN)		; Get key down
043F9C 47 
043F9D 4D 
043F9E 04 
043F9F 3D     10501 DEC	A 			; Set Z flag if keydown is 1
043FA0 3A     10502 LD	A, (KEYASCII)		; Get key ASCII value
043FA1 48 
043FA2 4D 
043FA3 04 
043FA4 C9     10503 RET
              10504 ;
              10505 ; TRAP
              10506 ; This is called whenever BASIC needs to check for ESC
              10507 ;
043FA5 CD     10508 TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FA6 91 
043FA7 3F 
043FA8 04 
              10509 ;
043FA9 3A     10510 LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FAA 42 
043FAB 4D 
043FAC 04 
043FAD B7     10511 OR	A			; This checks for bit 7; if it is not set then the result will
043FAE F0     10512 RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FAF 21     10513 LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FB0 42 
043FB1 4D 
043FB2 04 
043FB3 CB     10514 RES	7,(HL)			; Clear the escape pressed flag and
043FB4 BE 
043FB5 C3     10515 JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FB6 A3 
043FB7 0C 
043FB8 04 
              10516 
              10517 ;OSINIT - Initialise RAM mapping etc.
              10518 ;If BASIC is entered by BBCBASIC FILENAME then file
              10519 ;FILENAME.BBC is automatically CHAINed.
              10520 ;   Outputs: DE = initial value of HIMEM (top of RAM)
              10521 ;            HL = initial value of PAGE (user program)
              10522 ;            Z-flag reset indicates AUTO-RUN.
              10523 ;  Destroys: A,D,E,H,L,F
              10524 ;
043FB9 CD     10525 OSINIT:			CALL	VBLANK_INIT
043FBA 1E 
043FBB 49 
043FBC 04 
043FBD AF     10526 XOR	A
043FBE 21     10527 LD 	HL, USER
043FBF 00 
043FC0 4E 
043FC1 04 
043FC2 11     10528 LD	DE, RAM_Top
043FC3 00 
043FC4 00 
043FC5 0B 
043FC6 5F     10529 LD	E, A			; Page boundary
043FC7 C9     10530 RET
              10531 
              10532 ;
              10533 ;OSCLI - Process a MOS command
              10534 ;
043FC8 CD     10535 OSCLI: 			CALL    SKIPSP
043FC9 3C 
043FCA 40 
043FCB 04 
043FCC FE     10536 CP      CR
043FCD 0D 
043FCE C8     10537 RET     Z
043FCF FE     10538 CP      '|'
043FD0 7C 
043FD1 C8     10539 RET     Z
043FD2 EB     10540 EX      DE,HL
043FD3 21     10541 LD      HL,COMDS
043FD4 4B 
043FD5 40 
043FD6 04 
043FD7 1A     10542 OSCLI0:			LD      A,(DE)
043FD8 CD     10543 CALL    UPPRC
043FD9 43 
043FDA 40 
043FDB 04 
043FDC BE     10544 CP      (HL)
043FDD 28     10545 JR      Z,OSCLI2
043FDE 0B 
043FDF 38     10546 JR      C,OSCLI6
043FE0 30 
043FE1 CB     10547 OSCLI1:			BIT     7,(HL)
043FE2 7E 
043FE3 23     10548 INC     HL
043FE4 28     10549 JR      Z,OSCLI1
043FE5 FB 
043FE6 23     10550 INC     HL
043FE7 23     10551 INC     HL
043FE8 18     10552 JR      OSCLI0
043FE9 ED 
              10553 ;
043FEA D5     10554 OSCLI2:			PUSH    DE
043FEB 13     10555 OSCLI3:			INC     DE
043FEC 23     10556 INC     HL
043FED 1A     10557 LD      A,(DE)
043FEE CD     10558 CALL    UPPRC
043FEF 43 
043FF0 40 
043FF1 04 
043FF2 FE     10559 CP      '.'			; ABBREVIATED?
043FF3 2E 
043FF4 28     10560 JR      Z,OSCLI4
043FF5 0A 
043FF6 AE     10561 XOR     (HL)
043FF7 28     10562 JR      Z,OSCLI3
043FF8 F2 
043FF9 FE     10563 CP      80H
043FFA 80 
043FFB 28     10564 JR      Z,OSCLI4
043FFC 03 
043FFD D1     10565 POP     DE
043FFE 18     10566 JR      OSCLI1
043FFF E1 
              10567 ;
044000 F1     10568 OSCLI4:			POP     AF
044001 13     10569 INC     DE
044002 CB     10570 OSCLI5:			BIT     7,(HL)
044003 7E 
044004 23     10571 INC     HL
044005 28     10572 JR      Z,OSCLI5
044006 FB 
044007 7E     10573 LD      A,(HL)
044008 23     10574 INC     HL
044009 66     10575 LD      H,(HL)
04400A 6F     10576 LD      L,A
04400B E5     10577 PUSH    HL
04400C EB     10578 EX      DE,HL
04400D C3     10579 JP      SKIPSP
04400E 3C 
04400F 40 
044010 04 
              10580 ;
044011 EB     10581 OSCLI6:			EX	DE, HL			; HL: Buffer for command
044012 11     10582 LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
044013 00 
044014 4A 
044015 04 
044016 D5     10583 PUSH	DE			; Store buffer address
044017 CD     10584 CALL	CSTR_LINE		; Fetch the line
044018 63 
044019 3E 
04401A 04 
04401B E1     10585 POP	HL			; HL: Pointer to command string in ACCS
04401C FD     10586 PUSH	IY
04401D E5 
              10587 MOSCALL	mos_oscli		; Returns OSCLI error in A
04401E 3E     0001M LD	A, function
04401F 10 
044020 49     0002M RST.LIS	08h
044021 CF 
044022 FD     10588 POP	IY
044023 E1 
044024 B7     10589 OR	A			; 0 means MOS returned OK
044025 C8     10590 RET	Z			; So don't do anything
044026 C3     10591 JP 	OSERROR			; Otherwise it's a MOS error
044027 60 
044028 42 
044029 04 
              10592 
04402A 3E     10593 HUH:    		LD      A,254			; Bad command error
04402B FE 
04402C CD     10594 CALL    EXTERR
04402D AF 
04402E 37 
04402F 04 
044030 42     10595 DB    	"Bad command"
044031 61 
044032 64 
044033 20 
044033 63   
044034 6F 
044035 6D 
044036 6D 
044036 61   
044037 6E 
044038 64 
04403B 00     10596 DEFB    0
              10597 
04403C 7E     10598 SKIPSP:			LD      A,(HL)
04403D FE     10599 CP      ' '
04403E 20 
04403F C0     10600 RET     NZ
044040 23     10601 INC     HL
044041 18     10602 JR      SKIPSP
044042 F9 
              10603 
044043 E6     10604 UPPRC:  		AND     7FH
044044 7F 
044045 FE     10605 CP      '`'
044046 60 
044047 D8     10606 RET     C
044048 E6     10607 AND     5FH			; CONVERT TO UPPER CASE
044049 5F 
04404A C9     10608 RET
              10609 
              10610 ; Each command has bit 7 of the last character set, and is followed by the address of the handler
              10611 ; These must be in alphabetical order
              10612 ;
04404B 41     10613 COMDS:  		DB	"AS","M"+80h		; ASM
04404C 53 
04404D 4D 
04404E 69     10614 DW	STAR_ASM
04404F 40 
044050 42     10615 DB	"BY","E"+80h		; BYE
044051 59 
044052 45 
044053 75     10616 DW	STAR_BYE
044054 40 
044055 45     10617 DB	"EDI","T"+80h		; EDIT
044056 44 
044057 49 
044058 54 
044059 AA     10618 DW	STAR_EDIT
04405A 40 
04405B 46     10619 DB	"F","X"+80h		; FX
04405C 58 
04405D EA     10620 DW	STAR_FX
04405E 40 
04405F 56     10621 DB	"VERSIO","N"+80h	; VERSION
044060 45 
044061 52 
044062 53 
044062 49   
044063 4F 
044064 4E 
044066 81     10622 DW	STAR_VERSION
044067 40 
044068 FF     10623 DB	FFh
              10624 
              10625 ; *ASM string
              10626 ;
044069 FD     10627 STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
04406A E5 
04406B E5     10628 PUSH	HL			; HL = IY
04406C FD     10629 POP	IY
04406D E1 
04406E CD     10630 CALL	ASSEM			; Invoke the assembler
04406F CD 
044070 18 
044071 04 
044072 FD     10631 POP	IY
044073 E1 
044074 C9     10632 RET
              10633 
              10634 ; *BYE
              10635 ;
044075 CD     10636 STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044076 32 
044077 49 
044078 04 
044079 21     10637 LD	HL, 0			; The return value
04407A 00 
04407B 00 
04407C 00 
04407D C3     10638 JP	_end 			; Jump back to the end routine in init.asm
04407E 68 
04407F 00 
044080 04 
              10639 
              10640 ; *VERSION
              10641 ;
044081 CD     10642 STAR_VERSION:		CALL    TELL			; Output the welcome message
044082 C8 
044083 3D 
044084 04 
044085 42     10643 DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
044086 42 
044087 43 
044088 20 
044088 42   
044089 41 
04408A 53 
04408B 49 
04408B 43   
04408C 20 
04408D 28 
04408E 41 
04408E 67   
04408F 6F 
044090 6E 
044091 20 
044091 41   
044092 44 
044093 4C 
044094 29 
044094 20   
044095 56 
044096 65 
044097 72 
044097 73   
044098 69 
044099 6F 
04409A 6E 
04409A 20   
04409B 31 
04409C 2E 
04409D 30 
04409D 33   
04409E 0A 
04409F 0D 
0440A0 00 
0440A9 C9     10644 RET
              10645 
              10646 ; *EDIT linenum
              10647 ;
0440AA CD     10648 STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440AB CF 
0440AC 3D 
0440AD 04 
0440AE EB     10649 EX	DE, HL			; HL: Line number
0440AF CD     10650 CALL	FINDL			; HL: Address in RAM of tokenised line
0440B0 C7 
0440B1 39 
0440B2 04 
0440B3 3E     10651 LD	A, 41			; F:NZ If the line is not found
0440B4 29 
0440B5 C2     10652 JP	NZ, ERROR_		; Do error 41: No such line in that case
0440B6 98 
0440B7 37 
0440B8 04 
              10653 ;
              10654 ; Use LISTIT to output the line to the ACCS buffer
              10655 ;
0440B9 23     10656 INC	HL			; Skip the length byte
0440BA 5E     10657 LD	E, (HL)			; Fetch the line number
0440BB 23     10658 INC	HL
0440BC 56     10659 LD	D, (HL)
0440BD 23     10660 INC	HL
0440BE DD     10661 LD	IX, ACCS		; Pointer to where the copy is to be stored
0440BF 21 
0440C0 00 
0440C1 4A 
0440C1 04   
0440C3 DD     10662 LD	(OSWRCHPT), IX
0440C4 22 
0440C5 43 
0440C6 4D 
0440C6 04   
0440C8 DD     10663 LD	IX, LISTON		; Pointer to LISTON variable in RAM
0440C9 21 
0440CA 40 
0440CB 4D 
0440CB 04   
0440CD DD     10664 LD	A, (IX)			; Store that variable
0440CE 7E 
0440CF 00 
0440D0 F5     10665 PUSH	AF
0440D1 DD     10666 LD	(IX), 09h		; Set to echo to buffer
0440D2 36 
0440D3 00 
0440D4 09 
0440D5 CD     10667 CALL	LISTIT
0440D6 CA 
0440D7 38 
0440D8 04 
0440D9 F1     10668 POP	AF
0440DA DD     10669 LD	(IX), A			; Restore the original LISTON variable
0440DB 77 
0440DC 00 
0440DD 21     10670 LD	HL, ACCS		; HL: ACCS
0440DE 00 
0440DF 4A 
0440E0 04 
0440E1 5D     10671 LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0440E2 CD     10672 CALL	OSLINE1			; Invoke the editor
0440E3 99 
0440E4 3E 
0440E5 04 
0440E6 C3     10673 JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440E7 08 
0440E8 31 
0440E9 04 
              10674 
              10675 ; OSCLI FX n
              10676 ;
0440EA CD     10677 STAR_FX:		CALL	ASC_TO_NUMBER
0440EB CF 
0440EC 3D 
0440ED 04 
0440EE 4B     10678 LD	C, E			; C: Save FX #
0440EF CD     10679 CALL	ASC_TO_NUMBER
0440F0 CF 
0440F1 3D 
0440F2 04 
0440F3 7A     10680 LD	A, D  			; Is first parameter > 255?
0440F4 B7     10681 OR 	A
0440F5 28     10682 JR	Z, STAR_FX1		; Yes, so skip next bit
0440F6 03 
0440F7 EB     10683 EX	DE, HL 			; Parameter is 16-bit
0440F8 18     10684 JR	STAR_FX2
0440F9 07 
              10685 ;
0440FA 43     10686 STAR_FX1:		LD	B, E 			; B: Save First parameter
0440FB CD     10687 CALL	ASC_TO_NUMBER		; Fetch second parameter
0440FC CF 
0440FD 3D 
0440FE 04 
0440FF 68     10688 LD	L, B 			; L: First parameter
044100 63     10689 LD	H, E 			; H: Second parameter
              10690 ;
044101 79     10691 STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
              10692 ;
              10693 ; OSBYTE
              10694 ;  A: FX #
              10695 ;  L: First parameter
              10696 ;  H: Second parameter
              10697 ;
044102 FE     10698 OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
044103 0B 
044104 28     10699 JR	Z, OSBYTE_0B
044105 18 
044106 FE     10700 CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044107 0C 
044108 28     10701 JR	Z, OSBYTE_0C
044109 43 
04410A FE     10702 CP	13H			; *FX 19: Wait for vblank
04410B 13 
04410C 28     10703 JR	Z, OSBYTE_13
04410D 6E 
04410E FE     10704 CP	76H			; *FX 118, n: Set keyboard LED
04410F 76 
044110 CA     10705 JP	Z, OSBYTE_76
044111 97 
044112 41 
044113 04 
044114 FE     10706 CP	A0H
044115 A0 
044116 CA     10707 JP	Z, OSBYTE_A0
044117 C7 
044118 41 
044119 04 
04411A C3     10708 JP	HUH			; Anything else trips an error
04411B 2A 
04411C 40 
04411D 04 
              10709 
              10710 ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
              10711 ; Parameters:
              10712 ; - HL: Repeat delay
              10713 ;
              10714 OSBYTE_0B:		VDU	23
04411E 3E     0001M LD	A, val
04411F 17 
044120 CD     0002M CALL	OSWRCH
044121 38 
044122 3F 
044123 04 
              10715 VDU	0
044124 3E     0001M LD	A, val
044125 00 
044126 CD     0002M CALL	OSWRCH
044127 38 
044128 3F 
044129 04 
              10716 VDU	vdp_keystate
04412A 3E     0001M LD	A, val
04412B 88 
04412C CD     0002M CALL	OSWRCH
04412D 38 
04412E 3F 
04412F 04 
              10717 VDU	L
044130 7D     0001M LD	A, val
044131 CD     0002M CALL	OSWRCH
044132 38 
044133 3F 
044134 04 
              10718 VDU	H
044135 7C     0001M LD	A, val
044136 CD     0002M CALL	OSWRCH
044137 38 
044138 3F 
044139 04 
              10719 VDU	0
04413A 3E     0001M LD	A, val
04413B 00 
04413C CD     0002M CALL	OSWRCH
04413D 38 
04413E 3F 
04413F 04 
              10720 VDU 	0
044140 3E     0001M LD	A, val
044141 00 
044142 CD     0002M CALL	OSWRCH
044143 38 
044144 3F 
044145 04 
              10721 VDU	255
044146 3E     0001M LD	A, val
044147 FF 
044148 CD     0002M CALL	OSWRCH
044149 38 
04414A 3F 
04414B 04 
04414C C9     10722 RET
              10723 
              10724 ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
              10725 ; Parameters:
              10726 ; - HL: Repeat rate
              10727 ;
              10728 OSBYTE_0C:		VDU	23
04414D 3E     0001M LD	A, val
04414E 17 
04414F CD     0002M CALL	OSWRCH
044150 38 
044151 3F 
044152 04 
              10729 VDU	0
044153 3E     0001M LD	A, val
044154 00 
044155 CD     0002M CALL	OSWRCH
044156 38 
044157 3F 
044158 04 
              10730 VDU	vdp_keystate
044159 3E     0001M LD	A, val
04415A 88 
04415B CD     0002M CALL	OSWRCH
04415C 38 
04415D 3F 
04415E 04 
              10731 VDU	0
04415F 3E     0001M LD	A, val
044160 00 
044161 CD     0002M CALL	OSWRCH
044162 38 
044163 3F 
044164 04 
              10732 VDU 	0
044165 3E     0001M LD	A, val
044166 00 
044167 CD     0002M CALL	OSWRCH
044168 38 
044169 3F 
04416A 04 
              10733 VDU	L
04416B 7D     0001M LD	A, val
04416C CD     0002M CALL	OSWRCH
04416D 38 
04416E 3F 
04416F 04 
              10734 VDU	H
044170 7C     0001M LD	A, val
044171 CD     0002M CALL	OSWRCH
044172 38 
044173 3F 
044174 04 
              10735 VDU	255
044175 3E     0001M LD	A, val
044176 FF 
044177 CD     0002M CALL	OSWRCH
044178 38 
044179 3F 
04417A 04 
04417B C9     10736 RET
              10737 
              10738 ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
              10739 ;
04417C CD     10740 OSBYTE_13:		CALL	WAIT_VBLANK
04417D 86 
04417E 41 
04417F 04 
044180 2E     10741 LD	L, 0			; Returns 0
044181 00 
044182 C3     10742 JP	COUNT0
044183 84 
044184 05 
044185 04 
              10743 ;
044186 DD     10744 WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
044187 E5 
              10745 MOSCALL	mos_sysvars		; Fetch pointer to system variables
044188 3E     0001M LD	A, function
044189 08 
04418A 49     0002M RST.LIS	08h
04418B CF 
04418C DD     10746 LD	A, (IX + sysvar_time + 0)
04418D 7E 
04418E 00 
04418F DD     10747 @@:			CP 	A, (IX + sysvar_time + 0)
044190 BE 
044191 00 
044192 28     10748 JR	Z, @B
044193 FB 
044194 DD     10749 POP	IX
044195 E1 
044196 C9     10750 RET
              10751 
              10752 ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
              10753 ; Parameters:
              10754 ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
              10755 ;
              10756 OSBYTE_76:		VDU	23
044197 3E     0001M LD	A, val
044198 17 
044199 CD     0002M CALL	OSWRCH
04419A 38 
04419B 3F 
04419C 04 
              10757 VDU	0
04419D 3E     0001M LD	A, val
04419E 00 
04419F CD     0002M CALL	OSWRCH
0441A0 38 
0441A1 3F 
0441A2 04 
              10758 VDU	vdp_keystate
0441A3 3E     0001M LD	A, val
0441A4 88 
0441A5 CD     0002M CALL	OSWRCH
0441A6 38 
0441A7 3F 
0441A8 04 
              10759 VDU	0
0441A9 3E     0001M LD	A, val
0441AA 00 
0441AB CD     0002M CALL	OSWRCH
0441AC 38 
0441AD 3F 
0441AE 04 
              10760 VDU 	0
0441AF 3E     0001M LD	A, val
0441B0 00 
0441B1 CD     0002M CALL	OSWRCH
0441B2 38 
0441B3 3F 
0441B4 04 
              10761 VDU	0
0441B5 3E     0001M LD	A, val
0441B6 00 
0441B7 CD     0002M CALL	OSWRCH
0441B8 38 
0441B9 3F 
0441BA 04 
              10762 VDU	0
0441BB 3E     0001M LD	A, val
0441BC 00 
0441BD CD     0002M CALL	OSWRCH
0441BE 38 
0441BF 3F 
0441C0 04 
              10763 VDU	L
0441C1 7D     0001M LD	A, val
0441C2 CD     0002M CALL	OSWRCH
0441C3 38 
0441C4 3F 
0441C5 04 
0441C6 C9     10764 RET
              10765 
              10766 ; OSBYTE 0xA0: Fetch system variable
              10767 ; Parameters:
              10768 ; - L: The system variable to fetch
              10769 ;
0441C7 DD     10770 OSBYTE_A0:		PUSH	IX
0441C8 E5 
              10771 MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441C9 3E     0001M LD	A, function
0441CA 08 
0441CB 49     0002M RST.LIS	08h
0441CC CF 
0441CD 01     10772 LD	BC, 0
0441CE 00 
0441CF 00 
0441D0 00 
0441D1 4D     10773 LD	C, L			; BCU = L
0441D2 DD     10774 ADD	IX, BC			; Add to IX
0441D3 09 
0441D4 DD     10775 LD	L, (IX + 0)		; Fetch the return value
0441D5 6E 
0441D6 00 
0441D7 DD     10776 POP	IX
0441D8 E1 
0441D9 C3     10777 JP 	COUNT0
0441DA 84 
0441DB 05 
0441DC 04 
              10778 
              10779 ;OSLOAD - Load an area of memory from a file.
              10780 ;   Inputs: HL addresses filename (CR terminated)
              10781 ;           DE = address at which to load
              10782 ;           BC = maximum allowed size (bytes)
              10783 ;  Outputs: Carry reset indicates no room for file.
              10784 ; Destroys: A,B,C,D,E,H,L,F
              10785 ;
0441DD C5     10786 OSLOAD:			PUSH	BC			; Stack the size
0441DE D5     10787 PUSH	DE			; Stack the load address
0441DF 11     10788 LD	DE, ACCS		; Buffer address for filename
0441E0 00 
0441E1 4A 
0441E2 04 
0441E3 CD     10789 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0441E4 51 
0441E5 3E 
0441E6 04 
0441E7 21     10790 LD	HL, ACCS		; HL: Filename
0441E8 00 
0441E9 4A 
0441EA 04 
0441EB CD     10791 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441EC DD 
0441ED 42 
0441EE 04 
0441EF CD     10792 CALL	EXT_HANDLER		; Get the default handler
0441F0 F1 
0441F1 42 
0441F2 04 
0441F3 D1     10793 POP	DE			; Restore the load address
0441F4 C1     10794 POP	BC			; Restore the size
0441F5 B7     10795 OR	A
0441F6 28     10796 JR 	Z, OSLOAD_BBC
0441F7 60 
              10797 ;
              10798 ; Load the file in as a text file
              10799 ;
0441F8 AF     10800 OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441F9 CD     10801 CALL	OSOPEN			; Open the file
0441FA 65 
0441FB 43 
0441FC 04 
0441FD 5F     10802 LD 	E, A 			; The filehandle
0441FE B7     10803 OR	A
0441FF 3E     10804 LD	A, 4			; File not found error
044200 04 
044201 28     10805 JR	Z, OSERROR		; Jump to error handler
044202 5D 
044203 CD     10806 CALL	NEWIT			; Call NEW to clear the program space
044204 A4 
044205 38 
044206 04 
              10807 ;
044207 21     10808 OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044208 00 
044209 4A 
04420A 04 
              10809 ;
              10810 ; First skip any whitespace (indents) at the beginning of the input
              10811 ;
04420B CD     10812 @@:			CALL	OSBGET			; Read the byte into A
04420C 7C 
04420D 43 
04420E 04 
04420F 38     10813 JR	C, OSLOAD_TXT3		; Is it EOF?
044210 1E 
044211 FE     10814 CP	LF 			; Is it LF?
044212 0A 
044213 28     10815 JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
044214 1A 
044215 FE     10816 CP	21h			; Is it less than or equal to ASCII space?
044216 21 
044217 38     10817 JR	C, @B 			; Yes, so keep looping
044218 F2 
044219 77     10818 LD	(HL), A 		; Store the first character
04421A 2C     10819 INC	L
              10820 ;
              10821 ; Now read the rest of the line in
              10822 ;
04421B CD     10823 OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
04421C 7C 
04421D 43 
04421E 04 
04421F 38     10824 JR	C, OSLOAD_TXT4		; Is it EOF?
044220 2B 
044221 FE     10825 CP	20h			; Skip if not an ASCII character
044222 20 
044223 38     10826 JR	C, @F
044224 06 
044225 77     10827 LD	(HL), A 		; Store in the input buffer
044226 2C     10828 INC	L			; Increment the buffer pointer
044227 CA     10829 JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044228 30 
044229 37 
04422A 04 
04422B FE     10830 @@:			CP	LF			; Check for LF
04422C 0A 
04422D 20     10831 JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
04422E EC 
              10832 ;
              10833 ; Finally, handle EOL/EOF
              10834 ;
04422F 36     10835 OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
044230 0D 
044231 7D     10836 LD	A, L			; Check for minimum line length
044232 FE     10837 CP	2			; If it is 2 characters or less (including CR)
044233 02 
044234 38     10838 JR	C, @F			; Then don't bother entering it
044235 0A 
044236 D5     10839 PUSH	DE			; Preserve the filehandle
044237 CD     10840 CALL	ONEDIT1			; Enter the line in memory
044238 14 
044239 31 
04423A 04 
04423B DC     10841 CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
04423C 77 
04423D 38 
04423E 04 
04423F D1     10842 POP	DE
044240 CD     10843 @@:			CALL	OSSTAT			; End of file?
044241 8D 
044242 43 
044243 04 
044244 20     10844 JR	NZ, OSLOAD_TXT1		; No, so loop
044245 C1 
044246 CD     10845 CALL	OSSHUT			; Close the file
044247 74 
044248 43 
044249 04 
04424A 37     10846 SCF				; Flag to BASIC that we're good
04424B C9     10847 RET
              10848 ;
              10849 ; Special case for BASIC programs with no blank line at the end
              10850 ;
04424C FE     10851 OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
04424D 20 
04424E 38     10852 JR	C, @F
04424F 06 
044250 77     10853 LD	(HL), A			; Store the character
044251 2C     10854 INC	L
044252 CA     10855 JP	Z, BAD
044253 30 
044254 37 
044255 04 
044256 18     10856 @@:			JR	OSLOAD_TXT3
044257 D7 
              10857 
              10858 ;
              10859 ; Load the file in as a tokenised binary blob
              10860 ;
              10861 OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044258 3E     0001M LD	A, function
044259 01 
04425A 49     0002M RST.LIS	08h
04425B CF 
04425C D0     10862 RET	NC			; If load returns with carry reset - NO ROOM
04425D B7     10863 OR	A			; If there is no error (A=0)
04425E 37     10864 SCF				; Need to set carry indicating there was room
04425F C8     10865 RET	Z			; Return
              10866 ;
044260 F5     10867 OSERROR:		PUSH	AF			; Handle the MOS error
044261 21     10868 LD	HL, ACCS		; Address of the buffer
044262 00 
044263 4A 
044264 04 
044265 01     10869 LD	BC, 256			; Length of the buffer
044266 00 
044267 01 
044268 00 
044269 5F     10870 LD	E, A			; The error code
              10871 MOSCALL	mos_getError		; Copy the error message into the buffer
04426A 3E     0001M LD	A, function
04426B 0F 
04426C 49     0002M RST.LIS	08h
04426D CF 
04426E F1     10872 POP	AF
04426F E5     10873 PUSH	HL			; Stack the address of the error (now in ACCS)
044270 C6     10874 ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044271 7F 
044272 C3     10875 JP	EXTERR			; Trigger an external error
044273 AF 
044274 37 
044275 04 
              10876 
              10877 ;OSSAVE - Save an area of memory to a file.
              10878 ;   Inputs: HL addresses filename (term CR)
              10879 ;           DE = start address of data to save
              10880 ;           BC = length of data to save (bytes)
              10881 ; Destroys: A,B,C,D,E,H,L,F
              10882 ;
044276 C5     10883 OSSAVE:			PUSH	BC			; Stack the size
044277 D5     10884 PUSH	DE			; Stack the save address
044278 11     10885 LD	DE, ACCS		; Buffer address for filename
044279 00 
04427A 4A 
04427B 04 
04427C CD     10886 CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04427D 51 
04427E 3E 
04427F 04 
044280 21     10887 LD	HL, ACCS		; HL: Filename
044281 00 
044282 4A 
044283 04 
044284 CD     10888 CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044285 DD 
044286 42 
044287 04 
044288 CD     10889 CALL	EXT_HANDLER		; Get the default handler
044289 F1 
04428A 42 
04428B 04 
04428C D1     10890 POP	DE			; Restore the save address
04428D C1     10891 POP	BC			; Restore the size
04428E B7     10892 OR	A			; Is the extension .BBC
04428F 28     10893 JR	Z, OSSAVE_BBC		; Yes, so use that
044290 44 
              10894 ;
              10895 ; Save the file out as a text file
              10896 ;
044291 3A     10897 OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
044292 45 
044293 4D 
044294 04 
044295 F5     10898 PUSH	AF
044296 AF     10899 XOR	A
044297 3C     10900 INC	A			; Make sure C is clear, A is 1, for OPENOUT
044298 32     10901 LD	(OSWRCHCH), A
044299 45 
04429A 4D 
04429B 04 
04429C CD     10902 CALL	OSOPEN			; Open the file
04429D 65 
04429E 43 
04429F 04 
0442A0 32     10903 LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0442A1 46 
0442A2 4D 
0442A3 04 
0442A4 DD     10904 LD	IX, LISTON		; Required for LISTIT
0442A5 21 
0442A6 40 
0442A7 4D 
0442A7 04   
0442A9 2A     10905 LD	HL, (PAGE_)		; Get start of program area
0442AA 14 
0442AB 4D 
0442AC 04 
0442AD D9     10906 EXX
0442AE 01     10907 LD	BC, 0			; Set the initial indent counters
0442AF 00 
0442B0 00 
0442B1 00 
0442B2 D9     10908 EXX
0442B3 7E     10909 OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442B4 B7     10910 OR	A
0442B5 28     10911 JR	Z, OSSAVE_TXT2
0442B6 0F 
0442B7 23     10912 INC	HL			; Skip the length byte
0442B8 11     10913 LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442B9 00 
0442BA 00 
0442BB 00 
0442BC 5E     10914 LD	E, (HL)			; Get the line number
0442BD 23     10915 INC	HL
0442BE 56     10916 LD	D, (HL)
0442BF 23     10917 INC	HL
0442C0 CD     10918 CALL	LISTIT			; List the line
0442C1 CA 
0442C2 38 
0442C3 04 
0442C4 18     10919 JR	OSSAVE_TXT1
0442C5 ED 
0442C6 3A     10920 OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442C7 46 
0442C8 4D 
0442C9 04 
0442CA 5F     10921 LD	E, A
0442CB CD     10922 CALL	OSSHUT			; Close it
0442CC 74 
0442CD 43 
0442CE 04 
0442CF F1     10923 POP	AF			; Restore the channel
0442D0 32     10924 LD	(OSWRCHCH), A
0442D1 45 
0442D2 4D 
0442D3 04 
0442D4 C9     10925 RET
              10926 ;
              10927 ; Save the file out as a tokenised binary blob
              10928 ;
              10929 OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442D5 3E     0001M LD	A, function
0442D6 02 
0442D7 49     0002M RST.LIS	08h
0442D8 CF 
0442D9 B7     10930 OR	A			; If there is no error (A=0)
0442DA C8     10931 RET	Z			; Just return
0442DB 18     10932 JR	OSERROR			; Trip an error
0442DC 83 
              10933 
              10934 ; Check if an extension is specified in the filename
              10935 ; Add a default if not specified
              10936 ; HL: Filename (CSTR format)
              10937 ;
0442DD E5     10938 EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442DE 0E     10939 LD	C, '.'			; Search for dot (marks start of extension)
0442DF 2E 
0442E0 CD     10940 CALL	CSTR_FINDCH
0442E1 71 
0442E2 3E 
0442E3 04 
0442E4 B7     10941 OR	A			; Check for end of string marker
0442E5 20     10942 JR	NZ, @F			; No, so skip as we have an extension at this point
0442E6 08 
0442E7 11     10943 LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442E8 21 
0442E9 43 
0442EA 04 
0442EB CD     10944 CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442EC 88 
0442ED 3E 
0442EE 04 
0442EF E1     10945 @@:			POP	HL			; Restore the filename pointer
0442F0 C9     10946 RET
              10947 
              10948 ; Check if an extension is valid and, if so, provide a pointer to a handler
              10949 ; HL: Filename (CSTR format)
              10950 ; Returns:
              10951 ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
              10952 ;
0442F1 E5     10953 EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442F2 0E     10954 LD	C, '.'			; Find the '.'
0442F3 2E 
0442F4 CD     10955 CALL	CSTR_FINDCH
0442F5 71 
0442F6 3E 
0442F7 04 
0442F8 11     10956 LD	DE, EXT_LOOKUP		; The lookup table
0442F9 21 
0442FA 43 
0442FB 04 
              10957 ;
0442FC E5     10958 EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442FD CD     10959 CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442FE 79 
0442FF 3E 
044300 04 
044301 E1     10960 POP	HL			; Restore the pointer to the extension
044302 28     10961 JR	Z, EXT_HANDLER_2	; We have a match!
044303 19 
              10962 ;
044304 1A     10963 @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
044305 13     10964 INC	DE
044306 B7     10965 OR	A
044307 20     10966 JR	NZ, @B
044308 FB 
044309 13     10967 INC	DE			; Skip the file extension # byte
              10968 ;
04430A 1A     10969 LD	A, (DE)			; Are we at the end of the table?
04430B B7     10970 OR	A
04430C 20     10971 JR	NZ, EXT_HANDLER_1	; No, so loop
04430D EE 
              10972 ;
04430E 3E     10973 LD      A,204			; Throw a "Bad name" error
04430F CC 
044310 CD     10974 CALL    EXTERR
044311 AF 
044312 37 
044313 04 
044314 42     10975 DB    	"Bad name", 0
044315 61 
044316 64 
044317 20 
044317 6E   
044318 61 
044319 6D 
04431A 65 
04431A 00   
              10976 ;
04431D 13     10977 EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
04431E 1A     10978 LD	A, (DE)
04431F E1     10979 POP	HL			; Restore the filename pointer
044320 C9     10980 RET
              10981 ;
              10982 
              10983 
              10984 ; Extension lookup table
              10985 ; CSTR, TYPE
              10986 ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
              10987 ; 	- 1: Human readable plain text
              10988 ;
044321 2E     10989 EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
044322 42 
044323 42 
044324 43 
044324 00   
044325 00 
044327 2E     10990 DB	".TXT", 0, 1
044328 54 
044329 58 
04432A 54 
04432A 00   
04432B 01 
04432D 2E     10991 DB	".ASC", 0, 1
04432E 41 
04432F 53 
044330 43 
044330 00   
044331 01 
044333 2E     10992 DB	".BAS", 0, 1
044334 42 
044335 41 
044336 53 
044336 00   
044337 01 
044339 00     10993 DB	0			; End of table
              10994 
              10995 ;OSCALL - Intercept page &FF calls and provide an alternative address
              10996 ;
              10997 ;&FFF7:	OSCLI	Execute *command.
              10998 ;&FFF4:	OSBYTE	Various byte-wide functions.
              10999 ;&FFF1:	OSWORD	Various control block functions.
              11000 ;&FFEE:	OSWRCH	Write character to output stream.
              11001 ;&FFE7:	OSNEWL	Write NewLine to output stream.
              11002 ;&FFE3:	OSASCI	Write character or NewLine to output stream.
              11003 ;&FFE0:	OSRDCH	Wait for character from input stream.
              11004 ;&FFDD:	OSFILE	Perform actions on whole files or directories.
              11005 ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
              11006 ;&FFD7:	OSBGET	Read a byte from an a channel.
              11007 ;&FFD4:	OSBPUT	Write a byte to a channel.
              11008 ;&FFD1:	OSGBPB	Read and write blocks of data.
              11009 ;&FFCE:	OSFIND	Open or close a file.
              11010 ;
04433A 21     11011 OSCALL:			LD	HL, OSCALL_TABLE
04433B 50 
04433C 43 
04433D 04 
04433E 7E     11012 OSCALL_1:		LD	A, (HL)
04433F 23     11013 INC	HL
044340 FE     11014 CP	FFh
044341 FF 
044342 C8     11015 RET	Z
044343 FD     11016 CP	A, IYL
044344 BD 
044345 28     11017 JR	Z, OSCALL_2
044346 06 
044347 D0     11018 RET	NC
044348 23     11019 INC	HL
044349 23     11020 INC	HL
04434A 23     11021 INC	HL
04434B 18     11022 JR	OSCALL_1
04434C F1 
04434D ED     11023 OSCALL_2:		LD	IY,(HL)
04434E 31 
04434F C9     11024 RET
044350 D4     11025 OSCALL_TABLE:		DB 	D4h
044351 84     11026 DW24 	OSBPUT
044352 43 
044353 04 
044354 D7     11027 DB 	D7h
044355 7C     11028 DW24 	OSBGET
044356 43 
044357 04 
044358 EE     11029 DB 	EEh
044359 38     11030 DW24 	OSWRCH
04435A 3F 
04435B 04 
04435C F4     11031 DB	F4h
04435D 02     11032 DW24 	OSBYTE
04435E 41 
04435F 04 
044360 F7     11033 DB	F7h
044361 C8     11034 DW24	OSCLI
044362 3F 
044363 04 
044364 FF     11035 DB	FFh
              11036 
              11037 ; OSOPEN
              11038 ; HL: Pointer to path
              11039 ;  F: C Z
              11040 ;     x x OPENIN
              11041 ; 	  OPENOUT
              11042 ;     x	  OPENUP
              11043 ; Returns:
              11044 ;  A: Filehandle, 0 if cannot open
              11045 ;
044365 0E     11046 OSOPEN:			LD	C, fa_read
044366 01 
044367 28     11047 JR	Z, @F
044368 06 
044369 0E     11048 LD	C, fa_write | fa_open_append
04436A 32 
04436B 38     11049 JR	C, @F
04436C 02 
04436D 0E     11050 LD	C, fa_write | fa_create_always
04436E 0A 
              11051 @@:			MOSCALL	mos_fopen
04436F 3E     0001M LD	A, function
044370 0A 
044371 49     0002M RST.LIS	08h
044372 CF 
044373 C9     11052 RET
              11053 
              11054 ;OSSHUT - Close disk file(s).
              11055 ; E = file channel
              11056 ;  If E=0 all files are closed (except SPOOL)
              11057 ; Destroys: A,B,C,D,E,H,L,F
              11058 ;
044374 C5     11059 OSSHUT:			PUSH	BC
044375 4B     11060 LD	C, E
              11061 MOSCALL	mos_fclose
044376 3E     0001M LD	A, function
044377 0B 
044378 49     0002M RST.LIS	08h
044379 CF 
04437A C1     11062 POP	BC
04437B C9     11063 RET
              11064 
              11065 ; OSBGET - Read a byte from a random disk file.
              11066 ;  E = file channel
              11067 ; Returns
              11068 ;  A = byte read
              11069 ;  Carry set if LAST BYTE of file
              11070 ; Destroys: A,B,C,F
              11071 ;
04437C C5     11072 OSBGET:			PUSH	BC
04437D 4B     11073 LD	C, E
              11074 MOSCALL	mos_fgetc
04437E 3E     0001M LD	A, function
04437F 0C 
044380 49     0002M RST.LIS	08h
044381 CF 
044382 C1     11075 POP	BC
044383 C9     11076 RET
              11077 
              11078 ; OSBPUT - Write a byte to a random disk file.
              11079 ;  E = file channel
              11080 ;  A = byte to write
              11081 ; Destroys: A,B,C,F
              11082 ;
044384 C5     11083 OSBPUT:			PUSH	BC
044385 4B     11084 LD	C, E
044386 47     11085 LD	B, A
              11086 MOSCALL	mos_fputc
044387 3E     0001M LD	A, function
044388 0D 
044389 49     0002M RST.LIS	08h
04438A CF 
04438B C1     11087 POP	BC
04438C C9     11088 RET
              11089 
              11090 ; OSSTAT - Read file status
              11091 ;  E = file channel
              11092 ; Returns
              11093 ;  F: Z flag set - EOF
              11094 ;  A: If Z then A = 0
              11095 ; Destroys: A,D,E,H,L,F
              11096 ;
04438D C5     11097 OSSTAT:			PUSH	BC
04438E 4B     11098 LD	C, E
              11099 MOSCALL	mos_feof
04438F 3E     0001M LD	A, function
044390 0E 
044391 49     0002M RST.LIS	08h
044392 CF 
044393 C1     11100 POP	BC
044394 FE     11101 CP	1
044395 01 
044396 C9     11102 RET
              11103 
              11104 ; GETPTR - Return file pointer.
              11105 ;    E = file channel
              11106 ; Returns:
              11107 ; DEHL = pointer (0-&7FFFFF)
              11108 ; Destroys: A,B,C,D,E,H,L,F
              11109 ;
044397 FD     11110 GETPTR:			PUSH		IY
044398 E5 
044399 4B     11111 LD		C, E
              11112 MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
04439A 3E     0001M LD	A, function
04439B 19 
04439C 49     0002M RST.LIS	08h
04439D CF 
04439E E5     11113 PUSH		HL
04439F FD     11114 POP		IY		; IYU: Pointer to FIL structure
0443A0 E1 
0443A1 FD     11115 LD		L, (IY + FIL.fptr + 0)
0443A2 6E 
0443A3 11 
0443A4 FD     11116 LD		H, (IY + FIL.fptr + 1)
0443A5 66 
0443A6 12 
0443A7 FD     11117 LD		E, (IY + FIL.fptr + 2)
0443A8 5E 
0443A9 13 
0443AA FD     11118 LD		D, (IY + FIL.fptr + 3)
0443AB 56 
0443AC 14 
0443AD FD     11119 POP		IY
0443AE E1 
0443AF C9     11120 RET
              11121 
              11122 ; PUTPTR - Update file pointer.
              11123 ;    A = file channel
              11124 ; DEHL = new pointer (0-&7FFFFF)
              11125 ; Destroys: A,B,C,D,E,H,L,F
              11126 ;
0443B0 FD     11127 PUTPTR:			PUSH		IY
0443B1 E5 
0443B2 4F     11128 LD		C, A  		; C: Filehandle
0443B3 E5     11129 PUSH		HL
0443B4 21     11130 LD		HL, 2
0443B5 02 
0443B6 00 
0443B7 00 
0443B8 39     11131 ADD		HL, SP
0443B9 73     11132 LD		(HL), E 	; 3rd byte of DWORD set to E
0443BA E1     11133 POP		HL
0443BB 5A     11134 LD		E, D  		; 4th byte passed as E
              11135 MOSCALL		mos_flseek
0443BC 3E     0001M LD	A, function
0443BD 1C 
0443BE 49     0002M RST.LIS	08h
0443BF CF 
0443C0 FD     11136 POP		IY
0443C1 E1 
0443C2 C9     11137 RET
              11138 
              11139 ; GETEXT - Find file size.
              11140 ;    E = file channel
              11141 ; Returns:
              11142 ; DEHL = file size (0-&800000)
              11143 ; Destroys: A,B,C,D,E,H,L,F
              11144 ;
0443C3 FD     11145 GETEXT:         PUSH    IY
0443C4 E5 
0443C5 4B     11146 LD      C, E
              11147 MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443C6 3E     0001M LD	A, function
0443C7 19 
0443C8 49     0002M RST.LIS	08h
0443C9 CF 
0443CA E5     11148 PUSH    HL
0443CB FD     11149 POP     IY          ; IYU: Pointer to FIL structure
0443CC E1 
              11150 ; Access the obj.objsize field using the offset values
0443CD FD     11151 LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443CE 6E 
0443CF 0B 
0443D0 FD     11152 LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443D1 66 
0443D2 0C 
0443D3 FD     11153 LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443D4 5E 
0443D5 0D 
0443D6 FD     11154 LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443D7 56 
0443D8 0E 
              11155 
0443D9 FD     11156 POP     IY
0443DA E1 
0443DB C9     11157 RET
              11158 
              11159 ; GETIMS - Get time from RTC
              11160 ;
0443DC FD     11161 GETIMS:			PUSH	IY
0443DD E5 
0443DE 21     11162 LD	HL, ACCS 		; Where to store the time string
0443DF 00 
0443E0 4A 
0443E1 04 
              11163 MOSCALL	mos_getrtc
0443E2 3E     0001M LD	A, function
0443E3 12 
0443E4 49     0002M RST.LIS	08h
0443E5 CF 
0443E6 11     11164 LD	DE, ACCS		; DE: pointer to start of string accumulator
0443E7 00 
0443E8 4A 
0443E9 04 
0443EA 5F     11165 LD	E, A 			;  E: now points to the end of the string
0443EB FD     11166 POP	IY
0443EC E1 
0443ED C9     11167 RET
              11168 
              11169 ; Get two word values from EXPR in DE, HL
              11170 ; IY: Pointer to expression string
              11171 ; Returns:
              11172 ; DE: P1
              11173 ; HL: P2
              11174 ;
0443EE CD     11175 EXPR_W2:		CALL	EXPRI			; Get first parameter
0443EF 0F 
0443F0 03 
0443F1 04 
0443F2 D9     11176 EXX
0443F3 E5     11177 PUSH	HL
0443F4 CD     11178 CALL	COMMA
0443F5 2A 
0443F6 0A 
0443F7 04 
0443F8 CD     11179 CALL	EXPRI			; Get second parameter
0443F9 0F 
0443FA 03 
0443FB 04 
0443FC D9     11180 EXX
0443FD D1     11181 POP	DE
0443FE C9     11182 RET
              11183 
              11184 ; Stuff not implemented yet
              11185 ;
0443FF C9     11186 RESET:			RET
              11187 ; --- End patch.asm ---
              11188 
              11189 ; --- Begin agon_graphics.asm ---
              11190 ;
              11191 ; Title:	BBC Basic for AGON - Graphics stuff
              11192 ; Author:	Dean Belfield
              11193 ; Created:	12/05/2023
              11194 ; Last Updated:	07/06/2023
              11195 ;
              11196 ; Modinfo:
              11197 ; 07/06/2023:	Modified to run in ADL mode
              11198 
              11199 ; .ASSUME	ADL = 1
              11200 
              11201 ; INCLUDE	"equs.inc"
              11202 ; INCLUDE "macros.inc"
              11203 ; INCLUDE "mos_api.inc"	; In MOS/src
              11204 
              11205 ; SEGMENT CODE
              11206 
              11207 ; XDEF	CLG
              11208 ; XDEF	CLRSCN
              11209 ; XDEF	MODE
              11210 ; XDEF	COLOUR
              11211 ; XDEF	GCOL
              11212 ; XDEF	MOVE
              11213 ; XDEF	PLOT
              11214 ; XDEF	DRAW
              11215 ; XDEF	POINT
              11216 ; XDEF	GETSCHR
              11217 
              11218 ; XREF	OSWRCH
              11219 ; XREF	ASC_TO_NUMBER
              11220 ; XREF	EXTERR
              11221 ; XREF	EXPRI
              11222 ; XREF	COMMA
              11223 ; XREF	XEQ
              11224 ; XREF	NXT
              11225 ; XREF	BRAKET
              11226 ; XREF	COUNT0
              11227 ; XREF	CRTONULL
              11228 ; XREF	NULLTOCR
              11229 ; XREF	CRLF
              11230 ; XREF	EXPR_W2
              11231 ; XREF	INKEY1
              11232 
              11233 ; CLG: clears the graphics area
              11234 ;
              11235 CLG:			VDU	10h
044400 3E     0001M LD	A, val
044401 10 
044402 CD     0002M CALL	OSWRCH
044403 38 
044404 3F 
044405 04 
044406 C3     11236 JP	XEQ
044407 9E 
044408 0B 
044409 04 
              11237 
              11238 ; CLS: clears the text area
              11239 ;
04440A 3E     11240 CLRSCN:			LD	A, 0Ch
04440B 0C 
04440C C3     11241 JP	OSWRCH
04440D 38 
04440E 3F 
04440F 04 
              11242 
              11243 ; MODE n: Set video mode
              11244 ;
044410 DD     11245 MODE:			PUSH	IX			; Get the system vars in IX
044411 E5 
              11246 MOSCALL	mos_sysvars		; Reset the semaphore
044412 3E     0001M LD	A, function
044413 08 
044414 49     0002M RST.LIS	08h
044415 CF 
044416 DD     11247 RES	4, (IX+sysvar_vpd_pflags)
044417 CB 
044418 04 
044419 A6 
04441A CD     11248 CALL    EXPRI
04441B 0F 
04441C 03 
04441D 04 
04441E D9     11249 EXX
              11250 VDU	16H			; Mode change
04441F 3E     0001M LD	A, val
044420 16 
044421 CD     0002M CALL	OSWRCH
044422 38 
044423 3F 
044424 04 
              11251 VDU	L
044425 7D     0001M LD	A, val
044426 CD     0002M CALL	OSWRCH
044427 38 
044428 3F 
044429 04 
              11252 MOSCALL	mos_sysvars
04442A 3E     0001M LD	A, function
04442B 08 
04442C 49     0002M RST.LIS	08h
04442D CF 
04442E DD     11253 @@:			BIT	4, (IX+sysvar_vpd_pflags)
04442F CB 
044430 04 
044431 66 
044432 28     11254 JR	Z, @B			; Wait for the result
044433 FA 
044434 DD     11255 POP	IX
044435 E1 
044436 C3     11256 JP	XEQ
044437 9E 
044438 0B 
044439 04 
              11257 
              11258 ; GET(x,y): Get the ASCII code of a character on screen
              11259 ;
04443A FD     11260 GETSCHR:		INC	IY
04443B 23 
04443C CD     11261 CALL    EXPRI      		; Get X coordinate
04443D 0F 
04443E 03 
04443F 04 
044440 D9     11262 EXX
044441 22     11263 LD	(VDU_BUFFER+0), HL
044442 00 
044443 4A 
044444 04 
044445 CD     11264 CALL	COMMA
044446 2A 
044447 0A 
044448 04 
044449 CD     11265 CALL	EXPRI			; Get Y coordinate
04444A 0F 
04444B 03 
04444C 04 
04444D D9     11266 EXX
04444E 22     11267 LD	(VDU_BUFFER+2), HL
04444F 02 
044450 4A 
044451 04 
044452 CD     11268 CALL	BRAKET			; Closing bracket
044453 37 
044454 0A 
044455 04 
              11269 ;
044456 DD     11270 PUSH	IX			; Get the system vars in IX
044457 E5 
              11271 MOSCALL	mos_sysvars		; Reset the semaphore
044458 3E     0001M LD	A, function
044459 08 
04445A 49     0002M RST.LIS	08h
04445B CF 
04445C DD     11272 RES	1, (IX+sysvar_vpd_pflags)
04445D CB 
04445E 04 
04445F 8E 
              11273 VDU	23
044460 3E     0001M LD	A, val
044461 17 
044462 CD     0002M CALL	OSWRCH
044463 38 
044464 3F 
044465 04 
              11274 VDU	0
044466 3E     0001M LD	A, val
044467 00 
044468 CD     0002M CALL	OSWRCH
044469 38 
04446A 3F 
04446B 04 
              11275 VDU	vdp_scrchar
04446C 3E     0001M LD	A, val
04446D 83 
04446E CD     0002M CALL	OSWRCH
04446F 38 
044470 3F 
044471 04 
              11276 VDU	(VDU_BUFFER+0)
044472 3A     0001M LD	A, val
044473 00 
044474 4A 
044475 04 
044476 CD     0002M CALL	OSWRCH
044477 38 
044478 3F 
044479 04 
              11277 VDU	(VDU_BUFFER+1)
04447A 3A     0001M LD	A, val
04447B 01 
04447C 4A 
04447D 04 
04447E CD     0002M CALL	OSWRCH
04447F 38 
044480 3F 
044481 04 
              11278 VDU	(VDU_BUFFER+2)
044482 3A     0001M LD	A, val
044483 02 
044484 4A 
044485 04 
044486 CD     0002M CALL	OSWRCH
044487 38 
044488 3F 
044489 04 
              11279 VDU	(VDU_BUFFER+3)
04448A 3A     0001M LD	A, val
04448B 03 
04448C 4A 
04448D 04 
04448E CD     0002M CALL	OSWRCH
04448F 38 
044490 3F 
044491 04 
044492 DD     11280 @@:			BIT	1, (IX+sysvar_vpd_pflags)
044493 CB 
044494 04 
044495 4E 
044496 28     11281 JR	Z, @B			; Wait for the result
044497 FA 
044498 DD     11282 LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
044499 7E 
04449A 09 
04449B B7     11283 OR	A			; Check for 00h
04449C 37     11284 SCF				; C = character map
04449D 20     11285 JR	NZ, @F			; We have a character, so skip next bit
04449E 02 
04449F AF     11286 XOR	A			; Clear carry
0444A0 3D     11287 DEC	A			; Set A to FFh
0444A1 DD     11288 @@:			POP	IX
0444A2 E1 
0444A3 C3     11289 JP	INKEY1			; Jump back to the GET command
0444A4 E6 
0444A5 07 
0444A6 04 
              11290 
              11291 ; POINT(x,y): Get the pixel colour of a point on screen
              11292 ;
0444A7 CD     11293 POINT:			CALL    EXPRI      		; Get X coordinate
0444A8 0F 
0444A9 03 
0444AA 04 
0444AB D9     11294 EXX
0444AC 22     11295 LD	(VDU_BUFFER+0), HL
0444AD 00 
0444AE 4A 
0444AF 04 
0444B0 CD     11296 CALL	COMMA
0444B1 2A 
0444B2 0A 
0444B3 04 
0444B4 CD     11297 CALL	EXPRI			; Get Y coordinate
0444B5 0F 
0444B6 03 
0444B7 04 
0444B8 D9     11298 EXX
0444B9 22     11299 LD	(VDU_BUFFER+2), HL
0444BA 02 
0444BB 4A 
0444BC 04 
0444BD CD     11300 CALL	BRAKET			; Closing bracket
0444BE 37 
0444BF 0A 
0444C0 04 
              11301 ;
0444C1 DD     11302 PUSH	IX			; Get the system vars in IX
0444C2 E5 
              11303 MOSCALL	mos_sysvars		; Reset the semaphore
0444C3 3E     0001M LD	A, function
0444C4 08 
0444C5 49     0002M RST.LIS	08h
0444C6 CF 
0444C7 DD     11304 RES	2, (IX+sysvar_vpd_pflags)
0444C8 CB 
0444C9 04 
0444CA 96 
              11305 VDU	23
0444CB 3E     0001M LD	A, val
0444CC 17 
0444CD CD     0002M CALL	OSWRCH
0444CE 38 
0444CF 3F 
0444D0 04 
              11306 VDU	0
0444D1 3E     0001M LD	A, val
0444D2 00 
0444D3 CD     0002M CALL	OSWRCH
0444D4 38 
0444D5 3F 
0444D6 04 
              11307 VDU	vdp_scrpixel
0444D7 3E     0001M LD	A, val
0444D8 84 
0444D9 CD     0002M CALL	OSWRCH
0444DA 38 
0444DB 3F 
0444DC 04 
              11308 VDU	(VDU_BUFFER+0)
0444DD 3A     0001M LD	A, val
0444DE 00 
0444DF 4A 
0444E0 04 
0444E1 CD     0002M CALL	OSWRCH
0444E2 38 
0444E3 3F 
0444E4 04 
              11309 VDU	(VDU_BUFFER+1)
0444E5 3A     0001M LD	A, val
0444E6 01 
0444E7 4A 
0444E8 04 
0444E9 CD     0002M CALL	OSWRCH
0444EA 38 
0444EB 3F 
0444EC 04 
              11310 VDU	(VDU_BUFFER+2)
0444ED 3A     0001M LD	A, val
0444EE 02 
0444EF 4A 
0444F0 04 
0444F1 CD     0002M CALL	OSWRCH
0444F2 38 
0444F3 3F 
0444F4 04 
              11311 VDU	(VDU_BUFFER+3)
0444F5 3A     0001M LD	A, val
0444F6 03 
0444F7 4A 
0444F8 04 
0444F9 CD     0002M CALL	OSWRCH
0444FA 38 
0444FB 3F 
0444FC 04 
0444FD DD     11312 @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444FE CB 
0444FF 04 
044500 56 
044501 28     11313 JR	Z, @B			; Wait for the result
044502 FA 
              11314 ;
              11315 ; Return the data as a 1 byte index
              11316 ;
044503 DD     11317 LD	L, (IX+sysvar_scrpixelIndex)
044504 6E 
044505 16 
044506 DD     11318 POP	IX
044507 E1 
044508 C3     11319 JP	COUNT0
044509 84 
04450A 05 
04450B 04 
              11320 
              11321 
              11322 ; COLOUR colour
              11323 ; COLOUR L,P
              11324 ; COLOUR L,R,G,B
              11325 ;
04450C CD     11326 COLOUR:			CALL	EXPRI			; The colour / mode
04450D 0F 
04450E 03 
04450F 04 
044510 D9     11327 EXX
044511 7D     11328 LD	A, L
044512 32     11329 LD	(VDU_BUFFER+0), A	; Store first parameter
044513 00 
044514 4A 
044515 04 
044516 CD     11330 CALL	NXT			; Are there any more parameters?
044517 78 
044518 0A 
044519 04 
04451A FE     11331 CP	','
04451B 2C 
04451C 28     11332 JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
04451D 12 
              11333 ;
              11334 VDU	11h			; Just set the colour
04451E 3E     0001M LD	A, val
04451F 11 
044520 CD     0002M CALL	OSWRCH
044521 38 
044522 3F 
044523 04 
              11335 VDU	(VDU_BUFFER+0)
044524 3A     0001M LD	A, val
044525 00 
044526 4A 
044527 04 
044528 CD     0002M CALL	OSWRCH
044529 38 
04452A 3F 
04452B 04 
04452C C3     11336 JP	XEQ
04452D 9E 
04452E 0B 
04452F 04 
              11337 ;
044530 CD     11338 COLOUR_1:		CALL	COMMA
044531 2A 
044532 0A 
044533 04 
044534 CD     11339 CALL	EXPRI			; Parse R (OR P)
044535 0F 
044536 03 
044537 04 
044538 D9     11340 EXX
044539 7D     11341 LD	A, L
04453A 32     11342 LD	(VDU_BUFFER+1), A
04453B 01 
04453C 4A 
04453D 04 
04453E CD     11343 CALL	NXT			; Are there any more parameters?
04453F 78 
044540 0A 
044541 04 
044542 FE     11344 CP	','
044543 2C 
044544 28     11345 JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044545 2C 
              11346 ;
              11347 VDU	13h			; VDU:COLOUR
044546 3E     0001M LD	A, val
044547 13 
044548 CD     0002M CALL	OSWRCH
044549 38 
04454A 3F 
04454B 04 
              11348 VDU	(VDU_BUFFER+0)		; Logical Colour
04454C 3A     0001M LD	A, val
04454D 00 
04454E 4A 
04454F 04 
044550 CD     0002M CALL	OSWRCH
044551 38 
044552 3F 
044553 04 
              11349 VDU	(VDU_BUFFER+1)		; Palette Colour
044554 3A     0001M LD	A, val
044555 01 
044556 4A 
044557 04 
044558 CD     0002M CALL	OSWRCH
044559 38 
04455A 3F 
04455B 04 
              11350 VDU	0			; RGB set to 0
04455C 3E     0001M LD	A, val
04455D 00 
04455E CD     0002M CALL	OSWRCH
04455F 38 
044560 3F 
044561 04 
              11351 VDU	0
044562 3E     0001M LD	A, val
044563 00 
044564 CD     0002M CALL	OSWRCH
044565 38 
044566 3F 
044567 04 
              11352 VDU	0
044568 3E     0001M LD	A, val
044569 00 
04456A CD     0002M CALL	OSWRCH
04456B 38 
04456C 3F 
04456D 04 
04456E C3     11353 JP	XEQ
04456F 9E 
044570 0B 
044571 04 
              11354 ;
044572 CD     11355 COLOUR_2:		CALL	COMMA
044573 2A 
044574 0A 
044575 04 
044576 CD     11356 CALL	EXPRI			; Parse G
044577 0F 
044578 03 
044579 04 
04457A D9     11357 EXX
04457B 7D     11358 LD	A, L
04457C 32     11359 LD	(VDU_BUFFER+2), A
04457D 02 
04457E 4A 
04457F 04 
044580 CD     11360 CALL	COMMA
044581 2A 
044582 0A 
044583 04 
044584 CD     11361 CALL	EXPRI			; Parse B
044585 0F 
044586 03 
044587 04 
044588 D9     11362 EXX
044589 7D     11363 LD	A, L
04458A 32     11364 LD	(VDU_BUFFER+3), A
04458B 03 
04458C 4A 
04458D 04 
              11365 VDU	13h			; VDU:COLOUR
04458E 3E     0001M LD	A, val
04458F 13 
044590 CD     0002M CALL	OSWRCH
044591 38 
044592 3F 
044593 04 
              11366 VDU	(VDU_BUFFER+0)		; Logical Colour
044594 3A     0001M LD	A, val
044595 00 
044596 4A 
044597 04 
044598 CD     0002M CALL	OSWRCH
044599 38 
04459A 3F 
04459B 04 
              11367 VDU	FFh			; Physical Colour (-1 for RGB mode)
04459C 3E     0001M LD	A, val
04459D FF 
04459E CD     0002M CALL	OSWRCH
04459F 38 
0445A0 3F 
0445A1 04 
              11368 VDU	(VDU_BUFFER+1)		; R
0445A2 3A     0001M LD	A, val
0445A3 01 
0445A4 4A 
0445A5 04 
0445A6 CD     0002M CALL	OSWRCH
0445A7 38 
0445A8 3F 
0445A9 04 
              11369 VDU	(VDU_BUFFER+2)		; G
0445AA 3A     0001M LD	A, val
0445AB 02 
0445AC 4A 
0445AD 04 
0445AE CD     0002M CALL	OSWRCH
0445AF 38 
0445B0 3F 
0445B1 04 
              11370 VDU	(VDU_BUFFER+3)		; B
0445B2 3A     0001M LD	A, val
0445B3 03 
0445B4 4A 
0445B5 04 
0445B6 CD     0002M CALL	OSWRCH
0445B7 38 
0445B8 3F 
0445B9 04 
0445BA C3     11371 JP	XEQ
0445BB 9E 
0445BC 0B 
0445BD 04 
              11372 
              11373 ; GCOL mode,colour
              11374 ;
0445BE CD     11375 GCOL:			CALL	EXPRI			; Parse MODE
0445BF 0F 
0445C0 03 
0445C1 04 
0445C2 D9     11376 EXX
0445C3 7D     11377 LD	A, L
0445C4 32     11378 LD	(VDU_BUFFER+0), A
0445C5 00 
0445C6 4A 
0445C7 04 
0445C8 CD     11379 CALL	COMMA
0445C9 2A 
0445CA 0A 
0445CB 04 
              11380 ;
0445CC CD     11381 CALL	EXPRI			; Parse Colour
0445CD 0F 
0445CE 03 
0445CF 04 
0445D0 D9     11382 EXX
0445D1 7D     11383 LD	A, L
0445D2 32     11384 LD	(VDU_BUFFER+1), A
0445D3 01 
0445D4 4A 
0445D5 04 
              11385 ;
              11386 VDU	12h			; VDU:GCOL
0445D6 3E     0001M LD	A, val
0445D7 12 
0445D8 CD     0002M CALL	OSWRCH
0445D9 38 
0445DA 3F 
0445DB 04 
              11387 VDU	(VDU_BUFFER+0)		; Mode
0445DC 3A     0001M LD	A, val
0445DD 00 
0445DE 4A 
0445DF 04 
0445E0 CD     0002M CALL	OSWRCH
0445E1 38 
0445E2 3F 
0445E3 04 
              11388 VDU	(VDU_BUFFER+1)		; Colour
0445E4 3A     0001M LD	A, val
0445E5 01 
0445E6 4A 
0445E7 04 
0445E8 CD     0002M CALL	OSWRCH
0445E9 38 
0445EA 3F 
0445EB 04 
0445EC C3     11389 JP	XEQ
0445ED 9E 
0445EE 0B 
0445EF 04 
              11390 
              11391 ; PLOT mode,x,y
              11392 ;
0445F0 CD     11393 PLOT:			CALL	EXPRI		; Parse mode
0445F1 0F 
0445F2 03 
0445F3 04 
0445F4 D9     11394 EXX
0445F5 E5     11395 PUSH	HL		; Push mode (L) onto stack
0445F6 CD     11396 CALL	COMMA
0445F7 2A 
0445F8 0A 
0445F9 04 
0445FA CD     11397 CALL	EXPR_W2		; Parse X and Y
0445FB EE 
0445FC 43 
0445FD 04 
0445FE C1     11398 POP	BC		; Pop mode (C) off stack
              11399 PLOT_1:			VDU	19H		; VDU code for PLOT
0445FF 3E     0001M LD	A, val
044600 19 
044601 CD     0002M CALL	OSWRCH
044602 38 
044603 3F 
044604 04 
              11400 VDU	C		;  C: Mode
044605 79     0001M LD	A, val
044606 CD     0002M CALL	OSWRCH
044607 38 
044608 3F 
044609 04 
              11401 VDU	E		; DE: X
04460A 7B     0001M LD	A, val
04460B CD     0002M CALL	OSWRCH
04460C 38 
04460D 3F 
04460E 04 
              11402 VDU	D
04460F 7A     0001M LD	A, val
044610 CD     0002M CALL	OSWRCH
044611 38 
044612 3F 
044613 04 
              11403 VDU	L		; HL: Y
044614 7D     0001M LD	A, val
044615 CD     0002M CALL	OSWRCH
044616 38 
044617 3F 
044618 04 
              11404 VDU	H
044619 7C     0001M LD	A, val
04461A CD     0002M CALL	OSWRCH
04461B 38 
04461C 3F 
04461D 04 
04461E C3     11405 JP	XEQ
04461F 9E 
044620 0B 
044621 04 
              11406 
              11407 ; MOVE x,y
              11408 ;
044622 CD     11409 MOVE:			CALL	EXPR_W2		; Parse X and Y
044623 EE 
044624 43 
044625 04 
044626 0E     11410 LD	C, 04H		; Plot mode 04H (Move)
044627 04 
044628 18     11411 JR	PLOT_1		; Plot
044629 D5 
              11412 
              11413 ; DRAW x1,y1
              11414 ; DRAW x1,y1,x2,y2
              11415 ;
04462A CD     11416 DRAW:			CALL	EXPR_W2		; Get X1 and Y1
04462B EE 
04462C 43 
04462D 04 
04462E CD     11417 CALL	NXT		; Are there any more parameters?
04462F 78 
044630 0A 
044631 04 
044632 FE     11418 CP	','
044633 2C 
044634 0E     11419 LD	C, 05h		; Code for LINE
044635 05 
044636 20     11420 JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044637 C7 
              11421 VDU	19h		; Move to the first coordinates
044638 3E     0001M LD	A, val
044639 19 
04463A CD     0002M CALL	OSWRCH
04463B 38 
04463C 3F 
04463D 04 
              11422 VDU	04h
04463E 3E     0001M LD	A, val
04463F 04 
044640 CD     0002M CALL	OSWRCH
044641 38 
044642 3F 
044643 04 
              11423 VDU	E
044644 7B     0001M LD	A, val
044645 CD     0002M CALL	OSWRCH
044646 38 
044647 3F 
044648 04 
              11424 VDU	D
044649 7A     0001M LD	A, val
04464A CD     0002M CALL	OSWRCH
04464B 38 
04464C 3F 
04464D 04 
              11425 VDU	L
04464E 7D     0001M LD	A, val
04464F CD     0002M CALL	OSWRCH
044650 38 
044651 3F 
044652 04 
              11426 VDU	H
044653 7C     0001M LD	A, val
044654 CD     0002M CALL	OSWRCH
044655 38 
044656 3F 
044657 04 
044658 CD     11427 CALL	COMMA
044659 2A 
04465A 0A 
04465B 04 
04465C C5     11428 PUSH	BC
04465D CD     11429 CALL	EXPR_W2		; Get X2 and Y2
04465E EE 
04465F 43 
044660 04 
044661 C1     11430 POP	BC
044662 18     11431 JR	PLOT_1		; Now DRAW the line to those positions
044663 9B 
              11432 
              11433 
              11434 
              11435 ; --- End agon_graphics.asm ---
              11436 
              11437 ; --- Begin agon_sound.asm ---
              11438 ;
              11439 ; Title:	BBC Basic for AGON - Audio stuff
              11440 ; Author:	Dean Belfield
              11441 ; Created:	12/05/2023
              11442 ; Last Updated:	12/05/2023
              11443 ;
              11444 ; Modinfo:
              11445 
              11446 ; .ASSUME	ADL = 1
              11447 
              11448 ; INCLUDE	"equs.inc"
              11449 ; INCLUDE "macros.inc"
              11450 ; INCLUDE "mos_api.inc"	; In MOS/src
              11451 
              11452 ; SEGMENT CODE
              11453 
              11454 ; XDEF	SOUND
              11455 
              11456 ; XREF	COMMA
              11457 ; XREF	EXPR_W2
              11458 ; XREF	XEQ
              11459 ; XREF	LTRAP
              11460 ; XREF	OSWRCH
              11461 ; XREF	VDU_BUFFER
              11462 
              11463 
              11464 ; SOUND channel,volume,pitch,duration
              11465 ; volume: 0 (off) to -15 (full volume)
              11466 ; pitch: 0 - 255
              11467 ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
              11468 ;
044664 CD     11469 SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044665 EE 
044666 43 
044667 04 
044668 7D     11470 LD	A, L 			;  A: Volume
044669 F5     11471 PUSH	AF
04466A D5     11472 PUSH	DE
04466B CD     11473 CALL	COMMA
04466C 2A 
04466D 0A 
04466E 04 
04466F CD     11474 CALL	EXPR_W2			; DE: Pitch, HL: Duration
044670 EE 
044671 43 
044672 04 
044673 53     11475 LD	D, E			;  D: Pitch
044674 5D     11476 LD	E, L 			;  E: Duration
044675 E1     11477 POP	HL 			; HL: Channel/Control
044676 F1     11478 POP	AF
044677 ED     11479 NEG
044678 44 
044679 FE     11480 CP	16			; Check volume is in bounds
04467A 10 
04467B D2     11481 JP	NC, XEQ			; Out of bounds, do nothing
04467C 9E 
04467D 0B 
04467E 04 
              11482 ;
              11483 ; Store	in VDU vars
              11484 ;
04467F 4F     11485 LD	C, A			; Store Volume in C
044680 7D     11486 LD	A, L
044681 32     11487 LD	(VDU_BUFFER+0), A	; Channel
044682 00 
044683 4A 
044684 04 
044685 AF     11488 XOR	A
044686 32     11489 LD	(VDU_BUFFER+1), A	; Waveform
044687 01 
044688 4A 
044689 04 
              11490 ;
              11491 ; Calculate the volume
              11492 ;
04468A 06     11493 LD	B, 6			; C already contains the volume
04468B 06 
04468C ED     11494 MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
04468D 4C 
04468E 79     11495 LD	A, C
04468F 32     11496 LD	(VDU_BUFFER+2), A
044690 02 
044691 4A 
044692 04 
              11497 ;
              11498 ; And the frequency
              11499 ;
044693 4B     11500 LD	C, E			; Store duration in C
044694 26     11501 LD	H, 0			; Lookup the frequency
044695 00 
044696 6A     11502 LD	L, D
044697 11     11503 LD	DE, SOUND_FREQ_LOOKUP
044698 1E 
044699 47 
04469A 04 
04469B 29     11504 ADD	HL, HL
04469C 19     11505 ADD	HL, DE
04469D 7E     11506 LD	A, (HL)
04469E 32     11507 LD	(VDU_BUFFER+3), A
04469F 03 
0446A0 4A 
0446A1 04 
0446A2 23     11508 INC	HL
0446A3 7E     11509 LD	A, (HL)
0446A4 32     11510 LD	(VDU_BUFFER+4), A
0446A5 04 
0446A6 4A 
0446A7 04 
              11511 ;
              11512 ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
              11513 ;
0446A8 06     11514 LD	B, 50			; C contains the duration, so MLT by 50
0446A9 32 
0446AA ED     11515 MLT	BC
0446AB 4C 
0446AC ED     11516 LD	(VDU_BUFFER+5), BC
0446AD 43 
0446AE 05 
0446AF 4A 
0446AF 04   
              11517 ;
0446B1 DD     11518 PUSH	IX			; Get the system vars in IX
0446B2 E5 
              11519 MOSCALL	mos_sysvars		; Reset the semaphore
0446B3 3E     0001M LD	A, function
0446B4 08 
0446B5 49     0002M RST.LIS	08h
0446B6 CF 
0446B7 5B     11520 SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
0446B8 DD 
0446B9 CB 
0446BA 04 
0446BA 9E   
              11521 ;
              11522 VDU	23			; Send the sound command
0446BC 3E     0001M LD	A, val
0446BD 17 
0446BE CD     0002M CALL	OSWRCH
0446BF 38 
0446C0 3F 
0446C1 04 
              11523 VDU	0
0446C2 3E     0001M LD	A, val
0446C3 00 
0446C4 CD     0002M CALL	OSWRCH
0446C5 38 
0446C6 3F 
0446C7 04 
              11524 VDU	vdp_audio
0446C8 3E     0001M LD	A, val
0446C9 85 
0446CA CD     0002M CALL	OSWRCH
0446CB 38 
0446CC 3F 
0446CD 04 
              11525 VDU	(VDU_BUFFER+0)		; 0: Channel
0446CE 3A     0001M LD	A, val
0446CF 00 
0446D0 4A 
0446D1 04 
0446D2 CD     0002M CALL	OSWRCH
0446D3 38 
0446D4 3F 
0446D5 04 
              11526 VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446D6 3A     0001M LD	A, val
0446D7 01 
0446D8 4A 
0446D9 04 
0446DA CD     0002M CALL	OSWRCH
0446DB 38 
0446DC 3F 
0446DD 04 
              11527 VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446DE 3A     0001M LD	A, val
0446DF 02 
0446E0 4A 
0446E1 04 
0446E2 CD     0002M CALL	OSWRCH
0446E3 38 
0446E4 3F 
0446E5 04 
              11528 VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446E6 3A     0001M LD	A, val
0446E7 03 
0446E8 4A 
0446E9 04 
0446EA CD     0002M CALL	OSWRCH
0446EB 38 
0446EC 3F 
0446ED 04 
              11529 VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446EE 3A     0001M LD	A, val
0446EF 04 
0446F0 4A 
0446F1 04 
0446F2 CD     0002M CALL	OSWRCH
0446F3 38 
0446F4 3F 
0446F5 04 
              11530 VDU	(VDU_BUFFER+5)		; 5: Duration L
0446F6 3A     0001M LD	A, val
0446F7 05 
0446F8 4A 
0446F9 04 
0446FA CD     0002M CALL	OSWRCH
0446FB 38 
0446FC 3F 
0446FD 04 
              11531 VDU	(VDU_BUFFER+6)		; 6: Duration H
0446FE 3A     0001M LD	A, val
0446FF 06 
044700 4A 
044701 04 
044702 CD     0002M CALL	OSWRCH
044703 38 
044704 3F 
044705 04 
              11532 ;
              11533 ; Wait for acknowledgement
              11534 ;
044706 5B     11535 @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
044707 DD 
044708 CB 
044709 04 
044709 5E   
04470B 28     11536 JR	Z, @B			; Wait for the result
04470C F9 
04470D CD     11537 CALL	LTRAP			; Check for ESC
04470E A9 
04470F 3F 
044710 04 
044711 5B     11538 LD.LIL	A, (IX+sysvar_audioSuccess)
044712 DD 
044713 7E 
044714 0E 
044715 A7     11539 AND	A			; Check if VDP has queued the note
044716 28     11540 JR	Z, SOUND0		; No, so loop back and send again
044717 9F 
              11541 ;
044718 DD     11542 POP	IX
044719 E1 
04471A C3     11543 JP	XEQ
04471B 9E 
04471C 0B 
04471D 04 
              11544 
              11545 ; Frequency Lookup Table
              11546 ; Set up to replicate the BBC Micro audio frequencies
              11547 ;
              11548 ; Split over 5 complete octaves, with 53 being middle C
              11549 ; * C4: 262hz
              11550 ; + A4: 440hz
              11551 ;
              11552 ;	2	3	4	5	6	7	8
              11553 ;
              11554 ; B	1	49	97	145	193	241
              11555 ; A#	0	45	93	141	189	237
              11556 ; A		41	89+	137	185	233
              11557 ; G#		37	85	133	181	229
              11558 ; G		33	81	129	177	225
              11559 ; F#		29	77	125	173	221
              11560 ; F		25	73	121	169	217
              11561 ; E		21	69	117	165	213
              11562 ; D#		17	65	113	161	209
              11563 ; D		13	61	109	157	205	253
              11564 ; C#		9	57	105	153	201	249
              11565 ; C		5	53*	101	149	197	245
              11566 ;
04471E 75     11567 SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
04471F 00 
044720 76 
044721 00 
044721 78   
044722 00 
044723 7A 
044724 00 
044724 7B   
044725 00 
044726 83 
044727 00 
044727 85   
044728 00 
044729 87 
04472A 00 
04472E 89     11568 DW	 137,  139,  141,  143,  145,  147,  149,  151
04472F 00 
044730 8B 
044731 00 
044731 8D   
044732 00 
044733 8F 
044734 00 
044734 91   
044735 00 
044736 93 
044737 00 
044737 95   
044738 00 
044739 97 
04473A 00 
04473E 99     11569 DW	 153,  156,  158,  160,  162,  165,  167,  170
04473F 00 
044740 9C 
044741 00 
044741 9E   
044742 00 
044743 A0 
044744 00 
044744 A2   
044745 00 
044746 A5 
044747 00 
044747 A7   
044748 00 
044749 AA 
04474A 00 
04474E AC     11570 DW	 172,  175,  177,  180,  182,  185,  188,  190
04474F 00 
044750 AF 
044751 00 
044751 B1   
044752 00 
044753 B4 
044754 00 
044754 B6   
044755 00 
044756 B9 
044757 00 
044757 BC   
044758 00 
044759 BE 
04475A 00 
04475E C1     11571 DW	 193,  196,  199,  202,  205,  208,  211,  214
04475F 00 
044760 C4 
044761 00 
044761 C7   
044762 00 
044763 CA 
044764 00 
044764 CD   
044765 00 
044766 D0 
044767 00 
044767 D3   
044768 00 
044769 D6 
04476A 00 
04476E D9     11572 DW	 217,  220,  223,  226,  230,  233,  236,  240
04476F 00 
044770 DC 
044771 00 
044771 DF   
044772 00 
044773 E2 
044774 00 
044774 E6   
044775 00 
044776 E9 
044777 00 
044777 EC   
044778 00 
044779 F0 
04477A 00 
04477E F3     11573 DW	 243,  247,  251,  254,  258,  262,  265,  269
04477F 00 
044780 F7 
044781 00 
044781 FB   
044782 00 
044783 FE 
044784 00 
044784 02   
044785 01 
044786 06 
044787 01 
044787 09   
044788 01 
044789 0D 
04478A 01 
04478E 11     11574 DW	 273,  277,  281,  285,  289,  294,  298,  302
04478F 01 
044790 15 
044791 01 
044791 19   
044792 01 
044793 1D 
044794 01 
044794 21   
044795 01 
044796 26 
044797 01 
044797 2A   
044798 01 
044799 2E 
04479A 01 
04479E 33     11575 DW	 307,  311,  316,  320,  325,  330,  334,  339
04479F 01 
0447A0 37 
0447A1 01 
0447A1 3C   
0447A2 01 
0447A3 40 
0447A4 01 
0447A4 45   
0447A5 01 
0447A6 4A 
0447A7 01 
0447A7 4E   
0447A8 01 
0447A9 53 
0447AA 01 
0447AE 58     11576 DW	 344,  349,  354,  359,  365,  370,  375,  381
0447AF 01 
0447B0 5D 
0447B1 01 
0447B1 62   
0447B2 01 
0447B3 67 
0447B4 01 
0447B4 6D   
0447B5 01 
0447B6 72 
0447B7 01 
0447B7 77   
0447B8 01 
0447B9 7D 
0447BA 01 
0447BE 82     11577 DW	 386,  392,  398,  403,  409,  415,  421,  427
0447BF 01 
0447C0 88 
0447C1 01 
0447C1 8E   
0447C2 01 
0447C3 93 
0447C4 01 
0447C4 99   
0447C5 01 
0447C6 9F 
0447C7 01 
0447C7 A5   
0447C8 01 
0447C9 AB 
0447CA 01 
0447CE B2     11578 DW	 434,  440,  446,  453,  459,  466,  473,  480
0447CF 01 
0447D0 B8 
0447D1 01 
0447D1 BE   
0447D2 01 
0447D3 C5 
0447D4 01 
0447D4 CB   
0447D5 01 
0447D6 D2 
0447D7 01 
0447D7 D9   
0447D8 01 
0447D9 E0 
0447DA 01 
0447DE E7     11579 DW	 487,  494,  501,  508,  516,  523,  531,  539
0447DF 01 
0447E0 EE 
0447E1 01 
0447E1 F5   
0447E2 01 
0447E3 FC 
0447E4 01 
0447E4 04   
0447E5 02 
0447E6 0B 
0447E7 02 
0447E7 13   
0447E8 02 
0447E9 1B 
0447EA 02 
0447EE 22     11580 DW	 546,  554,  562,  571,  579,  587,  596,  605
0447EF 02 
0447F0 2A 
0447F1 02 
0447F1 32   
0447F2 02 
0447F3 3B 
0447F4 02 
0447F4 43   
0447F5 02 
0447F6 4B 
0447F7 02 
0447F7 54   
0447F8 02 
0447F9 5D 
0447FA 02 
0447FE 65     11581 DW	 613,  622,  631,  641,  650,  659,  669,  679
0447FF 02 
044800 6E 
044801 02 
044801 77   
044802 02 
044803 81 
044804 02 
044804 8A   
044805 02 
044806 93 
044807 02 
044807 9D   
044808 02 
044809 A7 
04480A 02 
04480E B1     11582 DW	 689,  699,  709,  719,  729,  740,  751,  762
04480F 02 
044810 BB 
044811 02 
044811 C5   
044812 02 
044813 CF 
044814 02 
044814 D9   
044815 02 
044816 E4 
044817 02 
044817 EF   
044818 02 
044819 FA 
04481A 02 
04481E 05     11583 DW	 773,  784,  795,  807,  819,  831,  843,  855
04481F 03 
044820 10 
044821 03 
044821 1B   
044822 03 
044823 27 
044824 03 
044824 33   
044825 03 
044826 3F 
044827 03 
044827 4B   
044828 03 
044829 57 
04482A 03 
04482E 63     11584 DW	 867,  880,  893,  906,  919,  932,  946,  960
04482F 03 
044830 70 
044831 03 
044831 7D   
044832 03 
044833 8A 
044834 03 
044834 97   
044835 03 
044836 A4 
044837 03 
044837 B2   
044838 03 
044839 C0 
04483A 03 
04483E CE     11585 DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
04483F 03 
044840 DC 
044841 03 
044841 EA   
044842 03 
044843 F9 
044844 03 
044844 08   
044845 04 
044846 17 
044847 04 
044847 26   
044848 04 
044849 36 
04484A 04 
04484E 45     11586 DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
04484F 04 
044850 55 
044851 04 
044851 65   
044852 04 
044853 76 
044854 04 
044854 86   
044855 04 
044856 97 
044857 04 
044857 A8   
044858 04 
044859 BA 
04485A 04 
04485E CB     11587 DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
04485F 04 
044860 DD 
044861 04 
044861 EF   
044862 04 
044863 02 
044864 05 
044864 14   
044865 05 
044866 27 
044867 05 
044867 3A   
044868 05 
044869 4E 
04486A 05 
04486E 62     11588 DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
04486F 05 
044870 76 
044871 05 
044871 8A   
044872 05 
044873 9F 
044874 05 
044874 B3   
044875 05 
044876 C9 
044877 05 
044877 DE   
044878 05 
044879 F4 
04487A 05 
04487E 0A     11589 DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
04487F 06 
044880 21 
044881 06 
044881 38   
044882 06 
044883 4F 
044884 06 
044884 66   
044885 06 
044886 7E 
044887 06 
044887 96   
044888 06 
044889 AF 
04488A 06 
04488E C8     11590 DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
04488F 06 
044890 E1 
044891 06 
044891 FA   
044892 06 
044893 14 
044894 07 
044894 2F   
044895 07 
044896 4A 
044897 07 
044897 65   
044898 07 
044899 80 
04489A 07 
04489E 9C     11591 DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
04489F 07 
0448A0 B8 
0448A1 07 
0448A1 D5   
0448A2 07 
0448A3 F2 
0448A4 07 
0448A4 10   
0448A5 08 
0448A6 2D 
0448A7 08 
0448A7 4B   
0448A8 08 
0448A9 6A 
0448AA 08 
0448AE 8A     11592 DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
0448AF 08 
0448B0 A9 
0448B1 08 
0448B1 CA   
0448B2 08 
0448B3 EA 
0448B4 08 
0448B4 0C   
0448B5 09 
0448B6 2D 
0448B7 09 
0448B7 4F   
0448B8 09 
0448B9 72 
0448BA 09 
0448BE 95     11593 DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
0448BF 09 
0448C0 B9 
0448C1 09 
0448C1 DD   
0448C2 09 
0448C3 02 
0448C4 0A 
0448C4 27   
0448C5 0A 
0448C6 4D 
0448C7 0A 
0448C7 73   
0448C8 0A 
0448C9 9A 
0448CA 0A 
0448CE C2     11594 DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
0448CF 0A 
0448D0 EA 
0448D1 0A 
0448D1 12   
0448D2 0B 
0448D3 3C 
0448D4 0B 
0448D4 66   
0448D5 0B 
0448D6 90 
0448D7 0B 
0448D7 BB   
0448D8 0B 
0448D9 E7 
0448DA 0B 
0448DE 13     11595 DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
0448DF 0C 
0448E0 40 
0448E1 0C 
0448E1 6E   
0448E2 0C 
0448E3 9C 
0448E4 0C 
0448E4 CB   
0448E5 0C 
0448E6 FA 
0448E7 0C 
0448E7 2B   
0448E8 0D 
0448E9 5C 
0448EA 0D 
0448EE 8E     11596 DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
0448EF 0D 
0448F0 C0 
0448F1 0D 
0448F1 F3   
0448F2 0D 
0448F3 27 
0448F4 0E 
0448F4 5C   
0448F5 0E 
0448F6 91 
0448F7 0E 
0448F7 C8   
0448F8 0E 
0448F9 FF 
0448FA 0E 
0448FE 36     11597 DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
0448FF 0F 
044900 6F 
044901 0F 
044901 A9   
044902 0F 
044903 E3 
044904 0F 
044904 1E   
044905 10 
044906 5A 
044907 10 
044907 97   
044908 10 
044909 D5 
04490A 10 
04490E 13     11598 DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
04490F 11 
044910 53 
044911 11 
044911 93   
044912 11 
044913 D5 
044914 11 
044914 17   
044915 12 
044916 5B 
044917 12 
044917 9F   
044918 12 
044919 E4 
04491A 12 
              11599 
              11600 
              11601 ; --- End agon_sound.asm ---
              11602 
              11603 ; --- Begin interrupts.asm ---
              11604 ;
              11605 ; Title:	BBC Basic for AGON - Interrupts
              11606 ; Author:	Dean Belfield
              11607 ; Created:	12/05/2023
              11608 ; Last Updated:	07/06/2023
              11609 ;
              11610 ; Modinfo:
              11611 ; 07/06/2023:	Modified to run in ADL mode
              11612 
              11613 ; .ASSUME	ADL = 1
              11614 
              11615 ; INCLUDE	"macros.inc"
              11616 ; INCLUDE	"equs.inc"
              11617 ; INCLUDE "mos_api.inc"	; In MOS/src
              11618 
              11619 ; SEGMENT CODE
              11620 
              11621 ; XDEF	VBLANK_INIT
              11622 ; XDEF	VBLANK_STOP
              11623 ; XDEF	VBLANK_HANDLER
              11624 
              11625 ; XREF	ESCSET
              11626 ; XREF	KEYDOWN		; In ram.asm
              11627 ; XREF	KEYASCII 	; In ram.asm
              11628 ; XREF	KEYCOUNT	; In ram.asm
              11629 
              11630 ; Hook into the MOS VBLANK interrupt
              11631 ;
04491E F3     11632 VBLANK_INIT:		DI
04491F 21     11633 LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044920 73 
044921 49 
044922 04 
044923 1E     11634 LD		E, 32h				; Set up the VBlank Interrupt Vector
044924 32 
              11635 MOSCALL		mos_setintvector
044925 3E     0001M LD	A, function
044926 14 
044927 49     0002M RST.LIS	08h
044928 CF 
              11636 ; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044929 EB     11637 ex de,hl
04492A 21     11638 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04492B 81 
04492C 49 
04492D 04 
04492E ED     11639 LD		(HL), DE			; Self-modify the code
04492F 1F 
044930 FB     11640 EI
044931 C9     11641 RET
              11642 
              11643 ; Unhook the custom VBLANK interrupt
              11644 ;
044932 F3     11645 VBLANK_STOP:		DI
044933 21     11646 LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044934 81 
044935 49 
044936 04 
044937 ED     11647 LD		DE, (HL)
044938 17 
044939 EB     11648 EX		DE, HL 				; HLU: Address of MOS interrupt vector
04493A 1E     11649 LD		E, 32h
04493B 32 
              11650 MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
04493C 3E     0001M LD	A, function
04493D 14 
04493E 49     0002M RST.LIS	08h
04493F CF 
044940 FB     11651 EI
044941 C9     11652 RET
              11653 
              11654 ; A safe LIS call to ESCSET
              11655 ;
              11656 DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044942 3E     0001M LD	A, function
044943 08 
044944 49     0002M RST.LIS	08h
044945 CF 
044946 21     11657 LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044947 49 
044948 4D 
044949 04 
04494A DD     11658 LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04494B 7E 
04494C 19 
04494D BE     11659 CP 		(HL)				; with our local copy
04494E 20     11660 JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
04494F 0A 
              11661 ;
044950 AF     11662 DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044951 32     11663 LD		(KEYASCII), A
044952 48 
044953 4D 
044954 04 
044955 32     11664 LD		(KEYDOWN), A
044956 47 
044957 4D 
044958 04 
044959 C9     11665 RET	 					; And return
              11666 ;
04495A 77     11667 DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04495B DD     11668 LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
04495C 7E 
04495D 18 
04495E B7     11669 OR		A
04495F 28     11670 JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044960 EF 
              11671 ;
044961 32     11672 LD		(KEYDOWN), A 			; Store the keydown value
044962 47 
044963 4D 
044964 04 
044965 DD     11673 LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044966 7E 
044967 05 
044968 32     11674 LD		(KEYASCII), A 			; Store locally
044969 48 
04496A 4D 
04496B 04 
04496C FE     11675 CP		1Bh				; Is it escape?
04496D 1B 
04496E CC     11676 CALL		Z, ESCSET			; Yes, so set the escape flags
04496F 84 
044970 3F 
044971 04 
044972 C9     11677 RET						; Return to the interrupt handler
              11678 
044973 F3     11679 VBLANK_HANDLER:		DI
044974 F5     11680 PUSH		AF
044975 E5     11681 PUSH		HL
044976 DD     11682 PUSH		IX
044977 E5 
044978 CD     11683 CALL		DO_KEYBOARD
044979 42 
04497A 49 
04497B 04 
04497C DD     11684 POP		IX
04497D E1 
04497E E1     11685 POP		HL
04497F F1     11686 POP		AF
              11687 ;
              11688 ; Finally jump to the MOS interrupt
              11689 ;
044980 C3     11690 VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044981 00 
044982 00 
044983 00 
              11691 
              11692 ; --- Begin sorry.asm ---
              11693 ;
              11694 ; Title:	BBC Basic Interpreter - Z80 version
              11695 ;		Catch-all for unimplemented functionality
              11696 ; Author:	Dean Belfield
              11697 ; Created:	12/05/2023
              11698 ; Last Updated:	12/05/2023
              11699 ;
              11700 ; Modinfo:
              11701 
              11702 ; .ASSUME	ADL = 1
              11703 
              11704 ; SEGMENT CODE
              11705 
              11706 ; XDEF	ENVEL
              11707 ; XDEF	ADVAL
              11708 ; XDEF	PUTIMS
              11709 
              11710 ; XREF	EXTERR
              11711 
              11712 ENVEL:
              11713 ADVAL:
              11714 PUTIMS:
044984 AF     11715 XOR     A
044985 CD     11716 CALL    EXTERR
044986 AF 
044987 37 
044988 04 
044989 53     11717 DEFB    "Sorry"
04498A 6F 
04498B 72 
04498C 72 
04498C 79   
04498E 00     11718 DEFB    0
              11719 ; --- End sorry.asm ---
              11720 
              11721 ; --- Begin ram.asm ---
              11722 ;
              11723 ; Title:	BBC Basic Interpreter - Z80 version
              11724 ;		RAM Module for BBC Basic Interpreter
              11725 ;		For use with Version 2.0 of BBC BASIC
              11726 ;		Standard CP/M Distribution Version
              11727 ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              11728 ; Modified By:	Dean Belfield
              11729 ; Created:	12/05/2023
              11730 ; Last Updated:	26/06/2023
              11731 ;
              11732 ; Modinfo:
              11733 ; 06/06/2023:	Modified to run in ADL mode
              11734 ; 26/06/2023:	Added temporary stores R0 and R1
              11735 
              11736 ; .ASSUME	ADL = 1
              11737 
              11738 ; DEFINE	LORAM, SPACE = ROM
              11739 ; SEGMENT LORAM
              11740 
              11741 ; XDEF	ACCS
              11742 ; XDEF	BUFFER
              11743 ; XDEF	STAVAR
              11744 ; XDEF	DYNVAR
              11745 ; XDEF	FNPTR
              11746 ; XDEF	PROPTR
              11747 ; XDEF	PAGE_
              11748 ; XDEF	TOP
              11749 ; XDEF	LOMEM
              11750 ; XDEF 	FREE
              11751 ; XDEF	HIMEM
              11752 ; XDEF	LINENO
              11753 ; XDEF	TRACEN
              11754 ; XDEF	AUTONO
              11755 ; XDEF	ERRTRP
              11756 ; XDEF	ERRTXT
              11757 ; XDEF	DATPTR
              11758 ; XDEF	ERL
              11759 ; XDEF	ERRLIN
              11760 ; XDEF	RANDOM
              11761 ; XDEF	COUNT
              11762 ; XDEF	WIDTH
              11763 ; XDEF	ERR
              11764 ; XDEF	LISTON
              11765 ; XDEF	INCREM
              11766 
              11767 ; XDEF	FLAGS
              11768 ; XDEF	OSWRCHPT
              11769 ; XDEF	OSWRCHCH
              11770 ; XDEF	OSWRCHFH
              11771 ; XDEF	KEYDOWN
              11772 ; XDEF	KEYASCII
              11773 ; XDEF	KEYCOUNT
              11774 
              11775 ; XDEF	R0
              11776 ; XDEF	R1
              11777 
              11778 ; XDEF	RAM_START
              11779 ; XDEF	RAM_END
              11780 ; XDEF	USER
              11781 
04498F FF     11782 ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
044990 FF 
044991 FF 
044992 FF 
044992 FF   
044993 FF 
044994 FF 
044995 FF 
044995 FF   
044996 FF 
044997 FF 
044998 FF 
044998 FF   
044999 FF 
04499A FF 
04499B FF 
04499B FF   
04499C FF 
04499D FF 
04499E FF 
04499E FF   
04499F FF 
0449A0 FF 
0449A1 FF 
0449A1 FF   
0449A2 FF 
0449A3 FF 
0449A4 FF 
0449A4 FF   
0449A5 FF 
0449A6 FF 
0449A7 FF 
0449A7 FF   
0449A8 FF 
0449A9 FF 
0449AA FF 
0449AA FF   
0449AB FF 
0449AC FF 
0449AD FF 
0449AD FF   
0449AE FF 
0449AF FF 
0449B0 FF 
0449B0 FF   
0449B1 FF 
0449B2 FF 
0449B3 FF 
0449B3 FF   
0449B4 FF 
0449B5 FF 
0449B6 FF 
0449B6 FF   
0449B7 FF 
0449B8 FF 
0449B9 FF 
0449B9 FF   
0449BA FF 
0449BB FF 
0449BC FF 
0449BC FF   
0449BD FF 
0449BE FF 
0449BF FF 
0449BF FF   
0449C0 FF 
0449C1 FF 
0449C2 FF 
0449C2 FF   
0449C3 FF 
0449C4 FF 
0449C5 FF 
0449C5 FF   
0449C6 FF 
0449C7 FF 
0449C8 FF 
0449C8 FF   
0449C9 FF 
0449CA FF 
0449CB FF 
0449CB FF   
0449CC FF 
0449CD FF 
0449CE FF 
0449CE FF   
0449CF FF 
0449D0 FF 
0449D1 FF 
0449D1 FF   
0449D2 FF 
0449D3 FF 
0449D4 FF 
0449D4 FF   
0449D5 FF 
0449D6 FF 
0449D7 FF 
0449D7 FF   
0449D8 FF 
0449D9 FF 
0449DA FF 
0449DA FF   
0449DB FF 
0449DC FF 
0449DD FF 
0449DD FF   
0449DE FF 
0449DF FF 
0449E0 FF 
0449E0 FF   
0449E1 FF 
0449E2 FF 
0449E3 FF 
0449E3 FF   
              11783 RAM_START:
              11784 ;
044A00 00     11785 ACCS:           BLKB    256,0             ; String Accumulator
044A01 00 
044A02 00 
044A03 00 
044A03 00   
044A04 00 
044A05 00 
044A06 00 
044A06 00   
044A07 00 
044A08 00 
044A09 00 
044A09 00   
044A0A 00 
044A0B 00 
044A0C 00 
044A0C 00   
044A0D 00 
044A0E 00 
044A0F 00 
044A0F 00   
044A10 00 
044A11 00 
044A12 00 
044A12 00   
044A13 00 
044A14 00 
044A15 00 
044A15 00   
044A16 00 
044A17 00 
044A18 00 
044A18 00   
044A19 00 
044A1A 00 
044A1B 00 
044A1B 00   
044A1C 00 
044A1D 00 
044A1E 00 
044A1E 00   
044A1F 00 
044A20 00 
044A21 00 
044A21 00   
044A22 00 
044A23 00 
044A24 00 
044A24 00   
044A25 00 
044A26 00 
044A27 00 
044A27 00   
044A28 00 
044A29 00 
044A2A 00 
044A2A 00   
044A2B 00 
044A2C 00 
044A2D 00 
044A2D 00   
044A2E 00 
044A2F 00 
044A30 00 
044A30 00   
044A31 00 
044A32 00 
044A33 00 
044A33 00   
044A34 00 
044A35 00 
044A36 00 
044A36 00   
044A37 00 
044A38 00 
044A39 00 
044A39 00   
044A3A 00 
044A3B 00 
044A3C 00 
044A3C 00   
044A3D 00 
044A3E 00 
044A3F 00 
044A3F 00   
044A40 00 
044A41 00 
044A42 00 
044A42 00   
044A43 00 
044A44 00 
044A45 00 
044A45 00   
044A46 00 
044A47 00 
044A48 00 
044A48 00   
044A49 00 
044A4A 00 
044A4B 00 
044A4B 00   
044A4C 00 
044A4D 00 
044A4E 00 
044A4E 00   
044A4F 00 
044A50 00 
044A51 00 
044A51 00   
044A52 00 
044A53 00 
044A54 00 
044A54 00   
044A55 00 
044A56 00 
044A57 00 
044A57 00   
044A58 00 
044A59 00 
044A5A 00 
044A5A 00   
044A5B 00 
044A5C 00 
044A5D 00 
044A5D 00   
044A5E 00 
044A5F 00 
044A60 00 
044A60 00   
044A61 00 
044A62 00 
044A63 00 
044A63 00   
044A64 00 
044A65 00 
044A66 00 
044A66 00   
044A67 00 
044A68 00 
044A69 00 
044A69 00   
044A6A 00 
044A6B 00 
044A6C 00 
044A6C 00   
044A6D 00 
044A6E 00 
044A6F 00 
044A6F 00   
044A70 00 
044A71 00 
044A72 00 
044A72 00   
044A73 00 
044A74 00 
044A75 00 
044A75 00   
044A76 00 
044A77 00 
044A78 00 
044A78 00   
044A79 00 
044A7A 00 
044A7B 00 
044A7B 00   
044A7C 00 
044A7D 00 
044A7E 00 
044A7E 00   
044A7F 00 
044A80 00 
044A81 00 
044A81 00   
044A82 00 
044A83 00 
044A84 00 
044A84 00   
044A85 00 
044A86 00 
044A87 00 
044A87 00   
044A88 00 
044A89 00 
044A8A 00 
044A8A 00   
044A8B 00 
044A8C 00 
044A8D 00 
044A8D 00   
044A8E 00 
044A8F 00 
044A90 00 
044A90 00   
044A91 00 
044A92 00 
044A93 00 
044A93 00   
044A94 00 
044A95 00 
044A96 00 
044A96 00   
044A97 00 
044A98 00 
044A99 00 
044A99 00   
044A9A 00 
044A9B 00 
044A9C 00 
044A9C 00   
044A9D 00 
044A9E 00 
044A9F 00 
044A9F 00   
044AA0 00 
044AA1 00 
044AA2 00 
044AA2 00   
044AA3 00 
044AA4 00 
044AA5 00 
044AA5 00   
044AA6 00 
044AA7 00 
044AA8 00 
044AA8 00   
044AA9 00 
044AAA 00 
044AAB 00 
044AAB 00   
044AAC 00 
044AAD 00 
044AAE 00 
044AAE 00   
044AAF 00 
044AB0 00 
044AB1 00 
044AB1 00   
044AB2 00 
044AB3 00 
044AB4 00 
044AB4 00   
044AB5 00 
044AB6 00 
044AB7 00 
044AB7 00   
044AB8 00 
044AB9 00 
044ABA 00 
044ABA 00   
044ABB 00 
044ABC 00 
044ABD 00 
044ABD 00   
044ABE 00 
044ABF 00 
044AC0 00 
044B00 00     11786 BUFFER:         BLKB    256,0             ; String Input Buffer
044B01 00 
044B02 00 
044B03 00 
044B03 00   
044B04 00 
044B05 00 
044B06 00 
044B06 00   
044B07 00 
044B08 00 
044B09 00 
044B09 00   
044B0A 00 
044B0B 00 
044B0C 00 
044B0C 00   
044B0D 00 
044B0E 00 
044B0F 00 
044B0F 00   
044B10 00 
044B11 00 
044B12 00 
044B12 00   
044B13 00 
044B14 00 
044B15 00 
044B15 00   
044B16 00 
044B17 00 
044B18 00 
044B18 00   
044B19 00 
044B1A 00 
044B1B 00 
044B1B 00   
044B1C 00 
044B1D 00 
044B1E 00 
044B1E 00   
044B1F 00 
044B20 00 
044B21 00 
044B21 00   
044B22 00 
044B23 00 
044B24 00 
044B24 00   
044B25 00 
044B26 00 
044B27 00 
044B27 00   
044B28 00 
044B29 00 
044B2A 00 
044B2A 00   
044B2B 00 
044B2C 00 
044B2D 00 
044B2D 00   
044B2E 00 
044B2F 00 
044B30 00 
044B30 00   
044B31 00 
044B32 00 
044B33 00 
044B33 00   
044B34 00 
044B35 00 
044B36 00 
044B36 00   
044B37 00 
044B38 00 
044B39 00 
044B39 00   
044B3A 00 
044B3B 00 
044B3C 00 
044B3C 00   
044B3D 00 
044B3E 00 
044B3F 00 
044B3F 00   
044B40 00 
044B41 00 
044B42 00 
044B42 00   
044B43 00 
044B44 00 
044B45 00 
044B45 00   
044B46 00 
044B47 00 
044B48 00 
044B48 00   
044B49 00 
044B4A 00 
044B4B 00 
044B4B 00   
044B4C 00 
044B4D 00 
044B4E 00 
044B4E 00   
044B4F 00 
044B50 00 
044B51 00 
044B51 00   
044B52 00 
044B53 00 
044B54 00 
044B54 00   
044B55 00 
044B56 00 
044B57 00 
044B57 00   
044B58 00 
044B59 00 
044B5A 00 
044B5A 00   
044B5B 00 
044B5C 00 
044B5D 00 
044B5D 00   
044B5E 00 
044B5F 00 
044B60 00 
044B60 00   
044B61 00 
044B62 00 
044B63 00 
044B63 00   
044B64 00 
044B65 00 
044B66 00 
044B66 00   
044B67 00 
044B68 00 
044B69 00 
044B69 00   
044B6A 00 
044B6B 00 
044B6C 00 
044B6C 00   
044B6D 00 
044B6E 00 
044B6F 00 
044B6F 00   
044B70 00 
044B71 00 
044B72 00 
044B72 00   
044B73 00 
044B74 00 
044B75 00 
044B75 00   
044B76 00 
044B77 00 
044B78 00 
044B78 00   
044B79 00 
044B7A 00 
044B7B 00 
044B7B 00   
044B7C 00 
044B7D 00 
044B7E 00 
044B7E 00   
044B7F 00 
044B80 00 
044B81 00 
044B81 00   
044B82 00 
044B83 00 
044B84 00 
044B84 00   
044B85 00 
044B86 00 
044B87 00 
044B87 00   
044B88 00 
044B89 00 
044B8A 00 
044B8A 00   
044B8B 00 
044B8C 00 
044B8D 00 
044B8D 00   
044B8E 00 
044B8F 00 
044B90 00 
044B90 00   
044B91 00 
044B92 00 
044B93 00 
044B93 00   
044B94 00 
044B95 00 
044B96 00 
044B96 00   
044B97 00 
044B98 00 
044B99 00 
044B99 00   
044B9A 00 
044B9B 00 
044B9C 00 
044B9C 00   
044B9D 00 
044B9E 00 
044B9F 00 
044B9F 00   
044BA0 00 
044BA1 00 
044BA2 00 
044BA2 00   
044BA3 00 
044BA4 00 
044BA5 00 
044BA5 00   
044BA6 00 
044BA7 00 
044BA8 00 
044BA8 00   
044BA9 00 
044BAA 00 
044BAB 00 
044BAB 00   
044BAC 00 
044BAD 00 
044BAE 00 
044BAE 00   
044BAF 00 
044BB0 00 
044BB1 00 
044BB1 00   
044BB2 00 
044BB3 00 
044BB4 00 
044BB4 00   
044BB5 00 
044BB6 00 
044BB7 00 
044BB7 00   
044BB8 00 
044BB9 00 
044BBA 00 
044BBA 00   
044BBB 00 
044BBC 00 
044BBD 00 
044BBD 00   
044BBE 00 
044BBF 00 
044BC0 00 
044C00 00     11787 STAVAR:         BLKB    27*4,0            ; Static Variables
044C01 00 
044C02 00 
044C03 00 
044C03 00   
044C04 00 
044C05 00 
044C06 00 
044C06 00   
044C07 00 
044C08 00 
044C09 00 
044C09 00   
044C0A 00 
044C0B 00 
044C0C 00 
044C0C 00   
044C0D 00 
044C0E 00 
044C0F 00 
044C0F 00   
044C10 00 
044C11 00 
044C12 00 
044C12 00   
044C13 00 
044C14 00 
044C15 00 
044C15 00   
044C16 00 
044C17 00 
044C18 00 
044C18 00   
044C19 00 
044C1A 00 
044C1B 00 
044C1B 00   
044C1C 00 
044C1D 00 
044C1E 00 
044C1E 00   
044C1F 00 
044C20 00 
044C21 00 
044C21 00   
044C22 00 
044C23 00 
044C24 00 
044C24 00   
044C25 00 
044C26 00 
044C27 00 
044C27 00   
044C28 00 
044C29 00 
044C2A 00 
044C2A 00   
044C2B 00 
044C2C 00 
044C2D 00 
044C2D 00   
044C2E 00 
044C2F 00 
044C30 00 
044C30 00   
044C31 00 
044C32 00 
044C33 00 
044C33 00   
044C34 00 
044C35 00 
044C36 00 
044C36 00   
044C37 00 
044C38 00 
044C39 00 
044C39 00   
044C3A 00 
044C3B 00 
044C3C 00 
044C3C 00   
044C3D 00 
044C3E 00 
044C3F 00 
044C3F 00   
044C40 00 
044C41 00 
044C42 00 
044C42 00   
044C43 00 
044C44 00 
044C45 00 
044C45 00   
044C46 00 
044C47 00 
044C48 00 
044C48 00   
044C49 00 
044C4A 00 
044C4B 00 
044C4B 00   
044C4C 00 
044C4D 00 
044C4E 00 
044C4E 00   
044C4F 00 
044C50 00 
044C51 00 
044C6C 00     11788 DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
044C6D 00 
044C6E 00 
044C6F 00 
044C6F 00   
044C70 00 
044C71 00 
044C72 00 
044C72 00   
044C73 00 
044C74 00 
044C75 00 
044C75 00   
044C76 00 
044C77 00 
044C78 00 
044C78 00   
044C79 00 
044C7A 00 
044C7B 00 
044C7B 00   
044C7C 00 
044C7D 00 
044C7E 00 
044C7E 00   
044C7F 00 
044C80 00 
044C81 00 
044C81 00   
044C82 00 
044C83 00 
044C84 00 
044C84 00   
044C85 00 
044C86 00 
044C87 00 
044C87 00   
044C88 00 
044C89 00 
044C8A 00 
044C8A 00   
044C8B 00 
044C8C 00 
044C8D 00 
044C8D 00   
044C8E 00 
044C8F 00 
044C90 00 
044C90 00   
044C91 00 
044C92 00 
044C93 00 
044C93 00   
044C94 00 
044C95 00 
044C96 00 
044C96 00   
044C97 00 
044C98 00 
044C99 00 
044C99 00   
044C9A 00 
044C9B 00 
044C9C 00 
044C9C 00   
044C9D 00 
044C9E 00 
044C9F 00 
044C9F 00   
044CA0 00 
044CA1 00 
044CA2 00 
044CA2 00   
044CA3 00 
044CA4 00 
044CA5 00 
044CA5 00   
044CA6 00 
044CA7 00 
044CA8 00 
044CA8 00   
044CA9 00 
044CAA 00 
044CAB 00 
044CAB 00   
044CAC 00 
044CAD 00 
044CAE 00 
044CAE 00   
044CAF 00 
044CB0 00 
044CB1 00 
044CB1 00   
044CB2 00 
044CB3 00 
044CB4 00 
044CB4 00   
044CB5 00 
044CB6 00 
044CB7 00 
044CB7 00   
044CB8 00 
044CB9 00 
044CBA 00 
044CBA 00   
044CBB 00 
044CBC 00 
044CBD 00 
044CBD 00   
044CBE 00 
044CBF 00 
044CC0 00 
044CC0 00   
044CC1 00 
044CC2 00 
044CC3 00 
044CC3 00   
044CC4 00 
044CC5 00 
044CC6 00 
044CC6 00   
044CC7 00 
044CC8 00 
044CC9 00 
044CC9 00   
044CCA 00 
044CCB 00 
044CCC 00 
044CCC 00   
044CCD 00 
044CCE 00 
044CCF 00 
044CCF 00   
044CD0 00 
044CD1 00 
044CD2 00 
044CD2 00   
044CD3 00 
044CD4 00 
044CD5 00 
044CD5 00   
044CD6 00 
044CD7 00 
044CD8 00 
044CD8 00   
044CD9 00 
044CDA 00 
044CDB 00 
044CDB 00   
044CDC 00 
044CDD 00 
044CDE 00 
044CDE 00   
044CDF 00 
044CE0 00 
044CE1 00 
044CE1 00   
044CE2 00 
044CE3 00 
044CE4 00 
044CE4 00   
044CE5 00 
044D0E 00     11789 FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D0F 00 
044D10 00 
044D11 00     11790 PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D12 00 
044D13 00 
              11791 ;
044D14 00     11792 PAGE_:          BLKB    3,0               ; Start of User Program
044D15 00 
044D16 00 
044D17 00     11793 TOP:            BLKB    3,0               ; First Location after User Program
044D18 00 
044D19 00 
044D1A 00     11794 LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1B 00 
044D1C 00 
044D1D 00     11795 FREE:           BLKB    3,0               ; First Free Space Byte
044D1E 00 
044D1F 00 
044D20 00     11796 HIMEM:          BLKB    3,0               ; First Protected Byte
044D21 00 
044D22 00 
              11797 ;
044D23 00     11798 LINENO:         BLKB    3,0               ; Line Number
044D24 00 
044D25 00 
044D26 00     11799 TRACEN:         BLKB    3,0               ; Trace Flag
044D27 00 
044D28 00 
044D29 00     11800 AUTONO:         BLKB    3,0               ; Auto Flag
044D2A 00 
044D2B 00 
044D2C 00     11801 ERRTRP:         BLKB    3,0               ; Error Trap
044D2D 00 
044D2E 00 
044D2F 00     11802 ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D30 00 
044D31 00     11803 DATPTR:         BLKB    2,0               ; Data Pointer
044D32 00 
044D33 00     11804 ERL:            BLKB    2,0               ; Error Line
044D34 00 
044D35 00     11805 ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D36 00 
044D37 00 
044D38 00     11806 RANDOM:         BLKB    5,0               ; Random Number
044D39 00 
044D3A 00 
044D3B 00 
044D3B 00   
044D3D 00     11807 COUNT:          BLKB    1,0               ; Print Position
044D3E 00     11808 WIDTH:          BLKB    1,0               ; Print Width
044D3F 00     11809 ERR:            BLKB    1,0               ; Error Number
044D40 00     11810 LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              11811 ; - BIT 0: If set, output a space after the line number
              11812 ; - BIT 1: If set, then indent FOR/NEXT loops
              11813 ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              11814 ; - BIT 3: If set, then output to buffer for *EDIT
              11815 ; OPT FLAG (top nibble)
              11816 ; - BIT 4: If set, then list whilst assembling
              11817 ; - BIT 5: If set, then assembler errors are reported
              11818 ; - BIT 6: If set, then place the code starting at address pointed to by O%
              11819 ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00     11820 INCREM:         BLKB    1,0               ; Auto-Increment Value
              11821 ;
              11822 ; --------------------------------------------------------------------------------------------
              11823 ; BEGIN MODIFIED CODE
              11824 ; --------------------------------------------------------------------------------------------
              11825 ; Originally in equs.inc
              11826 ;
              11827 OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
              11828 PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
              11829 VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              11830 ; --------------------------------------------------------------------------------------------
              11831 ; END MODIFIED CODE
              11832 ; --------------------------------------------------------------------------------------------
              11833 
              11834 ; Extra Agon-implementation specific system variables
              11835 ;
044D42 00     11836 FLAGS:          BLKB    1,0       ; Miscellaneous flags
              11837 ; - BIT 7: Set if ESC pressed
              11838 ; - BIT 6: Set to disable ESC
044D43 00     11839 OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D44 00 
044D45 00     11840 OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              11841 ; - 0: Console
              11842 ; - 1: File
044D46 00     11843 OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00     11844 KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00     11845 KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00     11846 KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00     11847 R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4B 00 
044D4C 00 
044D4D 00     11848 R1:             BLKB    3,0
044D4E 00 
044D4F 00 
              11849 
              11850 ;
              11851 ; This must be at the end
              11852 ;
              11853 RAM_END:
044D50 FF     11854 ALIGN	256
044D51 FF 
044D52 FF 
044D53 FF 
044D53 FF   
044D54 FF 
044D55 FF 
044D56 FF 
044D56 FF   
044D57 FF 
044D58 FF 
044D59 FF 
044D59 FF   
044D5A FF 
044D5B FF 
044D5C FF 
044D5C FF   
044D5D FF 
044D5E FF 
044D5F FF 
044D5F FF   
044D60 FF 
044D61 FF 
044D62 FF 
044D62 FF   
044D63 FF 
044D64 FF 
044D65 FF 
044D65 FF   
044D66 FF 
044D67 FF 
044D68 FF 
044D68 FF   
044D69 FF 
044D6A FF 
044D6B FF 
044D6B FF   
044D6C FF 
044D6D FF 
044D6E FF 
044D6E FF   
044D6F FF 
044D70 FF 
044D71 FF 
044D71 FF   
044D72 FF 
044D73 FF 
044D74 FF 
044D74 FF   
044D75 FF 
044D76 FF 
044D77 FF 
044D77 FF   
044D78 FF 
044D79 FF 
044D7A FF 
044D7A FF   
044D7B FF 
044D7C FF 
044D7D FF 
044D7D FF   
044D7E FF 
044D7F FF 
044D80 FF 
044D80 FF   
044D81 FF 
044D82 FF 
044D83 FF 
044D83 FF   
044D84 FF 
044D85 FF 
044D86 FF 
044D86 FF   
044D87 FF 
044D88 FF 
044D89 FF 
044D89 FF   
044D8A FF 
044D8B FF 
044D8C FF 
044D8C FF   
044D8D FF 
044D8E FF 
044D8F FF 
044D8F FF   
044D90 FF 
044D91 FF 
044D92 FF 
044D92 FF   
044D93 FF 
044D94 FF 
044D95 FF 
044D95 FF   
044D96 FF 
044D97 FF 
044D98 FF 
044D98 FF   
044D99 FF 
044D9A FF 
044D9B FF 
044D9B FF   
044D9C FF 
044D9D FF 
044D9E FF 
044D9E FF   
044D9F FF 
044DA0 FF 
044DA1 FF 
044DA1 FF   
044DA2 FF 
044DA3 FF 
044DA4 FF 
044DA4 FF   
044DA5 FF 
044DA6 FF 
044DA7 FF 
044DA7 FF   
044DA8 FF 
044DA9 FF 
044DAA FF 
044DAA FF   
044DAB FF 
044DAC FF 
044DAD FF 
044DAD FF   
044DAE FF 
044DAF FF 
044DB0 FF 
044DB0 FF   
044DB1 FF 
044DB2 FF 
044DB3 FF 
044DB3 FF   
044DB4 FF 
044DB5 FF 
044DB6 FF 
044DB6 FF   
044DB7 FF 
044DB8 FF 
044DB9 FF 
044DB9 FF   
044DBA FF 
044DBB FF 
044DBC FF 
044DBC FF   
044DBD FF 
044DBE FF 
044DBF FF 
044DBF FF   
044DC0 FF 
044DC1 FF 
044DC2 FF 
044DC2 FF   
044DC3 FF 
044DC4 FF 
044DC5 FF 
044DC5 FF   
044DC6 FF 
044DC7 FF 
044DC8 FF 
044DC8 FF   
044DC9 FF 
044DCA FF 
044DCB FF 
044DCB FF   
044DCC FF 
044DCD FF 
044DCE FF 
044DCE FF   
044DCF FF 
044DD0 FF 
044DD1 FF 
044DD1 FF   
044DD2 FF 
044DD3 FF 
044DD4 FF 
              11855 USER:							; Must be aligned on a page boundary
              11856 ; --- End ram.asm ---
              11857 
