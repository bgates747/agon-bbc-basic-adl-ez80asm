PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modinfo:
040000             0009  ; 05/08/2022:	Added mos_feof
040000             0010  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0011  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0012  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0013  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0014  ; 13/10/2022:	Added mos_oscli
040000             0015  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0016  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0017  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0018  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0019  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0020  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0021  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0022  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0023  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0024  ; 19/05/2023:	Added sysvar_scrMode
040000             0025  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0026  ; 03/08/2023:	Added mos_setkbvector
040000             0027  ; 10/08/2023:	Added mos_getkbmap
040000             0028  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0029  
040000             0030  ; VDP control (VDU 23, 0, n)
040000             0031  ;
040000             0032  vdp_gp:			EQU 	80h
040000             0033  vdp_keycode:		EQU 	81h
040000             0034  vdp_cursor:		EQU	82h
040000             0035  vdp_scrchar:		EQU	83h
040000             0036  vdp_scrpixel:		EQU	84h
040000             0037  vdp_audio:		EQU	85h
040000             0038  vdp_mode:		EQU	86h
040000             0039  vdp_rtc:		EQU	87h
040000             0040  vdp_keystate:		EQU	88h
040000             0041  vdp_logicalcoords:	EQU	C0h
040000             0042  vdp_terminalmode:	EQU	FFh
040000             0043  
040000             0044  ; MOS high level functions
040000             0045  ;
040000             0046  mos_getkey:		EQU	00h
040000             0047  mos_load:		EQU	01h
040000             0048  mos_save:		EQU	02h
040000             0049  mos_cd:			EQU	03h
040000             0050  mos_dir:		EQU	04h
040000             0051  mos_del:		EQU	05h
040000             0052  mos_ren:		EQU	06h
040000             0053  mos_mkdir:		EQU	07h
040000             0054  mos_sysvars:		EQU	08h
040000             0055  mos_editline:		EQU	09h
040000             0056  mos_fopen:		EQU	0Ah
040000             0057  mos_fclose:		EQU	0Bh
040000             0058  mos_fgetc:		EQU	0Ch
040000             0059  mos_fputc:		EQU	0Dh
040000             0060  mos_feof:		EQU	0Eh
040000             0061  mos_getError:		EQU	0Fh
040000             0062  mos_oscli:		EQU	10h
040000             0063  mos_copy:		EQU	11h
040000             0064  mos_getrtc:		EQU	12h
040000             0065  mos_setrtc:		EQU	13h
040000             0066  mos_setintvector:	EQU	14h
040000             0067  mos_uopen:		EQU	15h
040000             0068  mos_uclose:		EQU	16h
040000             0069  mos_ugetc:		EQU	17h
040000             0070  mos_uputc:		EQU 	18h
040000             0071  mos_getfil:		EQU	19h
040000             0072  mos_fread:		EQU	1Ah
040000             0073  mos_fwrite:		EQU	1Bh
040000             0074  mos_flseek:		EQU	1Ch
040000             0075  mos_setkbvector:	EQU	1Dh
040000             0076  mos_getkbmap:		EQU	1Eh
040000             0077  mos_i2c_open:		EQU	1Fh
040000             0078  mos_i2c_close:		EQU	20h
040000             0079  mos_i2c_write:		EQU	21h
040000             0080  mos_i2c_read:		EQU	22h
040000             0081  
040000             0082  
040000             0083  ; FatFS file access functions
040000             0084  ;
040000             0085  ffs_fopen:		EQU	80h
040000             0086  ffs_fclose:		EQU	81h
040000             0087  ffs_fread:		EQU	82h
040000             0088  ffs_fwrite:		EQU	83h
040000             0089  ffs_flseek:		EQU	84h
040000             0090  ffs_ftruncate:		EQU	85h
040000             0091  ffs_fsync:		EQU	86h
040000             0092  ffs_fforward:		EQU	87h
040000             0093  ffs_fexpand:		EQU	88h
040000             0094  ffs_fgets:		EQU	89h
040000             0095  ffs_fputc:		EQU	8Ah
040000             0096  ffs_fputs:		EQU	8Bh
040000             0097  ffs_fprintf:		EQU	8Ch
040000             0098  ffs_ftell:		EQU	8Dh
040000             0099  ffs_feof:		EQU	8Eh
040000             0100  ffs_fsize:		EQU	8Fh
040000             0101  ffs_ferror:		EQU	90h
040000             0102  
040000             0103  ; FatFS directory access functions
040000             0104  ;
040000             0105  ffs_dopen:		EQU	91h
040000             0106  ffs_dclose:		EQU	92h
040000             0107  ffs_dread:		EQU	93h
040000             0108  ffs_dfindfirst:		EQU	94h
040000             0109  ffs_dfindnext:		EQU	95h
040000             0110  
040000             0111  ; FatFS file and directory management functions
040000             0112  ;
040000             0113  ffs_stat:		EQU	96h
040000             0114  ffs_unlink:		EQU	97h
040000             0115  ffs_rename:		EQU	98h
040000             0116  ffs_chmod:		EQU	99h
040000             0117  ffs_utime:		EQU	9Ah
040000             0118  ffs_mkdir:		EQU	9Bh
040000             0119  ffs_chdir:		EQU	9Ch
040000             0120  ffs_chdrive:		EQU	9Dh
040000             0121  ffs_getcwd:		EQU	9Eh
040000             0122  
040000             0123  ; FatFS volume management and system configuration functions
040000             0124  ;
040000             0125  ffs_mount:		EQU	9Fh
040000             0126  ffs_mkfs:		EQU	A0h
040000             0127  ffs_fdisk:		EQU	A1h
040000             0128  ffs_getfree:		EQU	A2h
040000             0129  ffs_getlabel:		EQU	A3h
040000             0130  ffs_setlabel:		EQU	A4h
040000             0131  ffs_setcp:		EQU	A5h
040000             0132  
040000             0133  ; File access modes
040000             0134  ;
040000             0135  fa_read:		EQU	01h
040000             0136  fa_write:		EQU	02h
040000             0137  fa_open_existing:	EQU	00h
040000             0138  fa_create_new:		EQU	04h
040000             0139  fa_create_always:	EQU	08h
040000             0140  fa_open_always:		EQU	10h
040000             0141  fa_open_append:		EQU	30h
040000             0142  
040000             0143  ; System variable indexes for api_sysvars
040000             0144  ; Index into _sysvars in globals.asm
040000             0145  ;
040000             0146  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0147  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0148  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0149  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0150  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0151  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0152  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0153  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0154  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0155  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0156  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0157  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0158  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0159  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0160  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0161  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0162  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0163  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0164  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0165  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0166  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0167  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0168  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0169  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0170  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0171  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0172  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0173  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0174  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0175  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0176  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0177  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0178  
040000             0179  ; Flags for the VPD protocol
040000             0180  ;
040000             0181  vdp_pflag_cursor:	EQU	00000001b
040000             0182  vdp_pflag_scrchar:	EQU	00000010b
040000             0183  vdp_pflag_point:	EQU	00000100b
040000             0184  vdp_pflag_audio:	EQU	00001000b
040000             0185  vdp_pflag_mode:		EQU	00010000b
040000             0186  vdp_pflag_rtc:		EQU	00100000b
040000             0187  vdp_pflag_mouse:	EQU	01000000b
040000             0188  ; vdp_pflag_buffered:	EQU	10000000b
040000             0189  
040000             0190  ;
040000             0191  ; FatFS structures
040000             0192  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0193  ;
040000             0194  ; Object ID and allocation information (FFOBJID)
040000             0195  ;
040000             0196  ; FFOBJID	.STRUCT
040000             0197  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0198  ; 	id:		DS	2	; Hosting volume mount ID
040000             0199  ; 	attr:		DS	1	; Object attribute
040000             0200  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0201  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0202  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0203  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0204  ; ;
040000             0205  ; ; File object structure (FIL)
040000             0206  ; ;
040000             0207  ; FIL .STRUCT
040000             0208  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0209  ; 	flag:		DS	1	; File status flags
040000             0210  ; 	err:		DS	1	; Abort flag (error code)
040000             0211  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0212  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0213  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0214  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0215  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0216  ; FIL_SIZE .ENDSTRUCT FIL
040000             0217  ; ;
040000             0218  ; ; Directory object structure (DIR)
040000             0219  ; ;
040000             0220  ; DIR .STRUCT
040000             0221  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0222  ; 	dptr:		DS	4	; Current read/write offset
040000             0223  ; 	clust:		DS	4	; Current cluster
040000             0224  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0225  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0226  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0227  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0228  ; DIR_SIZE .ENDSTRUCT DIR
040000             0229  ; ;
040000             0230  ; ; File information structure (FILINFO)
040000             0231  ; ;
040000             0232  ; FILINFO .STRUCT
040000             0233  ; 	fsize:		DS 	4	; File size
040000             0234  ; 	fdate:		DS	2	; Modified date
040000             0235  ; 	ftime:		DS	2	; Modified time
040000             0236  ; 	fattrib:	DS	1	; File attribute
040000             0237  ; 	altname:	DS	13	; Alternative file name
040000             0238  ; 	fname:		DS	256	; Primary file name
040000             0239  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0240  
040000             0241  ; FFOBJID offsets
040000             0242  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0243  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0244  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0245  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0246  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0247  FFOBJID.objsize:  EQU 11   ; Object size
040000             0248  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0249  
040000             0250  ; FIL offsets (including FFOBJID fields)
040000             0251  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0252  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0253  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0254  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0255  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0256  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0257  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0258  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0259  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0260  
040000             0261  ; DIR offsets (including FFOBJID fields)
040000             0262  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0263  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0264  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0265  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0266  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0267  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0268  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0269  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0270  
040000             0271  ; FILINFO offsets
040000             0272  FILINFO.fsize:    EQU 0    ; File size
040000             0273  FILINFO.fdate:    EQU 4    ; Modified date
040000             0274  FILINFO.ftime:    EQU 6    ; Modified time
040000             0275  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0276  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0277  FILINFO.fname:    EQU 22   ; Primary file name
040000             0278  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0279  
040000             0280  ;
040000             0281  ; Macro for calling the API
040000             0282  ; Parameters:
040000             0283  ; - function: One of the function numbers listed above
040000             0284  ;
040000             0285  			MACRO MOSCALL	function
040000             0286  			LD	A, function
040000             0287  			RST.LIS	08h
040000             0288  			ENDMACRO 	; --- End mos_api.inc ---
040000             0289  
040000             0290  ; --- Begin macros.inc ---
040000             0291  	; Title:	BBC Basic Interpreter - Z80 version
040000             0292  	;		Useful macros
040000             0293  	; Author:	Dean Belfield
040000             0294  	; Created:	12/05/2023
040000             0295  	; Last Updated:	11/06/2023
040000             0296  	;
040000             0297  	; Modinfo:
040000             0298  	; 11/06/2023:	Modified to run in ADL mode
040000             0299  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0300  
040000             0301  	MACRO EXREG	rp1, rp2
040000             0302  		PUSH	rp1
040000             0303  		POP	rp2
040000             0304  	ENDMACRO
040000             0305  
040000             0306  	; MACRO ADD8U_DE	reg
040000             0307  		MACRO ADD8U_DE
040000             0308  		ADD	A, E
040000             0309  		LD	E, A
040000             0310  		ADC	A, D
040000             0311  		SUB	E
040000             0312  		LD	D, A
040000             0313  	ENDMACRO
040000             0314  
040000             0315  	; MACRO ADD8U_HL	reg
040000             0316  	MACRO ADD8U_HL
040000             0317  		ADD	A, L
040000             0318  		LD	L, A
040000             0319  		ADC	A, H
040000             0320  		SUB	L
040000             0321  		LD	H, A
040000             0322  	ENDMACRO
040000             0323  
040000             0324  	MACRO VDU	val
040000             0325  		LD	A, val
040000             0326  		CALL	OSWRCH
040000             0327  	ENDMACRO
040000             0328  
040000             0329  	MACRO SET_GPIO	reg, val
040000             0330  		IN0	A, (reg)
040000             0331  		OR	val
040000             0332  		OUT0	(reg), A
040000             0333  	ENDMACRO
040000             0334  
040000             0335  	MACRO RES_GPIO	reg, val
040000             0336  		PUSH	BC
040000             0337  		LD	A, val
040000             0338  		CPL
040000             0339  		LD	C, A
040000             0340  		IN0	A, (reg)
040000             0341  		AND	C
040000             0342  		OUT0	(reg), A
040000             0343  		POP	BC
040000             0344  	ENDMACRO
040000             0345  ; --- End macros.inc ---
040000             0346  
040000             0347  ; --- Begin equs.inc ---
040000             0348  ;
040000             0349  ; Title:	BBC Basic for AGON - Equs
040000             0350  ; Author:	Dean Belfield
040000             0351  ; Created:	12/05/2023
040000             0352  ; Last Updated:	08/06/2023
040000             0353  ;
040000             0354  ; Modinfo:
040000             0355  ; 08/06/2023:	Added SIZEW
040000             0356  
040000             0357  			; XREF		STAVAR
040000             0358  			; XREF		ACCS
040000             0359  
040000             0360  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0361  ;Stack_Top:		EQU		0000h	; Stack at top
040000             0362  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0363  
040000             0364  ; For GPIO
040000             0365  ; PA not available on eZ80L92
040000             0366  ;
040000             0367  PA_DR:			EQU		96h
040000             0368  PA_DDR:			EQU		97h
040000             0369  PA_ALT1:		EQU		98h
040000             0370  PA_ALT2:		EQU		99h
040000             0371  PB_DR:          	EQU		9Ah
040000             0372  PB_DDR:        	 	EQU		9Bh
040000             0373  PB_ALT1:        	EQU		9Ch
040000             0374  PB_ALT2:        	EQU		9Dh
040000             0375  PC_DR:          	EQU		9Eh
040000             0376  PC_DDR:         	EQU		9Fh
040000             0377  PC_ALT1:        	EQU		A0h
040000             0378  PC_ALT2:        	EQU		A1h
040000             0379  PD_DR:          	EQU		A2h
040000             0380  PD_DDR:			EQU		A3h
040000             0381  PD_ALT1:		EQU		A4h
040000             0382  PD_ALT2:		EQU		A5h
040000             0383  
040000             0384  GPIOMODE_OUT:		EQU		0	; Output
040000             0385  GPIOMODE_IN:		EQU		1	; Input
040000             0386  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0387  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0388  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0389  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0390  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0391  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0392  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0393  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0394  
040000             0395  ; ; Originally in ram.asm
040000             0396  ; ;
040000             0397  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040000             0398  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040000             0399  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040000             0400  
040000             0401  ; Originally in main.asm
040000             0402  ;
040000             0403  CR:			EQU     0DH
040000             0404  LF:			EQU     0AH
040000             0405  ESC:			EQU     1BH
040000             0406  ; --- End equs.inc ---
040000             0407  
040000             0408  ; --- Begin init.asm ---
040000             0409  ;
040000             0410  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0411  ;		Initialisation Code
040000             0412  ; Author:	Dean Belfield
040000             0413  ; Created:	12/05/2023
040000             0414  ; Last Updated:	26/11/2023
040000             0415  ;
040000             0416  ; Modinfo:
040000             0417  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0418  ; 26/11/2023:	Moved the ram clear routine into here
040000             0419  
040000             0420  			; SEGMENT CODE
040000             0421  
040000             0422  			; XDEF	_end
040000             0423  
040000             0424  			; XREF	_main				; In main.asm
040000             0425  
040000             0426  			; XREF	RAM_START			; In ram.asm
040000             0427  			; XREF	RAM_END
040000             0428  
040000             0429  			; .ASSUME	ADL = 1
040000             0430  
040000             0431  			; INCLUDE	"equs.inc"
040000             0432  
040000             0433  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0434  
040000             0435  ;
040000             0436  ; Start in ADL mode
040000             0437  ;
040000 C3 45 00 04 0438  			JP	_start				; Jump to start
040004             0439  ;
040004             0440  ; The header stuff is from byte 64 onwards
040004             0441  ;
040004 42 42 43 42 0442  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040011             0443  
040011 FF FF FF FF 0444  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0445  
040040 4D 4F 53    0446  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0447  			DB	00h				; MOS header version 0
040044 01          0448  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0449  ;
040045             0450  ; And the code follows on immediately after the header
040045             0451  ;
040045 F5          0452  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0453  			PUSH		BC
040047 D5          0454  			PUSH		DE
040048 DD E5       0455  			PUSH		IX
04004A FD E5       0456  			PUSH		IY
04004C             0457  
04004C ED 73 D7 00 0458  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0459  
040051 DD 21 DA 00 0460  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0461  			PUSH		IX
040058 CD 88 00 04 0462  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0463  			POP		IX			; IX: argv
04005E 06 00       0464  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0465  			CALL		_clear_ram
040064 C3 EE 2F 04 0466  			JP		_main			; Start user code
040068             0467  ;
040068             0468  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0469  ;
040068 ED 7B D7 00 0470  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0471  
04006D FD E1       0472  			POP		IY			; Restore the registers
04006F DD E1       0473  			POP		IX
040071 D1          0474  			POP		DE
040072 C1          0475  			POP		BC
040073 F1          0476  			POP		AF
040074 C9          0477  			RET					; Return to MOS
040075             0478  
040075             0479  ;Clear the application memory
040075             0480  ;
040075 C5          0481  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0482  			LD		HL, RAM_START
04007A 11 01 4A 04 0483  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0484  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0485  			XOR		A
040083 77          0486  			LD		(HL), A
040084 ED B0       0487  			LDIR
040086 C1          0488  			POP		BC
040087 C9          0489  			RET
040088             0490  
040088             0491  ; Parse the parameter string into a C array
040088             0492  ; Parameters
040088             0493  ; - HL: Address of parameter string
040088             0494  ; - IX: Address for array pointer storage
040088             0495  ; Returns:
040088             0496  ; -  C: Number of parameters parsed
040088             0497  ;
040088 01 04 00 04 0498  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0499  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0500  			INC	IX
040091 DD 23       0501  			INC	IX
040093 DD 23       0502  			INC	IX
040095 CD D0 00 04 0503  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0504  ;
040099 01 01 00 00 0505  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0506  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0507  ;
04009F             0508  _parse_params_1:
04009F C5          0509  			PUSH	BC			; Stack ARGC
0400A0 E5          0510  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0511  			CALL	_get_token		; Get the next token
0400A5 79          0512  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0513  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0514  			POP	BC			; ARGC
0400A8 B7          0515  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0516  			RET	Z
0400AA             0517  ;
0400AA DD 1F 00    0518  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0519  			PUSH	HL			; DE=HL
0400AE D1          0520  			POP	DE
0400AF CD D0 00 04 0521  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0522  			XOR	A
0400B4 12          0523  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0524  			INC	IX
0400B7 DD 23       0525  			INC	IX
0400B9 DD 23       0526  			INC	IX			; Advance to next pointer position
0400BB 0C          0527  			INC	C			; Increment ARGC
0400BC 79          0528  			LD	A, C			; Check for C >= A
0400BD B8          0529  			CP	B
0400BE 38 DF       0530  			JR	C, _parse_params_1	; And loop
0400C0 C9          0531  			RET
0400C1             0532  
0400C1             0533  ; Get the next token
0400C1             0534  ; Parameters:
0400C1             0535  ; - HL: Address of parameter string
0400C1             0536  ; Returns:
0400C1             0537  ; - HL: Address of first character after token
0400C1             0538  ; -  C: Length of token (in characters)
0400C1             0539  ;
0400C1 0E 00       0540  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0541  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0542  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0543  			RET 	Z
0400C6 FE 0D       0544  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0545  			RET	Z
0400C9 FE 20       0546  			CP	' '			; Exit if space (end of token)
0400CB C8          0547  			RET	Z
0400CC 23          0548  			INC	HL			; Advance to next character
0400CD 0C          0549  			INC 	C			; Increment length
0400CE 18 F3       0550  			JR	@B
0400D0             0551  
0400D0             0552  ; Skip spaces in the parameter string
0400D0             0553  ; Parameters:
0400D0             0554  ; - HL: Address of parameter string
0400D0             0555  ; Returns:
0400D0             0556  ; - HL: Address of next none-space character
0400D0             0557  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0558  ;
0400D0 7E          0559  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0560  			CP	' '			; Exit if not space
0400D3 C0          0561  			RET	NZ
0400D4 23          0562  			INC	HL			; Advance to next character
0400D5 18 F9       0563  			JR	_skip_spaces		; Increment length
0400D7             0564  
0400D7             0565  ; Storage
0400D7             0566  ;
0400D7             0567  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0568  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0569  
04010A             0570  ; --- Begin eval.asm ---
04010A             0571  ;
04010A             0572  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0573  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0574  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0575  ; Modified By:	Dean Belfield
04010A             0576  ; Created:	12/05/2023
04010A             0577  ; Last Updated:	17/08/2023
04010A             0578  ;
04010A             0579  ; Modinfo:
04010A             0580  ; 07/06/2023:	Modified to run in ADL mode
04010A             0581  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0582  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0583  ; 17/08/2023:	Added binary constants
04010A             0584  
04010A             0585  			; .ASSUME	ADL = 1
04010A             0586  
04010A             0587  			; INCLUDE	"equs.inc"
04010A             0588  			; INCLUDE "macros.inc"
04010A             0589  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0590  
04010A             0591  			; SEGMENT CODE
04010A             0592  
04010A             0593  			; XDEF	EXPR
04010A             0594  			; XDEF	EXPRN
04010A             0595  			; XDEF	EXPRI
04010A             0596  			; XDEF	EXPRS
04010A             0597  			; XDEF	ITEMI
04010A             0598  			; XDEF	LOADN
04010A             0599  			; XDEF	LOAD4
04010A             0600  			; XDEF	CONS
04010A             0601  			; XDEF	LOADS
04010A             0602  			; XDEF	SFIX
04010A             0603  			; XDEF	VAL0
04010A             0604  			; XDEF	SEARCH
04010A             0605  			; XDEF	SWAP
04010A             0606  			; XDEF	TEST
04010A             0607  			; XDEF	DECODE
04010A             0608  			; XDEF	HEXSTR
04010A             0609  			; XDEF	STR
04010A             0610  			; XDEF	ZERO
04010A             0611  			; XDEF	PUSHS
04010A             0612  			; XDEF	POPS
04010A             0613  			; XDEF	COMMA
04010A             0614  			; XDEF	BRAKET
04010A             0615  			; XDEF	NXT
04010A             0616  			; XDEF	COUNT0
04010A             0617  
04010A             0618  			; XREF	ADVAL
04010A             0619  			; XREF	FN_EX
04010A             0620  			; XREF	POINT
04010A             0621  			; XREF	USR
04010A             0622  			; XREF	SYNTAX
04010A             0623  			; XREF	ERROR_
04010A             0624  			; XREF	CHECK
04010A             0625  			; XREF	GETVAR
04010A             0626  			; XREF	LISTON
04010A             0627  			; XREF	RANGE
04010A             0628  			; XREF	FPP
04010A             0629  			; XREF	GETCSR
04010A             0630  			; XREF	CHANEL
04010A             0631  			; XREF	OSSTAT
04010A             0632  			; XREF	OSBGET
04010A             0633  			; XREF	LOMEM
04010A             0634  			; XREF	HIMEM
04010A             0635  			; XREF	PAGE_
04010A             0636  			; XREF	TOP
04010A             0637  			; XREF	ERL
04010A             0638  			; XREF	ERR
04010A             0639  			; XREF	COUNT
04010A             0640  			; XREF	OSOPEN
04010A             0641  			; XREF	GETEXT
04010A             0642  			; XREF	GETPTR
04010A             0643  			; XREF	GETIME
04010A             0644  			; XREF	GETIMS
04010A             0645  			; XREF	LEXAN2
04010A             0646  			; XREF	RANDOM
04010A             0647  			; XREF	STORE5
04010A             0648  			; XREF	GETSCHR
04010A             0649  			; XREF	OSRDCH
04010A             0650  			; XREF	OSKEY
04010A             0651  			; XREF	INKEY1
04010A             0652  			; XREF	EXTERR
04010A             0653  ;
04010A             0654  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0655  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0656  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0657  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0658  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0659  ;
04010A             0660  ; BINARY INTEGER REPRESENTATION:
04010A             0661  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0662  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0663  ;
04010A             0664  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0665  ;                             EXPONENT - C
04010A             0666  ;
04010A             0667  
04010A             0668  ;
04010A             0669  ; Table of addresses for functions
04010A             0670  ;
04010A             0671  FUNTOK:			EQU	8DH			; First token number
04010A             0672  ;
04010A EB 08 04    0673  FUNTBL:			DW24	DECODE			; Line number
04010D 99 05 04    0674  			DW24	OPENIN			; OPENIN
040110 BB 05 04    0675  			DW24	PTR_EV			; PTR
040113 55 05 04    0676  			DW24	PAGEV			; PAGE
040116 C5 05 04    0677  			DW24	TIMEV			; TIME
040119 41 05 04    0678  			DW24	LOMEMV			; LOMEM
04011C 4B 05 04    0679  			DW24	HIMEMV			; HIMEM
04011F 19 06 04    0680  			DW24	ABSV			; ABS
040122 55 06 04    0681  			DW24	ACS			; ACS
040125 84 49 04    0682  			DW24	ADVAL			; ADVAL
040128 2A 05 04    0683  			DW24	ASC			; ASC
04012B 4D 06 04    0684  			DW24	ASN			; ASN
04012E 51 06 04    0685  			DW24	ATN			; ATN
040131 F3 04 04    0686  			DW24	BGET			; BGET
040134 39 06 04    0687  			DW24	COS			; COS
040137 80 05 04    0688  			DW24	COUNTV			; COUNT
04013A 21 06 04    0689  			DW24	DEG			; DEG
04013D 74 05 04    0690  			DW24	ERLV			; ERL
040140 7A 05 04    0691  			DW24	ERRV			; ERR
040143 7E 06 04    0692  			DW24	EVAL_			; EVAL
040146 41 06 04    0693  			DW24	EXP			; EXP
040149 B1 05 04    0694  			DW24	EXT			; EXT
04014C 98 09 04    0695  			DW24	ZERO			; FALSE
04014F 87 10 04    0696  			DW24	FN_EX			; FN
040152 11 05 04    0697  			DW24	GET			; GET
040155 00 05 04    0698  			DW24	INKEY			; INKEY
040158 30 07 04    0699  			DW24	INSTR			; INSTR(
04015B 2D 06 04    0700  			DW24	INT_			; INT
04015E 3A 05 04    0701  			DW24	LEN			; LEN
040161 45 06 04    0702  			DW24	LN			; LN
040164 49 06 04    0703  			DW24	LOG			; LOG
040167 1D 06 04    0704  			DW24	NOTK			; NOT
04016A 95 05 04    0705  			DW24	OPENUP			; OPENUP
04016D 92 05 04    0706  			DW24	OPENOT			; OPENOUT
040170 15 06 04    0707  			DW24	PI			; PI
040173 A7 44 04    0708  			DW24	POINT			; POINT(
040176 D2 04 04    0709  			DW24	POS			; POS
040179 25 06 04    0710  			DW24	RAD			; RAD
04017C B2 06 04    0711  			DW24	RND			; RND
04017F 29 06 04    0712  			DW24	SGN			; SGN
040182 3D 06 04    0713  			DW24	SIN			; SIN
040185 31 06 04    0714  			DW24	SQR			; SQR
040188 35 06 04    0715  			DW24	TAN			; TAN
04018B 5F 05 04    0716  			DW24	TOPV			; TO(P)
04018E 0A 06 04    0717  			DW24	TRUE			; TRUE
040191 54 15 04    0718  			DW24	USR			; USR
040194 6F 06 04    0719  			DW24	VAL			; VAL
040197 DB 04 04    0720  			DW24	VPOS			; VPOS
04019A C4 07 04    0721  			DW24	CHRS			; CHRS
04019D CC 07 04    0722  			DW24	GETS			; GETS
0401A0 DD 07 04    0723  			DW24	INKEYS			; INKEYS
0401A3 62 08 04    0724  			DW24	LEFTS			; LEFTS(
0401A6 2A 08 04    0725  			DW24	MIDS			; MIDS(
0401A9 82 08 04    0726  			DW24	RIGHTS			; RIGHTS(
0401AC 4F 09 04    0727  			DW24	STRS			; STR$
0401AF A3 08 04    0728  			DW24	STRING_			; STRINGS(
0401B2 E3 04 04    0729  			DW24	EOF			; EOF
0401B5             0730  ;
0401B5             0731  FUNTBL_END:		EQU	$
0401B5             0732  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0733  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0734  
0401B5             0735  ANDK:			EQU     80H
0401B5             0736  DIVK:			EQU     81H
0401B5             0737  EORK:			EQU     82H
0401B5             0738  MODK:			EQU     83H
0401B5             0739  ORK:			EQU     84H
0401B5             0740  ;
0401B5 F5 05 04    0741  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 FE 05 04    0742  			DW24	SNE			; <>
0401BB EE 05 04    0743  			DW24	SGE			; >=
0401BE DF 05 04    0744  			DW24	SLT			; <
0401C1 05 06 04    0745  			DW24	SEQ			; =
0401C4 E6 05 04    0746  			DW24	SGT			; >
0401C7             0747  ;
0401C7             0748  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0749  ;     Expression type is returned in A'F':
0401C7             0750  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0751  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0752  ; Floating-point or integer result returned in HLH'L'C
0401C7             0753  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0754  ; String result returned in string accumulator, DE set.
0401C7             0755  ;
0401C7             0756  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0757  ;               (2) ^
0401C7             0758  ;               (3) * / MOD DIV
0401C7             0759  ;               (4) + -
0401C7             0760  ;               (5) = <> <= >= > <
0401C7             0761  ;               (6) AND
0401C7             0762  ;               (7) EOR OR
0401C7             0763  
0401C7             0764  ;
0401C7             0765  ; Level 7: EOR and OR
0401C7             0766  ;
0401C7 CD E0 01 04 0767  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0768  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0769  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0770  			CP      ORK			; Is operator OR
0401D1 C0          0771  			RET     NZ			; No, so return
0401D2             0772  ;
0401D2 CD 46 0A 04 0773  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0774  			CALL    EXPR1           	; Get second operand
0401DA CD 55 0A 04 0775  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0776  			JR      EXPR0A          	; And continue
0401E0             0777  ;
0401E0             0778  ; Level 6: AND
0401E0             0779  ;
0401E0 CD F5 01 04 0780  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0781  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0782  			RET     NZ			; No, so return
0401E7 CD 46 0A 04 0783  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0784  			CALL    EXPR2			; Get second operand
0401EF CD 55 0A 04 0785  			CALL    DOIT			; Do the operation
0401F3 18 EF       0786  			JR      EXPR1A			; And continue
0401F5             0787  ;
0401F5             0788  ; Level 5: Comparisons
0401F5             0789  ;
0401F5 CD 67 02 04 0790  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 1D 0A 04 0791  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0792  			RET     NZ			; No, so return
0401FE 47          0793  			LD      B,A			; Store the first operator in B
0401FF FD 23       0794  			INC     IY              	; Bump over operator
040201 CD 78 0A 04 0795  			CALL    NXT			;
040205 CD 1D 0A 04 0796  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0797  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0798  			INC     IY			; Bump over operator
04020D B8          0799  			CP      B			; Compare with first
04020E CA 9F 0C 04 0800  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0801  			ADD     A,B
040213 47          0802  			LD      B,A			; B: Unique code for the compound operator
040214 78          0803  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0804  			EX      AF,AF'
040216 FA 30 02 04 0805  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0806  			EX      AF,AF'
04021B D6 04       0807  			SUB     4
04021D FE 3A       0808  			CP      '>'-4
04021F 20 02       0809  			JR      NZ,EXPR2C
040221 C6 02       0810  			ADD     A,2
040223 CD 48 0A 04 0811  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0812  			CALL    EXPR3
04022B CD 55 0A 04 0813  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0814  			RET
040230             0815  ;
040230 08          0816  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0817  			DEC     A
040232 E6 07       0818  			AND     7
040234 CD B9 09 04 0819  			CALL    PUSHS           	; Save string on the stack
040238 F5          0820  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0821  			CALL    EXPR3           	; Get the second string
04023D 08          0822  			EX      AF,AF'
04023E F2 3B 03 04 0823  			JP      P,TYPE_EV_
040242 F1          0824  			POP     AF
040243 4B          0825  			LD      C,E             	; Length of string #2
040244 D1          0826  			POP     DE
040245 21 00 00 00 0827  			LD      HL,0
040249 39          0828  			ADD     HL,SP
04024A 43          0829  			LD      B,E             	; Length of string #1
04024B D5          0830  			PUSH    DE
04024C 11 00 4A 04 0831  			LD      DE,ACCS
040250 EB          0832  			EX      DE,HL
040251 CD 84 0A 04 0833  			CALL    DISPT2
040255 D1          0834  			POP     DE
040256 EB          0835  			EX      DE,HL
040257 7D          0836  			LD	A,L
040258 21 00 00 00 0837  			LD	HL,0
04025C 6F          0838  			LD	L,A
04025D 39          0839  			ADD     HL,SP
04025E F9          0840  			LD      SP,HL
04025F EB          0841  			EX      DE,HL
040260 AF          0842  			XOR     A               	; Numeric marker
040261 4F          0843  			LD      C,A             	; Integer marker
040262 08          0844  			EX      AF,AF'
040263 FD 7E 00    0845  			LD      A,(IY)
040266 C9          0846  			RET
040267             0847  ;
040267             0848  ; Level 4: + and -
040267             0849  ;
040267 CD C9 02 04 0850  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0851  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0852  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0853  			CP      '+'			; Is it "+"?
040271 C0          0854  			RET     NZ			; No, so return
040272 08          0855  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0856  			JP      M,EXPR3S		; Branch here if string
040277 08          0857  			EX      AF,AF'
040278 CD 46 0A 04 0858  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C9 02 04 0859  			CALL    EXPR4			; Fetch the second operator
040280 CD 55 0A 04 0860  			CALL    DOIT			; Do the operation
040284 18 E5       0861  			JR      EXPR3A			; And continue
040286             0862  ;
040286 08          0863  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0864  			INC     IY              	; Bump past the "+"
040289 CD B9 09 04 0865  			CALL    PUSHS           	; Save the string on the stack
04028D CD C9 02 04 0866  			CALL    EXPR4           	; Fetch the second operator
040291 08          0867  			EX      AF,AF'
040292 F2 3B 03 04 0868  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0869  			LD	BC, 0			; Clear BC
04029A 4B          0870  			LD      C,E             	; C: Length of the second string
04029B D1          0871  			POP     DE
04029C D5          0872  			PUSH    DE
04029D 21 00 4A 04 0873  			LD      HL,ACCS
0402A1 7B          0874  			LD	A,E			;  E: Length of the first string
0402A2 11 00 4A 04 0875  			LD      DE,ACCS
0402A6 5F          0876  			LD	E,A 			; DE: Pointer to the end of the first string
0402A7 79          0877  			LD      A,C
0402A8 B7          0878  			OR      A
0402A9 28 0F       0879  			JR      Z,EXP3S3
0402AB 6F          0880  			LD      L,A             	; Source
0402AC 83          0881  			ADD     A,E
0402AD 5F          0882  			LD      E,A             	; Destination
0402AE 3E 13       0883  			LD      A,19
0402B0 DA 98 37 04 0884  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402B4 D5          0885  			PUSH    DE
0402B5 1D          0886  			DEC     E
0402B6 2D          0887  			DEC     L
0402B7 ED B8       0888  			LDDR                    	; Copy
0402B9 D1          0889  			POP     DE
0402BA D9          0890  EXP3S3:			EXX
0402BB C1          0891  			POP     BC
0402BC CD E6 09 04 0892  			CALL    POPS            	; Restore from stack
0402C0 D9          0893  			EXX
0402C1 F6 80       0894  			OR      80H             	; Flag as a string
0402C3 08          0895  			EX      AF,AF'
0402C4 FD 7E 00    0896  			LD      A,(IY)			; Fetch the next character
0402C7 18 A2       0897  			JR      EXPR3A			; And continue
0402C9             0898  ;
0402C9             0899  ; Level 3: * / MOD DIV
0402C9             0900  ;
0402C9 CD EA 02 04 0901  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402CD FE 2A       0902  EXPR4A:			CP      '*'			; "*" is valid
0402CF 28 0B       0903  			JR      Z,EXPR4B
0402D1 FE 2F       0904  			CP      '/'			; "/" is valid
0402D3 28 07       0905  			JR      Z,EXPR4B
0402D5 FE 83       0906  			CP      MODK			; MOD token is valid
0402D7 28 03       0907  			JR      Z,EXPR4B
0402D9 FE 81       0908  			CP      DIVK			; DIV token is valid
0402DB C0          0909  			RET     NZ			; And return if it is anything else
0402DC CD 46 0A 04 0910  EXPR4B:			CALL    SAVE_EV
0402E0 CD EA 02 04 0911  			CALL    EXPR5
0402E4 CD 55 0A 04 0912  			CALL    DOIT
0402E8 18 E3       0913  			JR      EXPR4A
0402EA             0914  ;
0402EA             0915  ; Level 2: ^
0402EA             0916  ;
0402EA CD CA 03 04 0917  EXPR5:			CALL    ITEM			; Get variable
0402EE B7          0918  			OR      A               	; Test type
0402EF 08          0919  			EX      AF,AF'          	; Save type
0402F0 CD 78 0A 04 0920  EXPR5A:			CALL    NXT			; Skip spaces
0402F4 FE 5E       0921  			CP      '^'			; Is the operator "^"?
0402F6 C0          0922  			RET     NZ			; No, so return
0402F7 CD 46 0A 04 0923  			CALL    SAVE_EV			; Save first operand
0402FB CD CA 03 04 0924  			CALL    ITEM			; Get second operand
0402FF B7          0925  			OR      A			; Test type
040300 08          0926  			EX      AF,AF'			; Save type
040301 CD 55 0A 04 0927  			CALL    DOIT			; Do the operation
040305 18 E9       0928  			JR      EXPR5A			; And continue
040307             0929  ;
040307             0930  ; Evaluate a numeric expression
040307             0931  ;
040307 CD C7 01 04 0932  EXPRN:			CALL    EXPR			; Evaluate expression
04030B 08          0933  			EX      AF,AF'			; Get the type
04030C F0          0934  			RET     P			; And return if it is a number
04030D 18 2C       0935  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030F             0936  ;
04030F             0937  ; Evaluate a fixed-point expression
04030F             0938  ;
04030F CD C7 01 04 0939  EXPRI:			CALL    EXPR			; Evaluate the expression
040313 08          0940  			EX      AF,AF'			; Get the type
040314 F2 67 06 04 0941  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040318 18 21       0942  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031A             0943  ;
04031A             0944  ; Evaluate a string expression
04031A             0945  ;
04031A CD C7 01 04 0946  EXPRS:			CALL    EXPR			; Evaluate the expression
04031E 08          0947  			EX      AF,AF'			; Get the type
04031F F8          0948  			RET     M			; And return if it is a string
040320 18 19       0949  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040322             0950  ;
040322             0951  ; Get a numeric variable
040322             0952  ;
040322 CD CA 03 04 0953  ITEMN:			CALL    ITEM			; Get the variable
040326 B7          0954  			OR      A			; Test the type
040327 F0          0955  			RET     P			; And return if it is a number
040328 18 11       0956  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032A             0957  ;
04032A             0958  ; Get a fixed-point variable
04032A             0959  ;
04032A CD CA 03 04 0960  ITEMI:			CALL    ITEM			; Get the variable
04032E B7          0961  			OR      A			; Test the type
04032F F2 67 06 04 0962  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040333 18 06       0963  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040335             0964  ;
040335             0965  ; Get a string variable
040335             0966  ;
040335 CD CA 03 04 0967  ITEMS:			CALL    ITEM			; Get the variable
040339 B7          0968  			OR      A			; Test the type
04033A F8          0969  			RET     M			; If it is a string, then return
04033B             0970  ;							; Otherwise
04033B 3E 06       0971  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
04033D C3 98 37 04 0972  			JP      ERROR_
040341             0973  ;
040341             0974  ; Evaluate a bracketed expression
040341             0975  ;
040341 CD C7 01 04 0976  ITEM1:			CALL    EXPR            	; Evaluate the expression
040345 CD 37 0A 04 0977  			CALL    BRAKET			; Check for closing bracket
040349 08          0978  			EX      AF,AF'
04034A C9          0979  			RET
04034B             0980  ;
04034B             0981  ; HEX - Get hexadecimal constant.
04034B             0982  ;   Inputs: ASCII string at (IY)
04034B             0983  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
04034B             0984  ;           IY updated (points to delimiter)
04034B             0985  ;
04034B CD 98 09 04 0986  HEX:			CALL    ZERO			; Set result to 0
04034F CD 00 0A 04 0987  			CALL    HEXDIG			; Fetch the character from IY
040353 38 1B       0988  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040355 FD 23       0989  HEX1:			INC     IY			; Move pointer to next character
040357 E6 0F       0990  			AND     0FH			; Clear the top nibble
040359 06 04       0991  			LD      B,4			; Loop counter
04035B             0992  ;
04035B D9          0993  HEX2:			EXX				; Shift the result left B (4) times. This makes
04035C 52 29       0994  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
04035E D9          0995  			EXX				; .
04035F 52 ED 6A    0996  			ADC.S   HL,HL			; .
040362 10 F7       0997  			DJNZ    HEX2			; And loop
040364 D9          0998  			EXX
040365 B5          0999  			OR      L			; OR in the digit
040366 6F          1000  			LD      L,A
040367 D9          1001  			EXX
040368             1002  ;
040368 CD 00 0A 04 1003  			CALL    HEXDIG			; Fetch the next character
04036C 30 E7       1004  			JR      NC,HEX1			; If it is a HEX digit then loop
04036E AF          1005  			XOR     A			; Clear A
04036F C9          1006  			RET
040370             1007  ;
040370 3E 1C       1008  BADHEX:			LD      A,28
040372 C3 98 37 04 1009  			JP      ERROR_          	; Error: "Bad HEX"
040376             1010  ;
040376             1011  ; BIN - Get binary constant.
040376             1012  ;   Inputs: ASCII string at (IY)
040376             1013  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040376             1014  ;           IY updated (points to delimiter)
040376             1015  ;
040376 CD 98 09 04 1016  BIN:			CALL    ZERO			; Set result to 0
04037A CD 13 0A 04 1017  			CALL	BINDIG			; Fetch the character from IY
04037E 38 13       1018  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
040380 FD 23       1019  BIN1:			INC	IY			; Move pointer to next character
040382 0F          1020  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
040383 D9          1021  			EXX				;
040384 52 ED 6A    1022  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040387 D9          1023  			EXX
040388 52 ED 6A    1024  			ADC.S	HL,HL
04038B CD 13 0A 04 1025  			CALL	BINDIG			; Fetch the next character
04038F 30 EF       1026  			JR	NC,BIN1
040391 AF          1027  			XOR	A			; Clear A
040392 C9          1028  			RET
040393             1029  ;
040393 3E 1C       1030  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040395 CD AF 37 04 1031  			CALL	EXTERR
040399 42 61 64 20 1032  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0403A4             1033  ;
0403A4             1034  ; MINUS - Unary minus.
0403A4             1035  ;   Inputs: IY = text pointer
0403A4             1036  ;  Outputs: Numeric result, same type as argument.
0403A4             1037  ;           Result in H'L'HLC
0403A4             1038  ;
0403A4 CD 22 03 04 1039  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A8 0D          1040  MINUS0:			DEC     C			; Check exponent (C)
0403A9 0C          1041  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403AA 28 06       1042  			JR      Z,NEGATE_EV        	; So do an integer negation
0403AC             1043  ;
0403AC 7C          1044  			LD      A,H			; Do a FP negation by
0403AD EE 80       1045  			XOR     80H             	; Toggling the sign bit (H)
0403AF 67          1046  			LD      H,A
0403B0 AF          1047  			XOR     A               	; Numeric marker
0403B1 C9          1048  			RET
0403B2             1049  ;
0403B2 D9          1050  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403B3 7C          1051  			LD      A,H			; First do a one's complement by negating all the bytes
0403B4 2F          1052  			CPL
0403B5 67          1053  			LD      H,A
0403B6 7D          1054  			LD      A,L
0403B7 2F          1055  			CPL
0403B8 6F          1056  			LD      L,A
0403B9 D9          1057  			EXX
0403BA 7C          1058  			LD      A,H
0403BB 2F          1059  			CPL
0403BC 67          1060  			LD      H,A
0403BD 7D          1061  			LD      A,L
0403BE 2F          1062  			CPL
0403BF 6F          1063  			LD      L,A
0403C0 D9          1064  ADD1:			EXX				; Then add 1
0403C1 23          1065  			INC     HL
0403C2 7C          1066  			LD      A,H
0403C3 B5          1067  			OR      L
0403C4 D9          1068  			EXX
0403C5 3E 00       1069  			LD      A,0             	; Numeric marker
0403C7 C0          1070  			RET     NZ
0403C8 23          1071  			INC     HL
0403C9 C9          1072  			RET
0403CA             1073  ;
0403CA             1074  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403CA             1075  ; Item type is returned in A:  Bit 7=0 numeric.
0403CA             1076  ;                              Bit 7=1 string.
0403CA             1077  ; Numeric item returned in HLH'L'C.
0403CA             1078  ; String item returned in string accumulator,
0403CA             1079  ;   DE addresses byte after last (E=length).
0403CA             1080  ;
0403CA CD 81 16 04 1081  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403CE CD 78 0A 04 1082  			CALL    NXT			; Skip spaces
0403D2 FD 23       1083  			INC     IY			; Move to the prefix character
0403D4 FE 26       1084  			CP      '&'			; If `&`
0403D6 CA 4B 03 04 1085  			JP      Z,HEX           	; Then get a HEX constant
0403DA FE 25       1086  			CP	'%'			; If '%'
0403DC 28 98       1087  			JR	Z,BIN			; Then get a BINARY constant
0403DE FE 2D       1088  			CP      '-'			; If `-`
0403E0 28 C2       1089  			JR      Z,MINUS         	; Then get a negative number
0403E2 FE 2B       1090  			CP      '+'			; If `+`
0403E4 CA 22 03 04 1091  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E8 FE 28       1092  			CP      '('			; If `(`
0403EA CA 41 03 04 1093  			JP      Z,ITEM1         	; Start of a bracketed expression
0403EE FE 22       1094  			CP      34			; If `"`
0403F0 28 7A       1095  			JR      Z,CONS          	; Start of a string constant
0403F2 FE C6       1096  			CP      TCMD_EV			; Is it out of range of the function table?
0403F4 D2 9F 0C 04 1097  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F8 FE 8D       1098  			CP      FUNTOK			; If it is in range, then
0403FA D2 8B 0A 04 1099  			JP      NC,DISPAT       	; It's a function
0403FE FD 2B       1100  			DEC     IY
040400 FE 3A       1101  			CP      ':'
040402 30 0C       1102  			JR      NC,ITEM2		; VARIABLE?
040404 FE 30       1103  			CP      '0'
040406 D2 93 04 04 1104  			JP      NC,CON			; NUMERIC CONSTANT
04040A FE 2E       1105  			CP      '.'
04040C CA 93 04 04 1106  			JP      Z,CON			; NUMERIC CONSTANT
040410 CD 72 3A 04 1107  ITEM2:			CALL    GETVAR			; VARIABLE
040414 20 37       1108  			JR      NZ,NOSUCH
040416 B7          1109  			OR      A
040417 FA A5 04 04 1110  			JP      M,LOADS			; STRING VARIABLE
04041B B7          1111  LOADN:			OR      A
04041C 28 20       1112  			JR      Z,LOAD1			; BYTE VARIABLE
04041E 0E 00       1113  			LD      C,0
040420 CB 47       1114  			BIT     0,A
040422 28 03       1115  			JR      Z,LOAD4			; INTEGER VARIABLE
040424 DD 4E 04    1116  LOAD5:			LD      C,(IX+4)
040427 D9          1117  LOAD4:			EXX
040428 21 00 00 00 1118  			LD	HL, 0			; TODO: Optimise
04042C DD 6E 00    1119  			LD      L,(IX+0)
04042F DD 66 01    1120  			LD      H,(IX+1)
040432 D9          1121  			EXX
040433 21 00 00 00 1122  			LD	HL, 0			; TODO: Optimise
040437 DD 6E 02    1123  			LD      L,(IX+2)
04043A DD 66 03    1124  			LD      H,(IX+3)
04043D C9          1125  			RET
04043E             1126  ;
04043E 21 00 00 00 1127  LOAD1:			LD      HL,0
040442 D9          1128  			EXX
040443 21 00 00 00 1129  			LD      HL,0			; TODO: Optimise
040447 DD 6E 00    1130  			LD      L,(IX+0)
04044A D9          1131  			EXX
04044B 4C          1132  			LD      C,H
04044C C9          1133  			RET
04044D             1134  ;
04044D DA 9F 0C 04 1135  NOSUCH:			JP      C,SYNTAX
040451 3A 40 4D 04 1136  			LD      A,(LISTON)
040455 CB 6F       1137  			BIT     5,A
040457 3E 1A       1138  			LD      A,26
040459 20 26       1139  			JR      NZ,ERROR0_EV		; Throw "No such variable"
04045B FD 23       1140  NOS1:			INC     IY
04045D CD A7 3C 04 1141  			CALL    RANGE
040461 30 F8       1142  			JR      NC,NOS1
040463 DD 21 40 30 1143  			LD      IX,PC
       11          
040468 AF          1144  			XOR     A
040469 4F          1145  			LD      C,A
04046A 18 BB       1146  			JR      LOAD4
04046C             1147  ;
04046C             1148  ;CONS - Get string constant from ASCII string.
04046C             1149  ;   Inputs: ASCII string at (IY)
04046C             1150  ;  Outputs: Result in string accumulator.
04046C             1151  ;           D = MS byte of ACCS, E = string length
04046C             1152  ;           A7 = 1 (string marker)
04046C             1153  ;           IY updated
04046C             1154  ;
04046C 11 00 4A 04 1155  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040470 FD 7E 00    1156  CONS3:			LD      A,(IY)			; Fetch the first character and
040473 FD 23       1157  			INC     IY			; Increment the pointer
040475 FE 22       1158  			CP      '"'			; Check for start quote
040477 28 0C       1159  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040479             1160  ;
040479 12          1161  CONS1:			LD      (DE),A			; Store the character in the string accumulator
04047A 1C          1162  			INC     E			; Increment the string accumulator pointer
04047B FE 0D       1163  			CP      CR			; Is it CR
04047D 20 F1       1164  			JR      NZ,CONS3		; No, so keep looping
04047F             1165  ;
04047F 3E 09       1166  			LD      A,9
040481 C3 98 37 04 1167  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040485             1168  ;
040485 FD 7E 00    1169  CONS2:			LD      A,(IY)			; Fetch the next character
040488 FE 22       1170  			CP      '"'			; Check for end quote?
04048A FD 23       1171  			INC     IY			; Increment the pointer
04048C 28 EB       1172  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
04048E FD 2B       1173  			DEC     IY			;
040490 3E 80       1174  			LD      A,80H           	; String marker
040492 C9          1175  			RET
040493             1176  ;
040493             1177  ;CON - Get unsigned numeric constant from ASCII string.
040493             1178  ;   Inputs: ASCII string at (IY).
040493             1179  ;  Outputs: Variable-type result in HLH'L'C
040493             1180  ;           IY updated (points to delimiter)
040493             1181  ;           A7 = 0 (numeric marker)
040493             1182  ;
040493 FD E5       1183  CON:			PUSH    IY
040495 DD E1       1184  			POP     IX
040497 3E 24       1185  			LD      A,36
040499 CD A2 20 04 1186  			CALL    FPP
04049D 38 E2       1187  			JR      C,ERROR0_EV
04049F DD E5       1188  			PUSH    IX
0404A1 FD E1       1189  			POP     IY
0404A3 AF          1190  			XOR     A
0404A4 C9          1191  			RET
0404A5             1192  ;
0404A5 11 00 4A 04 1193  LOADS:			LD      DE,ACCS			; Where to store the string
0404A9 1F          1194  			RRA
0404AA 30 1A       1195  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404AC             1196  ;
0404AC D9          1197  			EXX				; This block was a call to LOAD4
0404AD DD 6E 00    1198  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404B0 DD 66 01    1199  			LD      H,(IX+1)		; The maximum original string length
0404B3 D9          1200  			EXX
0404B4 DD 27 02    1201  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B7             1202  ;
0404B7 D9          1203  			EXX
0404B8 7D          1204  			LD      A,L
0404B9 D9          1205  			EXX
0404BA B7          1206  			OR      A
0404BB 01 00 00 00 1207  			LD	BC,0			; BC: Number of bytes to copy
0404BF 4F          1208  			LD      C,A
0404C0 3E 80       1209  			LD      A,80H           	; String marker
0404C2 C8          1210  			RET     Z
0404C3 ED B0       1211  			LDIR
0404C5 C9          1212  			RET
0404C6 7E          1213  LOADS2:			LD      A,(HL)
0404C7 12          1214  			LD      (DE),A
0404C8 23          1215  			INC     HL
0404C9 FE 0D       1216  			CP      CR
0404CB 3E 80       1217  			LD      A,80H           	; String marker
0404CD C8          1218  			RET     Z
0404CE 1C          1219  			INC     E
0404CF 20 F5       1220  			JR      NZ,LOADS2
0404D1 C9          1221  			RET                     	; Return null string
0404D2             1222  ;
0404D2             1223  ;VARIABLE-TYPE FUNCTIONS:
0404D2             1224  ;
0404D2             1225  ;Result returned in HLH'L'C (floating point)
0404D2             1226  ;Result returned in HLH'L' (C=0) (integer)
0404D2             1227  ;Result returned in string accumulator & DE (string)
0404D2             1228  ;All registers destroyed.
0404D2             1229  ;IY (text pointer) updated.
0404D2             1230  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404D2             1231  ;
0404D2             1232  ;POS - horizontal cursor position.
0404D2             1233  ;VPOS - vertical cursor position.
0404D2             1234  ;EOF - return status of file.
0404D2             1235  ;BGET - read byte from file.
0404D2             1236  ;INKEY - as GET but wait only n centiseconds.
0404D2             1237  ;GET - wait for keypress and return ASCII value.
0404D2             1238  ;GET(n) - input from Z80 port n.
0404D2             1239  ;ASC - ASCII value of string.
0404D2             1240  ;LEN - length of string.
0404D2             1241  ;LOMEM - location of dynamic variables.
0404D2             1242  ;HIMEM - top of available RAM.
0404D2             1243  ;PAGE - start of current text page.
0404D2             1244  ;TOP - address of first free byte after program.
0404D2             1245  ;ERL - line number where last error occurred.
0404D2             1246  ;ERR - number of last error.
0404D2             1247  ;COUNT - number of printing characters since CR.
0404D2             1248  ;Results are integer numeric.
0404D2             1249  ;
0404D2 CD 04 3F 04 1250  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D6 EB          1251  			EX      DE,HL			;  L: The X cursor position
0404D7 C3 86 05 04 1252  			JP      COUNT1			; Return an 8-bit value
0404DB             1253  ;
0404DB CD 04 3F 04 1254  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DF C3 86 05 04 1255  			JP      COUNT1			; Return an 8-bit value
0404E3             1256  ;
0404E3 CD B8 18 04 1257  EOF:			CALL    CHANEL			; Check for EOF
0404E7 CD 8D 43 04 1258  			CALL    OSSTAT
0404EB CA 0A 06 04 1259  			JP      Z,TRUE			; Yes, so return true
0404EF C3 98 09 04 1260  			JP      ZERO			; Otherwise return false (zero)
0404F3             1261  ;
0404F3 CD B8 18 04 1262  BGET:			CALL    CHANEL          	; Channel number
0404F7 CD 7C 43 04 1263  			CALL    OSBGET
0404FB 6F          1264  			LD      L,A
0404FC C3 84 05 04 1265  			JP      COUNT0			; Return an 8-bit value
040500             1266  ;
040500 CD 2A 03 04 1267  INKEY:			CALL    ITEMI			; Get the argument
040504 CB 7C       1268  			BIT	7, H			; Check the sign
040506 D9          1269  			EXX				; HL: The argument
040507 C2 F0 07 04 1270  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
04050B CD E2 07 04 1271  			CALL	INKEY0 			; Do INKEY(n)
04050F 18 1D       1272  			JR      ASC0			; Return a numeric value
040511             1273  ;
040511 CD 78 0A 04 1274  GET:			CALL    NXT			; Skip whitespace
040515 FE 28       1275  			CP      '('			; Is it GET(
040517 20 0B       1276  			JR      NZ,GET0			; No, so get a keyboard character
040519 CD 2A 03 04 1277  			CALL    ITEMI           	; Yes, so fetch the port address
04051D D9          1278  			EXX
04051E 44          1279  			LD      B,H			; BC: The port address
04051F 4D          1280  			LD      C,L
040520 ED 68       1281  			IN      L,(C)           	;  L: Input from port BC
040522 18 60       1282  			JR      COUNT0			; Return an 8-bit value
040524             1283  ;
040524 CD CC 07 04 1284  GET0:			CALL    GETS			; Read the keyboard character
040528 18 0A       1285  			JR      ASC1			; And return the value
04052A             1286  ;
04052A CD 35 03 04 1287  ASC:			CALL    ITEMS			; Get the string argument argument
04052E AF          1288  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052F BB          1289  			CP      E			; Is the pointer 0
040530 CA 0A 06 04 1290  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
040534 2A 00 4A 04 1291  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040538 18 4A       1292  			JR      COUNT0			; An 8-bit value
04053A             1293  ;
04053A CD 35 03 04 1294  LEN:			CALL    ITEMS			; Get the string argument
04053E EB          1295  			EX      DE,HL			; HL: Pointer into ACCS
04053F 18 43       1296  			JR      COUNT0			; Return L
040541             1297  ;
040541 2A 1A 4D 04 1298  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040545 3A 1C 4D 04 1299  			LD	A, (LOMEM+2)
040549 18 41       1300  			JR      COUNT2			; A 24-bit value
04054B             1301  ;
04054B 2A 20 4D 04 1302  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054F 3A 22 4D 04 1303  			LD	A, (HIMEM+2)
040553 18 37       1304  			JR      COUNT2			; A 24-bit value
040555             1305  ;
040555 2A 14 4D 04 1306  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040559 3A 16 4D 04 1307  			LD	A, (PAGE_+2)		; A 24-bit value
04055D 18 2D       1308  			JR      COUNT2
04055F             1309  ;
04055F FD 7E 00    1310  TOPV:			LD      A,(IY)			; Return the TOP system variable
040562 FD 23       1311  			INC     IY              	; Skip "P"
040564 FE 50       1312  			CP      'P'
040566 C2 9F 0C 04 1313  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
04056A 2A 17 4D 04 1314  			LD      HL,(TOP)
04056E 3A 19 4D 04 1315  			LD	A, (TOP+2)
040572 18 18       1316  			JR      COUNT2
040574             1317  ;
040574 2A 33 4D 04 1318  ERLV:			LD      HL,(ERL)		; Return the error line
040578 18 0C       1319  			JR      COUNT1			; A 16-bit value
04057A             1320  ;
04057A 2A 3F 4D 04 1321  ERRV:			LD      HL,(ERR)		; Return the error value
04057E 18 04       1322  			JR      COUNT0			; An 8-bit value
040580             1323  ;
040580 2A 3D 4D 04 1324  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
040584             1325  
040584 26 00       1326  COUNT0:			LD      H,0			; Return L
040586 D9          1327  COUNT1:			EXX				; Return HL
040587 AF          1328  			XOR     A
040588 4F          1329  			LD      C,A             	; Integer marker
040589 67          1330  			LD      H,A
04058A 6F          1331  			LD      L,A
04058B C9          1332  			RET
04058C D9          1333  COUNT2:			EXX
04058D 6F          1334  			LD	L,A
04058E AF          1335  			XOR	A
04058F 4F          1336  			LD	C,A			; Integer marker
040590 67          1337  			LD	H,A
040591 C9          1338  			RET
040592             1339  ;
040592             1340  ;OPENIN - Open a file for reading.
040592             1341  ;OPENOT - Open a file for writing.
040592             1342  ;OPENUP - Open a file for reading or writing.
040592             1343  ;Result is integer channel number (0 if error)
040592             1344  ;
040592 AF          1345  OPENOT:			XOR     A			; Open for writing
040593 18 06       1346  			JR	OPENIN_1
040595             1347  ;
040595 3E 02       1348  OPENUP:			LD      A,2			; Open for reading / writing
040597 18 02       1349  			JR	OPENIN_1
040599             1350  ;
040599 3E 01       1351  OPENIN:			LD      A,1			; Open for reading
04059B             1352  ;
04059B F5          1353  OPENIN_1:		PUSH    AF              	; Save OPEN type
04059C CD 35 03 04 1354  			CALL    ITEMS           	; Fetch the filename
0405A0 3E 0D       1355  			LD      A,CR
0405A2 12          1356  			LD      (DE),A
0405A3 F1          1357  			POP     AF              	; Restore the OPEN type
0405A4 C6 FF       1358  			ADD     A,-1            	; Affect the flags
0405A6 21 00 4A 04 1359  			LD      HL,ACCS
0405AA CD 65 43 04 1360  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405AE 6F          1361  			LD      L,A			; L: Channel number
0405AF 18 D3       1362  			JR      COUNT0			; Return channel number to BASIC
0405B1             1363  ;
0405B1             1364  ;EXT - Return length of file.
0405B1             1365  ;PTR_EV - Return current file pointer.
0405B1             1366  ;Results are integer numeric.
0405B1             1367  ;
0405B1 CD B8 18 04 1368  EXT:			CALL    CHANEL
0405B5 CD C3 43 04 1369  			CALL    GETEXT
0405B9 18 15       1370  			JR      TIME0
0405BB             1371  ;
0405BB CD B8 18 04 1372  PTR_EV:			CALL    CHANEL
0405BF CD 97 43 04 1373  			CALL    GETPTR
0405C3 18 0B       1374  			JR      TIME0
0405C5             1375  ;
0405C5             1376  ;TIME - Return current value of elapsed time.
0405C5             1377  ;Result is integer numeric.
0405C5             1378  ;
0405C5 FD 7E 00    1379  TIMEV:			LD      A,(IY)
0405C8 FE 24       1380  			CP      '$'
0405CA 28 0A       1381  			JR      Z,TIMEVS
0405CC CD E4 3E 04 1382  			CALL    GETIME
0405D0 D5          1383  TIME0:			PUSH    DE
0405D1 D9          1384  			EXX
0405D2 E1          1385  			POP     HL
0405D3 AF          1386  			XOR     A
0405D4 4F          1387  			LD      C,A
0405D5 C9          1388  			RET
0405D6             1389  ;
0405D6             1390  ;TIME$ - Return date/time string.
0405D6             1391  ;Result is string
0405D6             1392  ;
0405D6 FD 23       1393  TIMEVS:			INC     IY              ;SKIP $
0405D8 CD DC 43 04 1394  			CALL    GETIMS
0405DC 3E 80       1395  			LD      A,80H           ;MARK STRING
0405DE C9          1396  			RET
0405DF             1397  ;
0405DF             1398  ;String comparison:
0405DF             1399  ;
0405DF CD 94 09 04 1400  SLT:			CALL    SCP
0405E3 D0          1401  			RET     NC
0405E4 18 24       1402  			JR      TRUE
0405E6             1403  ;
0405E6 CD 94 09 04 1404  SGT:			CALL    SCP
0405EA C8          1405  			RET     Z
0405EB D8          1406  			RET     C
0405EC 18 1C       1407  			JR      TRUE
0405EE             1408  ;
0405EE CD 94 09 04 1409  SGE:			CALL    SCP
0405F2 D8          1410  			RET     C
0405F3 18 15       1411  			JR      TRUE
0405F5             1412  ;
0405F5 CD 94 09 04 1413  SLE:			CALL    SCP
0405F9 28 0F       1414  			JR      Z,TRUE
0405FB D0          1415  			RET     NC
0405FC 18 0C       1416  			JR      TRUE
0405FE             1417  ;
0405FE CD 94 09 04 1418  SNE:			CALL    SCP
040602 C8          1419  			RET     Z
040603 18 05       1420  			JR      TRUE
040605             1421  ;
040605 CD 94 09 04 1422  SEQ:			CALL    SCP
040609 C0          1423  			RET     NZ
04060A 3E FF       1424  TRUE:			LD      A,-1
04060C D9          1425  			EXX
04060D 67          1426  			LD      H,A
04060E 6F          1427  			LD      L,A
04060F D9          1428  			EXX
040610 67          1429  			LD      H,A
040611 6F          1430  			LD      L,A
040612 3C          1431  			INC     A
040613 4F          1432  			LD      C,A
040614 C9          1433  			RET
040615             1434  ;
040615             1435  ;PI - Return PI (3.141592654)
040615             1436  ;Result is floating-point numeric.
040615             1437  ;
040615 3E 23       1438  PI:			LD      A,35
040617 18 44       1439  			JR      FPP1
040619             1440  ;
040619             1441  ;ABS - Absolute value
040619             1442  ;Result is numeric, variable type.
040619             1443  ;
040619 3E 10       1444  ABSV:			LD      A,16
04061B 18 3A       1445  			JR      FPPN
04061D             1446  ;
04061D             1447  ;NOT - Complement integer.
04061D             1448  ;Result is integer numeric.
04061D             1449  ;
04061D 3E 1A       1450  NOTK:			LD      A,26
04061F 18 36       1451  			JR      FPPN
040621             1452  ;
040621             1453  ;DEG - Convert radians to degrees
040621             1454  ;Result is floating-point numeric.
040621             1455  ;
040621 3E 15       1456  DEG:			LD      A,21
040623 18 32       1457  			JR      FPPN
040625             1458  ;
040625             1459  ;RAD - Convert degrees to radians
040625             1460  ;Result is floating-point numeric.
040625             1461  ;
040625 3E 1B       1462  RAD:			LD      A,27
040627 18 2E       1463  			JR      FPPN
040629             1464  ;
040629             1465  ;SGN - Return -1, 0 or +1
040629             1466  ;Result is integer numeric.
040629             1467  ;
040629 3E 1C       1468  SGN:			LD      A,28
04062B 18 2A       1469  			JR      FPPN
04062D             1470  ;
04062D             1471  ;INT - Floor function
04062D             1472  ;Result is integer numeric.
04062D             1473  ;
04062D 3E 17       1474  INT_:			LD      A,23
04062F 18 26       1475  			JR      FPPN
040631             1476  ;
040631             1477  ;SQR - square root
040631             1478  ;Result is floating-point numeric.
040631             1479  ;
040631 3E 1E       1480  SQR:			LD      A,30
040633 18 22       1481  			JR      FPPN
040635             1482  ;
040635             1483  ;TAN - Tangent function
040635             1484  ;Result is floating-point numeric.
040635             1485  ;
040635 3E 1F       1486  TAN:			LD      A,31
040637 18 1E       1487  			JR      FPPN
040639             1488  ;
040639             1489  ;COS - Cosine function
040639             1490  ;Result is floating-point numeric.
040639             1491  ;
040639 3E 14       1492  COS:			LD      A,20
04063B 18 1A       1493  			JR      FPPN
04063D             1494  ;
04063D             1495  ;SIN - Sine function
04063D             1496  ;Result is floating-point numeric.
04063D             1497  ;
04063D 3E 1D       1498  SIN:			LD      A,29
04063F 18 16       1499  			JR      FPPN
040641             1500  ;
040641             1501  ;EXP - Exponential function
040641             1502  ;Result is floating-point numeric.
040641             1503  ;
040641 3E 16       1504  EXP:			LD      A,22
040643 18 12       1505  			JR      FPPN
040645             1506  ;
040645             1507  ;LN - Natural log.
040645             1508  ;Result is floating-point numeric.
040645             1509  ;
040645 3E 18       1510  LN:			LD      A,24
040647 18 0E       1511  			JR      FPPN
040649             1512  ;
040649             1513  ;LOG - base-10 logarithm.
040649             1514  ;Result is floating-point numeric.
040649             1515  ;
040649 3E 19       1516  LOG:			LD      A,25
04064B 18 0A       1517  			JR      FPPN
04064D             1518  ;
04064D             1519  ;ASN - Arc-sine
04064D             1520  ;Result is floating-point numeric.
04064D             1521  ;
04064D 3E 12       1522  ASN:			LD      A,18
04064F 18 06       1523  			JR      FPPN
040651             1524  ;
040651             1525  ;ATN - arc-tangent
040651             1526  ;Result is floating-point numeric.
040651             1527  ;
040651 3E 13       1528  ATN:			LD      A,19
040653 18 02       1529  			JR      FPPN
040655             1530  ;
040655             1531  ;ACS - arc-cosine
040655             1532  ;Result is floating point numeric.
040655             1533  ;
040655 3E 11       1534  ACS:			LD      A,17
040657 F5          1535  FPPN:			PUSH    AF
040658 CD 22 03 04 1536  			CALL    ITEMN
04065C F1          1537  			POP     AF
04065D CD A2 20 04 1538  FPP1:			CALL    FPP
040661 DA 98 37 04 1539  			JP      C,ERROR_
040665 AF          1540  			XOR     A
040666 C9          1541  			RET
040667             1542  ;
040667             1543  ;SFIX - Convert to fixed-point notation
040667             1544  ;
040667 3E 26       1545  SFIX:			LD      A,38
040669 18 F2       1546  			JR      FPP1
04066B             1547  ;
04066B             1548  ;SFLOAT - Convert to floating-point notation
04066B             1549  ;
04066B 3E 27       1550  SFLOAT:			LD      A,39
04066D 18 EE       1551  			JR      FPP1
04066F             1552  ;
04066F             1553  ;VAL - Return numeric value of string.
04066F             1554  ;Result is variable type numeric.
04066F             1555  ;
04066F CD 35 03 04 1556  VAL:			CALL    ITEMS
040673 AF          1557  VAL0:			XOR     A
040674 12          1558  			LD      (DE),A
040675 DD 21 00 4A 1559  			LD      IX,ACCS
       04          
04067A 3E 24       1560  			LD      A,36
04067C 18 DF       1561  			JR      FPP1
04067E             1562  ;
04067E             1563  ;EVAL - Pass string to expression evaluator.
04067E             1564  ;Result is variable type (numeric or string).
04067E             1565  ;
04067E CD 35 03 04 1566  EVAL_:			CALL    ITEMS
040682 3E 0D       1567  			LD      A,CR
040684 12          1568  			LD      (DE),A
040685 FD E5       1569  			PUSH    IY
040687 11 00 4A 04 1570  			LD      DE,ACCS
04068B FD 21 00 4A 1571  			LD      IY,ACCS
       04          
040690 0E 00       1572  			LD      C,0
040692 CD D7 3C 04 1573  			CALL    LEXAN2          ;TOKENISE
040696 12          1574  			LD      (DE),A
040697 13          1575  			INC     DE
040698 AF          1576  			XOR     A
040699 CD B9 09 04 1577  			CALL    PUSHS           ;PUT ON STACK
04069D FD 21 03 00 1578  			LD      IY,SIZEW	;WAS 2
       00          
0406A2 FD 39       1579  			ADD     IY,SP
0406A4 CD C7 01 04 1580  			CALL    EXPR
0406A8 FD E1       1581  			POP     IY
0406AA FD 39       1582  			ADD     IY,SP
0406AC FD F9       1583  			LD      SP,IY           ;ADJUST STACK POINTER
0406AE FD E1       1584  			POP     IY
0406B0 08          1585  			EX      AF,AF'
0406B1 C9          1586  			RET
0406B2             1587  ;
0406B2             1588  ;RND - Random number function.
0406B2             1589  ; RND gives random integer 0-&FFFFFFFF
0406B2             1590  ; RND(-n) seeds random number & returns -n.
0406B2             1591  ; RND(0) returns last value in RND(1) form.
0406B2             1592  ; RND(1) returns floating-point 0-0.99999999.
0406B2             1593  ; RND(n) returns random integer 1-n.
0406B2             1594  ;
0406B2 DD 21 38 4D 1595  RND:			LD      IX,RANDOM
       04          
0406B7 CD 78 0A 04 1596  			CALL    NXT
0406BB FE 28       1597  			CP      '('
0406BD 28 20       1598  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BF CD 24 04 04 1599  			CALL    LOAD5
0406C3 CB 19       1600  RND1:			RR      C
0406C5 06 20       1601  			LD      B,32
0406C7 D9          1602  RND2:			EXX                     ;CALCULATE NEXT
0406C8 52 ED 6A    1603  			ADC.S   HL,HL
0406CB D9          1604  			EXX
0406CC 52 ED 6A    1605  			ADC.S   HL,HL
0406CF CB 5D       1606  			BIT     3,L
0406D1 28 01       1607  			JR      Z,RND3
0406D3 3F          1608  			CCF
0406D4 10 F1       1609  RND3:			DJNZ    RND2
0406D6 CB 11       1610  RND4:			RL      C               ;SAVE CARRY
0406D8 CD 0D 16 04 1611  			CALL    STORE5          ;STORE NEW NUMBER
0406DC AF          1612  			XOR     A
0406DD 4F          1613  			LD      C,A
0406DE C9          1614  			RET
0406DF CD 2A 03 04 1615  RND5:			CALL    ITEMI
0406E3 DD 21 38 4D 1616  			LD      IX,RANDOM
       04          
0406E8 CB 7C       1617  			BIT     7,H             ;NEGATIVE?
0406EA 37          1618  			SCF
0406EB 20 E9       1619  			JR      NZ,RND4         ;SEED
0406ED CD E4 08 04 1620  			CALL    TEST
0406F1 F5          1621  			PUSH    AF
0406F2 CD DC 08 04 1622  			CALL    SWAP
0406F6 D9          1623  			EXX
0406F7 CD 24 04 04 1624  			CALL    LOAD5
0406FB C4 C3 06 04 1625  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FF D9          1626  			EXX                     ;SCRAMBLE (CARE!)
040700 0E 7F       1627  			LD      C,7FH
040702 CB 7C       1628  RND6:			BIT     7,H             ;FLOAT
040704 20 0A       1629  			JR      NZ,RND7
040706 D9          1630  			EXX
040707 52 29       1631  			ADD.S   HL,HL
040709 D9          1632  			EXX
04070A 52 ED 6A    1633  			ADC.S   HL,HL
04070D 0D          1634  			DEC     C
04070E 20 F2       1635  			JR      NZ,RND6
040710 CB BC       1636  RND7:			RES     7,H             ;POSITIVE 0-0.999999
040712 F1          1637  			POP     AF
040713 C8          1638  			RET     Z               ;ZERO ARGUMENT
040714 D9          1639  			EXX
040715 7B          1640  			LD      A,E
040716 3D          1641  			DEC     A
040717 B2          1642  			OR      D
040718 D9          1643  			EXX
040719 B3          1644  			OR      E
04071A B2          1645  			OR      D
04071B C8          1646  			RET     Z               ;ARGUMENT=1
04071C 06 00       1647  			LD      B,0             ;INTEGER MARKER
04071E 3E 0A       1648  			LD      A,10
040720 CD A2 20 04 1649  			CALL    FPP             ;MULTIPLY
040724 DA 98 37 04 1650  			JP      C,ERROR_
040728 CD 67 06 04 1651  			CALL    SFIX
04072C C3 C0 03 04 1652  			JP      ADD1
040730             1653  ;
040730             1654  ; INSTR - String search.
040730             1655  ; Result is integer numeric.
040730             1656  ;
040730 CD 26 0A 04 1657  INSTR:			CALL    EXPRSC			; Get the first string expression
040734 CD B9 09 04 1658  			CALL    PUSHS           	; Push the string onto the stack
040738 CD 1A 03 04 1659  			CALL    EXPRS           	; Get the second string expression
04073C C1          1660  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
04073D 21 00 00 00 1661  			LD      HL,0
040741 39          1662  			ADD     HL,SP           	; HL: Pointer to main string
040742 C5          1663  			PUSH    BC              	;  C: Main string length
040743 43          1664  			LD      B,E             	;  B: Sub-string length
040744 CD 78 0A 04 1665  			CALL    NXT			; Skip whitespace
040748 FE 2C       1666  			CP      ','			; Check if there is a comma for the third parameter
04074A 3E 00       1667  			LD      A,0			;  A: Default start position in string
04074C 20 1A       1668  			JR      NZ,INSTR1		; No, so skip the next bit
04074E FD 23       1669  			INC     IY              	; Skip the comma
040750 C5          1670  			PUSH    BC              	; Save the lengths
040751 E5          1671  			PUSH    HL              	; Save the pointer to the main string
040752 CD B9 09 04 1672  			CALL    PUSHS			; Push the string onto the stack
040756 CD 0F 03 04 1673  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
04075A C1          1674  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
04075B CD E6 09 04 1675  			CALL    POPS			; Pop the string off the stack
04075F E1          1676  			POP     HL              	; Restore the pointer to the main string
040760 C1          1677  			POP     BC              	; Restore the lengths
040761 D9          1678  			EXX
040762 7D          1679  			LD      A,L			; A: The start position in the  string
040763 D9          1680  			EXX
040764 B7          1681  			OR      A			; Set the flags
040765 28 01       1682  			JR      Z,INSTR1		; If it is zero, then skip
040767 3D          1683  			DEC     A
040768 11 00 4A 04 1684  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
04076C CD 8A 07 04 1685  			CALL    SEARCH			; Do the search
040770 D1          1686  			POP     DE
040771 28 03       1687  			JR      Z,INSTR2        	; NB: Carry cleared
040773 ED 62       1688  			SBC     HL,HL
040775 39          1689  			ADD     HL,SP
040776 ED 72       1690  INSTR2:			SBC     HL,SP
040778 EB          1691  			EX      DE,HL
040779 7D          1692  			LD	A,L
04077A 21 00 00 00 1693  			LD      HL,0
04077E 6F          1694  			LD	L,A
04077F 39          1695  			ADD     HL,SP
040780 F9          1696  			LD      SP,HL
040781 EB          1697  			EX      DE,HL
040782 CD 37 0A 04 1698  			CALL    BRAKET			; Check for closing bracket
040786 C3 86 05 04 1699  			JP      COUNT1			; Return a numeric integer
04078A             1700  ;
04078A             1701  ; SEARCH - Search string for sub-string
04078A             1702  ;    Inputs: Main string at HL length C
04078A             1703  ;            Sub-string  at DE length B
04078A             1704  ;            Starting offset A
04078A             1705  ;   Outputs: NZ - not found
04078A             1706  ;            Z - found at location HL-1
04078A             1707  ;            Carry always cleared
04078A             1708  ;
04078A C5          1709  SEARCH:			PUSH    BC			; Add the starting offset to HL
04078B 01 00 00 00 1710  			LD      BC,0
04078F 4F          1711  			LD      C,A
040790 09          1712  			ADD     HL,BC           	; New start address
040791 C1          1713  			POP     BC
040792 91          1714  			SUB     C			; If the starting offset > main string length, then do nothing
040793 30 2C       1715  			JR      NC,SRCH4
040795 ED 44       1716  			NEG
040797 4F          1717  			LD      C,A             	; Remaining length
040798             1718  ;
040798 C5          1719  SRCH1:			PUSH    BC
040799 79          1720  			LD	A,C
04079A 01 00 00 00 1721  			LD	BC,0
04079E 4F          1722  			LD	C,A
04079F 1A          1723  			LD      A,(DE)
0407A0 ED B1       1724  			CPIR                    	; Find the first character
0407A2 79          1725  			LD      A,C
0407A3 C1          1726  			POP     BC
0407A4 20 1B       1727  			JR      NZ,SRCH4
0407A6 4F          1728  			LD      C,A
0407A7             1729  ;
0407A7             1730  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A7             1731  ;
0407A7 05          1732  			DEC     B			; Bug fix
0407A8 B8          1733  			CP      B			; Bug fix
0407A9 04          1734  			INC     B			; Bug fix
0407AA 38 15       1735  			JR      C,SRCH4			; Bug fix
0407AC             1736  ;
0407AC C5          1737  			PUSH    BC
0407AD D5          1738  			PUSH    DE
0407AE E5          1739  			PUSH    HL
0407AF 05          1740  			DEC     B
0407B0 28 08       1741  			JR      Z,SRCH3         	; Found!
0407B2 13          1742  SRCH2:			INC     DE
0407B3 1A          1743  			LD      A,(DE)
0407B4 BE          1744  			CP      (HL)
0407B5 20 03       1745  			JR      NZ,SRCH3
0407B7 23          1746  			INC     HL
0407B8 10 F8       1747  			DJNZ    SRCH2
0407BA E1          1748  SRCH3:			POP     HL
0407BB D1          1749  			POP     DE
0407BC C1          1750  			POP     BC
0407BD 20 D9       1751  			JR      NZ,SRCH1
0407BF AF          1752  			XOR     A               	; Flags: Z, NC
0407C0 C9          1753  			RET                     	; Found
0407C1             1754  ;
0407C1 F6 FF       1755  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407C3 C9          1756  			RET                     	; Not found
0407C4             1757  ;
0407C4             1758  ;CHRS - Return character with given ASCII value.
0407C4             1759  ;Result is string.
0407C4             1760  ;
0407C4 CD 2A 03 04 1761  CHRS:			CALL    ITEMI
0407C8 D9          1762  			EXX
0407C9 7D          1763  			LD      A,L
0407CA 18 0E       1764  			JR      GET1
0407CC             1765  ;
0407CC             1766  ;GETS - Return key pressed as stringor character at position (X,Y).
0407CC             1767  ;Result is string.
0407CC             1768  ;
0407CC CD 78 0A 04 1769  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407D0 FE 28       1770  			CP	'('
0407D2 CA 3A 44 04 1771  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D6 CD 61 3F 04 1772  			CALL    OSRDCH
0407DA 37          1773  GET1:			SCF
0407DB 18 09       1774  			JR      INKEY1
0407DD             1775  ;
0407DD             1776  ; INKEYS - Wait up to n centiseconds for keypress.
0407DD             1777  ;          Return key pressed as string or null
0407DD             1778  ;          string if time elapsed.
0407DD             1779  ; Result is string.
0407DD             1780  ;
0407DD CD 2A 03 04 1781  INKEYS:			CALL    ITEMI			; Fetch the argument
0407E1 D9          1782  			EXX
0407E2 CD 6A 3F 04 1783  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E6 11 00 4A 04 1784  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407EA 12          1785  			LD      (DE),A
0407EB 3E 80       1786  			LD      A,80H
0407ED D0          1787  			RET     NC
0407EE 1C          1788  			INC     E
0407EF C9          1789  			RET
0407F0             1790  ;
0407F0             1791  ; INKEYM - Check immediately whether a given key is being pressed
0407F0             1792  ; Result is integer numeric
0407F0             1793  ;
0407F0             1794  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407F0 3E 1E       0001M 			LD	A, function
0407F2 49 CF       0002M 			RST.LIS	08h
0407F4 23          1795  			INC	HL			; Index from 0
0407F5 7D          1796  			LD	A, L			; Negate the LSB of the answer
0407F6 ED 44       1797  			NEG
0407F8 4F          1798  			LD	C, A			;  E: The positive keycode value
0407F9 3E 01       1799  			LD	A, 1			; Throw an "Out of range" error
0407FB FA 98 37 04 1800  			JP	M, ERROR_		; if the argument < - 128
0407FF             1801  ;
0407FF 21 22 08 04 1802  			LD	HL, BITLOOKUP		; HL: The bit lookup table
040803 11 00 00 00 1803  			LD	DE, 0
040807 79          1804  			LD	A, C
040808 E6 07       1805  			AND	00000111b		; Just need the first three bits
04080A 5F          1806  			LD	E, A			; DE: The bit number
04080B 19          1807  			ADD	HL, DE
04080C 46          1808  			LD	B, (HL)			;  B: The mask
04080D             1809  ;
04080D 79          1810  			LD	A, C			; Fetch the keycode again
04080E E6 78       1811  			AND	01111000b		; And divide by 8
040810 0F          1812  			RRCA
040811 0F          1813  			RRCA
040812 0F          1814  			RRCA
040813 5F          1815  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
040814 DD 19       1816  			ADD	IX, DE			; IX: The address
040816 78          1817  			LD	A, B			;  B: The mask
040817 DD A6 00    1818  			AND	(IX+0)			; Check whether the bit is set
04081A CA 98 09 04 1819  			JP	Z, ZERO			; No, so return 0
04081E C3 0A 06 04 1820  			JP	TRUE			; Otherwise return -1
040822             1821  ;
040822             1822  ; A bit lookup table
040822             1823  ;
040822 01 02 04 08 1824  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040826 10 20 40 80 1825  			DB	10h, 20h, 40h, 80h
04082A             1826  ;
04082A             1827  ; MID$ - Return sub-string.
04082A             1828  ; Result is string.
04082A             1829  ;
04082A CD 26 0A 04 1830  MIDS:			CALL    EXPRSC			; Get the first string expression
04082E CD B9 09 04 1831  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040832 CD 0F 03 04 1832  			CALL    EXPRI			; Get the second expression
040836 C1          1833  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040837 CD E6 09 04 1834  			CALL    POPS			; Pop the string back off the stack to the string accumulator
04083B D9          1835  			EXX
04083C 7D          1836  			LD      A,L			; A: The start index
04083D D9          1837  			EXX
04083E B7          1838  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083F 28 0E       1839  			JR      Z,MIDS1
040841 3D          1840  			DEC     A
040842 6F          1841  			LD      L,A			; L: The start index - 1
040843 93          1842  			SUB     E			; Subtract from the string length
040844 1E 00       1843  			LD      E,0			; Preemptively set the string length to 0
040846 30 07       1844  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040848 ED 44       1845  			NEG				; Negate the answer and
04084A 4F          1846  			LD      C,A			; C: Number of bytes to copy
04084B CD 8E 08 04 1847  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084F CD 78 0A 04 1848  MIDS1:			CALL    NXT			; Skip whitespace
040853 FE 2C       1849  			CP      ','			; Check for a comma
040855 FD 23       1850  			INC     IY			; Advance to the next character in the BASIC line
040857 28 0D       1851  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040859 FD 2B       1852  			DEC     IY			; Restore the BASIC program pointer
04085B CD 37 0A 04 1853  			CALL    BRAKET			; Check for a bracket
04085F 3E 80       1854  			LD      A,80H			; String marker
040861 C9          1855  			RET
040862             1856  ;
040862             1857  ; LEFT$ - Return left part of string.
040862             1858  ; Carry cleared if entire string returned.
040862             1859  ; Result is string.
040862             1860  ;
040862 CD 26 0A 04 1861  LEFTS:			CALL    EXPRSC			; Get the first string expression
040866 CD B9 09 04 1862  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04086A CD 0F 03 04 1863  			CALL    EXPRI			; Get the second expression
04086E C1          1864  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086F CD E6 09 04 1865  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
040873 CD 37 0A 04 1866  			CALL    BRAKET			; Check for closing bracket
040877 D9          1867  			EXX
040878 7D          1868  			LD      A,L			; L: The second parameter
040879 D9          1869  			EXX
04087A BB          1870  			CP      E			; Compare with the string length
04087B 30 02       1871  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
04087D 6B          1872  			LD      L,E             	; For RIGHTS, no effect in LEFTS
04087E 5F          1873  LEFT2:			LD      E,A			; E: The new length of string
04087F 3E 80       1874  LEFT3:			LD      A,80H           	; String marker
040881 C9          1875  			RET
040882             1876  ;
040882             1877  ; RIGHT$ - Return right part of string.
040882             1878  ; Result is string.
040882             1879  ;
040882 CD 62 08 04 1880  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040886 D0          1881  			RET     NC			; Do nothing if the second parameter is >= string length
040887 1C          1882  			INC     E			; Check for a zero length string
040888 1D          1883  			DEC     E
040889 C8          1884  			RET     Z			; Yes, so do nothing
04088A 4B          1885  			LD      C,E			;  C: Number of bytes to copy
04088B 7D          1886  			LD      A,L
04088C 93          1887  			SUB     E
04088D 6F          1888  			LD      L,A			;  L: Index into the string
04088E 79          1889  RIGHT1:			LD	A,C
04088F 01 00 00 00 1890  			LD	BC,0
040893 4F          1891  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
040894 7D          1892  			LD	A,L
040895 21 00 4A 04 1893  			LD	HL,ACCS
040899 6F          1894  			LD	L,A			; HL: Source (in ACCS)
04089A 11 00 4A 04 1895  			LD      DE,ACCS			; DE: Destination (start of ACCS)
04089E ED B0       1896  			LDIR                    	; Copy
0408A0 3E 80       1897  			LD      A,80H			; String marker
0408A2 C9          1898  			RET
0408A3             1899  ;
0408A3             1900  ; STRINGS - Return n concatenations of a string.
0408A3             1901  ; Result is string.
0408A3             1902  ;
0408A3 CD 0F 03 04 1903  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A7 CD 2A 0A 04 1904  			CALL    COMMA			; Check for comma
0408AB D9          1905  			EXX
0408AC 7D          1906  			LD      A,L			; L: Number of iterations of string
0408AD D9          1907  			EXX
0408AE F5          1908  			PUSH    AF
0408AF CD 1A 03 04 1909  			CALL    EXPRS			; Get the string
0408B3 CD 37 0A 04 1910  			CALL    BRAKET			; Check for closing bracket
0408B7 F1          1911  			POP     AF			; A: Number of iterations of string
0408B8 B7          1912  			OR      A			; Set flags
0408B9 28 C3       1913  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408BB 3D          1914  			DEC     A
0408BC 4F          1915  			LD      C,A			; C: Loop counter
0408BD 3E 80       1916  			LD      A,80H			; String marker
0408BF C8          1917  			RET     Z
0408C0 1C          1918  			INC     E			; Check for empty string
0408C1 1D          1919  			DEC     E
0408C2 C8          1920  			RET     Z              		; And return
0408C3 43          1921  			LD      B,E			; B: String length tally
0408C4 21 00 4A 04 1922  			LD	HL,ACCS
0408C8 C5          1923  STRIN1:			PUSH    BC
0408C9 7E          1924  STRIN2:			LD      A,(HL)
0408CA 23          1925  			INC     HL
0408CB 12          1926  			LD      (DE),A
0408CC 1C          1927  			INC     E
0408CD 3E 13       1928  			LD      A,19
0408CF CA 98 37 04 1929  			JP      Z,ERROR_         	; Throw a "String too long" error
0408D3 10 F4       1930  			DJNZ    STRIN2
0408D5 C1          1931  			POP     BC
0408D6 0D          1932  			DEC     C
0408D7 20 EF       1933  			JR      NZ,STRIN1
0408D9 3E 80       1934  			LD      A,80H
0408DB C9          1935  			RET
0408DC             1936  ;
0408DC             1937  ;SUBROUTINES
0408DC             1938  ;
0408DC             1939  ;SWAP - Swap arguments
0408DC             1940  ;Exchanges DE,HL D'E',H'L' and B,C
0408DC             1941  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408DC             1942  ;
0408DC 79          1943  SWAP:			LD      A,C
0408DD 48          1944  			LD      C,B
0408DE 47          1945  			LD      B,A
0408DF EB          1946  			EX      DE,HL
0408E0 D9          1947  			EXX
0408E1 EB          1948  			EX      DE,HL
0408E2 D9          1949  			EXX
0408E3 C9          1950  			RET
0408E4             1951  ;
0408E4             1952  ;TEST - Test HLH'L' for zero
0408E4             1953  ;Outputs: Z-flag set & A=0 if zero
0408E4             1954  ;Destroys: A,F
0408E4             1955  ;
0408E4 7C          1956  TEST:			LD      A,H
0408E5 B5          1957  			OR      L
0408E6 D9          1958  			EXX
0408E7 B4          1959  			OR      H
0408E8 B5          1960  			OR      L
0408E9 D9          1961  			EXX
0408EA C9          1962  			RET
0408EB             1963  ;
0408EB             1964  ;DECODE - Decode line number in pseudo-binary.
0408EB             1965  ;   Inputs: IY = Text pointer.
0408EB             1966  ;   Outputs: HL=0, H'L'=line number, C=0.
0408EB             1967  ;   Destroys: A,C,H,L,H',L',IY,F
0408EB             1968  ;
0408EB D9          1969  DECODE:			EXX
0408EC 21 00 00 00 1970  			LD	HL, 0
0408F0 FD 7E 00    1971  			LD      A,(IY)
0408F3 FD 23       1972  			INC     IY
0408F5 17          1973  			RLA
0408F6 17          1974  			RLA
0408F7 67          1975  			LD      H,A
0408F8 E6 C0       1976  			AND     0C0H
0408FA FD AE 00    1977  			XOR     (IY)
0408FD FD 23       1978  			INC     IY
0408FF 6F          1979  			LD      L,A
040900 7C          1980  			LD      A,H
040901 17          1981  			RLA
040902 17          1982  			RLA
040903 E6 C0       1983  			AND     0C0H
040905 FD AE 00    1984  			XOR     (IY)
040908 FD 23       1985  			INC     IY
04090A 67          1986  			LD      H,A
04090B D9          1987  			EXX
04090C             1988  ;			XOR     A
04090C             1989  ;			LD      C,A
04090C             1990  ;			LD      H,A
04090C             1991  ;			LD      L,A
04090C 21 00 00 00 1992  			LD	HL, 0
040910 4D          1993  			LD	C, L
040911 C9          1994  			RET
040912             1995  ;
040912             1996  ;HEXSTR - convert numeric value to HEX string.
040912             1997  ;   Inputs: HLH'L'C = integer or floating-point number
040912             1998  ;  Outputs: String in string accumulator.
040912             1999  ;           E = string length.  D = ACCS/256
040912             2000  ;
040912 FD 23       2001  HEXSTS:			INC     IY              ;SKIP TILDE
040914 CD 22 03 04 2002  			CALL    ITEMN
040918 CD 1F 09 04 2003  			CALL    HEXSTR
04091C 3E 80       2004  			LD      A,80H
04091E C9          2005  			RET
04091F             2006  ;
04091F CD 67 06 04 2007  HEXSTR:			CALL    SFIX
040923 01 08 00 00 2008  			LD      BC,8
040927 11 00 4A 04 2009  			LD      DE,ACCS
04092B C5          2010  HEXST1:			PUSH    BC
04092C 06 04       2011  			LD      B,4
04092E AF          2012  			XOR     A
04092F D9          2013  HEXST2:			EXX
040930 52 29       2014  			ADD.S	HL,HL
040932 D9          2015  			EXX
040933 52 ED 6A    2016  			ADC.S	HL,HL
040936 17          2017  			RLA
040937 10 F6       2018  			DJNZ    HEXST2
040939 C1          2019  			POP     BC
04093A 0D          2020  			DEC     C
04093B F8          2021  			RET     M
04093C 28 06       2022  			JR      Z,HEXST3
04093E B7          2023  			OR      A
04093F 20 03       2024  			JR      NZ,HEXST3
040941 B8          2025  			CP      B
040942 28 E7       2026  			JR      Z,HEXST1
040944 C6 90       2027  HEXST3:			ADD     A,90H
040946 27          2028  			DAA
040947 CE 40       2029  			ADC     A,40H
040949 27          2030  			DAA
04094A 12          2031  			LD      (DE),A
04094B 13          2032  			INC     DE
04094C 47          2033  			LD      B,A
04094D 18 DC       2034  			JR      HEXST1
04094F             2035  ;
04094F             2036  ;Function STR - convert numeric value to ASCII string.
04094F             2037  ;   Inputs: HLH'L'C = integer or floating-point number.
04094F             2038  ;  Outputs: String in string accumulator.
04094F             2039  ;           E = length, D = ACCS/256
04094F             2040  ;           A = 80H (type=string)
04094F             2041  ;
04094F             2042  ;First normalise for decimal output:
04094F             2043  ;
04094F CD 78 0A 04 2044  STRS:			CALL    NXT
040953 FE 7E       2045  			CP      '~'
040955 28 BB       2046  			JR      Z,HEXSTS
040957 CD 22 03 04 2047  			CALL    ITEMN
04095B DD 21 00 4C 2048  			LD      IX,STAVAR
       04          
040960 DD 7E 03    2049  			LD      A,(IX+3)
040963 B7          2050  			OR      A
040964 DD 21 91 09 2051  			LD      IX,G9-1         ;G9 FORMAT
       04          
040969 28 05       2052  			JR      Z,STR0
04096B DD 21 00 4C 2053  STR:			LD      IX,STAVAR
       04          
040970 11 00 4A 04 2054  STR0:			LD      DE,ACCS
040974 3E 25       2055  			LD      A,37
040976 CD A2 20 04 2056  			CALL    FPP
04097A DA 98 37 04 2057  			JP      C,ERROR_
04097E DD CB 02 46 2058  			BIT     0,(IX+2)
040982 3E 80       2059  STR1:			LD      A,80H           ;STRING MARKER
040984 C8          2060  			RET     Z
040985 79          2061  			LD      A,C
040986 C6 04       2062  			ADD     A,4
040988 BB          2063  STR2:			CP      E
040989 28 F7       2064  			JR      Z,STR1
04098B EB          2065  			EX      DE,HL
04098C 36 20       2066  			LD      (HL),' '        ;TRAILING SPACE
04098E 23          2067  			INC     HL
04098F EB          2068  			EX      DE,HL
040990 18 F6       2069  			JR      STR2
040992             2070  ;
040992 09 00       2071  G9:			DW    9
040994             2072  ;
040994             2073  ;STRING COMPARE
040994             2074  ;Compare string (DE) length B with string (HL) length C.
040994             2075  ;Result preset to false.
040994             2076  ;
040994 CD A2 09 04 2077  SCP:			CALL	SCP0
040998             2078  ;
040998 3E 00       2079  ZERO:			LD      A,0
04099A D9          2080  			EXX
04099B 67          2081  			LD      H,A
04099C 6F          2082  			LD      L,A
04099D D9          2083  			EXX
04099E 67          2084  			LD      H,A
04099F 6F          2085  			LD      L,A
0409A0 4F          2086  			LD      C,A
0409A1 C9          2087  			RET
0409A2             2088  ;
0409A2 04          2089  SCP0:			INC     B
0409A3 0C          2090  			INC     C
0409A4 05          2091  SCP1:			DEC     B
0409A5 28 0A       2092  			JR      Z,SCP2
0409A7 0D          2093  			DEC     C
0409A8 28 0C       2094  			JR      Z,SCP3
0409AA 1A          2095  			LD      A,(DE)
0409AB BE          2096  			CP      (HL)
0409AC C0          2097  			RET     NZ
0409AD 13          2098  			INC     DE
0409AE 23          2099  			INC     HL
0409AF 18 F3       2100  			JR      SCP1
0409B1 B7          2101  SCP2:			OR      A
0409B2 0D          2102  			DEC     C
0409B3 C8          2103  			RET     Z
0409B4 37          2104  			SCF
0409B5 C9          2105  			RET
0409B6 B7          2106  SCP3:			OR      A
0409B7 0C          2107  			INC     C
0409B8 C9          2108  			RET
0409B9             2109  ;
0409B9             2110  ; PUSHS - SAVE STRING ON STACK.
0409B9             2111  ;     Inputs: String in string accumulator.
0409B9             2112  ;             E = string length.
0409B9             2113  ;             A - saved on stack.
0409B9             2114  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B9             2115  ;
0409B9 CD 81 16 04 2116  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409BD DD E1       2117  			POP     IX              	; IX: Return address
0409BF B7          2118  			OR      A               	; Clear the carry flag
0409C0 01 00 00 00 2119  			LD	BC,0			; BC: Length of the string
0409C4 4B          2120  			LD	C,E
0409C5 21 00 4A 04 2121  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C9 11 00 4A 04 2122  			LD	DE,ACCS
0409CD 59          2123  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409CE ED 52       2124  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409D0 39          2125  			ADD     HL,SP			; Grow the stack
0409D1 F9          2126  			LD      SP,HL
0409D2 57          2127  			LD      D,A			;  D: This needs to be set to A for some functions
0409D3 47          2128  			LD	B,A			; Stack A and C (the string length)
0409D4 C5          2129  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409D5 06 00       2130  			LD	B,0			; Reset B to 0 for the LDIR in this function
0409D7 28 0B       2131  			JR      Z,PUSHS1        	; Is it zero length?
0409D9 11 00 4A 04 2132  			LD      DE,ACCS			; DE: Destination
0409DD EB          2133  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409DE ED B0       2134  			LDIR	                    	; Copy to stack
0409E0 CD 81 16 04 2135  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409E4 DD E9       2136  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409E6             2137  ;
0409E6             2138  ; POPS - RESTORE STRING FROM STACK.
0409E6             2139  ;     Inputs: C = string length.
0409E6             2140  ;    Outputs: String in string accumulator.
0409E6             2141  ;             E = string length.
0409E6             2142  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409E6             2143  ;
0409E6 DD E1       2144  POPS:			POP     IX              	; IX: Return address
0409E8 69          2145  			LD	L,C			; Temporarily store string length in L
0409E9 01 00 00 00 2146  			LD	BC,0
0409ED 4D          2147  			LD	C,L			; BC: Number of bytes to copy
0409EE 21 00 00 00 2148  			LD      HL,0			; HL: 0
0409F2 39          2149  			ADD     HL,SP			; HL: Stack address
0409F3 11 00 4A 04 2150  			LD      DE,ACCS			; DE: Destination
0409F7 0C          2151  			INC     C			; Quick check to see if this is a zero length string
0409F8 0D          2152  			DEC     C
0409F9 28 02       2153  			JR      Z,POPS1         	; Yes it is, so skip
0409FB ED B0       2154  			LDIR                    	; No, so copy from the stack
0409FD F9          2155  POPS1:			LD      SP,HL			; Shrink the stack
0409FE DD E9       2156  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
040A00             2157  ;
040A00 FD 7E 00    2158  HEXDIG:			LD      A,(IY)
040A03 FE 30       2159  			CP      '0'
040A05 D8          2160  			RET     C
040A06 FE 3A       2161  			CP      '9'+1
040A08 3F          2162  			CCF
040A09 D0          2163  			RET     NC
040A0A FE 41       2164  			CP      'A'
040A0C D8          2165  			RET     C
040A0D D6 37       2166  			SUB     'A'-10
040A0F FE 10       2167  			CP      16
040A11 3F          2168  			CCF
040A12 C9          2169  			RET
040A13             2170  ;
040A13 FD 7E 00    2171  BINDIG:			LD	A,(IY)
040A16 FE 30       2172  			CP	'0'
040A18 D8          2173  			RET	C
040A19 FE 32       2174  			CP	'1'+1
040A1B 3F          2175  			CCF
040A1C C9          2176  			RET
040A1D             2177  ;
040A1D FE 3E       2178  RELOP?:			CP      '>'
040A1F D0          2179  			RET     NC
040A20 FE 3D       2180  			CP      '='
040A22 D0          2181  			RET     NC
040A23 FE 3C       2182  			CP      '<'
040A25 C9          2183  			RET
040A26             2184  ;
040A26 CD 1A 03 04 2185  EXPRSC:			CALL    EXPRS
040A2A CD 78 0A 04 2186  COMMA:			CALL    NXT
040A2E FD 23       2187  			INC     IY
040A30 FE 2C       2188  			CP      ','
040A32 C8          2189  			RET     Z
040A33 3E 05       2190  			LD      A,5
040A35 18 0B       2191  			JR      ERROR1_EV          ;"Missing ,"
040A37             2192  ;
040A37 CD 78 0A 04 2193  BRAKET:			CALL    NXT
040A3B FD 23       2194  			INC     IY
040A3D FE 29       2195  			CP      ')'
040A3F C8          2196  			RET     Z
040A40 3E 1B       2197  			LD      A,27
040A42 C3 98 37 04 2198  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A46             2199  ;
040A46 FD 23       2200  SAVE_EV:			INC     IY
040A48 08          2201  SAVE1:			EX      AF,AF'
040A49 FA 3B 03 04 2202  			JP      M,TYPE_EV_
040A4D 08          2203  			EX      AF,AF'
040A4E E3          2204  			EX      (SP),HL
040A4F D9          2205  			EXX
040A50 E5          2206  			PUSH    HL
040A51 D9          2207  			EXX
040A52 F5          2208  			PUSH    AF
040A53 C5          2209  			PUSH    BC
040A54 E9          2210  			JP      (HL)
040A55             2211  ;
040A55 08          2212  DOIT:			EX      AF,AF'
040A56 FA 3B 03 04 2213  			JP      M,TYPE_EV_
040A5A D9          2214  			EXX
040A5B C1          2215  			POP     BC              ;RETURN ADDRESS
040A5C D9          2216  			EXX
040A5D 79          2217  			LD      A,C
040A5E C1          2218  			POP     BC
040A5F 47          2219  			LD      B,A
040A60 F1          2220  			POP     AF              ;OPERATOR
040A61 D9          2221  			EXX
040A62 EB          2222  			EX      DE,HL
040A63 E1          2223  			POP     HL
040A64 D9          2224  			EXX
040A65 EB          2225  			EX      DE,HL
040A66 E1          2226  			POP     HL
040A67 D9          2227  			EXX
040A68 C5          2228  			PUSH    BC
040A69 D9          2229  			EXX
040A6A E6 0F       2230  			AND     0FH
040A6C CD A2 20 04 2231  			CALL    FPP
040A70 38 D0       2232  			JR      C,ERROR1_EV
040A72 AF          2233  			XOR     A
040A73 08          2234  			EX      AF,AF'          ;TYPE
040A74 FD 7E 00    2235  			LD      A,(IY)
040A77 C9          2236  			RET
040A78             2237  ;
040A78             2238  ; Skip spaces
040A78             2239  ; - IY: String pointer
040A78             2240  ; Returns:
040A78             2241  ;  - A: The non-space character found
040A78             2242  ; - IY: Points to the character before that
040A78             2243  ;
040A78 FD 7E 00    2244  NXT:			LD      A,(IY)			; Fetch the character
040A7B FE 20       2245  			CP      ' '			; If it is space, then return
040A7D C0          2246  			RET     NZ
040A7E FD 23       2247  			INC     IY			; Increment the pointer and
040A80 C3 78 0A 04 2248  			JP      NXT			; Loop
040A84             2249  ;
040A84 E5          2250  DISPT2:			PUSH    HL
040A85 21 B5 01 04 2251  			LD      HL,SOPTBL
040A89 18 07       2252  			JR      DISPT0
040A8B             2253  ;
040A8B E5          2254  DISPAT:			PUSH    HL
040A8C D6 8D       2255  			SUB     FUNTOK
040A8E 21 0A 01 04 2256  			LD      HL,FUNTBL
040A92 C5          2257  DISPT0:			PUSH    BC
040A93             2258  
040A93 01 03 00 00 2259  			LD	BC, 3
040A97 47          2260  			LD	B, A
040A98 ED 4C       2261  			MLT	BC
040A9A 09          2262  			ADD	HL, BC
040A9B ED 27       2263  			LD	HL, (HL)
040A9D             2264  
040A9D             2265  ;			ADD     A,A
040A9D             2266  ;			LD      C,A
040A9D             2267  ;			LD      B,0
040A9D             2268  ;			ADD     HL,BC
040A9D             2269  ;			LD      A,(HL)
040A9D             2270  ;			INC     HL
040A9D             2271  ;			LD      H,(HL)
040A9D             2272  ;			LD      L,A
040A9D             2273  
040A9D C1          2274  			POP     BC
040A9E E3          2275  			EX      (SP),HL
040A9F C9          2276  			RET                     ;OFF TO ROUTINE
040AA0             2277  
040AA0             2278  ; --- End eval.asm ---
040AA0             2279  
040AA0             2280  ; --- Begin exec.asm ---
040AA0             2281  ;
040AA0             2282  ; Title:	BBC Basic Interpreter - Z80 version
040AA0             2283  ;		Statement Execution & Assembler Module - "EXEC"
040AA0             2284  ; Author:	(C) Copyright  R.T.Russell  1984
040AA0             2285  ; Modified By:	Dean Belfield
040AA0             2286  ; Created:	12/05/2023
040AA0             2287  ; Last Updated:	26/06/2023
040AA0             2288  ;
040AA0             2289  ; Modinfo:
040AA0             2290  ; 27/01/1984:	Version 2.1
040AA0             2291  ; 02/03/1987:	Version 3.0
040AA0             2292  ; 11/06/1987:	Version 3.1
040AA0             2293  ; 12/05/2023:	Modified by Dean Belfield
040AA0             2294  ; 07/06/2023:	Modified to run in ADL mode
040AA0             2295  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040AA0             2296  
040AA0             2297  			; .ASSUME	ADL = 1
040AA0             2298  
040AA0             2299  			; INCLUDE	"equs.inc"
040AA0             2300  
040AA0             2301  			; SEGMENT CODE
040AA0             2302  
040AA0             2303  			; XDEF	XEQ
040AA0             2304  			; XDEF	CHAIN0
040AA0             2305  			; XDEF	RUN
040AA0             2306  			; XDEF	SYNTAX
040AA0             2307  			; XDEF	ESCAPE
040AA0             2308  			; XDEF	FN_EX
040AA0             2309  			; XDEF	USR
040AA0             2310  			; XDEF	STORE5
040AA0             2311  			; XDEF	STORE4
040AA0             2312  			; XDEF	CHECK
040AA0             2313  			; XDEF	TERMQ
040AA0             2314  			; XDEF	FILL
040AA0             2315  			; XDEF	X4OR5
040AA0             2316  			; XDEF	MUL16
040AA0             2317  			; XDEF	CHANEL
040AA0             2318  			; XDEF	ASSEM
040AA0             2319  
040AA0             2320  			; XREF	AUTO
040AA0             2321  			; XREF	DELETE
040AA0             2322  			; XREF	LOAD
040AA0             2323  			; XREF	LIST_
040AA0             2324  			; XREF	NEW
040AA0             2325  			; XREF	OLD
040AA0             2326  			; XREF	RENUM
040AA0             2327  			; XREF	SAVE
040AA0             2328  			; XREF	SOUND
040AA0             2329  			; XREF	CLG
040AA0             2330  			; XREF	DRAW
040AA0             2331  			; XREF	ENVEL
040AA0             2332  			; XREF	GCOL
040AA0             2333  			; XREF	MODE
040AA0             2334  			; XREF	MOVE
040AA0             2335  			; XREF	PLOT
040AA0             2336  			; XREF	COLOUR
040AA0             2337  			; XREF	EXPRS
040AA0             2338  			; XREF	HIMEM
040AA0             2339  			; XREF	LOAD0
040AA0             2340  			; XREF	RANDOM
040AA0             2341  			; XREF	CLEAR
040AA0             2342  			; XREF	ERRTRP
040AA0             2343  			; XREF	PAGE_
040AA0             2344  			; XREF	DATAPTR
040AA0             2345  			; XREF	ERRLIN
040AA0             2346  			; XREF	TRAP
040AA0             2347  			; XREF	NXT
040AA0             2348  			; XREF	SETLIN
040AA0             2349  			; XREF	CLOOP
040AA0             2350  			; XREF	OSSHUT
040AA0             2351  			; XREF	WARM
040AA0             2352  			; XREF	TRACEN
040AA0             2353  			; XREF	OUTCHR
040AA0             2354  			; XREF	PBCDL
040AA0             2355  			; XREF	OSCLI
040AA0             2356  			; XREF	LISTON
040AA0             2357  			; XREF	GETVAR
040AA0             2358  			; XREF	PUTVAR
040AA0             2359  			; XREF	DATPTR
040AA0             2360  			; XREF	ERROR_
040AA0             2361  			; XREF	EXPR
040AA0             2362  			; XREF	CREATE
040AA0             2363  			; XREF	EXPRI
040AA0             2364  			; XREF	BRAKET
040AA0             2365  			; XREF	FREE
040AA0             2366  			; XREF	OSBPUT
040AA0             2367  			; XREF	COUNT
040AA0             2368  			; XREF	STR
040AA0             2369  			; XREF	HEXSTR
040AA0             2370  			; XREF	CRLF
040AA0             2371  			; XREF	ITEMI
040AA0             2372  			; XREF	FINDL
040AA0             2373  			; XREF	TEST
040AA0             2374  			; XREF	EXPRN
040AA0             2375  			; XREF	DLOAD5
040AA0             2376  			; XREF	DLOAD5_SPL
040AA0             2377  			; XREF	LOADN
040AA0             2378  			; XREF	FPP
040AA0             2379  			; XREF	SWAP
040AA0             2380  			; XREF	GETDEF
040AA0             2381  			; XREF	ZERO
040AA0             2382  			; XREF	OSBGET
040AA0             2383  			; XREF	BUFFER
040AA0             2384  			; XREF	CONS
040AA0             2385  			; XREF	VAL0
040AA0             2386  			; XREF	OSLINE
040AA0             2387  			; XREF	CLRSCN
040AA0             2388  			; XREF	TELL
040AA0             2389  			; XREF	SAYLN
040AA0             2390  			; XREF	REPORT
040AA0             2391  			; XREF	PUTPTR
040AA0             2392  			; XREF	PUTIME
040AA0             2393  			; XREF	PUTIMS
040AA0             2394  			; XREF	LOMEM
040AA0             2395  			; XREF	WIDTH
040AA0             2396  			; XREF	OSWRCH
040AA0             2397  			; XREF	COMMA
040AA0             2398  			; XREF	OSCALL
040AA0             2399  			; XREF	SFIX
040AA0             2400  			; XREF	LOAD4
040AA0             2401  			; XREF	PUSHS
040AA0             2402  			; XREF	POPS
040AA0             2403  			; XREF	LOADS
040AA0             2404  			; XREF	PUTCSR
040AA0             2405  			; XREF	OUT_
040AA0             2406  			; XREF	R0
040AA0             2407  ;
040AA0             2408  ; List of token values used in this module
040AA0             2409  ;
040AA0             2410  TAND:			EQU     80H
040AA0             2411  TOR:			EQU     84H
040AA0             2412  TERROR_EX:			EQU     85H
040AA0             2413  LINE_EX_:			EQU     86H
040AA0             2414  OFF_:			EQU     87H
040AA0             2415  STEP:			EQU     88H
040AA0             2416  SPC:			EQU     89H
040AA0             2417  TAB:			EQU     8AH
040AA0             2418  ELSE_EX_:			EQU     8BH
040AA0             2419  THEN_EX_:			EQU     8CH
040AA0             2420  LINO_EX:			EQU     8DH
040AA0             2421  TO_EX:			EQU     B8H
040AA0             2422  TCMD_EX:			EQU     C6H
040AA0             2423  TCALL:			EQU     D6H
040AA0             2424  DATA_EX_:			EQU     DCH
040AA0             2425  DEF_:			EQU     DDH
040AA0             2426  TGOSUB:			EQU     E4H
040AA0             2427  TGOTO:			EQU     E5H
040AA0             2428  TON:			EQU     EEH
040AA0             2429  TPROC:			EQU     F2H
040AA0             2430  TSTOP:			EQU     FAH
040AA0             2431  
040AA0             2432  ; The command table
040AA0             2433  ; Commands are tokens from C6H onwards; this lookup table is used to
040AA0             2434  ; run the corresponding function; Note that DATA and DEF both use the same
040AA0             2435  ; code as REM
040AA0             2436  ;
040AA0 21 37 04    2437  CMDTAB:			DW24  AUTO			; C6H
040AA3 84 35 04    2438  			DW24  DELETE			; C7H
040AA6 62 37 04    2439  			DW24  LOAD			; C8H
040AA9 BF 35 04    2440  			DW24  LIST_			; C9H
040AAC 3F 37 04    2441  			DW24  NEW			; CAH
040AAF 45 37 04    2442  			DW24  OLD			; CBH
040AB2 4E 36 04    2443  			DW24  RENUM			; CCH
040AB5 73 37 04    2444  			DW24  SAVE			; CDH
040AB8 DA 15 04    2445  			DW24  PUT			; CEH
040ABB D0 13 04    2446  			DW24  PTR_EX			; CFH
040ABE EA 13 04    2447  			DW24  PAGEV_EX			; D0H
040AC1 FD 13 04    2448  			DW24  TIMEV_EX			; D1H
040AC4 26 14 04    2449  			DW24  LOMEMV_EX			; D2H
040AC7 3F 14 04    2450  			DW24  HIMEMV_EX			; D3H
040ACA 64 46 04    2451  			DW24  SOUND			; D4H
040ACD F4 14 04    2452  			DW24  BPUT			; D5H
040AD0 0C 15 04    2453  			DW24  CALL_			; D6H
040AD3 54 0B 04    2454  			DW24  CHAIN			; D7H
040AD6 9F 13 04    2455  			DW24  CLR			; D8H
040AD9 E8 14 04    2456  			DW24  CLOSE			; D9H
040ADC 00 44 04    2457  			DW24  CLG			; DAH
040ADF 72 13 04    2458  			DW24  CLS			; DBH
040AE2 33 0C 04    2459  			DW24  REM_EX             		; DCH: DATA
040AE5 33 0C 04    2460  			DW24  REM_EX             		; DDH: DEF
040AE8 F9 0C 04    2461  			DW24  DIM_EX			; DEH
040AEB 2A 46 04    2462  			DW24  DRAW			; DFH
040AEE CE 0B 04    2463  			DW24  END_			; E0H
040AF1 8A 11 04    2464  			DW24  ENDPRO			; E1H
040AF4 84 49 04    2465  			DW24  ENVEL			; E2H
040AF7 9F 0F 04    2466  			DW24  FOR_EX			; E3H
040AFA 4F 0F 04    2467  			DW24  GOSUB_EX			; E4H
040AFD 33 0F 04    2468  			DW24  GOTO_EX			; E5H
040B00 BE 45 04    2469  			DW24  GCOL			; E6H
040B03 3E 13 04    2470  			DW24  IF_			; E7H
040B06 2C 12 04    2471  			DW24  INPUT			; E8H
040B09 54 0C 04    2472  			DW24  LET			; E9H
040B0C 2F 11 04    2473  			DW24  LOCAL_EX_			; EAH
040B0F 10 44 04    2474  			DW24  MODE			; EBH
040B12 22 46 04    2475  			DW24  MOVE			; ECH
040B15 ED 0F 04    2476  			DW24  NEXT_EX			; EDH
040B18 C6 0E 04    2477  			DW24  ON_EX_			; EEH
040B1B A9 14 04    2478  			DW24  VDU			; EFH
040B1E F0 45 04    2479  			DW24  PLOT			; F0H
040B21 CF 0D 04    2480  			DW24  PRINT_			; F1H
040B24 8C 10 04    2481  			DW24  PROC_EX			; F2H
040B27 DE 12 04    2482  			DW24  READ			; F3H
040B2A 33 0C 04    2483  			DW24  REM_EX			; F4H
040B2D 6F 0F 04    2484  			DW24  REPEAT_EX			; F5H
040B30 97 13 04    2485  			DW24  REPOR			; F6H
040B33 A9 13 04    2486  			DW24  RESTOR_EX			; F7H
040B36 5D 0F 04    2487  			DW24  RETURN			; F8H
040B39 4E 0B 04    2488  			DW24  RUN			; F9H
040B3C 7F 13 04    2489  			DW24  STOP			; FAH
040B3F 0C 45 04    2490  			DW24  COLOUR			; FBH
040B42 8B 14 04    2491  			DW24  TRACE_EX			; FCH
040B45 79 0F 04    2492  			DW24  UNTIL_EX			; FDH
040B48 7D 14 04    2493  			DW24  WIDTHV			; FEH
040B4B 19 0C 04    2494  			DW24  CLI             		; FFH: OSCLI
040B4E             2495  
040B4E             2496  ; RUN
040B4E             2497  ; RUN "filename"
040B4E             2498  ;
040B4E CD AC 17 04 2499  RUN:			CALL    TERMQ			; Standalone RUN command?
040B52 28 10       2500  			JR      Z,RUN0			; Yes, so just RUN the code
040B54             2501  
040B54             2502  ; CHAIN "filename"
040B54             2503  ;
040B54 CD 1A 03 04 2504  CHAIN:			CALL    EXPRS			; Get the filename
040B58 3E 0D       2505  			LD      A,CR			; Terminate it with a CR
040B5A 12          2506  			LD      (DE),A
040B5B ED 7B 20 4D 2507  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B60 CD 57 38 04 2508  			CALL    LOAD0			; And load the file in
040B64             2509  ;
040B64 ED 7B 20 4D 2510  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B69 DD 21 38 4D 2511  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B6E ED 5F       2512  @@:			LD      A, R			; Use the R register to seed the random number generator
040B70 28 FC       2513  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B72 07          2514  			RLCA				; Rotate it
040B73 07          2515  			RLCA
040B74 DD 77 03    2516  			LD      (IX+3),A		; And store
040B77 9F          2517  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B78 DD 77 04    2518  			LD      (IX+4),A		; And store
040B7B CD AE 38 04 2519  			CALL    CLEAR
040B7F 21 00 00 00 2520  			LD      HL,0			; Clear the error trap sysvar
040B83 22 2C 4D 04 2521  			LD      (ERRTRP),HL
040B87 2A 14 4D 04 2522  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B8B 3E DC       2523  			LD      A,DATA_EX_			; The DATA token value
040B8D CD 80 18 04 2524  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B91 22 31 4D 04 2525  			LD      (DATPTR),HL     	; Set data pointer
040B95 FD 2A 14 4D 2526  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B9A             2527  ;
040B9A CD E2 0B 04 2528  XEQ0:			CALL    NEWLIN
040B9E FD 22 35 4D 2529  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040BA3 CD A5 3F 04 2530  			CALL    TRAP           		; Check keyboard
040BA7 CD 78 0A 04 2531  XEQ1:			CALL    NXT
040BAB FD 23       2532  			INC     IY
040BAD FE 3A       2533  			CP      ':'             	; Seperator
040BAF 28 F6       2534  			JR      Z,XEQ1
040BB1 FE 0D       2535  			CP      CR
040BB3 28 E5       2536  			JR      Z,XEQ0          	; New program line
040BB5 D6 C6       2537  			SUB     TCMD_EX
040BB7 DA 42 0C 04 2538  			JP      C,LET0          	; Implied "LET"
040BBB             2539  
040BBB 01 03 00 00 2540  			LD	BC, 3
040BBF 47          2541  			LD	B, A
040BC0 ED 4C       2542  			MLT	BC
040BC2 21 A0 0A 04 2543  			LD	HL,CMDTAB
040BC6 09          2544  			ADD	HL, BC
040BC7 ED 27       2545  			LD	HL, (HL)		; Table entry
040BC9             2546  
040BC9             2547  ;			ADD     A,A
040BC9             2548  ;			LD      C,A
040BC9             2549  ;			LD      B,0
040BC9             2550  ;			LD      HL,CMDTAB
040BC9             2551  ;			ADD     HL,BC
040BC9             2552  ;			LD      A,(HL)          	; Table entry
040BC9             2553  ;			INC     HL
040BC9             2554  ;			LD      H,(HL)
040BC9             2555  ;			LD      L,A
040BC9             2556  
040BC9 CD 78 0A 04 2557  			CALL    NXT
040BCD E9          2558  			JP      (HL)            	; Execute the statement
040BCE             2559  
040BCE             2560  ;END
040BCE             2561  ;
040BCE CD E6 39 04 2562  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BD2 7C          2563  			LD      A,H
040BD3 B5          2564  			OR      L               ;DIRECT?
040BD4 CA B8 30 04 2565  			JP      Z,CLOOP
040BD8 1E 00       2566  			LD      E,0
040BDA CD 74 43 04 2567  			CALL    OSSHUT          ;CLOSE ALL FILES
040BDE C3 B7 30 04 2568  			JP      WARM            ;"Ready"
040BE2             2569  ;
040BE2 FD 7E 00    2570  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BE5 01 03 00 00 2571  			LD      BC,3
040BE9 FD 09       2572  			ADD     IY,BC
040BEB B7          2573  			OR      A
040BEC 28 E0       2574  			JR      Z,END_           ;LENGTH=0, EXIT
040BEE 2A 26 4D 04 2575  			LD      HL,(TRACEN)
040BF2 7C          2576  			LD      A,H
040BF3 B5          2577  			OR      L
040BF4 C8          2578  			RET     Z
040BF5 11 00 00 00 2579  			LD	DE, 0		;Clear DE
040BF9 FD 56 FF    2580  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BFC FD 5E FE    2581  			LD      E,(IY-2)
040BFF ED 52       2582  			SBC     HL,DE
040C01 D8          2583  			RET     C
040C02 EB          2584  			EX      DE,HL
040C03 3E 5B       2585  			LD      A,'['           ;TRACE
040C05 CD 87 39 04 2586  			CALL    OUTCHR
040C09 CD 2F 3A 04 2587  			CALL    PBCDL
040C0D 3E 5D       2588  			LD      A,']'
040C0F CD 87 39 04 2589  			CALL    OUTCHR
040C13 3E 20       2590  			LD      A,' '
040C15 C3 87 39 04 2591  			JP      OUTCHR
040C19             2592  
040C19             2593  ; Routines for each statement -------------------------------------------------
040C19             2594  
040C19             2595  ; OSCLI
040C19             2596  ;
040C19 CD 1A 03 04 2597  CLI:			CALL    EXPRS
040C1D 3E 0D       2598  			LD      A,CR
040C1F 12          2599  			LD      (DE),A
040C20 21 00 4A 04 2600  			LD      HL,ACCS
040C24 CD C8 3F 04 2601  			CALL    OSCLI
040C28 C3 9E 0B 04 2602  			JP      XEQ
040C2C             2603  
040C2C             2604  ; REM, *
040C2C             2605  ;
040C2C FD E5       2606  EXT_EX:			PUSH    IY
040C2E E1          2607  			POP     HL
040C2F CD C8 3F 04 2608  			CALL    OSCLI
040C33 FD E5       2609  REM_EX:			PUSH    IY
040C35 E1          2610  			POP     HL
040C36 3E 0D       2611  			LD      A,CR
040C38 47          2612  			LD      B,A
040C39 ED B1       2613  			CPIR                    ;FIND LINE END
040C3B E5          2614  			PUSH    HL
040C3C FD E1       2615  			POP     IY
040C3E C3 9A 0B 04 2616  			JP      XEQ0
040C42             2617  
040C42             2618  ; [LET] var = expr
040C42             2619  ;
040C42 FE C5       2620  LET0:			CP      ELSE_EX_-TCMD_EX
040C44 28 ED       2621  			JR      Z,REM_EX
040C46             2622  			; CP      ('*'-TCMD) & 0FFH
040C46             2623  			; JR      Z,EXT_EX
040C46             2624  			; CP      ('='-TCMD) & 0FFH
040C46             2625  			; JR      Z,FNEND
040C46             2626  			; CP      ('['-TCMD) & 0FFH
040C46             2627  			; ez80asm doesn't like () in expressions
040C46 FE 64       2628  			CP      '*'-TCMD_EX & 0FFH
040C48 28 E2       2629  			JR      Z,EXT_EX
040C4A FE 77       2630  			CP      '='-TCMD_EX & 0FFH
040C4C 28 5B       2631  			JR      Z,FNEND
040C4E FE 95       2632  			CP      '['-TCMD_EX & 0FFH
040C50 28 25       2633  			JR      Z,ASM
040C52 FD 2B       2634  			DEC     IY
040C54 CD F0 15 04 2635  LET:			CALL    ASSIGN			; Assign the variable
040C58 CA 9E 0B 04 2636  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C5C 38 41       2637  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C5E             2638  ;
040C5E F5          2639  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C5F CD C2 17 04 2640  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C63 E5          2641  			PUSH    HL			; HL: Address of the variable
040C64 CD 1A 03 04 2642  			CALL    EXPRS
040C68 DD E1       2643  			POP     IX			; IX: Address of the variable
040C6A F1          2644  			POP     AF			; AF: The variable type
040C6B CD 32 16 04 2645  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C6F C3 9E 0B 04 2646  XEQR:			JP      XEQ
040C73             2647  ;
040C73 CD E2 0B 04 2648  ASM0:			CALL    NEWLIN
040C77 FD 22 35 4D 2649  ASM:			LD      (ERRLIN),IY
       04          
040C7C CD A5 3F 04 2650  			CALL    TRAP
040C80 CD CD 18 04 2651  			CALL    ASSEM
040C84 38 19       2652  			JR      C,SYNTAX
040C86 FE 0D       2653  			CP      CR
040C88 28 E9       2654  			JR      Z,ASM0
040C8A 21 40 4D 04 2655  			LD      HL,LISTON
040C8E 7E          2656  			LD      A,(HL)
040C8F E6 0F       2657  			AND     0FH
040C91 F6 B0       2658  			OR      B0H
040C93 77          2659  			LD      (HL),A
040C94 18 D9       2660  			JR      XEQR
040C96             2661  ;
040C96 CD 72 3A 04 2662  VAR_:			CALL    GETVAR
040C9A C8          2663  			RET     Z
040C9B D2 61 3A 04 2664  			JP      NC,PUTVAR
040C9F 3E 10       2665  SYNTAX:			LD      A,16            ;"Syntax error"
040CA1 18 02       2666  			JR	ERROR0_EX
040CA3 3E 11       2667  ESCAPE:			LD      A,17            ;"Escape"
040CA5 C3 98 37 04 2668  ERROR0_EX:			JP      ERROR_
040CA9             2669  
040CA9             2670  ; =
040CA9             2671  ;
040CA9 CD C7 01 04 2672  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CAD 43          2673  			LD      B,E
040CAE EB          2674  			EX      DE,HL
040CAF D9          2675  			EXX                     ;SAVE RESULT
040CB0 EB          2676  			EX      DE,HL           ; IN DEB'C'D'E'
040CB1 C1          2677  FNEND5:			POP     BC
040CB2 21 8A 17 04 2678  			LD      HL,LOCCHK
040CB6 B7          2679  			OR      A
040CB7 ED 42       2680  			SBC     HL,BC
040CB9 28 1C       2681  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CBB 21 8C 10 04 2682  			LD      HL,FNCHK
040CBF B7          2683  			OR      A
040CC0 ED 42       2684  			SBC     HL,BC
040CC2 3E 07       2685  			LD      A,7
040CC4 20 DF       2686  			JR      NZ,ERROR0_EX       ;"No FN"
040CC6 FD E1       2687  			POP     IY
040CC8 FD 22 35 4D 2688  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CCD EB          2689  			EX      DE,HL
040CCE D9          2690  			EXX
040CCF EB          2691  			EX      DE,HL
040CD0 11 00 4A 04 2692  			LD      DE,ACCS
040CD4 58          2693  			LD      E,B
040CD5 08          2694  			EX      AF,AF'
040CD6 C9          2695  			RET
040CD7             2696  ;
040CD7 DD E1       2697  FNEND0:			POP     IX
040CD9 C1          2698  			POP     BC
040CDA 78          2699  			LD      A,B
040CDB B7          2700  			OR      A
040CDC FA EA 0C 04 2701  			JP      M,FNEND1        ;STRING
040CE0 E1          2702  			POP     HL
040CE1 D9          2703  			EXX
040CE2 E1          2704  			POP     HL
040CE3 D9          2705  			EXX
040CE4 CD 08 16 04 2706  			CALL    STORE
040CE8 18 C7       2707  			JR      FNEND5
040CEA 21 00 00 00 2708  FNEND1:			LD      HL,0
040CEE 39          2709  			ADD     HL,SP
040CEF D5          2710  			PUSH    DE
040CF0 59          2711  			LD      E,C
040CF1 CD 36 16 04 2712  			CALL    STORES
040CF5 D1          2713  			POP     DE
040CF6 F9          2714  			LD      SP,HL
040CF7 18 B8       2715  			JR      FNEND5
040CF9             2716  
040CF9             2717  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF9             2718  ; DIM var expr[,var expr...]
040CF9             2719  ;
040CF9 CD 72 3A 04 2720  DIM_EX:			CALL    GETVAR          	; Get the variable
040CFD DA 89 0D 04 2721  			JP      C,BADDIM		; Throw a "Bad Dim" error
040D01 CA 93 0D 04 2722  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040D05 CD E6 3B 04 2723  			CALL    CREATE			; Create a new entity
040D09 E5          2724  			PUSH    HL			; HL: Address of the entity
040D0A DD E1       2725  			POP     IX			; IX: Address of the entity
040D0C FD 7E 00    2726  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D0F FE 28       2727  			CP      '('			; Check for opening brackets
040D11 7A          2728  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D12 20 7F       2729  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D14             2730  ;
040D14             2731  ; At this point we're reserving a variable array
040D14             2732  ;
040D14 E5          2733  			PUSH    HL			; HL: Address of the entity
040D15 F5          2734  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D16 11 01 00 00 2735  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D1A 42          2736  			LD      B,D			;  B: The number of dimensions in the array
040D1B             2737  ;
040D1B FD 23       2738  DIM1:			INC     IY			; Skip to the next token
040D1D C5          2739  			PUSH    BC			; Stack the dimension counter
040D1E D5          2740  			PUSH    DE			; Stack the total size of array accumulator
040D1F DD E5       2741  			PUSH    IX			; Stack the entity address
040D21 CD 0F 03 04 2742  			CALL    EXPRI           	; Fetch the size of this dimension
040D25 CB 7C       2743  			BIT     7,H			; If it is negative then
040D27 20 60       2744  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D29 D9          2745  			EXX
040D2A 23          2746  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D2B DD E1       2747  			POP     IX			; IX: The entity address
040D2D DD 23       2748  			INC     IX
040D2F DD 75 00    2749  			LD      (IX),L          	; Save the size of this dimension in the entity
040D32 DD 23       2750  			INC     IX
040D34 DD 74 00    2751  			LD      (IX),H
040D37 C1          2752  			POP     BC
040D38 CD A4 18 04 2753  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D3C 38 4F       2754  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D3E EB          2755  			EX      DE,HL           	; DE: The new total size of array accumulator
040D3F C1          2756  			POP     BC
040D40 04          2757  			INC     B               	;  B: The dimension counter; increment
040D41 FD 7E 00    2758  			LD      A,(IY)			; Fetch the nex token
040D44 FE 2C       2759  			CP      ','             	; Check for another dimension in the array
040D46 28 D3       2760  			JR      Z,DIM1			; And loop
040D48             2761  ;
040D48 CD 37 0A 04 2762  			CALL    BRAKET          	; Check for closing bracket
040D4C F1          2763  			POP     AF              	; Restore the type
040D4D DD 23       2764  			INC     IX
040D4F DD E3       2765  			EX      (SP),IX
040D51 DD 70 00    2766  			LD      (IX),B          	; Number of dimensions
040D54 CD 97 18 04 2767  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D58 E1          2768  			POP     HL			; Restore the entity address
040D59 38 32       2769  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D5B             2770  ;
040D5B             2771  ; We now allocate the memory for the array
040D5B             2772  ;
040D5B 19          2773  DIM3:			ADD     HL,DE
040D5C 38 2F       2774  			JR      C,NOROOM
040D5E E5          2775  			PUSH    HL
040D5F 24          2776  			INC     H
040D60 28 2B       2777  			JR      Z,NOROOM
040D62 ED 72       2778  			SBC     HL,SP
040D64 30 27       2779  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D66 E1          2780  			POP     HL
040D67 22 1D 4D 04 2781  			LD      (FREE),HL
040D6B 7A          2782  DIM2:			LD      A,D
040D6C B3          2783  			OR      E
040D6D 28 06       2784  			JR      Z,DIM5
040D6F 2B          2785  			DEC     HL
040D70 36 00       2786  			LD      (HL),0         		; Initialise the array
040D72 1B          2787  			DEC     DE
040D73 18 F6       2788  			JR      DIM2
040D75 CD 78 0A 04 2789  DIM5:			CALL    NXT
040D79 FE 2C       2790  			CP      ','            		; Another variable?
040D7B C2 9E 0B 04 2791  			JP      NZ,XEQ
040D7F FD 23       2792  			INC     IY
040D81 CD 78 0A 04 2793  			CALL    NXT
040D85 C3 F9 0C 04 2794  			JP      DIM_EX
040D89             2795  ;
040D89             2796  ; DIM errors
040D89             2797  ;
040D89 3E 0A       2798  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D8B 18 02       2799  			JR	ERROR1_EX
040D8D 3E 0B       2800  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D8F C3 98 37 04 2801  ERROR1_EX:			JP      ERROR_
040D93             2802  ;
040D93             2803  ; At this point we're reserving a block of memory, i.e.
040D93             2804  ; DIM var expr[,var expr...]
040D93             2805  ;
040D93 B7          2806  DIM4:			OR      A			;  A: The dimension variable type
040D94 28 F3       2807  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D96 FA 89 0D 04 2808  			JP      M,BADDIM        	; or a string
040D9A 47          2809  			LD      B,A			; Temporarily store the dimension variable type in B
040D9B FD 7E FF    2810  			LD      A,(IY-1)		; Get the last character but one
040D9E FE 29       2811  			CP      ')'			; Check if it is a trailing bracket
040DA0 28 E7       2812  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040DA2             2813  ;
040DA2 21 00 00 00 2814  			LD	HL,0			; Clear HL
040DA6 3A 1D 4D 04 2815  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DAA 6F          2816  			LD	L,A
040DAB 3A 1E 4D 04 2817  			LD	A,(FREE+1)
040DAF 67          2818  			LD	H,A
040DB0 78          2819  			LD	A,B			; Restore the dimension variable type
040DB1 D9          2820  			EXX
040DB2 21 00 00 00 2821  			LD	HL,0			; Clear HL
040DB6 47          2822  			LD	B,A			; Temporarily store the dimension variable type in B
040DB7 3A 1F 4D 04 2823  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DBB 6F          2824  			LD	L,A
040DBC 78          2825  			LD	A,B			; Restore the dimension variable type
040DBD 4C          2826  			LD	C,H
040DBE CD 08 16 04 2827  			CALL    STORE           	; Store the address
040DC2 CD 0F 03 04 2828  			CALL    EXPRI			; Get the number of bytes to store
040DC6 D9          2829  			EXX
040DC7 23          2830  			INC     HL			; Add one to it
040DC8 EB          2831  			EX      DE,HL
040DC9 2A 1D 4D 04 2832  			LD      HL,(FREE)
040DCD 18 8C       2833  			JR      DIM3			; Continue with the DIM
040DCF             2834  
040DCF             2835  ; PRINT list...
040DCF             2836  ; PRINT #channel,list...
040DCF             2837  ;
040DCF FE 23       2838  PRINT_:			CP      '#'
040DD1 20 7C       2839  			JR      NZ,PRINT0
040DD3 CD C4 18 04 2840  			CALL    CHNL            ;CHANNEL NO. = E
040DD7 CD 78 0A 04 2841  PRNTN1:			CALL    NXT
040DDB FE 2C       2842  			CP      ','
040DDD C2 9E 0B 04 2843  			JP      NZ,XEQ
040DE1 FD 23       2844  			INC     IY
040DE3 D5          2845  			PUSH    DE
040DE4 CD C7 01 04 2846  			CALL    EXPR            ;ITEM TO PRINT
040DE8 08          2847  			EX      AF,AF'
040DE9 FA 0F 0E 04 2848  			JP      M,PRNTN2        ;STRING
040DED D1          2849  			POP     DE
040DEE C5          2850  			PUSH    BC
040DEF D9          2851  			EXX
040DF0 7D          2852  			LD      A,L
040DF1 D9          2853  			EXX
040DF2 CD 84 43 04 2854  			CALL    OSBPUT
040DF6 D9          2855  			EXX
040DF7 7C          2856  			LD      A,H
040DF8 D9          2857  			EXX
040DF9 CD 84 43 04 2858  			CALL    OSBPUT
040DFD 7D          2859  			LD      A,L
040DFE CD 84 43 04 2860  			CALL    OSBPUT
040E02 7C          2861  			LD      A,H
040E03 CD 84 43 04 2862  			CALL    OSBPUT
040E07 C1          2863  			POP     BC
040E08 79          2864  			LD      A,C
040E09 CD 84 43 04 2865  			CALL    OSBPUT
040E0D 18 C8       2866  			JR      PRNTN1
040E0F 4B          2867  PRNTN2:			LD      C,E
040E10 D1          2868  			POP     DE
040E11 21 00 4A 04 2869  			LD      HL,ACCS
040E15 0C          2870  			INC     C
040E16 0D          2871  PRNTN3:			DEC     C
040E17 28 0A       2872  			JR      Z,PRNTN4
040E19 7E          2873  			LD      A,(HL)
040E1A 23          2874  			INC     HL
040E1B C5          2875  			PUSH    BC
040E1C CD 84 43 04 2876  			CALL    OSBPUT
040E20 C1          2877  			POP     BC
040E21 18 F3       2878  			JR      PRNTN3
040E23 3E 0D       2879  PRNTN4:			LD      A,CR
040E25 CD 84 43 04 2880  			CALL    OSBPUT
040E29 18 AC       2881  			JR      PRNTN1
040E2B             2882  ;
040E2B 06 02       2883  PRINT6:			LD      B,2
040E2D 18 27       2884  			JR      PRINTC
040E2F 01 00 01 00 2885  PRINT8:			LD      BC,100H
040E33 18 21       2886  			JR      PRINTC
040E35 21 00 4C 04 2887  PRINT9:			LD      HL,STAVAR
040E39 AF          2888  			XOR     A
040E3A BE          2889  			CP      (HL)
040E3B 28 12       2890  			JR      Z,PRINT0
040E3D 3A 3D 4D 04 2891  			LD      A,(COUNT)
040E41 B7          2892  			OR      A
040E42 28 0B       2893  			JR      Z,PRINT0
040E44 96          2894  PRINTA:			SUB     (HL)
040E45 28 08       2895  			JR      Z,PRINT0
040E47 30 FB       2896  			JR      NC,PRINTA
040E49 ED 44       2897  			NEG
040E4B CD 21 18 04 2898  			CALL    FILL
040E4F 3A 00 4C 04 2899  PRINT0:			LD      A,(STAVAR)
040E53 4F          2900  			LD      C,A             ;PRINTS
040E54 06 00       2901  			LD      B,0             ;PRINTF
040E56 CD AC 17 04 2902  PRINTC:			CALL    TERMQ
040E5A 28 3F       2903  			JR      Z,PRINT4
040E5C CB 80       2904  			RES     0,B
040E5E FD 23       2905  			INC     IY
040E60 FE 7E       2906  			CP      '~'
040E62 28 C7       2907  			JR      Z,PRINT6
040E64 FE 3B       2908  			CP      ';'
040E66 28 C7       2909  			JR      Z,PRINT8
040E68 FE 2C       2910  			CP      ','
040E6A 28 C9       2911  			JR      Z,PRINT9
040E6C CD D1 17 04 2912  			CALL    FORMAT          ;SPC, TAB, '
040E70 28 E4       2913  			JR      Z,PRINTC
040E72 FD 2B       2914  			DEC     IY
040E74 C5          2915  			PUSH    BC
040E75 CD C7 01 04 2916  			CALL    EXPR            ;VARIABLE TYPE
040E79 08          2917  			EX      AF,AF'
040E7A FA 94 0E 04 2918  			JP      M,PRINT3        ;STRING
040E7E D1          2919  			POP     DE
040E7F D5          2920  			PUSH    DE
040E80 CB 4A       2921  			BIT     1,D
040E82 F5          2922  			PUSH    AF
040E83 CC 6B 09 04 2923  			CALL    Z,STR           ;DECIMAL
040E87 F1          2924  			POP     AF
040E88 C4 1F 09 04 2925  			CALL    NZ,HEXSTR       ;HEX
040E8C C1          2926  			POP     BC
040E8D C5          2927  			PUSH    BC
040E8E 79          2928  			LD      A,C
040E8F 93          2929  			SUB     E
040E90 D4 21 18 04 2930  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E94 C1          2931  PRINT3:			POP     BC
040E95 CD 30 18 04 2932  			CALL    PTEXT           ;PRINT
040E99 18 BB       2933  			JR      PRINTC
040E9B CB 40       2934  PRINT4:			BIT     0,B
040E9D CC 7F 39 04 2935  			CALL    Z,CRLF
040EA1 C3 9E 0B 04 2936  			JP      XEQ
040EA5             2937  
040EA5             2938  ; ON ERROR statement [:statement...]
040EA5             2939  ; ON ERROR OFF
040EA5             2940  ;
040EA5 FD 23       2941  ONERR:			INC     IY              ;SKIP "ERROR"
040EA7 21 00 00 00 2942  			LD      HL,0
040EAB 22 2C 4D 04 2943  			LD      (ERRTRP),HL
040EAF CD 78 0A 04 2944  			CALL    NXT
040EB3 FE 87       2945  			CP      OFF_
040EB5 FD 23       2946  			INC     IY
040EB7 CA 9E 0B 04 2947  			JP      Z,XEQ
040EBB FD 2B       2948  			DEC     IY
040EBD FD 22 2C 4D 2949  			LD      (ERRTRP),IY
       04          
040EC2 C3 33 0C 04 2950  			JP      REM_EX
040EC6             2951  
040EC6             2952  ; ON expr GOTO line[,line...] [ELSE statement]
040EC6             2953  ; ON expr GOTO line[,line...] [ELSE line]
040EC6             2954  ; ON expr GOSUB line[,line...] [ELSE statement]
040EC6             2955  ; ON expr GOSUB line[,line...] [ELSE line]
040EC6             2956  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EC6             2957  ;
040EC6 FE 85       2958  ON_EX_:			CP      TERROR_EX
040EC8 28 DB       2959  			JR      Z,ONERR         ;"ON ERROR"
040ECA CD 0F 03 04 2960  			CALL    EXPRI
040ECE FD 7E 00    2961  			LD      A,(IY)
040ED1 FD 23       2962  			INC     IY
040ED3 1E 2C       2963  			LD      E,','           ;SEPARATOR
040ED5 FE E5       2964  			CP      TGOTO
040ED7 28 0B       2965  			JR      Z,ON1
040ED9 FE E4       2966  			CP      TGOSUB
040EDB 28 07       2967  			JR      Z,ON1
040EDD 1E F2       2968  			LD      E,TPROC
040EDF BB          2969  			CP      E
040EE0 3E 27       2970  			LD      A,39
040EE2 20 45       2971  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EE4 57          2972  ON1:			LD      D,A
040EE5 D9          2973  			EXX
040EE6 E5          2974  			PUSH    HL
040EE7 D9          2975  			EXX
040EE8 C1          2976  			POP     BC              ;ON INDEX
040EE9 78          2977  			LD      A,B
040EEA B4          2978  			OR      H
040EEB B5          2979  			OR      L
040EEC 20 2A       2980  			JR      NZ,ON4          ;OUT OF RANGE
040EEE B1          2981  			OR      C
040EEF 28 27       2982  			JR      Z,ON4
040EF1 0D          2983  			DEC     C
040EF2 28 0E       2984  			JR      Z,ON3           ;INDEX=1
040EF4 CD AC 17 04 2985  ON2:			CALL    TERMQ
040EF8 28 1E       2986  			JR      Z,ON4           ;OUT OF RANGE
040EFA FD 23       2987  			INC     IY              ;SKIP DELIMITER
040EFC BB          2988  			CP      E
040EFD 20 F5       2989  			JR      NZ,ON2
040EFF 0D          2990  			DEC     C
040F00 20 F2       2991  			JR      NZ,ON2
040F02 7B          2992  ON3:			LD      A,E
040F03 FE F2       2993  			CP      TPROC
040F05 28 26       2994  			JR      Z,ONPROC
040F07 D5          2995  			PUSH    DE
040F08 CD 2A 03 04 2996  			CALL    ITEMI           ;LINE NUMBER
040F0C D1          2997  			POP     DE
040F0D 7A          2998  			LD      A,D
040F0E FE E5       2999  			CP      TGOTO
040F10 28 2D       3000  			JR      Z,GOTO2
040F12 CD B9 17 04 3001  			CALL    SPAN            ;SKIP REST OF LIST
040F16 18 3B       3002  			JR      GOSUB1
040F18             3003  ;
040F18 FD 7E 00    3004  ON4:			LD      A,(IY)
040F1B FD 23       3005  			INC     IY
040F1D FE 8B       3006  			CP      ELSE_EX_
040F1F CA 53 13 04 3007  			JP      Z,IF1           ;ELSE CLAUSE
040F23 FE 0D       3008  			CP      CR
040F25 20 F1       3009  			JR      NZ,ON4
040F27 3E 28       3010  			LD      A,40
040F29 C3 98 37 04 3011  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F2D             3012  ;
040F2D 3E EE       3013  ONPROC:			LD      A,TON
040F2F C3 8C 10 04 3014  			JP      PROC_EX
040F33             3015  
040F33             3016  ; GOTO line
040F33             3017  ;
040F33 CD 2A 03 04 3018  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F37 CD AC 17 04 3019  GOTO1:			CALL    TERMQ			; Check for terminator
040F3B C2 9F 0C 04 3020  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F3F D9          3021  GOTO2:			EXX
040F40 CD C7 39 04 3022  			CALL    FINDL			; HL: Line number - Find the line
040F44 E5          3023  			PUSH    HL			; HL: Address of the line
040F45 FD E1       3024  			POP     IY			; IY = HL
040F47 CA 9A 0B 04 3025  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F4B 3E 29       3026  			LD      A,41			; Otherwise throw a "No such line" error
040F4D 18 DA       3027  			JR      ERROR2_EX
040F4F             3028  
040F4F             3029  ; GOSUB line
040F4F             3030  ; This pushes the following data onto the execution stack
040F4F             3031  ; - 3 bytes: Current execution address
040F4F             3032  ; - 3 bytes: Marker (the address of label GOSCHK)
040F4F             3033  ;
040F4F CD 2A 03 04 3034  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F53 FD E5       3035  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F55 CD 81 16 04 3036  			CALL    CHECK           	; Check there is enough room
040F59 CD 37 0F 04 3037  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F5D             3038  GOSCHK:			EQU     $
040F5D             3039  
040F5D             3040  ; RETURN
040F5D             3041  ; This pops the following data off the execution stack as pushed by GOSUB
040F5D             3042  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F5D             3043  ; - 3 bytes: The return execution address
040F5D             3044  ;
040F5D D1          3045  RETURN:			POP     DE			; Pop the marker off the execution stack
040F5E 21 5D 0F 04 3046  			LD      HL,GOSCHK		; Compare with GOSCHK
040F62 B7          3047  			OR      A
040F63 ED 52       3048  			SBC     HL,DE
040F65 FD E1       3049  			POP     IY			; Pop the return address off the execution stack
040F67 CA 9E 0B 04 3050  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F6B 3E 26       3051  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F6D 18 BA       3052  			JR      ERROR2_EX
040F6F             3053  
040F6F             3054  ; REPEAT
040F6F             3055  ; This pushes the following data onto the execution stack
040F6F             3056  ; - 3 bytes: Current execution address
040F6F             3057  ; - 3 bytes: Marker (the address of label REPCHK)
040F6F             3058  ;
040F6F FD E5       3059  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F71 CD 81 16 04 3060  			CALL    CHECK			; Check if there is enough room
040F75 CD 9E 0B 04 3061  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F79             3062  REPCHK:			EQU     $
040F79             3063  
040F79             3064  ; UNTIL expr
040F79             3065  ; This pops the following data off the execution stack
040F79             3066  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F79             3067  ; - 3 bytes: The address of the REPEAT instruction
040F79             3068  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F79             3069  ;
040F79 C1          3070  UNTIL_EX:			POP     BC			; Fetch the marker
040F7A C5          3071  			PUSH    BC			; And push it back onto the execution stack
040F7B 21 79 0F 04 3072  			LD      HL,REPCHK		; Compare with REPCHK
040F7F B7          3073  			OR      A
040F80 ED 42       3074  			SBC     HL,BC
040F82 3E 2B       3075  			LD      A,43
040F84 20 A3       3076  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F86 CD 0F 03 04 3077  			CALL    EXPRI			; Fetch the expression
040F8A CD E4 08 04 3078  			CALL    TEST			; Test if the expression evaluates to zero
040F8E C1          3079  			POP     BC			; Pop the marker
040F8F D1          3080  			POP     DE			; Pop the address of the REPEAT instruction
040F90 20 05       3081  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F92 D5          3082  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F93 C5          3083  			PUSH    BC			; Push the marker back on the stack
040F94 D5          3084  			PUSH    DE			; IY = DE
040F95 FD E1       3085  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F97 C3 9E 0B 04 3086  XEQ2:			JP      XEQ			; Continue execution
040F9B             3087  
040F9B             3088  ; FOR var = expr TO expr [STEP expr]
040F9B             3089  ; This pushes the following data onto the execution stack
040F9B             3090  ; - 3 bytes: The limit value
040F9B             3091  ; - 3 bytes: The step value
040F9B             3092  ; - 3 bytes: The current execution address
040F9B             3093  ; - 3 bytes: The address of the loop variable
040F9B             3094  ; - 3 bytes: Marker (the address of FORCHK)
040F9B             3095  ;
040F9B 3E 22       3096  FORVAR:			LD      A,34
040F9D 18 8A       3097  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F9F             3098  ;
040F9F CD F0 15 04 3099  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040FA3 20 F6       3100  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040FA5 F5          3101  			PUSH    AF              	; Save the variable type
040FA6 FD 7E 00    3102  			LD      A,(IY)			; Check the next token
040FA9 FE B8       3103  			CP      TO_EX			; Compare with the token value for "TO"
040FAB 3E 24       3104  			LD      A,36			; Set the error code to 36 ("No TO")
040FAD C2 29 0F 04 3105  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FB1 FD 23       3106  			INC     IY			; Skip to the next token
040FB3             3107  ;
040FB3 DD E5       3108  			PUSH    IX
040FB5 CD 07 03 04 3109  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB9 DD E1       3110  			POP     IX
040FBB F1          3111  			POP     AF
040FBC 47          3112  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FBD C5          3113  			PUSH    BC              	; Stack the LIMIT value
040FBE E5          3114  			PUSH    HL
040FBF 21 00 00 00 3115  			LD      HL,0
040FC3 4C          3116  			LD      C,H
040FC4 D9          3117  			EXX
040FC5 E5          3118  			PUSH    HL
040FC6             3119  ;
040FC6 21 01 00 00 3120  			LD      HL,1            	; The preset STEP value is 1
040FCA D9          3121  			EXX
040FCB FD 7E 00    3122  			LD      A,(IY)			; Fetch the next token
040FCE FE 88       3123  			CP      STEP			; Compare with the token value for "STEP"
040FD0 20 0A       3124  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FD2             3125  ;
040FD2 FD 23       3126  			INC     IY			; Skip past the STEP token
040FD4 DD E5       3127  			PUSH    IX
040FD6 CD 07 03 04 3128  			CALL    EXPRN          		; Fetch the STEP expression value
040FDA DD E1       3129  			POP     IX
040FDC             3130  ;
040FDC C5          3131  FOR1:			PUSH    BC			; Stack the STEP value
040FDD E5          3132  			PUSH    HL
040FDE D9          3133  			EXX
040FDF E5          3134  			PUSH    HL
040FE0 D9          3135  			EXX
040FE1             3136  ;
040FE1 FD E5       3137  			PUSH    IY              	; Stack the current execution address
040FE3 DD E5       3138  			PUSH    IX              	; Stack the loop variable
040FE5 CD 81 16 04 3139  			CALL    CHECK
040FE9 CD 9E 0B 04 3140  			CALL    XEQ
040FED             3141  FORCHK:			EQU     $
040FED             3142  
040FED             3143  ; NEXT [var[,var...]]
040FED             3144  ; This pops the following data off the execution stack
040FED             3145  ; - 3 bytes: Marker (the address of FORCHK)
040FED             3146  ; - 3 bytes: The address of the loop variable
040FED             3147  ; - 3 bytes: The current execution address
040FED             3148  ; - 3 bytes: The step value
040FED             3149  ; - 3 bytes: The limit value
040FED             3150  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FED             3151  ;
040FED C1          3152  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FEE 21 ED 0F 04 3153  			LD      HL,FORCHK		; Compare with FORCHK
040FF2 B7          3154  			OR      A
040FF3 ED 42       3155  			SBC     HL,BC
040FF5 3E 20       3156  			LD      A,32
040FF7 C2 83 10 04 3157  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FFB CD AC 17 04 3158  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FFF E1          3159  			POP     HL			; Pop the address of the loop variable off the execution stack
041000 E5          3160  			PUSH    HL			; Push it back onto the execution stack
041001 C5          3161  			PUSH    BC			; Push the marker back onto the execution stack
041002 E5          3162  			PUSH    HL			; HL: Address of the loop variable off the stack
041003 C4 72 3A 04 3163  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041007 D1          3164  			POP     DE			; DE: Address of the loop variable off the stack
041008 EB          3165  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041009 B7          3166  			OR      A
04100A ED 52       3167  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
04100C 20 61       3168  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
04100E D5          3169  			PUSH    DE
04100F DD 21 0C 00 3170  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
041014 DD 39       3171  			ADD     IX,SP
041016 CD 19 2A 04 3172  			CALL    DLOAD5_SPL      	; Load the STEP value
04101A DD 7E 10    3173  			LD      A,(IX+16)       	; Get the STEP type
04101D DD E1       3174  			POP     IX
04101F CD 1B 04 04 3175  			CALL    LOADN           	; Load the LOOP variable
041023 CB 7A       3176  			BIT     7,D             	; Check the sign
041025 F5          3177  			PUSH    AF
041026 3E 0B       3178  			LD      A,'+' & 0FH
041028 CD A2 20 04 3179  			CALL    FPP             	; Add the STEP
04102C 38 55       3180  			JR      C,ERROR3_EX
04102E F1          3181  			POP     AF              	; Restore TYPE
04102F F5          3182  			PUSH    AF
041030 CD 08 16 04 3183  			CALL    STORE           	; Update the variable
041034 DD 21 15 00 3184  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041039 DD 39       3185  			ADD     IX,SP
04103B CD 19 2A 04 3186  			CALL    DLOAD5_SPL      	; Load the LIMIT value
04103F F1          3187  			POP     AF
041040 CC DC 08 04 3188  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
041044             3189  			; LD      A,0+('<'-4) & 0FH
041044 3E 08       3190  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041046 CD A2 20 04 3191  			CALL    FPP             	; Test against the limit
04104A 38 37       3192  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
04104C 24          3193  			INC     H
04104D 20 14       3194  			JR      NZ,LOOP_        	; Keep looping
04104F 21 1B 00 00 3195  			LD      HL,27			; Adjust the stack
041053 39          3196  			ADD     HL,SP
041054 F9          3197  			LD      SP,HL
041055 CD 78 0A 04 3198  			CALL    NXT
041059 FE 2C       3199  			CP      ','			; Check for multiple variables
04105B C2 9E 0B 04 3200  			JP      NZ,XEQ			; No, so we are done at ths point
04105F FD 23       3201  			INC     IY			; Increment to the next variable
041061 18 8A       3202  			JR      NEXT_EX			; And continue
041063             3203  ;
041063 C1          3204  LOOP_:			POP     BC
041064 D1          3205  			POP     DE
041065 FD E1       3206  			POP     IY
041067 FD E5       3207  			PUSH    IY
041069 D5          3208  			PUSH    DE
04106A C5          3209  			PUSH    BC
04106B C3 9E 0B 04 3210  			JP      XEQ
04106F             3211  ;
04106F 21 1B 00 00 3212  NEXT1:			LD      HL,27			; TODO: What does this do?
041073 39          3213  			ADD     HL,SP
041074 F9          3214  			LD      SP,HL			; Adjust the stack
041075 C1          3215  			POP     BC
041076 21 ED 0F 04 3216  			LD      HL,FORCHK
04107A ED 42       3217  			SBC     HL,BC
04107C E1          3218  			POP     HL              	; Variable pointer
04107D E5          3219  			PUSH    HL
04107E C5          3220  			PUSH    BC
04107F 28 89       3221  			JR      Z,NEXT0
041081             3222  ;
041081 3E 21       3223  			LD      A,33
041083 C3 98 37 04 3224  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041087             3225  
041087             3226  ; FNname
041087             3227  ; N.B. ENTERED WITH A <> TON
041087             3228  ;
041087 F5          3229  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041088 CD 91 10 04 3230  			CALL    PROC1
04108C             3231  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
04108C             3232  
04108C             3233  ; PROCname
04108C             3234  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
04108C             3235  ; This pushes the following data onto the execution stack
04108C             3236  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
04108C             3237  ; - 3 bytes: Marker (the address of PROCHK)
04108C             3238  ;
04108C F5          3239  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
04108D CD 91 10 04 3240  			CALL    PROC1			; and is also space reserved on the stack for the return address
041091             3241  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041091             3242  ;
041091 CD 81 16 04 3243  PROC1:			CALL    CHECK			; Check there is space for this
041095 FD 2B       3244  			DEC     IY			; Decrement IY to the PROC token
041097 FD E5       3245  			PUSH    IY			; Stack the pointer
041099 CD 33 3B 04 3246  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
04109D C1          3247  			POP     BC			; BC = IY
04109E 28 41       3248  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0410A0 3E 1E       3249  			LD      A,30
0410A2 38 DF       3250  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0410A4             3251  ;
0410A4             3252  ; At this point the PROC/FN has not yet been registered in the dynamic area
0410A4             3253  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0410A4             3254  ;
0410A4 C5          3255  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0410A5 2A 14 4D 04 3256  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A9             3257  ;
0410A9 3E DD       3258  PROC2:			LD      A,DEF_			;  A: The token to search for
0410AB CD 80 18 04 3259  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410AF 38 26       3260  			JR      C,PROC3			; Not found, so jump to PROC3
0410B1 E5          3261  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410B2 FD E1       3262  			POP     IY			; IY = HL
0410B4 FD 23       3263  			INC     IY              	; Skip the DEF token
0410B6 CD 78 0A 04 3264  			CALL    NXT			; And any whitespace
0410BA CD 33 3B 04 3265  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410BE FD E5       3266  			PUSH    IY
0410C0 D1          3267  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410C1 38 09       3268  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410C3 C4 E6 3B 04 3269  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410C7 FD E5       3270  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C9 D1          3271  			POP     DE			; DE = IY
0410CA ED 1F       3272  			LD	(HL),DE			; Save address
0410CC             3273  ;
0410CC EB          3274  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410CD 3E 0D       3275  			LD      A,CR			; The character to search for
0410CF 01 00 01 00 3276  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410D3 ED B1       3277  			CPIR                    	; Skip to next line
0410D5 18 D2       3278  			JR      PROC2			; Rinse, lather and repeat
0410D7             3279  ;
0410D7             3280  ; At this point a DEF has not been found for the PROC/FN
0410D7             3281  ;
0410D7 FD E1       3282  PROC3:			POP     IY              	; Restore the execution address
0410D9 CD 33 3B 04 3283  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410DD 3E 1D       3284  			LD      A,29
0410DF 20 A2       3285  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410E1             3286  ;
0410E1             3287  ; At this point we have a PROC/FN entry in the dynamic area
0410E1             3288  ;
0410E1 ED 17       3289  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410E3 21 03 00 00 3290  			LD	HL,3
0410E7 39          3291  			ADD     HL,SP
0410E8 CD 78 0A 04 3292  			CALL    NXT             	; Allow space before "("
0410EC D5          3293  			PUSH    DE              	; Exchange DE and IY
0410ED FD E3       3294  			EX      (SP),IY
0410EF FE 28       3295  			CP      '('             	; Arguments?
0410F1 D1          3296  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410F2 20 20       3297  			JR      NZ,PROC5
0410F4 CD 78 0A 04 3298  			CALL    NXT             	; Allow space before "("
0410F8 FE 28       3299  			CP      '('
0410FA C2 9F 0C 04 3300  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410FE FD E5       3301  			PUSH    IY
041100 C1          3302  			POP     BC              	; Save IY in BC
041101 D9          3303  			EXX
041102 CD 2C 17 04 3304  			CALL    SAVLOC          	; Save local parameters
041106 CD 37 0A 04 3305  			CALL    BRAKET          	; Closing bracket
04110A D9          3306  			EXX
04110B C5          3307  			PUSH    BC
04110C FD E1       3308  			POP     IY              	; Restore IY
04110E E5          3309  			PUSH    HL
04110F CD A8 16 04 3310  			CALL    ARGUE           	; Transfer arguments
041113 E1          3311  			POP     HL
041114             3312  ;
041114 23          3313  PROC5:			INC	HL			; Increment to the ON PROC flag address
041115 7E          3314  			LD	A, (HL)			; And fetch the value
041116 2B          3315  			DEC 	HL
041117 ED 1F       3316  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041119 FE EE       3317  			CP	TON			; Was it "ON PROC"?
04111B C2 9E 0B 04 3318  			JP	NZ, XEQ			; No, so back to XEQ
04111F D5          3319  			PUSH    DE			; Exchange DE and IY
041120 FD E3       3320  			EX      (SP),IY
041122 CD B9 17 04 3321  			CALL    SPAN            	; Skip rest of ON list
041126 FD E3       3322  			EX      (SP),IY			; Exchange DE and IY
041128 D1          3323  			POP     DE
041129 ED 1F       3324  			LD	(HL), DE		; Save the return address
04112B C3 9E 0B 04 3325  			JP      XEQ
04112F             3326  
04112F             3327  ; LOCAL var[,var...]
04112F             3328  ;
04112F C1          3329  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041130 C5          3330  			PUSH    BC
041131 21 8C 10 04 3331  			LD      HL,FNCHK		; Check if we are in a FN
041135 B7          3332  			OR      A
041136 ED 42       3333  			SBC     HL,BC
041138 28 16       3334  			JR      Z,LOCAL1		; Yes, so all good, we can use local
04113A 21 91 10 04 3335  			LD      HL,PROCHK		; Now check if we are in a PROC
04113E B7          3336  			OR      A
04113F ED 42       3337  			SBC     HL,BC
041141 28 0D       3338  			JR      Z,LOCAL1		; Again, all good, we can use local
041143 21 8A 17 04 3339  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041147 B7          3340  			OR      A
041148 ED 42       3341  			SBC     HL,BC			; If it is not present, then
04114A 3E 0C       3342  			LD      A,12
04114C C2 98 37 04 3343  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041150             3344  ;
041150             3345  ; At this point we are adding a local variable into a PROC or FN
041150             3346  ;
041150 FD E5       3347  LOCAL1:			PUSH    IY			; IY: BASIC pointer
041152 C1          3348  			POP     BC			; BC: Copy of the BASIC pointer
041153 D9          3349  			EXX
041154 FD 2B       3350  			DEC     IY
041156 CD 2C 17 04 3351  			CALL    SAVLOC
04115A D9          3352  			EXX
04115B C5          3353  			PUSH    BC
04115C FD E1       3354  			POP     IY
04115E             3355  ;
04115E CD 72 3A 04 3356  LOCAL2:			CALL    GETVAR			; Get the variable location
041162 C2 9F 0C 04 3357  			JP      NZ,SYNTAX
041166 B7          3358  			OR      A               	; Check the variable type (80h = string)
041167 08          3359  			EX      AF,AF'
041168 CD 98 09 04 3360  			CALL    ZERO			; Zero the variable anyway
04116C 08          3361  			EX      AF,AF'
04116D F5          3362  			PUSH    AF
04116E F4 08 16 04 3363  			CALL    P,STORE         	; Call STORE if it is not a string
041172 F1          3364  			POP     AF
041173 59          3365  			LD      E,C
041174 FC 36 16 04 3366  			CALL    M,STORES		; Call STORES if it is a string
041178 CD 78 0A 04 3367  			CALL    NXT			; Skip to the next character in the expression
04117C FE 2C       3368  			CP      ','			; Is it a comma?
04117E C2 9E 0B 04 3369  			JP      NZ,XEQ			; No, so we're done, carry on executing
041182 FD 23       3370  			INC     IY			; Yes, so skip the comma
041184 CD 78 0A 04 3371  			CALL    NXT			; And any whitespace
041188 18 D4       3372  			JR      LOCAL2			; Then loop back and handle any further local variables
04118A             3373  
04118A             3374  ; ENDPROC
04118A             3375  ;
04118A C1          3376  ENDPRO:			POP     BC			; Pop the check value off the stack
04118B 21 8A 17 04 3377  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
04118F B7          3378  			OR      A
041190 ED 42       3379  			SBC     HL,BC
041192 28 13       3380  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041194             3381  ;
041194 21 91 10 04 3382  			LD      HL,PROCHK       	; Check if it is the PROC marker
041198 B7          3383  			OR      A
041199 ED 42       3384  			SBC     HL,BC
04119B FD E1       3385  			POP     IY
04119D CA 9E 0B 04 3386  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0411A1 3E 0D       3387  			LD      A,13			; Otherwise throw the "No PROC" error
0411A3 C3 98 37 04 3388  			JP      ERROR_
0411A7             3389  ;
0411A7 DD E1       3390  UNSTK:			POP     IX			; Unstack a single local variable
0411A9 C1          3391  			POP     BC
0411AA 78          3392  			LD      A,B
0411AB B7          3393  			OR      A
0411AC FA BA 11 04 3394  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411B0 E1          3395  			POP     HL			; Unstack a normal variable
0411B1 D9          3396  			EXX
0411B2 E1          3397  			POP     HL
0411B3 D9          3398  			EXX
0411B4 CD 08 16 04 3399  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B8 18 D0       3400  			JR      ENDPRO			; And loop back to ENDPRO
0411BA             3401  ;
0411BA 21 00 00 00 3402  UNSTK1:			LD      HL,0			; Unstack a string
0411BE 39          3403  			ADD     HL,SP
0411BF 59          3404  			LD      E,C
0411C0 CD 36 16 04 3405  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411C4 F9          3406  			LD      SP,HL
0411C5 18 C3       3407  			JR      ENDPRO
0411C7             3408  
0411C7             3409  ; INPUT #channel,var,var...
0411C7             3410  ;
0411C7 CD C4 18 04 3411  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411CB CD 78 0A 04 3412  INPN1:			CALL    NXT
0411CF FE 2C       3413  			CP      ','
0411D1 C2 9E 0B 04 3414  			JP      NZ,XEQ
0411D5 FD 23       3415  			INC     IY
0411D7 CD 78 0A 04 3416  			CALL    NXT
0411DB D5          3417  			PUSH    DE
0411DC CD 96 0C 04 3418  			CALL    VAR_
0411E0 D1          3419  			POP     DE
0411E1 F5          3420  			PUSH    AF              ;SAVE TYPE
0411E2 E5          3421  			PUSH    HL              ;VARPTR
0411E3 B7          3422  			OR      A
0411E4 FA 10 12 04 3423  			JP      M,INPN2         ;STRING
0411E8 CD 7C 43 04 3424  			CALL    OSBGET
0411EC D9          3425  			EXX
0411ED 6F          3426  			LD      L,A
0411EE D9          3427  			EXX
0411EF CD 7C 43 04 3428  			CALL    OSBGET
0411F3 D9          3429  			EXX
0411F4 67          3430  			LD      H,A
0411F5 D9          3431  			EXX
0411F6 CD 7C 43 04 3432  			CALL    OSBGET
0411FA 6F          3433  			LD      L,A
0411FB CD 7C 43 04 3434  			CALL    OSBGET
0411FF 67          3435  			LD      H,A
041200 CD 7C 43 04 3436  			CALL    OSBGET
041204 4F          3437  			LD      C,A
041205 DD E1       3438  			POP     IX
041207 F1          3439  			POP     AF              ;RESTORE TYPE
041208 D5          3440  			PUSH    DE              ;SAVE CHANNEL
041209 CD 08 16 04 3441  			CALL    STORE
04120D D1          3442  			POP     DE
04120E 18 BB       3443  			JR      INPN1
041210 21 00 4A 04 3444  INPN2:			LD      HL,ACCS
041214 CD 7C 43 04 3445  INPN3:			CALL    OSBGET
041218 FE 0D       3446  			CP      CR
04121A 28 04       3447  			JR      Z,INPN4
04121C 77          3448  			LD      (HL),A
04121D 2C          3449  			INC     L
04121E 20 F4       3450  			JR      NZ,INPN3
041220 DD E1       3451  INPN4:			POP     IX
041222 F1          3452  			POP     AF
041223 D5          3453  			PUSH    DE
041224 EB          3454  			EX      DE,HL
041225 CD 32 16 04 3455  			CALL    STACCS
041229 D1          3456  			POP     DE
04122A 18 9F       3457  			JR      INPN1
04122C             3458  
04122C             3459  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             3460  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             3461  ;
04122C FE 23       3462  INPUT:			CP      '#'
04122E 28 97       3463  			JR      Z,INPUTN
041230 0E 00       3464  			LD      C,0             ;FLAG PROMPT
041232 FE 86       3465  			CP      LINE_EX_
041234 20 04       3466  			JR      NZ,INPUT0
041236 FD 23       3467  			INC     IY              ;SKIP "LINE"
041238 0E 80       3468  			LD      C,80H
04123A 21 00 4B 04 3469  INPUT0:			LD      HL,BUFFER
04123E 36 0D       3470  			LD      (HL),CR         ;INITIALISE EMPTY
041240 CD AC 17 04 3471  INPUT1:			CALL    TERMQ
041244 CA 9E 0B 04 3472  			JP      Z,XEQ           ;DONE
041248 FD 23       3473  			INC     IY
04124A FE 2C       3474  			CP      ','
04124C 28 5C       3475  			JR      Z,INPUT3        ;SKIP COMMA
04124E FE 3B       3476  			CP      ';'
041250 28 58       3477  			JR      Z,INPUT3
041252 E5          3478  			PUSH    HL              ;SAVE BUFFER POINTER
041253 FE 22       3479  			CP      34		;ASCII ""
041255 20 0C       3480  			JR      NZ,INPUT6
041257 C5          3481  			PUSH    BC
041258 CD 6C 04 04 3482  			CALL    CONS
04125C C1          3483  			POP     BC
04125D CD 30 18 04 3484  			CALL    PTEXT           ;PRINT PROMPT
041261 18 06       3485  			JR      INPUT9
041263 CD D1 17 04 3486  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041267 20 05       3487  			JR      NZ,INPUT2
041269 E1          3488  INPUT9:			POP     HL
04126A CB C1       3489  			SET     0,C             ;FLAG NO PROMPT
04126C 18 CC       3490  			JR      INPUT0
04126E FD 2B       3491  INPUT2:			DEC     IY
041270 C5          3492  			PUSH    BC
041271 CD 96 0C 04 3493  			CALL    VAR_
041275 C1          3494  			POP     BC
041276 E1          3495  			POP     HL
041277 F5          3496  			PUSH    AF              ;SAVE TYPE
041278 7E          3497  			LD      A,(HL)
041279 23          3498  			INC     HL
04127A FE 0D       3499  			CP      CR              ;BUFFER EMPTY?
04127C CC AE 12 04 3500  			CALL    Z,REFILL
041280 CB 79       3501  			BIT     7,C
041282 F5          3502  			PUSH    AF
041283 C4 52 18 04 3503  			CALL    NZ,LINES
041287 F1          3504  			POP     AF
041288 CC 3F 18 04 3505  			CALL    Z,FETCHS
04128C F1          3506  			POP     AF              ;RESTORE TYPE
04128D C5          3507  			PUSH    BC
04128E E5          3508  			PUSH    HL
04128F B7          3509  			OR      A
041290 FA A4 12 04 3510  			JP      M,INPUT4        ;STRING
041294 F5          3511  			PUSH    AF
041295 DD E5       3512  			PUSH    IX
041297 CD 73 06 04 3513  			CALL    VAL0
04129B DD E1       3514  			POP     IX
04129D F1          3515  			POP     AF
04129E CD 08 16 04 3516  			CALL    STORE
0412A2 18 04       3517  			JR      INPUT5
0412A4 CD 32 16 04 3518  INPUT4:			CALL    STACCS
0412A8 E1          3519  INPUT5:			POP     HL
0412A9 C1          3520  			POP     BC
0412AA CB 81       3521  INPUT3:			RES     0,C
0412AC 18 92       3522  			JR      INPUT1
0412AE             3523  ;
0412AE CB 41       3524  REFILL:			BIT     0,C
0412B0 20 0C       3525  			JR      NZ,REFIL0       ;NO PROMPT
0412B2 3E 3F       3526  			LD      A,'?'
0412B4 CD 87 39 04 3527  			CALL    OUTCHR          ;PROMPT
0412B8 3E 20       3528  			LD      A,' '
0412BA CD 87 39 04 3529  			CALL    OUTCHR
0412BE 21 00 4B 04 3530  REFIL0:			LD      HL,BUFFER
0412C2 C5          3531  			PUSH    BC
0412C3 E5          3532  			PUSH    HL
0412C4 DD E5       3533  			PUSH    IX
0412C6 CD 97 3E 04 3534  			CALL    OSLINE
0412CA DD E1       3535  			POP     IX
0412CC E1          3536  			POP     HL
0412CD C1          3537  			POP     BC
0412CE 47          3538  			LD      B,A             ;POS AT ENTRY
0412CF AF          3539  			XOR     A
0412D0 32 3D 4D 04 3540  			LD      (COUNT),A
0412D4 B8          3541  			CP      B
0412D5 C8          3542  			RET     Z
0412D6 7E          3543  REFIL1:			LD      A,(HL)
0412D7 FE 0D       3544  			CP      CR
0412D9 C8          3545  			RET     Z
0412DA 23          3546  			INC     HL
0412DB 10 F9       3547  			DJNZ    REFIL1
0412DD C9          3548  			RET
0412DE             3549  
0412DE             3550  ; READ var[,var...]
0412DE             3551  ;
0412DE FE 23       3552  READ:			CP      '#'
0412E0 CA C7 11 04 3553  			JP      Z,INPUTN
0412E4 2A 31 4D 04 3554  			LD      HL,(DATPTR)
0412E8 7E          3555  READ0:			LD      A,(HL)
0412E9 23          3556  			INC     HL              ;SKIP COMMA OR "DATA"
0412EA FE 0D       3557  			CP      CR              ;END OF DATA STMT?
0412EC CC 30 13 04 3558  			CALL    Z,GETDAT
0412F0 E5          3559  			PUSH    HL
0412F1 CD 96 0C 04 3560  			CALL    VAR_
0412F5 E1          3561  			POP     HL
0412F6 B7          3562  			OR      A
0412F7 FA 10 13 04 3563  			JP      M,READ1         ;STRING
0412FB E5          3564  			PUSH    HL
0412FC FD E3       3565  			EX      (SP),IY
0412FE F5          3566  			PUSH    AF              ;SAVE TYPE
0412FF DD E5       3567  			PUSH    IX
041301 CD 07 03 04 3568  			CALL    EXPRN
041305 DD E1       3569  			POP     IX
041307 F1          3570  			POP     AF
041308 CD 08 16 04 3571  			CALL    STORE
04130C FD E3       3572  			EX      (SP),IY
04130E 18 09       3573  			JR      READ2
041310 CD 3F 18 04 3574  READ1:			CALL    FETCHS
041314 E5          3575  			PUSH    HL
041315 CD 32 16 04 3576  			CALL    STACCS
041319 E1          3577  READ2:			POP     HL
04131A 22 31 4D 04 3578  			LD      (DATPTR),HL
04131E CD 78 0A 04 3579  			CALL    NXT
041322 FE 2C       3580  			CP      ','
041324 C2 9E 0B 04 3581  			JP      NZ,XEQ
041328 FD 23       3582  			INC     IY
04132A CD 78 0A 04 3583  			CALL    NXT
04132E 18 B8       3584  			JR      READ0
041330             3585  ;
041330 3E DC       3586  GETDAT:			LD      A,DATA_EX_
041332 CD 80 18 04 3587  			CALL    SEARCH_EX
041336 23          3588  			INC     HL
041337 D0          3589  			RET     NC
041338 3E 2A       3590  			LD      A,42
04133A C3 98 37 04 3591  ERROR4:			JP      ERROR_           ;"Out of DATA"
04133E             3592  
04133E             3593  ; IF expr statement
04133E             3594  ; IF expr THEN statement [ELSE statement]
04133E             3595  ; IF expr THEN line [ELSE line]
04133E             3596  ;
04133E CD 0F 03 04 3597  IF_:			CALL    EXPRI
041342 CD E4 08 04 3598  			CALL    TEST
041346 28 19       3599  			JR      Z,IFNOT         ;FALSE
041348 FD 7E 00    3600  			LD      A,(IY)
04134B FE 8C       3601  			CP      THEN_EX_
04134D C2 9E 0B 04 3602  			JP      NZ,XEQ
041351 FD 23       3603  			INC     IY              ;SKIP "THEN"
041353 CD 78 0A 04 3604  IF1:			CALL    NXT
041357 FE 8D       3605  			CP      LINO_EX
041359 C2 9E 0B 04 3606  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
04135D C3 33 0F 04 3607  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041361 FD 7E 00    3608  IFNOT:			LD      A,(IY)
041364 FE 0D       3609  			CP      CR
041366 FD 23       3610  			INC     IY
041368 CA 9A 0B 04 3611  			JP      Z,XEQ0          ;END OF LINE
04136C FE 8B       3612  			CP      ELSE_EX_
04136E 20 F1       3613  			JR      NZ,IFNOT
041370 18 E1       3614  			JR      IF1
041372             3615  
041372             3616  ; CLS
041372             3617  ;
041372 CD 0A 44 04 3618  CLS:		CALL    CLRSCN
041376 AF          3619  			XOR     A
041377 32 3D 4D 04 3620  			LD      (COUNT),A
04137B C3 9E 0B 04 3621  			JP      XEQ
04137F             3622  
04137F             3623  ; STOP
04137F             3624  ;
04137F CD C8 3D 04 3625  STOP:			CALL    TELL
041383 0D          3626  			DB	CR
041384 0A          3627  			DB	LF
041385 FA          3628  			DB	TSTOP
041386 00          3629  			DB	0
041387 CD E6 39 04 3630  			CALL    SETLIN          ;FIND CURRENT LINE
04138B CD 1A 3A 04 3631  			CALL    SAYLN
04138F CD 7F 39 04 3632  			CALL    CRLF
041393 C3 B8 30 04 3633  			JP      CLOOP
041397             3634  
041397             3635  ; REPORT
041397             3636  ;
041397 CD BA 3D 04 3637  REPOR:			CALL    REPORT
04139B C3 9E 0B 04 3638  			JP      XEQ
04139F             3639  
04139F             3640  ; CLEAR
04139F             3641  ;
04139F CD AE 38 04 3642  CLR:			CALL    CLEAR
0413A3 2A 14 4D 04 3643  			LD      HL,(PAGE_)
0413A7 18 19       3644  			JR      RESTR1
0413A9             3645  
0413A9             3646  ; RESTORE [line]
0413A9             3647  ;
0413A9 2A 14 4D 04 3648  RESTOR_EX:			LD      HL,(PAGE_)
0413AD CD AC 17 04 3649  			CALL    TERMQ
0413B1 28 0F       3650  			JR      Z,RESTR1
0413B3 CD 2A 03 04 3651  			CALL    ITEMI
0413B7 D9          3652  			EXX
0413B8 CD C7 39 04 3653  			CALL    FINDL           ;SEARCH FOR LINE
0413BC 3E 29       3654  			LD      A,41
0413BE C2 3A 13 04 3655  			JP      NZ,ERROR4       ;"No such line"
0413C2 3E DC       3656  RESTR1:			LD      A,DATA_EX_
0413C4 CD 80 18 04 3657  			CALL    SEARCH_EX
0413C8 22 31 4D 04 3658  			LD      (DATPTR),HL
0413CC C3 9E 0B 04 3659  			JP      XEQ
0413D0             3660  
0413D0             3661  ; PTR#channel=expr
0413D0             3662  ; PAGE=expr
0413D0             3663  ; TIME=expr
0413D0             3664  ; LOMEM=expr
0413D0             3665  ; HIMEM=expr
0413D0             3666  ;
0413D0 CD B8 18 04 3667  PTR_EX:			CALL    CHANEL
0413D4 CD C2 17 04 3668  			CALL    EQUALS
0413D8 7B          3669  			LD      A,E
0413D9 F5          3670  			PUSH    AF
0413DA CD 0F 03 04 3671  			CALL    EXPRI
0413DE E5          3672  			PUSH    HL
0413DF D9          3673  			EXX
0413E0 D1          3674  			POP     DE
0413E1 F1          3675  			POP     AF
0413E2 CD B0 43 04 3676  			CALL    PUTPTR
0413E6 C3 9E 0B 04 3677  			JP      XEQ
0413EA             3678  ;
0413EA CD C2 17 04 3679  PAGEV_EX:			CALL    EQUALS
0413EE CD 0F 03 04 3680  			CALL    EXPRI
0413F2 D9          3681  			EXX
0413F3 2E 00       3682  			LD      L,0
0413F5 22 14 4D 04 3683  			LD      (PAGE_),HL
0413F9 C3 9E 0B 04 3684  			JP      XEQ
0413FD             3685  ;
0413FD FE 24       3686  TIMEV_EX:			CP      '$'
0413FF 28 13       3687  			JR      Z,TIMEVS_EX
041401 CD C2 17 04 3688  			CALL    EQUALS
041405 CD 0F 03 04 3689  			CALL    EXPRI
041409 E5          3690  			PUSH    HL
04140A D9          3691  			EXX
04140B D1          3692  			POP     DE
04140C CD CF 3E 04 3693  			CALL    PUTIME
041410 C3 9E 0B 04 3694  			JP      XEQ
041414             3695  ;
041414 FD 23       3696  TIMEVS_EX:			INC     IY              ;SKIP '$'
041416 CD C2 17 04 3697  			CALL    EQUALS
04141A CD 1A 03 04 3698  			CALL    EXPRS
04141E CD 84 49 04 3699  			CALL    PUTIMS
041422 C3 9E 0B 04 3700  			JP      XEQ
041426             3701  ;
041426 CD C2 17 04 3702  LOMEMV_EX:			CALL    EQUALS
04142A CD 0F 03 04 3703  			CALL    EXPRI
04142E CD AE 38 04 3704  			CALL    CLEAR
041432 D9          3705  			EXX
041433 22 1A 4D 04 3706  			LD      (LOMEM),HL
041437 22 1D 4D 04 3707  			LD      (FREE),HL
04143B C3 9E 0B 04 3708  			JP      XEQ
04143F             3709  ;
04143F CD C2 17 04 3710  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041443 CD 0F 03 04 3711  			CALL    EXPRI			; Load the expression into registers
041447 7D          3712  			LD	A,L			;  A: The MSB of the 24-bit value
041448 D9          3713  			EXX				; HL: The LSW of the 24-bit value
041449 22 4A 4D 04 3714  			LD	(R0),HL
04144D 32 4C 4D 04 3715  			LD	(R0+2),A
041451 2A 1D 4D 04 3716  			LD	HL,(FREE)
041455 11 00 01 00 3717  			LD      DE,256
041459 19          3718  			ADD	HL,DE
04145A EB          3719  			EX	DE,HL			; DE: FREE + 256
04145B 2A 4A 4D 04 3720  			LD	HL,(R0)			; HL: The passed expression
04145F AF          3721  			XOR     A
041460 ED 52       3722  			SBC     HL,DE
041462 19          3723  			ADD     HL,DE			; Do a bounds check
041463 DA 98 37 04 3724  			JP      C,ERROR_         	; Throw the error: "No room"
041467 ED 5B 20 4D 3725  			LD      DE,(HIMEM)
       04          
04146C 22 20 4D 04 3726  			LD      (HIMEM),HL
041470 EB          3727  			EX      DE,HL
041471 ED 72       3728  			SBC     HL,SP			; Adjust the stack
041473 C2 9E 0B 04 3729  			JP      NZ,XEQ
041477 EB          3730  			EX      DE,HL
041478 F9          3731  			LD      SP,HL           	; Load the SP
041479 C3 9E 0B 04 3732  			JP      XEQ
04147D             3733  
04147D             3734  ; WIDTH expr
04147D             3735  ;
04147D CD 0F 03 04 3736  WIDTHV:			CALL    EXPRI
041481 D9          3737  			EXX
041482 7D          3738  			LD      A,L
041483 32 3E 4D 04 3739  			LD      (WIDTH),A
041487 C3 9E 0B 04 3740  			JP      XEQ
04148B             3741  
04148B             3742  ; TRACE ON
04148B             3743  ; TRACE OFF
04148B             3744  ; TRACE line
04148B             3745  ;
04148B FD 23       3746  TRACE_EX:			INC     IY
04148D 21 00 00 00 3747  			LD      HL,0
041491 FE EE       3748  			CP      TON
041493 28 0B       3749  			JR      Z,TRACE0
041495 FE 87       3750  			CP      OFF_
041497 28 08       3751  			JR      Z,TRACE1
041499 FD 2B       3752  			DEC     IY
04149B CD 0F 03 04 3753  			CALL    EXPRI
04149F D9          3754  			EXX
0414A0 2B          3755  TRACE0:			DEC     HL
0414A1 22 26 4D 04 3756  TRACE1:			LD      (TRACEN),HL
0414A5 C3 9E 0B 04 3757  			JP      XEQ
0414A9             3758  
0414A9             3759  ; VDU expr,expr;....
0414A9             3760  ;
0414A9 DD 21 00 4B 3761  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0414AE DD E5       3762  VDU1:			PUSH	IX
0414B0 CD 0F 03 04 3763  			CALL    EXPRI			; Fetch the VDU character
0414B4 DD E1       3764  			POP	IX
0414B6 D9          3765  			EXX
0414B7 DD 75 00    3766  			LD	(IX+0),L		; Write out the character to the buffer
0414BA DD 23       3767  			INC	IX
0414BC FD 7E 00    3768  			LD      A,(IY)			;  A: The separator character
0414BF FE 2C       3769  			CP      ','			; Is it a comma?
0414C1 28 09       3770  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414C3 FE 3B       3771  			CP      ';'			; Is it a semicolon?
0414C5 20 07       3772  			JR      NZ,VDU3			; No, so skip to the next expression
0414C7 DD 74 00    3773  			LD	(IX+0),H		; Write out the high byte to the buffer
0414CA DD 23       3774  			INC	IX
0414CC FD 23       3775  VDU2:			INC     IY			; Skip to the next character
0414CE CD AC 17 04 3776  VDU3:			CALL    TERMQ			; Skip past white space
0414D2 20 DA       3777  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414D4 DD 7D       3778  			LD	A,IXL			;  A: Number of bytes to write out
0414D6 B7          3779  			OR	A
0414D7 28 0B       3780  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D9 21 00 4B 04 3781  			LD	HL,BUFFER		; HL: Start of stream
0414DD 01 00 00 00 3782  			LD	BC,0
0414E1 4F          3783  			LD	C,A			; BC: Number of bytes to write out
0414E2 5B DF       3784  			RST.LIL	18h			; Output the buffer to MOS
0414E4 C3 9E 0B 04 3785  VDU4:			JP      XEQ
0414E8             3786  
0414E8             3787  ; CLOSE channel number
0414E8             3788  ;
0414E8 CD B8 18 04 3789  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414EC CD 74 43 04 3790  			CALL    OSSHUT			; Close the channel
0414F0 C3 9E 0B 04 3791  			JP      XEQ
0414F4             3792  
0414F4             3793  ; BPUT channel,byte
0414F4             3794  ;
0414F4 CD B8 18 04 3795  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414F8 D5          3796  			PUSH    DE			; DE: Channel number
0414F9 CD 2A 0A 04 3797  			CALL    COMMA			; Skip to the next expression
0414FD CD 0F 03 04 3798  			CALL    EXPRI           	; Feth the data
041501 D9          3799  			EXX
041502 7D          3800  			LD      A,L			; A: The byte to write
041503 D1          3801  			POP     DE
041504 CD 84 43 04 3802  			CALL    OSBPUT			; Write the byte out
041508 C3 9E 0B 04 3803  			JP      XEQ
04150C             3804  
04150C             3805  ; CALL address[,var[,var...]]
04150C             3806  ;
04150C             3807  ; Note that the parameter table differs from the Z80 version
04150C             3808  ; Each entry now takes up 4 bytes, not 3, so the table is now:
04150C             3809  ;  -1 byte:  Number of parameters
04150C             3810  ; Then, for each parameter:
04150C             3811  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
04150C             3812  ;  -3 bytes: Parameter address
04150C             3813  ;
04150C             3814  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
04150C             3815  ;
04150C CD 0F 03 04 3816  CALL_:			CALL    EXPRI           	; Fetch the address
041510 7D          3817  			LD	A,L			;  A: MSB of address
041511 D9          3818  			EXX
041512 22 4A 4D 04 3819  			LD	(R0+0),HL		; HL: LSW of address
041516 32 4C 4D 04 3820  			LD	(R0+2),A
04151A 06 00       3821  			LD      B,0             	;  B: The parameter counter
04151C 11 00 4B 04 3822  			LD      DE,BUFFER       	; DE: Vector
041520             3823  ;
041520 CD 78 0A 04 3824  CALL1:			CALL    NXT			; Skip whitespace
041524 FE 2C       3825  			CP      ','			; Check for comma
041526 20 1B       3826  			JR      NZ,CALL2		; If no more parameters, then jump here
041528 FD 23       3827  			INC     IY			; Skip to the next character
04152A 04          3828  			INC     B			; Increment the parameter count
04152B CD 78 0A 04 3829  			CALL    NXT			; Skip whitespace
04152F C5          3830  			PUSH    BC
041530 D5          3831  			PUSH    DE
041531 CD 96 0C 04 3832  			CALL    VAR_
041535 D1          3833  			POP     DE
041536 C1          3834  			POP     BC
041537 13          3835  			INC     DE
041538 12          3836  			LD      (DE),A			; Save the parameter type
041539 13          3837  			INC     DE
04153A EB          3838  			EX      DE,HL
04153B ED 1F       3839  			LD	(HL),DE			; Save the parameter address (3 bytes)
04153D 23          3840  			INC	HL
04153E 23          3841  			INC	HL
04153F 23          3842  			INC	HL
041540 EB          3843  			EX      DE,HL
041541 18 DD       3844  			JR      CALL1
041543             3845  ;
041543 78          3846  CALL2:			LD      A,B
041544 32 00 4B 04 3847  			LD      (BUFFER),A      	; Save the parameter count
041548 2A 4A 4D 04 3848  			LD	HL,(R0)			; HL: Address of the code
04154C CD 66 15 04 3849  			CALL    USR1			; And call it
041550 C3 9E 0B 04 3850  			JP      XEQ
041554             3851  
041554             3852  ; USR(address)
041554             3853  ;
041554 CD 2A 03 04 3854  USR:			CALL    ITEMI			; Evaluate the expression
041558 7D          3855  			LD	A,L			;  A: MSB of address
041559 D9          3856  			EXX
04155A 22 4A 4D 04 3857  			LD	(R0+0),HL		; HL: LSW of address
04155E 32 4C 4D 04 3858  			LD	(R0+2),A
041562 2A 4A 4D 04 3859  			LD	HL,(R0)			; Get the 24-bit address in HL
041566             3860  ;
041566 E5          3861  USR1:			PUSH    HL              	; Address on stack
041567 FD E3       3862  			EX      (SP),IY
041569 24          3863  			INC     H               	; Check for PAGE &00FFxx
04156A B4          3864  			OR	H
04156B 21 D5 15 04 3865  			LD      HL,USR2         	; Return address
04156F E5          3866  			PUSH    HL
041570 DD 21 00 4C 3867  			LD      IX,STAVAR
       04          
041575 CC 3A 43 04 3868  			CALL    Z,OSCALL        	; Intercept &00FFxx
041579             3869  ;
041579 DD 4E 18    3870  			LD      C, (IX+24)		; F%
04157C C5          3871  			PUSH    BC
04157D             3872  ;
04157D DD 7E 08    3873  			LD	A, (IX+8)		; B% -> MSW
041580 32 4B 4D 04 3874  			LD	(R0+1), A
041584 DD 7E 09    3875  			LD	A, (IX+9)
041587 32 4C 4D 04 3876  			LD	(R0+2), A
04158B DD 7E 0C    3877  			LD	A, (IX+12)		; C% -> LSB
04158E 32 4A 4D 04 3878  			LD	(R0+0), A
041592 ED 4B 4A 4D 3879  			LD	BC, (R0)
       04          
041597             3880  ;
041597 DD 7E 10    3881  			LD	A, (IX+16)		; D% -> MSW
04159A 32 4B 4D 04 3882  			LD	(R0+1), A
04159E DD 7E 11    3883  			LD	A, (IX+17)
0415A1 32 4C 4D 04 3884  			LD	(R0+2), A
0415A5 DD 7E 14    3885  			LD	A, (IX+20)		; E% -> LSB
0415A8 32 4A 4D 04 3886  			LD	(R0+0), A
0415AC ED 5B 4A 4D 3887  			LD	DE, (R0)
       04          
0415B1             3888  ;
0415B1 DD 7E 20    3889  			LD	A, (IX+32)		; H% -> MSW
0415B4 32 4B 4D 04 3890  			LD	(R0+1), A
0415B8 DD 7E 21    3891  			LD	A, (IX+33)
0415BB 32 4C 4D 04 3892  			LD	(R0+2), A
0415BF DD 7E 30    3893  			LD	A, (IX+48)		; L% -> LSB
0415C2 32 4A 4D 04 3894  			LD	(R0+0), A
0415C6 2A 4A 4D 04 3895  			LD	HL, (R0)
0415CA             3896  ;
0415CA F1          3897  			POP     AF			; F%
0415CB DD 7E 04    3898  			LD      A, (IX+4)        	; A%
0415CE             3899  
0415CE DD 21 00 4B 3900  			LD      IX,BUFFER
       04          
0415D3 FD E9       3901  			JP      (IY)            	; Off to user routine
0415D5             3902  ;
0415D5 FD E1       3903  USR2:			POP     IY
0415D7 AF          3904  			XOR     A
0415D8 4F          3905  			LD      C,A
0415D9 C9          3906  			RET
0415DA             3907  
0415DA             3908  ; PUT port,data
0415DA             3909  ;
0415DA CD 0F 03 04 3910  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415DE D9          3911  			EXX
0415DF E5          3912  			PUSH    HL
0415E0 CD 2A 0A 04 3913  			CALL    COMMA
0415E4 CD 0F 03 04 3914  			CALL    EXPRI           ;DATA
0415E8 D9          3915  			EXX
0415E9 C1          3916  			POP     BC
0415EA ED 69       3917  			OUT     (C),L           ;OUTPUT TO PORT BC
0415EC C3 9E 0B 04 3918  			JP      XEQ
0415F0             3919  
0415F0             3920  ; SUBROUTINES -----------------------------------------------------------------
0415F0             3921  
0415F0             3922  ; ASSIGN - Assign a numeric value to a variable.
0415F0             3923  ; Outputs: NC,  Z - OK, numeric.
0415F0             3924  ;          NC, NZ - OK, string.
0415F0             3925  ;           C, NZ - illegal
0415F0             3926  ;
0415F0 CD 72 3A 04 3927  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415F4 D8          3928  			RET     C               	; Return with C if it is an illegal variable
0415F5 C4 61 3A 04 3929  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415F9 B7          3930  			OR      A
0415FA F8          3931  			RET     M               	; Return if type is string (81h)
0415FB F5          3932  			PUSH    AF              	; It's a numeric type from this point on
0415FC CD C2 17 04 3933  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041600 E5          3934  			PUSH    HL
041601 CD 07 03 04 3935  			CALL    EXPRN
041605 DD E1       3936  			POP     IX
041607 F1          3937  			POP     AF
041608 CB 47       3938  STORE:			BIT     0,A
04160A 28 13       3939  			JR      Z,STOREI
04160C BF          3940  			CP      A               	; Set the variable to 0
04160D DD 71 04    3941  STORE5:			LD      (IX+4),C
041610 D9          3942  STORE4:			EXX
041611 DD 75 00    3943  			LD      (IX+0),L
041614 DD 74 01    3944  			LD      (IX+1),H
041617 D9          3945  			EXX
041618 DD 75 02    3946  			LD      (IX+2),L
04161B DD 74 03    3947  			LD      (IX+3),H
04161E C9          3948  			RET
04161F F5          3949  STOREI:			PUSH    AF
041620 0C          3950  			INC     C               ;SPEED - & PRESERVE F'
041621 0D          3951  			DEC     C               ; WHEN CALLED BY FNEND0
041622 C4 67 06 04 3952  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
041626 F1          3953  			POP     AF
041627 FE 04       3954  			CP      4
041629 28 E5       3955  			JR      Z,STORE4
04162B BF          3956  			CP      A               ;SET ZERO
04162C D9          3957  STORE1:			EXX
04162D DD 75 00    3958  			LD      (IX+0),L
041630 D9          3959  			EXX
041631 C9          3960  			RET
041632             3961  ;
041632             3962  ; Copy a string from the string accumulator to variable storage on the stack
041632             3963  ; Parameters:
041632             3964  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041632             3965  ; - IX: Address of the variable storage on the stack
041632             3966  ;
041632 21 00 4A 04 3967  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041636             3968  ;
041636             3969  ; Parameters:
041636             3970  ; As above, but:
041636             3971  ; - HL: Address of the string to be stored
041636             3972  ; -  E: The string length
041636             3973  ; NB:
041636             3974  ; Strings are mutable
041636             3975  ; Strings are stored in the following format in the variable:
041636             3976  ; - Address of the next variable (3 bytes)
041636             3977  ; - The rest of the variable name - this is zero terminated
041636             3978  ; - Current string length (byte)
041636             3979  ; - Maximum (original) string length (byte)
041636             3980  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041636             3981  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041636             3982  ;
041636 1F          3983  STORES:			RRA				; Rotate right to shift bit 0 into carry
041637 30 5D       3984  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041639 E5          3985  			PUSH    HL			; Stack ACCS
04163A             3986  ;
04163A             3987  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
04163A             3988  ;
04163A D9          3989  			EXX				; This block was a call to LOAD4
04163B DD 6E 00    3990  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04163E DD 66 01    3991  			LD      H,(IX+1)		; The maximum original string length
041641 D9          3992  			EXX
041642 DD 27 02    3993  			LD	HL,(IX+2)		; Address of the string (24-bit)
041645             3994  ;
041645 7B          3995  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041646 D9          3996  			EXX
041647 6F          3997  			LD      L,A			; L': Length of string currently stored on the stack
041648 7C          3998  			LD      A,H             	; H': The maximum (original) string length
041649 D9          3999  			EXX
04164A BB          4000  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
04164B 30 17       4001  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04164D             4002  ;
04164D             4003  ; At this point we're either initialising a new string or assigning more memory to an existing string
04164D             4004  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04164D             4005  ; then the existing and new strings may both exist in memory.
04164D             4006  ;
04164D D9          4007  			EXX
04164E 65          4008  			LD      H,L			; H: Set the maximum string length to the string length
04164F D9          4009  			EXX
041650 E5          4010  			PUSH    HL
041651 01 00 00 00 4011  			LD	BC, 0
041655 4F          4012  			LD      C,A			; BC: The maximum (original) string length
041656 09          4013  			ADD     HL,BC			; Work out whether this is the last string in memory
041657 ED 4B 1D 4D 4014  			LD      BC,(FREE)
       04          
04165C ED 42       4015  			SBC     HL,BC			; Is string last?
04165E E1          4016  			POP     HL
04165F 37          4017  			SCF
041660 28 02       4018  			JR      Z,STORS1
041662             4019  			; LD	HL, BC			; HL=BC
041662 C5          4020  			push bc
041663 E1          4021  			pop hl
041664             4022  ;
041664             4023  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041664             4024  ; - H': The maximum (original) string length
041664             4025  ; - L': The actual string length (must be less than H')
041664             4026  ; - HL: Address of the string in memory
041664             4027  ;
041664 D9          4028  STORS1:			EXX				; This block was a call to STORE4
041665 DD 75 00    4029  			LD      (IX+0),L		; The actual string length (must be less then H')
041668 DD 74 01    4030  			LD      (IX+1),H		; The maximum (original) string length
04166B D9          4031  			EXX
04166C DD 2F 02    4032  			LD	(IX+2),HL		; The pointer to the original string
04166F             4033  ;
04166F 01 00 00 00 4034  			LD	BC, 0
041673 4B          4035  			LD      C,E			; BC: The new string length
041674 EB          4036  			EX      DE,HL
041675 E1          4037  			POP     HL
041676 0D          4038  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041677 0C          4039  			INC     C			; check whether BC is 0 without affecting the carry flag
041678 C8          4040  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041679 ED B0       4041  			LDIR				; Replace the string in memory
04167B D0          4042  			RET     NC
04167C ED 53 1D 4D 4043  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
041681             4044  ;
041681             4045  ; Check whether the stack is full
041681             4046  ;
041681 E5          4047  CHECK:			PUSH    HL
041682 C5          4048  			PUSH	BC
041683 2A 1D 4D 04 4049  			LD      HL,(FREE)		; HL: Address of first free space byte
041687 01 00 01 00 4050  			LD	BC,100h			; BC: One page of memory
04168B 09          4051  			ADD	HL,BC			; Add a page to FREE
04168C ED 72       4052  			SBC     HL,SP			; And subtract the current SP
04168E C1          4053  			POP	BC
04168F E1          4054  			POP     HL
041690 D8          4055  			RET     C			; The SP is not in the same page, so just return
041691 AF          4056  			XOR     A			; Otherwise
041692 C3 98 37 04 4057  			JP      ERROR_			; Throw error "No room"
041696             4058  ;
041696 01 00 00 00 4059  STORS3:			LD	BC,0
04169A 4B          4060  			LD      C,E			; BC: String length
04169B DD E5       4061  			PUSH    IX
04169D D1          4062  			POP     DE			; DE: Destination
04169E AF          4063  			XOR     A			; Check if string length is 0
04169F B9          4064  			CP      C
0416A0 28 02       4065  			JR      Z,STORS5		; Yes, so don't copy
0416A2 ED B0       4066  			LDIR
0416A4 3E 0D       4067  STORS5:			LD      A,CR			; Finally add the terminator
0416A6 12          4068  			LD      (DE),A
0416A7 C9          4069  			RET
0416A8             4070  
0416A8             4071  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0416A8             4072  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0416A8             4073  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0416A8             4074  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0416A8             4075  ;    Inputs: DE addresses parameter list
0416A8             4076  ;            IY addresses dummy variable list
0416A8             4077  ;   Outputs: DE,IY updated
0416A8             4078  ;  Destroys: Everything
0416A8             4079  ;
0416A8 3E FF       4080  ARGUE:			LD      A,-1
0416AA F5          4081  			PUSH    AF              	; Put marker on the stack
0416AB FD 23       4082  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416AD 13          4083  			INC     DE
0416AE D5          4084  			PUSH    DE
0416AF CD 78 0A 04 4085  			CALL    NXT			; Skip any whitespace
0416B3 CD 72 3A 04 4086  			CALL    GETVAR			; Get the location of the variable in HL/IX
0416B7 38 3F       4087  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B9 C4 61 3A 04 4088  			CALL    NZ,PUTVAR
0416BD D1          4089  			POP     DE
0416BE E5          4090  			PUSH    HL              	; VARPTR
0416BF B7          4091  			OR      A               	; Check the variable type
0416C0 F5          4092  			PUSH    AF
0416C1 D5          4093  			PUSH    DE
0416C2 FD E3       4094  			EX      (SP),IY
0416C4 FA DC 16 04 4095  			JP      M,ARGUE2        	; Jump here if it is a string
0416C8             4096  ;
0416C8 CD 07 03 04 4097  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416CC FD E3       4098  			EX      (SP),IY
0416CE D1          4099  			POP     DE
0416CF F1          4100  			POP     AF
0416D0 D9          4101  			EXX
0416D1 E5          4102  			PUSH    HL
0416D2 D9          4103  			EXX
0416D3 E5          4104  			PUSH    HL
0416D4 47          4105  			LD      B,A
0416D5 C5          4106  			PUSH    BC
0416D6 CD 81 16 04 4107  			CALL    CHECK           	; Check room
0416DA 18 0F       4108  			JR      ARGUE4
0416DC             4109  ;
0416DC CD 1A 03 04 4110  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416E0 FD E3       4111  			EX      (SP),IY
0416E2 D9          4112  			EXX
0416E3 D1          4113  			POP     DE
0416E4 D9          4114  			EXX
0416E5 F1          4115  			POP     AF
0416E6 CD B9 09 04 4116  			CALL    PUSHS
0416EA D9          4117  			EXX
0416EB             4118  ;
0416EB CD 78 0A 04 4119  ARGUE4:			CALL    NXT			; Skip whitespace
0416EF FE 2C       4120  			CP      ','			; Check to see if the next value is a comma
0416F1 20 0B       4121  			JR      NZ,ARGUE5		; No, so jump here
0416F3 1A          4122  			LD      A,(DE)
0416F4 FE 2C       4123  			CP      ','			; Are there any more arguments?
0416F6 28 B3       4124  			JR      Z,ARGUE1        	; Yes, so loop
0416F8             4125  ;
0416F8 3E 1F       4126  ARGERR:			LD      A,31
0416FA C3 98 37 04 4127  			JP      ERROR_           	; Throw error "Arguments"
0416FE             4128  ;
0416FE CD 37 0A 04 4129  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
041702 1A          4130  			LD      A,(DE)
041703 FE 29       4131  			CP      ')'
041705 20 F1       4132  			JR      NZ,ARGERR
041707 13          4133  			INC     DE
041708 D9          4134  			EXX
041709 C1          4135  ARGUE6:			POP     BC
04170A 78          4136  			LD      A,B
04170B 3C          4137  			INC     A
04170C D9          4138  			EXX
04170D C8          4139  			RET     Z               	; Marker popped
04170E D9          4140  			EXX
04170F 3D          4141  			DEC     A
041710 FA 20 17 04 4142  			JP      M,ARGUE7        	; If it is a string, then jump here
041714 E1          4143  			POP     HL
041715 D9          4144  			EXX
041716 E1          4145  			POP     HL
041717 D9          4146  			EXX
041718 DD E1       4147  			POP     IX
04171A CD 08 16 04 4148  			CALL    STORE	           	; Write to dummy variable
04171E 18 E9       4149  			JR      ARGUE6
041720             4150  ;
041720 CD E6 09 04 4151  ARGUE7:			CALL    POPS
041724 DD E1       4152  			POP     IX
041726 CD 32 16 04 4153  			CALL    STACCS
04172A 18 DD       4154  			JR      ARGUE6
04172C             4155  
04172C             4156  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
04172C             4157  ;   OF A FUNCTION OR PROCEDURE.
04172C             4158  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
04172C             4159  ;    Inputs: IY is parameters pointer
04172C             4160  ;   Outputs: IY updated
04172C             4161  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
04172C             4162  ;
04172C D1          4163  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
04172D             4164  ;
04172D FD 23       4165  SAVLO1:			INC     IY              	; Bump past '(' or ','
04172F CD 78 0A 04 4166  			CALL    NXT			; And also any whitespace
041733 D5          4167  			PUSH    DE			; Push the return address back onto the stack
041734 D9          4168  			EXX
041735 C5          4169  			PUSH    BC
041736 D5          4170  			PUSH    DE
041737 E5          4171  			PUSH    HL
041738 D9          4172  			EXX
041739 CD 96 0C 04 4173  			CALL    VAR_             	; Dummy variable
04173D D9          4174  			EXX
04173E E1          4175  			POP     HL
04173F D1          4176  			POP     DE
041740 C1          4177  			POP     BC
041741 D9          4178  			EXX
041742 D1          4179  			POP     DE
041743 B7          4180  			OR      A               	; Check the variable type
041744 FA 57 17 04 4181  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041748 D9          4182  			EXX
041749 E5          4183  			PUSH    HL              	; Save H'L'
04174A D9          4184  			EXX
04174B 47          4185  			LD      B,A             	;  B: Variable type
04174C CD 1B 04 04 4186  			CALL    LOADN
041750 D9          4187  			EXX
041751 E3          4188  			EX      (SP),HL
041752 D9          4189  			EXX
041753 E5          4190  			PUSH    HL
041754 C5          4191  			PUSH    BC
041755 18 2D       4192  			JR      SAVLO4
041757             4193  ;
041757 F5          4194  SAVLO2:			PUSH    AF              	; Save the type (string)
041758 D5          4195  			PUSH    DE
041759 D9          4196  			EXX
04175A E5          4197  			PUSH    HL
04175B D9          4198  			EXX
04175C CD A5 04 04 4199  			CALL    LOADS
041760 D9          4200  			EXX
041761 E1          4201  			POP     HL
041762 D9          4202  			EXX
041763 01 00 00 00 4203  			LD	BC,0
041767 4B          4204  			LD      C,E			; BC: String length
041768 D1          4205  			POP     DE
041769 CD 81 16 04 4206  			CALL    CHECK			; Check if there is space on the stack
04176D F1          4207  			POP     AF              	; Level stack
04176E 21 00 00 00 4208  			LD      HL,0
041772 ED 42       4209  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041774 39          4210  			ADD     HL,SP			; Make space for the string on the stack
041775 F9          4211  			LD      SP,HL
041776 47          4212  			LD      B,A             	;  B: Variable type
041777 C5          4213  			PUSH    BC
041778 28 0A       4214  			JR      Z,SAVLO4
04177A D5          4215  			PUSH    DE
04177B 11 00 4A 04 4216  			LD      DE,ACCS
04177F EB          4217  			EX      DE,HL
041780 45          4218  			LD      B,L
041781 ED B0       4219  			LDIR                    	; Save the string onto the stack
041783 D1          4220  			POP     DE
041784             4221  ;
041784 DD E5       4222  SAVLO4:			PUSH    IX			; VARPTR
041786 CD 8A 17 04 4223  			CALL    SAVLO5
04178A             4224  LOCCHK:			EQU     $
04178A CD 81 16 04 4225  SAVLO5:			CALL    CHECK
04178E CD 78 0A 04 4226  			CALL    NXT
041792 FE 2C       4227  			CP      ','             	; Are there any more local variables?
041794 28 97       4228  			JR      Z,SAVLO1		; Yes, so loop
041796 EB          4229  			EX      DE,HL			; DE -> HL: The return address
041797 E9          4230  			JP      (HL)            	; And effectvely return
041798             4231  ;
041798 FD 7E 00    4232  DELIM:			LD      A,(IY)          	; Assembler delimiter
04179B FE 20       4233  			CP      ' '
04179D C8          4234  			RET     Z
04179E FE 2C       4235  			CP      ','
0417A0 C8          4236  			RET     Z
0417A1 FE 29       4237  			CP      ')'
0417A3 C8          4238  			RET     Z
0417A4 FE 3B       4239  TERM:			CP      ';'             	; Assembler terminator
0417A6 C8          4240  			RET     Z
0417A7 FE 5C       4241  			CP      '\'
0417A9 C8          4242  			RET     Z
0417AA 18 07       4243  			JR      TERM0
0417AC             4244  ;
0417AC CD 78 0A 04 4245  TERMQ:			CALL    NXT
0417B0 FE 8B       4246  			CP      ELSE_EX_
0417B2 D0          4247  			RET     NC
0417B3 FE 3A       4248  TERM0:			CP      ':'             	; Assembler seperator
0417B5 D0          4249  			RET     NC
0417B6 FE 0D       4250  			CP      CR
0417B8 C9          4251  			RET
0417B9             4252  ;
0417B9 CD AC 17 04 4253  SPAN:			CALL    TERMQ
0417BD C8          4254  			RET     Z
0417BE FD 23       4255  			INC     IY
0417C0 18 F7       4256  			JR      SPAN
0417C2             4257  ;
0417C2             4258  ; This snippet is used to check whether an expression is followed by an '=' symbol
0417C2             4259  ;
0417C2 CD 78 0A 04 4260  EQUALS:			CALL    NXT			; Skip whitespace
0417C6 FD 23       4261  			INC     IY			; Skip past the character in question
0417C8 FE 3D       4262  			CP      '='			; Is it '='
0417CA C8          4263  			RET     Z			; Yes, so return
0417CB 3E 04       4264  			LD      A,4			; Otherwise
0417CD C3 98 37 04 4265  			JP      ERROR_           	; Throw error "Mistake"
0417D1             4266  ;
0417D1 FE 8A       4267  FORMAT:			CP      TAB
0417D3 28 0D       4268  			JR      Z,DOTAB
0417D5 FE 89       4269  			CP      SPC
0417D7 28 40       4270  			JR      Z,DOSPC
0417D9 FE 27       4271  			CP      '''
0417DB C0          4272  			RET     NZ
0417DC CD 7F 39 04 4273  			CALL    CRLF
0417E0 AF          4274  			XOR     A
0417E1 C9          4275  			RET
0417E2             4276  ;
0417E2 C5          4277  DOTAB:			PUSH    BC
0417E3 CD 0F 03 04 4278  			CALL    EXPRI
0417E7 D9          4279  			EXX
0417E8 C1          4280  			POP     BC
0417E9 FD 7E 00    4281  			LD      A,(IY)
0417EC FE 2C       4282  			CP      ','
0417EE 28 14       4283  			JR      Z,DOTAB1
0417F0 CD 37 0A 04 4284  			CALL    BRAKET
0417F4 7D          4285  			LD      A,L
0417F5 21 3D 4D 04 4286  TABIT:			LD      HL,COUNT
0417F9 BE          4287  			CP      (HL)
0417FA C8          4288  			RET     Z
0417FB F5          4289  			PUSH    AF
0417FC DC 7F 39 04 4290  			CALL    C,CRLF
041800 F1          4291  			POP     AF
041801 96          4292  			SUB     (HL)
041802 18 1D       4293  			JR      FILL
041804 FD 23       4294  DOTAB1:			INC     IY
041806 C5          4295  			PUSH    BC
041807 E5          4296  			PUSH    HL
041808 CD 0F 03 04 4297  			CALL    EXPRI
04180C D9          4298  			EXX
04180D D1          4299  			POP     DE
04180E C1          4300  			POP     BC
04180F CD 37 0A 04 4301  			CALL    BRAKET
041813 CD F9 3E 04 4302  			CALL    PUTCSR
041817 AF          4303  			XOR     A
041818 C9          4304  			RET
041819             4305  ;
041819 C5          4306  DOSPC:			PUSH    BC
04181A CD 2A 03 04 4307  			CALL    ITEMI
04181E D9          4308  			EXX
04181F 7D          4309  			LD      A,L
041820 C1          4310  			POP     BC
041821 B7          4311  FILL:			OR      A
041822 C8          4312  			RET     Z
041823 C5          4313  			PUSH    BC
041824 47          4314  			LD      B,A
041825 3E 20       4315  FILL1:			LD      A,' '
041827 CD 87 39 04 4316  			CALL    OUTCHR
04182B 10 F8       4317  			DJNZ    FILL1
04182D C1          4318  			POP     BC
04182E AF          4319  			XOR     A
04182F C9          4320  			RET
041830             4321  ;
041830 21 00 4A 04 4322  PTEXT:			LD      HL,ACCS
041834 1C          4323  			INC     E
041835 1D          4324  PTEXT1:			DEC     E
041836 C8          4325  			RET     Z
041837 7E          4326  			LD      A,(HL)
041838 23          4327  			INC     HL
041839 CD 87 39 04 4328  			CALL    OUTCHR
04183D 18 F6       4329  			JR      PTEXT1
04183F             4330  ;
04183F F5          4331  FETCHS:			PUSH    AF
041840 C5          4332  			PUSH    BC
041841 E5          4333  			PUSH    HL
041842 FD E3       4334  			EX      (SP),IY
041844 CD 5F 18 04 4335  			CALL    XTRACT
041848 CD 78 0A 04 4336  			CALL    NXT
04184C FD E3       4337  			EX      (SP),IY
04184E E1          4338  			POP     HL
04184F C1          4339  			POP     BC
041850 F1          4340  			POP     AF
041851 C9          4341  			RET
041852             4342  ;
041852 11 00 4A 04 4343  LINES:			LD      DE,ACCS
041856 7E          4344  LINE1S:			LD      A,(HL)
041857 12          4345  			LD      (DE),A
041858 FE 0D       4346  			CP      CR
04185A C8          4347  			RET     Z
04185B 23          4348  			INC     HL
04185C 1C          4349  			INC     E
04185D 18 F7       4350  			JR      LINE1S
04185F             4351  ;
04185F CD 78 0A 04 4352  XTRACT:			CALL    NXT
041863 FE 22       4353  			CP      '"'
041865 FD 23       4354  			INC     IY
041867 CA 6C 04 04 4355  			JP      Z,CONS
04186B FD 2B       4356  			DEC     IY
04186D 11 00 4A 04 4357  			LD      DE,ACCS
041871 FD 7E 00    4358  XTRAC1:			LD      A,(IY)
041874 12          4359  			LD      (DE),A
041875 FE 2C       4360  			CP      ','
041877 C8          4361  			RET     Z
041878 FE 0D       4362  			CP      CR
04187A C8          4363  			RET     Z
04187B FD 23       4364  			INC     IY
04187D 1C          4365  			INC     E
04187E 18 F1       4366  			JR      XTRAC1
041880             4367  
041880             4368  ; Search for a token at the start of a program line
041880             4369  ; - HL: Pointer to the start of a tokenised line in the program area
041880             4370  ; Returns:
041880             4371  ; - HL: Pointer to the
041880             4372  ; -  F: Carry set if not found
041880             4373  ; Corrupts:
041880             4374  ; - BC
041880             4375  ;
041880 01 00 00 00 4376  SEARCH_EX:			LD      BC,0			; Clear BC
041884             4377  ;
041884 4E          4378  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041885 0C          4379  			INC     C			; Check for 0, i.e. end of program marker
041886 0D          4380  			DEC     C
041887 28 0B       4381  			JR      Z,SRCH2_EX         	; Not found the token, so end
041889 23          4382  			INC     HL			; Skip the line length and line number
04188A 23          4383  			INC     HL
04188B 23          4384  			INC     HL
04188C BE          4385  			CP      (HL)			; Compare with the token
04188D C8          4386  			RET     Z			; Found it, so return with carry not set
04188E 0D          4387  			DEC     C			; Skip to the next line
04188F 0D          4388  			DEC     C
041890 0D          4389  			DEC     C
041891 09          4390  			ADD     HL,BC
041892 18 F0       4391  			JR      SRCH1_EX			; Rinse, lather and repeat
041894             4392  ;
041894 2B          4393  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041895 37          4394  			SCF				; And set the carry flag
041896 C9          4395  			RET
041897             4396  
041897             4397  ; Multiply by 4 or 5
041897             4398  ; This function is used to allocate space for dimensioned variables
041897             4399  ; This is a 24-bit operation
041897             4400  ; - DE: Number to multiple
041897             4401  ; -  A: 04h (Integer) - takes up 4 bytes
041897             4402  ;       05h (Float)   - takes up 5 bytes
041897             4403  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
041897             4404  ; Returns:
041897             4405  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
041897             4406  ; -  F: Carry if overflow
041897             4407  ; Corrupts:
041897             4408  ; - HL
041897 FE 04       4409  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041899             4410  			; LD	HL,DE
041899 D5          4411  			push de
04189A E1          4412  			pop hl
04189B 29          4413  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04189C D8          4414  			RET     C			; Exit if overflow
04189D 29          4415  			ADD     HL,HL			; Multiply by 2 again
04189E D8          4416  			RET     C			; Exit if overflow
04189F EB          4417  			EX      DE,HL			; DE: Product
0418A0 C8          4418  			RET     Z			; Exit if A = 4
0418A1 19          4419  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0418A2 EB          4420  			EX      DE,HL			; DE: Product
0418A3 C9          4421  			RET
0418A4             4422  
0418A4             4423  ; 16-bit unsigned multiply
0418A4             4424  ; - HL: Operand 1
0418A4             4425  ; - BC: Operand 2
0418A4             4426  ; Returns:
0418A4             4427  ; - HL: Result
0418A4             4428  ; -  F: C if overflow
0418A4             4429  ;
0418A4 C5          4430  MUL16:			PUSH	BC
0418A5 51          4431  			LD	D, C			; Set up the registers for the multiplies
0418A6 5D          4432  			LD	E, L
0418A7 69          4433  			LD	L, C
0418A8 4B          4434  			LD	C, E
0418A9 ED 6C       4435  			MLT	HL			; HL = H * C (*256)
0418AB ED 5C       4436  			MLT	DE			; DE = L * C
0418AD ED 4C       4437  			MLT	BC			; BC = B * L (*256)
0418AF 09          4438  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418B0 C1          4439  			POP	BC
0418B1 AF          4440  			XOR	A
0418B2 9C          4441  			SBC	H			; If H is not zero then it's an overflow
0418B3 D8          4442  			RET	C
0418B4 65          4443  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418B5 6F          4444  			LD	L, A
0418B6 19          4445  			ADD	HL, DE
0418B7 C9          4446  			RET
0418B8             4447  ;
0418B8 CD 78 0A 04 4448  CHANEL:			CALL    NXT			; Skip whitespace
0418BC FE 23       4449  			CP      '#'			; Check for the '#' symbol
0418BE 3E 2D       4450  			LD      A,45
0418C0 C2 98 37 04 4451  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418C4 FD 23       4452  CHNL:			INC     IY             		; Bump past the '#'
0418C6 CD 2A 03 04 4453  			CALL    ITEMI			; Get the channel number
0418CA D9          4454  			EXX
0418CB EB          4455  			EX      DE,HL			; DE: The channel number
0418CC C9          4456  			RET
0418CD             4457  
0418CD             4458  ; ASSEMBLER -------------------------------------------------------------------
0418CD             4459  
0418CD             4460  ; Language independant control section:
0418CD             4461  ;  Outputs: A=delimiter, carry set if syntax error.
0418CD             4462  ;
0418CD CD ED 1D 04 4463  ASSEM:			CALL    SKIP
0418D1 FD 23       4464  			INC     IY
0418D3 FE 3A       4465  			CP      ':'
0418D5 28 F6       4466  			JR      Z,ASSEM
0418D7 FE 5D       4467  			CP      ']'
0418D9 C8          4468  			RET     Z
0418DA FE 0D       4469  			CP      CR
0418DC C8          4470  			RET     Z
0418DD FD 2B       4471  			DEC     IY
0418DF DD 2A 40 30 4472  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       11          
0418E4 21 40 4D 04 4473  			LD      HL,LISTON
0418E8 CB 76       4474  			BIT     6,(HL)
0418EA 28 05       4475  			JR      Z,ASSEM0
0418EC DD 2A 3C 30 4476  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       11          
0418F1 DD E5       4477  ASSEM0:			PUSH    IX
0418F3 FD E5       4478  			PUSH    IY
0418F5 CD A5 19 04 4479  			CALL    ASMB
0418F9 C1          4480  			POP     BC
0418FA D1          4481  			POP     DE
0418FB D8          4482  			RET     C
0418FC CD ED 1D 04 4483  			CALL    SKIP
041900 37          4484  			SCF
041901 C0          4485  			RET     NZ
041902 FD 2B       4486  			DEC     IY
041904 FD 23       4487  ASSEM3:			INC     IY
041906 FD 7E 00    4488  			LD      A,(IY)
041909 CD B3 17 04 4489  			CALL    TERM0
04190D 20 F5       4490  			JR      NZ,ASSEM3
04190F 3A 40 4D 04 4491  			LD      A,(LISTON)
041913 DD E5       4492  			PUSH    IX
041915 E1          4493  			POP     HL
041916 B7          4494  			OR      A
041917 ED 52       4495  			SBC     HL,DE
041919 EB          4496  			EX      DE,HL           	; DE: Number of bytes
04191A E5          4497  			PUSH    HL
04191B 2A 40 30 11 4498  			LD      HL,(PC)
04191F E5          4499  			PUSH    HL
041920 19          4500  			ADD     HL,DE
041921 22 40 30 11 4501  			LD      (PC),HL         	; Update PC
041925 CB 77       4502  			BIT     6,A
041927 28 09       4503  			JR      Z,ASSEM5
041929 2A 3C 30 11 4504  			LD      HL,(OC)
04192D 19          4505  			ADD     HL,DE
04192E 22 3C 30 11 4506  			LD      (OC),HL         	; Update OC
041932 E1          4507  ASSEM5:			POP     HL              	; Old PC
041933 DD E1       4508  			POP     IX              	; Code here
041935 CB 67       4509  			BIT     4,A
041937 28 94       4510  			JR      Z,ASSEM
041939 22 4A 4D 04 4511  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04193D 3A 4C 4D 04 4512  			LD	A,(R0+2)		; Print out the address
041941 CD 8F 19 04 4513  			CALL	HEX_EX
041945 7C          4514  			LD      A,H
041946 CD 8F 19 04 4515  			CALL    HEX_EX
04194A 7D          4516  			LD      A,L
04194B CD 87 19 04 4517  			CALL    HEXSP
04194F AF          4518  			XOR     A
041950 BB          4519  			CP      E
041951 28 18       4520  			JR      Z,ASSEM2
041953             4521  ;
041953 3A 3D 4D 04 4522  ASSEM1:			LD      A,(COUNT)
041957 FE 14       4523  			CP      20
041959 3E 07       4524  			LD      A,7
04195B D4 F5 17 04 4525  			CALL    NC,TABIT        	; Next line
04195F DD 7E 00    4526  			LD      A,(IX)
041962 CD 87 19 04 4527  			CALL    HEXSP
041966 DD 23       4528  			INC     IX
041968 1D          4529  			DEC     E
041969 20 E8       4530  			JR      NZ,ASSEM1
04196B             4531  ;
04196B 3E 16       4532  ASSEM2:			LD      A,22			; Tab to the disassembly field
04196D CD F5 17 04 4533  			CALL    TABIT
041971 FD E5       4534  			PUSH    IY
041973 E1          4535  			POP     HL
041974 ED 42       4536  			SBC     HL,BC
041976 0A          4537  ASSEM4:			LD      A,(BC)
041977 CD A4 39 04 4538  			CALL    OUT_
04197B 03          4539  			INC     BC
04197C 2D          4540  			DEC     L
04197D 20 F7       4541  			JR      NZ,ASSEM4
04197F CD 7F 39 04 4542  			CALL    CRLF
041983 C3 CD 18 04 4543  			JP      ASSEM
041987             4544  ;
041987 CD 8F 19 04 4545  HEXSP:			CALL    HEX_EX
04198B 3E 20       4546  			LD      A,' '
04198D 18 12       4547  			JR      OUTCH1
04198F F5          4548  HEX_EX:			PUSH    AF
041990 0F          4549  			RRCA
041991 0F          4550  			RRCA
041992 0F          4551  			RRCA
041993 0F          4552  			RRCA
041994 CD 99 19 04 4553  			CALL    HEXOUT
041998 F1          4554  			POP     AF
041999 E6 0F       4555  HEXOUT:			AND     0FH
04199B C6 90       4556  			ADD     A,90H
04199D 27          4557  			DAA
04199E CE 40       4558  			ADC     A,40H
0419A0 27          4559  			DAA
0419A1 C3 A4 39 04 4560  OUTCH1:			JP      OUT_
0419A5             4561  
0419A5             4562  ; Processor Specific Translation Section:
0419A5             4563  ;
0419A5             4564  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0419A5             4565  ;                 C: Opcode beig built
0419A5             4566  ;                 D: Flags
0419A5             4567  ;			Bit 7: Set to 1 if the instruction uses long addressing
0419A5             4568  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0419A5             4569  ;                 E: Offset from IX or IY
0419A5             4570  ;                HL: Numeric operand value
0419A5             4571  ;                IX: Code destination pointer
0419A5             4572  ;                IY: Source text pointer
0419A5             4573  ;    Inputs: A = initial character
0419A5             4574  ;   Outputs: Carry set if syntax error.
0419A5             4575  ;
0419A5 FE 2E       4576  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0419A7 20 1F       4577  			JR      NZ,ASMB1		; No, so just process the instruction
0419A9 FD 23       4578  			INC     IY			; Skip past the dot to the label name
0419AB DD E5       4579  			PUSH    IX			; Store the code destination pointer
0419AD CD 96 0C 04 4580  			CALL    VAR_			; Create a variable
0419B1 F5          4581  			PUSH    AF
0419B2 CD 98 09 04 4582  			CALL    ZERO			; Zero it
0419B6 3A 42 30 11 4583  			LD	A,(PC+2)
0419BA 6F          4584  			LD	L,A			; The MSB of the 24-bit address
0419BB D9          4585  			EXX
0419BC 2A 40 30 11 4586  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419C0 D9          4587  			EXX
0419C1 F1          4588  			POP     AF
0419C2 CD 08 16 04 4589  			CALL    STORE			; Store the program counter
0419C6 DD E1       4590  			POP     IX			; Restore the code destination pointer
0419C8             4591  ;
0419C8 3A 40 4D 04 4592  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419CC E6 80       4593  			AND	80H
0419CE 57          4594  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419CF CD ED 1D 04 4595  			CALL    SKIP			; Skip any whitespace
0419D3 C8          4596  			RET     Z			; And return if there is nothing further to process
0419D4 FE D6       4597  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419D6 0E C4       4598  			LD      C,0C4H			;  A: The base operand
0419D8 FD 23       4599  			INC     IY			; Skip past the token
0419DA CA 22 1B 04 4600  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419DE FD 2B       4601  			DEC     IY			; Skip back, as we're not doing the above at this point
0419E0 21 04 1E 04 4602  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419E4 CD 9C 1D 04 4603  			CALL    FIND			; Find the opcode
0419E8 D8          4604  			RET     C			; If not found, then return; carry indicates an error condition
0419E9 48          4605  			LD      C,B     		;  C: A copy of the opcode
0419EA             4606  ;
0419EA             4607  ; GROUP 0: Trivial cases requiring no computation
0419EA             4608  ; GROUP 1: As Group 0, but with "ED" prefix
0419EA             4609  ;
0419EA D6 44       4610  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419EC 30 08       4611  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419EE FE CB       4612  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419F0 D4 F5 1C 04 4613  			CALL    NC,ED			; Needs to be prefixed with ED
0419F4 18 76       4614  			JR      BYTE0			; Then write the opcode byte
0419F6             4615  ;
0419F6             4616  ; GROUP 2: BIT, RES, SET
0419F6             4617  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419F6             4618  ;
0419F6 D6 0A       4619  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419F8 30 12       4620  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419FA FE F9       4621  			CP      3-10			;
0419FC DC 8A 1D 04 4622  			CALL    C,BIT_
041A00 D8          4623  			RET     C
041A01 CD 5B 1D 04 4624  			CALL    REGLO
041A05 D8          4625  			RET     C
041A06 CD F9 1C 04 4626  			CALL    CB
041A0A 18 60       4627  			JR      BYTE0
041A0C             4628  ;
041A0C             4629  ; GROUP 4 - PUSH, POP, EX (SP)
041A0C             4630  ;
041A0C D6 03       4631  GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A0E 30 07       4632  			JR      NC,GROUP05		; If not in that range, then check GROUP5
041A10 CD 7D 1D 04 4633  GROUP04_1:		CALL    PAIR_EX
041A14 D8          4634  			RET     C
041A15 18 55       4635  			JR      BYTE0
041A17             4636  ;
041A17             4637  ; GROUP 5 - SUB, AND, XOR, OR, CP
041A17             4638  ; GROUP 6 - ADD, ADC, SBC
041A17             4639  ;
041A17 D6 0A       4640  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A19 30 39       4641  			JR      NC,GROUP07
041A1B FE FD       4642  			CP      5-8
041A1D 06 07       4643  			LD      B,7
041A1F D4 09 1D 04 4644  			CALL    NC,OPND			; Get the first operand
041A23 78          4645  			LD      A,B
041A24 FE 07       4646  			CP      7			; Is the operand 'A'?
041A26 20 15       4647  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A28             4648  ;
041A28 CD 5B 1D 04 4649  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A2C 79          4650  			LD      A,C
041A2D 30 2E       4651  			JR      NC,BIND1		; If it is a register, then write that out
041A2F EE 46       4652  			XOR     46H			; Handle ADD A,n
041A31 CD FB 1C 04 4653  			CALL    BIND
041A35 CD 3B 1D 04 4654  DB_:			CALL    NUMBER
041A39 C3 F4 1A 04 4655  			JP      VAL8
041A3D             4656  ;
041A3D E6 3F       4657  GROUP05_HL:		AND     3FH
041A3F FE 0C       4658  			CP      12
041A41 37          4659  			SCF
041A42 C0          4660  			RET     NZ
041A43 79          4661  			LD      A,C
041A44 FE 80       4662  			CP      80H
041A46 0E 09       4663  			LD      C,9
041A48 28 C6       4664  			JR      Z,GROUP04_1
041A4A EE 1C       4665  			XOR     1CH
041A4C 0F          4666  			RRCA
041A4D 4F          4667  			LD      C,A
041A4E CD F5 1C 04 4668  			CALL    ED
041A52 18 BC       4669  			JR      GROUP04_1
041A54             4670  ;
041A54             4671  ; GROUP 7 - INC, DEC
041A54             4672  ;
041A54 D6 02       4673  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A56 30 19       4674  			JR      NC,GROUP08
041A58 CD 62 1D 04 4675  			CALL    REGHI
041A5C 79          4676  			LD      A,C
041A5D D2 FB 1C 04 4677  BIND1:			JP      NC,BIND
041A61 EE 64       4678  			XOR     64H
041A63 07          4679  			RLCA
041A64 07          4680  			RLCA
041A65 07          4681  			RLCA
041A66 4F          4682  			LD      C,A
041A67 CD 82 1D 04 4683  			CALL    PAIR1_EX
041A6B D8          4684  			RET     C
041A6C 79          4685  BYTE0:			LD      A,C
041A6D C3 2A 1D 04 4686  			JP      BYTE_
041A71             4687  ;
041A71             4688  ; Group 8: IN0, OUT0
041A71             4689  ;
041A71 D6 02       4690  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A73 30 2C       4691  			JR	NC,GROUP09
041A75 FE FF       4692  			CP	1-2
041A77 CC 3B 1D 04 4693  			CALL    Z,NUMBER		; Fetch number first if OUT
041A7B 08          4694  			EX      AF,AF'			; Save flags
041A7C CD 4F 1D 04 4695  			CALL    REG			; Get the register value regardless
041A80 D8          4696  			RET     C			; Return if not a register
041A81 08          4697  			EX      AF,AF'			; Restore the flags
041A82 DC 3B 1D 04 4698  			CALL    C,NUMBER		; Fetch number last if IN
041A86 78          4699  			LD	A,B			; Get the register number
041A87 FE 06       4700  			CP	6			; Fail on (HL)
041A89 37          4701  			SCF
041A8A C8          4702  			RET	Z
041A8B FE 08       4703  			CP	8			; Check it is just single pairs only
041A8D 3F          4704  			CCF
041A8E D8          4705  			RET	C			; And return if it is an invalid register
041A8F 07          4706  			RLCA				; Bind with the operand
041A90 07          4707  			RLCA
041A91 07          4708  			RLCA
041A92 81          4709  			ADD	A,C
041A93 4F          4710  			LD	C,A
041A94 CD F5 1C 04 4711  			CALL	ED			; Prefix with ED
041A98 79          4712  			LD	A,C
041A99 CD 2A 1D 04 4713  			CALL	BYTE_			; Write out the operand
041A9D C3 F4 1A 04 4714  			JP	VAL8			; Write out the value
041AA1             4715  ;
041AA1             4716  ; GROUP 9 - IN
041AA1             4717  ; GROUP 10 - OUT
041AA1             4718  ;
041AA1 D6 02       4719  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041AA3 30 25       4720  			JR      NC,GROUP11
041AA5 FE FF       4721  			CP      1-2			; Check if Group 9 or Group 1
041AA7 CC E9 1C 04 4722  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AAB 08          4723  			EX      AF,AF'			; Save flags
041AAC CD 62 1D 04 4724  			CALL    REGHI			; Get the register value regardless
041AB0 D8          4725  			RET     C			; Return if not a register
041AB1 08          4726  			EX      AF,AF'			; Restore the flags
041AB2 DC E9 1C 04 4727  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041AB6 24          4728  			INC     H			; If it is IN r,(C) or OUT (C),r then
041AB7 28 B3       4729  			JR      Z,BYTE0			; Just write the operand out
041AB9             4730  ;
041AB9 78          4731  			LD      A,B			; Check the register
041ABA FE 07       4732  			CP      7
041ABC 37          4733  			SCF
041ABD C0          4734  			RET     NZ			; If it is not A, then return
041ABE             4735  ;
041ABE 79          4736  			LD      A,C			; Bind the register with the operand
041ABF EE 03       4737  			XOR     3
041AC1 07          4738  			RLCA
041AC2 07          4739  			RLCA
041AC3 07          4740  			RLCA
041AC4 CD 2A 1D 04 4741  			CALL    BYTE_			; Write out the operand
041AC8 18 2A       4742  			JR      VAL8			; And the value
041ACA             4743  ;
041ACA             4744  ; GROUP 11 - JR, DJNZ
041ACA             4745  ;
041ACA D6 02       4746  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041ACC 30 2B       4747  			JR      NC,GROUP12
041ACE FE FF       4748  			CP      1-2
041AD0 C4 69 1D 04 4749  			CALL    NZ,COND_
041AD4 79          4750  			LD      A,C
041AD5 30 02       4751  			JR      NC,@F
041AD7 3E 18       4752  			LD      A,18H
041AD9 CD 2A 1D 04 4753  @@:			CALL    BYTE_
041ADD CD 3B 1D 04 4754  			CALL    NUMBER
041AE1 ED 5B 40 30 4755  			LD      DE,(PC)
       11          
041AE6 13          4756  			INC     DE
041AE7 37          4757  			SCF
041AE8 ED 52       4758  			SBC     HL,DE
041AEA 7D          4759  			LD      A,L
041AEB 17          4760  			RLA
041AEC 9F          4761  			SBC     A,A
041AED BC          4762  			CP      H
041AEE 3E 01       4763  TOOFAR:			LD      A,1
041AF0 C2 98 37 04 4764  			JP      NZ,ERROR_		; Throw an "Out of range" error
041AF4 7D          4765  VAL8:			LD      A,L
041AF5 C3 2A 1D 04 4766  			JP      BYTE_
041AF9             4767  ;
041AF9             4768  ; GROUP 12 - JP
041AF9             4769  ;
041AF9 D6 01       4770  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AFB 30 21       4771  			JR	NC,GROUP13
041AFD CD 4F 1C 04 4772  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041B01 D8          4773  			RET	C			; Exit if an invalid suffix is provided
041B02 CD 69 1D 04 4774  			CALL    COND_			; Evaluate the conditions
041B06 79          4775  			LD      A,C
041B07 30 0D       4776  			JR      NC,GROUP12_1
041B09 78          4777  			LD      A,B
041B0A E6 3F       4778  			AND     3FH
041B0C FE 06       4779  			CP      6
041B0E 3E E9       4780  			LD      A,0E9H
041B10 CA 2A 1D 04 4781  			JP      Z,BYTE_
041B14 3E C3       4782  			LD      A,0C3H
041B16 CD 2A 1D 04 4783  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B1A C3 A4 1C 04 4784  			JP	ADDR_			; Output the address
041B1E             4785  ;
041B1E             4786  ; GROUP 13 - CALL
041B1E             4787  ;
041B1E D6 01       4788  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B20 30 0C       4789  			JR	NC,GROUP14
041B22 CD 67 1C 04 4790  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B26 CD 49 1B 04 4791  			CALL    GROUP15_1		; Output the opcode (with conditions)
041B2A C3 A4 1C 04 4792  			JP	ADDR_			; Output the address
041B2E             4793  ;
041B2E             4794  ; GROUP 14 - RST
041B2E             4795  ;
041B2E D6 01       4796  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B30 30 13       4797  			JR	NC,GROUP15
041B32 CD 67 1C 04 4798  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B36 D8          4799  			RET	C			; Exit if an invalid suffix provided
041B37 CD 3B 1D 04 4800  			CALL    NUMBER
041B3B A1          4801  			AND     C
041B3C B4          4802  			OR      H
041B3D 20 AF       4803  			JR      NZ,TOOFAR
041B3F 7D          4804  			LD      A,L
041B40 B1          4805  			OR      C
041B41 C3 2A 1D 04 4806  	  		JP      BYTE_
041B45             4807  ;
041B45             4808  ; GROUP 15 - RET
041B45             4809  ;
041B45 D6 01       4810  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B47 30 0F       4811  			JR	NC,GROUP16
041B49 CD 69 1D 04 4812  GROUP15_1:		CALL    COND_
041B4D 79          4813  			LD      A,C
041B4E D2 2A 1D 04 4814  			JP      NC,BYTE_
041B52 F6 09       4815  			OR      9
041B54 C3 2A 1D 04 4816  			JP      BYTE_
041B58             4817  ;
041B58             4818  ; GROUP 16 - LD
041B58             4819  ;
041B58 D6 01       4820  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B5A 30 74       4821  			JR	NC,GROUP17
041B5C CD 67 1C 04 4822  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B60 CD 98 1D 04 4823  			CALL    LDOP			; Check for accumulator loads
041B64 D2 C4 1C 04 4824  			JP      NC,LDA			; Yes, so jump here
041B68 CD 62 1D 04 4825  			CALL    REGHI
041B6C 08          4826  			EX      AF,AF'
041B6D CD ED 1D 04 4827  			CALL    SKIP
041B71 FE 28       4828  			CP      '('			; Check for bracket
041B73 28 24       4829  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B75 08          4830  			EX      AF,AF'
041B76 D2 28 1A 04 4831  			JP      NC,GROUP05_1		; Load single register direct; go here
041B7A 0E 01       4832  			LD      C,1
041B7C CD 82 1D 04 4833  			CALL    PAIR1_EX
041B80 D8          4834  			RET     C
041B81 3E 0E       4835  			LD      A,14
041B83 B8          4836  			CP      B
041B84 47          4837  			LD      B,A
041B85 CC 7D 1D 04 4838  			CALL    Z,PAIR_EX
041B89 78          4839  			LD      A,B
041B8A E6 3F       4840  			AND     3FH
041B8C FE 0C       4841  			CP      12
041B8E 79          4842  			LD      A,C
041B8F C2 16 1B 04 4843  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B93 3E F9       4844  			LD      A,0F9H
041B95 C3 2A 1D 04 4845  			JP      BYTE_
041B99             4846  ;
041B99 08          4847  LDIN:			EX      AF,AF'
041B9A C5          4848  			PUSH    BC
041B9B D4 5B 1D 04 4849  			CALL    NC,REGLO
041B9F 79          4850  			LD      A,C
041BA0 C1          4851  			POP     BC
041BA1 D2 FB 1C 04 4852  			JP      NC,BIND
041BA5 0E 0A       4853  			LD      C,0AH
041BA7 CD 82 1D 04 4854  			CALL    PAIR1_EX
041BAB CD CF 1C 04 4855  			CALL    LD16
041BAF D2 16 1B 04 4856  			JP      NC,GROUP12_1
041BB3 CD 3B 1D 04 4857  			CALL    NUMBER
041BB7 0E 02       4858  			LD      C,2
041BB9 CD 7D 1D 04 4859  			CALL    PAIR_EX
041BBD CD CF 1C 04 4860  			CALL    LD16
041BC1 D8          4861  			RET     C
041BC2 CD 2A 1D 04 4862  			CALL    BYTE_
041BC6 CB 7A       4863  			BIT	7,D			; Check the ADL flag
041BC8 C2 B9 1C 04 4864  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BCC C3 AC 1C 04 4865  			JP      VAL16			; Otherwise use 16-bit addresses
041BD0             4866  ;
041BD0             4867  ; Group 17 - TST
041BD0             4868  ;
041BD0 D6 01       4869  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BD2 30 25       4870  			JR	NC,OPTS
041BD4 CD F5 1C 04 4871  			CALL	ED			; Needs to be prefixed with ED
041BD8 CD 4F 1D 04 4872  			CALL	REG			; Fetch the register
041BDC 30 0E       4873  			JR	NC,GROUP17_1		; It's just a register
041BDE             4874  ;
041BDE 3E 64       4875  			LD	A,64H			; Opcode for TST n
041BE0 CD 2A 1D 04 4876  			CALL	BYTE_			; Write out the opcode
041BE4 CD 3B 1D 04 4877  			CALL	NUMBER			; Get the number
041BE8 C3 F4 1A 04 4878  			JP	VAL8			; And write that out
041BEC             4879  ;
041BEC 78          4880  GROUP17_1:		LD	A,B			; Check the register rangs
041BED FE 08       4881  			CP	8
041BEF 3F          4882  			CCF
041BF0 D8          4883  			RET	C			; Ret with carry flag set for error if out of range
041BF1 07          4884  			RLCA				; Get the opcode value
041BF2 07          4885  			RLCA
041BF3 07          4886  			RLCA
041BF4 81          4887  			ADD	A,C			; Add the opcode base in
041BF5 C3 2A 1D 04 4888  			JP	BYTE_
041BF9             4889  
041BF9             4890  ;
041BF9             4891  ; Assembler directives - OPT, ADL
041BF9             4892  ;
041BF9 D6 02       4893  OPTS:			SUB	2
041BFB 30 2B       4894  			JR	NC, DEFS
041BFD FE FF       4895  			CP	1-2			; Check for ADL opcode
041BFF 28 13       4896  			JR	Z, ADL_
041C01             4897  ;
041C01 CD 3B 1D 04 4898  OPT:			CALL    NUMBER			; Fetch the OPT value
041C05 21 40 4D 04 4899  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041C09 E6 07       4900  			AND	7			; Only interested in the first three bits
041C0B 4F          4901  			LD      C,A			; Store the new OPT value in C
041C0C ED 6F       4902  			RLD				; Shift the top nibble of LISTON (OPT) into A
041C0E E6 08       4903  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041C10 B1          4904  			OR	C			; OR in the new value
041C11 ED 67       4905  			RRD				; And shift the nibble back in
041C13 C9          4906  			RET
041C14             4907  ;
041C14 CD 3B 1D 04 4908  ADL_:			CALL	NUMBER			; Fetch the ADL value
041C18 E6 01       4909  			AND	1			; Only interested if it is 0 or 1
041C1A 0F          4910  			RRCA				; Rotate to bit 7
041C1B 4F          4911  			LD	C,A			; Store in C
041C1C 3A 40 4D 04 4912  			LD	A,(LISTON)		; Get the LISTON system variable
041C20 E6 7F       4913  			AND	7Fh			; Clear bit 7
041C22 B1          4914  			OR	C			; OR in the ADL value
041C23 32 40 4D 04 4915  			LD	(LISTON),A		; Store
041C27 C9          4916  			RET
041C28             4917  ;
041C28             4918  ; DEFB, DEFW, DEFL, DEFM
041C28             4919  ;
041C28 B7          4920  DEFS:			OR	A			; Handle DEFB
041C29 CA 35 1A 04 4921  			JP	Z, DB_
041C2D 3D          4922  			DEC	A			; Handle DEFW
041C2E CA A8 1C 04 4923  			JP	Z, ADDR16
041C32 3D          4924  			DEC	A			; Handle DEFL
041C33 CA B5 1C 04 4925  			JP	Z, ADDR24
041C37             4926  ;
041C37 DD E5       4927  			PUSH    IX			; Handle DEFM
041C39 CD 1A 03 04 4928  			CALL    EXPRS
041C3D DD E1       4929  			POP     IX
041C3F 21 00 4A 04 4930  			LD      HL,ACCS
041C43 AF          4931  @@:			XOR     A
041C44 BB          4932  			CP      E
041C45 C8          4933  			RET     Z
041C46 7E          4934  			LD      A,(HL)
041C47 23          4935  			INC     HL
041C48 CD 2A 1D 04 4936  			CALL    BYTE_
041C4C 1D          4937  			DEC     E
041C4D 18 F4       4938  			JR      @B
041C4F             4939  
041C4F             4940  ;
041C4F             4941  ;SUBROUTINES:
041C4F             4942  ;
041C4F FD 7E 00    4943  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C52 FE 2E       4944  			CP	'.'
041C54 28 02       4945  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C56 B7          4946  			OR	A			; Reset the carry flag (no error)
041C57 C9          4947  			RET				; And return
041C58 FD 23       4948  @@:			INC	IY			; Skip the dot
041C5A C5          4949  			PUSH	BC			; Push the operand
041C5B 21 83 20 04 4950  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C5F CD 9C 1D 04 4951  			CALL	FIND			; Look up the operand
041C63 30 24       4952  			JR	NC,EZ80SF_OK
041C65 C1          4953  			POP	BC			; Not found at this point, so will return with a C (error)
041C66 C9          4954  			RET
041C67             4955  ;
041C67 FD 7E 00    4956  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C6A FE 2E       4957  			CP	'.'
041C6C 28 02       4958  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C6E B7          4959  			OR	A			; Reset the carry flag (no error)
041C6F C9          4960  			RET				; And return
041C70 FD 23       4961  @@:			INC	IY 			; Skip the dot
041C72 C5          4962  			PUSH	BC			; Push the operand
041C73 21 7B 20 04 4963  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C77 CD 9C 1D 04 4964  			CALL	FIND 			; Look up the operand
041C7B 30 0C       4965  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C7D CD 98 1C 04 4966  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C81 CD 9C 1D 04 4967  			CALL	FIND
041C85 30 02       4968  			JR	NC,EZ80SF_OK
041C87 C1          4969  			POP	BC			; Not found at this point, so will return with a C (error)
041C88 C9          4970  			RET
041C89             4971  ;
041C89 78          4972  EZ80SF_OK:		LD	A,B			; The operand value
041C8A D4 2A 1D 04 4973  			CALL	NC,BYTE_ 		; Write it out if found
041C8E CB BA       4974  			RES	7,D			; Clear the default ADL mode from the flags
041C90 E6 02       4975  			AND	2			; Check the second half of the suffix (.xxL)
041C92 0F          4976  			RRCA				; Shift into bit 7
041C93 0F          4977  			RRCA
041C94 B2          4978  			OR	D			; Or into bit 7 of D
041C95 57          4979  			LD	D,A
041C96 C1          4980  			POP	BC 			; Restore the operand
041C97 C9          4981  			RET
041C98             4982  ;
041C98 21 8C 20 04 4983  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C9C CB 7A       4984  			BIT 	7,D			; if bit 7 of D is 0
041C9E C8          4985  			RET	Z
041C9F 21 97 20 04 4986  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041CA3 C9          4987  			RET
041CA4             4988  ;
041CA4 CB 7A       4989  ADDR_:			BIT	7,D			; Check the ADL flag
041CA6 20 0D       4990  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CA8             4991  ;
041CA8 CD 3B 1D 04 4992  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CAC CD F4 1A 04 4993  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CB0 7C          4994  			LD      A,H
041CB1 C3 2A 1D 04 4995  			JP      BYTE_
041CB5             4996  ;
041CB5 CD 3B 1D 04 4997  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CB9 CD AC 1C 04 4998  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CBD D9          4999  			EXX
041CBE 7D          5000  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CBF D9          5001  			EXX
041CC0 C3 2A 1D 04 5002  			JP	BYTE_
041CC4             5003  ;
041CC4 FE 04       5004  LDA:			CP      4
041CC6 DC F5 1C 04 5005  			CALL    C,ED
041CCA 78          5006  			LD      A,B
041CCB C3 2A 1D 04 5007  			JP      BYTE_
041CCF             5008  ;
041CCF 78          5009  LD16:			LD      A,B
041CD0 38 0F       5010  			JR      C,LD8
041CD2 78          5011  			LD      A,B
041CD3 E6 3F       5012  			AND     3FH
041CD5 FE 0C       5013  			CP      12
041CD7 79          5014  			LD      A,C
041CD8 C8          5015  			RET     Z
041CD9 CD F5 1C 04 5016  			CALL    ED
041CDD 79          5017  			LD      A,C
041CDE F6 43       5018  			OR      43H
041CE0 C9          5019  			RET
041CE1             5020  ;
041CE1 FE 07       5021  LD8:			CP      7
041CE3 37          5022  			SCF
041CE4 C0          5023  			RET     NZ
041CE5 79          5024  			LD      A,C
041CE6 F6 30       5025  			OR      30H
041CE8 C9          5026  			RET
041CE9             5027  ;
041CE9             5028  ; Used in IN and OUT to handle whether the operand is C or a number
041CE9             5029  ;
041CE9 C5          5030  CORN:			PUSH    BC
041CEA CD 09 1D 04 5031  			CALL    OPND			; Get the operand
041CEE CB 68       5032  			BIT     5,B
041CF0 C1          5033  			POP     BC
041CF1 28 48       5034  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CF3 26 FF       5035  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CF5             5036  ;
041CF5 3E ED       5037  ED:			LD      A,0EDH			; Write an ED prefix out
041CF7 18 31       5038  			JR      BYTE_
041CF9             5039  ;
041CF9 3E CB       5040  CB:			LD      A,0CBH
041CFB FE 76       5041  BIND:			CP      76H
041CFD 37          5042  			SCF
041CFE C8          5043  			RET     Z               	; Reject LD (HL),(HL)
041CFF CD 2A 1D 04 5044  			CALL    BYTE_
041D03 CB 72       5045  			BIT	6,D			; Check the index bit in flags
041D05 C8          5046  			RET     Z
041D06 7B          5047  			LD      A,E			; If there is an index, output the offset
041D07 18 21       5048  			JR      BYTE_
041D09             5049  ;
041D09             5050  ; Search through the operand table
041D09             5051  ; Returns:
041D09             5052  ; - B: The operand type
041D09             5053  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041D09             5054  ; - E: The IX/IY offset
041D09             5055  ; - F: Carry if not found
041D09             5056  ;
041D09 E5          5057  OPND:			PUSH    HL			; Preserve HL
041D0A 21 0D 20 04 5058  			LD      HL,OPRNDS		; The operands table
041D0E CD 9C 1D 04 5059  			CALL    FIND			; Find the operand
041D12 E1          5060  			POP     HL
041D13 D8          5061  			RET     C			; Return if not found
041D14 CB 78       5062  			BIT     7,B			; Check if it is an index register (IX, IY)
041D16 C8          5063  			RET     Z			; Return if it isn't
041D17 CB F2       5064  			SET	6,D			; Set flag to indicate we've got an index
041D19 CB 58       5065  			BIT     3,B			; Check if an offset is required
041D1B E5          5066  			PUSH    HL
041D1C CC 31 1D 04 5067  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D20 5D          5068  			LD      E,L			; E: The offset
041D21 E1          5069  			POP     HL
041D22 3E DD       5070  			LD	A,DDH			; IX prefix
041D24 CB 70       5071  			BIT     6,B			; If bit 6 is reset then
041D26 28 02       5072  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D28 3E FD       5073  			LD	A,FDH			; IY prefix
041D2A             5074  ;
041D2A DD 77 00    5075  BYTE_:			LD      (IX),A			; Write a byte out
041D2D DD 23       5076  			INC     IX
041D2F B7          5077  			OR      A
041D30 C9          5078  			RET
041D31             5079  ;
041D31 FD 7E 00    5080  OFFSET_EX:			LD      A,(IY)
041D34 FE 29       5081  			CP      ')'
041D36 21 00 00 00 5082  			LD      HL,0
041D3A C8          5083  			RET     Z
041D3B CD ED 1D 04 5084  NUMBER:			CALL    SKIP
041D3F C5          5085  			PUSH    BC
041D40 D5          5086  			PUSH    DE
041D41 DD E5       5087  			PUSH    IX
041D43 CD 0F 03 04 5088  			CALL    EXPRI
041D47 DD E1       5089  			POP     IX
041D49 D9          5090  			EXX
041D4A D1          5091  			POP     DE
041D4B C1          5092  			POP     BC
041D4C 7D          5093  			LD      A,L
041D4D B7          5094  			OR      A
041D4E C9          5095  			RET
041D4F             5096  ;
041D4F CD 09 1D 04 5097  REG:			CALL    OPND
041D53 D8          5098  			RET     C
041D54 78          5099  			LD      A,B
041D55 E6 3F       5100  			AND     3FH
041D57 FE 08       5101  			CP      8
041D59 3F          5102  			CCF
041D5A C9          5103  			RET
041D5B             5104  ;
041D5B CD 4F 1D 04 5105  REGLO:			CALL    REG
041D5F D8          5106  			RET     C
041D60 18 33       5107  			JR      ORC
041D62             5108  ;
041D62 CD 4F 1D 04 5109  REGHI:			CALL    REG
041D66 D8          5110  			RET     C
041D67 18 29       5111  			JR      SHL3
041D69             5112  ;
041D69 CD 09 1D 04 5113  COND_:			CALL    OPND
041D6D D8          5114  			RET     C
041D6E 78          5115  			LD      A,B
041D6F E6 1F       5116  			AND     1FH
041D71 D6 10       5117  			SUB     16
041D73 30 1D       5118  			JR      NC,SHL3
041D75 FE F1       5119  			CP      -15
041D77 37          5120  			SCF
041D78 C0          5121  			RET     NZ
041D79 3E 03       5122  			LD      A,3
041D7B 18 15       5123  			JR      SHL3
041D7D             5124  ;
041D7D CD 09 1D 04 5125  PAIR_EX:			CALL    OPND
041D81 D8          5126  			RET     C
041D82 78          5127  PAIR1_EX:			LD      A,B
041D83 E6 0F       5128  			AND     0FH
041D85 D6 08       5129  			SUB     8
041D87 D8          5130  			RET     C
041D88 18 08       5131  			JR      SHL3
041D8A             5132  ;
041D8A CD 3B 1D 04 5133  BIT_:			CALL    NUMBER
041D8E FE 08       5134  			CP      8
041D90 3F          5135  			CCF
041D91 D8          5136  			RET     C
041D92 07          5137  SHL3:			RLCA
041D93 07          5138  			RLCA
041D94 07          5139  			RLCA
041D95 B1          5140  ORC:			OR      C
041D96 4F          5141  			LD      C,A
041D97 C9          5142  			RET
041D98             5143  ;
041D98 21 52 20 04 5144  LDOP:			LD      HL,LDOPS
041D9C             5145  
041D9C             5146  ;
041D9C             5147  ; Look up a value in a table
041D9C             5148  ; Parameters:
041D9C             5149  ; - IY: Address of the assembly language line in the BASIC program area
041D9C             5150  ; - HL: Address of the table
041D9C             5151  ; Returns:
041D9C             5152  ; - B: The operand code
041D9C             5153  ; - F: Carry set if not found
041D9C             5154  ;
041D9C CD ED 1D 04 5155  FIND:			CALL    SKIP			; Skip delimiters
041DA0             5156  ;
041DA0 06 00       5157  EXIT_:			LD      B,0			; Set B to 0
041DA2 37          5158  			SCF				; Set the carry flag
041DA3 C8          5159  			RET     Z			; Returns if Z
041DA4             5160  ;
041DA4 FE DD       5161  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041DA6 28 04       5162  			JR      Z,FIND0
041DA8 FE 85       5163  			CP      TOR+1			; Special case for tokens AND and OR
041DAA 3F          5164  			CCF
041DAB D8          5165  			RET     C
041DAC 7E          5166  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DAD B7          5167  			OR      A
041DAE 28 F0       5168  			JR      Z,EXIT_			; Exit
041DB0 FD AE 00    5169  			XOR     (IY)
041DB3 E6 5F       5170  			AND     01011111B
041DB5 28 09       5171  			JR      Z,FIND2
041DB7 CB 7E       5172  FIND1:			BIT     7,(HL)
041DB9 23          5173  			INC     HL
041DBA 28 FB       5174  			JR      Z,FIND1
041DBC 23          5175  			INC     HL
041DBD 04          5176  			INC     B
041DBE 18 EC       5177  			JR      FIND0
041DC0             5178  ;
041DC0 FD E5       5179  FIND2:			PUSH    IY
041DC2 CB 7E       5180  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DC4 FD 23       5181  			INC     IY
041DC6 23          5182  			INC     HL
041DC7 20 11       5183  			JR      NZ,FIND5		; Yes
041DC9 BE          5184  			CP      (HL)
041DCA CC EC 1D 04 5185  			CALL    Z,SKIP0
041DCE 7E          5186  			LD      A,(HL)
041DCF FD AE 00    5187  			XOR     (IY)
041DD2 E6 5F       5188  			AND     01011111B
041DD4 28 EC       5189  			JR      Z,FIND3
041DD6 FD E1       5190  FIND4:			POP     IY
041DD8 18 DD       5191  			JR      FIND1
041DDA             5192  ;
041DDA CD 98 17 04 5193  FIND5:			CALL    DELIM			; Is it a delimiter?
041DDE C4 01 1E 04 5194  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DE2 C4 FB 1D 04 5195  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DE6 20 EE       5196  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DE8             5197  ;
041DE8 78          5198  FIND6:			LD      A,B			; At this point we have a token
041DE9 46          5199  			LD      B,(HL)			; Fetch the token type code
041DEA E1          5200  			POP     HL			; Restore the stack
041DEB C9          5201  			RET
041DEC             5202  ;
041DEC 23          5203  SKIP0:			INC     HL
041DED CD 98 17 04 5204  SKIP:			CALL    DELIM			; Is it a delimiter?
041DF1 C0          5205  			RET     NZ			; No, so return
041DF2 CD A4 17 04 5206  			CALL    TERM			; Is it a terminator?
041DF6 C8          5207  			RET     Z			; Yes, so return
041DF7 FD 23       5208  			INC     IY			; Increment the basic program counter
041DF9 18 F2       5209  			JR      SKIP			; And loop
041DFB             5210  ;
041DFB FE 2B       5211  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DFD C8          5212  			RET     Z
041DFE FE 2D       5213  			CP      '-'
041E00 C9          5214  			RET
041E01             5215  ;
041E01 FE 2E       5216  DOT:			CP	'.'			; Check if it is a dot character
041E03 C9          5217  			RET
041E04             5218  ; Z80 opcode list
041E04             5219  ;
041E04             5220  ; Group 0: (15 opcodes)
041E04             5221  ; Trivial cases requiring no computation
041E04             5222  ;
041E04 4E 4F 50 00 5223  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E08 52 4C 43 41 5224  			DB	"RLC","A"+80H,07h
       07          
041E0D 45 58 00 41 5225  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041E17 52 52 43 41 5226  			DB	"RRC","A"+80H,0FH
       0F          
041E1C 52 4C 41 17 5227  			DB	"RL","A"+80H,17H
041E20 52 52 41 1F 5228  			DB	"RR","A"+80H,1FH
041E24 44 41 41 27 5229  			DB	"DA","A"+80H,27H
041E28 43 50 4C 2F 5230  			DB	"CP","L"+80H,2FH
041E2C 53 43 46 37 5231  			DB	"SC","F"+80H,37H
041E30 43 43 46 3F 5232  			DB	"CC","F"+80H,3FH
041E34 48 41 4C 54 5233  			DB	"HAL","T"+80H,76H
       76          
041E39 45 58 58 D9 5234  			DB	"EX","X"+80H,D9H
041E3D 45 58 00 44 5235  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
041E46 44 49 F3    5236  			DB	"D","I"+80H,F3H
041E49 45 49 FB    5237  			DB	"E","I"+80H,FBH
041E4C             5238  ;
041E4C             5239  ; Group 1: (53 opcodes)
041E4C             5240  ; As Group 0, but with an ED prefix
041E4C             5241  ;
041E4C 4E 45 47 44 5242  			DB	"NE","G"+80H,44H	; 0Fh
041E50 49 4D 00 30 5243  			DB	"IM",0,"0"+80H,46H
       46          
041E55 52 45 54 4E 5244  			DB	"RET","N"+80H,45H
       45          
041E5A 4D 4C 54 00 5245  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
041E61 52 45 54 49 5246  			DB	"RET","I"+80H,4DH
       4D          
041E66 49 4D 00 31 5247  			DB	"IM",0,"1"+80H,56H
       56          
041E6B 4D 4C 54 00 5248  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
041E72 49 4D 00 32 5249  			DB	"IM",0,"2"+80H,5EH
       5E          
041E77 52 52 44 67 5250  			DB	"RR","D"+80H,67H
041E7B 4D 4C 54 00 5251  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
041E82 4C 44 00 4D 5252  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
041E8A 4C 44 00 41 5253  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
041E92 52 4C 44 6F 5254  			DB	"RL","D"+80H,6FH
041E96 53 4C 50 76 5255  			DB	"SL","P"+80H,76H
041E9A 4D 4C 54 00 5256  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041EA1 53 54 4D 49 5257  			DB	"STMI","X"+80H,7DH
       58 7D       
041EA7 52 53 4D 49 5258  			DB	"RSMI","X"+80H,7EH
       58 7E       
041EAD 49 4E 49 4D 5259  			DB	"INI","M"+80H,82H
       82          
041EB2 4F 54 49 4D 5260  			DB	"OTI","M"+80H,83H
       83          
041EB7 49 4E 49 32 5261  			DB	"INI","2"+80H,84H
       84          
041EBC 49 4E 44 4D 5262  			DB	"IND","M"+80H,8AH
       8A          
041EC1 4F 54 44 4D 5263  			DB	"OTD","M"+80H,8BH
       8B          
041EC6 49 4E 44 32 5264  			DB	"IND","2"+80H,8CH
       8C          
041ECB 49 4E 49 4D 5265  			DB	"INIM","R"+80H,92H
       52 92       
041ED1 4F 54 49 4D 5266  			DB	"OTIM","R"+80H,93H
       52 93       
041ED7 49 4E 49 32 5267  			DB	"INI2","R"+80H,94H
       52 94       
041EDD 49 4E 44 4D 5268  			DB	"INDM","R"+80H,9AH
       52 9A       
041EE3 4F 54 44 4D 5269  			DB	"OTDM","R"+80H,9BH
       52 9B       
041EE9 49 4E 44 32 5270  			DB	"IND2","R"+80H,9CH
       52 9C       
041EEF 4C 44 49 A0 5271  			DB	"LD","I"+80H,A0H
041EF3 43 50 49 A1 5272  			DB	"CP","I"+80H,A1H
041EF7 49 4E 49 A2 5273  			DB	"IN","I"+80H,A2H
041EFB 4F 55 54 49 5274  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041F01 4F 55 54 49 5275  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041F06 4C 44 44 A8 5276  			DB	"LD","D"+80H,A8H
041F0A 43 50 44 A9 5277  			DB	"CP","D"+80H,A9H
041F0E 49 4E 44 AA 5278  			DB	"IN","D"+80H,AAH
041F12 4F 55 54 44 5279  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041F18 4F 55 54 44 5280  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
041F1D 4C 44 49 52 5281  			DB	"LDI","R"+80H,B0H
       B0          
041F22 43 50 49 52 5282  			DB	"CPI","R"+80H,B1H
       B1          
041F27 49 4E 49 52 5283  			DB	"INI","R"+80H,B2H
       B2          
041F2C 4F 54 49 52 5284  			DB	"OTI","R"+80H,B3H
       B3          
041F31 4F 54 49 32 5285  			DB	"OTI2","R"+80H,B4H
       52 B4       
041F37 4C 44 44 52 5286  			DB	"LDD","R"+80H,B8H
       B8          
041F3C 43 50 44 52 5287  			DB	"CPD","R"+80H,B9H
       B9          
041F41 49 4E 44 52 5288  			DB	"IND","R"+80H,BAH
       BA          
041F46 4F 54 44 52 5289  			DB	"OTD","R"+80H,BBH
       BB          
041F4B 4F 54 44 32 5290  			DB	"OTD2","R"+80H,BCH
       52 BC       
041F51 49 4E 49 52 5291  			DB	"INIR","X"+80H,C2H
       58 C2       
041F57 4F 54 49 52 5292  			DB	"OTIR","X"+80H,C3H
       58 C3       
041F5D 49 4E 44 52 5293  			DB	"INDR","X"+80H,CAH
       58 CA       
041F63 4F 54 44 52 5294  			DB	"OTDR","X"+80H,CBH
       58 CB       
041F69             5295  ;
041F69             5296  ; Group 2: (3 opcodes)
041F69             5297  ;
041F69 42 49 54 40 5298  			DB	"BI","T"+80H,40H	; 44h
041F6D 52 45 53 80 5299  			DB	"RE","S"+80H,80H
041F71 53 45 54 C0 5300  			DB	"SE","T"+80H,C0H
041F75             5301  ;
041F75             5302  ; Group 3: (7 opcodes)
041F75             5303  ;
041F75 52 4C 43 00 5304  			DB	"RL","C"+80H,00H	; 47h
041F79 52 52 43 08 5305  			DB	"RR","C"+80H,08H
041F7D 52 4C 10    5306  			DB	"R","L"+80H,10H
041F80 52 52 18    5307  			DB	"R","R"+80H,18H
041F83 53 4C 41 20 5308  			DB	"SL","A"+80H,20H
041F87 53 52 41 28 5309  			DB	"SR","A"+80H,28H
041F8B 53 52 4C 38 5310  			DB	"SR","L"+80H,38H
041F8F             5311  ;
041F8F             5312  ; Group 4: (3 opcodes)
041F8F             5313  ;
041F8F 50 4F 50 C1 5314  			DB	"PO","P"+80H,C1H	; 4Eh
041F93 50 55 53 48 5315  			DB	"PUS","H"+80H,C5H
       C5          
041F98 45 58 00 28 5316  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
041F9F             5317  ;
041F9F             5318  ; Group 5: (7 opcodes)
041F9F             5319  ;
041F9F 53 55 42 90 5320  			DB	"SU","B"+80H,90H	; 51h
041FA3 41 4E 44 A0 5321  			DB	"AN","D"+80H,A0H
041FA7 58 4F 52 A8 5322  			DB	"XO","R"+80H,A8H
041FAB 4F 52 B0    5323  			DB	"O","R"+80H,B0H
041FAE 43 50 B8    5324  			DB	"C","P"+80H,B8H
041FB1 80 A0       5325  			DB	TAND,A0H		; 56h TAND: Tokenised AND
041FB3 84 B0       5326  			DB	TOR,B0H			; 57h TOR: Tokenised OR
041FB5             5327  ;
041FB5             5328  ; Group 6 (3 opcodes)
041FB5             5329  ;
041FB5 41 44 44 80 5330  			DB	"AD","D"+80H,80H	; 58h
041FB9 41 44 43 88 5331  			DB	"AD","C"+80H,88H
041FBD 53 42 43 98 5332  			DB	"SB","C"+80H,98H
041FC1             5333  ;
041FC1             5334  ; Group 7: (2 opcodes)
041FC1             5335  ;
041FC1 49 4E 43 04 5336  			DB	"IN","C"+80H,04H	; 5Bh
041FC5 44 45 43 05 5337  			DB	"DE","C"+80H,05H
041FC9             5338  ;
041FC9             5339  ; Group 8: (2 opcodes)
041FC9             5340  ;
041FC9 49 4E 30 00 5341  			DB	"IN","0"+80H,00H	; 5Dh
041FCD 4F 55 54 30 5342  			DB	"OUT","0"+80H,01H
       01          
041FD2             5343  ;
041FD2             5344  ; Group 9: (1 opcode)
041FD2             5345  ;
041FD2 49 4E 40    5346  			DB	"I","N"+80H,40H		; 5Fh
041FD5             5347  ;
041FD5             5348  ; Group 10: (1 opcode)
041FD5             5349  ;
041FD5 4F 55 54 41 5350  			DB	"OU","T"+80H,41H	; 60h
041FD9             5351  ;
041FD9             5352  ; Group 11: (2 opcodes)
041FD9             5353  ;
041FD9 4A 52 20    5354  			DB	"J","R"+80H,20H		; 61h
041FDC 44 4A 4E 5A 5355  			DB	"DJN","Z"+80H,10H
       10          
041FE1             5356  ;
041FE1             5357  ; Group 12: (1 opcode)
041FE1             5358  ;
041FE1 4A 50 C2    5359  			DB	"J","P"+80H,C2H		; 63h
041FE4             5360  ;
041FE4             5361  ; Group 13: (1 opcode)
041FE4             5362  ;
041FE4 43 41 4C 4C 5363  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041FE9             5364  ;
041FE9             5365  ; Group 14: (1 opcode)
041FE9             5366  ;
041FE9 52 53 54 C7 5367  			DB	"RS","T"+80H,C7H	; 65h
041FED             5368  ;
041FED             5369  ; Group 15: (1 opcode)
041FED             5370  ;
041FED 52 45 54 C0 5371  			DB	"RE","T"+80H,C0H	; 66h
041FF1             5372  ;
041FF1             5373  ; Group 16: (1 opcode)
041FF1             5374  ;
041FF1 4C 44 40    5375  			DB	"L","D"+80H,40H		; 67h
041FF4             5376  ;
041FF4             5377  ; Group 17: (1 opcode)
041FF4             5378  ;
041FF4 54 53 54 04 5379  			DB	"TS","T"+80H,04H	; 68h
041FF8             5380  
041FF8             5381  ;
041FF8             5382  ; Assembler Directives
041FF8             5383  ;
041FF8 4F 50 54 00 5384  			DB	"OP","T"+80H,00H	; 69h OPT
041FFC 41 44 4C 00 5385  			DB	"AD","L"+80H,00H	; 6Ah ADL
042000             5386  ;
042000 5D 42 00    5387  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
042003 5D 57 00    5388  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042006 5D 4C 00    5389  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042009 5D 4D 00    5390  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
04200C             5391  ;
04200C 00          5392  			DB	0
04200D             5393  ;
04200D             5394  ; Operands
04200D             5395  ;
04200D 42 00       5396  OPRNDS:			DB	"B"+80H, 00H
04200F 43 01       5397  			DB	"C"+80H, 01H
042011 44 02       5398  			DB	"D"+80H, 02H
042013 45 03       5399  			DB	"E"+80H, 03H
042015 48 04       5400  			DB	"H"+80H, 04H
042017 4C 05       5401  			DB	"L"+80H, 05H
042019 28 48 4C 06 5402  			DB	"(H","L"+80H,06H
04201D 41 07       5403  			DB	"A"+80H, 07H
04201F 28 49 58 86 5404  			DB	"(I","X"+80H,86H
042023 28 49 59 C6 5405  			DB	"(I","Y"+80H,C6H
042027             5406  ;
042027 42 43 08    5407  			DB	"B","C"+80H,08H
04202A 44 45 0A    5408  			DB	"D","E"+80H,0AH
04202D 48 4C 0C    5409  			DB	"H","L"+80H,0CH
042030 49 58 8C    5410  			DB	"I","X"+80H,8CH
042033 49 59 CC    5411  			DB	"I","Y"+80H,CCH
042036 41 46 0E    5412  			DB	"A","F"+80H,0EH
042039 53 50 0E    5413  			DB	"S","P"+80H,0EH
04203C             5414  ;
04203C 4E 5A 10    5415  			DB	"N","Z"+80H,10H
04203F 5A 11       5416  			DB	"Z"+80H,11H
042041 4E 43 12    5417  			DB	"N","C"+80H,12H
042044 50 4F 14    5418  			DB	"P","O"+80H,14H
042047 50 45 15    5419  			DB	"P","E"+80H,15H
04204A 50 16       5420  			DB	"P"+80H,16H
04204C 4D 17       5421  			DB	"M"+80H,17H
04204E             5422  ;
04204E 28 43 20    5423  			DB	"(","C"+80H,20H
042051             5424  ;
042051 00          5425  			DB	0
042052             5426  ;
042052             5427  ; Load operations
042052             5428  ;
042052 49 00 41 47 5429  LDOPS:			DB	"I",0,"A"+80H,47H
042056 52 00 41 4F 5430  			DB	"R",0,"A"+80H,4FH
04205A 41 00 49 57 5431  			DB	"A",0,"I"+80H,57H
04205E 41 00 52 5F 5432  			DB	"A",0,"R"+80H,5FH
042062 28 42 43 00 5433  			DB	"(BC",0,"A"+80H,02h
       41 02       
042068 28 44 45 00 5434  			DB	"(DE",0,"A"+80H,12H
       41 12       
04206E 41 00 28 42 5435  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
042074 41 00 28 44 5436  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
04207A             5437  ;
04207A 00          5438  			DB	0
04207B             5439  ;
04207B             5440  ; eZ80 addressing mode suffixes
04207B             5441  ;
04207B             5442  ; Fully qualified suffixes
04207B             5443  ;
04207B 4C 49 53 49 5444  EZ80SFS_1:		DB	"LI","S"+80H,49H
04207F 53 49 4C 52 5445  			DB	"SI","L"+80H,52H
042083 53 49 53 40 5446  EZ80SFS_2:		DB	"SI","S"+80H,40H
042087 4C 49 4C 5B 5447  			DB	"LI","L"+80H,5BH
04208B             5448  ;
04208B 00          5449  			DB	0
04208C             5450  ;
04208C             5451  ; Shortcuts when ADL mode is 0
04208C             5452  ;
04208C 53 40       5453  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
04208E 4C 49       5454  			DB	"L"+80H,49H		; Equivalent to .LIS
042090 49 53 40    5455  			DB	"I","S"+80H,40H		; Equivalent to .SIS
042093 49 4C 52    5456  			DB	"I","L"+80H,52H		; Equivalent to .SIL
042096             5457  ;
042096 00          5458  			DB	0
042097             5459  ;
042097             5460  ; Shortcuts when ADL mode is 1
042097             5461  ;
042097 53 52       5462  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042099 4C 5B       5463  			DB	"L"+80H,5BH		; Equivalent to .LIL
04209B 49 53 49    5464  			DB	"I","S"+80H,49H		; Equivalent to .LIS
04209E 49 4C 5B    5465  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0420A1             5466  ;
0420A1 00          5467  			DB	0
0420A2             5468  ;
0420A2             5469  ; .LIST
0420A2             5470  ;
0420A2             5471  ; already defined in equs.inc
0420A2             5472  ; LF:			EQU     0AH
0420A2             5473  ; CR:			EQU     0DH; --- End exec.asm ---
0420A2             5474  
0420A2             5475  ; --- Begin fpp.asm ---
0420A2             5476  ;
0420A2             5477  ; Title:	BBC Basic Interpreter - Z80 version
0420A2             5478  ;		Z80 Floating Point Package
0420A2             5479  ; Author:	(C) Copyright  R.T.Russell  1986
0420A2             5480  ; Modified By:	Dean Belfield
0420A2             5481  ; Created:	03/05/2022
0420A2             5482  ; Last Updated:	07/06/2023
0420A2             5483  ;
0420A2             5484  ; Modinfo:
0420A2             5485  ; 26/10/1986:	Version 0.0
0420A2             5486  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0420A2             5487  ; 12/05/2023:	Modified by Dean Belfield
0420A2             5488  ; 07/06/2023:	Modified to run in ADL mode
0420A2             5489  
0420A2             5490  			; .ASSUME	ADL = 1
0420A2             5491  
0420A2             5492  			; SEGMENT CODE
0420A2             5493  
0420A2             5494  			; XDEF	FPP
0420A2             5495  			; XDEF	DLOAD5
0420A2             5496  			; XDEF	DLOAD5_SPL
0420A2             5497  ;
0420A2             5498  ;BINARY FLOATING POINT REPRESENTATION:
0420A2             5499  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0420A2             5500  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0420A2             5501  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0420A2             5502  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0420A2             5503  ;
0420A2             5504  ;BINARY INTEGER REPRESENTATION:
0420A2             5505  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0420A2             5506  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0420A2             5507  ;
0420A2             5508  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0420A2             5509  ;                            EXPONENT - C
0420A2             5510  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0420A2             5511  ;                               EXPONENT - B
0420A2             5512  
0420A2             5513  ;
0420A2             5514  ;Error codes:
0420A2             5515  ;
0420A2             5516  
0420A2             5517  BADOP:			EQU     1               ;Bad operation code
0420A2             5518  DIVBY0:			EQU     18              ;Division by zero
0420A2             5519  TOOBIG_FP:			EQU     20              ;Too big
0420A2             5520  NGROOT:			EQU     21              ;Negative root
0420A2             5521  LOGRNG:			EQU     22              ;Log range
0420A2             5522  ACLOST:			EQU     23              ;Accuracy lost
0420A2             5523  EXPRNG:			EQU     24              ;Exp range
0420A2             5524  ;
0420A2             5525  ;Call entry and despatch code:
0420A2             5526  ;
0420A2 FD E5       5527  FPP:			PUSH    IY              ;Save IY
0420A4 FD 21 00 00 5528          		LD      IY,0
       00          
0420A9 FD 39       5529          		ADD     IY,SP           ;Save SP in IY
0420AB CD BB 20 04 5530          		CALL    OP              ;Perform operation
0420AF BF          5531          		CP      A               ;Good return (Z, NC)
0420B0 FD E1       5532  EXIT_FP_:			POP     IY              ;Restore IY
0420B2 C9          5533          		RET                     ;Return to caller
0420B3             5534  ;
0420B3             5535  ;Error exit:
0420B3             5536  ;
0420B3 3E 01       5537  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420B5 FD F9       5538  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420B7 B7          5539          		OR      A               ;Set NZ
0420B8 37          5540          		SCF                     ;Set C
0420B9 18 F5       5541          		JR      EXIT_FP_
0420BB             5542  ;
0420BB             5543  ;Perform operation or function:
0420BB             5544  ;
0420BB             5545  ; OP:			CP      (RTABLE-DTABLE)/3
0420BB FE 2A       5546  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420BD             5547  
0420BD 30 F4       5548          		JR      NC,BAD_FP
0420BF             5549          		; CP      (FTABLE-DTABLE)/3
0420BF FE 10       5550  				CP      FTABLE-DTABLE/3 ; ditto
0420C1 30 08       5551          		JR      NC,DISPAT_FP
0420C3 08          5552          		EX      AF,AF'
0420C4 78          5553          		LD      A,B
0420C5 B1          5554          		OR      C               ;Both integer?
0420C6 C4 CE 2B 04 5555          		CALL    NZ,FLOATA       ;No, so float both
0420CA 08          5556          		EX      AF,AF'
0420CB E5          5557  DISPAT_FP:			PUSH    HL
0420CC 21 DE 20 04 5558          		LD      HL,DTABLE
0420D0 C5          5559          		PUSH    BC
0420D1 01 03 00 00 5560  			LD	BC, 3		; C = 3
0420D5 47          5561  			LD	B, A 		; B = op-code
0420D6 ED 4C       5562  			MLT 	BC 		;BC = op-code * 3
0420D8 09          5563  			ADD	HL, BC 		;Add to table base
0420D9 ED 27       5564  			LD	HL, (HL)	;Get the routine address (24-bit)
0420DB             5565  
0420DB             5566  ;        		ADD     A, A            ;A = op-code * 2
0420DB             5567  ;        		LD      C,A
0420DB             5568  ;        		LD      B,0             ;BC = op-code * 2
0420DB             5569  ;        		ADD     HL,BC
0420DB             5570  ;        		LD      A,(HL)          ;Get low byte
0420DB             5571  ;        		INC     HL
0420DB             5572  ;        		LD      H,(HL)          ;Get high byte
0420DB             5573  ;        		LD      L,A
0420DB             5574  
0420DB C1          5575          		POP     BC
0420DC E3          5576          		EX      (SP),HL
0420DD C9          5577          		RET                     ;Off to routine
0420DE             5578  ;
0420DE             5579  ;Despatch table:
0420DE             5580  ;
0420DE 90 21 04    5581  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420E1 FE 21 04    5582          		DW24  IBDIV           ;DIV
0420E4 A3 21 04    5583          		DW24  IEOR            ;EOR
0420E7 C9 21 04    5584          		DW24  IMOD            ;MOD
0420EA B6 21 04    5585          		DW24  IOR             ;OR
0420ED 84 24 04    5586          		DW24  ILE             ;<=
0420F0 93 24 04    5587          		DW24  INE             ;<>
0420F3 77 24 04    5588          		DW24  IGE             ;>=
0420F6 5C 24 04    5589          		DW24  ILT             ;<
0420F9 A0 24 04    5590          		DW24  IEQ             ;=
0420FC EC 22 04    5591          		DW24  IMUL            ;*
0420FF 27 22 04    5592          		DW24  IADD            ;+
042102 69 24 04    5593          		DW24  IGT             ;>
042105 0E 22 04    5594          		DW24  ISUB            ;-
042108 A3 23 04    5595          		DW24  IPOW            ;^
04210B 99 22 04    5596          		DW24  IDIV            ;/
04210E             5597  ;
04210E             5598  FTABLE:
04210E B2 24 04    5599  				DW24  ABSV_FP            ;ABS
042111 98 28 04    5600          		DW24  ACS_FP             ;ACS
042114 D6 27 04    5601          		DW24  ASN_FP             ;ASN
042117 06 28 04    5602          		DW24  ATN_FP             ;ATN
04211A D1 25 04    5603          		DW24  COS_FP             ;COS
04211D E0 24 04    5604          		DW24  DEG_FP             ;DEG
042120 8D 26 04    5605          		DW24  EXP_FP             ;EXP
042123 34 25 04    5606          		DW24  INT_FP_            ;INT
042126 2B 27 04    5607          		DW24  LN_FP              ;LN
042129 C0 27 04    5608          		DW24  LOG_FP             ;LOG
04212C BE 24 04    5609          		DW24  NOTK_FP            ;NOT
04212F EA 24 04    5610          		DW24  RAD_FP             ;RAD
042132 05 25 04    5611          		DW24  SGN_FP             ;SGN
042135 DE 25 04    5612          		DW24  SIN_FP             ;SIN
042138 4D 25 04    5613          		DW24  SQR_FP             ;SQR
04213B AB 25 04    5614          		DW24  TAN_FP             ;TAN
04213E             5615  ;
04213E 5B 2C 04    5616  		        DW24  ZERO_FP            ;ZERO
042141 66 26 04    5617          		DW24  FONE_FP            ;FONE
042144 A5 24 04    5618          		DW24  TRUE_FP            ;TRUE
042147 D2 24 04    5619          		DW24  PI_FP              ;PI
04214A             5620  ;
04214A 19 25 04    5621  		        DW24  VAL_FP             ;VAL
04214D A1 28 04    5622          		DW24  STR_FP             ;STR$
042150             5623  ;
042150 02 2B 04    5624          		DW24  SFIX_FP            ;FIX
042153 DE 2B 04    5625          		DW24  SFLOAT_FP          ;FLOAT
042156             5626  ;
042156 2C 2C 04    5627  		        DW24  FTEST_FP           ;TEST
042159 3E 2C 04    5628          		DW24  FCOMP_FP           ;COMPARE
04215C             5629  ;
04215C 8C 21 04    5630  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04215F FA 21 04    5631          		DW24  FBDIV           ;DIV
042162 9F 21 04    5632          		DW24  FEOR            ;EOR
042165 C5 21 04    5633          		DW24  FMOD            ;MOD
042168 B2 21 04    5634          		DW24  FFOR             ;OR
04216B 7E 24 04    5635          		DW24  FLE             ;<=
04216E 8D 24 04    5636          		DW24  FNE             ;<>
042171 71 24 04    5637          		DW24  FGE             ;>=
042174 56 24 04    5638          		DW24  FLT             ;<
042177 9A 24 04    5639          		DW24  FEQ             ;=
04217A 46 23 04    5640          		DW24  FMUL            ;*
04217D 34 22 04    5641          		DW24  FADD            ;+
042180 63 24 04    5642          		DW24  FGT             ;>
042183 1B 22 04    5643          		DW24  FSUB            ;-
042186 23 24 04    5644          		DW24  FPOW            ;^
042189 9D 22 04    5645          		DW24  FDIV            ;/
04218C             5646  ;
04218C             5647  ;       PAGE
04218C             5648  ;
04218C             5649  ;ARITHMETIC AND LOGICAL OPERATORS:
04218C             5650  ;All take two arguments, in HLH'L'C & DED'E'B.
04218C             5651  ;Output in HLH'L'C
04218C             5652  ;All registers except IX, IY destroyed.
04218C             5653  ; (N.B. FPOW destroys IX).
04218C             5654  ;
04218C             5655  ;FAND - Floating-point AND.
04218C             5656  ;IAND - Integer AND.
04218C             5657  ;
04218C CD F6 2A 04 5658  FAND:			CALL    FIX2
042190 7C          5659  IAND:			LD      A,H
042191 A2          5660          		AND     D
042192 67          5661          		LD      H,A
042193 7D          5662          		LD      A,L
042194 A3          5663          		AND     E
042195 6F          5664          		LD      L,A
042196 D9          5665          		EXX
042197 7C          5666          		LD      A,H
042198 A2          5667          		AND     D
042199 67          5668          		LD      H,A
04219A 7D          5669          		LD      A,L
04219B A3          5670          		AND     E
04219C 6F          5671          		LD      L,A
04219D D9          5672          		EXX
04219E C9          5673          		RET
04219F             5674  ;
04219F             5675  ;FEOR - Floating-point exclusive-OR.
04219F             5676  ;IEOR - Integer exclusive-OR.
04219F             5677  ;
04219F CD F6 2A 04 5678  FEOR:			CALL    FIX2
0421A3 7C          5679  IEOR:			LD      A,H
0421A4 AA          5680          		XOR     D
0421A5 67          5681          		LD      H,A
0421A6 7D          5682          		LD      A,L
0421A7 AB          5683          		XOR     E
0421A8 6F          5684          		LD      L,A
0421A9 D9          5685          		EXX
0421AA 7C          5686          		LD      A,H
0421AB AA          5687          		XOR     D
0421AC 67          5688          		LD      H,A
0421AD 7D          5689          		LD      A,L
0421AE AB          5690          		XOR     E
0421AF 6F          5691          		LD      L,A
0421B0 D9          5692          		EXX
0421B1 C9          5693          		RET
0421B2             5694  ;
0421B2             5695  ;FOR - Floating-point OR.
0421B2             5696  ;IOR - Integer OR.
0421B2             5697  ;
0421B2 CD F6 2A 04 5698  FFOR:			CALL    FIX2
0421B6 7C          5699  IOR:			LD      A,H
0421B7 B2          5700          		OR      D
0421B8 67          5701          		LD      H,A
0421B9 7D          5702          		LD      A,L
0421BA B3          5703          		OR      E
0421BB 6F          5704          		LD      L,A
0421BC D9          5705          		EXX
0421BD 7C          5706          		LD      A,H
0421BE B2          5707          		OR      D
0421BF 67          5708          		LD      H,A
0421C0 7D          5709          		LD      A,L
0421C1 B3          5710          		OR      E
0421C2 6F          5711          		LD      L,A
0421C3 D9          5712          		EXX
0421C4 C9          5713          		RET
0421C5             5714  ;
0421C5             5715  ;FMOD - Floating-point remainder.
0421C5             5716  ;IMOD - Integer remainder.
0421C5             5717  ;
0421C5 CD F6 2A 04 5718  FMOD:			CALL    FIX2
0421C9 7C          5719  IMOD:			LD      A,H
0421CA AA          5720          		XOR     D               ;DIV RESULT SIGN
0421CB CB 7C       5721          		BIT     7,H
0421CD 08          5722          		EX      AF,AF'
0421CE CB 7C       5723          		BIT     7,H
0421D0 C4 12 2B 04 5724          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421D4 CD 0F 2C 04 5725          		CALL    SWAP_FP
0421D8 CB 7C       5726          		BIT     7,H
0421DA C4 12 2B 04 5727          		CALL    NZ,NEGATE
0421DE 44          5728          		LD      B,H
0421DF 4D          5729          		LD      C,L
0421E0 21 00 00 00 5730          		LD      HL,0
0421E4 D9          5731          		EXX
0421E5 44          5732          		LD      B,H
0421E6 4D          5733          		LD      C,L
0421E7 21 00 00 00 5734          		LD      HL,0
0421EB 3E DF       5735          		LD      A,-33
0421ED CD 9C 2D 04 5736          		CALL    DIVA            ;DIVIDE
0421F1 D9          5737          		EXX
0421F2 0E 00       5738          		LD      C,0             ;INTEGER MARKER
0421F4 08          5739          		EX      AF,AF'
0421F5 C8          5740          		RET     Z
0421F6 C3 12 2B 04 5741          		JP      NEGATE
0421FA             5742  ;
0421FA             5743  ;BDIV - Integer division.
0421FA             5744  ;
0421FA CD F6 2A 04 5745  FBDIV:			CALL    FIX2
0421FE CD C9 21 04 5746  IBDIV:			CALL    IMOD
042202 B7          5747          		OR      A
042203 CD 0F 2C 04 5748          		CALL    SWAP_FP
042207 0E 00       5749          		LD      C,0
042209 F0          5750          		RET     P
04220A C3 12 2B 04 5751          		JP      NEGATE
04220E             5752  ;
04220E             5753  ;ISUB - Integer subtraction.
04220E             5754  ;FSUB - Floating point subtraction with rounding.
04220E             5755  ;
04220E CD AA 2C 04 5756  ISUB:			CALL    SUB_
042212 E0          5757          		RET     PO
042213 CD A2 2C 04 5758          		CALL    ADD_
042217 CD D2 2B 04 5759          		CALL    FLOAT2
04221B 7A          5760  FSUB:			LD      A,D
04221C EE 80       5761          		XOR     80H             ;CHANGE SIGN THEN ADD
04221E 57          5762          		LD      D,A
04221F 18 13       5763          		JR      FADD
042221             5764  ;
042221             5765  ;Reverse subtract.
042221             5766  ;
042221 7C          5767  RSUB:			LD      A,H
042222 EE 80       5768          		XOR     80H
042224 67          5769          		LD      H,A
042225 18 0D       5770          		JR      FADD
042227             5771  ;
042227             5772  ;IADD - Integer addition.
042227             5773  ;FADD - Floating point addition with rounding.
042227             5774  ;
042227 CD A2 2C 04 5775  IADD:			CALL    ADD_
04222B E0          5776          		RET     PO
04222C CD AA 2C 04 5777          		CALL    SUB_
042230 CD D2 2B 04 5778          		CALL    FLOAT2
042234 05          5779  FADD:			DEC     B
042235 04          5780          		INC     B
042236 C8          5781          		RET     Z               ;ARG 2 ZERO
042237 0D          5782          		DEC     C
042238 0C          5783          		INC     C
042239 CA 0F 2C 04 5784          		JP      Z,SWAP_FP          ;ARG 1 ZERO
04223D D9          5785          		EXX
04223E 01 00 00 00 5786          		LD      BC,0            ;INITIALISE
042242 D9          5787          		EXX
042243 7C          5788          		LD      A,H
042244 AA          5789          		XOR     D               ;XOR SIGNS
042245 F5          5790          		PUSH    AF
042246 78          5791          		LD      A,B
042247 B9          5792          		CP      C               ;COMPARE EXPONENTS
042248 DC 0F 2C 04 5793          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
04224C 78          5794          		LD      A,B
04224D CB FC       5795          		SET     7,H             ;IMPLIED 1
04224F C4 E3 2A 04 5796          		CALL    NZ,FIX          ;ALIGN
042253 F1          5797          		POP     AF
042254 7A          5798          		LD      A,D             ;SIGN OF LARGER
042255 CB FA       5799          		SET     7,D             ;IMPLIED 1
042257 FA 67 22 04 5800          		JP      M,FADD3         ;SIGNS DIFFERENT
04225B CD A2 2C 04 5801          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04225F DC 17 2C 04 5802          		CALL    C,DIV2          ;NORMALISE
042263 CB FC       5803          		SET     7,H
042265 18 0D       5804          		JR      FADD4
042267             5805  ;
042267 CD AA 2C 04 5806  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
04226B DC 2A 2B 04 5807          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04226F CD A9 2B 04 5808          		CALL    FLO48
042273 2F          5809          		CPL                     ;CHANGE RESULT SIGN
042274 D9          5810  FADD4:			EXX
042275 EB          5811          		EX      DE,HL
042276 21 00 80 00 5812          		LD      HL,8000H
04227A B7          5813          		OR      A               ;CLEAR CARRY
04227B 52 ED 42    5814          		SBC.S   HL,BC
04227E EB          5815          		EX      DE,HL
04227F D9          5816          		EXX
042280 CC 09 2C 04 5817          		CALL    Z,ODD           ;ROUND UNBIASSED
042284 DC F7 2B 04 5818          		CALL    C,ADD1_FP          ;ROUND UP
042288 DC 24 2C 04 5819          		CALL    C,INCC
04228C CB BC       5820          		RES     7,H
04228E 0D          5821          		DEC     C
04228F 0C          5822          		INC     C
042290 CA 5B 2C 04 5823          		JP      Z,ZERO_FP
042294 B7          5824          		OR      A               ;RESULT SIGNQ
042295 F0          5825          		RET     P               ;POSITIVE
042296 CB FC       5826          		SET     7,H             ;NEGATIVE
042298 C9          5827          		RET
042299             5828  ;
042299             5829  ;IDIV - Integer division.
042299             5830  ;FDIV - Floating point division with rounding.
042299             5831  ;
042299 CD D2 2B 04 5832  IDIV:			CALL    FLOAT2
04229D 05          5833  FDIV:			DEC     B               ;TEST FOR ZERO
04229E 04          5834          		INC     B
04229F 3E 12       5835          		LD      A,DIVBY0
0422A1 CA B5 20 04 5836          		JP      Z,ERROR_FP_         ;"Division by zero"
0422A5 0D          5837          		DEC     C               ;TEST FOR ZERO
0422A6 0C          5838          		INC     C
0422A7 C8          5839          		RET     Z
0422A8 7C          5840          		LD      A,H
0422A9 AA          5841          		XOR     D               ;CALC. RESULT SIGN
0422AA 08          5842          		EX      AF,AF'          ;SAVE SIGN
0422AB CB FA       5843          		SET     7,D             ;REPLACE IMPLIED 1's
0422AD CB FC       5844          		SET     7,H
0422AF C5          5845          		PUSH    BC              ;SAVE EXPONENTS
0422B0 42          5846          		LD      B,D             ;LOAD REGISTERS
0422B1 4B          5847          		LD      C,E
0422B2 11 00 00 00 5848          		LD      DE,0
0422B6 D9          5849          		EXX
0422B7 42          5850          		LD      B,D
0422B8 4B          5851          		LD      C,E
0422B9 11 00 00 00 5852          		LD      DE,0
0422BD 3E E0       5853          		LD      A,-32           ;LOOP COUNTER
0422BF CD 9C 2D 04 5854          		CALL    DIVA            ;DIVIDE
0422C3 D9          5855          		EXX
0422C4 CB 7A       5856          		BIT     7,D
0422C6 D9          5857          		EXX
0422C7 CC BB 2D 04 5858          		CALL    Z,DIVB          ;NORMALISE & INC A
0422CB EB          5859          		EX      DE,HL
0422CC D9          5860          		EXX
0422CD CB 38       5861          		SRL     B               ;DIVISOR/2
0422CF CB 19       5862          		RR      C
0422D1 B7          5863          		OR      A               ;CLEAR CARRY
0422D2 52 ED 42    5864          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422D5 3F          5865          		CCF
0422D6 EB          5866          		EX      DE,HL           ;RESULT IN HLH'L'
0422D7 CC 09 2C 04 5867          		CALL    Z,ODD           ;ROUND UNBIASSED
0422DB DC F7 2B 04 5868          		CALL    C,ADD1_FP          ;ROUND UP
0422DF C1          5869          		POP     BC              ;RESTORE EXPONENTS
0422E0 DC 24 2C 04 5870          		CALL    C,INCC
0422E4 1F          5871          		RRA                     ;LSB OF A TO CARRY
0422E5 79          5872          		LD      A,C             ;COMPUTE NEW EXPONENT
0422E6 98          5873          		SBC     A,B
0422E7 3F          5874          		CCF
0422E8 C3 89 23 04 5875          		JP      CHKOVF
0422EC             5876  ;
0422EC             5877  ;IMUL - Integer multiplication.
0422EC             5878  ;
0422EC 7C          5879  IMUL:			LD      A,H
0422ED AA          5880          		XOR     D
0422EE 08          5881          		EX      AF,AF'          ;SAVE RESULT SIGN
0422EF CB 7C       5882          		BIT     7,H
0422F1 C4 12 2B 04 5883          		CALL    NZ,NEGATE
0422F5 CD 0F 2C 04 5884          		CALL    SWAP_FP
0422F9 CB 7C       5885          		BIT     7,H
0422FB C4 12 2B 04 5886          		CALL    NZ,NEGATE
0422FF 44          5887          		LD      B,H
042300 4D          5888          		LD      C,L
042301 21 00 00 00 5889          		LD      HL,0
042305 D9          5890          		EXX
042306 44          5891          		LD      B,H
042307 4D          5892          		LD      C,L
042308 21 00 00 00 5893          		LD      HL,0
04230C 3E DF       5894          		LD      A,-33
04230E CD D3 2D 04 5895          		CALL    MULA            ;MULTIPLY
042312 D9          5896          		EXX
042313 0E BF       5897          		LD      C,191           ;PRESET EXPONENT
042315 CD 37 2C 04 5898          		CALL    TEST_FP            ;TEST RANGE
042319 20 0F       5899          		JR      NZ,IMUL1        ;TOO BIG
04231B CB 7A       5900          		BIT     7,D
04231D 20 0B       5901          		JR      NZ,IMUL1
04231F CD 0F 2C 04 5902          		CALL    SWAP_FP
042323 4A          5903          		LD      C,D             ;INTEGER MARKER
042324 08          5904          		EX      AF,AF'
042325 F0          5905          		RET     P
042326 C3 12 2B 04 5906          		JP      NEGATE
04232A             5907  ;
04232A 0D          5908  IMUL1:			DEC     C
04232B D9          5909          		EXX
04232C CB 23       5910          		SLA     E
04232E CB 12       5911          		RL      D
042330 D9          5912          		EXX
042331 CB 13       5913          		RL      E
042333 CB 12       5914          		RL      D
042335 D9          5915          		EXX
042336 52 ED 6A    5916          		ADC.S   HL,HL
042339 D9          5917          		EXX
04233A 52 ED 6A    5918          		ADC.S   HL,HL
04233D F2 2A 23 04 5919          		JP      P,IMUL1         ;NORMALISE
042341 08          5920          		EX      AF,AF'
042342 F8          5921          		RET     M
042343 CB BC       5922          		RES     7,H             ;POSITIVE
042345 C9          5923          		RET
042346             5924  ;
042346             5925  ;FMUL - Floating point multiplication with rounding.
042346             5926  ;
042346 05          5927  FMUL:			DEC     B               ;TEST FOR ZERO
042347 04          5928          		INC     B
042348 CA 5B 2C 04 5929          		JP      Z,ZERO_FP
04234C 0D          5930          		DEC     C               ;TEST FOR ZERO
04234D 0C          5931          		INC     C
04234E C8          5932          		RET     Z
04234F 7C          5933          		LD      A,H
042350 AA          5934          		XOR     D               ;CALC. RESULT SIGN
042351 08          5935          		EX      AF,AF'
042352 CB FA       5936          		SET     7,D             ;REPLACE IMPLIED 1's
042354 CB FC       5937          		SET     7,H
042356 C5          5938          		PUSH    BC              ;SAVE EXPONENTS
042357 44          5939          		LD      B,H             ;LOAD REGISTERS
042358 4D          5940          		LD      C,L
042359 21 00 00 00 5941          		LD      HL,0
04235D D9          5942          		EXX
04235E 44          5943          		LD      B,H
04235F 4D          5944          		LD      C,L
042360 21 00 00 00 5945          		LD      HL,0
042364 3E E0       5946          		LD      A,-32           ;LOOP COUNTER
042366 CD D3 2D 04 5947          		CALL    MULA            ;MULTIPLY
04236A DC E9 2D 04 5948          		CALL    C,MULB          ;NORMALISE & INC A
04236E D9          5949          		EXX
04236F E5          5950          		PUSH    HL
042370 21 00 80 00 5951          		LD      HL,8000H
042374 B7          5952          		OR      A               ;CLEAR CARRY
042375 52 ED 52    5953          		SBC.S   HL,DE
042378 E1          5954          		POP     HL
042379 CC 09 2C 04 5955          		CALL    Z,ODD           ;ROUND UNBIASSED
04237D DC F7 2B 04 5956          		CALL    C,ADD1_FP          ;ROUND UP
042381 C1          5957          		POP     BC              ;RESTORE EXPONENTS
042382 DC 24 2C 04 5958          		CALL    C,INCC
042386 1F          5959          		RRA                     ;LSB OF A TO CARRY
042387 79          5960          		LD      A,C             ;COMPUTE NEW EXPONENT
042388 88          5961          		ADC     A,B
042389 38 06       5962  CHKOVF:			JR      C,CHKO1
04238B F2 5B 2C 04 5963          		JP      P,ZERO_FP          ;UNDERFLOW
04238F 18 04       5964          		JR      CHKO2
042391 FA 26 2C 04 5965  CHKO1:			JP      M,OFLOW         ;OVERFLOW
042395 C6 80       5966  CHKO2:			ADD     A,80H
042397 4F          5967          		LD      C,A
042398 CA 5B 2C 04 5968          		JP      Z,ZERO_FP
04239C 08          5969          		EX      AF,AF'          ;RESTORE SIGN BIT
04239D CB BC       5970          		RES     7,H
04239F F0          5971          		RET     P
0423A0 CB FC       5972          		SET     7,H
0423A2 C9          5973          		RET
0423A3             5974  ;
0423A3             5975  ;IPOW - Integer involution.
0423A3             5976  ;
0423A3 CD 0F 2C 04 5977  IPOW:			CALL    SWAP_FP
0423A7 CB 7C       5978          		BIT     7,H
0423A9 F5          5979          		PUSH    AF              ;SAVE SIGN
0423AA C4 12 2B 04 5980          		CALL    NZ,NEGATE
0423AE 48          5981  IPOW0:			LD      C,B
0423AF 06 20       5982          		LD      B,32            ;LOOP COUNTER
0423B1 CD C7 2C 04 5983  IPOW1:			CALL    X2
0423B5 38 08       5984          		JR      C,IPOW2
0423B7 10 F8       5985          		DJNZ    IPOW1
0423B9 F1          5986          		POP     AF
0423BA D9          5987          		EXX
0423BB 2C          5988          		INC     L               ;RESULT=1
0423BC D9          5989          		EXX
0423BD 4C          5990          		LD      C,H
0423BE C9          5991          		RET
0423BF             5992  ;
0423BF F1          5993  IPOW2:			POP     AF
0423C0 C5          5994          		PUSH    BC
0423C1 EB          5995          		EX      DE,HL
0423C2 E5          5996          		PUSH    HL
0423C3 D9          5997          		EXX
0423C4 EB          5998          		EX      DE,HL
0423C5 E5          5999          		PUSH    HL
0423C6 D9          6000          		EXX
0423C7 DD 21 00 00 6001          		LD      IX,0
       00          
0423CC DD 39       6002          		ADD     IX,SP
0423CE 28 48       6003          		JR      Z,IPOW4
0423D0 C5          6004          		PUSH    BC
0423D1 D9          6005          		EXX
0423D2 D5          6006          		PUSH    DE
0423D3 D9          6007          		EXX
0423D4 D5          6008          		PUSH    DE
0423D5 CD DE 2B 04 6009          		CALL    SFLOAT_FP
0423D9 CD 12 27 04 6010          		CALL    RECIP
0423DD DD 71 04    6011          		LD      (IX+4),C
0423E0 D9          6012          		EXX
0423E1 DD 75 00    6013          		LD      (IX+0),L
0423E4 DD 74 01    6014          		LD      (IX+1),H
0423E7 D9          6015          		EXX
0423E8 DD 75 02    6016          		LD      (IX+2),L
0423EB DD 74 03    6017          		LD      (IX+3),H
0423EE 18 21       6018          		JR      IPOW5
0423F0             6019  ;
0423F0 C5          6020  IPOW3:			PUSH    BC
0423F1 D9          6021          		EXX
0423F2 CB 23       6022          		SLA     E
0423F4 CB 12       6023          		RL      D
0423F6 D5          6024          		PUSH    DE
0423F7 D9          6025          		EXX
0423F8 CB 13       6026          		RL      E
0423FA CB 12       6027          		RL      D
0423FC D5          6028          		PUSH    DE
0423FD 3E 0A       6029          		LD      A,'*' & 0FH
0423FF F5          6030          		PUSH    AF
042400 CD DB 2C 04 6031          		CALL    COPY_
042404 CD BB 20 04 6032          		CALL    OP              ;SQUARE
042408 F1          6033          		POP     AF
042409 CD 07 2A 04 6034          		CALL    DLOAD5
04240D DC BB 20 04 6035          		CALL    C,OP            ;MULTIPLY BY X
042411 D1          6036  IPOW5:			POP     DE
042412 D9          6037          		EXX
042413 D1          6038          		POP     DE
042414 D9          6039          		EXX
042415 79          6040          		LD      A,C
042416 C1          6041          		POP     BC
042417 4F          6042          		LD      C,A
042418 10 D6       6043  IPOW4:			DJNZ    IPOW3
04241A F1          6044          		POP     AF
04241B F1          6045          		POP     AF
04241C F1          6046          		POP     AF
04241D C9          6047          		RET
04241E             6048  ;
04241E F1          6049  FPOW0:			POP     AF
04241F F1          6050          		POP     AF
042420 F1          6051          		POP     AF
042421 18 8B       6052          		JR      IPOW0
042423             6053  ;
042423             6054  ;FPOW - Floating-point involution.
042423             6055  ;
042423 CB 7A       6056  FPOW:			BIT     7,D
042425 F5          6057          		PUSH    AF
042426 CD 0F 2C 04 6058          		CALL    SWAP_FP
04242A CD EB 2C 04 6059          		CALL    PUSH5
04242E 0D          6060          		DEC     C
04242F 0C          6061          		INC     C
042430 28 EC       6062          		JR      Z,FPOW0
042432 3E 9E       6063          		LD      A,158
042434 B9          6064          		CP      C
042435 38 0A       6065          		JR      C,FPOW1
042437 3C          6066          		INC     A
042438 CD E3 2A 04 6067          		CALL    FIX
04243C 08          6068          		EX      AF,AF'
04243D F2 1E 24 04 6069          		JP      P,FPOW0
042441 CD 0F 2C 04 6070  FPOW1:			CALL    SWAP_FP
042445 CD 2F 27 04 6071          		CALL    LN0
042449 CD F4 2C 04 6072          		CALL    POP5
04244D F1          6073          		POP     AF
04244E CD 46 23 04 6074          		CALL    FMUL
042452 C3 91 26 04 6075          		JP      EXP0
042456             6076  ;
042456             6077  ;Integer and floating-point compare.
042456             6078  ;Result is TRUE (-1) or FALSE (0).
042456             6079  ;
042456 CD 65 2C 04 6080  FLT:			CALL    FCP
04245A 18 04       6081          		JR      ILT1
04245C CD 57 2C 04 6082  ILT:			CALL    ICP
042460 D0          6083  ILT1:			RET     NC
042461 18 42       6084          		JR      TRUE_FP
042463             6085  ;
042463 CD 65 2C 04 6086  FGT:			CALL    FCP
042467 18 04       6087          		JR      IGT1
042469 CD 57 2C 04 6088  IGT:			CALL    ICP
04246D C8          6089  IGT1:			RET     Z
04246E D8          6090          		RET     C
04246F 18 34       6091          		JR      TRUE_FP
042471             6092  ;
042471 CD 65 2C 04 6093  FGE:			CALL    FCP
042475 18 04       6094          		JR      IGE1
042477 CD 57 2C 04 6095  IGE:			CALL    ICP
04247B D8          6096  IGE1:			RET     C
04247C 18 27       6097          		JR      TRUE_FP
04247E             6098  ;
04247E CD 65 2C 04 6099  FLE:			CALL    FCP
042482 18 04       6100          		JR      ILE1
042484 CD 57 2C 04 6101  ILE:			CALL    ICP
042488 28 1B       6102  ILE1:			JR      Z,TRUE_FP
04248A D0          6103          		RET     NC
04248B 18 18       6104          		JR      TRUE_FP
04248D             6105  ;
04248D CD 65 2C 04 6106  FNE:			CALL    FCP
042491 18 04       6107          		JR      INE1
042493 CD 57 2C 04 6108  INE:			CALL    ICP
042497 C8          6109  INE1:			RET     Z
042498 18 0B       6110          		JR      TRUE_FP
04249A             6111  ;
04249A CD 65 2C 04 6112  FEQ:			CALL    FCP
04249E 18 04       6113          		JR      IEQ1
0424A0 CD 57 2C 04 6114  IEQ:			CALL    ICP
0424A4 C0          6115  IEQ1:			RET     NZ
0424A5 21 FF FF FF 6116  TRUE_FP:			LD      HL,-1
0424A9 D9          6117          		EXX
0424AA 21 FF FF FF 6118          		LD      HL,-1
0424AE D9          6119          		EXX
0424AF AF          6120          		XOR     A
0424B0 4F          6121          		LD      C,A
0424B1 C9          6122          		RET
0424B2             6123  ;
0424B2             6124  ;FUNCTIONS:
0424B2             6125  ;
0424B2             6126  ;Result returned in HLH'L'C (floating point)
0424B2             6127  ;Result returned in HLH'L' (C=0) (integer)
0424B2             6128  ;All registers except IY destroyed.
0424B2             6129  ;
0424B2             6130  ;ABS - Absolute value
0424B2             6131  ;Result is numeric, variable type.
0424B2             6132  ;
0424B2 CB 7C       6133  ABSV_FP:			BIT     7,H
0424B4 C8          6134          		RET     Z               ;POSITIVE/ZERO
0424B5 0D          6135          		DEC     C
0424B6 0C          6136          		INC     C
0424B7 CA 12 2B 04 6137          		JP      Z,NEGATE        ;INTEGER
0424BB CB BC       6138          		RES     7,H
0424BD C9          6139          		RET
0424BE             6140  ;
0424BE             6141  ;NOT - Complement integer.
0424BE             6142  ;Result is integer numeric.
0424BE             6143  ;
0424BE CD 02 2B 04 6144  NOTK_FP:			CALL    SFIX_FP
0424C2 7C          6145          		LD      A,H
0424C3 2F          6146          		CPL
0424C4 67          6147          		LD      H,A
0424C5 7D          6148          		LD      A,L
0424C6 2F          6149          		CPL
0424C7 6F          6150          		LD      L,A
0424C8 D9          6151          		EXX
0424C9 7C          6152          		LD      A,H
0424CA 2F          6153          		CPL
0424CB 67          6154          		LD      H,A
0424CC 7D          6155          		LD      A,L
0424CD 2F          6156          		CPL
0424CE 6F          6157          		LD      L,A
0424CF D9          6158          		EXX
0424D0 AF          6159          		XOR     A               ;NUMERIC MARKER
0424D1 C9          6160          		RET
0424D2             6161  ;
0424D2             6162  ;PI - Return PI (3.141592654)
0424D2             6163  ;Result is floating-point numeric.
0424D2             6164  ;
0424D2 21 0F 49 00 6165  PI_FP:			LD      HL,490FH
0424D6 D9          6166          		EXX
0424D7 21 A2 DA 00 6167          		LD      HL,0DAA2H
0424DB D9          6168          		EXX
0424DC 0E 81       6169          		LD      C,81H
0424DE AF          6170          		XOR     A               ;NUMERIC MARKER
0424DF C9          6171          		RET
0424E0             6172  ;
0424E0             6173  ;DEG - Convert radians to degrees
0424E0             6174  ;Result is floating-point numeric.
0424E0             6175  ;
0424E0 CD F4 24 04 6176  DEG_FP:			CALL    FPI180
0424E4 CD 46 23 04 6177          		CALL    FMUL
0424E8 AF          6178          		XOR     A
0424E9 C9          6179          		RET
0424EA             6180  ;
0424EA             6181  ;RAD - Convert degrees to radians
0424EA             6182  ;Result is floating-point numeric.
0424EA             6183  ;
0424EA CD F4 24 04 6184  RAD_FP:			CALL    FPI180
0424EE CD 9D 22 04 6185          		CALL    FDIV
0424F2 AF          6186          		XOR     A
0424F3 C9          6187          		RET
0424F4             6188  ;
0424F4             6189  ;180/PI
0424F4             6190  ;
0424F4 CD DE 2B 04 6191  FPI180:			CALL    SFLOAT_FP
0424F8 11 2E 65 00 6192          		LD      DE,652EH
0424FC D9          6193          		EXX
0424FD 11 D3 E0 00 6194          		LD      DE,0E0D3H
042501 D9          6195          		EXX
042502 06 85       6196          		LD      B,85H
042504 C9          6197          		RET
042505             6198  ;
042505             6199  ;SGN - Return -1, 0 or +1
042505             6200  ;Result is integer numeric.
042505             6201  ;
042505 CD 37 2C 04 6202  SGN_FP:			CALL    TEST_FP
042509 B1          6203          		OR      C
04250A C8          6204          		RET     Z               ;ZERO
04250B CB 7C       6205          		BIT     7,H
04250D C2 A5 24 04 6206          		JP      NZ,TRUE_FP         ;-1
042511 CD 5B 2C 04 6207          		CALL    ZERO_FP
042515 C3 F7 2B 04 6208          		JP      ADD1_FP            ;1
042519             6209  ;
042519             6210  ;VAL - Return numeric value of string.
042519             6211  ;Input: ASCII string at IX
042519             6212  ;Result is variable type numeric.
042519             6213  ;
042519 CD 75 2E 04 6214  VAL_FP:			CALL    SIGNQ
04251D F5          6215          		PUSH    AF
04251E CD 25 2A 04 6216          		CALL    CON_FP
042522 F1          6217          		POP     AF
042523 FE 2D       6218          		CP      '-'
042525 3E 00       6219          		LD      A,0             ;NUMERIC MARKER
042527 C0          6220          		RET     NZ
042528 0D          6221          		DEC     C
042529 0C          6222          		INC     C
04252A CA 12 2B 04 6223          		JP      Z,NEGATE        ;ZERO/INTEGER
04252E 7C          6224          		LD      A,H
04252F EE 80       6225          		XOR     80H             ;CHANGE SIGN (FP)
042531 67          6226          		LD      H,A
042532 AF          6227          		XOR     A
042533 C9          6228          		RET
042534             6229  ;
042534             6230  ;INT - Floor function
042534             6231  ;Result is integer numeric.
042534             6232  ;
042534 0D          6233  INT_FP_:			DEC     C
042535 0C          6234          		INC     C
042536 C8          6235          		RET     Z               ;ZERO/INTEGER
042537 3E 9F       6236          		LD      A,159
042539 44          6237          		LD      B,H             ;B7=SIGN BIT
04253A CD E3 2A 04 6238          		CALL    FIX
04253E 08          6239          		EX      AF,AF'
04253F A0          6240          		AND     B
042540 FC F7 2B 04 6241          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042544 78          6242          		LD      A,B
042545 B7          6243          		OR      A
042546 FC 12 2B 04 6244          		CALL    M,NEGATE
04254A AF          6245          		XOR     A
04254B 4F          6246          		LD      C,A
04254C C9          6247          		RET
04254D             6248  ;
04254D             6249  ;SQR - square root
04254D             6250  ;Result is floating-point numeric.
04254D             6251  ;
04254D CD DE 2B 04 6252  SQR_FP:			CALL    SFLOAT_FP
042551 CB 7C       6253  SQR0:			BIT     7,H
042553 3E 15       6254          		LD      A,NGROOT
042555 C2 B5 20 04 6255          		JP      NZ,ERROR_FP_        ;"-ve root"
042559 0D          6256          		DEC     C
04255A 0C          6257          		INC     C
04255B C8          6258          		RET     Z               ;ZERO
04255C CB FC       6259          		SET     7,H             ;IMPLIED 1
04255E CB 41       6260          		BIT     0,C
042560 CC 17 2C 04 6261          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
042564 79          6262          		LD      A,C
042565 D6 80       6263          		SUB     80H
042567 CB 2F       6264          		SRA     A               ;HALVE EXPONENT
042569 C6 80       6265          		ADD     A,80H
04256B 4F          6266          		LD      C,A
04256C C5          6267          		PUSH    BC              ;SAVE EXPONENT
04256D EB          6268          		EX      DE,HL
04256E 21 00 00 00 6269          		LD      HL,0
042572 44          6270          		LD      B,H
042573 4D          6271          		LD      C,L
042574 D9          6272          		EXX
042575 EB          6273          		EX      DE,HL
042576 21 00 00 00 6274          		LD      HL,0
04257A 44          6275          		LD      B,H
04257B 4D          6276          		LD      C,L
04257C 3E E1       6277          		LD      A,-31
04257E CD 0D 2E 04 6278          		CALL    SQRA            ;ROOT
042582 D9          6279          		EXX
042583 CB 78       6280          		BIT     7,B
042585 D9          6281          		EXX
042586 CC 0D 2E 04 6282          		CALL    Z,SQRA          ;NORMALISE & INC A
04258A CD 4E 2E 04 6283          		CALL    SQRB
04258E B7          6284          		OR      A               ;CLEAR CARRY
04258F CD BB 2D 04 6285          		CALL    DIVB
042593 CB 1B       6286          		RR      E               ;LSB TO CARRY
042595 60          6287          		LD      H,B
042596 69          6288          		LD      L,C
042597 D9          6289          		EXX
042598 60          6290          		LD      H,B
042599 69          6291          		LD      L,C
04259A DC F7 2B 04 6292          		CALL    C,ADD1_FP          ;ROUND UP
04259E C1          6293          		POP     BC              ;RESTORE EXPONENT
04259F DC 24 2C 04 6294          		CALL    C,INCC
0425A3 1F          6295          		RRA
0425A4 9F          6296          		SBC     A,A
0425A5 81          6297          		ADD     A,C
0425A6 4F          6298          		LD      C,A
0425A7 CB BC       6299          		RES     7,H             ;POSITIVE
0425A9 AF          6300          		XOR     A
0425AA C9          6301          		RET
0425AB             6302  ;
0425AB             6303  ;TAN - Tangent function
0425AB             6304  ;Result is floating-point numeric.
0425AB             6305  ;
0425AB CD DE 2B 04 6306  TAN_FP:			CALL    SFLOAT_FP
0425AF CD EB 2C 04 6307          		CALL    PUSH5
0425B3 CD D5 25 04 6308          		CALL    COS0
0425B7 CD F4 2C 04 6309          		CALL    POP5
0425BB CD EB 2C 04 6310          		CALL    PUSH5
0425BF CD 0F 2C 04 6311          		CALL    SWAP_FP
0425C3 CD E2 25 04 6312          		CALL    SIN0
0425C7 CD F4 2C 04 6313          		CALL    POP5
0425CB CD 9D 22 04 6314          		CALL    FDIV
0425CF AF          6315          		XOR     A               ;NUMERIC MARKER
0425D0 C9          6316          		RET
0425D1             6317  ;
0425D1             6318  ;COS - Cosine function
0425D1             6319  ;Result is floating-point numeric.
0425D1             6320  ;
0425D1 CD DE 2B 04 6321  COS_FP:			CALL    SFLOAT_FP
0425D5 CD 3A 2B 04 6322  COS0:			CALL    SCALE
0425D9 1C          6323          		INC     E
0425DA 1C          6324          		INC     E
0425DB 7B          6325          		LD      A,E
0425DC 18 10       6326          		JR      SIN1
0425DE             6327  ;
0425DE             6328  ;SIN - Sine function
0425DE             6329  ;Result is floating-point numeric.
0425DE             6330  ;
0425DE CD DE 2B 04 6331  SIN_FP:			CALL    SFLOAT_FP
0425E2 E5          6332  SIN0:			PUSH    HL              ;H7=SIGN
0425E3 CD 3A 2B 04 6333          		CALL    SCALE
0425E7 F1          6334          		POP     AF
0425E8 07          6335          		RLCA
0425E9 07          6336          		RLCA
0425EA 07          6337          		RLCA
0425EB E6 04       6338          		AND     4
0425ED AB          6339          		XOR     E
0425EE F5          6340  SIN1:			PUSH    AF              ;OCTANT
0425EF CB BC       6341          		RES     7,H
0425F1 1F          6342          		RRA
0425F2 CD 80 26 04 6343          		CALL    PIBY4
0425F6 DC 21 22 04 6344          		CALL    C,RSUB          ;X=(PI/4)-X
0425FA F1          6345          		POP     AF
0425FB F5          6346          		PUSH    AF
0425FC E6 03       6347          		AND     3
0425FE E2 37 26 04 6348          		JP      PO,SIN2         ;USE COSINE APPROX.
042602 CD EB 2C 04 6349          		CALL    PUSH5           ;SAVE X
042606 CD E3 2C 04 6350          		CALL    SQUARE          ;PUSH X*X
04260A CD 28 2D 04 6351          		CALL    POLY
04260E B7 A8       6352          		DW	0A8B7H          ;a(8)
042610 11 36       6353          		DW	3611H
042612 6D          6354          		DB	6DH
042613 26 DE       6355          		DW	0DE26H          ;a(6)
042615 05 D0       6356          		DW	0D005H
042617 73          6357          		DB	73H
042618 C0 80       6358          		DW	80C0H           ;a(4)
04261A 88 08       6359          		DW	888H
04261C 79          6360          		DB	79H
04261D 9D AA       6361          		DW	0AA9DH          ;a(2)
04261F AA AA       6362          		DW	0AAAAH
042621 7D          6363          		DB	7DH
042622 00 00       6364          		DW	0               ;a(0)
042624 00 00       6365          		DW	0
042626 80          6366          		DB	80H
042627 CD F4 2C 04 6367          		CALL    POP5
04262B CD F4 2C 04 6368          		CALL    POP5
04262F CD 46 23 04 6369          		CALL    FMUL
042633 C3 5C 26 04 6370          		JP      SIN3
042637             6371  ;
042637 CD E3 2C 04 6372  SIN2:			CALL    SQUARE          ;PUSH X*X
04263B CD 28 2D 04 6373          		CALL    POLY
04263F 71 D5       6374          		DW	0D571H          ;b(8)
042641 78 4C       6375          		DW	4C78H
042643 70          6376          		DB	70H
042644 AF 94       6377          		DW	94AFH           ;b(6)
042646 03 B6       6378          		DW	0B603H
042648 76          6379          		DB	76H
042649 C8 9C       6380          		DW	9CC8H           ;b(4)
04264B AA 2A       6381          		DW	2AAAH
04264D 7B          6382          		DB	7BH
04264E DD FF       6383          		DW	0FFDDH          ;b(2)
042650 FF FF       6384          		DW	0FFFFH
042652 7E          6385          		DB	7EH
042653 00 00       6386          		DW	0               ;b(0)
042655 00 00       6387          		DW	0
042657 80          6388          		DB	80H
042658 CD F4 2C 04 6389          		CALL    POP5
04265C F1          6390  SIN3:			POP     AF
04265D E6 04       6391          		AND     4
04265F C8          6392          		RET     Z
042660 0D          6393          		DEC     C
042661 0C          6394          		INC     C
042662 C8          6395          		RET     Z               ;ZERO
042663 CB FC       6396          		SET     7,H             ;MAKE NEGATIVE
042665 C9          6397          		RET
042666             6398  ;
042666             6399  ;Floating-point one:
042666             6400  ;
042666 21 00 00 00 6401  FONE_FP:			LD      HL,0
04266A D9          6402          		EXX
04266B 21 00 00 00 6403          		LD      HL,0
04266F D9          6404          		EXX
042670 0E 80       6405          		LD      C,80H
042672 C9          6406          		RET
042673             6407  ;
042673 11 00 00 00 6408  DONE:			LD      DE,0
042677 D9          6409          		EXX
042678 11 00 00 00 6410          		LD      DE,0
04267C D9          6411          		EXX
04267D 06 80       6412          		LD      B,80H
04267F C9          6413          		RET
042680             6414  ;
042680 11 0F 49 00 6415  PIBY4:			LD      DE,490FH
042684 D9          6416          		EXX
042685 11 A2 DA 00 6417          		LD      DE,0DAA2H
042689 D9          6418          		EXX
04268A 06 7F       6419          		LD      B,7FH
04268C C9          6420          		RET
04268D             6421  ;
04268D             6422  ;EXP - Exponential function
04268D             6423  ;Result is floating-point numeric.
04268D             6424  ;
04268D CD DE 2B 04 6425  EXP_FP:			CALL    SFLOAT_FP
042691 CD 1E 27 04 6426  EXP0:			CALL    LN2             ;LN(2)
042695 D9          6427          		EXX
042696 1D          6428  	        	DEC     E
042697 01 CF D1 00 6429  		        LD      BC,0D1CFH       ;0.6931471805599453
04269B D9          6430          		EXX
04269C E5          6431          		PUSH    HL              ;H7=SIGN
04269D CD 4D 2B 04 6432          		CALL    MOD48           ;"MODULUS"
0426A1 F1          6433          		POP     AF
0426A2 CB 7B       6434          		BIT     7,E
0426A4 28 0B       6435          		JR      Z,EXP1
0426A6 17          6436          		RLA
0426A7 DA 5B 2C 04 6437          		JP      C,ZERO_FP
0426AB 3E 18       6438          		LD      A,EXPRNG
0426AD C3 B5 20 04 6439          		JP      ERROR_FP_           ;"Exp range"
0426B1             6440  ;
0426B1 E6 80       6441  EXP1:			AND     80H
0426B3 B3          6442          		OR      E
0426B4 F5          6443          		PUSH    AF              ;INTEGER PART
0426B5 CB BC       6444          		RES     7,H
0426B7 CD EB 2C 04 6445          		CALL    PUSH5           ;PUSH X*LN(2)
0426BB CD 28 2D 04 6446          		CALL    POLY
0426BF 72 40       6447          		DW	4072H           ;a(7)
0426C1 2E 94       6448          		DW	942EH
0426C3 73          6449          		DB	73H
0426C4 65 6F       6450          		DW	6F65H           ;a(6)
0426C6 4F 2E       6451          		DW	2E4FH
0426C8 76          6452          		DB	76H
0426C9 37 6D       6453          		DW	6D37H           ;a(5)
0426CB 02 88       6454          		DW	8802H
0426CD 79          6455          		DB	79H
0426CE 12 E5       6456          		DW	0E512H          ;a(4)
0426D0 A0 2A       6457          		DW	2AA0H
0426D2 7B          6458          		DB	7BH
0426D3 14 4F       6459          		DW	4F14H           ;a(3)
0426D5 AA AA       6460          		DW	0AAAAH
0426D7 7D          6461          		DB	7DH
0426D8 56 FD       6462          		DW	0FD56H          ;a(2)
0426DA FF 7F       6463          		DW	7FFFH
0426DC 7E          6464          		DB	7EH
0426DD FE FF       6465          		DW	0FFFEH          ;a(1)
0426DF FF FF       6466          		DW	0FFFFH
0426E1 7F          6467          		DB	7FH
0426E2 00 00       6468          		DW	0               ;a(0)
0426E4 00 00       6469          		DW	0
0426E6 80          6470          		DB	80H
0426E7 CD F4 2C 04 6471          		CALL    POP5
0426EB F1          6472          		POP     AF
0426EC F5          6473          		PUSH    AF
0426ED F4 12 27 04 6474          		CALL    P,RECIP         ;X=1/X
0426F1 F1          6475          		POP     AF
0426F2 F2 FA 26 04 6476          		JP      P,EXP4
0426F6 E6 7F       6477          		AND     7FH
0426F8 ED 44       6478          		NEG
0426FA C6 80       6479  EXP4:			ADD     A,80H
0426FC 81          6480          		ADD     A,C
0426FD 38 06       6481          		JR      C,EXP2
0426FF F2 5B 2C 04 6482          		JP      P,ZERO_FP          ;UNDERFLOW
042703 18 04       6483          		JR      EXP3
042705 FA 26 2C 04 6484  EXP2:			JP      M,OFLOW         ;OVERFLOW
042709 C6 80       6485  EXP3:			ADD     A,80H
04270B CA 5B 2C 04 6486          		JP      Z,ZERO_FP
04270F 4F          6487          		LD      C,A
042710 AF          6488          		XOR     A               ;NUMERIC MARKER
042711 C9          6489          		RET
042712             6490  ;
042712 CD 73 26 04 6491  RECIP:			CALL    DONE
042716 CD 0F 2C 04 6492  RDIV:			CALL    SWAP_FP
04271A C3 9D 22 04 6493          		JP      FDIV            ;RECIPROCAL
04271E             6494  ;
04271E 11 72 31 00 6495  LN2:			LD      DE,3172H        ;LN(2)
042722 D9          6496          		EXX
042723 11 F8 17 00 6497          		LD      DE,17F8H
042727 D9          6498          		EXX
042728 06 7F       6499          		LD      B,7FH
04272A C9          6500          		RET
04272B             6501  ;
04272B             6502  ;LN - Natural log.
04272B             6503  ;Result is floating-point numeric.
04272B             6504  ;
04272B CD DE 2B 04 6505  LN_FP:			CALL    SFLOAT_FP
04272F 3E 16       6506  LN0:			LD      A,LOGRNG
042731 CB 7C       6507          		BIT     7,H
042733 C2 B5 20 04 6508          		JP      NZ,ERROR_FP_        ;"Log range"
042737 0C          6509          		INC     C
042738 0D          6510          		DEC     C
042739 CA B5 20 04 6511          		JP      Z,ERROR_FP_
04273D 11 04 35 00 6512          		LD      DE,3504H        ;SQR(2)
042741 D9          6513          		EXX
042742 11 33 F3 00 6514          		LD      DE,0F333H       ;1.41421356237
042746 D9          6515          		EXX
042747 CD 6E 2C 04 6516          		CALL    ICP0            ;MANTISSA>SQR(2)?
04274B 79          6517          		LD      A,C             ;EXPONENT
04274C 0E 80       6518          		LD      C,80H           ;1 <= X < 2
04274E 38 02       6519          		JR      C,LN4
042750 0D          6520          		DEC     C
042751 3C          6521          		INC     A
042752 F5          6522  LN4:			PUSH    AF              ;SAVE EXPONENT
042753 CD 00 2D 04 6523          		CALL    RATIO           ;X=(X-1)/(X+1)
042757 CD EB 2C 04 6524          		CALL    PUSH5
04275B CD E3 2C 04 6525  		        CALL    SQUARE          ;PUSH X*X
04275F CD 28 2D 04 6526          		CALL    POLY
042763 48 CC       6527          		DW	0CC48H          ;a(9)
042765 FB 74       6528          		DW	74FBH
042767 7D          6529          		DB	7DH
042768 AF AE       6530          		DW	0AEAFH          ;a(7)
04276A FF 11       6531          		DW	11FFH
04276C 7E          6532          		DB	7EH
04276D 8C D9       6533          		DW	0D98CH          ;a(5)
04276F CD 4C       6534          		DW	4CCDH
042771 7E          6535          		DB	7EH
042772 E3 A9       6536          		DW	0A9E3H          ;a(3)
042774 AA 2A       6537          		DW	2AAAH
042776 7F          6538          		DB	7FH
042777 00 00       6539          		DW	0               ;a(1)
042779 00 00       6540          		DW	0
04277B 81          6541          		DB	81H
04277C CD F4 2C 04 6542          		CALL    POP5
042780 CD F4 2C 04 6543          		CALL    POP5
042784 CD 46 23 04 6544          		CALL    FMUL
042788 F1          6545          		POP     AF              ;EXPONENT
042789 CD EB 2C 04 6546          		CALL    PUSH5
04278D 08          6547          		EX      AF,AF'
04278E CD 5B 2C 04 6548          		CALL    ZERO_FP
042792 08          6549          		EX      AF,AF'
042793 D6 80       6550          		SUB     80H
042795 28 1F       6551          		JR      Z,LN3
042797 30 02       6552          		JR      NC,LN1
042799 2F          6553          		CPL
04279A 3C          6554          		INC     A
04279B 67          6555  LN1:			LD      H,A
04279C 0E 87       6556          		LD      C,87H
04279E F5          6557          		PUSH    AF
04279F CD BE 2B 04 6558          		CALL    FLOAT_
0427A3 CB BC       6559          		RES     7,H
0427A5 CD 1E 27 04 6560          		CALL    LN2
0427A9 CD 46 23 04 6561          		CALL    FMUL
0427AD F1          6562          		POP     AF
0427AE 30 06       6563          		JR      NC,LN3
0427B0 FA B6 27 04 6564          		JP      M,LN3
0427B4 CB FC       6565          		SET     7,H
0427B6 CD F4 2C 04 6566  LN3:			CALL    POP5
0427BA CD 34 22 04 6567          		CALL    FADD
0427BE AF          6568          		XOR     A
0427BF C9          6569          		RET
0427C0             6570  ;
0427C0             6571  ;LOG - base-10 logarithm.
0427C0             6572  ;Result is floating-point numeric.
0427C0             6573  ;
0427C0 CD 2B 27 04 6574  LOG_FP:			CALL    LN_FP
0427C4 11 5B 5E 00 6575          		LD      DE,5E5BH        ;LOG(e)
0427C8 D9          6576          		EXX
0427C9 11 A9 D8 00 6577          		LD      DE,0D8A9H
0427CD D9          6578          		EXX
0427CE 06 7E       6579          		LD      B,7EH
0427D0 CD 46 23 04 6580          		CALL    FMUL
0427D4 AF          6581          		XOR     A
0427D5 C9          6582          		RET
0427D6             6583  ;
0427D6             6584  ;ASN - Arc-sine
0427D6             6585  ;Result is floating-point numeric.
0427D6             6586  ;
0427D6 CD DE 2B 04 6587  ASN_FP:			CALL    SFLOAT_FP
0427DA CD EB 2C 04 6588          		CALL    PUSH5
0427DE CD DB 2C 04 6589          		CALL    COPY_
0427E2 CD 46 23 04 6590          		CALL    FMUL
0427E6 CD 73 26 04 6591          		CALL    DONE
0427EA CD 21 22 04 6592          		CALL    RSUB
0427EE CD 51 25 04 6593          		CALL    SQR0
0427F2 CD F4 2C 04 6594          		CALL    POP5
0427F6 0C          6595          		INC     C
0427F7 0D          6596          		DEC     C
0427F8 3E 02       6597          		LD      A,2
0427FA D5          6598          		PUSH    DE
0427FB CA 80 28 04 6599          		JP      Z,ACS1
0427FF D1          6600          		POP     DE
042800 CD 16 27 04 6601          		CALL    RDIV
042804 18 04       6602          		JR      ATN0
042806             6603  ;
042806             6604  ;ATN - arc-tangent
042806             6605  ;Result is floating-point numeric.
042806             6606  ;
042806 CD DE 2B 04 6607  ATN_FP:			CALL    SFLOAT_FP
04280A E5          6608  ATN0:			PUSH    HL              ;SAVE SIGN
04280B CB BC       6609          		RES     7,H
04280D 11 13 54 00 6610          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
042811 D9          6611          		EXX
042812 11 D0 CC 00 6612          		LD      DE,0CCD0H
042816 D9          6613          		EXX
042817 06 7E       6614          		LD      B,7EH
042819 CD 6B 2C 04 6615          		CALL    FCP0            ;COMPARE
04281D 06 00       6616          		LD      B,0
04281F 38 22       6617          		JR      C,ATN2
042821 11 82 1A 00 6618          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
042825 D9          6619          		EXX
042826 11 9A 79 00 6620          		LD      DE,799AH
04282A D9          6621          		EXX
04282B 06 81       6622          		LD      B,81H
04282D CD 6B 2C 04 6623          		CALL    FCP0            ;COMPARE
042831 38 0A       6624          		JR      C,ATN1
042833 CD 12 27 04 6625          		CALL    RECIP           ;X=1/X
042837 06 02       6626          		LD      B,2
042839 C3 43 28 04 6627          		JP      ATN2
04283D CD 00 2D 04 6628  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042841 06 01       6629          		LD      B,1
042843 C5          6630  ATN2:			PUSH    BC              ;SAVE FLAG
042844 CD EB 2C 04 6631          		CALL    PUSH5
042848 CD E3 2C 04 6632          		CALL    SQUARE          ;PUSH X*X
04284C CD 28 2D 04 6633          		CALL    POLY
042850 35 F3       6634          		DW	0F335H          ;a(13)
042852 D8 37       6635          		DW	37D8H
042854 7B          6636          		DB	7BH
042855 91 6B       6637          		DW	6B91H           ;a(11)
042857 B9 AA       6638          		DW	0AAB9H
042859 7C          6639          		DB	7CH
04285A DE 41       6640          		DW	41DEH           ;a(9)
04285C 97 61       6641          		DW	6197H
04285E 7C          6642          		DB	7CH
04285F 7B 9D       6643          		DW	9D7BH           ;a(7)
042861 37 92       6644          		DW	9237H
042863 7D          6645          		DB	7DH
042864 5A 2A       6646          		DW	2A5AH           ;a(5)
042866 CC 4C       6647          		DW	4CCCH
042868 7D          6648          		DB	7DH
042869 5C A9       6649          		DW	0A95CH          ;a(3)
04286B AA AA       6650          		DW	0AAAAH
04286D 7E          6651          		DB	7EH
04286E 00 00       6652          		DW	0               ;a(1)
042870 00 00       6653          		DW	0
042872 80          6654          		DB	80H
042873 CD F4 2C 04 6655          		CALL    POP5
042877 CD F4 2C 04 6656          		CALL    POP5
04287B CD 46 23 04 6657          		CALL    FMUL
04287F F1          6658          		POP     AF
042880 CD 80 26 04 6659  ACS1:			CALL    PIBY4           ;PI/4
042884 1F          6660          		RRA
042885 F5          6661          		PUSH    AF
042886 DC 34 22 04 6662          		CALL    C,FADD
04288A F1          6663          		POP     AF
04288B 04          6664          		INC     B
04288C 1F          6665          		RRA
04288D DC 21 22 04 6666          		CALL    C,RSUB
042891 F1          6667          		POP     AF
042892 B7          6668          		OR      A
042893 F0          6669          		RET     P
042894 CB FC       6670          		SET     7,H             ;MAKE NEGATIVE
042896 AF          6671          		XOR     A
042897 C9          6672          		RET
042898             6673  ;
042898             6674  ;ACS - Arc cosine=PI/2-ASN.
042898             6675  ;Result is floating point numeric.
042898             6676  ;
042898 CD D6 27 04 6677  ACS_FP:			CALL    ASN_FP
04289C 3E 02       6678          		LD      A,2
04289E F5          6679          		PUSH    AF
04289F 18 DF       6680          		JR      ACS1
0428A1             6681  ;
0428A1             6682  ;Function STR - convert numeric value to ASCII string.
0428A1             6683  ;   Inputs: HLH'L'C = integer or floating-point number
0428A1             6684  ;           DE = address at which to store string
0428A1             6685  ;           IX = address of @% format control
0428A1             6686  ;  Outputs: String stored, with NUL terminator
0428A1             6687  ;
0428A1             6688  ;First normalise for decimal output:
0428A1             6689  ;
0428A1 CD DE 2B 04 6690  STR_FP:			CALL    SFLOAT_FP
0428A5 06 00       6691          		LD      B,0             ;DEFAULT PT. POSITION
0428A7 CB 7C       6692          		BIT     7,H             ;NEGATIVE?
0428A9 28 06       6693          		JR      Z,STR10
0428AB CB BC       6694          		RES     7,H
0428AD 3E 2D       6695          		LD      A,'-'
0428AF 12          6696          		LD      (DE),A          ;STORE SIGN
0428B0 13          6697          		INC     DE
0428B1 AF          6698  STR10:			XOR     A               ;CLEAR A
0428B2 B9          6699          		CP      C
0428B3 28 4E       6700          		JR      Z,STR02          ;ZERO
0428B5 D5          6701          		PUSH    DE              ;SAVE TEXT POINTER
0428B6 78          6702          		LD      A,B
0428B7 F5          6703  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B8 79          6704          		LD      A,C             ;BINARY EXPONENT
0428B9 FE A1       6705          		CP      161
0428BB 30 1C       6706          		JR      NC,STR14
0428BD FE 9B       6707          		CP      155
0428BF 30 29       6708          		JR      NC,STR15
0428C1 2F          6709          		CPL
0428C2 FE E1       6710          		CP      225
0428C4 38 02       6711          		JR      C,STR13
0428C6 3E F8       6712          		LD      A,-8
0428C8 C6 1C       6713  STR13:			ADD     A,28
0428CA CD 57 2D 04 6714          		CALL    POWR10
0428CE F5          6715          		PUSH    AF
0428CF CD 46 23 04 6716          		CALL    FMUL
0428D3 F1          6717          		POP     AF
0428D4 47          6718          		LD      B,A
0428D5 F1          6719          		POP     AF
0428D6 90          6720          		SUB     B
0428D7 18 DE       6721          		JR      STR11
0428D9 D6 20       6722  STR14:			SUB     32
0428DB CD 57 2D 04 6723          		CALL    POWR10
0428DF F5          6724          		PUSH    AF
0428E0 CD 9D 22 04 6725          		CALL    FDIV
0428E4 F1          6726          		POP     AF
0428E5 47          6727          		LD      B,A
0428E6 F1          6728          		POP     AF
0428E7 80          6729          		ADD     A,B
0428E8 18 CD       6730          		JR      STR11
0428EA 3E 09       6731  STR15:			LD      A,9
0428EC CD 57 2D 04 6732          		CALL    POWR10          ;10^9
0428F0 CD 6B 2C 04 6733          		CALL    FCP0
0428F4 79          6734          		LD      A,C
0428F5 C1          6735          		POP     BC
0428F6 4F          6736          		LD      C,A
0428F7 CB FC       6737          		SET     7,H             ;IMPLIED 1
0428F9 DC 93 2C 04 6738          		CALL    C,X10B          ;X10, DEC B
0428FD D1          6739          		POP     DE              ;RESTORE TEXT POINTER
0428FE CB B9       6740          		RES     7,C
042900 3E 00       6741          		LD      A,0
042902 17          6742          		RLA                     ;PUT CARRY IN LSB
042903             6743  ;
042903             6744  ;At this point decimal normalisation has been done,
042903             6745  ;now convert to decimal digits:
042903             6746  ;      AHLH'L' = number in normalised integer form
042903             6747  ;            B = decimal place adjustment
042903             6748  ;            C = binary place adjustment (29-33)
042903             6749  ;
042903 0C          6750  STR02:			INC     C
042904 08          6751          		EX      AF,AF'          ;SAVE A
042905 78          6752          		LD      A,B
042906 DD CB 02 4E 6753          		BIT     1,(IX+2)
04290A 20 08       6754          		JR      NZ,STR20
04290C AF          6755          		XOR     A
04290D DD BE 01    6756          		CP      (IX+1)
042910 28 0B       6757          		JR      Z,STR21
042912 3E F6       6758          		LD      A,-10
042914 DD 86 01    6759  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042917 B7          6760          		OR      A               ;CLEAR CARRY
042918 FA 1D 29 04 6761          		JP      M,STR21
04291C AF          6762          		XOR     A
04291D F5          6763  STR21:			PUSH    AF
04291E 08          6764          		EX      AF,AF'          ;RESTORE A
04291F CD C7 2C 04 6765  STR22:			CALL    X2              ;RL AHLH'L'
042923 8F          6766          		ADC     A,A
042924 FE 0A       6767          		CP      10
042926 38 05       6768          		JR      C,STR23
042928 D6 0A       6769          		SUB     10
04292A D9          6770          		EXX
04292B 2C          6771          		INC     L               ;SET RESULT BIT
04292C D9          6772          		EXX
04292D 0D          6773  STR23:			DEC     C
04292E 20 EF       6774          		JR      NZ,STR22        ;32 TIMES
042930 4F          6775          		LD      C,A             ;REMAINDER
042931 7C          6776          		LD      A,H
042932 E6 3F       6777          		AND     3FH             ;CLEAR OUT JUNK
042934 67          6778          		LD      H,A
042935 F1          6779          		POP     AF
042936 F2 44 29 04 6780          		JP      P,STR24
04293A 3C          6781          		INC     A
04293B 20 1C       6782          		JR      NZ,STR26
04293D 3E 04       6783          		LD      A,4
04293F B9          6784          		CP      C               ;ROUND UP?
042940 3E 00       6785          		LD      A,0
042942 18 15       6786          		JR      STR26
042944 F5          6787  STR24:			PUSH    AF
042945 79          6788          		LD      A,C
042946 CE 30       6789          		ADC     A,'0'           ;ADD CARRY
042948 FE 30       6790          		CP      '0'
04294A 28 05       6791          		JR      Z,STR25         ;SUPPRESS ZERO
04294C FE 3A       6792          		CP      '9'+1
04294E 3F          6793          		CCF
04294F 30 08       6794          		JR      NC,STR26
042951 E3          6795  STR25:			EX      (SP),HL
042952 CB 75       6796          		BIT     6,L             ;ZERO FLAG
042954 E3          6797  		        EX      (SP),HL
042955 20 05       6798          		JR      NZ,STR27
042957 3E 30       6799          		LD      A,'0'
042959 3C          6800  STR26:			INC     A               ;SET +VE
04295A 3D          6801          		DEC     A
04295B F5          6802          		PUSH    AF              ;PUT ON STACK + CARRY
04295C 04          6803  STR27:			INC     B
04295D CD 37 2C 04 6804          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042961 0E 20       6805          		LD      C,32
042963 3E 00       6806          		LD      A,0
042965 20 B8       6807          		JR      NZ,STR22
042967 F1          6808          		POP     AF
042968 F5          6809          		PUSH    AF
042969 3E 00       6810          		LD      A,0
04296B 38 B2       6811          		JR      C,STR22
04296D             6812  ;
04296D             6813  ;At this point, the decimal character string is stored
04296D             6814  ; on the stack. Trailing zeroes are suppressed and may
04296D             6815  ; need to be replaced.
04296D             6816  ;B register holds decimal point position.
04296D             6817  ;Now format number and store as ASCII string:
04296D             6818  ;
04296D EB          6819  STR3:			EX      DE,HL           ;STRING POINTER
04296E 0E FF       6820          		LD      C,-1            ;FLAG "E"
042970 16 01       6821          		LD      D,1
042972 DD 5E 01    6822          		LD      E,(IX+1)        ;f2
042975 DD CB 02 46 6823          		BIT     0,(IX+2)
042979 20 35       6824          		JR      NZ,STR34        ;E MODE
04297B DD CB 02 4E 6825          		BIT     1,(IX+2)
04297F 28 12       6826          		JR      Z,STR31
042981 78          6827          		LD      A,B             ;F MODE
042982 B7          6828          		OR      A
042983 28 05       6829          		JR      Z,STR30
042985 FA 8A 29 04 6830          		JP      M,STR30
042989 50          6831          		LD      D,B
04298A 7A          6832  STR30:			LD      A,D
04298B DD 86 01    6833          		ADD     A,(IX+1)
04298E 5F          6834          		LD      E,A
04298F FE 0B       6835          		CP      11
042991 38 19       6836          		JR      C,STR32
042993 78          6837  STR31:			LD      A,B             ;G MODE
042994 11 01 01 00 6838          		LD      DE,101H
042998 B7          6839          		OR      A
042999 FA B0 29 04 6840          		JP      M,STR34
04299D 28 0D       6841          		JR      Z,STR32
04299F DD 7E 01    6842          		LD      A,(IX+1)
0429A2 B7          6843          		OR      A
0429A3 20 02       6844          		JR      NZ,STR3A
0429A5 3E 0A       6845          		LD      A,10
0429A7 B8          6846  STR3A:			CP      B
0429A8 38 06       6847          		JR      C,STR34
0429AA 50          6848          		LD      D,B
0429AB 58          6849          		LD      E,B
0429AC 78          6850  STR32:			LD      A,B
0429AD C6 81       6851          		ADD     A,129
0429AF 4F          6852          		LD      C,A
0429B0 CB FA       6853  STR34:			SET     7,D
0429B2 1D          6854          		DEC     E
0429B3 7A          6855  STR35:			LD      A,D
0429B4 B9          6856          		CP      C
0429B5 30 0E       6857          		JR      NC,STR33
0429B7 F1          6858  STR36:			POP     AF
0429B8 28 04       6859          		JR      Z,STR37
0429BA F2 C7 29 04 6860          		JP      P,STR38
0429BE F5          6861  STR37:			PUSH    AF
0429BF 1C          6862          		INC     E
0429C0 1D          6863          		DEC     E
0429C1 FA D8 29 04 6864          		JP      M,STR4
0429C5 3E 30       6865  STR33:			LD      A,'0'
0429C7 15          6866  STR38:			DEC     D
0429C8 E2 CF 29 04 6867          		JP      PO,STR39
0429CC 36 2E       6868          		LD      (HL),'.'
0429CE 23          6869          		INC     HL
0429CF 77          6870  STR39:			LD      (HL),A
0429D0 23          6871          		INC     HL
0429D1 1D          6872          		DEC     E
0429D2 F2 B3 29 04 6873          		JP      P,STR35
0429D6 18 DF       6874          		JR      STR36
0429D8             6875  ;
0429D8 F1          6876  STR4:			POP     AF
0429D9 0C          6877  STR40:			INC     C
0429DA 4D          6878          		LD      C,L
0429DB 20 28       6879          		JR      NZ,STR44
0429DD 36 45       6880          		LD      (HL),'E'        ;EXPONENT
0429DF 23          6881          		INC     HL
0429E0 78          6882          		LD      A,B
0429E1 3D          6883          		DEC     A
0429E2 F2 EB 29 04 6884          		JP      P,STR41
0429E6 36 2D       6885          		LD      (HL),'-'
0429E8 23          6886          		INC     HL
0429E9 ED 44       6887          		NEG
0429EB 36 30       6888  STR41:			LD      (HL),'0'
0429ED 28 15       6889          		JR      Z,STR47
0429EF FE 0A       6890          		CP      10
0429F1 47          6891          		LD      B,A
0429F2 3E 3A       6892          		LD      A,':'
0429F4 38 03       6893          		JR      C,STR42
0429F6 23          6894          		INC     HL
0429F7 36 30       6895          		LD      (HL),'0'
0429F9 34          6896  STR42:			INC     (HL)
0429FA BE          6897          		CP      (HL)
0429FB 20 05       6898          		JR      NZ,STR43
0429FD 36 30       6899          		LD      (HL),'0'
0429FF 2B          6900          		DEC     HL
042A00 34          6901          		INC     (HL)
042A01 23          6902          		INC     HL
042A02 10 F5       6903  STR43:			DJNZ    STR42
042A04 23          6904  STR47:			INC     HL
042A05 EB          6905  STR44:			EX      DE,HL
042A06 C9          6906        			RET
042A07             6907  ;
042A07             6908  ;Support subroutines:
042A07             6909  ;
042A07 DD 46 04    6910  DLOAD5:			LD      B,(IX+4)
042A0A D9          6911          		EXX
042A0B DD 5E 00    6912          		LD      E,(IX+0)
042A0E DD 56 01    6913          		LD      D,(IX+1)
042A11 D9          6914          		EXX
042A12 DD 5E 02    6915          		LD      E,(IX+2)
042A15 DD 56 03    6916          		LD      D,(IX+3)
042A18 C9          6917          		RET
042A19             6918  ;
042A19 DD 46 06    6919  DLOAD5_SPL:		LD      B,(IX+6)
042A1C D9          6920  			EXX
042A1D DD 17 00    6921  			LD	DE, (IX+0)
042A20 D9          6922  			EXX
042A21 DD 17 03    6923  			LD	DE, (IX+3)
042A24 C9          6924  			RET
042A25             6925  ;
042A25             6926  ;CON_FP - Get unsigned numeric constant from ASCII string.
042A25             6927  ;   Inputs: ASCII string at (IX).
042A25             6928  ;  Outputs: Variable-type result in HLH'L'C
042A25             6929  ;           IX updated (points to delimiter)
042A25             6930  ;           A7 = 0 (numeric marker)
042A25             6931  ;
042A25 CD 5B 2C 04 6932  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A29 0E 00       6933          		LD      C,0             ;TRUNCATION COUNTER
042A2B CD B9 2A 04 6934          		CALL    UINT          ;GET INTEGER PART
042A2F FE 2E       6935          		CP      '.'
042A31 06 00       6936          		LD      B,0             ;DECL. PLACE COUNTER
042A33 CC B7 2A 04 6937          		CALL    Z,NUMBIX        ;GET FRACTION PART
042A37 FE 45       6938          		CP      'E'
042A39 3E 00       6939          		LD      A,0             ;INITIALISE EXPONENT
042A3B CC 85 2A 04 6940          		CALL    Z,GETEXP        ;GET EXPONENT
042A3F CB 7C       6941          		BIT     7,H
042A41 20 08       6942          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A43 B7          6943          		OR      A
042A44 20 05       6944          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A46 B8          6945          		CP      B
042A47 20 02       6946          		JR      NZ,CON0         ;DECIMAL POINT
042A49 B9          6947          		CP      C
042A4A C8          6948          		RET     Z               ;INTEGER
042A4B 90          6949  CON0:			SUB     B
042A4C 81          6950          		ADD     A,C
042A4D 0E 9F       6951          		LD      C,159
042A4F CD BE 2B 04 6952          		CALL    FLOAT_
042A53 CB BC       6953          		RES     7,H             ;DITCH IMPLIED 1
042A55 B7          6954          		OR      A
042A56 C8          6955          		RET     Z               ;DONE
042A57 FA 65 2A 04 6956          		JP      M,CON2          ;NEGATIVE EXPONENT
042A5B CD 57 2D 04 6957          		CALL    POWR10
042A5F CD 46 23 04 6958          		CALL    FMUL            ;SCALE
042A63 AF          6959          		XOR     A
042A64 C9          6960          		RET
042A65 FE DA       6961  CON2:			CP      -38
042A67 38 0C       6962          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A69 ED 44       6963          		NEG
042A6B CD 57 2D 04 6964          		CALL    POWR10
042A6F CD 9D 22 04 6965          		CALL    FDIV            ;SCALE
042A73 AF          6966          		XOR     A
042A74 C9          6967          		RET
042A75 F5          6968  CON3:			PUSH    AF
042A76 3E 26       6969          		LD      A,38
042A78 CD 57 2D 04 6970          		CALL    POWR10
042A7C CD 9D 22 04 6971          		CALL    FDIV
042A80 F1          6972          		POP     AF
042A81 C6 26       6973          		ADD     A,38
042A83 18 E0       6974          		JR      CON2
042A85             6975  ;
042A85             6976  ;GETEXP - Get decimal exponent from string
042A85             6977  ;     Inputs: ASCII string at (IX)
042A85             6978  ;             (IX points at 'E')
042A85             6979  ;             A = initial value
042A85             6980  ;    Outputs: A = new exponent
042A85             6981  ;             IX updated.
042A85             6982  ;   Destroys: A,A',IX,F,F'
042A85             6983  ;
042A85 C5          6984  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A86 47          6985          		LD      B,A             ;INITIAL VALUE
042A87 0E 02       6986          		LD      C,2             ;2 DIGITS MAX
042A89 DD 23       6987          		INC     IX              ;BUMP PAST 'E'
042A8B CD 75 2E 04 6988          		CALL    SIGNQ
042A8F 08          6989          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A90 CD 6B 2E 04 6990  GETEX1:			CALL    DIGITQ
042A94 38 18       6991          		JR      C,GETEX2
042A96 78          6992          		LD      A,B             ;B=B*10
042A97 87          6993          		ADD     A,A
042A98 87          6994          		ADD     A,A
042A99 80          6995          		ADD     A,B
042A9A 87          6996          		ADD     A,A
042A9B 47          6997          		LD      B,A
042A9C DD 7E 00    6998          		LD      A,(IX)          ;GET BACK DIGIT
042A9F DD 23       6999          		INC     IX
042AA1 E6 0F       7000          		AND     0FH             ;MASK UNWANTED BITS
042AA3 80          7001          		ADD     A,B             ;ADD IN DIGIT
042AA4 47          7002          		LD      B,A
042AA5 0D          7003          		DEC     C
042AA6 F2 90 2A 04 7004          		JP      P,GETEX1
042AAA 06 64       7005          		LD      B,100           ;FORCE OVERFLOW
042AAC 18 E2       7006          		JR      GETEX1
042AAE 08          7007  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AAF FE 2D       7008          		CP      '-'
042AB1 78          7009          		LD      A,B
042AB2 C1          7010          		POP     BC              ;RESTORE
042AB3 C0          7011          		RET     NZ
042AB4 ED 44       7012          		NEG                     ;NEGATE EXPONENT
042AB6 C9          7013          		RET
042AB7             7014  ;
042AB7             7015  ;UINT: Get unsigned integer from string.
042AB7             7016  ;    Inputs: string at (IX)
042AB7             7017  ;            C = truncated digit count
042AB7             7018  ;                (initially zero)
042AB7             7019  ;            B = total digit count
042AB7             7020  ;            HLH'L' = initial value
042AB7             7021  ;   Outputs: HLH'L' = number (binary integer)
042AB7             7022  ;            A = delimiter.
042AB7             7023  ;            B, C & IX updated
042AB7             7024  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042AB7             7025  ;
042AB7 DD 23       7026  NUMBIX:			INC     IX
042AB9 CD 6B 2E 04 7027  UINT:			CALL    DIGITQ
042ABD D8          7028          		RET     C
042ABE 04          7029          		INC     B               ;INCREMENT DIGIT COUNT
042ABF DD 23       7030          		INC     IX
042AC1 CD B4 2C 04 7031          		CALL    X10             ;*10 & COPY OLD VALUE
042AC5 38 15       7032          		JR      C,NUMB1         ;OVERFLOW
042AC7 0D          7033          		DEC     C               ;SEE IF TRUNCATED
042AC8 0C          7034          		INC     C
042AC9 20 11       7035          		JR      NZ,NUMB1        ;IMPORTANT!
042ACB E6 0F       7036          		AND     0FH
042ACD D9          7037          		EXX
042ACE 06 00       7038          		LD      B,0
042AD0 4F          7039          		LD      C,A
042AD1 52 09       7040          		ADD.S   HL,BC           ;ADD IN DIGIT
042AD3 D9          7041          		EXX
042AD4 30 E3       7042          		JR      NC,UINT
042AD6 52 23       7043          		INC.S   HL              ;CARRY
042AD8 7C          7044          		LD      A,H
042AD9 B5          7045          		OR      L
042ADA 20 DD       7046          		JR      NZ,UINT
042ADC 0C          7047  NUMB1:			INC     C               ;TRUNCATION COUNTER
042ADD CD 12 2C 04 7048          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AE1 18 D6       7049          		JR      UINT
042AE3             7050  ;
042AE3             7051  ;FIX - Fix number to specified exponent value.
042AE3             7052  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AE3             7053  ;            A = desired exponent (A>C)
042AE3             7054  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AE3             7055  ;            fraction shifted into B'C'
042AE3             7056  ;            A'F' positive if integer input
042AE3             7057  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AE3             7058  ;
042AE3 08          7059  FIX:			EX      AF,AF'
042AE4 AF          7060          		XOR     A
042AE5 08          7061          		EX      AF,AF'
042AE6 CB FC       7062          		SET     7,H             ;IMPLIED 1
042AE8 CD 17 2C 04 7063  FIX1:			CALL    DIV2
042AEC B9          7064          		CP      C
042AED C8          7065          		RET     Z
042AEE D2 E8 2A 04 7066          		JP      NC,FIX1
042AF2 C3 26 2C 04 7067          		JP      OFLOW
042AF6             7068  ;
042AF6             7069  ;SFIX - Convert to integer if necessary.
042AF6             7070  ;    Input: Variable-type number in HLH'L'C
042AF6             7071  ;   Output: Integer in HLH'L', C=0
042AF6             7072  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042AF6             7073  ;
042AF6             7074  ;NEGATE - Negate HLH'L'
042AF6             7075  ;    Destroys: H,L,H',L',F
042AF6             7076  ;
042AF6 CD 0F 2C 04 7077  FIX2:			CALL    SWAP_FP
042AFA CD 02 2B 04 7078          		CALL    SFIX_FP
042AFE CD 0F 2C 04 7079          		CALL    SWAP_FP
042B02 0D          7080  SFIX_FP:			DEC     C
042B03 0C          7081          		INC     C
042B04 C8          7082          		RET     Z               ;INTEGER/ZERO
042B05 CB 7C       7083          		BIT     7,H             ;SIGN
042B07 F5          7084          		PUSH    AF
042B08 3E 9F       7085          		LD      A,159
042B0A CD E3 2A 04 7086          		CALL    FIX
042B0E F1          7087          		POP     AF
042B0F 0E 00       7088          		LD      C,0
042B11 C8          7089          		RET     Z
042B12 B7          7090  NEGATE:			OR      A               ;CLEAR CARRY
042B13 D9          7091          		EXX
042B14 D5          7092  NEG0:			PUSH    DE
042B15 EB          7093          		EX      DE,HL
042B16 21 00 00 00 7094          		LD      HL,0
042B1A 52 ED 52    7095          		SBC.S   HL,DE
042B1D D1          7096          		POP     DE
042B1E D9          7097          		EXX
042B1F D5          7098          		PUSH    DE
042B20 EB          7099          		EX      DE,HL
042B21 21 00 00 00 7100          		LD      HL,0
042B25 52 ED 52    7101          		SBC.S   HL,DE
042B28 D1          7102          		POP     DE
042B29 C9          7103          		RET
042B2A             7104  ;
042B2A             7105  ;NEG - Negate HLH'L'B'C'
042B2A             7106  ;    Also complements A (used in FADD)
042B2A             7107  ;    Destroys: A,H,L,B',C',H',L',F
042B2A             7108  ;
042B2A D9          7109  NEG_:			EXX
042B2B 2F          7110          		CPL
042B2C E5          7111          		PUSH    HL
042B2D B7          7112          		OR      A               ;CLEAR CARRY
042B2E 21 00 00 00 7113          		LD      HL,0
042B32 52 ED 42    7114          		SBC.S   HL,BC
042B35 44          7115          		LD      B,H
042B36 4D          7116          		LD      C,L
042B37 E1          7117          		POP     HL
042B38 18 DA       7118          		JR      NEG0
042B3A             7119  ;
042B3A             7120  ;SCALE - Trig scaling.
042B3A             7121  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B3A             7122  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B3A             7123  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B3A             7124  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B3A             7125  ;           E = quotient (bit 7 is sticky)
042B3A             7126  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B3A             7127  ;FLO48 - Float unsigned number (48 bits)
042B3A             7128  ;    Input/output in HLH'L'B'C'C
042B3A             7129  ;   Destroys: C,H,L,B',C',H',L',F
042B3A             7130  ;
042B3A 3E 96       7131  SCALE:			LD      A,150
042B3C B9          7132          		CP      C
042B3D 3E 17       7133          		LD      A,ACLOST
042B3F DA B5 20 04 7134          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B43 CD 80 26 04 7135          		CALL    PIBY4
042B47 D9          7136          		EXX
042B48 01 69 21 00 7137          		LD      BC,2169H        ;3.141592653589793238
042B4C D9          7138          		EXX
042B4D CB FA       7139  MOD48:			SET     7,D             ;IMPLIED 1
042B4F CB FC       7140          		SET     7,H
042B51 79          7141          		LD      A,C
042B52 0E 00       7142          		LD      C,0             ;INIT QUOTIENT
042B54 DD 21 00 00 7143          		LD      IX,0
       00          
042B59 DD E5       7144          		PUSH    IX              ;PUT ZERO ON STACK
042B5B B8          7145          		CP      B
042B5C 38 46       7146          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B5E D9          7147  MOD481:			EXX                     ;CARRY=0 HERE
042B5F E3          7148          		EX      (SP),HL
042B60 52 ED 42    7149          		SBC.S   HL,BC
042B63 E3          7150          		EX      (SP),HL
042B64 52 ED 52    7151          		SBC.S   HL,DE
042B67 D9          7152          		EXX
042B68 52 ED 52    7153          		SBC.S   HL,DE
042B6B 30 0C       7154          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B6D D9          7155          		EXX
042B6E E3          7156          		EX      (SP),HL
042B6F 52 09       7157          		ADD.S   HL,BC
042B71 E3          7158          		EX      (SP),HL
042B72 52 ED 5A    7159          		ADC.S   HL,DE
042B75 D9          7160          		EXX
042B76 52 ED 5A    7161          		ADC.S   HL,DE
042B79 3F          7162  MOD482:			CCF
042B7A CB 11       7163          		RL      C               ;QUOTIENT
042B7C 30 02       7164          		JR      NC,MOD483
042B7E CB F9       7165          		SET     7,C             ;STICKY BIT
042B80 3D          7166  MOD483:			DEC     A
042B81 B8          7167          		CP      B
042B82 38 1F       7168          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B84 E3          7169          		EX      (SP),HL
042B85 52 29       7170          		ADD.S   HL,HL           ;DIVIDEND * 2
042B87 E3          7171          		EX      (SP),HL
042B88 D9          7172          		EXX
042B89 52 ED 6A    7173          		ADC.S   HL,HL
042B8C D9          7174          		EXX
042B8D 52 ED 6A    7175          		ADC.S   HL,HL
042B90 30 CC       7176          		JR      NC,MOD481       ;AGAIN
042B92 B7          7177          		OR      A
042B93 D9          7178          		EXX
042B94 E3          7179          		EX      (SP),HL
042B95 52 ED 42    7180          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B98 E3          7181          		EX      (SP),HL
042B99 52 ED 52    7182          		SBC.S   HL,DE
042B9C D9          7183          		EXX
042B9D 52 ED 52    7184          		SBC.S   HL,DE
042BA0 B7          7185          		OR      A
042BA1 18 D6       7186          		JR      MOD482
042BA3             7187  ;
042BA3 3C          7188  MOD484:			INC     A
042BA4 59          7189  MOD485:			LD      E,C             ;QUOTIENT
042BA5 4F          7190          		LD      C,A             ;REMAINDER EXPONENT
042BA6 D9          7191          		EXX
042BA7 C1          7192          		POP     BC
042BA8 D9          7193          		EXX
042BA9 CB 7C       7194  FLO48:			BIT     7,H
042BAB C0          7195          		RET     NZ
042BAC D9          7196          		EXX
042BAD CB 21       7197          		SLA     C
042BAF CB 10       7198          		RL      B
042BB1 52 ED 6A    7199          		ADC.S   HL,HL
042BB4 D9          7200          		EXX
042BB5 52 ED 6A    7201          		ADC.S   HL,HL
042BB8 0D          7202          		DEC     C
042BB9 C2 A9 2B 04 7203          		JP      NZ,FLO48
042BBD C9          7204          		RET
042BBE             7205  ;
042BBE             7206  ;Float unsigned number
042BBE             7207  ;    Input/output in HLH'L'C
042BBE             7208  ;   Destroys: C,H,L,H',L',F
042BBE             7209  ;
042BBE CB 7C       7210  FLOAT_:			BIT     7,H
042BC0 C0          7211          		RET     NZ
042BC1 D9          7212          		EXX                     ;SAME AS "X2"
042BC2 52 29       7213          		ADD.S   HL,HL           ;TIME-CRITICAL
042BC4 D9          7214          		EXX                     ;REGION
042BC5 52 ED 6A    7215          		ADC.S   HL,HL           ;(BENCHMARKS)
042BC8 0D          7216          		DEC     C
042BC9 C2 BE 2B 04 7217          		JP      NZ,FLOAT_
042BCD C9          7218          		RET
042BCE             7219  ;
042BCE             7220  ;SFLOAT - Convert to floating-point if necessary.
042BCE             7221  ;    Input: Variable-type number in HLH'L'C
042BCE             7222  ;    Output: Floating-point in HLH'L'C
042BCE             7223  ;    Destroys: A,C,H,L,H',L',F
042BCE             7224  ;
042BCE 08          7225  FLOATA:			EX      AF,AF'
042BCF             7226          		; ADD     A,(RTABLE-DTABLE)/3
042BCF C6 2A       7227          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BD1 08          7228          		EX      AF,AF'
042BD2 CD 0F 2C 04 7229  FLOAT2:			CALL    SWAP_FP
042BD6 CD DE 2B 04 7230          		CALL    SFLOAT_FP
042BDA CD 0F 2C 04 7231          		CALL    SWAP_FP
042BDE 0D          7232  SFLOAT_FP:			DEC     C
042BDF 0C          7233          		INC     C
042BE0 C0          7234          		RET     NZ              ;ALREADY FLOATING-POINT
042BE1 CD 37 2C 04 7235          		CALL    TEST_FP
042BE5 C8          7236          		RET     Z               ;ZERO
042BE6 7C          7237          		LD      A,H
042BE7 B7          7238          		OR      A
042BE8 FC 12 2B 04 7239          		CALL    M,NEGATE
042BEC 0E 9F       7240          		LD      C,159
042BEE CD BE 2B 04 7241          		CALL    FLOAT_
042BF2 B7          7242          		OR      A
042BF3 F8          7243          		RET     M               ;NEGATIVE
042BF4 CB BC       7244          		RES     7,H
042BF6 C9          7245          		RET
042BF7             7246  ;
042BF7             7247  ;ROUND UP
042BF7             7248  ;Return with carry set if 32-bit overflow
042BF7             7249  ;   Destroys: H,L,B',C',H',L',F
042BF7             7250  ;
042BF7 D9          7251  ADD1_FP:			EXX
042BF8 01 01 00 00 7252          		LD      BC,1
042BFC 52 09       7253          		ADD.S   HL,BC
042BFE D9          7254          		EXX
042BFF D0          7255          		RET     NC
042C00 C5          7256          		PUSH    BC
042C01 01 01 00 00 7257          		LD      BC,1
042C05 52 09       7258          		ADD.S   HL,BC
042C07 C1          7259          		POP     BC
042C08 C9          7260          		RET
042C09             7261  ;
042C09             7262  ;ODD - Add one if even, leave alone if odd.
042C09             7263  ; (Used to perform unbiassed rounding, i.e.
042C09             7264  ;  number is rounded up half the time)
042C09             7265  ;    Destroys: L',F (carry cleared)
042C09             7266  ;
042C09 B7          7267  ODD:			OR      A               ;CLEAR CARRY
042C0A D9          7268          		EXX
042C0B CB C5       7269          		SET     0,L             ;MAKE ODD
042C0D D9          7270          		EXX
042C0E C9          7271          		RET
042C0F             7272  ;
042C0F             7273  ;SWAP_FP - Swap arguments.
042C0F             7274  ;    Exchanges DE,HL D'E',H'L' and B,C
042C0F             7275  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042C0F             7276  ;SWAP1 - Swap DEHL with D'E'H'L'
042C0F             7277  ;    Destroys: D,E,H,L,D',E',H',L'
042C0F             7278  ;
042C0F 79          7279  SWAP_FP:			LD      A,C
042C10 48          7280          		LD      C,B
042C11 47          7281          		LD      B,A
042C12 EB          7282  SWAP1:			EX      DE,HL
042C13 D9          7283          		EXX
042C14 EB          7284          		EX      DE,HL
042C15 D9          7285          		EXX
042C16 C9          7286          		RET
042C17             7287  ;
042C17             7288  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042C17             7289  ; INCC - destroys C,F
042C17             7290  ; OFLOW
042C17             7291  ;
042C17 CD D0 2C 04 7292  DIV2:			CALL    D2
042C1B D9          7293          		EXX
042C1C CB 18       7294          		RR      B
042C1E CB 19       7295          		RR      C
042C20 08          7296          		EX      AF,AF'
042C21 B0          7297          		OR      B
042C22 08          7298          		EX      AF,AF'
042C23 D9          7299          		EXX
042C24 0C          7300  INCC:			INC     C
042C25 C0          7301          		RET     NZ
042C26 3E 14       7302  OFLOW:			LD      A,TOOBIG_FP
042C28 C3 B5 20 04 7303          		JP      ERROR_FP_           ;"Too big"
042C2C             7304  ;
042C2C             7305  ; FTEST - Test for zero & sign
042C2C             7306  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042C2C             7307  ;
042C2C CD 37 2C 04 7308  FTEST_FP:			CALL    TEST_FP
042C30 C8          7309          		RET     Z
042C31 7C          7310          		LD      A,H
042C32 E6 80       7311          		AND     10000000B
042C34 F6 40       7312          		OR      01000000B
042C36 C9          7313          		RET
042C37             7314  ;
042C37             7315  ; TEST_FP - Test HLH'L' for zero.
042C37             7316  ;     Output: Z-flag set & A=0 if HLH'L'=0
042C37             7317  ;     Destroys: A,F
042C37             7318  ;
042C37 7C          7319  TEST_FP:			LD      A,H
042C38 B5          7320          		OR      L
042C39 D9          7321          		EXX
042C3A B4          7322          		OR      H
042C3B B5          7323          		OR      L
042C3C D9          7324          		EXX
042C3D C9          7325          		RET
042C3E             7326  ;
042C3E             7327  ; FCOMP - Compare two numbers
042C3E             7328  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C3E             7329  ;
042C3E 78          7330  FCOMP_FP:			LD      A,B
042C3F B1          7331          		OR      C               ;Both integer?
042C40 20 0B       7332          		JR      NZ,FCOMP1
042C42 CD 57 2C 04 7333          		CALL    ICP
042C46 3E 00       7334  FCOMP0:			LD      A,0
042C48 C8          7335          		RET     Z               ;Equal
042C49 3E 80       7336          		LD      A,80H
042C4B 1F          7337          		RRA
042C4C C9          7338          		RET
042C4D             7339  ;
042C4D CD D2 2B 04 7340  FCOMP1:			CALL    FLOAT2          ;Float both
042C51 CD 65 2C 04 7341          		CALL    FCP
042C55 18 EF       7342          		JR      FCOMP0
042C57             7343  ;
042C57             7344  ; Integer and floating point compare.
042C57             7345  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C57             7346  ; Result pre-set to FALSE
042C57             7347  ; ICP1, FCP1 destroy A,F
042C57             7348  ;
042C57             7349  ; ZERO - Return zero.
042C57             7350  ;  Destroys: A,C,H,L,H',L'
042C57             7351  ;
042C57 CD 8A 2C 04 7352  ICP:			CALL    ICP1
042C5B 3E 00       7353  ZERO_FP:			LD      A,0
042C5D D9          7354          		EXX
042C5E 67          7355          		LD      H,A
042C5F 6F          7356  	       		LD      L,A
042C60 D9          7357          		EXX
042C61 67          7358        			LD      H,A
042C62 6F          7359       			LD      L,A
042C63 4F          7360  	    		LD      C,A
042C64 C9          7361          		RET
042C65             7362  ;
042C65 CD 7C 2C 04 7363  FCP:			CALL    FCP1
042C69 18 F0       7364          		JR      ZERO_FP            ;PRESET FALSE
042C6B             7365  ;
042C6B 79          7366  FCP0:			LD      A,C
042C6C B8          7367          		CP      B               ;COMPARE EXPONENTS
042C6D C0          7368          		RET     NZ
042C6E             7369  ICP0:
042C6E 52 ED 52    7370  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C71 52 19       7371          		ADD.S   HL,DE
042C73 C0          7372          		RET     NZ
042C74 D9          7373          		EXX
042C75 52 ED 52    7374          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C78 52 19       7375          		ADD.S   HL,DE
042C7A D9          7376          		EXX
042C7B C9          7377          		RET
042C7C             7378  ;
042C7C 7C          7379  FCP1:			LD      A,H
042C7D AA          7380          		XOR     D
042C7E 7C          7381          		LD      A,H
042C7F 17          7382          		RLA
042C80 F8          7383          		RET     M
042C81 30 E8       7384          		JR      NC,FCP0
042C83 CD 6B 2C 04 7385          		CALL    FCP0
042C87 C8          7386          		RET     Z               ;** V0.1 BUG FIX
042C88 3F          7387          		CCF
042C89 C9          7388          		RET
042C8A             7389  ;
042C8A 7C          7390  ICP1:			LD      A,H
042C8B AA          7391          		XOR     D
042C8C F2 6E 2C 04 7392          		JP      P,ICP0
042C90 7C          7393          		LD      A,H
042C91 17          7394          		RLA
042C92 C9          7395          		RET
042C93             7396  ;
042C93             7397  ; ADD - Integer add.
042C93             7398  ; Carry, sign & zero flags valid on exit
042C93             7399  ;     Destroys: H,L,H',L',F
042C93             7400  ;
042C93 05          7401  X10B:			DEC     B
042C94 0C          7402          		INC     C
042C95 CD DC 2C 04 7403  X5:			CALL    COPY0
042C99 CD CF 2C 04 7404          		CALL    D2C
042C9D CD CF 2C 04 7405          		CALL    D2C
042CA1 08          7406          		EX      AF,AF'          ;SAVE CARRY
042CA2 D9          7407  ADD_:			EXX
042CA3 52 19       7408          		ADD.S   HL,DE
042CA5 D9          7409          		EXX
042CA6 52 ED 5A    7410          		ADC.S   HL,DE
042CA9 C9          7411          		RET
042CAA             7412  ;
042CAA             7413  ; SUB - Integer subtract.
042CAA             7414  ; Carry, sign & zero flags valid on exit
042CAA             7415  ;     Destroys: H,L,H',L',F
042CAA             7416  ;
042CAA D9          7417  SUB_:			EXX
042CAB B7          7418          		OR      A
042CAC 52 ED 52    7419          		SBC.S   HL,DE
042CAF D9          7420          		EXX
042CB0 52 ED 52    7421          		SBC.S   HL,DE
042CB3 C9          7422          		RET
042CB4             7423  ;
042CB4             7424  ; X10 - unsigned integer * 10
042CB4             7425  ;    Inputs: HLH'L' initial value
042CB4             7426  ;   Outputs: DED'E' = initial HLH'L'
042CB4             7427  ;            Carry bit set if overflow
042CB4             7428  ;            If carry not set HLH'L'=result
042CB4             7429  ;  Destroys: D,E,H,L,D',E',H',L',F
042CB4             7430  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042CB4             7431  ;     Carry set if MSB=1 before shift.
042CB4             7432  ;     Sign set if MSB=1 after shift.
042CB4             7433  ;     Destroys: H,L,H',L',F
042CB4             7434  ;
042CB4 CD DC 2C 04 7435  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CB8 CD C7 2C 04 7436          		CALL    X2
042CBC D8          7437          		RET     C               ;TOO BIG
042CBD CD C7 2C 04 7438          		CALL    X2
042CC1 D8          7439          		RET     C
042CC2 CD A2 2C 04 7440          		CALL    ADD_
042CC6 D8          7441          		RET     C
042CC7 D9          7442  X2:			EXX
042CC8 52 29       7443          		ADD.S   HL,HL
042CCA D9          7444          		EXX
042CCB 52 ED 6A    7445          		ADC.S   HL,HL
042CCE C9          7446          		RET
042CCF             7447  ;
042CCF             7448  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042CCF             7449  ;     Carry set if LSB=1 before shift.
042CCF             7450  ;     Destroys: H,L,H',L',F
042CCF             7451  ;
042CCF 0C          7452  D2C:			INC     C
042CD0 CB 3C       7453  D2:			SRL     H
042CD2 CB 1D       7454          		RR      L
042CD4 D9          7455          		EXX
042CD5 CB 1C       7456          		RR      H
042CD7 CB 1D       7457          		RR      L
042CD9 D9          7458          		EXX
042CDA C9          7459          		RET
042CDB             7460  ;
042CDB             7461  ; COPY - COPY HLH'L'C INTO DED'E'B
042CDB             7462  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CDB             7463  ;
042CDB 41          7464  COPY_:			LD      B,C
042CDC 54          7465  COPY0:			LD      D,H
042CDD 5D          7466          		LD      E,L
042CDE D9          7467          		EXX
042CDF 54          7468          		LD      D,H
042CE0 5D          7469          		LD      E,L
042CE1 D9          7470          		EXX
042CE2 C9          7471          		RET
042CE3             7472  ;
042CE3             7473  ; SQUARE - PUSH X*X
042CE3             7474  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CE3             7475  ;   Destroys: SP,IX
042CE3             7476  ;
042CE3 CD DB 2C 04 7477  SQUARE:			CALL    COPY_
042CE7 CD 46 23 04 7478          		CALL    FMUL
042CEB DD E1       7479  PUSH5:			POP     IX              ;RETURN ADDRESS
042CED C5          7480          		PUSH    BC
042CEE E5          7481          		PUSH    HL
042CEF D9          7482          		EXX
042CF0 E5          7483          		PUSH    HL
042CF1 D9          7484          		EXX
042CF2 DD E9       7485          		JP      (IX)            ;"RETURN"
042CF4             7486  ;
042CF4             7487  ; POP5 - POP DED'E'B OFF STACK.
042CF4             7488  ;   Destroys: A,B,D,E,D',E',SP,IX
042CF4             7489  ;
042CF4 DD E1       7490  POP5:			POP     IX              ;RETURN ADDRESS
042CF6 D9          7491          		EXX
042CF7 D1          7492          		POP     DE
042CF8 D9          7493          		EXX
042CF9 D1          7494          		POP     DE
042CFA 79          7495          		LD      A,C
042CFB C1          7496          		POP     BC
042CFC 41          7497          		LD      B,C
042CFD 4F          7498          		LD      C,A
042CFE DD E9       7499          		JP      (IX)            ;"RETURN"
042D00             7500  ;
042D00             7501  ; RATIO - Calculate (X-1)/(X+1)
042D00             7502  ;     Inputs: X in HLH'L'C
042D00             7503  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042D00             7504  ;   Destroys: Everything except IY,SP,I
042D00             7505  ;
042D00 CD EB 2C 04 7506  RATIO:			CALL    PUSH5           ;SAVE X
042D04 CD 73 26 04 7507          		CALL    DONE
042D08 CD 34 22 04 7508          		CALL    FADD
042D0C CD F4 2C 04 7509          		CALL    POP5            ;RESTORE X
042D10 CD EB 2C 04 7510          		CALL    PUSH5           ;SAVE X+1
042D14 CD 0F 2C 04 7511          		CALL    SWAP_FP
042D18 CD 73 26 04 7512          		CALL    DONE
042D1C CD 1B 22 04 7513          		CALL    FSUB
042D20 CD F4 2C 04 7514          		CALL    POP5            ;RESTORE X+1
042D24 C3 9D 22 04 7515          		JP      FDIV
042D28             7516  ;
042D28             7517  ; POLY - Evaluate a polynomial.
042D28             7518  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042D28             7519  ;             Polynomial coefficients follow call.
042D28             7520  ;    Outputs: Result in HLH'L'C
042D28             7521  ;   Destroys: Everything except IY,SP,I
042D28             7522  ; Routine terminates on finding a coefficient >=1.
042D28             7523  ; Note: The last coefficient is EXECUTED on return
042D28             7524  ;       so must contain only innocuous bytes!
042D28             7525  ;
042D28 DD 21 03 00 7526  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042D2D DD 39       7527          		ADD     IX, SP
042D2F DD E3       7528          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D31             7529  ;
042D31 CD 07 2A 04 7530          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042D35 CD 46 23 04 7531  POLY1:			CALL    FMUL
042D39 11 05 00 00 7532          		LD      DE, 5				; Skip to the next coefficient
042D3D DD 19       7533          		ADD     IX, DE
042D3F CD 07 2A 04 7534          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D43 DD E3       7535          		EX      (SP), IX			; Restore the SP just in case we need to return
042D45 04          7536          		INC     B
042D46 05          7537          		DEC     B               		; Test B for end byte (80h)
042D47 FA 34 22 04 7538          		JP      M,FADD				; Yes, so add and return
042D4B CD 34 22 04 7539          		CALL    FADD				; No, so add
042D4F CD 19 2A 04 7540          		CALL    DLOAD5_SPL			; Load X from SP
042D53 DD E3       7541          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D55 18 DE       7542          		JR      POLY1				; And loop
042D57             7543  ;
042D57             7544  ; POWR10 - Calculate power of ten.
042D57             7545  ;     Inputs: A=power of 10 required (A<128)
042D57             7546  ;             A=binary exponent to be exceeded (A>=128)
042D57             7547  ;    Outputs: DED'E'B = result
042D57             7548  ;             A = actual power of ten returned
042D57             7549  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D57             7550  ;
042D57 3C          7551  POWR10:			INC     A
042D58 08          7552          		EX      AF,AF'
042D59 E5          7553          		PUSH    HL
042D5A D9          7554          		EXX
042D5B E5          7555          		PUSH    HL
042D5C D9          7556          		EXX
042D5D CD 73 26 04 7557          		CALL    DONE
042D61 CD 0F 2C 04 7558          		CALL    SWAP_FP
042D65 AF          7559          		XOR     A
042D66 08          7560  POWR11:			EX      AF,AF'
042D67 3D          7561          		DEC     A
042D68 28 26       7562          		JR      Z,POWR14        ;EXIT TYPE 1
042D6A F2 72 2D 04 7563          		JP      P,POWR13
042D6E B9          7564          		CP      C
042D6F 38 1F       7565          		JR      C,POWR14        ;EXIT TYPE 2
042D71 3C          7566          		INC     A
042D72 08          7567  POWR13:			EX      AF,AF'
042D73 3C          7568          		INC     A
042D74 CB FC       7569          		SET     7,H
042D76 CD 95 2C 04 7570          		CALL    X5
042D7A 30 06       7571          		JR      NC,POWR12
042D7C 08          7572          		EX      AF,AF'
042D7D CD CF 2C 04 7573          		CALL    D2C
042D81 08          7574          		EX      AF,AF'
042D82 08          7575  POWR12:			EX      AF,AF'
042D83 DC F7 2B 04 7576          		CALL    C,ADD1_FP          ;ROUND UP
042D87 0C          7577          		INC     C
042D88 FA 66 2D 04 7578          		JP      M,POWR11
042D8C C3 26 2C 04 7579          		JP      OFLOW
042D90 CD 0F 2C 04 7580  POWR14:			CALL    SWAP_FP
042D94 CB BA       7581          		RES     7,D
042D96 D9          7582          		EXX
042D97 E1          7583          		POP     HL
042D98 D9          7584          		EXX
042D99 E1          7585          		POP     HL
042D9A 08          7586          		EX      AF,AF'
042D9B C9          7587          		RET
042D9C             7588  ;
042D9C             7589  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D9C             7590  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D9C             7591  ;               Remainder in H'L'HL
042D9C             7592  ;     Inputs: A = loop counter (normally -32)
042D9C             7593  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D9C             7594  ;
042D9C B7          7595  DIVA:			OR      A               ;CLEAR CARRY
042D9D             7596  DIV0:
042D9D 52 ED 42    7597  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DA0 D9          7598          		EXX
042DA1 52 ED 42    7599          		SBC.S   HL,BC
042DA4 D9          7600          		EXX
042DA5 30 07       7601          		JR      NC,DIV1
042DA7 52 09       7602          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA9 D9          7603          		EXX
042DAA 52 ED 4A    7604          		ADC.S   HL,BC
042DAD D9          7605          		EXX
042DAE 3F          7606  DIV1:			CCF
042DAF CB 13       7607  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DB1 CB 12       7608          		RL      D
042DB3 D9          7609          		EXX
042DB4 CB 13       7610          		RL      E
042DB6 CB 12       7611          		RL      D
042DB8 D9          7612          		EXX
042DB9 3C          7613          		INC     A
042DBA F0          7614          		RET     P
042DBB             7615  DIVB:
042DBB 52 ED 6A    7616  			ADC.S   HL,HL           ;DIVIDEND*2
042DBE D9          7617          		EXX
042DBF 52 ED 6A    7618          		ADC.S   HL,HL
042DC2 D9          7619          		EXX
042DC3 30 D8       7620          		JR      NC,DIV0
042DC5 B7          7621          		OR      A
042DC6 52 ED 42    7622          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DC9 D9          7623          		EXX
042DCA 52 ED 42    7624          		SBC.S   HL,BC
042DCD D9          7625          		EXX
042DCE 37          7626          		SCF
042DCF C3 AF 2D 04 7627          		JP      DIVC
042DD3             7628  ;
042DD3             7629  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042DD3             7630  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042DD3             7631  ;    Inputs: A = loop counter (usually -32)
042DD3             7632  ;            H'L'HL = 0
042DD3             7633  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042DD3             7634  ;
042DD3 B7          7635  MULA:			OR      A               ;CLEAR CARRY
042DD4 D9          7636  MUL0:			EXX
042DD5 CB 1A       7637          		RR      D               ;MULTIPLIER/2
042DD7 CB 1B       7638          		RR      E
042DD9 D9          7639          		EXX
042DDA CB 1A       7640          		RR      D
042DDC CB 1B       7641          		RR      E
042DDE 30 07       7642          		JR      NC,MUL1
042DE0 52 09       7643          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DE2 D9          7644          		EXX
042DE3 52 ED 4A    7645          		ADC.S   HL,BC
042DE6 D9          7646          		EXX
042DE7 3C          7647  MUL1:			INC     A
042DE8 F0          7648          		RET     P
042DE9 D9          7649  MULB:			EXX
042DEA CB 1C       7650          		RR      H               ;PRODUCT/2
042DEC CB 1D       7651          		RR      L
042DEE D9          7652          		EXX
042DEF CB 1C       7653          		RR      H
042DF1 CB 1D       7654          		RR      L
042DF3 C3 D4 2D 04 7655          		JP      MUL0
042DF7             7656  ;
042DF7             7657  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DF7             7658  ;     Function: B'C'BC = SQR (D'E'DE)
042DF7             7659  ;     Inputs: A = loop counter (normally -31)
042DF7             7660  ;             B'C'BCH'L'HL initialised to 0
042DF7             7661  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DF7             7662  ;
042DF7             7663  SQR1:
042DF7 52 ED 42    7664  			SBC.S   HL,BC
042DFA D9          7665          		EXX
042DFB 52 ED 42    7666          		SBC.S   HL,BC
042DFE D9          7667          		EXX
042DFF 0C          7668          		INC     C
042E00 30 09       7669          		JR      NC,SQR2
042E02 0D          7670          		DEC     C
042E03 52 09       7671          		ADD.S   HL,BC
042E05 D9          7672          		EXX
042E06 52 ED 4A    7673          		ADC.S   HL,BC
042E09 D9          7674          		EXX
042E0A 0D          7675          		DEC     C
042E0B 3C          7676  SQR2:			INC     A
042E0C F0          7677          		RET     P
042E0D CB 21       7678  SQRA:			SLA     C
042E0F CB 10       7679          		RL      B
042E11 D9          7680          		EXX
042E12 CB 11       7681          		RL      C
042E14 CB 10       7682          		RL      B
042E16 D9          7683          		EXX
042E17 0C          7684          		INC     C
042E18 CB 23       7685          		SLA     E
042E1A CB 12       7686          		RL      D
042E1C D9          7687          		EXX
042E1D CB 13       7688          		RL      E
042E1F CB 12       7689          		RL      D
042E21 D9          7690          		EXX
042E22 52 ED 6A    7691          		ADC.S   HL,HL
042E25 D9          7692          		EXX
042E26 52 ED 6A    7693          		ADC.S   HL,HL
042E29 D9          7694          		EXX
042E2A CB 23       7695          		SLA     E
042E2C CB 12       7696          		RL      D
042E2E D9          7697          		EXX
042E2F CB 13       7698          		RL      E
042E31 CB 12       7699          		RL      D
042E33 D9          7700          		EXX
042E34 52 ED 6A    7701          		ADC.S   HL,HL
042E37 D9          7702          		EXX
042E38 52 ED 6A    7703          		ADC.S   HL,HL
042E3B D9          7704          		EXX
042E3C D2 F7 2D 04 7705          		JP      NC,SQR1
042E40 B7          7706  SQR3:			OR      A
042E41 52 ED 42    7707          		SBC.S   HL,BC
042E44 D9          7708          		EXX
042E45 52 ED 42    7709          		SBC.S   HL,BC
042E48 D9          7710          		EXX
042E49 0C          7711          		INC     C
042E4A C3 0B 2E 04 7712          		JP      SQR2
042E4E             7713  ;
042E4E             7714  SQRB:
042E4E 52 29       7715  			ADD.S   HL,HL
042E50 D9          7716          		EXX
042E51 52 ED 6A    7717          		ADC.S   HL,HL
042E54 D9          7718          		EXX
042E55 38 E9       7719          		JR      C,SQR3
042E57 3C          7720          		INC     A
042E58 0C          7721          		INC     C
042E59 52 ED 42    7722          		SBC.S   HL,BC
042E5C D9          7723          		EXX
042E5D 52 ED 42    7724          		SBC.S   HL,BC
042E60 D9          7725          		EXX
042E61 D0          7726          		RET     NC
042E62 52 09       7727          		ADD.S   HL,BC
042E64 D9          7728          		EXX
042E65 52 ED 4A    7729          		ADC.S   HL,BC
042E68 D9          7730          		EXX
042E69 0D          7731          		DEC     C
042E6A C9          7732          		RET
042E6B             7733  ;
042E6B DD 7E 00    7734  DIGITQ:			LD      A,(IX)
042E6E FE 3A       7735          		CP      '9'+1
042E70 3F          7736          		CCF
042E71 D8          7737          		RET     C
042E72 FE 30       7738          		CP      '0'
042E74 C9          7739          		RET
042E75             7740  ;
042E75 DD 7E 00    7741  SIGNQ:			LD      A,(IX)
042E78 DD 23       7742          		INC     IX
042E7A FE 20       7743          		CP      ' '
042E7C 28 F7       7744          		JR      Z,SIGNQ
042E7E FE 2B       7745          		CP      '+'
042E80 C8          7746          		RET     Z
042E81 FE 2D       7747          		CP      '-'
042E83 C8          7748          		RET     Z
042E84 DD 2B       7749          		DEC     IX
042E86 C9          7750          		RET; --- End fpp.asm ---
042E87             7751  
042E87             7752  ; --- Begin gpio.asm ---
042E87             7753  ;
042E87             7754  ; Title:	BBC Basic for AGON - GPIO functions
042E87             7755  ; Author:	Dean Belfield
042E87             7756  ; Created:	12/05/2023
042E87             7757  ; Last Updated:	12/05/2023
042E87             7758  ;
042E87             7759  ; Modinfo:
042E87             7760  
042E87             7761  			; INCLUDE	"macros.inc"
042E87             7762  			; INCLUDE	"equs.inc"
042E87             7763  
042E87             7764  			; .ASSUME	ADL = 1
042E87             7765  
042E87             7766  			; SEGMENT CODE
042E87             7767  
042E87             7768  			; XDEF	GPIOB_SETMODE
042E87             7769  
042E87             7770  			; XREF	SWITCH_A
042E87             7771  
042E87             7772  ;  A: Mode
042E87             7773  ;  B: Pins
042E87             7774  ;
042E87 CD 2C 3E 04 7775  GPIOB_SETMODE:		CALL	SWITCH_A
042E8B 9F 2E       7776  			DW	GPIOB_M0	; Output
042E8D C4 2E       7777  			DW	GPIOB_M1	; Input
042E8F E4 2E       7778  			DW	GPIOB_M2	; Open Drain IO
042E91 04 2F       7779  			DW	GPIOB_M3	; Open Source IO
042E93 1F 2F       7780  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E95 4B 2F       7781  			DW	GPIOB_M5	; Alt Function
042E97 66 2F       7782  			DW	GPIOB_M6	; Interrupt, Active Low
042E99 8D 2F       7783  			DW	GPIOB_M7	; Interrupt, Active High
042E9B AF 2F       7784  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E9D D1 2F       7785  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E9F             7786  
042E9F             7787  ; Output
042E9F             7788  ;
042E9F             7789  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E9F C5          0001M 		PUSH	BC
042EA0 78          0002M 		LD	A, val
042EA1 2F          0003M 		CPL
042EA2 4F          0004M 		LD	C, A
042EA3 ED 38 9B    0005M 		IN0	A, (reg)
042EA6 A1          0006M 		AND	C
042EA7 ED 39 9B    0007M 		OUT0	(reg), A
042EAA C1          0008M 		POP	BC
042EAB             7790  			RES_GPIO PB_ALT1, B
042EAB C5          0001M 		PUSH	BC
042EAC 78          0002M 		LD	A, val
042EAD 2F          0003M 		CPL
042EAE 4F          0004M 		LD	C, A
042EAF ED 38 9C    0005M 		IN0	A, (reg)
042EB2 A1          0006M 		AND	C
042EB3 ED 39 9C    0007M 		OUT0	(reg), A
042EB6 C1          0008M 		POP	BC
042EB7             7791  			RES_GPIO PB_ALT2, B
042EB7 C5          0001M 		PUSH	BC
042EB8 78          0002M 		LD	A, val
042EB9 2F          0003M 		CPL
042EBA 4F          0004M 		LD	C, A
042EBB ED 38 9D    0005M 		IN0	A, (reg)
042EBE A1          0006M 		AND	C
042EBF ED 39 9D    0007M 		OUT0	(reg), A
042EC2 C1          0008M 		POP	BC
042EC3 C9          7792  			RET
042EC4             7793  
042EC4             7794  ; Input
042EC4             7795  ;
042EC4             7796  GPIOB_M1:		SET_GPIO PB_DDR,  B
042EC4 ED 38 9B    0001M 		IN0	A, (reg)
042EC7 B0          0002M 		OR	val
042EC8 ED 39 9B    0003M 		OUT0	(reg), A
042ECB             7797  			RES_GPIO PB_ALT1, B
042ECB C5          0001M 		PUSH	BC
042ECC 78          0002M 		LD	A, val
042ECD 2F          0003M 		CPL
042ECE 4F          0004M 		LD	C, A
042ECF ED 38 9C    0005M 		IN0	A, (reg)
042ED2 A1          0006M 		AND	C
042ED3 ED 39 9C    0007M 		OUT0	(reg), A
042ED6 C1          0008M 		POP	BC
042ED7             7798  			RES_GPIO PB_ALT2, B
042ED7 C5          0001M 		PUSH	BC
042ED8 78          0002M 		LD	A, val
042ED9 2F          0003M 		CPL
042EDA 4F          0004M 		LD	C, A
042EDB ED 38 9D    0005M 		IN0	A, (reg)
042EDE A1          0006M 		AND	C
042EDF ED 39 9D    0007M 		OUT0	(reg), A
042EE2 C1          0008M 		POP	BC
042EE3 C9          7799  			RET
042EE4             7800  
042EE4             7801  ; Open Drain IO
042EE4             7802  ;
042EE4             7803  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EE4 C5          0001M 		PUSH	BC
042EE5 78          0002M 		LD	A, val
042EE6 2F          0003M 		CPL
042EE7 4F          0004M 		LD	C, A
042EE8 ED 38 9B    0005M 		IN0	A, (reg)
042EEB A1          0006M 		AND	C
042EEC ED 39 9B    0007M 		OUT0	(reg), A
042EEF C1          0008M 		POP	BC
042EF0             7804  			SET_GPIO PB_ALT1, B
042EF0 ED 38 9C    0001M 		IN0	A, (reg)
042EF3 B0          0002M 		OR	val
042EF4 ED 39 9C    0003M 		OUT0	(reg), A
042EF7             7805  			RES_GPIO PB_ALT2, B
042EF7 C5          0001M 		PUSH	BC
042EF8 78          0002M 		LD	A, val
042EF9 2F          0003M 		CPL
042EFA 4F          0004M 		LD	C, A
042EFB ED 38 9D    0005M 		IN0	A, (reg)
042EFE A1          0006M 		AND	C
042EFF ED 39 9D    0007M 		OUT0	(reg), A
042F02 C1          0008M 		POP	BC
042F03 C9          7806  			RET
042F04             7807  
042F04             7808  ; Open Source IO
042F04             7809  ;
042F04             7810  GPIOB_M3:		SET_GPIO PB_DDR,  B
042F04 ED 38 9B    0001M 		IN0	A, (reg)
042F07 B0          0002M 		OR	val
042F08 ED 39 9B    0003M 		OUT0	(reg), A
042F0B             7811  			SET_GPIO PB_ALT1, B
042F0B ED 38 9C    0001M 		IN0	A, (reg)
042F0E B0          0002M 		OR	val
042F0F ED 39 9C    0003M 		OUT0	(reg), A
042F12             7812  			RES_GPIO PB_ALT2, B
042F12 C5          0001M 		PUSH	BC
042F13 78          0002M 		LD	A, val
042F14 2F          0003M 		CPL
042F15 4F          0004M 		LD	C, A
042F16 ED 38 9D    0005M 		IN0	A, (reg)
042F19 A1          0006M 		AND	C
042F1A ED 39 9D    0007M 		OUT0	(reg), A
042F1D C1          0008M 		POP	BC
042F1E C9          7813  			RET
042F1F             7814  
042F1F             7815  ; Interrupt, Dual Edge
042F1F             7816  ;
042F1F             7817  GPIOB_M4:		SET_GPIO PB_DR,   B
042F1F ED 38 9A    0001M 		IN0	A, (reg)
042F22 B0          0002M 		OR	val
042F23 ED 39 9A    0003M 		OUT0	(reg), A
042F26             7818  			RES_GPIO PB_DDR,  B
042F26 C5          0001M 		PUSH	BC
042F27 78          0002M 		LD	A, val
042F28 2F          0003M 		CPL
042F29 4F          0004M 		LD	C, A
042F2A ED 38 9B    0005M 		IN0	A, (reg)
042F2D A1          0006M 		AND	C
042F2E ED 39 9B    0007M 		OUT0	(reg), A
042F31 C1          0008M 		POP	BC
042F32             7819  			RES_GPIO PB_ALT1, B
042F32 C5          0001M 		PUSH	BC
042F33 78          0002M 		LD	A, val
042F34 2F          0003M 		CPL
042F35 4F          0004M 		LD	C, A
042F36 ED 38 9C    0005M 		IN0	A, (reg)
042F39 A1          0006M 		AND	C
042F3A ED 39 9C    0007M 		OUT0	(reg), A
042F3D C1          0008M 		POP	BC
042F3E             7820  			RES_GPIO PB_ALT2, B
042F3E C5          0001M 		PUSH	BC
042F3F 78          0002M 		LD	A, val
042F40 2F          0003M 		CPL
042F41 4F          0004M 		LD	C, A
042F42 ED 38 9D    0005M 		IN0	A, (reg)
042F45 A1          0006M 		AND	C
042F46 ED 39 9D    0007M 		OUT0	(reg), A
042F49 C1          0008M 		POP	BC
042F4A C9          7821  			RET
042F4B             7822  
042F4B             7823  ; Alt Function
042F4B             7824  ;
042F4B             7825  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F4B ED 38 9B    0001M 		IN0	A, (reg)
042F4E B0          0002M 		OR	val
042F4F ED 39 9B    0003M 		OUT0	(reg), A
042F52             7826  			RES_GPIO PB_ALT1, B
042F52 C5          0001M 		PUSH	BC
042F53 78          0002M 		LD	A, val
042F54 2F          0003M 		CPL
042F55 4F          0004M 		LD	C, A
042F56 ED 38 9C    0005M 		IN0	A, (reg)
042F59 A1          0006M 		AND	C
042F5A ED 39 9C    0007M 		OUT0	(reg), A
042F5D C1          0008M 		POP	BC
042F5E             7827  			SET_GPIO PB_ALT2, B
042F5E ED 38 9D    0001M 		IN0	A, (reg)
042F61 B0          0002M 		OR	val
042F62 ED 39 9D    0003M 		OUT0	(reg), A
042F65 C9          7828  			RET
042F66             7829  
042F66             7830  ; Interrupt, Active Low
042F66             7831  ;
042F66             7832  GPIOB_M6:		RES_GPIO PB_DR,   B
042F66 C5          0001M 		PUSH	BC
042F67 78          0002M 		LD	A, val
042F68 2F          0003M 		CPL
042F69 4F          0004M 		LD	C, A
042F6A ED 38 9A    0005M 		IN0	A, (reg)
042F6D A1          0006M 		AND	C
042F6E ED 39 9A    0007M 		OUT0	(reg), A
042F71 C1          0008M 		POP	BC
042F72             7833  			RES_GPIO PB_DDR,  B
042F72 C5          0001M 		PUSH	BC
042F73 78          0002M 		LD	A, val
042F74 2F          0003M 		CPL
042F75 4F          0004M 		LD	C, A
042F76 ED 38 9B    0005M 		IN0	A, (reg)
042F79 A1          0006M 		AND	C
042F7A ED 39 9B    0007M 		OUT0	(reg), A
042F7D C1          0008M 		POP	BC
042F7E             7834  			SET_GPIO PB_ALT1, B
042F7E ED 38 9C    0001M 		IN0	A, (reg)
042F81 B0          0002M 		OR	val
042F82 ED 39 9C    0003M 		OUT0	(reg), A
042F85             7835  			SET_GPIO PB_ALT2, B
042F85 ED 38 9D    0001M 		IN0	A, (reg)
042F88 B0          0002M 		OR	val
042F89 ED 39 9D    0003M 		OUT0	(reg), A
042F8C C9          7836  			RET
042F8D             7837  
042F8D             7838  
042F8D             7839  ; Interrupt, Active High
042F8D             7840  ;
042F8D             7841  GPIOB_M7:		SET_GPIO PB_DR,   B
042F8D ED 38 9A    0001M 		IN0	A, (reg)
042F90 B0          0002M 		OR	val
042F91 ED 39 9A    0003M 		OUT0	(reg), A
042F94             7842  			RES_GPIO PB_DDR,  B
042F94 C5          0001M 		PUSH	BC
042F95 78          0002M 		LD	A, val
042F96 2F          0003M 		CPL
042F97 4F          0004M 		LD	C, A
042F98 ED 38 9B    0005M 		IN0	A, (reg)
042F9B A1          0006M 		AND	C
042F9C ED 39 9B    0007M 		OUT0	(reg), A
042F9F C1          0008M 		POP	BC
042FA0             7843  			SET_GPIO PB_ALT1, B
042FA0 ED 38 9C    0001M 		IN0	A, (reg)
042FA3 B0          0002M 		OR	val
042FA4 ED 39 9C    0003M 		OUT0	(reg), A
042FA7             7844  			SET_GPIO PB_ALT2, B
042FA7 ED 38 9D    0001M 		IN0	A, (reg)
042FAA B0          0002M 		OR	val
042FAB ED 39 9D    0003M 		OUT0	(reg), A
042FAE C9          7845  			RET
042FAF             7846  
042FAF             7847  
042FAF             7848  ; Interrupt, Falling Edge
042FAF             7849  ;
042FAF             7850  GPIOB_M8:		RES_GPIO PB_DR,   B
042FAF C5          0001M 		PUSH	BC
042FB0 78          0002M 		LD	A, val
042FB1 2F          0003M 		CPL
042FB2 4F          0004M 		LD	C, A
042FB3 ED 38 9A    0005M 		IN0	A, (reg)
042FB6 A1          0006M 		AND	C
042FB7 ED 39 9A    0007M 		OUT0	(reg), A
042FBA C1          0008M 		POP	BC
042FBB             7851  			SET_GPIO PB_DDR,  B
042FBB ED 38 9B    0001M 		IN0	A, (reg)
042FBE B0          0002M 		OR	val
042FBF ED 39 9B    0003M 		OUT0	(reg), A
042FC2             7852  			SET_GPIO PB_ALT1, B
042FC2 ED 38 9C    0001M 		IN0	A, (reg)
042FC5 B0          0002M 		OR	val
042FC6 ED 39 9C    0003M 		OUT0	(reg), A
042FC9             7853  			SET_GPIO PB_ALT2, B
042FC9 ED 38 9D    0001M 		IN0	A, (reg)
042FCC B0          0002M 		OR	val
042FCD ED 39 9D    0003M 		OUT0	(reg), A
042FD0 C9          7854  			RET
042FD1             7855  
042FD1             7856  ; Interrupt, Rising Edge
042FD1             7857  ;
042FD1             7858  GPIOB_M9:		SET_GPIO PB_DR,   B
042FD1 ED 38 9A    0001M 		IN0	A, (reg)
042FD4 B0          0002M 		OR	val
042FD5 ED 39 9A    0003M 		OUT0	(reg), A
042FD8             7859  			SET_GPIO PB_DDR,  B
042FD8 ED 38 9B    0001M 		IN0	A, (reg)
042FDB B0          0002M 		OR	val
042FDC ED 39 9B    0003M 		OUT0	(reg), A
042FDF             7860  			SET_GPIO PB_ALT1, B
042FDF ED 38 9C    0001M 		IN0	A, (reg)
042FE2 B0          0002M 		OR	val
042FE3 ED 39 9C    0003M 		OUT0	(reg), A
042FE6             7861  			SET_GPIO PB_ALT2, B
042FE6 ED 38 9D    0001M 		IN0	A, (reg)
042FE9 B0          0002M 		OR	val
042FEA ED 39 9D    0003M 		OUT0	(reg), A
042FED C9          7862  			RET	; --- End gpio.asm ---
042FEE             7863  
042FEE             7864  ; --- Begin main.asm ---
042FEE             7865  ;
042FEE             7866  ; Title:	BBC Basic Interpreter - Z80 version
042FEE             7867  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FEE             7868  ; Author:	(C) Copyright  R.T.Russell  1984
042FEE             7869  ; Modified By:	Dean Belfield
042FEE             7870  ; Created:	12/05/2023
042FEE             7871  ; Last Updated:	26/11/2023
042FEE             7872  ;
042FEE             7873  ; Modinfo:
042FEE             7874  ; 07/05/1984:	Version 2.3
042FEE             7875  ; 01/03/1987:	Version 3.0
042FEE             7876  ; 03/05/2022:	Modified by Dean Belfield
042FEE             7877  ; 06/06/2023:	Modified to run in ADL mode
042FEE             7878  ; 26/06/2023:	Fixed binary and unary indirection
042FEE             7879  ; 17/08/2023:	Added binary constants
042FEE             7880  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FEE             7881  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FEE             7882  
042FEE             7883  			; .ASSUME	ADL = 1
042FEE             7884  
042FEE             7885  			; INCLUDE	"equs.inc"
042FEE             7886  
042FEE             7887  			; SEGMENT CODE
042FEE             7888  
042FEE             7889  			; XDEF	_main
042FEE             7890  
042FEE             7891  			; XDEF	COLD
042FEE             7892  			; XDEF	WARM
042FEE             7893  			; XDEF	CLOOP
042FEE             7894  			; XDEF	DELETE
042FEE             7895  			; XDEF	LIST_
042FEE             7896  			; XDEF	RENUM
042FEE             7897  			; XDEF	AUTO
042FEE             7898  			; XDEF	NEW
042FEE             7899  			; XDEF	OLD
042FEE             7900  			; XDEF	LOAD
042FEE             7901  			; XDEF	SAVE
042FEE             7902  			; XDEF	ERROR_
042FEE             7903  			; XDEF	EXTERR
042FEE             7904  			; XDEF	LOAD0
042FEE             7905  			; XDEF	CLEAR
042FEE             7906  			; XDEF	CRLF
042FEE             7907  			; XDEF	OUTCHR
042FEE             7908  			; XDEF	OUT_
042FEE             7909  			; XDEF	FINDL
042FEE             7910  			; XDEF	SETLIN
042FEE             7911  			; XDEF	PBCDL
042FEE             7912  			; XDEF	SAYLN
042FEE             7913  			; XDEF	PUTVAR
042FEE             7914  			; XDEF	GETVAR
042FEE             7915  			; XDEF	GETDEF
042FEE             7916  			; XDEF	CREATE
042FEE             7917  			; XDEF	RANGE
042FEE             7918  			; XDEF	LEXAN2
042FEE             7919  			; XDEF	REPORT
042FEE             7920  			; XDEF	TELL
042FEE             7921  			; XDEF	SPACE_
042FEE             7922  			; XDEF	KEYWDS
042FEE             7923  			; XDEF	KEYWDL
042FEE             7924  			; XDEF	ONEDIT
042FEE             7925  			; XDEF	ONEDIT1
042FEE             7926  			; XDEF	LISTIT
042FEE             7927  			; XDEF	CLEAN
042FEE             7928  
042FEE             7929  			; XREF	LISTON
042FEE             7930  			; XREF	ERRTXT
042FEE             7931  			; XREF	OSINIT
042FEE             7932  			; XREF	HIMEM
042FEE             7933  			; XREF	PAGE_
042FEE             7934  			; XREF	CHAIN0
042FEE             7935  			; XREF	PROMPT
042FEE             7936  			; XREF	ERRTRP
042FEE             7937  			; XREF	ERRLIN
042FEE             7938  			; XREF	AUTONO
042FEE             7939  			; XREF	LINENO
042FEE             7940  			; XREF	INCREM
042FEE             7941  			; XREF	OSLINE
042FEE             7942  			; XREF	COUNT
042FEE             7943  			; XREF	NXT
042FEE             7944  			; XREF	BUFFER
042FEE             7945  			; XREF	XEQ
042FEE             7946  			; XREF	TOP
042FEE             7947  			; XREF	EXPRI
042FEE             7948  			; XREF	SEARCH
042FEE             7949  			; XREF	LTRAP
042FEE             7950  			; XREF	LOMEM
042FEE             7951  			; XREF	DECODE
042FEE             7952  			; XREF	EXPRS
042FEE             7953  			; XREF	OSSAVE
042FEE             7954  			; XREF	ERR
042FEE             7955  			; XREF	ERL
042FEE             7956  			; XREF	TRACEN
042FEE             7957  			; XREF	RESET
042FEE             7958  			; XREF	OSSHUT
042FEE             7959  			; XREF	OSLOAD
042FEE             7960  			; XREF	FREE
042FEE             7961  			; XREF	DYNVAR
042FEE             7962  			; XREF	FILL
042FEE             7963  			; XREF	OSWRCH
042FEE             7964  			; XREF	WIDTH
042FEE             7965  			; XREF	COMMA
042FEE             7966  			; XREF	MUL16
042FEE             7967  			; XREF	BRAKET
042FEE             7968  			; XREF	X4OR5
042FEE             7969  			; XREF	LOADN
042FEE             7970  			; XREF	SFIX
042FEE             7971  			; XREF	ITEMI
042FEE             7972  			; XREF	FNPTR
042FEE             7973  			; XREF	PROPTR
042FEE             7974  			; XREF	CHECK
042FEE             7975  			; XREF	TERMQ
042FEE             7976  			; XREF	OSWRCHCH
042FEE             7977  			; XREF	NEWIT
042FEE             7978  			; XREF	BAD
042FEE             7979  			; XREF	RAM_START
042FEE             7980  			; XREF	RAM_END
042FEE             7981  			; XREF	R0
042FEE             7982  			; XREF	STAR_VERSION
042FEE             7983  
042FEE             7984  			; XREF	_end			; In init.asm
042FEE             7985  ;
042FEE             7986  ; A handful of common token IDs
042FEE             7987  ;
042FEE             7988  TERROR_MN:			EQU     85H
042FEE             7989  LINE_MN_:			EQU     86H
042FEE             7990  ELSE_MN_:			EQU     8BH
042FEE             7991  THEN_MN_:			EQU     8CH
042FEE             7992  LINO_MN:			EQU     8DH
042FEE             7993  FN:			EQU     A4H
042FEE             7994  TO_MN:			EQU     B8H
042FEE             7995  REN:			EQU     CCH
042FEE             7996  DATA_MN_:			EQU     DCH
042FEE             7997  DIM:			EQU     DEH
042FEE             7998  FOR:			EQU     E3H
042FEE             7999  GOSUB:			EQU     E4H
042FEE             8000  GOTO:			EQU     E5H
042FEE             8001  TIF:			EQU     E7H
042FEE             8002  LOCAL_:			EQU     EAH
042FEE             8003  NEXT:			EQU     EDH
042FEE             8004  ON_:			EQU     EEH
042FEE             8005  PROC:			EQU     F2H
042FEE             8006  REM:			EQU     F4H
042FEE             8007  REPEAT:			EQU     F5H
042FEE             8008  RESTOR:			EQU     F7H
042FEE             8009  TRACE:			EQU     FCH
042FEE             8010  UNTIL:			EQU     FDH
042FEE             8011  ;
042FEE             8012  ; This defines the block of tokens that are pseudo-variables.
042FEE             8013  ; There are two versions of each token, a GET and a SET
042FEE             8014  
042FEE             8015  ; Name  : GET : SET
042FEE             8016  ; ------:-----:----
042FEE             8017  ; PTR   : 8Fh : CFh
042FEE             8018  ; PAGE  : 90h : D0h
042FEE             8019  ; TIME  : 91h : D1h
042FEE             8020  ; LOMEM : 92h : D2h
042FEE             8021  ; HIMEM : 93h : D3h
042FEE             8022  ;
042FEE             8023  ; Examples:
042FEE             8024  ;   LET A% = PAGE : REM This is the GET version
042FEE             8025  ;   PAGE = 40000  : REM This is the SET version
042FEE             8026  ;
042FEE             8027  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FEE             8028  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FEE             8029  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FEE             8030  
042FEE             8031  ; The main routine
042FEE             8032  ; IXU: argv - pointer to array of parameters
042FEE             8033  ;   C: argc - number of parameters
042FEE             8034  ; Returns:
042FEE             8035  ;  HL: Error code, or 0 if OK
042FEE             8036  ;
042FEE 21 00 4A 04 8037  _main:			LD	HL, ACCS		; Clear the ACCS
042FF2 36 00       8038  			LD	(HL), 0
042FF4 79          8039  			LD	A, C
042FF5 FE 02       8040  			CP	2
042FF7 28 2D       8041  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF9 38 3F       8042  			JR	C, COLD			; 1 parameter = normal start
042FFB CD 81 40 04 8043  			CALL	STAR_VERSION
042FFF CD C8 3D 04 8044  			CALL	TELL
043003 55 73 61 67 8045  			DB	"Usage:\n\r"
       65 3A 0A 0D 
04300B 52 55 4E 20 8046  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
04301E 21 00 00 00 8047  			LD	HL, 0			; The error code
043022 C3 68 00 04 8048  			JP	_end
043026             8049  ;
043026 DD 27 03    8050  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043029 11 00 4A 04 8051  			LD	DE, ACCS		;  DE: Destination address
04302D 7E          8052  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
04302E 12          8053  			LD	(DE), A			;
04302F 23          8054  			INC	HL			; Increase the source pointer
043030 1C          8055  			INC	E			; We only need to increase E as ACCS is on a page boundary
043031 28 03       8056  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
043033 B7          8057  			OR	A
043034 20 F7       8058  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043036 1D          8059  AUTOLOAD_2:		DEC	E
043037 3E 0D       8060  			LD	A, CR
043039 12          8061  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
04303A             8062  ;
04303A E1          8063  COLD:			POP	HL			; Pop the return address to init off SPS
04303B E5          8064  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04303C 21 00 4C 04 8065  			LD	HL, STAVAR		; Cold start
043040 F9          8066  			LD	SP, HL
043041 36 0A       8067  			LD	(HL), 10
043043 23          8068  			INC	HL
043044 36 09       8069  			LD	(HL),9
043046 CD B9 3F 04 8070  			CALL    OSINIT			; Call the machine specific OS initialisation routines
04304A ED 53 20 4D 8071  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
04304F 22 14 4D 04 8072  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043053 3E B7       8073  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043055 32 40 4D 04 8074  			LD      (LISTON),A
043059 21 94 30 04 8075  			LD      HL,NOTICE
04305D 22 2F 4D 04 8076  			LD      (ERRTXT),HL
043061 CD A4 38 04 8077  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043065 3A 00 4A 04 8078  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043069 B7          8079  			OR	A
04306A C2 5B 0B 04 8080  			JP	NZ,CHAIN0		; Yes, so load and run
04306E CD 81 40 04 8081  			CALL	STAR_VERSION		;
043072 CD C8 3D 04 8082  			CALL    TELL			; Output the welcome message
043076 42 42 43 20 8083  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
043094 28 43 29 20 8084  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0430B4 0A 0D 00    8085  			DB	"\n\r", 0
0430B7             8086  ;
0430B7 F6          8087  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0430B8             8088  ;
0430B8             8089  ; This is the main entry point for BASIC
0430B8             8090  ;
0430B8 37          8091  CLOOP:			SCF				; See above - not sure why this is here!
0430B9 ED 7B 20 4D 8092  			LD      SP,(HIMEM)
       04          
0430BE CD 32 3F 04 8093  			CALL    PROMPT          	; Prompt user
0430C2 21 40 4D 04 8094  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430C6 7E          8095  			LD      A,(HL)			; Fetch the value
0430C7 E6 0F       8096  			AND     0FH             	; Bottom nibble: LISTO
0430C9 F6 B0       8097  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430CB 77          8098  			LD      (HL),A			; Store back in
0430CC ED 62       8099  			SBC     HL,HL           	; HL: 0
0430CE 22 2C 4D 04 8100  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430D2 22 35 4D 04 8101  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430D6             8102  ;
0430D6 2A 29 4D 04 8103  			LD      HL,(AUTONO)		; Get the auto line number
0430DA 22 23 4D 04 8104  			LD      (LINENO),HL		; Store in line number
0430DE 7C          8105  			LD      A,H			; If the auto line number is zero then
0430DF B5          8106  			OR      L
0430E0 28 1E       8107  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430E2             8108  ;
0430E2             8109  ; This section handles auto line numbering
0430E2             8110  ;
0430E2 E5          8111  			PUSH    HL			; Stack the line number
0430E3 CD 33 3A 04 8112  			CALL    PBCD           	 	; Output the line number
0430E7 E1          8113  			POP     HL			; Pop the line number back off the stack
0430E8             8114  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0430E8             8115  ;			LD      B,0			; So clear B
0430E8 01 00 00 00 8116  			LD	BC, 0			; Load BC with Increment
0430EC 3A 41 4D 04 8117  			LD	A,(INCREM)
0430F0 4F          8118  			LD	C, A
0430F1 09          8119  			ADD     HL,BC			; Add the increment to the line number
0430F2 DA 5D 3C 04 8120  			JP      C,TOOBIG		; And error if we wrap
0430F6 22 29 4D 04 8121  			LD      (AUTONO),HL		; Store the new auto line number
0430FA 3E 20       8122  			LD      A,' '			; Print a space
0430FC CD 87 39 04 8123  			CALL    OUTCHR
043100             8124  ;
043100             8125  ; This section invokes the line editor
043100             8126  ;
043100 21 00 4A 04 8127  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
043104 CD 97 3E 04 8128  			CALL    OSLINE          	; Call the line editor in MOS
043108 CD 14 31 04 8129  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
04310C DC 77 38 04 8130  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
043110 C3 B8 30 04 8131  			JP      CLOOP			; Jump back to immediate mode
043114             8132  ;
043114             8133  ; This bit enters the line into memory
043114             8134  ; Also called from OSLOAD_TXT
043114             8135  ; Returns:
043114             8136  ; F: C if a new line has been entered (CLEAN will need to be called)
043114             8137  ;
043114 AF          8138  ONEDIT1:		XOR     A			; Entry point after *EDIT
043115 32 3D 4D 04 8139  			LD      (COUNT),A
043119 FD 21 00 4A 8140  			LD      IY,ACCS
       04          
04311E CD 31 3C 04 8141  			CALL    LINNUM			; HL: The line number from the input buffer
043122 CD 78 0A 04 8142  			CALL    NXT			; Skip spaces
043126 7C          8143  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043127 B5          8144  			OR      L
043128 28 04       8145  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
04312A 22 23 4D 04 8146  			LD      (LINENO),HL		; Otherwise store it
04312E             8147  ;
04312E             8148  ; This bit does the lexical analysis and tokenisation
04312E             8149  ;
04312E 0E 01       8150  LNZERO:			LD	C,1			; Left mode
043130 11 00 4B 04 8151  			LD      DE,BUFFER		; Buffer for tokenised BASIC
043134 CD D7 3C 04 8152  			CALL    LEXAN2          	; Lexical analysis on the user input
043138 12          8153  			LD      (DE),A          	; Terminator
043139 AF          8154  			XOR     A
04313A             8155  ;			LD      B,A
04313A             8156  ;			LD      C,E             	; BC: Line length
04313A 01 00 00 00 8157  			LD	BC,0
04313E 4B          8158  			LD	C,E			; BC: Line length
04313F 13          8159  			INC     DE
043140 12          8160  			LD      (DE),A          	; Zero next
043141 2A 23 4D 04 8161  			LD      HL,(LINENO)		; Get the line number
043145 7C          8162  			LD      A,H			; Is it zero, i.e. a command with no line number?
043146 B5          8163  			OR      L
043147 FD 21 00 4B 8164  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
04314C CA 9E 0B 04 8165  			JP      Z,XEQ           	; Execute it
043150             8166  ;
043150             8167  ; This section stores the BASIC line in memory
043150             8168  ;
043150 C5          8169  			PUSH    BC
043151 E5          8170  			PUSH    HL
043152 CD 83 38 04 8171  			CALL    SETTOP          	; Set TOP sysvar
043156 E1          8172  			POP     HL
043157 CD C7 39 04 8173  			CALL    FINDL			; Find the address of the line
04315B CC 3A 38 04 8174  			CALL    Z,DEL			; Delete the existing line if found
04315F C1          8175  			POP     BC
043160 79          8176  			LD      A,C			; Check for the line length being zero, i.e.
043161 B7          8177  			OR      A			; the user has just entered a line number in the command line
043162 C8          8178  			RET	Z 	         	; If so, then don't do anything else
043163 C6 04       8179  			ADD     A,4
043165 4F          8180  			LD      C,A             	; Length inclusive
043166 D5          8181  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043167 C5          8182  			PUSH    BC              	; BC: Line length
043168 EB          8183  			EX      DE,HL			; DE: Address of the line in memory
043169 2A 17 4D 04 8184  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
04316D E5          8185  			PUSH    HL			; Stack TOP (current TOP value)
04316E 09          8186  			ADD     HL,BC			; Add the line length to HL, the new TOP value
04316F E5          8187  			PUSH    HL			; Stack HL (new TOP value)
043170 24          8188  			INC     H			; Add 256 to HL
043171 AF          8189  			XOR     A
043172 ED 72       8190  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
043174 E1          8191  			POP     HL			; Pop HL (new TOP value)
043175 D2 98 37 04 8192  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043179 22 17 4D 04 8193  			LD      (TOP),HL		; Store new value of TOP
04317D E3          8194  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
04317E E5          8195  			PUSH    HL			; PUSH current TOP value
04317F 23          8196  			INC     HL
043180 B7          8197  			OR      A
043181 ED 52       8198  			SBC     HL,DE			; DE: Address of the line in memory
043183 44          8199  			LD      B,H             	; BC: Amount to move
043184 4D          8200  			LD      C,L
043185 E1          8201  			POP     HL			; HL: Destination (current TOP value)
043186 D1          8202  			POP     DE			; DE: Source (new TOP value)
043187 28 02       8203  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043189 ED B8       8204  			LDDR                    	; Otherwise, make space for the new line in the program
04318B C1          8205  ATEND:			POP     BC              	; BC: Line length
04318C D1          8206  			POP     DE              	; DE: Line number
04318D 23          8207  			INC     HL			; HL: Destination address
04318E 71          8208  			LD      (HL),C          	; Store length
04318F 23          8209  			INC     HL
043190 73          8210  			LD      (HL),E          	; Store line number
043191 23          8211  			INC     HL
043192 72          8212  			LD      (HL),D
043193 23          8213  			INC     HL
043194 11 00 4B 04 8214  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
043198 EB          8215  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043199 0D          8216  			DEC     C			; Subtract 3 from the number of bytes to copy to
04319A 0D          8217  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
04319B 0D          8218  			DEC     C
04319C ED B0       8219  			LDIR                    	; Add the line to the BASIC program
04319E 37          8220  			SCF				; To flag we need to call CLEAN
04319F C9          8221  			RET
0431A0             8222  ;
0431A0             8223  ; List of tokens and keywords. If a keyword is followed by 0 then
0431A0             8224  ; it will only match with the keyword followed immediately by
0431A0             8225  ; a delimiter
0431A0             8226  ;
0431A0 80 41 4E 44 8227  KEYWDS:			DB    80H, "AND"
0431A4 94 41 42 53 8228  			DB    94H, "ABS"
0431A8 95 41 43 53 8229  			DB    95H, "ACS"
0431AC 96 41 44 56 8230  			DB    96H, "ADVAL"
       41 4C       
0431B2 97 41 53 43 8231  			DB    97H, "ASC"
0431B6 98 41 53 4E 8232  			DB    98H, "ASN"
0431BA 99 41 54 4E 8233  			DB    99H, "ATN"
0431BE C6 41 55 54 8234  			DB    C6H, "AUTO"
       4F          
0431C3 9A 42 47 45 8235  			DB    9AH, "BGET", 0
       54 00       
0431C9 D5 42 50 55 8236  			DB    D5H, "BPUT", 0
       54 00       
0431CF FB 43 4F 4C 8237  			DB    FBH, "COLOUR"
       4F 55 52    
0431D6 FB 43 4F 4C 8238  			DB    FBH, "COLOR"
       4F 52       
0431DC D6 43 41 4C 8239  			DB    D6H, "CALL"
       4C          
0431E1 D7 43 48 41 8240  			DB    D7H, "CHAIN"
       49 4E       
0431E7 BD 43 48 52 8241  			DB    BDH, "CHR$"
       24          
0431EC D8 43 4C 45 8242  			DB    D8H, "CLEAR", 0
       41 52 00    
0431F3 D9 43 4C 4F 8243  			DB    D9H, "CLOSE", 0
       53 45 00    
0431FA DA 43 4C 47 8244  			DB    DAH, "CLG", 0
       00          
0431FF DB 43 4C 53 8245  			DB    DBH, "CLS", 0
       00          
043204 9B 43 4F 53 8246  			DB    9BH, "COS"
043208 9C 43 4F 55 8247  			DB    9CH, "COUNT", 0
       4E 54 00    
04320F DC 44 41 54 8248  			DB    DCH, "DATA"
       41          
043214 9D 44 45 47 8249  			DB    9DH, "DEG"
043218 DD 44 45 46 8250  			DB    DDH, "DEF"
04321C C7 44 45 4C 8251  			DB    C7H, "DELETE"
       45 54 45    
043223 81 44 49 56 8252  			DB    81H, "DIV"
043227 DE 44 49 4D 8253  			DB    DEH, "DIM"
04322B DF 44 52 41 8254  			DB    DFH, "DRAW"
       57          
043230 E1 45 4E 44 8255  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043239 E0 45 4E 44 8256  			DB    E0H, "END", 0
       00          
04323E E2 45 4E 56 8257  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
043247 8B 45 4C 53 8258  			DB    8BH, "ELSE"
       45          
04324C A0 45 56 41 8259  			DB    A0H, "EVAL"
       4C          
043251 9E 45 52 4C 8260  			DB    9EH, "ERL", 0
       00          
043256 85 45 52 52 8261  			DB    85H, "ERROR"
       4F 52       
04325C C5 45 4F 46 8262  			DB    C5H, "EOF", 0
       00          
043261 82 45 4F 52 8263  			DB    82H, "EOR"
043265 9F 45 52 52 8264  			DB    9FH, "ERR", 0
       00          
04326A A1 45 58 50 8265  			DB    A1H, "EXP"
04326E A2 45 58 54 8266  			DB    A2H, "EXT", 0
       00          
043273 E3 46 4F 52 8267  			DB    E3H, "FOR"
043277 A3 46 41 4C 8268  			DB    A3H, "FALSE", 0
       53 45 00    
04327E A4 46 4E    8269  			DB    A4H, "FN"
043281 E5 47 4F 54 8270  			DB    E5H, "GOTO"
       4F          
043286 BE 47 45 54 8271  			DB    BEH, "GET$"
       24          
04328B A5 47 45 54 8272  			DB    A5H, "GET"
04328F E4 47 4F 53 8273  			DB    E4H, "GOSUB"
       55 42       
043295 E6 47 43 4F 8274  			DB    E6H, "GCOL"
       4C          
04329A 93 48 49 4D 8275  			DB    93H, "HIMEM", 0
       45 4D 00    
0432A1 E8 49 4E 50 8276  			DB    E8H, "INPUT"
       55 54       
0432A7 E7 49 46    8277  			DB    E7H, "IF"
0432AA BF 49 4E 4B 8278  			DB    BFH, "INKEY$"
       45 59 24    
0432B1 A6 49 4E 4B 8279  			DB    A6H, "INKEY"
       45 59       
0432B7 A8 49 4E 54 8280  			DB    A8H, "INT"
0432BB A7 49 4E 53 8281  			DB    A7H, "INSTR("
       54 52 28    
0432C2 C9 4C 49 53 8282  			DB    C9H, "LIST"
       54          
0432C7 86 4C 49 4E 8283  			DB    86H, "LINE"
       45          
0432CC C8 4C 4F 41 8284  			DB    C8H, "LOAD"
       44          
0432D1 92 4C 4F 4D 8285  			DB    92H, "LOMEM", 0
       45 4D 00    
0432D8 EA 4C 4F 43 8286  			DB    EAH, "LOCAL"
       41 4C       
0432DE C0 4C 45 46 8287  			DB    C0H, "LEFT$("
       54 24 28    
0432E5 A9 4C 45 4E 8288  			DB    A9H, "LEN"
0432E9 E9 4C 45 54 8289  			DB    E9H, "LET"
0432ED AB 4C 4F 47 8290  			DB    ABH, "LOG"
0432F1 AA 4C 4E    8291  			DB    AAH, "LN"
0432F4 C1 4D 49 44 8292  			DB    C1H, "MID$("
       24 28       
0432FA EB 4D 4F 44 8293  			DB    EBH, "MODE"
       45          
0432FF 83 4D 4F 44 8294  			DB    83H, "MOD"
043303 EC 4D 4F 56 8295  			DB    ECH, "MOVE"
       45          
043308 ED 4E 45 58 8296  			DB    EDH, "NEXT"
       54          
04330D CA 4E 45 57 8297  			DB    CAH, "NEW", 0
       00          
043312 AC 4E 4F 54 8298  			DB    ACH, "NOT"
043316 CB 4F 4C 44 8299  			DB    CBH, "OLD", 0
       00          
04331B EE 4F 4E    8300  			DB    EEH, "ON"
04331E 87 4F 46 46 8301  			DB    87H, "OFF"
043322 84 4F 52    8302  			DB    84H, "OR"
043325 8E 4F 50 45 8303  			DB    8EH, "OPENIN"
       4E 49 4E    
04332C AE 4F 50 45 8304  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
043334 AD 4F 50 45 8305  			DB    ADH, "OPENUP"
       4E 55 50    
04333B FF 4F 53 43 8306  			DB    FFH, "OSCLI"
       4C 49       
043341 F1 50 52 49 8307  			DB    F1H, "PRINT"
       4E 54       
043347 90 50 41 47 8308  			DB    90H, "PAGE", 0
       45 00       
04334D 8F 50 54 52 8309  			DB    8FH, "PTR", 0
       00          
043352 AF 50 49 00 8310  			DB    AFH, "PI", 0
043356 F0 50 4C 4F 8311  			DB    F0H, "PLOT"
       54          
04335B B0 50 4F 49 8312  			DB    B0H, "POINT("
       4E 54 28    
043362 F2 50 52 4F 8313  			DB    F2H, "PROC"
       43          
043367 B1 50 4F 53 8314  			DB    B1H, "POS", 0
       00          
04336C CE 50 55 54 8315  			DB    CEH, "PUT"
043370 F8 52 45 54 8316  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043378 F5 52 45 50 8317  			DB    F5H, "REPEAT"
       45 41 54    
04337F F6 52 45 50 8318  			DB    F6H, "REPORT", 0
       4F 52 54 00 
043387 F3 52 45 41 8319  			DB    F3H, "READ"
       44          
04338C F4 52 45 4D 8320  			DB    F4H, "REM"
043390 F9 52 55 4E 8321  			DB    F9H, "RUN", 0
       00          
043395 B2 52 41 44 8322  			DB    B2H, "RAD"
043399 F7 52 45 53 8323  			DB    F7H, "RESTORE"
       54 4F 52 45 
0433A1 C2 52 49 47 8324  			DB    C2H, "RIGHT$("
       48 54 24 28 
0433A9 B3 52 4E 44 8325  			DB    B3H, "RND", 0
       00          
0433AE CC 52 45 4E 8326  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0433B7 88 53 54 45 8327  			DB    88H, "STEP"
       50          
0433BC CD 53 41 56 8328  			DB    CDH, "SAVE"
       45          
0433C1 B4 53 47 4E 8329  			DB    B4H, "SGN"
0433C5 B5 53 49 4E 8330  			DB    B5H, "SIN"
0433C9 B6 53 51 52 8331  			DB    B6H, "SQR"
0433CD 89 53 50 43 8332  			DB    89H, "SPC"
0433D1 C3 53 54 52 8333  			DB    C3H, "STR$"
       24          
0433D6 C4 53 54 52 8334  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433DF D4 53 4F 55 8335  			DB    D4H, "SOUND"
       4E 44       
0433E5 FA 53 54 4F 8336  			DB    FAH, "STOP", 0
       50 00       
0433EB B7 54 41 4E 8337  			DB    B7H, "TAN"
0433EF 8C 54 48 45 8338  			DB    8CH, "THEN"
       4E          
0433F4 B8 54 4F    8339  			DB    B8H, "TO"
0433F7 8A 54 41 42 8340  			DB    8AH, "TAB("
       28          
0433FC FC 54 52 41 8341  			DB    FCH, "TRACE"
       43 45       
043402 91 54 49 4D 8342  			DB    91H, "TIME", 0
       45 00       
043408 B9 54 52 55 8343  			DB    B9H, "TRUE", 0
       45 00       
04340E FD 55 4E 54 8344  			DB    FDH, "UNTIL"
       49 4C       
043414 BA 55 53 52 8345  			DB    BAH, "USR"
043418 EF 56 44 55 8346  			DB    EFH, "VDU"
04341C BB 56 41 4C 8347  			DB    BBH, "VAL"
043420 BC 56 50 4F 8348  			DB    BCH, "VPOS", 0
       53 00       
043426 FE 57 49 44 8349  			DB    FEH, "WIDTH"
       54 48       
04342C D3 48 49 4D 8350  			DB    D3H, "HIMEM"
       45 4D       
043432 D2 4C 4F 4D 8351  			DB    D2H, "LOMEM"
       45 4D       
043438 D0 50 41 47 8352  			DB    D0H, "PAGE"
       45          
04343D CF 50 54 52 8353  			DB    CFH, "PTR"
043441 D1 54 49 4D 8354  			DB    D1H, "TIME"
       45          
043446             8355  ;
043446             8356  ; These are indexed from the ERRWDS table
043446             8357  ;
043446 01 4D 69 73 8358  			DB    01H, "Missing "
       73 69 6E 67 
       20          
04344F 02 4E 6F 20 8359  			DB    02H, "No such "
       73 75 63 68 
       20          
043458 03 42 61 64 8360  			DB    03H, "Bad "
       20          
04345D 04 20 72 61 8361  			DB    04H, " range"
       6E 67 65    
043464 05 76 61 72 8362  			DB    05H, "variable"
       69 61 62 6C 
       65          
04346D 06 4F 75 74 8363  			DB    06H, "Out of"
       20 6F 66    
043474 07 4E 6F 20 8364  			DB    07H, "No "
043478 08 20 73 70 8365  			DB    08H, " space"
       61 63 65    
04347F             8366  
04347F             8367  KEYWDL:			EQU     $-KEYWDS
04347F FF FF       8368  			DW    -1
043481             8369  ;
043481             8370  ; Error messages
043481             8371  ;
043481 07 72 6F 6F 8372  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
043487 06 04 00    8373  			DB    6, 4, 0			;  1: Out of range
04348A 00          8374  			DB    0				;  2: *
04348B 00          8375  			DB    0				;  3: *
04348C 4D 69 73 74 8376  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
043494 01 2C 00    8377  			DB    1, ",", 0			;  5: Missing ,
043497 54 79 70 65 8378  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0434A5 07 A4 00    8379  			DB    7, FN, 0			;  7: No FN
0434A8 00          8380  			DB    0				;  8: *
0434A9 01 22 00    8381  			DB    1, 34, 0			;  9: Missing "
0434AC 03 DE 00    8382  			DB    3, DIM, 0			; 10: Bad DIM
0434AF DE 08 00    8383  			DB    DIM, 8, 0			; 11: DIM space
0434B2 4E 6F 74 20 8384  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0434B8 07 F2 00    8385  			DB    7, PROC, 0		; 13: No PROC
0434BB 41 72 72 61 8386  			DB    "Array", 0		; 14: Array
       79 00       
0434C1 53 75 62 73 8387  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0434CB 53 79 6E 74 8388  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434D8 45 73 63 61 8389  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434DF 44 69 76 69 8390  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0434F0 53 74 72 69 8391  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
043500 54 6F 6F 20 8392  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
043508 2D 76 65 20 8393  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
043511 4C 6F 67 04 8394  			DB    "Log", 4, 0		; 22: Log range
       00          
043516 41 63 63 75 8395  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
043524 45 78 70 04 8396  			DB    "Exp", 4, 0		; 24: Exp range
       00          
043529 00          8397  			DB    0				; 25: *
04352A 02 05 00    8398  			DB    2, 5, 0			; 26: No such variable
04352D 01 29 00    8399  			DB    1, ")", 0			; 27: Missing )
043530 03 48 45 58 8400  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
043535 02 A4 2F F2 8401  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
04353A 03 63 61 6C 8402  			DB    3, "call", 0		; 30: Bad call
       6C 00       
043540 41 72 67 75 8403  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
04354A 07 E3 00    8404  			DB    7, FOR, 0			; 32: No FOR
04354D 43 61 6E 27 8405  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
04355B E3 20 05 00 8406  			DB    FOR, " ", 5, 0		; 34: FOR variable
04355F 00          8407  			DB    0				; 35: *
043560 07 B8 00    8408  			DB    7, TO_MN, 0			; 36: No TO
043563 00          8409  			DB    0				; 37: *
043564 07 E4 00    8410  			DB    7, GOSUB, 0		; 38: No GOSUB
043567 EE 20 73 79 8411  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
043570 EE 04 00    8412  			DB    ON_, 4, 0			; 40: ON range
043573 02 6C 69 6E 8413  			DB    2, "line", 0		; 41: No such line
       65 00       
043579 06 20 DC 00 8414  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
04357D 07 F5 00    8415  			DB    7, REPEAT, 0		; 43: No REPEAT
043580 00          8416  			DB    0				; 44: *
043581 01 23 00    8417  			DB    1, "#", 0			; 45: Missing #
043584             8418  ;
043584             8419  ; COMMANDS:
043584             8420  ;
043584             8421  ; DELETE line,line
043584             8422  ;
043584 CD 83 38 04 8423  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
043588 CD 8B 3C 04 8424  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04358C 7E          8425  DELET1:			LD      A,(HL)			; Check whether it's the last line
04358D B7          8426  			OR      A
04358E CA 15 36 04 8427  			JP      Z,WARMNC		; Yes, so do nothing
043592 23          8428  			INC     HL			; Skip the line length byte
043593 11 00 00 00 8429  			LD	DE, 0			; Clear DE
043597 5E          8430  			LD      E,(HL)			; Fetch the line number in DE
043598 23          8431  			INC     HL
043599 56          8432  			LD      D,(HL)
04359A 7A          8433  			LD      A,D			; If the line number is zero then
04359B B3          8434  			OR      E
04359C 28 1D       8435  			JR      Z,CLOOP1        	; Do nothing
04359E 2B          8436  			DEC     HL			; Decrement BASIC program pointer back to length
04359F 2B          8437  			DEC     HL
0435A0 EB          8438  			EX      DE,HL			; Check if we've gone past the terminating line
0435A1 37          8439  			SCF
0435A2 ED 42       8440  			SBC     HL,BC
0435A4 EB          8441  			EX      DE,HL
0435A5 30 6E       8442  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0435A7 C5          8443  			PUSH    BC
0435A8 CD 3A 38 04 8444  			CALL    DEL			; Delete the line pointed to by HL
0435AC C1          8445  			POP     BC
0435AD 18 DD       8446  			JR      DELET1			; And loop round to the next line
0435AF             8447  ;
0435AF             8448  ; LISTO expr
0435AF             8449  ;
0435AF FD 23       8450  LISTO:			INC     IY              	; Skip "O" byte
0435B1 CD 0F 03 04 8451  			CALL    EXPRI			; Get expr
0435B5 D9          8452  			EXX
0435B6 7D          8453  			LD      A,L
0435B7 32 40 4D 04 8454  			LD      (LISTON),A		; Store in LISTON sysvar
0435BB C3 B8 30 04 8455  CLOOP1:			JP      CLOOP
0435BF             8456  ;
0435BF             8457  ; LIST
0435BF             8458  ; LIST line
0435BF             8459  ; LIST line,line [IF string]
0435BF             8460  ; LIST ,line
0435BF             8461  ; LIST line,
0435BF             8462  ;
0435BF FE 4F       8463  LIST_:			CP      'O'			; Check for O (LISTO)
0435C1 28 EC       8464  			JR      Z,LISTO			; and jump to LISTO if zero
0435C3 CD 8B 3C 04 8465  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435C7 CD 78 0A 04 8466  			CALL    NXT			; Skip space
0435CB FE E7       8467  			CP      TIF             	; Check for IF clause (token IF)
0435CD 3E 00       8468  			LD      A,0             	; Initialise the IF clause string length
0435CF 20 17       8469  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435D1             8470  ;
0435D1 FD 23       8471  			INC     IY              	; Skip the IF token
0435D3 CD 78 0A 04 8472  			CALL    NXT             	; And skip any spaces
0435D7 EB          8473  			EX      DE,HL			; DE: Address in memory
0435D8 FD E5       8474  			PUSH    IY			; LD IY, HL
0435DA E1          8475  			POP     HL              	; HL is now the address of the tokenised line
0435DB 3E 0D       8476  			LD      A,CR
0435DD C5          8477  			PUSH    BC			; Stack the second line number arg
0435DE 01 00 01 00 8478  			LD      BC,256
0435E2 ED B1       8479  			CPIR                    	; Locate CR byte
0435E4 79          8480  			LD      A,C
0435E5 2F          8481  			CPL                    	 	; A: Substring length (of IF clause)
0435E6 C1          8482  			POP     BC			; Restore the second line number arg
0435E7 EB          8483  			EX      DE,HL			; HL: Address in memory
0435E8             8484  ;
0435E8 5F          8485  LISTB:			LD      E,A             	; E: IF clause string length
0435E9 78          8486  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0435EA B1          8487  			OR      C
0435EB 20 01       8488  			JR      NZ,LISTA		; If there isn't a second line number
0435ED 0B          8489  			DEC     BC			; then we set it to the maximum of 65535
0435EE             8490  ;
0435EE D9          8491  LISTA:			EXX
0435EF DD 21 40 4D 8492  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
0435F4 01 00 00 00 8493  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435F8 D9          8494  			EXX
0435F9 3E 14       8495  			LD      A,20			; Number of lines to list
0435FB             8496  ;
0435FB C5          8497  LISTC:			PUSH    BC              	; Save second line number
0435FC D5          8498  			PUSH    DE              	; Save IF clause length
0435FD E5          8499  			PUSH    HL              	; Save BASIC program counter
0435FE 08          8500  			EX      AF,AF'
0435FF             8501  ;
0435FF             8502  ; BBC BASIC for Z80 lines are stored as follows:
0435FF             8503  ;
0435FF             8504  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0435FF             8505  ; - [&00] [&FF] [&FF]: End of program marker
0435FF             8506  ;
0435FF             8507  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0435FF             8508  ;
0435FF 7E          8509  			LD      A,(HL)			; Check for end of program marker
043600 B7          8510  			OR      A			; If found
043601 28 12       8511  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
043603             8512  ;
043603             8513  ; Check if past terminating line number
043603             8514  ;
043603 7B          8515  			LD      A,E             	; A: IF clause length
043604 23          8516  			INC     HL			; Skip the length byte
043605 11 00 00 00 8517  			LD	DE,0			; Clear DE
043609 5E          8518  			LD      E,(HL)			; Fetch the line number in DE
04360A 23          8519  			INC     HL
04360B 56          8520  			LD      D,(HL)
04360C 2B          8521  			DEC     HL			; Step HL back to the length byte
04360D 2B          8522  			DEC     HL
04360E D5          8523  			PUSH    DE             	 	; Push the line number on the stack
04360F EB          8524  			EX      DE,HL			; HL: line number
043610 37          8525  			SCF				; Do a 16-bit compare of HL and DE
043611 ED 42       8526  			SBC     HL,BC
043613 EB          8527  			EX      DE,HL
043614 D1          8528  			POP     DE              	; Restore the line number
043615 D2 B7 30 04 8529  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043619 4E          8530  			LD      C,(HL)          	; C: Line length + 4
04361A 47          8531  			LD      B,A             	; B: IF clause length
04361B             8532  ;
04361B             8533  ; Check if "UNLISTABLE":
04361B             8534  ;
04361B 7A          8535  			LD      A,D			; TODO: What is "UNLISTABLE?"
04361C B3          8536  			OR      E
04361D CA B8 30 04 8537  			JP      Z,CLOOP
043621             8538  ;
043621             8539  ; Check for IF clause:
043621             8540  ;
043621 23          8541  			INC     HL			; Skip the length
043622 23          8542  			INC     HL			; Skip the line number
043623 23          8543  			INC     HL              	; HL: Address of the tokenised BASIC line
043624 0D          8544  			DEC     C			;  C: Line length
043625 0D          8545  			DEC     C
043626 0D          8546  			DEC     C
043627 0D          8547  			DEC     C
043628 D5          8548  			PUSH    DE              	; Save the line number
043629 E5          8549  			PUSH    HL              	; Save the BASIC program address
04362A AF          8550  			XOR     A               	;
04362B B8          8551  			CP      B              	 	; Check for an IF clause (B!=0)
04362C FD E5       8552  			PUSH    IY			; LD IY, DE
04362E D1          8553  			POP     DE              	; DE: Address of the IF clause string in the input buffer
04362F C4 8A 07 04 8554  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
043633 E1          8555  			POP     HL              	; Restore BASIC program address
043634 D1          8556  			POP     DE              	; Restore line number
043635 FD E5       8557  			PUSH    IY
043637 CC CA 38 04 8558  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
04363B FD E1       8559  			POP     IY
04363D             8560  ;
04363D 08          8561  			EX      AF,AF'
04363E 3D          8562  			DEC     A			; Decrement line list counter
04363F CD A9 3F 04 8563  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043643 E1          8564  			POP     HL             	 	; Restore BASIC program address to beginning of line
043644 11 00 00 00 8565  			LD	DE,0
043648 5E          8566  			LD      E,(HL)			; Fetch the length of line in DE
043649 19          8567  			ADD     HL,DE           	; Go to the next line
04364A D1          8568  			POP     DE              	; Restore IF clause length
04364B C1          8569  			POP     BC              	; Restore second line number
04364C 18 AD       8570  			JR      LISTC			; Loop back to do next line
04364E             8571  ;
04364E             8572  ; RENUMBER
04364E             8573  ; RENUMBER start
04364E             8574  ; RENUMBER start,increment
04364E             8575  ; RENUMBER ,increment
04364E             8576  ;
04364E CD AE 38 04 8577  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
043652 CD 63 3C 04 8578  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
043656 D9          8579  			EXX
043657 2A 14 4D 04 8580  			LD      HL,(PAGE_)		; HL: Top of program
04365B ED 5B 1A 4D 8581  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
043660             8582  ;
043660             8583  ; Build the table
043660             8584  ;
043660 7E          8585  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043661 B7          8586  			OR      A			; Is it zero, i.e. the end of program marker?
043662 28 36       8587  			JR      Z,RENUM2		; Yes, so skip to the next part
043664 23          8588  			INC     HL
043665 4E          8589  			LD      C,(HL)          	; BC: The OLD line number
043666 23          8590  			INC     HL
043667 46          8591  			LD      B,(HL)
043668 78          8592  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043669 B1          8593  			OR      C
04366A CA B8 30 04 8594  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
04366E EB          8595  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04366F 71          8596  			LD      (HL),C			; Store the OLD line number in the heap
043670 23          8597  			INC     HL
043671 70          8598  			LD      (HL),B
043672 23          8599  			INC     HL
043673 D9          8600  			EXX				; HL: line number, BC: increment (16-bit values)
043674 E5          8601  			PUSH    HL			; HL: Stack the NEW line number value
043675 52 09       8602  			ADD.S   HL,BC           	; Add the increment
043677 DA 5D 3C 04 8603  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
04367B D9          8604  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
04367C C1          8605  			POP     BC			; BC: Pop the NEW line number value off the stack
04367D 71          8606  			LD      (HL),C			; Store the NEW line number in the heap
04367E 23          8607  			INC     HL
04367F 70          8608  			LD      (HL),B
043680 23          8609  			INC     HL
043681 EB          8610  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043682 2B          8611  			DEC     HL			; Back up to the line length byte
043683 2B          8612  			DEC     HL
043684 01 00 00 00 8613  			LD	BC, 0
043688 4E          8614  			LD      C,(HL)			; BC: Line length
043689 09          8615  			ADD	HL,BC           	; Advance HL to next line
04368A EB          8616  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04368B E5          8617  			PUSH    HL
04368C 24          8618  			INC     H			; Increment to next page
04368D ED 72       8619  			SBC     HL,SP			; Subtract from SP
04368F E1          8620  			POP     HL
043690 EB          8621  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043691 38 CD       8622  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
043693 CD AF 37 04 8623  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
043697 CC          8624  			DB    	REN
043698 08          8625  			DB    	8
043699 00          8626  			DB    	0
04369A             8627  ;
04369A             8628  ; At this point a list of BASIC line numbers have been written to the heap
04369A             8629  ; as word pairs:
04369A             8630  ; - DW: The OLD line number
04369A             8631  ; - DW: The NEW line number
04369A             8632  ;
04369A EB          8633  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
04369B 36 FF       8634  			LD      (HL),-1			; Mark the end with FFFFh
04369D 23          8635  			INC     HL
04369E 36 FF       8636  			LD      (HL),-1
0436A0 ED 5B 1A 4D 8637  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
0436A5 D9          8638  			EXX
0436A6 2A 14 4D 04 8639  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436AA 4E          8640  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436AB 79          8641  			LD      A,C			; If it is zero, then no program, so...
0436AC B7          8642  			OR      A
0436AD CA B7 30 04 8643  			JP      Z,WARM			; Jump to warm start
0436B1 D9          8644  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436B2 EB          8645  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436B3 23          8646  			INC     HL			; Skip to the NEW line number
0436B4 23          8647  			INC     HL
0436B5 5E          8648  			LD      E,(HL)			; DE: The NEW line number
0436B6 23          8649  			INC     HL
0436B7 56          8650  			LD      D,(HL)
0436B8 23          8651  			INC     HL
0436B9 D5          8652  			PUSH    DE			; Stack the NEW line number
0436BA EB          8653  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436BB 22 23 4D 04 8654  			LD      (LINENO),HL		; Store the line number in LINENO
0436BF D9          8655  			EXX				; HL: Pointer to the BASIC program area
0436C0 D1          8656  			POP     DE			; DE: The NEW line number
0436C1 23          8657  			INC     HL
0436C2 73          8658  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436C3 23          8659  			INC     HL
0436C4 72          8660  			LD      (HL),D
0436C5 23          8661  			INC     HL
0436C6 0D          8662  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436C7 0D          8663  			DEC     C
0436C8 0D          8664  			DEC     C
0436C9 79          8665  			LD	A,C
0436CA 01 00 00 00 8666  			LD	BC,0
0436CE 4F          8667  			LD	C,A			; BC: Line length
0436CF             8668  ;
0436CF 3E 8D       8669  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436D1 ED B1       8670  			CPIR                    	; Search for the token
0436D3 20 D5       8671  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0436D5             8672  ;
0436D5             8673  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0436D5             8674  ;
0436D5 C5          8675  			PUSH    BC			; Stack everything
0436D6 E5          8676  			PUSH    HL
0436D7 E5          8677  			PUSH    HL			; HL: Pointer to encoded line number
0436D8 FD E1       8678  			POP     IY			; IY: Pointer to encoded line number
0436DA D9          8679  			EXX
0436DB CD EB 08 04 8680  			CALL    DECODE			; Decode the encoded line number (in HL')
0436DF D9          8681  			EXX				; HL: Decoded line number
0436E0 44          8682  			LD      B,H			; BC: Decoded line number
0436E1 4D          8683  			LD      C,L
0436E2 2A 1A 4D 04 8684  			LD      HL,(LOMEM)		; HL: Pointer to heap
0436E6             8685  ;
0436E6             8686  ; This section of code cross-references the decoded (OLD) line number with the list
0436E6             8687  ; created previously in the global heap
0436E6             8688  ;
0436E6 5E          8689  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436E7 23          8690  			INC     HL
0436E8 56          8691  			LD      D,(HL)
0436E9 23          8692  			INC     HL
0436EA EB          8693  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436EB B7          8694  			OR      A               	; Clear the carry and...
0436EC 52 ED 42    8695  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436EF EB          8696  			EX      DE,HL			; HL: Pointer in the global heap
0436F0 5E          8697  			LD      E,(HL)          	; DE: The NEW line number
0436F1 23          8698  			INC     HL
0436F2 56          8699  			LD      D,(HL)
0436F3 23          8700  			INC     HL
0436F4 38 F0       8701  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436F6 EB          8702  			EX      DE,HL			; DE: Pointer in the global heap
0436F7 28 1D       8703  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436F9             8704  ;
0436F9 CD C8 3D 04 8705  			CALL    TELL			; Display this error if the line number is not found
0436FD 46 61 69 6C 8706  			DB    	"Failed at "
       65 64 20 61 
       74 20       
043707 00          8707  			DB    	0
043708 2A 23 4D 04 8708  			LD      HL,(LINENO)
04370C CD 2F 3A 04 8709  			CALL    PBCDL
043710 CD 7F 39 04 8710  			CALL    CRLF
043714 18 07       8711  			JR      RENUM6			; And carry on renumbering
043716             8712  ;
043716             8713  ; This snippet re-encodes the line number in the BASIC program
043716             8714  ;
043716 D1          8715  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
043717 D5          8716  			PUSH    DE
043718 1B          8717  			DEC     DE			; Back up a byte to the LINO token
043719 CD 94 3D 04 8718  			CALL    ENCODE          	; Re-write the new line number out
04371D E1          8719  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
04371E C1          8720  			POP     BC			; BC: The remaining line length
04371F 18 AE       8721  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
043721             8722  ;
043721             8723  ; AUTO
043721             8724  ; AUTO start,increment
043721             8725  ; AUTO start
043721             8726  ; AUTO ,increment
043721             8727  ;
043721 CD 63 3C 04 8728  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
043725 22 29 4D 04 8729  			LD      (AUTONO),HL		; Store the start in AUTONO
043729 79          8730  			LD      A,C			; Increment is 8 bit (0-255)
04372A 32 41 4D 04 8731  			LD      (INCREM),A		; Store that in INCREM
04372E 18 2E       8732  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043730             8733  ;
043730             8734  ; BAD
043730             8735  ; NEW
043730             8736  ;
043730 CD C8 3D 04 8737  BAD:			CALL    TELL            	; Output "Bad program" error
043734 03          8738  			DB    3				; Token for "BAD"
043735 70 72 6F 67 8739  			DB    "program"
       72 61 6D    
04373C 0D          8740  			DB    CR
04373D 0A          8741  			DB    LF
04373E 00          8742  			DB    0				; Falls through to NEW
04373F             8743  ;
04373F CD A4 38 04 8744  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043743 18 19       8745  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043745             8746  ;
043745             8747  ; OLD
043745             8748  ;
043745 2A 14 4D 04 8749  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043749 E5          8750  			PUSH    HL			; Stack it
04374A 23          8751  			INC     HL			; Skip the potential length byte of first line of code
04374B 23          8752  			INC     HL			; And the line number word
04374C 23          8753  			INC     HL
04374D 01 FC 00 00 8754  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043751 3E 0D       8755  			LD      A,CR
043753 ED B1       8756  			CPIR
043755 20 D9       8757  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
043757 7D          8758  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043758 E1          8759  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043759 77          8760  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
04375A CD 77 38 04 8761  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04375E C3 B8 30 04 8762  CLOOP0:			JP      CLOOP			; Jump back to the command loop
043762             8763  ;
043762             8764  ; LOAD filename
043762             8765  ;
043762 CD 1A 03 04 8766  LOAD:			CALL    EXPRS           	; Get the filename
043766 3E 0D       8767  			LD      A,CR			; DE points to the last byte of filename in ACCS
043768 12          8768  			LD      (DE),A			; Terminate filename with a CR
043769 CD 57 38 04 8769  			CALL    LOAD0			; Load the file in, then CLEAN
04376D CD AE 38 04 8770  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043771 18 21       8771  			JR      WARM0			; Jump back to the command loop
043773             8772  ;
043773             8773  ; SAVE filename
043773             8774  ;
043773 CD 83 38 04 8775  SAVE:			CALL    SETTOP          	; Set TOP sysvar
043777 CD 1A 03 04 8776  			CALL    EXPRS           	; Get the filename
04377B 3E 0D       8777  			LD      A,CR			; Terminate the filename with a CR
04377D 12          8778  			LD      (DE),A
04377E ED 5B 14 4D 8779  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
043783 2A 17 4D 04 8780  			LD      HL,(TOP)		; HL: Top of program memory
043787 B7          8781  			OR      A			; Calculate program size (TOP-PAGE)
043788 ED 52       8782  			SBC     HL,DE
04378A 44          8783  			LD      B,H             	; BC: Length of program in bytes
04378B 4D          8784  			LD      C,L
04378C 21 00 4A 04 8785  			LD      HL,ACCS			; HL: Address of the filename
043790 CD 76 42 04 8786  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
043794 C3 B7 30 04 8787  WARM0:			JP      WARM			; Jump back to the command loop
043798             8788  
043798             8789  ;
043798             8790  ; ERROR
043798             8791  ; Called whenever BASIC needs to halt with an error
043798             8792  ; Error messages are indexed from 0
043798             8793  ; Inputs:
043798             8794  ;  A: Error number
043798             8795  ;
043798 ED 7B 20 4D 8796  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
04379D 21 81 34 04 8797  			LD      HL,ERRWDS		; Index into the error string table
0437A1 B7          8798  			OR      A			; We don't need to search for the first error
0437A2 28 0A       8799  			JR      Z,ERROR1		; So skip the search routine
0437A4             8800  ;
0437A4             8801  ; Search the error table for error #A
0437A4             8802  ; HL will end up being the pointer into the correct error
0437A4             8803  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0437A4             8804  ;
0437A4 47          8805  			LD      B,A             	; Store error number in B
0437A5 08          8806  			EX      AF,AF'			; Store error number in AF'
0437A6 AF          8807  			XOR     A
0437A7 BE          8808  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437A8 23          8809  			INC     HL			; Increment the string pointer
0437A9 20 FC       8810  			JR      NZ,ERROR0		; Loop until with hit a 0
0437AB 10 FA       8811  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0437AD 08          8812  			EX      AF,AF'			; Restore the error number from AF'
0437AE             8813  ;
0437AE             8814  ; At this point HL points to the tokenised error string
0437AE             8815  ;
0437AE E5          8816  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0437AF             8817  
0437AF             8818  ;
0437AF             8819  ; EXTERR
0437AF             8820  ; Inputs:
0437AF             8821  ;  A: Error number
0437AF             8822  ;
0437AF             8823  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0437AF             8824  ; The error text immediately follows the CALL to EXTERR, for example:
0437AF             8825  ; > CALL  EXTERR
0437AF             8826  ; > DB    "Silly", 0
0437AF             8827  ; So we can get the address of the string by popping the return address off the stack
0437AF             8828  ;
0437AF E1          8829  EXTERR:			POP     HL			; Pop the error string pointer
0437B0 22 2F 4D 04 8830  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437B4 ED 7B 20 4D 8831  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437B9 32 3F 4D 04 8832  			LD      (ERR),A			; Store error number in ERR sysvar
0437BD CD E6 39 04 8833  			CALL    SETLIN			; Get line number
0437C1 22 33 4D 04 8834  			LD      (ERL),HL		; Store in ERL sysvar
0437C5 B7          8835  			OR      A			; Is error number 0?
0437C6 28 0D       8836  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437C8             8837  ;
0437C8 2A 2C 4D 04 8838  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0437CC 7C          8839  			LD      A,H
0437CD B5          8840  			OR      L
0437CE E5          8841  			PUSH    HL			; HL: Error line
0437CF FD E1       8842  			POP     IY			; IY: HL
0437D1 C2 9E 0B 04 8843  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437D5             8844  ;
0437D5 21 00 00 00 8845  ERROR2:			LD      HL,0
0437D9 22 29 4D 04 8846  			LD      (AUTONO),HL		; Cancel AUTO
0437DD 22 26 4D 04 8847  			LD      (TRACEN),HL     	; Cancel TRACE
0437E1 CD FF 43 04 8848  			CALL    RESET           	; Reset OPSYS
0437E5 CD 7F 39 04 8849  			CALL    CRLF			; Output newline
0437E9 CD BA 3D 04 8850  			CALL    REPORT          	; Output the error message
0437ED CD 1A 3A 04 8851  			CALL    SAYLN			; Output " at line nnnn" message.
0437F1 1E 00       8852  			LD      E,0			; Close all files
0437F3 DC 74 43 04 8853  			CALL    C,OSSHUT
0437F7 CD 7F 39 04 8854  			CALL    CRLF			; Output newline
0437FB C3 B8 30 04 8855  			JP      CLOOP			; Back to CLOOP
0437FF             8856  ;
0437FF             8857  ; SUBROUTINES:
0437FF             8858  ;
0437FF             8859  ; LEX - SEARCH FOR KEYWORDS
0437FF             8860  ;   Inputs: HL = start of keyword table
0437FF             8861  ;           IY = start of match text
0437FF             8862  ;  Outputs: If found, Z-flag set, A=token.
0437FF             8863  ;           If not found, Z-flag reset, A=(IY).
0437FF             8864  ;           IY updated (if NZ, IY unchanged).
0437FF             8865  ; Destroys: A,B,H,L,IY,F
0437FF             8866  ;
0437FF 21 A0 31 04 8867  LEX:			LD      HL,KEYWDS		; Address of the keywords table
043803             8868  ;
043803 FD 7E 00    8869  LEX0:			LD      A,(IY)			; Fetch the character to match
043806 46          8870  			LD      B,(HL)			; B: The token from the keywords table
043807 23          8871  			INC     HL			; Increment the pointer in the keywords table
043808 BE          8872  			CP      (HL)			; Compare the first characters
043809 28 08       8873  			JR      Z,LEX2			; If there is a match, then skip to LEX2
04380B D8          8874  			RET     C               	; No match, so fail
04380C             8875  ;
04380C             8876  ; This snippet of code skips to the next token in the KEYWDS table
04380C             8877  ;
04380C 23          8878  LEX1:			INC     HL			; Increment the pointer
04380D CB 7E       8879  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
04380F 28 FB       8880  			JR      Z,LEX1			; No, so loop
043811 18 F0       8881  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
043813             8882  ;
043813 FD E5       8883  LEX2:			PUSH    IY              	; Save the input pointer
043815 23          8884  LEX3:			INC     HL			; Increment the keyword pointer
043816 CB 7E       8885  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043818 20 1C       8886  			JR      NZ,LEX6         	; Jump to here as we've found a token
04381A FD 23       8887  			INC     IY			; Increment the text pointer
04381C FD 7E 00    8888  			LD      A,(IY)			; Fetch the character
04381F FE 2E       8889  			CP      '.'			; Is it an abbreviated keyword?
043821 28 13       8890  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
043823 BE          8891  			CP      (HL)			; Compare with the keywords list
043824 28 EF       8892  			JR      Z,LEX3			; It's a match, so continue checking this keyword
043826 CD B3 3C 04 8893  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
04382A 38 04       8894  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
04382C             8895  ;
04382C FD E1       8896  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
04382E 18 DC       8897  			JR      LEX1			; And loop back to start again
043830             8898  ;
043830             8899  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
043830             8900  ; immediately delimited
043830             8901  ;
043830 7E          8902  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
043831 B7          8903  			OR      A			; If it is not zero, then...
043832 20 F8       8904  			JR      NZ,LEX4			; Keep searching
043834 FD 2B       8905  			DEC     IY			; If it is zero, then skip the input pointer back one byte
043836             8906  ;
043836             8907  ; We've found a token at this point
043836             8908  ;
043836 F1          8909  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
043837 AF          8910  			XOR     A			; Set the Z flag
043838 78          8911  			LD      A,B			; A: The token
043839 C9          8912  			RET
04383A             8913  ;
04383A             8914  ; DEL - DELETE A PROGRAM LINE.
04383A             8915  ;   Inputs: HL addresses program line.
04383A             8916  ; Destroys: B,C,F
04383A             8917  ;
04383A             8918  ; This simply erases the line by moving all of the code after the line to be deleted back over
04383A             8919  ; it using an LDIR
04383A             8920  ;
04383A D5          8921  DEL:			PUSH    DE
04383B E5          8922  			PUSH    HL
04383C E5          8923  			PUSH    HL			; HL: Address of the program line
04383D 06 00       8924  			LD      B,0			; BC: Length of the line
04383F 4E          8925  			LD      C,(HL)
043840 09          8926  			ADD     HL,BC			; HL: Advanced to the start of the next line
043841 E5          8927  			PUSH    HL
043842 EB          8928  			EX      DE,HL			; DE: Pointer to the next line
043843 2A 17 4D 04 8929  			LD      HL,(TOP)		; HL: Pointer to the end of the program
043847 ED 52       8930  			SBC     HL,DE
043849 44          8931  			LD      B,H			; BC: Size of block to move
04384A 4D          8932  			LD      C,L
04384B E1          8933  			POP     HL			; HL: Pointer to next line
04384C D1          8934  			POP     DE			; DE: Pointer to this line
04384D ED B0       8935  			LDIR                    	; Delete the line
04384F ED 53 17 4D 8936  			LD      (TOP),DE		; Adjust TOP
       04          
043854 E1          8937  			POP     HL
043855 D1          8938  			POP     DE
043856 C9          8939  			RET
043857             8940  ;
043857             8941  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
043857             8942  ;   Inputs: Filename in ACCS (term CR)
043857             8943  ; Destroys: A,B,C,D,E,H,L,F
043857             8944  ;
043857             8945  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
043857             8946  ; AND WRITE FF FF, THEN LOAD (TOP).
043857             8947  ; Destroys: A,B,C,H,L,F
043857             8948  ;
043857 ED 5B 14 4D 8949  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
04385C 21 00 FF FF 8950  			LD      HL,-256
043860 39          8951  			ADD     HL,SP
043861 ED 52       8952  			SBC     HL,DE           	; Find available space
043863 44          8953  			LD      B,H
043864 4D          8954  			LD      C,L
043865 21 00 4A 04 8955  			LD      HL,ACCS
043869 CD DD 41 04 8956  			CALL    OSLOAD          	; Call the OSLOAD function in patch
04386D D4 A4 38 04 8957  			CALL    NC,NEWIT		; If NC then NEW
043871 3E 00       8958  			LD      A,0
043873 D2 98 37 04 8959  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
043877             8960  ;
043877 CD 83 38 04 8961  CLEAN:			CALL    SETTOP			; Set TOP sysvar
04387B 2B          8962  			DEC     HL			; Write out the end of program markers
04387C 36 FF       8963  			LD      (HL),-1
04387E 2B          8964  			DEC     HL
04387F 36 FF       8965  			LD      (HL),-1
043881 18 2B       8966  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
043883             8967  ;
043883             8968  ; Set the TOP sysvar; the first free location after the end of the current program
043883             8969  ; Returns:
043883             8970  ; - HL: TOP
043883             8971  ;
043883 2A 14 4D 04 8972  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
043887 01 00 00 00 8973  			LD	BC, 0			; BC: 0
04388B 3E 0D       8974  			LD      A,CR			; End of line marker
04388D 4E          8975  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
04388E 0C          8976  			INC     C			; Check for zero
04388F 0D          8977  			DEC     C
043890 28 0A       8978  			JR      Z,SETOP2		; If it is zero, we've reached the end
043892 09          8979  			ADD     HL,BC			; Skip to next line
043893 2B          8980  			DEC     HL			; Check end of previous line
043894 BE          8981  			CP      (HL)
043895 23          8982  			INC     HL
043896 28 F5       8983  			JR      Z,SETOP1		; If CR then loop
043898 C3 30 37 04 8984  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
04389C             8985  ;
04389C 23          8986  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
04389D 23          8987  			INC     HL			; NB: Called from NEWIT
04389E 23          8988  			INC     HL
04389F 22 17 4D 04 8989  			LD      (TOP),HL		; Store in TOP sysvar
0438A3 C9          8990  			RET
0438A4             8991  ;
0438A4             8992  ; NEWIT - NEW PROGRAM THEN CLEAR
0438A4             8993  ;   Destroys: H,L
0438A4             8994  ;
0438A4             8995  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0438A4             8996  ; FUNCTION AND PROCEDURE POINTERS.
0438A4             8997  ;   Destroys: Nothing
0438A4             8998  ;
0438A4 2A 14 4D 04 8999  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438A8 36 00       9000  			LD      (HL),0			; Stick a 0 in there
0438AA CD 9C 38 04 9001  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438AE             9002  ;
0438AE E5          9003  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438AF 2A 17 4D 04 9004  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438B3 22 1A 4D 04 9005  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0438B7 22 1D 4D 04 9006  			LD      (FREE),HL		; And the FREE sysvar with that value
0438BB 21 6C 4C 04 9007  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438BF C5          9008  			PUSH    BC
0438C0             9009  			; LD      B,3*(54+2)		; Loop counter
0438C0 06 A8       9010  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438C2 36 00       9011  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438C4 23          9012  			INC     HL
0438C5 10 FB       9013  			DJNZ    CLEAR1
0438C7 C1          9014  			POP     BC
0438C8 E1          9015  			POP     HL			; Restore the BASIC program pointer
0438C9 C9          9016  			RET
0438CA             9017  ;
0438CA             9018  ;LISTIT - LIST A PROGRAM LINE.
0438CA             9019  ;    Inputs: HL addresses line
0438CA             9020  ;            DE = line number (binary)
0438CA             9021  ;            IX = Pointer to LISTON
0438CA             9022  ;             B = FOR/NEXT indent level
0438CA             9023  ;             C = REPEAT/UNTIL indent level
0438CA             9024  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0438CA             9025  ;
0438CA E5          9026  LISTIT:			PUSH    HL			; Stack the address of the line
0438CB EB          9027  			EX      DE,HL			; HL: Line number
0438CC C5          9028  			PUSH    BC
0438CD CD 33 3A 04 9029  			CALL    PBCD			; Print the line number
0438D1 C1          9030  			POP     BC
0438D2 E1          9031  			POP     HL			; HL: Address of the first token/character
0438D3 7E          9032  			LD      A,(HL)			; Fetch the token
0438D4 FE ED       9033  			CP      NEXT			; Is it NEXT...
0438D6 CC 60 39 04 9034  			CALL    Z,INDENT		; Yes, so indent in
0438DA FE FD       9035  			CP      UNTIL			; Or is it UNTIL...
0438DC CC 60 39 04 9036  			CALL    Z,INDENT		; Yes, so indent in
0438E0 D9          9037  			EXX
0438E1 3E 20       9038  			LD      A,' '
0438E3 DD CB 00 46 9039  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0438E7 C4 87 39 04 9040  			CALL    NZ,OUTCHR		; Then print a space after the line number
0438EB 78          9041  			LD      A,B			; Fetch the FOR/NEXT indent level
0438EC 87          9042  			ADD     A,A			; Multiply by 2
0438ED DD CB 00 4E 9043  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0438F1 C4 21 18 04 9044  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438F5 79          9045  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438F6 87          9046  			ADD     A,A			; Multiply by 2
0438F7 DD CB 00 56 9047  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0438FB C4 21 18 04 9048  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438FF D9          9049  			EXX
043900 7E          9050  			LD      A,(HL)			; Fetch the token
043901 FE E3       9051  			CP      FOR			; Is it FOR?
043903 CC 60 39 04 9052  			CALL    Z,INDENT		; Yes, so indent
043907 FE F5       9053  			CP      REPEAT			; Is it REPEAT?
043909 CC 60 39 04 9054  			CALL    Z,INDENT		; Yes, so indent
04390D 1E 00       9055  			LD      E,0			; E: The quote counter - reset to 0
04390F 7E          9056  LIST8:			LD      A,(HL)			; Fetch a character / token byte
043910 23          9057  			INC     HL
043911 FE 0D       9058  			CP      CR			; Is it end of line?
043913 28 0B       9059  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
043915 FE 22       9060  			CP      34			; Is it a quote character?
043917 20 01       9061  			JR      NZ,LIST7		; No, so skip to next bit
043919 1C          9062  			INC     E			; Otherwise increment quote counter
04391A CD 4F 39 04 9063  LIST7:			CALL    LOUT			; Output the character / token
04391E 18 EF       9064  			JR      LIST8			; And repeat
043920             9065  ;
043920             9066  ; DB: Modification for *EDIT
043920             9067  ; Terminate the line with either a CRLF or a NUL character
043920             9068  ;
043920 DD CB 00 5E 9069  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
043924 28 59       9070  			JR	Z, CRLF			; Yes, so print a CRLF
043926 AF          9071  			XOR	A			; Otherwise print a NUL (0)
043927 C3 38 3F 04 9072  			JP	OSWRCH
04392B             9073  ;
04392B             9074  ; Decode the 3 byte GOTO type line number
04392B             9075  ;
04392B E5          9076  PRLINO:			PUSH    HL			; Swap HL and IY
04392C FD E1       9077  			POP     IY			; IY: Pointer to the line number
04392E C5          9078  			PUSH    BC
04392F CD EB 08 04 9079  			CALL    DECODE			; Decode
043933 C1          9080  			POP     BC
043934 D9          9081  			EXX
043935 C5          9082  			PUSH    BC
043936 CD 2F 3A 04 9083  			CALL    PBCDL			; Output the line number
04393A C1          9084  			POP     BC
04393B D9          9085  			EXX
04393C FD E5       9086  			PUSH    IY			; Swap HL and IY
04393E E1          9087  			POP     HL			; HL: Pointer to the next character in the line
04393F C9          9088  			RET
043940             9089  ;
043940             9090  ; DB: Modification for internationalisation
043940             9091  ;
043940 CD A4 39 04 9092  PRREM:			CALL	OUT_			; Output the REM token
043944 7E          9093  @@:			LD	A, (HL)			; Fetch the character
043945 FE 0D       9094  			CP	CR			; If it is end of line, then
043947 C8          9095  			RET	Z			; we have finished
043948 CD 87 39 04 9096  			CALL	OUTCHR			; Ouput the character
04394C 23          9097  			INC	HL
04394D 18 F5       9098  			JR	@B			; And loop
04394F             9099  ;
04394F             9100  ; DB: End of modification
04394F             9101  ;
04394F CB 43       9102  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043951 20 34       9103  			JR      NZ,OUTCHR		; don't tokenise, just output the character
043953 FE F4       9104  			CP	REM			; DB: Is it REM
043955 28 E9       9105  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
043957 FE 8D       9106  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043959 28 D0       9107  			JR      Z,PRLINO		; Yes, so decode and print the line number
04395B CD A4 39 04 9108  			CALL    OUT_			; Output a character / keyword
04395F 7E          9109  			LD      A,(HL)			; Fetch the next character
043960             9110  ;
043960             9111  ; This block of code handles the indentation
043960             9112  ; B: Counter for FOR/NEXT indent
043960             9113  ; C: Counter for REPEAT/UNTIL indent
043960             9114  ;
043960 D9          9115  INDENT:			EXX
043961 FE E3       9116  			CP      FOR			; If the token is FOR
043963 28 09       9117  			JR      Z,IND1			; Then INC B
043965 FE ED       9118  			CP      NEXT			; If it is NEXT
043967 20 06       9119  			JR      NZ,IND2_		; Then...
043969 05          9120  			DEC     B			; DEC B
04396A F2 6F 39 04 9121  			JP      P,IND2_			; If we have gone below 0 then
04396E 04          9122  IND1:			INC     B			; Increment back to 0
04396F             9123  ;
04396F FE F5       9124  IND2_:			CP      REPEAT			; If the token is REPEAT
043971 28 09       9125  			JR      Z,IND3			; Then INC C
043973 FE FD       9126  			CP      UNTIL			; If it is UNTIL
043975 20 06       9127  			JR      NZ,IND4			; Then...
043977 0D          9128  			DEC     C			; DEC C
043978 F2 7D 39 04 9129  			JP      P,IND4			; If we have gone below 0 then
04397C 0C          9130  IND3:			INC     C			; Incremet back to 0
04397D D9          9131  IND4:			EXX
04397E C9          9132  			RET
04397F             9133  ;
04397F             9134  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
04397F             9135  ;  Destroys: A,F
04397F             9136  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
04397F             9137  ;    Inputs: A = character
04397F             9138  ;  Destroys: A,F
04397F             9139  ;
04397F 3E 0D       9140  CRLF:			LD      A,CR			; Output CR
043981 CD 87 39 04 9141  			CALL    OUTCHR
043985 3E 0A       9142  			LD      A,LF			; Output LF
043987             9143  ;
043987 CD 38 3F 04 9144  OUTCHR:			CALL    OSWRCH			; Output the character in A
04398B D6 0D       9145  			SUB     CR			; Check for CR
04398D 28 06       9146  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
04398F D8          9147  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043990 3A 3D 4D 04 9148  			LD      A,(COUNT)		; Increment the count
043994 3C          9149  			INC     A
043995             9150  ;
043995 32 3D 4D 04 9151  CARRET:			LD      (COUNT),A		; Store the new count value
043999 C8          9152  			RET     Z			; Return if the count has wrapped to 0
04399A E5          9153  			PUSH    HL			; Now check if count = print width
04399B 2A 3E 4D 04 9154  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
04399F BD          9155  			CP      L			; L is the width. Compare it with count.
0439A0 E1          9156  			POP     HL
0439A1 C0          9157  			RET     NZ			; If we've not hit print width, then just return
0439A2 18 DB       9158  			JR      CRLF			; Otherwise output CRLF
0439A4             9159  ;
0439A4             9160  ; OUT - SEND CHARACTER OR KEYWORD
0439A4             9161  ;   Inputs: A = character (>=10, <128)
0439A4             9162  ;           A = Token (<10, >=128)
0439A4             9163  ;  Destroys: A,F
0439A4             9164  ;
0439A4 FE 8A       9165  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0439A6 EA 87 39 04 9166  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439AA             9167  ;
0439AA             9168  ; This bit looks up the character in the KEYWDS token table and expands it
0439AA             9169  ; Note the CP 138; this sets the overflow flag as follows:
0439AA             9170  ;
0439AA             9171  ; NB:
0439AA             9172  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0439AA             9173  ;  2. CP is effectively a SUB; sets the flags without affecting A
0439AA             9174  ;  3. The operation n - -118 ~ n + 118
0439AA             9175  ;
0439AA             9176  ; So:
0439AA             9177  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0439AA             9178  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0439AA             9179  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0439AA             9180  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0439AA             9181  ;
0439AA C5          9182  			PUSH    BC			; Preserve BC and HL
0439AB E5          9183  			PUSH    HL
0439AC 21 A0 31 04 9184  			LD      HL,KEYWDS		; The list of tokens and keywords
0439B0 01 DF 02 00 9185  			LD      BC,KEYWDL		; The length of the keyword list
0439B4 ED B1       9186  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439B6             9187  ;							; At this point HL points to the next byte, the first character of the token
0439B6 7E          9188  TOKEN1:			LD      A,(HL)			; Fetch the character
0439B7 23          9189  			INC     HL			; Increment to the next byte in the token table
0439B8 FE 8A       9190  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439BA F5          9191  			PUSH    AF			; Then...
0439BB EC 87 39 04 9192  			CALL    PE,OUTCHR		; Output the character...
0439BF F1          9193  			POP     AF			;
0439C0 EA B6 39 04 9194  			JP      PE,TOKEN1		; And loop to the next character
0439C4 E1          9195  			POP     HL			; Done, so tidy up the stack and exit
0439C5 C1          9196  			POP     BC
0439C6 C9          9197  			RET
0439C7             9198  ;
0439C7             9199  ; FINDL - FIND PROGRAM LINE
0439C7             9200  ;   Inputs: HL = line number (binary)
0439C7             9201  ;  Outputs: HL addresses line (if found)
0439C7             9202  ;           DE = line number
0439C7             9203  ;           Z-flag set if found.
0439C7             9204  ; Destroys: A,B,C,D,E,H,L,F
0439C7             9205  ;
0439C7 EB          9206  FINDL:			EX      DE,HL			; DE: Line number (binary)
0439C8 2A 14 4D 04 9207  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439CC AF          9208  			XOR     A               	;  A: 0
0439CD BE          9209  			CP      (HL)			; Check for end of program marker
0439CE 3C          9210  			INC     A			;  A: 1
0439CF D0          9211  			RET     NC			; Return with 1 if 0
0439D0 AF          9212  			XOR     A               	; Clear the carry flag
0439D1             9213  ;			LD      B,A			;  B: 0
0439D1 01 00 00 00 9214  			LD	BC, 0			; BC: 0
0439D5             9215  ;
0439D5 4E          9216  FINDL1:			LD      C,(HL)			;  C: The line length
0439D6 E5          9217  			PUSH    HL			; Stack the current program counter
0439D7 23          9218  			INC     HL			; Skip to the line number bytes
0439D8 7E          9219  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439D9 23          9220  			INC     HL
0439DA 66          9221  			LD      H,(HL)
0439DB 6F          9222  			LD      L,A
0439DC 52 ED 52    9223  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439DF E1          9224  			POP     HL			; Get the current program counter
0439E0 D0          9225  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439E1 09          9226  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439E2 C3 D5 39 04 9227  			JP      FINDL1			; And loop
0439E6             9228  ;
0439E6             9229  ; SETLIN - Search program for line containing address
0439E6             9230  ;          Update (LINENO)
0439E6             9231  ;   Inputs: Address in (ERRLIN)
0439E6             9232  ;  Outputs: Line number in HL and (LINENO)
0439E6             9233  ; Destroys: B,C,D,E,H,L,F
0439E6             9234  ;
0439E6 01 00 00 00 9235  SETLIN:			LD	BC, 0			; Zero BC for later
0439EA             9236  ;			LD      B, 0			; Zero B for later
0439EA ED 5B 35 4D 9237  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
0439EF 2A 14 4D 04 9238  			LD      HL, (PAGE_)		; HL: Start of user program area
0439F3 B7          9239  			OR      A			; Do a 24 bit compare without destroying HL
0439F4 ED 52       9240  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439F6 19          9241  			ADD     HL, DE			;  C: DE > HL
0439F7 30 1B       9242  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439F9             9243  ;
0439F9 4E          9244  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439FA 0C          9245  			INC     C			; This is a way to check for zero without using the accumulator
0439FB 0D          9246  			DEC     C			; If it is zero, then...
0439FC 28 16       9247  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439FE 09          9248  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439FF ED 52       9249  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
043A01 19          9250  			ADD     HL, DE
043A02 38 F5       9251  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
043A04 ED 42       9252  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
043A06 23          9253  			INC     HL			; Skip the length counter
043A07 11 00 00 00 9254  			LD	DE, 0			; Zero DE
043A0B 5E          9255  			LD      E, (HL)          	; Fetch the line number
043A0C 23          9256  			INC     HL
043A0D 56          9257  			LD      D, (HL)
043A0E EB          9258  			EX      DE, HL			; HL: The line number
043A0F 22 23 4D 04 9259  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A13 C9          9260  			RET
043A14             9261  ;
043A14 21 00 00 00 9262  SET3:			LD      HL, 0			; We've not found the line at this point so
043A18 18 F5       9263  			JR      SET2			; Set LINENO to 0
043A1A             9264  ;
043A1A             9265  ;SAYLN - PRINT " at line nnnn" MESSAGE.
043A1A             9266  ;  Outputs: Carry=0 if line number is zero.
043A1A             9267  ;           Carry=1 if line number is non-zero.
043A1A             9268  ; Destroys: A,B,C,D,E,H,L,F
043A1A             9269  ;
043A1A 2A 23 4D 04 9270  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A1E 7C          9271  			LD      A,H			; If it is zero then
043A1F B5          9272  			OR      L
043A20 C8          9273  			RET     Z			; Don't need to do anything; return with F:C set to 0
043A21 CD C8 3D 04 9274  			CALL    TELL			; Output the error message
043A25 20 61 74 20 9275  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
043A2F 0E 00       9276  PBCDL:			LD      C,0			; C: Leading character (NUL)
043A31 18 02       9277  			JR      PBCD0			; Output the line number; return with F:C set to 1
043A33             9278  ;
043A33             9279  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
043A33             9280  ;   Inputs: HL = number (binary).
043A33             9281  ;  Outputs: Carry = 1
043A33             9282  ; Destroys: A,B,C,D,E,H,L,F
043A33             9283  ;
043A33 0E 20       9284  PBCD:			LD      C,' '			; C: Leading character (" ")
043A35 06 05       9285  PBCD0:			LD      B,5			; Number of digits in result
043A37 11 10 27 00 9286  			LD      DE,10000		; Start off with the 10,000 column
043A3B AF          9287  PBCD1:			XOR     A			; Counter
043A3C ED 52       9288  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A3E 3C          9289  			INC     A
043A3F 30 FB       9290  			JR      NC,PBCD2
043A41 19          9291  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A42 3D          9292  			DEC     A			; A: Number of 10,000s
043A43 28 04       9293  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A45 CB E1       9294  			SET     4,C			; C: Set to '0' ASCII (30h)
043A47 CB E9       9295  			SET     5,C
043A49 B1          9296  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A4A C4 87 39 04 9297  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A4E 78          9298  			LD      A,B			; If on first transition, skip this
043A4F FE 05       9299  			CP      5			; TODO: Need to find out why
043A51 28 06       9300  			JR      Z,PBCD4
043A53 29          9301  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A54 54          9302  			LD      D,H			;         : rather than shifting DE right
043A55 5D          9303  			LD      E,L			;         : This makes a lot of sense
043A56 29          9304  			ADD     HL,HL			; HL x  4
043A57 29          9305  			ADD     HL,HL			; HL x  8
043A58 19          9306  			ADD     HL,DE			; HL x 10
043A59 11 E8 03 00 9307  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A5D 10 DC       9308  			DJNZ    PBCD1			; Loop until done
043A5F 37          9309  			SCF				; SCF set for SAYLN in this module
043A60 C9          9310  			RET
043A61             9311  ;
043A61             9312  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A61             9313  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A61             9314  ;  Outputs: As GETVAR.
043A61             9315  ; Destroys: everything
043A61             9316  ;
043A61 CD E6 3B 04 9317  PUTVAR:			CALL    CREATE			; Create the variable
043A65 FD 7E 00    9318  			LD      A,(IY)			; Fetch the next character
043A68 FE 28       9319  			CP      '('			; Check for bad use of array
043A6A 20 70       9320  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A6C 3E 0E       9321  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A6E C3 98 37 04 9322  ERROR3:			JP      ERROR_
043A72             9323  ;
043A72             9324  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A72             9325  ;   Inputs: IY addresses first character.
043A72             9326  ;  Outputs: Carry set and NZ if illegal character.
043A72             9327  ;           Z-flag set if variable found, then:
043A72             9328  ;            A = variable type (0,4,5,128 or 129)
043A72             9329  ;            HL = IX = variable pointer.
043A72             9330  ;            IY updated
043A72             9331  ;           If Z-flag & carry reset, then:
043A72             9332  ;            HL, IY set for subsequent PUTVAR call.
043A72             9333  ; Destroys: everything
043A72             9334  ;
043A72 FD 7E 00    9335  GETVAR:			LD      A,(IY)			; Get the first character
043A75 FE 24       9336  			CP      '$'			; Is it a string?
043A77 28 69       9337  			JR      Z,GETV4			; Yes, so branch here
043A79 FE 21       9338  			CP      '!'			; Is it indirection (32-bit)?
043A7B 28 69       9339  			JR      Z,GETV5			; Yes, so branch here
043A7D FE 3F       9340  			CP      '?'			; Is it indirection (8-bit)?
043A7F 28 69       9341  			JR      Z,GETV6			; Yes, so branch here
043A81             9342  ;
043A81 CD 50 3B 04 9343  			CALL    LOCATE			; Locate the variable
043A85 C0          9344  			RET     NZ			; And exit here if not found
043A86             9345  ;
043A86             9346  ; At this point:
043A86             9347  ;  HL: Address of variable in memory
043A86             9348  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043A86             9349  ;
043A86 FD 7E 00    9350  			LD      A,(IY)			; Further checks
043A89 FE 28       9351  			CP      '('             	; Is it an array?
043A8B 20 47       9352  			JR      NZ,GETVX        	; No, so exit
043A8D             9353  ;
043A8D             9354  ; We are processing an array at this point
043A8D             9355  ;
043A8D D5          9356  			PUSH    DE              	; Save the variable type (in D)
043A8E 7E          9357  			LD      A,(HL)          	; Fetch the number of dimensions
043A8F B7          9358  			OR      A
043A90 28 DA       9359  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A92 23          9360  			INC     HL			;
043A93 11 00 00 00 9361  			LD      DE,0            	; Accumulator
043A97 F5          9362  			PUSH    AF
043A98 FD 23       9363  			INC     IY              	; Skip "("
043A9A 18 05       9364  			JR      GETV3
043A9C             9365  ;
043A9C F5          9366  GETV2:			PUSH    AF
043A9D CD 2A 0A 04 9367  			CALL    COMMA
043AA1 E5          9368  GETV3:			PUSH    HL
043AA2 D5          9369  			PUSH    DE
043AA3 CD 0F 03 04 9370  			CALL    EXPRI			; Get the subscript
043AA7 D9          9371  			EXX
043AA8 D1          9372  			POP     DE
043AA9 E3          9373  			EX      (SP),HL
043AAA 4E          9374  			LD      C,(HL)
043AAB 23          9375  			INC     HL
043AAC 46          9376  			LD      B,(HL)
043AAD 23          9377  			INC     HL
043AAE E3          9378  			EX      (SP),HL
043AAF EB          9379  			EX      DE,HL
043AB0 D5          9380  			PUSH    DE
043AB1 CD A4 18 04 9381  			CALL    MUL16			; HL=HL*BC
043AB5 D1          9382  			POP     DE
043AB6 19          9383  			ADD     HL,DE
043AB7 EB          9384  			EX      DE,HL
043AB8 B7          9385  			OR      A
043AB9 ED 42       9386  			SBC     HL,BC
043ABB 3E 0F       9387  			LD      A,15
043ABD 30 AF       9388  			JR      NC,ERROR3		; Throw a "Subscript" error
043ABF E1          9389  			POP     HL
043AC0 F1          9390  			POP     AF
043AC1 3D          9391  			DEC     A               	; Dimension counter
043AC2 20 D8       9392  			JR      NZ,GETV2
043AC4 CD 37 0A 04 9393  			CALL    BRAKET          	; Check for closing bracket
043AC8 F1          9394  			POP     AF              	; Restore the type
043AC9 E5          9395  			PUSH    HL
043ACA CD 97 18 04 9396  			CALL    X4OR5           	; DE=DE*n
043ACE E1          9397  			POP     HL
043ACF 19          9398  			ADD     HL,DE
043AD0 57          9399  			LD      D,A             	; The type
043AD1 FD 7E 00    9400  			LD      A,(IY)
043AD4 FE 3F       9401  GETVX:			CP      '?'
043AD6 28 1E       9402  			JR      Z,GETV9
043AD8 FE 21       9403  			CP      '!'
043ADA 28 16       9404  			JR      Z,GETV8
043ADC E5          9405  GETVZ:			PUSH    HL              	; Set exit conditions
043ADD DD E1       9406  			POP     IX
043ADF 7A          9407  			LD      A,D
043AE0 BF          9408  			CP      A
043AE1 C9          9409  			RET
043AE2             9410  ;
043AE2             9411  ; Process strings, unary & binary indirection:
043AE2             9412  ;
043AE2 3E 80       9413  GETV4:			LD      A,128           	; Static strings
043AE4 18 05       9414  			JR      GETV7
043AE6             9415  ;
043AE6 3E 04       9416  GETV5:			LD      A,4             	; Unary 32-bit indirection
043AE8 18 01       9417  			JR      GETV7
043AEA             9418  ;
043AEA AF          9419  GETV6:			XOR     A               	; Unary 8-bit indirection
043AEB             9420  ;
043AEB 21 00 00 00 9421  GETV7:			LD      HL,0
043AEF F5          9422  			PUSH    AF
043AF0 18 24       9423  			JR      GETV0
043AF2             9424  ;
043AF2 06 04       9425  GETV8:			LD      B,4             	; Binary 32-bt indirection
043AF4 18 02       9426  			JR      GETVA
043AF6             9427  ;
043AF6 06 00       9428  GETV9:			LD      B,0             	; Binary 8-bit indirection
043AF8             9429  ;
043AF8 E5          9430  GETVA:			PUSH    HL
043AF9 DD E1       9431  			POP     IX
043AFB 7A          9432  			LD      A,D            		; Fetch the variable type
043AFC FE 81       9433  			CP      129			; Is it a string?
043AFE C8          9434  			RET     Z               	; Yes, so exit here
043AFF C5          9435  			PUSH    BC
043B00 CD 1B 04 04 9436  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043B04 CD 67 06 04 9437  			CALL    SFIX
043B08 7D          9438  			LD	A,L
043B09 D9          9439  			EXX
043B0A 22 4A 4D 04 9440  			LD	(R0+0),HL
043B0E 32 4C 4D 04 9441  			LD	(R0+2),A
043B12 2A 4A 4D 04 9442  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B16             9443  ;
043B16 E5          9444  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B17 FD 23       9445  			INC     IY
043B19 CD 2A 03 04 9446  			CALL    ITEMI
043B1D 7D          9447  			LD	A,L			;  A: The MSB of the address
043B1E D9          9448  			EXX
043B1F 22 4A 4D 04 9449  			LD	(R0+0),HL		; HL: The LSW of the address
043B23 32 4C 4D 04 9450  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B27 D1          9451  			POP     DE
043B28 F1          9452  			POP     AF
043B29 2A 4A 4D 04 9453  			LD	HL,(R0)			; HL: L'HL
043B2D 19          9454  			ADD     HL,DE
043B2E E5          9455  			PUSH    HL
043B2F DD E1       9456  			POP     IX
043B31 BF          9457  			CP      A
043B32 C9          9458  			RET
043B33             9459  ;
043B33             9460  ;GETDEF - Find entry for FN or PROC in dynamic area.
043B33             9461  ;   Inputs: IY addresses byte following "DEF" token.
043B33             9462  ;  Outputs: Z flag set if found
043B33             9463  ;           Carry set if neither FN or PROC first.
043B33             9464  ;           If Z: HL points to entry
043B33             9465  ;                 IY addresses delimiter
043B33             9466  ; Destroys: A,D,E,H,L,IY,F
043B33             9467  ;
043B33 FD 7E 01    9468  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B36 CD B3 3C 04 9469  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B3A D8          9470  			RET     C			; No so return with C set
043B3B FD 7E 00    9471  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B3E 21 0E 4D 04 9472  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B42 FE A4       9473  			CP      FN			; Is it the token FN?
043B44 28 4A       9474  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B46 21 11 4D 04 9475  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B4A FE F2       9476  			CP      PROC			; Is it the token PROC?
043B4C 28 42       9477  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B4E 37          9478  			SCF				; No, so just return with C set
043B4F C9          9479  			RET
043B50             9480  ;
043B50             9481  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B50             9482  ; If illegal first character return carry, non-zero.
043B50             9483  ; If found, return no-carry, zero.
043B50             9484  ; If not found, return no-carry, non-zero.
043B50             9485  ;   Inputs: IY=Addresses first character of name.
043B50             9486  ;            A=(IY)
043B50             9487  ;  Outputs:  F=Z set if found, then:
043B50             9488  ;           IY=addresses terminator
043B50             9489  ;           HL=addresses location of variable
043B50             9490  ;            D=type of variable: 4 = integer
043B50             9491  ;                                5 = floating point
043B50             9492  ;                              129 = string
043B50             9493  ; Destroys: A,D,E,H,L,IY,F
043B50             9494  ;
043B50             9495  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B50             9496  ; They can contain any alphanumeric character and underscore (_)
043B50             9497  ; String variables are postfixed with the dollar ($) character
043B50             9498  ; Integer variables are postfixed with the percent (%) character
043B50             9499  ; Static integer variables are named @%, A% to Z%
043B50             9500  ; All other variables are dynamic
043B50             9501  ;
043B50 D6 40       9502  LOCATE:			SUB     '@'			; Check for valid range
043B52 D8          9503  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B53 21 00 00 00 9504  			LD      HL, 0			; Clear HL
043B57 FE 1B       9505  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B59 30 1E       9506  			JR      NC,LOC0         	; Then branch here
043B5B 6F          9507  			LD	L, A			; HL = A
043B5C FD 7E 01    9508  			LD      A,(IY+1)        	; Check the 2nd character
043B5F FE 25       9509  			CP      '%'			; If not "%" then it is not static...
043B61 20 21       9510  			JR      NZ,LOC1         	; Branch here
043B63 FD 7E 02    9511  			LD      A,(IY+2)		; Check the 3rd character
043B66 FE 28       9512  			CP      '('			; If it is "(" (array) then it is not static...
043B68 28 1A       9513  			JR      Z,LOC1          	; Branch here
043B6A             9514  ;
043B6A             9515  ; At this point we're dealing with a static variable
043B6A             9516  ;
043B6A 29          9517  			ADD     HL,HL			; HL: Variable index * 4
043B6B 29          9518  			ADD	HL,HL
043B6C 11 00 4C 04 9519  			LD      DE,STAVAR       	; The static variable area in memory
043B70 19          9520  			ADD     HL,DE			; HL: The address of the static variable
043B71 FD 23       9521  			INC     IY			; Skip the program pointer past the static variable name
043B73 FD 23       9522  			INC     IY
043B75 16 04       9523  			LD      D,4             	; Set the type to be integer
043B77 AF          9524  			XOR     A			; Set the Z flag
043B78 C9          9525  			RET
043B79             9526  ;
043B79             9527  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B79             9528  ;
043B79 FE 1F       9529  LOC0:			CP      '_'-'@'			; Check the first character is in
043B7B D8          9530  			RET     C			; the range "_" to
043B7C FE 3B       9531  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B7E 3F          9532  			CCF				; If it is not in range then
043B7F 3D          9533  			DEC     A               	; Set NZ flag and
043B80 D8          9534  			RET     C			; Exit here
043B81 D6 03       9535  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B83 6F          9536  			LD	L, A			; HL = A
043B84             9537  ;
043B84             9538  ; Yes, it's definitely a dynamic variable at this point...
043B84             9539  ;
043B84 7D          9540  LOC1:			LD	A, L			; Fetch variable index
043B85 87          9541  			ADD	A, A			; x 2
043B86 85          9542  			ADD	A, L			; x 3
043B87 D6 03       9543  			SUB	3			; Subtract 2 TODO: Should be 3
043B89 6F          9544  			LD	L, A
043B8A 11 6C 4C 04 9545  			LD      DE, DYNVAR       	; The dynamic variable storage
043B8E D8          9546  			RET	C			; Bounds check to trap for variable '@'
043B8F 19          9547  			ADD     HL, DE			; HL: Address of first entry
043B90             9548  ;
043B90             9549  ; Loop through the linked list of variables to find a match
043B90             9550  ;
043B90 ED 17       9551  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B92 E5          9552  			PUSH	HL			; Need to preserve HL for LOC6
043B93 AF          9553  			XOR	A			; Reset carry flag
043B94 ED 62       9554  			SBC	HL, HL			; Set HL to 0
043B96 ED 52       9555  			SBC	HL, DE			; Compare with 0
043B98 E1          9556  			POP	HL			; Restore the original pointer
043B99 28 49       9557  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B9B             9558  			; LD	HL, DE			; Make a copy of this pointer in HL
043B9B D5          9559  			push de
043B9C E1          9560  			pop hl ; how was that even possible?
043B9D 23          9561  			INC     HL              	; Skip the link (24-bits)
043B9E 23          9562  			INC     HL
043B9F 23          9563  			INC	HL			; HL: Address of the variable name in DYNVARS
043BA0 FD E5       9564  			PUSH    IY			; IY: Address of the variable name in the program
043BA2             9565  ;
043BA2 7E          9566  LOC3:			LD      A,(HL)         		; Compare
043BA3 23          9567  			INC     HL
043BA4 FD 23       9568  			INC     IY
043BA6 FD BE 00    9569  			CP      (IY)
043BA9 28 F7       9570  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043BAB B7          9571  			OR      A               	; Have we hit a terminator?
043BAC 28 07       9572  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BAE             9573  ;
043BAE FD E1       9574  LOC4:			POP     IY			; Restore the pointer in the program
043BB0 EB          9575  			EX      DE, HL			; HL: New pointer in DYNVARS
043BB1 C3 90 3B 04 9576  			JP      LOC2            	; Loop round and try again
043BB5             9577  ;
043BB5             9578  ; We might have located a variable at this point, just need to do a few more tests
043BB5             9579  ;
043BB5 FD 2B       9580  LOC5:			DEC     IY
043BB7 FD 7E 00    9581  			LD      A,(IY)
043BBA FE 28       9582  			CP      '('
043BBC 28 15       9583  			JR      Z,LOC5A         	; FOUND
043BBE FD 23       9584  			INC     IY
043BC0 CD A7 3C 04 9585  			CALL    RANGE
043BC4 38 0D       9586  			JR      C,LOC5A         	; FOUND
043BC6 FE 28       9587  			CP      '('
043BC8 28 E4       9588  			JR      Z,LOC4          	; KEEP LOOKING
043BCA FD 7E FF    9589  			LD      A,(IY-1)
043BCD CD B3 3C 04 9590  			CALL    RANGE1
043BD1 30 DB       9591  			JR      NC,LOC4         	; KEEP LOOKING
043BD3 D1          9592  LOC5A:			POP     DE
043BD4 FD 7E FF    9593  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BD7 FE 24       9594  			CP      '$'			; Is it a string?
043BD9 16 81       9595  			LD      D,129			; Yes, so return D = 129
043BDB C8          9596  			RET     Z
043BDC FE 25       9597  			CP      '%'			; Is it an integer?
043BDE 16 04       9598  			LD      D,4			; Yes, so return D = 4
043BE0 C8          9599  			RET     Z
043BE1 14          9600  			INC     D			; At this point it must be a float
043BE2 BF          9601  			CP      A			; Set the flags
043BE3 C9          9602  			RET
043BE4             9603  ;
043BE4             9604  ; The variable is undefined at this point; HL will be zero
043BE4             9605  ;
043BE4 3C          9606  LOC6:			INC     A               	; Set NZ flag
043BE5 C9          9607  			RET
043BE6             9608  ;
043BE6             9609  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043BE6             9610  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043BE6             9611  ;  Outputs: As LOCATE, GETDEF.
043BE6             9612  ; Destroys: As LOCATE, GETDEF.
043BE6             9613  ;
043BE6 AF          9614  CREATE:			XOR     A
043BE7 ED 5B 1D 4D 9615  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043BEC ED 1F       9616  			LD	(HL), DE		; Store
043BEE EB          9617  			EX      DE,HL
043BEF 77          9618  			LD      (HL),A			; Clear the link of the new entity
043BF0 23          9619  			INC     HL
043BF1 77          9620  			LD      (HL),A
043BF2 23          9621  			INC     HL
043BF3 77          9622  			LD      (HL),A
043BF4 23          9623  			INC     HL
043BF5 FD 23       9624  LOC7:			INC     IY
043BF7 CD A7 3C 04 9625  			CALL    RANGE           	; END OF VARIABLE?
043BFB 38 15       9626  			JR      C,LOC8
043BFD 77          9627  			LD      (HL),A
043BFE 23          9628  			INC     HL
043BFF CD B3 3C 04 9629  			CALL    RANGE1
043C03 30 F0       9630  			JR      NC,LOC7
043C05 FE 28       9631  			CP      '('
043C07 28 09       9632  			JR      Z,LOC8
043C09 FD 7E 01    9633  			LD      A,(IY+1)
043C0C FE 28       9634  			CP      '('
043C0E 28 E5       9635  			JR      Z,LOC7
043C10 FD 23       9636  			INC     IY
043C12 36 00       9637  LOC8:			LD      (HL),0          	; TERMINATOR
043C14 23          9638  			INC     HL
043C15 E5          9639  			PUSH    HL
043C16 CD D4 3B 04 9640  			CALL    TYPE_			; Get the variable type in D
043C1A 3E 04       9641  			LD      A,4			; If it is an integer then it takes up 4 bytes
043C1C BA          9642  			CP      D
043C1D 28 01       9643  			JR      Z,LOC9			; So skip the next bit
043C1F 3C          9644  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C20 36 00       9645  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C22 23          9646  			INC     HL
043C23 3D          9647  			DEC     A
043C24 20 FA       9648  			JR      NZ,LOC9
043C26 22 1D 4D 04 9649  			LD      (FREE),HL		; Adjust the stack
043C2A CD 81 16 04 9650  			CALL    CHECK			; Check whether we are out of space
043C2E E1          9651  			POP     HL
043C2F AF          9652  			XOR     A
043C30 C9          9653  			RET
043C31             9654  ;
043C31             9655  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043C31             9656  ;   Inputs: IY = Text Pointer
043C31             9657  ;  Outputs: HL = Line number (zero if none)
043C31             9658  ;           IY updated
043C31             9659  ; Destroys: A,D,E,H,L,IY,F
043C31             9660  ;
043C31             9661  ; This bit of code performs a BASE 10 shift to build up the number
043C31             9662  ; So if the string passed is "345", the algorithm does this:
043C31             9663  ;
043C31             9664  ;    HL : Digit	: Operation
043C31             9665  ; ----- : ----- : ---------
043C31             9666  ; 00000 :	:
043C31             9667  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043C31             9668  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043C31             9669  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043C31             9670  ;
043C31             9671  ; The multiply by 10 is done by an unrolled shift and add loop
043C31             9672  ;
043C31 CD 78 0A 04 9673  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C35 40 21 00 00 9674  			LD.SIS  HL,0			; The running total
043C39 FD 7E 00    9675  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C3C D6 30       9676  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C3E D8          9677  			RET     C			; And return if less than 0
043C3F FE 0A       9678  			CP      10			; Or greater than or equal to 10
043C41 D0          9679  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C42 FD 23       9680  			INC     IY			; Increment the string pointer
043C44 54          9681  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C45 5D          9682  			LD      E,L			; Store the original number in DE
043C46 52 29       9683  			ADD.S   HL,HL           	; *2
043C48 38 13       9684  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C4A 52 29       9685  			ADD.S   HL,HL           	; *4S
043C4C 38 0F       9686  			JR      C,TOOBIG
043C4E 52 19       9687  			ADD.S   HL,DE           	; *5
043C50 38 0B       9688  			JR      C,TOOBIG
043C52 52 29       9689  			ADD.S   HL,HL           	; *10
043C54 38 07       9690  			JR      C,TOOBIG
043C56 5F          9691  			LD      E,A			; A->DE: the digit to add in
043C57 16 00       9692  			LD      D,0
043C59 52 19       9693  			ADD.S   HL,DE           	; Add in the digit to the running total
043C5B 30 DC       9694  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C5D             9695  ;
043C5D 3E 14       9696  TOOBIG:			LD      A,20
043C5F C3 98 37 04 9697  			JP      ERROR_           	; Error: "Too big"
043C63             9698  ;
043C63             9699  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C63             9700  ;   Inputs: IY = text pointer
043C63             9701  ;  Outputs: HL = first number (10 by default)
043C63             9702  ;           BC = second number (10 by default)
043C63             9703  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C63             9704  ;
043C63 CD 31 3C 04 9705  PAIR:			CALL    LINNUM          	; Parse the first line number
043C67 7C          9706  			LD      A,H			; If it is not zero, then...
043C68 B5          9707  			OR      L
043C69 20 02       9708  			JR      NZ,PAIR1		; Skip...
043C6B 2E 0A       9709  			LD      L,10			; HL: the default value (10)
043C6D             9710  ;
043C6D CD AC 17 04 9711  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C71 FD 23       9712  			INC     IY			; Skip to next character
043C73 E5          9713  			PUSH    HL			; Stack the first line number
043C74 21 0A 00 00 9714  			LD      HL,10			; HL: the second default (10)
043C78 C4 31 3C 04 9715  			CALL    NZ,LINNUM       	; Parse the second line number
043C7C E3          9716  			EX      (SP),HL			; HL: The first line number (off the stack)
043C7D C1          9717  			POP     BC			; BC: Second line number
043C7E 78          9718  			LD      A,B			; If the second line number is not zero then...
043C7F B1          9719  			OR      C			; We're good...
043C80 C0          9720  			RET     NZ			; Exit, otherwise...
043C81 CD AF 37 04 9721  			CALL    EXTERR			; Throw error: "Silly"
043C85 53 69 6C 6C 9722  			DB    	"Silly", 0
       79 00       
043C8B             9723  ;
043C8B             9724  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043C8B             9725  ;   Inputs: IY = text pointer
043C8B             9726  ;  Outputs: HL = points to program text
043C8B             9727  ;           BC = second number (0 by default)
043C8B             9728  ; Destroys: A,B,C,D,E,H,L,IY,F
043C8B             9729  ;
043C8B CD 31 3C 04 9730  DLPAIR:			CALL    LINNUM			; Parse the first line number
043C8F E5          9731  			PUSH    HL			; Stack it
043C90 CD AC 17 04 9732  			CALL    TERMQ			; Check for ELSE, : or CR
043C94 28 0A       9733  			JR      Z,DLP1			; And exit if so
043C96 FE E7       9734  			CP      TIF			; Is the token IF?
043C98 28 06       9735  			JR      Z,DLP1			; Yes, so skip the next bit...
043C9A FD 23       9736  			INC     IY			; Otherwise...
043C9C CD 31 3C 04 9737  			CALL    LINNUM			; Fetch the second line number
043CA0 E3          9738  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043CA1 CD C7 39 04 9739  			CALL    FINDL			; HL: Find the address of the line
043CA5 C1          9740  			POP     BC			; BC: The second number
043CA6 C9          9741  			RET
043CA7             9742  ;
043CA7             9743  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043CA7             9744  ;   Inputs: IY addresses character
043CA7             9745  ;  Outputs: Carry set if out-of-range.
043CA7             9746  ; Destroys: A,F
043CA7             9747  ;
043CA7             9748  ; It is called here to check the following
043CA7             9749  ; In range: "$", "%" and "("
043CA7             9750  ;   Plus all characters in RANGE1 and RANGE2
043CA7             9751  ;
043CA7 FD 7E 00    9752  RANGE:			LD      A,(IY)			; Fetch the character
043CAA FE 24       9753  			CP      '$'			; Postfix for string variable is valid
043CAC C8          9754  			RET     Z
043CAD FE 25       9755  			CP      '%'			; Postfix for integer variable is valid
043CAF C8          9756  			RET     Z
043CB0 FE 28       9757  			CP      '('			; Postfix for array is valid
043CB2 C8          9758  			RET     Z
043CB3             9759  ;
043CB3             9760  ; It is called here to check the following
043CB3             9761  ; In range: "0" to "9" and "@"
043CB3             9762  ;   Plus all characters in RANGE2
043CB3             9763  ;
043CB3 FE 30       9764  RANGE1:			CP      '0'			; If it is between '0'...
043CB5 D8          9765  			RET     C
043CB6 FE 3A       9766  			CP      '9'+1			; And '9'...
043CB8 3F          9767  			CCF
043CB9 D0          9768  			RET     NC			; Then it is valid
043CBA FE 40       9769  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CBC C8          9770  			RET     Z
043CBD             9771  ;
043CBD             9772  ; It is called here to check the following
043CBD             9773  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043CBD             9774  ;
043CBD FE 41       9775  RANGE2:			CP      'A'			; If it is between 'A'...
043CBF D8          9776  			RET     C
043CC0 FE 5B       9777  			CP      'Z'+1			; And 'Z'...
043CC2 3F          9778  			CCF
043CC3 D0          9779  			RET     NC			; Then it is valid
043CC4 FE 5F       9780  			CP      '_'			; If it is underscore, grave, or between 'a'
043CC6 D8          9781  			RET     C
043CC7 FE 7B       9782  			CP      'z'+1			; And 'z'
043CC9 3F          9783  			CCF				; Then it is valid
043CCA C9          9784  			RET
043CCB             9785  ;
043CCB             9786  ; Throw a 'LINE space' error (line too long)
043CCB             9787  ; This is called from LEXAN
043CCB             9788  ;
043CCB AF          9789  SPACE_: 		XOR     A
043CCC CD AF 37 04 9790  			CALL    EXTERR          	; "LINE space"
043CD0 86 08 00    9791  			DB    	LINE_MN_, 8, 0
043CD3             9792  ;
043CD3             9793  ; LEXAN - LEXICAL ANALYSIS.
043CD3             9794  ;  Bit 0,C: 1=left, 0=right
043CD3             9795  ;  Bit 2,C: 1=in BINARY
043CD3             9796  ;  Bit 3,C: 1=in HEX
043CD3             9797  ;  Bit 4,C: 1=accept line number
043CD3             9798  ;  Bit 5,C: 1=in variable, FN, PROC
043CD3             9799  ;  Bit 6,C: 1=in REM, DATA, *
043CD3             9800  ;  Bit 7,C: 1=in quotes
043CD3             9801  ;   Inputs: IY addresses source string
043CD3             9802  ;           DE addresses destination string (must be page boundary)
043CD3             9803  ;            C sets initial mode
043CD3             9804  ;  Outputs: DE, IY updated
043CD3             9805  ;            A holds carriage return
043CD3             9806  ;
043CD3 12          9807  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CD4 13          9808  			INC     DE              	; Increment the pointers
043CD5 FD 23       9809  			INC     IY			; And fall through to the main function
043CD7             9810  ;
043CD7             9811  ; This is the main entry point
043CD7             9812  ;
043CD7 7B          9813  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CD8 FE FC       9814  			CP      252             	; If it is >= 252 bytes, then...
043CDA 30 EF       9815  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CDC FD 7E 00    9816  			LD      A,(IY)			; Fetch character from source string
043CDF FE 0D       9817  			CP      CR			; If it is a CR
043CE1 C8          9818  			RET     Z               	; Then it is end of line; we're done parsing
043CE2 CD B3 3C 04 9819  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CE6 30 06       9820  			JR      NC,LEXAN3		; Yes, so skip
043CE8 CB A9       9821  			RES     5,C             	; FLAG: NOT IN VARIABLE
043CEA CB 99       9822  			RES     3,C             	; FLAG: NOT IN HEX
043CEC CB 91       9823  			RES	2,C			; FLAG: NOT IN BINARY
043CEE             9824  ;
043CEE FE 20       9825  LEXAN3:			CP      ' '			; Ignore spaces
043CF0 28 E1       9826  			JR      Z,LEXAN1
043CF2 FE 2C       9827  			CP      ','			; Ignore commas
043CF4 28 DD       9828  			JR      Z,LEXAN1
043CF6 FE 32       9829  			CP	'2'			; If less than '2'
043CF8 30 02       9830  			JR	NC, @F			; No, so skip
043CFA CB 91       9831  			RES	2,C			; FLAG: NOT IN BINARY
043CFC FE 47       9832  @@:			CP      'G'			; If less then 'G'
043CFE 38 02       9833  			JR      C,LEXAN4		; Yes, so skip
043D00 CB 99       9834  			RES     3,C             	; FLAG: NOT IN HEX
043D02             9835  ;
043D02 FE 22       9836  LEXAN4:			CP      34			; Is it a quote character?
043D04 20 05       9837  			JR      NZ,LEXAN5		; No, so skip
043D06 CB 11       9838  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D08 3F          9839  			CCF                     	; Toggle the carry
043D09 CB 19       9840  			RR      C			; And then shifting it back into bit 7 of C
043D0B             9841  ;
043D0B CB 61       9842  LEXAN5:			BIT     4,C			; Accept line number?
043D0D 28 12       9843  			JR      Z,LEXAN6		; No, so skip
043D0F CB A1       9844  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D11 C5          9845  			PUSH    BC
043D12 D5          9846  			PUSH    DE
043D13 CD 31 3C 04 9847  			CALL    LINNUM         		; Parse the line number to HL
043D17 D1          9848  			POP     DE
043D18 C1          9849  			POP     BC
043D19 7C          9850  			LD      A,H			; If it is not zero
043D1A B5          9851  			OR      L
043D1B C4 94 3D 04 9852  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D1F 18 B6       9853  			JR      LEXAN2          	; And loop
043D21             9854  ;
043D21 0D          9855  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D22 28 0A       9856  			JR      Z,LEXAN7        	; If so, skip
043D24 0C          9857  			INC     C			; Otherwise restore C
043D25 20 AC       9858  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D27 B7          9859  			OR      A			; Set the flags based on the character
043D28 F4 FF 37 04 9860  			CALL    P,LEX           	; Tokenise if A < 128
043D2C 18 13       9861  			JR      LEXAN8			; And skip
043D2E             9862  ;
043D2E             9863  ; Processing the LEFT hand side here
043D2E             9864  ;
043D2E FE 2A       9865  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D30 28 17       9866  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D32 B7          9867  			OR      A			; Set the flags based on the character
043D33 F4 FF 37 04 9868  			CALL    P,LEX           	; Tokenise if A < 128
043D37             9869  ;
043D37             9870  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043D37             9871  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043D37             9872  ; Examples:
043D37             9873  ;   LET A% = PAGE : REM This is the GET version
043D37             9874  ;   PAGE = 40000  : REM This is the SET version
043D37             9875  ;
043D37 FE 8F       9876  			CP      TOKLO			; TOKLO is 8Fh
043D39 38 06       9877  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D3B FE 94       9878  			CP      TOKHI+1			; TOKHI is 93h
043D3D 30 02       9879  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D3F C6 40       9880  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D41             9881  ;
043D41 FE F4       9882  LEXAN8:			CP      REM			; If the token is REM
043D43 28 04       9883  			JR      Z,LEXAN9		; Then stop tokenising
043D45 FE DC       9884  			CP      DATA_MN_			; If it is not DATA then
043D47 20 02       9885  			JR      NZ,LEXANA		; Skip
043D49 CB F1       9886  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D4B             9887  ;
043D4B FE A4       9888  LEXANA:			CP      FN			; If the token is FN
043D4D 28 0A       9889  			JR      Z,LEXANB
043D4F FE F2       9890  			CP      PROC			; Or the token is PROC
043D51 28 06       9891  			JR      Z,LEXANB		; Then jump to here
043D53 CD BD 3C 04 9892  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D57 38 02       9893  			JR      C,LEXANC		; Jump here if out of range
043D59             9894  ;
043D59 CB E9       9895  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D5B FE 26       9896  LEXANC:			CP      '&'			; Check for hex prefix
043D5D 20 02       9897  			JR      NZ,LEXAND		; If not, skip
043D5F CB D9       9898  			SET     3,C             	; FLAG: IN HEX
043D61             9899  ;
043D61 FE 25       9900  LEXAND:			CP	'%'			; Check for binary prefix
043D63 20 02       9901  			JR	NZ,LEXANE		; If not, skip
043D65 CB D1       9902  			SET	2,C			; FLAG: IN BINARY
043D67             9903  ;
043D67 21 8B 3D 04 9904  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D6B C5          9905  			PUSH    BC
043D6C 01 06 00 00 9906  			LD      BC,LIST1L		; The list length
043D70 ED B1       9907  			CPIR				; Check if the token is in this list
043D72 C1          9908  			POP     BC
043D73 20 02       9909  			JR      NZ,LEXANF		; If not, then skip
043D75 CB E1       9910  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D77             9911  ;
043D77 21 8F 3D 04 9912  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D7B C5          9913  			PUSH    BC
043D7C 01 05 00 00 9914  			LD      BC,LIST2L		; The list length
043D80 ED B1       9915  			CPIR				; Check if the token is in this list
043D82 C1          9916  			POP     BC
043D83 20 02       9917  			JR      NZ,LEXANG		; If not, then skip
043D85 CB C1       9918  			SET     0,C             	; FLAG: ENTER LEFT MODE
043D87 C3 D3 3C 04 9919  LEXANG:			JP      LEXAN1			; And loop
043D8B             9920  
043D8B             9921  ;
043D8B             9922  ; LIST1: List of tokens that must be followed by line numbers
043D8B             9923  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043D8B             9924  ;
043D8B E5          9925  LIST1:			DB	GOTO
043D8C E4          9926  			DB	GOSUB
043D8D F7          9927  			DB	RESTOR
043D8E FC          9928  			DB	TRACE
043D8F 8C          9929  LIST2:			DB	THEN_MN_
043D90 8B          9930  			DB	ELSE_MN_
043D91             9931  LIST1L:			EQU     $-LIST1
043D91 F5          9932  			DB	REPEAT
043D92 85          9933  			DB	TERROR_MN
043D93 3A          9934  			DB    	':'
043D94             9935  LIST2L:			EQU     $-LIST2
043D94             9936  ;
043D94             9937  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043D94             9938  ;   Inputs: HL=line number, DE=string pointer
043D94             9939  ;  Outputs: DE updated, BIT 4,C set.
043D94             9940  ; Destroys: A,B,C,D,E,F
043D94             9941  ;
043D94             9942  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043D94             9943  ;
043D94             9944  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043D94             9945  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043D94             9946  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043D94             9947  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043D94             9948  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043D94             9949  ;
043D94 CB E1       9950  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D96 EB          9951  			EX      DE, HL			; HL: string pointer, DE: line number
043D97 36 8D       9952  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D99 23          9953  			INC     HL
043D9A 7A          9954  			LD      A,D			; Get the high byte
043D9B E6 C0       9955  			AND     0C0H			; Get the top two bits	DD000000
043D9D 0F          9956  			RRCA				; Shift right		00DD0000
043D9E 0F          9957  			RRCA
043D9F 47          9958  			LD      B,A			; Store in B
043DA0 7B          9959  			LD      A,E			; Get the low byte
043DA1 E6 C0       9960  			AND     0C0H			; Get the top two bits	EE000000
043DA3 B0          9961  			OR      B			; Combine with D	EEDD0000
043DA4 0F          9962  			RRCA				; Shift right		00EEDD00
043DA5 0F          9963  			RRCA
043DA6 EE 54       9964  			XOR     01010100B		; XOR with 54h
043DA8 77          9965  			LD      (HL),A			; Store this as the second byte
043DA9 23          9966  			INC     HL
043DAA 7B          9967  			LD      A,E			; Get the low byte
043DAB E6 3F       9968  			AND     3FH			; Strip the top two bits off
043DAD F6 40       9969  			OR      '@'			; OR with 40h
043DAF 77          9970  			LD      (HL),A			; Store
043DB0 23          9971  			INC     HL
043DB1 7A          9972  			LD      A,D			; Get the high byte
043DB2 E6 3F       9973  			AND     3FH			; Strip the top two bits off
043DB4 F6 40       9974  			OR      '@'			; OR with 40h
043DB6 77          9975  			LD      (HL),A			; Store
043DB7 23          9976  			INC     HL
043DB8 EB          9977  			EX      DE,HL			; DE: string pointer, HL: line number
043DB9 C9          9978  			RET
043DBA             9979  ;
043DBA             9980  ; TEXT - OUTPUT MESSAGE.
043DBA             9981  ;   Inputs: HL addresses text (terminated by nul)
043DBA             9982  ;  Outputs: HL addresses character following nul.
043DBA             9983  ; Destroys: A,H,L,F
043DBA             9984  ;
043DBA 2A 2F 4D 04 9985  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DBE             9986  ;
043DBE 7E          9987  TEXT_:			LD      A, (HL)			; Fetch the character
043DBF 23          9988  			INC     HL			; Increment pointer to next character
043DC0 B7          9989  			OR      A			; Check for the nul (0) string terminator
043DC1 C8          9990  			RET     Z			; And return if so
043DC2 CD A4 39 04 9991  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DC6 18 F6       9992  			JR      TEXT_			; And loop
043DC8             9993  ;
043DC8             9994  ; TELL - OUTPUT MESSAGE.
043DC8             9995  ;   Inputs: Text follows subroutine call (term=nul)
043DC8             9996  ; Destroys: A,F
043DC8             9997  ;
043DC8             9998  ; Example usage:
043DC8             9999  ;
043DC8             10000  ;	CALL	TELL			Call the function
043DC8             10001  ;	DB	"Hello World", 0	Followed by a zero terminated string
043DC8             10002  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043DC8             10003  ;
043DC8 E3          10004  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DC9 CD BE 3D 04 10005  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DCD E3          10006  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DCE C9          10007  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043DCF             10008  
043DCF             10009  ; --- Begin misc.asm ---
043DCF             10010  ;
043DCF             10011  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043DCF             10012  ; Author:	Dean Belfield
043DCF             10013  ; Created:	12/05/2023
043DCF             10014  ; Last Updated:	12/05/2023
043DCF             10015  ;
043DCF             10016  ; Modinfo:
043DCF             10017  
043DCF             10018  			; INCLUDE	"equs.inc"
043DCF             10019  			; INCLUDE	"macros.inc"
043DCF             10020  
043DCF             10021  			; .ASSUME	ADL = 1
043DCF             10022  
043DCF             10023  			; SEGMENT CODE
043DCF             10024  
043DCF             10025  			; XDEF	ASC_TO_NUMBER
043DCF             10026  			; XDEF	SWITCH_A
043DCF             10027  			; XDEF	NULLTOCR
043DCF             10028  			; XDEF	CRTONULL
043DCF             10029  			; XDEF	CSTR_FNAME
043DCF             10030  			; XDEF	CSTR_LINE
043DCF             10031  			; XDEF	CSTR_FINDCH
043DCF             10032  			; XDEF	CSTR_ENDSWITH
043DCF             10033  			; XDEF	CSTR_CAT
043DCF             10034  
043DCF             10035  			; XREF	OSWRCH
043DCF             10036  			; XREF	KEYWDS
043DCF             10037  			; XREF	KEYWDL
043DCF             10038  
043DCF             10039  ; Read a number and convert to binary
043DCF             10040  ; If prefixed with &, will read as hex, otherwise decimal
043DCF             10041  ;   Inputs: HL: Pointer in string buffer
043DCF             10042  ;  Outputs: HL: Updated text pointer
043DCF             10043  ;           DE: Value
043DCF             10044  ;            A: Terminator (spaces skipped)
043DCF             10045  ; Destroys: A,D,E,H,L,F
043DCF             10046  ;
043DCF C5          10047  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DD0 11 00 00 00 10048  			LD	DE, 0			; Initialise DE
043DD4 CD 16 3E 04 10049  			CALL	SKIPSPC			; Skip whitespace
043DD8 7E          10050  			LD	A, (HL)			; Read first character
043DD9 FE 26       10051  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DDB 20 1F       10052  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DDD 23          10053  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DDE             10054  ;
043DDE 7E          10055  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DDF CD 24 3E 04 10056  			CALL    UPPERC			; Convert to uppercase
043DE3 D6 30       10057  			SUB	'0'			; Normalise to 0
043DE5 38 2E       10058  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DE7 FE 0A       10059  			CP 	10			; Check if >= 10
043DE9 38 06       10060  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DEB D6 07       10061  			SUB 	7			; Adjust ASCII A-F to nibble
043DED FE 10       10062  			CP 	16			; Check for > F
043DEF 30 24       10063  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DF1 EB          10064  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DF2 29          10065  			ADD	HL, HL
043DF3 29          10066  			ADD	HL, HL
043DF4 29          10067  			ADD	HL, HL
043DF5 29          10068  			ADD	HL, HL
043DF6 EB          10069  			EX	DE, HL
043DF7 B3          10070  			OR      E			; OR the new digit in to the least significant nibble
043DF8 5F          10071  			LD      E, A
043DF9 23          10072  			INC     HL			; Onto the next character
043DFA 18 E2       10073  			JR      ASC_TO_NUMBER1		; And loop
043DFC             10074  ;
043DFC 7E          10075  ASC_TO_NUMBER3:		LD	A, (HL)
043DFD D6 30       10076  			SUB	'0'			; Normalise to 0
043DFF 38 14       10077  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E01 FE 0A       10078  			CP	10			; Check if >= 10
043E03 30 10       10079  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043E05 EB          10080  			EX 	DE, HL 			; Stick DE in HL
043E06 44          10081  			LD	B, H 			; And copy HL into BC
043E07 4D          10082  			LD	C, L
043E08 29          10083  			ADD	HL, HL 			; x 2
043E09 29          10084  			ADD	HL, HL 			; x 4
043E0A 09          10085  			ADD	HL, BC 			; x 5
043E0B 29          10086  			ADD	HL, HL 			; x 10
043E0C EB          10087  			EX	DE, HL
043E0D             10088  			ADD8U_DE 			; Add A to DE (macro)
043E0D 83          0001M 		ADD	A, E
043E0E 5F          0002M 		LD	E, A
043E0F 8A          0003M 		ADC	A, D
043E10 93          0004M 		SUB	E
043E11 57          0005M 		LD	D, A
043E12 23          10089  			INC	HL
043E13 18 E7       10090  			JR	ASC_TO_NUMBER3
043E15 C1          10091  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043E16             10092  
043E16             10093  ; Skip a space
043E16             10094  ; HL: Pointer in string buffer
043E16             10095  ;
043E16 7E          10096  SKIPSPC:			LD      A, (HL)
043E17 FE 20       10097  			CP      ' '
043E19 C0          10098  			RET     NZ
043E1A 23          10099  			INC     HL
043E1B 18 F9       10100  			JR      SKIPSPC
043E1D             10101  
043E1D             10102  ; Skip a string
043E1D             10103  ; HL: Pointer in string buffer
043E1D             10104  ;
043E1D 7E          10105  SKIPNOTSP:		LD	A, (HL)
043E1E FE 20       10106  			CP	' '
043E20 C8          10107  			RET	Z
043E21 23          10108  			INC	HL
043E22 18 F9       10109  			JR	SKIPNOTSP
043E24             10110  
043E24             10111  ; Convert a character to upper case
043E24             10112  ;  A: Character to convert
043E24             10113  ;
043E24 E6 7F       10114  UPPERC:  		AND     7FH
043E26 FE 60       10115  			CP      '`'
043E28 D8          10116  			RET     C
043E29 E6 5F       10117  			AND     5FH			; Convert to upper case
043E2B C9          10118  			RET
043E2C             10119  
043E2C             10120  ; Switch on A - lookup table immediately after call
043E2C             10121  ;  A: Index into lookup table
043E2C             10122  ;
043E2C E3          10123  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E2D 87          10124  			ADD	A, A			; Multiply A by two
043E2E             10125  			ADD8U_HL 			; Add to HL (macro)
043E2E 85          0001M 		ADD	A, L
043E2F 6F          0002M 		LD	L, A
043E30 8C          0003M 		ADC	A, H
043E31 95          0004M 		SUB	L
043E32 67          0005M 		LD	H, A
043E33 7E          10126  			LD	A, (HL)			; follow the call. Fetch an address from the
043E34 23          10127  			INC	HL 			; table.
043E35 66          10128  			LD	H, (HL)
043E36 6F          10129  			LD	L, A
043E37 E3          10130  			EX	(SP), HL		; Swap this new address back, restores HL
043E38 C9          10131  			RET				; Return program control to this new address
043E39             10132  
043E39             10133  ; Convert the buffer to a null terminated string and back
043E39             10134  ; HL: Buffer address
043E39             10135  ;
043E39 C5          10136  NULLTOCR:		PUSH 	BC
043E3A 06 00       10137  			LD	B, 0
043E3C 0E 0D       10138  			LD	C, CR
043E3E 18 05       10139  			JR	CRTONULL0
043E40             10140  ;
043E40 C5          10141  CRTONULL:		PUSH	BC
043E41 06 0D       10142  			LD	B, CR
043E43 0E 00       10143  			LD	C, 0
043E45             10144  ;
043E45 E5          10145  CRTONULL0:		PUSH	HL
043E46 7E          10146  CRTONULL1:		LD	A, (HL)
043E47 B8          10147  			CP 	B
043E48 28 03       10148  			JR	Z, CRTONULL2
043E4A 23          10149  			INC	HL
043E4B 18 F9       10150  			JR	CRTONULL1
043E4D 71          10151  CRTONULL2:		LD	(HL), C
043E4E E1          10152  			POP 	HL
043E4F C1          10153  			POP	BC
043E50 C9          10154  			RET
043E51             10155  
043E51             10156  ; Copy a filename to DE and zero terminate it
043E51             10157  ; HL: Source
043E51             10158  ; DE: Destination (ACCS)
043E51             10159  ;
043E51 7E          10160  CSTR_FNAME:		LD	A, (HL)			; Get source
043E52 FE 20       10161  			CP	32			; Is it space
043E54 28 09       10162  			JR	Z, @F
043E56 FE 0D       10163  			CP	CR			; Or is it CR
043E58 28 05       10164  			JR	Z, @F
043E5A 12          10165  			LD	(DE), A			; No, so store
043E5B 23          10166  			INC	HL			; Increment
043E5C 13          10167  			INC	DE
043E5D 18 F2       10168  			JR	CSTR_FNAME		; And loop
043E5F AF          10169  @@:			XOR	A			; Zero terminate the target string
043E60 12          10170  			LD	(DE), A
043E61 13          10171  			INC	DE			; And point to next free address
043E62 C9          10172  			RET
043E63             10173  
043E63             10174  ; Copy a CR terminated line to DE and zero terminate it
043E63             10175  ; HL: Source
043E63             10176  ; DE: Destination (ACCS)
043E63             10177  ;
043E63 7E          10178  CSTR_LINE:		LD	A, (HL)			; Get source
043E64 FE 0D       10179  			CP	CR			; Is it CR
043E66 28 05       10180  			JR	Z, @F
043E68 12          10181  			LD	(DE), A			; No, so store
043E69 23          10182  			INC	HL			; Increment
043E6A 13          10183  			INC	DE
043E6B 18 F6       10184  			JR	CSTR_LINE		; And loop
043E6D AF          10185  @@:			XOR	A			; Zero terminate the target string
043E6E 12          10186  			LD	(DE), A
043E6F 13          10187  			INC	DE			; And point to next free address
043E70 C9          10188  			RET
043E71             10189  
043E71             10190  ; Find the first occurrence of a character (case sensitive)
043E71             10191  ; HL: Source
043E71             10192  ;  C: Character to find
043E71             10193  ; Returns:
043E71             10194  ; HL: Pointer to character, or end of string marker
043E71             10195  ;
043E71 7E          10196  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E72 B9          10197  			CP	C			; Is it our character?
043E73 C8          10198  			RET	Z			; Yes, so exit
043E74 B7          10199  			OR	A			; Is it the end of string?
043E75 C8          10200  			RET	Z			; Yes, so exit
043E76 23          10201  			INC	HL
043E77 18 F8       10202  			JR	CSTR_FINDCH
043E79             10203  
043E79             10204  ; Check whether a string ends with another string (case insensitive)
043E79             10205  ; HL: Source
043E79             10206  ; DE: The substring we want to test with
043E79             10207  ; Returns:
043E79             10208  ;  F: Z if HL ends with DE, otherwise NZ
043E79             10209  ;
043E79 7E          10210  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E7A CD 24 3E 04 10211  			CALL	UPPERC			; Convert to upper case
043E7E 4F          10212  			LD	C, A
043E7F 1A          10213  			LD	A, (DE)			; Get the substring byte
043E80 B9          10214  			CP	C
043E81 C0          10215  			RET	NZ			; Return NZ if at any point the strings don't match
043E82 B1          10216  			OR	C			; Check whether both bytes are zero
043E83 C8          10217  			RET	Z			; If so, return, as we have reached the end of both strings
043E84 23          10218  			INC	HL
043E85 13          10219  			INC	DE
043E86 18 F1       10220  			JR	CSTR_ENDSWITH		; And loop
043E88             10221  
043E88             10222  ; Concatenate a string onto the end of another string
043E88             10223  ; HL: Source
043E88             10224  ; DE: Second string
043E88             10225  ;
043E88 7E          10226  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E89 B7          10227  			OR	A
043E8A 28 03       10228  			JR	Z, CSTR_CAT_1
043E8C 23          10229  			INC	HL
043E8D 18 F9       10230  			JR	CSTR_CAT
043E8F             10231  ;
043E8F 1A          10232  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E90 77          10233  			LD	(HL), A
043E91 B7          10234  			OR	A			; Check for end of string
043E92 C8          10235  			RET	Z			; And return
043E93 23          10236  			INC	HL
043E94 13          10237  			INC	DE
043E95 18 F8       10238  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E97             10239  
043E97             10240  ; --- Begin patch.asm ---
043E97             10241  ;
043E97             10242  ; Title:	BBC Basic for AGON
043E97             10243  ; Author:	Dean Belfield
043E97             10244  ; Created:	12/05/2023
043E97             10245  ; Last Updated:	15/11/2023
043E97             10246  ;
043E97             10247  ; Modinfo:
043E97             10248  ; 11/07/2023:	Fixed *BYE for ADL mode
043E97             10249  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043E97             10250  
043E97             10251  			; .ASSUME	ADL = 1
043E97             10252  
043E97             10253  			; INCLUDE	"equs.inc"
043E97             10254  			; INCLUDE "macros.inc"
043E97             10255  			; INCLUDE "mos_api.inc"	; In MOS/src
043E97             10256  
043E97             10257  			; SEGMENT CODE
043E97             10258  
043E97             10259  			; XDEF	OSWRCH
043E97             10260  			; XDEF	OSLINE
043E97             10261  			; XDEF	ESCSET
043E97             10262  			; XDEF	PUTIME
043E97             10263  			; XDEF	GETIME
043E97             10264  			; XDEF	PUTCSR
043E97             10265  			; XDEF 	GETCSR
043E97             10266  			; XDEF	OSRDCH
043E97             10267  			; XDEF	PROMPT
043E97             10268  			; XDEF	OSKEY
043E97             10269  			; XDEF	TRAP
043E97             10270  			; XDEF	LTRAP
043E97             10271  			; XDEF	OSINIT
043E97             10272  			; XDEF	OSCLI
043E97             10273  			; XDEF	OSBPUT
043E97             10274  			; XDEF	OSBGET
043E97             10275  			; XDEF	OSSTAT
043E97             10276  			; XDEF	OSSHUT
043E97             10277  			; XDEF	OSOPEN
043E97             10278  			; XDEF	OSCALL
043E97             10279  			; XDEF	GETPTR
043E97             10280  			; XDEF	PUTPTR
043E97             10281  			; XDEF	GETEXT
043E97             10282  			; XDEF	GETIMS
043E97             10283  			; XDEF	RESET
043E97             10284  			; XDEF	OSLOAD
043E97             10285  			; XDEF	OSSAVE
043E97             10286  			; XDEF	EXPR_W2
043E97             10287  			; XDEF	STAR_VERSION
043E97             10288  
043E97             10289  			; XREF	_end			; In init.asm
043E97             10290  
043E97             10291  			; XREF	ASC_TO_NUMBER
043E97             10292  			; XREF	RAM_START
043E97             10293  			; XREF	RAM_END
043E97             10294  			; XREF	FLAGS
043E97             10295  			; XREF	ESCAPE
043E97             10296  			; XREF	USER
043E97             10297  			; XREF	RAM_Top
043E97             10298  			; XREF	EXTERR
043E97             10299  			; XREF	COUNT0
043E97             10300  			; XREF	EXPRI
043E97             10301  			; XREF	COMMA
043E97             10302  			; XREF	XEQ
043E97             10303  			; XREF	NXT
043E97             10304  			; XREF	NULLTOCR
043E97             10305  			; XREF	CRLF
043E97             10306  			; XREF	CSTR_FNAME
043E97             10307  			; XREF	CSTR_LINE
043E97             10308  			; XREF	CSTR_FINDCH
043E97             10309  			; XREF	CSTR_ENDSWITH
043E97             10310  			; XREF	CSTR_CAT
043E97             10311  			; XREF	FINDL
043E97             10312  			; XREF	OUT_
043E97             10313  			; XREF	ERROR_
043E97             10314  			; XREF	ONEDIT
043E97             10315  			; XREF	TELL
043E97             10316  			; XREF	OSWRCHPT
043E97             10317  			; XREF	OSWRCHCH
043E97             10318  			; XREF	OSWRCHFH
043E97             10319  			; XREF	LISTON
043E97             10320  			; XREF	LISTIT
043E97             10321  			; XREF	PAGE_
043E97             10322  			; XREF	ONEDIT1
043E97             10323  			; XREF	CLEAN
043E97             10324  			; XREF	NEWIT
043E97             10325  			; XREF	BAD
043E97             10326  			; XREF	VBLANK_INIT
043E97             10327  			; XREF	VBLANK_STOP
043E97             10328  			; XREF	KEYDOWN
043E97             10329  			; XREF	KEYASCII
043E97             10330  			; XREF	WIDTH
043E97             10331  			; XREF	ASSEM
043E97             10332  
043E97             10333  ; OSLINE: Invoke the line editor
043E97             10334  ;
043E97 1E 01       10335  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E99             10336  
043E99             10337  ; Entry point to line editor that does not clear the buffer
043E99             10338  ;
043E99 FD E5       10339  OSLINE1:		PUSH	IY
043E9B E5          10340  			PUSH	HL			; Buffer address
043E9C 01 00 01 00 10341  			LD	BC, 256			; Buffer length
043EA0             10342  			MOSCALL	mos_editline		; Call the MOS line editor
043EA0 3E 09       0001M 			LD	A, function
043EA2 49 CF       0002M 			RST.LIS	08h
043EA4 E1          10343  			POP	HL			; Pop the address
043EA5 FD E1       10344  			POP	IY
043EA7 F5          10345  			PUSH	AF			; Stack the return value (key pressed)
043EA8 CD 39 3E 04 10346  			CALL	NULLTOCR		; Turn the 0 character to a CR
043EAC CD 7F 39 04 10347  			CALL	CRLF			; Display CRLF
043EB0 F1          10348  			POP	AF
043EB1 FE 1B       10349  			CP	1Bh 			; Check if ESC terminated the input
043EB3 CA AF 3F 04 10350  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043EB7 3A 42 4D 04 10351  			LD	A, (FLAGS)		; Otherwise
043EBB CB BF       10352  			RES	7, A 			; Clear the escape flag
043EBD 32 42 4D 04 10353  			LD	(FLAGS), A
043EC1 CD 86 41 04 10354  			CALL	WAIT_VBLANK 		; Wait a frame
043EC5 AF          10355   			XOR	A			; Return A = 0
043EC6 32 47 4D 04 10356  			LD	(KEYDOWN), A
043ECA 32 48 4D 04 10357  			LD	(KEYASCII), A
043ECE C9          10358  			RET
043ECF             10359  
043ECF             10360  ; PUTIME: set current time to DE:HL, in centiseconds.
043ECF             10361  ;
043ECF DD E5       10362  PUTIME:			PUSH 	IX
043ED1             10363  			MOSCALL	mos_sysvars
043ED1 3E 08       0001M 			LD	A, function
043ED3 49 CF       0002M 			RST.LIS	08h
043ED5 DD 75 00    10364  			LD	(IX + sysvar_time + 0), L
043ED8 DD 74 01    10365  			LD	(IX + sysvar_time + 1), H
043EDB DD 73 02    10366  			LD	(IX + sysvar_time + 2), E
043EDE DD 72 03    10367  			LD	(IX + sysvar_time + 3), D
043EE1 DD E1       10368  			POP	IX
043EE3 C9          10369  			RET
043EE4             10370  
043EE4             10371  ; GETIME: return current time in DE:HL, in centiseconds
043EE4             10372  ;
043EE4 DD E5       10373  GETIME:			PUSH 	IX
043EE6             10374  			MOSCALL	mos_sysvars
043EE6 3E 08       0001M 			LD	A, function
043EE8 49 CF       0002M 			RST.LIS	08h
043EEA DD 6E 00    10375  			LD	L, (IX + sysvar_time + 0)
043EED DD 66 01    10376  			LD	H, (IX + sysvar_time + 1)
043EF0 DD 5E 02    10377  			LD	E, (IX + sysvar_time + 2)
043EF3 DD 56 03    10378  			LD	D, (IX + sysvar_time + 3)
043EF6 DD E1       10379  			POP	IX
043EF8 C9          10380  			RET
043EF9             10381  
043EF9             10382  ; PUTCSR: move to cursor to x=DE, y=HL
043EF9             10383  ;
043EF9 3E 1F       10384  PUTCSR:			LD	A, 1Fh			; TAB
043EFB 5B D7       10385  			RST.LIL	10h
043EFD 7B          10386  			LD	A, E			; X
043EFE 5B D7       10387  			RST.LIL 10h
043F00 7D          10388  			LD	A, L			; Y
043F01 5B D7       10389  			RST.LIL 10h
043F03 C9          10390  			RET
043F04             10391  
043F04             10392  ; GETCSR: return cursor position in x=DE, y=HL
043F04             10393  ;
043F04 DD E5       10394  GETCSR:			PUSH	IX			; Get the system vars in IX
043F06             10395  			MOSCALL	mos_sysvars		; Reset the semaphore
043F06 3E 08       0001M 			LD	A, function
043F08 49 CF       0002M 			RST.LIS	08h
043F0A DD CB 04 86 10396  			RES	0, (IX+sysvar_vpd_pflags)
043F0E             10397  			VDU	23
043F0E 3E 17       0001M 		LD	A, val
043F10 CD 38 3F 04 0002M 		CALL	OSWRCH
043F14             10398  			VDU	0
043F14 3E 00       0001M 		LD	A, val
043F16 CD 38 3F 04 0002M 		CALL	OSWRCH
043F1A             10399  			VDU	vdp_cursor
043F1A 3E 82       0001M 		LD	A, val
043F1C CD 38 3F 04 0002M 		CALL	OSWRCH
043F20 DD CB 04 46 10400  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F24 28 FA       10401  			JR	Z, @B			; Wait for the result
043F26 16 00       10402  			LD 	D, 0
043F28 62          10403  			LD	H, D
043F29 DD 5E 07    10404  			LD	E, (IX + sysvar_cursorX)
043F2C DD 6E 08    10405  			LD	L, (IX + sysvar_cursorY)
043F2F DD E1       10406  			POP	IX
043F31 C9          10407  			RET
043F32             10408  
043F32             10409  ; PROMPT: output the input prompt
043F32             10410  ;
043F32 3E 3E       10411  PROMPT: 		LD	A,'>'
043F34 C3 38 3F 04 10412  			JP	OSWRCH
043F38             10413  
043F38             10414  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F38             10415  ; A: Character to write
043F38             10416  ;
043F38 E5          10417  OSWRCH:			PUSH	HL
043F39 21 40 4D 04 10418  			LD	HL, LISTON		; Fetch the LISTON variable
043F3D CB 5E       10419  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F3F 20 0B       10420  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F41             10421  ;
043F41 2A 45 4D 04 10422  			LD	HL, (OSWRCHCH)		; L: Channel #
043F45 2D          10423  			DEC	L			; If it is 1
043F46 28 10       10424  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F48             10425  ;
043F48 E1          10426  			POP	HL			; Otherwise
043F49 5B D7       10427  			RST.LIL	10h			; Output the character to MOS
043F4B C9          10428  			RET
043F4C             10429  ;
043F4C 2A 43 4D 04 10430  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F50 77          10431  			LD	(HL), A			; Echo the character into the buffer
043F51 23          10432  			INC	HL			; Increment pointer
043F52 22 43 4D 04 10433  			LD	(OSWRCHPT), HL		; Write pointer back
043F56 E1          10434  			POP	HL
043F57 C9          10435  			RET
043F58             10436  ;
043F58 D5          10437  OSWRCH_FILE:		PUSH	DE
043F59 5C          10438  			LD	E, H			; Filehandle to E
043F5A CD 84 43 04 10439  			CALL	OSBPUT			; Write the byte out
043F5E D1          10440  			POP	DE
043F5F E1          10441  			POP	HL
043F60 C9          10442  			RET
043F61             10443  
043F61             10444  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F61             10445  ; This is only called in GETS (eval.asm)
043F61             10446  ;
043F61             10447  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F61 3E 00       0001M 			LD	A, function
043F63 49 CF       0002M 			RST.LIS	08h
043F65 FE 1B       10448  			CP	1Bh
043F67 28 46       10449  			JR	Z, LTRAP1
043F69 C9          10450  			RET
043F6A             10451  
043F6A             10452  
043F6A             10453  ;OSKEY - Read key with time-limit, test for ESCape.
043F6A             10454  ;Main function is carried out in user patch.
043F6A             10455  ;   Inputs: HL = time limit (centiseconds)
043F6A             10456  ;  Outputs: Carry reset if time-out
043F6A             10457  ;           If carry set A = character
043F6A             10458  ; Destroys: A,H,L,F
043F6A             10459  ;
043F6A CD 9B 3F 04 10460  OSKEY:			CALL	READKEY			; Read the keyboard
043F6E 28 0A       10461  			JR	Z, @F 			; Skip if we have a key
043F70 7C          10462  			LD	A, H 			; Check loop counter
043F71 B5          10463  			OR 	L
043F72 C8          10464  			RET 	Z 			; Return, we've not got a key at this point
043F73 CD 86 41 04 10465  			CALL	WAIT_VBLANK 		; Wait a frame
043F77 2B          10466  			DEC 	HL			; Decrement
043F78 18 F0       10467  			JR	OSKEY 			; And loop
043F7A             10468  ;
043F7A 21 47 4D 04 10469  @@:			LD	HL, KEYDOWN		; We have a key, so
043F7E 36 00       10470  			LD	(HL), 0			; clear the keydown flag
043F80 FE 1B       10471  			CP	1BH			; If we are not pressing ESC,
043F82 37          10472  			SCF 				; then flag we've got a character
043F83 C0          10473  			RET	NZ
043F84             10474  ;
043F84             10475  ; ESCSET
043F84             10476  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043F84             10477  ;
043F84 E5          10478  ESCSET: 		PUSH    HL
043F85 21 42 4D 04 10479          		LD      HL,FLAGS		; Pointer to FLAGS
043F89 CB 76       10480          		BIT     6,(HL)			; If bit 6 is set, then
043F8B 20 02       10481          		JR      NZ,ESCDIS		; escape is disabled, so skip
043F8D CB FE       10482          		SET     7,(HL)			; Set bit 7, the escape flag
043F8F E1          10483  ESCDIS: 		POP     HL
043F90 C9          10484          		RET
043F91             10485  ;
043F91             10486  ; ESCTEST
043F91             10487  ; Test for ESC key
043F91             10488  ;
043F91 CD 9B 3F 04 10489  ESCTEST:		CALL	READKEY			; Read the keyboard
043F95 C0          10490  			RET	NZ			; Skip if no key is pressed
043F96 FE 1B       10491  			CP	1BH			; If ESC pressed then
043F98 28 EA       10492  			JR	Z,ESCSET		; jump to the escape set routine
043F9A C9          10493  			RET
043F9B             10494  
043F9B             10495  ; Read the keyboard
043F9B             10496  ; Returns:
043F9B             10497  ; - A: ASCII of the pressed key
043F9B             10498  ; - F: Z if the key is pressed, otherwise NZ
043F9B             10499  ;
043F9B 3A 47 4D 04 10500  READKEY:		LD	A, (KEYDOWN)		; Get key down
043F9F 3D          10501  			DEC	A 			; Set Z flag if keydown is 1
043FA0 3A 48 4D 04 10502  			LD	A, (KEYASCII)		; Get key ASCII value
043FA4 C9          10503  			RET
043FA5             10504  ;
043FA5             10505  ; TRAP
043FA5             10506  ; This is called whenever BASIC needs to check for ESC
043FA5             10507  ;
043FA5 CD 91 3F 04 10508  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FA9             10509  ;
043FA9 3A 42 4D 04 10510  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FAD B7          10511  			OR	A			; This checks for bit 7; if it is not set then the result will
043FAE F0          10512  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FAF 21 42 4D 04 10513  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FB3 CB BE       10514  			RES	7,(HL)			; Clear the escape pressed flag and
043FB5 C3 A3 0C 04 10515  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FB9             10516  
043FB9             10517  ;OSINIT - Initialise RAM mapping etc.
043FB9             10518  ;If BASIC is entered by BBCBASIC FILENAME then file
043FB9             10519  ;FILENAME.BBC is automatically CHAINed.
043FB9             10520  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043FB9             10521  ;            HL = initial value of PAGE (user program)
043FB9             10522  ;            Z-flag reset indicates AUTO-RUN.
043FB9             10523  ;  Destroys: A,D,E,H,L,F
043FB9             10524  ;
043FB9 CD 1E 49 04 10525  OSINIT:			CALL	VBLANK_INIT
043FBD AF          10526  			XOR	A
043FBE 21 00 4E 04 10527  			LD 	HL, USER
043FC2 11 00 00 0B 10528  			LD	DE, RAM_Top
043FC6 5F          10529  			LD	E, A			; Page boundary
043FC7 C9          10530  			RET
043FC8             10531  
043FC8             10532  ;
043FC8             10533  ;OSCLI - Process a MOS command
043FC8             10534  ;
043FC8 CD 3C 40 04 10535  OSCLI: 			CALL    SKIPSP
043FCC FE 0D       10536  			CP      CR
043FCE C8          10537  			RET     Z
043FCF FE 7C       10538  			CP      '|'
043FD1 C8          10539  			RET     Z
043FD2 EB          10540  			EX      DE,HL
043FD3 21 4B 40 04 10541  			LD      HL,COMDS
043FD7 1A          10542  OSCLI0:			LD      A,(DE)
043FD8 CD 43 40 04 10543  			CALL    UPPRC
043FDC BE          10544  			CP      (HL)
043FDD 28 0B       10545  			JR      Z,OSCLI2
043FDF 38 30       10546  			JR      C,OSCLI6
043FE1 CB 7E       10547  OSCLI1:			BIT     7,(HL)
043FE3 23          10548  			INC     HL
043FE4 28 FB       10549  			JR      Z,OSCLI1
043FE6 23          10550  			INC     HL
043FE7 23          10551  			INC     HL
043FE8 18 ED       10552  			JR      OSCLI0
043FEA             10553  ;
043FEA D5          10554  OSCLI2:			PUSH    DE
043FEB 13          10555  OSCLI3:			INC     DE
043FEC 23          10556  			INC     HL
043FED 1A          10557  			LD      A,(DE)
043FEE CD 43 40 04 10558  			CALL    UPPRC
043FF2 FE 2E       10559  			CP      '.'			; ABBREVIATED?
043FF4 28 0A       10560  			JR      Z,OSCLI4
043FF6 AE          10561  			XOR     (HL)
043FF7 28 F2       10562  			JR      Z,OSCLI3
043FF9 FE 80       10563  			CP      80H
043FFB 28 03       10564  			JR      Z,OSCLI4
043FFD D1          10565  			POP     DE
043FFE 18 E1       10566  			JR      OSCLI1
044000             10567  ;
044000 F1          10568  OSCLI4:			POP     AF
044001 13          10569  		        INC     DE
044002 CB 7E       10570  OSCLI5:			BIT     7,(HL)
044004 23          10571  			INC     HL
044005 28 FB       10572  			JR      Z,OSCLI5
044007 7E          10573  			LD      A,(HL)
044008 23          10574  			INC     HL
044009 66          10575  			LD      H,(HL)
04400A 6F          10576  			LD      L,A
04400B E5          10577  			PUSH    HL
04400C EB          10578  			EX      DE,HL
04400D C3 3C 40 04 10579  			JP      SKIPSP
044011             10580  ;
044011 EB          10581  OSCLI6:			EX	DE, HL			; HL: Buffer for command
044012 11 00 4A 04 10582  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
044016 D5          10583  			PUSH	DE			; Store buffer address
044017 CD 63 3E 04 10584  			CALL	CSTR_LINE		; Fetch the line
04401B E1          10585  			POP	HL			; HL: Pointer to command string in ACCS
04401C FD E5       10586  			PUSH	IY
04401E             10587  			MOSCALL	mos_oscli		; Returns OSCLI error in A
04401E 3E 10       0001M 			LD	A, function
044020 49 CF       0002M 			RST.LIS	08h
044022 FD E1       10588  			POP	IY
044024 B7          10589  			OR	A			; 0 means MOS returned OK
044025 C8          10590  			RET	Z			; So don't do anything
044026 C3 60 42 04 10591  			JP 	OSERROR			; Otherwise it's a MOS error
04402A             10592  
04402A 3E FE       10593  HUH:    		LD      A,254			; Bad command error
04402C CD AF 37 04 10594          		CALL    EXTERR
044030 42 61 64 20 10595          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
04403B 00          10596          		DEFB    0
04403C             10597  
04403C 7E          10598  SKIPSP:			LD      A,(HL)
04403D FE 20       10599          		CP      ' '
04403F C0          10600          		RET     NZ
044040 23          10601          		INC     HL
044041 18 F9       10602          		JR      SKIPSP
044043             10603  
044043 E6 7F       10604  UPPRC:  		AND     7FH
044045 FE 60       10605  			CP      '`'
044047 D8          10606  			RET     C
044048 E6 5F       10607  			AND     5FH			; CONVERT TO UPPER CASE
04404A C9          10608  			RET
04404B             10609  
04404B             10610  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
04404B             10611  ; These must be in alphabetical order
04404B             10612  ;
04404B 41 53 4D    10613  COMDS:  		DB	"AS","M"+80h		; ASM
04404E 69 40       10614  			DW	STAR_ASM
044050 42 59 45    10615  			DB	"BY","E"+80h		; BYE
044053 75 40       10616  			DW	STAR_BYE
044055 45 44 49 54 10617  			DB	"EDI","T"+80h		; EDIT
044059 AA 40       10618  			DW	STAR_EDIT
04405B 46 58       10619  			DB	"F","X"+80h		; FX
04405D EA 40       10620  			DW	STAR_FX
04405F 56 45 52 53 10621  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
044066 81 40       10622  			DW	STAR_VERSION
044068 FF          10623  			DB	FFh
044069             10624  
044069             10625  ; *ASM string
044069             10626  ;
044069 FD E5       10627  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
04406B E5          10628  			PUSH	HL			; HL = IY
04406C FD E1       10629  			POP	IY
04406E CD CD 18 04 10630  			CALL	ASSEM			; Invoke the assembler
044072 FD E1       10631  			POP	IY
044074 C9          10632  			RET
044075             10633  
044075             10634  ; *BYE
044075             10635  ;
044075 CD 32 49 04 10636  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044079 21 00 00 00 10637  			LD	HL, 0			; The return value
04407D C3 68 00 04 10638  			JP	_end 			; Jump back to the end routine in init.asm
044081             10639  
044081             10640  ; *VERSION
044081             10641  ;
044081 CD C8 3D 04 10642  STAR_VERSION:		CALL    TELL			; Output the welcome message
044085 42 42 43 20 10643  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0440A9 C9          10644  			RET
0440AA             10645  
0440AA             10646  ; *EDIT linenum
0440AA             10647  ;
0440AA CD CF 3D 04 10648  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440AE EB          10649  			EX	DE, HL			; HL: Line number
0440AF CD C7 39 04 10650  			CALL	FINDL			; HL: Address in RAM of tokenised line
0440B3 3E 29       10651  			LD	A, 41			; F:NZ If the line is not found
0440B5 C2 98 37 04 10652  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0440B9             10653  ;
0440B9             10654  ; Use LISTIT to output the line to the ACCS buffer
0440B9             10655  ;
0440B9 23          10656  			INC	HL			; Skip the length byte
0440BA 5E          10657  			LD	E, (HL)			; Fetch the line number
0440BB 23          10658  			INC	HL
0440BC 56          10659  			LD	D, (HL)
0440BD 23          10660  			INC	HL
0440BE DD 21 00 4A 10661  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0440C3 DD 22 43 4D 10662  			LD	(OSWRCHPT), IX
       04          
0440C8 DD 21 40 4D 10663  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0440CD DD 7E 00    10664  			LD	A, (IX)			; Store that variable
0440D0 F5          10665  			PUSH	AF
0440D1 DD 36 00 09 10666  			LD	(IX), 09h		; Set to echo to buffer
0440D5 CD CA 38 04 10667  			CALL	LISTIT
0440D9 F1          10668  			POP	AF
0440DA DD 77 00    10669  			LD	(IX), A			; Restore the original LISTON variable
0440DD 21 00 4A 04 10670  			LD	HL, ACCS		; HL: ACCS
0440E1 5D          10671  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0440E2 CD 99 3E 04 10672  			CALL	OSLINE1			; Invoke the editor
0440E6 C3 08 31 04 10673  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440EA             10674  
0440EA             10675  ; OSCLI FX n
0440EA             10676  ;
0440EA CD CF 3D 04 10677  STAR_FX:		CALL	ASC_TO_NUMBER
0440EE 4B          10678  			LD	C, E			; C: Save FX #
0440EF CD CF 3D 04 10679  			CALL	ASC_TO_NUMBER
0440F3 7A          10680  			LD	A, D  			; Is first parameter > 255?
0440F4 B7          10681  			OR 	A
0440F5 28 03       10682  			JR	Z, STAR_FX1		; Yes, so skip next bit
0440F7 EB          10683  			EX	DE, HL 			; Parameter is 16-bit
0440F8 18 07       10684  			JR	STAR_FX2
0440FA             10685  ;
0440FA 43          10686  STAR_FX1:		LD	B, E 			; B: Save First parameter
0440FB CD CF 3D 04 10687  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0440FF 68          10688  			LD	L, B 			; L: First parameter
044100 63          10689  			LD	H, E 			; H: Second parameter
044101             10690  ;
044101 79          10691  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
044102             10692  ;
044102             10693  ; OSBYTE
044102             10694  ;  A: FX #
044102             10695  ;  L: First parameter
044102             10696  ;  H: Second parameter
044102             10697  ;
044102 FE 0B       10698  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
044104 28 18       10699  			JR	Z, OSBYTE_0B
044106 FE 0C       10700  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044108 28 43       10701  			JR	Z, OSBYTE_0C
04410A FE 13       10702  			CP	13H			; *FX 19: Wait for vblank
04410C 28 6E       10703  			JR	Z, OSBYTE_13
04410E FE 76       10704  			CP	76H			; *FX 118, n: Set keyboard LED
044110 CA 97 41 04 10705  			JP	Z, OSBYTE_76
044114 FE A0       10706  			CP	A0H
044116 CA C7 41 04 10707  			JP	Z, OSBYTE_A0
04411A C3 2A 40 04 10708  			JP	HUH			; Anything else trips an error
04411E             10709  
04411E             10710  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
04411E             10711  ; Parameters:
04411E             10712  ; - HL: Repeat delay
04411E             10713  ;
04411E             10714  OSBYTE_0B:		VDU	23
04411E 3E 17       0001M 		LD	A, val
044120 CD 38 3F 04 0002M 		CALL	OSWRCH
044124             10715  			VDU	0
044124 3E 00       0001M 		LD	A, val
044126 CD 38 3F 04 0002M 		CALL	OSWRCH
04412A             10716  			VDU	vdp_keystate
04412A 3E 88       0001M 		LD	A, val
04412C CD 38 3F 04 0002M 		CALL	OSWRCH
044130             10717  			VDU	L
044130 7D          0001M 		LD	A, val
044131 CD 38 3F 04 0002M 		CALL	OSWRCH
044135             10718  			VDU	H
044135 7C          0001M 		LD	A, val
044136 CD 38 3F 04 0002M 		CALL	OSWRCH
04413A             10719  			VDU	0
04413A 3E 00       0001M 		LD	A, val
04413C CD 38 3F 04 0002M 		CALL	OSWRCH
044140             10720  			VDU 	0
044140 3E 00       0001M 		LD	A, val
044142 CD 38 3F 04 0002M 		CALL	OSWRCH
044146             10721  			VDU	255
044146 3E FF       0001M 		LD	A, val
044148 CD 38 3F 04 0002M 		CALL	OSWRCH
04414C C9          10722  			RET
04414D             10723  
04414D             10724  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
04414D             10725  ; Parameters:
04414D             10726  ; - HL: Repeat rate
04414D             10727  ;
04414D             10728  OSBYTE_0C:		VDU	23
04414D 3E 17       0001M 		LD	A, val
04414F CD 38 3F 04 0002M 		CALL	OSWRCH
044153             10729  			VDU	0
044153 3E 00       0001M 		LD	A, val
044155 CD 38 3F 04 0002M 		CALL	OSWRCH
044159             10730  			VDU	vdp_keystate
044159 3E 88       0001M 		LD	A, val
04415B CD 38 3F 04 0002M 		CALL	OSWRCH
04415F             10731  			VDU	0
04415F 3E 00       0001M 		LD	A, val
044161 CD 38 3F 04 0002M 		CALL	OSWRCH
044165             10732  			VDU 	0
044165 3E 00       0001M 		LD	A, val
044167 CD 38 3F 04 0002M 		CALL	OSWRCH
04416B             10733  			VDU	L
04416B 7D          0001M 		LD	A, val
04416C CD 38 3F 04 0002M 		CALL	OSWRCH
044170             10734  			VDU	H
044170 7C          0001M 		LD	A, val
044171 CD 38 3F 04 0002M 		CALL	OSWRCH
044175             10735  			VDU	255
044175 3E FF       0001M 		LD	A, val
044177 CD 38 3F 04 0002M 		CALL	OSWRCH
04417B C9          10736  			RET
04417C             10737  
04417C             10738  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
04417C             10739  ;
04417C CD 86 41 04 10740  OSBYTE_13:		CALL	WAIT_VBLANK
044180 2E 00       10741  			LD	L, 0			; Returns 0
044182 C3 84 05 04 10742  			JP	COUNT0
044186             10743  ;
044186 DD E5       10744  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
044188             10745  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044188 3E 08       0001M 			LD	A, function
04418A 49 CF       0002M 			RST.LIS	08h
04418C DD 7E 00    10746  			LD	A, (IX + sysvar_time + 0)
04418F DD BE 00    10747  @@:			CP 	A, (IX + sysvar_time + 0)
044192 28 FB       10748  			JR	Z, @B
044194 DD E1       10749  			POP	IX
044196 C9          10750  			RET
044197             10751  
044197             10752  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
044197             10753  ; Parameters:
044197             10754  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
044197             10755  ;
044197             10756  OSBYTE_76:		VDU	23
044197 3E 17       0001M 		LD	A, val
044199 CD 38 3F 04 0002M 		CALL	OSWRCH
04419D             10757  			VDU	0
04419D 3E 00       0001M 		LD	A, val
04419F CD 38 3F 04 0002M 		CALL	OSWRCH
0441A3             10758  			VDU	vdp_keystate
0441A3 3E 88       0001M 		LD	A, val
0441A5 CD 38 3F 04 0002M 		CALL	OSWRCH
0441A9             10759  			VDU	0
0441A9 3E 00       0001M 		LD	A, val
0441AB CD 38 3F 04 0002M 		CALL	OSWRCH
0441AF             10760  			VDU 	0
0441AF 3E 00       0001M 		LD	A, val
0441B1 CD 38 3F 04 0002M 		CALL	OSWRCH
0441B5             10761  			VDU	0
0441B5 3E 00       0001M 		LD	A, val
0441B7 CD 38 3F 04 0002M 		CALL	OSWRCH
0441BB             10762  			VDU	0
0441BB 3E 00       0001M 		LD	A, val
0441BD CD 38 3F 04 0002M 		CALL	OSWRCH
0441C1             10763  			VDU	L
0441C1 7D          0001M 		LD	A, val
0441C2 CD 38 3F 04 0002M 		CALL	OSWRCH
0441C6 C9          10764  			RET
0441C7             10765  
0441C7             10766  ; OSBYTE 0xA0: Fetch system variable
0441C7             10767  ; Parameters:
0441C7             10768  ; - L: The system variable to fetch
0441C7             10769  ;
0441C7 DD E5       10770  OSBYTE_A0:		PUSH	IX
0441C9             10771  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441C9 3E 08       0001M 			LD	A, function
0441CB 49 CF       0002M 			RST.LIS	08h
0441CD 01 00 00 00 10772  			LD	BC, 0
0441D1 4D          10773  			LD	C, L			; BCU = L
0441D2 DD 09       10774  			ADD	IX, BC			; Add to IX
0441D4 DD 6E 00    10775  			LD	L, (IX + 0)		; Fetch the return value
0441D7 DD E1       10776  			POP	IX
0441D9 C3 84 05 04 10777  			JP 	COUNT0
0441DD             10778  
0441DD             10779  ;OSLOAD - Load an area of memory from a file.
0441DD             10780  ;   Inputs: HL addresses filename (CR terminated)
0441DD             10781  ;           DE = address at which to load
0441DD             10782  ;           BC = maximum allowed size (bytes)
0441DD             10783  ;  Outputs: Carry reset indicates no room for file.
0441DD             10784  ; Destroys: A,B,C,D,E,H,L,F
0441DD             10785  ;
0441DD C5          10786  OSLOAD:			PUSH	BC			; Stack the size
0441DE D5          10787  			PUSH	DE			; Stack the load address
0441DF 11 00 4A 04 10788  			LD	DE, ACCS		; Buffer address for filename
0441E3 CD 51 3E 04 10789  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0441E7 21 00 4A 04 10790  			LD	HL, ACCS		; HL: Filename
0441EB CD DD 42 04 10791  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441EF CD F1 42 04 10792  			CALL	EXT_HANDLER		; Get the default handler
0441F3 D1          10793  			POP	DE			; Restore the load address
0441F4 C1          10794  			POP	BC			; Restore the size
0441F5 B7          10795  			OR	A
0441F6 28 60       10796  			JR 	Z, OSLOAD_BBC
0441F8             10797  ;
0441F8             10798  ; Load the file in as a text file
0441F8             10799  ;
0441F8 AF          10800  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441F9 CD 65 43 04 10801  			CALL	OSOPEN			; Open the file
0441FD 5F          10802  			LD 	E, A 			; The filehandle
0441FE B7          10803  			OR	A
0441FF 3E 04       10804  			LD	A, 4			; File not found error
044201 28 5D       10805  			JR	Z, OSERROR		; Jump to error handler
044203 CD A4 38 04 10806  			CALL	NEWIT			; Call NEW to clear the program space
044207             10807  ;
044207 21 00 4A 04 10808  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
04420B             10809  ;
04420B             10810  ; First skip any whitespace (indents) at the beginning of the input
04420B             10811  ;
04420B CD 7C 43 04 10812  @@:			CALL	OSBGET			; Read the byte into A
04420F 38 1E       10813  			JR	C, OSLOAD_TXT3		; Is it EOF?
044211 FE 0A       10814  			CP	LF 			; Is it LF?
044213 28 1A       10815  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
044215 FE 21       10816  			CP	21h			; Is it less than or equal to ASCII space?
044217 38 F2       10817  			JR	C, @B 			; Yes, so keep looping
044219 77          10818  			LD	(HL), A 		; Store the first character
04421A 2C          10819  			INC	L
04421B             10820  ;
04421B             10821  ; Now read the rest of the line in
04421B             10822  ;
04421B CD 7C 43 04 10823  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
04421F 38 2B       10824  			JR	C, OSLOAD_TXT4		; Is it EOF?
044221 FE 20       10825  			CP	20h			; Skip if not an ASCII character
044223 38 06       10826  			JR	C, @F
044225 77          10827  			LD	(HL), A 		; Store in the input buffer
044226 2C          10828  			INC	L			; Increment the buffer pointer
044227 CA 30 37 04 10829  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
04422B FE 0A       10830  @@:			CP	LF			; Check for LF
04422D 20 EC       10831  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
04422F             10832  ;
04422F             10833  ; Finally, handle EOL/EOF
04422F             10834  ;
04422F 36 0D       10835  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
044231 7D          10836  			LD	A, L			; Check for minimum line length
044232 FE 02       10837  			CP	2			; If it is 2 characters or less (including CR)
044234 38 0A       10838  			JR	C, @F			; Then don't bother entering it
044236 D5          10839  			PUSH	DE			; Preserve the filehandle
044237 CD 14 31 04 10840  			CALL	ONEDIT1			; Enter the line in memory
04423B DC 77 38 04 10841  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
04423F D1          10842  			POP	DE
044240 CD 8D 43 04 10843  @@:			CALL	OSSTAT			; End of file?
044244 20 C1       10844  			JR	NZ, OSLOAD_TXT1		; No, so loop
044246 CD 74 43 04 10845  			CALL	OSSHUT			; Close the file
04424A 37          10846  			SCF				; Flag to BASIC that we're good
04424B C9          10847  			RET
04424C             10848  ;
04424C             10849  ; Special case for BASIC programs with no blank line at the end
04424C             10850  ;
04424C FE 20       10851  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
04424E 38 06       10852  			JR	C, @F
044250 77          10853  			LD	(HL), A			; Store the character
044251 2C          10854  			INC	L
044252 CA 30 37 04 10855  			JP	Z, BAD
044256 18 D7       10856  @@:			JR	OSLOAD_TXT3
044258             10857  
044258             10858  ;
044258             10859  ; Load the file in as a tokenised binary blob
044258             10860  ;
044258             10861  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044258 3E 01       0001M 			LD	A, function
04425A 49 CF       0002M 			RST.LIS	08h
04425C D0          10862  			RET	NC			; If load returns with carry reset - NO ROOM
04425D B7          10863  			OR	A			; If there is no error (A=0)
04425E 37          10864  			SCF				; Need to set carry indicating there was room
04425F C8          10865  			RET	Z			; Return
044260             10866  ;
044260 F5          10867  OSERROR:		PUSH	AF			; Handle the MOS error
044261 21 00 4A 04 10868  			LD	HL, ACCS		; Address of the buffer
044265 01 00 01 00 10869  			LD	BC, 256			; Length of the buffer
044269 5F          10870  			LD	E, A			; The error code
04426A             10871  			MOSCALL	mos_getError		; Copy the error message into the buffer
04426A 3E 0F       0001M 			LD	A, function
04426C 49 CF       0002M 			RST.LIS	08h
04426E F1          10872  			POP	AF
04426F E5          10873  			PUSH	HL			; Stack the address of the error (now in ACCS)
044270 C6 7F       10874  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044272 C3 AF 37 04 10875  			JP	EXTERR			; Trigger an external error
044276             10876  
044276             10877  ;OSSAVE - Save an area of memory to a file.
044276             10878  ;   Inputs: HL addresses filename (term CR)
044276             10879  ;           DE = start address of data to save
044276             10880  ;           BC = length of data to save (bytes)
044276             10881  ; Destroys: A,B,C,D,E,H,L,F
044276             10882  ;
044276 C5          10883  OSSAVE:			PUSH	BC			; Stack the size
044277 D5          10884  			PUSH	DE			; Stack the save address
044278 11 00 4A 04 10885  			LD	DE, ACCS		; Buffer address for filename
04427C CD 51 3E 04 10886  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044280 21 00 4A 04 10887  			LD	HL, ACCS		; HL: Filename
044284 CD DD 42 04 10888  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044288 CD F1 42 04 10889  			CALL	EXT_HANDLER		; Get the default handler
04428C D1          10890  			POP	DE			; Restore the save address
04428D C1          10891  			POP	BC			; Restore the size
04428E B7          10892  			OR	A			; Is the extension .BBC
04428F 28 44       10893  			JR	Z, OSSAVE_BBC		; Yes, so use that
044291             10894  ;
044291             10895  ; Save the file out as a text file
044291             10896  ;
044291 3A 45 4D 04 10897  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
044295 F5          10898  			PUSH	AF
044296 AF          10899  			XOR	A
044297 3C          10900  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
044298 32 45 4D 04 10901  			LD	(OSWRCHCH), A
04429C CD 65 43 04 10902  			CALL	OSOPEN			; Open the file
0442A0 32 46 4D 04 10903  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0442A4 DD 21 40 4D 10904  			LD	IX, LISTON		; Required for LISTIT
       04          
0442A9 2A 14 4D 04 10905  			LD	HL, (PAGE_)		; Get start of program area
0442AD D9          10906  			EXX
0442AE 01 00 00 00 10907  			LD	BC, 0			; Set the initial indent counters
0442B2 D9          10908  			EXX
0442B3 7E          10909  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442B4 B7          10910  			OR	A
0442B5 28 0F       10911  			JR	Z, OSSAVE_TXT2
0442B7 23          10912  			INC	HL			; Skip the length byte
0442B8 11 00 00 00 10913  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442BC 5E          10914  			LD	E, (HL)			; Get the line number
0442BD 23          10915  			INC	HL
0442BE 56          10916  			LD	D, (HL)
0442BF 23          10917  			INC	HL
0442C0 CD CA 38 04 10918  			CALL	LISTIT			; List the line
0442C4 18 ED       10919  			JR	OSSAVE_TXT1
0442C6 3A 46 4D 04 10920  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442CA 5F          10921  			LD	E, A
0442CB CD 74 43 04 10922  			CALL	OSSHUT			; Close it
0442CF F1          10923  			POP	AF			; Restore the channel
0442D0 32 45 4D 04 10924  			LD	(OSWRCHCH), A
0442D4 C9          10925  			RET
0442D5             10926  ;
0442D5             10927  ; Save the file out as a tokenised binary blob
0442D5             10928  ;
0442D5             10929  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442D5 3E 02       0001M 			LD	A, function
0442D7 49 CF       0002M 			RST.LIS	08h
0442D9 B7          10930  			OR	A			; If there is no error (A=0)
0442DA C8          10931  			RET	Z			; Just return
0442DB 18 83       10932  			JR	OSERROR			; Trip an error
0442DD             10933  
0442DD             10934  ; Check if an extension is specified in the filename
0442DD             10935  ; Add a default if not specified
0442DD             10936  ; HL: Filename (CSTR format)
0442DD             10937  ;
0442DD E5          10938  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442DE 0E 2E       10939  			LD	C, '.'			; Search for dot (marks start of extension)
0442E0 CD 71 3E 04 10940  			CALL	CSTR_FINDCH
0442E4 B7          10941  			OR	A			; Check for end of string marker
0442E5 20 08       10942  			JR	NZ, @F			; No, so skip as we have an extension at this point
0442E7 11 21 43 04 10943  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442EB CD 88 3E 04 10944  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442EF E1          10945  @@:			POP	HL			; Restore the filename pointer
0442F0 C9          10946  			RET
0442F1             10947  
0442F1             10948  ; Check if an extension is valid and, if so, provide a pointer to a handler
0442F1             10949  ; HL: Filename (CSTR format)
0442F1             10950  ; Returns:
0442F1             10951  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0442F1             10952  ;
0442F1 E5          10953  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442F2 0E 2E       10954  			LD	C, '.'			; Find the '.'
0442F4 CD 71 3E 04 10955  			CALL	CSTR_FINDCH
0442F8 11 21 43 04 10956  			LD	DE, EXT_LOOKUP		; The lookup table
0442FC             10957  ;
0442FC E5          10958  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442FD CD 79 3E 04 10959  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
044301 E1          10960  			POP	HL			; Restore the pointer to the extension
044302 28 19       10961  			JR	Z, EXT_HANDLER_2	; We have a match!
044304             10962  ;
044304 1A          10963  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
044305 13          10964  			INC	DE
044306 B7          10965  			OR	A
044307 20 FB       10966  			JR	NZ, @B
044309 13          10967  			INC	DE			; Skip the file extension # byte
04430A             10968  ;
04430A 1A          10969  			LD	A, (DE)			; Are we at the end of the table?
04430B B7          10970  			OR	A
04430C 20 EE       10971  			JR	NZ, EXT_HANDLER_1	; No, so loop
04430E             10972  ;
04430E 3E CC       10973  			LD      A,204			; Throw a "Bad name" error
044310 CD AF 37 04 10974          		CALL    EXTERR
044314 42 61 64 20 10975          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
04431D             10976  ;
04431D 13          10977  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
04431E 1A          10978  			LD	A, (DE)
04431F E1          10979  			POP	HL			; Restore the filename pointer
044320 C9          10980  			RET
044321             10981  ;
044321             10982  
044321             10983  
044321             10984  ; Extension lookup table
044321             10985  ; CSTR, TYPE
044321             10986  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
044321             10987  ; 	- 1: Human readable plain text
044321             10988  ;
044321 2E 42 42 43 10989  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
044327 2E 54 58 54 10990  			DB	".TXT", 0, 1
       00 01       
04432D 2E 41 53 43 10991  			DB	".ASC", 0, 1
       00 01       
044333 2E 42 41 53 10992  			DB	".BAS", 0, 1
       00 01       
044339 00          10993  			DB	0			; End of table
04433A             10994  
04433A             10995  ;OSCALL - Intercept page &FF calls and provide an alternative address
04433A             10996  ;
04433A             10997  ;&FFF7:	OSCLI	Execute *command.
04433A             10998  ;&FFF4:	OSBYTE	Various byte-wide functions.
04433A             10999  ;&FFF1:	OSWORD	Various control block functions.
04433A             11000  ;&FFEE:	OSWRCH	Write character to output stream.
04433A             11001  ;&FFE7:	OSNEWL	Write NewLine to output stream.
04433A             11002  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
04433A             11003  ;&FFE0:	OSRDCH	Wait for character from input stream.
04433A             11004  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
04433A             11005  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
04433A             11006  ;&FFD7:	OSBGET	Read a byte from an a channel.
04433A             11007  ;&FFD4:	OSBPUT	Write a byte to a channel.
04433A             11008  ;&FFD1:	OSGBPB	Read and write blocks of data.
04433A             11009  ;&FFCE:	OSFIND	Open or close a file.
04433A             11010  ;
04433A 21 50 43 04 11011  OSCALL:			LD	HL, OSCALL_TABLE
04433E 7E          11012  OSCALL_1:		LD	A, (HL)
04433F 23          11013  			INC	HL
044340 FE FF       11014  			CP	FFh
044342 C8          11015  			RET	Z
044343 FD BD       11016  			CP	A, IYL
044345 28 06       11017  			JR	Z, OSCALL_2
044347 D0          11018  			RET	NC
044348 23          11019  			INC	HL
044349 23          11020  			INC	HL
04434A 23          11021  			INC	HL
04434B 18 F1       11022  			JR	OSCALL_1
04434D ED 31       11023  OSCALL_2:		LD	IY,(HL)
04434F C9          11024  			RET
044350 D4          11025  OSCALL_TABLE:		DB 	D4h
044351 84 43 04    11026  			DW24 	OSBPUT
044354 D7          11027  			DB 	D7h
044355 7C 43 04    11028  			DW24 	OSBGET
044358 EE          11029  			DB 	EEh
044359 38 3F 04    11030  			DW24 	OSWRCH
04435C F4          11031  			DB	F4h
04435D 02 41 04    11032  			DW24 	OSBYTE
044360 F7          11033  			DB	F7h
044361 C8 3F 04    11034  			DW24	OSCLI
044364 FF          11035  			DB	FFh
044365             11036  
044365             11037  ; OSOPEN
044365             11038  ; HL: Pointer to path
044365             11039  ;  F: C Z
044365             11040  ;     x x OPENIN
044365             11041  ; 	  OPENOUT
044365             11042  ;     x	  OPENUP
044365             11043  ; Returns:
044365             11044  ;  A: Filehandle, 0 if cannot open
044365             11045  ;
044365 0E 01       11046  OSOPEN:			LD	C, fa_read
044367 28 06       11047  			JR	Z, @F
044369 0E 32       11048  			LD	C, fa_write | fa_open_append
04436B 38 02       11049  			JR	C, @F
04436D 0E 0A       11050  			LD	C, fa_write | fa_create_always
04436F             11051  @@:			MOSCALL	mos_fopen
04436F 3E 0A       0001M 			LD	A, function
044371 49 CF       0002M 			RST.LIS	08h
044373 C9          11052  			RET
044374             11053  
044374             11054  ;OSSHUT - Close disk file(s).
044374             11055  ; E = file channel
044374             11056  ;  If E=0 all files are closed (except SPOOL)
044374             11057  ; Destroys: A,B,C,D,E,H,L,F
044374             11058  ;
044374 C5          11059  OSSHUT:			PUSH	BC
044375 4B          11060  			LD	C, E
044376             11061  			MOSCALL	mos_fclose
044376 3E 0B       0001M 			LD	A, function
044378 49 CF       0002M 			RST.LIS	08h
04437A C1          11062  			POP	BC
04437B C9          11063  			RET
04437C             11064  
04437C             11065  ; OSBGET - Read a byte from a random disk file.
04437C             11066  ;  E = file channel
04437C             11067  ; Returns
04437C             11068  ;  A = byte read
04437C             11069  ;  Carry set if LAST BYTE of file
04437C             11070  ; Destroys: A,B,C,F
04437C             11071  ;
04437C C5          11072  OSBGET:			PUSH	BC
04437D 4B          11073  			LD	C, E
04437E             11074  			MOSCALL	mos_fgetc
04437E 3E 0C       0001M 			LD	A, function
044380 49 CF       0002M 			RST.LIS	08h
044382 C1          11075  			POP	BC
044383 C9          11076  			RET
044384             11077  
044384             11078  ; OSBPUT - Write a byte to a random disk file.
044384             11079  ;  E = file channel
044384             11080  ;  A = byte to write
044384             11081  ; Destroys: A,B,C,F
044384             11082  ;
044384 C5          11083  OSBPUT:			PUSH	BC
044385 4B          11084  			LD	C, E
044386 47          11085  			LD	B, A
044387             11086  			MOSCALL	mos_fputc
044387 3E 0D       0001M 			LD	A, function
044389 49 CF       0002M 			RST.LIS	08h
04438B C1          11087  			POP	BC
04438C C9          11088  			RET
04438D             11089  
04438D             11090  ; OSSTAT - Read file status
04438D             11091  ;  E = file channel
04438D             11092  ; Returns
04438D             11093  ;  F: Z flag set - EOF
04438D             11094  ;  A: If Z then A = 0
04438D             11095  ; Destroys: A,D,E,H,L,F
04438D             11096  ;
04438D C5          11097  OSSTAT:			PUSH	BC
04438E 4B          11098  			LD	C, E
04438F             11099  			MOSCALL	mos_feof
04438F 3E 0E       0001M 			LD	A, function
044391 49 CF       0002M 			RST.LIS	08h
044393 C1          11100  			POP	BC
044394 FE 01       11101  			CP	1
044396 C9          11102  			RET
044397             11103  
044397             11104  ; GETPTR - Return file pointer.
044397             11105  ;    E = file channel
044397             11106  ; Returns:
044397             11107  ; DEHL = pointer (0-&7FFFFF)
044397             11108  ; Destroys: A,B,C,D,E,H,L,F
044397             11109  ;
044397 FD E5       11110  GETPTR:			PUSH		IY
044399 4B          11111  			LD		C, E
04439A             11112  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
04439A 3E 19       0001M 			LD	A, function
04439C 49 CF       0002M 			RST.LIS	08h
04439E E5          11113  			PUSH		HL
04439F FD E1       11114  			POP		IY		; IYU: Pointer to FIL structure
0443A1 FD 6E 11    11115  			LD		L, (IY + FIL.fptr + 0)
0443A4 FD 66 12    11116  			LD		H, (IY + FIL.fptr + 1)
0443A7 FD 5E 13    11117  			LD		E, (IY + FIL.fptr + 2)
0443AA FD 56 14    11118  			LD		D, (IY + FIL.fptr + 3)
0443AD FD E1       11119  			POP		IY
0443AF C9          11120  			RET
0443B0             11121  
0443B0             11122  ; PUTPTR - Update file pointer.
0443B0             11123  ;    A = file channel
0443B0             11124  ; DEHL = new pointer (0-&7FFFFF)
0443B0             11125  ; Destroys: A,B,C,D,E,H,L,F
0443B0             11126  ;
0443B0 FD E5       11127  PUTPTR:			PUSH		IY
0443B2 4F          11128  			LD		C, A  		; C: Filehandle
0443B3 E5          11129  			PUSH		HL
0443B4 21 02 00 00 11130  			LD		HL, 2
0443B8 39          11131  			ADD		HL, SP
0443B9 73          11132  			LD		(HL), E 	; 3rd byte of DWORD set to E
0443BA E1          11133  			POP		HL
0443BB 5A          11134  			LD		E, D  		; 4th byte passed as E
0443BC             11135  			MOSCALL		mos_flseek
0443BC 3E 1C       0001M 			LD	A, function
0443BE 49 CF       0002M 			RST.LIS	08h
0443C0 FD E1       11136  			POP		IY
0443C2 C9          11137  			RET
0443C3             11138  
0443C3             11139  ; GETEXT - Find file size.
0443C3             11140  ;    E = file channel
0443C3             11141  ; Returns:
0443C3             11142  ; DEHL = file size (0-&800000)
0443C3             11143  ; Destroys: A,B,C,D,E,H,L,F
0443C3             11144  ;
0443C3 FD E5       11145  GETEXT:         PUSH    IY
0443C5 4B          11146                  LD      C, E
0443C6             11147                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443C6 3E 19       0001M 			LD	A, function
0443C8 49 CF       0002M 			RST.LIS	08h
0443CA E5          11148                  PUSH    HL
0443CB FD E1       11149                  POP     IY          ; IYU: Pointer to FIL structure
0443CD             11150                  ; Access the obj.objsize field using the offset values
0443CD FD 6E 0B    11151                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443D0 FD 66 0C    11152                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443D3 FD 5E 0D    11153                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443D6 FD 56 0E    11154                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443D9             11155  
0443D9 FD E1       11156                  POP     IY
0443DB C9          11157  			RET
0443DC             11158  
0443DC             11159  ; GETIMS - Get time from RTC
0443DC             11160  ;
0443DC FD E5       11161  GETIMS:			PUSH	IY
0443DE 21 00 4A 04 11162  			LD	HL, ACCS 		; Where to store the time string
0443E2             11163  			MOSCALL	mos_getrtc
0443E2 3E 12       0001M 			LD	A, function
0443E4 49 CF       0002M 			RST.LIS	08h
0443E6 11 00 4A 04 11164  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0443EA 5F          11165  			LD	E, A 			;  E: now points to the end of the string
0443EB FD E1       11166  			POP	IY
0443ED C9          11167  			RET
0443EE             11168  
0443EE             11169  ; Get two word values from EXPR in DE, HL
0443EE             11170  ; IY: Pointer to expression string
0443EE             11171  ; Returns:
0443EE             11172  ; DE: P1
0443EE             11173  ; HL: P2
0443EE             11174  ;
0443EE CD 0F 03 04 11175  EXPR_W2:		CALL	EXPRI			; Get first parameter
0443F2 D9          11176  			EXX
0443F3 E5          11177  			PUSH	HL
0443F4 CD 2A 0A 04 11178  			CALL	COMMA
0443F8 CD 0F 03 04 11179  			CALL	EXPRI			; Get second parameter
0443FC D9          11180  			EXX
0443FD D1          11181  			POP	DE
0443FE C9          11182  			RET
0443FF             11183  
0443FF             11184  ; Stuff not implemented yet
0443FF             11185  ;
0443FF C9          11186  RESET:			RET
044400             11187  ; --- End patch.asm ---
044400             11188  
044400             11189  ; --- Begin agon_graphics.asm ---
044400             11190  ;
044400             11191  ; Title:	BBC Basic for AGON - Graphics stuff
044400             11192  ; Author:	Dean Belfield
044400             11193  ; Created:	12/05/2023
044400             11194  ; Last Updated:	07/06/2023
044400             11195  ;
044400             11196  ; Modinfo:
044400             11197  ; 07/06/2023:	Modified to run in ADL mode
044400             11198  
044400             11199  			; .ASSUME	ADL = 1
044400             11200  
044400             11201  			; INCLUDE	"equs.inc"
044400             11202  			; INCLUDE "macros.inc"
044400             11203  			; INCLUDE "mos_api.inc"	; In MOS/src
044400             11204  
044400             11205  			; SEGMENT CODE
044400             11206  
044400             11207  			; XDEF	CLG
044400             11208  			; XDEF	CLRSCN
044400             11209  			; XDEF	MODE
044400             11210  			; XDEF	COLOUR
044400             11211  			; XDEF	GCOL
044400             11212  			; XDEF	MOVE
044400             11213  			; XDEF	PLOT
044400             11214  			; XDEF	DRAW
044400             11215  			; XDEF	POINT
044400             11216  			; XDEF	GETSCHR
044400             11217  
044400             11218  			; XREF	OSWRCH
044400             11219  			; XREF	ASC_TO_NUMBER
044400             11220  			; XREF	EXTERR
044400             11221  			; XREF	EXPRI
044400             11222  			; XREF	COMMA
044400             11223  			; XREF	XEQ
044400             11224  			; XREF	NXT
044400             11225  			; XREF	BRAKET
044400             11226  			; XREF	COUNT0
044400             11227  			; XREF	CRTONULL
044400             11228  			; XREF	NULLTOCR
044400             11229  			; XREF	CRLF
044400             11230  			; XREF	EXPR_W2
044400             11231  			; XREF	INKEY1
044400             11232  
044400             11233  ; CLG: clears the graphics area
044400             11234  ;
044400             11235  CLG:			VDU	10h
044400 3E 10       0001M 		LD	A, val
044402 CD 38 3F 04 0002M 		CALL	OSWRCH
044406 C3 9E 0B 04 11236  			JP	XEQ
04440A             11237  
04440A             11238  ; CLS: clears the text area
04440A             11239  ;
04440A 3E 0C       11240  CLRSCN:			LD	A, 0Ch
04440C C3 38 3F 04 11241  			JP	OSWRCH
044410             11242  
044410             11243  ; MODE n: Set video mode
044410             11244  ;
044410 DD E5       11245  MODE:			PUSH	IX			; Get the system vars in IX
044412             11246  			MOSCALL	mos_sysvars		; Reset the semaphore
044412 3E 08       0001M 			LD	A, function
044414 49 CF       0002M 			RST.LIS	08h
044416 DD CB 04 A6 11247  			RES	4, (IX+sysvar_vpd_pflags)
04441A CD 0F 03 04 11248  			CALL    EXPRI
04441E D9          11249  			EXX
04441F             11250  			VDU	16H			; Mode change
04441F 3E 16       0001M 		LD	A, val
044421 CD 38 3F 04 0002M 		CALL	OSWRCH
044425             11251  			VDU	L
044425 7D          0001M 		LD	A, val
044426 CD 38 3F 04 0002M 		CALL	OSWRCH
04442A             11252  			MOSCALL	mos_sysvars
04442A 3E 08       0001M 			LD	A, function
04442C 49 CF       0002M 			RST.LIS	08h
04442E DD CB 04 66 11253  @@:			BIT	4, (IX+sysvar_vpd_pflags)
044432 28 FA       11254  			JR	Z, @B			; Wait for the result
044434 DD E1       11255  			POP	IX
044436 C3 9E 0B 04 11256  			JP	XEQ
04443A             11257  
04443A             11258  ; GET(x,y): Get the ASCII code of a character on screen
04443A             11259  ;
04443A FD 23       11260  GETSCHR:		INC	IY
04443C CD 0F 03 04 11261  			CALL    EXPRI      		; Get X coordinate
044440 D9          11262  			EXX
044441 22 00 4A 04 11263  			LD	(VDU_BUFFER+0), HL
044445 CD 2A 0A 04 11264  			CALL	COMMA
044449 CD 0F 03 04 11265  			CALL	EXPRI			; Get Y coordinate
04444D D9          11266  			EXX
04444E 22 02 4A 04 11267  			LD	(VDU_BUFFER+2), HL
044452 CD 37 0A 04 11268  			CALL	BRAKET			; Closing bracket
044456             11269  ;
044456 DD E5       11270  			PUSH	IX			; Get the system vars in IX
044458             11271  			MOSCALL	mos_sysvars		; Reset the semaphore
044458 3E 08       0001M 			LD	A, function
04445A 49 CF       0002M 			RST.LIS	08h
04445C DD CB 04 8E 11272  			RES	1, (IX+sysvar_vpd_pflags)
044460             11273  			VDU	23
044460 3E 17       0001M 		LD	A, val
044462 CD 38 3F 04 0002M 		CALL	OSWRCH
044466             11274  			VDU	0
044466 3E 00       0001M 		LD	A, val
044468 CD 38 3F 04 0002M 		CALL	OSWRCH
04446C             11275  			VDU	vdp_scrchar
04446C 3E 83       0001M 		LD	A, val
04446E CD 38 3F 04 0002M 		CALL	OSWRCH
044472             11276  			VDU	(VDU_BUFFER+0)
044472 3A 00 4A 04 0001M 		LD	A, val
044476 CD 38 3F 04 0002M 		CALL	OSWRCH
04447A             11277  			VDU	(VDU_BUFFER+1)
04447A 3A 01 4A 04 0001M 		LD	A, val
04447E CD 38 3F 04 0002M 		CALL	OSWRCH
044482             11278  			VDU	(VDU_BUFFER+2)
044482 3A 02 4A 04 0001M 		LD	A, val
044486 CD 38 3F 04 0002M 		CALL	OSWRCH
04448A             11279  			VDU	(VDU_BUFFER+3)
04448A 3A 03 4A 04 0001M 		LD	A, val
04448E CD 38 3F 04 0002M 		CALL	OSWRCH
044492 DD CB 04 4E 11280  @@:			BIT	1, (IX+sysvar_vpd_pflags)
044496 28 FA       11281  			JR	Z, @B			; Wait for the result
044498 DD 7E 09    11282  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
04449B B7          11283  			OR	A			; Check for 00h
04449C 37          11284  			SCF				; C = character map
04449D 20 02       11285  			JR	NZ, @F			; We have a character, so skip next bit
04449F AF          11286  			XOR	A			; Clear carry
0444A0 3D          11287  			DEC	A			; Set A to FFh
0444A1 DD E1       11288  @@:			POP	IX
0444A3 C3 E6 07 04 11289  			JP	INKEY1			; Jump back to the GET command
0444A7             11290  
0444A7             11291  ; POINT(x,y): Get the pixel colour of a point on screen
0444A7             11292  ;
0444A7 CD 0F 03 04 11293  POINT:			CALL    EXPRI      		; Get X coordinate
0444AB D9          11294  			EXX
0444AC 22 00 4A 04 11295  			LD	(VDU_BUFFER+0), HL
0444B0 CD 2A 0A 04 11296  			CALL	COMMA
0444B4 CD 0F 03 04 11297  			CALL	EXPRI			; Get Y coordinate
0444B8 D9          11298  			EXX
0444B9 22 02 4A 04 11299  			LD	(VDU_BUFFER+2), HL
0444BD CD 37 0A 04 11300  			CALL	BRAKET			; Closing bracket
0444C1             11301  ;
0444C1 DD E5       11302  			PUSH	IX			; Get the system vars in IX
0444C3             11303  			MOSCALL	mos_sysvars		; Reset the semaphore
0444C3 3E 08       0001M 			LD	A, function
0444C5 49 CF       0002M 			RST.LIS	08h
0444C7 DD CB 04 96 11304  			RES	2, (IX+sysvar_vpd_pflags)
0444CB             11305  			VDU	23
0444CB 3E 17       0001M 		LD	A, val
0444CD CD 38 3F 04 0002M 		CALL	OSWRCH
0444D1             11306  			VDU	0
0444D1 3E 00       0001M 		LD	A, val
0444D3 CD 38 3F 04 0002M 		CALL	OSWRCH
0444D7             11307  			VDU	vdp_scrpixel
0444D7 3E 84       0001M 		LD	A, val
0444D9 CD 38 3F 04 0002M 		CALL	OSWRCH
0444DD             11308  			VDU	(VDU_BUFFER+0)
0444DD 3A 00 4A 04 0001M 		LD	A, val
0444E1 CD 38 3F 04 0002M 		CALL	OSWRCH
0444E5             11309  			VDU	(VDU_BUFFER+1)
0444E5 3A 01 4A 04 0001M 		LD	A, val
0444E9 CD 38 3F 04 0002M 		CALL	OSWRCH
0444ED             11310  			VDU	(VDU_BUFFER+2)
0444ED 3A 02 4A 04 0001M 		LD	A, val
0444F1 CD 38 3F 04 0002M 		CALL	OSWRCH
0444F5             11311  			VDU	(VDU_BUFFER+3)
0444F5 3A 03 4A 04 0001M 		LD	A, val
0444F9 CD 38 3F 04 0002M 		CALL	OSWRCH
0444FD DD CB 04 56 11312  @@:			BIT	2, (IX+sysvar_vpd_pflags)
044501 28 FA       11313  			JR	Z, @B			; Wait for the result
044503             11314  ;
044503             11315  ; Return the data as a 1 byte index
044503             11316  ;
044503 DD 6E 16    11317  			LD	L, (IX+sysvar_scrpixelIndex)
044506 DD E1       11318  			POP	IX
044508 C3 84 05 04 11319  			JP	COUNT0
04450C             11320  
04450C             11321  
04450C             11322  ; COLOUR colour
04450C             11323  ; COLOUR L,P
04450C             11324  ; COLOUR L,R,G,B
04450C             11325  ;
04450C CD 0F 03 04 11326  COLOUR:			CALL	EXPRI			; The colour / mode
044510 D9          11327  			EXX
044511 7D          11328  			LD	A, L
044512 32 00 4A 04 11329  			LD	(VDU_BUFFER+0), A	; Store first parameter
044516 CD 78 0A 04 11330  			CALL	NXT			; Are there any more parameters?
04451A FE 2C       11331  			CP	','
04451C 28 12       11332  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
04451E             11333  ;
04451E             11334  			VDU	11h			; Just set the colour
04451E 3E 11       0001M 		LD	A, val
044520 CD 38 3F 04 0002M 		CALL	OSWRCH
044524             11335  			VDU	(VDU_BUFFER+0)
044524 3A 00 4A 04 0001M 		LD	A, val
044528 CD 38 3F 04 0002M 		CALL	OSWRCH
04452C C3 9E 0B 04 11336  			JP	XEQ
044530             11337  ;
044530 CD 2A 0A 04 11338  COLOUR_1:		CALL	COMMA
044534 CD 0F 03 04 11339  			CALL	EXPRI			; Parse R (OR P)
044538 D9          11340  			EXX
044539 7D          11341  			LD	A, L
04453A 32 01 4A 04 11342  			LD	(VDU_BUFFER+1), A
04453E CD 78 0A 04 11343  			CALL	NXT			; Are there any more parameters?
044542 FE 2C       11344  			CP	','
044544 28 2C       11345  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044546             11346  ;
044546             11347  			VDU	13h			; VDU:COLOUR
044546 3E 13       0001M 		LD	A, val
044548 CD 38 3F 04 0002M 		CALL	OSWRCH
04454C             11348  			VDU	(VDU_BUFFER+0)		; Logical Colour
04454C 3A 00 4A 04 0001M 		LD	A, val
044550 CD 38 3F 04 0002M 		CALL	OSWRCH
044554             11349  			VDU	(VDU_BUFFER+1)		; Palette Colour
044554 3A 01 4A 04 0001M 		LD	A, val
044558 CD 38 3F 04 0002M 		CALL	OSWRCH
04455C             11350  			VDU	0			; RGB set to 0
04455C 3E 00       0001M 		LD	A, val
04455E CD 38 3F 04 0002M 		CALL	OSWRCH
044562             11351  			VDU	0
044562 3E 00       0001M 		LD	A, val
044564 CD 38 3F 04 0002M 		CALL	OSWRCH
044568             11352  			VDU	0
044568 3E 00       0001M 		LD	A, val
04456A CD 38 3F 04 0002M 		CALL	OSWRCH
04456E C3 9E 0B 04 11353  			JP	XEQ
044572             11354  ;
044572 CD 2A 0A 04 11355  COLOUR_2:		CALL	COMMA
044576 CD 0F 03 04 11356  			CALL	EXPRI			; Parse G
04457A D9          11357  			EXX
04457B 7D          11358  			LD	A, L
04457C 32 02 4A 04 11359  			LD	(VDU_BUFFER+2), A
044580 CD 2A 0A 04 11360  			CALL	COMMA
044584 CD 0F 03 04 11361  			CALL	EXPRI			; Parse B
044588 D9          11362  			EXX
044589 7D          11363  			LD	A, L
04458A 32 03 4A 04 11364  			LD	(VDU_BUFFER+3), A
04458E             11365  			VDU	13h			; VDU:COLOUR
04458E 3E 13       0001M 		LD	A, val
044590 CD 38 3F 04 0002M 		CALL	OSWRCH
044594             11366  			VDU	(VDU_BUFFER+0)		; Logical Colour
044594 3A 00 4A 04 0001M 		LD	A, val
044598 CD 38 3F 04 0002M 		CALL	OSWRCH
04459C             11367  			VDU	FFh			; Physical Colour (-1 for RGB mode)
04459C 3E FF       0001M 		LD	A, val
04459E CD 38 3F 04 0002M 		CALL	OSWRCH
0445A2             11368  			VDU	(VDU_BUFFER+1)		; R
0445A2 3A 01 4A 04 0001M 		LD	A, val
0445A6 CD 38 3F 04 0002M 		CALL	OSWRCH
0445AA             11369  			VDU	(VDU_BUFFER+2)		; G
0445AA 3A 02 4A 04 0001M 		LD	A, val
0445AE CD 38 3F 04 0002M 		CALL	OSWRCH
0445B2             11370  			VDU	(VDU_BUFFER+3)		; B
0445B2 3A 03 4A 04 0001M 		LD	A, val
0445B6 CD 38 3F 04 0002M 		CALL	OSWRCH
0445BA C3 9E 0B 04 11371  			JP	XEQ
0445BE             11372  
0445BE             11373  ; GCOL mode,colour
0445BE             11374  ;
0445BE CD 0F 03 04 11375  GCOL:			CALL	EXPRI			; Parse MODE
0445C2 D9          11376  			EXX
0445C3 7D          11377  			LD	A, L
0445C4 32 00 4A 04 11378  			LD	(VDU_BUFFER+0), A
0445C8 CD 2A 0A 04 11379  			CALL	COMMA
0445CC             11380  ;
0445CC CD 0F 03 04 11381  			CALL	EXPRI			; Parse Colour
0445D0 D9          11382  			EXX
0445D1 7D          11383  			LD	A, L
0445D2 32 01 4A 04 11384  			LD	(VDU_BUFFER+1), A
0445D6             11385  ;
0445D6             11386  			VDU	12h			; VDU:GCOL
0445D6 3E 12       0001M 		LD	A, val
0445D8 CD 38 3F 04 0002M 		CALL	OSWRCH
0445DC             11387  			VDU	(VDU_BUFFER+0)		; Mode
0445DC 3A 00 4A 04 0001M 		LD	A, val
0445E0 CD 38 3F 04 0002M 		CALL	OSWRCH
0445E4             11388  			VDU	(VDU_BUFFER+1)		; Colour
0445E4 3A 01 4A 04 0001M 		LD	A, val
0445E8 CD 38 3F 04 0002M 		CALL	OSWRCH
0445EC C3 9E 0B 04 11389  			JP	XEQ
0445F0             11390  
0445F0             11391  ; PLOT mode,x,y
0445F0             11392  ;
0445F0 CD 0F 03 04 11393  PLOT:			CALL	EXPRI		; Parse mode
0445F4 D9          11394  			EXX
0445F5 E5          11395  			PUSH	HL		; Push mode (L) onto stack
0445F6 CD 2A 0A 04 11396  			CALL	COMMA
0445FA CD EE 43 04 11397  			CALL	EXPR_W2		; Parse X and Y
0445FE C1          11398  			POP	BC		; Pop mode (C) off stack
0445FF             11399  PLOT_1:			VDU	19H		; VDU code for PLOT
0445FF 3E 19       0001M 		LD	A, val
044601 CD 38 3F 04 0002M 		CALL	OSWRCH
044605             11400  			VDU	C		;  C: Mode
044605 79          0001M 		LD	A, val
044606 CD 38 3F 04 0002M 		CALL	OSWRCH
04460A             11401  			VDU	E		; DE: X
04460A 7B          0001M 		LD	A, val
04460B CD 38 3F 04 0002M 		CALL	OSWRCH
04460F             11402  			VDU	D
04460F 7A          0001M 		LD	A, val
044610 CD 38 3F 04 0002M 		CALL	OSWRCH
044614             11403  			VDU	L		; HL: Y
044614 7D          0001M 		LD	A, val
044615 CD 38 3F 04 0002M 		CALL	OSWRCH
044619             11404  			VDU	H
044619 7C          0001M 		LD	A, val
04461A CD 38 3F 04 0002M 		CALL	OSWRCH
04461E C3 9E 0B 04 11405  			JP	XEQ
044622             11406  
044622             11407  ; MOVE x,y
044622             11408  ;
044622 CD EE 43 04 11409  MOVE:			CALL	EXPR_W2		; Parse X and Y
044626 0E 04       11410  			LD	C, 04H		; Plot mode 04H (Move)
044628 18 D5       11411  			JR	PLOT_1		; Plot
04462A             11412  
04462A             11413  ; DRAW x1,y1
04462A             11414  ; DRAW x1,y1,x2,y2
04462A             11415  ;
04462A CD EE 43 04 11416  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
04462E CD 78 0A 04 11417  			CALL	NXT		; Are there any more parameters?
044632 FE 2C       11418  			CP	','
044634 0E 05       11419  			LD	C, 05h		; Code for LINE
044636 20 C7       11420  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044638             11421  			VDU	19h		; Move to the first coordinates
044638 3E 19       0001M 		LD	A, val
04463A CD 38 3F 04 0002M 		CALL	OSWRCH
04463E             11422  			VDU	04h
04463E 3E 04       0001M 		LD	A, val
044640 CD 38 3F 04 0002M 		CALL	OSWRCH
044644             11423  			VDU	E
044644 7B          0001M 		LD	A, val
044645 CD 38 3F 04 0002M 		CALL	OSWRCH
044649             11424  			VDU	D
044649 7A          0001M 		LD	A, val
04464A CD 38 3F 04 0002M 		CALL	OSWRCH
04464E             11425  			VDU	L
04464E 7D          0001M 		LD	A, val
04464F CD 38 3F 04 0002M 		CALL	OSWRCH
044653             11426  			VDU	H
044653 7C          0001M 		LD	A, val
044654 CD 38 3F 04 0002M 		CALL	OSWRCH
044658 CD 2A 0A 04 11427  			CALL	COMMA
04465C C5          11428  			PUSH	BC
04465D CD EE 43 04 11429  			CALL	EXPR_W2		; Get X2 and Y2
044661 C1          11430  			POP	BC
044662 18 9B       11431  			JR	PLOT_1		; Now DRAW the line to those positions
044664             11432  
044664             11433  
044664             11434  
044664             11435  ; --- End agon_graphics.asm ---
044664             11436  
044664             11437  ; --- Begin agon_sound.asm ---
044664             11438  ;
044664             11439  ; Title:	BBC Basic for AGON - Audio stuff
044664             11440  ; Author:	Dean Belfield
044664             11441  ; Created:	12/05/2023
044664             11442  ; Last Updated:	12/05/2023
044664             11443  ;
044664             11444  ; Modinfo:
044664             11445  
044664             11446  			; .ASSUME	ADL = 1
044664             11447  
044664             11448  			; INCLUDE	"equs.inc"
044664             11449  			; INCLUDE "macros.inc"
044664             11450  			; INCLUDE "mos_api.inc"	; In MOS/src
044664             11451  
044664             11452  			; SEGMENT CODE
044664             11453  
044664             11454  			; XDEF	SOUND
044664             11455  
044664             11456  			; XREF	COMMA
044664             11457  			; XREF	EXPR_W2
044664             11458  			; XREF	XEQ
044664             11459  			; XREF	LTRAP
044664             11460  			; XREF	OSWRCH
044664             11461  			; XREF	VDU_BUFFER
044664             11462  
044664             11463  
044664             11464  ; SOUND channel,volume,pitch,duration
044664             11465  ; volume: 0 (off) to -15 (full volume)
044664             11466  ; pitch: 0 - 255
044664             11467  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
044664             11468  ;
044664 CD EE 43 04 11469  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044668 7D          11470  			LD	A, L 			;  A: Volume
044669 F5          11471  			PUSH	AF
04466A D5          11472  			PUSH	DE
04466B CD 2A 0A 04 11473  			CALL	COMMA
04466F CD EE 43 04 11474  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
044673 53          11475  			LD	D, E			;  D: Pitch
044674 5D          11476  			LD	E, L 			;  E: Duration
044675 E1          11477  			POP	HL 			; HL: Channel/Control
044676 F1          11478  			POP	AF
044677 ED 44       11479  			NEG
044679 FE 10       11480  			CP	16			; Check volume is in bounds
04467B D2 9E 0B 04 11481  			JP	NC, XEQ			; Out of bounds, do nothing
04467F             11482  ;
04467F             11483  ; Store	in VDU vars
04467F             11484  ;
04467F 4F          11485  			LD	C, A			; Store Volume in C
044680 7D          11486  			LD	A, L
044681 32 00 4A 04 11487  			LD	(VDU_BUFFER+0), A	; Channel
044685 AF          11488  			XOR	A
044686 32 01 4A 04 11489  			LD	(VDU_BUFFER+1), A	; Waveform
04468A             11490  ;
04468A             11491  ; Calculate the volume
04468A             11492  ;
04468A 06 06       11493  			LD	B, 6			; C already contains the volume
04468C ED 4C       11494  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
04468E 79          11495  			LD	A, C
04468F 32 02 4A 04 11496  			LD	(VDU_BUFFER+2), A
044693             11497  ;
044693             11498  ; And the frequency
044693             11499  ;
044693 4B          11500  			LD	C, E			; Store duration in C
044694 26 00       11501  			LD	H, 0			; Lookup the frequency
044696 6A          11502  			LD	L, D
044697 11 1E 47 04 11503  			LD	DE, SOUND_FREQ_LOOKUP
04469B 29          11504  			ADD	HL, HL
04469C 19          11505  			ADD	HL, DE
04469D 7E          11506  			LD	A, (HL)
04469E 32 03 4A 04 11507  			LD	(VDU_BUFFER+3), A
0446A2 23          11508  			INC	HL
0446A3 7E          11509  			LD	A, (HL)
0446A4 32 04 4A 04 11510  			LD	(VDU_BUFFER+4), A
0446A8             11511  ;
0446A8             11512  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0446A8             11513  ;
0446A8 06 32       11514  			LD	B, 50			; C contains the duration, so MLT by 50
0446AA ED 4C       11515  			MLT	BC
0446AC ED 43 05 4A 11516  			LD	(VDU_BUFFER+5), BC
       04          
0446B1             11517  ;
0446B1 DD E5       11518  			PUSH	IX			; Get the system vars in IX
0446B3             11519  			MOSCALL	mos_sysvars		; Reset the semaphore
0446B3 3E 08       0001M 			LD	A, function
0446B5 49 CF       0002M 			RST.LIS	08h
0446B7 5B DD CB 04 11520  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0446BC             11521  ;
0446BC             11522  			VDU	23			; Send the sound command
0446BC 3E 17       0001M 		LD	A, val
0446BE CD 38 3F 04 0002M 		CALL	OSWRCH
0446C2             11523  			VDU	0
0446C2 3E 00       0001M 		LD	A, val
0446C4 CD 38 3F 04 0002M 		CALL	OSWRCH
0446C8             11524  			VDU	vdp_audio
0446C8 3E 85       0001M 		LD	A, val
0446CA CD 38 3F 04 0002M 		CALL	OSWRCH
0446CE             11525  			VDU	(VDU_BUFFER+0)		; 0: Channel
0446CE 3A 00 4A 04 0001M 		LD	A, val
0446D2 CD 38 3F 04 0002M 		CALL	OSWRCH
0446D6             11526  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446D6 3A 01 4A 04 0001M 		LD	A, val
0446DA CD 38 3F 04 0002M 		CALL	OSWRCH
0446DE             11527  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446DE 3A 02 4A 04 0001M 		LD	A, val
0446E2 CD 38 3F 04 0002M 		CALL	OSWRCH
0446E6             11528  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446E6 3A 03 4A 04 0001M 		LD	A, val
0446EA CD 38 3F 04 0002M 		CALL	OSWRCH
0446EE             11529  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446EE 3A 04 4A 04 0001M 		LD	A, val
0446F2 CD 38 3F 04 0002M 		CALL	OSWRCH
0446F6             11530  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0446F6 3A 05 4A 04 0001M 		LD	A, val
0446FA CD 38 3F 04 0002M 		CALL	OSWRCH
0446FE             11531  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0446FE 3A 06 4A 04 0001M 		LD	A, val
044702 CD 38 3F 04 0002M 		CALL	OSWRCH
044706             11532  ;
044706             11533  ; Wait for acknowledgement
044706             11534  ;
044706 5B DD CB 04 11535  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
04470B 28 F9       11536  			JR	Z, @B			; Wait for the result
04470D CD A9 3F 04 11537  			CALL	LTRAP			; Check for ESC
044711 5B DD 7E 0E 11538  			LD.LIL	A, (IX+sysvar_audioSuccess)
044715 A7          11539  			AND	A			; Check if VDP has queued the note
044716 28 9F       11540  			JR	Z, SOUND0		; No, so loop back and send again
044718             11541  ;
044718 DD E1       11542  			POP	IX
04471A C3 9E 0B 04 11543  			JP	XEQ
04471E             11544  
04471E             11545  ; Frequency Lookup Table
04471E             11546  ; Set up to replicate the BBC Micro audio frequencies
04471E             11547  ;
04471E             11548  ; Split over 5 complete octaves, with 53 being middle C
04471E             11549  ; * C4: 262hz
04471E             11550  ; + A4: 440hz
04471E             11551  ;
04471E             11552  ;	2	3	4	5	6	7	8
04471E             11553  ;
04471E             11554  ; B	1	49	97	145	193	241
04471E             11555  ; A#	0	45	93	141	189	237
04471E             11556  ; A		41	89+	137	185	233
04471E             11557  ; G#		37	85	133	181	229
04471E             11558  ; G		33	81	129	177	225
04471E             11559  ; F#		29	77	125	173	221
04471E             11560  ; F		25	73	121	169	217
04471E             11561  ; E		21	69	117	165	213
04471E             11562  ; D#		17	65	113	161	209
04471E             11563  ; D		13	61	109	157	205	253
04471E             11564  ; C#		9	57	105	153	201	249
04471E             11565  ; C		5	53*	101	149	197	245
04471E             11566  ;
04471E 75 00 76 00 11567  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
04472E 89 00 8B 00 11568  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
04473E 99 00 9C 00 11569  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
04474E AC 00 AF 00 11570  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
04475E C1 00 C4 00 11571  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
04476E D9 00 DC 00 11572  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
04477E F3 00 F7 00 11573  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
04478E 11 01 15 01 11574  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
04479E 33 01 37 01 11575  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0447AE 58 01 5D 01 11576  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0447BE 82 01 88 01 11577  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0447CE B2 01 B8 01 11578  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447DE E7 01 EE 01 11579  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0447EE 22 02 2A 02 11580  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0447FE 65 02 6E 02 11581  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
04480E B1 02 BB 02 11582  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
04481E 05 03 10 03 11583  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
04482E 63 03 70 03 11584  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
04483E CE 03 DC 03 11585  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
04484E 45 04 55 04 11586  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
04485E CB 04 DD 04 11587  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
04486E 62 05 76 05 11588  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
04487E 0A 06 21 06 11589  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
04488E C8 06 E1 06 11590  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
04489E 9C 07 B8 07 11591  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0448AE 8A 08 A9 08 11592  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0448BE 95 09 B9 09 11593  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0448CE C2 0A EA 0A 11594  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448DE 13 0C 40 0C 11595  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0448EE 8E 0D C0 0D 11596  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0448FE 36 0F 6F 0F 11597  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
04490E 13 11 53 11 11598  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
04491E             11599  
04491E             11600  
04491E             11601  ; --- End agon_sound.asm ---
04491E             11602  
04491E             11603  ; --- Begin interrupts.asm ---
04491E             11604  ;
04491E             11605  ; Title:	BBC Basic for AGON - Interrupts
04491E             11606  ; Author:	Dean Belfield
04491E             11607  ; Created:	12/05/2023
04491E             11608  ; Last Updated:	07/06/2023
04491E             11609  ;
04491E             11610  ; Modinfo:
04491E             11611  ; 07/06/2023:	Modified to run in ADL mode
04491E             11612  
04491E             11613  			; .ASSUME	ADL = 1
04491E             11614  
04491E             11615  			; INCLUDE	"macros.inc"
04491E             11616  			; INCLUDE	"equs.inc"
04491E             11617  			; INCLUDE "mos_api.inc"	; In MOS/src
04491E             11618  
04491E             11619  			; SEGMENT CODE
04491E             11620  
04491E             11621  			; XDEF	VBLANK_INIT
04491E             11622  			; XDEF	VBLANK_STOP
04491E             11623  			; XDEF	VBLANK_HANDLER
04491E             11624  
04491E             11625  			; XREF	ESCSET
04491E             11626  			; XREF	KEYDOWN		; In ram.asm
04491E             11627  			; XREF	KEYASCII 	; In ram.asm
04491E             11628  			; XREF	KEYCOUNT	; In ram.asm
04491E             11629  
04491E             11630  ; Hook into the MOS VBLANK interrupt
04491E             11631  ;
04491E F3          11632  VBLANK_INIT:		DI
04491F 21 73 49 04 11633  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044923 1E 32       11634  			LD		E, 32h				; Set up the VBlank Interrupt Vector
044925             11635  			MOSCALL		mos_setintvector
044925 3E 14       0001M 			LD	A, function
044927 49 CF       0002M 			RST.LIS	08h
044929             11636  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044929 EB          11637  			ex de,hl
04492A 21 81 49 04 11638  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04492E ED 1F       11639  			LD		(HL), DE			; Self-modify the code
044930 FB          11640  			EI
044931 C9          11641  			RET
044932             11642  
044932             11643  ; Unhook the custom VBLANK interrupt
044932             11644  ;
044932 F3          11645  VBLANK_STOP:		DI
044933 21 81 49 04 11646  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044937 ED 17       11647  			LD		DE, (HL)
044939 EB          11648  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
04493A 1E 32       11649  			LD		E, 32h
04493C             11650  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
04493C 3E 14       0001M 			LD	A, function
04493E 49 CF       0002M 			RST.LIS	08h
044940 FB          11651  			EI
044941 C9          11652  			RET
044942             11653  
044942             11654  ; A safe LIS call to ESCSET
044942             11655  ;
044942             11656  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044942 3E 08       0001M 			LD	A, function
044944 49 CF       0002M 			RST.LIS	08h
044946 21 49 4D 04 11657  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04494A DD 7E 19    11658  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04494D BE          11659  			CP 		(HL)				; with our local copy
04494E 20 0A       11660  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044950             11661  ;
044950 AF          11662  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044951 32 48 4D 04 11663  			LD		(KEYASCII), A
044955 32 47 4D 04 11664  			LD		(KEYDOWN), A
044959 C9          11665  			RET	 					; And return
04495A             11666  ;
04495A 77          11667  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04495B DD 7E 18    11668  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
04495E B7          11669  			OR		A
04495F 28 EF       11670  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044961             11671  ;
044961 32 47 4D 04 11672  			LD		(KEYDOWN), A 			; Store the keydown value
044965 DD 7E 05    11673  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044968 32 48 4D 04 11674  			LD		(KEYASCII), A 			; Store locally
04496C FE 1B       11675  			CP		1Bh				; Is it escape?
04496E CC 84 3F 04 11676  			CALL		Z, ESCSET			; Yes, so set the escape flags
044972 C9          11677  			RET						; Return to the interrupt handler
044973             11678  
044973 F3          11679  VBLANK_HANDLER:		DI
044974 F5          11680  			PUSH		AF
044975 E5          11681  			PUSH		HL
044976 DD E5       11682  			PUSH		IX
044978 CD 42 49 04 11683  			CALL		DO_KEYBOARD
04497C DD E1       11684  			POP		IX
04497E E1          11685  			POP		HL
04497F F1          11686  			POP		AF
044980             11687  ;
044980             11688  ; Finally jump to the MOS interrupt
044980             11689  ;
044980 C3 00 00 00 11690  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044984             11691  
044984             11692  ; --- Begin sorry.asm ---
044984             11693  ;
044984             11694  ; Title:	BBC Basic Interpreter - Z80 version
044984             11695  ;		Catch-all for unimplemented functionality
044984             11696  ; Author:	Dean Belfield
044984             11697  ; Created:	12/05/2023
044984             11698  ; Last Updated:	12/05/2023
044984             11699  ;
044984             11700  ; Modinfo:
044984             11701  
044984             11702  			; .ASSUME	ADL = 1
044984             11703  
044984             11704  			; SEGMENT CODE
044984             11705  
044984             11706  			; XDEF	ENVEL
044984             11707  			; XDEF	ADVAL
044984             11708  			; XDEF	PUTIMS
044984             11709  
044984             11710  			; XREF	EXTERR
044984             11711  
044984             11712  ENVEL:
044984             11713  ADVAL:
044984             11714  PUTIMS:
044984 AF          11715  			XOR     A
044985 CD AF 37 04 11716  			CALL    EXTERR
044989 53 6F 72 72 11717  			DEFB    "Sorry"
       79          
04498E 00          11718  			DEFB    0
04498F             11719  ; --- End sorry.asm ---
04498F             11720  
04498F             11721  ; --- Begin ram.asm ---
04498F             11722  ;
04498F             11723  ; Title:	BBC Basic Interpreter - Z80 version
04498F             11724  ;		RAM Module for BBC Basic Interpreter
04498F             11725  ;		For use with Version 2.0 of BBC BASIC
04498F             11726  ;		Standard CP/M Distribution Version
04498F             11727  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
04498F             11728  ; Modified By:	Dean Belfield
04498F             11729  ; Created:	12/05/2023
04498F             11730  ; Last Updated:	26/06/2023
04498F             11731  ;
04498F             11732  ; Modinfo:
04498F             11733  ; 06/06/2023:	Modified to run in ADL mode
04498F             11734  ; 26/06/2023:	Added temporary stores R0 and R1
04498F             11735  
04498F             11736  			; .ASSUME	ADL = 1
04498F             11737  
04498F             11738  			; DEFINE	LORAM, SPACE = ROM
04498F             11739  			; SEGMENT LORAM
04498F             11740  
04498F             11741  			; XDEF	ACCS
04498F             11742  			; XDEF	BUFFER
04498F             11743  			; XDEF	STAVAR
04498F             11744  			; XDEF	DYNVAR
04498F             11745  			; XDEF	FNPTR
04498F             11746  			; XDEF	PROPTR
04498F             11747  			; XDEF	PAGE_
04498F             11748  			; XDEF	TOP
04498F             11749  			; XDEF	LOMEM
04498F             11750  			; XDEF 	FREE
04498F             11751  			; XDEF	HIMEM
04498F             11752  			; XDEF	LINENO
04498F             11753  			; XDEF	TRACEN
04498F             11754  			; XDEF	AUTONO
04498F             11755  			; XDEF	ERRTRP
04498F             11756  			; XDEF	ERRTXT
04498F             11757  			; XDEF	DATPTR
04498F             11758  			; XDEF	ERL
04498F             11759  			; XDEF	ERRLIN
04498F             11760  			; XDEF	RANDOM
04498F             11761  			; XDEF	COUNT
04498F             11762  			; XDEF	WIDTH
04498F             11763  			; XDEF	ERR
04498F             11764  			; XDEF	LISTON
04498F             11765  			; XDEF	INCREM
04498F             11766  
04498F             11767  			; XDEF	FLAGS
04498F             11768  			; XDEF	OSWRCHPT
04498F             11769  			; XDEF	OSWRCHCH
04498F             11770  			; XDEF	OSWRCHFH
04498F             11771  			; XDEF	KEYDOWN
04498F             11772  			; XDEF	KEYASCII
04498F             11773  			; XDEF	KEYCOUNT
04498F             11774  
04498F             11775  			; XDEF	R0
04498F             11776  			; XDEF	R1
04498F             11777  
04498F             11778  			; XDEF	RAM_START
04498F             11779  			; XDEF	RAM_END
04498F             11780  			; XDEF	USER
04498F             11781  
04498F FF FF FF FF 11782  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
044A00             11783  RAM_START:
044A00             11784  ;
044A00 00 00 00 00 11785  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 11786  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 11787  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 11788  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    11789  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    11790  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             11791  ;
044D14 00 00 00    11792  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    11793  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    11794  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    11795  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    11796  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             11797  ;
044D23 00 00 00    11798  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    11799  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    11800  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    11801  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       11802  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       11803  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       11804  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    11805  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 11806  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          11807  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          11808  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          11809  ERR:            BLKB    1,0               ; Error Number
044D40 00          11810  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             11811                                  ; - BIT 0: If set, output a space after the line number
044D41             11812                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             11813                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             11814                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             11815                                  ; OPT FLAG (top nibble)
044D41             11816                                  ; - BIT 4: If set, then list whilst assembling
044D41             11817                                  ; - BIT 5: If set, then assembler errors are reported
044D41             11818                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             11819                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          11820  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             11821  ;
044D42             11822  ; --------------------------------------------------------------------------------------------
044D42             11823  ; BEGIN MODIFIED CODE
044D42             11824  ; --------------------------------------------------------------------------------------------
044D42             11825  ; Originally in equs.inc
044D42             11826  ;
044D42             11827  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
044D42             11828  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
044D42             11829  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044D42             11830  ; --------------------------------------------------------------------------------------------
044D42             11831  ; END MODIFIED CODE
044D42             11832  ; --------------------------------------------------------------------------------------------
044D42             11833  
044D42             11834  ; Extra Agon-implementation specific system variables
044D42             11835  ;
044D42 00          11836  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             11837                                  ; - BIT 7: Set if ESC pressed
044D43             11838                                  ; - BIT 6: Set to disable ESC
044D43 00 00       11839  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          11840  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             11841                                  ; - 0: Console
044D46             11842                                  ; - 1: File
044D46 00          11843  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          11844  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          11845  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          11846  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    11847  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    11848  R1:             BLKB    3,0
044D50             11849  
044D50             11850  ;
044D50             11851  ; This must be at the end
044D50             11852  ;
044D50             11853  RAM_END:
044D50 FF FF FF FF 11854  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
044E00             11855  USER:							; Must be aligned on a page boundary
044E00             11856  	; --- End ram.asm ---
044E00             11857  
