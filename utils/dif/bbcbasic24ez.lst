PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modinfo:
040000             0009  ; 05/08/2022:	Added mos_feof
040000             0010  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0011  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0012  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0013  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0014  ; 13/10/2022:	Added mos_oscli
040000             0015  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0016  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0017  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0018  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0019  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0020  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0021  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0022  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0023  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0024  ; 19/05/2023:	Added sysvar_scrMode
040000             0025  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0026  ; 03/08/2023:	Added mos_setkbvector
040000             0027  ; 10/08/2023:	Added mos_getkbmap
040000             0028  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0029  
040000             0030  ; VDP control (VDU 23, 0, n)
040000             0031  ;
040000             0032  vdp_gp:			EQU 	80h
040000             0033  vdp_keycode:		EQU 	81h
040000             0034  vdp_cursor:		EQU	82h
040000             0035  vdp_scrchar:		EQU	83h
040000             0036  vdp_scrpixel:		EQU	84h
040000             0037  vdp_audio:		EQU	85h
040000             0038  vdp_mode:		EQU	86h
040000             0039  vdp_rtc:		EQU	87h
040000             0040  vdp_keystate:		EQU	88h
040000             0041  vdp_logicalcoords:	EQU	C0h
040000             0042  vdp_terminalmode:	EQU	FFh
040000             0043  
040000             0044  ; MOS high level functions
040000             0045  ;
040000             0046  mos_getkey:		EQU	00h
040000             0047  mos_load:		EQU	01h
040000             0048  mos_save:		EQU	02h
040000             0049  mos_cd:			EQU	03h
040000             0050  mos_dir:		EQU	04h
040000             0051  mos_del:		EQU	05h
040000             0052  mos_ren:		EQU	06h
040000             0053  mos_mkdir:		EQU	07h
040000             0054  mos_sysvars:		EQU	08h
040000             0055  mos_editline:		EQU	09h
040000             0056  mos_fopen:		EQU	0Ah
040000             0057  mos_fclose:		EQU	0Bh
040000             0058  mos_fgetc:		EQU	0Ch
040000             0059  mos_fputc:		EQU	0Dh
040000             0060  mos_feof:		EQU	0Eh
040000             0061  mos_getError:		EQU	0Fh
040000             0062  mos_oscli:		EQU	10h
040000             0063  mos_copy:		EQU	11h
040000             0064  mos_getrtc:		EQU	12h
040000             0065  mos_setrtc:		EQU	13h
040000             0066  mos_setintvector:	EQU	14h
040000             0067  mos_uopen:		EQU	15h
040000             0068  mos_uclose:		EQU	16h
040000             0069  mos_ugetc:		EQU	17h
040000             0070  mos_uputc:		EQU 	18h
040000             0071  mos_getfil:		EQU	19h
040000             0072  mos_fread:		EQU	1Ah
040000             0073  mos_fwrite:		EQU	1Bh
040000             0074  mos_flseek:		EQU	1Ch
040000             0075  mos_setkbvector:	EQU	1Dh
040000             0076  mos_getkbmap:		EQU	1Eh
040000             0077  mos_i2c_open:		EQU	1Fh
040000             0078  mos_i2c_close:		EQU	20h
040000             0079  mos_i2c_write:		EQU	21h
040000             0080  mos_i2c_read:		EQU	22h
040000             0081  
040000             0082  
040000             0083  ; FatFS file access functions
040000             0084  ;
040000             0085  ffs_fopen:		EQU	80h
040000             0086  ffs_fclose:		EQU	81h
040000             0087  ffs_fread:		EQU	82h
040000             0088  ffs_fwrite:		EQU	83h
040000             0089  ffs_flseek:		EQU	84h
040000             0090  ffs_ftruncate:		EQU	85h
040000             0091  ffs_fsync:		EQU	86h
040000             0092  ffs_fforward:		EQU	87h
040000             0093  ffs_fexpand:		EQU	88h
040000             0094  ffs_fgets:		EQU	89h
040000             0095  ffs_fputc:		EQU	8Ah
040000             0096  ffs_fputs:		EQU	8Bh
040000             0097  ffs_fprintf:		EQU	8Ch
040000             0098  ffs_ftell:		EQU	8Dh
040000             0099  ffs_feof:		EQU	8Eh
040000             0100  ffs_fsize:		EQU	8Fh
040000             0101  ffs_ferror:		EQU	90h
040000             0102  
040000             0103  ; FatFS directory access functions
040000             0104  ;
040000             0105  ffs_dopen:		EQU	91h
040000             0106  ffs_dclose:		EQU	92h
040000             0107  ffs_dread:		EQU	93h
040000             0108  ffs_dfindfirst:		EQU	94h
040000             0109  ffs_dfindnext:		EQU	95h
040000             0110  
040000             0111  ; FatFS file and directory management functions
040000             0112  ;
040000             0113  ffs_stat:		EQU	96h
040000             0114  ffs_unlink:		EQU	97h
040000             0115  ffs_rename:		EQU	98h
040000             0116  ffs_chmod:		EQU	99h
040000             0117  ffs_utime:		EQU	9Ah
040000             0118  ffs_mkdir:		EQU	9Bh
040000             0119  ffs_chdir:		EQU	9Ch
040000             0120  ffs_chdrive:		EQU	9Dh
040000             0121  ffs_getcwd:		EQU	9Eh
040000             0122  
040000             0123  ; FatFS volume management and system configuration functions
040000             0124  ;
040000             0125  ffs_mount:		EQU	9Fh
040000             0126  ffs_mkfs:		EQU	A0h
040000             0127  ffs_fdisk:		EQU	A1h
040000             0128  ffs_getfree:		EQU	A2h
040000             0129  ffs_getlabel:		EQU	A3h
040000             0130  ffs_setlabel:		EQU	A4h
040000             0131  ffs_setcp:		EQU	A5h
040000             0132  
040000             0133  ; File access modes
040000             0134  ;
040000             0135  fa_read:		EQU	01h
040000             0136  fa_write:		EQU	02h
040000             0137  fa_open_existing:	EQU	00h
040000             0138  fa_create_new:		EQU	04h
040000             0139  fa_create_always:	EQU	08h
040000             0140  fa_open_always:		EQU	10h
040000             0141  fa_open_append:		EQU	30h
040000             0142  
040000             0143  ; System variable indexes for api_sysvars
040000             0144  ; Index into _sysvars in globals.asm
040000             0145  ;
040000             0146  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0147  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0148  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0149  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0150  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0151  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0152  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0153  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0154  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0155  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0156  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0157  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0158  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0159  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0160  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0161  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0162  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0163  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0164  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0165  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0166  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0167  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0168  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0169  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0170  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0171  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0172  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0173  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0174  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0175  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0176  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0177  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0178  
040000             0179  ; Flags for the VPD protocol
040000             0180  ;
040000             0181  vdp_pflag_cursor:	EQU	00000001b
040000             0182  vdp_pflag_scrchar:	EQU	00000010b
040000             0183  vdp_pflag_point:	EQU	00000100b
040000             0184  vdp_pflag_audio:	EQU	00001000b
040000             0185  vdp_pflag_mode:		EQU	00010000b
040000             0186  vdp_pflag_rtc:		EQU	00100000b
040000             0187  vdp_pflag_mouse:	EQU	01000000b
040000             0188  ; vdp_pflag_buffered:	EQU	10000000b
040000             0189  
040000             0190  ;
040000             0191  ; FatFS structures
040000             0192  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0193  ;
040000             0194  ; Object ID and allocation information (FFOBJID)
040000             0195  ;
040000             0196  ; FFOBJID	.STRUCT
040000             0197  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0198  ; 	id:		DS	2	; Hosting volume mount ID
040000             0199  ; 	attr:		DS	1	; Object attribute
040000             0200  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0201  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0202  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0203  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0204  ; ;
040000             0205  ; ; File object structure (FIL)
040000             0206  ; ;
040000             0207  ; FIL .STRUCT
040000             0208  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0209  ; 	flag:		DS	1	; File status flags
040000             0210  ; 	err:		DS	1	; Abort flag (error code)
040000             0211  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0212  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0213  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0214  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0215  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0216  ; FIL_SIZE .ENDSTRUCT FIL
040000             0217  ; ;
040000             0218  ; ; Directory object structure (DIR)
040000             0219  ; ;
040000             0220  ; DIR .STRUCT
040000             0221  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0222  ; 	dptr:		DS	4	; Current read/write offset
040000             0223  ; 	clust:		DS	4	; Current cluster
040000             0224  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0225  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0226  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0227  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0228  ; DIR_SIZE .ENDSTRUCT DIR
040000             0229  ; ;
040000             0230  ; ; File information structure (FILINFO)
040000             0231  ; ;
040000             0232  ; FILINFO .STRUCT
040000             0233  ; 	fsize:		DS 	4	; File size
040000             0234  ; 	fdate:		DS	2	; Modified date
040000             0235  ; 	ftime:		DS	2	; Modified time
040000             0236  ; 	fattrib:	DS	1	; File attribute
040000             0237  ; 	altname:	DS	13	; Alternative file name
040000             0238  ; 	fname:		DS	256	; Primary file name
040000             0239  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0240  
040000             0241  ; FFOBJID offsets
040000             0242  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0243  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0244  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0245  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0246  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0247  FFOBJID.objsize:  EQU 11   ; Object size
040000             0248  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0249  
040000             0250  ; FIL offsets (including FFOBJID fields)
040000             0251  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0252  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0253  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0254  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0255  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0256  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0257  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0258  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0259  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0260  
040000             0261  ; DIR offsets (including FFOBJID fields)
040000             0262  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0263  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0264  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0265  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0266  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0267  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0268  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0269  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0270  
040000             0271  ; FILINFO offsets
040000             0272  FILINFO.fsize:    EQU 0    ; File size
040000             0273  FILINFO.fdate:    EQU 4    ; Modified date
040000             0274  FILINFO.ftime:    EQU 6    ; Modified time
040000             0275  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0276  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0277  FILINFO.fname:    EQU 22   ; Primary file name
040000             0278  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0279  
040000             0280  ;
040000             0281  ; Macro for calling the API
040000             0282  ; Parameters:
040000             0283  ; - function: One of the function numbers listed above
040000             0284  ;
040000             0285  			MACRO MOSCALL	function
040000             0286  			LD	A, function
040000             0287  			RST.LIS	08h
040000             0288  			ENDMACRO 	; --- End mos_api.inc ---
040000             0289  
040000             0290  ; --- Begin macros.inc ---
040000             0291  	; Title:	BBC Basic Interpreter - Z80 version
040000             0292  	;		Useful macros
040000             0293  	; Author:	Dean Belfield
040000             0294  	; Created:	12/05/2023
040000             0295  	; Last Updated:	11/06/2023
040000             0296  	;
040000             0297  	; Modinfo:
040000             0298  	; 11/06/2023:	Modified to run in ADL mode
040000             0299  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0300  
040000             0301  	MACRO EXREG	rp1, rp2
040000             0302  		PUSH	rp1
040000             0303  		POP	rp2
040000             0304  	ENDMACRO
040000             0305  
040000             0306  	; MACRO ADD8U_DE	reg
040000             0307  		MACRO ADD8U_DE
040000             0308  		ADD	A, E
040000             0309  		LD	E, A
040000             0310  		ADC	A, D
040000             0311  		SUB	E
040000             0312  		LD	D, A
040000             0313  	ENDMACRO
040000             0314  
040000             0315  	; MACRO ADD8U_HL	reg
040000             0316  	MACRO ADD8U_HL
040000             0317  		ADD	A, L
040000             0318  		LD	L, A
040000             0319  		ADC	A, H
040000             0320  		SUB	L
040000             0321  		LD	H, A
040000             0322  	ENDMACRO
040000             0323  
040000             0324  	MACRO VDU	val
040000             0325  		LD	A, val
040000             0326  		CALL	OSWRCH
040000             0327  	ENDMACRO
040000             0328  
040000             0329  	MACRO SET_GPIO	reg, val
040000             0330  		IN0	A, (reg)
040000             0331  		OR	val
040000             0332  		OUT0	(reg), A
040000             0333  	ENDMACRO
040000             0334  
040000             0335  	MACRO RES_GPIO	reg, val
040000             0336  		PUSH	BC
040000             0337  		LD	A, val
040000             0338  		CPL
040000             0339  		LD	C, A
040000             0340  		IN0	A, (reg)
040000             0341  		AND	C
040000             0342  		OUT0	(reg), A
040000             0343  		POP	BC
040000             0344  	ENDMACRO
040000             0345  ; --- End macros.inc ---
040000             0346  
040000             0347  ; --- Begin equs.inc ---
040000             0348  ;
040000             0349  ; Title:	BBC Basic for AGON - Equs
040000             0350  ; Author:	Dean Belfield
040000             0351  ; Created:	12/05/2023
040000             0352  ; Last Updated:	08/06/2023
040000             0353  ;
040000             0354  ; Modinfo:
040000             0355  ; 08/06/2023:	Added SIZEW
040000             0356  
040000             0357  			; XREF		STAVAR
040000             0358  			; XREF		ACCS
040000             0359  
040000             0360  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0361  ;Stack_Top:		EQU		0000h	; Stack at top
040000             0362  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0363  
040000             0364  ; For GPIO
040000             0365  ; PA not available on eZ80L92
040000             0366  ;
040000             0367  PA_DR:			EQU		96h
040000             0368  PA_DDR:			EQU		97h
040000             0369  PA_ALT1:		EQU		98h
040000             0370  PA_ALT2:		EQU		99h
040000             0371  PB_DR:          	EQU		9Ah
040000             0372  PB_DDR:        	 	EQU		9Bh
040000             0373  PB_ALT1:        	EQU		9Ch
040000             0374  PB_ALT2:        	EQU		9Dh
040000             0375  PC_DR:          	EQU		9Eh
040000             0376  PC_DDR:         	EQU		9Fh
040000             0377  PC_ALT1:        	EQU		A0h
040000             0378  PC_ALT2:        	EQU		A1h
040000             0379  PD_DR:          	EQU		A2h
040000             0380  PD_DDR:			EQU		A3h
040000             0381  PD_ALT1:		EQU		A4h
040000             0382  PD_ALT2:		EQU		A5h
040000             0383  
040000             0384  GPIOMODE_OUT:		EQU		0	; Output
040000             0385  GPIOMODE_IN:		EQU		1	; Input
040000             0386  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0387  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0388  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0389  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0390  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0391  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0392  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0393  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0394  
040000             0395  ; ; Originally in ram.asm
040000             0396  ; ;
040000             0397  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040000             0398  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040000             0399  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040000             0400  
040000             0401  ; Originally in main.asm
040000             0402  ;
040000             0403  CR:			EQU     0DH
040000             0404  LF:			EQU     0AH
040000             0405  ESC:			EQU     1BH
040000             0406  ; --- End equs.inc ---
040000             0407  
040000             0408  ; --- Begin init.asm ---
040000             0409  ;
040000             0410  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0411  ;		Initialisation Code
040000             0412  ; Author:	Dean Belfield
040000             0413  ; Created:	12/05/2023
040000             0414  ; Last Updated:	26/11/2023
040000             0415  ;
040000             0416  ; Modinfo:
040000             0417  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0418  ; 26/11/2023:	Moved the ram clear routine into here
040000             0419  
040000             0420  			; SEGMENT CODE
040000             0421  
040000             0422  			; XDEF	_end
040000             0423  
040000             0424  			; XREF	_main				; In main.asm
040000             0425  
040000             0426  			; XREF	RAM_START			; In ram.asm
040000             0427  			; XREF	RAM_END
040000             0428  
040000             0429  			; .ASSUME	ADL = 1
040000             0430  
040000             0431  			; INCLUDE	"equs.inc"
040000             0432  
040000             0433  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0434  
040000             0435  ;
040000             0436  ; Start in ADL mode
040000             0437  ;
040000 C3 45 00 04 0438  			JP	_start				; Jump to start
040004             0439  ;
040004             0440  ; The header stuff is from byte 64 onwards
040004             0441  ;
040004 42 42 43 42 0442  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040011             0443  
040011 FF FF FF FF 0444  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0445  
040040 4D 4F 53    0446  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0447  			DB	00h				; MOS header version 0
040044 01          0448  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0449  ;
040045             0450  ; And the code follows on immediately after the header
040045             0451  ;
040045 F5          0452  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0453  			PUSH		BC
040047 D5          0454  			PUSH		DE
040048 DD E5       0455  			PUSH		IX
04004A FD E5       0456  			PUSH		IY
04004C             0457  
04004C ED 73 D7 00 0458  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0459  
040051 DD 21 DA 00 0460  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0461  			PUSH		IX
040058 CD 88 00 04 0462  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0463  			POP		IX			; IX: argv
04005E 06 00       0464  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0465  			CALL		_clear_ram
040064 C3 B6 2F 04 0466  			JP		_main			; Start user code
040068             0467  ;
040068             0468  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0469  ;
040068 ED 7B D7 00 0470  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0471  
04006D FD E1       0472  			POP		IY			; Restore the registers
04006F DD E1       0473  			POP		IX
040071 D1          0474  			POP		DE
040072 C1          0475  			POP		BC
040073 F1          0476  			POP		AF
040074 C9          0477  			RET					; Return to MOS
040075             0478  
040075             0479  ;Clear the application memory
040075             0480  ;
040075 C5          0481  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0482  			LD		HL, RAM_START
04007A 11 01 4A 04 0483  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0484  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0485  			XOR		A
040083 77          0486  			LD		(HL), A
040084 ED B0       0487  			LDIR
040086 C1          0488  			POP		BC
040087 C9          0489  			RET
040088             0490  
040088             0491  ; Parse the parameter string into a C array
040088             0492  ; Parameters
040088             0493  ; - HL: Address of parameter string
040088             0494  ; - IX: Address for array pointer storage
040088             0495  ; Returns:
040088             0496  ; -  C: Number of parameters parsed
040088             0497  ;
040088 01 04 00 04 0498  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0499  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0500  			INC	IX
040091 DD 23       0501  			INC	IX
040093 DD 23       0502  			INC	IX
040095 CD D0 00 04 0503  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0504  ;
040099 01 01 00 00 0505  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0506  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0507  ;
04009F             0508  _parse_params_1:
04009F C5          0509  			PUSH	BC			; Stack ARGC
0400A0 E5          0510  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0511  			CALL	_get_token		; Get the next token
0400A5 79          0512  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0513  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0514  			POP	BC			; ARGC
0400A8 B7          0515  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0516  			RET	Z
0400AA             0517  ;
0400AA DD 1F 00    0518  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0519  			PUSH	HL			; DE=HL
0400AE D1          0520  			POP	DE
0400AF CD D0 00 04 0521  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0522  			XOR	A
0400B4 12          0523  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0524  			INC	IX
0400B7 DD 23       0525  			INC	IX
0400B9 DD 23       0526  			INC	IX			; Advance to next pointer position
0400BB 0C          0527  			INC	C			; Increment ARGC
0400BC 79          0528  			LD	A, C			; Check for C >= A
0400BD B8          0529  			CP	B
0400BE 38 DF       0530  			JR	C, _parse_params_1	; And loop
0400C0 C9          0531  			RET
0400C1             0532  
0400C1             0533  ; Get the next token
0400C1             0534  ; Parameters:
0400C1             0535  ; - HL: Address of parameter string
0400C1             0536  ; Returns:
0400C1             0537  ; - HL: Address of first character after token
0400C1             0538  ; -  C: Length of token (in characters)
0400C1             0539  ;
0400C1 0E 00       0540  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0541  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0542  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0543  			RET 	Z
0400C6 FE 0D       0544  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0545  			RET	Z
0400C9 FE 20       0546  			CP	' '			; Exit if space (end of token)
0400CB C8          0547  			RET	Z
0400CC 23          0548  			INC	HL			; Advance to next character
0400CD 0C          0549  			INC 	C			; Increment length
0400CE 18 F3       0550  			JR	@B
0400D0             0551  
0400D0             0552  ; Skip spaces in the parameter string
0400D0             0553  ; Parameters:
0400D0             0554  ; - HL: Address of parameter string
0400D0             0555  ; Returns:
0400D0             0556  ; - HL: Address of next none-space character
0400D0             0557  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0558  ;
0400D0 7E          0559  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0560  			CP	' '			; Exit if not space
0400D3 C0          0561  			RET	NZ
0400D4 23          0562  			INC	HL			; Advance to next character
0400D5 18 F9       0563  			JR	_skip_spaces		; Increment length
0400D7             0564  
0400D7             0565  ; Storage
0400D7             0566  ;
0400D7             0567  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0568  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0569  
04010A             0570  ; --- Begin eval.asm ---
04010A             0571  ;
04010A             0572  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0573  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0574  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0575  ; Modified By:	Dean Belfield
04010A             0576  ; Created:	12/05/2023
04010A             0577  ; Last Updated:	17/08/2023
04010A             0578  ;
04010A             0579  ; Modinfo:
04010A             0580  ; 07/06/2023:	Modified to run in ADL mode
04010A             0581  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0582  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0583  ; 17/08/2023:	Added binary constants
04010A             0584  
04010A             0585  			; .ASSUME	ADL = 1
04010A             0586  
04010A             0587  			; INCLUDE	"equs.inc"
04010A             0588  			; INCLUDE "macros.inc"
04010A             0589  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0590  
04010A             0591  			; SEGMENT CODE
04010A             0592  
04010A             0593  			; XDEF	EXPR
04010A             0594  			; XDEF	EXPRN
04010A             0595  			; XDEF	EXPRI
04010A             0596  			; XDEF	EXPRS
04010A             0597  			; XDEF	ITEMI
04010A             0598  			; XDEF	LOADN
04010A             0599  			; XDEF	LOAD4
04010A             0600  			; XDEF	CONS
04010A             0601  			; XDEF	LOADS
04010A             0602  			; XDEF	SFIX
04010A             0603  			; XDEF	VAL0
04010A             0604  			; XDEF	SEARCH
04010A             0605  			; XDEF	SWAP
04010A             0606  			; XDEF	TEST
04010A             0607  			; XDEF	DECODE
04010A             0608  			; XDEF	HEXSTR
04010A             0609  			; XDEF	STR
04010A             0610  			; XDEF	ZERO
04010A             0611  			; XDEF	PUSHS
04010A             0612  			; XDEF	POPS
04010A             0613  			; XDEF	COMMA
04010A             0614  			; XDEF	BRAKET
04010A             0615  			; XDEF	NXT
04010A             0616  			; XDEF	COUNT0
04010A             0617  
04010A             0618  			; XREF	ADVAL
04010A             0619  			; XREF	FN_EX
04010A             0620  			; XREF	POINT
04010A             0621  			; XREF	USR
04010A             0622  			; XREF	SYNTAX
04010A             0623  			; XREF	ERROR_
04010A             0624  			; XREF	CHECK
04010A             0625  			; XREF	GETVAR
04010A             0626  			; XREF	LISTON
04010A             0627  			; XREF	RANGE
04010A             0628  			; XREF	FPP
04010A             0629  			; XREF	GETCSR
04010A             0630  			; XREF	CHANEL
04010A             0631  			; XREF	OSSTAT
04010A             0632  			; XREF	OSBGET
04010A             0633  			; XREF	LOMEM
04010A             0634  			; XREF	HIMEM
04010A             0635  			; XREF	PAGE_
04010A             0636  			; XREF	TOP
04010A             0637  			; XREF	ERL
04010A             0638  			; XREF	ERR
04010A             0639  			; XREF	COUNT
04010A             0640  			; XREF	OSOPEN
04010A             0641  			; XREF	GETEXT
04010A             0642  			; XREF	GETPTR
04010A             0643  			; XREF	GETIME
04010A             0644  			; XREF	GETIMS
04010A             0645  			; XREF	LEXAN2
04010A             0646  			; XREF	RANDOM
04010A             0647  			; XREF	STORE5
04010A             0648  			; XREF	GETSCHR
04010A             0649  			; XREF	OSRDCH
04010A             0650  			; XREF	OSKEY
04010A             0651  			; XREF	INKEY1
04010A             0652  			; XREF	EXTERR
04010A             0653  ;
04010A             0654  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0655  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0656  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0657  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0658  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0659  ;
04010A             0660  ; BINARY INTEGER REPRESENTATION:
04010A             0661  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0662  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0663  ;
04010A             0664  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0665  ;                             EXPONENT - C
04010A             0666  ;
04010A             0667  
04010A             0668  ;
04010A             0669  ; Table of addresses for functions
04010A             0670  ;
04010A             0671  FUNTOK:			EQU	8DH			; First token number
04010A             0672  ;
04010A E6 08 04    0673  FUNTBL:			DW24	DECODE			; Line number
04010D 94 05 04    0674  			DW24	OPENIN			; OPENIN
040110 B6 05 04    0675  			DW24	PTR_EV			; PTR
040113 50 05 04    0676  			DW24	PAGEV			; PAGE
040116 C0 05 04    0677  			DW24	TIMEV			; TIME
040119 3C 05 04    0678  			DW24	LOMEMV			; LOMEM
04011C 46 05 04    0679  			DW24	HIMEMV			; HIMEM
04011F 14 06 04    0680  			DW24	ABSV			; ABS
040122 50 06 04    0681  			DW24	ACS			; ACS
040125 46 49 04    0682  			DW24	ADVAL			; ADVAL
040128 25 05 04    0683  			DW24	ASC			; ASC
04012B 48 06 04    0684  			DW24	ASN			; ASN
04012E 4C 06 04    0685  			DW24	ATN			; ATN
040131 EE 04 04    0686  			DW24	BGET			; BGET
040134 34 06 04    0687  			DW24	COS			; COS
040137 7B 05 04    0688  			DW24	COUNTV			; COUNT
04013A 1C 06 04    0689  			DW24	DEG			; DEG
04013D 6F 05 04    0690  			DW24	ERLV			; ERL
040140 75 05 04    0691  			DW24	ERRV			; ERR
040143 79 06 04    0692  			DW24	EVAL_			; EVAL
040146 3C 06 04    0693  			DW24	EXP			; EXP
040149 AC 05 04    0694  			DW24	EXT			; EXT
04014C 93 09 04    0695  			DW24	ZERO			; FALSE
04014F 7F 10 04    0696  			DW24	FN_EX			; FN
040152 0C 05 04    0697  			DW24	GET			; GET
040155 FB 04 04    0698  			DW24	INKEY			; INKEY
040158 2B 07 04    0699  			DW24	INSTR			; INSTR(
04015B 28 06 04    0700  			DW24	INT_			; INT
04015E 35 05 04    0701  			DW24	LEN			; LEN
040161 40 06 04    0702  			DW24	LN			; LN
040164 44 06 04    0703  			DW24	LOG			; LOG
040167 18 06 04    0704  			DW24	NOTK			; NOT
04016A 90 05 04    0705  			DW24	OPENUP			; OPENUP
04016D 8D 05 04    0706  			DW24	OPENOT			; OPENOUT
040170 10 06 04    0707  			DW24	PI			; PI
040173 69 44 04    0708  			DW24	POINT			; POINT(
040176 CD 04 04    0709  			DW24	POS			; POS
040179 20 06 04    0710  			DW24	RAD			; RAD
04017C AD 06 04    0711  			DW24	RND			; RND
04017F 24 06 04    0712  			DW24	SGN			; SGN
040182 38 06 04    0713  			DW24	SIN			; SIN
040185 2C 06 04    0714  			DW24	SQR			; SQR
040188 30 06 04    0715  			DW24	TAN			; TAN
04018B 5A 05 04    0716  			DW24	TOPV			; TO(P)
04018E 05 06 04    0717  			DW24	TRUE			; TRUE
040191 22 15 04    0718  			DW24	USR			; USR
040194 6A 06 04    0719  			DW24	VAL			; VAL
040197 D6 04 04    0720  			DW24	VPOS			; VPOS
04019A BF 07 04    0721  			DW24	CHRS			; CHRS
04019D C7 07 04    0722  			DW24	GETS			; GETS
0401A0 D8 07 04    0723  			DW24	INKEYS			; INKEYS
0401A3 5D 08 04    0724  			DW24	LEFTS			; LEFTS(
0401A6 25 08 04    0725  			DW24	MIDS			; MIDS(
0401A9 7D 08 04    0726  			DW24	RIGHTS			; RIGHTS(
0401AC 4A 09 04    0727  			DW24	STRS			; STR$
0401AF 9E 08 04    0728  			DW24	STRING_			; STRINGS(
0401B2 DE 04 04    0729  			DW24	EOF			; EOF
0401B5             0730  ;
0401B5             0731  FUNTBL_END:		EQU	$
0401B5             0732  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0733  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0734  
0401B5             0735  ANDK:			EQU     80H
0401B5             0736  DIVK:			EQU     81H
0401B5             0737  EORK:			EQU     82H
0401B5             0738  MODK:			EQU     83H
0401B5             0739  ORK:			EQU     84H
0401B5             0740  ;
0401B5 F0 05 04    0741  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 F9 05 04    0742  			DW24	SNE			; <>
0401BB E9 05 04    0743  			DW24	SGE			; >=
0401BE DA 05 04    0744  			DW24	SLT			; <
0401C1 00 06 04    0745  			DW24	SEQ			; =
0401C4 E1 05 04    0746  			DW24	SGT			; >
0401C7             0747  ;
0401C7             0748  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0749  ;     Expression type is returned in A'F':
0401C7             0750  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0751  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0752  ; Floating-point or integer result returned in HLH'L'C
0401C7             0753  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0754  ; String result returned in string accumulator, DE set.
0401C7             0755  ;
0401C7             0756  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0757  ;               (2) ^
0401C7             0758  ;               (3) * / MOD DIV
0401C7             0759  ;               (4) + -
0401C7             0760  ;               (5) = <> <= >= > <
0401C7             0761  ;               (6) AND
0401C7             0762  ;               (7) EOR OR
0401C7             0763  
0401C7             0764  ;
0401C7             0765  ; Level 7: EOR and OR
0401C7             0766  ;
0401C7 CD E0 01 04 0767  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0768  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0769  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0770  			CP      ORK			; Is operator OR
0401D1 C0          0771  			RET     NZ			; No, so return
0401D2             0772  ;
0401D2 CD 3E 0A 04 0773  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0774  			CALL    EXPR1           	; Get second operand
0401DA CD 4D 0A 04 0775  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0776  			JR      EXPR0A          	; And continue
0401E0             0777  ;
0401E0             0778  ; Level 6: AND
0401E0             0779  ;
0401E0 CD F5 01 04 0780  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0781  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0782  			RET     NZ			; No, so return
0401E7 CD 3E 0A 04 0783  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0784  			CALL    EXPR2			; Get second operand
0401EF CD 4D 0A 04 0785  			CALL    DOIT			; Do the operation
0401F3 18 EF       0786  			JR      EXPR1A			; And continue
0401F5             0787  ;
0401F5             0788  ; Level 5: Comparisons
0401F5             0789  ;
0401F5 CD 67 02 04 0790  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 15 0A 04 0791  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0792  			RET     NZ			; No, so return
0401FE 47          0793  			LD      B,A			; Store the first operator in B
0401FF FD 23       0794  			INC     IY              	; Bump over operator
040201 CD 70 0A 04 0795  			CALL    NXT			;
040205 CD 15 0A 04 0796  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0797  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0798  			INC     IY			; Bump over operator
04020D B8          0799  			CP      B			; Compare with first
04020E CA 97 0C 04 0800  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0801  			ADD     A,B
040213 47          0802  			LD      B,A			; B: Unique code for the compound operator
040214 78          0803  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0804  			EX      AF,AF'
040216 FA 30 02 04 0805  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0806  			EX      AF,AF'
04021B D6 04       0807  			SUB     4
04021D FE 3A       0808  			CP      '>'-4
04021F 20 02       0809  			JR      NZ,EXPR2C
040221 C6 02       0810  			ADD     A,2
040223 CD 40 0A 04 0811  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0812  			CALL    EXPR3
04022B CD 4D 0A 04 0813  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0814  			RET
040230             0815  ;
040230 08          0816  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0817  			DEC     A
040232 E6 07       0818  			AND     7
040234 CD B4 09 04 0819  			CALL    PUSHS           	; Save string on the stack
040238 F5          0820  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0821  			CALL    EXPR3           	; Get the second string
04023D 08          0822  			EX      AF,AF'
04023E F2 36 03 04 0823  			JP      P,TYPE_EV_
040242 F1          0824  			POP     AF
040243 4B          0825  			LD      C,E             	; Length of string #2
040244 D1          0826  			POP     DE
040245 21 00 00 00 0827  			LD      HL,0
040249 39          0828  			ADD     HL,SP
04024A 43          0829  			LD      B,E             	; Length of string #1
04024B D5          0830  			PUSH    DE
04024C 11 00 4A 04 0831  			LD      DE,ACCS
040250 EB          0832  			EX      DE,HL
040251 CD 7C 0A 04 0833  			CALL    DISPT2
040255 D1          0834  			POP     DE
040256 EB          0835  			EX      DE,HL
040257 7D          0836  			LD	A,L
040258 21 00 00 00 0837  			LD	HL,0
04025C 6F          0838  			LD	L,A
04025D 39          0839  			ADD     HL,SP
04025E F9          0840  			LD      SP,HL
04025F EB          0841  			EX      DE,HL
040260 AF          0842  			XOR     A               	; Numeric marker
040261 4F          0843  			LD      C,A             	; Integer marker
040262 08          0844  			EX      AF,AF'
040263 FD 7E 00    0845  			LD      A,(IY)
040266 C9          0846  			RET
040267             0847  ;
040267             0848  ; Level 4: + and -
040267             0849  ;
040267 CD C4 02 04 0850  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0851  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0852  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0853  			CP      '+'			; Is it "+"?
040271 C0          0854  			RET     NZ			; No, so return
040272 08          0855  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0856  			JP      M,EXPR3S		; Branch here if string
040277 08          0857  			EX      AF,AF'
040278 CD 3E 0A 04 0858  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C4 02 04 0859  			CALL    EXPR4			; Fetch the second operator
040280 CD 4D 0A 04 0860  			CALL    DOIT			; Do the operation
040284 18 E5       0861  			JR      EXPR3A			; And continue
040286             0862  ;
040286 08          0863  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0864  			INC     IY              	; Bump past the "+"
040289 CD B4 09 04 0865  			CALL    PUSHS           	; Save the string on the stack
04028D CD C4 02 04 0866  			CALL    EXPR4           	; Fetch the second operator
040291 08          0867  			EX      AF,AF'
040292 F2 36 03 04 0868  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0869  			LD	BC, 0			; Clear BC
04029A 4B          0870  			LD      C,E             	; C: Length of the second string
04029B D1          0871  			POP     DE
04029C D5          0872  			PUSH    DE
04029D 21 00 4A 04 0873  			LD      HL,ACCS
0402A1             0874  ; BEGIN MISSING FROM BINARY
0402A1             0875  			; LD	A,E			;  E: Length of the first string
0402A1             0876  			; LD      DE,ACCS
0402A1             0877  			; LD	E,A 			; DE: Pointer to the end of the first string
0402A1             0878  ; END MISSING FROM BINARY
0402A1 54          0879  			LD		D,H ; ADDED FROM BINARY
0402A2 79          0880  			LD      A,C
0402A3 B7          0881  			OR      A
0402A4 28 0F       0882  			JR      Z,EXP3S3
0402A6 6F          0883  			LD      L,A             	; Source
0402A7 83          0884  			ADD     A,E
0402A8 5F          0885  			LD      E,A             	; Destination
0402A9 3E 13       0886  			LD      A,19
0402AB DA 60 37 04 0887  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402AF D5          0888  			PUSH    DE
0402B0 1D          0889  			DEC     E
0402B1 2D          0890  			DEC     L
0402B2 ED B8       0891  			LDDR                    	; Copy
0402B4 D1          0892  			POP     DE
0402B5 D9          0893  EXP3S3:			EXX
0402B6 C1          0894  			POP     BC
0402B7 CD DE 09 04 0895  			CALL    POPS            	; Restore from stack
0402BB D9          0896  			EXX
0402BC F6 80       0897  			OR      80H             	; Flag as a string
0402BE 08          0898  			EX      AF,AF'
0402BF FD 7E 00    0899  			LD      A,(IY)			; Fetch the next character
0402C2 18 A7       0900  			JR      EXPR3A			; And continue
0402C4             0901  ;
0402C4             0902  ; Level 3: * / MOD DIV
0402C4             0903  ;
0402C4 CD E5 02 04 0904  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402C8 FE 2A       0905  EXPR4A:			CP      '*'			; "*" is valid
0402CA 28 0B       0906  			JR      Z,EXPR4B
0402CC FE 2F       0907  			CP      '/'			; "/" is valid
0402CE 28 07       0908  			JR      Z,EXPR4B
0402D0 FE 83       0909  			CP      MODK			; MOD token is valid
0402D2 28 03       0910  			JR      Z,EXPR4B
0402D4 FE 81       0911  			CP      DIVK			; DIV token is valid
0402D6 C0          0912  			RET     NZ			; And return if it is anything else
0402D7 CD 3E 0A 04 0913  EXPR4B:			CALL    SAVE_EV
0402DB CD E5 02 04 0914  			CALL    EXPR5
0402DF CD 4D 0A 04 0915  			CALL    DOIT
0402E3 18 E3       0916  			JR      EXPR4A
0402E5             0917  ;
0402E5             0918  ; Level 2: ^
0402E5             0919  ;
0402E5 CD C5 03 04 0920  EXPR5:			CALL    ITEM			; Get variable
0402E9 B7          0921  			OR      A               	; Test type
0402EA 08          0922  			EX      AF,AF'          	; Save type
0402EB CD 70 0A 04 0923  EXPR5A:			CALL    NXT			; Skip spaces
0402EF FE 5E       0924  			CP      '^'			; Is the operator "^"?
0402F1 C0          0925  			RET     NZ			; No, so return
0402F2 CD 3E 0A 04 0926  			CALL    SAVE_EV			; Save first operand
0402F6 CD C5 03 04 0927  			CALL    ITEM			; Get second operand
0402FA B7          0928  			OR      A			; Test type
0402FB 08          0929  			EX      AF,AF'			; Save type
0402FC CD 4D 0A 04 0930  			CALL    DOIT			; Do the operation
040300 18 E9       0931  			JR      EXPR5A			; And continue
040302             0932  ;
040302             0933  ; Evaluate a numeric expression
040302             0934  ;
040302 CD C7 01 04 0935  EXPRN:			CALL    EXPR			; Evaluate expression
040306 08          0936  			EX      AF,AF'			; Get the type
040307 F0          0937  			RET     P			; And return if it is a number
040308 18 2C       0938  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030A             0939  ;
04030A             0940  ; Evaluate a fixed-point expression
04030A             0941  ;
04030A CD C7 01 04 0942  EXPRI:			CALL    EXPR			; Evaluate the expression
04030E 08          0943  			EX      AF,AF'			; Get the type
04030F F2 62 06 04 0944  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040313 18 21       0945  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040315             0946  ;
040315             0947  ; Evaluate a string expression
040315             0948  ;
040315 CD C7 01 04 0949  EXPRS:			CALL    EXPR			; Evaluate the expression
040319 08          0950  			EX      AF,AF'			; Get the type
04031A F8          0951  			RET     M			; And return if it is a string
04031B 18 19       0952  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031D             0953  ;
04031D             0954  ; Get a numeric variable
04031D             0955  ;
04031D CD C5 03 04 0956  ITEMN:			CALL    ITEM			; Get the variable
040321 B7          0957  			OR      A			; Test the type
040322 F0          0958  			RET     P			; And return if it is a number
040323 18 11       0959  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040325             0960  ;
040325             0961  ; Get a fixed-point variable
040325             0962  ;
040325 CD C5 03 04 0963  ITEMI:			CALL    ITEM			; Get the variable
040329 B7          0964  			OR      A			; Test the type
04032A F2 62 06 04 0965  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04032E 18 06       0966  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040330             0967  ;
040330             0968  ; Get a string variable
040330             0969  ;
040330 CD C5 03 04 0970  ITEMS:			CALL    ITEM			; Get the variable
040334 B7          0971  			OR      A			; Test the type
040335 F8          0972  			RET     M			; If it is a string, then return
040336             0973  ;							; Otherwise
040336 3E 06       0974  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040338 C3 60 37 04 0975  			JP      ERROR_
04033C             0976  ;
04033C             0977  ; Evaluate a bracketed expression
04033C             0978  ;
04033C CD C7 01 04 0979  ITEM1:			CALL    EXPR            	; Evaluate the expression
040340 CD 2F 0A 04 0980  			CALL    BRAKET			; Check for closing bracket
040344 08          0981  			EX      AF,AF'
040345 C9          0982  			RET
040346             0983  ;
040346             0984  ; HEX - Get hexadecimal constant.
040346             0985  ;   Inputs: ASCII string at (IY)
040346             0986  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040346             0987  ;           IY updated (points to delimiter)
040346             0988  ;
040346 CD 93 09 04 0989  HEX:			CALL    ZERO			; Set result to 0
04034A CD F8 09 04 0990  			CALL    HEXDIG			; Fetch the character from IY
04034E 38 1B       0991  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040350 FD 23       0992  HEX1:			INC     IY			; Move pointer to next character
040352 E6 0F       0993  			AND     0FH			; Clear the top nibble
040354 06 04       0994  			LD      B,4			; Loop counter
040356             0995  ;
040356 D9          0996  HEX2:			EXX				; Shift the result left B (4) times. This makes
040357 52 29       0997  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040359 D9          0998  			EXX				; .
04035A 52 ED 6A    0999  			ADC.S   HL,HL			; .
04035D 10 F7       1000  			DJNZ    HEX2			; And loop
04035F D9          1001  			EXX
040360 B5          1002  			OR      L			; OR in the digit
040361 6F          1003  			LD      L,A
040362 D9          1004  			EXX
040363             1005  ;
040363 CD F8 09 04 1006  			CALL    HEXDIG			; Fetch the next character
040367 30 E7       1007  			JR      NC,HEX1			; If it is a HEX digit then loop
040369 AF          1008  			XOR     A			; Clear A
04036A C9          1009  			RET
04036B             1010  ;
04036B 3E 1C       1011  BADHEX:			LD      A,28
04036D C3 60 37 04 1012  			JP      ERROR_          	; Error: "Bad HEX"
040371             1013  ;
040371             1014  ; BIN - Get binary constant.
040371             1015  ;   Inputs: ASCII string at (IY)
040371             1016  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040371             1017  ;           IY updated (points to delimiter)
040371             1018  ;
040371 CD 93 09 04 1019  BIN:			CALL    ZERO			; Set result to 0
040375 CD 0B 0A 04 1020  			CALL	BINDIG			; Fetch the character from IY
040379 38 13       1021  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037B FD 23       1022  BIN1:			INC	IY			; Move pointer to next character
04037D 0F          1023  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04037E D9          1024  			EXX				;
04037F 52 ED 6A    1025  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040382 D9          1026  			EXX
040383 52 ED 6A    1027  			ADC.S	HL,HL
040386 CD 0B 0A 04 1028  			CALL	BINDIG			; Fetch the next character
04038A 30 EF       1029  			JR	NC,BIN1
04038C AF          1030  			XOR	A			; Clear A
04038D C9          1031  			RET
04038E             1032  ;
04038E 3E 1C       1033  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040390 CD 77 37 04 1034  			CALL	EXTERR
040394 42 61 64 20 1035  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
04039F             1036  ;
04039F             1037  ; MINUS - Unary minus.
04039F             1038  ;   Inputs: IY = text pointer
04039F             1039  ;  Outputs: Numeric result, same type as argument.
04039F             1040  ;           Result in H'L'HLC
04039F             1041  ;
04039F CD 1D 03 04 1042  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A3 0D          1043  MINUS0:			DEC     C			; Check exponent (C)
0403A4 0C          1044  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403A5 28 06       1045  			JR      Z,NEGATE_EV        	; So do an integer negation
0403A7             1046  ;
0403A7 7C          1047  			LD      A,H			; Do a FP negation by
0403A8 EE 80       1048  			XOR     80H             	; Toggling the sign bit (H)
0403AA 67          1049  			LD      H,A
0403AB AF          1050  			XOR     A               	; Numeric marker
0403AC C9          1051  			RET
0403AD             1052  ;
0403AD D9          1053  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403AE 7C          1054  			LD      A,H			; First do a one's complement by negating all the bytes
0403AF 2F          1055  			CPL
0403B0 67          1056  			LD      H,A
0403B1 7D          1057  			LD      A,L
0403B2 2F          1058  			CPL
0403B3 6F          1059  			LD      L,A
0403B4 D9          1060  			EXX
0403B5 7C          1061  			LD      A,H
0403B6 2F          1062  			CPL
0403B7 67          1063  			LD      H,A
0403B8 7D          1064  			LD      A,L
0403B9 2F          1065  			CPL
0403BA 6F          1066  			LD      L,A
0403BB D9          1067  ADD1:			EXX				; Then add 1
0403BC 23          1068  			INC     HL
0403BD 7C          1069  			LD      A,H
0403BE B5          1070  			OR      L
0403BF D9          1071  			EXX
0403C0 3E 00       1072  			LD      A,0             	; Numeric marker
0403C2 C0          1073  			RET     NZ
0403C3 23          1074  			INC     HL
0403C4 C9          1075  			RET
0403C5             1076  ;
0403C5             1077  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403C5             1078  ; Item type is returned in A:  Bit 7=0 numeric.
0403C5             1079  ;                              Bit 7=1 string.
0403C5             1080  ; Numeric item returned in HLH'L'C.
0403C5             1081  ; String item returned in string accumulator,
0403C5             1082  ;   DE addresses byte after last (E=length).
0403C5             1083  ;
0403C5 CD 4F 16 04 1084  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403C9 CD 70 0A 04 1085  			CALL    NXT			; Skip spaces
0403CD FD 23       1086  			INC     IY			; Move to the prefix character
0403CF FE 26       1087  			CP      '&'			; If `&`
0403D1 CA 46 03 04 1088  			JP      Z,HEX           	; Then get a HEX constant
0403D5 FE 25       1089  			CP	'%'			; If '%'
0403D7 28 98       1090  			JR	Z,BIN			; Then get a BINARY constant
0403D9 FE 2D       1091  			CP      '-'			; If `-`
0403DB 28 C2       1092  			JR      Z,MINUS         	; Then get a negative number
0403DD FE 2B       1093  			CP      '+'			; If `+`
0403DF CA 1D 03 04 1094  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E3 FE 28       1095  			CP      '('			; If `(`
0403E5 CA 3C 03 04 1096  			JP      Z,ITEM1         	; Start of a bracketed expression
0403E9 FE 22       1097  			CP      34			; If `"`
0403EB 28 7A       1098  			JR      Z,CONS          	; Start of a string constant
0403ED FE C6       1099  			CP      TCMD_EV			; Is it out of range of the function table?
0403EF D2 97 0C 04 1100  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F3 FE 8D       1101  			CP      FUNTOK			; If it is in range, then
0403F5 D2 83 0A 04 1102  			JP      NC,DISPAT       	; It's a function
0403F9 FD 2B       1103  			DEC     IY
0403FB FE 3A       1104  			CP      ':'
0403FD 30 0C       1105  			JR      NC,ITEM2		; VARIABLE?
0403FF FE 30       1106  			CP      '0'
040401 D2 8E 04 04 1107  			JP      NC,CON			; NUMERIC CONSTANT
040405 FE 2E       1108  			CP      '.'
040407 CA 8E 04 04 1109  			JP      Z,CON			; NUMERIC CONSTANT
04040B CD 3A 3A 04 1110  ITEM2:			CALL    GETVAR			; VARIABLE
04040F 20 37       1111  			JR      NZ,NOSUCH
040411 B7          1112  			OR      A
040412 FA A0 04 04 1113  			JP      M,LOADS			; STRING VARIABLE
040416 B7          1114  LOADN:			OR      A
040417 28 20       1115  			JR      Z,LOAD1			; BYTE VARIABLE
040419 0E 00       1116  			LD      C,0
04041B CB 47       1117  			BIT     0,A
04041D 28 03       1118  			JR      Z,LOAD4			; INTEGER VARIABLE
04041F DD 4E 04    1119  LOAD5:			LD      C,(IX+4)
040422 D9          1120  LOAD4:			EXX
040423 21 00 00 00 1121  			LD	HL, 0			; TODO: Optimise
040427 DD 6E 00    1122  			LD      L,(IX+0)
04042A DD 66 01    1123  			LD      H,(IX+1)
04042D D9          1124  			EXX
04042E 21 00 00 00 1125  			LD	HL, 0			; TODO: Optimise
040432 DD 6E 02    1126  			LD      L,(IX+2)
040435 DD 66 03    1127  			LD      H,(IX+3)
040438 C9          1128  			RET
040439             1129  ;
040439 21 00 00 00 1130  LOAD1:			LD      HL,0
04043D D9          1131  			EXX
04043E 21 00 00 00 1132  			LD      HL,0			; TODO: Optimise
040442 DD 6E 00    1133  			LD      L,(IX+0)
040445 D9          1134  			EXX
040446 4C          1135  			LD      C,H
040447 C9          1136  			RET
040448             1137  ;
040448 DA 97 0C 04 1138  NOSUCH:			JP      C,SYNTAX
04044C 3A 40 4D 04 1139  			LD      A,(LISTON)
040450 CB 6F       1140  			BIT     5,A
040452 3E 1A       1141  			LD      A,26
040454 20 26       1142  			JR      NZ,ERROR0_EV		; Throw "No such variable"
040456 FD 23       1143  NOS1:			INC     IY
040458 CD 6F 3C 04 1144  			CALL    RANGE
04045C 30 F8       1145  			JR      NC,NOS1
04045E DD 21 40 30 1146  			LD      IX,PC
       11          
040463 AF          1147  			XOR     A
040464 4F          1148  			LD      C,A
040465 18 BB       1149  			JR      LOAD4
040467             1150  ;
040467             1151  ;CONS - Get string constant from ASCII string.
040467             1152  ;   Inputs: ASCII string at (IY)
040467             1153  ;  Outputs: Result in string accumulator.
040467             1154  ;           D = MS byte of ACCS, E = string length
040467             1155  ;           A7 = 1 (string marker)
040467             1156  ;           IY updated
040467             1157  ;
040467 11 00 4A 04 1158  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04046B FD 7E 00    1159  CONS3:			LD      A,(IY)			; Fetch the first character and
04046E FD 23       1160  			INC     IY			; Increment the pointer
040470 FE 22       1161  			CP      '"'			; Check for start quote
040472 28 0C       1162  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040474             1163  ;
040474 12          1164  CONS1:			LD      (DE),A			; Store the character in the string accumulator
040475 1C          1165  			INC     E			; Increment the string accumulator pointer
040476 FE 0D       1166  			CP      CR			; Is it CR
040478 20 F1       1167  			JR      NZ,CONS3		; No, so keep looping
04047A             1168  ;
04047A 3E 09       1169  			LD      A,9
04047C C3 60 37 04 1170  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040480             1171  ;
040480 FD 7E 00    1172  CONS2:			LD      A,(IY)			; Fetch the next character
040483 FE 22       1173  			CP      '"'			; Check for end quote?
040485 FD 23       1174  			INC     IY			; Increment the pointer
040487 28 EB       1175  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040489 FD 2B       1176  			DEC     IY			;
04048B 3E 80       1177  			LD      A,80H           	; String marker
04048D C9          1178  			RET
04048E             1179  ;
04048E             1180  ;CON - Get unsigned numeric constant from ASCII string.
04048E             1181  ;   Inputs: ASCII string at (IY).
04048E             1182  ;  Outputs: Variable-type result in HLH'L'C
04048E             1183  ;           IY updated (points to delimiter)
04048E             1184  ;           A7 = 0 (numeric marker)
04048E             1185  ;
04048E FD E5       1186  CON:			PUSH    IY
040490 DD E1       1187  			POP     IX
040492 3E 24       1188  			LD      A,36
040494 CD 6A 20 04 1189  			CALL    FPP
040498 38 E2       1190  			JR      C,ERROR0_EV
04049A DD E5       1191  			PUSH    IX
04049C FD E1       1192  			POP     IY
04049E AF          1193  			XOR     A
04049F C9          1194  			RET
0404A0             1195  ;
0404A0 11 00 4A 04 1196  LOADS:			LD      DE,ACCS			; Where to store the string
0404A4 1F          1197  			RRA
0404A5 30 1A       1198  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404A7             1199  ;
0404A7 D9          1200  			EXX				; This block was a call to LOAD4
0404A8 DD 6E 00    1201  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404AB DD 66 01    1202  			LD      H,(IX+1)		; The maximum original string length
0404AE D9          1203  			EXX
0404AF DD 27 02    1204  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B2             1205  ;
0404B2 D9          1206  			EXX
0404B3 7D          1207  			LD      A,L
0404B4 D9          1208  			EXX
0404B5 B7          1209  			OR      A
0404B6 01 00 00 00 1210  			LD	BC,0			; BC: Number of bytes to copy
0404BA 4F          1211  			LD      C,A
0404BB 3E 80       1212  			LD      A,80H           	; String marker
0404BD C8          1213  			RET     Z
0404BE ED B0       1214  			LDIR
0404C0 C9          1215  			RET
0404C1 7E          1216  LOADS2:			LD      A,(HL)
0404C2 12          1217  			LD      (DE),A
0404C3 23          1218  			INC     HL
0404C4 FE 0D       1219  			CP      CR
0404C6 3E 80       1220  			LD      A,80H           	; String marker
0404C8 C8          1221  			RET     Z
0404C9 1C          1222  			INC     E
0404CA 20 F5       1223  			JR      NZ,LOADS2
0404CC C9          1224  			RET                     	; Return null string
0404CD             1225  ;
0404CD             1226  ;VARIABLE-TYPE FUNCTIONS:
0404CD             1227  ;
0404CD             1228  ;Result returned in HLH'L'C (floating point)
0404CD             1229  ;Result returned in HLH'L' (C=0) (integer)
0404CD             1230  ;Result returned in string accumulator & DE (string)
0404CD             1231  ;All registers destroyed.
0404CD             1232  ;IY (text pointer) updated.
0404CD             1233  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404CD             1234  ;
0404CD             1235  ;POS - horizontal cursor position.
0404CD             1236  ;VPOS - vertical cursor position.
0404CD             1237  ;EOF - return status of file.
0404CD             1238  ;BGET - read byte from file.
0404CD             1239  ;INKEY - as GET but wait only n centiseconds.
0404CD             1240  ;GET - wait for keypress and return ASCII value.
0404CD             1241  ;GET(n) - input from Z80 port n.
0404CD             1242  ;ASC - ASCII value of string.
0404CD             1243  ;LEN - length of string.
0404CD             1244  ;LOMEM - location of dynamic variables.
0404CD             1245  ;HIMEM - top of available RAM.
0404CD             1246  ;PAGE - start of current text page.
0404CD             1247  ;TOP - address of first free byte after program.
0404CD             1248  ;ERL - line number where last error occurred.
0404CD             1249  ;ERR - number of last error.
0404CD             1250  ;COUNT - number of printing characters since CR.
0404CD             1251  ;Results are integer numeric.
0404CD             1252  ;
0404CD CD CC 3E 04 1253  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D1 EB          1254  			EX      DE,HL			;  L: The X cursor position
0404D2 C3 81 05 04 1255  			JP      COUNT1			; Return an 8-bit value
0404D6             1256  ;
0404D6 CD CC 3E 04 1257  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DA C3 81 05 04 1258  			JP      COUNT1			; Return an 8-bit value
0404DE             1259  ;
0404DE CD 86 18 04 1260  EOF:			CALL    CHANEL			; Check for EOF
0404E2 CD 44 43 04 1261  			CALL    OSSTAT
0404E6 CA 05 06 04 1262  			JP      Z,TRUE			; Yes, so return true
0404EA C3 93 09 04 1263  			JP      ZERO			; Otherwise return false (zero)
0404EE             1264  ;
0404EE CD 86 18 04 1265  BGET:			CALL    CHANEL          	; Channel number
0404F2 CD 33 43 04 1266  			CALL    OSBGET
0404F6 6F          1267  			LD      L,A
0404F7 C3 7F 05 04 1268  			JP      COUNT0			; Return an 8-bit value
0404FB             1269  ;
0404FB CD 25 03 04 1270  INKEY:			CALL    ITEMI			; Get the argument
0404FF CB 7C       1271  			BIT	7, H			; Check the sign
040501 D9          1272  			EXX				; HL: The argument
040502 C2 EB 07 04 1273  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040506 CD DD 07 04 1274  			CALL	INKEY0 			; Do INKEY(n)
04050A 18 1D       1275  			JR      ASC0			; Return a numeric value
04050C             1276  ;
04050C CD 70 0A 04 1277  GET:			CALL    NXT			; Skip whitespace
040510 FE 28       1278  			CP      '('			; Is it GET(
040512 20 0B       1279  			JR      NZ,GET0			; No, so get a keyboard character
040514 CD 25 03 04 1280  			CALL    ITEMI           	; Yes, so fetch the port address
040518 D9          1281  			EXX
040519 44          1282  			LD      B,H			; BC: The port address
04051A 4D          1283  			LD      C,L
04051B ED 68       1284  			IN      L,(C)           	;  L: Input from port BC
04051D 18 60       1285  			JR      COUNT0			; Return an 8-bit value
04051F             1286  ;
04051F CD C7 07 04 1287  GET0:			CALL    GETS			; Read the keyboard character
040523 18 0A       1288  			JR      ASC1			; And return the value
040525             1289  ;
040525 CD 30 03 04 1290  ASC:			CALL    ITEMS			; Get the string argument argument
040529 AF          1291  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052A BB          1292  			CP      E			; Is the pointer 0
04052B CA 05 06 04 1293  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04052F 2A 00 4A 04 1294  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040533 18 4A       1295  			JR      COUNT0			; An 8-bit value
040535             1296  ;
040535 CD 30 03 04 1297  LEN:			CALL    ITEMS			; Get the string argument
040539 EB          1298  			EX      DE,HL			; HL: Pointer into ACCS
04053A 18 43       1299  			JR      COUNT0			; Return L
04053C             1300  ;
04053C 2A 1A 4D 04 1301  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040540 3A 1C 4D 04 1302  			LD	A, (LOMEM+2)
040544 18 41       1303  			JR      COUNT2			; A 24-bit value
040546             1304  ;
040546 2A 20 4D 04 1305  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054A 3A 22 4D 04 1306  			LD	A, (HIMEM+2)
04054E 18 37       1307  			JR      COUNT2			; A 24-bit value
040550             1308  ;
040550 2A 14 4D 04 1309  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040554 3A 16 4D 04 1310  			LD	A, (PAGE_+2)		; A 24-bit value
040558 18 2D       1311  			JR      COUNT2
04055A             1312  ;
04055A FD 7E 00    1313  TOPV:			LD      A,(IY)			; Return the TOP system variable
04055D FD 23       1314  			INC     IY              	; Skip "P"
04055F FE 50       1315  			CP      'P'
040561 C2 97 0C 04 1316  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
040565 2A 17 4D 04 1317  			LD      HL,(TOP)
040569 3A 19 4D 04 1318  			LD	A, (TOP+2)
04056D 18 18       1319  			JR      COUNT2
04056F             1320  ;
04056F 2A 33 4D 04 1321  ERLV:			LD      HL,(ERL)		; Return the error line
040573 18 0C       1322  			JR      COUNT1			; A 16-bit value
040575             1323  ;
040575 2A 3F 4D 04 1324  ERRV:			LD      HL,(ERR)		; Return the error value
040579 18 04       1325  			JR      COUNT0			; An 8-bit value
04057B             1326  ;
04057B 2A 3D 4D 04 1327  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04057F             1328  
04057F 26 00       1329  COUNT0:			LD      H,0			; Return L
040581 D9          1330  COUNT1:			EXX				; Return HL
040582 AF          1331  			XOR     A
040583 4F          1332  			LD      C,A             	; Integer marker
040584 67          1333  			LD      H,A
040585 6F          1334  			LD      L,A
040586 C9          1335  			RET
040587 D9          1336  COUNT2:			EXX
040588 6F          1337  			LD	L,A
040589 AF          1338  			XOR	A
04058A 4F          1339  			LD	C,A			; Integer marker
04058B 67          1340  			LD	H,A
04058C C9          1341  			RET
04058D             1342  ;
04058D             1343  ;OPENIN - Open a file for reading.
04058D             1344  ;OPENOT - Open a file for writing.
04058D             1345  ;OPENUP - Open a file for reading or writing.
04058D             1346  ;Result is integer channel number (0 if error)
04058D             1347  ;
04058D AF          1348  OPENOT:			XOR     A			; Open for writing
04058E 18 06       1349  			JR	OPENIN_1
040590             1350  ;
040590 3E 02       1351  OPENUP:			LD      A,2			; Open for reading / writing
040592 18 02       1352  			JR	OPENIN_1
040594             1353  ;
040594 3E 01       1354  OPENIN:			LD      A,1			; Open for reading
040596             1355  ;
040596 F5          1356  OPENIN_1:		PUSH    AF              	; Save OPEN type
040597 CD 30 03 04 1357  			CALL    ITEMS           	; Fetch the filename
04059B 3E 0D       1358  			LD      A,CR
04059D 12          1359  			LD      (DE),A
04059E F1          1360  			POP     AF              	; Restore the OPEN type
04059F C6 FF       1361  			ADD     A,-1            	; Affect the flags
0405A1 21 00 4A 04 1362  			LD      HL,ACCS
0405A5 CD 1C 43 04 1363  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405A9 6F          1364  			LD      L,A			; L: Channel number
0405AA 18 D3       1365  			JR      COUNT0			; Return channel number to BASIC
0405AC             1366  ;
0405AC             1367  ;EXT - Return length of file.
0405AC             1368  ;PTR_EV - Return current file pointer.
0405AC             1369  ;Results are integer numeric.
0405AC             1370  ;
0405AC CD 86 18 04 1371  EXT:			CALL    CHANEL
0405B0 CD 7A 43 04 1372  			CALL    GETEXT
0405B4 18 15       1373  			JR      TIME0
0405B6             1374  ;
0405B6 CD 86 18 04 1375  PTR_EV:			CALL    CHANEL
0405BA CD 4E 43 04 1376  			CALL    GETPTR
0405BE 18 0B       1377  			JR      TIME0
0405C0             1378  ;
0405C0             1379  ;TIME - Return current value of elapsed time.
0405C0             1380  ;Result is integer numeric.
0405C0             1381  ;
0405C0 FD 7E 00    1382  TIMEV:			LD      A,(IY)
0405C3 FE 24       1383  			CP      '$'
0405C5 28 0A       1384  			JR      Z,TIMEVS
0405C7 CD AC 3E 04 1385  			CALL    GETIME
0405CB D5          1386  TIME0:			PUSH    DE
0405CC D9          1387  			EXX
0405CD E1          1388  			POP     HL
0405CE AF          1389  			XOR     A
0405CF 4F          1390  			LD      C,A
0405D0 C9          1391  			RET
0405D1             1392  ;
0405D1             1393  ;TIME$ - Return date/time string.
0405D1             1394  ;Result is string
0405D1             1395  ;
0405D1 FD 23       1396  TIMEVS:			INC     IY              ;SKIP $
0405D3 CD 93 43 04 1397  			CALL    GETIMS
0405D7 3E 80       1398  			LD      A,80H           ;MARK STRING
0405D9 C9          1399  			RET
0405DA             1400  ;
0405DA             1401  ;String comparison:
0405DA             1402  ;
0405DA CD 8F 09 04 1403  SLT:			CALL    SCP
0405DE D0          1404  			RET     NC
0405DF 18 24       1405  			JR      TRUE
0405E1             1406  ;
0405E1 CD 8F 09 04 1407  SGT:			CALL    SCP
0405E5 C8          1408  			RET     Z
0405E6 D8          1409  			RET     C
0405E7 18 1C       1410  			JR      TRUE
0405E9             1411  ;
0405E9 CD 8F 09 04 1412  SGE:			CALL    SCP
0405ED D8          1413  			RET     C
0405EE 18 15       1414  			JR      TRUE
0405F0             1415  ;
0405F0 CD 8F 09 04 1416  SLE:			CALL    SCP
0405F4 28 0F       1417  			JR      Z,TRUE
0405F6 D0          1418  			RET     NC
0405F7 18 0C       1419  			JR      TRUE
0405F9             1420  ;
0405F9 CD 8F 09 04 1421  SNE:			CALL    SCP
0405FD C8          1422  			RET     Z
0405FE 18 05       1423  			JR      TRUE
040600             1424  ;
040600 CD 8F 09 04 1425  SEQ:			CALL    SCP
040604 C0          1426  			RET     NZ
040605 3E FF       1427  TRUE:			LD      A,-1
040607 D9          1428  			EXX
040608 67          1429  			LD      H,A
040609 6F          1430  			LD      L,A
04060A D9          1431  			EXX
04060B 67          1432  			LD      H,A
04060C 6F          1433  			LD      L,A
04060D 3C          1434  			INC     A
04060E 4F          1435  			LD      C,A
04060F C9          1436  			RET
040610             1437  ;
040610             1438  ;PI - Return PI (3.141592654)
040610             1439  ;Result is floating-point numeric.
040610             1440  ;
040610 3E 23       1441  PI:			LD      A,35
040612 18 44       1442  			JR      FPP1
040614             1443  ;
040614             1444  ;ABS - Absolute value
040614             1445  ;Result is numeric, variable type.
040614             1446  ;
040614 3E 10       1447  ABSV:			LD      A,16
040616 18 3A       1448  			JR      FPPN
040618             1449  ;
040618             1450  ;NOT - Complement integer.
040618             1451  ;Result is integer numeric.
040618             1452  ;
040618 3E 1A       1453  NOTK:			LD      A,26
04061A 18 36       1454  			JR      FPPN
04061C             1455  ;
04061C             1456  ;DEG - Convert radians to degrees
04061C             1457  ;Result is floating-point numeric.
04061C             1458  ;
04061C 3E 15       1459  DEG:			LD      A,21
04061E 18 32       1460  			JR      FPPN
040620             1461  ;
040620             1462  ;RAD - Convert degrees to radians
040620             1463  ;Result is floating-point numeric.
040620             1464  ;
040620 3E 1B       1465  RAD:			LD      A,27
040622 18 2E       1466  			JR      FPPN
040624             1467  ;
040624             1468  ;SGN - Return -1, 0 or +1
040624             1469  ;Result is integer numeric.
040624             1470  ;
040624 3E 1C       1471  SGN:			LD      A,28
040626 18 2A       1472  			JR      FPPN
040628             1473  ;
040628             1474  ;INT - Floor function
040628             1475  ;Result is integer numeric.
040628             1476  ;
040628 3E 17       1477  INT_:			LD      A,23
04062A 18 26       1478  			JR      FPPN
04062C             1479  ;
04062C             1480  ;SQR - square root
04062C             1481  ;Result is floating-point numeric.
04062C             1482  ;
04062C 3E 1E       1483  SQR:			LD      A,30
04062E 18 22       1484  			JR      FPPN
040630             1485  ;
040630             1486  ;TAN - Tangent function
040630             1487  ;Result is floating-point numeric.
040630             1488  ;
040630 3E 1F       1489  TAN:			LD      A,31
040632 18 1E       1490  			JR      FPPN
040634             1491  ;
040634             1492  ;COS - Cosine function
040634             1493  ;Result is floating-point numeric.
040634             1494  ;
040634 3E 14       1495  COS:			LD      A,20
040636 18 1A       1496  			JR      FPPN
040638             1497  ;
040638             1498  ;SIN - Sine function
040638             1499  ;Result is floating-point numeric.
040638             1500  ;
040638 3E 1D       1501  SIN:			LD      A,29
04063A 18 16       1502  			JR      FPPN
04063C             1503  ;
04063C             1504  ;EXP - Exponential function
04063C             1505  ;Result is floating-point numeric.
04063C             1506  ;
04063C 3E 16       1507  EXP:			LD      A,22
04063E 18 12       1508  			JR      FPPN
040640             1509  ;
040640             1510  ;LN - Natural log.
040640             1511  ;Result is floating-point numeric.
040640             1512  ;
040640 3E 18       1513  LN:			LD      A,24
040642 18 0E       1514  			JR      FPPN
040644             1515  ;
040644             1516  ;LOG - base-10 logarithm.
040644             1517  ;Result is floating-point numeric.
040644             1518  ;
040644 3E 19       1519  LOG:			LD      A,25
040646 18 0A       1520  			JR      FPPN
040648             1521  ;
040648             1522  ;ASN - Arc-sine
040648             1523  ;Result is floating-point numeric.
040648             1524  ;
040648 3E 12       1525  ASN:			LD      A,18
04064A 18 06       1526  			JR      FPPN
04064C             1527  ;
04064C             1528  ;ATN - arc-tangent
04064C             1529  ;Result is floating-point numeric.
04064C             1530  ;
04064C 3E 13       1531  ATN:			LD      A,19
04064E 18 02       1532  			JR      FPPN
040650             1533  ;
040650             1534  ;ACS - arc-cosine
040650             1535  ;Result is floating point numeric.
040650             1536  ;
040650 3E 11       1537  ACS:			LD      A,17
040652 F5          1538  FPPN:			PUSH    AF
040653 CD 1D 03 04 1539  			CALL    ITEMN
040657 F1          1540  			POP     AF
040658 CD 6A 20 04 1541  FPP1:			CALL    FPP
04065C DA 60 37 04 1542  			JP      C,ERROR_
040660 AF          1543  			XOR     A
040661 C9          1544  			RET
040662             1545  ;
040662             1546  ;SFIX - Convert to fixed-point notation
040662             1547  ;
040662 3E 26       1548  SFIX:			LD      A,38
040664 18 F2       1549  			JR      FPP1
040666             1550  ;
040666             1551  ;SFLOAT - Convert to floating-point notation
040666             1552  ;
040666 3E 27       1553  SFLOAT:			LD      A,39
040668 18 EE       1554  			JR      FPP1
04066A             1555  ;
04066A             1556  ;VAL - Return numeric value of string.
04066A             1557  ;Result is variable type numeric.
04066A             1558  ;
04066A CD 30 03 04 1559  VAL:			CALL    ITEMS
04066E AF          1560  VAL0:			XOR     A
04066F 12          1561  			LD      (DE),A
040670 DD 21 00 4A 1562  			LD      IX,ACCS
       04          
040675 3E 24       1563  			LD      A,36
040677 18 DF       1564  			JR      FPP1
040679             1565  ;
040679             1566  ;EVAL - Pass string to expression evaluator.
040679             1567  ;Result is variable type (numeric or string).
040679             1568  ;
040679 CD 30 03 04 1569  EVAL_:			CALL    ITEMS
04067D 3E 0D       1570  			LD      A,CR
04067F 12          1571  			LD      (DE),A
040680 FD E5       1572  			PUSH    IY
040682 11 00 4A 04 1573  			LD      DE,ACCS
040686 FD 21 00 4A 1574  			LD      IY,ACCS
       04          
04068B 0E 00       1575  			LD      C,0
04068D CD 9F 3C 04 1576  			CALL    LEXAN2          ;TOKENISE
040691 12          1577  			LD      (DE),A
040692 13          1578  			INC     DE
040693 AF          1579  			XOR     A
040694 CD B4 09 04 1580  			CALL    PUSHS           ;PUT ON STACK
040698 FD 21 03 00 1581  			LD      IY,SIZEW	;WAS 2
       00          
04069D FD 39       1582  			ADD     IY,SP
04069F CD C7 01 04 1583  			CALL    EXPR
0406A3 FD E1       1584  			POP     IY
0406A5 FD 39       1585  			ADD     IY,SP
0406A7 FD F9       1586  			LD      SP,IY           ;ADJUST STACK POINTER
0406A9 FD E1       1587  			POP     IY
0406AB 08          1588  			EX      AF,AF'
0406AC C9          1589  			RET
0406AD             1590  ;
0406AD             1591  ;RND - Random number function.
0406AD             1592  ; RND gives random integer 0-&FFFFFFFF
0406AD             1593  ; RND(-n) seeds random number & returns -n.
0406AD             1594  ; RND(0) returns last value in RND(1) form.
0406AD             1595  ; RND(1) returns floating-point 0-0.99999999.
0406AD             1596  ; RND(n) returns random integer 1-n.
0406AD             1597  ;
0406AD DD 21 38 4D 1598  RND:			LD      IX,RANDOM
       04          
0406B2 CD 70 0A 04 1599  			CALL    NXT
0406B6 FE 28       1600  			CP      '('
0406B8 28 20       1601  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BA CD 1F 04 04 1602  			CALL    LOAD5
0406BE CB 19       1603  RND1:			RR      C
0406C0 06 20       1604  			LD      B,32
0406C2 D9          1605  RND2:			EXX                     ;CALCULATE NEXT
0406C3 52 ED 6A    1606  			ADC.S   HL,HL
0406C6 D9          1607  			EXX
0406C7 52 ED 6A    1608  			ADC.S   HL,HL
0406CA CB 5D       1609  			BIT     3,L
0406CC 28 01       1610  			JR      Z,RND3
0406CE 3F          1611  			CCF
0406CF 10 F1       1612  RND3:			DJNZ    RND2
0406D1 CB 11       1613  RND4:			RL      C               ;SAVE CARRY
0406D3 CD DB 15 04 1614  			CALL    STORE5          ;STORE NEW NUMBER
0406D7 AF          1615  			XOR     A
0406D8 4F          1616  			LD      C,A
0406D9 C9          1617  			RET
0406DA CD 25 03 04 1618  RND5:			CALL    ITEMI
0406DE DD 21 38 4D 1619  			LD      IX,RANDOM
       04          
0406E3 CB 7C       1620  			BIT     7,H             ;NEGATIVE?
0406E5 37          1621  			SCF
0406E6 20 E9       1622  			JR      NZ,RND4         ;SEED
0406E8 CD DF 08 04 1623  			CALL    TEST
0406EC F5          1624  			PUSH    AF
0406ED CD D7 08 04 1625  			CALL    SWAP
0406F1 D9          1626  			EXX
0406F2 CD 1F 04 04 1627  			CALL    LOAD5
0406F6 C4 BE 06 04 1628  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FA D9          1629  			EXX                     ;SCRAMBLE (CARE!)
0406FB 0E 7F       1630  			LD      C,7FH
0406FD CB 7C       1631  RND6:			BIT     7,H             ;FLOAT
0406FF 20 0A       1632  			JR      NZ,RND7
040701 D9          1633  			EXX
040702 52 29       1634  			ADD.S   HL,HL
040704 D9          1635  			EXX
040705 52 ED 6A    1636  			ADC.S   HL,HL
040708 0D          1637  			DEC     C
040709 20 F2       1638  			JR      NZ,RND6
04070B CB BC       1639  RND7:			RES     7,H             ;POSITIVE 0-0.999999
04070D F1          1640  			POP     AF
04070E C8          1641  			RET     Z               ;ZERO ARGUMENT
04070F D9          1642  			EXX
040710 7B          1643  			LD      A,E
040711 3D          1644  			DEC     A
040712 B2          1645  			OR      D
040713 D9          1646  			EXX
040714 B3          1647  			OR      E
040715 B2          1648  			OR      D
040716 C8          1649  			RET     Z               ;ARGUMENT=1
040717 06 00       1650  			LD      B,0             ;INTEGER MARKER
040719 3E 0A       1651  			LD      A,10
04071B CD 6A 20 04 1652  			CALL    FPP             ;MULTIPLY
04071F DA 60 37 04 1653  			JP      C,ERROR_
040723 CD 62 06 04 1654  			CALL    SFIX
040727 C3 BB 03 04 1655  			JP      ADD1
04072B             1656  ;
04072B             1657  ; INSTR - String search.
04072B             1658  ; Result is integer numeric.
04072B             1659  ;
04072B CD 1E 0A 04 1660  INSTR:			CALL    EXPRSC			; Get the first string expression
04072F CD B4 09 04 1661  			CALL    PUSHS           	; Push the string onto the stack
040733 CD 15 03 04 1662  			CALL    EXPRS           	; Get the second string expression
040737 C1          1663  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
040738 21 00 00 00 1664  			LD      HL,0
04073C 39          1665  			ADD     HL,SP           	; HL: Pointer to main string
04073D C5          1666  			PUSH    BC              	;  C: Main string length
04073E 43          1667  			LD      B,E             	;  B: Sub-string length
04073F CD 70 0A 04 1668  			CALL    NXT			; Skip whitespace
040743 FE 2C       1669  			CP      ','			; Check if there is a comma for the third parameter
040745 3E 00       1670  			LD      A,0			;  A: Default start position in string
040747 20 1A       1671  			JR      NZ,INSTR1		; No, so skip the next bit
040749 FD 23       1672  			INC     IY              	; Skip the comma
04074B C5          1673  			PUSH    BC              	; Save the lengths
04074C E5          1674  			PUSH    HL              	; Save the pointer to the main string
04074D CD B4 09 04 1675  			CALL    PUSHS			; Push the string onto the stack
040751 CD 0A 03 04 1676  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040755 C1          1677  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040756 CD DE 09 04 1678  			CALL    POPS			; Pop the string off the stack
04075A E1          1679  			POP     HL              	; Restore the pointer to the main string
04075B C1          1680  			POP     BC              	; Restore the lengths
04075C D9          1681  			EXX
04075D 7D          1682  			LD      A,L			; A: The start position in the  string
04075E D9          1683  			EXX
04075F B7          1684  			OR      A			; Set the flags
040760 28 01       1685  			JR      Z,INSTR1		; If it is zero, then skip
040762 3D          1686  			DEC     A
040763 11 00 4A 04 1687  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040767 CD 85 07 04 1688  			CALL    SEARCH			; Do the search
04076B D1          1689  			POP     DE
04076C 28 03       1690  			JR      Z,INSTR2        	; NB: Carry cleared
04076E ED 62       1691  			SBC     HL,HL
040770 39          1692  			ADD     HL,SP
040771 ED 72       1693  INSTR2:			SBC     HL,SP
040773 EB          1694  			EX      DE,HL
040774 7D          1695  			LD	A,L
040775 21 00 00 00 1696  			LD      HL,0
040779 6F          1697  			LD	L,A
04077A 39          1698  			ADD     HL,SP
04077B F9          1699  			LD      SP,HL
04077C EB          1700  			EX      DE,HL
04077D CD 2F 0A 04 1701  			CALL    BRAKET			; Check for closing bracket
040781 C3 81 05 04 1702  			JP      COUNT1			; Return a numeric integer
040785             1703  ;
040785             1704  ; SEARCH - Search string for sub-string
040785             1705  ;    Inputs: Main string at HL length C
040785             1706  ;            Sub-string  at DE length B
040785             1707  ;            Starting offset A
040785             1708  ;   Outputs: NZ - not found
040785             1709  ;            Z - found at location HL-1
040785             1710  ;            Carry always cleared
040785             1711  ;
040785 C5          1712  SEARCH:			PUSH    BC			; Add the starting offset to HL
040786 01 00 00 00 1713  			LD      BC,0
04078A 4F          1714  			LD      C,A
04078B 09          1715  			ADD     HL,BC           	; New start address
04078C C1          1716  			POP     BC
04078D 91          1717  			SUB     C			; If the starting offset > main string length, then do nothing
04078E 30 2C       1718  			JR      NC,SRCH4
040790 ED 44       1719  			NEG
040792 4F          1720  			LD      C,A             	; Remaining length
040793             1721  ;
040793 C5          1722  SRCH1:			PUSH    BC
040794 79          1723  			LD	A,C
040795 01 00 00 00 1724  			LD	BC,0
040799 4F          1725  			LD	C,A
04079A 1A          1726  			LD      A,(DE)
04079B ED B1       1727  			CPIR                    	; Find the first character
04079D 79          1728  			LD      A,C
04079E C1          1729  			POP     BC
04079F 20 1B       1730  			JR      NZ,SRCH4
0407A1 4F          1731  			LD      C,A
0407A2             1732  ;
0407A2             1733  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A2             1734  ;
0407A2 05          1735  			DEC     B			; Bug fix
0407A3 B8          1736  			CP      B			; Bug fix
0407A4 04          1737  			INC     B			; Bug fix
0407A5 38 15       1738  			JR      C,SRCH4			; Bug fix
0407A7             1739  ;
0407A7 C5          1740  			PUSH    BC
0407A8 D5          1741  			PUSH    DE
0407A9 E5          1742  			PUSH    HL
0407AA 05          1743  			DEC     B
0407AB 28 08       1744  			JR      Z,SRCH3         	; Found!
0407AD 13          1745  SRCH2:			INC     DE
0407AE 1A          1746  			LD      A,(DE)
0407AF BE          1747  			CP      (HL)
0407B0 20 03       1748  			JR      NZ,SRCH3
0407B2 23          1749  			INC     HL
0407B3 10 F8       1750  			DJNZ    SRCH2
0407B5 E1          1751  SRCH3:			POP     HL
0407B6 D1          1752  			POP     DE
0407B7 C1          1753  			POP     BC
0407B8 20 D9       1754  			JR      NZ,SRCH1
0407BA AF          1755  			XOR     A               	; Flags: Z, NC
0407BB C9          1756  			RET                     	; Found
0407BC             1757  ;
0407BC F6 FF       1758  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407BE C9          1759  			RET                     	; Not found
0407BF             1760  ;
0407BF             1761  ;CHRS - Return character with given ASCII value.
0407BF             1762  ;Result is string.
0407BF             1763  ;
0407BF CD 25 03 04 1764  CHRS:			CALL    ITEMI
0407C3 D9          1765  			EXX
0407C4 7D          1766  			LD      A,L
0407C5 18 0E       1767  			JR      GET1
0407C7             1768  ;
0407C7             1769  ;GETS - Return key pressed as stringor character at position (X,Y).
0407C7             1770  ;Result is string.
0407C7             1771  ;
0407C7 CD 70 0A 04 1772  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407CB FE 28       1773  			CP	'('
0407CD CA FC 43 04 1774  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D1 CD 29 3F 04 1775  			CALL    OSRDCH
0407D5 37          1776  GET1:			SCF
0407D6 18 09       1777  			JR      INKEY1
0407D8             1778  ;
0407D8             1779  ; INKEYS - Wait up to n centiseconds for keypress.
0407D8             1780  ;          Return key pressed as string or null
0407D8             1781  ;          string if time elapsed.
0407D8             1782  ; Result is string.
0407D8             1783  ;
0407D8 CD 25 03 04 1784  INKEYS:			CALL    ITEMI			; Fetch the argument
0407DC D9          1785  			EXX
0407DD CD 32 3F 04 1786  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E1 11 00 4A 04 1787  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E5 12          1788  			LD      (DE),A
0407E6 3E 80       1789  			LD      A,80H
0407E8 D0          1790  			RET     NC
0407E9 1C          1791  			INC     E
0407EA C9          1792  			RET
0407EB             1793  ;
0407EB             1794  ; INKEYM - Check immediately whether a given key is being pressed
0407EB             1795  ; Result is integer numeric
0407EB             1796  ;
0407EB             1797  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407EB 3E 1E       0001M 			LD	A, function
0407ED 49 CF       0002M 			RST.LIS	08h
0407EF 23          1798  			INC	HL			; Index from 0
0407F0 7D          1799  			LD	A, L			; Negate the LSB of the answer
0407F1 ED 44       1800  			NEG
0407F3 4F          1801  			LD	C, A			;  E: The positive keycode value
0407F4 3E 01       1802  			LD	A, 1			; Throw an "Out of range" error
0407F6 FA 60 37 04 1803  			JP	M, ERROR_		; if the argument < - 128
0407FA             1804  ;
0407FA 21 1D 08 04 1805  			LD	HL, BITLOOKUP		; HL: The bit lookup table
0407FE 11 00 00 00 1806  			LD	DE, 0
040802 79          1807  			LD	A, C
040803 E6 07       1808  			AND	00000111b		; Just need the first three bits
040805 5F          1809  			LD	E, A			; DE: The bit number
040806 19          1810  			ADD	HL, DE
040807 46          1811  			LD	B, (HL)			;  B: The mask
040808             1812  ;
040808 79          1813  			LD	A, C			; Fetch the keycode again
040809 E6 78       1814  			AND	01111000b		; And divide by 8
04080B 0F          1815  			RRCA
04080C 0F          1816  			RRCA
04080D 0F          1817  			RRCA
04080E 5F          1818  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04080F DD 19       1819  			ADD	IX, DE			; IX: The address
040811 78          1820  			LD	A, B			;  B: The mask
040812 DD A6 00    1821  			AND	(IX+0)			; Check whether the bit is set
040815 CA 93 09 04 1822  			JP	Z, ZERO			; No, so return 0
040819 C3 05 06 04 1823  			JP	TRUE			; Otherwise return -1
04081D             1824  ;
04081D             1825  ; A bit lookup table
04081D             1826  ;
04081D 01 02 04 08 1827  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040821 10 20 40 80 1828  			DB	10h, 20h, 40h, 80h
040825             1829  ;
040825             1830  ; MID$ - Return sub-string.
040825             1831  ; Result is string.
040825             1832  ;
040825 CD 1E 0A 04 1833  MIDS:			CALL    EXPRSC			; Get the first string expression
040829 CD B4 09 04 1834  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082D CD 0A 03 04 1835  			CALL    EXPRI			; Get the second expression
040831 C1          1836  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040832 CD DE 09 04 1837  			CALL    POPS			; Pop the string back off the stack to the string accumulator
040836 D9          1838  			EXX
040837 7D          1839  			LD      A,L			; A: The start index
040838 D9          1840  			EXX
040839 B7          1841  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083A 28 0E       1842  			JR      Z,MIDS1
04083C 3D          1843  			DEC     A
04083D 6F          1844  			LD      L,A			; L: The start index - 1
04083E 93          1845  			SUB     E			; Subtract from the string length
04083F 1E 00       1846  			LD      E,0			; Preemptively set the string length to 0
040841 30 07       1847  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040843 ED 44       1848  			NEG				; Negate the answer and
040845 4F          1849  			LD      C,A			; C: Number of bytes to copy
040846 CD 89 08 04 1850  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084A CD 70 0A 04 1851  MIDS1:			CALL    NXT			; Skip whitespace
04084E FE 2C       1852  			CP      ','			; Check for a comma
040850 FD 23       1853  			INC     IY			; Advance to the next character in the BASIC line
040852 28 0D       1854  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040854 FD 2B       1855  			DEC     IY			; Restore the BASIC program pointer
040856 CD 2F 0A 04 1856  			CALL    BRAKET			; Check for a bracket
04085A 3E 80       1857  			LD      A,80H			; String marker
04085C C9          1858  			RET
04085D             1859  ;
04085D             1860  ; LEFT$ - Return left part of string.
04085D             1861  ; Carry cleared if entire string returned.
04085D             1862  ; Result is string.
04085D             1863  ;
04085D CD 1E 0A 04 1864  LEFTS:			CALL    EXPRSC			; Get the first string expression
040861 CD B4 09 04 1865  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040865 CD 0A 03 04 1866  			CALL    EXPRI			; Get the second expression
040869 C1          1867  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086A CD DE 09 04 1868  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04086E CD 2F 0A 04 1869  			CALL    BRAKET			; Check for closing bracket
040872 D9          1870  			EXX
040873 7D          1871  			LD      A,L			; L: The second parameter
040874 D9          1872  			EXX
040875 BB          1873  			CP      E			; Compare with the string length
040876 30 02       1874  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
040878 6B          1875  			LD      L,E             	; For RIGHTS, no effect in LEFTS
040879 5F          1876  LEFT2:			LD      E,A			; E: The new length of string
04087A 3E 80       1877  LEFT3:			LD      A,80H           	; String marker
04087C C9          1878  			RET
04087D             1879  ;
04087D             1880  ; RIGHT$ - Return right part of string.
04087D             1881  ; Result is string.
04087D             1882  ;
04087D CD 5D 08 04 1883  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040881 D0          1884  			RET     NC			; Do nothing if the second parameter is >= string length
040882 1C          1885  			INC     E			; Check for a zero length string
040883 1D          1886  			DEC     E
040884 C8          1887  			RET     Z			; Yes, so do nothing
040885 4B          1888  			LD      C,E			;  C: Number of bytes to copy
040886 7D          1889  			LD      A,L
040887 93          1890  			SUB     E
040888 6F          1891  			LD      L,A			;  L: Index into the string
040889 79          1892  RIGHT1:			LD	A,C
04088A 01 00 00 00 1893  			LD	BC,0
04088E 4F          1894  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04088F 7D          1895  			LD	A,L
040890 21 00 4A 04 1896  			LD	HL,ACCS
040894 6F          1897  			LD	L,A			; HL: Source (in ACCS)
040895 11 00 4A 04 1898  			LD      DE,ACCS			; DE: Destination (start of ACCS)
040899 ED B0       1899  			LDIR                    	; Copy
04089B 3E 80       1900  			LD      A,80H			; String marker
04089D C9          1901  			RET
04089E             1902  ;
04089E             1903  ; STRINGS - Return n concatenations of a string.
04089E             1904  ; Result is string.
04089E             1905  ;
04089E CD 0A 03 04 1906  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A2 CD 22 0A 04 1907  			CALL    COMMA			; Check for comma
0408A6 D9          1908  			EXX
0408A7 7D          1909  			LD      A,L			; L: Number of iterations of string
0408A8 D9          1910  			EXX
0408A9 F5          1911  			PUSH    AF
0408AA CD 15 03 04 1912  			CALL    EXPRS			; Get the string
0408AE CD 2F 0A 04 1913  			CALL    BRAKET			; Check for closing bracket
0408B2 F1          1914  			POP     AF			; A: Number of iterations of string
0408B3 B7          1915  			OR      A			; Set flags
0408B4 28 C3       1916  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408B6 3D          1917  			DEC     A
0408B7 4F          1918  			LD      C,A			; C: Loop counter
0408B8 3E 80       1919  			LD      A,80H			; String marker
0408BA C8          1920  			RET     Z
0408BB 1C          1921  			INC     E			; Check for empty string
0408BC 1D          1922  			DEC     E
0408BD C8          1923  			RET     Z              		; And return
0408BE 43          1924  			LD      B,E			; B: String length tally
0408BF 21 00 4A 04 1925  			LD	HL,ACCS
0408C3 C5          1926  STRIN1:			PUSH    BC
0408C4 7E          1927  STRIN2:			LD      A,(HL)
0408C5 23          1928  			INC     HL
0408C6 12          1929  			LD      (DE),A
0408C7 1C          1930  			INC     E
0408C8 3E 13       1931  			LD      A,19
0408CA CA 60 37 04 1932  			JP      Z,ERROR_         	; Throw a "String too long" error
0408CE 10 F4       1933  			DJNZ    STRIN2
0408D0 C1          1934  			POP     BC
0408D1 0D          1935  			DEC     C
0408D2 20 EF       1936  			JR      NZ,STRIN1
0408D4 3E 80       1937  			LD      A,80H
0408D6 C9          1938  			RET
0408D7             1939  ;
0408D7             1940  ;SUBROUTINES
0408D7             1941  ;
0408D7             1942  ;SWAP - Swap arguments
0408D7             1943  ;Exchanges DE,HL D'E',H'L' and B,C
0408D7             1944  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408D7             1945  ;
0408D7 79          1946  SWAP:			LD      A,C
0408D8 48          1947  			LD      C,B
0408D9 47          1948  			LD      B,A
0408DA EB          1949  			EX      DE,HL
0408DB D9          1950  			EXX
0408DC EB          1951  			EX      DE,HL
0408DD D9          1952  			EXX
0408DE C9          1953  			RET
0408DF             1954  ;
0408DF             1955  ;TEST - Test HLH'L' for zero
0408DF             1956  ;Outputs: Z-flag set & A=0 if zero
0408DF             1957  ;Destroys: A,F
0408DF             1958  ;
0408DF 7C          1959  TEST:			LD      A,H
0408E0 B5          1960  			OR      L
0408E1 D9          1961  			EXX
0408E2 B4          1962  			OR      H
0408E3 B5          1963  			OR      L
0408E4 D9          1964  			EXX
0408E5 C9          1965  			RET
0408E6             1966  ;
0408E6             1967  ;DECODE - Decode line number in pseudo-binary.
0408E6             1968  ;   Inputs: IY = Text pointer.
0408E6             1969  ;   Outputs: HL=0, H'L'=line number, C=0.
0408E6             1970  ;   Destroys: A,C,H,L,H',L',IY,F
0408E6             1971  ;
0408E6 D9          1972  DECODE:			EXX
0408E7 21 00 00 00 1973  			LD	HL, 0
0408EB FD 7E 00    1974  			LD      A,(IY)
0408EE FD 23       1975  			INC     IY
0408F0 17          1976  			RLA
0408F1 17          1977  			RLA
0408F2 67          1978  			LD      H,A
0408F3 E6 C0       1979  			AND     0C0H
0408F5 FD AE 00    1980  			XOR     (IY)
0408F8 FD 23       1981  			INC     IY
0408FA 6F          1982  			LD      L,A
0408FB 7C          1983  			LD      A,H
0408FC 17          1984  			RLA
0408FD 17          1985  			RLA
0408FE E6 C0       1986  			AND     0C0H
040900 FD AE 00    1987  			XOR     (IY)
040903 FD 23       1988  			INC     IY
040905 67          1989  			LD      H,A
040906 D9          1990  			EXX
040907             1991  ;			XOR     A
040907             1992  ;			LD      C,A
040907             1993  ;			LD      H,A
040907             1994  ;			LD      L,A
040907 21 00 00 00 1995  			LD	HL, 0
04090B 4D          1996  			LD	C, L
04090C C9          1997  			RET
04090D             1998  ;
04090D             1999  ;HEXSTR - convert numeric value to HEX string.
04090D             2000  ;   Inputs: HLH'L'C = integer or floating-point number
04090D             2001  ;  Outputs: String in string accumulator.
04090D             2002  ;           E = string length.  D = ACCS/256
04090D             2003  ;
04090D FD 23       2004  HEXSTS:			INC     IY              ;SKIP TILDE
04090F CD 1D 03 04 2005  			CALL    ITEMN
040913 CD 1A 09 04 2006  			CALL    HEXSTR
040917 3E 80       2007  			LD      A,80H
040919 C9          2008  			RET
04091A             2009  ;
04091A CD 62 06 04 2010  HEXSTR:			CALL    SFIX
04091E 01 08 00 00 2011  			LD      BC,8
040922 11 00 4A 04 2012  			LD      DE,ACCS
040926 C5          2013  HEXST1:			PUSH    BC
040927 06 04       2014  			LD      B,4
040929 AF          2015  			XOR     A
04092A D9          2016  HEXST2:			EXX
04092B 52 29       2017  			ADD.S	HL,HL
04092D D9          2018  			EXX
04092E 52 ED 6A    2019  			ADC.S	HL,HL
040931 17          2020  			RLA
040932 10 F6       2021  			DJNZ    HEXST2
040934 C1          2022  			POP     BC
040935 0D          2023  			DEC     C
040936 F8          2024  			RET     M
040937 28 06       2025  			JR      Z,HEXST3
040939 B7          2026  			OR      A
04093A 20 03       2027  			JR      NZ,HEXST3
04093C B8          2028  			CP      B
04093D 28 E7       2029  			JR      Z,HEXST1
04093F C6 90       2030  HEXST3:			ADD     A,90H
040941 27          2031  			DAA
040942 CE 40       2032  			ADC     A,40H
040944 27          2033  			DAA
040945 12          2034  			LD      (DE),A
040946 13          2035  			INC     DE
040947 47          2036  			LD      B,A
040948 18 DC       2037  			JR      HEXST1
04094A             2038  ;
04094A             2039  ;Function STR - convert numeric value to ASCII string.
04094A             2040  ;   Inputs: HLH'L'C = integer or floating-point number.
04094A             2041  ;  Outputs: String in string accumulator.
04094A             2042  ;           E = length, D = ACCS/256
04094A             2043  ;           A = 80H (type=string)
04094A             2044  ;
04094A             2045  ;First normalise for decimal output:
04094A             2046  ;
04094A CD 70 0A 04 2047  STRS:			CALL    NXT
04094E FE 7E       2048  			CP      '~'
040950 28 BB       2049  			JR      Z,HEXSTS
040952 CD 1D 03 04 2050  			CALL    ITEMN
040956 DD 21 00 4C 2051  			LD      IX,STAVAR
       04          
04095B DD 7E 03    2052  			LD      A,(IX+3)
04095E B7          2053  			OR      A
04095F DD 21 8C 09 2054  			LD      IX,G9-1         ;G9 FORMAT
       04          
040964 28 05       2055  			JR      Z,STR0
040966 DD 21 00 4C 2056  STR:			LD      IX,STAVAR
       04          
04096B 11 00 4A 04 2057  STR0:			LD      DE,ACCS
04096F 3E 25       2058  			LD      A,37
040971 CD 6A 20 04 2059  			CALL    FPP
040975 DA 60 37 04 2060  			JP      C,ERROR_
040979 DD CB 02 46 2061  			BIT     0,(IX+2)
04097D 3E 80       2062  STR1:			LD      A,80H           ;STRING MARKER
04097F C8          2063  			RET     Z
040980 79          2064  			LD      A,C
040981 C6 04       2065  			ADD     A,4
040983 BB          2066  STR2:			CP      E
040984 28 F7       2067  			JR      Z,STR1
040986 EB          2068  			EX      DE,HL
040987 36 20       2069  			LD      (HL),' '        ;TRAILING SPACE
040989 23          2070  			INC     HL
04098A EB          2071  			EX      DE,HL
04098B 18 F6       2072  			JR      STR2
04098D             2073  ;
04098D 09 00       2074  G9:			DW    9
04098F             2075  ;
04098F             2076  ;STRING COMPARE
04098F             2077  ;Compare string (DE) length B with string (HL) length C.
04098F             2078  ;Result preset to false.
04098F             2079  ;
04098F CD 9D 09 04 2080  SCP:			CALL	SCP0
040993             2081  ;
040993 3E 00       2082  ZERO:			LD      A,0
040995 D9          2083  			EXX
040996 67          2084  			LD      H,A
040997 6F          2085  			LD      L,A
040998 D9          2086  			EXX
040999 67          2087  			LD      H,A
04099A 6F          2088  			LD      L,A
04099B 4F          2089  			LD      C,A
04099C C9          2090  			RET
04099D             2091  ;
04099D 04          2092  SCP0:			INC     B
04099E 0C          2093  			INC     C
04099F 05          2094  SCP1:			DEC     B
0409A0 28 0A       2095  			JR      Z,SCP2
0409A2 0D          2096  			DEC     C
0409A3 28 0C       2097  			JR      Z,SCP3
0409A5 1A          2098  			LD      A,(DE)
0409A6 BE          2099  			CP      (HL)
0409A7 C0          2100  			RET     NZ
0409A8 13          2101  			INC     DE
0409A9 23          2102  			INC     HL
0409AA 18 F3       2103  			JR      SCP1
0409AC B7          2104  SCP2:			OR      A
0409AD 0D          2105  			DEC     C
0409AE C8          2106  			RET     Z
0409AF 37          2107  			SCF
0409B0 C9          2108  			RET
0409B1 B7          2109  SCP3:			OR      A
0409B2 0C          2110  			INC     C
0409B3 C9          2111  			RET
0409B4             2112  ;
0409B4             2113  ; PUSHS - SAVE STRING ON STACK.
0409B4             2114  ;     Inputs: String in string accumulator.
0409B4             2115  ;             E = string length.
0409B4             2116  ;             A - saved on stack.
0409B4             2117  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B4             2118  ;
0409B4 CD 4F 16 04 2119  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409B8 DD E1       2120  			POP     IX              	; IX: Return address
0409BA B7          2121  			OR      A               	; Clear the carry flag
0409BB 01 00 00 00 2122  			LD	BC,0			; BC: Length of the string
0409BF 4B          2123  			LD	C,E
0409C0 21 00 4A 04 2124  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C4 11 00 4A 04 2125  			LD	DE,ACCS
0409C8 59          2126  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409C9 ED 52       2127  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CB 39          2128  			ADD     HL,SP			; Grow the stack
0409CC F9          2129  			LD      SP,HL
0409CD 57          2130  			LD      D,A			;  D: This needs to be set to A for some functions
0409CE             2131  ; BEGIN MISSING FROM BINARY
0409CE             2132  			; LD	B,A			; Stack A and C (the string length)
0409CE             2133  			; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409CE             2134  			; LD	B,0			; Reset B to 0 for the LDIR in this function
0409CE             2135  ; END MISSING FROM BINARY
0409CE D5          2136  			PUSH 	DE ; ADDED FROM BINARY
0409CF 28 0B       2137  			JR      Z,PUSHS1        	; Is it zero length?
0409D1 11 00 4A 04 2138  			LD      DE,ACCS			; DE: Destination
0409D5 EB          2139  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409D6 ED B0       2140  			LDIR	                    	; Copy to stack
0409D8 CD 4F 16 04 2141  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409DC DD E9       2142  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409DE             2143  ;
0409DE             2144  ; POPS - RESTORE STRING FROM STACK.
0409DE             2145  ;     Inputs: C = string length.
0409DE             2146  ;    Outputs: String in string accumulator.
0409DE             2147  ;             E = string length.
0409DE             2148  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409DE             2149  ;
0409DE DD E1       2150  POPS:			POP     IX              	; IX: Return address
0409E0 69          2151  			LD	L,C			; Temporarily store string length in L
0409E1 01 00 00 00 2152  			LD	BC,0
0409E5 4D          2153  			LD	C,L			; BC: Number of bytes to copy
0409E6 21 00 00 00 2154  			LD      HL,0			; HL: 0
0409EA 39          2155  			ADD     HL,SP			; HL: Stack address
0409EB 11 00 4A 04 2156  			LD      DE,ACCS			; DE: Destination
0409EF 0C          2157  			INC     C			; Quick check to see if this is a zero length string
0409F0 0D          2158  			DEC     C
0409F1 28 02       2159  			JR      Z,POPS1         	; Yes it is, so skip
0409F3 ED B0       2160  			LDIR                    	; No, so copy from the stack
0409F5 F9          2161  POPS1:			LD      SP,HL			; Shrink the stack
0409F6 DD E9       2162  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F8             2163  ;
0409F8 FD 7E 00    2164  HEXDIG:			LD      A,(IY)
0409FB FE 30       2165  			CP      '0'
0409FD D8          2166  			RET     C
0409FE FE 3A       2167  			CP      '9'+1
040A00 3F          2168  			CCF
040A01 D0          2169  			RET     NC
040A02 FE 41       2170  			CP      'A'
040A04 D8          2171  			RET     C
040A05 D6 37       2172  			SUB     'A'-10
040A07 FE 10       2173  			CP      16
040A09 3F          2174  			CCF
040A0A C9          2175  			RET
040A0B             2176  ;
040A0B FD 7E 00    2177  BINDIG:			LD	A,(IY)
040A0E FE 30       2178  			CP	'0'
040A10 D8          2179  			RET	C
040A11 FE 32       2180  			CP	'1'+1
040A13 3F          2181  			CCF
040A14 C9          2182  			RET
040A15             2183  ;
040A15 FE 3E       2184  RELOP?:			CP      '>'
040A17 D0          2185  			RET     NC
040A18 FE 3D       2186  			CP      '='
040A1A D0          2187  			RET     NC
040A1B FE 3C       2188  			CP      '<'
040A1D C9          2189  			RET
040A1E             2190  ;
040A1E CD 15 03 04 2191  EXPRSC:			CALL    EXPRS
040A22 CD 70 0A 04 2192  COMMA:			CALL    NXT
040A26 FD 23       2193  			INC     IY
040A28 FE 2C       2194  			CP      ','
040A2A C8          2195  			RET     Z
040A2B 3E 05       2196  			LD      A,5
040A2D 18 0B       2197  			JR      ERROR1_EV          ;"Missing ,"
040A2F             2198  ;
040A2F CD 70 0A 04 2199  BRAKET:			CALL    NXT
040A33 FD 23       2200  			INC     IY
040A35 FE 29       2201  			CP      ')'
040A37 C8          2202  			RET     Z
040A38 3E 1B       2203  			LD      A,27
040A3A C3 60 37 04 2204  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A3E             2205  ;
040A3E FD 23       2206  SAVE_EV:			INC     IY
040A40 08          2207  SAVE1:			EX      AF,AF'
040A41 FA 36 03 04 2208  			JP      M,TYPE_EV_
040A45 08          2209  			EX      AF,AF'
040A46 E3          2210  			EX      (SP),HL
040A47 D9          2211  			EXX
040A48 E5          2212  			PUSH    HL
040A49 D9          2213  			EXX
040A4A F5          2214  			PUSH    AF
040A4B C5          2215  			PUSH    BC
040A4C E9          2216  			JP      (HL)
040A4D             2217  ;
040A4D 08          2218  DOIT:			EX      AF,AF'
040A4E FA 36 03 04 2219  			JP      M,TYPE_EV_
040A52 D9          2220  			EXX
040A53 C1          2221  			POP     BC              ;RETURN ADDRESS
040A54 D9          2222  			EXX
040A55 79          2223  			LD      A,C
040A56 C1          2224  			POP     BC
040A57 47          2225  			LD      B,A
040A58 F1          2226  			POP     AF              ;OPERATOR
040A59 D9          2227  			EXX
040A5A EB          2228  			EX      DE,HL
040A5B E1          2229  			POP     HL
040A5C D9          2230  			EXX
040A5D EB          2231  			EX      DE,HL
040A5E E1          2232  			POP     HL
040A5F D9          2233  			EXX
040A60 C5          2234  			PUSH    BC
040A61 D9          2235  			EXX
040A62 E6 0F       2236  			AND     0FH
040A64 CD 6A 20 04 2237  			CALL    FPP
040A68 38 D0       2238  			JR      C,ERROR1_EV
040A6A AF          2239  			XOR     A
040A6B 08          2240  			EX      AF,AF'          ;TYPE
040A6C FD 7E 00    2241  			LD      A,(IY)
040A6F C9          2242  			RET
040A70             2243  ;
040A70             2244  ; Skip spaces
040A70             2245  ; - IY: String pointer
040A70             2246  ; Returns:
040A70             2247  ;  - A: The non-space character found
040A70             2248  ; - IY: Points to the character before that
040A70             2249  ;
040A70 FD 7E 00    2250  NXT:			LD      A,(IY)			; Fetch the character
040A73 FE 20       2251  			CP      ' '			; If it is space, then return
040A75 C0          2252  			RET     NZ
040A76 FD 23       2253  			INC     IY			; Increment the pointer and
040A78 C3 70 0A 04 2254  			JP      NXT			; Loop
040A7C             2255  ;
040A7C E5          2256  DISPT2:			PUSH    HL
040A7D 21 B5 01 04 2257  			LD      HL,SOPTBL
040A81 18 07       2258  			JR      DISPT0
040A83             2259  ;
040A83 E5          2260  DISPAT:			PUSH    HL
040A84 D6 8D       2261  			SUB     FUNTOK
040A86 21 0A 01 04 2262  			LD      HL,FUNTBL
040A8A C5          2263  DISPT0:			PUSH    BC
040A8B             2264  
040A8B 01 03 00 00 2265  			LD	BC, 3
040A8F 47          2266  			LD	B, A
040A90 ED 4C       2267  			MLT	BC
040A92 09          2268  			ADD	HL, BC
040A93 ED 27       2269  			LD	HL, (HL)
040A95             2270  
040A95             2271  ;			ADD     A,A
040A95             2272  ;			LD      C,A
040A95             2273  ;			LD      B,0
040A95             2274  ;			ADD     HL,BC
040A95             2275  ;			LD      A,(HL)
040A95             2276  ;			INC     HL
040A95             2277  ;			LD      H,(HL)
040A95             2278  ;			LD      L,A
040A95             2279  
040A95 C1          2280  			POP     BC
040A96 E3          2281  			EX      (SP),HL
040A97 C9          2282  			RET                     ;OFF TO ROUTINE
040A98             2283  
040A98             2284  ; --- End eval.asm ---
040A98             2285  
040A98             2286  ; --- Begin exec.asm ---
040A98             2287  ;
040A98             2288  ; Title:	BBC Basic Interpreter - Z80 version
040A98             2289  ;		Statement Execution & Assembler Module - "EXEC"
040A98             2290  ; Author:	(C) Copyright  R.T.Russell  1984
040A98             2291  ; Modified By:	Dean Belfield
040A98             2292  ; Created:	12/05/2023
040A98             2293  ; Last Updated:	26/06/2023
040A98             2294  ;
040A98             2295  ; Modinfo:
040A98             2296  ; 27/01/1984:	Version 2.1
040A98             2297  ; 02/03/1987:	Version 3.0
040A98             2298  ; 11/06/1987:	Version 3.1
040A98             2299  ; 12/05/2023:	Modified by Dean Belfield
040A98             2300  ; 07/06/2023:	Modified to run in ADL mode
040A98             2301  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040A98             2302  
040A98             2303  			; .ASSUME	ADL = 1
040A98             2304  
040A98             2305  			; INCLUDE	"equs.inc"
040A98             2306  
040A98             2307  			; SEGMENT CODE
040A98             2308  
040A98             2309  			; XDEF	XEQ
040A98             2310  			; XDEF	CHAIN0
040A98             2311  			; XDEF	RUN
040A98             2312  			; XDEF	SYNTAX
040A98             2313  			; XDEF	ESCAPE
040A98             2314  			; XDEF	FN_EX
040A98             2315  			; XDEF	USR
040A98             2316  			; XDEF	STORE5
040A98             2317  			; XDEF	STORE4
040A98             2318  			; XDEF	CHECK
040A98             2319  			; XDEF	TERMQ
040A98             2320  			; XDEF	FILL
040A98             2321  			; XDEF	X4OR5
040A98             2322  			; XDEF	MUL16
040A98             2323  			; XDEF	CHANEL
040A98             2324  			; XDEF	ASSEM
040A98             2325  
040A98             2326  			; XREF	AUTO
040A98             2327  			; XREF	DELETE
040A98             2328  			; XREF	LOAD
040A98             2329  			; XREF	LIST_
040A98             2330  			; XREF	NEW
040A98             2331  			; XREF	OLD
040A98             2332  			; XREF	RENUM
040A98             2333  			; XREF	SAVE
040A98             2334  			; XREF	SOUND
040A98             2335  			; XREF	CLG
040A98             2336  			; XREF	DRAW
040A98             2337  			; XREF	ENVEL
040A98             2338  			; XREF	GCOL
040A98             2339  			; XREF	MODE
040A98             2340  			; XREF	MOVE
040A98             2341  			; XREF	PLOT
040A98             2342  			; XREF	COLOUR
040A98             2343  			; XREF	EXPRS
040A98             2344  			; XREF	HIMEM
040A98             2345  			; XREF	LOAD0
040A98             2346  			; XREF	RANDOM
040A98             2347  			; XREF	CLEAR
040A98             2348  			; XREF	ERRTRP
040A98             2349  			; XREF	PAGE_
040A98             2350  			; XREF	DATAPTR
040A98             2351  			; XREF	ERRLIN
040A98             2352  			; XREF	TRAP
040A98             2353  			; XREF	NXT
040A98             2354  			; XREF	SETLIN
040A98             2355  			; XREF	CLOOP
040A98             2356  			; XREF	OSSHUT
040A98             2357  			; XREF	WARM
040A98             2358  			; XREF	TRACEN
040A98             2359  			; XREF	OUTCHR
040A98             2360  			; XREF	PBCDL
040A98             2361  			; XREF	OSCLI
040A98             2362  			; XREF	LISTON
040A98             2363  			; XREF	GETVAR
040A98             2364  			; XREF	PUTVAR
040A98             2365  			; XREF	DATPTR
040A98             2366  			; XREF	ERROR_
040A98             2367  			; XREF	EXPR
040A98             2368  			; XREF	CREATE
040A98             2369  			; XREF	EXPRI
040A98             2370  			; XREF	BRAKET
040A98             2371  			; XREF	FREE
040A98             2372  			; XREF	OSBPUT
040A98             2373  			; XREF	COUNT
040A98             2374  			; XREF	STR
040A98             2375  			; XREF	HEXSTR
040A98             2376  			; XREF	CRLF
040A98             2377  			; XREF	ITEMI
040A98             2378  			; XREF	FINDL
040A98             2379  			; XREF	TEST
040A98             2380  			; XREF	EXPRN
040A98             2381  			; XREF	DLOAD5
040A98             2382  			; XREF	DLOAD5_SPL
040A98             2383  			; XREF	LOADN
040A98             2384  			; XREF	FPP
040A98             2385  			; XREF	SWAP
040A98             2386  			; XREF	GETDEF
040A98             2387  			; XREF	ZERO
040A98             2388  			; XREF	OSBGET
040A98             2389  			; XREF	BUFFER
040A98             2390  			; XREF	CONS
040A98             2391  			; XREF	VAL0
040A98             2392  			; XREF	OSLINE
040A98             2393  			; XREF	CLRSCN
040A98             2394  			; XREF	TELL
040A98             2395  			; XREF	SAYLN
040A98             2396  			; XREF	REPORT
040A98             2397  			; XREF	PUTPTR
040A98             2398  			; XREF	PUTIME
040A98             2399  			; XREF	PUTIMS
040A98             2400  			; XREF	LOMEM
040A98             2401  			; XREF	WIDTH
040A98             2402  			; XREF	OSWRCH
040A98             2403  			; XREF	COMMA
040A98             2404  			; XREF	OSCALL
040A98             2405  			; XREF	SFIX
040A98             2406  			; XREF	LOAD4
040A98             2407  			; XREF	PUSHS
040A98             2408  			; XREF	POPS
040A98             2409  			; XREF	LOADS
040A98             2410  			; XREF	PUTCSR
040A98             2411  			; XREF	OUT_
040A98             2412  			; XREF	R0
040A98             2413  ;
040A98             2414  ; List of token values used in this module
040A98             2415  ;
040A98             2416  TAND:			EQU     80H
040A98             2417  TOR:			EQU     84H
040A98             2418  TERROR_EX:			EQU     85H
040A98             2419  LINE_EX_:			EQU     86H
040A98             2420  OFF_:			EQU     87H
040A98             2421  STEP:			EQU     88H
040A98             2422  SPC:			EQU     89H
040A98             2423  TAB:			EQU     8AH
040A98             2424  ELSE_EX_:			EQU     8BH
040A98             2425  THEN_EX_:			EQU     8CH
040A98             2426  LINO_EX:			EQU     8DH
040A98             2427  TO_EX:			EQU     B8H
040A98             2428  TCMD_EX:			EQU     C6H
040A98             2429  TCALL:			EQU     D6H
040A98             2430  DATA_EX_:			EQU     DCH
040A98             2431  DEF_:			EQU     DDH
040A98             2432  TGOSUB:			EQU     E4H
040A98             2433  TGOTO:			EQU     E5H
040A98             2434  TON:			EQU     EEH
040A98             2435  TPROC:			EQU     F2H
040A98             2436  TSTOP:			EQU     FAH
040A98             2437  
040A98             2438  ; The command table
040A98             2439  ; Commands are tokens from C6H onwards; this lookup table is used to
040A98             2440  ; run the corresponding function; Note that DATA and DEF both use the same
040A98             2441  ; code as REM
040A98             2442  ;
040A98 E9 36 04    2443  CMDTAB:			DW24  AUTO			; C6H
040A9B 4C 35 04    2444  			DW24  DELETE			; C7H
040A9E 2A 37 04    2445  			DW24  LOAD			; C8H
040AA1 87 35 04    2446  			DW24  LIST_			; C9H
040AA4 07 37 04    2447  			DW24  NEW			; CAH
040AA7 0D 37 04    2448  			DW24  OLD			; CBH
040AAA 16 36 04    2449  			DW24  RENUM			; CCH
040AAD 3B 37 04    2450  			DW24  SAVE			; CDH
040AB0 A8 15 04    2451  			DW24  PUT			; CEH
040AB3 C8 13 04    2452  			DW24  PTR_EX			; CFH
040AB6 E2 13 04    2453  			DW24  PAGEV_EX			; D0H
040AB9 F5 13 04    2454  			DW24  TIMEV_EX			; D1H
040ABC 1E 14 04    2455  			DW24  LOMEMV_EX			; D2H
040ABF 37 14 04    2456  			DW24  HIMEMV_EX			; D3H
040AC2 26 46 04    2457  			DW24  SOUND			; D4H
040AC5 C2 14 04    2458  			DW24  BPUT			; D5H
040AC8 DA 14 04    2459  			DW24  CALL_			; D6H
040ACB 4C 0B 04    2460  			DW24  CHAIN			; D7H
040ACE 97 13 04    2461  			DW24  CLR			; D8H
040AD1 B6 14 04    2462  			DW24  CLOSE			; D9H
040AD4 C2 43 04    2463  			DW24  CLG			; DAH
040AD7 6A 13 04    2464  			DW24  CLS			; DBH
040ADA 2B 0C 04    2465  			DW24  REM_EX             		; DCH: DATA
040ADD 2B 0C 04    2466  			DW24  REM_EX             		; DDH: DEF
040AE0 F1 0C 04    2467  			DW24  DIM_EX			; DEH
040AE3 EC 45 04    2468  			DW24  DRAW			; DFH
040AE6 C6 0B 04    2469  			DW24  END_			; E0H
040AE9 82 11 04    2470  			DW24  ENDPRO			; E1H
040AEC 46 49 04    2471  			DW24  ENVEL			; E2H
040AEF 97 0F 04    2472  			DW24  FOR_EX			; E3H
040AF2 47 0F 04    2473  			DW24  GOSUB_EX			; E4H
040AF5 2B 0F 04    2474  			DW24  GOTO_EX			; E5H
040AF8 80 45 04    2475  			DW24  GCOL			; E6H
040AFB 36 13 04    2476  			DW24  IF_			; E7H
040AFE 24 12 04    2477  			DW24  INPUT			; E8H
040B01 4C 0C 04    2478  			DW24  LET			; E9H
040B04 27 11 04    2479  			DW24  LOCAL_EX_			; EAH
040B07 D2 43 04    2480  			DW24  MODE			; EBH
040B0A E4 45 04    2481  			DW24  MOVE			; ECH
040B0D E5 0F 04    2482  			DW24  NEXT_EX			; EDH
040B10 BE 0E 04    2483  			DW24  ON_EX_			; EEH
040B13 90 14 04    2484  			DW24  VDU			; EFH
040B16 B2 45 04    2485  			DW24  PLOT			; F0H
040B19 C7 0D 04    2486  			DW24  PRINT_			; F1H
040B1C 84 10 04    2487  			DW24  PROC_EX			; F2H
040B1F D6 12 04    2488  			DW24  READ			; F3H
040B22 2B 0C 04    2489  			DW24  REM_EX			; F4H
040B25 67 0F 04    2490  			DW24  REPEAT_EX			; F5H
040B28 8F 13 04    2491  			DW24  REPOR			; F6H
040B2B A1 13 04    2492  			DW24  RESTOR_EX			; F7H
040B2E 55 0F 04    2493  			DW24  RETURN			; F8H
040B31 46 0B 04    2494  			DW24  RUN			; F9H
040B34 77 13 04    2495  			DW24  STOP			; FAH
040B37 CE 44 04    2496  			DW24  COLOUR			; FBH
040B3A 72 14 04    2497  			DW24  TRACE_EX			; FCH
040B3D 71 0F 04    2498  			DW24  UNTIL_EX			; FDH
040B40 64 14 04    2499  			DW24  WIDTHV			; FEH
040B43 11 0C 04    2500  			DW24  CLI             		; FFH: OSCLI
040B46             2501  
040B46             2502  ; RUN
040B46             2503  ; RUN "filename"
040B46             2504  ;
040B46 CD 7A 17 04 2505  RUN:			CALL    TERMQ			; Standalone RUN command?
040B4A 28 10       2506  			JR      Z,RUN0			; Yes, so just RUN the code
040B4C             2507  
040B4C             2508  ; CHAIN "filename"
040B4C             2509  ;
040B4C CD 15 03 04 2510  CHAIN:			CALL    EXPRS			; Get the filename
040B50 3E 0D       2511  			LD      A,CR			; Terminate it with a CR
040B52 12          2512  			LD      (DE),A
040B53 ED 7B 20 4D 2513  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B58 CD 1F 38 04 2514  			CALL    LOAD0			; And load the file in
040B5C             2515  ;
040B5C ED 7B 20 4D 2516  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B61 DD 21 38 4D 2517  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B66 ED 5F       2518  @@:			LD      A, R			; Use the R register to seed the random number generator
040B68 28 FC       2519  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B6A 07          2520  			RLCA				; Rotate it
040B6B 07          2521  			RLCA
040B6C DD 77 03    2522  			LD      (IX+3),A		; And store
040B6F 9F          2523  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B70 DD 77 04    2524  			LD      (IX+4),A		; And store
040B73 CD 76 38 04 2525  			CALL    CLEAR
040B77 21 00 00 00 2526  			LD      HL,0			; Clear the error trap sysvar
040B7B 22 2C 4D 04 2527  			LD      (ERRTRP),HL
040B7F 2A 14 4D 04 2528  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B83 3E DC       2529  			LD      A,DATA_EX_			; The DATA token value
040B85 CD 4E 18 04 2530  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B89 22 31 4D 04 2531  			LD      (DATPTR),HL     	; Set data pointer
040B8D FD 2A 14 4D 2532  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B92             2533  ;
040B92 CD DA 0B 04 2534  XEQ0:			CALL    NEWLIN
040B96 FD 22 35 4D 2535  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040B9B CD 6D 3F 04 2536  			CALL    TRAP           		; Check keyboard
040B9F CD 70 0A 04 2537  XEQ1:			CALL    NXT
040BA3 FD 23       2538  			INC     IY
040BA5 FE 3A       2539  			CP      ':'             	; Seperator
040BA7 28 F6       2540  			JR      Z,XEQ1
040BA9 FE 0D       2541  			CP      CR
040BAB 28 E5       2542  			JR      Z,XEQ0          	; New program line
040BAD D6 C6       2543  			SUB     TCMD_EX
040BAF DA 3A 0C 04 2544  			JP      C,LET0          	; Implied "LET"
040BB3             2545  
040BB3 01 03 00 00 2546  			LD	BC, 3
040BB7 47          2547  			LD	B, A
040BB8 ED 4C       2548  			MLT	BC
040BBA 21 98 0A 04 2549  			LD	HL,CMDTAB
040BBE 09          2550  			ADD	HL, BC
040BBF ED 27       2551  			LD	HL, (HL)		; Table entry
040BC1             2552  
040BC1             2553  ;			ADD     A,A
040BC1             2554  ;			LD      C,A
040BC1             2555  ;			LD      B,0
040BC1             2556  ;			LD      HL,CMDTAB
040BC1             2557  ;			ADD     HL,BC
040BC1             2558  ;			LD      A,(HL)          	; Table entry
040BC1             2559  ;			INC     HL
040BC1             2560  ;			LD      H,(HL)
040BC1             2561  ;			LD      L,A
040BC1             2562  
040BC1 CD 70 0A 04 2563  			CALL    NXT
040BC5 E9          2564  			JP      (HL)            	; Execute the statement
040BC6             2565  
040BC6             2566  ;END
040BC6             2567  ;
040BC6 CD AE 39 04 2568  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BCA 7C          2569  			LD      A,H
040BCB B5          2570  			OR      L               ;DIRECT?
040BCC CA 80 30 04 2571  			JP      Z,CLOOP
040BD0 1E 00       2572  			LD      E,0
040BD2 CD 2B 43 04 2573  			CALL    OSSHUT          ;CLOSE ALL FILES
040BD6 C3 7F 30 04 2574  			JP      WARM            ;"Ready"
040BDA             2575  ;
040BDA FD 7E 00    2576  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BDD 01 03 00 00 2577  			LD      BC,3
040BE1 FD 09       2578  			ADD     IY,BC
040BE3 B7          2579  			OR      A
040BE4 28 E0       2580  			JR      Z,END_           ;LENGTH=0, EXIT
040BE6 2A 26 4D 04 2581  			LD      HL,(TRACEN)
040BEA 7C          2582  			LD      A,H
040BEB B5          2583  			OR      L
040BEC C8          2584  			RET     Z
040BED 11 00 00 00 2585  			LD	DE, 0		;Clear DE
040BF1 FD 56 FF    2586  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BF4 FD 5E FE    2587  			LD      E,(IY-2)
040BF7 ED 52       2588  			SBC     HL,DE
040BF9 D8          2589  			RET     C
040BFA EB          2590  			EX      DE,HL
040BFB 3E 5B       2591  			LD      A,'['           ;TRACE
040BFD CD 4F 39 04 2592  			CALL    OUTCHR
040C01 CD F7 39 04 2593  			CALL    PBCDL
040C05 3E 5D       2594  			LD      A,']'
040C07 CD 4F 39 04 2595  			CALL    OUTCHR
040C0B 3E 20       2596  			LD      A,' '
040C0D C3 4F 39 04 2597  			JP      OUTCHR
040C11             2598  
040C11             2599  ; Routines for each statement -------------------------------------------------
040C11             2600  
040C11             2601  ; OSCLI
040C11             2602  ;
040C11 CD 15 03 04 2603  CLI:			CALL    EXPRS
040C15 3E 0D       2604  			LD      A,CR
040C17 12          2605  			LD      (DE),A
040C18 21 00 4A 04 2606  			LD      HL,ACCS
040C1C CD 90 3F 04 2607  			CALL    OSCLI
040C20 C3 96 0B 04 2608  			JP      XEQ
040C24             2609  
040C24             2610  ; REM, *
040C24             2611  ;
040C24 FD E5       2612  EXT_EX:			PUSH    IY
040C26 E1          2613  			POP     HL
040C27 CD 90 3F 04 2614  			CALL    OSCLI
040C2B FD E5       2615  REM_EX:			PUSH    IY
040C2D E1          2616  			POP     HL
040C2E 3E 0D       2617  			LD      A,CR
040C30 47          2618  			LD      B,A
040C31 ED B1       2619  			CPIR                    ;FIND LINE END
040C33 E5          2620  			PUSH    HL
040C34 FD E1       2621  			POP     IY
040C36 C3 92 0B 04 2622  			JP      XEQ0
040C3A             2623  
040C3A             2624  ; [LET] var = expr
040C3A             2625  ;
040C3A FE C5       2626  LET0:			CP      ELSE_EX_-TCMD_EX
040C3C 28 ED       2627  			JR      Z,REM_EX
040C3E             2628  			; CP      ('*'-TCMD) & 0FFH
040C3E             2629  			; JR      Z,EXT_EX
040C3E             2630  			; CP      ('='-TCMD) & 0FFH
040C3E             2631  			; JR      Z,FNEND
040C3E             2632  			; CP      ('['-TCMD) & 0FFH
040C3E             2633  			; ez80asm doesn't like () in expressions
040C3E FE 64       2634  			CP      '*'-TCMD_EX & 0FFH
040C40 28 E2       2635  			JR      Z,EXT_EX
040C42 FE 77       2636  			CP      '='-TCMD_EX & 0FFH
040C44 28 5B       2637  			JR      Z,FNEND
040C46 FE 95       2638  			CP      '['-TCMD_EX & 0FFH
040C48 28 25       2639  			JR      Z,ASM
040C4A FD 2B       2640  			DEC     IY
040C4C CD BE 15 04 2641  LET:			CALL    ASSIGN			; Assign the variable
040C50 CA 96 0B 04 2642  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C54 38 41       2643  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C56             2644  ;
040C56 F5          2645  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C57 CD 90 17 04 2646  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C5B E5          2647  			PUSH    HL			; HL: Address of the variable
040C5C CD 15 03 04 2648  			CALL    EXPRS
040C60 DD E1       2649  			POP     IX			; IX: Address of the variable
040C62 F1          2650  			POP     AF			; AF: The variable type
040C63 CD 00 16 04 2651  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C67 C3 96 0B 04 2652  XEQR:			JP      XEQ
040C6B             2653  ;
040C6B CD DA 0B 04 2654  ASM0:			CALL    NEWLIN
040C6F FD 22 35 4D 2655  ASM:			LD      (ERRLIN),IY
       04          
040C74 CD 6D 3F 04 2656  			CALL    TRAP
040C78 CD 9B 18 04 2657  			CALL    ASSEM
040C7C 38 19       2658  			JR      C,SYNTAX
040C7E FE 0D       2659  			CP      CR
040C80 28 E9       2660  			JR      Z,ASM0
040C82 21 40 4D 04 2661  			LD      HL,LISTON
040C86 7E          2662  			LD      A,(HL)
040C87 E6 0F       2663  			AND     0FH
040C89 F6 B0       2664  			OR      B0H
040C8B 77          2665  			LD      (HL),A
040C8C 18 D9       2666  			JR      XEQR
040C8E             2667  ;
040C8E CD 3A 3A 04 2668  VAR_:			CALL    GETVAR
040C92 C8          2669  			RET     Z
040C93 D2 29 3A 04 2670  			JP      NC,PUTVAR
040C97 3E 10       2671  SYNTAX:			LD      A,16            ;"Syntax error"
040C99 18 02       2672  			JR	ERROR0_EX
040C9B 3E 11       2673  ESCAPE:			LD      A,17            ;"Escape"
040C9D C3 60 37 04 2674  ERROR0_EX:			JP      ERROR_
040CA1             2675  
040CA1             2676  ; =
040CA1             2677  ;
040CA1 CD C7 01 04 2678  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CA5 43          2679  			LD      B,E
040CA6 EB          2680  			EX      DE,HL
040CA7 D9          2681  			EXX                     ;SAVE RESULT
040CA8 EB          2682  			EX      DE,HL           ; IN DEB'C'D'E'
040CA9 C1          2683  FNEND5:			POP     BC
040CAA 21 58 17 04 2684  			LD      HL,LOCCHK
040CAE B7          2685  			OR      A
040CAF ED 42       2686  			SBC     HL,BC
040CB1 28 1C       2687  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CB3 21 84 10 04 2688  			LD      HL,FNCHK
040CB7 B7          2689  			OR      A
040CB8 ED 42       2690  			SBC     HL,BC
040CBA 3E 07       2691  			LD      A,7
040CBC 20 DF       2692  			JR      NZ,ERROR0_EX       ;"No FN"
040CBE FD E1       2693  			POP     IY
040CC0 FD 22 35 4D 2694  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CC5 EB          2695  			EX      DE,HL
040CC6 D9          2696  			EXX
040CC7 EB          2697  			EX      DE,HL
040CC8 11 00 4A 04 2698  			LD      DE,ACCS
040CCC 58          2699  			LD      E,B
040CCD 08          2700  			EX      AF,AF'
040CCE C9          2701  			RET
040CCF             2702  ;
040CCF DD E1       2703  FNEND0:			POP     IX
040CD1 C1          2704  			POP     BC
040CD2 78          2705  			LD      A,B
040CD3 B7          2706  			OR      A
040CD4 FA E2 0C 04 2707  			JP      M,FNEND1        ;STRING
040CD8 E1          2708  			POP     HL
040CD9 D9          2709  			EXX
040CDA E1          2710  			POP     HL
040CDB D9          2711  			EXX
040CDC CD D6 15 04 2712  			CALL    STORE
040CE0 18 C7       2713  			JR      FNEND5
040CE2 21 00 00 00 2714  FNEND1:			LD      HL,0
040CE6 39          2715  			ADD     HL,SP
040CE7 D5          2716  			PUSH    DE
040CE8 59          2717  			LD      E,C
040CE9 CD 04 16 04 2718  			CALL    STORES
040CED D1          2719  			POP     DE
040CEE F9          2720  			LD      SP,HL
040CEF 18 B8       2721  			JR      FNEND5
040CF1             2722  
040CF1             2723  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF1             2724  ; DIM var expr[,var expr...]
040CF1             2725  ;
040CF1 CD 3A 3A 04 2726  DIM_EX:			CALL    GETVAR          	; Get the variable
040CF5 DA 81 0D 04 2727  			JP      C,BADDIM		; Throw a "Bad Dim" error
040CF9 CA 8B 0D 04 2728  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040CFD CD AE 3B 04 2729  			CALL    CREATE			; Create a new entity
040D01 E5          2730  			PUSH    HL			; HL: Address of the entity
040D02 DD E1       2731  			POP     IX			; IX: Address of the entity
040D04 FD 7E 00    2732  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D07 FE 28       2733  			CP      '('			; Check for opening brackets
040D09 7A          2734  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D0A 20 7F       2735  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D0C             2736  ;
040D0C             2737  ; At this point we're reserving a variable array
040D0C             2738  ;
040D0C E5          2739  			PUSH    HL			; HL: Address of the entity
040D0D F5          2740  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D0E 11 01 00 00 2741  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D12 42          2742  			LD      B,D			;  B: The number of dimensions in the array
040D13             2743  ;
040D13 FD 23       2744  DIM1:			INC     IY			; Skip to the next token
040D15 C5          2745  			PUSH    BC			; Stack the dimension counter
040D16 D5          2746  			PUSH    DE			; Stack the total size of array accumulator
040D17 DD E5       2747  			PUSH    IX			; Stack the entity address
040D19 CD 0A 03 04 2748  			CALL    EXPRI           	; Fetch the size of this dimension
040D1D CB 7C       2749  			BIT     7,H			; If it is negative then
040D1F 20 60       2750  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D21 D9          2751  			EXX
040D22 23          2752  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D23 DD E1       2753  			POP     IX			; IX: The entity address
040D25 DD 23       2754  			INC     IX
040D27 DD 75 00    2755  			LD      (IX),L          	; Save the size of this dimension in the entity
040D2A DD 23       2756  			INC     IX
040D2C DD 74 00    2757  			LD      (IX),H
040D2F C1          2758  			POP     BC
040D30 CD 72 18 04 2759  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D34 38 4F       2760  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D36 EB          2761  			EX      DE,HL           	; DE: The new total size of array accumulator
040D37 C1          2762  			POP     BC
040D38 04          2763  			INC     B               	;  B: The dimension counter; increment
040D39 FD 7E 00    2764  			LD      A,(IY)			; Fetch the nex token
040D3C FE 2C       2765  			CP      ','             	; Check for another dimension in the array
040D3E 28 D3       2766  			JR      Z,DIM1			; And loop
040D40             2767  ;
040D40 CD 2F 0A 04 2768  			CALL    BRAKET          	; Check for closing bracket
040D44 F1          2769  			POP     AF              	; Restore the type
040D45 DD 23       2770  			INC     IX
040D47 DD E3       2771  			EX      (SP),IX
040D49 DD 70 00    2772  			LD      (IX),B          	; Number of dimensions
040D4C CD 65 18 04 2773  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D50 E1          2774  			POP     HL			; Restore the entity address
040D51 38 32       2775  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D53             2776  ;
040D53             2777  ; We now allocate the memory for the array
040D53             2778  ;
040D53 19          2779  DIM3:			ADD     HL,DE
040D54 38 2F       2780  			JR      C,NOROOM
040D56 E5          2781  			PUSH    HL
040D57 24          2782  			INC     H
040D58 28 2B       2783  			JR      Z,NOROOM
040D5A ED 72       2784  			SBC     HL,SP
040D5C 30 27       2785  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D5E E1          2786  			POP     HL
040D5F 22 1D 4D 04 2787  			LD      (FREE),HL
040D63 7A          2788  DIM2:			LD      A,D
040D64 B3          2789  			OR      E
040D65 28 06       2790  			JR      Z,DIM5
040D67 2B          2791  			DEC     HL
040D68 36 00       2792  			LD      (HL),0         		; Initialise the array
040D6A 1B          2793  			DEC     DE
040D6B 18 F6       2794  			JR      DIM2
040D6D CD 70 0A 04 2795  DIM5:			CALL    NXT
040D71 FE 2C       2796  			CP      ','            		; Another variable?
040D73 C2 96 0B 04 2797  			JP      NZ,XEQ
040D77 FD 23       2798  			INC     IY
040D79 CD 70 0A 04 2799  			CALL    NXT
040D7D C3 F1 0C 04 2800  			JP      DIM_EX
040D81             2801  ;
040D81             2802  ; DIM errors
040D81             2803  ;
040D81 3E 0A       2804  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D83 18 02       2805  			JR	ERROR1_EX
040D85 3E 0B       2806  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D87 C3 60 37 04 2807  ERROR1_EX:			JP      ERROR_
040D8B             2808  ;
040D8B             2809  ; At this point we're reserving a block of memory, i.e.
040D8B             2810  ; DIM var expr[,var expr...]
040D8B             2811  ;
040D8B B7          2812  DIM4:			OR      A			;  A: The dimension variable type
040D8C 28 F3       2813  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D8E FA 81 0D 04 2814  			JP      M,BADDIM        	; or a string
040D92 47          2815  			LD      B,A			; Temporarily store the dimension variable type in B
040D93 FD 7E FF    2816  			LD      A,(IY-1)		; Get the last character but one
040D96 FE 29       2817  			CP      ')'			; Check if it is a trailing bracket
040D98 28 E7       2818  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040D9A             2819  ;
040D9A 21 00 00 00 2820  			LD	HL,0			; Clear HL
040D9E 3A 1D 4D 04 2821  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DA2 6F          2822  			LD	L,A
040DA3 3A 1E 4D 04 2823  			LD	A,(FREE+1)
040DA7 67          2824  			LD	H,A
040DA8 78          2825  			LD	A,B			; Restore the dimension variable type
040DA9 D9          2826  			EXX
040DAA 21 00 00 00 2827  			LD	HL,0			; Clear HL
040DAE 47          2828  			LD	B,A			; Temporarily store the dimension variable type in B
040DAF 3A 1F 4D 04 2829  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB3 6F          2830  			LD	L,A
040DB4 78          2831  			LD	A,B			; Restore the dimension variable type
040DB5 4C          2832  			LD	C,H
040DB6 CD D6 15 04 2833  			CALL    STORE           	; Store the address
040DBA CD 0A 03 04 2834  			CALL    EXPRI			; Get the number of bytes to store
040DBE D9          2835  			EXX
040DBF 23          2836  			INC     HL			; Add one to it
040DC0 EB          2837  			EX      DE,HL
040DC1 2A 1D 4D 04 2838  			LD      HL,(FREE)
040DC5 18 8C       2839  			JR      DIM3			; Continue with the DIM
040DC7             2840  
040DC7             2841  ; PRINT list...
040DC7             2842  ; PRINT #channel,list...
040DC7             2843  ;
040DC7 FE 23       2844  PRINT_:			CP      '#'
040DC9 20 7C       2845  			JR      NZ,PRINT0
040DCB CD 92 18 04 2846  			CALL    CHNL            ;CHANNEL NO. = E
040DCF CD 70 0A 04 2847  PRNTN1:			CALL    NXT
040DD3 FE 2C       2848  			CP      ','
040DD5 C2 96 0B 04 2849  			JP      NZ,XEQ
040DD9 FD 23       2850  			INC     IY
040DDB D5          2851  			PUSH    DE
040DDC CD C7 01 04 2852  			CALL    EXPR            ;ITEM TO PRINT
040DE0 08          2853  			EX      AF,AF'
040DE1 FA 07 0E 04 2854  			JP      M,PRNTN2        ;STRING
040DE5 D1          2855  			POP     DE
040DE6 C5          2856  			PUSH    BC
040DE7 D9          2857  			EXX
040DE8 7D          2858  			LD      A,L
040DE9 D9          2859  			EXX
040DEA CD 3B 43 04 2860  			CALL    OSBPUT
040DEE D9          2861  			EXX
040DEF 7C          2862  			LD      A,H
040DF0 D9          2863  			EXX
040DF1 CD 3B 43 04 2864  			CALL    OSBPUT
040DF5 7D          2865  			LD      A,L
040DF6 CD 3B 43 04 2866  			CALL    OSBPUT
040DFA 7C          2867  			LD      A,H
040DFB CD 3B 43 04 2868  			CALL    OSBPUT
040DFF C1          2869  			POP     BC
040E00 79          2870  			LD      A,C
040E01 CD 3B 43 04 2871  			CALL    OSBPUT
040E05 18 C8       2872  			JR      PRNTN1
040E07 4B          2873  PRNTN2:			LD      C,E
040E08 D1          2874  			POP     DE
040E09 21 00 4A 04 2875  			LD      HL,ACCS
040E0D 0C          2876  			INC     C
040E0E 0D          2877  PRNTN3:			DEC     C
040E0F 28 0A       2878  			JR      Z,PRNTN4
040E11 7E          2879  			LD      A,(HL)
040E12 23          2880  			INC     HL
040E13 C5          2881  			PUSH    BC
040E14 CD 3B 43 04 2882  			CALL    OSBPUT
040E18 C1          2883  			POP     BC
040E19 18 F3       2884  			JR      PRNTN3
040E1B 3E 0D       2885  PRNTN4:			LD      A,CR
040E1D CD 3B 43 04 2886  			CALL    OSBPUT
040E21 18 AC       2887  			JR      PRNTN1
040E23             2888  ;
040E23 06 02       2889  PRINT6:			LD      B,2
040E25 18 27       2890  			JR      PRINTC
040E27 01 00 01 00 2891  PRINT8:			LD      BC,100H
040E2B 18 21       2892  			JR      PRINTC
040E2D 21 00 4C 04 2893  PRINT9:			LD      HL,STAVAR
040E31 AF          2894  			XOR     A
040E32 BE          2895  			CP      (HL)
040E33 28 12       2896  			JR      Z,PRINT0
040E35 3A 3D 4D 04 2897  			LD      A,(COUNT)
040E39 B7          2898  			OR      A
040E3A 28 0B       2899  			JR      Z,PRINT0
040E3C 96          2900  PRINTA:			SUB     (HL)
040E3D 28 08       2901  			JR      Z,PRINT0
040E3F 30 FB       2902  			JR      NC,PRINTA
040E41 ED 44       2903  			NEG
040E43 CD EF 17 04 2904  			CALL    FILL
040E47 3A 00 4C 04 2905  PRINT0:			LD      A,(STAVAR)
040E4B 4F          2906  			LD      C,A             ;PRINTS
040E4C 06 00       2907  			LD      B,0             ;PRINTF
040E4E CD 7A 17 04 2908  PRINTC:			CALL    TERMQ
040E52 28 3F       2909  			JR      Z,PRINT4
040E54 CB 80       2910  			RES     0,B
040E56 FD 23       2911  			INC     IY
040E58 FE 7E       2912  			CP      '~'
040E5A 28 C7       2913  			JR      Z,PRINT6
040E5C FE 3B       2914  			CP      ';'
040E5E 28 C7       2915  			JR      Z,PRINT8
040E60 FE 2C       2916  			CP      ','
040E62 28 C9       2917  			JR      Z,PRINT9
040E64 CD 9F 17 04 2918  			CALL    FORMAT          ;SPC, TAB, '
040E68 28 E4       2919  			JR      Z,PRINTC
040E6A FD 2B       2920  			DEC     IY
040E6C C5          2921  			PUSH    BC
040E6D CD C7 01 04 2922  			CALL    EXPR            ;VARIABLE TYPE
040E71 08          2923  			EX      AF,AF'
040E72 FA 8C 0E 04 2924  			JP      M,PRINT3        ;STRING
040E76 D1          2925  			POP     DE
040E77 D5          2926  			PUSH    DE
040E78 CB 4A       2927  			BIT     1,D
040E7A F5          2928  			PUSH    AF
040E7B CC 66 09 04 2929  			CALL    Z,STR           ;DECIMAL
040E7F F1          2930  			POP     AF
040E80 C4 1A 09 04 2931  			CALL    NZ,HEXSTR       ;HEX
040E84 C1          2932  			POP     BC
040E85 C5          2933  			PUSH    BC
040E86 79          2934  			LD      A,C
040E87 93          2935  			SUB     E
040E88 D4 EF 17 04 2936  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E8C C1          2937  PRINT3:			POP     BC
040E8D CD FE 17 04 2938  			CALL    PTEXT           ;PRINT
040E91 18 BB       2939  			JR      PRINTC
040E93 CB 40       2940  PRINT4:			BIT     0,B
040E95 CC 47 39 04 2941  			CALL    Z,CRLF
040E99 C3 96 0B 04 2942  			JP      XEQ
040E9D             2943  
040E9D             2944  ; ON ERROR statement [:statement...]
040E9D             2945  ; ON ERROR OFF
040E9D             2946  ;
040E9D FD 23       2947  ONERR:			INC     IY              ;SKIP "ERROR"
040E9F 21 00 00 00 2948  			LD      HL,0
040EA3 22 2C 4D 04 2949  			LD      (ERRTRP),HL
040EA7 CD 70 0A 04 2950  			CALL    NXT
040EAB FE 87       2951  			CP      OFF_
040EAD FD 23       2952  			INC     IY
040EAF CA 96 0B 04 2953  			JP      Z,XEQ
040EB3 FD 2B       2954  			DEC     IY
040EB5 FD 22 2C 4D 2955  			LD      (ERRTRP),IY
       04          
040EBA C3 2B 0C 04 2956  			JP      REM_EX
040EBE             2957  
040EBE             2958  ; ON expr GOTO line[,line...] [ELSE statement]
040EBE             2959  ; ON expr GOTO line[,line...] [ELSE line]
040EBE             2960  ; ON expr GOSUB line[,line...] [ELSE statement]
040EBE             2961  ; ON expr GOSUB line[,line...] [ELSE line]
040EBE             2962  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EBE             2963  ;
040EBE FE 85       2964  ON_EX_:			CP      TERROR_EX
040EC0 28 DB       2965  			JR      Z,ONERR         ;"ON ERROR"
040EC2 CD 0A 03 04 2966  			CALL    EXPRI
040EC6 FD 7E 00    2967  			LD      A,(IY)
040EC9 FD 23       2968  			INC     IY
040ECB 1E 2C       2969  			LD      E,','           ;SEPARATOR
040ECD FE E5       2970  			CP      TGOTO
040ECF 28 0B       2971  			JR      Z,ON1
040ED1 FE E4       2972  			CP      TGOSUB
040ED3 28 07       2973  			JR      Z,ON1
040ED5 1E F2       2974  			LD      E,TPROC
040ED7 BB          2975  			CP      E
040ED8 3E 27       2976  			LD      A,39
040EDA 20 45       2977  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EDC 57          2978  ON1:			LD      D,A
040EDD D9          2979  			EXX
040EDE E5          2980  			PUSH    HL
040EDF D9          2981  			EXX
040EE0 C1          2982  			POP     BC              ;ON INDEX
040EE1 78          2983  			LD      A,B
040EE2 B4          2984  			OR      H
040EE3 B5          2985  			OR      L
040EE4 20 2A       2986  			JR      NZ,ON4          ;OUT OF RANGE
040EE6 B1          2987  			OR      C
040EE7 28 27       2988  			JR      Z,ON4
040EE9 0D          2989  			DEC     C
040EEA 28 0E       2990  			JR      Z,ON3           ;INDEX=1
040EEC CD 7A 17 04 2991  ON2:			CALL    TERMQ
040EF0 28 1E       2992  			JR      Z,ON4           ;OUT OF RANGE
040EF2 FD 23       2993  			INC     IY              ;SKIP DELIMITER
040EF4 BB          2994  			CP      E
040EF5 20 F5       2995  			JR      NZ,ON2
040EF7 0D          2996  			DEC     C
040EF8 20 F2       2997  			JR      NZ,ON2
040EFA 7B          2998  ON3:			LD      A,E
040EFB FE F2       2999  			CP      TPROC
040EFD 28 26       3000  			JR      Z,ONPROC
040EFF D5          3001  			PUSH    DE
040F00 CD 25 03 04 3002  			CALL    ITEMI           ;LINE NUMBER
040F04 D1          3003  			POP     DE
040F05 7A          3004  			LD      A,D
040F06 FE E5       3005  			CP      TGOTO
040F08 28 2D       3006  			JR      Z,GOTO2
040F0A CD 87 17 04 3007  			CALL    SPAN            ;SKIP REST OF LIST
040F0E 18 3B       3008  			JR      GOSUB1
040F10             3009  ;
040F10 FD 7E 00    3010  ON4:			LD      A,(IY)
040F13 FD 23       3011  			INC     IY
040F15 FE 8B       3012  			CP      ELSE_EX_
040F17 CA 4B 13 04 3013  			JP      Z,IF1           ;ELSE CLAUSE
040F1B FE 0D       3014  			CP      CR
040F1D 20 F1       3015  			JR      NZ,ON4
040F1F 3E 28       3016  			LD      A,40
040F21 C3 60 37 04 3017  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F25             3018  ;
040F25 3E EE       3019  ONPROC:			LD      A,TON
040F27 C3 84 10 04 3020  			JP      PROC_EX
040F2B             3021  
040F2B             3022  ; GOTO line
040F2B             3023  ;
040F2B CD 25 03 04 3024  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F2F CD 7A 17 04 3025  GOTO1:			CALL    TERMQ			; Check for terminator
040F33 C2 97 0C 04 3026  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F37 D9          3027  GOTO2:			EXX
040F38 CD 8F 39 04 3028  			CALL    FINDL			; HL: Line number - Find the line
040F3C E5          3029  			PUSH    HL			; HL: Address of the line
040F3D FD E1       3030  			POP     IY			; IY = HL
040F3F CA 92 0B 04 3031  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F43 3E 29       3032  			LD      A,41			; Otherwise throw a "No such line" error
040F45 18 DA       3033  			JR      ERROR2_EX
040F47             3034  
040F47             3035  ; GOSUB line
040F47             3036  ; This pushes the following data onto the execution stack
040F47             3037  ; - 3 bytes: Current execution address
040F47             3038  ; - 3 bytes: Marker (the address of label GOSCHK)
040F47             3039  ;
040F47 CD 25 03 04 3040  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F4B FD E5       3041  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F4D CD 4F 16 04 3042  			CALL    CHECK           	; Check there is enough room
040F51 CD 2F 0F 04 3043  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F55             3044  GOSCHK:			EQU     $
040F55             3045  
040F55             3046  ; RETURN
040F55             3047  ; This pops the following data off the execution stack as pushed by GOSUB
040F55             3048  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F55             3049  ; - 3 bytes: The return execution address
040F55             3050  ;
040F55 D1          3051  RETURN:			POP     DE			; Pop the marker off the execution stack
040F56 21 55 0F 04 3052  			LD      HL,GOSCHK		; Compare with GOSCHK
040F5A B7          3053  			OR      A
040F5B ED 52       3054  			SBC     HL,DE
040F5D FD E1       3055  			POP     IY			; Pop the return address off the execution stack
040F5F CA 96 0B 04 3056  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F63 3E 26       3057  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F65 18 BA       3058  			JR      ERROR2_EX
040F67             3059  
040F67             3060  ; REPEAT
040F67             3061  ; This pushes the following data onto the execution stack
040F67             3062  ; - 3 bytes: Current execution address
040F67             3063  ; - 3 bytes: Marker (the address of label REPCHK)
040F67             3064  ;
040F67 FD E5       3065  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F69 CD 4F 16 04 3066  			CALL    CHECK			; Check if there is enough room
040F6D CD 96 0B 04 3067  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F71             3068  REPCHK:			EQU     $
040F71             3069  
040F71             3070  ; UNTIL expr
040F71             3071  ; This pops the following data off the execution stack
040F71             3072  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F71             3073  ; - 3 bytes: The address of the REPEAT instruction
040F71             3074  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F71             3075  ;
040F71 C1          3076  UNTIL_EX:			POP     BC			; Fetch the marker
040F72 C5          3077  			PUSH    BC			; And push it back onto the execution stack
040F73 21 71 0F 04 3078  			LD      HL,REPCHK		; Compare with REPCHK
040F77 B7          3079  			OR      A
040F78 ED 42       3080  			SBC     HL,BC
040F7A 3E 2B       3081  			LD      A,43
040F7C 20 A3       3082  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F7E CD 0A 03 04 3083  			CALL    EXPRI			; Fetch the expression
040F82 CD DF 08 04 3084  			CALL    TEST			; Test if the expression evaluates to zero
040F86 C1          3085  			POP     BC			; Pop the marker
040F87 D1          3086  			POP     DE			; Pop the address of the REPEAT instruction
040F88 20 05       3087  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F8A D5          3088  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F8B C5          3089  			PUSH    BC			; Push the marker back on the stack
040F8C D5          3090  			PUSH    DE			; IY = DE
040F8D FD E1       3091  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F8F C3 96 0B 04 3092  XEQ2:			JP      XEQ			; Continue execution
040F93             3093  
040F93             3094  ; FOR var = expr TO expr [STEP expr]
040F93             3095  ; This pushes the following data onto the execution stack
040F93             3096  ; - 3 bytes: The limit value
040F93             3097  ; - 3 bytes: The step value
040F93             3098  ; - 3 bytes: The current execution address
040F93             3099  ; - 3 bytes: The address of the loop variable
040F93             3100  ; - 3 bytes: Marker (the address of FORCHK)
040F93             3101  ;
040F93 3E 22       3102  FORVAR:			LD      A,34
040F95 18 8A       3103  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F97             3104  ;
040F97 CD BE 15 04 3105  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040F9B 20 F6       3106  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040F9D F5          3107  			PUSH    AF              	; Save the variable type
040F9E FD 7E 00    3108  			LD      A,(IY)			; Check the next token
040FA1 FE B8       3109  			CP      TO_EX			; Compare with the token value for "TO"
040FA3 3E 24       3110  			LD      A,36			; Set the error code to 36 ("No TO")
040FA5 C2 21 0F 04 3111  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FA9 FD 23       3112  			INC     IY			; Skip to the next token
040FAB             3113  ;
040FAB DD E5       3114  			PUSH    IX
040FAD CD 02 03 04 3115  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB1 DD E1       3116  			POP     IX
040FB3 F1          3117  			POP     AF
040FB4 47          3118  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FB5 C5          3119  			PUSH    BC              	; Stack the LIMIT value
040FB6 E5          3120  			PUSH    HL
040FB7 21 00 00 00 3121  			LD      HL,0
040FBB 4C          3122  			LD      C,H
040FBC D9          3123  			EXX
040FBD E5          3124  			PUSH    HL
040FBE             3125  ;
040FBE 21 01 00 00 3126  			LD      HL,1            	; The preset STEP value is 1
040FC2 D9          3127  			EXX
040FC3 FD 7E 00    3128  			LD      A,(IY)			; Fetch the next token
040FC6 FE 88       3129  			CP      STEP			; Compare with the token value for "STEP"
040FC8 20 0A       3130  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FCA             3131  ;
040FCA FD 23       3132  			INC     IY			; Skip past the STEP token
040FCC DD E5       3133  			PUSH    IX
040FCE CD 02 03 04 3134  			CALL    EXPRN          		; Fetch the STEP expression value
040FD2 DD E1       3135  			POP     IX
040FD4             3136  ;
040FD4 C5          3137  FOR1:			PUSH    BC			; Stack the STEP value
040FD5 E5          3138  			PUSH    HL
040FD6 D9          3139  			EXX
040FD7 E5          3140  			PUSH    HL
040FD8 D9          3141  			EXX
040FD9             3142  ;
040FD9 FD E5       3143  			PUSH    IY              	; Stack the current execution address
040FDB DD E5       3144  			PUSH    IX              	; Stack the loop variable
040FDD CD 4F 16 04 3145  			CALL    CHECK
040FE1 CD 96 0B 04 3146  			CALL    XEQ
040FE5             3147  FORCHK:			EQU     $
040FE5             3148  
040FE5             3149  ; NEXT [var[,var...]]
040FE5             3150  ; This pops the following data off the execution stack
040FE5             3151  ; - 3 bytes: Marker (the address of FORCHK)
040FE5             3152  ; - 3 bytes: The address of the loop variable
040FE5             3153  ; - 3 bytes: The current execution address
040FE5             3154  ; - 3 bytes: The step value
040FE5             3155  ; - 3 bytes: The limit value
040FE5             3156  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FE5             3157  ;
040FE5 C1          3158  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FE6 21 E5 0F 04 3159  			LD      HL,FORCHK		; Compare with FORCHK
040FEA B7          3160  			OR      A
040FEB ED 42       3161  			SBC     HL,BC
040FED 3E 20       3162  			LD      A,32
040FEF C2 7B 10 04 3163  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF3 CD 7A 17 04 3164  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FF7 E1          3165  			POP     HL			; Pop the address of the loop variable off the execution stack
040FF8 E5          3166  			PUSH    HL			; Push it back onto the execution stack
040FF9 C5          3167  			PUSH    BC			; Push the marker back onto the execution stack
040FFA E5          3168  			PUSH    HL			; HL: Address of the loop variable off the stack
040FFB C4 3A 3A 04 3169  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040FFF D1          3170  			POP     DE			; DE: Address of the loop variable off the stack
041000 EB          3171  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041001 B7          3172  			OR      A
041002 ED 52       3173  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041004 20 61       3174  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041006 D5          3175  			PUSH    DE
041007 DD 21 0C 00 3176  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
04100C DD 39       3177  			ADD     IX,SP
04100E CD E1 29 04 3178  			CALL    DLOAD5_SPL      	; Load the STEP value
041012 DD 7E 10    3179  			LD      A,(IX+16)       	; Get the STEP type
041015 DD E1       3180  			POP     IX
041017 CD 16 04 04 3181  			CALL    LOADN           	; Load the LOOP variable
04101B CB 7A       3182  			BIT     7,D             	; Check the sign
04101D F5          3183  			PUSH    AF
04101E 3E 0B       3184  			LD      A,'+' & 0FH
041020 CD 6A 20 04 3185  			CALL    FPP             	; Add the STEP
041024 38 55       3186  			JR      C,ERROR3_EX
041026 F1          3187  			POP     AF              	; Restore TYPE
041027 F5          3188  			PUSH    AF
041028 CD D6 15 04 3189  			CALL    STORE           	; Update the variable
04102C DD 21 15 00 3190  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041031 DD 39       3191  			ADD     IX,SP
041033 CD E1 29 04 3192  			CALL    DLOAD5_SPL      	; Load the LIMIT value
041037 F1          3193  			POP     AF
041038 CC D7 08 04 3194  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
04103C             3195  			; LD      A,0+('<'-4) & 0FH
04103C 3E 08       3196  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04103E CD 6A 20 04 3197  			CALL    FPP             	; Test against the limit
041042 38 37       3198  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041044 24          3199  			INC     H
041045 20 14       3200  			JR      NZ,LOOP_        	; Keep looping
041047 21 1B 00 00 3201  			LD      HL,27			; Adjust the stack
04104B 39          3202  			ADD     HL,SP
04104C F9          3203  			LD      SP,HL
04104D CD 70 0A 04 3204  			CALL    NXT
041051 FE 2C       3205  			CP      ','			; Check for multiple variables
041053 C2 96 0B 04 3206  			JP      NZ,XEQ			; No, so we are done at ths point
041057 FD 23       3207  			INC     IY			; Increment to the next variable
041059 18 8A       3208  			JR      NEXT_EX			; And continue
04105B             3209  ;
04105B C1          3210  LOOP_:			POP     BC
04105C D1          3211  			POP     DE
04105D FD E1       3212  			POP     IY
04105F FD E5       3213  			PUSH    IY
041061 D5          3214  			PUSH    DE
041062 C5          3215  			PUSH    BC
041063 C3 96 0B 04 3216  			JP      XEQ
041067             3217  ;
041067 21 1B 00 00 3218  NEXT1:			LD      HL,27			; TODO: What does this do?
04106B 39          3219  			ADD     HL,SP
04106C F9          3220  			LD      SP,HL			; Adjust the stack
04106D C1          3221  			POP     BC
04106E 21 E5 0F 04 3222  			LD      HL,FORCHK
041072 ED 42       3223  			SBC     HL,BC
041074 E1          3224  			POP     HL              	; Variable pointer
041075 E5          3225  			PUSH    HL
041076 C5          3226  			PUSH    BC
041077 28 89       3227  			JR      Z,NEXT0
041079             3228  ;
041079 3E 21       3229  			LD      A,33
04107B C3 60 37 04 3230  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
04107F             3231  
04107F             3232  ; FNname
04107F             3233  ; N.B. ENTERED WITH A <> TON
04107F             3234  ;
04107F F5          3235  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041080 CD 89 10 04 3236  			CALL    PROC1
041084             3237  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041084             3238  
041084             3239  ; PROCname
041084             3240  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
041084             3241  ; This pushes the following data onto the execution stack
041084             3242  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
041084             3243  ; - 3 bytes: Marker (the address of PROCHK)
041084             3244  ;
041084 F5          3245  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041085 CD 89 10 04 3246  			CALL    PROC1			; and is also space reserved on the stack for the return address
041089             3247  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041089             3248  ;
041089 CD 4F 16 04 3249  PROC1:			CALL    CHECK			; Check there is space for this
04108D FD 2B       3250  			DEC     IY			; Decrement IY to the PROC token
04108F FD E5       3251  			PUSH    IY			; Stack the pointer
041091 CD FB 3A 04 3252  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041095 C1          3253  			POP     BC			; BC = IY
041096 28 41       3254  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041098 3E 1E       3255  			LD      A,30
04109A 38 DF       3256  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
04109C             3257  ;
04109C             3258  ; At this point the PROC/FN has not yet been registered in the dynamic area
04109C             3259  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
04109C             3260  ;
04109C C5          3261  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
04109D 2A 14 4D 04 3262  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A1             3263  ;
0410A1 3E DD       3264  PROC2:			LD      A,DEF_			;  A: The token to search for
0410A3 CD 4E 18 04 3265  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410A7 38 26       3266  			JR      C,PROC3			; Not found, so jump to PROC3
0410A9 E5          3267  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410AA FD E1       3268  			POP     IY			; IY = HL
0410AC FD 23       3269  			INC     IY              	; Skip the DEF token
0410AE CD 70 0A 04 3270  			CALL    NXT			; And any whitespace
0410B2 CD FB 3A 04 3271  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410B6 FD E5       3272  			PUSH    IY
0410B8 D1          3273  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410B9 38 09       3274  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410BB C4 AE 3B 04 3275  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410BF FD E5       3276  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C1 D1          3277  			POP     DE			; DE = IY
0410C2 ED 1F       3278  			LD	(HL),DE			; Save address
0410C4             3279  ;
0410C4 EB          3280  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410C5 3E 0D       3281  			LD      A,CR			; The character to search for
0410C7 01 00 01 00 3282  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410CB ED B1       3283  			CPIR                    	; Skip to next line
0410CD 18 D2       3284  			JR      PROC2			; Rinse, lather and repeat
0410CF             3285  ;
0410CF             3286  ; At this point a DEF has not been found for the PROC/FN
0410CF             3287  ;
0410CF FD E1       3288  PROC3:			POP     IY              	; Restore the execution address
0410D1 CD FB 3A 04 3289  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410D5 3E 1D       3290  			LD      A,29
0410D7 20 A2       3291  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410D9             3292  ;
0410D9             3293  ; At this point we have a PROC/FN entry in the dynamic area
0410D9             3294  ;
0410D9 ED 17       3295  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410DB 21 03 00 00 3296  			LD	HL,3
0410DF 39          3297  			ADD     HL,SP
0410E0 CD 70 0A 04 3298  			CALL    NXT             	; Allow space before "("
0410E4 D5          3299  			PUSH    DE              	; Exchange DE and IY
0410E5 FD E3       3300  			EX      (SP),IY
0410E7 FE 28       3301  			CP      '('             	; Arguments?
0410E9 D1          3302  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410EA 20 20       3303  			JR      NZ,PROC5
0410EC CD 70 0A 04 3304  			CALL    NXT             	; Allow space before "("
0410F0 FE 28       3305  			CP      '('
0410F2 C2 97 0C 04 3306  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410F6 FD E5       3307  			PUSH    IY
0410F8 C1          3308  			POP     BC              	; Save IY in BC
0410F9 D9          3309  			EXX
0410FA CD FA 16 04 3310  			CALL    SAVLOC          	; Save local parameters
0410FE CD 2F 0A 04 3311  			CALL    BRAKET          	; Closing bracket
041102 D9          3312  			EXX
041103 C5          3313  			PUSH    BC
041104 FD E1       3314  			POP     IY              	; Restore IY
041106 E5          3315  			PUSH    HL
041107 CD 76 16 04 3316  			CALL    ARGUE           	; Transfer arguments
04110B E1          3317  			POP     HL
04110C             3318  ;
04110C 23          3319  PROC5:			INC	HL			; Increment to the ON PROC flag address
04110D 7E          3320  			LD	A, (HL)			; And fetch the value
04110E 2B          3321  			DEC 	HL
04110F ED 1F       3322  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041111 FE EE       3323  			CP	TON			; Was it "ON PROC"?
041113 C2 96 0B 04 3324  			JP	NZ, XEQ			; No, so back to XEQ
041117 D5          3325  			PUSH    DE			; Exchange DE and IY
041118 FD E3       3326  			EX      (SP),IY
04111A CD 87 17 04 3327  			CALL    SPAN            	; Skip rest of ON list
04111E FD E3       3328  			EX      (SP),IY			; Exchange DE and IY
041120 D1          3329  			POP     DE
041121 ED 1F       3330  			LD	(HL), DE		; Save the return address
041123 C3 96 0B 04 3331  			JP      XEQ
041127             3332  
041127             3333  ; LOCAL var[,var...]
041127             3334  ;
041127 C1          3335  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041128 C5          3336  			PUSH    BC
041129 21 84 10 04 3337  			LD      HL,FNCHK		; Check if we are in a FN
04112D B7          3338  			OR      A
04112E ED 42       3339  			SBC     HL,BC
041130 28 16       3340  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041132 21 89 10 04 3341  			LD      HL,PROCHK		; Now check if we are in a PROC
041136 B7          3342  			OR      A
041137 ED 42       3343  			SBC     HL,BC
041139 28 0D       3344  			JR      Z,LOCAL1		; Again, all good, we can use local
04113B 21 58 17 04 3345  			LD      HL,LOCCHK		; Finally check for the local parameters marker
04113F B7          3346  			OR      A
041140 ED 42       3347  			SBC     HL,BC			; If it is not present, then
041142 3E 0C       3348  			LD      A,12
041144 C2 60 37 04 3349  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041148             3350  ;
041148             3351  ; At this point we are adding a local variable into a PROC or FN
041148             3352  ;
041148 FD E5       3353  LOCAL1:			PUSH    IY			; IY: BASIC pointer
04114A C1          3354  			POP     BC			; BC: Copy of the BASIC pointer
04114B D9          3355  			EXX
04114C FD 2B       3356  			DEC     IY
04114E CD FA 16 04 3357  			CALL    SAVLOC
041152 D9          3358  			EXX
041153 C5          3359  			PUSH    BC
041154 FD E1       3360  			POP     IY
041156             3361  ;
041156 CD 3A 3A 04 3362  LOCAL2:			CALL    GETVAR			; Get the variable location
04115A C2 97 0C 04 3363  			JP      NZ,SYNTAX
04115E B7          3364  			OR      A               	; Check the variable type (80h = string)
04115F 08          3365  			EX      AF,AF'
041160 CD 93 09 04 3366  			CALL    ZERO			; Zero the variable anyway
041164 08          3367  			EX      AF,AF'
041165 F5          3368  			PUSH    AF
041166 F4 D6 15 04 3369  			CALL    P,STORE         	; Call STORE if it is not a string
04116A F1          3370  			POP     AF
04116B 59          3371  			LD      E,C
04116C FC 04 16 04 3372  			CALL    M,STORES		; Call STORES if it is a string
041170 CD 70 0A 04 3373  			CALL    NXT			; Skip to the next character in the expression
041174 FE 2C       3374  			CP      ','			; Is it a comma?
041176 C2 96 0B 04 3375  			JP      NZ,XEQ			; No, so we're done, carry on executing
04117A FD 23       3376  			INC     IY			; Yes, so skip the comma
04117C CD 70 0A 04 3377  			CALL    NXT			; And any whitespace
041180 18 D4       3378  			JR      LOCAL2			; Then loop back and handle any further local variables
041182             3379  
041182             3380  ; ENDPROC
041182             3381  ;
041182 C1          3382  ENDPRO:			POP     BC			; Pop the check value off the stack
041183 21 58 17 04 3383  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041187 B7          3384  			OR      A
041188 ED 42       3385  			SBC     HL,BC
04118A 28 13       3386  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04118C             3387  ;
04118C 21 89 10 04 3388  			LD      HL,PROCHK       	; Check if it is the PROC marker
041190 B7          3389  			OR      A
041191 ED 42       3390  			SBC     HL,BC
041193 FD E1       3391  			POP     IY
041195 CA 96 0B 04 3392  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
041199 3E 0D       3393  			LD      A,13			; Otherwise throw the "No PROC" error
04119B C3 60 37 04 3394  			JP      ERROR_
04119F             3395  ;
04119F DD E1       3396  UNSTK:			POP     IX			; Unstack a single local variable
0411A1 C1          3397  			POP     BC
0411A2 78          3398  			LD      A,B
0411A3 B7          3399  			OR      A
0411A4 FA B2 11 04 3400  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411A8 E1          3401  			POP     HL			; Unstack a normal variable
0411A9 D9          3402  			EXX
0411AA E1          3403  			POP     HL
0411AB D9          3404  			EXX
0411AC CD D6 15 04 3405  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B0 18 D0       3406  			JR      ENDPRO			; And loop back to ENDPRO
0411B2             3407  ;
0411B2 21 00 00 00 3408  UNSTK1:			LD      HL,0			; Unstack a string
0411B6 39          3409  			ADD     HL,SP
0411B7 59          3410  			LD      E,C
0411B8 CD 04 16 04 3411  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411BC F9          3412  			LD      SP,HL
0411BD 18 C3       3413  			JR      ENDPRO
0411BF             3414  
0411BF             3415  ; INPUT #channel,var,var...
0411BF             3416  ;
0411BF CD 92 18 04 3417  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C3 CD 70 0A 04 3418  INPN1:			CALL    NXT
0411C7 FE 2C       3419  			CP      ','
0411C9 C2 96 0B 04 3420  			JP      NZ,XEQ
0411CD FD 23       3421  			INC     IY
0411CF CD 70 0A 04 3422  			CALL    NXT
0411D3 D5          3423  			PUSH    DE
0411D4 CD 8E 0C 04 3424  			CALL    VAR_
0411D8 D1          3425  			POP     DE
0411D9 F5          3426  			PUSH    AF              ;SAVE TYPE
0411DA E5          3427  			PUSH    HL              ;VARPTR
0411DB B7          3428  			OR      A
0411DC FA 08 12 04 3429  			JP      M,INPN2         ;STRING
0411E0 CD 33 43 04 3430  			CALL    OSBGET
0411E4 D9          3431  			EXX
0411E5 6F          3432  			LD      L,A
0411E6 D9          3433  			EXX
0411E7 CD 33 43 04 3434  			CALL    OSBGET
0411EB D9          3435  			EXX
0411EC 67          3436  			LD      H,A
0411ED D9          3437  			EXX
0411EE CD 33 43 04 3438  			CALL    OSBGET
0411F2 6F          3439  			LD      L,A
0411F3 CD 33 43 04 3440  			CALL    OSBGET
0411F7 67          3441  			LD      H,A
0411F8 CD 33 43 04 3442  			CALL    OSBGET
0411FC 4F          3443  			LD      C,A
0411FD DD E1       3444  			POP     IX
0411FF F1          3445  			POP     AF              ;RESTORE TYPE
041200 D5          3446  			PUSH    DE              ;SAVE CHANNEL
041201 CD D6 15 04 3447  			CALL    STORE
041205 D1          3448  			POP     DE
041206 18 BB       3449  			JR      INPN1
041208 21 00 4A 04 3450  INPN2:			LD      HL,ACCS
04120C CD 33 43 04 3451  INPN3:			CALL    OSBGET
041210 FE 0D       3452  			CP      CR
041212 28 04       3453  			JR      Z,INPN4
041214 77          3454  			LD      (HL),A
041215 2C          3455  			INC     L
041216 20 F4       3456  			JR      NZ,INPN3
041218 DD E1       3457  INPN4:			POP     IX
04121A F1          3458  			POP     AF
04121B D5          3459  			PUSH    DE
04121C EB          3460  			EX      DE,HL
04121D CD 00 16 04 3461  			CALL    STACCS
041221 D1          3462  			POP     DE
041222 18 9F       3463  			JR      INPN1
041224             3464  
041224             3465  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3466  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3467  ;
041224 FE 23       3468  INPUT:			CP      '#'
041226 28 97       3469  			JR      Z,INPUTN
041228 0E 00       3470  			LD      C,0             ;FLAG PROMPT
04122A FE 86       3471  			CP      LINE_EX_
04122C 20 04       3472  			JR      NZ,INPUT0
04122E FD 23       3473  			INC     IY              ;SKIP "LINE"
041230 0E 80       3474  			LD      C,80H
041232 21 00 4B 04 3475  INPUT0:			LD      HL,BUFFER
041236 36 0D       3476  			LD      (HL),CR         ;INITIALISE EMPTY
041238 CD 7A 17 04 3477  INPUT1:			CALL    TERMQ
04123C CA 96 0B 04 3478  			JP      Z,XEQ           ;DONE
041240 FD 23       3479  			INC     IY
041242 FE 2C       3480  			CP      ','
041244 28 5C       3481  			JR      Z,INPUT3        ;SKIP COMMA
041246 FE 3B       3482  			CP      ';'
041248 28 58       3483  			JR      Z,INPUT3
04124A E5          3484  			PUSH    HL              ;SAVE BUFFER POINTER
04124B FE 22       3485  			CP      34		;ASCII ""
04124D 20 0C       3486  			JR      NZ,INPUT6
04124F C5          3487  			PUSH    BC
041250 CD 67 04 04 3488  			CALL    CONS
041254 C1          3489  			POP     BC
041255 CD FE 17 04 3490  			CALL    PTEXT           ;PRINT PROMPT
041259 18 06       3491  			JR      INPUT9
04125B CD 9F 17 04 3492  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
04125F 20 05       3493  			JR      NZ,INPUT2
041261 E1          3494  INPUT9:			POP     HL
041262 CB C1       3495  			SET     0,C             ;FLAG NO PROMPT
041264 18 CC       3496  			JR      INPUT0
041266 FD 2B       3497  INPUT2:			DEC     IY
041268 C5          3498  			PUSH    BC
041269 CD 8E 0C 04 3499  			CALL    VAR_
04126D C1          3500  			POP     BC
04126E E1          3501  			POP     HL
04126F F5          3502  			PUSH    AF              ;SAVE TYPE
041270 7E          3503  			LD      A,(HL)
041271 23          3504  			INC     HL
041272 FE 0D       3505  			CP      CR              ;BUFFER EMPTY?
041274 CC A6 12 04 3506  			CALL    Z,REFILL
041278 CB 79       3507  			BIT     7,C
04127A F5          3508  			PUSH    AF
04127B C4 20 18 04 3509  			CALL    NZ,LINES
04127F F1          3510  			POP     AF
041280 CC 0D 18 04 3511  			CALL    Z,FETCHS
041284 F1          3512  			POP     AF              ;RESTORE TYPE
041285 C5          3513  			PUSH    BC
041286 E5          3514  			PUSH    HL
041287 B7          3515  			OR      A
041288 FA 9C 12 04 3516  			JP      M,INPUT4        ;STRING
04128C F5          3517  			PUSH    AF
04128D DD E5       3518  			PUSH    IX
04128F CD 6E 06 04 3519  			CALL    VAL0
041293 DD E1       3520  			POP     IX
041295 F1          3521  			POP     AF
041296 CD D6 15 04 3522  			CALL    STORE
04129A 18 04       3523  			JR      INPUT5
04129C CD 00 16 04 3524  INPUT4:			CALL    STACCS
0412A0 E1          3525  INPUT5:			POP     HL
0412A1 C1          3526  			POP     BC
0412A2 CB 81       3527  INPUT3:			RES     0,C
0412A4 18 92       3528  			JR      INPUT1
0412A6             3529  ;
0412A6 CB 41       3530  REFILL:			BIT     0,C
0412A8 20 0C       3531  			JR      NZ,REFIL0       ;NO PROMPT
0412AA 3E 3F       3532  			LD      A,'?'
0412AC CD 4F 39 04 3533  			CALL    OUTCHR          ;PROMPT
0412B0 3E 20       3534  			LD      A,' '
0412B2 CD 4F 39 04 3535  			CALL    OUTCHR
0412B6 21 00 4B 04 3536  REFIL0:			LD      HL,BUFFER
0412BA C5          3537  			PUSH    BC
0412BB E5          3538  			PUSH    HL
0412BC DD E5       3539  			PUSH    IX
0412BE CD 5F 3E 04 3540  			CALL    OSLINE
0412C2 DD E1       3541  			POP     IX
0412C4 E1          3542  			POP     HL
0412C5 C1          3543  			POP     BC
0412C6 47          3544  			LD      B,A             ;POS AT ENTRY
0412C7 AF          3545  			XOR     A
0412C8 32 3D 4D 04 3546  			LD      (COUNT),A
0412CC B8          3547  			CP      B
0412CD C8          3548  			RET     Z
0412CE 7E          3549  REFIL1:			LD      A,(HL)
0412CF FE 0D       3550  			CP      CR
0412D1 C8          3551  			RET     Z
0412D2 23          3552  			INC     HL
0412D3 10 F9       3553  			DJNZ    REFIL1
0412D5 C9          3554  			RET
0412D6             3555  
0412D6             3556  ; READ var[,var...]
0412D6             3557  ;
0412D6 FE 23       3558  READ:			CP      '#'
0412D8 CA BF 11 04 3559  			JP      Z,INPUTN
0412DC 2A 31 4D 04 3560  			LD      HL,(DATPTR)
0412E0 7E          3561  READ0:			LD      A,(HL)
0412E1 23          3562  			INC     HL              ;SKIP COMMA OR "DATA"
0412E2 FE 0D       3563  			CP      CR              ;END OF DATA STMT?
0412E4 CC 28 13 04 3564  			CALL    Z,GETDAT
0412E8 E5          3565  			PUSH    HL
0412E9 CD 8E 0C 04 3566  			CALL    VAR_
0412ED E1          3567  			POP     HL
0412EE B7          3568  			OR      A
0412EF FA 08 13 04 3569  			JP      M,READ1         ;STRING
0412F3 E5          3570  			PUSH    HL
0412F4 FD E3       3571  			EX      (SP),IY
0412F6 F5          3572  			PUSH    AF              ;SAVE TYPE
0412F7 DD E5       3573  			PUSH    IX
0412F9 CD 02 03 04 3574  			CALL    EXPRN
0412FD DD E1       3575  			POP     IX
0412FF F1          3576  			POP     AF
041300 CD D6 15 04 3577  			CALL    STORE
041304 FD E3       3578  			EX      (SP),IY
041306 18 09       3579  			JR      READ2
041308 CD 0D 18 04 3580  READ1:			CALL    FETCHS
04130C E5          3581  			PUSH    HL
04130D CD 00 16 04 3582  			CALL    STACCS
041311 E1          3583  READ2:			POP     HL
041312 22 31 4D 04 3584  			LD      (DATPTR),HL
041316 CD 70 0A 04 3585  			CALL    NXT
04131A FE 2C       3586  			CP      ','
04131C C2 96 0B 04 3587  			JP      NZ,XEQ
041320 FD 23       3588  			INC     IY
041322 CD 70 0A 04 3589  			CALL    NXT
041326 18 B8       3590  			JR      READ0
041328             3591  ;
041328 3E DC       3592  GETDAT:			LD      A,DATA_EX_
04132A CD 4E 18 04 3593  			CALL    SEARCH_EX
04132E 23          3594  			INC     HL
04132F D0          3595  			RET     NC
041330 3E 2A       3596  			LD      A,42
041332 C3 60 37 04 3597  ERROR4:			JP      ERROR_           ;"Out of DATA"
041336             3598  
041336             3599  ; IF expr statement
041336             3600  ; IF expr THEN statement [ELSE statement]
041336             3601  ; IF expr THEN line [ELSE line]
041336             3602  ;
041336 CD 0A 03 04 3603  IF_:			CALL    EXPRI
04133A CD DF 08 04 3604  			CALL    TEST
04133E 28 19       3605  			JR      Z,IFNOT         ;FALSE
041340 FD 7E 00    3606  			LD      A,(IY)
041343 FE 8C       3607  			CP      THEN_EX_
041345 C2 96 0B 04 3608  			JP      NZ,XEQ
041349 FD 23       3609  			INC     IY              ;SKIP "THEN"
04134B CD 70 0A 04 3610  IF1:			CALL    NXT
04134F FE 8D       3611  			CP      LINO_EX
041351 C2 96 0B 04 3612  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
041355 C3 2B 0F 04 3613  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041359 FD 7E 00    3614  IFNOT:			LD      A,(IY)
04135C FE 0D       3615  			CP      CR
04135E FD 23       3616  			INC     IY
041360 CA 92 0B 04 3617  			JP      Z,XEQ0          ;END OF LINE
041364 FE 8B       3618  			CP      ELSE_EX_
041366 20 F1       3619  			JR      NZ,IFNOT
041368 18 E1       3620  			JR      IF1
04136A             3621  
04136A             3622  ; CLS
04136A             3623  ;
04136A CD CC 43 04 3624  CLS:		CALL    CLRSCN
04136E AF          3625  			XOR     A
04136F 32 3D 4D 04 3626  			LD      (COUNT),A
041373 C3 96 0B 04 3627  			JP      XEQ
041377             3628  
041377             3629  ; STOP
041377             3630  ;
041377 CD 90 3D 04 3631  STOP:			CALL    TELL
04137B 0D          3632  			DB	CR
04137C 0A          3633  			DB	LF
04137D FA          3634  			DB	TSTOP
04137E 00          3635  			DB	0
04137F CD AE 39 04 3636  			CALL    SETLIN          ;FIND CURRENT LINE
041383 CD E2 39 04 3637  			CALL    SAYLN
041387 CD 47 39 04 3638  			CALL    CRLF
04138B C3 80 30 04 3639  			JP      CLOOP
04138F             3640  
04138F             3641  ; REPORT
04138F             3642  ;
04138F CD 82 3D 04 3643  REPOR:			CALL    REPORT
041393 C3 96 0B 04 3644  			JP      XEQ
041397             3645  
041397             3646  ; CLEAR
041397             3647  ;
041397 CD 76 38 04 3648  CLR:			CALL    CLEAR
04139B 2A 14 4D 04 3649  			LD      HL,(PAGE_)
04139F 18 19       3650  			JR      RESTR1
0413A1             3651  
0413A1             3652  ; RESTORE [line]
0413A1             3653  ;
0413A1 2A 14 4D 04 3654  RESTOR_EX:			LD      HL,(PAGE_)
0413A5 CD 7A 17 04 3655  			CALL    TERMQ
0413A9 28 0F       3656  			JR      Z,RESTR1
0413AB CD 25 03 04 3657  			CALL    ITEMI
0413AF D9          3658  			EXX
0413B0 CD 8F 39 04 3659  			CALL    FINDL           ;SEARCH FOR LINE
0413B4 3E 29       3660  			LD      A,41
0413B6 C2 32 13 04 3661  			JP      NZ,ERROR4       ;"No such line"
0413BA 3E DC       3662  RESTR1:			LD      A,DATA_EX_
0413BC CD 4E 18 04 3663  			CALL    SEARCH_EX
0413C0 22 31 4D 04 3664  			LD      (DATPTR),HL
0413C4 C3 96 0B 04 3665  			JP      XEQ
0413C8             3666  
0413C8             3667  ; PTR#channel=expr
0413C8             3668  ; PAGE=expr
0413C8             3669  ; TIME=expr
0413C8             3670  ; LOMEM=expr
0413C8             3671  ; HIMEM=expr
0413C8             3672  ;
0413C8 CD 86 18 04 3673  PTR_EX:			CALL    CHANEL
0413CC CD 90 17 04 3674  			CALL    EQUALS
0413D0 7B          3675  			LD      A,E
0413D1 F5          3676  			PUSH    AF
0413D2 CD 0A 03 04 3677  			CALL    EXPRI
0413D6 E5          3678  			PUSH    HL
0413D7 D9          3679  			EXX
0413D8 D1          3680  			POP     DE
0413D9 F1          3681  			POP     AF
0413DA CD 67 43 04 3682  			CALL    PUTPTR
0413DE C3 96 0B 04 3683  			JP      XEQ
0413E2             3684  ;
0413E2 CD 90 17 04 3685  PAGEV_EX:			CALL    EQUALS
0413E6 CD 0A 03 04 3686  			CALL    EXPRI
0413EA D9          3687  			EXX
0413EB 2E 00       3688  			LD      L,0
0413ED 22 14 4D 04 3689  			LD      (PAGE_),HL
0413F1 C3 96 0B 04 3690  			JP      XEQ
0413F5             3691  ;
0413F5 FE 24       3692  TIMEV_EX:			CP      '$'
0413F7 28 13       3693  			JR      Z,TIMEVS_EX
0413F9 CD 90 17 04 3694  			CALL    EQUALS
0413FD CD 0A 03 04 3695  			CALL    EXPRI
041401 E5          3696  			PUSH    HL
041402 D9          3697  			EXX
041403 D1          3698  			POP     DE
041404 CD 97 3E 04 3699  			CALL    PUTIME
041408 C3 96 0B 04 3700  			JP      XEQ
04140C             3701  ;
04140C FD 23       3702  TIMEVS_EX:			INC     IY              ;SKIP '$'
04140E CD 90 17 04 3703  			CALL    EQUALS
041412 CD 15 03 04 3704  			CALL    EXPRS
041416 CD 46 49 04 3705  			CALL    PUTIMS
04141A C3 96 0B 04 3706  			JP      XEQ
04141E             3707  ;
04141E CD 90 17 04 3708  LOMEMV_EX:			CALL    EQUALS
041422 CD 0A 03 04 3709  			CALL    EXPRI
041426 CD 76 38 04 3710  			CALL    CLEAR
04142A D9          3711  			EXX
04142B 22 1A 4D 04 3712  			LD      (LOMEM),HL
04142F 22 1D 4D 04 3713  			LD      (FREE),HL
041433 C3 96 0B 04 3714  			JP      XEQ
041437             3715  ;
041437 CD 90 17 04 3716  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
04143B CD 0A 03 04 3717  			CALL    EXPRI			; Load the expression into registers
04143F             3718  ; BEGIN MISSING FROM BINARY
04143F             3719  			; LD	A,L			;  A: The MSB of the 24-bit value
04143F             3720  			; EXX				; HL: The LSW of the 24-bit value
04143F             3721  			; LD	(R0),HL
04143F             3722  			; LD	(R0+2),A
04143F             3723  			; LD	HL,(FREE)
04143F             3724  			; LD      DE,256
04143F             3725  			; ADD	HL,DE
04143F             3726  			; EX	DE,HL			; DE: FREE + 256
04143F             3727  			; LD	HL,(R0)			; HL: The passed expression
04143F             3728  ; END MISSING FROM BINARY
04143F             3729  ; BEGIN ADDED FROM BINARY
04143F D9          3730  			exx
041440 ED 5B 1D 4D 3731  			ld de,(FREE)
       04          
041445 14          3732  			inc d
041446             3733  ; END ADDED FROM BINARY
041446 AF          3734  			XOR     A
041447 ED 52       3735  			SBC     HL,DE
041449 19          3736  			ADD     HL,DE			; Do a bounds check
04144A DA 60 37 04 3737  			JP      C,ERROR_         	; Throw the error: "No room"
04144E ED 5B 20 4D 3738  			LD      DE,(HIMEM)
       04          
041453 22 20 4D 04 3739  			LD      (HIMEM),HL
041457 EB          3740  			EX      DE,HL
041458 ED 72       3741  			SBC     HL,SP			; Adjust the stack
04145A C2 96 0B 04 3742  			JP      NZ,XEQ
04145E EB          3743  			EX      DE,HL
04145F F9          3744  			LD      SP,HL           	; Load the SP
041460 C3 96 0B 04 3745  			JP      XEQ
041464             3746  
041464             3747  ; WIDTH expr
041464             3748  ;
041464 CD 0A 03 04 3749  WIDTHV:			CALL    EXPRI
041468 D9          3750  			EXX
041469 7D          3751  			LD      A,L
04146A 32 3E 4D 04 3752  			LD      (WIDTH),A
04146E C3 96 0B 04 3753  			JP      XEQ
041472             3754  
041472             3755  ; TRACE ON
041472             3756  ; TRACE OFF
041472             3757  ; TRACE line
041472             3758  ;
041472 FD 23       3759  TRACE_EX:			INC     IY
041474 21 00 00 00 3760  			LD      HL,0
041478 FE EE       3761  			CP      TON
04147A 28 0B       3762  			JR      Z,TRACE0
04147C FE 87       3763  			CP      OFF_
04147E 28 08       3764  			JR      Z,TRACE1
041480 FD 2B       3765  			DEC     IY
041482 CD 0A 03 04 3766  			CALL    EXPRI
041486 D9          3767  			EXX
041487 2B          3768  TRACE0:			DEC     HL
041488 22 26 4D 04 3769  TRACE1:			LD      (TRACEN),HL
04148C C3 96 0B 04 3770  			JP      XEQ
041490             3771  
041490             3772  ; VDU expr,expr;....
041490             3773  ;
041490             3774  ; BEGIN MISSING FROM BINARY
041490             3775  ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
041490             3776  ; VDU1:			PUSH	IX
041490             3777  ; 			CALL    EXPRI			; Fetch the VDU character
041490             3778  ; 			POP	IX
041490             3779  ; 			EXX
041490             3780  ; 			LD	(IX+0),L		; Write out the character to the buffer
041490             3781  ; 			INC	IX
041490             3782  ; 			LD      A,(IY)			;  A: The separator character
041490             3783  ; 			CP      ','			; Is it a comma?
041490             3784  ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
041490             3785  ; 			CP      ';'			; Is it a semicolon?
041490             3786  ; 			JR      NZ,VDU3			; No, so skip to the next expression
041490             3787  ; 			LD	(IX+0),H		; Write out the high byte to the buffer
041490             3788  ; 			INC	IX
041490             3789  ; VDU2:			INC     IY			; Skip to the next character
041490             3790  ; VDU3:			CALL    TERMQ			; Skip past white space
041490             3791  ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
041490             3792  ; 			LD	A,IXL			;  A: Number of bytes to write out
041490             3793  ; 			OR	A
041490             3794  ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
041490             3795  ; 			LD	HL,BUFFER		; HL: Start of stream
041490             3796  ; 			LD	BC,0
041490             3797  ; 			LD	C,A			; BC: Number of bytes to write out
041490             3798  ; 			RST.LIL	18h			; Output the buffer to MOS
041490             3799  ; END MISSING FROM BINARY
041490             3800  ; BEGIN ADDED FROM BINARY
041490             3801  VDU:
041490 CD 0A 03 04 3802  			call EXPRI
041494 D9          3803  			exx
041495 7D          3804  			ld a,l
041496 CD FA 3E 04 3805  			call PROMPT
04149A FD 7E 00    3806  			ld a,(iy)
04149D FE 2C       3807  			cp $2c
04149F 28 09       3808  			jr z,$+$0b
0414A1 FE 3B       3809  			cp $3b
0414A3 20 07       3810  			jr nz,$+$09
0414A5 7C          3811  			ld a,h
0414A6 CD FA 3E 04 3812  			call PROMPT
0414AA FD 23       3813  			inc iy
0414AC CD 7A 17 04 3814  			call TERMQ
0414B0 20 DE       3815  			jr nz,$-$20
0414B2             3816  ; END ADDED FROM BINARY
0414B2 C3 96 0B 04 3817  VDU4:			JP      XEQ
0414B6             3818  
0414B6             3819  ; CLOSE channel number
0414B6             3820  ;
0414B6 CD 86 18 04 3821  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414BA CD 2B 43 04 3822  			CALL    OSSHUT			; Close the channel
0414BE C3 96 0B 04 3823  			JP      XEQ
0414C2             3824  
0414C2             3825  ; BPUT channel,byte
0414C2             3826  ;
0414C2 CD 86 18 04 3827  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414C6 D5          3828  			PUSH    DE			; DE: Channel number
0414C7 CD 22 0A 04 3829  			CALL    COMMA			; Skip to the next expression
0414CB CD 0A 03 04 3830  			CALL    EXPRI           	; Feth the data
0414CF D9          3831  			EXX
0414D0 7D          3832  			LD      A,L			; A: The byte to write
0414D1 D1          3833  			POP     DE
0414D2 CD 3B 43 04 3834  			CALL    OSBPUT			; Write the byte out
0414D6 C3 96 0B 04 3835  			JP      XEQ
0414DA             3836  
0414DA             3837  ; CALL address[,var[,var...]]
0414DA             3838  ;
0414DA             3839  ; Note that the parameter table differs from the Z80 version
0414DA             3840  ; Each entry now takes up 4 bytes, not 3, so the table is now:
0414DA             3841  ;  -1 byte:  Number of parameters
0414DA             3842  ; Then, for each parameter:
0414DA             3843  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
0414DA             3844  ;  -3 bytes: Parameter address
0414DA             3845  ;
0414DA             3846  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
0414DA             3847  ;
0414DA CD 0A 03 04 3848  CALL_:			CALL    EXPRI           	; Fetch the address
0414DE 7D          3849  			LD	A,L			;  A: MSB of address
0414DF D9          3850  			EXX
0414E0 22 4A 4D 04 3851  			LD	(R0+0),HL		; HL: LSW of address
0414E4 32 4C 4D 04 3852  			LD	(R0+2),A
0414E8 06 00       3853  			LD      B,0             	;  B: The parameter counter
0414EA 11 00 4B 04 3854  			LD      DE,BUFFER       	; DE: Vector
0414EE             3855  ;
0414EE CD 70 0A 04 3856  CALL1:			CALL    NXT			; Skip whitespace
0414F2 FE 2C       3857  			CP      ','			; Check for comma
0414F4 20 1B       3858  			JR      NZ,CALL2		; If no more parameters, then jump here
0414F6 FD 23       3859  			INC     IY			; Skip to the next character
0414F8 04          3860  			INC     B			; Increment the parameter count
0414F9 CD 70 0A 04 3861  			CALL    NXT			; Skip whitespace
0414FD C5          3862  			PUSH    BC
0414FE D5          3863  			PUSH    DE
0414FF CD 8E 0C 04 3864  			CALL    VAR_
041503 D1          3865  			POP     DE
041504 C1          3866  			POP     BC
041505 13          3867  			INC     DE
041506 12          3868  			LD      (DE),A			; Save the parameter type
041507 13          3869  			INC     DE
041508 EB          3870  			EX      DE,HL
041509 ED 1F       3871  			LD	(HL),DE			; Save the parameter address (3 bytes)
04150B 23          3872  			INC	HL
04150C 23          3873  			INC	HL
04150D 23          3874  			INC	HL
04150E EB          3875  			EX      DE,HL
04150F 18 DD       3876  			JR      CALL1
041511             3877  ;
041511 78          3878  CALL2:			LD      A,B
041512 32 00 4B 04 3879  			LD      (BUFFER),A      	; Save the parameter count
041516 2A 4A 4D 04 3880  			LD	HL,(R0)			; HL: Address of the code
04151A CD 34 15 04 3881  			CALL    USR1			; And call it
04151E C3 96 0B 04 3882  			JP      XEQ
041522             3883  
041522             3884  ; USR(address)
041522             3885  ;
041522 CD 25 03 04 3886  USR:			CALL    ITEMI			; Evaluate the expression
041526 7D          3887  			LD	A,L			;  A: MSB of address
041527 D9          3888  			EXX
041528 22 4A 4D 04 3889  			LD	(R0+0),HL		; HL: LSW of address
04152C 32 4C 4D 04 3890  			LD	(R0+2),A
041530 2A 4A 4D 04 3891  			LD	HL,(R0)			; Get the 24-bit address in HL
041534             3892  ;
041534 E5          3893  USR1:			PUSH    HL              	; Address on stack
041535 FD E3       3894  			EX      (SP),IY
041537 24          3895  			INC     H               	; Check for PAGE &00FFxx
041538 B4          3896  			OR	H
041539 21 A3 15 04 3897  			LD      HL,USR2         	; Return address
04153D E5          3898  			PUSH    HL
04153E DD 21 00 4C 3899  			LD      IX,STAVAR
       04          
041543 CC F1 42 04 3900  			CALL    Z,OSCALL        	; Intercept &00FFxx
041547             3901  ;
041547 DD 4E 18    3902  			LD      C, (IX+24)		; F%
04154A C5          3903  			PUSH    BC
04154B             3904  ;
04154B DD 7E 08    3905  			LD	A, (IX+8)		; B% -> MSW
04154E 32 4B 4D 04 3906  			LD	(R0+1), A
041552 DD 7E 09    3907  			LD	A, (IX+9)
041555 32 4C 4D 04 3908  			LD	(R0+2), A
041559 DD 7E 0C    3909  			LD	A, (IX+12)		; C% -> LSB
04155C 32 4A 4D 04 3910  			LD	(R0+0), A
041560 ED 4B 4A 4D 3911  			LD	BC, (R0)
       04          
041565             3912  ;
041565 DD 7E 10    3913  			LD	A, (IX+16)		; D% -> MSW
041568 32 4B 4D 04 3914  			LD	(R0+1), A
04156C DD 7E 11    3915  			LD	A, (IX+17)
04156F 32 4C 4D 04 3916  			LD	(R0+2), A
041573 DD 7E 14    3917  			LD	A, (IX+20)		; E% -> LSB
041576 32 4A 4D 04 3918  			LD	(R0+0), A
04157A ED 5B 4A 4D 3919  			LD	DE, (R0)
       04          
04157F             3920  ;
04157F DD 7E 20    3921  			LD	A, (IX+32)		; H% -> MSW
041582 32 4B 4D 04 3922  			LD	(R0+1), A
041586 DD 7E 21    3923  			LD	A, (IX+33)
041589 32 4C 4D 04 3924  			LD	(R0+2), A
04158D DD 7E 30    3925  			LD	A, (IX+48)		; L% -> LSB
041590 32 4A 4D 04 3926  			LD	(R0+0), A
041594 2A 4A 4D 04 3927  			LD	HL, (R0)
041598             3928  ;
041598 F1          3929  			POP     AF			; F%
041599 DD 7E 04    3930  			LD      A, (IX+4)        	; A%
04159C             3931  
04159C DD 21 00 4B 3932  			LD      IX,BUFFER
       04          
0415A1 FD E9       3933  			JP      (IY)            	; Off to user routine
0415A3             3934  ;
0415A3 FD E1       3935  USR2:			POP     IY
0415A5 AF          3936  			XOR     A
0415A6 4F          3937  			LD      C,A
0415A7 C9          3938  			RET
0415A8             3939  
0415A8             3940  ; PUT port,data
0415A8             3941  ;
0415A8 CD 0A 03 04 3942  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415AC D9          3943  			EXX
0415AD E5          3944  			PUSH    HL
0415AE CD 22 0A 04 3945  			CALL    COMMA
0415B2 CD 0A 03 04 3946  			CALL    EXPRI           ;DATA
0415B6 D9          3947  			EXX
0415B7 C1          3948  			POP     BC
0415B8 ED 69       3949  			OUT     (C),L           ;OUTPUT TO PORT BC
0415BA C3 96 0B 04 3950  			JP      XEQ
0415BE             3951  
0415BE             3952  ; SUBROUTINES -----------------------------------------------------------------
0415BE             3953  
0415BE             3954  ; ASSIGN - Assign a numeric value to a variable.
0415BE             3955  ; Outputs: NC,  Z - OK, numeric.
0415BE             3956  ;          NC, NZ - OK, string.
0415BE             3957  ;           C, NZ - illegal
0415BE             3958  ;
0415BE CD 3A 3A 04 3959  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415C2 D8          3960  			RET     C               	; Return with C if it is an illegal variable
0415C3 C4 29 3A 04 3961  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415C7 B7          3962  			OR      A
0415C8 F8          3963  			RET     M               	; Return if type is string (81h)
0415C9 F5          3964  			PUSH    AF              	; It's a numeric type from this point on
0415CA CD 90 17 04 3965  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415CE E5          3966  			PUSH    HL
0415CF CD 02 03 04 3967  			CALL    EXPRN
0415D3 DD E1       3968  			POP     IX
0415D5 F1          3969  			POP     AF
0415D6 CB 47       3970  STORE:			BIT     0,A
0415D8 28 13       3971  			JR      Z,STOREI
0415DA BF          3972  			CP      A               	; Set the variable to 0
0415DB DD 71 04    3973  STORE5:			LD      (IX+4),C
0415DE D9          3974  STORE4:			EXX
0415DF DD 75 00    3975  			LD      (IX+0),L
0415E2 DD 74 01    3976  			LD      (IX+1),H
0415E5 D9          3977  			EXX
0415E6 DD 75 02    3978  			LD      (IX+2),L
0415E9 DD 74 03    3979  			LD      (IX+3),H
0415EC C9          3980  			RET
0415ED F5          3981  STOREI:			PUSH    AF
0415EE 0C          3982  			INC     C               ;SPEED - & PRESERVE F'
0415EF 0D          3983  			DEC     C               ; WHEN CALLED BY FNEND0
0415F0 C4 62 06 04 3984  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
0415F4 F1          3985  			POP     AF
0415F5 FE 04       3986  			CP      4
0415F7 28 E5       3987  			JR      Z,STORE4
0415F9 BF          3988  			CP      A               ;SET ZERO
0415FA D9          3989  STORE1:			EXX
0415FB DD 75 00    3990  			LD      (IX+0),L
0415FE D9          3991  			EXX
0415FF C9          3992  			RET
041600             3993  ;
041600             3994  ; Copy a string from the string accumulator to variable storage on the stack
041600             3995  ; Parameters:
041600             3996  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041600             3997  ; - IX: Address of the variable storage on the stack
041600             3998  ;
041600 21 00 4A 04 3999  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041604             4000  ;
041604             4001  ; Parameters:
041604             4002  ; As above, but:
041604             4003  ; - HL: Address of the string to be stored
041604             4004  ; -  E: The string length
041604             4005  ; NB:
041604             4006  ; Strings are mutable
041604             4007  ; Strings are stored in the following format in the variable:
041604             4008  ; - Address of the next variable (3 bytes)
041604             4009  ; - The rest of the variable name - this is zero terminated
041604             4010  ; - Current string length (byte)
041604             4011  ; - Maximum (original) string length (byte)
041604             4012  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041604             4013  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041604             4014  ;
041604 1F          4015  STORES:			RRA				; Rotate right to shift bit 0 into carry
041605 30 5D       4016  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041607 E5          4017  			PUSH    HL			; Stack ACCS
041608             4018  ;
041608             4019  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
041608             4020  ;
041608 D9          4021  			EXX				; This block was a call to LOAD4
041609 DD 6E 00    4022  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04160C DD 66 01    4023  			LD      H,(IX+1)		; The maximum original string length
04160F D9          4024  			EXX
041610 DD 27 02    4025  			LD	HL,(IX+2)		; Address of the string (24-bit)
041613             4026  ;
041613 7B          4027  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041614 D9          4028  			EXX
041615 6F          4029  			LD      L,A			; L': Length of string currently stored on the stack
041616 7C          4030  			LD      A,H             	; H': The maximum (original) string length
041617 D9          4031  			EXX
041618 BB          4032  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041619 30 17       4033  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04161B             4034  ;
04161B             4035  ; At this point we're either initialising a new string or assigning more memory to an existing string
04161B             4036  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04161B             4037  ; then the existing and new strings may both exist in memory.
04161B             4038  ;
04161B D9          4039  			EXX
04161C 65          4040  			LD      H,L			; H: Set the maximum string length to the string length
04161D D9          4041  			EXX
04161E E5          4042  			PUSH    HL
04161F 01 00 00 00 4043  			LD	BC, 0
041623 4F          4044  			LD      C,A			; BC: The maximum (original) string length
041624 09          4045  			ADD     HL,BC			; Work out whether this is the last string in memory
041625 ED 4B 1D 4D 4046  			LD      BC,(FREE)
       04          
04162A ED 42       4047  			SBC     HL,BC			; Is string last?
04162C E1          4048  			POP     HL
04162D 37          4049  			SCF
04162E 28 02       4050  			JR      Z,STORS1
041630             4051  			; LD	HL, BC			; HL=BC
041630 C5          4052  			push bc
041631 E1          4053  			pop hl
041632             4054  ;
041632             4055  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041632             4056  ; - H': The maximum (original) string length
041632             4057  ; - L': The actual string length (must be less than H')
041632             4058  ; - HL: Address of the string in memory
041632             4059  ;
041632 D9          4060  STORS1:			EXX				; This block was a call to STORE4
041633 DD 75 00    4061  			LD      (IX+0),L		; The actual string length (must be less then H')
041636 DD 74 01    4062  			LD      (IX+1),H		; The maximum (original) string length
041639 D9          4063  			EXX
04163A DD 2F 02    4064  			LD	(IX+2),HL		; The pointer to the original string
04163D             4065  ;
04163D 01 00 00 00 4066  			LD	BC, 0
041641 4B          4067  			LD      C,E			; BC: The new string length
041642 EB          4068  			EX      DE,HL
041643 E1          4069  			POP     HL
041644 0D          4070  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041645 0C          4071  			INC     C			; check whether BC is 0 without affecting the carry flag
041646 C8          4072  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041647 ED B0       4073  			LDIR				; Replace the string in memory
041649 D0          4074  			RET     NC
04164A ED 53 1D 4D 4075  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
04164F             4076  ;
04164F             4077  ; Check whether the stack is full
04164F             4078  ;
04164F E5          4079  CHECK:			PUSH    HL
041650 C5          4080  			PUSH	BC
041651 2A 1D 4D 04 4081  			LD      HL,(FREE)		; HL: Address of first free space byte
041655 01 00 01 00 4082  			LD	BC,100h			; BC: One page of memory
041659 09          4083  			ADD	HL,BC			; Add a page to FREE
04165A ED 72       4084  			SBC     HL,SP			; And subtract the current SP
04165C C1          4085  			POP	BC
04165D E1          4086  			POP     HL
04165E D8          4087  			RET     C			; The SP is not in the same page, so just return
04165F AF          4088  			XOR     A			; Otherwise
041660 C3 60 37 04 4089  			JP      ERROR_			; Throw error "No room"
041664             4090  ;
041664 01 00 00 00 4091  STORS3:			LD	BC,0
041668 4B          4092  			LD      C,E			; BC: String length
041669 DD E5       4093  			PUSH    IX
04166B D1          4094  			POP     DE			; DE: Destination
04166C AF          4095  			XOR     A			; Check if string length is 0
04166D B9          4096  			CP      C
04166E 28 02       4097  			JR      Z,STORS5		; Yes, so don't copy
041670 ED B0       4098  			LDIR
041672 3E 0D       4099  STORS5:			LD      A,CR			; Finally add the terminator
041674 12          4100  			LD      (DE),A
041675 C9          4101  			RET
041676             4102  
041676             4103  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
041676             4104  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
041676             4105  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
041676             4106  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
041676             4107  ;    Inputs: DE addresses parameter list
041676             4108  ;            IY addresses dummy variable list
041676             4109  ;   Outputs: DE,IY updated
041676             4110  ;  Destroys: Everything
041676             4111  ;
041676 3E FF       4112  ARGUE:			LD      A,-1
041678 F5          4113  			PUSH    AF              	; Put marker on the stack
041679 FD 23       4114  ARGUE1:			INC     IY              	; Bump past '(' or ',''
04167B 13          4115  			INC     DE
04167C D5          4116  			PUSH    DE
04167D CD 70 0A 04 4117  			CALL    NXT			; Skip any whitespace
041681 CD 3A 3A 04 4118  			CALL    GETVAR			; Get the location of the variable in HL/IX
041685 38 3F       4119  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
041687 C4 29 3A 04 4120  			CALL    NZ,PUTVAR
04168B D1          4121  			POP     DE
04168C E5          4122  			PUSH    HL              	; VARPTR
04168D B7          4123  			OR      A               	; Check the variable type
04168E F5          4124  			PUSH    AF
04168F D5          4125  			PUSH    DE
041690 FD E3       4126  			EX      (SP),IY
041692 FA AA 16 04 4127  			JP      M,ARGUE2        	; Jump here if it is a string
041696             4128  ;
041696 CD 02 03 04 4129  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
04169A FD E3       4130  			EX      (SP),IY
04169C D1          4131  			POP     DE
04169D F1          4132  			POP     AF
04169E D9          4133  			EXX
04169F E5          4134  			PUSH    HL
0416A0 D9          4135  			EXX
0416A1 E5          4136  			PUSH    HL
0416A2 47          4137  			LD      B,A
0416A3 C5          4138  			PUSH    BC
0416A4 CD 4F 16 04 4139  			CALL    CHECK           	; Check room
0416A8 18 0F       4140  			JR      ARGUE4
0416AA             4141  ;
0416AA CD 15 03 04 4142  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416AE FD E3       4143  			EX      (SP),IY
0416B0 D9          4144  			EXX
0416B1 D1          4145  			POP     DE
0416B2 D9          4146  			EXX
0416B3 F1          4147  			POP     AF
0416B4 CD B4 09 04 4148  			CALL    PUSHS
0416B8 D9          4149  			EXX
0416B9             4150  ;
0416B9 CD 70 0A 04 4151  ARGUE4:			CALL    NXT			; Skip whitespace
0416BD FE 2C       4152  			CP      ','			; Check to see if the next value is a comma
0416BF 20 0B       4153  			JR      NZ,ARGUE5		; No, so jump here
0416C1 1A          4154  			LD      A,(DE)
0416C2 FE 2C       4155  			CP      ','			; Are there any more arguments?
0416C4 28 B3       4156  			JR      Z,ARGUE1        	; Yes, so loop
0416C6             4157  ;
0416C6 3E 1F       4158  ARGERR:			LD      A,31
0416C8 C3 60 37 04 4159  			JP      ERROR_           	; Throw error "Arguments"
0416CC             4160  ;
0416CC CD 2F 0A 04 4161  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416D0 1A          4162  			LD      A,(DE)
0416D1 FE 29       4163  			CP      ')'
0416D3 20 F1       4164  			JR      NZ,ARGERR
0416D5 13          4165  			INC     DE
0416D6 D9          4166  			EXX
0416D7 C1          4167  ARGUE6:			POP     BC
0416D8 78          4168  			LD      A,B
0416D9 3C          4169  			INC     A
0416DA D9          4170  			EXX
0416DB C8          4171  			RET     Z               	; Marker popped
0416DC D9          4172  			EXX
0416DD 3D          4173  			DEC     A
0416DE FA EE 16 04 4174  			JP      M,ARGUE7        	; If it is a string, then jump here
0416E2 E1          4175  			POP     HL
0416E3 D9          4176  			EXX
0416E4 E1          4177  			POP     HL
0416E5 D9          4178  			EXX
0416E6 DD E1       4179  			POP     IX
0416E8 CD D6 15 04 4180  			CALL    STORE	           	; Write to dummy variable
0416EC 18 E9       4181  			JR      ARGUE6
0416EE             4182  ;
0416EE CD DE 09 04 4183  ARGUE7:			CALL    POPS
0416F2 DD E1       4184  			POP     IX
0416F4 CD 00 16 04 4185  			CALL    STACCS
0416F8 18 DD       4186  			JR      ARGUE6
0416FA             4187  
0416FA             4188  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
0416FA             4189  ;   OF A FUNCTION OR PROCEDURE.
0416FA             4190  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
0416FA             4191  ;    Inputs: IY is parameters pointer
0416FA             4192  ;   Outputs: IY updated
0416FA             4193  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
0416FA             4194  ;
0416FA D1          4195  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
0416FB             4196  ;
0416FB FD 23       4197  SAVLO1:			INC     IY              	; Bump past '(' or ','
0416FD CD 70 0A 04 4198  			CALL    NXT			; And also any whitespace
041701 D5          4199  			PUSH    DE			; Push the return address back onto the stack
041702 D9          4200  			EXX
041703 C5          4201  			PUSH    BC
041704 D5          4202  			PUSH    DE
041705 E5          4203  			PUSH    HL
041706 D9          4204  			EXX
041707 CD 8E 0C 04 4205  			CALL    VAR_             	; Dummy variable
04170B D9          4206  			EXX
04170C E1          4207  			POP     HL
04170D D1          4208  			POP     DE
04170E C1          4209  			POP     BC
04170F D9          4210  			EXX
041710 D1          4211  			POP     DE
041711 B7          4212  			OR      A               	; Check the variable type
041712 FA 25 17 04 4213  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041716 D9          4214  			EXX
041717 E5          4215  			PUSH    HL              	; Save H'L'
041718 D9          4216  			EXX
041719 47          4217  			LD      B,A             	;  B: Variable type
04171A CD 16 04 04 4218  			CALL    LOADN
04171E D9          4219  			EXX
04171F E3          4220  			EX      (SP),HL
041720 D9          4221  			EXX
041721 E5          4222  			PUSH    HL
041722 C5          4223  			PUSH    BC
041723 18 2D       4224  			JR      SAVLO4
041725             4225  ;
041725 F5          4226  SAVLO2:			PUSH    AF              	; Save the type (string)
041726 D5          4227  			PUSH    DE
041727 D9          4228  			EXX
041728 E5          4229  			PUSH    HL
041729 D9          4230  			EXX
04172A CD A0 04 04 4231  			CALL    LOADS
04172E D9          4232  			EXX
04172F E1          4233  			POP     HL
041730 D9          4234  			EXX
041731 01 00 00 00 4235  			LD	BC,0
041735 4B          4236  			LD      C,E			; BC: String length
041736 D1          4237  			POP     DE
041737 CD 4F 16 04 4238  			CALL    CHECK			; Check if there is space on the stack
04173B F1          4239  			POP     AF              	; Level stack
04173C 21 00 00 00 4240  			LD      HL,0
041740 ED 42       4241  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041742 39          4242  			ADD     HL,SP			; Make space for the string on the stack
041743 F9          4243  			LD      SP,HL
041744 47          4244  			LD      B,A             	;  B: Variable type
041745 C5          4245  			PUSH    BC
041746 28 0A       4246  			JR      Z,SAVLO4
041748 D5          4247  			PUSH    DE
041749 11 00 4A 04 4248  			LD      DE,ACCS
04174D EB          4249  			EX      DE,HL
04174E 45          4250  			LD      B,L
04174F ED B0       4251  			LDIR                    	; Save the string onto the stack
041751 D1          4252  			POP     DE
041752             4253  ;
041752 DD E5       4254  SAVLO4:			PUSH    IX			; VARPTR
041754 CD 58 17 04 4255  			CALL    SAVLO5
041758             4256  LOCCHK:			EQU     $
041758 CD 4F 16 04 4257  SAVLO5:			CALL    CHECK
04175C CD 70 0A 04 4258  			CALL    NXT
041760 FE 2C       4259  			CP      ','             	; Are there any more local variables?
041762 28 97       4260  			JR      Z,SAVLO1		; Yes, so loop
041764 EB          4261  			EX      DE,HL			; DE -> HL: The return address
041765 E9          4262  			JP      (HL)            	; And effectvely return
041766             4263  ;
041766 FD 7E 00    4264  DELIM:			LD      A,(IY)          	; Assembler delimiter
041769 FE 20       4265  			CP      ' '
04176B C8          4266  			RET     Z
04176C FE 2C       4267  			CP      ','
04176E C8          4268  			RET     Z
04176F FE 29       4269  			CP      ')'
041771 C8          4270  			RET     Z
041772 FE 3B       4271  TERM:			CP      ';'             	; Assembler terminator
041774 C8          4272  			RET     Z
041775 FE 5C       4273  			CP      '\'
041777 C8          4274  			RET     Z
041778 18 07       4275  			JR      TERM0
04177A             4276  ;
04177A CD 70 0A 04 4277  TERMQ:			CALL    NXT
04177E FE 8B       4278  			CP      ELSE_EX_
041780 D0          4279  			RET     NC
041781 FE 3A       4280  TERM0:			CP      ':'             	; Assembler seperator
041783 D0          4281  			RET     NC
041784 FE 0D       4282  			CP      CR
041786 C9          4283  			RET
041787             4284  ;
041787 CD 7A 17 04 4285  SPAN:			CALL    TERMQ
04178B C8          4286  			RET     Z
04178C FD 23       4287  			INC     IY
04178E 18 F7       4288  			JR      SPAN
041790             4289  ;
041790             4290  ; This snippet is used to check whether an expression is followed by an '=' symbol
041790             4291  ;
041790 CD 70 0A 04 4292  EQUALS:			CALL    NXT			; Skip whitespace
041794 FD 23       4293  			INC     IY			; Skip past the character in question
041796 FE 3D       4294  			CP      '='			; Is it '='
041798 C8          4295  			RET     Z			; Yes, so return
041799 3E 04       4296  			LD      A,4			; Otherwise
04179B C3 60 37 04 4297  			JP      ERROR_           	; Throw error "Mistake"
04179F             4298  ;
04179F FE 8A       4299  FORMAT:			CP      TAB
0417A1 28 0D       4300  			JR      Z,DOTAB
0417A3 FE 89       4301  			CP      SPC
0417A5 28 40       4302  			JR      Z,DOSPC
0417A7 FE 27       4303  			CP      '''
0417A9 C0          4304  			RET     NZ
0417AA CD 47 39 04 4305  			CALL    CRLF
0417AE AF          4306  			XOR     A
0417AF C9          4307  			RET
0417B0             4308  ;
0417B0 C5          4309  DOTAB:			PUSH    BC
0417B1 CD 0A 03 04 4310  			CALL    EXPRI
0417B5 D9          4311  			EXX
0417B6 C1          4312  			POP     BC
0417B7 FD 7E 00    4313  			LD      A,(IY)
0417BA FE 2C       4314  			CP      ','
0417BC 28 14       4315  			JR      Z,DOTAB1
0417BE CD 2F 0A 04 4316  			CALL    BRAKET
0417C2 7D          4317  			LD      A,L
0417C3 21 3D 4D 04 4318  TABIT:			LD      HL,COUNT
0417C7 BE          4319  			CP      (HL)
0417C8 C8          4320  			RET     Z
0417C9 F5          4321  			PUSH    AF
0417CA DC 47 39 04 4322  			CALL    C,CRLF
0417CE F1          4323  			POP     AF
0417CF 96          4324  			SUB     (HL)
0417D0 18 1D       4325  			JR      FILL
0417D2 FD 23       4326  DOTAB1:			INC     IY
0417D4 C5          4327  			PUSH    BC
0417D5 E5          4328  			PUSH    HL
0417D6 CD 0A 03 04 4329  			CALL    EXPRI
0417DA D9          4330  			EXX
0417DB D1          4331  			POP     DE
0417DC C1          4332  			POP     BC
0417DD CD 2F 0A 04 4333  			CALL    BRAKET
0417E1 CD C1 3E 04 4334  			CALL    PUTCSR
0417E5 AF          4335  			XOR     A
0417E6 C9          4336  			RET
0417E7             4337  ;
0417E7 C5          4338  DOSPC:			PUSH    BC
0417E8 CD 25 03 04 4339  			CALL    ITEMI
0417EC D9          4340  			EXX
0417ED 7D          4341  			LD      A,L
0417EE C1          4342  			POP     BC
0417EF B7          4343  FILL:			OR      A
0417F0 C8          4344  			RET     Z
0417F1 C5          4345  			PUSH    BC
0417F2 47          4346  			LD      B,A
0417F3 3E 20       4347  FILL1:			LD      A,' '
0417F5 CD 4F 39 04 4348  			CALL    OUTCHR
0417F9 10 F8       4349  			DJNZ    FILL1
0417FB C1          4350  			POP     BC
0417FC AF          4351  			XOR     A
0417FD C9          4352  			RET
0417FE             4353  ;
0417FE 21 00 4A 04 4354  PTEXT:			LD      HL,ACCS
041802 1C          4355  			INC     E
041803 1D          4356  PTEXT1:			DEC     E
041804 C8          4357  			RET     Z
041805 7E          4358  			LD      A,(HL)
041806 23          4359  			INC     HL
041807 CD 4F 39 04 4360  			CALL    OUTCHR
04180B 18 F6       4361  			JR      PTEXT1
04180D             4362  ;
04180D F5          4363  FETCHS:			PUSH    AF
04180E C5          4364  			PUSH    BC
04180F E5          4365  			PUSH    HL
041810 FD E3       4366  			EX      (SP),IY
041812 CD 2D 18 04 4367  			CALL    XTRACT
041816 CD 70 0A 04 4368  			CALL    NXT
04181A FD E3       4369  			EX      (SP),IY
04181C E1          4370  			POP     HL
04181D C1          4371  			POP     BC
04181E F1          4372  			POP     AF
04181F C9          4373  			RET
041820             4374  ;
041820 11 00 4A 04 4375  LINES:			LD      DE,ACCS
041824 7E          4376  LINE1S:			LD      A,(HL)
041825 12          4377  			LD      (DE),A
041826 FE 0D       4378  			CP      CR
041828 C8          4379  			RET     Z
041829 23          4380  			INC     HL
04182A 1C          4381  			INC     E
04182B 18 F7       4382  			JR      LINE1S
04182D             4383  ;
04182D CD 70 0A 04 4384  XTRACT:			CALL    NXT
041831 FE 22       4385  			CP      '"'
041833 FD 23       4386  			INC     IY
041835 CA 67 04 04 4387  			JP      Z,CONS
041839 FD 2B       4388  			DEC     IY
04183B 11 00 4A 04 4389  			LD      DE,ACCS
04183F FD 7E 00    4390  XTRAC1:			LD      A,(IY)
041842 12          4391  			LD      (DE),A
041843 FE 2C       4392  			CP      ','
041845 C8          4393  			RET     Z
041846 FE 0D       4394  			CP      CR
041848 C8          4395  			RET     Z
041849 FD 23       4396  			INC     IY
04184B 1C          4397  			INC     E
04184C 18 F1       4398  			JR      XTRAC1
04184E             4399  
04184E             4400  ; Search for a token at the start of a program line
04184E             4401  ; - HL: Pointer to the start of a tokenised line in the program area
04184E             4402  ; Returns:
04184E             4403  ; - HL: Pointer to the
04184E             4404  ; -  F: Carry set if not found
04184E             4405  ; Corrupts:
04184E             4406  ; - BC
04184E             4407  ;
04184E 01 00 00 00 4408  SEARCH_EX:			LD      BC,0			; Clear BC
041852             4409  ;
041852 4E          4410  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041853 0C          4411  			INC     C			; Check for 0, i.e. end of program marker
041854 0D          4412  			DEC     C
041855 28 0B       4413  			JR      Z,SRCH2_EX         	; Not found the token, so end
041857 23          4414  			INC     HL			; Skip the line length and line number
041858 23          4415  			INC     HL
041859 23          4416  			INC     HL
04185A BE          4417  			CP      (HL)			; Compare with the token
04185B C8          4418  			RET     Z			; Found it, so return with carry not set
04185C 0D          4419  			DEC     C			; Skip to the next line
04185D 0D          4420  			DEC     C
04185E 0D          4421  			DEC     C
04185F 09          4422  			ADD     HL,BC
041860 18 F0       4423  			JR      SRCH1_EX			; Rinse, lather and repeat
041862             4424  ;
041862 2B          4425  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041863 37          4426  			SCF				; And set the carry flag
041864 C9          4427  			RET
041865             4428  
041865             4429  ; Multiply by 4 or 5
041865             4430  ; This function is used to allocate space for dimensioned variables
041865             4431  ; This is a 24-bit operation
041865             4432  ; - DE: Number to multiple
041865             4433  ; -  A: 04h (Integer) - takes up 4 bytes
041865             4434  ;       05h (Float)   - takes up 5 bytes
041865             4435  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
041865             4436  ; Returns:
041865             4437  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
041865             4438  ; -  F: Carry if overflow
041865             4439  ; Corrupts:
041865             4440  ; - HL
041865 FE 04       4441  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041867             4442  			; LD	HL,DE
041867 D5          4443  			push de
041868 E1          4444  			pop hl
041869 29          4445  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04186A D8          4446  			RET     C			; Exit if overflow
04186B 29          4447  			ADD     HL,HL			; Multiply by 2 again
04186C D8          4448  			RET     C			; Exit if overflow
04186D EB          4449  			EX      DE,HL			; DE: Product
04186E C8          4450  			RET     Z			; Exit if A = 4
04186F 19          4451  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
041870 EB          4452  			EX      DE,HL			; DE: Product
041871 C9          4453  			RET
041872             4454  
041872             4455  ; 16-bit unsigned multiply
041872             4456  ; - HL: Operand 1
041872             4457  ; - BC: Operand 2
041872             4458  ; Returns:
041872             4459  ; - HL: Result
041872             4460  ; -  F: C if overflow
041872             4461  ;
041872 C5          4462  MUL16:			PUSH	BC
041873 51          4463  			LD	D, C			; Set up the registers for the multiplies
041874 5D          4464  			LD	E, L
041875 69          4465  			LD	L, C
041876 4B          4466  			LD	C, E
041877 ED 6C       4467  			MLT	HL			; HL = H * C (*256)
041879 ED 5C       4468  			MLT	DE			; DE = L * C
04187B ED 4C       4469  			MLT	BC			; BC = B * L (*256)
04187D 09          4470  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
04187E C1          4471  			POP	BC
04187F AF          4472  			XOR	A
041880 9C          4473  			SBC	H			; If H is not zero then it's an overflow
041881 D8          4474  			RET	C
041882 65          4475  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
041883 6F          4476  			LD	L, A
041884 19          4477  			ADD	HL, DE
041885 C9          4478  			RET
041886             4479  ;
041886 CD 70 0A 04 4480  CHANEL:			CALL    NXT			; Skip whitespace
04188A FE 23       4481  			CP      '#'			; Check for the '#' symbol
04188C 3E 2D       4482  			LD      A,45
04188E C2 60 37 04 4483  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
041892 FD 23       4484  CHNL:			INC     IY             		; Bump past the '#'
041894 CD 25 03 04 4485  			CALL    ITEMI			; Get the channel number
041898 D9          4486  			EXX
041899 EB          4487  			EX      DE,HL			; DE: The channel number
04189A C9          4488  			RET
04189B             4489  
04189B             4490  ; ASSEMBLER -------------------------------------------------------------------
04189B             4491  
04189B             4492  ; Language independant control section:
04189B             4493  ;  Outputs: A=delimiter, carry set if syntax error.
04189B             4494  ;
04189B CD B5 1D 04 4495  ASSEM:			CALL    SKIP
04189F FD 23       4496  			INC     IY
0418A1 FE 3A       4497  			CP      ':'
0418A3 28 F6       4498  			JR      Z,ASSEM
0418A5 FE 5D       4499  			CP      ']'
0418A7 C8          4500  			RET     Z
0418A8 FE 0D       4501  			CP      CR
0418AA C8          4502  			RET     Z
0418AB FD 2B       4503  			DEC     IY
0418AD DD 2A 40 30 4504  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       11          
0418B2 21 40 4D 04 4505  			LD      HL,LISTON
0418B6 CB 76       4506  			BIT     6,(HL)
0418B8 28 05       4507  			JR      Z,ASSEM0
0418BA DD 2A 3C 30 4508  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       11          
0418BF DD E5       4509  ASSEM0:			PUSH    IX
0418C1 FD E5       4510  			PUSH    IY
0418C3 CD 73 19 04 4511  			CALL    ASMB
0418C7 C1          4512  			POP     BC
0418C8 D1          4513  			POP     DE
0418C9 D8          4514  			RET     C
0418CA CD B5 1D 04 4515  			CALL    SKIP
0418CE 37          4516  			SCF
0418CF C0          4517  			RET     NZ
0418D0 FD 2B       4518  			DEC     IY
0418D2 FD 23       4519  ASSEM3:			INC     IY
0418D4 FD 7E 00    4520  			LD      A,(IY)
0418D7 CD 81 17 04 4521  			CALL    TERM0
0418DB 20 F5       4522  			JR      NZ,ASSEM3
0418DD 3A 40 4D 04 4523  			LD      A,(LISTON)
0418E1 DD E5       4524  			PUSH    IX
0418E3 E1          4525  			POP     HL
0418E4 B7          4526  			OR      A
0418E5 ED 52       4527  			SBC     HL,DE
0418E7 EB          4528  			EX      DE,HL           	; DE: Number of bytes
0418E8 E5          4529  			PUSH    HL
0418E9 2A 40 30 11 4530  			LD      HL,(PC)
0418ED E5          4531  			PUSH    HL
0418EE 19          4532  			ADD     HL,DE
0418EF 22 40 30 11 4533  			LD      (PC),HL         	; Update PC
0418F3 CB 77       4534  			BIT     6,A
0418F5 28 09       4535  			JR      Z,ASSEM5
0418F7 2A 3C 30 11 4536  			LD      HL,(OC)
0418FB 19          4537  			ADD     HL,DE
0418FC 22 3C 30 11 4538  			LD      (OC),HL         	; Update OC
041900 E1          4539  ASSEM5:			POP     HL              	; Old PC
041901 DD E1       4540  			POP     IX              	; Code here
041903 CB 67       4541  			BIT     4,A
041905 28 94       4542  			JR      Z,ASSEM
041907 22 4A 4D 04 4543  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04190B 3A 4C 4D 04 4544  			LD	A,(R0+2)		; Print out the address
04190F CD 5D 19 04 4545  			CALL	HEX_EX
041913 7C          4546  			LD      A,H
041914 CD 5D 19 04 4547  			CALL    HEX_EX
041918 7D          4548  			LD      A,L
041919 CD 55 19 04 4549  			CALL    HEXSP
04191D AF          4550  			XOR     A
04191E BB          4551  			CP      E
04191F 28 18       4552  			JR      Z,ASSEM2
041921             4553  ;
041921 3A 3D 4D 04 4554  ASSEM1:			LD      A,(COUNT)
041925 FE 14       4555  			CP      20
041927 3E 07       4556  			LD      A,7
041929 D4 C3 17 04 4557  			CALL    NC,TABIT        	; Next line
04192D DD 7E 00    4558  			LD      A,(IX)
041930 CD 55 19 04 4559  			CALL    HEXSP
041934 DD 23       4560  			INC     IX
041936 1D          4561  			DEC     E
041937 20 E8       4562  			JR      NZ,ASSEM1
041939             4563  ;
041939 3E 16       4564  ASSEM2:			LD      A,22			; Tab to the disassembly field
04193B CD C3 17 04 4565  			CALL    TABIT
04193F FD E5       4566  			PUSH    IY
041941 E1          4567  			POP     HL
041942 ED 42       4568  			SBC     HL,BC
041944 0A          4569  ASSEM4:			LD      A,(BC)
041945 CD 6C 39 04 4570  			CALL    OUT_
041949 03          4571  			INC     BC
04194A 2D          4572  			DEC     L
04194B 20 F7       4573  			JR      NZ,ASSEM4
04194D CD 47 39 04 4574  			CALL    CRLF
041951 C3 9B 18 04 4575  			JP      ASSEM
041955             4576  ;
041955 CD 5D 19 04 4577  HEXSP:			CALL    HEX_EX
041959 3E 20       4578  			LD      A,' '
04195B 18 12       4579  			JR      OUTCH1
04195D F5          4580  HEX_EX:			PUSH    AF
04195E 0F          4581  			RRCA
04195F 0F          4582  			RRCA
041960 0F          4583  			RRCA
041961 0F          4584  			RRCA
041962 CD 67 19 04 4585  			CALL    HEXOUT
041966 F1          4586  			POP     AF
041967 E6 0F       4587  HEXOUT:			AND     0FH
041969 C6 90       4588  			ADD     A,90H
04196B 27          4589  			DAA
04196C CE 40       4590  			ADC     A,40H
04196E 27          4591  			DAA
04196F C3 6C 39 04 4592  OUTCH1:			JP      OUT_
041973             4593  
041973             4594  ; Processor Specific Translation Section:
041973             4595  ;
041973             4596  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
041973             4597  ;                 C: Opcode beig built
041973             4598  ;                 D: Flags
041973             4599  ;			Bit 7: Set to 1 if the instruction uses long addressing
041973             4600  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
041973             4601  ;                 E: Offset from IX or IY
041973             4602  ;                HL: Numeric operand value
041973             4603  ;                IX: Code destination pointer
041973             4604  ;                IY: Source text pointer
041973             4605  ;    Inputs: A = initial character
041973             4606  ;   Outputs: Carry set if syntax error.
041973             4607  ;
041973 FE 2E       4608  ASMB:			CP      '.'			; Check for a dot; this indicates a label
041975 20 1F       4609  			JR      NZ,ASMB1		; No, so just process the instruction
041977 FD 23       4610  			INC     IY			; Skip past the dot to the label name
041979 DD E5       4611  			PUSH    IX			; Store the code destination pointer
04197B CD 8E 0C 04 4612  			CALL    VAR_			; Create a variable
04197F F5          4613  			PUSH    AF
041980 CD 93 09 04 4614  			CALL    ZERO			; Zero it
041984 3A 42 30 11 4615  			LD	A,(PC+2)
041988 6F          4616  			LD	L,A			; The MSB of the 24-bit address
041989 D9          4617  			EXX
04198A 2A 40 30 11 4618  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
04198E D9          4619  			EXX
04198F F1          4620  			POP     AF
041990 CD D6 15 04 4621  			CALL    STORE			; Store the program counter
041994 DD E1       4622  			POP     IX			; Restore the code destination pointer
041996             4623  ;
041996 3A 40 4D 04 4624  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
04199A E6 80       4625  			AND	80H
04199C 57          4626  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
04199D CD B5 1D 04 4627  			CALL    SKIP			; Skip any whitespace
0419A1 C8          4628  			RET     Z			; And return if there is nothing further to process
0419A2 FE D6       4629  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419A4 0E C4       4630  			LD      C,0C4H			;  A: The base operand
0419A6 FD 23       4631  			INC     IY			; Skip past the token
0419A8 CA EA 1A 04 4632  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419AC FD 2B       4633  			DEC     IY			; Skip back, as we're not doing the above at this point
0419AE 21 CC 1D 04 4634  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419B2 CD 64 1D 04 4635  			CALL    FIND			; Find the opcode
0419B6 D8          4636  			RET     C			; If not found, then return; carry indicates an error condition
0419B7 48          4637  			LD      C,B     		;  C: A copy of the opcode
0419B8             4638  ;
0419B8             4639  ; GROUP 0: Trivial cases requiring no computation
0419B8             4640  ; GROUP 1: As Group 0, but with "ED" prefix
0419B8             4641  ;
0419B8 D6 44       4642  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419BA 30 08       4643  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419BC FE CB       4644  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419BE D4 BD 1C 04 4645  			CALL    NC,ED			; Needs to be prefixed with ED
0419C2 18 76       4646  			JR      BYTE0			; Then write the opcode byte
0419C4             4647  ;
0419C4             4648  ; GROUP 2: BIT, RES, SET
0419C4             4649  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419C4             4650  ;
0419C4 D6 0A       4651  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419C6 30 12       4652  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419C8 FE F9       4653  			CP      3-10			;
0419CA DC 52 1D 04 4654  			CALL    C,BIT_
0419CE D8          4655  			RET     C
0419CF CD 23 1D 04 4656  			CALL    REGLO
0419D3 D8          4657  			RET     C
0419D4 CD C1 1C 04 4658  			CALL    CB
0419D8 18 60       4659  			JR      BYTE0
0419DA             4660  ;
0419DA             4661  ; GROUP 4 - PUSH, POP, EX (SP)
0419DA             4662  ;
0419DA D6 03       4663  GROUP04:		SUB     3			; The number of opcodes in GROUP4
0419DC 30 07       4664  			JR      NC,GROUP05		; If not in that range, then check GROUP5
0419DE CD 45 1D 04 4665  GROUP04_1:		CALL    PAIR_EX
0419E2 D8          4666  			RET     C
0419E3 18 55       4667  			JR      BYTE0
0419E5             4668  ;
0419E5             4669  ; GROUP 5 - SUB, AND, XOR, OR, CP
0419E5             4670  ; GROUP 6 - ADD, ADC, SBC
0419E5             4671  ;
0419E5 D6 0A       4672  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0419E7 30 39       4673  			JR      NC,GROUP07
0419E9 FE FD       4674  			CP      5-8
0419EB 06 07       4675  			LD      B,7
0419ED D4 D1 1C 04 4676  			CALL    NC,OPND			; Get the first operand
0419F1 78          4677  			LD      A,B
0419F2 FE 07       4678  			CP      7			; Is the operand 'A'?
0419F4 20 15       4679  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0419F6             4680  ;
0419F6 CD 23 1D 04 4681  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0419FA 79          4682  			LD      A,C
0419FB 30 2E       4683  			JR      NC,BIND1		; If it is a register, then write that out
0419FD EE 46       4684  			XOR     46H			; Handle ADD A,n
0419FF CD C3 1C 04 4685  			CALL    BIND
041A03 CD 03 1D 04 4686  DB_:			CALL    NUMBER
041A07 C3 BC 1A 04 4687  			JP      VAL8
041A0B             4688  ;
041A0B E6 3F       4689  GROUP05_HL:		AND     3FH
041A0D FE 0C       4690  			CP      12
041A0F 37          4691  			SCF
041A10 C0          4692  			RET     NZ
041A11 79          4693  			LD      A,C
041A12 FE 80       4694  			CP      80H
041A14 0E 09       4695  			LD      C,9
041A16 28 C6       4696  			JR      Z,GROUP04_1
041A18 EE 1C       4697  			XOR     1CH
041A1A 0F          4698  			RRCA
041A1B 4F          4699  			LD      C,A
041A1C CD BD 1C 04 4700  			CALL    ED
041A20 18 BC       4701  			JR      GROUP04_1
041A22             4702  ;
041A22             4703  ; GROUP 7 - INC, DEC
041A22             4704  ;
041A22 D6 02       4705  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A24 30 19       4706  			JR      NC,GROUP08
041A26 CD 2A 1D 04 4707  			CALL    REGHI
041A2A 79          4708  			LD      A,C
041A2B D2 C3 1C 04 4709  BIND1:			JP      NC,BIND
041A2F EE 64       4710  			XOR     64H
041A31 07          4711  			RLCA
041A32 07          4712  			RLCA
041A33 07          4713  			RLCA
041A34 4F          4714  			LD      C,A
041A35 CD 4A 1D 04 4715  			CALL    PAIR1_EX
041A39 D8          4716  			RET     C
041A3A 79          4717  BYTE0:			LD      A,C
041A3B C3 F2 1C 04 4718  			JP      BYTE_
041A3F             4719  ;
041A3F             4720  ; Group 8: IN0, OUT0
041A3F             4721  ;
041A3F D6 02       4722  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A41 30 26       4723  			JR	NC,GROUP09
041A43 FE FF       4724  			CP	1-2
041A45 CC 03 1D 04 4725  			CALL    Z,NUMBER		; Fetch number first if OUT
041A49 08          4726  			EX      AF,AF'			; Save flags
041A4A CD 17 1D 04 4727  			CALL    REG			; Get the register value regardless
041A4E D8          4728  			RET     C			; Return if not a register
041A4F 08          4729  			EX      AF,AF'			; Restore the flags
041A50 DC 03 1D 04 4730  			CALL    C,NUMBER		; Fetch number last if IN
041A54 78          4731  			LD	A,B			; Get the register number
041A55 FE 06       4732  			CP	6			; Fail on (HL)
041A57 37          4733  			SCF
041A58 C8          4734  			RET	Z
041A59 FE 08       4735  			CP	8			; Check it is just single pairs only
041A5B 3F          4736  			CCF
041A5C D8          4737  			RET	C			; And return if it is an invalid register
041A5D 07          4738  			RLCA				; Bind with the operand
041A5E 07          4739  			RLCA
041A5F 07          4740  			RLCA
041A60 81          4741  			ADD	A,C
041A61             4742  ; BEGIN NOT IN BINARY
041A61             4743  			; LD	C,A
041A61             4744  			; CALL	ED			; Prefix with ED
041A61             4745  			; LD	A,C
041A61             4746  ; END NOT IN BINARY
041A61 CD F2 1C 04 4747  			CALL	BYTE_			; Write out the operand
041A65 C3 BC 1A 04 4748  			JP	VAL8			; Write out the value
041A69             4749  ;
041A69             4750  ; GROUP 9 - IN
041A69             4751  ; GROUP 10 - OUT
041A69             4752  ;
041A69 D6 02       4753  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041A6B 30 25       4754  			JR      NC,GROUP11
041A6D FE FF       4755  			CP      1-2			; Check if Group 9 or Group 1
041A6F CC B1 1C 04 4756  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041A73 08          4757  			EX      AF,AF'			; Save flags
041A74 CD 2A 1D 04 4758  			CALL    REGHI			; Get the register value regardless
041A78 D8          4759  			RET     C			; Return if not a register
041A79 08          4760  			EX      AF,AF'			; Restore the flags
041A7A DC B1 1C 04 4761  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041A7E 24          4762  			INC     H			; If it is IN r,(C) or OUT (C),r then
041A7F 28 B9       4763  			JR      Z,BYTE0			; Just write the operand out
041A81             4764  ;
041A81 78          4765  			LD      A,B			; Check the register
041A82 FE 07       4766  			CP      7
041A84 37          4767  			SCF
041A85 C0          4768  			RET     NZ			; If it is not A, then return
041A86             4769  ;
041A86 79          4770  			LD      A,C			; Bind the register with the operand
041A87 EE 03       4771  			XOR     3
041A89 07          4772  			RLCA
041A8A 07          4773  			RLCA
041A8B 07          4774  			RLCA
041A8C CD F2 1C 04 4775  			CALL    BYTE_			; Write out the operand
041A90 18 2A       4776  			JR      VAL8			; And the value
041A92             4777  ;
041A92             4778  ; GROUP 11 - JR, DJNZ
041A92             4779  ;
041A92 D6 02       4780  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041A94 30 2B       4781  			JR      NC,GROUP12
041A96 FE FF       4782  			CP      1-2
041A98 C4 31 1D 04 4783  			CALL    NZ,COND_
041A9C 79          4784  			LD      A,C
041A9D 30 02       4785  			JR      NC,@F
041A9F 3E 18       4786  			LD      A,18H
041AA1 CD F2 1C 04 4787  @@:			CALL    BYTE_
041AA5 CD 03 1D 04 4788  			CALL    NUMBER
041AA9 ED 5B 40 30 4789  			LD      DE,(PC)
       11          
041AAE 13          4790  			INC     DE
041AAF 37          4791  			SCF
041AB0 ED 52       4792  			SBC     HL,DE
041AB2 7D          4793  			LD      A,L
041AB3 17          4794  			RLA
041AB4 9F          4795  			SBC     A,A
041AB5 BC          4796  			CP      H
041AB6 3E 01       4797  TOOFAR:			LD      A,1
041AB8 C2 60 37 04 4798  			JP      NZ,ERROR_		; Throw an "Out of range" error
041ABC 7D          4799  VAL8:			LD      A,L
041ABD C3 F2 1C 04 4800  			JP      BYTE_
041AC1             4801  ;
041AC1             4802  ; GROUP 12 - JP
041AC1             4803  ;
041AC1 D6 01       4804  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AC3 30 21       4805  			JR	NC,GROUP13
041AC5 CD 17 1C 04 4806  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AC9 D8          4807  			RET	C			; Exit if an invalid suffix is provided
041ACA CD 31 1D 04 4808  			CALL    COND_			; Evaluate the conditions
041ACE 79          4809  			LD      A,C
041ACF 30 0D       4810  			JR      NC,GROUP12_1
041AD1 78          4811  			LD      A,B
041AD2 E6 3F       4812  			AND     3FH
041AD4 FE 06       4813  			CP      6
041AD6 3E E9       4814  			LD      A,0E9H
041AD8 CA F2 1C 04 4815  			JP      Z,BYTE_
041ADC 3E C3       4816  			LD      A,0C3H
041ADE CD F2 1C 04 4817  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041AE2 C3 6C 1C 04 4818  			JP	ADDR_			; Output the address
041AE6             4819  ;
041AE6             4820  ; GROUP 13 - CALL
041AE6             4821  ;
041AE6 D6 01       4822  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041AE8 30 0C       4823  			JR	NC,GROUP14
041AEA CD 2F 1C 04 4824  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041AEE CD 11 1B 04 4825  			CALL    GROUP15_1		; Output the opcode (with conditions)
041AF2 C3 6C 1C 04 4826  			JP	ADDR_			; Output the address
041AF6             4827  ;
041AF6             4828  ; GROUP 14 - RST
041AF6             4829  ;
041AF6 D6 01       4830  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041AF8 30 13       4831  			JR	NC,GROUP15
041AFA CD 2F 1C 04 4832  			CALL	EZ80SF_FULL		; Evaluate the suffix
041AFE D8          4833  			RET	C			; Exit if an invalid suffix provided
041AFF CD 03 1D 04 4834  			CALL    NUMBER
041B03 A1          4835  			AND     C
041B04 B4          4836  			OR      H
041B05 20 AF       4837  			JR      NZ,TOOFAR
041B07 7D          4838  			LD      A,L
041B08 B1          4839  			OR      C
041B09 C3 F2 1C 04 4840  	  		JP      BYTE_
041B0D             4841  ;
041B0D             4842  ; GROUP 15 - RET
041B0D             4843  ;
041B0D D6 01       4844  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B0F 30 0F       4845  			JR	NC,GROUP16
041B11 CD 31 1D 04 4846  GROUP15_1:		CALL    COND_
041B15 79          4847  			LD      A,C
041B16 D2 F2 1C 04 4848  			JP      NC,BYTE_
041B1A F6 09       4849  			OR      9
041B1C C3 F2 1C 04 4850  			JP      BYTE_
041B20             4851  ;
041B20             4852  ; GROUP 16 - LD
041B20             4853  ;
041B20 D6 01       4854  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B22 30 74       4855  			JR	NC,GROUP17
041B24 CD 2F 1C 04 4856  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B28 CD 60 1D 04 4857  			CALL    LDOP			; Check for accumulator loads
041B2C D2 8C 1C 04 4858  			JP      NC,LDA			; Yes, so jump here
041B30 CD 2A 1D 04 4859  			CALL    REGHI
041B34 08          4860  			EX      AF,AF'
041B35 CD B5 1D 04 4861  			CALL    SKIP
041B39 FE 28       4862  			CP      '('			; Check for bracket
041B3B 28 24       4863  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B3D 08          4864  			EX      AF,AF'
041B3E D2 F6 19 04 4865  			JP      NC,GROUP05_1		; Load single register direct; go here
041B42 0E 01       4866  			LD      C,1
041B44 CD 4A 1D 04 4867  			CALL    PAIR1_EX
041B48 D8          4868  			RET     C
041B49 3E 0E       4869  			LD      A,14
041B4B B8          4870  			CP      B
041B4C 47          4871  			LD      B,A
041B4D CC 45 1D 04 4872  			CALL    Z,PAIR_EX
041B51 78          4873  			LD      A,B
041B52 E6 3F       4874  			AND     3FH
041B54 FE 0C       4875  			CP      12
041B56 79          4876  			LD      A,C
041B57 C2 DE 1A 04 4877  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B5B 3E F9       4878  			LD      A,0F9H
041B5D C3 F2 1C 04 4879  			JP      BYTE_
041B61             4880  ;
041B61 08          4881  LDIN:			EX      AF,AF'
041B62 C5          4882  			PUSH    BC
041B63 D4 23 1D 04 4883  			CALL    NC,REGLO
041B67 79          4884  			LD      A,C
041B68 C1          4885  			POP     BC
041B69 D2 C3 1C 04 4886  			JP      NC,BIND
041B6D 0E 0A       4887  			LD      C,0AH
041B6F CD 4A 1D 04 4888  			CALL    PAIR1_EX
041B73 CD 97 1C 04 4889  			CALL    LD16
041B77 D2 DE 1A 04 4890  			JP      NC,GROUP12_1
041B7B CD 03 1D 04 4891  			CALL    NUMBER
041B7F 0E 02       4892  			LD      C,2
041B81 CD 45 1D 04 4893  			CALL    PAIR_EX
041B85 CD 97 1C 04 4894  			CALL    LD16
041B89 D8          4895  			RET     C
041B8A CD F2 1C 04 4896  			CALL    BYTE_
041B8E CB 7A       4897  			BIT	7,D			; Check the ADL flag
041B90 C2 81 1C 04 4898  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041B94 C3 74 1C 04 4899  			JP      VAL16			; Otherwise use 16-bit addresses
041B98             4900  ;
041B98             4901  ; Group 17 - TST
041B98             4902  ;
041B98 D6 01       4903  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041B9A 30 25       4904  			JR	NC,OPTS
041B9C CD BD 1C 04 4905  			CALL	ED			; Needs to be prefixed with ED
041BA0 CD 17 1D 04 4906  			CALL	REG			; Fetch the register
041BA4 30 0E       4907  			JR	NC,GROUP17_1		; It's just a register
041BA6             4908  ;
041BA6 3E 64       4909  			LD	A,64H			; Opcode for TST n
041BA8 CD F2 1C 04 4910  			CALL	BYTE_			; Write out the opcode
041BAC CD 03 1D 04 4911  			CALL	NUMBER			; Get the number
041BB0 C3 BC 1A 04 4912  			JP	VAL8			; And write that out
041BB4             4913  ;
041BB4 78          4914  GROUP17_1:		LD	A,B			; Check the register rangs
041BB5 FE 08       4915  			CP	8
041BB7 3F          4916  			CCF
041BB8 D8          4917  			RET	C			; Ret with carry flag set for error if out of range
041BB9 07          4918  			RLCA				; Get the opcode value
041BBA 07          4919  			RLCA
041BBB 07          4920  			RLCA
041BBC 81          4921  			ADD	A,C			; Add the opcode base in
041BBD C3 F2 1C 04 4922  			JP	BYTE_
041BC1             4923  
041BC1             4924  ;
041BC1             4925  ; Assembler directives - OPT, ADL
041BC1             4926  ;
041BC1 D6 02       4927  OPTS:			SUB	2
041BC3 30 2B       4928  			JR	NC, DEFS
041BC5 FE FF       4929  			CP	1-2			; Check for ADL opcode
041BC7 28 13       4930  			JR	Z, ADL_
041BC9             4931  ;
041BC9 CD 03 1D 04 4932  OPT:			CALL    NUMBER			; Fetch the OPT value
041BCD 21 40 4D 04 4933  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041BD1 E6 07       4934  			AND	7			; Only interested in the first three bits
041BD3 4F          4935  			LD      C,A			; Store the new OPT value in C
041BD4 ED 6F       4936  			RLD				; Shift the top nibble of LISTON (OPT) into A
041BD6 E6 08       4937  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041BD8 B1          4938  			OR	C			; OR in the new value
041BD9 ED 67       4939  			RRD				; And shift the nibble back in
041BDB C9          4940  			RET
041BDC             4941  ;
041BDC CD 03 1D 04 4942  ADL_:			CALL	NUMBER			; Fetch the ADL value
041BE0 E6 01       4943  			AND	1			; Only interested if it is 0 or 1
041BE2 0F          4944  			RRCA				; Rotate to bit 7
041BE3 4F          4945  			LD	C,A			; Store in C
041BE4 3A 40 4D 04 4946  			LD	A,(LISTON)		; Get the LISTON system variable
041BE8 E6 7F       4947  			AND	7Fh			; Clear bit 7
041BEA B1          4948  			OR	C			; OR in the ADL value
041BEB 32 40 4D 04 4949  			LD	(LISTON),A		; Store
041BEF C9          4950  			RET
041BF0             4951  ;
041BF0             4952  ; DEFB, DEFW, DEFL, DEFM
041BF0             4953  ;
041BF0 B7          4954  DEFS:			OR	A			; Handle DEFB
041BF1 CA 03 1A 04 4955  			JP	Z, DB_
041BF5 3D          4956  			DEC	A			; Handle DEFW
041BF6 CA 70 1C 04 4957  			JP	Z, ADDR16
041BFA 3D          4958  			DEC	A			; Handle DEFL
041BFB CA 7D 1C 04 4959  			JP	Z, ADDR24
041BFF             4960  ;
041BFF DD E5       4961  			PUSH    IX			; Handle DEFM
041C01 CD 15 03 04 4962  			CALL    EXPRS
041C05 DD E1       4963  			POP     IX
041C07 21 00 4A 04 4964  			LD      HL,ACCS
041C0B AF          4965  @@:			XOR     A
041C0C BB          4966  			CP      E
041C0D C8          4967  			RET     Z
041C0E 7E          4968  			LD      A,(HL)
041C0F 23          4969  			INC     HL
041C10 CD F2 1C 04 4970  			CALL    BYTE_
041C14 1D          4971  			DEC     E
041C15 18 F4       4972  			JR      @B
041C17             4973  
041C17             4974  ;
041C17             4975  ;SUBROUTINES:
041C17             4976  ;
041C17 FD 7E 00    4977  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C1A FE 2E       4978  			CP	'.'
041C1C 28 02       4979  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C1E B7          4980  			OR	A			; Reset the carry flag (no error)
041C1F C9          4981  			RET				; And return
041C20 FD 23       4982  @@:			INC	IY			; Skip the dot
041C22 C5          4983  			PUSH	BC			; Push the operand
041C23 21 4B 20 04 4984  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C27 CD 64 1D 04 4985  			CALL	FIND			; Look up the operand
041C2B 30 24       4986  			JR	NC,EZ80SF_OK
041C2D C1          4987  			POP	BC			; Not found at this point, so will return with a C (error)
041C2E C9          4988  			RET
041C2F             4989  ;
041C2F FD 7E 00    4990  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C32 FE 2E       4991  			CP	'.'
041C34 28 02       4992  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C36 B7          4993  			OR	A			; Reset the carry flag (no error)
041C37 C9          4994  			RET				; And return
041C38 FD 23       4995  @@:			INC	IY 			; Skip the dot
041C3A C5          4996  			PUSH	BC			; Push the operand
041C3B 21 43 20 04 4997  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C3F CD 64 1D 04 4998  			CALL	FIND 			; Look up the operand
041C43 30 0C       4999  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C45 CD 60 1C 04 5000  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C49 CD 64 1D 04 5001  			CALL	FIND
041C4D 30 02       5002  			JR	NC,EZ80SF_OK
041C4F C1          5003  			POP	BC			; Not found at this point, so will return with a C (error)
041C50 C9          5004  			RET
041C51             5005  ;
041C51 78          5006  EZ80SF_OK:		LD	A,B			; The operand value
041C52 D4 F2 1C 04 5007  			CALL	NC,BYTE_ 		; Write it out if found
041C56 CB BA       5008  			RES	7,D			; Clear the default ADL mode from the flags
041C58 E6 02       5009  			AND	2			; Check the second half of the suffix (.xxL)
041C5A 0F          5010  			RRCA				; Shift into bit 7
041C5B 0F          5011  			RRCA
041C5C B2          5012  			OR	D			; Or into bit 7 of D
041C5D 57          5013  			LD	D,A
041C5E C1          5014  			POP	BC 			; Restore the operand
041C5F C9          5015  			RET
041C60             5016  ;
041C60 21 54 20 04 5017  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C64 CB 7A       5018  			BIT 	7,D			; if bit 7 of D is 0
041C66 C8          5019  			RET	Z
041C67 21 5F 20 04 5020  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041C6B C9          5021  			RET
041C6C             5022  ;
041C6C CB 7A       5023  ADDR_:			BIT	7,D			; Check the ADL flag
041C6E 20 0D       5024  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041C70             5025  ;
041C70 CD 03 1D 04 5026  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041C74 CD BC 1A 04 5027  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041C78 7C          5028  			LD      A,H
041C79 C3 F2 1C 04 5029  			JP      BYTE_
041C7D             5030  ;
041C7D CD 03 1D 04 5031  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041C81 CD 74 1C 04 5032  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041C85 D9          5033  			EXX
041C86 7D          5034  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041C87 D9          5035  			EXX
041C88 C3 F2 1C 04 5036  			JP	BYTE_
041C8C             5037  ;
041C8C FE 04       5038  LDA:			CP      4
041C8E DC BD 1C 04 5039  			CALL    C,ED
041C92 78          5040  			LD      A,B
041C93 C3 F2 1C 04 5041  			JP      BYTE_
041C97             5042  ;
041C97 78          5043  LD16:			LD      A,B
041C98 38 0F       5044  			JR      C,LD8
041C9A 78          5045  			LD      A,B
041C9B E6 3F       5046  			AND     3FH
041C9D FE 0C       5047  			CP      12
041C9F 79          5048  			LD      A,C
041CA0 C8          5049  			RET     Z
041CA1 CD BD 1C 04 5050  			CALL    ED
041CA5 79          5051  			LD      A,C
041CA6 F6 43       5052  			OR      43H
041CA8 C9          5053  			RET
041CA9             5054  ;
041CA9 FE 07       5055  LD8:			CP      7
041CAB 37          5056  			SCF
041CAC C0          5057  			RET     NZ
041CAD 79          5058  			LD      A,C
041CAE F6 30       5059  			OR      30H
041CB0 C9          5060  			RET
041CB1             5061  ;
041CB1             5062  ; Used in IN and OUT to handle whether the operand is C or a number
041CB1             5063  ;
041CB1 C5          5064  CORN:			PUSH    BC
041CB2 CD D1 1C 04 5065  			CALL    OPND			; Get the operand
041CB6 CB 68       5066  			BIT     5,B
041CB8 C1          5067  			POP     BC
041CB9 28 48       5068  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CBB 26 FF       5069  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CBD             5070  ;
041CBD 3E ED       5071  ED:			LD      A,0EDH			; Write an ED prefix out
041CBF 18 31       5072  			JR      BYTE_
041CC1             5073  ;
041CC1 3E CB       5074  CB:			LD      A,0CBH
041CC3 FE 76       5075  BIND:			CP      76H
041CC5 37          5076  			SCF
041CC6 C8          5077  			RET     Z               	; Reject LD (HL),(HL)
041CC7 CD F2 1C 04 5078  			CALL    BYTE_
041CCB CB 72       5079  			BIT	6,D			; Check the index bit in flags
041CCD C8          5080  			RET     Z
041CCE 7B          5081  			LD      A,E			; If there is an index, output the offset
041CCF 18 21       5082  			JR      BYTE_
041CD1             5083  ;
041CD1             5084  ; Search through the operand table
041CD1             5085  ; Returns:
041CD1             5086  ; - B: The operand type
041CD1             5087  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041CD1             5088  ; - E: The IX/IY offset
041CD1             5089  ; - F: Carry if not found
041CD1             5090  ;
041CD1 E5          5091  OPND:			PUSH    HL			; Preserve HL
041CD2 21 D5 1F 04 5092  			LD      HL,OPRNDS		; The operands table
041CD6 CD 64 1D 04 5093  			CALL    FIND			; Find the operand
041CDA E1          5094  			POP     HL
041CDB D8          5095  			RET     C			; Return if not found
041CDC CB 78       5096  			BIT     7,B			; Check if it is an index register (IX, IY)
041CDE C8          5097  			RET     Z			; Return if it isn't
041CDF CB F2       5098  			SET	6,D			; Set flag to indicate we've got an index
041CE1 CB 58       5099  			BIT     3,B			; Check if an offset is required
041CE3 E5          5100  			PUSH    HL
041CE4 CC F9 1C 04 5101  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041CE8 5D          5102  			LD      E,L			; E: The offset
041CE9 E1          5103  			POP     HL
041CEA 3E DD       5104  			LD	A,DDH			; IX prefix
041CEC CB 70       5105  			BIT     6,B			; If bit 6 is reset then
041CEE 28 02       5106  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041CF0 3E FD       5107  			LD	A,FDH			; IY prefix
041CF2             5108  ;
041CF2 DD 77 00    5109  BYTE_:			LD      (IX),A			; Write a byte out
041CF5 DD 23       5110  			INC     IX
041CF7 B7          5111  			OR      A
041CF8 C9          5112  			RET
041CF9             5113  ;
041CF9 FD 7E 00    5114  OFFSET_EX:			LD      A,(IY)
041CFC FE 29       5115  			CP      ')'
041CFE 21 00 00 00 5116  			LD      HL,0
041D02 C8          5117  			RET     Z
041D03 CD B5 1D 04 5118  NUMBER:			CALL    SKIP
041D07 C5          5119  			PUSH    BC
041D08 D5          5120  			PUSH    DE
041D09 DD E5       5121  			PUSH    IX
041D0B CD 0A 03 04 5122  			CALL    EXPRI
041D0F DD E1       5123  			POP     IX
041D11 D9          5124  			EXX
041D12 D1          5125  			POP     DE
041D13 C1          5126  			POP     BC
041D14 7D          5127  			LD      A,L
041D15 B7          5128  			OR      A
041D16 C9          5129  			RET
041D17             5130  ;
041D17 CD D1 1C 04 5131  REG:			CALL    OPND
041D1B D8          5132  			RET     C
041D1C 78          5133  			LD      A,B
041D1D E6 3F       5134  			AND     3FH
041D1F FE 08       5135  			CP      8
041D21 3F          5136  			CCF
041D22 C9          5137  			RET
041D23             5138  ;
041D23 CD 17 1D 04 5139  REGLO:			CALL    REG
041D27 D8          5140  			RET     C
041D28 18 33       5141  			JR      ORC
041D2A             5142  ;
041D2A CD 17 1D 04 5143  REGHI:			CALL    REG
041D2E D8          5144  			RET     C
041D2F 18 29       5145  			JR      SHL3
041D31             5146  ;
041D31 CD D1 1C 04 5147  COND_:			CALL    OPND
041D35 D8          5148  			RET     C
041D36 78          5149  			LD      A,B
041D37 E6 1F       5150  			AND     1FH
041D39 D6 10       5151  			SUB     16
041D3B 30 1D       5152  			JR      NC,SHL3
041D3D FE F1       5153  			CP      -15
041D3F 37          5154  			SCF
041D40 C0          5155  			RET     NZ
041D41 3E 03       5156  			LD      A,3
041D43 18 15       5157  			JR      SHL3
041D45             5158  ;
041D45 CD D1 1C 04 5159  PAIR_EX:			CALL    OPND
041D49 D8          5160  			RET     C
041D4A 78          5161  PAIR1_EX:			LD      A,B
041D4B E6 0F       5162  			AND     0FH
041D4D D6 08       5163  			SUB     8
041D4F D8          5164  			RET     C
041D50 18 08       5165  			JR      SHL3
041D52             5166  ;
041D52 CD 03 1D 04 5167  BIT_:			CALL    NUMBER
041D56 FE 08       5168  			CP      8
041D58 3F          5169  			CCF
041D59 D8          5170  			RET     C
041D5A 07          5171  SHL3:			RLCA
041D5B 07          5172  			RLCA
041D5C 07          5173  			RLCA
041D5D B1          5174  ORC:			OR      C
041D5E 4F          5175  			LD      C,A
041D5F C9          5176  			RET
041D60             5177  ;
041D60 21 1A 20 04 5178  LDOP:			LD      HL,LDOPS
041D64             5179  
041D64             5180  ;
041D64             5181  ; Look up a value in a table
041D64             5182  ; Parameters:
041D64             5183  ; - IY: Address of the assembly language line in the BASIC program area
041D64             5184  ; - HL: Address of the table
041D64             5185  ; Returns:
041D64             5186  ; - B: The operand code
041D64             5187  ; - F: Carry set if not found
041D64             5188  ;
041D64 CD B5 1D 04 5189  FIND:			CALL    SKIP			; Skip delimiters
041D68             5190  ;
041D68 06 00       5191  EXIT_:			LD      B,0			; Set B to 0
041D6A 37          5192  			SCF				; Set the carry flag
041D6B C8          5193  			RET     Z			; Returns if Z
041D6C             5194  ;
041D6C FE DD       5195  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041D6E 28 04       5196  			JR      Z,FIND0
041D70 FE 85       5197  			CP      TOR+1			; Special case for tokens AND and OR
041D72 3F          5198  			CCF
041D73 D8          5199  			RET     C
041D74 7E          5200  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041D75 B7          5201  			OR      A
041D76 28 F0       5202  			JR      Z,EXIT_			; Exit
041D78 FD AE 00    5203  			XOR     (IY)
041D7B E6 5F       5204  			AND     01011111B
041D7D 28 09       5205  			JR      Z,FIND2
041D7F CB 7E       5206  FIND1:			BIT     7,(HL)
041D81 23          5207  			INC     HL
041D82 28 FB       5208  			JR      Z,FIND1
041D84 23          5209  			INC     HL
041D85 04          5210  			INC     B
041D86 18 EC       5211  			JR      FIND0
041D88             5212  ;
041D88 FD E5       5213  FIND2:			PUSH    IY
041D8A CB 7E       5214  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041D8C FD 23       5215  			INC     IY
041D8E 23          5216  			INC     HL
041D8F 20 11       5217  			JR      NZ,FIND5		; Yes
041D91 BE          5218  			CP      (HL)
041D92 CC B4 1D 04 5219  			CALL    Z,SKIP0
041D96 7E          5220  			LD      A,(HL)
041D97 FD AE 00    5221  			XOR     (IY)
041D9A E6 5F       5222  			AND     01011111B
041D9C 28 EC       5223  			JR      Z,FIND3
041D9E FD E1       5224  FIND4:			POP     IY
041DA0 18 DD       5225  			JR      FIND1
041DA2             5226  ;
041DA2 CD 66 17 04 5227  FIND5:			CALL    DELIM			; Is it a delimiter?
041DA6 C4 C9 1D 04 5228  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DAA C4 C3 1D 04 5229  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DAE 20 EE       5230  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DB0             5231  ;
041DB0 78          5232  FIND6:			LD      A,B			; At this point we have a token
041DB1 46          5233  			LD      B,(HL)			; Fetch the token type code
041DB2 E1          5234  			POP     HL			; Restore the stack
041DB3 C9          5235  			RET
041DB4             5236  ;
041DB4 23          5237  SKIP0:			INC     HL
041DB5 CD 66 17 04 5238  SKIP:			CALL    DELIM			; Is it a delimiter?
041DB9 C0          5239  			RET     NZ			; No, so return
041DBA CD 72 17 04 5240  			CALL    TERM			; Is it a terminator?
041DBE C8          5241  			RET     Z			; Yes, so return
041DBF FD 23       5242  			INC     IY			; Increment the basic program counter
041DC1 18 F2       5243  			JR      SKIP			; And loop
041DC3             5244  ;
041DC3 FE 2B       5245  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DC5 C8          5246  			RET     Z
041DC6 FE 2D       5247  			CP      '-'
041DC8 C9          5248  			RET
041DC9             5249  ;
041DC9 FE 2E       5250  DOT:			CP	'.'			; Check if it is a dot character
041DCB C9          5251  			RET
041DCC             5252  ; Z80 opcode list
041DCC             5253  ;
041DCC             5254  ; Group 0: (15 opcodes)
041DCC             5255  ; Trivial cases requiring no computation
041DCC             5256  ;
041DCC             5257  ; BEGIN REFACTOR FROM BINARY
041DCC             5258  ; OPCODS:
041DCC             5259  ; 			DB	"NO","P"+80H,00h	; # 00h
041DCC             5260  ; 			DB	"RLC","A"+80H,07h
041DCC             5261  ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
041DCC             5262  ; 			DB	"RRC","A"+80H,0FH
041DCC             5263  ; 			DB	"RL","A"+80H,17H
041DCC             5264  ; 			DB	"RR","A"+80H,1FH
041DCC             5265  ; 			DB	"DA","A"+80H,27H
041DCC             5266  ; 			DB	"CP","L"+80H,2FH
041DCC             5267  ; 			DB	"SC","F"+80H,37H
041DCC             5268  ; 			DB	"CC","F"+80H,3FH
041DCC             5269  ; 			DB	"HAL","T"+80H,76H
041DCC             5270  ; 			DB	"EX","X"+80H,D9H
041DCC             5271  ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
041DCC             5272  ; 			DB	"D","I"+80H,F3H
041DCC             5273  ; 			DB	"E","I"+80H,FBH
041DCC             5274  ; ;
041DCC             5275  ; ; Group 1: (53 opcodes)
041DCC             5276  ; ; As Group 0, but with an ED prefix
041DCC             5277  ; ;
041DCC             5278  ; 			DB	"NE","G"+80H,44H	; 0Fh
041DCC             5279  ; 			DB	"IM",0,"0"+80H,46H
041DCC             5280  ; 			DB	"RET","N"+80H,45H
041DCC             5281  ; 			DB	"MLT",0,"B","C"+80H,4CH
041DCC             5282  ; 			DB	"RET","I"+80H,4DH
041DCC             5283  ; 			DB	"IM",0,"1"+80H,56H
041DCC             5284  ; 			DB	"MLT",0,"D","E"+80H,5CH
041DCC             5285  ; 			DB	"IM",0,"2"+80H,5EH
041DCC             5286  ; 			DB	"RR","D"+80H,67H
041DCC             5287  ; 			DB	"MLT",0,"H","L"+80H,6CH
041DCC             5288  ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
041DCC             5289  ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
041DCC             5290  ; 			DB	"RL","D"+80H,6FH
041DCC             5291  ; 			DB	"SL","P"+80H,76H
041DCC             5292  ; 			DB	"MLT",0,"S","P"+80H,7CH
041DCC             5293  ; 			DB	"STMI","X"+80H,7DH
041DCC             5294  ; 			DB	"RSMI","X"+80H,7EH
041DCC             5295  ; 			DB	"INI","M"+80H,82H
041DCC             5296  ; 			DB	"OTI","M"+80H,83H
041DCC             5297  ; 			DB	"INI","2"+80H,84H
041DCC             5298  ; 			DB	"IND","M"+80H,8AH
041DCC             5299  ; 			DB	"OTD","M"+80H,8BH
041DCC             5300  ; 			DB	"IND","2"+80H,8CH
041DCC             5301  ; 			DB	"INIM","R"+80H,92H
041DCC             5302  ; 			DB	"OTIM","R"+80H,93H
041DCC             5303  ; 			DB	"INI2","R"+80H,94H
041DCC             5304  ; 			DB	"INDM","R"+80H,9AH
041DCC             5305  ; 			DB	"OTDM","R"+80H,9BH
041DCC             5306  ; 			DB	"IND2","R"+80H,9CH
041DCC             5307  ; 			DB	"LD","I"+80H,A0H
041DCC             5308  ; 			DB	"CP","I"+80H,A1H
041DCC             5309  ; 			DB	"IN","I"+80H,A2H
041DCC             5310  ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041DCC             5311  ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041DCC             5312  ; 			DB	"LD","D"+80H,A8H
041DCC             5313  ; 			DB	"CP","D"+80H,A9H
041DCC             5314  ; 			DB	"IN","D"+80H,AAH
041DCC             5315  ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041DCC             5316  ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041DCC             5317  ; 			DB	"LDI","R"+80H,B0H
041DCC             5318  ; 			DB	"CPI","R"+80H,B1H
041DCC             5319  ; 			DB	"INI","R"+80H,B2H
041DCC             5320  ; 			DB	"OTI","R"+80H,B3H
041DCC             5321  ; 			DB	"OTI2","R"+80H,B4H
041DCC             5322  ; 			DB	"LDD","R"+80H,B8H
041DCC             5323  ; 			DB	"CPD","R"+80H,B9H
041DCC             5324  ; 			DB	"IND","R"+80H,BAH
041DCC             5325  ; 			DB	"OTD","R"+80H,BBH
041DCC             5326  ; 			DB	"OTD2","R"+80H,BCH
041DCC             5327  ; 			DB	"INIR","X"+80H,C2H
041DCC             5328  ; 			DB	"OTIR","X"+80H,C3H
041DCC             5329  ; 			DB	"INDR","X"+80H,CAH
041DCC             5330  ; 			DB	"OTDR","X"+80H,CBH
041DCC             5331  ; ;
041DCC             5332  ; ; Group 2: (3 opcodes)
041DCC             5333  ; ;
041DCC             5334  ; 			DB	"BI","T"+80H,40H	; 44h
041DCC             5335  ; 			DB	"RE","S"+80H,80H
041DCC             5336  ; 			DB	"SE","T"+80H,C0H
041DCC             5337  ; ;
041DCC             5338  ; ; Group 3: (7 opcodes)
041DCC             5339  ; ;
041DCC             5340  ; 			DB	"RL","C"+80H,00H	; 47h
041DCC             5341  ; 			DB	"RR","C"+80H,08H
041DCC             5342  ; 			DB	"R","L"+80H,10H
041DCC             5343  ; 			DB	"R","R"+80H,18H
041DCC             5344  ; 			DB	"SL","A"+80H,20H
041DCC             5345  ; 			DB	"SR","A"+80H,28H
041DCC             5346  ; 			DB	"SR","L"+80H,38H
041DCC             5347  ; ;
041DCC             5348  ; ; Group 4: (3 opcodes)
041DCC             5349  ; ;
041DCC             5350  ; 			DB	"PO","P"+80H,C1H	; 4Eh
041DCC             5351  ; 			DB	"PUS","H"+80H,C5H
041DCC             5352  ; 			DB	"EX",0,"(S","P"+80H,E3H
041DCC             5353  ; ;
041DCC             5354  ; ; Group 5: (7 opcodes)
041DCC             5355  ; ;
041DCC             5356  ; 			DB	"SU","B"+80H,90H	; 51h
041DCC             5357  ; 			DB	"AN","D"+80H,A0H
041DCC             5358  ; 			DB	"XO","R"+80H,A8H
041DCC             5359  ; 			DB	"O","R"+80H,B0H
041DCC             5360  ; 			DB	"C","P"+80H,B8H
041DCC             5361  ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
041DCC             5362  ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
041DCC             5363  ; ;
041DCC             5364  ; ; Group 6 (3 opcodes)
041DCC             5365  ; ;
041DCC             5366  ; 			DB	"AD","D"+80H,80H	; 58h
041DCC             5367  ; 			DB	"AD","C"+80H,88H
041DCC             5368  ; 			DB	"SB","C"+80H,98H
041DCC             5369  ; ;
041DCC             5370  ; ; Group 7: (2 opcodes)
041DCC             5371  ; ;
041DCC             5372  ; 			DB	"IN","C"+80H,04H	; 5Bh
041DCC             5373  ; 			DB	"DE","C"+80H,05H
041DCC             5374  ; ;
041DCC             5375  ; ; Group 8: (2 opcodes)
041DCC             5376  ; ;
041DCC             5377  ; 			DB	"IN","0"+80H,00H	; 5Dh
041DCC             5378  ; 			DB	"OUT","0"+80H,01H
041DCC             5379  ; ;
041DCC             5380  ; ; Group 9: (1 opcode)
041DCC             5381  ; ;
041DCC             5382  ; 			DB	"I","N"+80H,40H		; 5Fh
041DCC             5383  ; ;
041DCC             5384  ; ; Group 10: (1 opcode)
041DCC             5385  ; ;
041DCC             5386  ; 			DB	"OU","T"+80H,41H	; 60h
041DCC             5387  ; ;
041DCC             5388  ; ; Group 11: (2 opcodes)
041DCC             5389  ; ;
041DCC             5390  ; 			DB	"J","R"+80H,20H		; 61h
041DCC             5391  ; 			DB	"DJN","Z"+80H,10H
041DCC             5392  ; ;
041DCC             5393  ; ; Group 12: (1 opcode)
041DCC             5394  ; ;
041DCC             5395  ; 			DB	"J","P"+80H,C2H		; 63h
041DCC             5396  ; ;
041DCC             5397  ; ; Group 13: (1 opcode)
041DCC             5398  ; ;
041DCC             5399  ; 			DB	"CAL","L"+80H,C4H	; 64h
041DCC             5400  ; ;
041DCC             5401  ; ; Group 14: (1 opcode)
041DCC             5402  ; ;
041DCC             5403  ; 			DB	"RS","T"+80H,C7H	; 65h
041DCC             5404  ; ;
041DCC             5405  ; ; Group 15: (1 opcode)
041DCC             5406  ; ;
041DCC             5407  ; 			DB	"RE","T"+80H,C0H	; 66h
041DCC             5408  ; ;
041DCC             5409  ; ; Group 16: (1 opcode)
041DCC             5410  ; ;
041DCC             5411  ; 			DB	"L","D"+80H,40H		; 67h
041DCC             5412  ; ;
041DCC             5413  ; ; Group 17: (1 opcode)
041DCC             5414  ; ;
041DCC             5415  ; 			DB	"TS","T"+80H,04H	; 68h
041DCC             5416  
041DCC             5417  ; ;
041DCC             5418  ; ; Assembler Directives
041DCC             5419  ; ;
041DCC             5420  ; 			DB	"OP","T"+80H,00H	; 69h OPT
041DCC             5421  ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
041DCC             5422  ; ;
041DCC             5423  ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041DCC             5424  ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041DCC             5425  ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041DCC             5426  ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
041DCC             5427  ; ;
041DCC             5428  ; 			DB	0
041DCC             5429  ; ;
041DCC             5430  ; ; Operands
041DCC             5431  ; ;
041DCC             5432  ; OPRNDS:			DB	"B"+80H, 00H
041DCC             5433  ; 			DB	"C"+80H, 01H
041DCC             5434  ; 			DB	"D"+80H, 02H
041DCC             5435  ; 			DB	"E"+80H, 03H
041DCC             5436  ; 			DB	"H"+80H, 04H
041DCC             5437  ; 			DB	"L"+80H, 05H
041DCC             5438  ; 			DB	"(H","L"+80H,06H
041DCC             5439  ; 			DB	"A"+80H, 07H
041DCC             5440  ; 			DB	"(I","X"+80H,86H
041DCC             5441  ; 			DB	"(I","Y"+80H,C6H
041DCC             5442  ; ;
041DCC             5443  ; 			DB	"B","C"+80H,08H
041DCC             5444  ; 			DB	"D","E"+80H,0AH
041DCC             5445  ; 			DB	"H","L"+80H,0CH
041DCC             5446  ; 			DB	"I","X"+80H,8CH
041DCC             5447  ; 			DB	"I","Y"+80H,CCH
041DCC             5448  ; 			DB	"A","F"+80H,0EH
041DCC             5449  ; 			DB	"S","P"+80H,0EH
041DCC             5450  ; ;
041DCC             5451  ; 			DB	"N","Z"+80H,10H
041DCC             5452  ; 			DB	"Z"+80H,11H
041DCC             5453  ; 			DB	"N","C"+80H,12H
041DCC             5454  ; 			DB	"P","O"+80H,14H
041DCC             5455  ; 			DB	"P","E"+80H,15H
041DCC             5456  ; 			DB	"P"+80H,16H
041DCC             5457  ; 			DB	"M"+80H,17H
041DCC             5458  ; ;
041DCC             5459  ; 			DB	"(","C"+80H,20H
041DCC             5460  ; ;
041DCC             5461  ; 			DB	0
041DCC             5462  ; ;
041DCC             5463  ; ; Load operations
041DCC             5464  ; ;
041DCC             5465  ; LDOPS:			DB	"I",0,"A"+80H,47H
041DCC             5466  ; 			DB	"R",0,"A"+80H,4FH
041DCC             5467  ; 			DB	"A",0,"I"+80H,57H
041DCC             5468  ; 			DB	"A",0,"R"+80H,5FH
041DCC             5469  ; 			DB	"(BC",0,"A"+80H,02h
041DCC             5470  ; 			DB	"(DE",0,"A"+80H,12H
041DCC             5471  ; 			DB	"A",0,"(B","C"+80H,0AH
041DCC             5472  ; 			DB	"A",0,"(D","E"+80H,1AH
041DCC             5473  ; ;
041DCC             5474  ; 			DB	0
041DCC             5475  ; ;
041DCC             5476  ; ; eZ80 addressing mode suffixes
041DCC             5477  ; ;
041DCC             5478  ; ; Fully qualified suffixes
041DCC             5479  ; ;
041DCC             5480  ; EZ80SFS_1:		DB	"LI","S"+80H,49H
041DCC             5481  ; 			DB	"SI","L"+80H,52H
041DCC             5482  ; EZ80SFS_2:		DB	"SI","S"+80H,40H
041DCC             5483  ; 			DB	"LI","L"+80H,5BH
041DCC             5484  ; ;
041DCC             5485  ; 			DB	0
041DCC             5486  ; ;
041DCC             5487  ; ; Shortcuts when ADL mode is 0
041DCC             5488  ; ;
041DCC             5489  ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
041DCC             5490  ; 			DB	"L"+80H,49H		; Equivalent to .LIS
041DCC             5491  ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
041DCC             5492  ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
041DCC             5493  ; ;
041DCC             5494  ; 			DB	0
041DCC             5495  ; ;
041DCC             5496  ; ; Shortcuts when ADL mode is 1
041DCC             5497  ; ;
041DCC             5498  ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
041DCC             5499  ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
041DCC             5500  ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
041DCC             5501  ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
041DCC             5502  ; ;
041DCC             5503  ; 			DB	0
041DCC             5504  ; END REFACTOR FROM BINARY
041DCC             5505  ; BEGIN INSERT FROM BINARY
041DCC             5506  ;
041DCC             5507  ; Trivial cases requiring no computation
041DCC             5508  OPCODS:
041DCC 4E          5509  	db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
041DCD 4F          5510  	db 0x4f ; 041DCD
041DCE D0          5511  	db 0xd0 ; 041DCE
041DCF 00          5512  	db 0x00 ; 041DCF
041DD0 52          5513  	db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
041DD1 4C          5514  	db 0x4c ; 041DD1
041DD2 43          5515  	db 0x43 ; 041DD2
041DD3 C1          5516  	db 0xc1 ; 041DD3
041DD4 07          5517  	db 0x07 ; 041DD4
041DD5 45          5518  	db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
041DD6 58          5519  	db 0x58 ; 041DD6
041DD7 00          5520  	db 0x00 ; 041DD7
041DD8 41          5521  	db 0x41 ; 041DD8
041DD9 46          5522  	db 0x46 ; 041DD9
041DDA 00          5523  	db 0x00 ; 041DDA
041DDB 41          5524  	db 0x41 ; 041DDB
041DDC 46          5525  	db 0x46 ; 041DDC
041DDD A7          5526  	db 0xa7 ; 041DDD
041DDE 08          5527  	db 0x08 ; 041DDE
041DDF 52          5528  	db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
041DE0 52          5529  	db 0x52 ; 041DE0
041DE1 43          5530  	db 0x43 ; 041DE1
041DE2 C1          5531  	db 0xc1 ; 041DE2
041DE3 0F          5532  	db 0x0f ; 041DE3
041DE4 52          5533  	db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
041DE5 4C          5534  	db 0x4c ; 041DE5
041DE6 C1          5535  	db 0xc1 ; 041DE6
041DE7 17          5536  	db 0x17 ; 041DE7
041DE8 52          5537  	db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
041DE9 52          5538  	db 0x52 ; 041DE9
041DEA C1          5539  	db 0xc1 ; 041DEA
041DEB 1F          5540  	db 0x1f ; 041DEB
041DEC 44          5541  	db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
041DED 41          5542  	db 0x41 ; 041DED
041DEE C1          5543  	db 0xc1 ; 041DEE
041DEF 27          5544  	db 0x27 ; 041DEF
041DF0 43          5545  	db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
041DF1 50          5546  	db 0x50 ; 041DF1
041DF2 CC          5547  	db 0xcc ; 041DF2
041DF3 2F          5548  	db 0x2f ; 041DF3
041DF4 53          5549  	db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
041DF5 43          5550  	db 0x43 ; 041DF5
041DF6 C6          5551  	db 0xc6 ; 041DF6
041DF7 37          5552  	db 0x37 ; 041DF7
041DF8 43          5553  	db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
041DF9 43          5554  	db 0x43 ; 041DF9
041DFA C6          5555  	db 0xc6 ; 041DFA
041DFB 3F          5556  	db 0x3f ; 041DFB
041DFC 48          5557  	db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
041DFD 41          5558  	db 0x41 ; 041DFD
041DFE 4C          5559  	db 0x4c ; 041DFE
041DFF D4          5560  	db 0xd4 ; 041DFF
041E00 76          5561  	db 0x76 ; 041E00
041E01 45          5562  	db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
041E02 58          5563  	db 0x58 ; 041E02
041E03 D8          5564  	db 0xd8 ; 041E03
041E04 D9          5565  	db 0xd9 ; 041E04
041E05 45          5566  	db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
041E06 58          5567  	db 0x58 ; 041E06
041E07 00          5568  	db 0x00 ; 041E07
041E08 44          5569  	db 0x44 ; 041E08
041E09 45          5570  	db 0x45 ; 041E09
041E0A 00          5571  	db 0x00 ; 041E0A
041E0B 48          5572  	db 0x48 ; 041E0B
041E0C CC          5573  	db 0xcc ; 041E0C
041E0D EB          5574  	db 0xeb ; 041E0D
041E0E 44          5575  	db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
041E0F C9          5576  	db 0xc9 ; 041E0F
041E10 F3          5577  	db 0xf3 ; 041E10
041E11 45          5578  	db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
041E12 C9          5579  	db 0xc9 ; 041E12
041E13 FB          5580  	db 0xfb ; 041E13
041E14             5581  ;
041E14             5582  ; Group 1: (53 opcodes)
041E14             5583  ; As Group 0, but with an ED prefix
041E14             5584  ;
041E14 4E          5585  	db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
041E15 45          5586  	db 0x45 ; 041E15
041E16 C7          5587  	db 0xc7 ; 041E16
041E17 44          5588  	db 0x44 ; 041E17
041E18 49          5589  	db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
041E19 4D          5590  	db 0x4d ; 041E19
041E1A 00          5591  	db 0x00 ; 041E1A
041E1B B0          5592  	db 0xb0 ; 041E1B
041E1C 46          5593  	db 0x46 ; 041E1C
041E1D 52          5594  	db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
041E1E 45          5595  	db 0x45 ; 041E1E
041E1F 54          5596  	db 0x54 ; 041E1F
041E20 CE          5597  	db 0xce ; 041E20
041E21 45          5598  	db 0x45 ; 041E21
041E22 4D          5599  	db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
041E23 4C          5600  	db 0x4c ; 041E23
041E24 54          5601  	db 0x54 ; 041E24
041E25 00          5602  	db 0x00 ; 041E25
041E26 42          5603  	db 0x42 ; 041E26
041E27 C3          5604  	db 0xc3 ; 041E27
041E28 4C          5605  	db 0x4c ; 041E28
041E29 52          5606  	db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
041E2A 45          5607  	db 0x45 ; 041E2A
041E2B 54          5608  	db 0x54 ; 041E2B
041E2C C9          5609  	db 0xc9 ; 041E2C
041E2D 4D          5610  	db 0x4d ; 041E2D
041E2E 49          5611  	db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
041E2F 4D          5612  	db 0x4d ; 041E2F
041E30 00          5613  	db 0x00 ; 041E30
041E31 B1          5614  	db 0xb1 ; 041E31
041E32 56          5615  	db 0x56 ; 041E32
041E33 4D          5616  	db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
041E34 4C          5617  	db 0x4c ; 041E34
041E35 54          5618  	db 0x54 ; 041E35
041E36 00          5619  	db 0x00 ; 041E36
041E37 44          5620  	db 0x44 ; 041E37
041E38 C5          5621  	db 0xc5 ; 041E38
041E39 5C          5622  	db 0x5c ; 041E39
041E3A 49          5623  	db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
041E3B 4D          5624  	db 0x4d ; 041E3B
041E3C 00          5625  	db 0x00 ; 041E3C
041E3D B2          5626  	db 0xb2 ; 041E3D
041E3E 5E          5627  	db 0x5e ; 041E3E
041E3F 52          5628  	db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
041E40 52          5629  	db 0x52 ; 041E40
041E41 C4          5630  	db 0xc4 ; 041E41
041E42 67          5631  	db 0x67 ; 041E42
041E43 4D          5632  	db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
041E44 4C          5633  	db 0x4c ; 041E44
041E45 54          5634  	db 0x54 ; 041E45
041E46 00          5635  	db 0x00 ; 041E46
041E47 48          5636  	db 0x48 ; 041E47
041E48 CC          5637  	db 0xcc ; 041E48
041E49 6C          5638  	db 0x6c ; 041E49
041E4A 4C          5639  	db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
041E4B 44          5640  	db 0x44 ; 041E4B
041E4C 00          5641  	db 0x00 ; 041E4C
041E4D 4D          5642  	db 0x4d ; 041E4D
041E4E 42          5643  	db 0x42 ; 041E4E
041E4F 00          5644  	db 0x00 ; 041E4F
041E50 C1          5645  	db 0xc1 ; 041E50
041E51 6D          5646  	db 0x6d ; 041E51
041E52 4C          5647  	db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
041E53 44          5648  	db 0x44 ; 041E53
041E54 00          5649  	db 0x00 ; 041E54
041E55 41          5650  	db 0x41 ; 041E55
041E56 00          5651  	db 0x00 ; 041E56
041E57 4D          5652  	db 0x4d ; 041E57
041E58 C2          5653  	db 0xc2 ; 041E58
041E59 6E          5654  	db 0x6e ; 041E59
041E5A 52          5655  	db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
041E5B 4C          5656  	db 0x4c ; 041E5B
041E5C C4          5657  	db 0xc4 ; 041E5C
041E5D 6F          5658  	db 0x6f ; 041E5D
041E5E 53          5659  	db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
041E5F 4C          5660  	db 0x4c ; 041E5F
041E60 D0          5661  	db 0xd0 ; 041E60
041E61 76          5662  	db 0x76 ; 041E61
041E62 4D          5663  	db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
041E63 4C          5664  	db 0x4c ; 041E63
041E64 54          5665  	db 0x54 ; 041E64
041E65 00          5666  	db 0x00 ; 041E65
041E66 53          5667  	db 0x53 ; 041E66
041E67 D0          5668  	db 0xd0 ; 041E67
041E68 7C          5669  	db 0x7c ; 041E68
041E69 53          5670  	db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
041E6A 54          5671  	db 0x54 ; 041E6A
041E6B 4D          5672  	db 0x4d ; 041E6B
041E6C 49          5673  	db 0x49 ; 041E6C
041E6D D8          5674  	db 0xd8 ; 041E6D
041E6E 7D          5675  	db 0x7d ; 041E6E
041E6F 52          5676  	db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
041E70 53          5677  	db 0x53 ; 041E70
041E71 4D          5678  	db 0x4d ; 041E71
041E72 49          5679  	db 0x49 ; 041E72
041E73 D8          5680  	db 0xd8 ; 041E73
041E74 7E          5681  	db 0x7e ; 041E74
041E75 49          5682  	db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
041E76 4E          5683  	db 0x4e ; 041E76
041E77 49          5684  	db 0x49 ; 041E77
041E78 CD          5685  	db 0xcd ; 041E78
041E79 82          5686  	db 0x82 ; 041E79
041E7A 4F          5687  	db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
041E7B 54          5688  	db 0x54 ; 041E7B
041E7C 49          5689  	db 0x49 ; 041E7C
041E7D CD          5690  	db 0xcd ; 041E7D
041E7E 83          5691  	db 0x83 ; 041E7E
041E7F 49          5692  	db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
041E80 4E          5693  	db 0x4e ; 041E80
041E81 49          5694  	db 0x49 ; 041E81
041E82 B2          5695  	db 0xb2 ; 041E82
041E83 84          5696  	db 0x84 ; 041E83
041E84 49          5697  	db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
041E85 4E          5698  	db 0x4e ; 041E85
041E86 44          5699  	db 0x44 ; 041E86
041E87 CD          5700  	db 0xcd ; 041E87
041E88 8A          5701  	db 0x8a ; 041E88
041E89 4F          5702  	db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
041E8A 54          5703  	db 0x54 ; 041E8A
041E8B 44          5704  	db 0x44 ; 041E8B
041E8C CD          5705  	db 0xcd ; 041E8C
041E8D 8B          5706  	db 0x8b ; 041E8D
041E8E 49          5707  	db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
041E8F 4E          5708  	db 0x4e ; 041E8F
041E90 44          5709  	db 0x44 ; 041E90
041E91 B2          5710  	db 0xb2 ; 041E91
041E92 8C          5711  	db 0x8c ; 041E92
041E93 49          5712  	db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
041E94 4E          5713  	db 0x4e ; 041E94
041E95 49          5714  	db 0x49 ; 041E95
041E96 4D          5715  	db 0x4d ; 041E96
041E97 D2          5716  	db 0xd2 ; 041E97
041E98 92          5717  	db 0x92 ; 041E98
041E99 4F          5718  	db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
041E9A 54          5719  	db 0x54 ; 041E9A
041E9B 49          5720  	db 0x49 ; 041E9B
041E9C 4D          5721  	db 0x4d ; 041E9C
041E9D D2          5722  	db 0xd2 ; 041E9D
041E9E 93          5723  	db 0x93 ; 041E9E
041E9F 49          5724  	db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
041EA0 4E          5725  	db 0x4e ; 041EA0
041EA1 49          5726  	db 0x49 ; 041EA1
041EA2 32          5727  	db 0x32 ; 041EA2
041EA3 D2          5728  	db 0xd2 ; 041EA3
041EA4 94          5729  	db 0x94 ; 041EA4
041EA5 49          5730  	db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
041EA6 4E          5731  	db 0x4e ; 041EA6
041EA7 44          5732  	db 0x44 ; 041EA7
041EA8 4D          5733  	db 0x4d ; 041EA8
041EA9 D2          5734  	db 0xd2 ; 041EA9
041EAA 9A          5735  	db 0x9a ; 041EAA
041EAB 4F          5736  	db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
041EAC 54          5737  	db 0x54 ; 041EAC
041EAD 44          5738  	db 0x44 ; 041EAD
041EAE 4D          5739  	db 0x4d ; 041EAE
041EAF D2          5740  	db 0xd2 ; 041EAF
041EB0 9B          5741  	db 0x9b ; 041EB0
041EB1 49          5742  	db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
041EB2 4E          5743  	db 0x4e ; 041EB2
041EB3 44          5744  	db 0x44 ; 041EB3
041EB4 32          5745  	db 0x32 ; 041EB4
041EB5 D2          5746  	db 0xd2 ; 041EB5
041EB6 9C          5747  	db 0x9c ; 041EB6
041EB7 4C          5748  	db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
041EB8 44          5749  	db 0x44 ; 041EB8
041EB9 C9          5750  	db 0xc9 ; 041EB9
041EBA A0          5751  	db 0xa0 ; 041EBA
041EBB 43          5752  	db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
041EBC 50          5753  	db 0x50 ; 041EBC
041EBD C9          5754  	db 0xc9 ; 041EBD
041EBE A1          5755  	db 0xa1 ; 041EBE
041EBF 49          5756  	db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
041EC0 4E          5757  	db 0x4e ; 041EC0
041EC1 C9          5758  	db 0xc9 ; 041EC1
041EC2 A2          5759  	db 0xa2 ; 041EC2
041EC3 4F          5760  	db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041EC4 55          5761  	db 0x55 ; 041EC4
041EC5 54          5762  	db 0x54 ; 041EC5
041EC6 49          5763  	db 0x49 ; 041EC6
041EC7 B2          5764  	db 0xb2 ; 041EC7
041EC8 A4          5765  	db 0xa4 ; 041EC8
041EC9 4F          5766  	db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041ECA 55          5767  	db 0x55 ; 041ECA
041ECB 54          5768  	db 0x54 ; 041ECB
041ECC C9          5769  	db 0xc9 ; 041ECC
041ECD A3          5770  	db 0xa3 ; 041ECD
041ECE 4C          5771  	db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
041ECF 44          5772  	db 0x44 ; 041ECF
041ED0 C4          5773  	db 0xc4 ; 041ED0
041ED1 A8          5774  	db 0xa8 ; 041ED1
041ED2 43          5775  	db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
041ED3 50          5776  	db 0x50 ; 041ED3
041ED4 C4          5777  	db 0xc4 ; 041ED4
041ED5 A9          5778  	db 0xa9 ; 041ED5
041ED6 49          5779  	db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
041ED7 4E          5780  	db 0x4e ; 041ED7
041ED8 C4          5781  	db 0xc4 ; 041ED8
041ED9 AA          5782  	db 0xaa ; 041ED9
041EDA 4F          5783  	db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041EDB 55          5784  	db 0x55 ; 041EDB
041EDC 54          5785  	db 0x54 ; 041EDC
041EDD 44          5786  	db 0x44 ; 041EDD
041EDE B2          5787  	db 0xb2 ; 041EDE
041EDF AC          5788  	db 0xac ; 041EDF
041EE0 4F          5789  	db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041EE1 55          5790  	db 0x55 ; 041EE1
041EE2 54          5791  	db 0x54 ; 041EE2
041EE3 C4          5792  	db 0xc4 ; 041EE3
041EE4 AB          5793  	db 0xab ; 041EE4
041EE5 4C          5794  	db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
041EE6 44          5795  	db 0x44 ; 041EE6
041EE7 49          5796  	db 0x49 ; 041EE7
041EE8 D2          5797  	db 0xd2 ; 041EE8
041EE9 B0          5798  	db 0xb0 ; 041EE9
041EEA 43          5799  	db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
041EEB 50          5800  	db 0x50 ; 041EEB
041EEC 49          5801  	db 0x49 ; 041EEC
041EED D2          5802  	db 0xd2 ; 041EED
041EEE B1          5803  	db 0xb1 ; 041EEE
041EEF 49          5804  	db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
041EF0 4E          5805  	db 0x4e ; 041EF0
041EF1 49          5806  	db 0x49 ; 041EF1
041EF2 D2          5807  	db 0xd2 ; 041EF2
041EF3 B2          5808  	db 0xb2 ; 041EF3
041EF4 4F          5809  	db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
041EF5 54          5810  	db 0x54 ; 041EF5
041EF6 49          5811  	db 0x49 ; 041EF6
041EF7 D2          5812  	db 0xd2 ; 041EF7
041EF8 B3          5813  	db 0xb3 ; 041EF8
041EF9 4F          5814  	db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
041EFA 54          5815  	db 0x54 ; 041EFA
041EFB 49          5816  	db 0x49 ; 041EFB
041EFC 32          5817  	db 0x32 ; 041EFC
041EFD D2          5818  	db 0xd2 ; 041EFD
041EFE B4          5819  	db 0xb4 ; 041EFE
041EFF 4C          5820  	db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
041F00 44          5821  	db 0x44 ; 041F00
041F01 44          5822  	db 0x44 ; 041F01
041F02 D2          5823  	db 0xd2 ; 041F02
041F03 B8          5824  	db 0xb8 ; 041F03
041F04 43          5825  	db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
041F05 50          5826  	db 0x50 ; 041F05
041F06 44          5827  	db 0x44 ; 041F06
041F07 D2          5828  	db 0xd2 ; 041F07
041F08 B9          5829  	db 0xb9 ; 041F08
041F09 49          5830  	db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
041F0A 4E          5831  	db 0x4e ; 041F0A
041F0B 44          5832  	db 0x44 ; 041F0B
041F0C D2          5833  	db 0xd2 ; 041F0C
041F0D BA          5834  	db 0xba ; 041F0D
041F0E 4F          5835  	db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
041F0F 54          5836  	db 0x54 ; 041F0F
041F10 44          5837  	db 0x44 ; 041F10
041F11 D2          5838  	db 0xd2 ; 041F11
041F12 BB          5839  	db 0xbb ; 041F12
041F13 4F          5840  	db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
041F14 54          5841  	db 0x54 ; 041F14
041F15 44          5842  	db 0x44 ; 041F15
041F16 32          5843  	db 0x32 ; 041F16
041F17 D2          5844  	db 0xd2 ; 041F17
041F18 BC          5845  	db 0xbc ; 041F18
041F19 49          5846  	db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
041F1A 4E          5847  	db 0x4e ; 041F1A
041F1B 49          5848  	db 0x49 ; 041F1B
041F1C 52          5849  	db 0x52 ; 041F1C
041F1D D8          5850  	db 0xd8 ; 041F1D
041F1E C2          5851  	db 0xc2 ; 041F1E
041F1F 4F          5852  	db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
041F20 54          5853  	db 0x54 ; 041F20
041F21 49          5854  	db 0x49 ; 041F21
041F22 52          5855  	db 0x52 ; 041F22
041F23 D8          5856  	db 0xd8 ; 041F23
041F24 C3          5857  	db 0xc3 ; 041F24
041F25 49          5858  	db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
041F26 4E          5859  	db 0x4e ; 041F26
041F27 44          5860  	db 0x44 ; 041F27
041F28 52          5861  	db 0x52 ; 041F28
041F29 D8          5862  	db 0xd8 ; 041F29
041F2A CA          5863  	db 0xca ; 041F2A
041F2B 4F          5864  	db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
041F2C 54          5865  	db 0x54 ; 041F2C
041F2D 44          5866  	db 0x44 ; 041F2D
041F2E 52          5867  	db 0x52 ; 041F2E
041F2F D8          5868  	db 0xd8 ; 041F2F
041F30 CB          5869  	db 0xcb ; 041F30
041F31             5870  ;
041F31             5871  ; Group 2: (3 opcodes)
041F31             5872  ;
041F31 42          5873  	db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
041F32 49          5874  	db 0x49 ; 041F32
041F33 D4          5875  	db 0xd4 ; 041F33
041F34 40          5876  	db 0x40 ; 041F34
041F35 52          5877  	db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
041F36 45          5878  	db 0x45 ; 041F36
041F37 D3          5879  	db 0xd3 ; 041F37
041F38 80          5880  	db 0x80 ; 041F38
041F39 53          5881  	db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
041F3A 45          5882  	db 0x45 ; 041F3A
041F3B D4          5883  	db 0xd4 ; 041F3B
041F3C C0          5884  	db 0xc0 ; 041F3C
041F3D             5885  ;
041F3D             5886  ; Group 3: (7 opcodes)
041F3D             5887  ;
041F3D 52          5888  	db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
041F3E 4C          5889  	db 0x4c ; 041F3E
041F3F C3          5890  	db 0xc3 ; 041F3F
041F40 00          5891  	db 0x00 ; 041F40
041F41 52          5892  	db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
041F42 52          5893  	db 0x52 ; 041F42
041F43 C3          5894  	db 0xc3 ; 041F43
041F44 08          5895  	db 0x08 ; 041F44
041F45 52          5896  	db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
041F46 CC          5897  	db 0xcc ; 041F46
041F47 10          5898  	db 0x10 ; 041F47
041F48 52          5899  	db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
041F49 D2          5900  	db 0xd2 ; 041F49
041F4A 18          5901  	db 0x18 ; 041F4A
041F4B 53          5902  	db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
041F4C 4C          5903  	db 0x4c ; 041F4C
041F4D C1          5904  	db 0xc1 ; 041F4D
041F4E 20          5905  	db 0x20 ; 041F4E
041F4F 53          5906  	db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
041F50 52          5907  	db 0x52 ; 041F50
041F51 C1          5908  	db 0xc1 ; 041F51
041F52 28          5909  	db 0x28 ; 041F52
041F53 53          5910  	db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
041F54 52          5911  	db 0x52 ; 041F54
041F55 CC          5912  	db 0xcc ; 041F55
041F56 38          5913  	db 0x38 ; 041F56
041F57             5914  ;
041F57             5915  ; Group 4: (3 opcodes)
041F57             5916  ;
041F57 50          5917  	db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
041F58 4F          5918  	db 0x4f ; 041F58
041F59 D0          5919  	db 0xd0 ; 041F59
041F5A C1          5920  	db 0xc1 ; 041F5A
041F5B 50          5921  	db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
041F5C 55          5922  	db 0x55 ; 041F5C
041F5D 53          5923  	db 0x53 ; 041F5D
041F5E C8          5924  	db 0xc8 ; 041F5E
041F5F C5          5925  	db 0xc5 ; 041F5F
041F60 45          5926  	db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
041F61 58          5927  	db 0x58 ; 041F61
041F62 00          5928  	db 0x00 ; 041F62
041F63 28          5929  	db 0x28 ; 041F63
041F64 53          5930  	db 0x53 ; 041F64
041F65 D0          5931  	db 0xd0 ; 041F65
041F66 E3          5932  	db 0xe3 ; 041F66
041F67             5933  ;
041F67             5934  ; Group 5: (7 opcodes)
041F67             5935  ;
041F67 53          5936  	db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
041F68 55          5937  	db 0x55 ; 041F68
041F69 C2          5938  	db 0xc2 ; 041F69
041F6A 90          5939  	db 0x90 ; 041F6A
041F6B 41          5940  	db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
041F6C 4E          5941  	db 0x4e ; 041F6C
041F6D C4          5942  	db 0xc4 ; 041F6D
041F6E A0          5943  	db 0xa0 ; 041F6E
041F6F 58          5944  	db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
041F70 4F          5945  	db 0x4f ; 041F70
041F71 D2          5946  	db 0xd2 ; 041F71
041F72 A8          5947  	db 0xa8 ; 041F72
041F73 4F          5948  	db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
041F74 D2          5949  	db 0xd2 ; 041F74
041F75 B0          5950  	db 0xb0 ; 041F75
041F76 43          5951  	db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
041F77 D0          5952  	db 0xd0 ; 041F77
041F78 B8          5953  	db 0xb8 ; 041F78
041F79 80          5954  	db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
041F7A A0          5955  	db 0xa0 ; 041F7A
041F7B 84          5956  	db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
041F7C B0          5957  	db 0xb0 ; 041F7C
041F7D             5958  ;
041F7D             5959  ; Group 6 (3 opcodes)
041F7D             5960  ;
041F7D 41          5961  	db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
041F7E 44          5962  	db 0x44 ; 041F7E
041F7F C4          5963  	db 0xc4 ; 041F7F
041F80 80          5964  	db 0x80 ; 041F80
041F81 41          5965  	db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
041F82 44          5966  	db 0x44 ; 041F82
041F83 C3          5967  	db 0xc3 ; 041F83
041F84 88          5968  	db 0x88 ; 041F84
041F85 53          5969  	db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
041F86 42          5970  	db 0x42 ; 041F86
041F87 C3          5971  	db 0xc3 ; 041F87
041F88 98          5972  	db 0x98 ; 041F88
041F89             5973  ;
041F89             5974  ; Group 7: (2 opcodes)
041F89             5975  ;
041F89 49          5976  	db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
041F8A 4E          5977  	db 0x4e ; 041F8A
041F8B C3          5978  	db 0xc3 ; 041F8B
041F8C 04          5979  	db 0x04 ; 041F8C
041F8D 44          5980  	db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
041F8E 45          5981  	db 0x45 ; 041F8E
041F8F C3          5982  	db 0xc3 ; 041F8F
041F90 05          5983  	db 0x05 ; 041F90
041F91             5984  ;
041F91             5985  ; Group 8: (2 opcodes)
041F91             5986  ;
041F91 49          5987  	db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
041F92 4E          5988  	db 0x4e ; 041F92
041F93 B0          5989  	db 0xb0 ; 041F93
041F94 00          5990  	db 0x00 ; 041F94
041F95 4F          5991  	db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
041F96 55          5992  	db 0x55 ; 041F96
041F97 54          5993  	db 0x54 ; 041F97
041F98 B0          5994  	db 0xb0 ; 041F98
041F99 01          5995  	db 0x01 ; 041F99
041F9A             5996  ;
041F9A             5997  ; Group 9: (1 opcode)
041F9A             5998  ;
041F9A 49          5999  	db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
041F9B CE          6000  	db 0xce ; 041F9B
041F9C 40          6001  	db 0x40 ; 041F9C
041F9D             6002  ;
041F9D             6003  ; Group 10: (1 opcode)
041F9D             6004  ;
041F9D 4F          6005  	db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
041F9E 55          6006  	db 0x55 ; 041F9E
041F9F D4          6007  	db 0xd4 ; 041F9F
041FA0 41          6008  	db 0x41 ; 041FA0
041FA1             6009  ;
041FA1             6010  ; Group 11: (2 opcodes)
041FA1             6011  ;
041FA1 4A          6012  	db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
041FA2 D2          6013  	db 0xd2 ; 041FA2
041FA3 20          6014  	db 0x20 ; 041FA3
041FA4 44          6015  	db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
041FA5 4A          6016  	db 0x4a ; 041FA5
041FA6 4E          6017  	db 0x4e ; 041FA6
041FA7 DA          6018  	db 0xda ; 041FA7
041FA8 10          6019  	db 0x10 ; 041FA8
041FA9             6020  ;
041FA9             6021  ; Group 12: (1 opcode)
041FA9             6022  ;
041FA9 4A          6023  	db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
041FAA D0          6024  	db 0xd0 ; 041FAA
041FAB C2          6025  	db 0xc2 ; 041FAB
041FAC             6026  ;
041FAC             6027  ; Group 13: (1 opcode)
041FAC             6028  ;
041FAC 43          6029  	db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
041FAD 41          6030  	db 0x41 ; 041FAD
041FAE 4C          6031  	db 0x4c ; 041FAE
041FAF CC          6032  	db 0xcc ; 041FAF
041FB0 C4          6033  	db 0xc4 ; 041FB0
041FB1             6034  ;
041FB1             6035  ; Group 14: (1 opcode)
041FB1             6036  ;
041FB1 52          6037  	db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
041FB2 53          6038  	db 0x53 ; 041FB2
041FB3 D4          6039  	db 0xd4 ; 041FB3
041FB4 C7          6040  	db 0xc7 ; 041FB4
041FB5             6041  ;
041FB5             6042  ; Group 15: (1 opcode)
041FB5             6043  ;
041FB5 52          6044  	db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
041FB6 45          6045  	db 0x45 ; 041FB6
041FB7 D4          6046  	db 0xd4 ; 041FB7
041FB8 C0          6047  	db 0xc0 ; 041FB8
041FB9             6048  ;
041FB9             6049  ; Group 16: (1 opcode)
041FB9             6050  ;
041FB9 4C          6051  	db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
041FBA C4          6052  	db 0xc4 ; 041FBA
041FBB 40          6053  	db 0x40 ; 041FBB
041FBC             6054  ;
041FBC             6055  ; Group 17: (1 opcode)
041FBC             6056  ;
041FBC 54          6057  	db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
041FBD 53          6058  	db 0x53 ; 041FBD
041FBE D4          6059  	db 0xd4 ; 041FBE
041FBF 04          6060  	db 0x04 ; 041FBF
041FC0             6061  ;
041FC0             6062  ; Assembler Directives
041FC0             6063  ;
041FC0 4F          6064  	db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
041FC1 50          6065  	db 0x50 ; 041FC1
041FC2 D4          6066  	db 0xd4 ; 041FC2
041FC3 00          6067  	db 0x00 ; 041FC3
041FC4 41          6068  	db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
041FC5 44          6069  	db 0x44 ; 041FC5
041FC6 CC          6070  	db 0xcc ; 041FC6
041FC7 00          6071  	db 0x00 ; 041FC7
041FC8 5D          6072  	db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041FC9 C2          6073  	db 0xc2 ; 041FC9
041FCA 00          6074  	db 0x00 ; 041FCA
041FCB 5D          6075  	db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041FCC D7          6076  	db 0xd7 ; 041FCC
041FCD 00          6077  	db 0x00 ; 041FCD
041FCE 5D          6078  	db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041FCF CC          6079  	db 0xcc ; 041FCF
041FD0 00          6080  	db 0x00 ; 041FD0
041FD1 5D          6081  	db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
041FD2 CD          6082  	db 0xcd ; 041FD2
041FD3 00          6083  	db 0x00 ; 041FD3
041FD4 00          6084  	db 0x00 ; 041FD4 00      5426 DB	0
041FD5             6085  ;
041FD5             6086  ; Operands
041FD5             6087  ;
041FD5             6088  OPRNDS:
041FD5 C2          6089  	db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
041FD6 00          6090  	db 0x00 ; 041FD6
041FD7 C3          6091  	db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
041FD8 01          6092  	db 0x01 ; 041FD8
041FD9 C4          6093  	db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
041FDA 02          6094  	db 0x02 ; 041FDA
041FDB C5          6095  	db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
041FDC 03          6096  	db 0x03 ; 041FDC
041FDD C8          6097  	db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
041FDE 04          6098  	db 0x04 ; 041FDE
041FDF CC          6099  	db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
041FE0 05          6100  	db 0x05 ; 041FE0
041FE1 28          6101  	db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
041FE2 48          6102  	db 0x48 ; 041FE2
041FE3 CC          6103  	db 0xcc ; 041FE3
041FE4 06          6104  	db 0x06 ; 041FE4
041FE5 C1          6105  	db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
041FE6 07          6106  	db 0x07 ; 041FE6
041FE7 28          6107  	db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
041FE8 49          6108  	db 0x49 ; 041FE8
041FE9 D8          6109  	db 0xd8 ; 041FE9
041FEA 86          6110  	db 0x86 ; 041FEA
041FEB 28          6111  	db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
041FEC 49          6112  	db 0x49 ; 041FEC
041FED D9          6113  	db 0xd9 ; 041FED
041FEE C6          6114  	db 0xc6 ; 041FEE
041FEF 42          6115  	db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
041FF0 C3          6116  	db 0xc3 ; 041FF0
041FF1 08          6117  	db 0x08 ; 041FF1
041FF2 44          6118  	db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
041FF3 C5          6119  	db 0xc5 ; 041FF3
041FF4 0A          6120  	db 0x0a ; 041FF4
041FF5 48          6121  	db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
041FF6 CC          6122  	db 0xcc ; 041FF6
041FF7 0C          6123  	db 0x0c ; 041FF7
041FF8 49          6124  	db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
041FF9 D8          6125  	db 0xd8 ; 041FF9
041FFA 8C          6126  	db 0x8c ; 041FFA
041FFB 49          6127  	db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
041FFC D9          6128  	db 0xd9 ; 041FFC
041FFD CC          6129  	db 0xcc ; 041FFD
041FFE 41          6130  	db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
041FFF C6          6131  	db 0xc6 ; 041FFF
042000 0E          6132  	db 0x0e ; 042000
042001 53          6133  	db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
042002 D0          6134  	db 0xd0 ; 042002
042003 0E          6135  	db 0x0e ; 042003
042004 4E          6136  	db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
042005 DA          6137  	db 0xda ; 042005
042006 10          6138  	db 0x10 ; 042006
042007 DA          6139  	db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
042008 11          6140  	db 0x11 ; 042008
042009 4E          6141  	db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
04200A C3          6142  	db 0xc3 ; 04200A
04200B 12          6143  	db 0x12 ; 04200B
04200C 50          6144  	db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
04200D CF          6145  	db 0xcf ; 04200D
04200E 14          6146  	db 0x14 ; 04200E
04200F 50          6147  	db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
042010 C5          6148  	db 0xc5 ; 042010
042011 15          6149  	db 0x15 ; 042011
042012 D0          6150  	db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
042013 16          6151  	db 0x16 ; 042013
042014 CD          6152  	db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
042015 17          6153  	db 0x17 ; 042015
042016 28          6154  	db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
042017 C3          6155  	db 0xc3 ; 042017
042018 20          6156  	db 0x20 ; 042018
042019 00          6157  	db 0x00 ; 042019 00      5459 DB	0
04201A             6158  ;
04201A             6159  ; Load operations
04201A             6160  ;
04201A             6161  LDOPS:
04201A 49          6162  	db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
04201B 00          6163  	db 0x00 ; 04201B
04201C C1          6164  	db 0xc1 ; 04201C
04201D 47          6165  	db 0x47 ; 04201D
04201E 52          6166  	db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
04201F 00          6167  	db 0x00 ; 04201F
042020 C1          6168  	db 0xc1 ; 042020
042021 4F          6169  	db 0x4f ; 042021
042022 41          6170  	db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
042023 00          6171  	db 0x00 ; 042023
042024 C9          6172  	db 0xc9 ; 042024
042025 57          6173  	db 0x57 ; 042025
042026 41          6174  	db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
042027 00          6175  	db 0x00 ; 042027
042028 D2          6176  	db 0xd2 ; 042028
042029 5F          6177  	db 0x5f ; 042029
04202A 28          6178  	db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
04202B 42          6179  	db 0x42 ; 04202B
04202C 43          6180  	db 0x43 ; 04202C
04202D 00          6181  	db 0x00 ; 04202D
04202E C1          6182  	db 0xc1 ; 04202E
04202F 02          6183  	db 0x02 ; 04202F
042030 28          6184  	db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
042031 44          6185  	db 0x44 ; 042031
042032 45          6186  	db 0x45 ; 042032
042033 00          6187  	db 0x00 ; 042033
042034 C1          6188  	db 0xc1 ; 042034
042035 12          6189  	db 0x12 ; 042035
042036 41          6190  	db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
042037 00          6191  	db 0x00 ; 042037
042038 28          6192  	db 0x28 ; 042038
042039 42          6193  	db 0x42 ; 042039
04203A C3          6194  	db 0xc3 ; 04203A
04203B 0A          6195  	db 0x0a ; 04203B
04203C 41          6196  	db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
04203D 00          6197  	db 0x00 ; 04203D
04203E 28          6198  	db 0x28 ; 04203E
04203F 44          6199  	db 0x44 ; 04203F
042040 C5          6200  	db 0xc5 ; 042040
042041 1A          6201  	db 0x1a ; 042041
042042 00          6202  	db 0x00 ; 042042 00      5472 DB	0
042043             6203  ;
042043             6204  ; eZ80 addressing mode suffixes
042043             6205  ;
042043             6206  ; Fully qualified suffixes
042043             6207  ;
042043             6208  EZ80SFS_1:
042043 4C          6209  	db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
042044 49          6210  	db 0x49 ; 042044
042045 D3          6211  	db 0xd3 ; 042045
042046 49          6212  	db 0x49 ; 042046
042047 53          6213  	db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
042048 49          6214  	db 0x49 ; 042048
042049 CC          6215  	db 0xcc ; 042049
04204A 52          6216  	db 0x52 ; 04204A
04204B             6217  
04204B             6218  EZ80SFS_2:
04204B 53          6219  	db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
04204C 49          6220  	db 0x49 ; 04204C
04204D D3          6221  	db 0xd3 ; 04204D
04204E 40          6222  	db 0x40 ; 04204E
04204F 4C          6223  	db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
042050 49          6224  	db 0x49 ; 042050
042051 CC          6225  	db 0xcc ; 042051
042052 5B          6226  	db 0x5b ; 042052
042053 00          6227  	db 0x00 ; 042053 00      5483 DB	0
042054             6228  ;
042054             6229  ; Shortcuts when ADL mode is 0
042054             6230  ;
042054             6231  EZ80SFS_ADL0:
042054 D3          6232  	db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042055 40          6233  	db 0x40 ; 042055
042056 CC          6234  	db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
042057 49          6235  	db 0x49 ; 042057
042058 49          6236  	db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
042059 D3          6237  	db 0xd3 ; 042059
04205A 40          6238  	db 0x40 ; 04205A
04205B 49          6239  	db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
04205C CC          6240  	db 0xcc ; 04205C
04205D 52          6241  	db 0x52 ; 04205D
04205E 00          6242  	db 0x00 ; 04205E 00      5492 DB	0
04205F             6243  ;
04205F             6244  ; Shortcuts when ADL mode is 1
04205F             6245  ;
04205F             6246  EZ80SFS_ADL1:
04205F D3          6247  	db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042060 52          6248  	db 0x52 ; 042060
042061 CC          6249  	db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
042062 5B          6250  	db 0x5b ; 042062
042063 49          6251  	db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
042064 D3          6252  	db 0xd3 ; 042064
042065 49          6253  	db 0x49 ; 042065
042066 49          6254  	db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
042067 CC          6255  	db 0xcc ; 042067
042068 5B          6256  	db 0x5b ; 042068
042069 00          6257  	db 0x00 ; 042069 00      5501 DB	0
04206A             6258  ; END INSERT FROM BINARY
04206A             6259  ;
04206A             6260  ; .LIST
04206A             6261  ;
04206A             6262  ; already defined in equs.inc
04206A             6263  ; LF:			EQU     0AH
04206A             6264  ; CR:			EQU     0DH; --- End exec.asm ---
04206A             6265  
04206A             6266  ; --- Begin fpp.asm ---
04206A             6267  ;
04206A             6268  ; Title:	BBC Basic Interpreter - Z80 version
04206A             6269  ;		Z80 Floating Point Package
04206A             6270  ; Author:	(C) Copyright  R.T.Russell  1986
04206A             6271  ; Modified By:	Dean Belfield
04206A             6272  ; Created:	03/05/2022
04206A             6273  ; Last Updated:	07/06/2023
04206A             6274  ;
04206A             6275  ; Modinfo:
04206A             6276  ; 26/10/1986:	Version 0.0
04206A             6277  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
04206A             6278  ; 12/05/2023:	Modified by Dean Belfield
04206A             6279  ; 07/06/2023:	Modified to run in ADL mode
04206A             6280  
04206A             6281  			; .ASSUME	ADL = 1
04206A             6282  
04206A             6283  			; SEGMENT CODE
04206A             6284  
04206A             6285  			; XDEF	FPP
04206A             6286  			; XDEF	DLOAD5
04206A             6287  			; XDEF	DLOAD5_SPL
04206A             6288  ;
04206A             6289  ;BINARY FLOATING POINT REPRESENTATION:
04206A             6290  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04206A             6291  ;    8 BIT EXCESS-128 SIGNED EXPONENT
04206A             6292  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04206A             6293  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04206A             6294  ;
04206A             6295  ;BINARY INTEGER REPRESENTATION:
04206A             6296  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04206A             6297  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
04206A             6298  ;
04206A             6299  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04206A             6300  ;                            EXPONENT - C
04206A             6301  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
04206A             6302  ;                               EXPONENT - B
04206A             6303  
04206A             6304  ;
04206A             6305  ;Error codes:
04206A             6306  ;
04206A             6307  
04206A             6308  BADOP:			EQU     1               ;Bad operation code
04206A             6309  DIVBY0:			EQU     18              ;Division by zero
04206A             6310  TOOBIG_FP:			EQU     20              ;Too big
04206A             6311  NGROOT:			EQU     21              ;Negative root
04206A             6312  LOGRNG:			EQU     22              ;Log range
04206A             6313  ACLOST:			EQU     23              ;Accuracy lost
04206A             6314  EXPRNG:			EQU     24              ;Exp range
04206A             6315  ;
04206A             6316  ;Call entry and despatch code:
04206A             6317  ;
04206A FD E5       6318  FPP:			PUSH    IY              ;Save IY
04206C FD 21 00 00 6319          		LD      IY,0
       00          
042071 FD 39       6320          		ADD     IY,SP           ;Save SP in IY
042073 CD 83 20 04 6321          		CALL    OP              ;Perform operation
042077 BF          6322          		CP      A               ;Good return (Z, NC)
042078 FD E1       6323  EXIT_FP_:			POP     IY              ;Restore IY
04207A C9          6324          		RET                     ;Return to caller
04207B             6325  ;
04207B             6326  ;Error exit:
04207B             6327  ;
04207B 3E 01       6328  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
04207D FD F9       6329  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
04207F B7          6330          		OR      A               ;Set NZ
042080 37          6331          		SCF                     ;Set C
042081 18 F5       6332          		JR      EXIT_FP_
042083             6333  ;
042083             6334  ;Perform operation or function:
042083             6335  ;
042083             6336  ; OP:			CP      (RTABLE-DTABLE)/3
042083 FE 2A       6337  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042085             6338  
042085 30 F4       6339          		JR      NC,BAD_FP
042087             6340          		; CP      (FTABLE-DTABLE)/3
042087 FE 10       6341  				CP      FTABLE-DTABLE/3 ; ditto
042089 30 08       6342          		JR      NC,DISPAT_FP
04208B 08          6343          		EX      AF,AF'
04208C 78          6344          		LD      A,B
04208D B1          6345          		OR      C               ;Both integer?
04208E C4 96 2B 04 6346          		CALL    NZ,FLOATA       ;No, so float both
042092 08          6347          		EX      AF,AF'
042093 E5          6348  DISPAT_FP:			PUSH    HL
042094 21 A6 20 04 6349          		LD      HL,DTABLE
042098 C5          6350          		PUSH    BC
042099 01 03 00 00 6351  			LD	BC, 3		; C = 3
04209D 47          6352  			LD	B, A 		; B = op-code
04209E ED 4C       6353  			MLT 	BC 		;BC = op-code * 3
0420A0 09          6354  			ADD	HL, BC 		;Add to table base
0420A1 ED 27       6355  			LD	HL, (HL)	;Get the routine address (24-bit)
0420A3             6356  
0420A3             6357  ;        		ADD     A, A            ;A = op-code * 2
0420A3             6358  ;        		LD      C,A
0420A3             6359  ;        		LD      B,0             ;BC = op-code * 2
0420A3             6360  ;        		ADD     HL,BC
0420A3             6361  ;        		LD      A,(HL)          ;Get low byte
0420A3             6362  ;        		INC     HL
0420A3             6363  ;        		LD      H,(HL)          ;Get high byte
0420A3             6364  ;        		LD      L,A
0420A3             6365  
0420A3 C1          6366          		POP     BC
0420A4 E3          6367          		EX      (SP),HL
0420A5 C9          6368          		RET                     ;Off to routine
0420A6             6369  ;
0420A6             6370  ;Despatch table:
0420A6             6371  ;
0420A6 58 21 04    6372  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420A9 C6 21 04    6373          		DW24  IBDIV           ;DIV
0420AC 6B 21 04    6374          		DW24  IEOR            ;EOR
0420AF 91 21 04    6375          		DW24  IMOD            ;MOD
0420B2 7E 21 04    6376          		DW24  IOR             ;OR
0420B5 4C 24 04    6377          		DW24  ILE             ;<=
0420B8 5B 24 04    6378          		DW24  INE             ;<>
0420BB 3F 24 04    6379          		DW24  IGE             ;>=
0420BE 24 24 04    6380          		DW24  ILT             ;<
0420C1 68 24 04    6381          		DW24  IEQ             ;=
0420C4 B4 22 04    6382          		DW24  IMUL            ;*
0420C7 EF 21 04    6383          		DW24  IADD            ;+
0420CA 31 24 04    6384          		DW24  IGT             ;>
0420CD D6 21 04    6385          		DW24  ISUB            ;-
0420D0 6B 23 04    6386          		DW24  IPOW            ;^
0420D3 61 22 04    6387          		DW24  IDIV            ;/
0420D6             6388  ;
0420D6             6389  FTABLE:
0420D6 7A 24 04    6390  				DW24  ABSV_FP            ;ABS
0420D9 60 28 04    6391          		DW24  ACS_FP             ;ACS
0420DC 9E 27 04    6392          		DW24  ASN_FP             ;ASN
0420DF CE 27 04    6393          		DW24  ATN_FP             ;ATN
0420E2 99 25 04    6394          		DW24  COS_FP             ;COS
0420E5 A8 24 04    6395          		DW24  DEG_FP             ;DEG
0420E8 55 26 04    6396          		DW24  EXP_FP             ;EXP
0420EB FC 24 04    6397          		DW24  INT_FP_            ;INT
0420EE F3 26 04    6398          		DW24  LN_FP              ;LN
0420F1 88 27 04    6399          		DW24  LOG_FP             ;LOG
0420F4 86 24 04    6400          		DW24  NOTK_FP            ;NOT
0420F7 B2 24 04    6401          		DW24  RAD_FP             ;RAD
0420FA CD 24 04    6402          		DW24  SGN_FP             ;SGN
0420FD A6 25 04    6403          		DW24  SIN_FP             ;SIN
042100 15 25 04    6404          		DW24  SQR_FP             ;SQR
042103 73 25 04    6405          		DW24  TAN_FP             ;TAN
042106             6406  ;
042106 23 2C 04    6407  		        DW24  ZERO_FP            ;ZERO
042109 2E 26 04    6408          		DW24  FONE_FP            ;FONE
04210C 6D 24 04    6409          		DW24  TRUE_FP            ;TRUE
04210F 9A 24 04    6410          		DW24  PI_FP              ;PI
042112             6411  ;
042112 E1 24 04    6412  		        DW24  VAL_FP             ;VAL
042115 69 28 04    6413          		DW24  STR_FP             ;STR$
042118             6414  ;
042118 CA 2A 04    6415          		DW24  SFIX_FP            ;FIX
04211B A6 2B 04    6416          		DW24  SFLOAT_FP          ;FLOAT
04211E             6417  ;
04211E F4 2B 04    6418  		        DW24  FTEST_FP           ;TEST
042121 06 2C 04    6419          		DW24  FCOMP_FP           ;COMPARE
042124             6420  ;
042124 54 21 04    6421  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042127 C2 21 04    6422          		DW24  FBDIV           ;DIV
04212A 67 21 04    6423          		DW24  FEOR            ;EOR
04212D 8D 21 04    6424          		DW24  FMOD            ;MOD
042130 7A 21 04    6425          		DW24  FFOR             ;OR
042133 46 24 04    6426          		DW24  FLE             ;<=
042136 55 24 04    6427          		DW24  FNE             ;<>
042139 39 24 04    6428          		DW24  FGE             ;>=
04213C 1E 24 04    6429          		DW24  FLT             ;<
04213F 62 24 04    6430          		DW24  FEQ             ;=
042142 0E 23 04    6431          		DW24  FMUL            ;*
042145 FC 21 04    6432          		DW24  FADD            ;+
042148 2B 24 04    6433          		DW24  FGT             ;>
04214B E3 21 04    6434          		DW24  FSUB            ;-
04214E EB 23 04    6435          		DW24  FPOW            ;^
042151 65 22 04    6436          		DW24  FDIV            ;/
042154             6437  ;
042154             6438  ;       PAGE
042154             6439  ;
042154             6440  ;ARITHMETIC AND LOGICAL OPERATORS:
042154             6441  ;All take two arguments, in HLH'L'C & DED'E'B.
042154             6442  ;Output in HLH'L'C
042154             6443  ;All registers except IX, IY destroyed.
042154             6444  ; (N.B. FPOW destroys IX).
042154             6445  ;
042154             6446  ;FAND - Floating-point AND.
042154             6447  ;IAND - Integer AND.
042154             6448  ;
042154 CD BE 2A 04 6449  FAND:			CALL    FIX2
042158 7C          6450  IAND:			LD      A,H
042159 A2          6451          		AND     D
04215A 67          6452          		LD      H,A
04215B 7D          6453          		LD      A,L
04215C A3          6454          		AND     E
04215D 6F          6455          		LD      L,A
04215E D9          6456          		EXX
04215F 7C          6457          		LD      A,H
042160 A2          6458          		AND     D
042161 67          6459          		LD      H,A
042162 7D          6460          		LD      A,L
042163 A3          6461          		AND     E
042164 6F          6462          		LD      L,A
042165 D9          6463          		EXX
042166 C9          6464          		RET
042167             6465  ;
042167             6466  ;FEOR - Floating-point exclusive-OR.
042167             6467  ;IEOR - Integer exclusive-OR.
042167             6468  ;
042167 CD BE 2A 04 6469  FEOR:			CALL    FIX2
04216B 7C          6470  IEOR:			LD      A,H
04216C AA          6471          		XOR     D
04216D 67          6472          		LD      H,A
04216E 7D          6473          		LD      A,L
04216F AB          6474          		XOR     E
042170 6F          6475          		LD      L,A
042171 D9          6476          		EXX
042172 7C          6477          		LD      A,H
042173 AA          6478          		XOR     D
042174 67          6479          		LD      H,A
042175 7D          6480          		LD      A,L
042176 AB          6481          		XOR     E
042177 6F          6482          		LD      L,A
042178 D9          6483          		EXX
042179 C9          6484          		RET
04217A             6485  ;
04217A             6486  ;FOR - Floating-point OR.
04217A             6487  ;IOR - Integer OR.
04217A             6488  ;
04217A CD BE 2A 04 6489  FFOR:			CALL    FIX2
04217E 7C          6490  IOR:			LD      A,H
04217F B2          6491          		OR      D
042180 67          6492          		LD      H,A
042181 7D          6493          		LD      A,L
042182 B3          6494          		OR      E
042183 6F          6495          		LD      L,A
042184 D9          6496          		EXX
042185 7C          6497          		LD      A,H
042186 B2          6498          		OR      D
042187 67          6499          		LD      H,A
042188 7D          6500          		LD      A,L
042189 B3          6501          		OR      E
04218A 6F          6502          		LD      L,A
04218B D9          6503          		EXX
04218C C9          6504          		RET
04218D             6505  ;
04218D             6506  ;FMOD - Floating-point remainder.
04218D             6507  ;IMOD - Integer remainder.
04218D             6508  ;
04218D CD BE 2A 04 6509  FMOD:			CALL    FIX2
042191 7C          6510  IMOD:			LD      A,H
042192 AA          6511          		XOR     D               ;DIV RESULT SIGN
042193 CB 7C       6512          		BIT     7,H
042195 08          6513          		EX      AF,AF'
042196 CB 7C       6514          		BIT     7,H
042198 C4 DA 2A 04 6515          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
04219C CD D7 2B 04 6516          		CALL    SWAP_FP
0421A0 CB 7C       6517          		BIT     7,H
0421A2 C4 DA 2A 04 6518          		CALL    NZ,NEGATE
0421A6 44          6519          		LD      B,H
0421A7 4D          6520          		LD      C,L
0421A8 21 00 00 00 6521          		LD      HL,0
0421AC D9          6522          		EXX
0421AD 44          6523          		LD      B,H
0421AE 4D          6524          		LD      C,L
0421AF 21 00 00 00 6525          		LD      HL,0
0421B3 3E DF       6526          		LD      A,-33
0421B5 CD 64 2D 04 6527          		CALL    DIVA            ;DIVIDE
0421B9 D9          6528          		EXX
0421BA 0E 00       6529          		LD      C,0             ;INTEGER MARKER
0421BC 08          6530          		EX      AF,AF'
0421BD C8          6531          		RET     Z
0421BE C3 DA 2A 04 6532          		JP      NEGATE
0421C2             6533  ;
0421C2             6534  ;BDIV - Integer division.
0421C2             6535  ;
0421C2 CD BE 2A 04 6536  FBDIV:			CALL    FIX2
0421C6 CD 91 21 04 6537  IBDIV:			CALL    IMOD
0421CA B7          6538          		OR      A
0421CB CD D7 2B 04 6539          		CALL    SWAP_FP
0421CF 0E 00       6540          		LD      C,0
0421D1 F0          6541          		RET     P
0421D2 C3 DA 2A 04 6542          		JP      NEGATE
0421D6             6543  ;
0421D6             6544  ;ISUB - Integer subtraction.
0421D6             6545  ;FSUB - Floating point subtraction with rounding.
0421D6             6546  ;
0421D6 CD 72 2C 04 6547  ISUB:			CALL    SUB_
0421DA E0          6548          		RET     PO
0421DB CD 6A 2C 04 6549          		CALL    ADD_
0421DF CD 9A 2B 04 6550          		CALL    FLOAT2
0421E3 7A          6551  FSUB:			LD      A,D
0421E4 EE 80       6552          		XOR     80H             ;CHANGE SIGN THEN ADD
0421E6 57          6553          		LD      D,A
0421E7 18 13       6554          		JR      FADD
0421E9             6555  ;
0421E9             6556  ;Reverse subtract.
0421E9             6557  ;
0421E9 7C          6558  RSUB:			LD      A,H
0421EA EE 80       6559          		XOR     80H
0421EC 67          6560          		LD      H,A
0421ED 18 0D       6561          		JR      FADD
0421EF             6562  ;
0421EF             6563  ;IADD - Integer addition.
0421EF             6564  ;FADD - Floating point addition with rounding.
0421EF             6565  ;
0421EF CD 6A 2C 04 6566  IADD:			CALL    ADD_
0421F3 E0          6567          		RET     PO
0421F4 CD 72 2C 04 6568          		CALL    SUB_
0421F8 CD 9A 2B 04 6569          		CALL    FLOAT2
0421FC 05          6570  FADD:			DEC     B
0421FD 04          6571          		INC     B
0421FE C8          6572          		RET     Z               ;ARG 2 ZERO
0421FF 0D          6573          		DEC     C
042200 0C          6574          		INC     C
042201 CA D7 2B 04 6575          		JP      Z,SWAP_FP          ;ARG 1 ZERO
042205 D9          6576          		EXX
042206 01 00 00 00 6577          		LD      BC,0            ;INITIALISE
04220A D9          6578          		EXX
04220B 7C          6579          		LD      A,H
04220C AA          6580          		XOR     D               ;XOR SIGNS
04220D F5          6581          		PUSH    AF
04220E 78          6582          		LD      A,B
04220F B9          6583          		CP      C               ;COMPARE EXPONENTS
042210 DC D7 2B 04 6584          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042214 78          6585          		LD      A,B
042215 CB FC       6586          		SET     7,H             ;IMPLIED 1
042217 C4 AB 2A 04 6587          		CALL    NZ,FIX          ;ALIGN
04221B F1          6588          		POP     AF
04221C 7A          6589          		LD      A,D             ;SIGN OF LARGER
04221D CB FA       6590          		SET     7,D             ;IMPLIED 1
04221F FA 2F 22 04 6591          		JP      M,FADD3         ;SIGNS DIFFERENT
042223 CD 6A 2C 04 6592          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
042227 DC DF 2B 04 6593          		CALL    C,DIV2          ;NORMALISE
04222B CB FC       6594          		SET     7,H
04222D 18 0D       6595          		JR      FADD4
04222F             6596  ;
04222F CD 72 2C 04 6597  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042233 DC F2 2A 04 6598          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
042237 CD 71 2B 04 6599          		CALL    FLO48
04223B 2F          6600          		CPL                     ;CHANGE RESULT SIGN
04223C D9          6601  FADD4:			EXX
04223D EB          6602          		EX      DE,HL
04223E 21 00 80 00 6603          		LD      HL,8000H
042242 B7          6604          		OR      A               ;CLEAR CARRY
042243 52 ED 42    6605          		SBC.S   HL,BC
042246 EB          6606          		EX      DE,HL
042247 D9          6607          		EXX
042248 CC D1 2B 04 6608          		CALL    Z,ODD           ;ROUND UNBIASSED
04224C DC BF 2B 04 6609          		CALL    C,ADD1_FP          ;ROUND UP
042250 DC EC 2B 04 6610          		CALL    C,INCC
042254 CB BC       6611          		RES     7,H
042256 0D          6612          		DEC     C
042257 0C          6613          		INC     C
042258 CA 23 2C 04 6614          		JP      Z,ZERO_FP
04225C B7          6615          		OR      A               ;RESULT SIGNQ
04225D F0          6616          		RET     P               ;POSITIVE
04225E CB FC       6617          		SET     7,H             ;NEGATIVE
042260 C9          6618          		RET
042261             6619  ;
042261             6620  ;IDIV - Integer division.
042261             6621  ;FDIV - Floating point division with rounding.
042261             6622  ;
042261 CD 9A 2B 04 6623  IDIV:			CALL    FLOAT2
042265 05          6624  FDIV:			DEC     B               ;TEST FOR ZERO
042266 04          6625          		INC     B
042267 3E 12       6626          		LD      A,DIVBY0
042269 CA 7D 20 04 6627          		JP      Z,ERROR_FP_         ;"Division by zero"
04226D 0D          6628          		DEC     C               ;TEST FOR ZERO
04226E 0C          6629          		INC     C
04226F C8          6630          		RET     Z
042270 7C          6631          		LD      A,H
042271 AA          6632          		XOR     D               ;CALC. RESULT SIGN
042272 08          6633          		EX      AF,AF'          ;SAVE SIGN
042273 CB FA       6634          		SET     7,D             ;REPLACE IMPLIED 1's
042275 CB FC       6635          		SET     7,H
042277 C5          6636          		PUSH    BC              ;SAVE EXPONENTS
042278 42          6637          		LD      B,D             ;LOAD REGISTERS
042279 4B          6638          		LD      C,E
04227A 11 00 00 00 6639          		LD      DE,0
04227E D9          6640          		EXX
04227F 42          6641          		LD      B,D
042280 4B          6642          		LD      C,E
042281 11 00 00 00 6643          		LD      DE,0
042285 3E E0       6644          		LD      A,-32           ;LOOP COUNTER
042287 CD 64 2D 04 6645          		CALL    DIVA            ;DIVIDE
04228B D9          6646          		EXX
04228C CB 7A       6647          		BIT     7,D
04228E D9          6648          		EXX
04228F CC 83 2D 04 6649          		CALL    Z,DIVB          ;NORMALISE & INC A
042293 EB          6650          		EX      DE,HL
042294 D9          6651          		EXX
042295 CB 38       6652          		SRL     B               ;DIVISOR/2
042297 CB 19       6653          		RR      C
042299 B7          6654          		OR      A               ;CLEAR CARRY
04229A 52 ED 42    6655          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
04229D 3F          6656          		CCF
04229E EB          6657          		EX      DE,HL           ;RESULT IN HLH'L'
04229F CC D1 2B 04 6658          		CALL    Z,ODD           ;ROUND UNBIASSED
0422A3 DC BF 2B 04 6659          		CALL    C,ADD1_FP          ;ROUND UP
0422A7 C1          6660          		POP     BC              ;RESTORE EXPONENTS
0422A8 DC EC 2B 04 6661          		CALL    C,INCC
0422AC 1F          6662          		RRA                     ;LSB OF A TO CARRY
0422AD 79          6663          		LD      A,C             ;COMPUTE NEW EXPONENT
0422AE 98          6664          		SBC     A,B
0422AF 3F          6665          		CCF
0422B0 C3 51 23 04 6666          		JP      CHKOVF
0422B4             6667  ;
0422B4             6668  ;IMUL - Integer multiplication.
0422B4             6669  ;
0422B4 7C          6670  IMUL:			LD      A,H
0422B5 AA          6671          		XOR     D
0422B6 08          6672          		EX      AF,AF'          ;SAVE RESULT SIGN
0422B7 CB 7C       6673          		BIT     7,H
0422B9 C4 DA 2A 04 6674          		CALL    NZ,NEGATE
0422BD CD D7 2B 04 6675          		CALL    SWAP_FP
0422C1 CB 7C       6676          		BIT     7,H
0422C3 C4 DA 2A 04 6677          		CALL    NZ,NEGATE
0422C7 44          6678          		LD      B,H
0422C8 4D          6679          		LD      C,L
0422C9 21 00 00 00 6680          		LD      HL,0
0422CD D9          6681          		EXX
0422CE 44          6682          		LD      B,H
0422CF 4D          6683          		LD      C,L
0422D0 21 00 00 00 6684          		LD      HL,0
0422D4 3E DF       6685          		LD      A,-33
0422D6 CD 9B 2D 04 6686          		CALL    MULA            ;MULTIPLY
0422DA D9          6687          		EXX
0422DB 0E BF       6688          		LD      C,191           ;PRESET EXPONENT
0422DD CD FF 2B 04 6689          		CALL    TEST_FP            ;TEST RANGE
0422E1 20 0F       6690          		JR      NZ,IMUL1        ;TOO BIG
0422E3 CB 7A       6691          		BIT     7,D
0422E5 20 0B       6692          		JR      NZ,IMUL1
0422E7 CD D7 2B 04 6693          		CALL    SWAP_FP
0422EB 4A          6694          		LD      C,D             ;INTEGER MARKER
0422EC 08          6695          		EX      AF,AF'
0422ED F0          6696          		RET     P
0422EE C3 DA 2A 04 6697          		JP      NEGATE
0422F2             6698  ;
0422F2 0D          6699  IMUL1:			DEC     C
0422F3 D9          6700          		EXX
0422F4 CB 23       6701          		SLA     E
0422F6 CB 12       6702          		RL      D
0422F8 D9          6703          		EXX
0422F9 CB 13       6704          		RL      E
0422FB CB 12       6705          		RL      D
0422FD D9          6706          		EXX
0422FE 52 ED 6A    6707          		ADC.S   HL,HL
042301 D9          6708          		EXX
042302 52 ED 6A    6709          		ADC.S   HL,HL
042305 F2 F2 22 04 6710          		JP      P,IMUL1         ;NORMALISE
042309 08          6711          		EX      AF,AF'
04230A F8          6712          		RET     M
04230B CB BC       6713          		RES     7,H             ;POSITIVE
04230D C9          6714          		RET
04230E             6715  ;
04230E             6716  ;FMUL - Floating point multiplication with rounding.
04230E             6717  ;
04230E 05          6718  FMUL:			DEC     B               ;TEST FOR ZERO
04230F 04          6719          		INC     B
042310 CA 23 2C 04 6720          		JP      Z,ZERO_FP
042314 0D          6721          		DEC     C               ;TEST FOR ZERO
042315 0C          6722          		INC     C
042316 C8          6723          		RET     Z
042317 7C          6724          		LD      A,H
042318 AA          6725          		XOR     D               ;CALC. RESULT SIGN
042319 08          6726          		EX      AF,AF'
04231A CB FA       6727          		SET     7,D             ;REPLACE IMPLIED 1's
04231C CB FC       6728          		SET     7,H
04231E C5          6729          		PUSH    BC              ;SAVE EXPONENTS
04231F 44          6730          		LD      B,H             ;LOAD REGISTERS
042320 4D          6731          		LD      C,L
042321 21 00 00 00 6732          		LD      HL,0
042325 D9          6733          		EXX
042326 44          6734          		LD      B,H
042327 4D          6735          		LD      C,L
042328 21 00 00 00 6736          		LD      HL,0
04232C 3E E0       6737          		LD      A,-32           ;LOOP COUNTER
04232E CD 9B 2D 04 6738          		CALL    MULA            ;MULTIPLY
042332 DC B1 2D 04 6739          		CALL    C,MULB          ;NORMALISE & INC A
042336 D9          6740          		EXX
042337 E5          6741          		PUSH    HL
042338 21 00 80 00 6742          		LD      HL,8000H
04233C B7          6743          		OR      A               ;CLEAR CARRY
04233D 52 ED 52    6744          		SBC.S   HL,DE
042340 E1          6745          		POP     HL
042341 CC D1 2B 04 6746          		CALL    Z,ODD           ;ROUND UNBIASSED
042345 DC BF 2B 04 6747          		CALL    C,ADD1_FP          ;ROUND UP
042349 C1          6748          		POP     BC              ;RESTORE EXPONENTS
04234A DC EC 2B 04 6749          		CALL    C,INCC
04234E 1F          6750          		RRA                     ;LSB OF A TO CARRY
04234F 79          6751          		LD      A,C             ;COMPUTE NEW EXPONENT
042350 88          6752          		ADC     A,B
042351 38 06       6753  CHKOVF:			JR      C,CHKO1
042353 F2 23 2C 04 6754          		JP      P,ZERO_FP          ;UNDERFLOW
042357 18 04       6755          		JR      CHKO2
042359 FA EE 2B 04 6756  CHKO1:			JP      M,OFLOW         ;OVERFLOW
04235D C6 80       6757  CHKO2:			ADD     A,80H
04235F 4F          6758          		LD      C,A
042360 CA 23 2C 04 6759          		JP      Z,ZERO_FP
042364 08          6760          		EX      AF,AF'          ;RESTORE SIGN BIT
042365 CB BC       6761          		RES     7,H
042367 F0          6762          		RET     P
042368 CB FC       6763          		SET     7,H
04236A C9          6764          		RET
04236B             6765  ;
04236B             6766  ;IPOW - Integer involution.
04236B             6767  ;
04236B CD D7 2B 04 6768  IPOW:			CALL    SWAP_FP
04236F CB 7C       6769          		BIT     7,H
042371 F5          6770          		PUSH    AF              ;SAVE SIGN
042372 C4 DA 2A 04 6771          		CALL    NZ,NEGATE
042376 48          6772  IPOW0:			LD      C,B
042377 06 20       6773          		LD      B,32            ;LOOP COUNTER
042379 CD 8F 2C 04 6774  IPOW1:			CALL    X2
04237D 38 08       6775          		JR      C,IPOW2
04237F 10 F8       6776          		DJNZ    IPOW1
042381 F1          6777          		POP     AF
042382 D9          6778          		EXX
042383 2C          6779          		INC     L               ;RESULT=1
042384 D9          6780          		EXX
042385 4C          6781          		LD      C,H
042386 C9          6782          		RET
042387             6783  ;
042387 F1          6784  IPOW2:			POP     AF
042388 C5          6785          		PUSH    BC
042389 EB          6786          		EX      DE,HL
04238A E5          6787          		PUSH    HL
04238B D9          6788          		EXX
04238C EB          6789          		EX      DE,HL
04238D E5          6790          		PUSH    HL
04238E D9          6791          		EXX
04238F DD 21 00 00 6792          		LD      IX,0
       00          
042394 DD 39       6793          		ADD     IX,SP
042396 28 48       6794          		JR      Z,IPOW4
042398 C5          6795          		PUSH    BC
042399 D9          6796          		EXX
04239A D5          6797          		PUSH    DE
04239B D9          6798          		EXX
04239C D5          6799          		PUSH    DE
04239D CD A6 2B 04 6800          		CALL    SFLOAT_FP
0423A1 CD DA 26 04 6801          		CALL    RECIP
0423A5 DD 71 04    6802          		LD      (IX+4),C
0423A8 D9          6803          		EXX
0423A9 DD 75 00    6804          		LD      (IX+0),L
0423AC DD 74 01    6805          		LD      (IX+1),H
0423AF D9          6806          		EXX
0423B0 DD 75 02    6807          		LD      (IX+2),L
0423B3 DD 74 03    6808          		LD      (IX+3),H
0423B6 18 21       6809          		JR      IPOW5
0423B8             6810  ;
0423B8 C5          6811  IPOW3:			PUSH    BC
0423B9 D9          6812          		EXX
0423BA CB 23       6813          		SLA     E
0423BC CB 12       6814          		RL      D
0423BE D5          6815          		PUSH    DE
0423BF D9          6816          		EXX
0423C0 CB 13       6817          		RL      E
0423C2 CB 12       6818          		RL      D
0423C4 D5          6819          		PUSH    DE
0423C5 3E 0A       6820          		LD      A,'*' & 0FH
0423C7 F5          6821          		PUSH    AF
0423C8 CD A3 2C 04 6822          		CALL    COPY_
0423CC CD 83 20 04 6823          		CALL    OP              ;SQUARE
0423D0 F1          6824          		POP     AF
0423D1 CD CF 29 04 6825          		CALL    DLOAD5
0423D5 DC 83 20 04 6826          		CALL    C,OP            ;MULTIPLY BY X
0423D9 D1          6827  IPOW5:			POP     DE
0423DA D9          6828          		EXX
0423DB D1          6829          		POP     DE
0423DC D9          6830          		EXX
0423DD 79          6831          		LD      A,C
0423DE C1          6832          		POP     BC
0423DF 4F          6833          		LD      C,A
0423E0 10 D6       6834  IPOW4:			DJNZ    IPOW3
0423E2 F1          6835          		POP     AF
0423E3 F1          6836          		POP     AF
0423E4 F1          6837          		POP     AF
0423E5 C9          6838          		RET
0423E6             6839  ;
0423E6 F1          6840  FPOW0:			POP     AF
0423E7 F1          6841          		POP     AF
0423E8 F1          6842          		POP     AF
0423E9 18 8B       6843          		JR      IPOW0
0423EB             6844  ;
0423EB             6845  ;FPOW - Floating-point involution.
0423EB             6846  ;
0423EB CB 7A       6847  FPOW:			BIT     7,D
0423ED F5          6848          		PUSH    AF
0423EE CD D7 2B 04 6849          		CALL    SWAP_FP
0423F2 CD B3 2C 04 6850          		CALL    PUSH5
0423F6 0D          6851          		DEC     C
0423F7 0C          6852          		INC     C
0423F8 28 EC       6853          		JR      Z,FPOW0
0423FA 3E 9E       6854          		LD      A,158
0423FC B9          6855          		CP      C
0423FD 38 0A       6856          		JR      C,FPOW1
0423FF 3C          6857          		INC     A
042400 CD AB 2A 04 6858          		CALL    FIX
042404 08          6859          		EX      AF,AF'
042405 F2 E6 23 04 6860          		JP      P,FPOW0
042409 CD D7 2B 04 6861  FPOW1:			CALL    SWAP_FP
04240D CD F7 26 04 6862          		CALL    LN0
042411 CD BC 2C 04 6863          		CALL    POP5
042415 F1          6864          		POP     AF
042416 CD 0E 23 04 6865          		CALL    FMUL
04241A C3 59 26 04 6866          		JP      EXP0
04241E             6867  ;
04241E             6868  ;Integer and floating-point compare.
04241E             6869  ;Result is TRUE (-1) or FALSE (0).
04241E             6870  ;
04241E CD 2D 2C 04 6871  FLT:			CALL    FCP
042422 18 04       6872          		JR      ILT1
042424 CD 1F 2C 04 6873  ILT:			CALL    ICP
042428 D0          6874  ILT1:			RET     NC
042429 18 42       6875          		JR      TRUE_FP
04242B             6876  ;
04242B CD 2D 2C 04 6877  FGT:			CALL    FCP
04242F 18 04       6878          		JR      IGT1
042431 CD 1F 2C 04 6879  IGT:			CALL    ICP
042435 C8          6880  IGT1:			RET     Z
042436 D8          6881          		RET     C
042437 18 34       6882          		JR      TRUE_FP
042439             6883  ;
042439 CD 2D 2C 04 6884  FGE:			CALL    FCP
04243D 18 04       6885          		JR      IGE1
04243F CD 1F 2C 04 6886  IGE:			CALL    ICP
042443 D8          6887  IGE1:			RET     C
042444 18 27       6888          		JR      TRUE_FP
042446             6889  ;
042446 CD 2D 2C 04 6890  FLE:			CALL    FCP
04244A 18 04       6891          		JR      ILE1
04244C CD 1F 2C 04 6892  ILE:			CALL    ICP
042450 28 1B       6893  ILE1:			JR      Z,TRUE_FP
042452 D0          6894          		RET     NC
042453 18 18       6895          		JR      TRUE_FP
042455             6896  ;
042455 CD 2D 2C 04 6897  FNE:			CALL    FCP
042459 18 04       6898          		JR      INE1
04245B CD 1F 2C 04 6899  INE:			CALL    ICP
04245F C8          6900  INE1:			RET     Z
042460 18 0B       6901          		JR      TRUE_FP
042462             6902  ;
042462 CD 2D 2C 04 6903  FEQ:			CALL    FCP
042466 18 04       6904          		JR      IEQ1
042468 CD 1F 2C 04 6905  IEQ:			CALL    ICP
04246C C0          6906  IEQ1:			RET     NZ
04246D 21 FF FF FF 6907  TRUE_FP:			LD      HL,-1
042471 D9          6908          		EXX
042472 21 FF FF FF 6909          		LD      HL,-1
042476 D9          6910          		EXX
042477 AF          6911          		XOR     A
042478 4F          6912          		LD      C,A
042479 C9          6913          		RET
04247A             6914  ;
04247A             6915  ;FUNCTIONS:
04247A             6916  ;
04247A             6917  ;Result returned in HLH'L'C (floating point)
04247A             6918  ;Result returned in HLH'L' (C=0) (integer)
04247A             6919  ;All registers except IY destroyed.
04247A             6920  ;
04247A             6921  ;ABS - Absolute value
04247A             6922  ;Result is numeric, variable type.
04247A             6923  ;
04247A CB 7C       6924  ABSV_FP:			BIT     7,H
04247C C8          6925          		RET     Z               ;POSITIVE/ZERO
04247D 0D          6926          		DEC     C
04247E 0C          6927          		INC     C
04247F CA DA 2A 04 6928          		JP      Z,NEGATE        ;INTEGER
042483 CB BC       6929          		RES     7,H
042485 C9          6930          		RET
042486             6931  ;
042486             6932  ;NOT - Complement integer.
042486             6933  ;Result is integer numeric.
042486             6934  ;
042486 CD CA 2A 04 6935  NOTK_FP:			CALL    SFIX_FP
04248A 7C          6936          		LD      A,H
04248B 2F          6937          		CPL
04248C 67          6938          		LD      H,A
04248D 7D          6939          		LD      A,L
04248E 2F          6940          		CPL
04248F 6F          6941          		LD      L,A
042490 D9          6942          		EXX
042491 7C          6943          		LD      A,H
042492 2F          6944          		CPL
042493 67          6945          		LD      H,A
042494 7D          6946          		LD      A,L
042495 2F          6947          		CPL
042496 6F          6948          		LD      L,A
042497 D9          6949          		EXX
042498 AF          6950          		XOR     A               ;NUMERIC MARKER
042499 C9          6951          		RET
04249A             6952  ;
04249A             6953  ;PI - Return PI (3.141592654)
04249A             6954  ;Result is floating-point numeric.
04249A             6955  ;
04249A 21 0F 49 00 6956  PI_FP:			LD      HL,490FH
04249E D9          6957          		EXX
04249F 21 A2 DA 00 6958          		LD      HL,0DAA2H
0424A3 D9          6959          		EXX
0424A4 0E 81       6960          		LD      C,81H
0424A6 AF          6961          		XOR     A               ;NUMERIC MARKER
0424A7 C9          6962          		RET
0424A8             6963  ;
0424A8             6964  ;DEG - Convert radians to degrees
0424A8             6965  ;Result is floating-point numeric.
0424A8             6966  ;
0424A8 CD BC 24 04 6967  DEG_FP:			CALL    FPI180
0424AC CD 0E 23 04 6968          		CALL    FMUL
0424B0 AF          6969          		XOR     A
0424B1 C9          6970          		RET
0424B2             6971  ;
0424B2             6972  ;RAD - Convert degrees to radians
0424B2             6973  ;Result is floating-point numeric.
0424B2             6974  ;
0424B2 CD BC 24 04 6975  RAD_FP:			CALL    FPI180
0424B6 CD 65 22 04 6976          		CALL    FDIV
0424BA AF          6977          		XOR     A
0424BB C9          6978          		RET
0424BC             6979  ;
0424BC             6980  ;180/PI
0424BC             6981  ;
0424BC CD A6 2B 04 6982  FPI180:			CALL    SFLOAT_FP
0424C0 11 2E 65 00 6983          		LD      DE,652EH
0424C4 D9          6984          		EXX
0424C5 11 D3 E0 00 6985          		LD      DE,0E0D3H
0424C9 D9          6986          		EXX
0424CA 06 85       6987          		LD      B,85H
0424CC C9          6988          		RET
0424CD             6989  ;
0424CD             6990  ;SGN - Return -1, 0 or +1
0424CD             6991  ;Result is integer numeric.
0424CD             6992  ;
0424CD CD FF 2B 04 6993  SGN_FP:			CALL    TEST_FP
0424D1 B1          6994          		OR      C
0424D2 C8          6995          		RET     Z               ;ZERO
0424D3 CB 7C       6996          		BIT     7,H
0424D5 C2 6D 24 04 6997          		JP      NZ,TRUE_FP         ;-1
0424D9 CD 23 2C 04 6998          		CALL    ZERO_FP
0424DD C3 BF 2B 04 6999          		JP      ADD1_FP            ;1
0424E1             7000  ;
0424E1             7001  ;VAL - Return numeric value of string.
0424E1             7002  ;Input: ASCII string at IX
0424E1             7003  ;Result is variable type numeric.
0424E1             7004  ;
0424E1 CD 3D 2E 04 7005  VAL_FP:			CALL    SIGNQ
0424E5 F5          7006          		PUSH    AF
0424E6 CD ED 29 04 7007          		CALL    CON_FP
0424EA F1          7008          		POP     AF
0424EB FE 2D       7009          		CP      '-'
0424ED 3E 00       7010          		LD      A,0             ;NUMERIC MARKER
0424EF C0          7011          		RET     NZ
0424F0 0D          7012          		DEC     C
0424F1 0C          7013          		INC     C
0424F2 CA DA 2A 04 7014          		JP      Z,NEGATE        ;ZERO/INTEGER
0424F6 7C          7015          		LD      A,H
0424F7 EE 80       7016          		XOR     80H             ;CHANGE SIGN (FP)
0424F9 67          7017          		LD      H,A
0424FA AF          7018          		XOR     A
0424FB C9          7019          		RET
0424FC             7020  ;
0424FC             7021  ;INT - Floor function
0424FC             7022  ;Result is integer numeric.
0424FC             7023  ;
0424FC 0D          7024  INT_FP_:			DEC     C
0424FD 0C          7025          		INC     C
0424FE C8          7026          		RET     Z               ;ZERO/INTEGER
0424FF 3E 9F       7027          		LD      A,159
042501 44          7028          		LD      B,H             ;B7=SIGN BIT
042502 CD AB 2A 04 7029          		CALL    FIX
042506 08          7030          		EX      AF,AF'
042507 A0          7031          		AND     B
042508 FC BF 2B 04 7032          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04250C 78          7033          		LD      A,B
04250D B7          7034          		OR      A
04250E FC DA 2A 04 7035          		CALL    M,NEGATE
042512 AF          7036          		XOR     A
042513 4F          7037          		LD      C,A
042514 C9          7038          		RET
042515             7039  ;
042515             7040  ;SQR - square root
042515             7041  ;Result is floating-point numeric.
042515             7042  ;
042515 CD A6 2B 04 7043  SQR_FP:			CALL    SFLOAT_FP
042519 CB 7C       7044  SQR0:			BIT     7,H
04251B 3E 15       7045          		LD      A,NGROOT
04251D C2 7D 20 04 7046          		JP      NZ,ERROR_FP_        ;"-ve root"
042521 0D          7047          		DEC     C
042522 0C          7048          		INC     C
042523 C8          7049          		RET     Z               ;ZERO
042524 CB FC       7050          		SET     7,H             ;IMPLIED 1
042526 CB 41       7051          		BIT     0,C
042528 CC DF 2B 04 7052          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
04252C 79          7053          		LD      A,C
04252D D6 80       7054          		SUB     80H
04252F CB 2F       7055          		SRA     A               ;HALVE EXPONENT
042531 C6 80       7056          		ADD     A,80H
042533 4F          7057          		LD      C,A
042534 C5          7058          		PUSH    BC              ;SAVE EXPONENT
042535 EB          7059          		EX      DE,HL
042536 21 00 00 00 7060          		LD      HL,0
04253A 44          7061          		LD      B,H
04253B 4D          7062          		LD      C,L
04253C D9          7063          		EXX
04253D EB          7064          		EX      DE,HL
04253E 21 00 00 00 7065          		LD      HL,0
042542 44          7066          		LD      B,H
042543 4D          7067          		LD      C,L
042544 3E E1       7068          		LD      A,-31
042546 CD D5 2D 04 7069          		CALL    SQRA            ;ROOT
04254A D9          7070          		EXX
04254B CB 78       7071          		BIT     7,B
04254D D9          7072          		EXX
04254E CC D5 2D 04 7073          		CALL    Z,SQRA          ;NORMALISE & INC A
042552 CD 16 2E 04 7074          		CALL    SQRB
042556 B7          7075          		OR      A               ;CLEAR CARRY
042557 CD 83 2D 04 7076          		CALL    DIVB
04255B CB 1B       7077          		RR      E               ;LSB TO CARRY
04255D 60          7078          		LD      H,B
04255E 69          7079          		LD      L,C
04255F D9          7080          		EXX
042560 60          7081          		LD      H,B
042561 69          7082          		LD      L,C
042562 DC BF 2B 04 7083          		CALL    C,ADD1_FP          ;ROUND UP
042566 C1          7084          		POP     BC              ;RESTORE EXPONENT
042567 DC EC 2B 04 7085          		CALL    C,INCC
04256B 1F          7086          		RRA
04256C 9F          7087          		SBC     A,A
04256D 81          7088          		ADD     A,C
04256E 4F          7089          		LD      C,A
04256F CB BC       7090          		RES     7,H             ;POSITIVE
042571 AF          7091          		XOR     A
042572 C9          7092          		RET
042573             7093  ;
042573             7094  ;TAN - Tangent function
042573             7095  ;Result is floating-point numeric.
042573             7096  ;
042573 CD A6 2B 04 7097  TAN_FP:			CALL    SFLOAT_FP
042577 CD B3 2C 04 7098          		CALL    PUSH5
04257B CD 9D 25 04 7099          		CALL    COS0
04257F CD BC 2C 04 7100          		CALL    POP5
042583 CD B3 2C 04 7101          		CALL    PUSH5
042587 CD D7 2B 04 7102          		CALL    SWAP_FP
04258B CD AA 25 04 7103          		CALL    SIN0
04258F CD BC 2C 04 7104          		CALL    POP5
042593 CD 65 22 04 7105          		CALL    FDIV
042597 AF          7106          		XOR     A               ;NUMERIC MARKER
042598 C9          7107          		RET
042599             7108  ;
042599             7109  ;COS - Cosine function
042599             7110  ;Result is floating-point numeric.
042599             7111  ;
042599 CD A6 2B 04 7112  COS_FP:			CALL    SFLOAT_FP
04259D CD 02 2B 04 7113  COS0:			CALL    SCALE
0425A1 1C          7114          		INC     E
0425A2 1C          7115          		INC     E
0425A3 7B          7116          		LD      A,E
0425A4 18 10       7117          		JR      SIN1
0425A6             7118  ;
0425A6             7119  ;SIN - Sine function
0425A6             7120  ;Result is floating-point numeric.
0425A6             7121  ;
0425A6 CD A6 2B 04 7122  SIN_FP:			CALL    SFLOAT_FP
0425AA E5          7123  SIN0:			PUSH    HL              ;H7=SIGN
0425AB CD 02 2B 04 7124          		CALL    SCALE
0425AF F1          7125          		POP     AF
0425B0 07          7126          		RLCA
0425B1 07          7127          		RLCA
0425B2 07          7128          		RLCA
0425B3 E6 04       7129          		AND     4
0425B5 AB          7130          		XOR     E
0425B6 F5          7131  SIN1:			PUSH    AF              ;OCTANT
0425B7 CB BC       7132          		RES     7,H
0425B9 1F          7133          		RRA
0425BA CD 48 26 04 7134          		CALL    PIBY4
0425BE DC E9 21 04 7135          		CALL    C,RSUB          ;X=(PI/4)-X
0425C2 F1          7136          		POP     AF
0425C3 F5          7137          		PUSH    AF
0425C4 E6 03       7138          		AND     3
0425C6 E2 FF 25 04 7139          		JP      PO,SIN2         ;USE COSINE APPROX.
0425CA CD B3 2C 04 7140          		CALL    PUSH5           ;SAVE X
0425CE CD AB 2C 04 7141          		CALL    SQUARE          ;PUSH X*X
0425D2 CD F0 2C 04 7142          		CALL    POLY
0425D6 B7 A8       7143          		DW	0A8B7H          ;a(8)
0425D8 11 36       7144          		DW	3611H
0425DA 6D          7145          		DB	6DH
0425DB 26 DE       7146          		DW	0DE26H          ;a(6)
0425DD 05 D0       7147          		DW	0D005H
0425DF 73          7148          		DB	73H
0425E0 C0 80       7149          		DW	80C0H           ;a(4)
0425E2 88 08       7150          		DW	888H
0425E4 79          7151          		DB	79H
0425E5 9D AA       7152          		DW	0AA9DH          ;a(2)
0425E7 AA AA       7153          		DW	0AAAAH
0425E9 7D          7154          		DB	7DH
0425EA 00 00       7155          		DW	0               ;a(0)
0425EC 00 00       7156          		DW	0
0425EE 80          7157          		DB	80H
0425EF CD BC 2C 04 7158          		CALL    POP5
0425F3 CD BC 2C 04 7159          		CALL    POP5
0425F7 CD 0E 23 04 7160          		CALL    FMUL
0425FB C3 24 26 04 7161          		JP      SIN3
0425FF             7162  ;
0425FF CD AB 2C 04 7163  SIN2:			CALL    SQUARE          ;PUSH X*X
042603 CD F0 2C 04 7164          		CALL    POLY
042607 71 D5       7165          		DW	0D571H          ;b(8)
042609 78 4C       7166          		DW	4C78H
04260B 70          7167          		DB	70H
04260C AF 94       7168          		DW	94AFH           ;b(6)
04260E 03 B6       7169          		DW	0B603H
042610 76          7170          		DB	76H
042611 C8 9C       7171          		DW	9CC8H           ;b(4)
042613 AA 2A       7172          		DW	2AAAH
042615 7B          7173          		DB	7BH
042616 DD FF       7174          		DW	0FFDDH          ;b(2)
042618 FF FF       7175          		DW	0FFFFH
04261A 7E          7176          		DB	7EH
04261B 00 00       7177          		DW	0               ;b(0)
04261D 00 00       7178          		DW	0
04261F 80          7179          		DB	80H
042620 CD BC 2C 04 7180          		CALL    POP5
042624 F1          7181  SIN3:			POP     AF
042625 E6 04       7182          		AND     4
042627 C8          7183          		RET     Z
042628 0D          7184          		DEC     C
042629 0C          7185          		INC     C
04262A C8          7186          		RET     Z               ;ZERO
04262B CB FC       7187          		SET     7,H             ;MAKE NEGATIVE
04262D C9          7188          		RET
04262E             7189  ;
04262E             7190  ;Floating-point one:
04262E             7191  ;
04262E 21 00 00 00 7192  FONE_FP:			LD      HL,0
042632 D9          7193          		EXX
042633 21 00 00 00 7194          		LD      HL,0
042637 D9          7195          		EXX
042638 0E 80       7196          		LD      C,80H
04263A C9          7197          		RET
04263B             7198  ;
04263B 11 00 00 00 7199  DONE:			LD      DE,0
04263F D9          7200          		EXX
042640 11 00 00 00 7201          		LD      DE,0
042644 D9          7202          		EXX
042645 06 80       7203          		LD      B,80H
042647 C9          7204          		RET
042648             7205  ;
042648 11 0F 49 00 7206  PIBY4:			LD      DE,490FH
04264C D9          7207          		EXX
04264D 11 A2 DA 00 7208          		LD      DE,0DAA2H
042651 D9          7209          		EXX
042652 06 7F       7210          		LD      B,7FH
042654 C9          7211          		RET
042655             7212  ;
042655             7213  ;EXP - Exponential function
042655             7214  ;Result is floating-point numeric.
042655             7215  ;
042655 CD A6 2B 04 7216  EXP_FP:			CALL    SFLOAT_FP
042659 CD E6 26 04 7217  EXP0:			CALL    LN2             ;LN(2)
04265D D9          7218          		EXX
04265E 1D          7219  	        	DEC     E
04265F 01 CF D1 00 7220  		        LD      BC,0D1CFH       ;0.6931471805599453
042663 D9          7221          		EXX
042664 E5          7222          		PUSH    HL              ;H7=SIGN
042665 CD 15 2B 04 7223          		CALL    MOD48           ;"MODULUS"
042669 F1          7224          		POP     AF
04266A CB 7B       7225          		BIT     7,E
04266C 28 0B       7226          		JR      Z,EXP1
04266E 17          7227          		RLA
04266F DA 23 2C 04 7228          		JP      C,ZERO_FP
042673 3E 18       7229          		LD      A,EXPRNG
042675 C3 7D 20 04 7230          		JP      ERROR_FP_           ;"Exp range"
042679             7231  ;
042679 E6 80       7232  EXP1:			AND     80H
04267B B3          7233          		OR      E
04267C F5          7234          		PUSH    AF              ;INTEGER PART
04267D CB BC       7235          		RES     7,H
04267F CD B3 2C 04 7236          		CALL    PUSH5           ;PUSH X*LN(2)
042683 CD F0 2C 04 7237          		CALL    POLY
042687 72 40       7238          		DW	4072H           ;a(7)
042689 2E 94       7239          		DW	942EH
04268B 73          7240          		DB	73H
04268C 65 6F       7241          		DW	6F65H           ;a(6)
04268E 4F 2E       7242          		DW	2E4FH
042690 76          7243          		DB	76H
042691 37 6D       7244          		DW	6D37H           ;a(5)
042693 02 88       7245          		DW	8802H
042695 79          7246          		DB	79H
042696 12 E5       7247          		DW	0E512H          ;a(4)
042698 A0 2A       7248          		DW	2AA0H
04269A 7B          7249          		DB	7BH
04269B 14 4F       7250          		DW	4F14H           ;a(3)
04269D AA AA       7251          		DW	0AAAAH
04269F 7D          7252          		DB	7DH
0426A0 56 FD       7253          		DW	0FD56H          ;a(2)
0426A2 FF 7F       7254          		DW	7FFFH
0426A4 7E          7255          		DB	7EH
0426A5 FE FF       7256          		DW	0FFFEH          ;a(1)
0426A7 FF FF       7257          		DW	0FFFFH
0426A9 7F          7258          		DB	7FH
0426AA 00 00       7259          		DW	0               ;a(0)
0426AC 00 00       7260          		DW	0
0426AE 80          7261          		DB	80H
0426AF CD BC 2C 04 7262          		CALL    POP5
0426B3 F1          7263          		POP     AF
0426B4 F5          7264          		PUSH    AF
0426B5 F4 DA 26 04 7265          		CALL    P,RECIP         ;X=1/X
0426B9 F1          7266          		POP     AF
0426BA F2 C2 26 04 7267          		JP      P,EXP4
0426BE E6 7F       7268          		AND     7FH
0426C0 ED 44       7269          		NEG
0426C2 C6 80       7270  EXP4:			ADD     A,80H
0426C4 81          7271          		ADD     A,C
0426C5 38 06       7272          		JR      C,EXP2
0426C7 F2 23 2C 04 7273          		JP      P,ZERO_FP          ;UNDERFLOW
0426CB 18 04       7274          		JR      EXP3
0426CD FA EE 2B 04 7275  EXP2:			JP      M,OFLOW         ;OVERFLOW
0426D1 C6 80       7276  EXP3:			ADD     A,80H
0426D3 CA 23 2C 04 7277          		JP      Z,ZERO_FP
0426D7 4F          7278          		LD      C,A
0426D8 AF          7279          		XOR     A               ;NUMERIC MARKER
0426D9 C9          7280          		RET
0426DA             7281  ;
0426DA CD 3B 26 04 7282  RECIP:			CALL    DONE
0426DE CD D7 2B 04 7283  RDIV:			CALL    SWAP_FP
0426E2 C3 65 22 04 7284          		JP      FDIV            ;RECIPROCAL
0426E6             7285  ;
0426E6 11 72 31 00 7286  LN2:			LD      DE,3172H        ;LN(2)
0426EA D9          7287          		EXX
0426EB 11 F8 17 00 7288          		LD      DE,17F8H
0426EF D9          7289          		EXX
0426F0 06 7F       7290          		LD      B,7FH
0426F2 C9          7291          		RET
0426F3             7292  ;
0426F3             7293  ;LN - Natural log.
0426F3             7294  ;Result is floating-point numeric.
0426F3             7295  ;
0426F3 CD A6 2B 04 7296  LN_FP:			CALL    SFLOAT_FP
0426F7 3E 16       7297  LN0:			LD      A,LOGRNG
0426F9 CB 7C       7298          		BIT     7,H
0426FB C2 7D 20 04 7299          		JP      NZ,ERROR_FP_        ;"Log range"
0426FF 0C          7300          		INC     C
042700 0D          7301          		DEC     C
042701 CA 7D 20 04 7302          		JP      Z,ERROR_FP_
042705 11 04 35 00 7303          		LD      DE,3504H        ;SQR(2)
042709 D9          7304          		EXX
04270A 11 33 F3 00 7305          		LD      DE,0F333H       ;1.41421356237
04270E D9          7306          		EXX
04270F CD 36 2C 04 7307          		CALL    ICP0            ;MANTISSA>SQR(2)?
042713 79          7308          		LD      A,C             ;EXPONENT
042714 0E 80       7309          		LD      C,80H           ;1 <= X < 2
042716 38 02       7310          		JR      C,LN4
042718 0D          7311          		DEC     C
042719 3C          7312          		INC     A
04271A F5          7313  LN4:			PUSH    AF              ;SAVE EXPONENT
04271B CD C8 2C 04 7314          		CALL    RATIO           ;X=(X-1)/(X+1)
04271F CD B3 2C 04 7315          		CALL    PUSH5
042723 CD AB 2C 04 7316  		        CALL    SQUARE          ;PUSH X*X
042727 CD F0 2C 04 7317          		CALL    POLY
04272B 48 CC       7318          		DW	0CC48H          ;a(9)
04272D FB 74       7319          		DW	74FBH
04272F 7D          7320          		DB	7DH
042730 AF AE       7321          		DW	0AEAFH          ;a(7)
042732 FF 11       7322          		DW	11FFH
042734 7E          7323          		DB	7EH
042735 8C D9       7324          		DW	0D98CH          ;a(5)
042737 CD 4C       7325          		DW	4CCDH
042739 7E          7326          		DB	7EH
04273A E3 A9       7327          		DW	0A9E3H          ;a(3)
04273C AA 2A       7328          		DW	2AAAH
04273E 7F          7329          		DB	7FH
04273F 00 00       7330          		DW	0               ;a(1)
042741 00 00       7331          		DW	0
042743 81          7332          		DB	81H
042744 CD BC 2C 04 7333          		CALL    POP5
042748 CD BC 2C 04 7334          		CALL    POP5
04274C CD 0E 23 04 7335          		CALL    FMUL
042750 F1          7336          		POP     AF              ;EXPONENT
042751 CD B3 2C 04 7337          		CALL    PUSH5
042755 08          7338          		EX      AF,AF'
042756 CD 23 2C 04 7339          		CALL    ZERO_FP
04275A 08          7340          		EX      AF,AF'
04275B D6 80       7341          		SUB     80H
04275D 28 1F       7342          		JR      Z,LN3
04275F 30 02       7343          		JR      NC,LN1
042761 2F          7344          		CPL
042762 3C          7345          		INC     A
042763 67          7346  LN1:			LD      H,A
042764 0E 87       7347          		LD      C,87H
042766 F5          7348          		PUSH    AF
042767 CD 86 2B 04 7349          		CALL    FLOAT_
04276B CB BC       7350          		RES     7,H
04276D CD E6 26 04 7351          		CALL    LN2
042771 CD 0E 23 04 7352          		CALL    FMUL
042775 F1          7353          		POP     AF
042776 30 06       7354          		JR      NC,LN3
042778 FA 7E 27 04 7355          		JP      M,LN3
04277C CB FC       7356          		SET     7,H
04277E CD BC 2C 04 7357  LN3:			CALL    POP5
042782 CD FC 21 04 7358          		CALL    FADD
042786 AF          7359          		XOR     A
042787 C9          7360          		RET
042788             7361  ;
042788             7362  ;LOG - base-10 logarithm.
042788             7363  ;Result is floating-point numeric.
042788             7364  ;
042788 CD F3 26 04 7365  LOG_FP:			CALL    LN_FP
04278C 11 5B 5E 00 7366          		LD      DE,5E5BH        ;LOG(e)
042790 D9          7367          		EXX
042791 11 A9 D8 00 7368          		LD      DE,0D8A9H
042795 D9          7369          		EXX
042796 06 7E       7370          		LD      B,7EH
042798 CD 0E 23 04 7371          		CALL    FMUL
04279C AF          7372          		XOR     A
04279D C9          7373          		RET
04279E             7374  ;
04279E             7375  ;ASN - Arc-sine
04279E             7376  ;Result is floating-point numeric.
04279E             7377  ;
04279E CD A6 2B 04 7378  ASN_FP:			CALL    SFLOAT_FP
0427A2 CD B3 2C 04 7379          		CALL    PUSH5
0427A6 CD A3 2C 04 7380          		CALL    COPY_
0427AA CD 0E 23 04 7381          		CALL    FMUL
0427AE CD 3B 26 04 7382          		CALL    DONE
0427B2 CD E9 21 04 7383          		CALL    RSUB
0427B6 CD 19 25 04 7384          		CALL    SQR0
0427BA CD BC 2C 04 7385          		CALL    POP5
0427BE 0C          7386          		INC     C
0427BF 0D          7387          		DEC     C
0427C0 3E 02       7388          		LD      A,2
0427C2 D5          7389          		PUSH    DE
0427C3 CA 48 28 04 7390          		JP      Z,ACS1
0427C7 D1          7391          		POP     DE
0427C8 CD DE 26 04 7392          		CALL    RDIV
0427CC 18 04       7393          		JR      ATN0
0427CE             7394  ;
0427CE             7395  ;ATN - arc-tangent
0427CE             7396  ;Result is floating-point numeric.
0427CE             7397  ;
0427CE CD A6 2B 04 7398  ATN_FP:			CALL    SFLOAT_FP
0427D2 E5          7399  ATN0:			PUSH    HL              ;SAVE SIGN
0427D3 CB BC       7400          		RES     7,H
0427D5 11 13 54 00 7401          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0427D9 D9          7402          		EXX
0427DA 11 D0 CC 00 7403          		LD      DE,0CCD0H
0427DE D9          7404          		EXX
0427DF 06 7E       7405          		LD      B,7EH
0427E1 CD 33 2C 04 7406          		CALL    FCP0            ;COMPARE
0427E5 06 00       7407          		LD      B,0
0427E7 38 22       7408          		JR      C,ATN2
0427E9 11 82 1A 00 7409          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0427ED D9          7410          		EXX
0427EE 11 9A 79 00 7411          		LD      DE,799AH
0427F2 D9          7412          		EXX
0427F3 06 81       7413          		LD      B,81H
0427F5 CD 33 2C 04 7414          		CALL    FCP0            ;COMPARE
0427F9 38 0A       7415          		JR      C,ATN1
0427FB CD DA 26 04 7416          		CALL    RECIP           ;X=1/X
0427FF 06 02       7417          		LD      B,2
042801 C3 0B 28 04 7418          		JP      ATN2
042805 CD C8 2C 04 7419  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042809 06 01       7420          		LD      B,1
04280B C5          7421  ATN2:			PUSH    BC              ;SAVE FLAG
04280C CD B3 2C 04 7422          		CALL    PUSH5
042810 CD AB 2C 04 7423          		CALL    SQUARE          ;PUSH X*X
042814 CD F0 2C 04 7424          		CALL    POLY
042818 35 F3       7425          		DW	0F335H          ;a(13)
04281A D8 37       7426          		DW	37D8H
04281C 7B          7427          		DB	7BH
04281D 91 6B       7428          		DW	6B91H           ;a(11)
04281F B9 AA       7429          		DW	0AAB9H
042821 7C          7430          		DB	7CH
042822 DE 41       7431          		DW	41DEH           ;a(9)
042824 97 61       7432          		DW	6197H
042826 7C          7433          		DB	7CH
042827 7B 9D       7434          		DW	9D7BH           ;a(7)
042829 37 92       7435          		DW	9237H
04282B 7D          7436          		DB	7DH
04282C 5A 2A       7437          		DW	2A5AH           ;a(5)
04282E CC 4C       7438          		DW	4CCCH
042830 7D          7439          		DB	7DH
042831 5C A9       7440          		DW	0A95CH          ;a(3)
042833 AA AA       7441          		DW	0AAAAH
042835 7E          7442          		DB	7EH
042836 00 00       7443          		DW	0               ;a(1)
042838 00 00       7444          		DW	0
04283A 80          7445          		DB	80H
04283B CD BC 2C 04 7446          		CALL    POP5
04283F CD BC 2C 04 7447          		CALL    POP5
042843 CD 0E 23 04 7448          		CALL    FMUL
042847 F1          7449          		POP     AF
042848 CD 48 26 04 7450  ACS1:			CALL    PIBY4           ;PI/4
04284C 1F          7451          		RRA
04284D F5          7452          		PUSH    AF
04284E DC FC 21 04 7453          		CALL    C,FADD
042852 F1          7454          		POP     AF
042853 04          7455          		INC     B
042854 1F          7456          		RRA
042855 DC E9 21 04 7457          		CALL    C,RSUB
042859 F1          7458          		POP     AF
04285A B7          7459          		OR      A
04285B F0          7460          		RET     P
04285C CB FC       7461          		SET     7,H             ;MAKE NEGATIVE
04285E AF          7462          		XOR     A
04285F C9          7463          		RET
042860             7464  ;
042860             7465  ;ACS - Arc cosine=PI/2-ASN.
042860             7466  ;Result is floating point numeric.
042860             7467  ;
042860 CD 9E 27 04 7468  ACS_FP:			CALL    ASN_FP
042864 3E 02       7469          		LD      A,2
042866 F5          7470          		PUSH    AF
042867 18 DF       7471          		JR      ACS1
042869             7472  ;
042869             7473  ;Function STR - convert numeric value to ASCII string.
042869             7474  ;   Inputs: HLH'L'C = integer or floating-point number
042869             7475  ;           DE = address at which to store string
042869             7476  ;           IX = address of @% format control
042869             7477  ;  Outputs: String stored, with NUL terminator
042869             7478  ;
042869             7479  ;First normalise for decimal output:
042869             7480  ;
042869 CD A6 2B 04 7481  STR_FP:			CALL    SFLOAT_FP
04286D 06 00       7482          		LD      B,0             ;DEFAULT PT. POSITION
04286F CB 7C       7483          		BIT     7,H             ;NEGATIVE?
042871 28 06       7484          		JR      Z,STR10
042873 CB BC       7485          		RES     7,H
042875 3E 2D       7486          		LD      A,'-'
042877 12          7487          		LD      (DE),A          ;STORE SIGN
042878 13          7488          		INC     DE
042879 AF          7489  STR10:			XOR     A               ;CLEAR A
04287A B9          7490          		CP      C
04287B 28 4E       7491          		JR      Z,STR02          ;ZERO
04287D D5          7492          		PUSH    DE              ;SAVE TEXT POINTER
04287E 78          7493          		LD      A,B
04287F F5          7494  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
042880 79          7495          		LD      A,C             ;BINARY EXPONENT
042881 FE A1       7496          		CP      161
042883 30 1C       7497          		JR      NC,STR14
042885 FE 9B       7498          		CP      155
042887 30 29       7499          		JR      NC,STR15
042889 2F          7500          		CPL
04288A FE E1       7501          		CP      225
04288C 38 02       7502          		JR      C,STR13
04288E 3E F8       7503          		LD      A,-8
042890 C6 1C       7504  STR13:			ADD     A,28
042892 CD 1F 2D 04 7505          		CALL    POWR10
042896 F5          7506          		PUSH    AF
042897 CD 0E 23 04 7507          		CALL    FMUL
04289B F1          7508          		POP     AF
04289C 47          7509          		LD      B,A
04289D F1          7510          		POP     AF
04289E 90          7511          		SUB     B
04289F 18 DE       7512          		JR      STR11
0428A1 D6 20       7513  STR14:			SUB     32
0428A3 CD 1F 2D 04 7514          		CALL    POWR10
0428A7 F5          7515          		PUSH    AF
0428A8 CD 65 22 04 7516          		CALL    FDIV
0428AC F1          7517          		POP     AF
0428AD 47          7518          		LD      B,A
0428AE F1          7519          		POP     AF
0428AF 80          7520          		ADD     A,B
0428B0 18 CD       7521          		JR      STR11
0428B2 3E 09       7522  STR15:			LD      A,9
0428B4 CD 1F 2D 04 7523          		CALL    POWR10          ;10^9
0428B8 CD 33 2C 04 7524          		CALL    FCP0
0428BC 79          7525          		LD      A,C
0428BD C1          7526          		POP     BC
0428BE 4F          7527          		LD      C,A
0428BF CB FC       7528          		SET     7,H             ;IMPLIED 1
0428C1 DC 5B 2C 04 7529          		CALL    C,X10B          ;X10, DEC B
0428C5 D1          7530          		POP     DE              ;RESTORE TEXT POINTER
0428C6 CB B9       7531          		RES     7,C
0428C8 3E 00       7532          		LD      A,0
0428CA 17          7533          		RLA                     ;PUT CARRY IN LSB
0428CB             7534  ;
0428CB             7535  ;At this point decimal normalisation has been done,
0428CB             7536  ;now convert to decimal digits:
0428CB             7537  ;      AHLH'L' = number in normalised integer form
0428CB             7538  ;            B = decimal place adjustment
0428CB             7539  ;            C = binary place adjustment (29-33)
0428CB             7540  ;
0428CB 0C          7541  STR02:			INC     C
0428CC 08          7542          		EX      AF,AF'          ;SAVE A
0428CD 78          7543          		LD      A,B
0428CE DD CB 02 4E 7544          		BIT     1,(IX+2)
0428D2 20 08       7545          		JR      NZ,STR20
0428D4 AF          7546          		XOR     A
0428D5 DD BE 01    7547          		CP      (IX+1)
0428D8 28 0B       7548          		JR      Z,STR21
0428DA 3E F6       7549          		LD      A,-10
0428DC DD 86 01    7550  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0428DF B7          7551          		OR      A               ;CLEAR CARRY
0428E0 FA E5 28 04 7552          		JP      M,STR21
0428E4 AF          7553          		XOR     A
0428E5 F5          7554  STR21:			PUSH    AF
0428E6 08          7555          		EX      AF,AF'          ;RESTORE A
0428E7 CD 8F 2C 04 7556  STR22:			CALL    X2              ;RL AHLH'L'
0428EB 8F          7557          		ADC     A,A
0428EC FE 0A       7558          		CP      10
0428EE 38 05       7559          		JR      C,STR23
0428F0 D6 0A       7560          		SUB     10
0428F2 D9          7561          		EXX
0428F3 2C          7562          		INC     L               ;SET RESULT BIT
0428F4 D9          7563          		EXX
0428F5 0D          7564  STR23:			DEC     C
0428F6 20 EF       7565          		JR      NZ,STR22        ;32 TIMES
0428F8 4F          7566          		LD      C,A             ;REMAINDER
0428F9 7C          7567          		LD      A,H
0428FA E6 3F       7568          		AND     3FH             ;CLEAR OUT JUNK
0428FC 67          7569          		LD      H,A
0428FD F1          7570          		POP     AF
0428FE F2 0C 29 04 7571          		JP      P,STR24
042902 3C          7572          		INC     A
042903 20 1C       7573          		JR      NZ,STR26
042905 3E 04       7574          		LD      A,4
042907 B9          7575          		CP      C               ;ROUND UP?
042908 3E 00       7576          		LD      A,0
04290A 18 15       7577          		JR      STR26
04290C F5          7578  STR24:			PUSH    AF
04290D 79          7579          		LD      A,C
04290E CE 30       7580          		ADC     A,'0'           ;ADD CARRY
042910 FE 30       7581          		CP      '0'
042912 28 05       7582          		JR      Z,STR25         ;SUPPRESS ZERO
042914 FE 3A       7583          		CP      '9'+1
042916 3F          7584          		CCF
042917 30 08       7585          		JR      NC,STR26
042919 E3          7586  STR25:			EX      (SP),HL
04291A CB 75       7587          		BIT     6,L             ;ZERO FLAG
04291C E3          7588  		        EX      (SP),HL
04291D 20 05       7589          		JR      NZ,STR27
04291F 3E 30       7590          		LD      A,'0'
042921 3C          7591  STR26:			INC     A               ;SET +VE
042922 3D          7592          		DEC     A
042923 F5          7593          		PUSH    AF              ;PUT ON STACK + CARRY
042924 04          7594  STR27:			INC     B
042925 CD FF 2B 04 7595          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042929 0E 20       7596          		LD      C,32
04292B 3E 00       7597          		LD      A,0
04292D 20 B8       7598          		JR      NZ,STR22
04292F F1          7599          		POP     AF
042930 F5          7600          		PUSH    AF
042931 3E 00       7601          		LD      A,0
042933 38 B2       7602          		JR      C,STR22
042935             7603  ;
042935             7604  ;At this point, the decimal character string is stored
042935             7605  ; on the stack. Trailing zeroes are suppressed and may
042935             7606  ; need to be replaced.
042935             7607  ;B register holds decimal point position.
042935             7608  ;Now format number and store as ASCII string:
042935             7609  ;
042935 EB          7610  STR3:			EX      DE,HL           ;STRING POINTER
042936 0E FF       7611          		LD      C,-1            ;FLAG "E"
042938 16 01       7612          		LD      D,1
04293A DD 5E 01    7613          		LD      E,(IX+1)        ;f2
04293D DD CB 02 46 7614          		BIT     0,(IX+2)
042941 20 35       7615          		JR      NZ,STR34        ;E MODE
042943 DD CB 02 4E 7616          		BIT     1,(IX+2)
042947 28 12       7617          		JR      Z,STR31
042949 78          7618          		LD      A,B             ;F MODE
04294A B7          7619          		OR      A
04294B 28 05       7620          		JR      Z,STR30
04294D FA 52 29 04 7621          		JP      M,STR30
042951 50          7622          		LD      D,B
042952 7A          7623  STR30:			LD      A,D
042953 DD 86 01    7624          		ADD     A,(IX+1)
042956 5F          7625          		LD      E,A
042957 FE 0B       7626          		CP      11
042959 38 19       7627          		JR      C,STR32
04295B 78          7628  STR31:			LD      A,B             ;G MODE
04295C 11 01 01 00 7629          		LD      DE,101H
042960 B7          7630          		OR      A
042961 FA 78 29 04 7631          		JP      M,STR34
042965 28 0D       7632          		JR      Z,STR32
042967 DD 7E 01    7633          		LD      A,(IX+1)
04296A B7          7634          		OR      A
04296B 20 02       7635          		JR      NZ,STR3A
04296D 3E 0A       7636          		LD      A,10
04296F B8          7637  STR3A:			CP      B
042970 38 06       7638          		JR      C,STR34
042972 50          7639          		LD      D,B
042973 58          7640          		LD      E,B
042974 78          7641  STR32:			LD      A,B
042975 C6 81       7642          		ADD     A,129
042977 4F          7643          		LD      C,A
042978 CB FA       7644  STR34:			SET     7,D
04297A 1D          7645          		DEC     E
04297B 7A          7646  STR35:			LD      A,D
04297C B9          7647          		CP      C
04297D 30 0E       7648          		JR      NC,STR33
04297F F1          7649  STR36:			POP     AF
042980 28 04       7650          		JR      Z,STR37
042982 F2 8F 29 04 7651          		JP      P,STR38
042986 F5          7652  STR37:			PUSH    AF
042987 1C          7653          		INC     E
042988 1D          7654          		DEC     E
042989 FA A0 29 04 7655          		JP      M,STR4
04298D 3E 30       7656  STR33:			LD      A,'0'
04298F 15          7657  STR38:			DEC     D
042990 E2 97 29 04 7658          		JP      PO,STR39
042994 36 2E       7659          		LD      (HL),'.'
042996 23          7660          		INC     HL
042997 77          7661  STR39:			LD      (HL),A
042998 23          7662          		INC     HL
042999 1D          7663          		DEC     E
04299A F2 7B 29 04 7664          		JP      P,STR35
04299E 18 DF       7665          		JR      STR36
0429A0             7666  ;
0429A0 F1          7667  STR4:			POP     AF
0429A1 0C          7668  STR40:			INC     C
0429A2 4D          7669          		LD      C,L
0429A3 20 28       7670          		JR      NZ,STR44
0429A5 36 45       7671          		LD      (HL),'E'        ;EXPONENT
0429A7 23          7672          		INC     HL
0429A8 78          7673          		LD      A,B
0429A9 3D          7674          		DEC     A
0429AA F2 B3 29 04 7675          		JP      P,STR41
0429AE 36 2D       7676          		LD      (HL),'-'
0429B0 23          7677          		INC     HL
0429B1 ED 44       7678          		NEG
0429B3 36 30       7679  STR41:			LD      (HL),'0'
0429B5 28 15       7680          		JR      Z,STR47
0429B7 FE 0A       7681          		CP      10
0429B9 47          7682          		LD      B,A
0429BA 3E 3A       7683          		LD      A,':'
0429BC 38 03       7684          		JR      C,STR42
0429BE 23          7685          		INC     HL
0429BF 36 30       7686          		LD      (HL),'0'
0429C1 34          7687  STR42:			INC     (HL)
0429C2 BE          7688          		CP      (HL)
0429C3 20 05       7689          		JR      NZ,STR43
0429C5 36 30       7690          		LD      (HL),'0'
0429C7 2B          7691          		DEC     HL
0429C8 34          7692          		INC     (HL)
0429C9 23          7693          		INC     HL
0429CA 10 F5       7694  STR43:			DJNZ    STR42
0429CC 23          7695  STR47:			INC     HL
0429CD EB          7696  STR44:			EX      DE,HL
0429CE C9          7697        			RET
0429CF             7698  ;
0429CF             7699  ;Support subroutines:
0429CF             7700  ;
0429CF DD 46 04    7701  DLOAD5:			LD      B,(IX+4)
0429D2 D9          7702          		EXX
0429D3 DD 5E 00    7703          		LD      E,(IX+0)
0429D6 DD 56 01    7704          		LD      D,(IX+1)
0429D9 D9          7705          		EXX
0429DA DD 5E 02    7706          		LD      E,(IX+2)
0429DD DD 56 03    7707          		LD      D,(IX+3)
0429E0 C9          7708          		RET
0429E1             7709  ;
0429E1 DD 46 06    7710  DLOAD5_SPL:		LD      B,(IX+6)
0429E4 D9          7711  			EXX
0429E5 DD 17 00    7712  			LD	DE, (IX+0)
0429E8 D9          7713  			EXX
0429E9 DD 17 03    7714  			LD	DE, (IX+3)
0429EC C9          7715  			RET
0429ED             7716  ;
0429ED             7717  ;CON_FP - Get unsigned numeric constant from ASCII string.
0429ED             7718  ;   Inputs: ASCII string at (IX).
0429ED             7719  ;  Outputs: Variable-type result in HLH'L'C
0429ED             7720  ;           IX updated (points to delimiter)
0429ED             7721  ;           A7 = 0 (numeric marker)
0429ED             7722  ;
0429ED CD 23 2C 04 7723  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0429F1 0E 00       7724          		LD      C,0             ;TRUNCATION COUNTER
0429F3 CD 81 2A 04 7725          		CALL    UINT          ;GET INTEGER PART
0429F7 FE 2E       7726          		CP      '.'
0429F9 06 00       7727          		LD      B,0             ;DECL. PLACE COUNTER
0429FB CC 7F 2A 04 7728          		CALL    Z,NUMBIX        ;GET FRACTION PART
0429FF FE 45       7729          		CP      'E'
042A01 3E 00       7730          		LD      A,0             ;INITIALISE EXPONENT
042A03 CC 4D 2A 04 7731          		CALL    Z,GETEXP        ;GET EXPONENT
042A07 CB 7C       7732          		BIT     7,H
042A09 20 08       7733          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A0B B7          7734          		OR      A
042A0C 20 05       7735          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A0E B8          7736          		CP      B
042A0F 20 02       7737          		JR      NZ,CON0         ;DECIMAL POINT
042A11 B9          7738          		CP      C
042A12 C8          7739          		RET     Z               ;INTEGER
042A13 90          7740  CON0:			SUB     B
042A14 81          7741          		ADD     A,C
042A15 0E 9F       7742          		LD      C,159
042A17 CD 86 2B 04 7743          		CALL    FLOAT_
042A1B CB BC       7744          		RES     7,H             ;DITCH IMPLIED 1
042A1D B7          7745          		OR      A
042A1E C8          7746          		RET     Z               ;DONE
042A1F FA 2D 2A 04 7747          		JP      M,CON2          ;NEGATIVE EXPONENT
042A23 CD 1F 2D 04 7748          		CALL    POWR10
042A27 CD 0E 23 04 7749          		CALL    FMUL            ;SCALE
042A2B AF          7750          		XOR     A
042A2C C9          7751          		RET
042A2D FE DA       7752  CON2:			CP      -38
042A2F 38 0C       7753          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A31 ED 44       7754          		NEG
042A33 CD 1F 2D 04 7755          		CALL    POWR10
042A37 CD 65 22 04 7756          		CALL    FDIV            ;SCALE
042A3B AF          7757          		XOR     A
042A3C C9          7758          		RET
042A3D F5          7759  CON3:			PUSH    AF
042A3E 3E 26       7760          		LD      A,38
042A40 CD 1F 2D 04 7761          		CALL    POWR10
042A44 CD 65 22 04 7762          		CALL    FDIV
042A48 F1          7763          		POP     AF
042A49 C6 26       7764          		ADD     A,38
042A4B 18 E0       7765          		JR      CON2
042A4D             7766  ;
042A4D             7767  ;GETEXP - Get decimal exponent from string
042A4D             7768  ;     Inputs: ASCII string at (IX)
042A4D             7769  ;             (IX points at 'E')
042A4D             7770  ;             A = initial value
042A4D             7771  ;    Outputs: A = new exponent
042A4D             7772  ;             IX updated.
042A4D             7773  ;   Destroys: A,A',IX,F,F'
042A4D             7774  ;
042A4D C5          7775  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A4E 47          7776          		LD      B,A             ;INITIAL VALUE
042A4F 0E 02       7777          		LD      C,2             ;2 DIGITS MAX
042A51 DD 23       7778          		INC     IX              ;BUMP PAST 'E'
042A53 CD 3D 2E 04 7779          		CALL    SIGNQ
042A57 08          7780          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A58 CD 33 2E 04 7781  GETEX1:			CALL    DIGITQ
042A5C 38 18       7782          		JR      C,GETEX2
042A5E 78          7783          		LD      A,B             ;B=B*10
042A5F 87          7784          		ADD     A,A
042A60 87          7785          		ADD     A,A
042A61 80          7786          		ADD     A,B
042A62 87          7787          		ADD     A,A
042A63 47          7788          		LD      B,A
042A64 DD 7E 00    7789          		LD      A,(IX)          ;GET BACK DIGIT
042A67 DD 23       7790          		INC     IX
042A69 E6 0F       7791          		AND     0FH             ;MASK UNWANTED BITS
042A6B 80          7792          		ADD     A,B             ;ADD IN DIGIT
042A6C 47          7793          		LD      B,A
042A6D 0D          7794          		DEC     C
042A6E F2 58 2A 04 7795          		JP      P,GETEX1
042A72 06 64       7796          		LD      B,100           ;FORCE OVERFLOW
042A74 18 E2       7797          		JR      GETEX1
042A76 08          7798  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042A77 FE 2D       7799          		CP      '-'
042A79 78          7800          		LD      A,B
042A7A C1          7801          		POP     BC              ;RESTORE
042A7B C0          7802          		RET     NZ
042A7C ED 44       7803          		NEG                     ;NEGATE EXPONENT
042A7E C9          7804          		RET
042A7F             7805  ;
042A7F             7806  ;UINT: Get unsigned integer from string.
042A7F             7807  ;    Inputs: string at (IX)
042A7F             7808  ;            C = truncated digit count
042A7F             7809  ;                (initially zero)
042A7F             7810  ;            B = total digit count
042A7F             7811  ;            HLH'L' = initial value
042A7F             7812  ;   Outputs: HLH'L' = number (binary integer)
042A7F             7813  ;            A = delimiter.
042A7F             7814  ;            B, C & IX updated
042A7F             7815  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042A7F             7816  ;
042A7F DD 23       7817  NUMBIX:			INC     IX
042A81 CD 33 2E 04 7818  UINT:			CALL    DIGITQ
042A85 D8          7819          		RET     C
042A86 04          7820          		INC     B               ;INCREMENT DIGIT COUNT
042A87 DD 23       7821          		INC     IX
042A89 CD 7C 2C 04 7822          		CALL    X10             ;*10 & COPY OLD VALUE
042A8D 38 15       7823          		JR      C,NUMB1         ;OVERFLOW
042A8F 0D          7824          		DEC     C               ;SEE IF TRUNCATED
042A90 0C          7825          		INC     C
042A91 20 11       7826          		JR      NZ,NUMB1        ;IMPORTANT!
042A93 E6 0F       7827          		AND     0FH
042A95 D9          7828          		EXX
042A96 06 00       7829          		LD      B,0
042A98 4F          7830          		LD      C,A
042A99 52 09       7831          		ADD.S   HL,BC           ;ADD IN DIGIT
042A9B D9          7832          		EXX
042A9C 30 E3       7833          		JR      NC,UINT
042A9E 52 23       7834          		INC.S   HL              ;CARRY
042AA0 7C          7835          		LD      A,H
042AA1 B5          7836          		OR      L
042AA2 20 DD       7837          		JR      NZ,UINT
042AA4 0C          7838  NUMB1:			INC     C               ;TRUNCATION COUNTER
042AA5 CD DA 2B 04 7839          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AA9 18 D6       7840          		JR      UINT
042AAB             7841  ;
042AAB             7842  ;FIX - Fix number to specified exponent value.
042AAB             7843  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AAB             7844  ;            A = desired exponent (A>C)
042AAB             7845  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AAB             7846  ;            fraction shifted into B'C'
042AAB             7847  ;            A'F' positive if integer input
042AAB             7848  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AAB             7849  ;
042AAB 08          7850  FIX:			EX      AF,AF'
042AAC AF          7851          		XOR     A
042AAD 08          7852          		EX      AF,AF'
042AAE CB FC       7853          		SET     7,H             ;IMPLIED 1
042AB0 CD DF 2B 04 7854  FIX1:			CALL    DIV2
042AB4 B9          7855          		CP      C
042AB5 C8          7856          		RET     Z
042AB6 D2 B0 2A 04 7857          		JP      NC,FIX1
042ABA C3 EE 2B 04 7858          		JP      OFLOW
042ABE             7859  ;
042ABE             7860  ;SFIX - Convert to integer if necessary.
042ABE             7861  ;    Input: Variable-type number in HLH'L'C
042ABE             7862  ;   Output: Integer in HLH'L', C=0
042ABE             7863  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042ABE             7864  ;
042ABE             7865  ;NEGATE - Negate HLH'L'
042ABE             7866  ;    Destroys: H,L,H',L',F
042ABE             7867  ;
042ABE CD D7 2B 04 7868  FIX2:			CALL    SWAP_FP
042AC2 CD CA 2A 04 7869          		CALL    SFIX_FP
042AC6 CD D7 2B 04 7870          		CALL    SWAP_FP
042ACA 0D          7871  SFIX_FP:			DEC     C
042ACB 0C          7872          		INC     C
042ACC C8          7873          		RET     Z               ;INTEGER/ZERO
042ACD CB 7C       7874          		BIT     7,H             ;SIGN
042ACF F5          7875          		PUSH    AF
042AD0 3E 9F       7876          		LD      A,159
042AD2 CD AB 2A 04 7877          		CALL    FIX
042AD6 F1          7878          		POP     AF
042AD7 0E 00       7879          		LD      C,0
042AD9 C8          7880          		RET     Z
042ADA B7          7881  NEGATE:			OR      A               ;CLEAR CARRY
042ADB D9          7882          		EXX
042ADC D5          7883  NEG0:			PUSH    DE
042ADD EB          7884          		EX      DE,HL
042ADE 21 00 00 00 7885          		LD      HL,0
042AE2 52 ED 52    7886          		SBC.S   HL,DE
042AE5 D1          7887          		POP     DE
042AE6 D9          7888          		EXX
042AE7 D5          7889          		PUSH    DE
042AE8 EB          7890          		EX      DE,HL
042AE9 21 00 00 00 7891          		LD      HL,0
042AED 52 ED 52    7892          		SBC.S   HL,DE
042AF0 D1          7893          		POP     DE
042AF1 C9          7894          		RET
042AF2             7895  ;
042AF2             7896  ;NEG - Negate HLH'L'B'C'
042AF2             7897  ;    Also complements A (used in FADD)
042AF2             7898  ;    Destroys: A,H,L,B',C',H',L',F
042AF2             7899  ;
042AF2 D9          7900  NEG_:			EXX
042AF3 2F          7901          		CPL
042AF4 E5          7902          		PUSH    HL
042AF5 B7          7903          		OR      A               ;CLEAR CARRY
042AF6 21 00 00 00 7904          		LD      HL,0
042AFA 52 ED 42    7905          		SBC.S   HL,BC
042AFD 44          7906          		LD      B,H
042AFE 4D          7907          		LD      C,L
042AFF E1          7908          		POP     HL
042B00 18 DA       7909          		JR      NEG0
042B02             7910  ;
042B02             7911  ;SCALE - Trig scaling.
042B02             7912  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B02             7913  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B02             7914  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B02             7915  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B02             7916  ;           E = quotient (bit 7 is sticky)
042B02             7917  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B02             7918  ;FLO48 - Float unsigned number (48 bits)
042B02             7919  ;    Input/output in HLH'L'B'C'C
042B02             7920  ;   Destroys: C,H,L,B',C',H',L',F
042B02             7921  ;
042B02 3E 96       7922  SCALE:			LD      A,150
042B04 B9          7923          		CP      C
042B05 3E 17       7924          		LD      A,ACLOST
042B07 DA 7D 20 04 7925          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B0B CD 48 26 04 7926          		CALL    PIBY4
042B0F D9          7927          		EXX
042B10 01 69 21 00 7928          		LD      BC,2169H        ;3.141592653589793238
042B14 D9          7929          		EXX
042B15 CB FA       7930  MOD48:			SET     7,D             ;IMPLIED 1
042B17 CB FC       7931          		SET     7,H
042B19 79          7932          		LD      A,C
042B1A 0E 00       7933          		LD      C,0             ;INIT QUOTIENT
042B1C DD 21 00 00 7934          		LD      IX,0
       00          
042B21 DD E5       7935          		PUSH    IX              ;PUT ZERO ON STACK
042B23 B8          7936          		CP      B
042B24 38 46       7937          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B26 D9          7938  MOD481:			EXX                     ;CARRY=0 HERE
042B27 E3          7939          		EX      (SP),HL
042B28 52 ED 42    7940          		SBC.S   HL,BC
042B2B E3          7941          		EX      (SP),HL
042B2C 52 ED 52    7942          		SBC.S   HL,DE
042B2F D9          7943          		EXX
042B30 52 ED 52    7944          		SBC.S   HL,DE
042B33 30 0C       7945          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B35 D9          7946          		EXX
042B36 E3          7947          		EX      (SP),HL
042B37 52 09       7948          		ADD.S   HL,BC
042B39 E3          7949          		EX      (SP),HL
042B3A 52 ED 5A    7950          		ADC.S   HL,DE
042B3D D9          7951          		EXX
042B3E 52 ED 5A    7952          		ADC.S   HL,DE
042B41 3F          7953  MOD482:			CCF
042B42 CB 11       7954          		RL      C               ;QUOTIENT
042B44 30 02       7955          		JR      NC,MOD483
042B46 CB F9       7956          		SET     7,C             ;STICKY BIT
042B48 3D          7957  MOD483:			DEC     A
042B49 B8          7958          		CP      B
042B4A 38 1F       7959          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B4C E3          7960          		EX      (SP),HL
042B4D 52 29       7961          		ADD.S   HL,HL           ;DIVIDEND * 2
042B4F E3          7962          		EX      (SP),HL
042B50 D9          7963          		EXX
042B51 52 ED 6A    7964          		ADC.S   HL,HL
042B54 D9          7965          		EXX
042B55 52 ED 6A    7966          		ADC.S   HL,HL
042B58 30 CC       7967          		JR      NC,MOD481       ;AGAIN
042B5A B7          7968          		OR      A
042B5B D9          7969          		EXX
042B5C E3          7970          		EX      (SP),HL
042B5D 52 ED 42    7971          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B60 E3          7972          		EX      (SP),HL
042B61 52 ED 52    7973          		SBC.S   HL,DE
042B64 D9          7974          		EXX
042B65 52 ED 52    7975          		SBC.S   HL,DE
042B68 B7          7976          		OR      A
042B69 18 D6       7977          		JR      MOD482
042B6B             7978  ;
042B6B 3C          7979  MOD484:			INC     A
042B6C 59          7980  MOD485:			LD      E,C             ;QUOTIENT
042B6D 4F          7981          		LD      C,A             ;REMAINDER EXPONENT
042B6E D9          7982          		EXX
042B6F C1          7983          		POP     BC
042B70 D9          7984          		EXX
042B71 CB 7C       7985  FLO48:			BIT     7,H
042B73 C0          7986          		RET     NZ
042B74 D9          7987          		EXX
042B75 CB 21       7988          		SLA     C
042B77 CB 10       7989          		RL      B
042B79 52 ED 6A    7990          		ADC.S   HL,HL
042B7C D9          7991          		EXX
042B7D 52 ED 6A    7992          		ADC.S   HL,HL
042B80 0D          7993          		DEC     C
042B81 C2 71 2B 04 7994          		JP      NZ,FLO48
042B85 C9          7995          		RET
042B86             7996  ;
042B86             7997  ;Float unsigned number
042B86             7998  ;    Input/output in HLH'L'C
042B86             7999  ;   Destroys: C,H,L,H',L',F
042B86             8000  ;
042B86 CB 7C       8001  FLOAT_:			BIT     7,H
042B88 C0          8002          		RET     NZ
042B89 D9          8003          		EXX                     ;SAME AS "X2"
042B8A 52 29       8004          		ADD.S   HL,HL           ;TIME-CRITICAL
042B8C D9          8005          		EXX                     ;REGION
042B8D 52 ED 6A    8006          		ADC.S   HL,HL           ;(BENCHMARKS)
042B90 0D          8007          		DEC     C
042B91 C2 86 2B 04 8008          		JP      NZ,FLOAT_
042B95 C9          8009          		RET
042B96             8010  ;
042B96             8011  ;SFLOAT - Convert to floating-point if necessary.
042B96             8012  ;    Input: Variable-type number in HLH'L'C
042B96             8013  ;    Output: Floating-point in HLH'L'C
042B96             8014  ;    Destroys: A,C,H,L,H',L',F
042B96             8015  ;
042B96 08          8016  FLOATA:			EX      AF,AF'
042B97             8017          		; ADD     A,(RTABLE-DTABLE)/3
042B97 C6 2A       8018          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042B99 08          8019          		EX      AF,AF'
042B9A CD D7 2B 04 8020  FLOAT2:			CALL    SWAP_FP
042B9E CD A6 2B 04 8021          		CALL    SFLOAT_FP
042BA2 CD D7 2B 04 8022          		CALL    SWAP_FP
042BA6 0D          8023  SFLOAT_FP:			DEC     C
042BA7 0C          8024          		INC     C
042BA8 C0          8025          		RET     NZ              ;ALREADY FLOATING-POINT
042BA9 CD FF 2B 04 8026          		CALL    TEST_FP
042BAD C8          8027          		RET     Z               ;ZERO
042BAE 7C          8028          		LD      A,H
042BAF B7          8029          		OR      A
042BB0 FC DA 2A 04 8030          		CALL    M,NEGATE
042BB4 0E 9F       8031          		LD      C,159
042BB6 CD 86 2B 04 8032          		CALL    FLOAT_
042BBA B7          8033          		OR      A
042BBB F8          8034          		RET     M               ;NEGATIVE
042BBC CB BC       8035          		RES     7,H
042BBE C9          8036          		RET
042BBF             8037  ;
042BBF             8038  ;ROUND UP
042BBF             8039  ;Return with carry set if 32-bit overflow
042BBF             8040  ;   Destroys: H,L,B',C',H',L',F
042BBF             8041  ;
042BBF D9          8042  ADD1_FP:			EXX
042BC0 01 01 00 00 8043          		LD      BC,1
042BC4 52 09       8044          		ADD.S   HL,BC
042BC6 D9          8045          		EXX
042BC7 D0          8046          		RET     NC
042BC8 C5          8047          		PUSH    BC
042BC9 01 01 00 00 8048          		LD      BC,1
042BCD 52 09       8049          		ADD.S   HL,BC
042BCF C1          8050          		POP     BC
042BD0 C9          8051          		RET
042BD1             8052  ;
042BD1             8053  ;ODD - Add one if even, leave alone if odd.
042BD1             8054  ; (Used to perform unbiassed rounding, i.e.
042BD1             8055  ;  number is rounded up half the time)
042BD1             8056  ;    Destroys: L',F (carry cleared)
042BD1             8057  ;
042BD1 B7          8058  ODD:			OR      A               ;CLEAR CARRY
042BD2 D9          8059          		EXX
042BD3 CB C5       8060          		SET     0,L             ;MAKE ODD
042BD5 D9          8061          		EXX
042BD6 C9          8062          		RET
042BD7             8063  ;
042BD7             8064  ;SWAP_FP - Swap arguments.
042BD7             8065  ;    Exchanges DE,HL D'E',H'L' and B,C
042BD7             8066  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042BD7             8067  ;SWAP1 - Swap DEHL with D'E'H'L'
042BD7             8068  ;    Destroys: D,E,H,L,D',E',H',L'
042BD7             8069  ;
042BD7 79          8070  SWAP_FP:			LD      A,C
042BD8 48          8071          		LD      C,B
042BD9 47          8072          		LD      B,A
042BDA EB          8073  SWAP1:			EX      DE,HL
042BDB D9          8074          		EXX
042BDC EB          8075          		EX      DE,HL
042BDD D9          8076          		EXX
042BDE C9          8077          		RET
042BDF             8078  ;
042BDF             8079  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042BDF             8080  ; INCC - destroys C,F
042BDF             8081  ; OFLOW
042BDF             8082  ;
042BDF CD 98 2C 04 8083  DIV2:			CALL    D2
042BE3 D9          8084          		EXX
042BE4 CB 18       8085          		RR      B
042BE6 CB 19       8086          		RR      C
042BE8 08          8087          		EX      AF,AF'
042BE9 B0          8088          		OR      B
042BEA 08          8089          		EX      AF,AF'
042BEB D9          8090          		EXX
042BEC 0C          8091  INCC:			INC     C
042BED C0          8092          		RET     NZ
042BEE 3E 14       8093  OFLOW:			LD      A,TOOBIG_FP
042BF0 C3 7D 20 04 8094          		JP      ERROR_FP_           ;"Too big"
042BF4             8095  ;
042BF4             8096  ; FTEST - Test for zero & sign
042BF4             8097  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042BF4             8098  ;
042BF4 CD FF 2B 04 8099  FTEST_FP:			CALL    TEST_FP
042BF8 C8          8100          		RET     Z
042BF9 7C          8101          		LD      A,H
042BFA E6 80       8102          		AND     10000000B
042BFC F6 40       8103          		OR      01000000B
042BFE C9          8104          		RET
042BFF             8105  ;
042BFF             8106  ; TEST_FP - Test HLH'L' for zero.
042BFF             8107  ;     Output: Z-flag set & A=0 if HLH'L'=0
042BFF             8108  ;     Destroys: A,F
042BFF             8109  ;
042BFF 7C          8110  TEST_FP:			LD      A,H
042C00 B5          8111          		OR      L
042C01 D9          8112          		EXX
042C02 B4          8113          		OR      H
042C03 B5          8114          		OR      L
042C04 D9          8115          		EXX
042C05 C9          8116          		RET
042C06             8117  ;
042C06             8118  ; FCOMP - Compare two numbers
042C06             8119  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C06             8120  ;
042C06 78          8121  FCOMP_FP:			LD      A,B
042C07 B1          8122          		OR      C               ;Both integer?
042C08 20 0B       8123          		JR      NZ,FCOMP1
042C0A CD 1F 2C 04 8124          		CALL    ICP
042C0E 3E 00       8125  FCOMP0:			LD      A,0
042C10 C8          8126          		RET     Z               ;Equal
042C11 3E 80       8127          		LD      A,80H
042C13 1F          8128          		RRA
042C14 C9          8129          		RET
042C15             8130  ;
042C15 CD 9A 2B 04 8131  FCOMP1:			CALL    FLOAT2          ;Float both
042C19 CD 2D 2C 04 8132          		CALL    FCP
042C1D 18 EF       8133          		JR      FCOMP0
042C1F             8134  ;
042C1F             8135  ; Integer and floating point compare.
042C1F             8136  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C1F             8137  ; Result pre-set to FALSE
042C1F             8138  ; ICP1, FCP1 destroy A,F
042C1F             8139  ;
042C1F             8140  ; ZERO - Return zero.
042C1F             8141  ;  Destroys: A,C,H,L,H',L'
042C1F             8142  ;
042C1F CD 52 2C 04 8143  ICP:			CALL    ICP1
042C23 3E 00       8144  ZERO_FP:			LD      A,0
042C25 D9          8145          		EXX
042C26 67          8146          		LD      H,A
042C27 6F          8147  	       		LD      L,A
042C28 D9          8148          		EXX
042C29 67          8149        			LD      H,A
042C2A 6F          8150       			LD      L,A
042C2B 4F          8151  	    		LD      C,A
042C2C C9          8152          		RET
042C2D             8153  ;
042C2D CD 44 2C 04 8154  FCP:			CALL    FCP1
042C31 18 F0       8155          		JR      ZERO_FP            ;PRESET FALSE
042C33             8156  ;
042C33 79          8157  FCP0:			LD      A,C
042C34 B8          8158          		CP      B               ;COMPARE EXPONENTS
042C35 C0          8159          		RET     NZ
042C36             8160  ICP0:
042C36 52 ED 52    8161  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C39 52 19       8162          		ADD.S   HL,DE
042C3B C0          8163          		RET     NZ
042C3C D9          8164          		EXX
042C3D 52 ED 52    8165          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C40 52 19       8166          		ADD.S   HL,DE
042C42 D9          8167          		EXX
042C43 C9          8168          		RET
042C44             8169  ;
042C44 7C          8170  FCP1:			LD      A,H
042C45 AA          8171          		XOR     D
042C46 7C          8172          		LD      A,H
042C47 17          8173          		RLA
042C48 F8          8174          		RET     M
042C49 30 E8       8175          		JR      NC,FCP0
042C4B CD 33 2C 04 8176          		CALL    FCP0
042C4F C8          8177          		RET     Z               ;** V0.1 BUG FIX
042C50 3F          8178          		CCF
042C51 C9          8179          		RET
042C52             8180  ;
042C52 7C          8181  ICP1:			LD      A,H
042C53 AA          8182          		XOR     D
042C54 F2 36 2C 04 8183          		JP      P,ICP0
042C58 7C          8184          		LD      A,H
042C59 17          8185          		RLA
042C5A C9          8186          		RET
042C5B             8187  ;
042C5B             8188  ; ADD - Integer add.
042C5B             8189  ; Carry, sign & zero flags valid on exit
042C5B             8190  ;     Destroys: H,L,H',L',F
042C5B             8191  ;
042C5B 05          8192  X10B:			DEC     B
042C5C 0C          8193          		INC     C
042C5D CD A4 2C 04 8194  X5:			CALL    COPY0
042C61 CD 97 2C 04 8195          		CALL    D2C
042C65 CD 97 2C 04 8196          		CALL    D2C
042C69 08          8197          		EX      AF,AF'          ;SAVE CARRY
042C6A D9          8198  ADD_:			EXX
042C6B 52 19       8199          		ADD.S   HL,DE
042C6D D9          8200          		EXX
042C6E 52 ED 5A    8201          		ADC.S   HL,DE
042C71 C9          8202          		RET
042C72             8203  ;
042C72             8204  ; SUB - Integer subtract.
042C72             8205  ; Carry, sign & zero flags valid on exit
042C72             8206  ;     Destroys: H,L,H',L',F
042C72             8207  ;
042C72 D9          8208  SUB_:			EXX
042C73 B7          8209          		OR      A
042C74 52 ED 52    8210          		SBC.S   HL,DE
042C77 D9          8211          		EXX
042C78 52 ED 52    8212          		SBC.S   HL,DE
042C7B C9          8213          		RET
042C7C             8214  ;
042C7C             8215  ; X10 - unsigned integer * 10
042C7C             8216  ;    Inputs: HLH'L' initial value
042C7C             8217  ;   Outputs: DED'E' = initial HLH'L'
042C7C             8218  ;            Carry bit set if overflow
042C7C             8219  ;            If carry not set HLH'L'=result
042C7C             8220  ;  Destroys: D,E,H,L,D',E',H',L',F
042C7C             8221  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042C7C             8222  ;     Carry set if MSB=1 before shift.
042C7C             8223  ;     Sign set if MSB=1 after shift.
042C7C             8224  ;     Destroys: H,L,H',L',F
042C7C             8225  ;
042C7C CD A4 2C 04 8226  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042C80 CD 8F 2C 04 8227          		CALL    X2
042C84 D8          8228          		RET     C               ;TOO BIG
042C85 CD 8F 2C 04 8229          		CALL    X2
042C89 D8          8230          		RET     C
042C8A CD 6A 2C 04 8231          		CALL    ADD_
042C8E D8          8232          		RET     C
042C8F D9          8233  X2:			EXX
042C90 52 29       8234          		ADD.S   HL,HL
042C92 D9          8235          		EXX
042C93 52 ED 6A    8236          		ADC.S   HL,HL
042C96 C9          8237          		RET
042C97             8238  ;
042C97             8239  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042C97             8240  ;     Carry set if LSB=1 before shift.
042C97             8241  ;     Destroys: H,L,H',L',F
042C97             8242  ;
042C97 0C          8243  D2C:			INC     C
042C98 CB 3C       8244  D2:			SRL     H
042C9A CB 1D       8245          		RR      L
042C9C D9          8246          		EXX
042C9D CB 1C       8247          		RR      H
042C9F CB 1D       8248          		RR      L
042CA1 D9          8249          		EXX
042CA2 C9          8250          		RET
042CA3             8251  ;
042CA3             8252  ; COPY - COPY HLH'L'C INTO DED'E'B
042CA3             8253  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CA3             8254  ;
042CA3 41          8255  COPY_:			LD      B,C
042CA4 54          8256  COPY0:			LD      D,H
042CA5 5D          8257          		LD      E,L
042CA6 D9          8258          		EXX
042CA7 54          8259          		LD      D,H
042CA8 5D          8260          		LD      E,L
042CA9 D9          8261          		EXX
042CAA C9          8262          		RET
042CAB             8263  ;
042CAB             8264  ; SQUARE - PUSH X*X
042CAB             8265  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CAB             8266  ;   Destroys: SP,IX
042CAB             8267  ;
042CAB CD A3 2C 04 8268  SQUARE:			CALL    COPY_
042CAF CD 0E 23 04 8269          		CALL    FMUL
042CB3 DD E1       8270  PUSH5:			POP     IX              ;RETURN ADDRESS
042CB5 C5          8271          		PUSH    BC
042CB6 E5          8272          		PUSH    HL
042CB7 D9          8273          		EXX
042CB8 E5          8274          		PUSH    HL
042CB9 D9          8275          		EXX
042CBA DD E9       8276          		JP      (IX)            ;"RETURN"
042CBC             8277  ;
042CBC             8278  ; POP5 - POP DED'E'B OFF STACK.
042CBC             8279  ;   Destroys: A,B,D,E,D',E',SP,IX
042CBC             8280  ;
042CBC DD E1       8281  POP5:			POP     IX              ;RETURN ADDRESS
042CBE D9          8282          		EXX
042CBF D1          8283          		POP     DE
042CC0 D9          8284          		EXX
042CC1 D1          8285          		POP     DE
042CC2 79          8286          		LD      A,C
042CC3 C1          8287          		POP     BC
042CC4 41          8288          		LD      B,C
042CC5 4F          8289          		LD      C,A
042CC6 DD E9       8290          		JP      (IX)            ;"RETURN"
042CC8             8291  ;
042CC8             8292  ; RATIO - Calculate (X-1)/(X+1)
042CC8             8293  ;     Inputs: X in HLH'L'C
042CC8             8294  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042CC8             8295  ;   Destroys: Everything except IY,SP,I
042CC8             8296  ;
042CC8 CD B3 2C 04 8297  RATIO:			CALL    PUSH5           ;SAVE X
042CCC CD 3B 26 04 8298          		CALL    DONE
042CD0 CD FC 21 04 8299          		CALL    FADD
042CD4 CD BC 2C 04 8300          		CALL    POP5            ;RESTORE X
042CD8 CD B3 2C 04 8301          		CALL    PUSH5           ;SAVE X+1
042CDC CD D7 2B 04 8302          		CALL    SWAP_FP
042CE0 CD 3B 26 04 8303          		CALL    DONE
042CE4 CD E3 21 04 8304          		CALL    FSUB
042CE8 CD BC 2C 04 8305          		CALL    POP5            ;RESTORE X+1
042CEC C3 65 22 04 8306          		JP      FDIV
042CF0             8307  ;
042CF0             8308  ; POLY - Evaluate a polynomial.
042CF0             8309  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042CF0             8310  ;             Polynomial coefficients follow call.
042CF0             8311  ;    Outputs: Result in HLH'L'C
042CF0             8312  ;   Destroys: Everything except IY,SP,I
042CF0             8313  ; Routine terminates on finding a coefficient >=1.
042CF0             8314  ; Note: The last coefficient is EXECUTED on return
042CF0             8315  ;       so must contain only innocuous bytes!
042CF0             8316  ;
042CF0 DD 21 03 00 8317  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042CF5 DD 39       8318          		ADD     IX, SP
042CF7 DD E3       8319          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042CF9             8320  ;
042CF9 CD CF 29 04 8321          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042CFD CD 0E 23 04 8322  POLY1:			CALL    FMUL
042D01 11 05 00 00 8323          		LD      DE, 5				; Skip to the next coefficient
042D05 DD 19       8324          		ADD     IX, DE
042D07 CD CF 29 04 8325          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D0B DD E3       8326          		EX      (SP), IX			; Restore the SP just in case we need to return
042D0D 04          8327          		INC     B
042D0E 05          8328          		DEC     B               		; Test B for end byte (80h)
042D0F FA FC 21 04 8329          		JP      M,FADD				; Yes, so add and return
042D13 CD FC 21 04 8330          		CALL    FADD				; No, so add
042D17 CD E1 29 04 8331          		CALL    DLOAD5_SPL			; Load X from SP
042D1B DD E3       8332          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D1D 18 DE       8333          		JR      POLY1				; And loop
042D1F             8334  ;
042D1F             8335  ; POWR10 - Calculate power of ten.
042D1F             8336  ;     Inputs: A=power of 10 required (A<128)
042D1F             8337  ;             A=binary exponent to be exceeded (A>=128)
042D1F             8338  ;    Outputs: DED'E'B = result
042D1F             8339  ;             A = actual power of ten returned
042D1F             8340  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D1F             8341  ;
042D1F 3C          8342  POWR10:			INC     A
042D20 08          8343          		EX      AF,AF'
042D21 E5          8344          		PUSH    HL
042D22 D9          8345          		EXX
042D23 E5          8346          		PUSH    HL
042D24 D9          8347          		EXX
042D25 CD 3B 26 04 8348          		CALL    DONE
042D29 CD D7 2B 04 8349          		CALL    SWAP_FP
042D2D AF          8350          		XOR     A
042D2E 08          8351  POWR11:			EX      AF,AF'
042D2F 3D          8352          		DEC     A
042D30 28 26       8353          		JR      Z,POWR14        ;EXIT TYPE 1
042D32 F2 3A 2D 04 8354          		JP      P,POWR13
042D36 B9          8355          		CP      C
042D37 38 1F       8356          		JR      C,POWR14        ;EXIT TYPE 2
042D39 3C          8357          		INC     A
042D3A 08          8358  POWR13:			EX      AF,AF'
042D3B 3C          8359          		INC     A
042D3C CB FC       8360          		SET     7,H
042D3E CD 5D 2C 04 8361          		CALL    X5
042D42 30 06       8362          		JR      NC,POWR12
042D44 08          8363          		EX      AF,AF'
042D45 CD 97 2C 04 8364          		CALL    D2C
042D49 08          8365          		EX      AF,AF'
042D4A 08          8366  POWR12:			EX      AF,AF'
042D4B DC BF 2B 04 8367          		CALL    C,ADD1_FP          ;ROUND UP
042D4F 0C          8368          		INC     C
042D50 FA 2E 2D 04 8369          		JP      M,POWR11
042D54 C3 EE 2B 04 8370          		JP      OFLOW
042D58 CD D7 2B 04 8371  POWR14:			CALL    SWAP_FP
042D5C CB BA       8372          		RES     7,D
042D5E D9          8373          		EXX
042D5F E1          8374          		POP     HL
042D60 D9          8375          		EXX
042D61 E1          8376          		POP     HL
042D62 08          8377          		EX      AF,AF'
042D63 C9          8378          		RET
042D64             8379  ;
042D64             8380  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D64             8381  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D64             8382  ;               Remainder in H'L'HL
042D64             8383  ;     Inputs: A = loop counter (normally -32)
042D64             8384  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D64             8385  ;
042D64 B7          8386  DIVA:			OR      A               ;CLEAR CARRY
042D65             8387  DIV0:
042D65 52 ED 42    8388  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D68 D9          8389          		EXX
042D69 52 ED 42    8390          		SBC.S   HL,BC
042D6C D9          8391          		EXX
042D6D 30 07       8392          		JR      NC,DIV1
042D6F 52 09       8393          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042D71 D9          8394          		EXX
042D72 52 ED 4A    8395          		ADC.S   HL,BC
042D75 D9          8396          		EXX
042D76 3F          8397  DIV1:			CCF
042D77 CB 13       8398  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042D79 CB 12       8399          		RL      D
042D7B D9          8400          		EXX
042D7C CB 13       8401          		RL      E
042D7E CB 12       8402          		RL      D
042D80 D9          8403          		EXX
042D81 3C          8404          		INC     A
042D82 F0          8405          		RET     P
042D83             8406  DIVB:
042D83 52 ED 6A    8407  			ADC.S   HL,HL           ;DIVIDEND*2
042D86 D9          8408          		EXX
042D87 52 ED 6A    8409          		ADC.S   HL,HL
042D8A D9          8410          		EXX
042D8B 30 D8       8411          		JR      NC,DIV0
042D8D B7          8412          		OR      A
042D8E 52 ED 42    8413          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D91 D9          8414          		EXX
042D92 52 ED 42    8415          		SBC.S   HL,BC
042D95 D9          8416          		EXX
042D96 37          8417          		SCF
042D97 C3 77 2D 04 8418          		JP      DIVC
042D9B             8419  ;
042D9B             8420  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042D9B             8421  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042D9B             8422  ;    Inputs: A = loop counter (usually -32)
042D9B             8423  ;            H'L'HL = 0
042D9B             8424  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042D9B             8425  ;
042D9B B7          8426  MULA:			OR      A               ;CLEAR CARRY
042D9C D9          8427  MUL0:			EXX
042D9D CB 1A       8428          		RR      D               ;MULTIPLIER/2
042D9F CB 1B       8429          		RR      E
042DA1 D9          8430          		EXX
042DA2 CB 1A       8431          		RR      D
042DA4 CB 1B       8432          		RR      E
042DA6 30 07       8433          		JR      NC,MUL1
042DA8 52 09       8434          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DAA D9          8435          		EXX
042DAB 52 ED 4A    8436          		ADC.S   HL,BC
042DAE D9          8437          		EXX
042DAF 3C          8438  MUL1:			INC     A
042DB0 F0          8439          		RET     P
042DB1 D9          8440  MULB:			EXX
042DB2 CB 1C       8441          		RR      H               ;PRODUCT/2
042DB4 CB 1D       8442          		RR      L
042DB6 D9          8443          		EXX
042DB7 CB 1C       8444          		RR      H
042DB9 CB 1D       8445          		RR      L
042DBB C3 9C 2D 04 8446          		JP      MUL0
042DBF             8447  ;
042DBF             8448  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DBF             8449  ;     Function: B'C'BC = SQR (D'E'DE)
042DBF             8450  ;     Inputs: A = loop counter (normally -31)
042DBF             8451  ;             B'C'BCH'L'HL initialised to 0
042DBF             8452  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DBF             8453  ;
042DBF             8454  SQR1:
042DBF 52 ED 42    8455  			SBC.S   HL,BC
042DC2 D9          8456          		EXX
042DC3 52 ED 42    8457          		SBC.S   HL,BC
042DC6 D9          8458          		EXX
042DC7 0C          8459          		INC     C
042DC8 30 09       8460          		JR      NC,SQR2
042DCA 0D          8461          		DEC     C
042DCB 52 09       8462          		ADD.S   HL,BC
042DCD D9          8463          		EXX
042DCE 52 ED 4A    8464          		ADC.S   HL,BC
042DD1 D9          8465          		EXX
042DD2 0D          8466          		DEC     C
042DD3 3C          8467  SQR2:			INC     A
042DD4 F0          8468          		RET     P
042DD5 CB 21       8469  SQRA:			SLA     C
042DD7 CB 10       8470          		RL      B
042DD9 D9          8471          		EXX
042DDA CB 11       8472          		RL      C
042DDC CB 10       8473          		RL      B
042DDE D9          8474          		EXX
042DDF 0C          8475          		INC     C
042DE0 CB 23       8476          		SLA     E
042DE2 CB 12       8477          		RL      D
042DE4 D9          8478          		EXX
042DE5 CB 13       8479          		RL      E
042DE7 CB 12       8480          		RL      D
042DE9 D9          8481          		EXX
042DEA 52 ED 6A    8482          		ADC.S   HL,HL
042DED D9          8483          		EXX
042DEE 52 ED 6A    8484          		ADC.S   HL,HL
042DF1 D9          8485          		EXX
042DF2 CB 23       8486          		SLA     E
042DF4 CB 12       8487          		RL      D
042DF6 D9          8488          		EXX
042DF7 CB 13       8489          		RL      E
042DF9 CB 12       8490          		RL      D
042DFB D9          8491          		EXX
042DFC 52 ED 6A    8492          		ADC.S   HL,HL
042DFF D9          8493          		EXX
042E00 52 ED 6A    8494          		ADC.S   HL,HL
042E03 D9          8495          		EXX
042E04 D2 BF 2D 04 8496          		JP      NC,SQR1
042E08 B7          8497  SQR3:			OR      A
042E09 52 ED 42    8498          		SBC.S   HL,BC
042E0C D9          8499          		EXX
042E0D 52 ED 42    8500          		SBC.S   HL,BC
042E10 D9          8501          		EXX
042E11 0C          8502          		INC     C
042E12 C3 D3 2D 04 8503          		JP      SQR2
042E16             8504  ;
042E16             8505  SQRB:
042E16 52 29       8506  			ADD.S   HL,HL
042E18 D9          8507          		EXX
042E19 52 ED 6A    8508          		ADC.S   HL,HL
042E1C D9          8509          		EXX
042E1D 38 E9       8510          		JR      C,SQR3
042E1F 3C          8511          		INC     A
042E20 0C          8512          		INC     C
042E21 52 ED 42    8513          		SBC.S   HL,BC
042E24 D9          8514          		EXX
042E25 52 ED 42    8515          		SBC.S   HL,BC
042E28 D9          8516          		EXX
042E29 D0          8517          		RET     NC
042E2A 52 09       8518          		ADD.S   HL,BC
042E2C D9          8519          		EXX
042E2D 52 ED 4A    8520          		ADC.S   HL,BC
042E30 D9          8521          		EXX
042E31 0D          8522          		DEC     C
042E32 C9          8523          		RET
042E33             8524  ;
042E33 DD 7E 00    8525  DIGITQ:			LD      A,(IX)
042E36 FE 3A       8526          		CP      '9'+1
042E38 3F          8527          		CCF
042E39 D8          8528          		RET     C
042E3A FE 30       8529          		CP      '0'
042E3C C9          8530          		RET
042E3D             8531  ;
042E3D DD 7E 00    8532  SIGNQ:			LD      A,(IX)
042E40 DD 23       8533          		INC     IX
042E42 FE 20       8534          		CP      ' '
042E44 28 F7       8535          		JR      Z,SIGNQ
042E46 FE 2B       8536          		CP      '+'
042E48 C8          8537          		RET     Z
042E49 FE 2D       8538          		CP      '-'
042E4B C8          8539          		RET     Z
042E4C DD 2B       8540          		DEC     IX
042E4E C9          8541          		RET; --- End fpp.asm ---
042E4F             8542  
042E4F             8543  ; --- Begin gpio.asm ---
042E4F             8544  ;
042E4F             8545  ; Title:	BBC Basic for AGON - GPIO functions
042E4F             8546  ; Author:	Dean Belfield
042E4F             8547  ; Created:	12/05/2023
042E4F             8548  ; Last Updated:	12/05/2023
042E4F             8549  ;
042E4F             8550  ; Modinfo:
042E4F             8551  
042E4F             8552  			; INCLUDE	"macros.inc"
042E4F             8553  			; INCLUDE	"equs.inc"
042E4F             8554  
042E4F             8555  			; .ASSUME	ADL = 1
042E4F             8556  
042E4F             8557  			; SEGMENT CODE
042E4F             8558  
042E4F             8559  			; XDEF	GPIOB_SETMODE
042E4F             8560  
042E4F             8561  			; XREF	SWITCH_A
042E4F             8562  
042E4F             8563  ;  A: Mode
042E4F             8564  ;  B: Pins
042E4F             8565  ;
042E4F CD F4 3D 04 8566  GPIOB_SETMODE:		CALL	SWITCH_A
042E53 67 2E       8567  			DW	GPIOB_M0	; Output
042E55 8C 2E       8568  			DW	GPIOB_M1	; Input
042E57 AC 2E       8569  			DW	GPIOB_M2	; Open Drain IO
042E59 CC 2E       8570  			DW	GPIOB_M3	; Open Source IO
042E5B E7 2E       8571  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E5D 13 2F       8572  			DW	GPIOB_M5	; Alt Function
042E5F 2E 2F       8573  			DW	GPIOB_M6	; Interrupt, Active Low
042E61 55 2F       8574  			DW	GPIOB_M7	; Interrupt, Active High
042E63 77 2F       8575  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E65 99 2F       8576  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E67             8577  
042E67             8578  ; Output
042E67             8579  ;
042E67             8580  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E67 C5          0001M 		PUSH	BC
042E68 78          0002M 		LD	A, val
042E69 2F          0003M 		CPL
042E6A 4F          0004M 		LD	C, A
042E6B ED 38 9B    0005M 		IN0	A, (reg)
042E6E A1          0006M 		AND	C
042E6F ED 39 9B    0007M 		OUT0	(reg), A
042E72 C1          0008M 		POP	BC
042E73             8581  			RES_GPIO PB_ALT1, B
042E73 C5          0001M 		PUSH	BC
042E74 78          0002M 		LD	A, val
042E75 2F          0003M 		CPL
042E76 4F          0004M 		LD	C, A
042E77 ED 38 9C    0005M 		IN0	A, (reg)
042E7A A1          0006M 		AND	C
042E7B ED 39 9C    0007M 		OUT0	(reg), A
042E7E C1          0008M 		POP	BC
042E7F             8582  			RES_GPIO PB_ALT2, B
042E7F C5          0001M 		PUSH	BC
042E80 78          0002M 		LD	A, val
042E81 2F          0003M 		CPL
042E82 4F          0004M 		LD	C, A
042E83 ED 38 9D    0005M 		IN0	A, (reg)
042E86 A1          0006M 		AND	C
042E87 ED 39 9D    0007M 		OUT0	(reg), A
042E8A C1          0008M 		POP	BC
042E8B C9          8583  			RET
042E8C             8584  
042E8C             8585  ; Input
042E8C             8586  ;
042E8C             8587  GPIOB_M1:		SET_GPIO PB_DDR,  B
042E8C ED 38 9B    0001M 		IN0	A, (reg)
042E8F B0          0002M 		OR	val
042E90 ED 39 9B    0003M 		OUT0	(reg), A
042E93             8588  			RES_GPIO PB_ALT1, B
042E93 C5          0001M 		PUSH	BC
042E94 78          0002M 		LD	A, val
042E95 2F          0003M 		CPL
042E96 4F          0004M 		LD	C, A
042E97 ED 38 9C    0005M 		IN0	A, (reg)
042E9A A1          0006M 		AND	C
042E9B ED 39 9C    0007M 		OUT0	(reg), A
042E9E C1          0008M 		POP	BC
042E9F             8589  			RES_GPIO PB_ALT2, B
042E9F C5          0001M 		PUSH	BC
042EA0 78          0002M 		LD	A, val
042EA1 2F          0003M 		CPL
042EA2 4F          0004M 		LD	C, A
042EA3 ED 38 9D    0005M 		IN0	A, (reg)
042EA6 A1          0006M 		AND	C
042EA7 ED 39 9D    0007M 		OUT0	(reg), A
042EAA C1          0008M 		POP	BC
042EAB C9          8590  			RET
042EAC             8591  
042EAC             8592  ; Open Drain IO
042EAC             8593  ;
042EAC             8594  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EAC C5          0001M 		PUSH	BC
042EAD 78          0002M 		LD	A, val
042EAE 2F          0003M 		CPL
042EAF 4F          0004M 		LD	C, A
042EB0 ED 38 9B    0005M 		IN0	A, (reg)
042EB3 A1          0006M 		AND	C
042EB4 ED 39 9B    0007M 		OUT0	(reg), A
042EB7 C1          0008M 		POP	BC
042EB8             8595  			SET_GPIO PB_ALT1, B
042EB8 ED 38 9C    0001M 		IN0	A, (reg)
042EBB B0          0002M 		OR	val
042EBC ED 39 9C    0003M 		OUT0	(reg), A
042EBF             8596  			RES_GPIO PB_ALT2, B
042EBF C5          0001M 		PUSH	BC
042EC0 78          0002M 		LD	A, val
042EC1 2F          0003M 		CPL
042EC2 4F          0004M 		LD	C, A
042EC3 ED 38 9D    0005M 		IN0	A, (reg)
042EC6 A1          0006M 		AND	C
042EC7 ED 39 9D    0007M 		OUT0	(reg), A
042ECA C1          0008M 		POP	BC
042ECB C9          8597  			RET
042ECC             8598  
042ECC             8599  ; Open Source IO
042ECC             8600  ;
042ECC             8601  GPIOB_M3:		SET_GPIO PB_DDR,  B
042ECC ED 38 9B    0001M 		IN0	A, (reg)
042ECF B0          0002M 		OR	val
042ED0 ED 39 9B    0003M 		OUT0	(reg), A
042ED3             8602  			SET_GPIO PB_ALT1, B
042ED3 ED 38 9C    0001M 		IN0	A, (reg)
042ED6 B0          0002M 		OR	val
042ED7 ED 39 9C    0003M 		OUT0	(reg), A
042EDA             8603  			RES_GPIO PB_ALT2, B
042EDA C5          0001M 		PUSH	BC
042EDB 78          0002M 		LD	A, val
042EDC 2F          0003M 		CPL
042EDD 4F          0004M 		LD	C, A
042EDE ED 38 9D    0005M 		IN0	A, (reg)
042EE1 A1          0006M 		AND	C
042EE2 ED 39 9D    0007M 		OUT0	(reg), A
042EE5 C1          0008M 		POP	BC
042EE6 C9          8604  			RET
042EE7             8605  
042EE7             8606  ; Interrupt, Dual Edge
042EE7             8607  ;
042EE7             8608  GPIOB_M4:		SET_GPIO PB_DR,   B
042EE7 ED 38 9A    0001M 		IN0	A, (reg)
042EEA B0          0002M 		OR	val
042EEB ED 39 9A    0003M 		OUT0	(reg), A
042EEE             8609  			RES_GPIO PB_DDR,  B
042EEE C5          0001M 		PUSH	BC
042EEF 78          0002M 		LD	A, val
042EF0 2F          0003M 		CPL
042EF1 4F          0004M 		LD	C, A
042EF2 ED 38 9B    0005M 		IN0	A, (reg)
042EF5 A1          0006M 		AND	C
042EF6 ED 39 9B    0007M 		OUT0	(reg), A
042EF9 C1          0008M 		POP	BC
042EFA             8610  			RES_GPIO PB_ALT1, B
042EFA C5          0001M 		PUSH	BC
042EFB 78          0002M 		LD	A, val
042EFC 2F          0003M 		CPL
042EFD 4F          0004M 		LD	C, A
042EFE ED 38 9C    0005M 		IN0	A, (reg)
042F01 A1          0006M 		AND	C
042F02 ED 39 9C    0007M 		OUT0	(reg), A
042F05 C1          0008M 		POP	BC
042F06             8611  			RES_GPIO PB_ALT2, B
042F06 C5          0001M 		PUSH	BC
042F07 78          0002M 		LD	A, val
042F08 2F          0003M 		CPL
042F09 4F          0004M 		LD	C, A
042F0A ED 38 9D    0005M 		IN0	A, (reg)
042F0D A1          0006M 		AND	C
042F0E ED 39 9D    0007M 		OUT0	(reg), A
042F11 C1          0008M 		POP	BC
042F12 C9          8612  			RET
042F13             8613  
042F13             8614  ; Alt Function
042F13             8615  ;
042F13             8616  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F13 ED 38 9B    0001M 		IN0	A, (reg)
042F16 B0          0002M 		OR	val
042F17 ED 39 9B    0003M 		OUT0	(reg), A
042F1A             8617  			RES_GPIO PB_ALT1, B
042F1A C5          0001M 		PUSH	BC
042F1B 78          0002M 		LD	A, val
042F1C 2F          0003M 		CPL
042F1D 4F          0004M 		LD	C, A
042F1E ED 38 9C    0005M 		IN0	A, (reg)
042F21 A1          0006M 		AND	C
042F22 ED 39 9C    0007M 		OUT0	(reg), A
042F25 C1          0008M 		POP	BC
042F26             8618  			SET_GPIO PB_ALT2, B
042F26 ED 38 9D    0001M 		IN0	A, (reg)
042F29 B0          0002M 		OR	val
042F2A ED 39 9D    0003M 		OUT0	(reg), A
042F2D C9          8619  			RET
042F2E             8620  
042F2E             8621  ; Interrupt, Active Low
042F2E             8622  ;
042F2E             8623  GPIOB_M6:		RES_GPIO PB_DR,   B
042F2E C5          0001M 		PUSH	BC
042F2F 78          0002M 		LD	A, val
042F30 2F          0003M 		CPL
042F31 4F          0004M 		LD	C, A
042F32 ED 38 9A    0005M 		IN0	A, (reg)
042F35 A1          0006M 		AND	C
042F36 ED 39 9A    0007M 		OUT0	(reg), A
042F39 C1          0008M 		POP	BC
042F3A             8624  			RES_GPIO PB_DDR,  B
042F3A C5          0001M 		PUSH	BC
042F3B 78          0002M 		LD	A, val
042F3C 2F          0003M 		CPL
042F3D 4F          0004M 		LD	C, A
042F3E ED 38 9B    0005M 		IN0	A, (reg)
042F41 A1          0006M 		AND	C
042F42 ED 39 9B    0007M 		OUT0	(reg), A
042F45 C1          0008M 		POP	BC
042F46             8625  			SET_GPIO PB_ALT1, B
042F46 ED 38 9C    0001M 		IN0	A, (reg)
042F49 B0          0002M 		OR	val
042F4A ED 39 9C    0003M 		OUT0	(reg), A
042F4D             8626  			SET_GPIO PB_ALT2, B
042F4D ED 38 9D    0001M 		IN0	A, (reg)
042F50 B0          0002M 		OR	val
042F51 ED 39 9D    0003M 		OUT0	(reg), A
042F54 C9          8627  			RET
042F55             8628  
042F55             8629  
042F55             8630  ; Interrupt, Active High
042F55             8631  ;
042F55             8632  GPIOB_M7:		SET_GPIO PB_DR,   B
042F55 ED 38 9A    0001M 		IN0	A, (reg)
042F58 B0          0002M 		OR	val
042F59 ED 39 9A    0003M 		OUT0	(reg), A
042F5C             8633  			RES_GPIO PB_DDR,  B
042F5C C5          0001M 		PUSH	BC
042F5D 78          0002M 		LD	A, val
042F5E 2F          0003M 		CPL
042F5F 4F          0004M 		LD	C, A
042F60 ED 38 9B    0005M 		IN0	A, (reg)
042F63 A1          0006M 		AND	C
042F64 ED 39 9B    0007M 		OUT0	(reg), A
042F67 C1          0008M 		POP	BC
042F68             8634  			SET_GPIO PB_ALT1, B
042F68 ED 38 9C    0001M 		IN0	A, (reg)
042F6B B0          0002M 		OR	val
042F6C ED 39 9C    0003M 		OUT0	(reg), A
042F6F             8635  			SET_GPIO PB_ALT2, B
042F6F ED 38 9D    0001M 		IN0	A, (reg)
042F72 B0          0002M 		OR	val
042F73 ED 39 9D    0003M 		OUT0	(reg), A
042F76 C9          8636  			RET
042F77             8637  
042F77             8638  
042F77             8639  ; Interrupt, Falling Edge
042F77             8640  ;
042F77             8641  GPIOB_M8:		RES_GPIO PB_DR,   B
042F77 C5          0001M 		PUSH	BC
042F78 78          0002M 		LD	A, val
042F79 2F          0003M 		CPL
042F7A 4F          0004M 		LD	C, A
042F7B ED 38 9A    0005M 		IN0	A, (reg)
042F7E A1          0006M 		AND	C
042F7F ED 39 9A    0007M 		OUT0	(reg), A
042F82 C1          0008M 		POP	BC
042F83             8642  			SET_GPIO PB_DDR,  B
042F83 ED 38 9B    0001M 		IN0	A, (reg)
042F86 B0          0002M 		OR	val
042F87 ED 39 9B    0003M 		OUT0	(reg), A
042F8A             8643  			SET_GPIO PB_ALT1, B
042F8A ED 38 9C    0001M 		IN0	A, (reg)
042F8D B0          0002M 		OR	val
042F8E ED 39 9C    0003M 		OUT0	(reg), A
042F91             8644  			SET_GPIO PB_ALT2, B
042F91 ED 38 9D    0001M 		IN0	A, (reg)
042F94 B0          0002M 		OR	val
042F95 ED 39 9D    0003M 		OUT0	(reg), A
042F98 C9          8645  			RET
042F99             8646  
042F99             8647  ; Interrupt, Rising Edge
042F99             8648  ;
042F99             8649  GPIOB_M9:		SET_GPIO PB_DR,   B
042F99 ED 38 9A    0001M 		IN0	A, (reg)
042F9C B0          0002M 		OR	val
042F9D ED 39 9A    0003M 		OUT0	(reg), A
042FA0             8650  			SET_GPIO PB_DDR,  B
042FA0 ED 38 9B    0001M 		IN0	A, (reg)
042FA3 B0          0002M 		OR	val
042FA4 ED 39 9B    0003M 		OUT0	(reg), A
042FA7             8651  			SET_GPIO PB_ALT1, B
042FA7 ED 38 9C    0001M 		IN0	A, (reg)
042FAA B0          0002M 		OR	val
042FAB ED 39 9C    0003M 		OUT0	(reg), A
042FAE             8652  			SET_GPIO PB_ALT2, B
042FAE ED 38 9D    0001M 		IN0	A, (reg)
042FB1 B0          0002M 		OR	val
042FB2 ED 39 9D    0003M 		OUT0	(reg), A
042FB5 C9          8653  			RET	; --- End gpio.asm ---
042FB6             8654  
042FB6             8655  ; --- Begin main.asm ---
042FB6             8656  ;
042FB6             8657  ; Title:	BBC Basic Interpreter - Z80 version
042FB6             8658  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FB6             8659  ; Author:	(C) Copyright  R.T.Russell  1984
042FB6             8660  ; Modified By:	Dean Belfield
042FB6             8661  ; Created:	12/05/2023
042FB6             8662  ; Last Updated:	26/11/2023
042FB6             8663  ;
042FB6             8664  ; Modinfo:
042FB6             8665  ; 07/05/1984:	Version 2.3
042FB6             8666  ; 01/03/1987:	Version 3.0
042FB6             8667  ; 03/05/2022:	Modified by Dean Belfield
042FB6             8668  ; 06/06/2023:	Modified to run in ADL mode
042FB6             8669  ; 26/06/2023:	Fixed binary and unary indirection
042FB6             8670  ; 17/08/2023:	Added binary constants
042FB6             8671  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FB6             8672  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FB6             8673  
042FB6             8674  			; .ASSUME	ADL = 1
042FB6             8675  
042FB6             8676  			; INCLUDE	"equs.inc"
042FB6             8677  
042FB6             8678  			; SEGMENT CODE
042FB6             8679  
042FB6             8680  			; XDEF	_main
042FB6             8681  
042FB6             8682  			; XDEF	COLD
042FB6             8683  			; XDEF	WARM
042FB6             8684  			; XDEF	CLOOP
042FB6             8685  			; XDEF	DELETE
042FB6             8686  			; XDEF	LIST_
042FB6             8687  			; XDEF	RENUM
042FB6             8688  			; XDEF	AUTO
042FB6             8689  			; XDEF	NEW
042FB6             8690  			; XDEF	OLD
042FB6             8691  			; XDEF	LOAD
042FB6             8692  			; XDEF	SAVE
042FB6             8693  			; XDEF	ERROR_
042FB6             8694  			; XDEF	EXTERR
042FB6             8695  			; XDEF	LOAD0
042FB6             8696  			; XDEF	CLEAR
042FB6             8697  			; XDEF	CRLF
042FB6             8698  			; XDEF	OUTCHR
042FB6             8699  			; XDEF	OUT_
042FB6             8700  			; XDEF	FINDL
042FB6             8701  			; XDEF	SETLIN
042FB6             8702  			; XDEF	PBCDL
042FB6             8703  			; XDEF	SAYLN
042FB6             8704  			; XDEF	PUTVAR
042FB6             8705  			; XDEF	GETVAR
042FB6             8706  			; XDEF	GETDEF
042FB6             8707  			; XDEF	CREATE
042FB6             8708  			; XDEF	RANGE
042FB6             8709  			; XDEF	LEXAN2
042FB6             8710  			; XDEF	REPORT
042FB6             8711  			; XDEF	TELL
042FB6             8712  			; XDEF	SPACE_
042FB6             8713  			; XDEF	KEYWDS
042FB6             8714  			; XDEF	KEYWDL
042FB6             8715  			; XDEF	ONEDIT
042FB6             8716  			; XDEF	ONEDIT1
042FB6             8717  			; XDEF	LISTIT
042FB6             8718  			; XDEF	CLEAN
042FB6             8719  
042FB6             8720  			; XREF	LISTON
042FB6             8721  			; XREF	ERRTXT
042FB6             8722  			; XREF	OSINIT
042FB6             8723  			; XREF	HIMEM
042FB6             8724  			; XREF	PAGE_
042FB6             8725  			; XREF	CHAIN0
042FB6             8726  			; XREF	PROMPT
042FB6             8727  			; XREF	ERRTRP
042FB6             8728  			; XREF	ERRLIN
042FB6             8729  			; XREF	AUTONO
042FB6             8730  			; XREF	LINENO
042FB6             8731  			; XREF	INCREM
042FB6             8732  			; XREF	OSLINE
042FB6             8733  			; XREF	COUNT
042FB6             8734  			; XREF	NXT
042FB6             8735  			; XREF	BUFFER
042FB6             8736  			; XREF	XEQ
042FB6             8737  			; XREF	TOP
042FB6             8738  			; XREF	EXPRI
042FB6             8739  			; XREF	SEARCH
042FB6             8740  			; XREF	LTRAP
042FB6             8741  			; XREF	LOMEM
042FB6             8742  			; XREF	DECODE
042FB6             8743  			; XREF	EXPRS
042FB6             8744  			; XREF	OSSAVE
042FB6             8745  			; XREF	ERR
042FB6             8746  			; XREF	ERL
042FB6             8747  			; XREF	TRACEN
042FB6             8748  			; XREF	RESET
042FB6             8749  			; XREF	OSSHUT
042FB6             8750  			; XREF	OSLOAD
042FB6             8751  			; XREF	FREE
042FB6             8752  			; XREF	DYNVAR
042FB6             8753  			; XREF	FILL
042FB6             8754  			; XREF	OSWRCH
042FB6             8755  			; XREF	WIDTH
042FB6             8756  			; XREF	COMMA
042FB6             8757  			; XREF	MUL16
042FB6             8758  			; XREF	BRAKET
042FB6             8759  			; XREF	X4OR5
042FB6             8760  			; XREF	LOADN
042FB6             8761  			; XREF	SFIX
042FB6             8762  			; XREF	ITEMI
042FB6             8763  			; XREF	FNPTR
042FB6             8764  			; XREF	PROPTR
042FB6             8765  			; XREF	CHECK
042FB6             8766  			; XREF	TERMQ
042FB6             8767  			; XREF	OSWRCHCH
042FB6             8768  			; XREF	NEWIT
042FB6             8769  			; XREF	BAD
042FB6             8770  			; XREF	RAM_START
042FB6             8771  			; XREF	RAM_END
042FB6             8772  			; XREF	R0
042FB6             8773  			; XREF	STAR_VERSION
042FB6             8774  
042FB6             8775  			; XREF	_end			; In init.asm
042FB6             8776  ;
042FB6             8777  ; A handful of common token IDs
042FB6             8778  ;
042FB6             8779  TERROR_MN:			EQU     85H
042FB6             8780  LINE_MN_:			EQU     86H
042FB6             8781  ELSE_MN_:			EQU     8BH
042FB6             8782  THEN_MN_:			EQU     8CH
042FB6             8783  LINO_MN:			EQU     8DH
042FB6             8784  FN:			EQU     A4H
042FB6             8785  TO_MN:			EQU     B8H
042FB6             8786  REN:			EQU     CCH
042FB6             8787  DATA_MN_:			EQU     DCH
042FB6             8788  DIM:			EQU     DEH
042FB6             8789  FOR:			EQU     E3H
042FB6             8790  GOSUB:			EQU     E4H
042FB6             8791  GOTO:			EQU     E5H
042FB6             8792  TIF:			EQU     E7H
042FB6             8793  LOCAL_:			EQU     EAH
042FB6             8794  NEXT:			EQU     EDH
042FB6             8795  ON_:			EQU     EEH
042FB6             8796  PROC:			EQU     F2H
042FB6             8797  REM:			EQU     F4H
042FB6             8798  REPEAT:			EQU     F5H
042FB6             8799  RESTOR:			EQU     F7H
042FB6             8800  TRACE:			EQU     FCH
042FB6             8801  UNTIL:			EQU     FDH
042FB6             8802  ;
042FB6             8803  ; This defines the block of tokens that are pseudo-variables.
042FB6             8804  ; There are two versions of each token, a GET and a SET
042FB6             8805  
042FB6             8806  ; Name  : GET : SET
042FB6             8807  ; ------:-----:----
042FB6             8808  ; PTR   : 8Fh : CFh
042FB6             8809  ; PAGE  : 90h : D0h
042FB6             8810  ; TIME  : 91h : D1h
042FB6             8811  ; LOMEM : 92h : D2h
042FB6             8812  ; HIMEM : 93h : D3h
042FB6             8813  ;
042FB6             8814  ; Examples:
042FB6             8815  ;   LET A% = PAGE : REM This is the GET version
042FB6             8816  ;   PAGE = 40000  : REM This is the SET version
042FB6             8817  ;
042FB6             8818  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FB6             8819  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FB6             8820  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FB6             8821  
042FB6             8822  ; The main routine
042FB6             8823  ; IXU: argv - pointer to array of parameters
042FB6             8824  ;   C: argc - number of parameters
042FB6             8825  ; Returns:
042FB6             8826  ;  HL: Error code, or 0 if OK
042FB6             8827  ;
042FB6 21 00 4A 04 8828  _main:			LD	HL, ACCS		; Clear the ACCS
042FBA 36 00       8829  			LD	(HL), 0
042FBC 79          8830  			LD	A, C
042FBD FE 02       8831  			CP	2
042FBF 28 2D       8832  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FC1 38 3F       8833  			JR	C, COLD			; 1 parameter = normal start
042FC3 CD 38 40 04 8834  			CALL	STAR_VERSION
042FC7 CD 90 3D 04 8835  			CALL	TELL
042FCB 55 73 61 67 8836  			DB	"Usage:\n\r"
       65 3A 0A 0D 
042FD3 52 55 4E 20 8837  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
042FE6 21 00 00 00 8838  			LD	HL, 0			; The error code
042FEA C3 68 00 04 8839  			JP	_end
042FEE             8840  ;
042FEE DD 27 03    8841  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
042FF1 11 00 4A 04 8842  			LD	DE, ACCS		;  DE: Destination address
042FF5 7E          8843  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
042FF6 12          8844  			LD	(DE), A			;
042FF7 23          8845  			INC	HL			; Increase the source pointer
042FF8 1C          8846  			INC	E			; We only need to increase E as ACCS is on a page boundary
042FF9 28 03       8847  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
042FFB B7          8848  			OR	A
042FFC 20 F7       8849  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
042FFE 1D          8850  AUTOLOAD_2:		DEC	E
042FFF 3E 0D       8851  			LD	A, CR
043001 12          8852  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
043002             8853  ;
043002 E1          8854  COLD:			POP	HL			; Pop the return address to init off SPS
043003 E5          8855  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043004 21 00 4C 04 8856  			LD	HL, STAVAR		; Cold start
043008 F9          8857  			LD	SP, HL
043009 36 0A       8858  			LD	(HL), 10
04300B 23          8859  			INC	HL
04300C 36 09       8860  			LD	(HL),9
04300E CD 81 3F 04 8861  			CALL    OSINIT			; Call the machine specific OS initialisation routines
043012 ED 53 20 4D 8862  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
043017 22 14 4D 04 8863  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
04301B 3E B7       8864  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
04301D 32 40 4D 04 8865  			LD      (LISTON),A
043021 21 5C 30 04 8866  			LD      HL,NOTICE
043025 22 2F 4D 04 8867  			LD      (ERRTXT),HL
043029 CD 6C 38 04 8868  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
04302D 3A 00 4A 04 8869  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043031 B7          8870  			OR	A
043032 C2 53 0B 04 8871  			JP	NZ,CHAIN0		; Yes, so load and run
043036 CD 38 40 04 8872  			CALL	STAR_VERSION		;
04303A CD 90 3D 04 8873  			CALL    TELL			; Output the welcome message
04303E 42 42 43 20 8874  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
04305C 28 43 29 20 8875  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
04307C 0A 0D 00    8876  			DB	"\n\r", 0
04307F             8877  ;
04307F F6          8878  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
043080             8879  ;
043080             8880  ; This is the main entry point for BASIC
043080             8881  ;
043080 37          8882  CLOOP:			SCF				; See above - not sure why this is here!
043081 ED 7B 20 4D 8883  			LD      SP,(HIMEM)
       04          
043086 CD FA 3E 04 8884  			CALL    PROMPT          	; Prompt user
04308A 21 40 4D 04 8885  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
04308E 7E          8886  			LD      A,(HL)			; Fetch the value
04308F E6 0F       8887  			AND     0FH             	; Bottom nibble: LISTO
043091 F6 B0       8888  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
043093 77          8889  			LD      (HL),A			; Store back in
043094 ED 62       8890  			SBC     HL,HL           	; HL: 0
043096 22 2C 4D 04 8891  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
04309A 22 35 4D 04 8892  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
04309E             8893  ;
04309E 2A 29 4D 04 8894  			LD      HL,(AUTONO)		; Get the auto line number
0430A2 22 23 4D 04 8895  			LD      (LINENO),HL		; Store in line number
0430A6 7C          8896  			LD      A,H			; If the auto line number is zero then
0430A7 B5          8897  			OR      L
0430A8 28 1E       8898  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430AA             8899  ;
0430AA             8900  ; This section handles auto line numbering
0430AA             8901  ;
0430AA E5          8902  			PUSH    HL			; Stack the line number
0430AB CD FB 39 04 8903  			CALL    PBCD           	 	; Output the line number
0430AF E1          8904  			POP     HL			; Pop the line number back off the stack
0430B0             8905  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0430B0             8906  ;			LD      B,0			; So clear B
0430B0 01 00 00 00 8907  			LD	BC, 0			; Load BC with Increment
0430B4 3A 41 4D 04 8908  			LD	A,(INCREM)
0430B8 4F          8909  			LD	C, A
0430B9 09          8910  			ADD     HL,BC			; Add the increment to the line number
0430BA DA 25 3C 04 8911  			JP      C,TOOBIG		; And error if we wrap
0430BE 22 29 4D 04 8912  			LD      (AUTONO),HL		; Store the new auto line number
0430C2 3E 20       8913  			LD      A,' '			; Print a space
0430C4 CD 4F 39 04 8914  			CALL    OUTCHR
0430C8             8915  ;
0430C8             8916  ; This section invokes the line editor
0430C8             8917  ;
0430C8 21 00 4A 04 8918  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0430CC CD 5F 3E 04 8919  			CALL    OSLINE          	; Call the line editor in MOS
0430D0 CD DC 30 04 8920  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0430D4 DC 3F 38 04 8921  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0430D8 C3 80 30 04 8922  			JP      CLOOP			; Jump back to immediate mode
0430DC             8923  ;
0430DC             8924  ; This bit enters the line into memory
0430DC             8925  ; Also called from OSLOAD_TXT
0430DC             8926  ; Returns:
0430DC             8927  ; F: C if a new line has been entered (CLEAN will need to be called)
0430DC             8928  ;
0430DC AF          8929  ONEDIT1:		XOR     A			; Entry point after *EDIT
0430DD 32 3D 4D 04 8930  			LD      (COUNT),A
0430E1 FD 21 00 4A 8931  			LD      IY,ACCS
       04          
0430E6 CD F9 3B 04 8932  			CALL    LINNUM			; HL: The line number from the input buffer
0430EA CD 70 0A 04 8933  			CALL    NXT			; Skip spaces
0430EE 7C          8934  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0430EF B5          8935  			OR      L
0430F0 28 04       8936  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0430F2 22 23 4D 04 8937  			LD      (LINENO),HL		; Otherwise store it
0430F6             8938  ;
0430F6             8939  ; This bit does the lexical analysis and tokenisation
0430F6             8940  ;
0430F6 0E 01       8941  LNZERO:			LD	C,1			; Left mode
0430F8 11 00 4B 04 8942  			LD      DE,BUFFER		; Buffer for tokenised BASIC
0430FC CD 9F 3C 04 8943  			CALL    LEXAN2          	; Lexical analysis on the user input
043100 12          8944  			LD      (DE),A          	; Terminator
043101 AF          8945  			XOR     A
043102             8946  ;			LD      B,A
043102             8947  ;			LD      C,E             	; BC: Line length
043102 01 00 00 00 8948  			LD	BC,0
043106 4B          8949  			LD	C,E			; BC: Line length
043107 13          8950  			INC     DE
043108 12          8951  			LD      (DE),A          	; Zero next
043109 2A 23 4D 04 8952  			LD      HL,(LINENO)		; Get the line number
04310D 7C          8953  			LD      A,H			; Is it zero, i.e. a command with no line number?
04310E B5          8954  			OR      L
04310F FD 21 00 4B 8955  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
043114 CA 96 0B 04 8956  			JP      Z,XEQ           	; Execute it
043118             8957  ;
043118             8958  ; This section stores the BASIC line in memory
043118             8959  ;
043118 C5          8960  			PUSH    BC
043119 E5          8961  			PUSH    HL
04311A CD 4B 38 04 8962  			CALL    SETTOP          	; Set TOP sysvar
04311E E1          8963  			POP     HL
04311F CD 8F 39 04 8964  			CALL    FINDL			; Find the address of the line
043123 CC 02 38 04 8965  			CALL    Z,DEL			; Delete the existing line if found
043127 C1          8966  			POP     BC
043128 79          8967  			LD      A,C			; Check for the line length being zero, i.e.
043129 B7          8968  			OR      A			; the user has just entered a line number in the command line
04312A C8          8969  			RET	Z 	         	; If so, then don't do anything else
04312B C6 04       8970  			ADD     A,4
04312D 4F          8971  			LD      C,A             	; Length inclusive
04312E D5          8972  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
04312F C5          8973  			PUSH    BC              	; BC: Line length
043130 EB          8974  			EX      DE,HL			; DE: Address of the line in memory
043131 2A 17 4D 04 8975  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043135 E5          8976  			PUSH    HL			; Stack TOP (current TOP value)
043136 09          8977  			ADD     HL,BC			; Add the line length to HL, the new TOP value
043137 E5          8978  			PUSH    HL			; Stack HL (new TOP value)
043138 24          8979  			INC     H			; Add 256 to HL
043139 AF          8980  			XOR     A
04313A ED 72       8981  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04313C E1          8982  			POP     HL			; Pop HL (new TOP value)
04313D D2 60 37 04 8983  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043141 22 17 4D 04 8984  			LD      (TOP),HL		; Store new value of TOP
043145 E3          8985  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043146 E5          8986  			PUSH    HL			; PUSH current TOP value
043147 23          8987  			INC     HL
043148 B7          8988  			OR      A
043149 ED 52       8989  			SBC     HL,DE			; DE: Address of the line in memory
04314B 44          8990  			LD      B,H             	; BC: Amount to move
04314C 4D          8991  			LD      C,L
04314D E1          8992  			POP     HL			; HL: Destination (current TOP value)
04314E D1          8993  			POP     DE			; DE: Source (new TOP value)
04314F 28 02       8994  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043151 ED B8       8995  			LDDR                    	; Otherwise, make space for the new line in the program
043153 C1          8996  ATEND:			POP     BC              	; BC: Line length
043154 D1          8997  			POP     DE              	; DE: Line number
043155 23          8998  			INC     HL			; HL: Destination address
043156 71          8999  			LD      (HL),C          	; Store length
043157 23          9000  			INC     HL
043158 73          9001  			LD      (HL),E          	; Store line number
043159 23          9002  			INC     HL
04315A 72          9003  			LD      (HL),D
04315B 23          9004  			INC     HL
04315C 11 00 4B 04 9005  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
043160 EB          9006  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043161 0D          9007  			DEC     C			; Subtract 3 from the number of bytes to copy to
043162 0D          9008  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
043163 0D          9009  			DEC     C
043164 ED B0       9010  			LDIR                    	; Add the line to the BASIC program
043166 37          9011  			SCF				; To flag we need to call CLEAN
043167 C9          9012  			RET
043168             9013  ;
043168             9014  ; List of tokens and keywords. If a keyword is followed by 0 then
043168             9015  ; it will only match with the keyword followed immediately by
043168             9016  ; a delimiter
043168             9017  ;
043168 80 41 4E 44 9018  KEYWDS:			DB    80H, "AND"
04316C 94 41 42 53 9019  			DB    94H, "ABS"
043170 95 41 43 53 9020  			DB    95H, "ACS"
043174 96 41 44 56 9021  			DB    96H, "ADVAL"
       41 4C       
04317A 97 41 53 43 9022  			DB    97H, "ASC"
04317E 98 41 53 4E 9023  			DB    98H, "ASN"
043182 99 41 54 4E 9024  			DB    99H, "ATN"
043186 C6 41 55 54 9025  			DB    C6H, "AUTO"
       4F          
04318B 9A 42 47 45 9026  			DB    9AH, "BGET", 0
       54 00       
043191 D5 42 50 55 9027  			DB    D5H, "BPUT", 0
       54 00       
043197 FB 43 4F 4C 9028  			DB    FBH, "COLOUR"
       4F 55 52    
04319E FB 43 4F 4C 9029  			DB    FBH, "COLOR"
       4F 52       
0431A4 D6 43 41 4C 9030  			DB    D6H, "CALL"
       4C          
0431A9 D7 43 48 41 9031  			DB    D7H, "CHAIN"
       49 4E       
0431AF BD 43 48 52 9032  			DB    BDH, "CHR$"
       24          
0431B4 D8 43 4C 45 9033  			DB    D8H, "CLEAR", 0
       41 52 00    
0431BB D9 43 4C 4F 9034  			DB    D9H, "CLOSE", 0
       53 45 00    
0431C2 DA 43 4C 47 9035  			DB    DAH, "CLG", 0
       00          
0431C7 DB 43 4C 53 9036  			DB    DBH, "CLS", 0
       00          
0431CC 9B 43 4F 53 9037  			DB    9BH, "COS"
0431D0 9C 43 4F 55 9038  			DB    9CH, "COUNT", 0
       4E 54 00    
0431D7 DC 44 41 54 9039  			DB    DCH, "DATA"
       41          
0431DC 9D 44 45 47 9040  			DB    9DH, "DEG"
0431E0 DD 44 45 46 9041  			DB    DDH, "DEF"
0431E4 C7 44 45 4C 9042  			DB    C7H, "DELETE"
       45 54 45    
0431EB 81 44 49 56 9043  			DB    81H, "DIV"
0431EF DE 44 49 4D 9044  			DB    DEH, "DIM"
0431F3 DF 44 52 41 9045  			DB    DFH, "DRAW"
       57          
0431F8 E1 45 4E 44 9046  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043201 E0 45 4E 44 9047  			DB    E0H, "END", 0
       00          
043206 E2 45 4E 56 9048  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
04320F 8B 45 4C 53 9049  			DB    8BH, "ELSE"
       45          
043214 A0 45 56 41 9050  			DB    A0H, "EVAL"
       4C          
043219 9E 45 52 4C 9051  			DB    9EH, "ERL", 0
       00          
04321E 85 45 52 52 9052  			DB    85H, "ERROR"
       4F 52       
043224 C5 45 4F 46 9053  			DB    C5H, "EOF", 0
       00          
043229 82 45 4F 52 9054  			DB    82H, "EOR"
04322D 9F 45 52 52 9055  			DB    9FH, "ERR", 0
       00          
043232 A1 45 58 50 9056  			DB    A1H, "EXP"
043236 A2 45 58 54 9057  			DB    A2H, "EXT", 0
       00          
04323B E3 46 4F 52 9058  			DB    E3H, "FOR"
04323F A3 46 41 4C 9059  			DB    A3H, "FALSE", 0
       53 45 00    
043246 A4 46 4E    9060  			DB    A4H, "FN"
043249 E5 47 4F 54 9061  			DB    E5H, "GOTO"
       4F          
04324E BE 47 45 54 9062  			DB    BEH, "GET$"
       24          
043253 A5 47 45 54 9063  			DB    A5H, "GET"
043257 E4 47 4F 53 9064  			DB    E4H, "GOSUB"
       55 42       
04325D E6 47 43 4F 9065  			DB    E6H, "GCOL"
       4C          
043262 93 48 49 4D 9066  			DB    93H, "HIMEM", 0
       45 4D 00    
043269 E8 49 4E 50 9067  			DB    E8H, "INPUT"
       55 54       
04326F E7 49 46    9068  			DB    E7H, "IF"
043272 BF 49 4E 4B 9069  			DB    BFH, "INKEY$"
       45 59 24    
043279 A6 49 4E 4B 9070  			DB    A6H, "INKEY"
       45 59       
04327F A8 49 4E 54 9071  			DB    A8H, "INT"
043283 A7 49 4E 53 9072  			DB    A7H, "INSTR("
       54 52 28    
04328A C9 4C 49 53 9073  			DB    C9H, "LIST"
       54          
04328F 86 4C 49 4E 9074  			DB    86H, "LINE"
       45          
043294 C8 4C 4F 41 9075  			DB    C8H, "LOAD"
       44          
043299 92 4C 4F 4D 9076  			DB    92H, "LOMEM", 0
       45 4D 00    
0432A0 EA 4C 4F 43 9077  			DB    EAH, "LOCAL"
       41 4C       
0432A6 C0 4C 45 46 9078  			DB    C0H, "LEFT$("
       54 24 28    
0432AD A9 4C 45 4E 9079  			DB    A9H, "LEN"
0432B1 E9 4C 45 54 9080  			DB    E9H, "LET"
0432B5 AB 4C 4F 47 9081  			DB    ABH, "LOG"
0432B9 AA 4C 4E    9082  			DB    AAH, "LN"
0432BC C1 4D 49 44 9083  			DB    C1H, "MID$("
       24 28       
0432C2 EB 4D 4F 44 9084  			DB    EBH, "MODE"
       45          
0432C7 83 4D 4F 44 9085  			DB    83H, "MOD"
0432CB EC 4D 4F 56 9086  			DB    ECH, "MOVE"
       45          
0432D0 ED 4E 45 58 9087  			DB    EDH, "NEXT"
       54          
0432D5 CA 4E 45 57 9088  			DB    CAH, "NEW", 0
       00          
0432DA AC 4E 4F 54 9089  			DB    ACH, "NOT"
0432DE CB 4F 4C 44 9090  			DB    CBH, "OLD", 0
       00          
0432E3 EE 4F 4E    9091  			DB    EEH, "ON"
0432E6 87 4F 46 46 9092  			DB    87H, "OFF"
0432EA 84 4F 52    9093  			DB    84H, "OR"
0432ED 8E 4F 50 45 9094  			DB    8EH, "OPENIN"
       4E 49 4E    
0432F4 AE 4F 50 45 9095  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0432FC AD 4F 50 45 9096  			DB    ADH, "OPENUP"
       4E 55 50    
043303 FF 4F 53 43 9097  			DB    FFH, "OSCLI"
       4C 49       
043309 F1 50 52 49 9098  			DB    F1H, "PRINT"
       4E 54       
04330F 90 50 41 47 9099  			DB    90H, "PAGE", 0
       45 00       
043315 8F 50 54 52 9100  			DB    8FH, "PTR", 0
       00          
04331A AF 50 49 00 9101  			DB    AFH, "PI", 0
04331E F0 50 4C 4F 9102  			DB    F0H, "PLOT"
       54          
043323 B0 50 4F 49 9103  			DB    B0H, "POINT("
       4E 54 28    
04332A F2 50 52 4F 9104  			DB    F2H, "PROC"
       43          
04332F B1 50 4F 53 9105  			DB    B1H, "POS", 0
       00          
043334 CE 50 55 54 9106  			DB    CEH, "PUT"
043338 F8 52 45 54 9107  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043340 F5 52 45 50 9108  			DB    F5H, "REPEAT"
       45 41 54    
043347 F6 52 45 50 9109  			DB    F6H, "REPORT", 0
       4F 52 54 00 
04334F F3 52 45 41 9110  			DB    F3H, "READ"
       44          
043354 F4 52 45 4D 9111  			DB    F4H, "REM"
043358 F9 52 55 4E 9112  			DB    F9H, "RUN", 0
       00          
04335D B2 52 41 44 9113  			DB    B2H, "RAD"
043361 F7 52 45 53 9114  			DB    F7H, "RESTORE"
       54 4F 52 45 
043369 C2 52 49 47 9115  			DB    C2H, "RIGHT$("
       48 54 24 28 
043371 B3 52 4E 44 9116  			DB    B3H, "RND", 0
       00          
043376 CC 52 45 4E 9117  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
04337F 88 53 54 45 9118  			DB    88H, "STEP"
       50          
043384 CD 53 41 56 9119  			DB    CDH, "SAVE"
       45          
043389 B4 53 47 4E 9120  			DB    B4H, "SGN"
04338D B5 53 49 4E 9121  			DB    B5H, "SIN"
043391 B6 53 51 52 9122  			DB    B6H, "SQR"
043395 89 53 50 43 9123  			DB    89H, "SPC"
043399 C3 53 54 52 9124  			DB    C3H, "STR$"
       24          
04339E C4 53 54 52 9125  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433A7 D4 53 4F 55 9126  			DB    D4H, "SOUND"
       4E 44       
0433AD FA 53 54 4F 9127  			DB    FAH, "STOP", 0
       50 00       
0433B3 B7 54 41 4E 9128  			DB    B7H, "TAN"
0433B7 8C 54 48 45 9129  			DB    8CH, "THEN"
       4E          
0433BC B8 54 4F    9130  			DB    B8H, "TO"
0433BF 8A 54 41 42 9131  			DB    8AH, "TAB("
       28          
0433C4 FC 54 52 41 9132  			DB    FCH, "TRACE"
       43 45       
0433CA 91 54 49 4D 9133  			DB    91H, "TIME", 0
       45 00       
0433D0 B9 54 52 55 9134  			DB    B9H, "TRUE", 0
       45 00       
0433D6 FD 55 4E 54 9135  			DB    FDH, "UNTIL"
       49 4C       
0433DC BA 55 53 52 9136  			DB    BAH, "USR"
0433E0 EF 56 44 55 9137  			DB    EFH, "VDU"
0433E4 BB 56 41 4C 9138  			DB    BBH, "VAL"
0433E8 BC 56 50 4F 9139  			DB    BCH, "VPOS", 0
       53 00       
0433EE FE 57 49 44 9140  			DB    FEH, "WIDTH"
       54 48       
0433F4 D3 48 49 4D 9141  			DB    D3H, "HIMEM"
       45 4D       
0433FA D2 4C 4F 4D 9142  			DB    D2H, "LOMEM"
       45 4D       
043400 D0 50 41 47 9143  			DB    D0H, "PAGE"
       45          
043405 CF 50 54 52 9144  			DB    CFH, "PTR"
043409 D1 54 49 4D 9145  			DB    D1H, "TIME"
       45          
04340E             9146  ;
04340E             9147  ; These are indexed from the ERRWDS table
04340E             9148  ;
04340E 01 4D 69 73 9149  			DB    01H, "Missing "
       73 69 6E 67 
       20          
043417 02 4E 6F 20 9150  			DB    02H, "No such "
       73 75 63 68 
       20          
043420 03 42 61 64 9151  			DB    03H, "Bad "
       20          
043425 04 20 72 61 9152  			DB    04H, " range"
       6E 67 65    
04342C 05 76 61 72 9153  			DB    05H, "variable"
       69 61 62 6C 
       65          
043435 06 4F 75 74 9154  			DB    06H, "Out of"
       20 6F 66    
04343C 07 4E 6F 20 9155  			DB    07H, "No "
043440 08 20 73 70 9156  			DB    08H, " space"
       61 63 65    
043447             9157  
043447             9158  KEYWDL:			EQU     $-KEYWDS
043447 FF FF       9159  			DW    -1
043449             9160  ;
043449             9161  ; Error messages
043449             9162  ;
043449 07 72 6F 6F 9163  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
04344F 06 04 00    9164  			DB    6, 4, 0			;  1: Out of range
043452 00          9165  			DB    0				;  2: *
043453 00          9166  			DB    0				;  3: *
043454 4D 69 73 74 9167  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
04345C 01 2C 00    9168  			DB    1, ",", 0			;  5: Missing ,
04345F 54 79 70 65 9169  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
04346D 07 A4 00    9170  			DB    7, FN, 0			;  7: No FN
043470 00          9171  			DB    0				;  8: *
043471 01 22 00    9172  			DB    1, 34, 0			;  9: Missing "
043474 03 DE 00    9173  			DB    3, DIM, 0			; 10: Bad DIM
043477 DE 08 00    9174  			DB    DIM, 8, 0			; 11: DIM space
04347A 4E 6F 74 20 9175  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
043480 07 F2 00    9176  			DB    7, PROC, 0		; 13: No PROC
043483 41 72 72 61 9177  			DB    "Array", 0		; 14: Array
       79 00       
043489 53 75 62 73 9178  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
043493 53 79 6E 74 9179  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434A0 45 73 63 61 9180  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434A7 44 69 76 69 9181  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0434B8 53 74 72 69 9182  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0434C8 54 6F 6F 20 9183  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
0434D0 2D 76 65 20 9184  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
0434D9 4C 6F 67 04 9185  			DB    "Log", 4, 0		; 22: Log range
       00          
0434DE 41 63 63 75 9186  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
0434EC 45 78 70 04 9187  			DB    "Exp", 4, 0		; 24: Exp range
       00          
0434F1 00          9188  			DB    0				; 25: *
0434F2 02 05 00    9189  			DB    2, 5, 0			; 26: No such variable
0434F5 01 29 00    9190  			DB    1, ")", 0			; 27: Missing )
0434F8 03 48 45 58 9191  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
0434FD 02 A4 2F F2 9192  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043502 03 63 61 6C 9193  			DB    3, "call", 0		; 30: Bad call
       6C 00       
043508 41 72 67 75 9194  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043512 07 E3 00    9195  			DB    7, FOR, 0			; 32: No FOR
043515 43 61 6E 27 9196  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043523 E3 20 05 00 9197  			DB    FOR, " ", 5, 0		; 34: FOR variable
043527 00          9198  			DB    0				; 35: *
043528 07 B8 00    9199  			DB    7, TO_MN, 0			; 36: No TO
04352B 00          9200  			DB    0				; 37: *
04352C 07 E4 00    9201  			DB    7, GOSUB, 0		; 38: No GOSUB
04352F EE 20 73 79 9202  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
043538 EE 04 00    9203  			DB    ON_, 4, 0			; 40: ON range
04353B 02 6C 69 6E 9204  			DB    2, "line", 0		; 41: No such line
       65 00       
043541 06 20 DC 00 9205  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
043545 07 F5 00    9206  			DB    7, REPEAT, 0		; 43: No REPEAT
043548 00          9207  			DB    0				; 44: *
043549 01 23 00    9208  			DB    1, "#", 0			; 45: Missing #
04354C             9209  ;
04354C             9210  ; COMMANDS:
04354C             9211  ;
04354C             9212  ; DELETE line,line
04354C             9213  ;
04354C CD 4B 38 04 9214  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
043550 CD 53 3C 04 9215  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043554 7E          9216  DELET1:			LD      A,(HL)			; Check whether it's the last line
043555 B7          9217  			OR      A
043556 CA DD 35 04 9218  			JP      Z,WARMNC		; Yes, so do nothing
04355A 23          9219  			INC     HL			; Skip the line length byte
04355B 11 00 00 00 9220  			LD	DE, 0			; Clear DE
04355F 5E          9221  			LD      E,(HL)			; Fetch the line number in DE
043560 23          9222  			INC     HL
043561 56          9223  			LD      D,(HL)
043562 7A          9224  			LD      A,D			; If the line number is zero then
043563 B3          9225  			OR      E
043564 28 1D       9226  			JR      Z,CLOOP1        	; Do nothing
043566 2B          9227  			DEC     HL			; Decrement BASIC program pointer back to length
043567 2B          9228  			DEC     HL
043568 EB          9229  			EX      DE,HL			; Check if we've gone past the terminating line
043569 37          9230  			SCF
04356A ED 42       9231  			SBC     HL,BC
04356C EB          9232  			EX      DE,HL
04356D 30 6E       9233  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04356F C5          9234  			PUSH    BC
043570 CD 02 38 04 9235  			CALL    DEL			; Delete the line pointed to by HL
043574 C1          9236  			POP     BC
043575 18 DD       9237  			JR      DELET1			; And loop round to the next line
043577             9238  ;
043577             9239  ; LISTO expr
043577             9240  ;
043577 FD 23       9241  LISTO:			INC     IY              	; Skip "O" byte
043579 CD 0A 03 04 9242  			CALL    EXPRI			; Get expr
04357D D9          9243  			EXX
04357E 7D          9244  			LD      A,L
04357F 32 40 4D 04 9245  			LD      (LISTON),A		; Store in LISTON sysvar
043583 C3 80 30 04 9246  CLOOP1:			JP      CLOOP
043587             9247  ;
043587             9248  ; LIST
043587             9249  ; LIST line
043587             9250  ; LIST line,line [IF string]
043587             9251  ; LIST ,line
043587             9252  ; LIST line,
043587             9253  ;
043587 FE 4F       9254  LIST_:			CP      'O'			; Check for O (LISTO)
043589 28 EC       9255  			JR      Z,LISTO			; and jump to LISTO if zero
04358B CD 53 3C 04 9256  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04358F CD 70 0A 04 9257  			CALL    NXT			; Skip space
043593 FE E7       9258  			CP      TIF             	; Check for IF clause (token IF)
043595 3E 00       9259  			LD      A,0             	; Initialise the IF clause string length
043597 20 17       9260  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
043599             9261  ;
043599 FD 23       9262  			INC     IY              	; Skip the IF token
04359B CD 70 0A 04 9263  			CALL    NXT             	; And skip any spaces
04359F EB          9264  			EX      DE,HL			; DE: Address in memory
0435A0 FD E5       9265  			PUSH    IY			; LD IY, HL
0435A2 E1          9266  			POP     HL              	; HL is now the address of the tokenised line
0435A3 3E 0D       9267  			LD      A,CR
0435A5 C5          9268  			PUSH    BC			; Stack the second line number arg
0435A6 01 00 01 00 9269  			LD      BC,256
0435AA ED B1       9270  			CPIR                    	; Locate CR byte
0435AC 79          9271  			LD      A,C
0435AD 2F          9272  			CPL                    	 	; A: Substring length (of IF clause)
0435AE C1          9273  			POP     BC			; Restore the second line number arg
0435AF EB          9274  			EX      DE,HL			; HL: Address in memory
0435B0             9275  ;
0435B0 5F          9276  LISTB:			LD      E,A             	; E: IF clause string length
0435B1 78          9277  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0435B2 B1          9278  			OR      C
0435B3 20 01       9279  			JR      NZ,LISTA		; If there isn't a second line number
0435B5 0B          9280  			DEC     BC			; then we set it to the maximum of 65535
0435B6             9281  ;
0435B6 D9          9282  LISTA:			EXX
0435B7 DD 21 40 4D 9283  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
0435BC 01 00 00 00 9284  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435C0 D9          9285  			EXX
0435C1 3E 14       9286  			LD      A,20			; Number of lines to list
0435C3             9287  ;
0435C3 C5          9288  LISTC:			PUSH    BC              	; Save second line number
0435C4 D5          9289  			PUSH    DE              	; Save IF clause length
0435C5 E5          9290  			PUSH    HL              	; Save BASIC program counter
0435C6 08          9291  			EX      AF,AF'
0435C7             9292  ;
0435C7             9293  ; BBC BASIC for Z80 lines are stored as follows:
0435C7             9294  ;
0435C7             9295  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0435C7             9296  ; - [&00] [&FF] [&FF]: End of program marker
0435C7             9297  ;
0435C7             9298  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0435C7             9299  ;
0435C7 7E          9300  			LD      A,(HL)			; Check for end of program marker
0435C8 B7          9301  			OR      A			; If found
0435C9 28 12       9302  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0435CB             9303  ;
0435CB             9304  ; Check if past terminating line number
0435CB             9305  ;
0435CB 7B          9306  			LD      A,E             	; A: IF clause length
0435CC 23          9307  			INC     HL			; Skip the length byte
0435CD 11 00 00 00 9308  			LD	DE,0			; Clear DE
0435D1 5E          9309  			LD      E,(HL)			; Fetch the line number in DE
0435D2 23          9310  			INC     HL
0435D3 56          9311  			LD      D,(HL)
0435D4 2B          9312  			DEC     HL			; Step HL back to the length byte
0435D5 2B          9313  			DEC     HL
0435D6 D5          9314  			PUSH    DE             	 	; Push the line number on the stack
0435D7 EB          9315  			EX      DE,HL			; HL: line number
0435D8 37          9316  			SCF				; Do a 16-bit compare of HL and DE
0435D9 ED 42       9317  			SBC     HL,BC
0435DB EB          9318  			EX      DE,HL
0435DC D1          9319  			POP     DE              	; Restore the line number
0435DD D2 7F 30 04 9320  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0435E1 4E          9321  			LD      C,(HL)          	; C: Line length + 4
0435E2 47          9322  			LD      B,A             	; B: IF clause length
0435E3             9323  ;
0435E3             9324  ; Check if "UNLISTABLE":
0435E3             9325  ;
0435E3 7A          9326  			LD      A,D			; TODO: What is "UNLISTABLE?"
0435E4 B3          9327  			OR      E
0435E5 CA 80 30 04 9328  			JP      Z,CLOOP
0435E9             9329  ;
0435E9             9330  ; Check for IF clause:
0435E9             9331  ;
0435E9 23          9332  			INC     HL			; Skip the length
0435EA 23          9333  			INC     HL			; Skip the line number
0435EB 23          9334  			INC     HL              	; HL: Address of the tokenised BASIC line
0435EC 0D          9335  			DEC     C			;  C: Line length
0435ED 0D          9336  			DEC     C
0435EE 0D          9337  			DEC     C
0435EF 0D          9338  			DEC     C
0435F0 D5          9339  			PUSH    DE              	; Save the line number
0435F1 E5          9340  			PUSH    HL              	; Save the BASIC program address
0435F2 AF          9341  			XOR     A               	;
0435F3 B8          9342  			CP      B              	 	; Check for an IF clause (B!=0)
0435F4 FD E5       9343  			PUSH    IY			; LD IY, DE
0435F6 D1          9344  			POP     DE              	; DE: Address of the IF clause string in the input buffer
0435F7 C4 85 07 04 9345  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0435FB E1          9346  			POP     HL              	; Restore BASIC program address
0435FC D1          9347  			POP     DE              	; Restore line number
0435FD FD E5       9348  			PUSH    IY
0435FF CC 92 38 04 9349  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043603 FD E1       9350  			POP     IY
043605             9351  ;
043605 08          9352  			EX      AF,AF'
043606 3D          9353  			DEC     A			; Decrement line list counter
043607 CD 71 3F 04 9354  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
04360B E1          9355  			POP     HL             	 	; Restore BASIC program address to beginning of line
04360C 11 00 00 00 9356  			LD	DE,0
043610 5E          9357  			LD      E,(HL)			; Fetch the length of line in DE
043611 19          9358  			ADD     HL,DE           	; Go to the next line
043612 D1          9359  			POP     DE              	; Restore IF clause length
043613 C1          9360  			POP     BC              	; Restore second line number
043614 18 AD       9361  			JR      LISTC			; Loop back to do next line
043616             9362  ;
043616             9363  ; RENUMBER
043616             9364  ; RENUMBER start
043616             9365  ; RENUMBER start,increment
043616             9366  ; RENUMBER ,increment
043616             9367  ;
043616 CD 76 38 04 9368  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04361A CD 2B 3C 04 9369  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04361E D9          9370  			EXX
04361F 2A 14 4D 04 9371  			LD      HL,(PAGE_)		; HL: Top of program
043623 ED 5B 1A 4D 9372  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
043628             9373  ;
043628             9374  ; Build the table
043628             9375  ;
043628 7E          9376  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043629 B7          9377  			OR      A			; Is it zero, i.e. the end of program marker?
04362A 28 36       9378  			JR      Z,RENUM2		; Yes, so skip to the next part
04362C 23          9379  			INC     HL
04362D 4E          9380  			LD      C,(HL)          	; BC: The OLD line number
04362E 23          9381  			INC     HL
04362F 46          9382  			LD      B,(HL)
043630 78          9383  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043631 B1          9384  			OR      C
043632 CA 80 30 04 9385  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043636 EB          9386  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043637 71          9387  			LD      (HL),C			; Store the OLD line number in the heap
043638 23          9388  			INC     HL
043639 70          9389  			LD      (HL),B
04363A 23          9390  			INC     HL
04363B D9          9391  			EXX				; HL: line number, BC: increment (16-bit values)
04363C E5          9392  			PUSH    HL			; HL: Stack the NEW line number value
04363D 52 09       9393  			ADD.S   HL,BC           	; Add the increment
04363F DA 25 3C 04 9394  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043643 D9          9395  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
043644 C1          9396  			POP     BC			; BC: Pop the NEW line number value off the stack
043645 71          9397  			LD      (HL),C			; Store the NEW line number in the heap
043646 23          9398  			INC     HL
043647 70          9399  			LD      (HL),B
043648 23          9400  			INC     HL
043649 EB          9401  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
04364A 2B          9402  			DEC     HL			; Back up to the line length byte
04364B 2B          9403  			DEC     HL
04364C 01 00 00 00 9404  			LD	BC, 0
043650 4E          9405  			LD      C,(HL)			; BC: Line length
043651 09          9406  			ADD	HL,BC           	; Advance HL to next line
043652 EB          9407  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043653 E5          9408  			PUSH    HL
043654 24          9409  			INC     H			; Increment to next page
043655 ED 72       9410  			SBC     HL,SP			; Subtract from SP
043657 E1          9411  			POP     HL
043658 EB          9412  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043659 38 CD       9413  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
04365B CD 77 37 04 9414  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04365F CC          9415  			DB    	REN
043660 08          9416  			DB    	8
043661 00          9417  			DB    	0
043662             9418  ;
043662             9419  ; At this point a list of BASIC line numbers have been written to the heap
043662             9420  ; as word pairs:
043662             9421  ; - DW: The OLD line number
043662             9422  ; - DW: The NEW line number
043662             9423  ;
043662 EB          9424  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
043663 36 FF       9425  			LD      (HL),-1			; Mark the end with FFFFh
043665 23          9426  			INC     HL
043666 36 FF       9427  			LD      (HL),-1
043668 ED 5B 1A 4D 9428  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
04366D D9          9429  			EXX
04366E 2A 14 4D 04 9430  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
043672 4E          9431  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
043673 79          9432  			LD      A,C			; If it is zero, then no program, so...
043674 B7          9433  			OR      A
043675 CA 7F 30 04 9434  			JP      Z,WARM			; Jump to warm start
043679 D9          9435  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
04367A EB          9436  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
04367B 23          9437  			INC     HL			; Skip to the NEW line number
04367C 23          9438  			INC     HL
04367D 5E          9439  			LD      E,(HL)			; DE: The NEW line number
04367E 23          9440  			INC     HL
04367F 56          9441  			LD      D,(HL)
043680 23          9442  			INC     HL
043681 D5          9443  			PUSH    DE			; Stack the NEW line number
043682 EB          9444  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
043683 22 23 4D 04 9445  			LD      (LINENO),HL		; Store the line number in LINENO
043687 D9          9446  			EXX				; HL: Pointer to the BASIC program area
043688 D1          9447  			POP     DE			; DE: The NEW line number
043689 23          9448  			INC     HL
04368A 73          9449  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
04368B 23          9450  			INC     HL
04368C 72          9451  			LD      (HL),D
04368D 23          9452  			INC     HL
04368E 0D          9453  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
04368F 0D          9454  			DEC     C
043690 0D          9455  			DEC     C
043691 79          9456  			LD	A,C
043692 01 00 00 00 9457  			LD	BC,0
043696 4F          9458  			LD	C,A			; BC: Line length
043697             9459  ;
043697 3E 8D       9460  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
043699 ED B1       9461  			CPIR                    	; Search for the token
04369B 20 D5       9462  			JR      NZ,RENUM3		; If not found, then loop to process the next line
04369D             9463  ;
04369D             9464  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
04369D             9465  ;
04369D C5          9466  			PUSH    BC			; Stack everything
04369E E5          9467  			PUSH    HL
04369F E5          9468  			PUSH    HL			; HL: Pointer to encoded line number
0436A0 FD E1       9469  			POP     IY			; IY: Pointer to encoded line number
0436A2 D9          9470  			EXX
0436A3 CD E6 08 04 9471  			CALL    DECODE			; Decode the encoded line number (in HL')
0436A7 D9          9472  			EXX				; HL: Decoded line number
0436A8 44          9473  			LD      B,H			; BC: Decoded line number
0436A9 4D          9474  			LD      C,L
0436AA 2A 1A 4D 04 9475  			LD      HL,(LOMEM)		; HL: Pointer to heap
0436AE             9476  ;
0436AE             9477  ; This section of code cross-references the decoded (OLD) line number with the list
0436AE             9478  ; created previously in the global heap
0436AE             9479  ;
0436AE 5E          9480  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436AF 23          9481  			INC     HL
0436B0 56          9482  			LD      D,(HL)
0436B1 23          9483  			INC     HL
0436B2 EB          9484  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436B3 B7          9485  			OR      A               	; Clear the carry and...
0436B4 52 ED 42    9486  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436B7 EB          9487  			EX      DE,HL			; HL: Pointer in the global heap
0436B8 5E          9488  			LD      E,(HL)          	; DE: The NEW line number
0436B9 23          9489  			INC     HL
0436BA 56          9490  			LD      D,(HL)
0436BB 23          9491  			INC     HL
0436BC 38 F0       9492  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436BE EB          9493  			EX      DE,HL			; DE: Pointer in the global heap
0436BF 28 1D       9494  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436C1             9495  ;
0436C1 CD 90 3D 04 9496  			CALL    TELL			; Display this error if the line number is not found
0436C5 46 61 69 6C 9497  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0436CF 00          9498  			DB    	0
0436D0 2A 23 4D 04 9499  			LD      HL,(LINENO)
0436D4 CD F7 39 04 9500  			CALL    PBCDL
0436D8 CD 47 39 04 9501  			CALL    CRLF
0436DC 18 07       9502  			JR      RENUM6			; And carry on renumbering
0436DE             9503  ;
0436DE             9504  ; This snippet re-encodes the line number in the BASIC program
0436DE             9505  ;
0436DE D1          9506  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0436DF D5          9507  			PUSH    DE
0436E0 1B          9508  			DEC     DE			; Back up a byte to the LINO token
0436E1 CD 5C 3D 04 9509  			CALL    ENCODE          	; Re-write the new line number out
0436E5 E1          9510  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0436E6 C1          9511  			POP     BC			; BC: The remaining line length
0436E7 18 AE       9512  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0436E9             9513  ;
0436E9             9514  ; AUTO
0436E9             9515  ; AUTO start,increment
0436E9             9516  ; AUTO start
0436E9             9517  ; AUTO ,increment
0436E9             9518  ;
0436E9 CD 2B 3C 04 9519  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0436ED 22 29 4D 04 9520  			LD      (AUTONO),HL		; Store the start in AUTONO
0436F1 79          9521  			LD      A,C			; Increment is 8 bit (0-255)
0436F2 32 41 4D 04 9522  			LD      (INCREM),A		; Store that in INCREM
0436F6 18 2E       9523  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0436F8             9524  ;
0436F8             9525  ; BAD
0436F8             9526  ; NEW
0436F8             9527  ;
0436F8 CD 90 3D 04 9528  BAD:			CALL    TELL            	; Output "Bad program" error
0436FC 03          9529  			DB    3				; Token for "BAD"
0436FD 70 72 6F 67 9530  			DB    "program"
       72 61 6D    
043704 0D          9531  			DB    CR
043705 0A          9532  			DB    LF
043706 00          9533  			DB    0				; Falls through to NEW
043707             9534  ;
043707 CD 6C 38 04 9535  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
04370B 18 19       9536  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04370D             9537  ;
04370D             9538  ; OLD
04370D             9539  ;
04370D 2A 14 4D 04 9540  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043711 E5          9541  			PUSH    HL			; Stack it
043712 23          9542  			INC     HL			; Skip the potential length byte of first line of code
043713 23          9543  			INC     HL			; And the line number word
043714 23          9544  			INC     HL
043715 01 FC 00 00 9545  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043719 3E 0D       9546  			LD      A,CR
04371B ED B1       9547  			CPIR
04371D 20 D9       9548  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04371F 7D          9549  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043720 E1          9550  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043721 77          9551  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043722 CD 3F 38 04 9552  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043726 C3 80 30 04 9553  CLOOP0:			JP      CLOOP			; Jump back to the command loop
04372A             9554  ;
04372A             9555  ; LOAD filename
04372A             9556  ;
04372A CD 15 03 04 9557  LOAD:			CALL    EXPRS           	; Get the filename
04372E 3E 0D       9558  			LD      A,CR			; DE points to the last byte of filename in ACCS
043730 12          9559  			LD      (DE),A			; Terminate filename with a CR
043731 CD 1F 38 04 9560  			CALL    LOAD0			; Load the file in, then CLEAN
043735 CD 76 38 04 9561  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043739 18 21       9562  			JR      WARM0			; Jump back to the command loop
04373B             9563  ;
04373B             9564  ; SAVE filename
04373B             9565  ;
04373B CD 4B 38 04 9566  SAVE:			CALL    SETTOP          	; Set TOP sysvar
04373F CD 15 03 04 9567  			CALL    EXPRS           	; Get the filename
043743 3E 0D       9568  			LD      A,CR			; Terminate the filename with a CR
043745 12          9569  			LD      (DE),A
043746 ED 5B 14 4D 9570  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
04374B 2A 17 4D 04 9571  			LD      HL,(TOP)		; HL: Top of program memory
04374F B7          9572  			OR      A			; Calculate program size (TOP-PAGE)
043750 ED 52       9573  			SBC     HL,DE
043752 44          9574  			LD      B,H             	; BC: Length of program in bytes
043753 4D          9575  			LD      C,L
043754 21 00 4A 04 9576  			LD      HL,ACCS			; HL: Address of the filename
043758 CD 2D 42 04 9577  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
04375C C3 7F 30 04 9578  WARM0:			JP      WARM			; Jump back to the command loop
043760             9579  
043760             9580  ;
043760             9581  ; ERROR
043760             9582  ; Called whenever BASIC needs to halt with an error
043760             9583  ; Error messages are indexed from 0
043760             9584  ; Inputs:
043760             9585  ;  A: Error number
043760             9586  ;
043760 ED 7B 20 4D 9587  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
043765 21 49 34 04 9588  			LD      HL,ERRWDS		; Index into the error string table
043769 B7          9589  			OR      A			; We don't need to search for the first error
04376A 28 0A       9590  			JR      Z,ERROR1		; So skip the search routine
04376C             9591  ;
04376C             9592  ; Search the error table for error #A
04376C             9593  ; HL will end up being the pointer into the correct error
04376C             9594  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
04376C             9595  ;
04376C 47          9596  			LD      B,A             	; Store error number in B
04376D 08          9597  			EX      AF,AF'			; Store error number in AF'
04376E AF          9598  			XOR     A
04376F BE          9599  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
043770 23          9600  			INC     HL			; Increment the string pointer
043771 20 FC       9601  			JR      NZ,ERROR0		; Loop until with hit a 0
043773 10 FA       9602  			DJNZ    ERROR0			; Decrements the error number and loop until 0
043775 08          9603  			EX      AF,AF'			; Restore the error number from AF'
043776             9604  ;
043776             9605  ; At this point HL points to the tokenised error string
043776             9606  ;
043776 E5          9607  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
043777             9608  
043777             9609  ;
043777             9610  ; EXTERR
043777             9611  ; Inputs:
043777             9612  ;  A: Error number
043777             9613  ;
043777             9614  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
043777             9615  ; The error text immediately follows the CALL to EXTERR, for example:
043777             9616  ; > CALL  EXTERR
043777             9617  ; > DB    "Silly", 0
043777             9618  ; So we can get the address of the string by popping the return address off the stack
043777             9619  ;
043777 E1          9620  EXTERR:			POP     HL			; Pop the error string pointer
043778 22 2F 4D 04 9621  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
04377C ED 7B 20 4D 9622  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
043781 32 3F 4D 04 9623  			LD      (ERR),A			; Store error number in ERR sysvar
043785 CD AE 39 04 9624  			CALL    SETLIN			; Get line number
043789 22 33 4D 04 9625  			LD      (ERL),HL		; Store in ERL sysvar
04378D B7          9626  			OR      A			; Is error number 0?
04378E 28 0D       9627  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
043790             9628  ;
043790 2A 2C 4D 04 9629  			LD      HL,(ERRTRP)		; Check whether the error is trapped
043794 7C          9630  			LD      A,H
043795 B5          9631  			OR      L
043796 E5          9632  			PUSH    HL			; HL: Error line
043797 FD E1       9633  			POP     IY			; IY: HL
043799 C2 96 0B 04 9634  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
04379D             9635  ;
04379D 21 00 00 00 9636  ERROR2:			LD      HL,0
0437A1 22 29 4D 04 9637  			LD      (AUTONO),HL		; Cancel AUTO
0437A5 22 26 4D 04 9638  			LD      (TRACEN),HL     	; Cancel TRACE
0437A9 CD B6 43 04 9639  			CALL    RESET           	; Reset OPSYS
0437AD CD 47 39 04 9640  			CALL    CRLF			; Output newline
0437B1 CD 82 3D 04 9641  			CALL    REPORT          	; Output the error message
0437B5 CD E2 39 04 9642  			CALL    SAYLN			; Output " at line nnnn" message.
0437B9 1E 00       9643  			LD      E,0			; Close all files
0437BB DC 2B 43 04 9644  			CALL    C,OSSHUT
0437BF CD 47 39 04 9645  			CALL    CRLF			; Output newline
0437C3 C3 80 30 04 9646  			JP      CLOOP			; Back to CLOOP
0437C7             9647  ;
0437C7             9648  ; SUBROUTINES:
0437C7             9649  ;
0437C7             9650  ; LEX - SEARCH FOR KEYWORDS
0437C7             9651  ;   Inputs: HL = start of keyword table
0437C7             9652  ;           IY = start of match text
0437C7             9653  ;  Outputs: If found, Z-flag set, A=token.
0437C7             9654  ;           If not found, Z-flag reset, A=(IY).
0437C7             9655  ;           IY updated (if NZ, IY unchanged).
0437C7             9656  ; Destroys: A,B,H,L,IY,F
0437C7             9657  ;
0437C7 21 68 31 04 9658  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0437CB             9659  ;
0437CB FD 7E 00    9660  LEX0:			LD      A,(IY)			; Fetch the character to match
0437CE 46          9661  			LD      B,(HL)			; B: The token from the keywords table
0437CF 23          9662  			INC     HL			; Increment the pointer in the keywords table
0437D0 BE          9663  			CP      (HL)			; Compare the first characters
0437D1 28 08       9664  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0437D3 D8          9665  			RET     C               	; No match, so fail
0437D4             9666  ;
0437D4             9667  ; This snippet of code skips to the next token in the KEYWDS table
0437D4             9668  ;
0437D4 23          9669  LEX1:			INC     HL			; Increment the pointer
0437D5 CB 7E       9670  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0437D7 28 FB       9671  			JR      Z,LEX1			; No, so loop
0437D9 18 F0       9672  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0437DB             9673  ;
0437DB FD E5       9674  LEX2:			PUSH    IY              	; Save the input pointer
0437DD 23          9675  LEX3:			INC     HL			; Increment the keyword pointer
0437DE CB 7E       9676  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0437E0 20 1C       9677  			JR      NZ,LEX6         	; Jump to here as we've found a token
0437E2 FD 23       9678  			INC     IY			; Increment the text pointer
0437E4 FD 7E 00    9679  			LD      A,(IY)			; Fetch the character
0437E7 FE 2E       9680  			CP      '.'			; Is it an abbreviated keyword?
0437E9 28 13       9681  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0437EB BE          9682  			CP      (HL)			; Compare with the keywords list
0437EC 28 EF       9683  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0437EE CD 7B 3C 04 9684  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0437F2 38 04       9685  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0437F4             9686  ;
0437F4 FD E1       9687  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0437F6 18 DC       9688  			JR      LEX1			; And loop back to start again
0437F8             9689  ;
0437F8             9690  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0437F8             9691  ; immediately delimited
0437F8             9692  ;
0437F8 7E          9693  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0437F9 B7          9694  			OR      A			; If it is not zero, then...
0437FA 20 F8       9695  			JR      NZ,LEX4			; Keep searching
0437FC FD 2B       9696  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0437FE             9697  ;
0437FE             9698  ; We've found a token at this point
0437FE             9699  ;
0437FE F1          9700  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0437FF AF          9701  			XOR     A			; Set the Z flag
043800 78          9702  			LD      A,B			; A: The token
043801 C9          9703  			RET
043802             9704  ;
043802             9705  ; DEL - DELETE A PROGRAM LINE.
043802             9706  ;   Inputs: HL addresses program line.
043802             9707  ; Destroys: B,C,F
043802             9708  ;
043802             9709  ; This simply erases the line by moving all of the code after the line to be deleted back over
043802             9710  ; it using an LDIR
043802             9711  ;
043802 D5          9712  DEL:			PUSH    DE
043803 E5          9713  			PUSH    HL
043804 E5          9714  			PUSH    HL			; HL: Address of the program line
043805 06 00       9715  			LD      B,0			; BC: Length of the line
043807 4E          9716  			LD      C,(HL)
043808 09          9717  			ADD     HL,BC			; HL: Advanced to the start of the next line
043809 E5          9718  			PUSH    HL
04380A EB          9719  			EX      DE,HL			; DE: Pointer to the next line
04380B 2A 17 4D 04 9720  			LD      HL,(TOP)		; HL: Pointer to the end of the program
04380F ED 52       9721  			SBC     HL,DE
043811 44          9722  			LD      B,H			; BC: Size of block to move
043812 4D          9723  			LD      C,L
043813 E1          9724  			POP     HL			; HL: Pointer to next line
043814 D1          9725  			POP     DE			; DE: Pointer to this line
043815 ED B0       9726  			LDIR                    	; Delete the line
043817 ED 53 17 4D 9727  			LD      (TOP),DE		; Adjust TOP
       04          
04381C E1          9728  			POP     HL
04381D D1          9729  			POP     DE
04381E C9          9730  			RET
04381F             9731  ;
04381F             9732  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
04381F             9733  ;   Inputs: Filename in ACCS (term CR)
04381F             9734  ; Destroys: A,B,C,D,E,H,L,F
04381F             9735  ;
04381F             9736  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
04381F             9737  ; AND WRITE FF FF, THEN LOAD (TOP).
04381F             9738  ; Destroys: A,B,C,H,L,F
04381F             9739  ;
04381F ED 5B 14 4D 9740  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
043824 21 00 FF FF 9741  			LD      HL,-256
043828 39          9742  			ADD     HL,SP
043829 ED 52       9743  			SBC     HL,DE           	; Find available space
04382B 44          9744  			LD      B,H
04382C 4D          9745  			LD      C,L
04382D 21 00 4A 04 9746  			LD      HL,ACCS
043831 CD 94 41 04 9747  			CALL    OSLOAD          	; Call the OSLOAD function in patch
043835 D4 6C 38 04 9748  			CALL    NC,NEWIT		; If NC then NEW
043839 3E 00       9749  			LD      A,0
04383B D2 60 37 04 9750  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04383F             9751  ;
04383F CD 4B 38 04 9752  CLEAN:			CALL    SETTOP			; Set TOP sysvar
043843 2B          9753  			DEC     HL			; Write out the end of program markers
043844 36 FF       9754  			LD      (HL),-1
043846 2B          9755  			DEC     HL
043847 36 FF       9756  			LD      (HL),-1
043849 18 2B       9757  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
04384B             9758  ;
04384B             9759  ; Set the TOP sysvar; the first free location after the end of the current program
04384B             9760  ; Returns:
04384B             9761  ; - HL: TOP
04384B             9762  ;
04384B 2A 14 4D 04 9763  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04384F 01 00 00 00 9764  			LD	BC, 0			; BC: 0
043853 3E 0D       9765  			LD      A,CR			; End of line marker
043855 4E          9766  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
043856 0C          9767  			INC     C			; Check for zero
043857 0D          9768  			DEC     C
043858 28 0A       9769  			JR      Z,SETOP2		; If it is zero, we've reached the end
04385A 09          9770  			ADD     HL,BC			; Skip to next line
04385B 2B          9771  			DEC     HL			; Check end of previous line
04385C BE          9772  			CP      (HL)
04385D 23          9773  			INC     HL
04385E 28 F5       9774  			JR      Z,SETOP1		; If CR then loop
043860 C3 F8 36 04 9775  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043864             9776  ;
043864 23          9777  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
043865 23          9778  			INC     HL			; NB: Called from NEWIT
043866 23          9779  			INC     HL
043867 22 17 4D 04 9780  			LD      (TOP),HL		; Store in TOP sysvar
04386B C9          9781  			RET
04386C             9782  ;
04386C             9783  ; NEWIT - NEW PROGRAM THEN CLEAR
04386C             9784  ;   Destroys: H,L
04386C             9785  ;
04386C             9786  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
04386C             9787  ; FUNCTION AND PROCEDURE POINTERS.
04386C             9788  ;   Destroys: Nothing
04386C             9789  ;
04386C 2A 14 4D 04 9790  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
043870 36 00       9791  			LD      (HL),0			; Stick a 0 in there
043872 CD 64 38 04 9792  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
043876             9793  ;
043876 E5          9794  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
043877 2A 17 4D 04 9795  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
04387B 22 1A 4D 04 9796  			LD      (LOMEM),HL		; Set the LOMEM sysvar
04387F 22 1D 4D 04 9797  			LD      (FREE),HL		; And the FREE sysvar with that value
043883 21 6C 4C 04 9798  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
043887 C5          9799  			PUSH    BC
043888             9800  			; LD      B,3*(54+2)		; Loop counter
043888 06 A8       9801  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
04388A 36 00       9802  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
04388C 23          9803  			INC     HL
04388D 10 FB       9804  			DJNZ    CLEAR1
04388F C1          9805  			POP     BC
043890 E1          9806  			POP     HL			; Restore the BASIC program pointer
043891 C9          9807  			RET
043892             9808  ;
043892             9809  ;LISTIT - LIST A PROGRAM LINE.
043892             9810  ;    Inputs: HL addresses line
043892             9811  ;            DE = line number (binary)
043892             9812  ;            IX = Pointer to LISTON
043892             9813  ;             B = FOR/NEXT indent level
043892             9814  ;             C = REPEAT/UNTIL indent level
043892             9815  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
043892             9816  ;
043892 E5          9817  LISTIT:			PUSH    HL			; Stack the address of the line
043893 EB          9818  			EX      DE,HL			; HL: Line number
043894 C5          9819  			PUSH    BC
043895 CD FB 39 04 9820  			CALL    PBCD			; Print the line number
043899 C1          9821  			POP     BC
04389A E1          9822  			POP     HL			; HL: Address of the first token/character
04389B 7E          9823  			LD      A,(HL)			; Fetch the token
04389C FE ED       9824  			CP      NEXT			; Is it NEXT...
04389E CC 28 39 04 9825  			CALL    Z,INDENT		; Yes, so indent in
0438A2 FE FD       9826  			CP      UNTIL			; Or is it UNTIL...
0438A4 CC 28 39 04 9827  			CALL    Z,INDENT		; Yes, so indent in
0438A8 D9          9828  			EXX
0438A9 3E 20       9829  			LD      A,' '
0438AB DD CB 00 46 9830  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0438AF C4 4F 39 04 9831  			CALL    NZ,OUTCHR		; Then print a space after the line number
0438B3 78          9832  			LD      A,B			; Fetch the FOR/NEXT indent level
0438B4 87          9833  			ADD     A,A			; Multiply by 2
0438B5 DD CB 00 4E 9834  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0438B9 C4 EF 17 04 9835  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438BD 79          9836  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438BE 87          9837  			ADD     A,A			; Multiply by 2
0438BF DD CB 00 56 9838  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0438C3 C4 EF 17 04 9839  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438C7 D9          9840  			EXX
0438C8 7E          9841  			LD      A,(HL)			; Fetch the token
0438C9 FE E3       9842  			CP      FOR			; Is it FOR?
0438CB CC 28 39 04 9843  			CALL    Z,INDENT		; Yes, so indent
0438CF FE F5       9844  			CP      REPEAT			; Is it REPEAT?
0438D1 CC 28 39 04 9845  			CALL    Z,INDENT		; Yes, so indent
0438D5 1E 00       9846  			LD      E,0			; E: The quote counter - reset to 0
0438D7 7E          9847  LIST8:			LD      A,(HL)			; Fetch a character / token byte
0438D8 23          9848  			INC     HL
0438D9 FE 0D       9849  			CP      CR			; Is it end of line?
0438DB 28 0B       9850  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0438DD FE 22       9851  			CP      34			; Is it a quote character?
0438DF 20 01       9852  			JR      NZ,LIST7		; No, so skip to next bit
0438E1 1C          9853  			INC     E			; Otherwise increment quote counter
0438E2 CD 17 39 04 9854  LIST7:			CALL    LOUT			; Output the character / token
0438E6 18 EF       9855  			JR      LIST8			; And repeat
0438E8             9856  ;
0438E8             9857  ; DB: Modification for *EDIT
0438E8             9858  ; Terminate the line with either a CRLF or a NUL character
0438E8             9859  ;
0438E8 DD CB 00 5E 9860  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0438EC 28 59       9861  			JR	Z, CRLF			; Yes, so print a CRLF
0438EE AF          9862  			XOR	A			; Otherwise print a NUL (0)
0438EF C3 00 3F 04 9863  			JP	OSWRCH
0438F3             9864  ;
0438F3             9865  ; Decode the 3 byte GOTO type line number
0438F3             9866  ;
0438F3 E5          9867  PRLINO:			PUSH    HL			; Swap HL and IY
0438F4 FD E1       9868  			POP     IY			; IY: Pointer to the line number
0438F6 C5          9869  			PUSH    BC
0438F7 CD E6 08 04 9870  			CALL    DECODE			; Decode
0438FB C1          9871  			POP     BC
0438FC D9          9872  			EXX
0438FD C5          9873  			PUSH    BC
0438FE CD F7 39 04 9874  			CALL    PBCDL			; Output the line number
043902 C1          9875  			POP     BC
043903 D9          9876  			EXX
043904 FD E5       9877  			PUSH    IY			; Swap HL and IY
043906 E1          9878  			POP     HL			; HL: Pointer to the next character in the line
043907 C9          9879  			RET
043908             9880  ;
043908             9881  ; DB: Modification for internationalisation
043908             9882  ;
043908 CD 6C 39 04 9883  PRREM:			CALL	OUT_			; Output the REM token
04390C 7E          9884  @@:			LD	A, (HL)			; Fetch the character
04390D FE 0D       9885  			CP	CR			; If it is end of line, then
04390F C8          9886  			RET	Z			; we have finished
043910 CD 4F 39 04 9887  			CALL	OUTCHR			; Ouput the character
043914 23          9888  			INC	HL
043915 18 F5       9889  			JR	@B			; And loop
043917             9890  ;
043917             9891  ; DB: End of modification
043917             9892  ;
043917 CB 43       9893  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043919 20 34       9894  			JR      NZ,OUTCHR		; don't tokenise, just output the character
04391B FE F4       9895  			CP	REM			; DB: Is it REM
04391D 28 E9       9896  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
04391F FE 8D       9897  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043921 28 D0       9898  			JR      Z,PRLINO		; Yes, so decode and print the line number
043923 CD 6C 39 04 9899  			CALL    OUT_			; Output a character / keyword
043927 7E          9900  			LD      A,(HL)			; Fetch the next character
043928             9901  ;
043928             9902  ; This block of code handles the indentation
043928             9903  ; B: Counter for FOR/NEXT indent
043928             9904  ; C: Counter for REPEAT/UNTIL indent
043928             9905  ;
043928 D9          9906  INDENT:			EXX
043929 FE E3       9907  			CP      FOR			; If the token is FOR
04392B 28 09       9908  			JR      Z,IND1			; Then INC B
04392D FE ED       9909  			CP      NEXT			; If it is NEXT
04392F 20 06       9910  			JR      NZ,IND2_		; Then...
043931 05          9911  			DEC     B			; DEC B
043932 F2 37 39 04 9912  			JP      P,IND2_			; If we have gone below 0 then
043936 04          9913  IND1:			INC     B			; Increment back to 0
043937             9914  ;
043937 FE F5       9915  IND2_:			CP      REPEAT			; If the token is REPEAT
043939 28 09       9916  			JR      Z,IND3			; Then INC C
04393B FE FD       9917  			CP      UNTIL			; If it is UNTIL
04393D 20 06       9918  			JR      NZ,IND4			; Then...
04393F 0D          9919  			DEC     C			; DEC C
043940 F2 45 39 04 9920  			JP      P,IND4			; If we have gone below 0 then
043944 0C          9921  IND3:			INC     C			; Incremet back to 0
043945 D9          9922  IND4:			EXX
043946 C9          9923  			RET
043947             9924  ;
043947             9925  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
043947             9926  ;  Destroys: A,F
043947             9927  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
043947             9928  ;    Inputs: A = character
043947             9929  ;  Destroys: A,F
043947             9930  ;
043947 3E 0D       9931  CRLF:			LD      A,CR			; Output CR
043949 CD 4F 39 04 9932  			CALL    OUTCHR
04394D 3E 0A       9933  			LD      A,LF			; Output LF
04394F             9934  ;
04394F CD 00 3F 04 9935  OUTCHR:			CALL    OSWRCH			; Output the character in A
043953 D6 0D       9936  			SUB     CR			; Check for CR
043955 28 06       9937  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
043957 D8          9938  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043958 3A 3D 4D 04 9939  			LD      A,(COUNT)		; Increment the count
04395C 3C          9940  			INC     A
04395D             9941  ;
04395D 32 3D 4D 04 9942  CARRET:			LD      (COUNT),A		; Store the new count value
043961 C8          9943  			RET     Z			; Return if the count has wrapped to 0
043962 E5          9944  			PUSH    HL			; Now check if count = print width
043963 2A 3E 4D 04 9945  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
043967 BD          9946  			CP      L			; L is the width. Compare it with count.
043968 E1          9947  			POP     HL
043969 C0          9948  			RET     NZ			; If we've not hit print width, then just return
04396A 18 DB       9949  			JR      CRLF			; Otherwise output CRLF
04396C             9950  ;
04396C             9951  ; OUT - SEND CHARACTER OR KEYWORD
04396C             9952  ;   Inputs: A = character (>=10, <128)
04396C             9953  ;           A = Token (<10, >=128)
04396C             9954  ;  Destroys: A,F
04396C             9955  ;
04396C FE 8A       9956  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04396E EA 4F 39 04 9957  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
043972             9958  ;
043972             9959  ; This bit looks up the character in the KEYWDS token table and expands it
043972             9960  ; Note the CP 138; this sets the overflow flag as follows:
043972             9961  ;
043972             9962  ; NB:
043972             9963  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
043972             9964  ;  2. CP is effectively a SUB; sets the flags without affecting A
043972             9965  ;  3. The operation n - -118 ~ n + 118
043972             9966  ;
043972             9967  ; So:
043972             9968  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
043972             9969  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
043972             9970  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
043972             9971  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
043972             9972  ;
043972 C5          9973  			PUSH    BC			; Preserve BC and HL
043973 E5          9974  			PUSH    HL
043974 21 68 31 04 9975  			LD      HL,KEYWDS		; The list of tokens and keywords
043978 01 DF 02 00 9976  			LD      BC,KEYWDL		; The length of the keyword list
04397C ED B1       9977  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
04397E             9978  ;							; At this point HL points to the next byte, the first character of the token
04397E 7E          9979  TOKEN1:			LD      A,(HL)			; Fetch the character
04397F 23          9980  			INC     HL			; Increment to the next byte in the token table
043980 FE 8A       9981  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
043982 F5          9982  			PUSH    AF			; Then...
043983 EC 4F 39 04 9983  			CALL    PE,OUTCHR		; Output the character...
043987 F1          9984  			POP     AF			;
043988 EA 7E 39 04 9985  			JP      PE,TOKEN1		; And loop to the next character
04398C E1          9986  			POP     HL			; Done, so tidy up the stack and exit
04398D C1          9987  			POP     BC
04398E C9          9988  			RET
04398F             9989  ;
04398F             9990  ; FINDL - FIND PROGRAM LINE
04398F             9991  ;   Inputs: HL = line number (binary)
04398F             9992  ;  Outputs: HL addresses line (if found)
04398F             9993  ;           DE = line number
04398F             9994  ;           Z-flag set if found.
04398F             9995  ; Destroys: A,B,C,D,E,H,L,F
04398F             9996  ;
04398F EB          9997  FINDL:			EX      DE,HL			; DE: Line number (binary)
043990 2A 14 4D 04 9998  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
043994 AF          9999  			XOR     A               	;  A: 0
043995 BE          10000  			CP      (HL)			; Check for end of program marker
043996 3C          10001  			INC     A			;  A: 1
043997 D0          10002  			RET     NC			; Return with 1 if 0
043998 AF          10003  			XOR     A               	; Clear the carry flag
043999             10004  ;			LD      B,A			;  B: 0
043999 01 00 00 00 10005  			LD	BC, 0			; BC: 0
04399D             10006  ;
04399D 4E          10007  FINDL1:			LD      C,(HL)			;  C: The line length
04399E E5          10008  			PUSH    HL			; Stack the current program counter
04399F 23          10009  			INC     HL			; Skip to the line number bytes
0439A0 7E          10010  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439A1 23          10011  			INC     HL
0439A2 66          10012  			LD      H,(HL)
0439A3 6F          10013  			LD      L,A
0439A4 52 ED 52    10014  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439A7 E1          10015  			POP     HL			; Get the current program counter
0439A8 D0          10016  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439A9 09          10017  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439AA C3 9D 39 04 10018  			JP      FINDL1			; And loop
0439AE             10019  ;
0439AE             10020  ; SETLIN - Search program for line containing address
0439AE             10021  ;          Update (LINENO)
0439AE             10022  ;   Inputs: Address in (ERRLIN)
0439AE             10023  ;  Outputs: Line number in HL and (LINENO)
0439AE             10024  ; Destroys: B,C,D,E,H,L,F
0439AE             10025  ;
0439AE 01 00 00 00 10026  SETLIN:			LD	BC, 0			; Zero BC for later
0439B2             10027  ;			LD      B, 0			; Zero B for later
0439B2 ED 5B 35 4D 10028  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
0439B7 2A 14 4D 04 10029  			LD      HL, (PAGE_)		; HL: Start of user program area
0439BB B7          10030  			OR      A			; Do a 24 bit compare without destroying HL
0439BC ED 52       10031  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439BE 19          10032  			ADD     HL, DE			;  C: DE > HL
0439BF 30 1B       10033  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439C1             10034  ;
0439C1 4E          10035  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439C2 0C          10036  			INC     C			; This is a way to check for zero without using the accumulator
0439C3 0D          10037  			DEC     C			; If it is zero, then...
0439C4 28 16       10038  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439C6 09          10039  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439C7 ED 52       10040  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0439C9 19          10041  			ADD     HL, DE
0439CA 38 F5       10042  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0439CC ED 42       10043  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0439CE 23          10044  			INC     HL			; Skip the length counter
0439CF 11 00 00 00 10045  			LD	DE, 0			; Zero DE
0439D3 5E          10046  			LD      E, (HL)          	; Fetch the line number
0439D4 23          10047  			INC     HL
0439D5 56          10048  			LD      D, (HL)
0439D6 EB          10049  			EX      DE, HL			; HL: The line number
0439D7 22 23 4D 04 10050  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0439DB C9          10051  			RET
0439DC             10052  ;
0439DC 21 00 00 00 10053  SET3:			LD      HL, 0			; We've not found the line at this point so
0439E0 18 F5       10054  			JR      SET2			; Set LINENO to 0
0439E2             10055  ;
0439E2             10056  ;SAYLN - PRINT " at line nnnn" MESSAGE.
0439E2             10057  ;  Outputs: Carry=0 if line number is zero.
0439E2             10058  ;           Carry=1 if line number is non-zero.
0439E2             10059  ; Destroys: A,B,C,D,E,H,L,F
0439E2             10060  ;
0439E2 2A 23 4D 04 10061  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0439E6 7C          10062  			LD      A,H			; If it is zero then
0439E7 B5          10063  			OR      L
0439E8 C8          10064  			RET     Z			; Don't need to do anything; return with F:C set to 0
0439E9 CD 90 3D 04 10065  			CALL    TELL			; Output the error message
0439ED 20 61 74 20 10066  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
0439F7 0E 00       10067  PBCDL:			LD      C,0			; C: Leading character (NUL)
0439F9 18 02       10068  			JR      PBCD0			; Output the line number; return with F:C set to 1
0439FB             10069  ;
0439FB             10070  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
0439FB             10071  ;   Inputs: HL = number (binary).
0439FB             10072  ;  Outputs: Carry = 1
0439FB             10073  ; Destroys: A,B,C,D,E,H,L,F
0439FB             10074  ;
0439FB 0E 20       10075  PBCD:			LD      C,' '			; C: Leading character (" ")
0439FD 06 05       10076  PBCD0:			LD      B,5			; Number of digits in result
0439FF 11 10 27 00 10077  			LD      DE,10000		; Start off with the 10,000 column
043A03 AF          10078  PBCD1:			XOR     A			; Counter
043A04 ED 52       10079  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A06 3C          10080  			INC     A
043A07 30 FB       10081  			JR      NC,PBCD2
043A09 19          10082  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A0A 3D          10083  			DEC     A			; A: Number of 10,000s
043A0B 28 04       10084  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A0D CB E1       10085  			SET     4,C			; C: Set to '0' ASCII (30h)
043A0F CB E9       10086  			SET     5,C
043A11 B1          10087  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A12 C4 4F 39 04 10088  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A16 78          10089  			LD      A,B			; If on first transition, skip this
043A17 FE 05       10090  			CP      5			; TODO: Need to find out why
043A19 28 06       10091  			JR      Z,PBCD4
043A1B 29          10092  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A1C 54          10093  			LD      D,H			;         : rather than shifting DE right
043A1D 5D          10094  			LD      E,L			;         : This makes a lot of sense
043A1E 29          10095  			ADD     HL,HL			; HL x  4
043A1F 29          10096  			ADD     HL,HL			; HL x  8
043A20 19          10097  			ADD     HL,DE			; HL x 10
043A21 11 E8 03 00 10098  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A25 10 DC       10099  			DJNZ    PBCD1			; Loop until done
043A27 37          10100  			SCF				; SCF set for SAYLN in this module
043A28 C9          10101  			RET
043A29             10102  ;
043A29             10103  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A29             10104  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A29             10105  ;  Outputs: As GETVAR.
043A29             10106  ; Destroys: everything
043A29             10107  ;
043A29 CD AE 3B 04 10108  PUTVAR:			CALL    CREATE			; Create the variable
043A2D FD 7E 00    10109  			LD      A,(IY)			; Fetch the next character
043A30 FE 28       10110  			CP      '('			; Check for bad use of array
043A32 20 70       10111  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A34 3E 0E       10112  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A36 C3 60 37 04 10113  ERROR3:			JP      ERROR_
043A3A             10114  ;
043A3A             10115  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A3A             10116  ;   Inputs: IY addresses first character.
043A3A             10117  ;  Outputs: Carry set and NZ if illegal character.
043A3A             10118  ;           Z-flag set if variable found, then:
043A3A             10119  ;            A = variable type (0,4,5,128 or 129)
043A3A             10120  ;            HL = IX = variable pointer.
043A3A             10121  ;            IY updated
043A3A             10122  ;           If Z-flag & carry reset, then:
043A3A             10123  ;            HL, IY set for subsequent PUTVAR call.
043A3A             10124  ; Destroys: everything
043A3A             10125  ;
043A3A FD 7E 00    10126  GETVAR:			LD      A,(IY)			; Get the first character
043A3D FE 24       10127  			CP      '$'			; Is it a string?
043A3F 28 69       10128  			JR      Z,GETV4			; Yes, so branch here
043A41 FE 21       10129  			CP      '!'			; Is it indirection (32-bit)?
043A43 28 69       10130  			JR      Z,GETV5			; Yes, so branch here
043A45 FE 3F       10131  			CP      '?'			; Is it indirection (8-bit)?
043A47 28 69       10132  			JR      Z,GETV6			; Yes, so branch here
043A49             10133  ;
043A49 CD 18 3B 04 10134  			CALL    LOCATE			; Locate the variable
043A4D C0          10135  			RET     NZ			; And exit here if not found
043A4E             10136  ;
043A4E             10137  ; At this point:
043A4E             10138  ;  HL: Address of variable in memory
043A4E             10139  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043A4E             10140  ;
043A4E FD 7E 00    10141  			LD      A,(IY)			; Further checks
043A51 FE 28       10142  			CP      '('             	; Is it an array?
043A53 20 47       10143  			JR      NZ,GETVX        	; No, so exit
043A55             10144  ;
043A55             10145  ; We are processing an array at this point
043A55             10146  ;
043A55 D5          10147  			PUSH    DE              	; Save the variable type (in D)
043A56 7E          10148  			LD      A,(HL)          	; Fetch the number of dimensions
043A57 B7          10149  			OR      A
043A58 28 DA       10150  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A5A 23          10151  			INC     HL			;
043A5B 11 00 00 00 10152  			LD      DE,0            	; Accumulator
043A5F F5          10153  			PUSH    AF
043A60 FD 23       10154  			INC     IY              	; Skip "("
043A62 18 05       10155  			JR      GETV3
043A64             10156  ;
043A64 F5          10157  GETV2:			PUSH    AF
043A65 CD 22 0A 04 10158  			CALL    COMMA
043A69 E5          10159  GETV3:			PUSH    HL
043A6A D5          10160  			PUSH    DE
043A6B CD 0A 03 04 10161  			CALL    EXPRI			; Get the subscript
043A6F D9          10162  			EXX
043A70 D1          10163  			POP     DE
043A71 E3          10164  			EX      (SP),HL
043A72 4E          10165  			LD      C,(HL)
043A73 23          10166  			INC     HL
043A74 46          10167  			LD      B,(HL)
043A75 23          10168  			INC     HL
043A76 E3          10169  			EX      (SP),HL
043A77 EB          10170  			EX      DE,HL
043A78 D5          10171  			PUSH    DE
043A79 CD 72 18 04 10172  			CALL    MUL16			; HL=HL*BC
043A7D D1          10173  			POP     DE
043A7E 19          10174  			ADD     HL,DE
043A7F EB          10175  			EX      DE,HL
043A80 B7          10176  			OR      A
043A81 ED 42       10177  			SBC     HL,BC
043A83 3E 0F       10178  			LD      A,15
043A85 30 AF       10179  			JR      NC,ERROR3		; Throw a "Subscript" error
043A87 E1          10180  			POP     HL
043A88 F1          10181  			POP     AF
043A89 3D          10182  			DEC     A               	; Dimension counter
043A8A 20 D8       10183  			JR      NZ,GETV2
043A8C CD 2F 0A 04 10184  			CALL    BRAKET          	; Check for closing bracket
043A90 F1          10185  			POP     AF              	; Restore the type
043A91 E5          10186  			PUSH    HL
043A92 CD 65 18 04 10187  			CALL    X4OR5           	; DE=DE*n
043A96 E1          10188  			POP     HL
043A97 19          10189  			ADD     HL,DE
043A98 57          10190  			LD      D,A             	; The type
043A99 FD 7E 00    10191  			LD      A,(IY)
043A9C FE 3F       10192  GETVX:			CP      '?'
043A9E 28 1E       10193  			JR      Z,GETV9
043AA0 FE 21       10194  			CP      '!'
043AA2 28 16       10195  			JR      Z,GETV8
043AA4 E5          10196  GETVZ:			PUSH    HL              	; Set exit conditions
043AA5 DD E1       10197  			POP     IX
043AA7 7A          10198  			LD      A,D
043AA8 BF          10199  			CP      A
043AA9 C9          10200  			RET
043AAA             10201  ;
043AAA             10202  ; Process strings, unary & binary indirection:
043AAA             10203  ;
043AAA 3E 80       10204  GETV4:			LD      A,128           	; Static strings
043AAC 18 05       10205  			JR      GETV7
043AAE             10206  ;
043AAE 3E 04       10207  GETV5:			LD      A,4             	; Unary 32-bit indirection
043AB0 18 01       10208  			JR      GETV7
043AB2             10209  ;
043AB2 AF          10210  GETV6:			XOR     A               	; Unary 8-bit indirection
043AB3             10211  ;
043AB3 21 00 00 00 10212  GETV7:			LD      HL,0
043AB7 F5          10213  			PUSH    AF
043AB8 18 24       10214  			JR      GETV0
043ABA             10215  ;
043ABA 06 04       10216  GETV8:			LD      B,4             	; Binary 32-bt indirection
043ABC 18 02       10217  			JR      GETVA
043ABE             10218  ;
043ABE 06 00       10219  GETV9:			LD      B,0             	; Binary 8-bit indirection
043AC0             10220  ;
043AC0 E5          10221  GETVA:			PUSH    HL
043AC1 DD E1       10222  			POP     IX
043AC3 7A          10223  			LD      A,D            		; Fetch the variable type
043AC4 FE 81       10224  			CP      129			; Is it a string?
043AC6 C8          10225  			RET     Z               	; Yes, so exit here
043AC7 C5          10226  			PUSH    BC
043AC8 CD 16 04 04 10227  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043ACC CD 62 06 04 10228  			CALL    SFIX
043AD0 7D          10229  			LD	A,L
043AD1 D9          10230  			EXX
043AD2 22 4A 4D 04 10231  			LD	(R0+0),HL
043AD6 32 4C 4D 04 10232  			LD	(R0+2),A
043ADA 2A 4A 4D 04 10233  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043ADE             10234  ;
043ADE E5          10235  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043ADF FD 23       10236  			INC     IY
043AE1 CD 25 03 04 10237  			CALL    ITEMI
043AE5 7D          10238  			LD	A,L			;  A: The MSB of the address
043AE6 D9          10239  			EXX
043AE7 22 4A 4D 04 10240  			LD	(R0+0),HL		; HL: The LSW of the address
043AEB 32 4C 4D 04 10241  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043AEF D1          10242  			POP     DE
043AF0 F1          10243  			POP     AF
043AF1 2A 4A 4D 04 10244  			LD	HL,(R0)			; HL: L'HL
043AF5 19          10245  			ADD     HL,DE
043AF6 E5          10246  			PUSH    HL
043AF7 DD E1       10247  			POP     IX
043AF9 BF          10248  			CP      A
043AFA C9          10249  			RET
043AFB             10250  ;
043AFB             10251  ;GETDEF - Find entry for FN or PROC in dynamic area.
043AFB             10252  ;   Inputs: IY addresses byte following "DEF" token.
043AFB             10253  ;  Outputs: Z flag set if found
043AFB             10254  ;           Carry set if neither FN or PROC first.
043AFB             10255  ;           If Z: HL points to entry
043AFB             10256  ;                 IY addresses delimiter
043AFB             10257  ; Destroys: A,D,E,H,L,IY,F
043AFB             10258  ;
043AFB FD 7E 01    10259  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043AFE CD 7B 3C 04 10260  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B02 D8          10261  			RET     C			; No so return with C set
043B03 FD 7E 00    10262  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B06 21 0E 4D 04 10263  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B0A FE A4       10264  			CP      FN			; Is it the token FN?
043B0C 28 4A       10265  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B0E 21 11 4D 04 10266  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B12 FE F2       10267  			CP      PROC			; Is it the token PROC?
043B14 28 42       10268  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B16 37          10269  			SCF				; No, so just return with C set
043B17 C9          10270  			RET
043B18             10271  ;
043B18             10272  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B18             10273  ; If illegal first character return carry, non-zero.
043B18             10274  ; If found, return no-carry, zero.
043B18             10275  ; If not found, return no-carry, non-zero.
043B18             10276  ;   Inputs: IY=Addresses first character of name.
043B18             10277  ;            A=(IY)
043B18             10278  ;  Outputs:  F=Z set if found, then:
043B18             10279  ;           IY=addresses terminator
043B18             10280  ;           HL=addresses location of variable
043B18             10281  ;            D=type of variable: 4 = integer
043B18             10282  ;                                5 = floating point
043B18             10283  ;                              129 = string
043B18             10284  ; Destroys: A,D,E,H,L,IY,F
043B18             10285  ;
043B18             10286  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B18             10287  ; They can contain any alphanumeric character and underscore (_)
043B18             10288  ; String variables are postfixed with the dollar ($) character
043B18             10289  ; Integer variables are postfixed with the percent (%) character
043B18             10290  ; Static integer variables are named @%, A% to Z%
043B18             10291  ; All other variables are dynamic
043B18             10292  ;
043B18 D6 40       10293  LOCATE:			SUB     '@'			; Check for valid range
043B1A D8          10294  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B1B 21 00 00 00 10295  			LD      HL, 0			; Clear HL
043B1F FE 1B       10296  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B21 30 1E       10297  			JR      NC,LOC0         	; Then branch here
043B23 6F          10298  			LD	L, A			; HL = A
043B24 FD 7E 01    10299  			LD      A,(IY+1)        	; Check the 2nd character
043B27 FE 25       10300  			CP      '%'			; If not "%" then it is not static...
043B29 20 21       10301  			JR      NZ,LOC1         	; Branch here
043B2B FD 7E 02    10302  			LD      A,(IY+2)		; Check the 3rd character
043B2E FE 28       10303  			CP      '('			; If it is "(" (array) then it is not static...
043B30 28 1A       10304  			JR      Z,LOC1          	; Branch here
043B32             10305  ;
043B32             10306  ; At this point we're dealing with a static variable
043B32             10307  ;
043B32 29          10308  			ADD     HL,HL			; HL: Variable index * 4
043B33 29          10309  			ADD	HL,HL
043B34 11 00 4C 04 10310  			LD      DE,STAVAR       	; The static variable area in memory
043B38 19          10311  			ADD     HL,DE			; HL: The address of the static variable
043B39 FD 23       10312  			INC     IY			; Skip the program pointer past the static variable name
043B3B FD 23       10313  			INC     IY
043B3D 16 04       10314  			LD      D,4             	; Set the type to be integer
043B3F AF          10315  			XOR     A			; Set the Z flag
043B40 C9          10316  			RET
043B41             10317  ;
043B41             10318  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B41             10319  ;
043B41 FE 1F       10320  LOC0:			CP      '_'-'@'			; Check the first character is in
043B43 D8          10321  			RET     C			; the range "_" to
043B44 FE 3B       10322  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B46 3F          10323  			CCF				; If it is not in range then
043B47 3D          10324  			DEC     A               	; Set NZ flag and
043B48 D8          10325  			RET     C			; Exit here
043B49 D6 03       10326  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B4B 6F          10327  			LD	L, A			; HL = A
043B4C             10328  ;
043B4C             10329  ; Yes, it's definitely a dynamic variable at this point...
043B4C             10330  ;
043B4C 7D          10331  LOC1:			LD	A, L			; Fetch variable index
043B4D 87          10332  			ADD	A, A			; x 2
043B4E 85          10333  			ADD	A, L			; x 3
043B4F D6 03       10334  			SUB	3			; Subtract 2 TODO: Should be 3
043B51 6F          10335  			LD	L, A
043B52 11 6C 4C 04 10336  			LD      DE, DYNVAR       	; The dynamic variable storage
043B56 D8          10337  			RET	C			; Bounds check to trap for variable '@'
043B57 19          10338  			ADD     HL, DE			; HL: Address of first entry
043B58             10339  ;
043B58             10340  ; Loop through the linked list of variables to find a match
043B58             10341  ;
043B58 ED 17       10342  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B5A E5          10343  			PUSH	HL			; Need to preserve HL for LOC6
043B5B AF          10344  			XOR	A			; Reset carry flag
043B5C ED 62       10345  			SBC	HL, HL			; Set HL to 0
043B5E ED 52       10346  			SBC	HL, DE			; Compare with 0
043B60 E1          10347  			POP	HL			; Restore the original pointer
043B61 28 49       10348  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B63             10349  			; LD	HL, DE			; Make a copy of this pointer in HL
043B63 D5          10350  			push de
043B64 E1          10351  			pop hl ; how was that even possible?
043B65 23          10352  			INC     HL              	; Skip the link (24-bits)
043B66 23          10353  			INC     HL
043B67 23          10354  			INC	HL			; HL: Address of the variable name in DYNVARS
043B68 FD E5       10355  			PUSH    IY			; IY: Address of the variable name in the program
043B6A             10356  ;
043B6A 7E          10357  LOC3:			LD      A,(HL)         		; Compare
043B6B 23          10358  			INC     HL
043B6C FD 23       10359  			INC     IY
043B6E FD BE 00    10360  			CP      (IY)
043B71 28 F7       10361  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043B73 B7          10362  			OR      A               	; Have we hit a terminator?
043B74 28 07       10363  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043B76             10364  ;
043B76 FD E1       10365  LOC4:			POP     IY			; Restore the pointer in the program
043B78 EB          10366  			EX      DE, HL			; HL: New pointer in DYNVARS
043B79 C3 58 3B 04 10367  			JP      LOC2            	; Loop round and try again
043B7D             10368  ;
043B7D             10369  ; We might have located a variable at this point, just need to do a few more tests
043B7D             10370  ;
043B7D FD 2B       10371  LOC5:			DEC     IY
043B7F FD 7E 00    10372  			LD      A,(IY)
043B82 FE 28       10373  			CP      '('
043B84 28 15       10374  			JR      Z,LOC5A         	; FOUND
043B86 FD 23       10375  			INC     IY
043B88 CD 6F 3C 04 10376  			CALL    RANGE
043B8C 38 0D       10377  			JR      C,LOC5A         	; FOUND
043B8E FE 28       10378  			CP      '('
043B90 28 E4       10379  			JR      Z,LOC4          	; KEEP LOOKING
043B92 FD 7E FF    10380  			LD      A,(IY-1)
043B95 CD 7B 3C 04 10381  			CALL    RANGE1
043B99 30 DB       10382  			JR      NC,LOC4         	; KEEP LOOKING
043B9B D1          10383  LOC5A:			POP     DE
043B9C FD 7E FF    10384  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043B9F FE 24       10385  			CP      '$'			; Is it a string?
043BA1 16 81       10386  			LD      D,129			; Yes, so return D = 129
043BA3 C8          10387  			RET     Z
043BA4 FE 25       10388  			CP      '%'			; Is it an integer?
043BA6 16 04       10389  			LD      D,4			; Yes, so return D = 4
043BA8 C8          10390  			RET     Z
043BA9 14          10391  			INC     D			; At this point it must be a float
043BAA BF          10392  			CP      A			; Set the flags
043BAB C9          10393  			RET
043BAC             10394  ;
043BAC             10395  ; The variable is undefined at this point; HL will be zero
043BAC             10396  ;
043BAC 3C          10397  LOC6:			INC     A               	; Set NZ flag
043BAD C9          10398  			RET
043BAE             10399  ;
043BAE             10400  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043BAE             10401  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043BAE             10402  ;  Outputs: As LOCATE, GETDEF.
043BAE             10403  ; Destroys: As LOCATE, GETDEF.
043BAE             10404  ;
043BAE AF          10405  CREATE:			XOR     A
043BAF ED 5B 1D 4D 10406  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043BB4 ED 1F       10407  			LD	(HL), DE		; Store
043BB6 EB          10408  			EX      DE,HL
043BB7 77          10409  			LD      (HL),A			; Clear the link of the new entity
043BB8 23          10410  			INC     HL
043BB9 77          10411  			LD      (HL),A
043BBA 23          10412  			INC     HL
043BBB 77          10413  			LD      (HL),A
043BBC 23          10414  			INC     HL
043BBD FD 23       10415  LOC7:			INC     IY
043BBF CD 6F 3C 04 10416  			CALL    RANGE           	; END OF VARIABLE?
043BC3 38 15       10417  			JR      C,LOC8
043BC5 77          10418  			LD      (HL),A
043BC6 23          10419  			INC     HL
043BC7 CD 7B 3C 04 10420  			CALL    RANGE1
043BCB 30 F0       10421  			JR      NC,LOC7
043BCD FE 28       10422  			CP      '('
043BCF 28 09       10423  			JR      Z,LOC8
043BD1 FD 7E 01    10424  			LD      A,(IY+1)
043BD4 FE 28       10425  			CP      '('
043BD6 28 E5       10426  			JR      Z,LOC7
043BD8 FD 23       10427  			INC     IY
043BDA 36 00       10428  LOC8:			LD      (HL),0          	; TERMINATOR
043BDC 23          10429  			INC     HL
043BDD E5          10430  			PUSH    HL
043BDE CD 9C 3B 04 10431  			CALL    TYPE_			; Get the variable type in D
043BE2 3E 04       10432  			LD      A,4			; If it is an integer then it takes up 4 bytes
043BE4 BA          10433  			CP      D
043BE5 28 01       10434  			JR      Z,LOC9			; So skip the next bit
043BE7 3C          10435  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043BE8 36 00       10436  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043BEA 23          10437  			INC     HL
043BEB 3D          10438  			DEC     A
043BEC 20 FA       10439  			JR      NZ,LOC9
043BEE 22 1D 4D 04 10440  			LD      (FREE),HL		; Adjust the stack
043BF2 CD 4F 16 04 10441  			CALL    CHECK			; Check whether we are out of space
043BF6 E1          10442  			POP     HL
043BF7 AF          10443  			XOR     A
043BF8 C9          10444  			RET
043BF9             10445  ;
043BF9             10446  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043BF9             10447  ;   Inputs: IY = Text Pointer
043BF9             10448  ;  Outputs: HL = Line number (zero if none)
043BF9             10449  ;           IY updated
043BF9             10450  ; Destroys: A,D,E,H,L,IY,F
043BF9             10451  ;
043BF9             10452  ; This bit of code performs a BASE 10 shift to build up the number
043BF9             10453  ; So if the string passed is "345", the algorithm does this:
043BF9             10454  ;
043BF9             10455  ;    HL : Digit	: Operation
043BF9             10456  ; ----- : ----- : ---------
043BF9             10457  ; 00000 :	:
043BF9             10458  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043BF9             10459  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043BF9             10460  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043BF9             10461  ;
043BF9             10462  ; The multiply by 10 is done by an unrolled shift and add loop
043BF9             10463  ;
043BF9 CD 70 0A 04 10464  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043BFD 40 21 00 00 10465  			LD.SIS  HL,0			; The running total
043C01 FD 7E 00    10466  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C04 D6 30       10467  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C06 D8          10468  			RET     C			; And return if less than 0
043C07 FE 0A       10469  			CP      10			; Or greater than or equal to 10
043C09 D0          10470  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C0A FD 23       10471  			INC     IY			; Increment the string pointer
043C0C 54          10472  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C0D 5D          10473  			LD      E,L			; Store the original number in DE
043C0E 52 29       10474  			ADD.S   HL,HL           	; *2
043C10 38 13       10475  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C12 52 29       10476  			ADD.S   HL,HL           	; *4S
043C14 38 0F       10477  			JR      C,TOOBIG
043C16 52 19       10478  			ADD.S   HL,DE           	; *5
043C18 38 0B       10479  			JR      C,TOOBIG
043C1A 52 29       10480  			ADD.S   HL,HL           	; *10
043C1C 38 07       10481  			JR      C,TOOBIG
043C1E 5F          10482  			LD      E,A			; A->DE: the digit to add in
043C1F 16 00       10483  			LD      D,0
043C21 52 19       10484  			ADD.S   HL,DE           	; Add in the digit to the running total
043C23 30 DC       10485  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C25             10486  ;
043C25 3E 14       10487  TOOBIG:			LD      A,20
043C27 C3 60 37 04 10488  			JP      ERROR_           	; Error: "Too big"
043C2B             10489  ;
043C2B             10490  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C2B             10491  ;   Inputs: IY = text pointer
043C2B             10492  ;  Outputs: HL = first number (10 by default)
043C2B             10493  ;           BC = second number (10 by default)
043C2B             10494  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C2B             10495  ;
043C2B CD F9 3B 04 10496  PAIR:			CALL    LINNUM          	; Parse the first line number
043C2F 7C          10497  			LD      A,H			; If it is not zero, then...
043C30 B5          10498  			OR      L
043C31 20 02       10499  			JR      NZ,PAIR1		; Skip...
043C33 2E 0A       10500  			LD      L,10			; HL: the default value (10)
043C35             10501  ;
043C35 CD 7A 17 04 10502  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C39 FD 23       10503  			INC     IY			; Skip to next character
043C3B E5          10504  			PUSH    HL			; Stack the first line number
043C3C 21 0A 00 00 10505  			LD      HL,10			; HL: the second default (10)
043C40 C4 F9 3B 04 10506  			CALL    NZ,LINNUM       	; Parse the second line number
043C44 E3          10507  			EX      (SP),HL			; HL: The first line number (off the stack)
043C45 C1          10508  			POP     BC			; BC: Second line number
043C46 78          10509  			LD      A,B			; If the second line number is not zero then...
043C47 B1          10510  			OR      C			; We're good...
043C48 C0          10511  			RET     NZ			; Exit, otherwise...
043C49 CD 77 37 04 10512  			CALL    EXTERR			; Throw error: "Silly"
043C4D 53 69 6C 6C 10513  			DB    	"Silly", 0
       79 00       
043C53             10514  ;
043C53             10515  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043C53             10516  ;   Inputs: IY = text pointer
043C53             10517  ;  Outputs: HL = points to program text
043C53             10518  ;           BC = second number (0 by default)
043C53             10519  ; Destroys: A,B,C,D,E,H,L,IY,F
043C53             10520  ;
043C53 CD F9 3B 04 10521  DLPAIR:			CALL    LINNUM			; Parse the first line number
043C57 E5          10522  			PUSH    HL			; Stack it
043C58 CD 7A 17 04 10523  			CALL    TERMQ			; Check for ELSE, : or CR
043C5C 28 0A       10524  			JR      Z,DLP1			; And exit if so
043C5E FE E7       10525  			CP      TIF			; Is the token IF?
043C60 28 06       10526  			JR      Z,DLP1			; Yes, so skip the next bit...
043C62 FD 23       10527  			INC     IY			; Otherwise...
043C64 CD F9 3B 04 10528  			CALL    LINNUM			; Fetch the second line number
043C68 E3          10529  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043C69 CD 8F 39 04 10530  			CALL    FINDL			; HL: Find the address of the line
043C6D C1          10531  			POP     BC			; BC: The second number
043C6E C9          10532  			RET
043C6F             10533  ;
043C6F             10534  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043C6F             10535  ;   Inputs: IY addresses character
043C6F             10536  ;  Outputs: Carry set if out-of-range.
043C6F             10537  ; Destroys: A,F
043C6F             10538  ;
043C6F             10539  ; It is called here to check the following
043C6F             10540  ; In range: "$", "%" and "("
043C6F             10541  ;   Plus all characters in RANGE1 and RANGE2
043C6F             10542  ;
043C6F FD 7E 00    10543  RANGE:			LD      A,(IY)			; Fetch the character
043C72 FE 24       10544  			CP      '$'			; Postfix for string variable is valid
043C74 C8          10545  			RET     Z
043C75 FE 25       10546  			CP      '%'			; Postfix for integer variable is valid
043C77 C8          10547  			RET     Z
043C78 FE 28       10548  			CP      '('			; Postfix for array is valid
043C7A C8          10549  			RET     Z
043C7B             10550  ;
043C7B             10551  ; It is called here to check the following
043C7B             10552  ; In range: "0" to "9" and "@"
043C7B             10553  ;   Plus all characters in RANGE2
043C7B             10554  ;
043C7B FE 30       10555  RANGE1:			CP      '0'			; If it is between '0'...
043C7D D8          10556  			RET     C
043C7E FE 3A       10557  			CP      '9'+1			; And '9'...
043C80 3F          10558  			CCF
043C81 D0          10559  			RET     NC			; Then it is valid
043C82 FE 40       10560  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043C84 C8          10561  			RET     Z
043C85             10562  ;
043C85             10563  ; It is called here to check the following
043C85             10564  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043C85             10565  ;
043C85 FE 41       10566  RANGE2:			CP      'A'			; If it is between 'A'...
043C87 D8          10567  			RET     C
043C88 FE 5B       10568  			CP      'Z'+1			; And 'Z'...
043C8A 3F          10569  			CCF
043C8B D0          10570  			RET     NC			; Then it is valid
043C8C FE 5F       10571  			CP      '_'			; If it is underscore, grave, or between 'a'
043C8E D8          10572  			RET     C
043C8F FE 7B       10573  			CP      'z'+1			; And 'z'
043C91 3F          10574  			CCF				; Then it is valid
043C92 C9          10575  			RET
043C93             10576  ;
043C93             10577  ; Throw a 'LINE space' error (line too long)
043C93             10578  ; This is called from LEXAN
043C93             10579  ;
043C93 AF          10580  SPACE_: 		XOR     A
043C94 CD 77 37 04 10581  			CALL    EXTERR          	; "LINE space"
043C98 86 08 00    10582  			DB    	LINE_MN_, 8, 0
043C9B             10583  ;
043C9B             10584  ; LEXAN - LEXICAL ANALYSIS.
043C9B             10585  ;  Bit 0,C: 1=left, 0=right
043C9B             10586  ;  Bit 2,C: 1=in BINARY
043C9B             10587  ;  Bit 3,C: 1=in HEX
043C9B             10588  ;  Bit 4,C: 1=accept line number
043C9B             10589  ;  Bit 5,C: 1=in variable, FN, PROC
043C9B             10590  ;  Bit 6,C: 1=in REM, DATA, *
043C9B             10591  ;  Bit 7,C: 1=in quotes
043C9B             10592  ;   Inputs: IY addresses source string
043C9B             10593  ;           DE addresses destination string (must be page boundary)
043C9B             10594  ;            C sets initial mode
043C9B             10595  ;  Outputs: DE, IY updated
043C9B             10596  ;            A holds carriage return
043C9B             10597  ;
043C9B 12          10598  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043C9C 13          10599  			INC     DE              	; Increment the pointers
043C9D FD 23       10600  			INC     IY			; And fall through to the main function
043C9F             10601  ;
043C9F             10602  ; This is the main entry point
043C9F             10603  ;
043C9F 7B          10604  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CA0 FE FC       10605  			CP      252             	; If it is >= 252 bytes, then...
043CA2 30 EF       10606  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CA4 FD 7E 00    10607  			LD      A,(IY)			; Fetch character from source string
043CA7 FE 0D       10608  			CP      CR			; If it is a CR
043CA9 C8          10609  			RET     Z               	; Then it is end of line; we're done parsing
043CAA CD 7B 3C 04 10610  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CAE 30 06       10611  			JR      NC,LEXAN3		; Yes, so skip
043CB0 CB A9       10612  			RES     5,C             	; FLAG: NOT IN VARIABLE
043CB2 CB 99       10613  			RES     3,C             	; FLAG: NOT IN HEX
043CB4 CB 91       10614  			RES	2,C			; FLAG: NOT IN BINARY
043CB6             10615  ;
043CB6 FE 20       10616  LEXAN3:			CP      ' '			; Ignore spaces
043CB8 28 E1       10617  			JR      Z,LEXAN1
043CBA FE 2C       10618  			CP      ','			; Ignore commas
043CBC 28 DD       10619  			JR      Z,LEXAN1
043CBE FE 32       10620  			CP	'2'			; If less than '2'
043CC0 30 02       10621  			JR	NC, @F			; No, so skip
043CC2 CB 91       10622  			RES	2,C			; FLAG: NOT IN BINARY
043CC4 FE 47       10623  @@:			CP      'G'			; If less then 'G'
043CC6 38 02       10624  			JR      C,LEXAN4		; Yes, so skip
043CC8 CB 99       10625  			RES     3,C             	; FLAG: NOT IN HEX
043CCA             10626  ;
043CCA FE 22       10627  LEXAN4:			CP      34			; Is it a quote character?
043CCC 20 05       10628  			JR      NZ,LEXAN5		; No, so skip
043CCE CB 11       10629  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043CD0 3F          10630  			CCF                     	; Toggle the carry
043CD1 CB 19       10631  			RR      C			; And then shifting it back into bit 7 of C
043CD3             10632  ;
043CD3 CB 61       10633  LEXAN5:			BIT     4,C			; Accept line number?
043CD5 28 12       10634  			JR      Z,LEXAN6		; No, so skip
043CD7 CB A1       10635  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043CD9 C5          10636  			PUSH    BC
043CDA D5          10637  			PUSH    DE
043CDB CD F9 3B 04 10638  			CALL    LINNUM         		; Parse the line number to HL
043CDF D1          10639  			POP     DE
043CE0 C1          10640  			POP     BC
043CE1 7C          10641  			LD      A,H			; If it is not zero
043CE2 B5          10642  			OR      L
043CE3 C4 5C 3D 04 10643  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043CE7 18 B6       10644  			JR      LEXAN2          	; And loop
043CE9             10645  ;
043CE9 0D          10646  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043CEA 28 0A       10647  			JR      Z,LEXAN7        	; If so, skip
043CEC 0C          10648  			INC     C			; Otherwise restore C
043CED 20 AC       10649  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043CEF B7          10650  			OR      A			; Set the flags based on the character
043CF0 F4 C7 37 04 10651  			CALL    P,LEX           	; Tokenise if A < 128
043CF4 18 13       10652  			JR      LEXAN8			; And skip
043CF6             10653  ;
043CF6             10654  ; Processing the LEFT hand side here
043CF6             10655  ;
043CF6 FE 2A       10656  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043CF8 28 17       10657  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043CFA B7          10658  			OR      A			; Set the flags based on the character
043CFB F4 C7 37 04 10659  			CALL    P,LEX           	; Tokenise if A < 128
043CFF             10660  ;
043CFF             10661  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043CFF             10662  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043CFF             10663  ; Examples:
043CFF             10664  ;   LET A% = PAGE : REM This is the GET version
043CFF             10665  ;   PAGE = 40000  : REM This is the SET version
043CFF             10666  ;
043CFF FE 8F       10667  			CP      TOKLO			; TOKLO is 8Fh
043D01 38 06       10668  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D03 FE 94       10669  			CP      TOKHI+1			; TOKHI is 93h
043D05 30 02       10670  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D07 C6 40       10671  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D09             10672  ;
043D09 FE F4       10673  LEXAN8:			CP      REM			; If the token is REM
043D0B 28 04       10674  			JR      Z,LEXAN9		; Then stop tokenising
043D0D FE DC       10675  			CP      DATA_MN_			; If it is not DATA then
043D0F 20 02       10676  			JR      NZ,LEXANA		; Skip
043D11 CB F1       10677  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D13             10678  ;
043D13 FE A4       10679  LEXANA:			CP      FN			; If the token is FN
043D15 28 0A       10680  			JR      Z,LEXANB
043D17 FE F2       10681  			CP      PROC			; Or the token is PROC
043D19 28 06       10682  			JR      Z,LEXANB		; Then jump to here
043D1B CD 85 3C 04 10683  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D1F 38 02       10684  			JR      C,LEXANC		; Jump here if out of range
043D21             10685  ;
043D21 CB E9       10686  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D23 FE 26       10687  LEXANC:			CP      '&'			; Check for hex prefix
043D25 20 02       10688  			JR      NZ,LEXAND		; If not, skip
043D27 CB D9       10689  			SET     3,C             	; FLAG: IN HEX
043D29             10690  ;
043D29 FE 25       10691  LEXAND:			CP	'%'			; Check for binary prefix
043D2B 20 02       10692  			JR	NZ,LEXANE		; If not, skip
043D2D CB D1       10693  			SET	2,C			; FLAG: IN BINARY
043D2F             10694  ;
043D2F 21 53 3D 04 10695  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D33 C5          10696  			PUSH    BC
043D34 01 06 00 00 10697  			LD      BC,LIST1L		; The list length
043D38 ED B1       10698  			CPIR				; Check if the token is in this list
043D3A C1          10699  			POP     BC
043D3B 20 02       10700  			JR      NZ,LEXANF		; If not, then skip
043D3D CB E1       10701  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D3F             10702  ;
043D3F 21 57 3D 04 10703  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D43 C5          10704  			PUSH    BC
043D44 01 05 00 00 10705  			LD      BC,LIST2L		; The list length
043D48 ED B1       10706  			CPIR				; Check if the token is in this list
043D4A C1          10707  			POP     BC
043D4B 20 02       10708  			JR      NZ,LEXANG		; If not, then skip
043D4D CB C1       10709  			SET     0,C             	; FLAG: ENTER LEFT MODE
043D4F C3 9B 3C 04 10710  LEXANG:			JP      LEXAN1			; And loop
043D53             10711  
043D53             10712  ;
043D53             10713  ; LIST1: List of tokens that must be followed by line numbers
043D53             10714  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043D53             10715  ;
043D53 E5          10716  LIST1:			DB	GOTO
043D54 E4          10717  			DB	GOSUB
043D55 F7          10718  			DB	RESTOR
043D56 FC          10719  			DB	TRACE
043D57 8C          10720  LIST2:			DB	THEN_MN_
043D58 8B          10721  			DB	ELSE_MN_
043D59             10722  LIST1L:			EQU     $-LIST1
043D59 F5          10723  			DB	REPEAT
043D5A 85          10724  			DB	TERROR_MN
043D5B 3A          10725  			DB    	':'
043D5C             10726  LIST2L:			EQU     $-LIST2
043D5C             10727  ;
043D5C             10728  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043D5C             10729  ;   Inputs: HL=line number, DE=string pointer
043D5C             10730  ;  Outputs: DE updated, BIT 4,C set.
043D5C             10731  ; Destroys: A,B,C,D,E,F
043D5C             10732  ;
043D5C             10733  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043D5C             10734  ;
043D5C             10735  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043D5C             10736  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043D5C             10737  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043D5C             10738  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043D5C             10739  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043D5C             10740  ;
043D5C CB E1       10741  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D5E EB          10742  			EX      DE, HL			; HL: string pointer, DE: line number
043D5F 36 8D       10743  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D61 23          10744  			INC     HL
043D62 7A          10745  			LD      A,D			; Get the high byte
043D63 E6 C0       10746  			AND     0C0H			; Get the top two bits	DD000000
043D65 0F          10747  			RRCA				; Shift right		00DD0000
043D66 0F          10748  			RRCA
043D67 47          10749  			LD      B,A			; Store in B
043D68 7B          10750  			LD      A,E			; Get the low byte
043D69 E6 C0       10751  			AND     0C0H			; Get the top two bits	EE000000
043D6B B0          10752  			OR      B			; Combine with D	EEDD0000
043D6C 0F          10753  			RRCA				; Shift right		00EEDD00
043D6D 0F          10754  			RRCA
043D6E EE 54       10755  			XOR     01010100B		; XOR with 54h
043D70 77          10756  			LD      (HL),A			; Store this as the second byte
043D71 23          10757  			INC     HL
043D72 7B          10758  			LD      A,E			; Get the low byte
043D73 E6 3F       10759  			AND     3FH			; Strip the top two bits off
043D75 F6 40       10760  			OR      '@'			; OR with 40h
043D77 77          10761  			LD      (HL),A			; Store
043D78 23          10762  			INC     HL
043D79 7A          10763  			LD      A,D			; Get the high byte
043D7A E6 3F       10764  			AND     3FH			; Strip the top two bits off
043D7C F6 40       10765  			OR      '@'			; OR with 40h
043D7E 77          10766  			LD      (HL),A			; Store
043D7F 23          10767  			INC     HL
043D80 EB          10768  			EX      DE,HL			; DE: string pointer, HL: line number
043D81 C9          10769  			RET
043D82             10770  ;
043D82             10771  ; TEXT - OUTPUT MESSAGE.
043D82             10772  ;   Inputs: HL addresses text (terminated by nul)
043D82             10773  ;  Outputs: HL addresses character following nul.
043D82             10774  ; Destroys: A,H,L,F
043D82             10775  ;
043D82 2A 2F 4D 04 10776  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043D86             10777  ;
043D86 7E          10778  TEXT_:			LD      A, (HL)			; Fetch the character
043D87 23          10779  			INC     HL			; Increment pointer to next character
043D88 B7          10780  			OR      A			; Check for the nul (0) string terminator
043D89 C8          10781  			RET     Z			; And return if so
043D8A CD 6C 39 04 10782  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043D8E 18 F6       10783  			JR      TEXT_			; And loop
043D90             10784  ;
043D90             10785  ; TELL - OUTPUT MESSAGE.
043D90             10786  ;   Inputs: Text follows subroutine call (term=nul)
043D90             10787  ; Destroys: A,F
043D90             10788  ;
043D90             10789  ; Example usage:
043D90             10790  ;
043D90             10791  ;	CALL	TELL			Call the function
043D90             10792  ;	DB	"Hello World", 0	Followed by a zero terminated string
043D90             10793  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043D90             10794  ;
043D90 E3          10795  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043D91 CD 86 3D 04 10796  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043D95 E3          10797  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043D96 C9          10798  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043D97             10799  
043D97             10800  ; --- Begin misc.asm ---
043D97             10801  ;
043D97             10802  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043D97             10803  ; Author:	Dean Belfield
043D97             10804  ; Created:	12/05/2023
043D97             10805  ; Last Updated:	12/05/2023
043D97             10806  ;
043D97             10807  ; Modinfo:
043D97             10808  
043D97             10809  			; INCLUDE	"equs.inc"
043D97             10810  			; INCLUDE	"macros.inc"
043D97             10811  
043D97             10812  			; .ASSUME	ADL = 1
043D97             10813  
043D97             10814  			; SEGMENT CODE
043D97             10815  
043D97             10816  			; XDEF	ASC_TO_NUMBER
043D97             10817  			; XDEF	SWITCH_A
043D97             10818  			; XDEF	NULLTOCR
043D97             10819  			; XDEF	CRTONULL
043D97             10820  			; XDEF	CSTR_FNAME
043D97             10821  			; XDEF	CSTR_LINE
043D97             10822  			; XDEF	CSTR_FINDCH
043D97             10823  			; XDEF	CSTR_ENDSWITH
043D97             10824  			; XDEF	CSTR_CAT
043D97             10825  
043D97             10826  			; XREF	OSWRCH
043D97             10827  			; XREF	KEYWDS
043D97             10828  			; XREF	KEYWDL
043D97             10829  
043D97             10830  ; Read a number and convert to binary
043D97             10831  ; If prefixed with &, will read as hex, otherwise decimal
043D97             10832  ;   Inputs: HL: Pointer in string buffer
043D97             10833  ;  Outputs: HL: Updated text pointer
043D97             10834  ;           DE: Value
043D97             10835  ;            A: Terminator (spaces skipped)
043D97             10836  ; Destroys: A,D,E,H,L,F
043D97             10837  ;
043D97 C5          10838  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043D98 11 00 00 00 10839  			LD	DE, 0			; Initialise DE
043D9C CD DE 3D 04 10840  			CALL	SKIPSPC			; Skip whitespace
043DA0 7E          10841  			LD	A, (HL)			; Read first character
043DA1 FE 26       10842  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DA3 20 1F       10843  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DA5 23          10844  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DA6             10845  ;
043DA6 7E          10846  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DA7 CD EC 3D 04 10847  			CALL    UPPERC			; Convert to uppercase
043DAB D6 30       10848  			SUB	'0'			; Normalise to 0
043DAD 38 2E       10849  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DAF FE 0A       10850  			CP 	10			; Check if >= 10
043DB1 38 06       10851  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DB3 D6 07       10852  			SUB 	7			; Adjust ASCII A-F to nibble
043DB5 FE 10       10853  			CP 	16			; Check for > F
043DB7 30 24       10854  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DB9 EB          10855  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DBA 29          10856  			ADD	HL, HL
043DBB 29          10857  			ADD	HL, HL
043DBC 29          10858  			ADD	HL, HL
043DBD 29          10859  			ADD	HL, HL
043DBE EB          10860  			EX	DE, HL
043DBF B3          10861  			OR      E			; OR the new digit in to the least significant nibble
043DC0 5F          10862  			LD      E, A
043DC1 23          10863  			INC     HL			; Onto the next character
043DC2 18 E2       10864  			JR      ASC_TO_NUMBER1		; And loop
043DC4             10865  ;
043DC4 7E          10866  ASC_TO_NUMBER3:		LD	A, (HL)
043DC5 D6 30       10867  			SUB	'0'			; Normalise to 0
043DC7 38 14       10868  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DC9 FE 0A       10869  			CP	10			; Check if >= 10
043DCB 30 10       10870  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043DCD EB          10871  			EX 	DE, HL 			; Stick DE in HL
043DCE 44          10872  			LD	B, H 			; And copy HL into BC
043DCF 4D          10873  			LD	C, L
043DD0 29          10874  			ADD	HL, HL 			; x 2
043DD1 29          10875  			ADD	HL, HL 			; x 4
043DD2 09          10876  			ADD	HL, BC 			; x 5
043DD3 29          10877  			ADD	HL, HL 			; x 10
043DD4 EB          10878  			EX	DE, HL
043DD5             10879  			ADD8U_DE 			; Add A to DE (macro)
043DD5 83          0001M 		ADD	A, E
043DD6 5F          0002M 		LD	E, A
043DD7 8A          0003M 		ADC	A, D
043DD8 93          0004M 		SUB	E
043DD9 57          0005M 		LD	D, A
043DDA 23          10880  			INC	HL
043DDB 18 E7       10881  			JR	ASC_TO_NUMBER3
043DDD C1          10882  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043DDE             10883  
043DDE             10884  ; Skip a space
043DDE             10885  ; HL: Pointer in string buffer
043DDE             10886  ;
043DDE 7E          10887  SKIPSPC:			LD      A, (HL)
043DDF FE 20       10888  			CP      ' '
043DE1 C0          10889  			RET     NZ
043DE2 23          10890  			INC     HL
043DE3 18 F9       10891  			JR      SKIPSPC
043DE5             10892  
043DE5             10893  ; Skip a string
043DE5             10894  ; HL: Pointer in string buffer
043DE5             10895  ;
043DE5 7E          10896  SKIPNOTSP:		LD	A, (HL)
043DE6 FE 20       10897  			CP	' '
043DE8 C8          10898  			RET	Z
043DE9 23          10899  			INC	HL
043DEA 18 F9       10900  			JR	SKIPNOTSP
043DEC             10901  
043DEC             10902  ; Convert a character to upper case
043DEC             10903  ;  A: Character to convert
043DEC             10904  ;
043DEC E6 7F       10905  UPPERC:  		AND     7FH
043DEE FE 60       10906  			CP      '`'
043DF0 D8          10907  			RET     C
043DF1 E6 5F       10908  			AND     5FH			; Convert to upper case
043DF3 C9          10909  			RET
043DF4             10910  
043DF4             10911  ; Switch on A - lookup table immediately after call
043DF4             10912  ;  A: Index into lookup table
043DF4             10913  ;
043DF4 E3          10914  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043DF5 87          10915  			ADD	A, A			; Multiply A by two
043DF6             10916  			ADD8U_HL 			; Add to HL (macro)
043DF6 85          0001M 		ADD	A, L
043DF7 6F          0002M 		LD	L, A
043DF8 8C          0003M 		ADC	A, H
043DF9 95          0004M 		SUB	L
043DFA 67          0005M 		LD	H, A
043DFB 7E          10917  			LD	A, (HL)			; follow the call. Fetch an address from the
043DFC 23          10918  			INC	HL 			; table.
043DFD 66          10919  			LD	H, (HL)
043DFE 6F          10920  			LD	L, A
043DFF E3          10921  			EX	(SP), HL		; Swap this new address back, restores HL
043E00 C9          10922  			RET				; Return program control to this new address
043E01             10923  
043E01             10924  ; Convert the buffer to a null terminated string and back
043E01             10925  ; HL: Buffer address
043E01             10926  ;
043E01 C5          10927  NULLTOCR:		PUSH 	BC
043E02 06 00       10928  			LD	B, 0
043E04 0E 0D       10929  			LD	C, CR
043E06 18 05       10930  			JR	CRTONULL0
043E08             10931  ;
043E08 C5          10932  CRTONULL:		PUSH	BC
043E09 06 0D       10933  			LD	B, CR
043E0B 0E 00       10934  			LD	C, 0
043E0D             10935  ;
043E0D E5          10936  CRTONULL0:		PUSH	HL
043E0E 7E          10937  CRTONULL1:		LD	A, (HL)
043E0F B8          10938  			CP 	B
043E10 28 03       10939  			JR	Z, CRTONULL2
043E12 23          10940  			INC	HL
043E13 18 F9       10941  			JR	CRTONULL1
043E15 71          10942  CRTONULL2:		LD	(HL), C
043E16 E1          10943  			POP 	HL
043E17 C1          10944  			POP	BC
043E18 C9          10945  			RET
043E19             10946  
043E19             10947  ; Copy a filename to DE and zero terminate it
043E19             10948  ; HL: Source
043E19             10949  ; DE: Destination (ACCS)
043E19             10950  ;
043E19 7E          10951  CSTR_FNAME:		LD	A, (HL)			; Get source
043E1A FE 20       10952  			CP	32			; Is it space
043E1C 28 09       10953  			JR	Z, @F
043E1E FE 0D       10954  			CP	CR			; Or is it CR
043E20 28 05       10955  			JR	Z, @F
043E22 12          10956  			LD	(DE), A			; No, so store
043E23 23          10957  			INC	HL			; Increment
043E24 13          10958  			INC	DE
043E25 18 F2       10959  			JR	CSTR_FNAME		; And loop
043E27 AF          10960  @@:			XOR	A			; Zero terminate the target string
043E28 12          10961  			LD	(DE), A
043E29 13          10962  			INC	DE			; And point to next free address
043E2A C9          10963  			RET
043E2B             10964  
043E2B             10965  ; Copy a CR terminated line to DE and zero terminate it
043E2B             10966  ; HL: Source
043E2B             10967  ; DE: Destination (ACCS)
043E2B             10968  ;
043E2B 7E          10969  CSTR_LINE:		LD	A, (HL)			; Get source
043E2C FE 0D       10970  			CP	CR			; Is it CR
043E2E 28 05       10971  			JR	Z, @F
043E30 12          10972  			LD	(DE), A			; No, so store
043E31 23          10973  			INC	HL			; Increment
043E32 13          10974  			INC	DE
043E33 18 F6       10975  			JR	CSTR_LINE		; And loop
043E35 AF          10976  @@:			XOR	A			; Zero terminate the target string
043E36 12          10977  			LD	(DE), A
043E37 13          10978  			INC	DE			; And point to next free address
043E38 C9          10979  			RET
043E39             10980  
043E39             10981  ; Find the first occurrence of a character (case sensitive)
043E39             10982  ; HL: Source
043E39             10983  ;  C: Character to find
043E39             10984  ; Returns:
043E39             10985  ; HL: Pointer to character, or end of string marker
043E39             10986  ;
043E39 7E          10987  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E3A B9          10988  			CP	C			; Is it our character?
043E3B C8          10989  			RET	Z			; Yes, so exit
043E3C B7          10990  			OR	A			; Is it the end of string?
043E3D C8          10991  			RET	Z			; Yes, so exit
043E3E 23          10992  			INC	HL
043E3F 18 F8       10993  			JR	CSTR_FINDCH
043E41             10994  
043E41             10995  ; Check whether a string ends with another string (case insensitive)
043E41             10996  ; HL: Source
043E41             10997  ; DE: The substring we want to test with
043E41             10998  ; Returns:
043E41             10999  ;  F: Z if HL ends with DE, otherwise NZ
043E41             11000  ;
043E41 7E          11001  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E42 CD EC 3D 04 11002  			CALL	UPPERC			; Convert to upper case
043E46 4F          11003  			LD	C, A
043E47 1A          11004  			LD	A, (DE)			; Get the substring byte
043E48 B9          11005  			CP	C
043E49 C0          11006  			RET	NZ			; Return NZ if at any point the strings don't match
043E4A B1          11007  			OR	C			; Check whether both bytes are zero
043E4B C8          11008  			RET	Z			; If so, return, as we have reached the end of both strings
043E4C 23          11009  			INC	HL
043E4D 13          11010  			INC	DE
043E4E 18 F1       11011  			JR	CSTR_ENDSWITH		; And loop
043E50             11012  
043E50             11013  ; Concatenate a string onto the end of another string
043E50             11014  ; HL: Source
043E50             11015  ; DE: Second string
043E50             11016  ;
043E50 7E          11017  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E51 B7          11018  			OR	A
043E52 28 03       11019  			JR	Z, CSTR_CAT_1
043E54 23          11020  			INC	HL
043E55 18 F9       11021  			JR	CSTR_CAT
043E57             11022  ;
043E57 1A          11023  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E58 77          11024  			LD	(HL), A
043E59 B7          11025  			OR	A			; Check for end of string
043E5A C8          11026  			RET	Z			; And return
043E5B 23          11027  			INC	HL
043E5C 13          11028  			INC	DE
043E5D 18 F8       11029  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E5F             11030  
043E5F             11031  ; --- Begin patch.asm ---
043E5F             11032  ;
043E5F             11033  ; Title:	BBC Basic for AGON
043E5F             11034  ; Author:	Dean Belfield
043E5F             11035  ; Created:	12/05/2023
043E5F             11036  ; Last Updated:	15/11/2023
043E5F             11037  ;
043E5F             11038  ; Modinfo:
043E5F             11039  ; 11/07/2023:	Fixed *BYE for ADL mode
043E5F             11040  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043E5F             11041  
043E5F             11042  			; .ASSUME	ADL = 1
043E5F             11043  
043E5F             11044  			; INCLUDE	"equs.inc"
043E5F             11045  			; INCLUDE "macros.inc"
043E5F             11046  			; INCLUDE "mos_api.inc"	; In MOS/src
043E5F             11047  
043E5F             11048  			; SEGMENT CODE
043E5F             11049  
043E5F             11050  			; XDEF	OSWRCH
043E5F             11051  			; XDEF	OSLINE
043E5F             11052  			; XDEF	ESCSET
043E5F             11053  			; XDEF	PUTIME
043E5F             11054  			; XDEF	GETIME
043E5F             11055  			; XDEF	PUTCSR
043E5F             11056  			; XDEF 	GETCSR
043E5F             11057  			; XDEF	OSRDCH
043E5F             11058  			; XDEF	PROMPT
043E5F             11059  			; XDEF	OSKEY
043E5F             11060  			; XDEF	TRAP
043E5F             11061  			; XDEF	LTRAP
043E5F             11062  			; XDEF	OSINIT
043E5F             11063  			; XDEF	OSCLI
043E5F             11064  			; XDEF	OSBPUT
043E5F             11065  			; XDEF	OSBGET
043E5F             11066  			; XDEF	OSSTAT
043E5F             11067  			; XDEF	OSSHUT
043E5F             11068  			; XDEF	OSOPEN
043E5F             11069  			; XDEF	OSCALL
043E5F             11070  			; XDEF	GETPTR
043E5F             11071  			; XDEF	PUTPTR
043E5F             11072  			; XDEF	GETEXT
043E5F             11073  			; XDEF	GETIMS
043E5F             11074  			; XDEF	RESET
043E5F             11075  			; XDEF	OSLOAD
043E5F             11076  			; XDEF	OSSAVE
043E5F             11077  			; XDEF	EXPR_W2
043E5F             11078  			; XDEF	STAR_VERSION
043E5F             11079  
043E5F             11080  			; XREF	_end			; In init.asm
043E5F             11081  
043E5F             11082  			; XREF	ASC_TO_NUMBER
043E5F             11083  			; XREF	RAM_START
043E5F             11084  			; XREF	RAM_END
043E5F             11085  			; XREF	FLAGS
043E5F             11086  			; XREF	ESCAPE
043E5F             11087  			; XREF	USER
043E5F             11088  			; XREF	RAM_Top
043E5F             11089  			; XREF	EXTERR
043E5F             11090  			; XREF	COUNT0
043E5F             11091  			; XREF	EXPRI
043E5F             11092  			; XREF	COMMA
043E5F             11093  			; XREF	XEQ
043E5F             11094  			; XREF	NXT
043E5F             11095  			; XREF	NULLTOCR
043E5F             11096  			; XREF	CRLF
043E5F             11097  			; XREF	CSTR_FNAME
043E5F             11098  			; XREF	CSTR_LINE
043E5F             11099  			; XREF	CSTR_FINDCH
043E5F             11100  			; XREF	CSTR_ENDSWITH
043E5F             11101  			; XREF	CSTR_CAT
043E5F             11102  			; XREF	FINDL
043E5F             11103  			; XREF	OUT_
043E5F             11104  			; XREF	ERROR_
043E5F             11105  			; XREF	ONEDIT
043E5F             11106  			; XREF	TELL
043E5F             11107  			; XREF	OSWRCHPT
043E5F             11108  			; XREF	OSWRCHCH
043E5F             11109  			; XREF	OSWRCHFH
043E5F             11110  			; XREF	LISTON
043E5F             11111  			; XREF	LISTIT
043E5F             11112  			; XREF	PAGE_
043E5F             11113  			; XREF	ONEDIT1
043E5F             11114  			; XREF	CLEAN
043E5F             11115  			; XREF	NEWIT
043E5F             11116  			; XREF	BAD
043E5F             11117  			; XREF	VBLANK_INIT
043E5F             11118  			; XREF	VBLANK_STOP
043E5F             11119  			; XREF	KEYDOWN
043E5F             11120  			; XREF	KEYASCII
043E5F             11121  			; XREF	WIDTH
043E5F             11122  			; XREF	ASSEM
043E5F             11123  
043E5F             11124  ; OSLINE: Invoke the line editor
043E5F             11125  ;
043E5F 1E 01       11126  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E61             11127  
043E61             11128  ; Entry point to line editor that does not clear the buffer
043E61             11129  ;
043E61 FD E5       11130  OSLINE1:		PUSH	IY
043E63 E5          11131  			PUSH	HL			; Buffer address
043E64 01 00 01 00 11132  			LD	BC, 256			; Buffer length
043E68             11133  			MOSCALL	mos_editline		; Call the MOS line editor
043E68 3E 09       0001M 			LD	A, function
043E6A 49 CF       0002M 			RST.LIS	08h
043E6C E1          11134  			POP	HL			; Pop the address
043E6D FD E1       11135  			POP	IY
043E6F F5          11136  			PUSH	AF			; Stack the return value (key pressed)
043E70 CD 01 3E 04 11137  			CALL	NULLTOCR		; Turn the 0 character to a CR
043E74 CD 47 39 04 11138  			CALL	CRLF			; Display CRLF
043E78 F1          11139  			POP	AF
043E79 FE 1B       11140  			CP	1Bh 			; Check if ESC terminated the input
043E7B CA 77 3F 04 11141  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043E7F 3A 42 4D 04 11142  			LD	A, (FLAGS)		; Otherwise
043E83 CB BF       11143  			RES	7, A 			; Clear the escape flag
043E85 32 42 4D 04 11144  			LD	(FLAGS), A
043E89 CD 3D 41 04 11145  			CALL	WAIT_VBLANK 		; Wait a frame
043E8D AF          11146   			XOR	A			; Return A = 0
043E8E 32 47 4D 04 11147  			LD	(KEYDOWN), A
043E92 32 48 4D 04 11148  			LD	(KEYASCII), A
043E96 C9          11149  			RET
043E97             11150  
043E97             11151  ; PUTIME: set current time to DE:HL, in centiseconds.
043E97             11152  ;
043E97 DD E5       11153  PUTIME:			PUSH 	IX
043E99             11154  			MOSCALL	mos_sysvars
043E99 3E 08       0001M 			LD	A, function
043E9B 49 CF       0002M 			RST.LIS	08h
043E9D DD 75 00    11155  			LD	(IX + sysvar_time + 0), L
043EA0 DD 74 01    11156  			LD	(IX + sysvar_time + 1), H
043EA3 DD 73 02    11157  			LD	(IX + sysvar_time + 2), E
043EA6 DD 72 03    11158  			LD	(IX + sysvar_time + 3), D
043EA9 DD E1       11159  			POP	IX
043EAB C9          11160  			RET
043EAC             11161  
043EAC             11162  ; GETIME: return current time in DE:HL, in centiseconds
043EAC             11163  ;
043EAC DD E5       11164  GETIME:			PUSH 	IX
043EAE             11165  			MOSCALL	mos_sysvars
043EAE 3E 08       0001M 			LD	A, function
043EB0 49 CF       0002M 			RST.LIS	08h
043EB2 DD 6E 00    11166  			LD	L, (IX + sysvar_time + 0)
043EB5 DD 66 01    11167  			LD	H, (IX + sysvar_time + 1)
043EB8 DD 5E 02    11168  			LD	E, (IX + sysvar_time + 2)
043EBB DD 56 03    11169  			LD	D, (IX + sysvar_time + 3)
043EBE DD E1       11170  			POP	IX
043EC0 C9          11171  			RET
043EC1             11172  
043EC1             11173  ; PUTCSR: move to cursor to x=DE, y=HL
043EC1             11174  ;
043EC1 3E 1F       11175  PUTCSR:			LD	A, 1Fh			; TAB
043EC3 5B D7       11176  			RST.LIL	10h
043EC5 7B          11177  			LD	A, E			; X
043EC6 5B D7       11178  			RST.LIL 10h
043EC8 7D          11179  			LD	A, L			; Y
043EC9 5B D7       11180  			RST.LIL 10h
043ECB C9          11181  			RET
043ECC             11182  
043ECC             11183  ; GETCSR: return cursor position in x=DE, y=HL
043ECC             11184  ;
043ECC DD E5       11185  GETCSR:			PUSH	IX			; Get the system vars in IX
043ECE             11186  			MOSCALL	mos_sysvars		; Reset the semaphore
043ECE 3E 08       0001M 			LD	A, function
043ED0 49 CF       0002M 			RST.LIS	08h
043ED2 DD CB 04 86 11187  			RES	0, (IX+sysvar_vpd_pflags)
043ED6             11188  			VDU	23
043ED6 3E 17       0001M 		LD	A, val
043ED8 CD 00 3F 04 0002M 		CALL	OSWRCH
043EDC             11189  			VDU	0
043EDC 3E 00       0001M 		LD	A, val
043EDE CD 00 3F 04 0002M 		CALL	OSWRCH
043EE2             11190  			VDU	vdp_cursor
043EE2 3E 82       0001M 		LD	A, val
043EE4 CD 00 3F 04 0002M 		CALL	OSWRCH
043EE8 DD CB 04 46 11191  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043EEC 28 FA       11192  			JR	Z, @B			; Wait for the result
043EEE 16 00       11193  			LD 	D, 0
043EF0 62          11194  			LD	H, D
043EF1 DD 5E 07    11195  			LD	E, (IX + sysvar_cursorX)
043EF4 DD 6E 08    11196  			LD	L, (IX + sysvar_cursorY)
043EF7 DD E1       11197  			POP	IX
043EF9 C9          11198  			RET
043EFA             11199  
043EFA             11200  ; PROMPT: output the input prompt
043EFA             11201  ;
043EFA 3E 3E       11202  PROMPT: 		LD	A,'>'
043EFC C3 00 3F 04 11203  			JP	OSWRCH
043F00             11204  
043F00             11205  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F00             11206  ; A: Character to write
043F00             11207  ;
043F00 E5          11208  OSWRCH:			PUSH	HL
043F01 21 40 4D 04 11209  			LD	HL, LISTON		; Fetch the LISTON variable
043F05 CB 5E       11210  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F07 20 0B       11211  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F09             11212  ;
043F09 2A 45 4D 04 11213  			LD	HL, (OSWRCHCH)		; L: Channel #
043F0D 2D          11214  			DEC	L			; If it is 1
043F0E 28 10       11215  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F10             11216  ;
043F10 E1          11217  			POP	HL			; Otherwise
043F11 5B D7       11218  			RST.LIL	10h			; Output the character to MOS
043F13 C9          11219  			RET
043F14             11220  ;
043F14 2A 43 4D 04 11221  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F18 77          11222  			LD	(HL), A			; Echo the character into the buffer
043F19 23          11223  			INC	HL			; Increment pointer
043F1A 22 43 4D 04 11224  			LD	(OSWRCHPT), HL		; Write pointer back
043F1E E1          11225  			POP	HL
043F1F C9          11226  			RET
043F20             11227  ;
043F20 D5          11228  OSWRCH_FILE:		PUSH	DE
043F21 5C          11229  			LD	E, H			; Filehandle to E
043F22 CD 3B 43 04 11230  			CALL	OSBPUT			; Write the byte out
043F26 D1          11231  			POP	DE
043F27 E1          11232  			POP	HL
043F28 C9          11233  			RET
043F29             11234  
043F29             11235  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F29             11236  ; This is only called in GETS (eval.asm)
043F29             11237  ;
043F29             11238  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F29 3E 00       0001M 			LD	A, function
043F2B 49 CF       0002M 			RST.LIS	08h
043F2D FE 1B       11239  			CP	1Bh
043F2F 28 46       11240  			JR	Z, LTRAP1
043F31 C9          11241  			RET
043F32             11242  
043F32             11243  
043F32             11244  ;OSKEY - Read key with time-limit, test for ESCape.
043F32             11245  ;Main function is carried out in user patch.
043F32             11246  ;   Inputs: HL = time limit (centiseconds)
043F32             11247  ;  Outputs: Carry reset if time-out
043F32             11248  ;           If carry set A = character
043F32             11249  ; Destroys: A,H,L,F
043F32             11250  ;
043F32 CD 63 3F 04 11251  OSKEY:			CALL	READKEY			; Read the keyboard
043F36 28 0A       11252  			JR	Z, @F 			; Skip if we have a key
043F38 7C          11253  			LD	A, H 			; Check loop counter
043F39 B5          11254  			OR 	L
043F3A C8          11255  			RET 	Z 			; Return, we've not got a key at this point
043F3B CD 3D 41 04 11256  			CALL	WAIT_VBLANK 		; Wait a frame
043F3F 2B          11257  			DEC 	HL			; Decrement
043F40 18 F0       11258  			JR	OSKEY 			; And loop
043F42             11259  ;
043F42 21 47 4D 04 11260  @@:			LD	HL, KEYDOWN		; We have a key, so
043F46 36 00       11261  			LD	(HL), 0			; clear the keydown flag
043F48 FE 1B       11262  			CP	1BH			; If we are not pressing ESC,
043F4A 37          11263  			SCF 				; then flag we've got a character
043F4B C0          11264  			RET	NZ
043F4C             11265  ;
043F4C             11266  ; ESCSET
043F4C             11267  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043F4C             11268  ;
043F4C E5          11269  ESCSET: 		PUSH    HL
043F4D 21 42 4D 04 11270          		LD      HL,FLAGS		; Pointer to FLAGS
043F51 CB 76       11271          		BIT     6,(HL)			; If bit 6 is set, then
043F53 20 02       11272          		JR      NZ,ESCDIS		; escape is disabled, so skip
043F55 CB FE       11273          		SET     7,(HL)			; Set bit 7, the escape flag
043F57 E1          11274  ESCDIS: 		POP     HL
043F58 C9          11275          		RET
043F59             11276  ;
043F59             11277  ; ESCTEST
043F59             11278  ; Test for ESC key
043F59             11279  ;
043F59 CD 63 3F 04 11280  ESCTEST:		CALL	READKEY			; Read the keyboard
043F5D C0          11281  			RET	NZ			; Skip if no key is pressed
043F5E FE 1B       11282  			CP	1BH			; If ESC pressed then
043F60 28 EA       11283  			JR	Z,ESCSET		; jump to the escape set routine
043F62 C9          11284  			RET
043F63             11285  
043F63             11286  ; Read the keyboard
043F63             11287  ; Returns:
043F63             11288  ; - A: ASCII of the pressed key
043F63             11289  ; - F: Z if the key is pressed, otherwise NZ
043F63             11290  ;
043F63 3A 47 4D 04 11291  READKEY:		LD	A, (KEYDOWN)		; Get key down
043F67 3D          11292  			DEC	A 			; Set Z flag if keydown is 1
043F68 3A 48 4D 04 11293  			LD	A, (KEYASCII)		; Get key ASCII value
043F6C C9          11294  			RET
043F6D             11295  ;
043F6D             11296  ; TRAP
043F6D             11297  ; This is called whenever BASIC needs to check for ESC
043F6D             11298  ;
043F6D CD 59 3F 04 11299  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043F71             11300  ;
043F71 3A 42 4D 04 11301  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043F75 B7          11302  			OR	A			; This checks for bit 7; if it is not set then the result will
043F76 F0          11303  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043F77 21 42 4D 04 11304  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043F7B CB BE       11305  			RES	7,(HL)			; Clear the escape pressed flag and
043F7D C3 9B 0C 04 11306  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043F81             11307  
043F81             11308  ;OSINIT - Initialise RAM mapping etc.
043F81             11309  ;If BASIC is entered by BBCBASIC FILENAME then file
043F81             11310  ;FILENAME.BBC is automatically CHAINed.
043F81             11311  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043F81             11312  ;            HL = initial value of PAGE (user program)
043F81             11313  ;            Z-flag reset indicates AUTO-RUN.
043F81             11314  ;  Destroys: A,D,E,H,L,F
043F81             11315  ;
043F81 CD E0 48 04 11316  OSINIT:			CALL	VBLANK_INIT
043F85 AF          11317  			XOR	A
043F86 21 00 4E 04 11318  			LD 	HL, USER
043F8A 11 00 00 0B 11319  			LD	DE, RAM_Top
043F8E 5F          11320  			LD	E, A			; Page boundary
043F8F C9          11321  			RET
043F90             11322  
043F90             11323  ;
043F90             11324  ;OSCLI - Process a MOS command
043F90             11325  ;
043F90 CD 04 40 04 11326  OSCLI: 			CALL    SKIPSP
043F94 FE 0D       11327  			CP      CR
043F96 C8          11328  			RET     Z
043F97 FE 7C       11329  			CP      '|'
043F99 C8          11330  			RET     Z
043F9A EB          11331  			EX      DE,HL
043F9B 21 13 40 04 11332  			LD      HL,COMDS
043F9F 1A          11333  OSCLI0:			LD      A,(DE)
043FA0 CD 0B 40 04 11334  			CALL    UPPRC
043FA4 BE          11335  			CP      (HL)
043FA5 28 0B       11336  			JR      Z,OSCLI2
043FA7 38 30       11337  			JR      C,OSCLI6
043FA9 CB 7E       11338  OSCLI1:			BIT     7,(HL)
043FAB 23          11339  			INC     HL
043FAC 28 FB       11340  			JR      Z,OSCLI1
043FAE 23          11341  			INC     HL
043FAF 23          11342  			INC     HL
043FB0 18 ED       11343  			JR      OSCLI0
043FB2             11344  ;
043FB2 D5          11345  OSCLI2:			PUSH    DE
043FB3 13          11346  OSCLI3:			INC     DE
043FB4 23          11347  			INC     HL
043FB5 1A          11348  			LD      A,(DE)
043FB6 CD 0B 40 04 11349  			CALL    UPPRC
043FBA FE 2E       11350  			CP      '.'			; ABBREVIATED?
043FBC 28 0A       11351  			JR      Z,OSCLI4
043FBE AE          11352  			XOR     (HL)
043FBF 28 F2       11353  			JR      Z,OSCLI3
043FC1 FE 80       11354  			CP      80H
043FC3 28 03       11355  			JR      Z,OSCLI4
043FC5 D1          11356  			POP     DE
043FC6 18 E1       11357  			JR      OSCLI1
043FC8             11358  ;
043FC8 F1          11359  OSCLI4:			POP     AF
043FC9 13          11360  		        INC     DE
043FCA CB 7E       11361  OSCLI5:			BIT     7,(HL)
043FCC 23          11362  			INC     HL
043FCD 28 FB       11363  			JR      Z,OSCLI5
043FCF 7E          11364  			LD      A,(HL)
043FD0 23          11365  			INC     HL
043FD1 66          11366  			LD      H,(HL)
043FD2 6F          11367  			LD      L,A
043FD3 E5          11368  			PUSH    HL
043FD4 EB          11369  			EX      DE,HL
043FD5 C3 04 40 04 11370  			JP      SKIPSP
043FD9             11371  ;
043FD9 EB          11372  OSCLI6:			EX	DE, HL			; HL: Buffer for command
043FDA 11 00 4A 04 11373  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
043FDE D5          11374  			PUSH	DE			; Store buffer address
043FDF CD 2B 3E 04 11375  			CALL	CSTR_LINE		; Fetch the line
043FE3 E1          11376  			POP	HL			; HL: Pointer to command string in ACCS
043FE4 FD E5       11377  			PUSH	IY
043FE6             11378  			MOSCALL	mos_oscli		; Returns OSCLI error in A
043FE6 3E 10       0001M 			LD	A, function
043FE8 49 CF       0002M 			RST.LIS	08h
043FEA FD E1       11379  			POP	IY
043FEC B7          11380  			OR	A			; 0 means MOS returned OK
043FED C8          11381  			RET	Z			; So don't do anything
043FEE C3 17 42 04 11382  			JP 	OSERROR			; Otherwise it's a MOS error
043FF2             11383  
043FF2 3E FE       11384  HUH:    		LD      A,254			; Bad command error
043FF4 CD 77 37 04 11385          		CALL    EXTERR
043FF8 42 61 64 20 11386          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044003 00          11387          		DEFB    0
044004             11388  
044004 7E          11389  SKIPSP:			LD      A,(HL)
044005 FE 20       11390          		CP      ' '
044007 C0          11391          		RET     NZ
044008 23          11392          		INC     HL
044009 18 F9       11393          		JR      SKIPSP
04400B             11394  
04400B E6 7F       11395  UPPRC:  		AND     7FH
04400D FE 60       11396  			CP      '`'
04400F D8          11397  			RET     C
044010 E6 5F       11398  			AND     5FH			; CONVERT TO UPPER CASE
044012 C9          11399  			RET
044013             11400  
044013             11401  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044013             11402  ; These must be in alphabetical order
044013             11403  ;
044013             11404  ; BEGIN NOT FOUND IN BINARY
044013             11405  ; COMDS:  		DB	"AS","M"+80h		; ASM
044013             11406  ; 			DW	STAR_ASM
044013             11407  ; 			DB	"BY","E"+80h		; BYE
044013             11408  ; 			DW	STAR_BYE
044013             11409  ; 			DB	"EDI","T"+80h		; EDIT
044013             11410  ; 			DW	STAR_EDIT
044013             11411  ; 			DB	"F","X"+80h		; FX
044013             11412  ; 			DW	STAR_FX
044013             11413  ; 			DB	"VERSIO","N"+80h	; VERSION
044013             11414  ; 			DW	STAR_VERSION
044013             11415  ; 			DB	FFh
044013             11416  ; END NOT FOUND IN BINARY
044013             11417  ; BEGIN INSERTED FROM BINARY
044013             11418  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044013             11419  ; These must be in alphabetical order
044013             11420  ;
044013             11421  COMDS:
044013 42          11422  	db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
044014 59          11423  	db 0x59 ; 044014
044015 C5          11424  	db 0xc5 ; 044015
044016 2C          11425  	db 0x2c ; 044016 31     11405 DW	STAR_ASM
044017 40          11426  	db 0x40 ; 044017
044018 45          11427  	db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
044019 44          11428  	db 0x44 ; 044019
04401A 49          11429  	db 0x49 ; 04401A
04401B D4          11430  	db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
04401C 61          11431  	db 0x61 ; 04401C
04401D 40          11432  	db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
04401E 46          11433  	db 0x46 ; 04401E
04401F D8          11434  	db 0xd8 ; 04401F
044020 A1          11435  	db 0xa1 ; 044020
044021 40          11436  	db 0x40 ; 044021 72     11409 DW	STAR_EDIT
044022 56          11437  	db 0x56 ; 044022
044023 45          11438  	db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
044024 52          11439  	db 0x52 ; 044024
044025 53          11440  	db 0x53 ; 044025 B2     11411 DW	STAR_FX
044026 49          11441  	db 0x49 ; 044026
044027 4F          11442  	db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
044028 CE          11443  	db 0xce ; 044028
044029 38          11444  	db 0x38 ; 044029
04402A 40          11445  	db 0x40 ; 04402A
04402B FF          11446  	db 0xff ; 04402B
04402C             11447  ; END INSERTED FROM BINARY
04402C             11448  
04402C             11449  ; BEGIN NOT FOUND IN BINARY
04402C             11450  ; ; *ASM string
04402C             11451  ; ;
04402C             11452  ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
04402C             11453  ; 			PUSH	HL			; HL = IY
04402C             11454  ; 			POP	IY
04402C             11455  ; 			CALL	ASSEM			; Invoke the assembler
04402C             11456  ; 			POP	IY
04402C             11457  ; 			RET
04402C             11458  ; END NOT FOUND IN BINARY
04402C             11459  
04402C             11460  ; *BYE
04402C             11461  ;
04402C CD F4 48 04 11462  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044030 21 00 00 00 11463  			LD	HL, 0			; The return value
044034 C3 68 00 04 11464  			JP	_end 			; Jump back to the end routine in init.asm
044038             11465  
044038             11466  ; *VERSION
044038             11467  ;
044038 CD 90 3D 04 11468  STAR_VERSION:		CALL    TELL			; Output the welcome message
04403C 42 42 43 20 11469  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
044060 C9          11470  			RET
044061             11471  
044061             11472  ; *EDIT linenum
044061             11473  ;
044061 CD 97 3D 04 11474  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
044065 EB          11475  			EX	DE, HL			; HL: Line number
044066 CD 8F 39 04 11476  			CALL	FINDL			; HL: Address in RAM of tokenised line
04406A 3E 29       11477  			LD	A, 41			; F:NZ If the line is not found
04406C C2 60 37 04 11478  			JP	NZ, ERROR_		; Do error 41: No such line in that case
044070             11479  ;
044070             11480  ; Use LISTIT to output the line to the ACCS buffer
044070             11481  ;
044070 23          11482  			INC	HL			; Skip the length byte
044071 5E          11483  			LD	E, (HL)			; Fetch the line number
044072 23          11484  			INC	HL
044073 56          11485  			LD	D, (HL)
044074 23          11486  			INC	HL
044075 DD 21 00 4A 11487  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
04407A DD 22 43 4D 11488  			LD	(OSWRCHPT), IX
       04          
04407F DD 21 40 4D 11489  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
044084 DD 7E 00    11490  			LD	A, (IX)			; Store that variable
044087 F5          11491  			PUSH	AF
044088 DD 36 00 09 11492  			LD	(IX), 09h		; Set to echo to buffer
04408C CD 92 38 04 11493  			CALL	LISTIT
044090 F1          11494  			POP	AF
044091 DD 77 00    11495  			LD	(IX), A			; Restore the original LISTON variable
044094 21 00 4A 04 11496  			LD	HL, ACCS		; HL: ACCS
044098 5D          11497  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044099 CD 61 3E 04 11498  			CALL	OSLINE1			; Invoke the editor
04409D C3 D0 30 04 11499  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440A1             11500  
0440A1             11501  ; OSCLI FX n
0440A1             11502  ;
0440A1 CD 97 3D 04 11503  STAR_FX:		CALL	ASC_TO_NUMBER
0440A5 4B          11504  			LD	C, E			; C: Save FX #
0440A6 CD 97 3D 04 11505  			CALL	ASC_TO_NUMBER
0440AA 7A          11506  			LD	A, D  			; Is first parameter > 255?
0440AB B7          11507  			OR 	A
0440AC 28 03       11508  			JR	Z, STAR_FX1		; Yes, so skip next bit
0440AE EB          11509  			EX	DE, HL 			; Parameter is 16-bit
0440AF 18 07       11510  			JR	STAR_FX2
0440B1             11511  ;
0440B1 43          11512  STAR_FX1:		LD	B, E 			; B: Save First parameter
0440B2 CD 97 3D 04 11513  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0440B6 68          11514  			LD	L, B 			; L: First parameter
0440B7 63          11515  			LD	H, E 			; H: Second parameter
0440B8             11516  ;
0440B8 79          11517  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0440B9             11518  ;
0440B9             11519  ; OSBYTE
0440B9             11520  ;  A: FX #
0440B9             11521  ;  L: First parameter
0440B9             11522  ;  H: Second parameter
0440B9             11523  ;
0440B9 FE 0B       11524  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0440BB 28 18       11525  			JR	Z, OSBYTE_0B
0440BD FE 0C       11526  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0440BF 28 43       11527  			JR	Z, OSBYTE_0C
0440C1 FE 13       11528  			CP	13H			; *FX 19: Wait for vblank
0440C3 28 6E       11529  			JR	Z, OSBYTE_13
0440C5 FE 76       11530  			CP	76H			; *FX 118, n: Set keyboard LED
0440C7 CA 4E 41 04 11531  			JP	Z, OSBYTE_76
0440CB FE A0       11532  			CP	A0H
0440CD CA 7E 41 04 11533  			JP	Z, OSBYTE_A0
0440D1 C3 F2 3F 04 11534  			JP	HUH			; Anything else trips an error
0440D5             11535  
0440D5             11536  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0440D5             11537  ; Parameters:
0440D5             11538  ; - HL: Repeat delay
0440D5             11539  ;
0440D5             11540  OSBYTE_0B:		VDU	23
0440D5 3E 17       0001M 		LD	A, val
0440D7 CD 00 3F 04 0002M 		CALL	OSWRCH
0440DB             11541  			VDU	0
0440DB 3E 00       0001M 		LD	A, val
0440DD CD 00 3F 04 0002M 		CALL	OSWRCH
0440E1             11542  			VDU	vdp_keystate
0440E1 3E 88       0001M 		LD	A, val
0440E3 CD 00 3F 04 0002M 		CALL	OSWRCH
0440E7             11543  			VDU	L
0440E7 7D          0001M 		LD	A, val
0440E8 CD 00 3F 04 0002M 		CALL	OSWRCH
0440EC             11544  			VDU	H
0440EC 7C          0001M 		LD	A, val
0440ED CD 00 3F 04 0002M 		CALL	OSWRCH
0440F1             11545  			VDU	0
0440F1 3E 00       0001M 		LD	A, val
0440F3 CD 00 3F 04 0002M 		CALL	OSWRCH
0440F7             11546  			VDU 	0
0440F7 3E 00       0001M 		LD	A, val
0440F9 CD 00 3F 04 0002M 		CALL	OSWRCH
0440FD             11547  			VDU	255
0440FD 3E FF       0001M 		LD	A, val
0440FF CD 00 3F 04 0002M 		CALL	OSWRCH
044103 C9          11548  			RET
044104             11549  
044104             11550  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
044104             11551  ; Parameters:
044104             11552  ; - HL: Repeat rate
044104             11553  ;
044104             11554  OSBYTE_0C:		VDU	23
044104 3E 17       0001M 		LD	A, val
044106 CD 00 3F 04 0002M 		CALL	OSWRCH
04410A             11555  			VDU	0
04410A 3E 00       0001M 		LD	A, val
04410C CD 00 3F 04 0002M 		CALL	OSWRCH
044110             11556  			VDU	vdp_keystate
044110 3E 88       0001M 		LD	A, val
044112 CD 00 3F 04 0002M 		CALL	OSWRCH
044116             11557  			VDU	0
044116 3E 00       0001M 		LD	A, val
044118 CD 00 3F 04 0002M 		CALL	OSWRCH
04411C             11558  			VDU 	0
04411C 3E 00       0001M 		LD	A, val
04411E CD 00 3F 04 0002M 		CALL	OSWRCH
044122             11559  			VDU	L
044122 7D          0001M 		LD	A, val
044123 CD 00 3F 04 0002M 		CALL	OSWRCH
044127             11560  			VDU	H
044127 7C          0001M 		LD	A, val
044128 CD 00 3F 04 0002M 		CALL	OSWRCH
04412C             11561  			VDU	255
04412C 3E FF       0001M 		LD	A, val
04412E CD 00 3F 04 0002M 		CALL	OSWRCH
044132 C9          11562  			RET
044133             11563  
044133             11564  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
044133             11565  ;
044133 CD 3D 41 04 11566  OSBYTE_13:		CALL	WAIT_VBLANK
044137 2E 00       11567  			LD	L, 0			; Returns 0
044139 C3 7F 05 04 11568  			JP	COUNT0
04413D             11569  ;
04413D DD E5       11570  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
04413F             11571  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
04413F 3E 08       0001M 			LD	A, function
044141 49 CF       0002M 			RST.LIS	08h
044143 DD 7E 00    11572  			LD	A, (IX + sysvar_time + 0)
044146 DD BE 00    11573  @@:			CP 	A, (IX + sysvar_time + 0)
044149 28 FB       11574  			JR	Z, @B
04414B DD E1       11575  			POP	IX
04414D C9          11576  			RET
04414E             11577  
04414E             11578  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
04414E             11579  ; Parameters:
04414E             11580  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
04414E             11581  ;
04414E             11582  OSBYTE_76:		VDU	23
04414E 3E 17       0001M 		LD	A, val
044150 CD 00 3F 04 0002M 		CALL	OSWRCH
044154             11583  			VDU	0
044154 3E 00       0001M 		LD	A, val
044156 CD 00 3F 04 0002M 		CALL	OSWRCH
04415A             11584  			VDU	vdp_keystate
04415A 3E 88       0001M 		LD	A, val
04415C CD 00 3F 04 0002M 		CALL	OSWRCH
044160             11585  			VDU	0
044160 3E 00       0001M 		LD	A, val
044162 CD 00 3F 04 0002M 		CALL	OSWRCH
044166             11586  			VDU 	0
044166 3E 00       0001M 		LD	A, val
044168 CD 00 3F 04 0002M 		CALL	OSWRCH
04416C             11587  			VDU	0
04416C 3E 00       0001M 		LD	A, val
04416E CD 00 3F 04 0002M 		CALL	OSWRCH
044172             11588  			VDU	0
044172 3E 00       0001M 		LD	A, val
044174 CD 00 3F 04 0002M 		CALL	OSWRCH
044178             11589  			VDU	L
044178 7D          0001M 		LD	A, val
044179 CD 00 3F 04 0002M 		CALL	OSWRCH
04417D C9          11590  			RET
04417E             11591  
04417E             11592  ; OSBYTE 0xA0: Fetch system variable
04417E             11593  ; Parameters:
04417E             11594  ; - L: The system variable to fetch
04417E             11595  ;
04417E DD E5       11596  OSBYTE_A0:		PUSH	IX
044180             11597  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044180 3E 08       0001M 			LD	A, function
044182 49 CF       0002M 			RST.LIS	08h
044184 01 00 00 00 11598  			LD	BC, 0
044188 4D          11599  			LD	C, L			; BCU = L
044189 DD 09       11600  			ADD	IX, BC			; Add to IX
04418B DD 6E 00    11601  			LD	L, (IX + 0)		; Fetch the return value
04418E DD E1       11602  			POP	IX
044190 C3 7F 05 04 11603  			JP 	COUNT0
044194             11604  
044194             11605  ;OSLOAD - Load an area of memory from a file.
044194             11606  ;   Inputs: HL addresses filename (CR terminated)
044194             11607  ;           DE = address at which to load
044194             11608  ;           BC = maximum allowed size (bytes)
044194             11609  ;  Outputs: Carry reset indicates no room for file.
044194             11610  ; Destroys: A,B,C,D,E,H,L,F
044194             11611  ;
044194 C5          11612  OSLOAD:			PUSH	BC			; Stack the size
044195 D5          11613  			PUSH	DE			; Stack the load address
044196 11 00 4A 04 11614  			LD	DE, ACCS		; Buffer address for filename
04419A CD 19 3E 04 11615  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04419E 21 00 4A 04 11616  			LD	HL, ACCS		; HL: Filename
0441A2 CD 94 42 04 11617  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441A6 CD A8 42 04 11618  			CALL	EXT_HANDLER		; Get the default handler
0441AA D1          11619  			POP	DE			; Restore the load address
0441AB C1          11620  			POP	BC			; Restore the size
0441AC B7          11621  			OR	A
0441AD 28 60       11622  			JR 	Z, OSLOAD_BBC
0441AF             11623  ;
0441AF             11624  ; Load the file in as a text file
0441AF             11625  ;
0441AF AF          11626  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441B0 CD 1C 43 04 11627  			CALL	OSOPEN			; Open the file
0441B4 5F          11628  			LD 	E, A 			; The filehandle
0441B5 B7          11629  			OR	A
0441B6 3E 04       11630  			LD	A, 4			; File not found error
0441B8 28 5D       11631  			JR	Z, OSERROR		; Jump to error handler
0441BA CD 6C 38 04 11632  			CALL	NEWIT			; Call NEW to clear the program space
0441BE             11633  ;
0441BE 21 00 4A 04 11634  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0441C2             11635  ;
0441C2             11636  ; First skip any whitespace (indents) at the beginning of the input
0441C2             11637  ;
0441C2 CD 33 43 04 11638  @@:			CALL	OSBGET			; Read the byte into A
0441C6 38 1E       11639  			JR	C, OSLOAD_TXT3		; Is it EOF?
0441C8 FE 0A       11640  			CP	LF 			; Is it LF?
0441CA 28 1A       11641  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0441CC FE 21       11642  			CP	21h			; Is it less than or equal to ASCII space?
0441CE 38 F2       11643  			JR	C, @B 			; Yes, so keep looping
0441D0 77          11644  			LD	(HL), A 		; Store the first character
0441D1 2C          11645  			INC	L
0441D2             11646  ;
0441D2             11647  ; Now read the rest of the line in
0441D2             11648  ;
0441D2 CD 33 43 04 11649  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0441D6 38 2B       11650  			JR	C, OSLOAD_TXT4		; Is it EOF?
0441D8 FE 20       11651  			CP	20h			; Skip if not an ASCII character
0441DA 38 06       11652  			JR	C, @F
0441DC 77          11653  			LD	(HL), A 		; Store in the input buffer
0441DD 2C          11654  			INC	L			; Increment the buffer pointer
0441DE CA F8 36 04 11655  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0441E2 FE 0A       11656  @@:			CP	LF			; Check for LF
0441E4 20 EC       11657  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0441E6             11658  ;
0441E6             11659  ; Finally, handle EOL/EOF
0441E6             11660  ;
0441E6 36 0D       11661  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0441E8 7D          11662  			LD	A, L			; Check for minimum line length
0441E9 FE 02       11663  			CP	2			; If it is 2 characters or less (including CR)
0441EB 38 0A       11664  			JR	C, @F			; Then don't bother entering it
0441ED D5          11665  			PUSH	DE			; Preserve the filehandle
0441EE CD DC 30 04 11666  			CALL	ONEDIT1			; Enter the line in memory
0441F2 DC 3F 38 04 11667  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0441F6 D1          11668  			POP	DE
0441F7 CD 44 43 04 11669  @@:			CALL	OSSTAT			; End of file?
0441FB 20 C1       11670  			JR	NZ, OSLOAD_TXT1		; No, so loop
0441FD CD 2B 43 04 11671  			CALL	OSSHUT			; Close the file
044201 37          11672  			SCF				; Flag to BASIC that we're good
044202 C9          11673  			RET
044203             11674  ;
044203             11675  ; Special case for BASIC programs with no blank line at the end
044203             11676  ;
044203 FE 20       11677  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044205 38 06       11678  			JR	C, @F
044207 77          11679  			LD	(HL), A			; Store the character
044208 2C          11680  			INC	L
044209 CA F8 36 04 11681  			JP	Z, BAD
04420D 18 D7       11682  @@:			JR	OSLOAD_TXT3
04420F             11683  
04420F             11684  ;
04420F             11685  ; Load the file in as a tokenised binary blob
04420F             11686  ;
04420F             11687  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
04420F 3E 01       0001M 			LD	A, function
044211 49 CF       0002M 			RST.LIS	08h
044213 D0          11688  			RET	NC			; If load returns with carry reset - NO ROOM
044214 B7          11689  			OR	A			; If there is no error (A=0)
044215 37          11690  			SCF				; Need to set carry indicating there was room
044216 C8          11691  			RET	Z			; Return
044217             11692  ;
044217 F5          11693  OSERROR:		PUSH	AF			; Handle the MOS error
044218 21 00 4A 04 11694  			LD	HL, ACCS		; Address of the buffer
04421C 01 00 01 00 11695  			LD	BC, 256			; Length of the buffer
044220 5F          11696  			LD	E, A			; The error code
044221             11697  			MOSCALL	mos_getError		; Copy the error message into the buffer
044221 3E 0F       0001M 			LD	A, function
044223 49 CF       0002M 			RST.LIS	08h
044225 F1          11698  			POP	AF
044226 E5          11699  			PUSH	HL			; Stack the address of the error (now in ACCS)
044227 C6 7F       11700  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044229 C3 77 37 04 11701  			JP	EXTERR			; Trigger an external error
04422D             11702  
04422D             11703  ;OSSAVE - Save an area of memory to a file.
04422D             11704  ;   Inputs: HL addresses filename (term CR)
04422D             11705  ;           DE = start address of data to save
04422D             11706  ;           BC = length of data to save (bytes)
04422D             11707  ; Destroys: A,B,C,D,E,H,L,F
04422D             11708  ;
04422D C5          11709  OSSAVE:			PUSH	BC			; Stack the size
04422E D5          11710  			PUSH	DE			; Stack the save address
04422F 11 00 4A 04 11711  			LD	DE, ACCS		; Buffer address for filename
044233 CD 19 3E 04 11712  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044237 21 00 4A 04 11713  			LD	HL, ACCS		; HL: Filename
04423B CD 94 42 04 11714  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04423F CD A8 42 04 11715  			CALL	EXT_HANDLER		; Get the default handler
044243 D1          11716  			POP	DE			; Restore the save address
044244 C1          11717  			POP	BC			; Restore the size
044245 B7          11718  			OR	A			; Is the extension .BBC
044246 28 44       11719  			JR	Z, OSSAVE_BBC		; Yes, so use that
044248             11720  ;
044248             11721  ; Save the file out as a text file
044248             11722  ;
044248 3A 45 4D 04 11723  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
04424C F5          11724  			PUSH	AF
04424D AF          11725  			XOR	A
04424E 3C          11726  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
04424F 32 45 4D 04 11727  			LD	(OSWRCHCH), A
044253 CD 1C 43 04 11728  			CALL	OSOPEN			; Open the file
044257 32 46 4D 04 11729  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
04425B DD 21 40 4D 11730  			LD	IX, LISTON		; Required for LISTIT
       04          
044260 2A 14 4D 04 11731  			LD	HL, (PAGE_)		; Get start of program area
044264 D9          11732  			EXX
044265 01 00 00 00 11733  			LD	BC, 0			; Set the initial indent counters
044269 D9          11734  			EXX
04426A 7E          11735  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
04426B B7          11736  			OR	A
04426C 28 0F       11737  			JR	Z, OSSAVE_TXT2
04426E 23          11738  			INC	HL			; Skip the length byte
04426F 11 00 00 00 11739  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
044273 5E          11740  			LD	E, (HL)			; Get the line number
044274 23          11741  			INC	HL
044275 56          11742  			LD	D, (HL)
044276 23          11743  			INC	HL
044277 CD 92 38 04 11744  			CALL	LISTIT			; List the line
04427B 18 ED       11745  			JR	OSSAVE_TXT1
04427D 3A 46 4D 04 11746  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
044281 5F          11747  			LD	E, A
044282 CD 2B 43 04 11748  			CALL	OSSHUT			; Close it
044286 F1          11749  			POP	AF			; Restore the channel
044287 32 45 4D 04 11750  			LD	(OSWRCHCH), A
04428B C9          11751  			RET
04428C             11752  ;
04428C             11753  ; Save the file out as a tokenised binary blob
04428C             11754  ;
04428C             11755  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
04428C 3E 02       0001M 			LD	A, function
04428E 49 CF       0002M 			RST.LIS	08h
044290 B7          11756  			OR	A			; If there is no error (A=0)
044291 C8          11757  			RET	Z			; Just return
044292 18 83       11758  			JR	OSERROR			; Trip an error
044294             11759  
044294             11760  ; Check if an extension is specified in the filename
044294             11761  ; Add a default if not specified
044294             11762  ; HL: Filename (CSTR format)
044294             11763  ;
044294 E5          11764  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044295 0E 2E       11765  			LD	C, '.'			; Search for dot (marks start of extension)
044297 CD 39 3E 04 11766  			CALL	CSTR_FINDCH
04429B B7          11767  			OR	A			; Check for end of string marker
04429C 20 08       11768  			JR	NZ, @F			; No, so skip as we have an extension at this point
04429E 11 D8 42 04 11769  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442A2 CD 50 3E 04 11770  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442A6 E1          11771  @@:			POP	HL			; Restore the filename pointer
0442A7 C9          11772  			RET
0442A8             11773  
0442A8             11774  ; Check if an extension is valid and, if so, provide a pointer to a handler
0442A8             11775  ; HL: Filename (CSTR format)
0442A8             11776  ; Returns:
0442A8             11777  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0442A8             11778  ;
0442A8 E5          11779  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442A9 0E 2E       11780  			LD	C, '.'			; Find the '.'
0442AB CD 39 3E 04 11781  			CALL	CSTR_FINDCH
0442AF 11 D8 42 04 11782  			LD	DE, EXT_LOOKUP		; The lookup table
0442B3             11783  ;
0442B3 E5          11784  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442B4 CD 41 3E 04 11785  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442B8 E1          11786  			POP	HL			; Restore the pointer to the extension
0442B9 28 19       11787  			JR	Z, EXT_HANDLER_2	; We have a match!
0442BB             11788  ;
0442BB 1A          11789  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0442BC 13          11790  			INC	DE
0442BD B7          11791  			OR	A
0442BE 20 FB       11792  			JR	NZ, @B
0442C0 13          11793  			INC	DE			; Skip the file extension # byte
0442C1             11794  ;
0442C1 1A          11795  			LD	A, (DE)			; Are we at the end of the table?
0442C2 B7          11796  			OR	A
0442C3 20 EE       11797  			JR	NZ, EXT_HANDLER_1	; No, so loop
0442C5             11798  ;
0442C5 3E CC       11799  			LD      A,204			; Throw a "Bad name" error
0442C7 CD 77 37 04 11800          		CALL    EXTERR
0442CB 42 61 64 20 11801          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0442D4             11802  ;
0442D4 13          11803  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0442D5 1A          11804  			LD	A, (DE)
0442D6 E1          11805  			POP	HL			; Restore the filename pointer
0442D7 C9          11806  			RET
0442D8             11807  ;
0442D8             11808  
0442D8             11809  
0442D8             11810  ; Extension lookup table
0442D8             11811  ; CSTR, TYPE
0442D8             11812  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0442D8             11813  ; 	- 1: Human readable plain text
0442D8             11814  ;
0442D8 2E 42 42 43 11815  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0442DE 2E 54 58 54 11816  			DB	".TXT", 0, 1
       00 01       
0442E4 2E 41 53 43 11817  			DB	".ASC", 0, 1
       00 01       
0442EA 2E 42 41 53 11818  			DB	".BAS", 0, 1
       00 01       
0442F0 00          11819  			DB	0			; End of table
0442F1             11820  
0442F1             11821  ;OSCALL - Intercept page &FF calls and provide an alternative address
0442F1             11822  ;
0442F1             11823  ;&FFF7:	OSCLI	Execute *command.
0442F1             11824  ;&FFF4:	OSBYTE	Various byte-wide functions.
0442F1             11825  ;&FFF1:	OSWORD	Various control block functions.
0442F1             11826  ;&FFEE:	OSWRCH	Write character to output stream.
0442F1             11827  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0442F1             11828  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0442F1             11829  ;&FFE0:	OSRDCH	Wait for character from input stream.
0442F1             11830  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0442F1             11831  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0442F1             11832  ;&FFD7:	OSBGET	Read a byte from an a channel.
0442F1             11833  ;&FFD4:	OSBPUT	Write a byte to a channel.
0442F1             11834  ;&FFD1:	OSGBPB	Read and write blocks of data.
0442F1             11835  ;&FFCE:	OSFIND	Open or close a file.
0442F1             11836  ;
0442F1 21 07 43 04 11837  OSCALL:			LD	HL, OSCALL_TABLE
0442F5 7E          11838  OSCALL_1:		LD	A, (HL)
0442F6 23          11839  			INC	HL
0442F7 FE FF       11840  			CP	FFh
0442F9 C8          11841  			RET	Z
0442FA FD BD       11842  			CP	A, IYL
0442FC 28 06       11843  			JR	Z, OSCALL_2
0442FE D0          11844  			RET	NC
0442FF 23          11845  			INC	HL
044300 23          11846  			INC	HL
044301 23          11847  			INC	HL
044302 18 F1       11848  			JR	OSCALL_1
044304 ED 31       11849  OSCALL_2:		LD	IY,(HL)
044306 C9          11850  			RET
044307 D4          11851  OSCALL_TABLE:		DB 	D4h
044308 3B 43 04    11852  			DW24 	OSBPUT
04430B D7          11853  			DB 	D7h
04430C 33 43 04    11854  			DW24 	OSBGET
04430F EE          11855  			DB 	EEh
044310 00 3F 04    11856  			DW24 	OSWRCH
044313 F4          11857  			DB	F4h
044314 B9 40 04    11858  			DW24 	OSBYTE
044317 F7          11859  			DB	F7h
044318 90 3F 04    11860  			DW24	OSCLI
04431B FF          11861  			DB	FFh
04431C             11862  
04431C             11863  ; OSOPEN
04431C             11864  ; HL: Pointer to path
04431C             11865  ;  F: C Z
04431C             11866  ;     x x OPENIN
04431C             11867  ; 	  OPENOUT
04431C             11868  ;     x	  OPENUP
04431C             11869  ; Returns:
04431C             11870  ;  A: Filehandle, 0 if cannot open
04431C             11871  ;
04431C 0E 01       11872  OSOPEN:			LD	C, fa_read
04431E 28 06       11873  			JR	Z, @F
044320 0E 32       11874  			LD	C, fa_write | fa_open_append
044322 38 02       11875  			JR	C, @F
044324 0E 0A       11876  			LD	C, fa_write | fa_create_always
044326             11877  @@:			MOSCALL	mos_fopen
044326 3E 0A       0001M 			LD	A, function
044328 49 CF       0002M 			RST.LIS	08h
04432A C9          11878  			RET
04432B             11879  
04432B             11880  ;OSSHUT - Close disk file(s).
04432B             11881  ; E = file channel
04432B             11882  ;  If E=0 all files are closed (except SPOOL)
04432B             11883  ; Destroys: A,B,C,D,E,H,L,F
04432B             11884  ;
04432B C5          11885  OSSHUT:			PUSH	BC
04432C 4B          11886  			LD	C, E
04432D             11887  			MOSCALL	mos_fclose
04432D 3E 0B       0001M 			LD	A, function
04432F 49 CF       0002M 			RST.LIS	08h
044331 C1          11888  			POP	BC
044332 C9          11889  			RET
044333             11890  
044333             11891  ; OSBGET - Read a byte from a random disk file.
044333             11892  ;  E = file channel
044333             11893  ; Returns
044333             11894  ;  A = byte read
044333             11895  ;  Carry set if LAST BYTE of file
044333             11896  ; Destroys: A,B,C,F
044333             11897  ;
044333 C5          11898  OSBGET:			PUSH	BC
044334 4B          11899  			LD	C, E
044335             11900  			MOSCALL	mos_fgetc
044335 3E 0C       0001M 			LD	A, function
044337 49 CF       0002M 			RST.LIS	08h
044339 C1          11901  			POP	BC
04433A C9          11902  			RET
04433B             11903  
04433B             11904  ; OSBPUT - Write a byte to a random disk file.
04433B             11905  ;  E = file channel
04433B             11906  ;  A = byte to write
04433B             11907  ; Destroys: A,B,C,F
04433B             11908  ;
04433B C5          11909  OSBPUT:			PUSH	BC
04433C 4B          11910  			LD	C, E
04433D 47          11911  			LD	B, A
04433E             11912  			MOSCALL	mos_fputc
04433E 3E 0D       0001M 			LD	A, function
044340 49 CF       0002M 			RST.LIS	08h
044342 C1          11913  			POP	BC
044343 C9          11914  			RET
044344             11915  
044344             11916  ; OSSTAT - Read file status
044344             11917  ;  E = file channel
044344             11918  ; Returns
044344             11919  ;  F: Z flag set - EOF
044344             11920  ;  A: If Z then A = 0
044344             11921  ; Destroys: A,D,E,H,L,F
044344             11922  ;
044344 C5          11923  OSSTAT:			PUSH	BC
044345 4B          11924  			LD	C, E
044346             11925  			MOSCALL	mos_feof
044346 3E 0E       0001M 			LD	A, function
044348 49 CF       0002M 			RST.LIS	08h
04434A C1          11926  			POP	BC
04434B FE 01       11927  			CP	1
04434D C9          11928  			RET
04434E             11929  
04434E             11930  ; GETPTR - Return file pointer.
04434E             11931  ;    E = file channel
04434E             11932  ; Returns:
04434E             11933  ; DEHL = pointer (0-&7FFFFF)
04434E             11934  ; Destroys: A,B,C,D,E,H,L,F
04434E             11935  ;
04434E FD E5       11936  GETPTR:			PUSH		IY
044350 4B          11937  			LD		C, E
044351             11938  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044351 3E 19       0001M 			LD	A, function
044353 49 CF       0002M 			RST.LIS	08h
044355 E5          11939  			PUSH		HL
044356 FD E1       11940  			POP		IY		; IYU: Pointer to FIL structure
044358 FD 6E 11    11941  			LD		L, (IY + FIL.fptr + 0)
04435B FD 66 12    11942  			LD		H, (IY + FIL.fptr + 1)
04435E FD 5E 13    11943  			LD		E, (IY + FIL.fptr + 2)
044361 FD 56 14    11944  			LD		D, (IY + FIL.fptr + 3)
044364 FD E1       11945  			POP		IY
044366 C9          11946  			RET
044367             11947  
044367             11948  ; PUTPTR - Update file pointer.
044367             11949  ;    A = file channel
044367             11950  ; DEHL = new pointer (0-&7FFFFF)
044367             11951  ; Destroys: A,B,C,D,E,H,L,F
044367             11952  ;
044367 FD E5       11953  PUTPTR:			PUSH		IY
044369 4F          11954  			LD		C, A  		; C: Filehandle
04436A E5          11955  			PUSH		HL
04436B 21 02 00 00 11956  			LD		HL, 2
04436F 39          11957  			ADD		HL, SP
044370 73          11958  			LD		(HL), E 	; 3rd byte of DWORD set to E
044371 E1          11959  			POP		HL
044372 5A          11960  			LD		E, D  		; 4th byte passed as E
044373             11961  			MOSCALL		mos_flseek
044373 3E 1C       0001M 			LD	A, function
044375 49 CF       0002M 			RST.LIS	08h
044377 FD E1       11962  			POP		IY
044379 C9          11963  			RET
04437A             11964  
04437A             11965  ; GETEXT - Find file size.
04437A             11966  ;    E = file channel
04437A             11967  ; Returns:
04437A             11968  ; DEHL = file size (0-&800000)
04437A             11969  ; Destroys: A,B,C,D,E,H,L,F
04437A             11970  ;
04437A FD E5       11971  GETEXT:         PUSH    IY
04437C 4B          11972                  LD      C, E
04437D             11973                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
04437D 3E 19       0001M 			LD	A, function
04437F 49 CF       0002M 			RST.LIS	08h
044381 E5          11974                  PUSH    HL
044382 FD E1       11975                  POP     IY          ; IYU: Pointer to FIL structure
044384             11976                  ; Access the obj.objsize field using the offset values
044384 FD 6E 0B    11977                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
044387 FD 66 0C    11978                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
04438A FD 5E 0D    11979                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
04438D FD 56 0E    11980                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
044390             11981  
044390 FD E1       11982                  POP     IY
044392 C9          11983  			RET
044393             11984  
044393             11985  ; GETIMS - Get time from RTC
044393             11986  ;
044393 FD E5       11987  GETIMS:			PUSH	IY
044395 21 00 4A 04 11988  			LD	HL, ACCS 		; Where to store the time string
044399             11989  			MOSCALL	mos_getrtc
044399 3E 12       0001M 			LD	A, function
04439B 49 CF       0002M 			RST.LIS	08h
04439D 11 00 4A 04 11990  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0443A1 5F          11991  			LD	E, A 			;  E: now points to the end of the string
0443A2 FD E1       11992  			POP	IY
0443A4 C9          11993  			RET
0443A5             11994  
0443A5             11995  ; Get two word values from EXPR in DE, HL
0443A5             11996  ; IY: Pointer to expression string
0443A5             11997  ; Returns:
0443A5             11998  ; DE: P1
0443A5             11999  ; HL: P2
0443A5             12000  ;
0443A5 CD 0A 03 04 12001  EXPR_W2:		CALL	EXPRI			; Get first parameter
0443A9 D9          12002  			EXX
0443AA E5          12003  			PUSH	HL
0443AB CD 22 0A 04 12004  			CALL	COMMA
0443AF CD 0A 03 04 12005  			CALL	EXPRI			; Get second parameter
0443B3 D9          12006  			EXX
0443B4 D1          12007  			POP	DE
0443B5 C9          12008  			RET
0443B6             12009  
0443B6             12010  ; Stuff not implemented yet
0443B6             12011  ;
0443B6 C9          12012  RESET:			RET
0443B7             12013  ; BEGIN INSERTED FROM BINARY
0443B7 AF          12014  	xor a
0443B8 CD 77 37 04 12015  	call EXTERR
0443BC 53          12016  	ld d,e
0443BD 6F          12017  	ld l,a
0443BE 72          12018  	ld (hl),d
0443BF 72          12019  	ld (hl),d
0443C0 79          12020  	ld a,c
0443C1 00          12021  	nop
0443C2             12022  ; END INSERTED FROM BINARY; --- End patch.asm ---
0443C2             12023  
0443C2             12024  ; --- Begin agon_graphics.asm ---
0443C2             12025  ;
0443C2             12026  ; Title:	BBC Basic for AGON - Graphics stuff
0443C2             12027  ; Author:	Dean Belfield
0443C2             12028  ; Created:	12/05/2023
0443C2             12029  ; Last Updated:	07/06/2023
0443C2             12030  ;
0443C2             12031  ; Modinfo:
0443C2             12032  ; 07/06/2023:	Modified to run in ADL mode
0443C2             12033  
0443C2             12034  			; .ASSUME	ADL = 1
0443C2             12035  
0443C2             12036  			; INCLUDE	"equs.inc"
0443C2             12037  			; INCLUDE "macros.inc"
0443C2             12038  			; INCLUDE "mos_api.inc"	; In MOS/src
0443C2             12039  
0443C2             12040  			; SEGMENT CODE
0443C2             12041  
0443C2             12042  			; XDEF	CLG
0443C2             12043  			; XDEF	CLRSCN
0443C2             12044  			; XDEF	MODE
0443C2             12045  			; XDEF	COLOUR
0443C2             12046  			; XDEF	GCOL
0443C2             12047  			; XDEF	MOVE
0443C2             12048  			; XDEF	PLOT
0443C2             12049  			; XDEF	DRAW
0443C2             12050  			; XDEF	POINT
0443C2             12051  			; XDEF	GETSCHR
0443C2             12052  
0443C2             12053  			; XREF	OSWRCH
0443C2             12054  			; XREF	ASC_TO_NUMBER
0443C2             12055  			; XREF	EXTERR
0443C2             12056  			; XREF	EXPRI
0443C2             12057  			; XREF	COMMA
0443C2             12058  			; XREF	XEQ
0443C2             12059  			; XREF	NXT
0443C2             12060  			; XREF	BRAKET
0443C2             12061  			; XREF	COUNT0
0443C2             12062  			; XREF	CRTONULL
0443C2             12063  			; XREF	NULLTOCR
0443C2             12064  			; XREF	CRLF
0443C2             12065  			; XREF	EXPR_W2
0443C2             12066  			; XREF	INKEY1
0443C2             12067  
0443C2             12068  ; CLG: clears the graphics area
0443C2             12069  ;
0443C2             12070  CLG:
0443C2             12071  
0443C2             12072  			VDU	10h
0443C2 3E 10       0001M 		LD	A, val
0443C4 CD 00 3F 04 0002M 		CALL	OSWRCH
0443C8 C3 96 0B 04 12073  			JP	XEQ
0443CC             12074  
0443CC             12075  ; CLS: clears the text area
0443CC             12076  ;
0443CC 3E 0C       12077  CLRSCN:			LD	A, 0Ch
0443CE C3 00 3F 04 12078  			JP	OSWRCH
0443D2             12079  
0443D2             12080  ; MODE n: Set video mode
0443D2             12081  ;
0443D2 DD E5       12082  MODE:			PUSH	IX			; Get the system vars in IX
0443D4             12083  			MOSCALL	mos_sysvars		; Reset the semaphore
0443D4 3E 08       0001M 			LD	A, function
0443D6 49 CF       0002M 			RST.LIS	08h
0443D8 DD CB 04 A6 12084  			RES	4, (IX+sysvar_vpd_pflags)
0443DC CD 0A 03 04 12085  			CALL    EXPRI
0443E0 D9          12086  			EXX
0443E1             12087  			VDU	16H			; Mode change
0443E1 3E 16       0001M 		LD	A, val
0443E3 CD 00 3F 04 0002M 		CALL	OSWRCH
0443E7             12088  			VDU	L
0443E7 7D          0001M 		LD	A, val
0443E8 CD 00 3F 04 0002M 		CALL	OSWRCH
0443EC             12089  			MOSCALL	mos_sysvars
0443EC 3E 08       0001M 			LD	A, function
0443EE 49 CF       0002M 			RST.LIS	08h
0443F0 DD CB 04 66 12090  @@:			BIT	4, (IX+sysvar_vpd_pflags)
0443F4 28 FA       12091  			JR	Z, @B			; Wait for the result
0443F6 DD E1       12092  			POP	IX
0443F8 C3 96 0B 04 12093  			JP	XEQ
0443FC             12094  
0443FC             12095  ; GET(x,y): Get the ASCII code of a character on screen
0443FC             12096  ;
0443FC FD 23       12097  GETSCHR:		INC	IY
0443FE CD 0A 03 04 12098  			CALL    EXPRI      		; Get X coordinate
044402 D9          12099  			EXX
044403 22 00 4A 04 12100  			LD	(VDU_BUFFER+0), HL
044407 CD 22 0A 04 12101  			CALL	COMMA
04440B CD 0A 03 04 12102  			CALL	EXPRI			; Get Y coordinate
04440F D9          12103  			EXX
044410 22 02 4A 04 12104  			LD	(VDU_BUFFER+2), HL
044414 CD 2F 0A 04 12105  			CALL	BRAKET			; Closing bracket
044418             12106  ;
044418 DD E5       12107  			PUSH	IX			; Get the system vars in IX
04441A             12108  			MOSCALL	mos_sysvars		; Reset the semaphore
04441A 3E 08       0001M 			LD	A, function
04441C 49 CF       0002M 			RST.LIS	08h
04441E DD CB 04 8E 12109  			RES	1, (IX+sysvar_vpd_pflags)
044422             12110  			VDU	23
044422 3E 17       0001M 		LD	A, val
044424 CD 00 3F 04 0002M 		CALL	OSWRCH
044428             12111  			VDU	0
044428 3E 00       0001M 		LD	A, val
04442A CD 00 3F 04 0002M 		CALL	OSWRCH
04442E             12112  			VDU	vdp_scrchar
04442E 3E 83       0001M 		LD	A, val
044430 CD 00 3F 04 0002M 		CALL	OSWRCH
044434             12113  			VDU	(VDU_BUFFER+0)
044434 3A 00 4A 04 0001M 		LD	A, val
044438 CD 00 3F 04 0002M 		CALL	OSWRCH
04443C             12114  			VDU	(VDU_BUFFER+1)
04443C 3A 01 4A 04 0001M 		LD	A, val
044440 CD 00 3F 04 0002M 		CALL	OSWRCH
044444             12115  			VDU	(VDU_BUFFER+2)
044444 3A 02 4A 04 0001M 		LD	A, val
044448 CD 00 3F 04 0002M 		CALL	OSWRCH
04444C             12116  			VDU	(VDU_BUFFER+3)
04444C 3A 03 4A 04 0001M 		LD	A, val
044450 CD 00 3F 04 0002M 		CALL	OSWRCH
044454 DD CB 04 4E 12117  @@:			BIT	1, (IX+sysvar_vpd_pflags)
044458 28 FA       12118  			JR	Z, @B			; Wait for the result
04445A DD 7E 09    12119  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
04445D B7          12120  			OR	A			; Check for 00h
04445E 37          12121  			SCF				; C = character map
04445F 20 02       12122  			JR	NZ, @F			; We have a character, so skip next bit
044461 AF          12123  			XOR	A			; Clear carry
044462 3D          12124  			DEC	A			; Set A to FFh
044463 DD E1       12125  @@:			POP	IX
044465 C3 E1 07 04 12126  			JP	INKEY1			; Jump back to the GET command
044469             12127  
044469             12128  ; POINT(x,y): Get the pixel colour of a point on screen
044469             12129  ;
044469 CD 0A 03 04 12130  POINT:			CALL    EXPRI      		; Get X coordinate
04446D D9          12131  			EXX
04446E 22 00 4A 04 12132  			LD	(VDU_BUFFER+0), HL
044472 CD 22 0A 04 12133  			CALL	COMMA
044476 CD 0A 03 04 12134  			CALL	EXPRI			; Get Y coordinate
04447A D9          12135  			EXX
04447B 22 02 4A 04 12136  			LD	(VDU_BUFFER+2), HL
04447F CD 2F 0A 04 12137  			CALL	BRAKET			; Closing bracket
044483             12138  ;
044483 DD E5       12139  			PUSH	IX			; Get the system vars in IX
044485             12140  			MOSCALL	mos_sysvars		; Reset the semaphore
044485 3E 08       0001M 			LD	A, function
044487 49 CF       0002M 			RST.LIS	08h
044489 DD CB 04 96 12141  			RES	2, (IX+sysvar_vpd_pflags)
04448D             12142  			VDU	23
04448D 3E 17       0001M 		LD	A, val
04448F CD 00 3F 04 0002M 		CALL	OSWRCH
044493             12143  			VDU	0
044493 3E 00       0001M 		LD	A, val
044495 CD 00 3F 04 0002M 		CALL	OSWRCH
044499             12144  			VDU	vdp_scrpixel
044499 3E 84       0001M 		LD	A, val
04449B CD 00 3F 04 0002M 		CALL	OSWRCH
04449F             12145  			VDU	(VDU_BUFFER+0)
04449F 3A 00 4A 04 0001M 		LD	A, val
0444A3 CD 00 3F 04 0002M 		CALL	OSWRCH
0444A7             12146  			VDU	(VDU_BUFFER+1)
0444A7 3A 01 4A 04 0001M 		LD	A, val
0444AB CD 00 3F 04 0002M 		CALL	OSWRCH
0444AF             12147  			VDU	(VDU_BUFFER+2)
0444AF 3A 02 4A 04 0001M 		LD	A, val
0444B3 CD 00 3F 04 0002M 		CALL	OSWRCH
0444B7             12148  			VDU	(VDU_BUFFER+3)
0444B7 3A 03 4A 04 0001M 		LD	A, val
0444BB CD 00 3F 04 0002M 		CALL	OSWRCH
0444BF DD CB 04 56 12149  @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444C3 28 FA       12150  			JR	Z, @B			; Wait for the result
0444C5             12151  ;
0444C5             12152  ; Return the data as a 1 byte index
0444C5             12153  ;
0444C5 DD 6E 16    12154  			LD	L, (IX+sysvar_scrpixelIndex)
0444C8 DD E1       12155  			POP	IX
0444CA C3 7F 05 04 12156  			JP	COUNT0
0444CE             12157  
0444CE             12158  
0444CE             12159  ; COLOUR colour
0444CE             12160  ; COLOUR L,P
0444CE             12161  ; COLOUR L,R,G,B
0444CE             12162  ;
0444CE CD 0A 03 04 12163  COLOUR:			CALL	EXPRI			; The colour / mode
0444D2 D9          12164  			EXX
0444D3 7D          12165  			LD	A, L
0444D4 32 00 4A 04 12166  			LD	(VDU_BUFFER+0), A	; Store first parameter
0444D8 CD 70 0A 04 12167  			CALL	NXT			; Are there any more parameters?
0444DC FE 2C       12168  			CP	','
0444DE 28 12       12169  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0444E0             12170  ;
0444E0             12171  			VDU	11h			; Just set the colour
0444E0 3E 11       0001M 		LD	A, val
0444E2 CD 00 3F 04 0002M 		CALL	OSWRCH
0444E6             12172  			VDU	(VDU_BUFFER+0)
0444E6 3A 00 4A 04 0001M 		LD	A, val
0444EA CD 00 3F 04 0002M 		CALL	OSWRCH
0444EE C3 96 0B 04 12173  			JP	XEQ
0444F2             12174  ;
0444F2 CD 22 0A 04 12175  COLOUR_1:		CALL	COMMA
0444F6 CD 0A 03 04 12176  			CALL	EXPRI			; Parse R (OR P)
0444FA D9          12177  			EXX
0444FB 7D          12178  			LD	A, L
0444FC 32 01 4A 04 12179  			LD	(VDU_BUFFER+1), A
044500 CD 70 0A 04 12180  			CALL	NXT			; Are there any more parameters?
044504 FE 2C       12181  			CP	','
044506 28 2C       12182  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044508             12183  ;
044508             12184  			VDU	13h			; VDU:COLOUR
044508 3E 13       0001M 		LD	A, val
04450A CD 00 3F 04 0002M 		CALL	OSWRCH
04450E             12185  			VDU	(VDU_BUFFER+0)		; Logical Colour
04450E 3A 00 4A 04 0001M 		LD	A, val
044512 CD 00 3F 04 0002M 		CALL	OSWRCH
044516             12186  			VDU	(VDU_BUFFER+1)		; Palette Colour
044516 3A 01 4A 04 0001M 		LD	A, val
04451A CD 00 3F 04 0002M 		CALL	OSWRCH
04451E             12187  			VDU	0			; RGB set to 0
04451E 3E 00       0001M 		LD	A, val
044520 CD 00 3F 04 0002M 		CALL	OSWRCH
044524             12188  			VDU	0
044524 3E 00       0001M 		LD	A, val
044526 CD 00 3F 04 0002M 		CALL	OSWRCH
04452A             12189  			VDU	0
04452A 3E 00       0001M 		LD	A, val
04452C CD 00 3F 04 0002M 		CALL	OSWRCH
044530 C3 96 0B 04 12190  			JP	XEQ
044534             12191  ;
044534 CD 22 0A 04 12192  COLOUR_2:		CALL	COMMA
044538 CD 0A 03 04 12193  			CALL	EXPRI			; Parse G
04453C D9          12194  			EXX
04453D 7D          12195  			LD	A, L
04453E 32 02 4A 04 12196  			LD	(VDU_BUFFER+2), A
044542 CD 22 0A 04 12197  			CALL	COMMA
044546 CD 0A 03 04 12198  			CALL	EXPRI			; Parse B
04454A D9          12199  			EXX
04454B 7D          12200  			LD	A, L
04454C 32 03 4A 04 12201  			LD	(VDU_BUFFER+3), A
044550             12202  			VDU	13h			; VDU:COLOUR
044550 3E 13       0001M 		LD	A, val
044552 CD 00 3F 04 0002M 		CALL	OSWRCH
044556             12203  			VDU	(VDU_BUFFER+0)		; Logical Colour
044556 3A 00 4A 04 0001M 		LD	A, val
04455A CD 00 3F 04 0002M 		CALL	OSWRCH
04455E             12204  			VDU	FFh			; Physical Colour (-1 for RGB mode)
04455E 3E FF       0001M 		LD	A, val
044560 CD 00 3F 04 0002M 		CALL	OSWRCH
044564             12205  			VDU	(VDU_BUFFER+1)		; R
044564 3A 01 4A 04 0001M 		LD	A, val
044568 CD 00 3F 04 0002M 		CALL	OSWRCH
04456C             12206  			VDU	(VDU_BUFFER+2)		; G
04456C 3A 02 4A 04 0001M 		LD	A, val
044570 CD 00 3F 04 0002M 		CALL	OSWRCH
044574             12207  			VDU	(VDU_BUFFER+3)		; B
044574 3A 03 4A 04 0001M 		LD	A, val
044578 CD 00 3F 04 0002M 		CALL	OSWRCH
04457C C3 96 0B 04 12208  			JP	XEQ
044580             12209  
044580             12210  ; GCOL mode,colour
044580             12211  ;
044580 CD 0A 03 04 12212  GCOL:			CALL	EXPRI			; Parse MODE
044584 D9          12213  			EXX
044585 7D          12214  			LD	A, L
044586 32 00 4A 04 12215  			LD	(VDU_BUFFER+0), A
04458A CD 22 0A 04 12216  			CALL	COMMA
04458E             12217  ;
04458E CD 0A 03 04 12218  			CALL	EXPRI			; Parse Colour
044592 D9          12219  			EXX
044593 7D          12220  			LD	A, L
044594 32 01 4A 04 12221  			LD	(VDU_BUFFER+1), A
044598             12222  ;
044598             12223  			VDU	12h			; VDU:GCOL
044598 3E 12       0001M 		LD	A, val
04459A CD 00 3F 04 0002M 		CALL	OSWRCH
04459E             12224  			VDU	(VDU_BUFFER+0)		; Mode
04459E 3A 00 4A 04 0001M 		LD	A, val
0445A2 CD 00 3F 04 0002M 		CALL	OSWRCH
0445A6             12225  			VDU	(VDU_BUFFER+1)		; Colour
0445A6 3A 01 4A 04 0001M 		LD	A, val
0445AA CD 00 3F 04 0002M 		CALL	OSWRCH
0445AE C3 96 0B 04 12226  			JP	XEQ
0445B2             12227  
0445B2             12228  ; PLOT mode,x,y
0445B2             12229  ;
0445B2 CD 0A 03 04 12230  PLOT:			CALL	EXPRI		; Parse mode
0445B6 D9          12231  			EXX
0445B7 E5          12232  			PUSH	HL		; Push mode (L) onto stack
0445B8 CD 22 0A 04 12233  			CALL	COMMA
0445BC CD A5 43 04 12234  			CALL	EXPR_W2		; Parse X and Y
0445C0 C1          12235  			POP	BC		; Pop mode (C) off stack
0445C1             12236  PLOT_1:			VDU	19H		; VDU code for PLOT
0445C1 3E 19       0001M 		LD	A, val
0445C3 CD 00 3F 04 0002M 		CALL	OSWRCH
0445C7             12237  			VDU	C		;  C: Mode
0445C7 79          0001M 		LD	A, val
0445C8 CD 00 3F 04 0002M 		CALL	OSWRCH
0445CC             12238  			VDU	E		; DE: X
0445CC 7B          0001M 		LD	A, val
0445CD CD 00 3F 04 0002M 		CALL	OSWRCH
0445D1             12239  			VDU	D
0445D1 7A          0001M 		LD	A, val
0445D2 CD 00 3F 04 0002M 		CALL	OSWRCH
0445D6             12240  			VDU	L		; HL: Y
0445D6 7D          0001M 		LD	A, val
0445D7 CD 00 3F 04 0002M 		CALL	OSWRCH
0445DB             12241  			VDU	H
0445DB 7C          0001M 		LD	A, val
0445DC CD 00 3F 04 0002M 		CALL	OSWRCH
0445E0 C3 96 0B 04 12242  			JP	XEQ
0445E4             12243  
0445E4             12244  ; MOVE x,y
0445E4             12245  ;
0445E4 CD A5 43 04 12246  MOVE:			CALL	EXPR_W2		; Parse X and Y
0445E8 0E 04       12247  			LD	C, 04H		; Plot mode 04H (Move)
0445EA 18 D5       12248  			JR	PLOT_1		; Plot
0445EC             12249  
0445EC             12250  ; DRAW x1,y1
0445EC             12251  ; DRAW x1,y1,x2,y2
0445EC             12252  ;
0445EC CD A5 43 04 12253  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0445F0 CD 70 0A 04 12254  			CALL	NXT		; Are there any more parameters?
0445F4 FE 2C       12255  			CP	','
0445F6 0E 05       12256  			LD	C, 05h		; Code for LINE
0445F8 20 C7       12257  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0445FA             12258  			VDU	19h		; Move to the first coordinates
0445FA 3E 19       0001M 		LD	A, val
0445FC CD 00 3F 04 0002M 		CALL	OSWRCH
044600             12259  			VDU	04h
044600 3E 04       0001M 		LD	A, val
044602 CD 00 3F 04 0002M 		CALL	OSWRCH
044606             12260  			VDU	E
044606 7B          0001M 		LD	A, val
044607 CD 00 3F 04 0002M 		CALL	OSWRCH
04460B             12261  			VDU	D
04460B 7A          0001M 		LD	A, val
04460C CD 00 3F 04 0002M 		CALL	OSWRCH
044610             12262  			VDU	L
044610 7D          0001M 		LD	A, val
044611 CD 00 3F 04 0002M 		CALL	OSWRCH
044615             12263  			VDU	H
044615 7C          0001M 		LD	A, val
044616 CD 00 3F 04 0002M 		CALL	OSWRCH
04461A CD 22 0A 04 12264  			CALL	COMMA
04461E C5          12265  			PUSH	BC
04461F CD A5 43 04 12266  			CALL	EXPR_W2		; Get X2 and Y2
044623 C1          12267  			POP	BC
044624 18 9B       12268  			JR	PLOT_1		; Now DRAW the line to those positions
044626             12269  
044626             12270  
044626             12271  
044626             12272  ; --- End agon_graphics.asm ---
044626             12273  
044626             12274  ; --- Begin agon_sound.asm ---
044626             12275  ;
044626             12276  ; Title:	BBC Basic for AGON - Audio stuff
044626             12277  ; Author:	Dean Belfield
044626             12278  ; Created:	12/05/2023
044626             12279  ; Last Updated:	12/05/2023
044626             12280  ;
044626             12281  ; Modinfo:
044626             12282  
044626             12283  			; .ASSUME	ADL = 1
044626             12284  
044626             12285  			; INCLUDE	"equs.inc"
044626             12286  			; INCLUDE "macros.inc"
044626             12287  			; INCLUDE "mos_api.inc"	; In MOS/src
044626             12288  
044626             12289  			; SEGMENT CODE
044626             12290  
044626             12291  			; XDEF	SOUND
044626             12292  
044626             12293  			; XREF	COMMA
044626             12294  			; XREF	EXPR_W2
044626             12295  			; XREF	XEQ
044626             12296  			; XREF	LTRAP
044626             12297  			; XREF	OSWRCH
044626             12298  			; XREF	VDU_BUFFER
044626             12299  
044626             12300  
044626             12301  ; SOUND channel,volume,pitch,duration
044626             12302  ; volume: 0 (off) to -15 (full volume)
044626             12303  ; pitch: 0 - 255
044626             12304  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
044626             12305  ;
044626 CD A5 43 04 12306  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
04462A 7D          12307  			LD	A, L 			;  A: Volume
04462B F5          12308  			PUSH	AF
04462C D5          12309  			PUSH	DE
04462D CD 22 0A 04 12310  			CALL	COMMA
044631 CD A5 43 04 12311  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
044635 53          12312  			LD	D, E			;  D: Pitch
044636 5D          12313  			LD	E, L 			;  E: Duration
044637 E1          12314  			POP	HL 			; HL: Channel/Control
044638 F1          12315  			POP	AF
044639 ED 44       12316  			NEG
04463B FE 10       12317  			CP	16			; Check volume is in bounds
04463D D2 96 0B 04 12318  			JP	NC, XEQ			; Out of bounds, do nothing
044641             12319  ;
044641             12320  ; Store	in VDU vars
044641             12321  ;
044641 4F          12322  			LD	C, A			; Store Volume in C
044642 7D          12323  			LD	A, L
044643 32 00 4A 04 12324  			LD	(VDU_BUFFER+0), A	; Channel
044647 AF          12325  			XOR	A
044648 32 01 4A 04 12326  			LD	(VDU_BUFFER+1), A	; Waveform
04464C             12327  ;
04464C             12328  ; Calculate the volume
04464C             12329  ;
04464C 06 06       12330  			LD	B, 6			; C already contains the volume
04464E ED 4C       12331  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
044650 79          12332  			LD	A, C
044651 32 02 4A 04 12333  			LD	(VDU_BUFFER+2), A
044655             12334  ;
044655             12335  ; And the frequency
044655             12336  ;
044655 4B          12337  			LD	C, E			; Store duration in C
044656 26 00       12338  			LD	H, 0			; Lookup the frequency
044658 6A          12339  			LD	L, D
044659 11 E0 46 04 12340  			LD	DE, SOUND_FREQ_LOOKUP
04465D 29          12341  			ADD	HL, HL
04465E 19          12342  			ADD	HL, DE
04465F 7E          12343  			LD	A, (HL)
044660 32 03 4A 04 12344  			LD	(VDU_BUFFER+3), A
044664 23          12345  			INC	HL
044665 7E          12346  			LD	A, (HL)
044666 32 04 4A 04 12347  			LD	(VDU_BUFFER+4), A
04466A             12348  ;
04466A             12349  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
04466A             12350  ;
04466A 06 32       12351  			LD	B, 50			; C contains the duration, so MLT by 50
04466C ED 4C       12352  			MLT	BC
04466E ED 43 05 4A 12353  			LD	(VDU_BUFFER+5), BC
       04          
044673             12354  ;
044673 DD E5       12355  			PUSH	IX			; Get the system vars in IX
044675             12356  			MOSCALL	mos_sysvars		; Reset the semaphore
044675 3E 08       0001M 			LD	A, function
044677 49 CF       0002M 			RST.LIS	08h
044679 5B DD CB 04 12357  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
04467E             12358  ;
04467E             12359  			VDU	23			; Send the sound command
04467E 3E 17       0001M 		LD	A, val
044680 CD 00 3F 04 0002M 		CALL	OSWRCH
044684             12360  			VDU	0
044684 3E 00       0001M 		LD	A, val
044686 CD 00 3F 04 0002M 		CALL	OSWRCH
04468A             12361  			VDU	vdp_audio
04468A 3E 85       0001M 		LD	A, val
04468C CD 00 3F 04 0002M 		CALL	OSWRCH
044690             12362  			VDU	(VDU_BUFFER+0)		; 0: Channel
044690 3A 00 4A 04 0001M 		LD	A, val
044694 CD 00 3F 04 0002M 		CALL	OSWRCH
044698             12363  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
044698 3A 01 4A 04 0001M 		LD	A, val
04469C CD 00 3F 04 0002M 		CALL	OSWRCH
0446A0             12364  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446A0 3A 02 4A 04 0001M 		LD	A, val
0446A4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446A8             12365  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446A8 3A 03 4A 04 0001M 		LD	A, val
0446AC CD 00 3F 04 0002M 		CALL	OSWRCH
0446B0             12366  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446B0 3A 04 4A 04 0001M 		LD	A, val
0446B4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446B8             12367  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0446B8 3A 05 4A 04 0001M 		LD	A, val
0446BC CD 00 3F 04 0002M 		CALL	OSWRCH
0446C0             12368  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0446C0 3A 06 4A 04 0001M 		LD	A, val
0446C4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446C8             12369  ;
0446C8             12370  ; Wait for acknowledgement
0446C8             12371  ;
0446C8 5B DD CB 04 12372  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
0446CD 28 F9       12373  			JR	Z, @B			; Wait for the result
0446CF CD 71 3F 04 12374  			CALL	LTRAP			; Check for ESC
0446D3 5B DD 7E 0E 12375  			LD.LIL	A, (IX+sysvar_audioSuccess)
0446D7 A7          12376  			AND	A			; Check if VDP has queued the note
0446D8 28 9F       12377  			JR	Z, SOUND0		; No, so loop back and send again
0446DA             12378  ;
0446DA DD E1       12379  			POP	IX
0446DC C3 96 0B 04 12380  			JP	XEQ
0446E0             12381  
0446E0             12382  ; Frequency Lookup Table
0446E0             12383  ; Set up to replicate the BBC Micro audio frequencies
0446E0             12384  ;
0446E0             12385  ; Split over 5 complete octaves, with 53 being middle C
0446E0             12386  ; * C4: 262hz
0446E0             12387  ; + A4: 440hz
0446E0             12388  ;
0446E0             12389  ;	2	3	4	5	6	7	8
0446E0             12390  ;
0446E0             12391  ; B	1	49	97	145	193	241
0446E0             12392  ; A#	0	45	93	141	189	237
0446E0             12393  ; A		41	89+	137	185	233
0446E0             12394  ; G#		37	85	133	181	229
0446E0             12395  ; G		33	81	129	177	225
0446E0             12396  ; F#		29	77	125	173	221
0446E0             12397  ; F		25	73	121	169	217
0446E0             12398  ; E		21	69	117	165	213
0446E0             12399  ; D#		17	65	113	161	209
0446E0             12400  ; D		13	61	109	157	205	253
0446E0             12401  ; C#		9	57	105	153	201	249
0446E0             12402  ; C		5	53*	101	149	197	245
0446E0             12403  ;
0446E0 75 00 76 00 12404  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
0446F0 89 00 8B 00 12405  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
044700 99 00 9C 00 12406  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
044710 AC 00 AF 00 12407  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
044720 C1 00 C4 00 12408  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
044730 D9 00 DC 00 12409  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
044740 F3 00 F7 00 12410  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
044750 11 01 15 01 12411  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
044760 33 01 37 01 12412  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
044770 58 01 5D 01 12413  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
044780 82 01 88 01 12414  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
044790 B2 01 B8 01 12415  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447A0 E7 01 EE 01 12416  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0447B0 22 02 2A 02 12417  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0447C0 65 02 6E 02 12418  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
0447D0 B1 02 BB 02 12419  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
0447E0 05 03 10 03 12420  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
0447F0 63 03 70 03 12421  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
044800 CE 03 DC 03 12422  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
044810 45 04 55 04 12423  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
044820 CB 04 DD 04 12424  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
044830 62 05 76 05 12425  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
044840 0A 06 21 06 12426  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
044850 C8 06 E1 06 12427  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
044860 9C 07 B8 07 12428  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
044870 8A 08 A9 08 12429  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
044880 95 09 B9 09 12430  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
044890 C2 0A EA 0A 12431  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448A0 13 0C 40 0C 12432  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0448B0 8E 0D C0 0D 12433  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0448C0 36 0F 6F 0F 12434  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
0448D0 13 11 53 11 12435  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
0448E0             12436  
0448E0             12437  
0448E0             12438  ; --- End agon_sound.asm ---
0448E0             12439  
0448E0             12440  ; --- Begin interrupts.asm ---
0448E0             12441  ;
0448E0             12442  ; Title:	BBC Basic for AGON - Interrupts
0448E0             12443  ; Author:	Dean Belfield
0448E0             12444  ; Created:	12/05/2023
0448E0             12445  ; Last Updated:	07/06/2023
0448E0             12446  ;
0448E0             12447  ; Modinfo:
0448E0             12448  ; 07/06/2023:	Modified to run in ADL mode
0448E0             12449  
0448E0             12450  			; .ASSUME	ADL = 1
0448E0             12451  
0448E0             12452  			; INCLUDE	"macros.inc"
0448E0             12453  			; INCLUDE	"equs.inc"
0448E0             12454  			; INCLUDE "mos_api.inc"	; In MOS/src
0448E0             12455  
0448E0             12456  			; SEGMENT CODE
0448E0             12457  
0448E0             12458  			; XDEF	VBLANK_INIT
0448E0             12459  			; XDEF	VBLANK_STOP
0448E0             12460  			; XDEF	VBLANK_HANDLER
0448E0             12461  
0448E0             12462  			; XREF	ESCSET
0448E0             12463  			; XREF	KEYDOWN		; In ram.asm
0448E0             12464  			; XREF	KEYASCII 	; In ram.asm
0448E0             12465  			; XREF	KEYCOUNT	; In ram.asm
0448E0             12466  
0448E0             12467  ; Hook into the MOS VBLANK interrupt
0448E0             12468  ;
0448E0 F3          12469  VBLANK_INIT:		DI
0448E1 21 35 49 04 12470  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0448E5 1E 32       12471  			LD		E, 32h				; Set up the VBlank Interrupt Vector
0448E7             12472  			MOSCALL		mos_setintvector
0448E7 3E 14       0001M 			LD	A, function
0448E9 49 CF       0002M 			RST.LIS	08h
0448EB             12473  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0448EB EB          12474  			ex de,hl
0448EC 21 43 49 04 12475  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448F0 ED 1F       12476  			LD		(HL), DE			; Self-modify the code
0448F2 FB          12477  			EI
0448F3 C9          12478  			RET
0448F4             12479  
0448F4             12480  ; Unhook the custom VBLANK interrupt
0448F4             12481  ;
0448F4 F3          12482  VBLANK_STOP:		DI
0448F5 21 43 49 04 12483  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448F9 ED 17       12484  			LD		DE, (HL)
0448FB EB          12485  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
0448FC 1E 32       12486  			LD		E, 32h
0448FE             12487  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0448FE 3E 14       0001M 			LD	A, function
044900 49 CF       0002M 			RST.LIS	08h
044902 FB          12488  			EI
044903 C9          12489  			RET
044904             12490  
044904             12491  ; A safe LIS call to ESCSET
044904             12492  ;
044904             12493  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044904 3E 08       0001M 			LD	A, function
044906 49 CF       0002M 			RST.LIS	08h
044908 21 49 4D 04 12494  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04490C DD 7E 19    12495  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04490F BE          12496  			CP 		(HL)				; with our local copy
044910 20 0A       12497  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044912             12498  ;
044912 AF          12499  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044913 32 48 4D 04 12500  			LD		(KEYASCII), A
044917 32 47 4D 04 12501  			LD		(KEYDOWN), A
04491B C9          12502  			RET	 					; And return
04491C             12503  ;
04491C 77          12504  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04491D DD 7E 18    12505  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044920 B7          12506  			OR		A
044921 28 EF       12507  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044923             12508  ;
044923 32 47 4D 04 12509  			LD		(KEYDOWN), A 			; Store the keydown value
044927 DD 7E 05    12510  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
04492A 32 48 4D 04 12511  			LD		(KEYASCII), A 			; Store locally
04492E FE 1B       12512  			CP		1Bh				; Is it escape?
044930 CC 4C 3F 04 12513  			CALL		Z, ESCSET			; Yes, so set the escape flags
044934 C9          12514  			RET						; Return to the interrupt handler
044935             12515  
044935 F3          12516  VBLANK_HANDLER:		DI
044936 F5          12517  			PUSH		AF
044937 E5          12518  			PUSH		HL
044938 DD E5       12519  			PUSH		IX
04493A CD 04 49 04 12520  			CALL		DO_KEYBOARD
04493E DD E1       12521  			POP		IX
044940 E1          12522  			POP		HL
044941 F1          12523  			POP		AF
044942             12524  ;
044942             12525  ; Finally jump to the MOS interrupt
044942             12526  ;
044942 C3 00 00 00 12527  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044946             12528  
044946             12529  ; --- Begin sorry.asm ---
044946             12530  ;
044946             12531  ; Title:	BBC Basic Interpreter - Z80 version
044946             12532  ;		Catch-all for unimplemented functionality
044946             12533  ; Author:	Dean Belfield
044946             12534  ; Created:	12/05/2023
044946             12535  ; Last Updated:	12/05/2023
044946             12536  ;
044946             12537  ; Modinfo:
044946             12538  
044946             12539  			; .ASSUME	ADL = 1
044946             12540  
044946             12541  			; SEGMENT CODE
044946             12542  
044946             12543  			; XDEF	ENVEL
044946             12544  			; XDEF	ADVAL
044946             12545  			; XDEF	PUTIMS
044946             12546  
044946             12547  			; XREF	EXTERR
044946             12548  
044946             12549  ENVEL:
044946             12550  ADVAL:
044946             12551  PUTIMS:
044946 AF          12552  			XOR     A
044947 CD 77 37 04 12553  			CALL    EXTERR
04494B 53 6F 72 72 12554  			DEFB    "Sorry"
       79          
044950 00          12555  			DEFB    0
044951             12556  ; --- End sorry.asm ---
044951             12557  
044951             12558  ; --- Begin ram.asm ---
044951             12559  ;
044951             12560  ; Title:	BBC Basic Interpreter - Z80 version
044951             12561  ;		RAM Module for BBC Basic Interpreter
044951             12562  ;		For use with Version 2.0 of BBC BASIC
044951             12563  ;		Standard CP/M Distribution Version
044951             12564  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
044951             12565  ; Modified By:	Dean Belfield
044951             12566  ; Created:	12/05/2023
044951             12567  ; Last Updated:	26/06/2023
044951             12568  ;
044951             12569  ; Modinfo:
044951             12570  ; 06/06/2023:	Modified to run in ADL mode
044951             12571  ; 26/06/2023:	Added temporary stores R0 and R1
044951             12572  
044951             12573  			; .ASSUME	ADL = 1
044951             12574  
044951             12575  			; DEFINE	LORAM, SPACE = ROM
044951             12576  			; SEGMENT LORAM
044951             12577  
044951             12578  			; XDEF	ACCS
044951             12579  			; XDEF	BUFFER
044951             12580  			; XDEF	STAVAR
044951             12581  			; XDEF	DYNVAR
044951             12582  			; XDEF	FNPTR
044951             12583  			; XDEF	PROPTR
044951             12584  			; XDEF	PAGE_
044951             12585  			; XDEF	TOP
044951             12586  			; XDEF	LOMEM
044951             12587  			; XDEF 	FREE
044951             12588  			; XDEF	HIMEM
044951             12589  			; XDEF	LINENO
044951             12590  			; XDEF	TRACEN
044951             12591  			; XDEF	AUTONO
044951             12592  			; XDEF	ERRTRP
044951             12593  			; XDEF	ERRTXT
044951             12594  			; XDEF	DATPTR
044951             12595  			; XDEF	ERL
044951             12596  			; XDEF	ERRLIN
044951             12597  			; XDEF	RANDOM
044951             12598  			; XDEF	COUNT
044951             12599  			; XDEF	WIDTH
044951             12600  			; XDEF	ERR
044951             12601  			; XDEF	LISTON
044951             12602  			; XDEF	INCREM
044951             12603  
044951             12604  			; XDEF	FLAGS
044951             12605  			; XDEF	OSWRCHPT
044951             12606  			; XDEF	OSWRCHCH
044951             12607  			; XDEF	OSWRCHFH
044951             12608  			; XDEF	KEYDOWN
044951             12609  			; XDEF	KEYASCII
044951             12610  			; XDEF	KEYCOUNT
044951             12611  
044951             12612  			; XDEF	R0
044951             12613  			; XDEF	R1
044951             12614  
044951             12615  			; XDEF	RAM_START
044951             12616  			; XDEF	RAM_END
044951             12617  			; XDEF	USER
044951             12618  
044951 FF FF FF FF 12619  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
044A00             12620  RAM_START:
044A00             12621  ;
044A00 00 00 00 00 12622  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 12623  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 12624  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 12625  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    12626  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    12627  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             12628  ;
044D14 00 00 00    12629  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    12630  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    12631  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    12632  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    12633  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             12634  ;
044D23 00 00 00    12635  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    12636  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    12637  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    12638  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       12639  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       12640  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       12641  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    12642  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 12643  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          12644  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          12645  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          12646  ERR:            BLKB    1,0               ; Error Number
044D40 00          12647  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             12648                                  ; - BIT 0: If set, output a space after the line number
044D41             12649                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             12650                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             12651                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             12652                                  ; OPT FLAG (top nibble)
044D41             12653                                  ; - BIT 4: If set, then list whilst assembling
044D41             12654                                  ; - BIT 5: If set, then assembler errors are reported
044D41             12655                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             12656                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          12657  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             12658  ;
044D42             12659  ; --------------------------------------------------------------------------------------------
044D42             12660  ; BEGIN MODIFIED CODE
044D42             12661  ; --------------------------------------------------------------------------------------------
044D42             12662  ; Originally in equs.inc
044D42             12663  ;
044D42             12664  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
044D42             12665  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
044D42             12666  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044D42             12667  ; --------------------------------------------------------------------------------------------
044D42             12668  ; END MODIFIED CODE
044D42             12669  ; --------------------------------------------------------------------------------------------
044D42             12670  
044D42             12671  ; Extra Agon-implementation specific system variables
044D42             12672  ;
044D42 00          12673  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             12674                                  ; - BIT 7: Set if ESC pressed
044D43             12675                                  ; - BIT 6: Set to disable ESC
044D43 00 00       12676  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          12677  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             12678                                  ; - 0: Console
044D46             12679                                  ; - 1: File
044D46 00          12680  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          12681  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          12682  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          12683  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    12684  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    12685  R1:             BLKB    3,0
044D50             12686  
044D50             12687  ;
044D50             12688  ; This must be at the end
044D50             12689  ;
044D50             12690  RAM_END:
044D50 FF FF FF FF 12691  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
044E00             12692  USER:							; Must be aligned on a page boundary
044E00             12693  	; --- End ram.asm ---
044E00             12694  
