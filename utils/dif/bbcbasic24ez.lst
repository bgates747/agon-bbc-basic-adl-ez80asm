PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modinfo:
040000             0009  ; 05/08/2022:	Added mos_feof
040000             0010  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0011  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0012  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0013  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0014  ; 13/10/2022:	Added mos_oscli
040000             0015  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0016  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0017  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0018  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0019  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0020  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0021  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0022  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0023  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0024  ; 19/05/2023:	Added sysvar_scrMode
040000             0025  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0026  ; 03/08/2023:	Added mos_setkbvector
040000             0027  ; 10/08/2023:	Added mos_getkbmap
040000             0028  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0029  
040000             0030  ; VDP control (VDU 23, 0, n)
040000             0031  ;
040000             0032  vdp_gp:			EQU 	80h
040000             0033  vdp_keycode:		EQU 	81h
040000             0034  vdp_cursor:		EQU	82h
040000             0035  vdp_scrchar:		EQU	83h
040000             0036  vdp_scrpixel:		EQU	84h
040000             0037  vdp_audio:		EQU	85h
040000             0038  vdp_mode:		EQU	86h
040000             0039  vdp_rtc:		EQU	87h
040000             0040  vdp_keystate:		EQU	88h
040000             0041  vdp_logicalcoords:	EQU	C0h
040000             0042  vdp_terminalmode:	EQU	FFh
040000             0043  
040000             0044  ; MOS high level functions
040000             0045  ;
040000             0046  mos_getkey:		EQU	00h
040000             0047  mos_load:		EQU	01h
040000             0048  mos_save:		EQU	02h
040000             0049  mos_cd:			EQU	03h
040000             0050  mos_dir:		EQU	04h
040000             0051  mos_del:		EQU	05h
040000             0052  mos_ren:		EQU	06h
040000             0053  mos_mkdir:		EQU	07h
040000             0054  mos_sysvars:		EQU	08h
040000             0055  mos_editline:		EQU	09h
040000             0056  mos_fopen:		EQU	0Ah
040000             0057  mos_fclose:		EQU	0Bh
040000             0058  mos_fgetc:		EQU	0Ch
040000             0059  mos_fputc:		EQU	0Dh
040000             0060  mos_feof:		EQU	0Eh
040000             0061  mos_getError:		EQU	0Fh
040000             0062  mos_oscli:		EQU	10h
040000             0063  mos_copy:		EQU	11h
040000             0064  mos_getrtc:		EQU	12h
040000             0065  mos_setrtc:		EQU	13h
040000             0066  mos_setintvector:	EQU	14h
040000             0067  mos_uopen:		EQU	15h
040000             0068  mos_uclose:		EQU	16h
040000             0069  mos_ugetc:		EQU	17h
040000             0070  mos_uputc:		EQU 	18h
040000             0071  mos_getfil:		EQU	19h
040000             0072  mos_fread:		EQU	1Ah
040000             0073  mos_fwrite:		EQU	1Bh
040000             0074  mos_flseek:		EQU	1Ch
040000             0075  mos_setkbvector:	EQU	1Dh
040000             0076  mos_getkbmap:		EQU	1Eh
040000             0077  mos_i2c_open:		EQU	1Fh
040000             0078  mos_i2c_close:		EQU	20h
040000             0079  mos_i2c_write:		EQU	21h
040000             0080  mos_i2c_read:		EQU	22h
040000             0081  
040000             0082  
040000             0083  ; FatFS file access functions
040000             0084  ;
040000             0085  ffs_fopen:		EQU	80h
040000             0086  ffs_fclose:		EQU	81h
040000             0087  ffs_fread:		EQU	82h
040000             0088  ffs_fwrite:		EQU	83h
040000             0089  ffs_flseek:		EQU	84h
040000             0090  ffs_ftruncate:		EQU	85h
040000             0091  ffs_fsync:		EQU	86h
040000             0092  ffs_fforward:		EQU	87h
040000             0093  ffs_fexpand:		EQU	88h
040000             0094  ffs_fgets:		EQU	89h
040000             0095  ffs_fputc:		EQU	8Ah
040000             0096  ffs_fputs:		EQU	8Bh
040000             0097  ffs_fprintf:		EQU	8Ch
040000             0098  ffs_ftell:		EQU	8Dh
040000             0099  ffs_feof:		EQU	8Eh
040000             0100  ffs_fsize:		EQU	8Fh
040000             0101  ffs_ferror:		EQU	90h
040000             0102  
040000             0103  ; FatFS directory access functions
040000             0104  ;
040000             0105  ffs_dopen:		EQU	91h
040000             0106  ffs_dclose:		EQU	92h
040000             0107  ffs_dread:		EQU	93h
040000             0108  ffs_dfindfirst:		EQU	94h
040000             0109  ffs_dfindnext:		EQU	95h
040000             0110  
040000             0111  ; FatFS file and directory management functions
040000             0112  ;
040000             0113  ffs_stat:		EQU	96h
040000             0114  ffs_unlink:		EQU	97h
040000             0115  ffs_rename:		EQU	98h
040000             0116  ffs_chmod:		EQU	99h
040000             0117  ffs_utime:		EQU	9Ah
040000             0118  ffs_mkdir:		EQU	9Bh
040000             0119  ffs_chdir:		EQU	9Ch
040000             0120  ffs_chdrive:		EQU	9Dh
040000             0121  ffs_getcwd:		EQU	9Eh
040000             0122  
040000             0123  ; FatFS volume management and system configuration functions
040000             0124  ;
040000             0125  ffs_mount:		EQU	9Fh
040000             0126  ffs_mkfs:		EQU	A0h
040000             0127  ffs_fdisk:		EQU	A1h
040000             0128  ffs_getfree:		EQU	A2h
040000             0129  ffs_getlabel:		EQU	A3h
040000             0130  ffs_setlabel:		EQU	A4h
040000             0131  ffs_setcp:		EQU	A5h
040000             0132  
040000             0133  ; File access modes
040000             0134  ;
040000             0135  fa_read:		EQU	01h
040000             0136  fa_write:		EQU	02h
040000             0137  fa_open_existing:	EQU	00h
040000             0138  fa_create_new:		EQU	04h
040000             0139  fa_create_always:	EQU	08h
040000             0140  fa_open_always:		EQU	10h
040000             0141  fa_open_append:		EQU	30h
040000             0142  
040000             0143  ; System variable indexes for api_sysvars
040000             0144  ; Index into _sysvars in globals.asm
040000             0145  ;
040000             0146  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0147  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0148  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0149  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0150  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0151  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0152  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0153  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0154  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0155  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0156  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0157  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0158  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0159  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0160  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0161  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0162  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0163  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0164  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0165  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0166  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0167  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0168  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0169  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0170  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0171  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0172  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0173  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0174  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0175  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0176  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0177  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0178  
040000             0179  ; Flags for the VPD protocol
040000             0180  ;
040000             0181  vdp_pflag_cursor:	EQU	00000001b
040000             0182  vdp_pflag_scrchar:	EQU	00000010b
040000             0183  vdp_pflag_point:	EQU	00000100b
040000             0184  vdp_pflag_audio:	EQU	00001000b
040000             0185  vdp_pflag_mode:		EQU	00010000b
040000             0186  vdp_pflag_rtc:		EQU	00100000b
040000             0187  vdp_pflag_mouse:	EQU	01000000b
040000             0188  ; vdp_pflag_buffered:	EQU	10000000b
040000             0189  
040000             0190  ;
040000             0191  ; FatFS structures
040000             0192  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0193  ;
040000             0194  ; Object ID and allocation information (FFOBJID)
040000             0195  ;
040000             0196  ; FFOBJID	.STRUCT
040000             0197  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0198  ; 	id:		DS	2	; Hosting volume mount ID
040000             0199  ; 	attr:		DS	1	; Object attribute
040000             0200  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0201  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0202  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0203  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0204  ; ;
040000             0205  ; ; File object structure (FIL)
040000             0206  ; ;
040000             0207  ; FIL .STRUCT
040000             0208  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0209  ; 	flag:		DS	1	; File status flags
040000             0210  ; 	err:		DS	1	; Abort flag (error code)
040000             0211  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0212  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0213  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0214  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0215  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0216  ; FIL_SIZE .ENDSTRUCT FIL
040000             0217  ; ;
040000             0218  ; ; Directory object structure (DIR)
040000             0219  ; ;
040000             0220  ; DIR .STRUCT
040000             0221  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0222  ; 	dptr:		DS	4	; Current read/write offset
040000             0223  ; 	clust:		DS	4	; Current cluster
040000             0224  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0225  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0226  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0227  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0228  ; DIR_SIZE .ENDSTRUCT DIR
040000             0229  ; ;
040000             0230  ; ; File information structure (FILINFO)
040000             0231  ; ;
040000             0232  ; FILINFO .STRUCT
040000             0233  ; 	fsize:		DS 	4	; File size
040000             0234  ; 	fdate:		DS	2	; Modified date
040000             0235  ; 	ftime:		DS	2	; Modified time
040000             0236  ; 	fattrib:	DS	1	; File attribute
040000             0237  ; 	altname:	DS	13	; Alternative file name
040000             0238  ; 	fname:		DS	256	; Primary file name
040000             0239  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0240  
040000             0241  ; FFOBJID offsets
040000             0242  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0243  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0244  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0245  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0246  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0247  FFOBJID.objsize:  EQU 11   ; Object size
040000             0248  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0249  
040000             0250  ; FIL offsets (including FFOBJID fields)
040000             0251  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0252  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0253  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0254  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0255  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0256  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0257  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0258  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0259  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0260  
040000             0261  ; DIR offsets (including FFOBJID fields)
040000             0262  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0263  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0264  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0265  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0266  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0267  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0268  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0269  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0270  
040000             0271  ; FILINFO offsets
040000             0272  FILINFO.fsize:    EQU 0    ; File size
040000             0273  FILINFO.fdate:    EQU 4    ; Modified date
040000             0274  FILINFO.ftime:    EQU 6    ; Modified time
040000             0275  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0276  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0277  FILINFO.fname:    EQU 22   ; Primary file name
040000             0278  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0279  
040000             0280  ;
040000             0281  ; Macro for calling the API
040000             0282  ; Parameters:
040000             0283  ; - function: One of the function numbers listed above
040000             0284  ;
040000             0285  			MACRO MOSCALL	function
040000             0286  			LD	A, function
040000             0287  			RST.LIS	08h
040000             0288  			ENDMACRO 	; --- End mos_api.inc ---
040000             0289  
040000             0290  ; --- Begin macros.inc ---
040000             0291  	; Title:	BBC Basic Interpreter - Z80 version
040000             0292  	;		Useful macros
040000             0293  	; Author:	Dean Belfield
040000             0294  	; Created:	12/05/2023
040000             0295  	; Last Updated:	11/06/2023
040000             0296  	;
040000             0297  	; Modinfo:
040000             0298  	; 11/06/2023:	Modified to run in ADL mode
040000             0299  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0300  
040000             0301  	MACRO EXREG	rp1, rp2
040000             0302  		PUSH	rp1
040000             0303  		POP	rp2
040000             0304  	ENDMACRO
040000             0305  
040000             0306  	; MACRO ADD8U_DE	reg
040000             0307  		MACRO ADD8U_DE
040000             0308  		ADD	A, E
040000             0309  		LD	E, A
040000             0310  		ADC	A, D
040000             0311  		SUB	E
040000             0312  		LD	D, A
040000             0313  	ENDMACRO
040000             0314  
040000             0315  	; MACRO ADD8U_HL	reg
040000             0316  	MACRO ADD8U_HL
040000             0317  		ADD	A, L
040000             0318  		LD	L, A
040000             0319  		ADC	A, H
040000             0320  		SUB	L
040000             0321  		LD	H, A
040000             0322  	ENDMACRO
040000             0323  
040000             0324  	MACRO VDU	val
040000             0325  		LD	A, val
040000             0326  		CALL	OSWRCH
040000             0327  	ENDMACRO
040000             0328  
040000             0329  	MACRO SET_GPIO	reg, val
040000             0330  		IN0	A, (reg)
040000             0331  		OR	val
040000             0332  		OUT0	(reg), A
040000             0333  	ENDMACRO
040000             0334  
040000             0335  	MACRO RES_GPIO	reg, val
040000             0336  		PUSH	BC
040000             0337  		LD	A, val
040000             0338  		CPL
040000             0339  		LD	C, A
040000             0340  		IN0	A, (reg)
040000             0341  		AND	C
040000             0342  		OUT0	(reg), A
040000             0343  		POP	BC
040000             0344  	ENDMACRO
040000             0345  ; --- End macros.inc ---
040000             0346  
040000             0347  ; --- Begin equs.inc ---
040000             0348  ;
040000             0349  ; Title:	BBC Basic for AGON - Equs
040000             0350  ; Author:	Dean Belfield
040000             0351  ; Created:	12/05/2023
040000             0352  ; Last Updated:	08/06/2023
040000             0353  ;
040000             0354  ; Modinfo:
040000             0355  ; 08/06/2023:	Added SIZEW
040000             0356  
040000             0357  			; XREF		STAVAR
040000             0358  			; XREF		ACCS
040000             0359  
040000             0360  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0361  ;Stack_Top:		EQU		0000h	; Stack at top
040000             0362  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0363  
040000             0364  ; For GPIO
040000             0365  ; PA not available on eZ80L92
040000             0366  ;
040000             0367  PA_DR:			EQU		96h
040000             0368  PA_DDR:			EQU		97h
040000             0369  PA_ALT1:		EQU		98h
040000             0370  PA_ALT2:		EQU		99h
040000             0371  PB_DR:          	EQU		9Ah
040000             0372  PB_DDR:        	 	EQU		9Bh
040000             0373  PB_ALT1:        	EQU		9Ch
040000             0374  PB_ALT2:        	EQU		9Dh
040000             0375  PC_DR:          	EQU		9Eh
040000             0376  PC_DDR:         	EQU		9Fh
040000             0377  PC_ALT1:        	EQU		A0h
040000             0378  PC_ALT2:        	EQU		A1h
040000             0379  PD_DR:          	EQU		A2h
040000             0380  PD_DDR:			EQU		A3h
040000             0381  PD_ALT1:		EQU		A4h
040000             0382  PD_ALT2:		EQU		A5h
040000             0383  
040000             0384  GPIOMODE_OUT:		EQU		0	; Output
040000             0385  GPIOMODE_IN:		EQU		1	; Input
040000             0386  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0387  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0388  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0389  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0390  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0391  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0392  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0393  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0394  
040000             0395  ; ; Originally in ram.asm
040000             0396  ; ;
040000             0397  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040000             0398  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040000             0399  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040000             0400  
040000             0401  ; Originally in main.asm
040000             0402  ;
040000             0403  CR:			EQU     0DH
040000             0404  LF:			EQU     0AH
040000             0405  ESC:			EQU     1BH
040000             0406  ; --- End equs.inc ---
040000             0407  
040000             0408  ; --- Begin init.asm ---
040000             0409  ;
040000             0410  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0411  ;		Initialisation Code
040000             0412  ; Author:	Dean Belfield
040000             0413  ; Created:	12/05/2023
040000             0414  ; Last Updated:	26/11/2023
040000             0415  ;
040000             0416  ; Modinfo:
040000             0417  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0418  ; 26/11/2023:	Moved the ram clear routine into here
040000             0419  
040000             0420  			; SEGMENT CODE
040000             0421  
040000             0422  			; XDEF	_end
040000             0423  
040000             0424  			; XREF	_main				; In main.asm
040000             0425  
040000             0426  			; XREF	RAM_START			; In ram.asm
040000             0427  			; XREF	RAM_END
040000             0428  
040000             0429  			; .ASSUME	ADL = 1
040000             0430  
040000             0431  			; INCLUDE	"equs.inc"
040000             0432  
040000             0433  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0434  
040000             0435  ;
040000             0436  ; Start in ADL mode
040000             0437  ;
040000 C3 45 00 04 0438  			JP	_start				; Jump to start
040004             0439  ;
040004             0440  ; The header stuff is from byte 64 onwards
040004             0441  ;
040004 42 42 43 42 0442  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040011             0443  
040011 FF FF FF FF 0444  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0445  
040040 4D 4F 53    0446  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0447  			DB	00h				; MOS header version 0
040044 01          0448  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0449  ;
040045             0450  ; And the code follows on immediately after the header
040045             0451  ;
040045 F5          0452  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0453  			PUSH		BC
040047 D5          0454  			PUSH		DE
040048 DD E5       0455  			PUSH		IX
04004A FD E5       0456  			PUSH		IY
04004C             0457  
04004C ED 73 D7 00 0458  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0459  
040051 DD 21 DA 00 0460  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0461  			PUSH		IX
040058 CD 88 00 04 0462  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0463  			POP		IX			; IX: argv
04005E 06 00       0464  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0465  			CALL		_clear_ram
040064 C3 E6 2F 04 0466  			JP		_main			; Start user code
040068             0467  ;
040068             0468  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0469  ;
040068 ED 7B D7 00 0470  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0471  
04006D FD E1       0472  			POP		IY			; Restore the registers
04006F DD E1       0473  			POP		IX
040071 D1          0474  			POP		DE
040072 C1          0475  			POP		BC
040073 F1          0476  			POP		AF
040074 C9          0477  			RET					; Return to MOS
040075             0478  
040075             0479  ;Clear the application memory
040075             0480  ;
040075 C5          0481  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0482  			LD		HL, RAM_START
04007A 11 01 4A 04 0483  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0484  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0485  			XOR		A
040083 77          0486  			LD		(HL), A
040084 ED B0       0487  			LDIR
040086 C1          0488  			POP		BC
040087 C9          0489  			RET
040088             0490  
040088             0491  ; Parse the parameter string into a C array
040088             0492  ; Parameters
040088             0493  ; - HL: Address of parameter string
040088             0494  ; - IX: Address for array pointer storage
040088             0495  ; Returns:
040088             0496  ; -  C: Number of parameters parsed
040088             0497  ;
040088 01 04 00 04 0498  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0499  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0500  			INC	IX
040091 DD 23       0501  			INC	IX
040093 DD 23       0502  			INC	IX
040095 CD D0 00 04 0503  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0504  ;
040099 01 01 00 00 0505  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0506  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0507  ;
04009F             0508  _parse_params_1:
04009F C5          0509  			PUSH	BC			; Stack ARGC
0400A0 E5          0510  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0511  			CALL	_get_token		; Get the next token
0400A5 79          0512  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0513  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0514  			POP	BC			; ARGC
0400A8 B7          0515  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0516  			RET	Z
0400AA             0517  ;
0400AA DD 1F 00    0518  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0519  			PUSH	HL			; DE=HL
0400AE D1          0520  			POP	DE
0400AF CD D0 00 04 0521  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0522  			XOR	A
0400B4 12          0523  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0524  			INC	IX
0400B7 DD 23       0525  			INC	IX
0400B9 DD 23       0526  			INC	IX			; Advance to next pointer position
0400BB 0C          0527  			INC	C			; Increment ARGC
0400BC 79          0528  			LD	A, C			; Check for C >= A
0400BD B8          0529  			CP	B
0400BE 38 DF       0530  			JR	C, _parse_params_1	; And loop
0400C0 C9          0531  			RET
0400C1             0532  
0400C1             0533  ; Get the next token
0400C1             0534  ; Parameters:
0400C1             0535  ; - HL: Address of parameter string
0400C1             0536  ; Returns:
0400C1             0537  ; - HL: Address of first character after token
0400C1             0538  ; -  C: Length of token (in characters)
0400C1             0539  ;
0400C1 0E 00       0540  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0541  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0542  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0543  			RET 	Z
0400C6 FE 0D       0544  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0545  			RET	Z
0400C9 FE 20       0546  			CP	' '			; Exit if space (end of token)
0400CB C8          0547  			RET	Z
0400CC 23          0548  			INC	HL			; Advance to next character
0400CD 0C          0549  			INC 	C			; Increment length
0400CE 18 F3       0550  			JR	@B
0400D0             0551  
0400D0             0552  ; Skip spaces in the parameter string
0400D0             0553  ; Parameters:
0400D0             0554  ; - HL: Address of parameter string
0400D0             0555  ; Returns:
0400D0             0556  ; - HL: Address of next none-space character
0400D0             0557  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0558  ;
0400D0 7E          0559  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0560  			CP	' '			; Exit if not space
0400D3 C0          0561  			RET	NZ
0400D4 23          0562  			INC	HL			; Advance to next character
0400D5 18 F9       0563  			JR	_skip_spaces		; Increment length
0400D7             0564  
0400D7             0565  ; Storage
0400D7             0566  ;
0400D7             0567  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0568  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0569  
04010A             0570  ; --- Begin eval.asm ---
04010A             0571  ;
04010A             0572  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0573  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0574  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0575  ; Modified By:	Dean Belfield
04010A             0576  ; Created:	12/05/2023
04010A             0577  ; Last Updated:	17/08/2023
04010A             0578  ;
04010A             0579  ; Modinfo:
04010A             0580  ; 07/06/2023:	Modified to run in ADL mode
04010A             0581  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0582  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0583  ; 17/08/2023:	Added binary constants
04010A             0584  
04010A             0585  			; .ASSUME	ADL = 1
04010A             0586  
04010A             0587  			; INCLUDE	"equs.inc"
04010A             0588  			; INCLUDE "macros.inc"
04010A             0589  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0590  
04010A             0591  			; SEGMENT CODE
04010A             0592  
04010A             0593  			; XDEF	EXPR
04010A             0594  			; XDEF	EXPRN
04010A             0595  			; XDEF	EXPRI
04010A             0596  			; XDEF	EXPRS
04010A             0597  			; XDEF	ITEMI
04010A             0598  			; XDEF	LOADN
04010A             0599  			; XDEF	LOAD4
04010A             0600  			; XDEF	CONS
04010A             0601  			; XDEF	LOADS
04010A             0602  			; XDEF	SFIX
04010A             0603  			; XDEF	VAL0
04010A             0604  			; XDEF	SEARCH
04010A             0605  			; XDEF	SWAP
04010A             0606  			; XDEF	TEST
04010A             0607  			; XDEF	DECODE
04010A             0608  			; XDEF	HEXSTR
04010A             0609  			; XDEF	STR
04010A             0610  			; XDEF	ZERO
04010A             0611  			; XDEF	PUSHS
04010A             0612  			; XDEF	POPS
04010A             0613  			; XDEF	COMMA
04010A             0614  			; XDEF	BRAKET
04010A             0615  			; XDEF	NXT
04010A             0616  			; XDEF	COUNT0
04010A             0617  
04010A             0618  			; XREF	ADVAL
04010A             0619  			; XREF	FN_EX
04010A             0620  			; XREF	POINT
04010A             0621  			; XREF	USR
04010A             0622  			; XREF	SYNTAX
04010A             0623  			; XREF	ERROR_
04010A             0624  			; XREF	CHECK
04010A             0625  			; XREF	GETVAR
04010A             0626  			; XREF	LISTON
04010A             0627  			; XREF	RANGE
04010A             0628  			; XREF	FPP
04010A             0629  			; XREF	GETCSR
04010A             0630  			; XREF	CHANEL
04010A             0631  			; XREF	OSSTAT
04010A             0632  			; XREF	OSBGET
04010A             0633  			; XREF	LOMEM
04010A             0634  			; XREF	HIMEM
04010A             0635  			; XREF	PAGE_
04010A             0636  			; XREF	TOP
04010A             0637  			; XREF	ERL
04010A             0638  			; XREF	ERR
04010A             0639  			; XREF	COUNT
04010A             0640  			; XREF	OSOPEN
04010A             0641  			; XREF	GETEXT
04010A             0642  			; XREF	GETPTR
04010A             0643  			; XREF	GETIME
04010A             0644  			; XREF	GETIMS
04010A             0645  			; XREF	LEXAN2
04010A             0646  			; XREF	RANDOM
04010A             0647  			; XREF	STORE5
04010A             0648  			; XREF	GETSCHR
04010A             0649  			; XREF	OSRDCH
04010A             0650  			; XREF	OSKEY
04010A             0651  			; XREF	INKEY1
04010A             0652  			; XREF	EXTERR
04010A             0653  ;
04010A             0654  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0655  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0656  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0657  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0658  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0659  ;
04010A             0660  ; BINARY INTEGER REPRESENTATION:
04010A             0661  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0662  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0663  ;
04010A             0664  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0665  ;                             EXPONENT - C
04010A             0666  ;
04010A             0667  
04010A             0668  ;
04010A             0669  ; Table of addresses for functions
04010A             0670  ;
04010A             0671  FUNTOK:			EQU	8DH			; First token number
04010A             0672  ;
04010A E6 08 04    0673  FUNTBL:			DW24	DECODE			; Line number
04010D 94 05 04    0674  			DW24	OPENIN			; OPENIN
040110 B6 05 04    0675  			DW24	PTR_EV			; PTR
040113 50 05 04    0676  			DW24	PAGEV			; PAGE
040116 C0 05 04    0677  			DW24	TIMEV			; TIME
040119 3C 05 04    0678  			DW24	LOMEMV			; LOMEM
04011C 46 05 04    0679  			DW24	HIMEMV			; HIMEM
04011F 14 06 04    0680  			DW24	ABSV			; ABS
040122 50 06 04    0681  			DW24	ACS			; ACS
040125 7C 49 04    0682  			DW24	ADVAL			; ADVAL
040128 25 05 04    0683  			DW24	ASC			; ASC
04012B 48 06 04    0684  			DW24	ASN			; ASN
04012E 4C 06 04    0685  			DW24	ATN			; ATN
040131 EE 04 04    0686  			DW24	BGET			; BGET
040134 34 06 04    0687  			DW24	COS			; COS
040137 7B 05 04    0688  			DW24	COUNTV			; COUNT
04013A 1C 06 04    0689  			DW24	DEG			; DEG
04013D 6F 05 04    0690  			DW24	ERLV			; ERL
040140 75 05 04    0691  			DW24	ERRV			; ERR
040143 79 06 04    0692  			DW24	EVAL_			; EVAL
040146 3C 06 04    0693  			DW24	EXP			; EXP
040149 AC 05 04    0694  			DW24	EXT			; EXT
04014C 93 09 04    0695  			DW24	ZERO			; FALSE
04014F 7F 10 04    0696  			DW24	FN_EX			; FN
040152 0C 05 04    0697  			DW24	GET			; GET
040155 FB 04 04    0698  			DW24	INKEY			; INKEY
040158 2B 07 04    0699  			DW24	INSTR			; INSTR(
04015B 28 06 04    0700  			DW24	INT_			; INT
04015E 35 05 04    0701  			DW24	LEN			; LEN
040161 40 06 04    0702  			DW24	LN			; LN
040164 44 06 04    0703  			DW24	LOG			; LOG
040167 18 06 04    0704  			DW24	NOTK			; NOT
04016A 90 05 04    0705  			DW24	OPENUP			; OPENUP
04016D 8D 05 04    0706  			DW24	OPENOT			; OPENOUT
040170 10 06 04    0707  			DW24	PI			; PI
040173 9F 44 04    0708  			DW24	POINT			; POINT(
040176 CD 04 04    0709  			DW24	POS			; POS
040179 20 06 04    0710  			DW24	RAD			; RAD
04017C AD 06 04    0711  			DW24	RND			; RND
04017F 24 06 04    0712  			DW24	SGN			; SGN
040182 38 06 04    0713  			DW24	SIN			; SIN
040185 2C 06 04    0714  			DW24	SQR			; SQR
040188 30 06 04    0715  			DW24	TAN			; TAN
04018B 5A 05 04    0716  			DW24	TOPV			; TO(P)
04018E 05 06 04    0717  			DW24	TRUE			; TRUE
040191 4C 15 04    0718  			DW24	USR			; USR
040194 6A 06 04    0719  			DW24	VAL			; VAL
040197 D6 04 04    0720  			DW24	VPOS			; VPOS
04019A BF 07 04    0721  			DW24	CHRS			; CHRS
04019D C7 07 04    0722  			DW24	GETS			; GETS
0401A0 D8 07 04    0723  			DW24	INKEYS			; INKEYS
0401A3 5D 08 04    0724  			DW24	LEFTS			; LEFTS(
0401A6 25 08 04    0725  			DW24	MIDS			; MIDS(
0401A9 7D 08 04    0726  			DW24	RIGHTS			; RIGHTS(
0401AC 4A 09 04    0727  			DW24	STRS			; STR$
0401AF 9E 08 04    0728  			DW24	STRING_			; STRINGS(
0401B2 DE 04 04    0729  			DW24	EOF			; EOF
0401B5             0730  ;
0401B5             0731  FUNTBL_END:		EQU	$
0401B5             0732  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0733  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0734  
0401B5             0735  ANDK:			EQU     80H
0401B5             0736  DIVK:			EQU     81H
0401B5             0737  EORK:			EQU     82H
0401B5             0738  MODK:			EQU     83H
0401B5             0739  ORK:			EQU     84H
0401B5             0740  ;
0401B5 F0 05 04    0741  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 F9 05 04    0742  			DW24	SNE			; <>
0401BB E9 05 04    0743  			DW24	SGE			; >=
0401BE DA 05 04    0744  			DW24	SLT			; <
0401C1 00 06 04    0745  			DW24	SEQ			; =
0401C4 E1 05 04    0746  			DW24	SGT			; >
0401C7             0747  ;
0401C7             0748  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0749  ;     Expression type is returned in A'F':
0401C7             0750  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0751  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0752  ; Floating-point or integer result returned in HLH'L'C
0401C7             0753  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0754  ; String result returned in string accumulator, DE set.
0401C7             0755  ;
0401C7             0756  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0757  ;               (2) ^
0401C7             0758  ;               (3) * / MOD DIV
0401C7             0759  ;               (4) + -
0401C7             0760  ;               (5) = <> <= >= > <
0401C7             0761  ;               (6) AND
0401C7             0762  ;               (7) EOR OR
0401C7             0763  
0401C7             0764  ;
0401C7             0765  ; Level 7: EOR and OR
0401C7             0766  ;
0401C7 CD E0 01 04 0767  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0768  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0769  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0770  			CP      ORK			; Is operator OR
0401D1 C0          0771  			RET     NZ			; No, so return
0401D2             0772  ;
0401D2 CD 3E 0A 04 0773  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0774  			CALL    EXPR1           	; Get second operand
0401DA CD 4D 0A 04 0775  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0776  			JR      EXPR0A          	; And continue
0401E0             0777  ;
0401E0             0778  ; Level 6: AND
0401E0             0779  ;
0401E0 CD F5 01 04 0780  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0781  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0782  			RET     NZ			; No, so return
0401E7 CD 3E 0A 04 0783  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0784  			CALL    EXPR2			; Get second operand
0401EF CD 4D 0A 04 0785  			CALL    DOIT			; Do the operation
0401F3 18 EF       0786  			JR      EXPR1A			; And continue
0401F5             0787  ;
0401F5             0788  ; Level 5: Comparisons
0401F5             0789  ;
0401F5 CD 67 02 04 0790  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 15 0A 04 0791  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0792  			RET     NZ			; No, so return
0401FE 47          0793  			LD      B,A			; Store the first operator in B
0401FF FD 23       0794  			INC     IY              	; Bump over operator
040201 CD 70 0A 04 0795  			CALL    NXT			;
040205 CD 15 0A 04 0796  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0797  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0798  			INC     IY			; Bump over operator
04020D B8          0799  			CP      B			; Compare with first
04020E CA 97 0C 04 0800  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0801  			ADD     A,B
040213 47          0802  			LD      B,A			; B: Unique code for the compound operator
040214 78          0803  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0804  			EX      AF,AF'
040216 FA 30 02 04 0805  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0806  			EX      AF,AF'
04021B D6 04       0807  			SUB     4
04021D FE 3A       0808  			CP      '>'-4
04021F 20 02       0809  			JR      NZ,EXPR2C
040221 C6 02       0810  			ADD     A,2
040223 CD 40 0A 04 0811  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0812  			CALL    EXPR3
04022B CD 4D 0A 04 0813  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0814  			RET
040230             0815  ;
040230 08          0816  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0817  			DEC     A
040232 E6 07       0818  			AND     7
040234 CD B4 09 04 0819  			CALL    PUSHS           	; Save string on the stack
040238 F5          0820  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0821  			CALL    EXPR3           	; Get the second string
04023D 08          0822  			EX      AF,AF'
04023E F2 36 03 04 0823  			JP      P,TYPE_EV_
040242 F1          0824  			POP     AF
040243 4B          0825  			LD      C,E             	; Length of string #2
040244 D1          0826  			POP     DE
040245 21 00 00 00 0827  			LD      HL,0
040249 39          0828  			ADD     HL,SP
04024A 43          0829  			LD      B,E             	; Length of string #1
04024B D5          0830  			PUSH    DE
04024C 11 00 4A 04 0831  			LD      DE,ACCS
040250 EB          0832  			EX      DE,HL
040251 CD 7C 0A 04 0833  			CALL    DISPT2
040255 D1          0834  			POP     DE
040256 EB          0835  			EX      DE,HL
040257 7D          0836  			LD	A,L
040258 21 00 00 00 0837  			LD	HL,0
04025C 6F          0838  			LD	L,A
04025D 39          0839  			ADD     HL,SP
04025E F9          0840  			LD      SP,HL
04025F EB          0841  			EX      DE,HL
040260 AF          0842  			XOR     A               	; Numeric marker
040261 4F          0843  			LD      C,A             	; Integer marker
040262 08          0844  			EX      AF,AF'
040263 FD 7E 00    0845  			LD      A,(IY)
040266 C9          0846  			RET
040267             0847  ;
040267             0848  ; Level 4: + and -
040267             0849  ;
040267 CD C4 02 04 0850  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0851  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0852  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0853  			CP      '+'			; Is it "+"?
040271 C0          0854  			RET     NZ			; No, so return
040272 08          0855  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0856  			JP      M,EXPR3S		; Branch here if string
040277 08          0857  			EX      AF,AF'
040278 CD 3E 0A 04 0858  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C4 02 04 0859  			CALL    EXPR4			; Fetch the second operator
040280 CD 4D 0A 04 0860  			CALL    DOIT			; Do the operation
040284 18 E5       0861  			JR      EXPR3A			; And continue
040286             0862  ;
040286 08          0863  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0864  			INC     IY              	; Bump past the "+"
040289 CD B4 09 04 0865  			CALL    PUSHS           	; Save the string on the stack
04028D CD C4 02 04 0866  			CALL    EXPR4           	; Fetch the second operator
040291 08          0867  			EX      AF,AF'
040292 F2 36 03 04 0868  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0869  			LD	BC, 0			; Clear BC
04029A 4B          0870  			LD      C,E             	; C: Length of the second string
04029B D1          0871  			POP     DE
04029C D5          0872  			PUSH    DE
04029D 21 00 4A 04 0873  			LD      HL,ACCS
0402A1             0874  ; BEGIN MISSING FROM BINARY
0402A1             0875  			; LD	A,E			;  E: Length of the first string
0402A1             0876  			; LD      DE,ACCS
0402A1             0877  			; LD	E,A 			; DE: Pointer to the end of the first string
0402A1             0878  ; END MISSING FROM BINARY
0402A1 54          0879  			LD		D,H ; ADDED FROM BINARY
0402A2 79          0880  			LD      A,C
0402A3 B7          0881  			OR      A
0402A4 28 0F       0882  			JR      Z,EXP3S3
0402A6 6F          0883  			LD      L,A             	; Source
0402A7 83          0884  			ADD     A,E
0402A8 5F          0885  			LD      E,A             	; Destination
0402A9 3E 13       0886  			LD      A,19
0402AB DA 90 37 04 0887  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402AF D5          0888  			PUSH    DE
0402B0 1D          0889  			DEC     E
0402B1 2D          0890  			DEC     L
0402B2 ED B8       0891  			LDDR                    	; Copy
0402B4 D1          0892  			POP     DE
0402B5 D9          0893  EXP3S3:			EXX
0402B6 C1          0894  			POP     BC
0402B7 CD DE 09 04 0895  			CALL    POPS            	; Restore from stack
0402BB D9          0896  			EXX
0402BC F6 80       0897  			OR      80H             	; Flag as a string
0402BE 08          0898  			EX      AF,AF'
0402BF FD 7E 00    0899  			LD      A,(IY)			; Fetch the next character
0402C2 18 A7       0900  			JR      EXPR3A			; And continue
0402C4             0901  ;
0402C4             0902  ; Level 3: * / MOD DIV
0402C4             0903  ;
0402C4 CD E5 02 04 0904  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402C8 FE 2A       0905  EXPR4A:			CP      '*'			; "*" is valid
0402CA 28 0B       0906  			JR      Z,EXPR4B
0402CC FE 2F       0907  			CP      '/'			; "/" is valid
0402CE 28 07       0908  			JR      Z,EXPR4B
0402D0 FE 83       0909  			CP      MODK			; MOD token is valid
0402D2 28 03       0910  			JR      Z,EXPR4B
0402D4 FE 81       0911  			CP      DIVK			; DIV token is valid
0402D6 C0          0912  			RET     NZ			; And return if it is anything else
0402D7 CD 3E 0A 04 0913  EXPR4B:			CALL    SAVE_EV
0402DB CD E5 02 04 0914  			CALL    EXPR5
0402DF CD 4D 0A 04 0915  			CALL    DOIT
0402E3 18 E3       0916  			JR      EXPR4A
0402E5             0917  ;
0402E5             0918  ; Level 2: ^
0402E5             0919  ;
0402E5 CD C5 03 04 0920  EXPR5:			CALL    ITEM			; Get variable
0402E9 B7          0921  			OR      A               	; Test type
0402EA 08          0922  			EX      AF,AF'          	; Save type
0402EB CD 70 0A 04 0923  EXPR5A:			CALL    NXT			; Skip spaces
0402EF FE 5E       0924  			CP      '^'			; Is the operator "^"?
0402F1 C0          0925  			RET     NZ			; No, so return
0402F2 CD 3E 0A 04 0926  			CALL    SAVE_EV			; Save first operand
0402F6 CD C5 03 04 0927  			CALL    ITEM			; Get second operand
0402FA B7          0928  			OR      A			; Test type
0402FB 08          0929  			EX      AF,AF'			; Save type
0402FC CD 4D 0A 04 0930  			CALL    DOIT			; Do the operation
040300 18 E9       0931  			JR      EXPR5A			; And continue
040302             0932  ;
040302             0933  ; Evaluate a numeric expression
040302             0934  ;
040302 CD C7 01 04 0935  EXPRN:			CALL    EXPR			; Evaluate expression
040306 08          0936  			EX      AF,AF'			; Get the type
040307 F0          0937  			RET     P			; And return if it is a number
040308 18 2C       0938  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030A             0939  ;
04030A             0940  ; Evaluate a fixed-point expression
04030A             0941  ;
04030A CD C7 01 04 0942  EXPRI:			CALL    EXPR			; Evaluate the expression
04030E 08          0943  			EX      AF,AF'			; Get the type
04030F F2 62 06 04 0944  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040313 18 21       0945  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040315             0946  ;
040315             0947  ; Evaluate a string expression
040315             0948  ;
040315 CD C7 01 04 0949  EXPRS:			CALL    EXPR			; Evaluate the expression
040319 08          0950  			EX      AF,AF'			; Get the type
04031A F8          0951  			RET     M			; And return if it is a string
04031B 18 19       0952  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031D             0953  ;
04031D             0954  ; Get a numeric variable
04031D             0955  ;
04031D CD C5 03 04 0956  ITEMN:			CALL    ITEM			; Get the variable
040321 B7          0957  			OR      A			; Test the type
040322 F0          0958  			RET     P			; And return if it is a number
040323 18 11       0959  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040325             0960  ;
040325             0961  ; Get a fixed-point variable
040325             0962  ;
040325 CD C5 03 04 0963  ITEMI:			CALL    ITEM			; Get the variable
040329 B7          0964  			OR      A			; Test the type
04032A F2 62 06 04 0965  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04032E 18 06       0966  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040330             0967  ;
040330             0968  ; Get a string variable
040330             0969  ;
040330 CD C5 03 04 0970  ITEMS:			CALL    ITEM			; Get the variable
040334 B7          0971  			OR      A			; Test the type
040335 F8          0972  			RET     M			; If it is a string, then return
040336             0973  ;							; Otherwise
040336 3E 06       0974  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040338 C3 90 37 04 0975  			JP      ERROR_
04033C             0976  ;
04033C             0977  ; Evaluate a bracketed expression
04033C             0978  ;
04033C CD C7 01 04 0979  ITEM1:			CALL    EXPR            	; Evaluate the expression
040340 CD 2F 0A 04 0980  			CALL    BRAKET			; Check for closing bracket
040344 08          0981  			EX      AF,AF'
040345 C9          0982  			RET
040346             0983  ;
040346             0984  ; HEX - Get hexadecimal constant.
040346             0985  ;   Inputs: ASCII string at (IY)
040346             0986  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040346             0987  ;           IY updated (points to delimiter)
040346             0988  ;
040346 CD 93 09 04 0989  HEX:			CALL    ZERO			; Set result to 0
04034A CD F8 09 04 0990  			CALL    HEXDIG			; Fetch the character from IY
04034E 38 1B       0991  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040350 FD 23       0992  HEX1:			INC     IY			; Move pointer to next character
040352 E6 0F       0993  			AND     0FH			; Clear the top nibble
040354 06 04       0994  			LD      B,4			; Loop counter
040356             0995  ;
040356 D9          0996  HEX2:			EXX				; Shift the result left B (4) times. This makes
040357 52 29       0997  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040359 D9          0998  			EXX				; .
04035A 52 ED 6A    0999  			ADC.S   HL,HL			; .
04035D 10 F7       1000  			DJNZ    HEX2			; And loop
04035F D9          1001  			EXX
040360 B5          1002  			OR      L			; OR in the digit
040361 6F          1003  			LD      L,A
040362 D9          1004  			EXX
040363             1005  ;
040363 CD F8 09 04 1006  			CALL    HEXDIG			; Fetch the next character
040367 30 E7       1007  			JR      NC,HEX1			; If it is a HEX digit then loop
040369 AF          1008  			XOR     A			; Clear A
04036A C9          1009  			RET
04036B             1010  ;
04036B 3E 1C       1011  BADHEX:			LD      A,28
04036D C3 90 37 04 1012  			JP      ERROR_          	; Error: "Bad HEX"
040371             1013  ;
040371             1014  ; BIN - Get binary constant.
040371             1015  ;   Inputs: ASCII string at (IY)
040371             1016  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040371             1017  ;           IY updated (points to delimiter)
040371             1018  ;
040371 CD 93 09 04 1019  BIN:			CALL    ZERO			; Set result to 0
040375 CD 0B 0A 04 1020  			CALL	BINDIG			; Fetch the character from IY
040379 38 13       1021  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037B FD 23       1022  BIN1:			INC	IY			; Move pointer to next character
04037D 0F          1023  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04037E D9          1024  			EXX				;
04037F 52 ED 6A    1025  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040382 D9          1026  			EXX
040383 52 ED 6A    1027  			ADC.S	HL,HL
040386 CD 0B 0A 04 1028  			CALL	BINDIG			; Fetch the next character
04038A 30 EF       1029  			JR	NC,BIN1
04038C AF          1030  			XOR	A			; Clear A
04038D C9          1031  			RET
04038E             1032  ;
04038E 3E 1C       1033  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040390 CD A7 37 04 1034  			CALL	EXTERR
040394 42 61 64 20 1035  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
04039F             1036  ;
04039F             1037  ; MINUS - Unary minus.
04039F             1038  ;   Inputs: IY = text pointer
04039F             1039  ;  Outputs: Numeric result, same type as argument.
04039F             1040  ;           Result in H'L'HLC
04039F             1041  ;
04039F CD 1D 03 04 1042  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A3 0D          1043  MINUS0:			DEC     C			; Check exponent (C)
0403A4 0C          1044  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403A5 28 06       1045  			JR      Z,NEGATE_EV        	; So do an integer negation
0403A7             1046  ;
0403A7 7C          1047  			LD      A,H			; Do a FP negation by
0403A8 EE 80       1048  			XOR     80H             	; Toggling the sign bit (H)
0403AA 67          1049  			LD      H,A
0403AB AF          1050  			XOR     A               	; Numeric marker
0403AC C9          1051  			RET
0403AD             1052  ;
0403AD D9          1053  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403AE 7C          1054  			LD      A,H			; First do a one's complement by negating all the bytes
0403AF 2F          1055  			CPL
0403B0 67          1056  			LD      H,A
0403B1 7D          1057  			LD      A,L
0403B2 2F          1058  			CPL
0403B3 6F          1059  			LD      L,A
0403B4 D9          1060  			EXX
0403B5 7C          1061  			LD      A,H
0403B6 2F          1062  			CPL
0403B7 67          1063  			LD      H,A
0403B8 7D          1064  			LD      A,L
0403B9 2F          1065  			CPL
0403BA 6F          1066  			LD      L,A
0403BB D9          1067  ADD1:			EXX				; Then add 1
0403BC 23          1068  			INC     HL
0403BD 7C          1069  			LD      A,H
0403BE B5          1070  			OR      L
0403BF D9          1071  			EXX
0403C0 3E 00       1072  			LD      A,0             	; Numeric marker
0403C2 C0          1073  			RET     NZ
0403C3 23          1074  			INC     HL
0403C4 C9          1075  			RET
0403C5             1076  ;
0403C5             1077  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403C5             1078  ; Item type is returned in A:  Bit 7=0 numeric.
0403C5             1079  ;                              Bit 7=1 string.
0403C5             1080  ; Numeric item returned in HLH'L'C.
0403C5             1081  ; String item returned in string accumulator,
0403C5             1082  ;   DE addresses byte after last (E=length).
0403C5             1083  ;
0403C5 CD 79 16 04 1084  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403C9 CD 70 0A 04 1085  			CALL    NXT			; Skip spaces
0403CD FD 23       1086  			INC     IY			; Move to the prefix character
0403CF FE 26       1087  			CP      '&'			; If `&`
0403D1 CA 46 03 04 1088  			JP      Z,HEX           	; Then get a HEX constant
0403D5 FE 25       1089  			CP	'%'			; If '%'
0403D7 28 98       1090  			JR	Z,BIN			; Then get a BINARY constant
0403D9 FE 2D       1091  			CP      '-'			; If `-`
0403DB 28 C2       1092  			JR      Z,MINUS         	; Then get a negative number
0403DD FE 2B       1093  			CP      '+'			; If `+`
0403DF CA 1D 03 04 1094  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E3 FE 28       1095  			CP      '('			; If `(`
0403E5 CA 3C 03 04 1096  			JP      Z,ITEM1         	; Start of a bracketed expression
0403E9 FE 22       1097  			CP      34			; If `"`
0403EB 28 7A       1098  			JR      Z,CONS          	; Start of a string constant
0403ED FE C6       1099  			CP      TCMD_EV			; Is it out of range of the function table?
0403EF D2 97 0C 04 1100  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F3 FE 8D       1101  			CP      FUNTOK			; If it is in range, then
0403F5 D2 83 0A 04 1102  			JP      NC,DISPAT       	; It's a function
0403F9 FD 2B       1103  			DEC     IY
0403FB FE 3A       1104  			CP      ':'
0403FD 30 0C       1105  			JR      NC,ITEM2		; VARIABLE?
0403FF FE 30       1106  			CP      '0'
040401 D2 8E 04 04 1107  			JP      NC,CON			; NUMERIC CONSTANT
040405 FE 2E       1108  			CP      '.'
040407 CA 8E 04 04 1109  			JP      Z,CON			; NUMERIC CONSTANT
04040B CD 6A 3A 04 1110  ITEM2:			CALL    GETVAR			; VARIABLE
04040F 20 37       1111  			JR      NZ,NOSUCH
040411 B7          1112  			OR      A
040412 FA A0 04 04 1113  			JP      M,LOADS			; STRING VARIABLE
040416 B7          1114  LOADN:			OR      A
040417 28 20       1115  			JR      Z,LOAD1			; BYTE VARIABLE
040419 0E 00       1116  			LD      C,0
04041B CB 47       1117  			BIT     0,A
04041D 28 03       1118  			JR      Z,LOAD4			; INTEGER VARIABLE
04041F DD 4E 04    1119  LOAD5:			LD      C,(IX+4)
040422 D9          1120  LOAD4:			EXX
040423 21 00 00 00 1121  			LD	HL, 0			; TODO: Optimise
040427 DD 6E 00    1122  			LD      L,(IX+0)
04042A DD 66 01    1123  			LD      H,(IX+1)
04042D D9          1124  			EXX
04042E 21 00 00 00 1125  			LD	HL, 0			; TODO: Optimise
040432 DD 6E 02    1126  			LD      L,(IX+2)
040435 DD 66 03    1127  			LD      H,(IX+3)
040438 C9          1128  			RET
040439             1129  ;
040439 21 00 00 00 1130  LOAD1:			LD      HL,0
04043D D9          1131  			EXX
04043E 21 00 00 00 1132  			LD      HL,0			; TODO: Optimise
040442 DD 6E 00    1133  			LD      L,(IX+0)
040445 D9          1134  			EXX
040446 4C          1135  			LD      C,H
040447 C9          1136  			RET
040448             1137  ;
040448 DA 97 0C 04 1138  NOSUCH:			JP      C,SYNTAX
04044C 3A 40 4D 04 1139  			LD      A,(LISTON)
040450 CB 6F       1140  			BIT     5,A
040452 3E 1A       1141  			LD      A,26
040454 20 26       1142  			JR      NZ,ERROR0_EV		; Throw "No such variable"
040456 FD 23       1143  NOS1:			INC     IY
040458 CD 9F 3C 04 1144  			CALL    RANGE
04045C 30 F8       1145  			JR      NC,NOS1
04045E DD 21 40 30 1146  			LD      IX,PC
       11          
040463 AF          1147  			XOR     A
040464 4F          1148  			LD      C,A
040465 18 BB       1149  			JR      LOAD4
040467             1150  ;
040467             1151  ;CONS - Get string constant from ASCII string.
040467             1152  ;   Inputs: ASCII string at (IY)
040467             1153  ;  Outputs: Result in string accumulator.
040467             1154  ;           D = MS byte of ACCS, E = string length
040467             1155  ;           A7 = 1 (string marker)
040467             1156  ;           IY updated
040467             1157  ;
040467 11 00 4A 04 1158  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04046B FD 7E 00    1159  CONS3:			LD      A,(IY)			; Fetch the first character and
04046E FD 23       1160  			INC     IY			; Increment the pointer
040470 FE 22       1161  			CP      '"'			; Check for start quote
040472 28 0C       1162  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040474             1163  ;
040474 12          1164  CONS1:			LD      (DE),A			; Store the character in the string accumulator
040475 1C          1165  			INC     E			; Increment the string accumulator pointer
040476 FE 0D       1166  			CP      CR			; Is it CR
040478 20 F1       1167  			JR      NZ,CONS3		; No, so keep looping
04047A             1168  ;
04047A 3E 09       1169  			LD      A,9
04047C C3 90 37 04 1170  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040480             1171  ;
040480 FD 7E 00    1172  CONS2:			LD      A,(IY)			; Fetch the next character
040483 FE 22       1173  			CP      '"'			; Check for end quote?
040485 FD 23       1174  			INC     IY			; Increment the pointer
040487 28 EB       1175  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040489 FD 2B       1176  			DEC     IY			;
04048B 3E 80       1177  			LD      A,80H           	; String marker
04048D C9          1178  			RET
04048E             1179  ;
04048E             1180  ;CON - Get unsigned numeric constant from ASCII string.
04048E             1181  ;   Inputs: ASCII string at (IY).
04048E             1182  ;  Outputs: Variable-type result in HLH'L'C
04048E             1183  ;           IY updated (points to delimiter)
04048E             1184  ;           A7 = 0 (numeric marker)
04048E             1185  ;
04048E FD E5       1186  CON:			PUSH    IY
040490 DD E1       1187  			POP     IX
040492 3E 24       1188  			LD      A,36
040494 CD 9A 20 04 1189  			CALL    FPP
040498 38 E2       1190  			JR      C,ERROR0_EV
04049A DD E5       1191  			PUSH    IX
04049C FD E1       1192  			POP     IY
04049E AF          1193  			XOR     A
04049F C9          1194  			RET
0404A0             1195  ;
0404A0 11 00 4A 04 1196  LOADS:			LD      DE,ACCS			; Where to store the string
0404A4 1F          1197  			RRA
0404A5 30 1A       1198  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404A7             1199  ;
0404A7 D9          1200  			EXX				; This block was a call to LOAD4
0404A8 DD 6E 00    1201  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404AB DD 66 01    1202  			LD      H,(IX+1)		; The maximum original string length
0404AE D9          1203  			EXX
0404AF DD 27 02    1204  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B2             1205  ;
0404B2 D9          1206  			EXX
0404B3 7D          1207  			LD      A,L
0404B4 D9          1208  			EXX
0404B5 B7          1209  			OR      A
0404B6 01 00 00 00 1210  			LD	BC,0			; BC: Number of bytes to copy
0404BA 4F          1211  			LD      C,A
0404BB 3E 80       1212  			LD      A,80H           	; String marker
0404BD C8          1213  			RET     Z
0404BE ED B0       1214  			LDIR
0404C0 C9          1215  			RET
0404C1 7E          1216  LOADS2:			LD      A,(HL)
0404C2 12          1217  			LD      (DE),A
0404C3 23          1218  			INC     HL
0404C4 FE 0D       1219  			CP      CR
0404C6 3E 80       1220  			LD      A,80H           	; String marker
0404C8 C8          1221  			RET     Z
0404C9 1C          1222  			INC     E
0404CA 20 F5       1223  			JR      NZ,LOADS2
0404CC C9          1224  			RET                     	; Return null string
0404CD             1225  ;
0404CD             1226  ;VARIABLE-TYPE FUNCTIONS:
0404CD             1227  ;
0404CD             1228  ;Result returned in HLH'L'C (floating point)
0404CD             1229  ;Result returned in HLH'L' (C=0) (integer)
0404CD             1230  ;Result returned in string accumulator & DE (string)
0404CD             1231  ;All registers destroyed.
0404CD             1232  ;IY (text pointer) updated.
0404CD             1233  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404CD             1234  ;
0404CD             1235  ;POS - horizontal cursor position.
0404CD             1236  ;VPOS - vertical cursor position.
0404CD             1237  ;EOF - return status of file.
0404CD             1238  ;BGET - read byte from file.
0404CD             1239  ;INKEY - as GET but wait only n centiseconds.
0404CD             1240  ;GET - wait for keypress and return ASCII value.
0404CD             1241  ;GET(n) - input from Z80 port n.
0404CD             1242  ;ASC - ASCII value of string.
0404CD             1243  ;LEN - length of string.
0404CD             1244  ;LOMEM - location of dynamic variables.
0404CD             1245  ;HIMEM - top of available RAM.
0404CD             1246  ;PAGE - start of current text page.
0404CD             1247  ;TOP - address of first free byte after program.
0404CD             1248  ;ERL - line number where last error occurred.
0404CD             1249  ;ERR - number of last error.
0404CD             1250  ;COUNT - number of printing characters since CR.
0404CD             1251  ;Results are integer numeric.
0404CD             1252  ;
0404CD CD FC 3E 04 1253  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D1 EB          1254  			EX      DE,HL			;  L: The X cursor position
0404D2 C3 81 05 04 1255  			JP      COUNT1			; Return an 8-bit value
0404D6             1256  ;
0404D6 CD FC 3E 04 1257  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DA C3 81 05 04 1258  			JP      COUNT1			; Return an 8-bit value
0404DE             1259  ;
0404DE CD B0 18 04 1260  EOF:			CALL    CHANEL			; Check for EOF
0404E2 CD 85 43 04 1261  			CALL    OSSTAT
0404E6 CA 05 06 04 1262  			JP      Z,TRUE			; Yes, so return true
0404EA C3 93 09 04 1263  			JP      ZERO			; Otherwise return false (zero)
0404EE             1264  ;
0404EE CD B0 18 04 1265  BGET:			CALL    CHANEL          	; Channel number
0404F2 CD 74 43 04 1266  			CALL    OSBGET
0404F6 6F          1267  			LD      L,A
0404F7 C3 7F 05 04 1268  			JP      COUNT0			; Return an 8-bit value
0404FB             1269  ;
0404FB CD 25 03 04 1270  INKEY:			CALL    ITEMI			; Get the argument
0404FF CB 7C       1271  			BIT	7, H			; Check the sign
040501 D9          1272  			EXX				; HL: The argument
040502 C2 EB 07 04 1273  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040506 CD DD 07 04 1274  			CALL	INKEY0 			; Do INKEY(n)
04050A 18 1D       1275  			JR      ASC0			; Return a numeric value
04050C             1276  ;
04050C CD 70 0A 04 1277  GET:			CALL    NXT			; Skip whitespace
040510 FE 28       1278  			CP      '('			; Is it GET(
040512 20 0B       1279  			JR      NZ,GET0			; No, so get a keyboard character
040514 CD 25 03 04 1280  			CALL    ITEMI           	; Yes, so fetch the port address
040518 D9          1281  			EXX
040519 44          1282  			LD      B,H			; BC: The port address
04051A 4D          1283  			LD      C,L
04051B ED 68       1284  			IN      L,(C)           	;  L: Input from port BC
04051D 18 60       1285  			JR      COUNT0			; Return an 8-bit value
04051F             1286  ;
04051F CD C7 07 04 1287  GET0:			CALL    GETS			; Read the keyboard character
040523 18 0A       1288  			JR      ASC1			; And return the value
040525             1289  ;
040525 CD 30 03 04 1290  ASC:			CALL    ITEMS			; Get the string argument argument
040529 AF          1291  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052A BB          1292  			CP      E			; Is the pointer 0
04052B CA 05 06 04 1293  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04052F 2A 00 4A 04 1294  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040533 18 4A       1295  			JR      COUNT0			; An 8-bit value
040535             1296  ;
040535 CD 30 03 04 1297  LEN:			CALL    ITEMS			; Get the string argument
040539 EB          1298  			EX      DE,HL			; HL: Pointer into ACCS
04053A 18 43       1299  			JR      COUNT0			; Return L
04053C             1300  ;
04053C 2A 1A 4D 04 1301  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040540 3A 1C 4D 04 1302  			LD	A, (LOMEM+2)
040544 18 41       1303  			JR      COUNT2			; A 24-bit value
040546             1304  ;
040546 2A 20 4D 04 1305  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054A 3A 22 4D 04 1306  			LD	A, (HIMEM+2)
04054E 18 37       1307  			JR      COUNT2			; A 24-bit value
040550             1308  ;
040550 2A 14 4D 04 1309  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040554 3A 16 4D 04 1310  			LD	A, (PAGE_+2)		; A 24-bit value
040558 18 2D       1311  			JR      COUNT2
04055A             1312  ;
04055A FD 7E 00    1313  TOPV:			LD      A,(IY)			; Return the TOP system variable
04055D FD 23       1314  			INC     IY              	; Skip "P"
04055F FE 50       1315  			CP      'P'
040561 C2 97 0C 04 1316  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
040565 2A 17 4D 04 1317  			LD      HL,(TOP)
040569 3A 19 4D 04 1318  			LD	A, (TOP+2)
04056D 18 18       1319  			JR      COUNT2
04056F             1320  ;
04056F 2A 33 4D 04 1321  ERLV:			LD      HL,(ERL)		; Return the error line
040573 18 0C       1322  			JR      COUNT1			; A 16-bit value
040575             1323  ;
040575 2A 3F 4D 04 1324  ERRV:			LD      HL,(ERR)		; Return the error value
040579 18 04       1325  			JR      COUNT0			; An 8-bit value
04057B             1326  ;
04057B 2A 3D 4D 04 1327  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04057F             1328  
04057F 26 00       1329  COUNT0:			LD      H,0			; Return L
040581 D9          1330  COUNT1:			EXX				; Return HL
040582 AF          1331  			XOR     A
040583 4F          1332  			LD      C,A             	; Integer marker
040584 67          1333  			LD      H,A
040585 6F          1334  			LD      L,A
040586 C9          1335  			RET
040587 D9          1336  COUNT2:			EXX
040588 6F          1337  			LD	L,A
040589 AF          1338  			XOR	A
04058A 4F          1339  			LD	C,A			; Integer marker
04058B 67          1340  			LD	H,A
04058C C9          1341  			RET
04058D             1342  ;
04058D             1343  ;OPENIN - Open a file for reading.
04058D             1344  ;OPENOT - Open a file for writing.
04058D             1345  ;OPENUP - Open a file for reading or writing.
04058D             1346  ;Result is integer channel number (0 if error)
04058D             1347  ;
04058D AF          1348  OPENOT:			XOR     A			; Open for writing
04058E 18 06       1349  			JR	OPENIN_1
040590             1350  ;
040590 3E 02       1351  OPENUP:			LD      A,2			; Open for reading / writing
040592 18 02       1352  			JR	OPENIN_1
040594             1353  ;
040594 3E 01       1354  OPENIN:			LD      A,1			; Open for reading
040596             1355  ;
040596 F5          1356  OPENIN_1:		PUSH    AF              	; Save OPEN type
040597 CD 30 03 04 1357  			CALL    ITEMS           	; Fetch the filename
04059B 3E 0D       1358  			LD      A,CR
04059D 12          1359  			LD      (DE),A
04059E F1          1360  			POP     AF              	; Restore the OPEN type
04059F C6 FF       1361  			ADD     A,-1            	; Affect the flags
0405A1 21 00 4A 04 1362  			LD      HL,ACCS
0405A5 CD 5D 43 04 1363  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405A9 6F          1364  			LD      L,A			; L: Channel number
0405AA 18 D3       1365  			JR      COUNT0			; Return channel number to BASIC
0405AC             1366  ;
0405AC             1367  ;EXT - Return length of file.
0405AC             1368  ;PTR_EV - Return current file pointer.
0405AC             1369  ;Results are integer numeric.
0405AC             1370  ;
0405AC CD B0 18 04 1371  EXT:			CALL    CHANEL
0405B0 CD BB 43 04 1372  			CALL    GETEXT
0405B4 18 15       1373  			JR      TIME0
0405B6             1374  ;
0405B6 CD B0 18 04 1375  PTR_EV:			CALL    CHANEL
0405BA CD 8F 43 04 1376  			CALL    GETPTR
0405BE 18 0B       1377  			JR      TIME0
0405C0             1378  ;
0405C0             1379  ;TIME - Return current value of elapsed time.
0405C0             1380  ;Result is integer numeric.
0405C0             1381  ;
0405C0 FD 7E 00    1382  TIMEV:			LD      A,(IY)
0405C3 FE 24       1383  			CP      '$'
0405C5 28 0A       1384  			JR      Z,TIMEVS
0405C7 CD DC 3E 04 1385  			CALL    GETIME
0405CB D5          1386  TIME0:			PUSH    DE
0405CC D9          1387  			EXX
0405CD E1          1388  			POP     HL
0405CE AF          1389  			XOR     A
0405CF 4F          1390  			LD      C,A
0405D0 C9          1391  			RET
0405D1             1392  ;
0405D1             1393  ;TIME$ - Return date/time string.
0405D1             1394  ;Result is string
0405D1             1395  ;
0405D1 FD 23       1396  TIMEVS:			INC     IY              ;SKIP $
0405D3 CD D4 43 04 1397  			CALL    GETIMS
0405D7 3E 80       1398  			LD      A,80H           ;MARK STRING
0405D9 C9          1399  			RET
0405DA             1400  ;
0405DA             1401  ;String comparison:
0405DA             1402  ;
0405DA CD 8F 09 04 1403  SLT:			CALL    SCP
0405DE D0          1404  			RET     NC
0405DF 18 24       1405  			JR      TRUE
0405E1             1406  ;
0405E1 CD 8F 09 04 1407  SGT:			CALL    SCP
0405E5 C8          1408  			RET     Z
0405E6 D8          1409  			RET     C
0405E7 18 1C       1410  			JR      TRUE
0405E9             1411  ;
0405E9 CD 8F 09 04 1412  SGE:			CALL    SCP
0405ED D8          1413  			RET     C
0405EE 18 15       1414  			JR      TRUE
0405F0             1415  ;
0405F0 CD 8F 09 04 1416  SLE:			CALL    SCP
0405F4 28 0F       1417  			JR      Z,TRUE
0405F6 D0          1418  			RET     NC
0405F7 18 0C       1419  			JR      TRUE
0405F9             1420  ;
0405F9 CD 8F 09 04 1421  SNE:			CALL    SCP
0405FD C8          1422  			RET     Z
0405FE 18 05       1423  			JR      TRUE
040600             1424  ;
040600 CD 8F 09 04 1425  SEQ:			CALL    SCP
040604 C0          1426  			RET     NZ
040605 3E FF       1427  TRUE:			LD      A,-1
040607 D9          1428  			EXX
040608 67          1429  			LD      H,A
040609 6F          1430  			LD      L,A
04060A D9          1431  			EXX
04060B 67          1432  			LD      H,A
04060C 6F          1433  			LD      L,A
04060D 3C          1434  			INC     A
04060E 4F          1435  			LD      C,A
04060F C9          1436  			RET
040610             1437  ;
040610             1438  ;PI - Return PI (3.141592654)
040610             1439  ;Result is floating-point numeric.
040610             1440  ;
040610 3E 23       1441  PI:			LD      A,35
040612 18 44       1442  			JR      FPP1
040614             1443  ;
040614             1444  ;ABS - Absolute value
040614             1445  ;Result is numeric, variable type.
040614             1446  ;
040614 3E 10       1447  ABSV:			LD      A,16
040616 18 3A       1448  			JR      FPPN
040618             1449  ;
040618             1450  ;NOT - Complement integer.
040618             1451  ;Result is integer numeric.
040618             1452  ;
040618 3E 1A       1453  NOTK:			LD      A,26
04061A 18 36       1454  			JR      FPPN
04061C             1455  ;
04061C             1456  ;DEG - Convert radians to degrees
04061C             1457  ;Result is floating-point numeric.
04061C             1458  ;
04061C 3E 15       1459  DEG:			LD      A,21
04061E 18 32       1460  			JR      FPPN
040620             1461  ;
040620             1462  ;RAD - Convert degrees to radians
040620             1463  ;Result is floating-point numeric.
040620             1464  ;
040620 3E 1B       1465  RAD:			LD      A,27
040622 18 2E       1466  			JR      FPPN
040624             1467  ;
040624             1468  ;SGN - Return -1, 0 or +1
040624             1469  ;Result is integer numeric.
040624             1470  ;
040624 3E 1C       1471  SGN:			LD      A,28
040626 18 2A       1472  			JR      FPPN
040628             1473  ;
040628             1474  ;INT - Floor function
040628             1475  ;Result is integer numeric.
040628             1476  ;
040628 3E 17       1477  INT_:			LD      A,23
04062A 18 26       1478  			JR      FPPN
04062C             1479  ;
04062C             1480  ;SQR - square root
04062C             1481  ;Result is floating-point numeric.
04062C             1482  ;
04062C 3E 1E       1483  SQR:			LD      A,30
04062E 18 22       1484  			JR      FPPN
040630             1485  ;
040630             1486  ;TAN - Tangent function
040630             1487  ;Result is floating-point numeric.
040630             1488  ;
040630 3E 1F       1489  TAN:			LD      A,31
040632 18 1E       1490  			JR      FPPN
040634             1491  ;
040634             1492  ;COS - Cosine function
040634             1493  ;Result is floating-point numeric.
040634             1494  ;
040634 3E 14       1495  COS:			LD      A,20
040636 18 1A       1496  			JR      FPPN
040638             1497  ;
040638             1498  ;SIN - Sine function
040638             1499  ;Result is floating-point numeric.
040638             1500  ;
040638 3E 1D       1501  SIN:			LD      A,29
04063A 18 16       1502  			JR      FPPN
04063C             1503  ;
04063C             1504  ;EXP - Exponential function
04063C             1505  ;Result is floating-point numeric.
04063C             1506  ;
04063C 3E 16       1507  EXP:			LD      A,22
04063E 18 12       1508  			JR      FPPN
040640             1509  ;
040640             1510  ;LN - Natural log.
040640             1511  ;Result is floating-point numeric.
040640             1512  ;
040640 3E 18       1513  LN:			LD      A,24
040642 18 0E       1514  			JR      FPPN
040644             1515  ;
040644             1516  ;LOG - base-10 logarithm.
040644             1517  ;Result is floating-point numeric.
040644             1518  ;
040644 3E 19       1519  LOG:			LD      A,25
040646 18 0A       1520  			JR      FPPN
040648             1521  ;
040648             1522  ;ASN - Arc-sine
040648             1523  ;Result is floating-point numeric.
040648             1524  ;
040648 3E 12       1525  ASN:			LD      A,18
04064A 18 06       1526  			JR      FPPN
04064C             1527  ;
04064C             1528  ;ATN - arc-tangent
04064C             1529  ;Result is floating-point numeric.
04064C             1530  ;
04064C 3E 13       1531  ATN:			LD      A,19
04064E 18 02       1532  			JR      FPPN
040650             1533  ;
040650             1534  ;ACS - arc-cosine
040650             1535  ;Result is floating point numeric.
040650             1536  ;
040650 3E 11       1537  ACS:			LD      A,17
040652 F5          1538  FPPN:			PUSH    AF
040653 CD 1D 03 04 1539  			CALL    ITEMN
040657 F1          1540  			POP     AF
040658 CD 9A 20 04 1541  FPP1:			CALL    FPP
04065C DA 90 37 04 1542  			JP      C,ERROR_
040660 AF          1543  			XOR     A
040661 C9          1544  			RET
040662             1545  ;
040662             1546  ;SFIX - Convert to fixed-point notation
040662             1547  ;
040662 3E 26       1548  SFIX:			LD      A,38
040664 18 F2       1549  			JR      FPP1
040666             1550  ;
040666             1551  ;SFLOAT - Convert to floating-point notation
040666             1552  ;
040666 3E 27       1553  SFLOAT:			LD      A,39
040668 18 EE       1554  			JR      FPP1
04066A             1555  ;
04066A             1556  ;VAL - Return numeric value of string.
04066A             1557  ;Result is variable type numeric.
04066A             1558  ;
04066A CD 30 03 04 1559  VAL:			CALL    ITEMS
04066E AF          1560  VAL0:			XOR     A
04066F 12          1561  			LD      (DE),A
040670 DD 21 00 4A 1562  			LD      IX,ACCS
       04          
040675 3E 24       1563  			LD      A,36
040677 18 DF       1564  			JR      FPP1
040679             1565  ;
040679             1566  ;EVAL - Pass string to expression evaluator.
040679             1567  ;Result is variable type (numeric or string).
040679             1568  ;
040679 CD 30 03 04 1569  EVAL_:			CALL    ITEMS
04067D 3E 0D       1570  			LD      A,CR
04067F 12          1571  			LD      (DE),A
040680 FD E5       1572  			PUSH    IY
040682 11 00 4A 04 1573  			LD      DE,ACCS
040686 FD 21 00 4A 1574  			LD      IY,ACCS
       04          
04068B 0E 00       1575  			LD      C,0
04068D CD CF 3C 04 1576  			CALL    LEXAN2          ;TOKENISE
040691 12          1577  			LD      (DE),A
040692 13          1578  			INC     DE
040693 AF          1579  			XOR     A
040694 CD B4 09 04 1580  			CALL    PUSHS           ;PUT ON STACK
040698 FD 21 03 00 1581  			LD      IY,SIZEW	;WAS 2
       00          
04069D FD 39       1582  			ADD     IY,SP
04069F CD C7 01 04 1583  			CALL    EXPR
0406A3 FD E1       1584  			POP     IY
0406A5 FD 39       1585  			ADD     IY,SP
0406A7 FD F9       1586  			LD      SP,IY           ;ADJUST STACK POINTER
0406A9 FD E1       1587  			POP     IY
0406AB 08          1588  			EX      AF,AF'
0406AC C9          1589  			RET
0406AD             1590  ;
0406AD             1591  ;RND - Random number function.
0406AD             1592  ; RND gives random integer 0-&FFFFFFFF
0406AD             1593  ; RND(-n) seeds random number & returns -n.
0406AD             1594  ; RND(0) returns last value in RND(1) form.
0406AD             1595  ; RND(1) returns floating-point 0-0.99999999.
0406AD             1596  ; RND(n) returns random integer 1-n.
0406AD             1597  ;
0406AD DD 21 38 4D 1598  RND:			LD      IX,RANDOM
       04          
0406B2 CD 70 0A 04 1599  			CALL    NXT
0406B6 FE 28       1600  			CP      '('
0406B8 28 20       1601  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BA CD 1F 04 04 1602  			CALL    LOAD5
0406BE CB 19       1603  RND1:			RR      C
0406C0 06 20       1604  			LD      B,32
0406C2 D9          1605  RND2:			EXX                     ;CALCULATE NEXT
0406C3 52 ED 6A    1606  			ADC.S   HL,HL
0406C6 D9          1607  			EXX
0406C7 52 ED 6A    1608  			ADC.S   HL,HL
0406CA CB 5D       1609  			BIT     3,L
0406CC 28 01       1610  			JR      Z,RND3
0406CE 3F          1611  			CCF
0406CF 10 F1       1612  RND3:			DJNZ    RND2
0406D1 CB 11       1613  RND4:			RL      C               ;SAVE CARRY
0406D3 CD 05 16 04 1614  			CALL    STORE5          ;STORE NEW NUMBER
0406D7 AF          1615  			XOR     A
0406D8 4F          1616  			LD      C,A
0406D9 C9          1617  			RET
0406DA CD 25 03 04 1618  RND5:			CALL    ITEMI
0406DE DD 21 38 4D 1619  			LD      IX,RANDOM
       04          
0406E3 CB 7C       1620  			BIT     7,H             ;NEGATIVE?
0406E5 37          1621  			SCF
0406E6 20 E9       1622  			JR      NZ,RND4         ;SEED
0406E8 CD DF 08 04 1623  			CALL    TEST
0406EC F5          1624  			PUSH    AF
0406ED CD D7 08 04 1625  			CALL    SWAP
0406F1 D9          1626  			EXX
0406F2 CD 1F 04 04 1627  			CALL    LOAD5
0406F6 C4 BE 06 04 1628  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FA D9          1629  			EXX                     ;SCRAMBLE (CARE!)
0406FB 0E 7F       1630  			LD      C,7FH
0406FD CB 7C       1631  RND6:			BIT     7,H             ;FLOAT
0406FF 20 0A       1632  			JR      NZ,RND7
040701 D9          1633  			EXX
040702 52 29       1634  			ADD.S   HL,HL
040704 D9          1635  			EXX
040705 52 ED 6A    1636  			ADC.S   HL,HL
040708 0D          1637  			DEC     C
040709 20 F2       1638  			JR      NZ,RND6
04070B CB BC       1639  RND7:			RES     7,H             ;POSITIVE 0-0.999999
04070D F1          1640  			POP     AF
04070E C8          1641  			RET     Z               ;ZERO ARGUMENT
04070F D9          1642  			EXX
040710 7B          1643  			LD      A,E
040711 3D          1644  			DEC     A
040712 B2          1645  			OR      D
040713 D9          1646  			EXX
040714 B3          1647  			OR      E
040715 B2          1648  			OR      D
040716 C8          1649  			RET     Z               ;ARGUMENT=1
040717 06 00       1650  			LD      B,0             ;INTEGER MARKER
040719 3E 0A       1651  			LD      A,10
04071B CD 9A 20 04 1652  			CALL    FPP             ;MULTIPLY
04071F DA 90 37 04 1653  			JP      C,ERROR_
040723 CD 62 06 04 1654  			CALL    SFIX
040727 C3 BB 03 04 1655  			JP      ADD1
04072B             1656  ;
04072B             1657  ; INSTR - String search.
04072B             1658  ; Result is integer numeric.
04072B             1659  ;
04072B CD 1E 0A 04 1660  INSTR:			CALL    EXPRSC			; Get the first string expression
04072F CD B4 09 04 1661  			CALL    PUSHS           	; Push the string onto the stack
040733 CD 15 03 04 1662  			CALL    EXPRS           	; Get the second string expression
040737 C1          1663  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
040738 21 00 00 00 1664  			LD      HL,0
04073C 39          1665  			ADD     HL,SP           	; HL: Pointer to main string
04073D C5          1666  			PUSH    BC              	;  C: Main string length
04073E 43          1667  			LD      B,E             	;  B: Sub-string length
04073F CD 70 0A 04 1668  			CALL    NXT			; Skip whitespace
040743 FE 2C       1669  			CP      ','			; Check if there is a comma for the third parameter
040745 3E 00       1670  			LD      A,0			;  A: Default start position in string
040747 20 1A       1671  			JR      NZ,INSTR1		; No, so skip the next bit
040749 FD 23       1672  			INC     IY              	; Skip the comma
04074B C5          1673  			PUSH    BC              	; Save the lengths
04074C E5          1674  			PUSH    HL              	; Save the pointer to the main string
04074D CD B4 09 04 1675  			CALL    PUSHS			; Push the string onto the stack
040751 CD 0A 03 04 1676  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040755 C1          1677  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040756 CD DE 09 04 1678  			CALL    POPS			; Pop the string off the stack
04075A E1          1679  			POP     HL              	; Restore the pointer to the main string
04075B C1          1680  			POP     BC              	; Restore the lengths
04075C D9          1681  			EXX
04075D 7D          1682  			LD      A,L			; A: The start position in the  string
04075E D9          1683  			EXX
04075F B7          1684  			OR      A			; Set the flags
040760 28 01       1685  			JR      Z,INSTR1		; If it is zero, then skip
040762 3D          1686  			DEC     A
040763 11 00 4A 04 1687  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040767 CD 85 07 04 1688  			CALL    SEARCH			; Do the search
04076B D1          1689  			POP     DE
04076C 28 03       1690  			JR      Z,INSTR2        	; NB: Carry cleared
04076E ED 62       1691  			SBC     HL,HL
040770 39          1692  			ADD     HL,SP
040771 ED 72       1693  INSTR2:			SBC     HL,SP
040773 EB          1694  			EX      DE,HL
040774 7D          1695  			LD	A,L
040775 21 00 00 00 1696  			LD      HL,0
040779 6F          1697  			LD	L,A
04077A 39          1698  			ADD     HL,SP
04077B F9          1699  			LD      SP,HL
04077C EB          1700  			EX      DE,HL
04077D CD 2F 0A 04 1701  			CALL    BRAKET			; Check for closing bracket
040781 C3 81 05 04 1702  			JP      COUNT1			; Return a numeric integer
040785             1703  ;
040785             1704  ; SEARCH - Search string for sub-string
040785             1705  ;    Inputs: Main string at HL length C
040785             1706  ;            Sub-string  at DE length B
040785             1707  ;            Starting offset A
040785             1708  ;   Outputs: NZ - not found
040785             1709  ;            Z - found at location HL-1
040785             1710  ;            Carry always cleared
040785             1711  ;
040785 C5          1712  SEARCH:			PUSH    BC			; Add the starting offset to HL
040786 01 00 00 00 1713  			LD      BC,0
04078A 4F          1714  			LD      C,A
04078B 09          1715  			ADD     HL,BC           	; New start address
04078C C1          1716  			POP     BC
04078D 91          1717  			SUB     C			; If the starting offset > main string length, then do nothing
04078E 30 2C       1718  			JR      NC,SRCH4
040790 ED 44       1719  			NEG
040792 4F          1720  			LD      C,A             	; Remaining length
040793             1721  ;
040793 C5          1722  SRCH1:			PUSH    BC
040794 79          1723  			LD	A,C
040795 01 00 00 00 1724  			LD	BC,0
040799 4F          1725  			LD	C,A
04079A 1A          1726  			LD      A,(DE)
04079B ED B1       1727  			CPIR                    	; Find the first character
04079D 79          1728  			LD      A,C
04079E C1          1729  			POP     BC
04079F 20 1B       1730  			JR      NZ,SRCH4
0407A1 4F          1731  			LD      C,A
0407A2             1732  ;
0407A2             1733  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A2             1734  ;
0407A2 05          1735  			DEC     B			; Bug fix
0407A3 B8          1736  			CP      B			; Bug fix
0407A4 04          1737  			INC     B			; Bug fix
0407A5 38 15       1738  			JR      C,SRCH4			; Bug fix
0407A7             1739  ;
0407A7 C5          1740  			PUSH    BC
0407A8 D5          1741  			PUSH    DE
0407A9 E5          1742  			PUSH    HL
0407AA 05          1743  			DEC     B
0407AB 28 08       1744  			JR      Z,SRCH3         	; Found!
0407AD 13          1745  SRCH2:			INC     DE
0407AE 1A          1746  			LD      A,(DE)
0407AF BE          1747  			CP      (HL)
0407B0 20 03       1748  			JR      NZ,SRCH3
0407B2 23          1749  			INC     HL
0407B3 10 F8       1750  			DJNZ    SRCH2
0407B5 E1          1751  SRCH3:			POP     HL
0407B6 D1          1752  			POP     DE
0407B7 C1          1753  			POP     BC
0407B8 20 D9       1754  			JR      NZ,SRCH1
0407BA AF          1755  			XOR     A               	; Flags: Z, NC
0407BB C9          1756  			RET                     	; Found
0407BC             1757  ;
0407BC F6 FF       1758  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407BE C9          1759  			RET                     	; Not found
0407BF             1760  ;
0407BF             1761  ;CHRS - Return character with given ASCII value.
0407BF             1762  ;Result is string.
0407BF             1763  ;
0407BF CD 25 03 04 1764  CHRS:			CALL    ITEMI
0407C3 D9          1765  			EXX
0407C4 7D          1766  			LD      A,L
0407C5 18 0E       1767  			JR      GET1
0407C7             1768  ;
0407C7             1769  ;GETS - Return key pressed as stringor character at position (X,Y).
0407C7             1770  ;Result is string.
0407C7             1771  ;
0407C7 CD 70 0A 04 1772  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407CB FE 28       1773  			CP	'('
0407CD CA 32 44 04 1774  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D1 CD 59 3F 04 1775  			CALL    OSRDCH
0407D5 37          1776  GET1:			SCF
0407D6 18 09       1777  			JR      INKEY1
0407D8             1778  ;
0407D8             1779  ; INKEYS - Wait up to n centiseconds for keypress.
0407D8             1780  ;          Return key pressed as string or null
0407D8             1781  ;          string if time elapsed.
0407D8             1782  ; Result is string.
0407D8             1783  ;
0407D8 CD 25 03 04 1784  INKEYS:			CALL    ITEMI			; Fetch the argument
0407DC D9          1785  			EXX
0407DD CD 62 3F 04 1786  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E1 11 00 4A 04 1787  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E5 12          1788  			LD      (DE),A
0407E6 3E 80       1789  			LD      A,80H
0407E8 D0          1790  			RET     NC
0407E9 1C          1791  			INC     E
0407EA C9          1792  			RET
0407EB             1793  ;
0407EB             1794  ; INKEYM - Check immediately whether a given key is being pressed
0407EB             1795  ; Result is integer numeric
0407EB             1796  ;
0407EB             1797  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407EB 3E 1E       0001M 			LD	A, function
0407ED 49 CF       0002M 			RST.LIS	08h
0407EF 23          1798  			INC	HL			; Index from 0
0407F0 7D          1799  			LD	A, L			; Negate the LSB of the answer
0407F1 ED 44       1800  			NEG
0407F3 4F          1801  			LD	C, A			;  E: The positive keycode value
0407F4 3E 01       1802  			LD	A, 1			; Throw an "Out of range" error
0407F6 FA 90 37 04 1803  			JP	M, ERROR_		; if the argument < - 128
0407FA             1804  ;
0407FA 21 1D 08 04 1805  			LD	HL, BITLOOKUP		; HL: The bit lookup table
0407FE 11 00 00 00 1806  			LD	DE, 0
040802 79          1807  			LD	A, C
040803 E6 07       1808  			AND	00000111b		; Just need the first three bits
040805 5F          1809  			LD	E, A			; DE: The bit number
040806 19          1810  			ADD	HL, DE
040807 46          1811  			LD	B, (HL)			;  B: The mask
040808             1812  ;
040808 79          1813  			LD	A, C			; Fetch the keycode again
040809 E6 78       1814  			AND	01111000b		; And divide by 8
04080B 0F          1815  			RRCA
04080C 0F          1816  			RRCA
04080D 0F          1817  			RRCA
04080E 5F          1818  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04080F DD 19       1819  			ADD	IX, DE			; IX: The address
040811 78          1820  			LD	A, B			;  B: The mask
040812 DD A6 00    1821  			AND	(IX+0)			; Check whether the bit is set
040815 CA 93 09 04 1822  			JP	Z, ZERO			; No, so return 0
040819 C3 05 06 04 1823  			JP	TRUE			; Otherwise return -1
04081D             1824  ;
04081D             1825  ; A bit lookup table
04081D             1826  ;
04081D 01 02 04 08 1827  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040821 10 20 40 80 1828  			DB	10h, 20h, 40h, 80h
040825             1829  ;
040825             1830  ; MID$ - Return sub-string.
040825             1831  ; Result is string.
040825             1832  ;
040825 CD 1E 0A 04 1833  MIDS:			CALL    EXPRSC			; Get the first string expression
040829 CD B4 09 04 1834  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082D CD 0A 03 04 1835  			CALL    EXPRI			; Get the second expression
040831 C1          1836  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040832 CD DE 09 04 1837  			CALL    POPS			; Pop the string back off the stack to the string accumulator
040836 D9          1838  			EXX
040837 7D          1839  			LD      A,L			; A: The start index
040838 D9          1840  			EXX
040839 B7          1841  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083A 28 0E       1842  			JR      Z,MIDS1
04083C 3D          1843  			DEC     A
04083D 6F          1844  			LD      L,A			; L: The start index - 1
04083E 93          1845  			SUB     E			; Subtract from the string length
04083F 1E 00       1846  			LD      E,0			; Preemptively set the string length to 0
040841 30 07       1847  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040843 ED 44       1848  			NEG				; Negate the answer and
040845 4F          1849  			LD      C,A			; C: Number of bytes to copy
040846 CD 89 08 04 1850  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084A CD 70 0A 04 1851  MIDS1:			CALL    NXT			; Skip whitespace
04084E FE 2C       1852  			CP      ','			; Check for a comma
040850 FD 23       1853  			INC     IY			; Advance to the next character in the BASIC line
040852 28 0D       1854  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040854 FD 2B       1855  			DEC     IY			; Restore the BASIC program pointer
040856 CD 2F 0A 04 1856  			CALL    BRAKET			; Check for a bracket
04085A 3E 80       1857  			LD      A,80H			; String marker
04085C C9          1858  			RET
04085D             1859  ;
04085D             1860  ; LEFT$ - Return left part of string.
04085D             1861  ; Carry cleared if entire string returned.
04085D             1862  ; Result is string.
04085D             1863  ;
04085D CD 1E 0A 04 1864  LEFTS:			CALL    EXPRSC			; Get the first string expression
040861 CD B4 09 04 1865  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040865 CD 0A 03 04 1866  			CALL    EXPRI			; Get the second expression
040869 C1          1867  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086A CD DE 09 04 1868  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04086E CD 2F 0A 04 1869  			CALL    BRAKET			; Check for closing bracket
040872 D9          1870  			EXX
040873 7D          1871  			LD      A,L			; L: The second parameter
040874 D9          1872  			EXX
040875 BB          1873  			CP      E			; Compare with the string length
040876 30 02       1874  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
040878 6B          1875  			LD      L,E             	; For RIGHTS, no effect in LEFTS
040879 5F          1876  LEFT2:			LD      E,A			; E: The new length of string
04087A 3E 80       1877  LEFT3:			LD      A,80H           	; String marker
04087C C9          1878  			RET
04087D             1879  ;
04087D             1880  ; RIGHT$ - Return right part of string.
04087D             1881  ; Result is string.
04087D             1882  ;
04087D CD 5D 08 04 1883  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040881 D0          1884  			RET     NC			; Do nothing if the second parameter is >= string length
040882 1C          1885  			INC     E			; Check for a zero length string
040883 1D          1886  			DEC     E
040884 C8          1887  			RET     Z			; Yes, so do nothing
040885 4B          1888  			LD      C,E			;  C: Number of bytes to copy
040886 7D          1889  			LD      A,L
040887 93          1890  			SUB     E
040888 6F          1891  			LD      L,A			;  L: Index into the string
040889 79          1892  RIGHT1:			LD	A,C
04088A 01 00 00 00 1893  			LD	BC,0
04088E 4F          1894  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04088F 7D          1895  			LD	A,L
040890 21 00 4A 04 1896  			LD	HL,ACCS
040894 6F          1897  			LD	L,A			; HL: Source (in ACCS)
040895 11 00 4A 04 1898  			LD      DE,ACCS			; DE: Destination (start of ACCS)
040899 ED B0       1899  			LDIR                    	; Copy
04089B 3E 80       1900  			LD      A,80H			; String marker
04089D C9          1901  			RET
04089E             1902  ;
04089E             1903  ; STRINGS - Return n concatenations of a string.
04089E             1904  ; Result is string.
04089E             1905  ;
04089E CD 0A 03 04 1906  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A2 CD 22 0A 04 1907  			CALL    COMMA			; Check for comma
0408A6 D9          1908  			EXX
0408A7 7D          1909  			LD      A,L			; L: Number of iterations of string
0408A8 D9          1910  			EXX
0408A9 F5          1911  			PUSH    AF
0408AA CD 15 03 04 1912  			CALL    EXPRS			; Get the string
0408AE CD 2F 0A 04 1913  			CALL    BRAKET			; Check for closing bracket
0408B2 F1          1914  			POP     AF			; A: Number of iterations of string
0408B3 B7          1915  			OR      A			; Set flags
0408B4 28 C3       1916  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408B6 3D          1917  			DEC     A
0408B7 4F          1918  			LD      C,A			; C: Loop counter
0408B8 3E 80       1919  			LD      A,80H			; String marker
0408BA C8          1920  			RET     Z
0408BB 1C          1921  			INC     E			; Check for empty string
0408BC 1D          1922  			DEC     E
0408BD C8          1923  			RET     Z              		; And return
0408BE 43          1924  			LD      B,E			; B: String length tally
0408BF 21 00 4A 04 1925  			LD	HL,ACCS
0408C3 C5          1926  STRIN1:			PUSH    BC
0408C4 7E          1927  STRIN2:			LD      A,(HL)
0408C5 23          1928  			INC     HL
0408C6 12          1929  			LD      (DE),A
0408C7 1C          1930  			INC     E
0408C8 3E 13       1931  			LD      A,19
0408CA CA 90 37 04 1932  			JP      Z,ERROR_         	; Throw a "String too long" error
0408CE 10 F4       1933  			DJNZ    STRIN2
0408D0 C1          1934  			POP     BC
0408D1 0D          1935  			DEC     C
0408D2 20 EF       1936  			JR      NZ,STRIN1
0408D4 3E 80       1937  			LD      A,80H
0408D6 C9          1938  			RET
0408D7             1939  ;
0408D7             1940  ;SUBROUTINES
0408D7             1941  ;
0408D7             1942  ;SWAP - Swap arguments
0408D7             1943  ;Exchanges DE,HL D'E',H'L' and B,C
0408D7             1944  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408D7             1945  ;
0408D7 79          1946  SWAP:			LD      A,C
0408D8 48          1947  			LD      C,B
0408D9 47          1948  			LD      B,A
0408DA EB          1949  			EX      DE,HL
0408DB D9          1950  			EXX
0408DC EB          1951  			EX      DE,HL
0408DD D9          1952  			EXX
0408DE C9          1953  			RET
0408DF             1954  ;
0408DF             1955  ;TEST - Test HLH'L' for zero
0408DF             1956  ;Outputs: Z-flag set & A=0 if zero
0408DF             1957  ;Destroys: A,F
0408DF             1958  ;
0408DF 7C          1959  TEST:			LD      A,H
0408E0 B5          1960  			OR      L
0408E1 D9          1961  			EXX
0408E2 B4          1962  			OR      H
0408E3 B5          1963  			OR      L
0408E4 D9          1964  			EXX
0408E5 C9          1965  			RET
0408E6             1966  ;
0408E6             1967  ;DECODE - Decode line number in pseudo-binary.
0408E6             1968  ;   Inputs: IY = Text pointer.
0408E6             1969  ;   Outputs: HL=0, H'L'=line number, C=0.
0408E6             1970  ;   Destroys: A,C,H,L,H',L',IY,F
0408E6             1971  ;
0408E6 D9          1972  DECODE:			EXX
0408E7 21 00 00 00 1973  			LD	HL, 0
0408EB FD 7E 00    1974  			LD      A,(IY)
0408EE FD 23       1975  			INC     IY
0408F0 17          1976  			RLA
0408F1 17          1977  			RLA
0408F2 67          1978  			LD      H,A
0408F3 E6 C0       1979  			AND     0C0H
0408F5 FD AE 00    1980  			XOR     (IY)
0408F8 FD 23       1981  			INC     IY
0408FA 6F          1982  			LD      L,A
0408FB 7C          1983  			LD      A,H
0408FC 17          1984  			RLA
0408FD 17          1985  			RLA
0408FE E6 C0       1986  			AND     0C0H
040900 FD AE 00    1987  			XOR     (IY)
040903 FD 23       1988  			INC     IY
040905 67          1989  			LD      H,A
040906 D9          1990  			EXX
040907             1991  ;			XOR     A
040907             1992  ;			LD      C,A
040907             1993  ;			LD      H,A
040907             1994  ;			LD      L,A
040907 21 00 00 00 1995  			LD	HL, 0
04090B 4D          1996  			LD	C, L
04090C C9          1997  			RET
04090D             1998  ;
04090D             1999  ;HEXSTR - convert numeric value to HEX string.
04090D             2000  ;   Inputs: HLH'L'C = integer or floating-point number
04090D             2001  ;  Outputs: String in string accumulator.
04090D             2002  ;           E = string length.  D = ACCS/256
04090D             2003  ;
04090D FD 23       2004  HEXSTS:			INC     IY              ;SKIP TILDE
04090F CD 1D 03 04 2005  			CALL    ITEMN
040913 CD 1A 09 04 2006  			CALL    HEXSTR
040917 3E 80       2007  			LD      A,80H
040919 C9          2008  			RET
04091A             2009  ;
04091A CD 62 06 04 2010  HEXSTR:			CALL    SFIX
04091E 01 08 00 00 2011  			LD      BC,8
040922 11 00 4A 04 2012  			LD      DE,ACCS
040926 C5          2013  HEXST1:			PUSH    BC
040927 06 04       2014  			LD      B,4
040929 AF          2015  			XOR     A
04092A D9          2016  HEXST2:			EXX
04092B 52 29       2017  			ADD.S	HL,HL
04092D D9          2018  			EXX
04092E 52 ED 6A    2019  			ADC.S	HL,HL
040931 17          2020  			RLA
040932 10 F6       2021  			DJNZ    HEXST2
040934 C1          2022  			POP     BC
040935 0D          2023  			DEC     C
040936 F8          2024  			RET     M
040937 28 06       2025  			JR      Z,HEXST3
040939 B7          2026  			OR      A
04093A 20 03       2027  			JR      NZ,HEXST3
04093C B8          2028  			CP      B
04093D 28 E7       2029  			JR      Z,HEXST1
04093F C6 90       2030  HEXST3:			ADD     A,90H
040941 27          2031  			DAA
040942 CE 40       2032  			ADC     A,40H
040944 27          2033  			DAA
040945 12          2034  			LD      (DE),A
040946 13          2035  			INC     DE
040947 47          2036  			LD      B,A
040948 18 DC       2037  			JR      HEXST1
04094A             2038  ;
04094A             2039  ;Function STR - convert numeric value to ASCII string.
04094A             2040  ;   Inputs: HLH'L'C = integer or floating-point number.
04094A             2041  ;  Outputs: String in string accumulator.
04094A             2042  ;           E = length, D = ACCS/256
04094A             2043  ;           A = 80H (type=string)
04094A             2044  ;
04094A             2045  ;First normalise for decimal output:
04094A             2046  ;
04094A CD 70 0A 04 2047  STRS:			CALL    NXT
04094E FE 7E       2048  			CP      '~'
040950 28 BB       2049  			JR      Z,HEXSTS
040952 CD 1D 03 04 2050  			CALL    ITEMN
040956 DD 21 00 4C 2051  			LD      IX,STAVAR
       04          
04095B DD 7E 03    2052  			LD      A,(IX+3)
04095E B7          2053  			OR      A
04095F DD 21 8C 09 2054  			LD      IX,G9-1         ;G9 FORMAT
       04          
040964 28 05       2055  			JR      Z,STR0
040966 DD 21 00 4C 2056  STR:			LD      IX,STAVAR
       04          
04096B 11 00 4A 04 2057  STR0:			LD      DE,ACCS
04096F 3E 25       2058  			LD      A,37
040971 CD 9A 20 04 2059  			CALL    FPP
040975 DA 90 37 04 2060  			JP      C,ERROR_
040979 DD CB 02 46 2061  			BIT     0,(IX+2)
04097D 3E 80       2062  STR1:			LD      A,80H           ;STRING MARKER
04097F C8          2063  			RET     Z
040980 79          2064  			LD      A,C
040981 C6 04       2065  			ADD     A,4
040983 BB          2066  STR2:			CP      E
040984 28 F7       2067  			JR      Z,STR1
040986 EB          2068  			EX      DE,HL
040987 36 20       2069  			LD      (HL),' '        ;TRAILING SPACE
040989 23          2070  			INC     HL
04098A EB          2071  			EX      DE,HL
04098B 18 F6       2072  			JR      STR2
04098D             2073  ;
04098D 09 00       2074  G9:			DW    9
04098F             2075  ;
04098F             2076  ;STRING COMPARE
04098F             2077  ;Compare string (DE) length B with string (HL) length C.
04098F             2078  ;Result preset to false.
04098F             2079  ;
04098F CD 9D 09 04 2080  SCP:			CALL	SCP0
040993             2081  ;
040993 3E 00       2082  ZERO:			LD      A,0
040995 D9          2083  			EXX
040996 67          2084  			LD      H,A
040997 6F          2085  			LD      L,A
040998 D9          2086  			EXX
040999 67          2087  			LD      H,A
04099A 6F          2088  			LD      L,A
04099B 4F          2089  			LD      C,A
04099C C9          2090  			RET
04099D             2091  ;
04099D 04          2092  SCP0:			INC     B
04099E 0C          2093  			INC     C
04099F 05          2094  SCP1:			DEC     B
0409A0 28 0A       2095  			JR      Z,SCP2
0409A2 0D          2096  			DEC     C
0409A3 28 0C       2097  			JR      Z,SCP3
0409A5 1A          2098  			LD      A,(DE)
0409A6 BE          2099  			CP      (HL)
0409A7 C0          2100  			RET     NZ
0409A8 13          2101  			INC     DE
0409A9 23          2102  			INC     HL
0409AA 18 F3       2103  			JR      SCP1
0409AC B7          2104  SCP2:			OR      A
0409AD 0D          2105  			DEC     C
0409AE C8          2106  			RET     Z
0409AF 37          2107  			SCF
0409B0 C9          2108  			RET
0409B1 B7          2109  SCP3:			OR      A
0409B2 0C          2110  			INC     C
0409B3 C9          2111  			RET
0409B4             2112  ;
0409B4             2113  ; PUSHS - SAVE STRING ON STACK.
0409B4             2114  ;     Inputs: String in string accumulator.
0409B4             2115  ;             E = string length.
0409B4             2116  ;             A - saved on stack.
0409B4             2117  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B4             2118  ;
0409B4 CD 79 16 04 2119  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409B8 DD E1       2120  			POP     IX              	; IX: Return address
0409BA B7          2121  			OR      A               	; Clear the carry flag
0409BB 01 00 00 00 2122  			LD	BC,0			; BC: Length of the string
0409BF 4B          2123  			LD	C,E
0409C0 21 00 4A 04 2124  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C4 11 00 4A 04 2125  			LD	DE,ACCS
0409C8 59          2126  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409C9 ED 52       2127  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CB 39          2128  			ADD     HL,SP			; Grow the stack
0409CC F9          2129  			LD      SP,HL
0409CD 57          2130  			LD      D,A			;  D: This needs to be set to A for some functions
0409CE             2131  ; BEGIN MISSING FROM BINARY
0409CE             2132  			; LD	B,A			; Stack A and C (the string length)
0409CE             2133  			; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409CE             2134  			; LD	B,0			; Reset B to 0 for the LDIR in this function
0409CE             2135  ; END MISSING FROM BINARY
0409CE D5          2136  			PUSH 	DE ; ADDED FROM BINARY
0409CF 28 0B       2137  			JR      Z,PUSHS1        	; Is it zero length?
0409D1 11 00 4A 04 2138  			LD      DE,ACCS			; DE: Destination
0409D5 EB          2139  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409D6 ED B0       2140  			LDIR	                    	; Copy to stack
0409D8 CD 79 16 04 2141  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409DC DD E9       2142  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409DE             2143  ;
0409DE             2144  ; POPS - RESTORE STRING FROM STACK.
0409DE             2145  ;     Inputs: C = string length.
0409DE             2146  ;    Outputs: String in string accumulator.
0409DE             2147  ;             E = string length.
0409DE             2148  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409DE             2149  ;
0409DE DD E1       2150  POPS:			POP     IX              	; IX: Return address
0409E0 69          2151  			LD	L,C			; Temporarily store string length in L
0409E1 01 00 00 00 2152  			LD	BC,0
0409E5 4D          2153  			LD	C,L			; BC: Number of bytes to copy
0409E6 21 00 00 00 2154  			LD      HL,0			; HL: 0
0409EA 39          2155  			ADD     HL,SP			; HL: Stack address
0409EB 11 00 4A 04 2156  			LD      DE,ACCS			; DE: Destination
0409EF 0C          2157  			INC     C			; Quick check to see if this is a zero length string
0409F0 0D          2158  			DEC     C
0409F1 28 02       2159  			JR      Z,POPS1         	; Yes it is, so skip
0409F3 ED B0       2160  			LDIR                    	; No, so copy from the stack
0409F5 F9          2161  POPS1:			LD      SP,HL			; Shrink the stack
0409F6 DD E9       2162  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F8             2163  ;
0409F8 FD 7E 00    2164  HEXDIG:			LD      A,(IY)
0409FB FE 30       2165  			CP      '0'
0409FD D8          2166  			RET     C
0409FE FE 3A       2167  			CP      '9'+1
040A00 3F          2168  			CCF
040A01 D0          2169  			RET     NC
040A02 FE 41       2170  			CP      'A'
040A04 D8          2171  			RET     C
040A05 D6 37       2172  			SUB     'A'-10
040A07 FE 10       2173  			CP      16
040A09 3F          2174  			CCF
040A0A C9          2175  			RET
040A0B             2176  ;
040A0B FD 7E 00    2177  BINDIG:			LD	A,(IY)
040A0E FE 30       2178  			CP	'0'
040A10 D8          2179  			RET	C
040A11 FE 32       2180  			CP	'1'+1
040A13 3F          2181  			CCF
040A14 C9          2182  			RET
040A15             2183  ;
040A15 FE 3E       2184  RELOP?:			CP      '>'
040A17 D0          2185  			RET     NC
040A18 FE 3D       2186  			CP      '='
040A1A D0          2187  			RET     NC
040A1B FE 3C       2188  			CP      '<'
040A1D C9          2189  			RET
040A1E             2190  ;
040A1E CD 15 03 04 2191  EXPRSC:			CALL    EXPRS
040A22 CD 70 0A 04 2192  COMMA:			CALL    NXT
040A26 FD 23       2193  			INC     IY
040A28 FE 2C       2194  			CP      ','
040A2A C8          2195  			RET     Z
040A2B 3E 05       2196  			LD      A,5
040A2D 18 0B       2197  			JR      ERROR1_EV          ;"Missing ,"
040A2F             2198  ;
040A2F CD 70 0A 04 2199  BRAKET:			CALL    NXT
040A33 FD 23       2200  			INC     IY
040A35 FE 29       2201  			CP      ')'
040A37 C8          2202  			RET     Z
040A38 3E 1B       2203  			LD      A,27
040A3A C3 90 37 04 2204  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A3E             2205  ;
040A3E FD 23       2206  SAVE_EV:			INC     IY
040A40 08          2207  SAVE1:			EX      AF,AF'
040A41 FA 36 03 04 2208  			JP      M,TYPE_EV_
040A45 08          2209  			EX      AF,AF'
040A46 E3          2210  			EX      (SP),HL
040A47 D9          2211  			EXX
040A48 E5          2212  			PUSH    HL
040A49 D9          2213  			EXX
040A4A F5          2214  			PUSH    AF
040A4B C5          2215  			PUSH    BC
040A4C E9          2216  			JP      (HL)
040A4D             2217  ;
040A4D 08          2218  DOIT:			EX      AF,AF'
040A4E FA 36 03 04 2219  			JP      M,TYPE_EV_
040A52 D9          2220  			EXX
040A53 C1          2221  			POP     BC              ;RETURN ADDRESS
040A54 D9          2222  			EXX
040A55 79          2223  			LD      A,C
040A56 C1          2224  			POP     BC
040A57 47          2225  			LD      B,A
040A58 F1          2226  			POP     AF              ;OPERATOR
040A59 D9          2227  			EXX
040A5A EB          2228  			EX      DE,HL
040A5B E1          2229  			POP     HL
040A5C D9          2230  			EXX
040A5D EB          2231  			EX      DE,HL
040A5E E1          2232  			POP     HL
040A5F D9          2233  			EXX
040A60 C5          2234  			PUSH    BC
040A61 D9          2235  			EXX
040A62 E6 0F       2236  			AND     0FH
040A64 CD 9A 20 04 2237  			CALL    FPP
040A68 38 D0       2238  			JR      C,ERROR1_EV
040A6A AF          2239  			XOR     A
040A6B 08          2240  			EX      AF,AF'          ;TYPE
040A6C FD 7E 00    2241  			LD      A,(IY)
040A6F C9          2242  			RET
040A70             2243  ;
040A70             2244  ; Skip spaces
040A70             2245  ; - IY: String pointer
040A70             2246  ; Returns:
040A70             2247  ;  - A: The non-space character found
040A70             2248  ; - IY: Points to the character before that
040A70             2249  ;
040A70 FD 7E 00    2250  NXT:			LD      A,(IY)			; Fetch the character
040A73 FE 20       2251  			CP      ' '			; If it is space, then return
040A75 C0          2252  			RET     NZ
040A76 FD 23       2253  			INC     IY			; Increment the pointer and
040A78 C3 70 0A 04 2254  			JP      NXT			; Loop
040A7C             2255  ;
040A7C E5          2256  DISPT2:			PUSH    HL
040A7D 21 B5 01 04 2257  			LD      HL,SOPTBL
040A81 18 07       2258  			JR      DISPT0
040A83             2259  ;
040A83 E5          2260  DISPAT:			PUSH    HL
040A84 D6 8D       2261  			SUB     FUNTOK
040A86 21 0A 01 04 2262  			LD      HL,FUNTBL
040A8A C5          2263  DISPT0:			PUSH    BC
040A8B             2264  
040A8B 01 03 00 00 2265  			LD	BC, 3
040A8F 47          2266  			LD	B, A
040A90 ED 4C       2267  			MLT	BC
040A92 09          2268  			ADD	HL, BC
040A93 ED 27       2269  			LD	HL, (HL)
040A95             2270  
040A95             2271  ;			ADD     A,A
040A95             2272  ;			LD      C,A
040A95             2273  ;			LD      B,0
040A95             2274  ;			ADD     HL,BC
040A95             2275  ;			LD      A,(HL)
040A95             2276  ;			INC     HL
040A95             2277  ;			LD      H,(HL)
040A95             2278  ;			LD      L,A
040A95             2279  
040A95 C1          2280  			POP     BC
040A96 E3          2281  			EX      (SP),HL
040A97 C9          2282  			RET                     ;OFF TO ROUTINE
040A98             2283  
040A98             2284  ; --- End eval.asm ---
040A98             2285  
040A98             2286  ; --- Begin exec.asm ---
040A98             2287  ;
040A98             2288  ; Title:	BBC Basic Interpreter - Z80 version
040A98             2289  ;		Statement Execution & Assembler Module - "EXEC"
040A98             2290  ; Author:	(C) Copyright  R.T.Russell  1984
040A98             2291  ; Modified By:	Dean Belfield
040A98             2292  ; Created:	12/05/2023
040A98             2293  ; Last Updated:	26/06/2023
040A98             2294  ;
040A98             2295  ; Modinfo:
040A98             2296  ; 27/01/1984:	Version 2.1
040A98             2297  ; 02/03/1987:	Version 3.0
040A98             2298  ; 11/06/1987:	Version 3.1
040A98             2299  ; 12/05/2023:	Modified by Dean Belfield
040A98             2300  ; 07/06/2023:	Modified to run in ADL mode
040A98             2301  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040A98             2302  
040A98             2303  			; .ASSUME	ADL = 1
040A98             2304  
040A98             2305  			; INCLUDE	"equs.inc"
040A98             2306  
040A98             2307  			; SEGMENT CODE
040A98             2308  
040A98             2309  			; XDEF	XEQ
040A98             2310  			; XDEF	CHAIN0
040A98             2311  			; XDEF	RUN
040A98             2312  			; XDEF	SYNTAX
040A98             2313  			; XDEF	ESCAPE
040A98             2314  			; XDEF	FN_EX
040A98             2315  			; XDEF	USR
040A98             2316  			; XDEF	STORE5
040A98             2317  			; XDEF	STORE4
040A98             2318  			; XDEF	CHECK
040A98             2319  			; XDEF	TERMQ
040A98             2320  			; XDEF	FILL
040A98             2321  			; XDEF	X4OR5
040A98             2322  			; XDEF	MUL16
040A98             2323  			; XDEF	CHANEL
040A98             2324  			; XDEF	ASSEM
040A98             2325  
040A98             2326  			; XREF	AUTO
040A98             2327  			; XREF	DELETE
040A98             2328  			; XREF	LOAD
040A98             2329  			; XREF	LIST_
040A98             2330  			; XREF	NEW
040A98             2331  			; XREF	OLD
040A98             2332  			; XREF	RENUM
040A98             2333  			; XREF	SAVE
040A98             2334  			; XREF	SOUND
040A98             2335  			; XREF	CLG
040A98             2336  			; XREF	DRAW
040A98             2337  			; XREF	ENVEL
040A98             2338  			; XREF	GCOL
040A98             2339  			; XREF	MODE
040A98             2340  			; XREF	MOVE
040A98             2341  			; XREF	PLOT
040A98             2342  			; XREF	COLOUR
040A98             2343  			; XREF	EXPRS
040A98             2344  			; XREF	HIMEM
040A98             2345  			; XREF	LOAD0
040A98             2346  			; XREF	RANDOM
040A98             2347  			; XREF	CLEAR
040A98             2348  			; XREF	ERRTRP
040A98             2349  			; XREF	PAGE_
040A98             2350  			; XREF	DATAPTR
040A98             2351  			; XREF	ERRLIN
040A98             2352  			; XREF	TRAP
040A98             2353  			; XREF	NXT
040A98             2354  			; XREF	SETLIN
040A98             2355  			; XREF	CLOOP
040A98             2356  			; XREF	OSSHUT
040A98             2357  			; XREF	WARM
040A98             2358  			; XREF	TRACEN
040A98             2359  			; XREF	OUTCHR
040A98             2360  			; XREF	PBCDL
040A98             2361  			; XREF	OSCLI
040A98             2362  			; XREF	LISTON
040A98             2363  			; XREF	GETVAR
040A98             2364  			; XREF	PUTVAR
040A98             2365  			; XREF	DATPTR
040A98             2366  			; XREF	ERROR_
040A98             2367  			; XREF	EXPR
040A98             2368  			; XREF	CREATE
040A98             2369  			; XREF	EXPRI
040A98             2370  			; XREF	BRAKET
040A98             2371  			; XREF	FREE
040A98             2372  			; XREF	OSBPUT
040A98             2373  			; XREF	COUNT
040A98             2374  			; XREF	STR
040A98             2375  			; XREF	HEXSTR
040A98             2376  			; XREF	CRLF
040A98             2377  			; XREF	ITEMI
040A98             2378  			; XREF	FINDL
040A98             2379  			; XREF	TEST
040A98             2380  			; XREF	EXPRN
040A98             2381  			; XREF	DLOAD5
040A98             2382  			; XREF	DLOAD5_SPL
040A98             2383  			; XREF	LOADN
040A98             2384  			; XREF	FPP
040A98             2385  			; XREF	SWAP
040A98             2386  			; XREF	GETDEF
040A98             2387  			; XREF	ZERO
040A98             2388  			; XREF	OSBGET
040A98             2389  			; XREF	BUFFER
040A98             2390  			; XREF	CONS
040A98             2391  			; XREF	VAL0
040A98             2392  			; XREF	OSLINE
040A98             2393  			; XREF	CLRSCN
040A98             2394  			; XREF	TELL
040A98             2395  			; XREF	SAYLN
040A98             2396  			; XREF	REPORT
040A98             2397  			; XREF	PUTPTR
040A98             2398  			; XREF	PUTIME
040A98             2399  			; XREF	PUTIMS
040A98             2400  			; XREF	LOMEM
040A98             2401  			; XREF	WIDTH
040A98             2402  			; XREF	OSWRCH
040A98             2403  			; XREF	COMMA
040A98             2404  			; XREF	OSCALL
040A98             2405  			; XREF	SFIX
040A98             2406  			; XREF	LOAD4
040A98             2407  			; XREF	PUSHS
040A98             2408  			; XREF	POPS
040A98             2409  			; XREF	LOADS
040A98             2410  			; XREF	PUTCSR
040A98             2411  			; XREF	OUT_
040A98             2412  			; XREF	R0
040A98             2413  ;
040A98             2414  ; List of token values used in this module
040A98             2415  ;
040A98             2416  TAND:			EQU     80H
040A98             2417  TOR:			EQU     84H
040A98             2418  TERROR_EX:			EQU     85H
040A98             2419  LINE_EX_:			EQU     86H
040A98             2420  OFF_:			EQU     87H
040A98             2421  STEP:			EQU     88H
040A98             2422  SPC:			EQU     89H
040A98             2423  TAB:			EQU     8AH
040A98             2424  ELSE_EX_:			EQU     8BH
040A98             2425  THEN_EX_:			EQU     8CH
040A98             2426  LINO_EX:			EQU     8DH
040A98             2427  TO_EX:			EQU     B8H
040A98             2428  TCMD_EX:			EQU     C6H
040A98             2429  TCALL:			EQU     D6H
040A98             2430  DATA_EX_:			EQU     DCH
040A98             2431  DEF_:			EQU     DDH
040A98             2432  TGOSUB:			EQU     E4H
040A98             2433  TGOTO:			EQU     E5H
040A98             2434  TON:			EQU     EEH
040A98             2435  TPROC:			EQU     F2H
040A98             2436  TSTOP:			EQU     FAH
040A98             2437  
040A98             2438  ; The command table
040A98             2439  ; Commands are tokens from C6H onwards; this lookup table is used to
040A98             2440  ; run the corresponding function; Note that DATA and DEF both use the same
040A98             2441  ; code as REM
040A98             2442  ;
040A98 19 37 04    2443  CMDTAB:			DW24  AUTO			; C6H
040A9B 7C 35 04    2444  			DW24  DELETE			; C7H
040A9E 5A 37 04    2445  			DW24  LOAD			; C8H
040AA1 B7 35 04    2446  			DW24  LIST_			; C9H
040AA4 37 37 04    2447  			DW24  NEW			; CAH
040AA7 3D 37 04    2448  			DW24  OLD			; CBH
040AAA 46 36 04    2449  			DW24  RENUM			; CCH
040AAD 6B 37 04    2450  			DW24  SAVE			; CDH
040AB0 D2 15 04    2451  			DW24  PUT			; CEH
040AB3 C8 13 04    2452  			DW24  PTR_EX			; CFH
040AB6 E2 13 04    2453  			DW24  PAGEV_EX			; D0H
040AB9 F5 13 04    2454  			DW24  TIMEV_EX			; D1H
040ABC 1E 14 04    2455  			DW24  LOMEMV_EX			; D2H
040ABF 37 14 04    2456  			DW24  HIMEMV_EX			; D3H
040AC2 5C 46 04    2457  			DW24  SOUND			; D4H
040AC5 EC 14 04    2458  			DW24  BPUT			; D5H
040AC8 04 15 04    2459  			DW24  CALL_			; D6H
040ACB 4C 0B 04    2460  			DW24  CHAIN			; D7H
040ACE 97 13 04    2461  			DW24  CLR			; D8H
040AD1 E0 14 04    2462  			DW24  CLOSE			; D9H
040AD4 F8 43 04    2463  			DW24  CLG			; DAH
040AD7 6A 13 04    2464  			DW24  CLS			; DBH
040ADA 2B 0C 04    2465  			DW24  REM_EX             		; DCH: DATA
040ADD 2B 0C 04    2466  			DW24  REM_EX             		; DDH: DEF
040AE0 F1 0C 04    2467  			DW24  DIM_EX			; DEH
040AE3 22 46 04    2468  			DW24  DRAW			; DFH
040AE6 C6 0B 04    2469  			DW24  END_			; E0H
040AE9 82 11 04    2470  			DW24  ENDPRO			; E1H
040AEC 7C 49 04    2471  			DW24  ENVEL			; E2H
040AEF 97 0F 04    2472  			DW24  FOR_EX			; E3H
040AF2 47 0F 04    2473  			DW24  GOSUB_EX			; E4H
040AF5 2B 0F 04    2474  			DW24  GOTO_EX			; E5H
040AF8 B6 45 04    2475  			DW24  GCOL			; E6H
040AFB 36 13 04    2476  			DW24  IF_			; E7H
040AFE 24 12 04    2477  			DW24  INPUT			; E8H
040B01 4C 0C 04    2478  			DW24  LET			; E9H
040B04 27 11 04    2479  			DW24  LOCAL_EX_			; EAH
040B07 08 44 04    2480  			DW24  MODE			; EBH
040B0A 1A 46 04    2481  			DW24  MOVE			; ECH
040B0D E5 0F 04    2482  			DW24  NEXT_EX			; EDH
040B10 BE 0E 04    2483  			DW24  ON_EX_			; EEH
040B13 A1 14 04    2484  			DW24  VDU			; EFH
040B16 E8 45 04    2485  			DW24  PLOT			; F0H
040B19 C7 0D 04    2486  			DW24  PRINT_			; F1H
040B1C 84 10 04    2487  			DW24  PROC_EX			; F2H
040B1F D6 12 04    2488  			DW24  READ			; F3H
040B22 2B 0C 04    2489  			DW24  REM_EX			; F4H
040B25 67 0F 04    2490  			DW24  REPEAT_EX			; F5H
040B28 8F 13 04    2491  			DW24  REPOR			; F6H
040B2B A1 13 04    2492  			DW24  RESTOR_EX			; F7H
040B2E 55 0F 04    2493  			DW24  RETURN			; F8H
040B31 46 0B 04    2494  			DW24  RUN			; F9H
040B34 77 13 04    2495  			DW24  STOP			; FAH
040B37 04 45 04    2496  			DW24  COLOUR			; FBH
040B3A 83 14 04    2497  			DW24  TRACE_EX			; FCH
040B3D 71 0F 04    2498  			DW24  UNTIL_EX			; FDH
040B40 75 14 04    2499  			DW24  WIDTHV			; FEH
040B43 11 0C 04    2500  			DW24  CLI             		; FFH: OSCLI
040B46             2501  
040B46             2502  ; RUN
040B46             2503  ; RUN "filename"
040B46             2504  ;
040B46 CD A4 17 04 2505  RUN:			CALL    TERMQ			; Standalone RUN command?
040B4A 28 10       2506  			JR      Z,RUN0			; Yes, so just RUN the code
040B4C             2507  
040B4C             2508  ; CHAIN "filename"
040B4C             2509  ;
040B4C CD 15 03 04 2510  CHAIN:			CALL    EXPRS			; Get the filename
040B50 3E 0D       2511  			LD      A,CR			; Terminate it with a CR
040B52 12          2512  			LD      (DE),A
040B53 ED 7B 20 4D 2513  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B58 CD 4F 38 04 2514  			CALL    LOAD0			; And load the file in
040B5C             2515  ;
040B5C ED 7B 20 4D 2516  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B61 DD 21 38 4D 2517  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B66 ED 5F       2518  @@:			LD      A, R			; Use the R register to seed the random number generator
040B68 28 FC       2519  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B6A 07          2520  			RLCA				; Rotate it
040B6B 07          2521  			RLCA
040B6C DD 77 03    2522  			LD      (IX+3),A		; And store
040B6F 9F          2523  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B70 DD 77 04    2524  			LD      (IX+4),A		; And store
040B73 CD A6 38 04 2525  			CALL    CLEAR
040B77 21 00 00 00 2526  			LD      HL,0			; Clear the error trap sysvar
040B7B 22 2C 4D 04 2527  			LD      (ERRTRP),HL
040B7F 2A 14 4D 04 2528  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B83 3E DC       2529  			LD      A,DATA_EX_			; The DATA token value
040B85 CD 78 18 04 2530  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B89 22 31 4D 04 2531  			LD      (DATPTR),HL     	; Set data pointer
040B8D FD 2A 14 4D 2532  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B92             2533  ;
040B92 CD DA 0B 04 2534  XEQ0:			CALL    NEWLIN
040B96 FD 22 35 4D 2535  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040B9B CD 9D 3F 04 2536  			CALL    TRAP           		; Check keyboard
040B9F CD 70 0A 04 2537  XEQ1:			CALL    NXT
040BA3 FD 23       2538  			INC     IY
040BA5 FE 3A       2539  			CP      ':'             	; Seperator
040BA7 28 F6       2540  			JR      Z,XEQ1
040BA9 FE 0D       2541  			CP      CR
040BAB 28 E5       2542  			JR      Z,XEQ0          	; New program line
040BAD D6 C6       2543  			SUB     TCMD_EX
040BAF DA 3A 0C 04 2544  			JP      C,LET0          	; Implied "LET"
040BB3             2545  
040BB3 01 03 00 00 2546  			LD	BC, 3
040BB7 47          2547  			LD	B, A
040BB8 ED 4C       2548  			MLT	BC
040BBA 21 98 0A 04 2549  			LD	HL,CMDTAB
040BBE 09          2550  			ADD	HL, BC
040BBF ED 27       2551  			LD	HL, (HL)		; Table entry
040BC1             2552  
040BC1             2553  ;			ADD     A,A
040BC1             2554  ;			LD      C,A
040BC1             2555  ;			LD      B,0
040BC1             2556  ;			LD      HL,CMDTAB
040BC1             2557  ;			ADD     HL,BC
040BC1             2558  ;			LD      A,(HL)          	; Table entry
040BC1             2559  ;			INC     HL
040BC1             2560  ;			LD      H,(HL)
040BC1             2561  ;			LD      L,A
040BC1             2562  
040BC1 CD 70 0A 04 2563  			CALL    NXT
040BC5 E9          2564  			JP      (HL)            	; Execute the statement
040BC6             2565  
040BC6             2566  ;END
040BC6             2567  ;
040BC6 CD DE 39 04 2568  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BCA 7C          2569  			LD      A,H
040BCB B5          2570  			OR      L               ;DIRECT?
040BCC CA B0 30 04 2571  			JP      Z,CLOOP
040BD0 1E 00       2572  			LD      E,0
040BD2 CD 6C 43 04 2573  			CALL    OSSHUT          ;CLOSE ALL FILES
040BD6 C3 AF 30 04 2574  			JP      WARM            ;"Ready"
040BDA             2575  ;
040BDA FD 7E 00    2576  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BDD 01 03 00 00 2577  			LD      BC,3
040BE1 FD 09       2578  			ADD     IY,BC
040BE3 B7          2579  			OR      A
040BE4 28 E0       2580  			JR      Z,END_           ;LENGTH=0, EXIT
040BE6 2A 26 4D 04 2581  			LD      HL,(TRACEN)
040BEA 7C          2582  			LD      A,H
040BEB B5          2583  			OR      L
040BEC C8          2584  			RET     Z
040BED 11 00 00 00 2585  			LD	DE, 0		;Clear DE
040BF1 FD 56 FF    2586  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BF4 FD 5E FE    2587  			LD      E,(IY-2)
040BF7 ED 52       2588  			SBC     HL,DE
040BF9 D8          2589  			RET     C
040BFA EB          2590  			EX      DE,HL
040BFB 3E 5B       2591  			LD      A,'['           ;TRACE
040BFD CD 7F 39 04 2592  			CALL    OUTCHR
040C01 CD 27 3A 04 2593  			CALL    PBCDL
040C05 3E 5D       2594  			LD      A,']'
040C07 CD 7F 39 04 2595  			CALL    OUTCHR
040C0B 3E 20       2596  			LD      A,' '
040C0D C3 7F 39 04 2597  			JP      OUTCHR
040C11             2598  
040C11             2599  ; Routines for each statement -------------------------------------------------
040C11             2600  
040C11             2601  ; OSCLI
040C11             2602  ;
040C11 CD 15 03 04 2603  CLI:			CALL    EXPRS
040C15 3E 0D       2604  			LD      A,CR
040C17 12          2605  			LD      (DE),A
040C18 21 00 4A 04 2606  			LD      HL,ACCS
040C1C CD C0 3F 04 2607  			CALL    OSCLI
040C20 C3 96 0B 04 2608  			JP      XEQ
040C24             2609  
040C24             2610  ; REM, *
040C24             2611  ;
040C24 FD E5       2612  EXT_EX:			PUSH    IY
040C26 E1          2613  			POP     HL
040C27 CD C0 3F 04 2614  			CALL    OSCLI
040C2B FD E5       2615  REM_EX:			PUSH    IY
040C2D E1          2616  			POP     HL
040C2E 3E 0D       2617  			LD      A,CR
040C30 47          2618  			LD      B,A
040C31 ED B1       2619  			CPIR                    ;FIND LINE END
040C33 E5          2620  			PUSH    HL
040C34 FD E1       2621  			POP     IY
040C36 C3 92 0B 04 2622  			JP      XEQ0
040C3A             2623  
040C3A             2624  ; [LET] var = expr
040C3A             2625  ;
040C3A FE C5       2626  LET0:			CP      ELSE_EX_-TCMD_EX
040C3C 28 ED       2627  			JR      Z,REM_EX
040C3E             2628  			; CP      ('*'-TCMD) & 0FFH
040C3E             2629  			; JR      Z,EXT_EX
040C3E             2630  			; CP      ('='-TCMD) & 0FFH
040C3E             2631  			; JR      Z,FNEND
040C3E             2632  			; CP      ('['-TCMD) & 0FFH
040C3E             2633  			; ez80asm doesn't like () in expressions
040C3E FE 64       2634  			CP      '*'-TCMD_EX & 0FFH
040C40 28 E2       2635  			JR      Z,EXT_EX
040C42 FE 77       2636  			CP      '='-TCMD_EX & 0FFH
040C44 28 5B       2637  			JR      Z,FNEND
040C46 FE 95       2638  			CP      '['-TCMD_EX & 0FFH
040C48 28 25       2639  			JR      Z,ASM
040C4A FD 2B       2640  			DEC     IY
040C4C CD E8 15 04 2641  LET:			CALL    ASSIGN			; Assign the variable
040C50 CA 96 0B 04 2642  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C54 38 41       2643  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C56             2644  ;
040C56 F5          2645  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C57 CD BA 17 04 2646  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C5B E5          2647  			PUSH    HL			; HL: Address of the variable
040C5C CD 15 03 04 2648  			CALL    EXPRS
040C60 DD E1       2649  			POP     IX			; IX: Address of the variable
040C62 F1          2650  			POP     AF			; AF: The variable type
040C63 CD 2A 16 04 2651  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C67 C3 96 0B 04 2652  XEQR:			JP      XEQ
040C6B             2653  ;
040C6B CD DA 0B 04 2654  ASM0:			CALL    NEWLIN
040C6F FD 22 35 4D 2655  ASM:			LD      (ERRLIN),IY
       04          
040C74 CD 9D 3F 04 2656  			CALL    TRAP
040C78 CD C5 18 04 2657  			CALL    ASSEM
040C7C 38 19       2658  			JR      C,SYNTAX
040C7E FE 0D       2659  			CP      CR
040C80 28 E9       2660  			JR      Z,ASM0
040C82 21 40 4D 04 2661  			LD      HL,LISTON
040C86 7E          2662  			LD      A,(HL)
040C87 E6 0F       2663  			AND     0FH
040C89 F6 B0       2664  			OR      B0H
040C8B 77          2665  			LD      (HL),A
040C8C 18 D9       2666  			JR      XEQR
040C8E             2667  ;
040C8E CD 6A 3A 04 2668  VAR_:			CALL    GETVAR
040C92 C8          2669  			RET     Z
040C93 D2 59 3A 04 2670  			JP      NC,PUTVAR
040C97 3E 10       2671  SYNTAX:			LD      A,16            ;"Syntax error"
040C99 18 02       2672  			JR	ERROR0_EX
040C9B 3E 11       2673  ESCAPE:			LD      A,17            ;"Escape"
040C9D C3 90 37 04 2674  ERROR0_EX:			JP      ERROR_
040CA1             2675  
040CA1             2676  ; =
040CA1             2677  ;
040CA1 CD C7 01 04 2678  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CA5 43          2679  			LD      B,E
040CA6 EB          2680  			EX      DE,HL
040CA7 D9          2681  			EXX                     ;SAVE RESULT
040CA8 EB          2682  			EX      DE,HL           ; IN DEB'C'D'E'
040CA9 C1          2683  FNEND5:			POP     BC
040CAA 21 82 17 04 2684  			LD      HL,LOCCHK
040CAE B7          2685  			OR      A
040CAF ED 42       2686  			SBC     HL,BC
040CB1 28 1C       2687  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CB3 21 84 10 04 2688  			LD      HL,FNCHK
040CB7 B7          2689  			OR      A
040CB8 ED 42       2690  			SBC     HL,BC
040CBA 3E 07       2691  			LD      A,7
040CBC 20 DF       2692  			JR      NZ,ERROR0_EX       ;"No FN"
040CBE FD E1       2693  			POP     IY
040CC0 FD 22 35 4D 2694  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CC5 EB          2695  			EX      DE,HL
040CC6 D9          2696  			EXX
040CC7 EB          2697  			EX      DE,HL
040CC8 11 00 4A 04 2698  			LD      DE,ACCS
040CCC 58          2699  			LD      E,B
040CCD 08          2700  			EX      AF,AF'
040CCE C9          2701  			RET
040CCF             2702  ;
040CCF DD E1       2703  FNEND0:			POP     IX
040CD1 C1          2704  			POP     BC
040CD2 78          2705  			LD      A,B
040CD3 B7          2706  			OR      A
040CD4 FA E2 0C 04 2707  			JP      M,FNEND1        ;STRING
040CD8 E1          2708  			POP     HL
040CD9 D9          2709  			EXX
040CDA E1          2710  			POP     HL
040CDB D9          2711  			EXX
040CDC CD 00 16 04 2712  			CALL    STORE
040CE0 18 C7       2713  			JR      FNEND5
040CE2 21 00 00 00 2714  FNEND1:			LD      HL,0
040CE6 39          2715  			ADD     HL,SP
040CE7 D5          2716  			PUSH    DE
040CE8 59          2717  			LD      E,C
040CE9 CD 2E 16 04 2718  			CALL    STORES
040CED D1          2719  			POP     DE
040CEE F9          2720  			LD      SP,HL
040CEF 18 B8       2721  			JR      FNEND5
040CF1             2722  
040CF1             2723  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF1             2724  ; DIM var expr[,var expr...]
040CF1             2725  ;
040CF1 CD 6A 3A 04 2726  DIM_EX:			CALL    GETVAR          	; Get the variable
040CF5 DA 81 0D 04 2727  			JP      C,BADDIM		; Throw a "Bad Dim" error
040CF9 CA 8B 0D 04 2728  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040CFD CD DE 3B 04 2729  			CALL    CREATE			; Create a new entity
040D01 E5          2730  			PUSH    HL			; HL: Address of the entity
040D02 DD E1       2731  			POP     IX			; IX: Address of the entity
040D04 FD 7E 00    2732  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D07 FE 28       2733  			CP      '('			; Check for opening brackets
040D09 7A          2734  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D0A 20 7F       2735  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D0C             2736  ;
040D0C             2737  ; At this point we're reserving a variable array
040D0C             2738  ;
040D0C E5          2739  			PUSH    HL			; HL: Address of the entity
040D0D F5          2740  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D0E 11 01 00 00 2741  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D12 42          2742  			LD      B,D			;  B: The number of dimensions in the array
040D13             2743  ;
040D13 FD 23       2744  DIM1:			INC     IY			; Skip to the next token
040D15 C5          2745  			PUSH    BC			; Stack the dimension counter
040D16 D5          2746  			PUSH    DE			; Stack the total size of array accumulator
040D17 DD E5       2747  			PUSH    IX			; Stack the entity address
040D19 CD 0A 03 04 2748  			CALL    EXPRI           	; Fetch the size of this dimension
040D1D CB 7C       2749  			BIT     7,H			; If it is negative then
040D1F 20 60       2750  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D21 D9          2751  			EXX
040D22 23          2752  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D23 DD E1       2753  			POP     IX			; IX: The entity address
040D25 DD 23       2754  			INC     IX
040D27 DD 75 00    2755  			LD      (IX),L          	; Save the size of this dimension in the entity
040D2A DD 23       2756  			INC     IX
040D2C DD 74 00    2757  			LD      (IX),H
040D2F C1          2758  			POP     BC
040D30 CD 9C 18 04 2759  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D34 38 4F       2760  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D36 EB          2761  			EX      DE,HL           	; DE: The new total size of array accumulator
040D37 C1          2762  			POP     BC
040D38 04          2763  			INC     B               	;  B: The dimension counter; increment
040D39 FD 7E 00    2764  			LD      A,(IY)			; Fetch the nex token
040D3C FE 2C       2765  			CP      ','             	; Check for another dimension in the array
040D3E 28 D3       2766  			JR      Z,DIM1			; And loop
040D40             2767  ;
040D40 CD 2F 0A 04 2768  			CALL    BRAKET          	; Check for closing bracket
040D44 F1          2769  			POP     AF              	; Restore the type
040D45 DD 23       2770  			INC     IX
040D47 DD E3       2771  			EX      (SP),IX
040D49 DD 70 00    2772  			LD      (IX),B          	; Number of dimensions
040D4C CD 8F 18 04 2773  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D50 E1          2774  			POP     HL			; Restore the entity address
040D51 38 32       2775  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D53             2776  ;
040D53             2777  ; We now allocate the memory for the array
040D53             2778  ;
040D53 19          2779  DIM3:			ADD     HL,DE
040D54 38 2F       2780  			JR      C,NOROOM
040D56 E5          2781  			PUSH    HL
040D57 24          2782  			INC     H
040D58 28 2B       2783  			JR      Z,NOROOM
040D5A ED 72       2784  			SBC     HL,SP
040D5C 30 27       2785  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D5E E1          2786  			POP     HL
040D5F 22 1D 4D 04 2787  			LD      (FREE),HL
040D63 7A          2788  DIM2:			LD      A,D
040D64 B3          2789  			OR      E
040D65 28 06       2790  			JR      Z,DIM5
040D67 2B          2791  			DEC     HL
040D68 36 00       2792  			LD      (HL),0         		; Initialise the array
040D6A 1B          2793  			DEC     DE
040D6B 18 F6       2794  			JR      DIM2
040D6D CD 70 0A 04 2795  DIM5:			CALL    NXT
040D71 FE 2C       2796  			CP      ','            		; Another variable?
040D73 C2 96 0B 04 2797  			JP      NZ,XEQ
040D77 FD 23       2798  			INC     IY
040D79 CD 70 0A 04 2799  			CALL    NXT
040D7D C3 F1 0C 04 2800  			JP      DIM_EX
040D81             2801  ;
040D81             2802  ; DIM errors
040D81             2803  ;
040D81 3E 0A       2804  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D83 18 02       2805  			JR	ERROR1_EX
040D85 3E 0B       2806  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D87 C3 90 37 04 2807  ERROR1_EX:			JP      ERROR_
040D8B             2808  ;
040D8B             2809  ; At this point we're reserving a block of memory, i.e.
040D8B             2810  ; DIM var expr[,var expr...]
040D8B             2811  ;
040D8B B7          2812  DIM4:			OR      A			;  A: The dimension variable type
040D8C 28 F3       2813  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D8E FA 81 0D 04 2814  			JP      M,BADDIM        	; or a string
040D92 47          2815  			LD      B,A			; Temporarily store the dimension variable type in B
040D93 FD 7E FF    2816  			LD      A,(IY-1)		; Get the last character but one
040D96 FE 29       2817  			CP      ')'			; Check if it is a trailing bracket
040D98 28 E7       2818  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040D9A             2819  ;
040D9A 21 00 00 00 2820  			LD	HL,0			; Clear HL
040D9E 3A 1D 4D 04 2821  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DA2 6F          2822  			LD	L,A
040DA3 3A 1E 4D 04 2823  			LD	A,(FREE+1)
040DA7 67          2824  			LD	H,A
040DA8 78          2825  			LD	A,B			; Restore the dimension variable type
040DA9 D9          2826  			EXX
040DAA 21 00 00 00 2827  			LD	HL,0			; Clear HL
040DAE 47          2828  			LD	B,A			; Temporarily store the dimension variable type in B
040DAF 3A 1F 4D 04 2829  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB3 6F          2830  			LD	L,A
040DB4 78          2831  			LD	A,B			; Restore the dimension variable type
040DB5 4C          2832  			LD	C,H
040DB6 CD 00 16 04 2833  			CALL    STORE           	; Store the address
040DBA CD 0A 03 04 2834  			CALL    EXPRI			; Get the number of bytes to store
040DBE D9          2835  			EXX
040DBF 23          2836  			INC     HL			; Add one to it
040DC0 EB          2837  			EX      DE,HL
040DC1 2A 1D 4D 04 2838  			LD      HL,(FREE)
040DC5 18 8C       2839  			JR      DIM3			; Continue with the DIM
040DC7             2840  
040DC7             2841  ; PRINT list...
040DC7             2842  ; PRINT #channel,list...
040DC7             2843  ;
040DC7 FE 23       2844  PRINT_:			CP      '#'
040DC9 20 7C       2845  			JR      NZ,PRINT0
040DCB CD BC 18 04 2846  			CALL    CHNL            ;CHANNEL NO. = E
040DCF CD 70 0A 04 2847  PRNTN1:			CALL    NXT
040DD3 FE 2C       2848  			CP      ','
040DD5 C2 96 0B 04 2849  			JP      NZ,XEQ
040DD9 FD 23       2850  			INC     IY
040DDB D5          2851  			PUSH    DE
040DDC CD C7 01 04 2852  			CALL    EXPR            ;ITEM TO PRINT
040DE0 08          2853  			EX      AF,AF'
040DE1 FA 07 0E 04 2854  			JP      M,PRNTN2        ;STRING
040DE5 D1          2855  			POP     DE
040DE6 C5          2856  			PUSH    BC
040DE7 D9          2857  			EXX
040DE8 7D          2858  			LD      A,L
040DE9 D9          2859  			EXX
040DEA CD 7C 43 04 2860  			CALL    OSBPUT
040DEE D9          2861  			EXX
040DEF 7C          2862  			LD      A,H
040DF0 D9          2863  			EXX
040DF1 CD 7C 43 04 2864  			CALL    OSBPUT
040DF5 7D          2865  			LD      A,L
040DF6 CD 7C 43 04 2866  			CALL    OSBPUT
040DFA 7C          2867  			LD      A,H
040DFB CD 7C 43 04 2868  			CALL    OSBPUT
040DFF C1          2869  			POP     BC
040E00 79          2870  			LD      A,C
040E01 CD 7C 43 04 2871  			CALL    OSBPUT
040E05 18 C8       2872  			JR      PRNTN1
040E07 4B          2873  PRNTN2:			LD      C,E
040E08 D1          2874  			POP     DE
040E09 21 00 4A 04 2875  			LD      HL,ACCS
040E0D 0C          2876  			INC     C
040E0E 0D          2877  PRNTN3:			DEC     C
040E0F 28 0A       2878  			JR      Z,PRNTN4
040E11 7E          2879  			LD      A,(HL)
040E12 23          2880  			INC     HL
040E13 C5          2881  			PUSH    BC
040E14 CD 7C 43 04 2882  			CALL    OSBPUT
040E18 C1          2883  			POP     BC
040E19 18 F3       2884  			JR      PRNTN3
040E1B 3E 0D       2885  PRNTN4:			LD      A,CR
040E1D CD 7C 43 04 2886  			CALL    OSBPUT
040E21 18 AC       2887  			JR      PRNTN1
040E23             2888  ;
040E23 06 02       2889  PRINT6:			LD      B,2
040E25 18 27       2890  			JR      PRINTC
040E27 01 00 01 00 2891  PRINT8:			LD      BC,100H
040E2B 18 21       2892  			JR      PRINTC
040E2D 21 00 4C 04 2893  PRINT9:			LD      HL,STAVAR
040E31 AF          2894  			XOR     A
040E32 BE          2895  			CP      (HL)
040E33 28 12       2896  			JR      Z,PRINT0
040E35 3A 3D 4D 04 2897  			LD      A,(COUNT)
040E39 B7          2898  			OR      A
040E3A 28 0B       2899  			JR      Z,PRINT0
040E3C 96          2900  PRINTA:			SUB     (HL)
040E3D 28 08       2901  			JR      Z,PRINT0
040E3F 30 FB       2902  			JR      NC,PRINTA
040E41 ED 44       2903  			NEG
040E43 CD 19 18 04 2904  			CALL    FILL
040E47 3A 00 4C 04 2905  PRINT0:			LD      A,(STAVAR)
040E4B 4F          2906  			LD      C,A             ;PRINTS
040E4C 06 00       2907  			LD      B,0             ;PRINTF
040E4E CD A4 17 04 2908  PRINTC:			CALL    TERMQ
040E52 28 3F       2909  			JR      Z,PRINT4
040E54 CB 80       2910  			RES     0,B
040E56 FD 23       2911  			INC     IY
040E58 FE 7E       2912  			CP      '~'
040E5A 28 C7       2913  			JR      Z,PRINT6
040E5C FE 3B       2914  			CP      ';'
040E5E 28 C7       2915  			JR      Z,PRINT8
040E60 FE 2C       2916  			CP      ','
040E62 28 C9       2917  			JR      Z,PRINT9
040E64 CD C9 17 04 2918  			CALL    FORMAT          ;SPC, TAB, '
040E68 28 E4       2919  			JR      Z,PRINTC
040E6A FD 2B       2920  			DEC     IY
040E6C C5          2921  			PUSH    BC
040E6D CD C7 01 04 2922  			CALL    EXPR            ;VARIABLE TYPE
040E71 08          2923  			EX      AF,AF'
040E72 FA 8C 0E 04 2924  			JP      M,PRINT3        ;STRING
040E76 D1          2925  			POP     DE
040E77 D5          2926  			PUSH    DE
040E78 CB 4A       2927  			BIT     1,D
040E7A F5          2928  			PUSH    AF
040E7B CC 66 09 04 2929  			CALL    Z,STR           ;DECIMAL
040E7F F1          2930  			POP     AF
040E80 C4 1A 09 04 2931  			CALL    NZ,HEXSTR       ;HEX
040E84 C1          2932  			POP     BC
040E85 C5          2933  			PUSH    BC
040E86 79          2934  			LD      A,C
040E87 93          2935  			SUB     E
040E88 D4 19 18 04 2936  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E8C C1          2937  PRINT3:			POP     BC
040E8D CD 28 18 04 2938  			CALL    PTEXT           ;PRINT
040E91 18 BB       2939  			JR      PRINTC
040E93 CB 40       2940  PRINT4:			BIT     0,B
040E95 CC 77 39 04 2941  			CALL    Z,CRLF
040E99 C3 96 0B 04 2942  			JP      XEQ
040E9D             2943  
040E9D             2944  ; ON ERROR statement [:statement...]
040E9D             2945  ; ON ERROR OFF
040E9D             2946  ;
040E9D FD 23       2947  ONERR:			INC     IY              ;SKIP "ERROR"
040E9F 21 00 00 00 2948  			LD      HL,0
040EA3 22 2C 4D 04 2949  			LD      (ERRTRP),HL
040EA7 CD 70 0A 04 2950  			CALL    NXT
040EAB FE 87       2951  			CP      OFF_
040EAD FD 23       2952  			INC     IY
040EAF CA 96 0B 04 2953  			JP      Z,XEQ
040EB3 FD 2B       2954  			DEC     IY
040EB5 FD 22 2C 4D 2955  			LD      (ERRTRP),IY
       04          
040EBA C3 2B 0C 04 2956  			JP      REM_EX
040EBE             2957  
040EBE             2958  ; ON expr GOTO line[,line...] [ELSE statement]
040EBE             2959  ; ON expr GOTO line[,line...] [ELSE line]
040EBE             2960  ; ON expr GOSUB line[,line...] [ELSE statement]
040EBE             2961  ; ON expr GOSUB line[,line...] [ELSE line]
040EBE             2962  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EBE             2963  ;
040EBE FE 85       2964  ON_EX_:			CP      TERROR_EX
040EC0 28 DB       2965  			JR      Z,ONERR         ;"ON ERROR"
040EC2 CD 0A 03 04 2966  			CALL    EXPRI
040EC6 FD 7E 00    2967  			LD      A,(IY)
040EC9 FD 23       2968  			INC     IY
040ECB 1E 2C       2969  			LD      E,','           ;SEPARATOR
040ECD FE E5       2970  			CP      TGOTO
040ECF 28 0B       2971  			JR      Z,ON1
040ED1 FE E4       2972  			CP      TGOSUB
040ED3 28 07       2973  			JR      Z,ON1
040ED5 1E F2       2974  			LD      E,TPROC
040ED7 BB          2975  			CP      E
040ED8 3E 27       2976  			LD      A,39
040EDA 20 45       2977  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EDC 57          2978  ON1:			LD      D,A
040EDD D9          2979  			EXX
040EDE E5          2980  			PUSH    HL
040EDF D9          2981  			EXX
040EE0 C1          2982  			POP     BC              ;ON INDEX
040EE1 78          2983  			LD      A,B
040EE2 B4          2984  			OR      H
040EE3 B5          2985  			OR      L
040EE4 20 2A       2986  			JR      NZ,ON4          ;OUT OF RANGE
040EE6 B1          2987  			OR      C
040EE7 28 27       2988  			JR      Z,ON4
040EE9 0D          2989  			DEC     C
040EEA 28 0E       2990  			JR      Z,ON3           ;INDEX=1
040EEC CD A4 17 04 2991  ON2:			CALL    TERMQ
040EF0 28 1E       2992  			JR      Z,ON4           ;OUT OF RANGE
040EF2 FD 23       2993  			INC     IY              ;SKIP DELIMITER
040EF4 BB          2994  			CP      E
040EF5 20 F5       2995  			JR      NZ,ON2
040EF7 0D          2996  			DEC     C
040EF8 20 F2       2997  			JR      NZ,ON2
040EFA 7B          2998  ON3:			LD      A,E
040EFB FE F2       2999  			CP      TPROC
040EFD 28 26       3000  			JR      Z,ONPROC
040EFF D5          3001  			PUSH    DE
040F00 CD 25 03 04 3002  			CALL    ITEMI           ;LINE NUMBER
040F04 D1          3003  			POP     DE
040F05 7A          3004  			LD      A,D
040F06 FE E5       3005  			CP      TGOTO
040F08 28 2D       3006  			JR      Z,GOTO2
040F0A CD B1 17 04 3007  			CALL    SPAN            ;SKIP REST OF LIST
040F0E 18 3B       3008  			JR      GOSUB1
040F10             3009  ;
040F10 FD 7E 00    3010  ON4:			LD      A,(IY)
040F13 FD 23       3011  			INC     IY
040F15 FE 8B       3012  			CP      ELSE_EX_
040F17 CA 4B 13 04 3013  			JP      Z,IF1           ;ELSE CLAUSE
040F1B FE 0D       3014  			CP      CR
040F1D 20 F1       3015  			JR      NZ,ON4
040F1F 3E 28       3016  			LD      A,40
040F21 C3 90 37 04 3017  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F25             3018  ;
040F25 3E EE       3019  ONPROC:			LD      A,TON
040F27 C3 84 10 04 3020  			JP      PROC_EX
040F2B             3021  
040F2B             3022  ; GOTO line
040F2B             3023  ;
040F2B CD 25 03 04 3024  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F2F CD A4 17 04 3025  GOTO1:			CALL    TERMQ			; Check for terminator
040F33 C2 97 0C 04 3026  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F37 D9          3027  GOTO2:			EXX
040F38 CD BF 39 04 3028  			CALL    FINDL			; HL: Line number - Find the line
040F3C E5          3029  			PUSH    HL			; HL: Address of the line
040F3D FD E1       3030  			POP     IY			; IY = HL
040F3F CA 92 0B 04 3031  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F43 3E 29       3032  			LD      A,41			; Otherwise throw a "No such line" error
040F45 18 DA       3033  			JR      ERROR2_EX
040F47             3034  
040F47             3035  ; GOSUB line
040F47             3036  ; This pushes the following data onto the execution stack
040F47             3037  ; - 3 bytes: Current execution address
040F47             3038  ; - 3 bytes: Marker (the address of label GOSCHK)
040F47             3039  ;
040F47 CD 25 03 04 3040  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F4B FD E5       3041  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F4D CD 79 16 04 3042  			CALL    CHECK           	; Check there is enough room
040F51 CD 2F 0F 04 3043  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F55             3044  GOSCHK:			EQU     $
040F55             3045  
040F55             3046  ; RETURN
040F55             3047  ; This pops the following data off the execution stack as pushed by GOSUB
040F55             3048  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F55             3049  ; - 3 bytes: The return execution address
040F55             3050  ;
040F55 D1          3051  RETURN:			POP     DE			; Pop the marker off the execution stack
040F56 21 55 0F 04 3052  			LD      HL,GOSCHK		; Compare with GOSCHK
040F5A B7          3053  			OR      A
040F5B ED 52       3054  			SBC     HL,DE
040F5D FD E1       3055  			POP     IY			; Pop the return address off the execution stack
040F5F CA 96 0B 04 3056  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F63 3E 26       3057  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F65 18 BA       3058  			JR      ERROR2_EX
040F67             3059  
040F67             3060  ; REPEAT
040F67             3061  ; This pushes the following data onto the execution stack
040F67             3062  ; - 3 bytes: Current execution address
040F67             3063  ; - 3 bytes: Marker (the address of label REPCHK)
040F67             3064  ;
040F67 FD E5       3065  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F69 CD 79 16 04 3066  			CALL    CHECK			; Check if there is enough room
040F6D CD 96 0B 04 3067  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F71             3068  REPCHK:			EQU     $
040F71             3069  
040F71             3070  ; UNTIL expr
040F71             3071  ; This pops the following data off the execution stack
040F71             3072  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F71             3073  ; - 3 bytes: The address of the REPEAT instruction
040F71             3074  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F71             3075  ;
040F71 C1          3076  UNTIL_EX:			POP     BC			; Fetch the marker
040F72 C5          3077  			PUSH    BC			; And push it back onto the execution stack
040F73 21 71 0F 04 3078  			LD      HL,REPCHK		; Compare with REPCHK
040F77 B7          3079  			OR      A
040F78 ED 42       3080  			SBC     HL,BC
040F7A 3E 2B       3081  			LD      A,43
040F7C 20 A3       3082  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F7E CD 0A 03 04 3083  			CALL    EXPRI			; Fetch the expression
040F82 CD DF 08 04 3084  			CALL    TEST			; Test if the expression evaluates to zero
040F86 C1          3085  			POP     BC			; Pop the marker
040F87 D1          3086  			POP     DE			; Pop the address of the REPEAT instruction
040F88 20 05       3087  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F8A D5          3088  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F8B C5          3089  			PUSH    BC			; Push the marker back on the stack
040F8C D5          3090  			PUSH    DE			; IY = DE
040F8D FD E1       3091  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F8F C3 96 0B 04 3092  XEQ2:			JP      XEQ			; Continue execution
040F93             3093  
040F93             3094  ; FOR var = expr TO expr [STEP expr]
040F93             3095  ; This pushes the following data onto the execution stack
040F93             3096  ; - 3 bytes: The limit value
040F93             3097  ; - 3 bytes: The step value
040F93             3098  ; - 3 bytes: The current execution address
040F93             3099  ; - 3 bytes: The address of the loop variable
040F93             3100  ; - 3 bytes: Marker (the address of FORCHK)
040F93             3101  ;
040F93 3E 22       3102  FORVAR:			LD      A,34
040F95 18 8A       3103  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F97             3104  ;
040F97 CD E8 15 04 3105  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040F9B 20 F6       3106  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040F9D F5          3107  			PUSH    AF              	; Save the variable type
040F9E FD 7E 00    3108  			LD      A,(IY)			; Check the next token
040FA1 FE B8       3109  			CP      TO_EX			; Compare with the token value for "TO"
040FA3 3E 24       3110  			LD      A,36			; Set the error code to 36 ("No TO")
040FA5 C2 21 0F 04 3111  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FA9 FD 23       3112  			INC     IY			; Skip to the next token
040FAB             3113  ;
040FAB DD E5       3114  			PUSH    IX
040FAD CD 02 03 04 3115  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB1 DD E1       3116  			POP     IX
040FB3 F1          3117  			POP     AF
040FB4 47          3118  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FB5 C5          3119  			PUSH    BC              	; Stack the LIMIT value
040FB6 E5          3120  			PUSH    HL
040FB7 21 00 00 00 3121  			LD      HL,0
040FBB 4C          3122  			LD      C,H
040FBC D9          3123  			EXX
040FBD E5          3124  			PUSH    HL
040FBE             3125  ;
040FBE 21 01 00 00 3126  			LD      HL,1            	; The preset STEP value is 1
040FC2 D9          3127  			EXX
040FC3 FD 7E 00    3128  			LD      A,(IY)			; Fetch the next token
040FC6 FE 88       3129  			CP      STEP			; Compare with the token value for "STEP"
040FC8 20 0A       3130  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FCA             3131  ;
040FCA FD 23       3132  			INC     IY			; Skip past the STEP token
040FCC DD E5       3133  			PUSH    IX
040FCE CD 02 03 04 3134  			CALL    EXPRN          		; Fetch the STEP expression value
040FD2 DD E1       3135  			POP     IX
040FD4             3136  ;
040FD4 C5          3137  FOR1:			PUSH    BC			; Stack the STEP value
040FD5 E5          3138  			PUSH    HL
040FD6 D9          3139  			EXX
040FD7 E5          3140  			PUSH    HL
040FD8 D9          3141  			EXX
040FD9             3142  ;
040FD9 FD E5       3143  			PUSH    IY              	; Stack the current execution address
040FDB DD E5       3144  			PUSH    IX              	; Stack the loop variable
040FDD CD 79 16 04 3145  			CALL    CHECK
040FE1 CD 96 0B 04 3146  			CALL    XEQ
040FE5             3147  FORCHK:			EQU     $
040FE5             3148  
040FE5             3149  ; NEXT [var[,var...]]
040FE5             3150  ; This pops the following data off the execution stack
040FE5             3151  ; - 3 bytes: Marker (the address of FORCHK)
040FE5             3152  ; - 3 bytes: The address of the loop variable
040FE5             3153  ; - 3 bytes: The current execution address
040FE5             3154  ; - 3 bytes: The step value
040FE5             3155  ; - 3 bytes: The limit value
040FE5             3156  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FE5             3157  ;
040FE5 C1          3158  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FE6 21 E5 0F 04 3159  			LD      HL,FORCHK		; Compare with FORCHK
040FEA B7          3160  			OR      A
040FEB ED 42       3161  			SBC     HL,BC
040FED 3E 20       3162  			LD      A,32
040FEF C2 7B 10 04 3163  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF3 CD A4 17 04 3164  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FF7 E1          3165  			POP     HL			; Pop the address of the loop variable off the execution stack
040FF8 E5          3166  			PUSH    HL			; Push it back onto the execution stack
040FF9 C5          3167  			PUSH    BC			; Push the marker back onto the execution stack
040FFA E5          3168  			PUSH    HL			; HL: Address of the loop variable off the stack
040FFB C4 6A 3A 04 3169  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040FFF D1          3170  			POP     DE			; DE: Address of the loop variable off the stack
041000 EB          3171  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041001 B7          3172  			OR      A
041002 ED 52       3173  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041004 20 61       3174  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041006 D5          3175  			PUSH    DE
041007 DD 21 0C 00 3176  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
04100C DD 39       3177  			ADD     IX,SP
04100E CD 11 2A 04 3178  			CALL    DLOAD5_SPL      	; Load the STEP value
041012 DD 7E 10    3179  			LD      A,(IX+16)       	; Get the STEP type
041015 DD E1       3180  			POP     IX
041017 CD 16 04 04 3181  			CALL    LOADN           	; Load the LOOP variable
04101B CB 7A       3182  			BIT     7,D             	; Check the sign
04101D F5          3183  			PUSH    AF
04101E 3E 0B       3184  			LD      A,'+' & 0FH
041020 CD 9A 20 04 3185  			CALL    FPP             	; Add the STEP
041024 38 55       3186  			JR      C,ERROR3_EX
041026 F1          3187  			POP     AF              	; Restore TYPE
041027 F5          3188  			PUSH    AF
041028 CD 00 16 04 3189  			CALL    STORE           	; Update the variable
04102C DD 21 15 00 3190  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041031 DD 39       3191  			ADD     IX,SP
041033 CD 11 2A 04 3192  			CALL    DLOAD5_SPL      	; Load the LIMIT value
041037 F1          3193  			POP     AF
041038 CC D7 08 04 3194  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
04103C             3195  			; LD      A,0+('<'-4) & 0FH
04103C 3E 08       3196  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04103E CD 9A 20 04 3197  			CALL    FPP             	; Test against the limit
041042 38 37       3198  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041044 24          3199  			INC     H
041045 20 14       3200  			JR      NZ,LOOP_        	; Keep looping
041047 21 1B 00 00 3201  			LD      HL,27			; Adjust the stack
04104B 39          3202  			ADD     HL,SP
04104C F9          3203  			LD      SP,HL
04104D CD 70 0A 04 3204  			CALL    NXT
041051 FE 2C       3205  			CP      ','			; Check for multiple variables
041053 C2 96 0B 04 3206  			JP      NZ,XEQ			; No, so we are done at ths point
041057 FD 23       3207  			INC     IY			; Increment to the next variable
041059 18 8A       3208  			JR      NEXT_EX			; And continue
04105B             3209  ;
04105B C1          3210  LOOP_:			POP     BC
04105C D1          3211  			POP     DE
04105D FD E1       3212  			POP     IY
04105F FD E5       3213  			PUSH    IY
041061 D5          3214  			PUSH    DE
041062 C5          3215  			PUSH    BC
041063 C3 96 0B 04 3216  			JP      XEQ
041067             3217  ;
041067 21 1B 00 00 3218  NEXT1:			LD      HL,27			; TODO: What does this do?
04106B 39          3219  			ADD     HL,SP
04106C F9          3220  			LD      SP,HL			; Adjust the stack
04106D C1          3221  			POP     BC
04106E 21 E5 0F 04 3222  			LD      HL,FORCHK
041072 ED 42       3223  			SBC     HL,BC
041074 E1          3224  			POP     HL              	; Variable pointer
041075 E5          3225  			PUSH    HL
041076 C5          3226  			PUSH    BC
041077 28 89       3227  			JR      Z,NEXT0
041079             3228  ;
041079 3E 21       3229  			LD      A,33
04107B C3 90 37 04 3230  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
04107F             3231  
04107F             3232  ; FNname
04107F             3233  ; N.B. ENTERED WITH A <> TON
04107F             3234  ;
04107F F5          3235  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041080 CD 89 10 04 3236  			CALL    PROC1
041084             3237  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041084             3238  
041084             3239  ; PROCname
041084             3240  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
041084             3241  ; This pushes the following data onto the execution stack
041084             3242  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
041084             3243  ; - 3 bytes: Marker (the address of PROCHK)
041084             3244  ;
041084 F5          3245  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041085 CD 89 10 04 3246  			CALL    PROC1			; and is also space reserved on the stack for the return address
041089             3247  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041089             3248  ;
041089 CD 79 16 04 3249  PROC1:			CALL    CHECK			; Check there is space for this
04108D FD 2B       3250  			DEC     IY			; Decrement IY to the PROC token
04108F FD E5       3251  			PUSH    IY			; Stack the pointer
041091 CD 2B 3B 04 3252  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041095 C1          3253  			POP     BC			; BC = IY
041096 28 41       3254  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041098 3E 1E       3255  			LD      A,30
04109A 38 DF       3256  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
04109C             3257  ;
04109C             3258  ; At this point the PROC/FN has not yet been registered in the dynamic area
04109C             3259  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
04109C             3260  ;
04109C C5          3261  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
04109D 2A 14 4D 04 3262  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A1             3263  ;
0410A1 3E DD       3264  PROC2:			LD      A,DEF_			;  A: The token to search for
0410A3 CD 78 18 04 3265  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410A7 38 26       3266  			JR      C,PROC3			; Not found, so jump to PROC3
0410A9 E5          3267  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410AA FD E1       3268  			POP     IY			; IY = HL
0410AC FD 23       3269  			INC     IY              	; Skip the DEF token
0410AE CD 70 0A 04 3270  			CALL    NXT			; And any whitespace
0410B2 CD 2B 3B 04 3271  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410B6 FD E5       3272  			PUSH    IY
0410B8 D1          3273  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410B9 38 09       3274  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410BB C4 DE 3B 04 3275  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410BF FD E5       3276  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C1 D1          3277  			POP     DE			; DE = IY
0410C2 ED 1F       3278  			LD	(HL),DE			; Save address
0410C4             3279  ;
0410C4 EB          3280  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410C5 3E 0D       3281  			LD      A,CR			; The character to search for
0410C7 01 00 01 00 3282  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410CB ED B1       3283  			CPIR                    	; Skip to next line
0410CD 18 D2       3284  			JR      PROC2			; Rinse, lather and repeat
0410CF             3285  ;
0410CF             3286  ; At this point a DEF has not been found for the PROC/FN
0410CF             3287  ;
0410CF FD E1       3288  PROC3:			POP     IY              	; Restore the execution address
0410D1 CD 2B 3B 04 3289  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410D5 3E 1D       3290  			LD      A,29
0410D7 20 A2       3291  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410D9             3292  ;
0410D9             3293  ; At this point we have a PROC/FN entry in the dynamic area
0410D9             3294  ;
0410D9 ED 17       3295  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410DB 21 03 00 00 3296  			LD	HL,3
0410DF 39          3297  			ADD     HL,SP
0410E0 CD 70 0A 04 3298  			CALL    NXT             	; Allow space before "("
0410E4 D5          3299  			PUSH    DE              	; Exchange DE and IY
0410E5 FD E3       3300  			EX      (SP),IY
0410E7 FE 28       3301  			CP      '('             	; Arguments?
0410E9 D1          3302  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410EA 20 20       3303  			JR      NZ,PROC5
0410EC CD 70 0A 04 3304  			CALL    NXT             	; Allow space before "("
0410F0 FE 28       3305  			CP      '('
0410F2 C2 97 0C 04 3306  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410F6 FD E5       3307  			PUSH    IY
0410F8 C1          3308  			POP     BC              	; Save IY in BC
0410F9 D9          3309  			EXX
0410FA CD 24 17 04 3310  			CALL    SAVLOC          	; Save local parameters
0410FE CD 2F 0A 04 3311  			CALL    BRAKET          	; Closing bracket
041102 D9          3312  			EXX
041103 C5          3313  			PUSH    BC
041104 FD E1       3314  			POP     IY              	; Restore IY
041106 E5          3315  			PUSH    HL
041107 CD A0 16 04 3316  			CALL    ARGUE           	; Transfer arguments
04110B E1          3317  			POP     HL
04110C             3318  ;
04110C 23          3319  PROC5:			INC	HL			; Increment to the ON PROC flag address
04110D 7E          3320  			LD	A, (HL)			; And fetch the value
04110E 2B          3321  			DEC 	HL
04110F ED 1F       3322  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041111 FE EE       3323  			CP	TON			; Was it "ON PROC"?
041113 C2 96 0B 04 3324  			JP	NZ, XEQ			; No, so back to XEQ
041117 D5          3325  			PUSH    DE			; Exchange DE and IY
041118 FD E3       3326  			EX      (SP),IY
04111A CD B1 17 04 3327  			CALL    SPAN            	; Skip rest of ON list
04111E FD E3       3328  			EX      (SP),IY			; Exchange DE and IY
041120 D1          3329  			POP     DE
041121 ED 1F       3330  			LD	(HL), DE		; Save the return address
041123 C3 96 0B 04 3331  			JP      XEQ
041127             3332  
041127             3333  ; LOCAL var[,var...]
041127             3334  ;
041127 C1          3335  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041128 C5          3336  			PUSH    BC
041129 21 84 10 04 3337  			LD      HL,FNCHK		; Check if we are in a FN
04112D B7          3338  			OR      A
04112E ED 42       3339  			SBC     HL,BC
041130 28 16       3340  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041132 21 89 10 04 3341  			LD      HL,PROCHK		; Now check if we are in a PROC
041136 B7          3342  			OR      A
041137 ED 42       3343  			SBC     HL,BC
041139 28 0D       3344  			JR      Z,LOCAL1		; Again, all good, we can use local
04113B 21 82 17 04 3345  			LD      HL,LOCCHK		; Finally check for the local parameters marker
04113F B7          3346  			OR      A
041140 ED 42       3347  			SBC     HL,BC			; If it is not present, then
041142 3E 0C       3348  			LD      A,12
041144 C2 90 37 04 3349  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041148             3350  ;
041148             3351  ; At this point we are adding a local variable into a PROC or FN
041148             3352  ;
041148 FD E5       3353  LOCAL1:			PUSH    IY			; IY: BASIC pointer
04114A C1          3354  			POP     BC			; BC: Copy of the BASIC pointer
04114B D9          3355  			EXX
04114C FD 2B       3356  			DEC     IY
04114E CD 24 17 04 3357  			CALL    SAVLOC
041152 D9          3358  			EXX
041153 C5          3359  			PUSH    BC
041154 FD E1       3360  			POP     IY
041156             3361  ;
041156 CD 6A 3A 04 3362  LOCAL2:			CALL    GETVAR			; Get the variable location
04115A C2 97 0C 04 3363  			JP      NZ,SYNTAX
04115E B7          3364  			OR      A               	; Check the variable type (80h = string)
04115F 08          3365  			EX      AF,AF'
041160 CD 93 09 04 3366  			CALL    ZERO			; Zero the variable anyway
041164 08          3367  			EX      AF,AF'
041165 F5          3368  			PUSH    AF
041166 F4 00 16 04 3369  			CALL    P,STORE         	; Call STORE if it is not a string
04116A F1          3370  			POP     AF
04116B 59          3371  			LD      E,C
04116C FC 2E 16 04 3372  			CALL    M,STORES		; Call STORES if it is a string
041170 CD 70 0A 04 3373  			CALL    NXT			; Skip to the next character in the expression
041174 FE 2C       3374  			CP      ','			; Is it a comma?
041176 C2 96 0B 04 3375  			JP      NZ,XEQ			; No, so we're done, carry on executing
04117A FD 23       3376  			INC     IY			; Yes, so skip the comma
04117C CD 70 0A 04 3377  			CALL    NXT			; And any whitespace
041180 18 D4       3378  			JR      LOCAL2			; Then loop back and handle any further local variables
041182             3379  
041182             3380  ; ENDPROC
041182             3381  ;
041182 C1          3382  ENDPRO:			POP     BC			; Pop the check value off the stack
041183 21 82 17 04 3383  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041187 B7          3384  			OR      A
041188 ED 42       3385  			SBC     HL,BC
04118A 28 13       3386  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04118C             3387  ;
04118C 21 89 10 04 3388  			LD      HL,PROCHK       	; Check if it is the PROC marker
041190 B7          3389  			OR      A
041191 ED 42       3390  			SBC     HL,BC
041193 FD E1       3391  			POP     IY
041195 CA 96 0B 04 3392  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
041199 3E 0D       3393  			LD      A,13			; Otherwise throw the "No PROC" error
04119B C3 90 37 04 3394  			JP      ERROR_
04119F             3395  ;
04119F DD E1       3396  UNSTK:			POP     IX			; Unstack a single local variable
0411A1 C1          3397  			POP     BC
0411A2 78          3398  			LD      A,B
0411A3 B7          3399  			OR      A
0411A4 FA B2 11 04 3400  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411A8 E1          3401  			POP     HL			; Unstack a normal variable
0411A9 D9          3402  			EXX
0411AA E1          3403  			POP     HL
0411AB D9          3404  			EXX
0411AC CD 00 16 04 3405  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B0 18 D0       3406  			JR      ENDPRO			; And loop back to ENDPRO
0411B2             3407  ;
0411B2 21 00 00 00 3408  UNSTK1:			LD      HL,0			; Unstack a string
0411B6 39          3409  			ADD     HL,SP
0411B7 59          3410  			LD      E,C
0411B8 CD 2E 16 04 3411  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411BC F9          3412  			LD      SP,HL
0411BD 18 C3       3413  			JR      ENDPRO
0411BF             3414  
0411BF             3415  ; INPUT #channel,var,var...
0411BF             3416  ;
0411BF CD BC 18 04 3417  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C3 CD 70 0A 04 3418  INPN1:			CALL    NXT
0411C7 FE 2C       3419  			CP      ','
0411C9 C2 96 0B 04 3420  			JP      NZ,XEQ
0411CD FD 23       3421  			INC     IY
0411CF CD 70 0A 04 3422  			CALL    NXT
0411D3 D5          3423  			PUSH    DE
0411D4 CD 8E 0C 04 3424  			CALL    VAR_
0411D8 D1          3425  			POP     DE
0411D9 F5          3426  			PUSH    AF              ;SAVE TYPE
0411DA E5          3427  			PUSH    HL              ;VARPTR
0411DB B7          3428  			OR      A
0411DC FA 08 12 04 3429  			JP      M,INPN2         ;STRING
0411E0 CD 74 43 04 3430  			CALL    OSBGET
0411E4 D9          3431  			EXX
0411E5 6F          3432  			LD      L,A
0411E6 D9          3433  			EXX
0411E7 CD 74 43 04 3434  			CALL    OSBGET
0411EB D9          3435  			EXX
0411EC 67          3436  			LD      H,A
0411ED D9          3437  			EXX
0411EE CD 74 43 04 3438  			CALL    OSBGET
0411F2 6F          3439  			LD      L,A
0411F3 CD 74 43 04 3440  			CALL    OSBGET
0411F7 67          3441  			LD      H,A
0411F8 CD 74 43 04 3442  			CALL    OSBGET
0411FC 4F          3443  			LD      C,A
0411FD DD E1       3444  			POP     IX
0411FF F1          3445  			POP     AF              ;RESTORE TYPE
041200 D5          3446  			PUSH    DE              ;SAVE CHANNEL
041201 CD 00 16 04 3447  			CALL    STORE
041205 D1          3448  			POP     DE
041206 18 BB       3449  			JR      INPN1
041208 21 00 4A 04 3450  INPN2:			LD      HL,ACCS
04120C CD 74 43 04 3451  INPN3:			CALL    OSBGET
041210 FE 0D       3452  			CP      CR
041212 28 04       3453  			JR      Z,INPN4
041214 77          3454  			LD      (HL),A
041215 2C          3455  			INC     L
041216 20 F4       3456  			JR      NZ,INPN3
041218 DD E1       3457  INPN4:			POP     IX
04121A F1          3458  			POP     AF
04121B D5          3459  			PUSH    DE
04121C EB          3460  			EX      DE,HL
04121D CD 2A 16 04 3461  			CALL    STACCS
041221 D1          3462  			POP     DE
041222 18 9F       3463  			JR      INPN1
041224             3464  
041224             3465  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3466  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3467  ;
041224 FE 23       3468  INPUT:			CP      '#'
041226 28 97       3469  			JR      Z,INPUTN
041228 0E 00       3470  			LD      C,0             ;FLAG PROMPT
04122A FE 86       3471  			CP      LINE_EX_
04122C 20 04       3472  			JR      NZ,INPUT0
04122E FD 23       3473  			INC     IY              ;SKIP "LINE"
041230 0E 80       3474  			LD      C,80H
041232 21 00 4B 04 3475  INPUT0:			LD      HL,BUFFER
041236 36 0D       3476  			LD      (HL),CR         ;INITIALISE EMPTY
041238 CD A4 17 04 3477  INPUT1:			CALL    TERMQ
04123C CA 96 0B 04 3478  			JP      Z,XEQ           ;DONE
041240 FD 23       3479  			INC     IY
041242 FE 2C       3480  			CP      ','
041244 28 5C       3481  			JR      Z,INPUT3        ;SKIP COMMA
041246 FE 3B       3482  			CP      ';'
041248 28 58       3483  			JR      Z,INPUT3
04124A E5          3484  			PUSH    HL              ;SAVE BUFFER POINTER
04124B FE 22       3485  			CP      34		;ASCII ""
04124D 20 0C       3486  			JR      NZ,INPUT6
04124F C5          3487  			PUSH    BC
041250 CD 67 04 04 3488  			CALL    CONS
041254 C1          3489  			POP     BC
041255 CD 28 18 04 3490  			CALL    PTEXT           ;PRINT PROMPT
041259 18 06       3491  			JR      INPUT9
04125B CD C9 17 04 3492  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
04125F 20 05       3493  			JR      NZ,INPUT2
041261 E1          3494  INPUT9:			POP     HL
041262 CB C1       3495  			SET     0,C             ;FLAG NO PROMPT
041264 18 CC       3496  			JR      INPUT0
041266 FD 2B       3497  INPUT2:			DEC     IY
041268 C5          3498  			PUSH    BC
041269 CD 8E 0C 04 3499  			CALL    VAR_
04126D C1          3500  			POP     BC
04126E E1          3501  			POP     HL
04126F F5          3502  			PUSH    AF              ;SAVE TYPE
041270 7E          3503  			LD      A,(HL)
041271 23          3504  			INC     HL
041272 FE 0D       3505  			CP      CR              ;BUFFER EMPTY?
041274 CC A6 12 04 3506  			CALL    Z,REFILL
041278 CB 79       3507  			BIT     7,C
04127A F5          3508  			PUSH    AF
04127B C4 4A 18 04 3509  			CALL    NZ,LINES
04127F F1          3510  			POP     AF
041280 CC 37 18 04 3511  			CALL    Z,FETCHS
041284 F1          3512  			POP     AF              ;RESTORE TYPE
041285 C5          3513  			PUSH    BC
041286 E5          3514  			PUSH    HL
041287 B7          3515  			OR      A
041288 FA 9C 12 04 3516  			JP      M,INPUT4        ;STRING
04128C F5          3517  			PUSH    AF
04128D DD E5       3518  			PUSH    IX
04128F CD 6E 06 04 3519  			CALL    VAL0
041293 DD E1       3520  			POP     IX
041295 F1          3521  			POP     AF
041296 CD 00 16 04 3522  			CALL    STORE
04129A 18 04       3523  			JR      INPUT5
04129C CD 2A 16 04 3524  INPUT4:			CALL    STACCS
0412A0 E1          3525  INPUT5:			POP     HL
0412A1 C1          3526  			POP     BC
0412A2 CB 81       3527  INPUT3:			RES     0,C
0412A4 18 92       3528  			JR      INPUT1
0412A6             3529  ;
0412A6 CB 41       3530  REFILL:			BIT     0,C
0412A8 20 0C       3531  			JR      NZ,REFIL0       ;NO PROMPT
0412AA 3E 3F       3532  			LD      A,'?'
0412AC CD 7F 39 04 3533  			CALL    OUTCHR          ;PROMPT
0412B0 3E 20       3534  			LD      A,' '
0412B2 CD 7F 39 04 3535  			CALL    OUTCHR
0412B6 21 00 4B 04 3536  REFIL0:			LD      HL,BUFFER
0412BA C5          3537  			PUSH    BC
0412BB E5          3538  			PUSH    HL
0412BC DD E5       3539  			PUSH    IX
0412BE CD 8F 3E 04 3540  			CALL    OSLINE
0412C2 DD E1       3541  			POP     IX
0412C4 E1          3542  			POP     HL
0412C5 C1          3543  			POP     BC
0412C6 47          3544  			LD      B,A             ;POS AT ENTRY
0412C7 AF          3545  			XOR     A
0412C8 32 3D 4D 04 3546  			LD      (COUNT),A
0412CC B8          3547  			CP      B
0412CD C8          3548  			RET     Z
0412CE 7E          3549  REFIL1:			LD      A,(HL)
0412CF FE 0D       3550  			CP      CR
0412D1 C8          3551  			RET     Z
0412D2 23          3552  			INC     HL
0412D3 10 F9       3553  			DJNZ    REFIL1
0412D5 C9          3554  			RET
0412D6             3555  
0412D6             3556  ; READ var[,var...]
0412D6             3557  ;
0412D6 FE 23       3558  READ:			CP      '#'
0412D8 CA BF 11 04 3559  			JP      Z,INPUTN
0412DC 2A 31 4D 04 3560  			LD      HL,(DATPTR)
0412E0 7E          3561  READ0:			LD      A,(HL)
0412E1 23          3562  			INC     HL              ;SKIP COMMA OR "DATA"
0412E2 FE 0D       3563  			CP      CR              ;END OF DATA STMT?
0412E4 CC 28 13 04 3564  			CALL    Z,GETDAT
0412E8 E5          3565  			PUSH    HL
0412E9 CD 8E 0C 04 3566  			CALL    VAR_
0412ED E1          3567  			POP     HL
0412EE B7          3568  			OR      A
0412EF FA 08 13 04 3569  			JP      M,READ1         ;STRING
0412F3 E5          3570  			PUSH    HL
0412F4 FD E3       3571  			EX      (SP),IY
0412F6 F5          3572  			PUSH    AF              ;SAVE TYPE
0412F7 DD E5       3573  			PUSH    IX
0412F9 CD 02 03 04 3574  			CALL    EXPRN
0412FD DD E1       3575  			POP     IX
0412FF F1          3576  			POP     AF
041300 CD 00 16 04 3577  			CALL    STORE
041304 FD E3       3578  			EX      (SP),IY
041306 18 09       3579  			JR      READ2
041308 CD 37 18 04 3580  READ1:			CALL    FETCHS
04130C E5          3581  			PUSH    HL
04130D CD 2A 16 04 3582  			CALL    STACCS
041311 E1          3583  READ2:			POP     HL
041312 22 31 4D 04 3584  			LD      (DATPTR),HL
041316 CD 70 0A 04 3585  			CALL    NXT
04131A FE 2C       3586  			CP      ','
04131C C2 96 0B 04 3587  			JP      NZ,XEQ
041320 FD 23       3588  			INC     IY
041322 CD 70 0A 04 3589  			CALL    NXT
041326 18 B8       3590  			JR      READ0
041328             3591  ;
041328 3E DC       3592  GETDAT:			LD      A,DATA_EX_
04132A CD 78 18 04 3593  			CALL    SEARCH_EX
04132E 23          3594  			INC     HL
04132F D0          3595  			RET     NC
041330 3E 2A       3596  			LD      A,42
041332 C3 90 37 04 3597  ERROR4:			JP      ERROR_           ;"Out of DATA"
041336             3598  
041336             3599  ; IF expr statement
041336             3600  ; IF expr THEN statement [ELSE statement]
041336             3601  ; IF expr THEN line [ELSE line]
041336             3602  ;
041336 CD 0A 03 04 3603  IF_:			CALL    EXPRI
04133A CD DF 08 04 3604  			CALL    TEST
04133E 28 19       3605  			JR      Z,IFNOT         ;FALSE
041340 FD 7E 00    3606  			LD      A,(IY)
041343 FE 8C       3607  			CP      THEN_EX_
041345 C2 96 0B 04 3608  			JP      NZ,XEQ
041349 FD 23       3609  			INC     IY              ;SKIP "THEN"
04134B CD 70 0A 04 3610  IF1:			CALL    NXT
04134F FE 8D       3611  			CP      LINO_EX
041351 C2 96 0B 04 3612  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
041355 C3 2B 0F 04 3613  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041359 FD 7E 00    3614  IFNOT:			LD      A,(IY)
04135C FE 0D       3615  			CP      CR
04135E FD 23       3616  			INC     IY
041360 CA 92 0B 04 3617  			JP      Z,XEQ0          ;END OF LINE
041364 FE 8B       3618  			CP      ELSE_EX_
041366 20 F1       3619  			JR      NZ,IFNOT
041368 18 E1       3620  			JR      IF1
04136A             3621  
04136A             3622  ; CLS
04136A             3623  ;
04136A CD 02 44 04 3624  CLS:		CALL    CLRSCN
04136E AF          3625  			XOR     A
04136F 32 3D 4D 04 3626  			LD      (COUNT),A
041373 C3 96 0B 04 3627  			JP      XEQ
041377             3628  
041377             3629  ; STOP
041377             3630  ;
041377 CD C0 3D 04 3631  STOP:			CALL    TELL
04137B 0D          3632  			DB	CR
04137C 0A          3633  			DB	LF
04137D FA          3634  			DB	TSTOP
04137E 00          3635  			DB	0
04137F CD DE 39 04 3636  			CALL    SETLIN          ;FIND CURRENT LINE
041383 CD 12 3A 04 3637  			CALL    SAYLN
041387 CD 77 39 04 3638  			CALL    CRLF
04138B C3 B0 30 04 3639  			JP      CLOOP
04138F             3640  
04138F             3641  ; REPORT
04138F             3642  ;
04138F CD B2 3D 04 3643  REPOR:			CALL    REPORT
041393 C3 96 0B 04 3644  			JP      XEQ
041397             3645  
041397             3646  ; CLEAR
041397             3647  ;
041397 CD A6 38 04 3648  CLR:			CALL    CLEAR
04139B 2A 14 4D 04 3649  			LD      HL,(PAGE_)
04139F 18 19       3650  			JR      RESTR1
0413A1             3651  
0413A1             3652  ; RESTORE [line]
0413A1             3653  ;
0413A1 2A 14 4D 04 3654  RESTOR_EX:			LD      HL,(PAGE_)
0413A5 CD A4 17 04 3655  			CALL    TERMQ
0413A9 28 0F       3656  			JR      Z,RESTR1
0413AB CD 25 03 04 3657  			CALL    ITEMI
0413AF D9          3658  			EXX
0413B0 CD BF 39 04 3659  			CALL    FINDL           ;SEARCH FOR LINE
0413B4 3E 29       3660  			LD      A,41
0413B6 C2 32 13 04 3661  			JP      NZ,ERROR4       ;"No such line"
0413BA 3E DC       3662  RESTR1:			LD      A,DATA_EX_
0413BC CD 78 18 04 3663  			CALL    SEARCH_EX
0413C0 22 31 4D 04 3664  			LD      (DATPTR),HL
0413C4 C3 96 0B 04 3665  			JP      XEQ
0413C8             3666  
0413C8             3667  ; PTR#channel=expr
0413C8             3668  ; PAGE=expr
0413C8             3669  ; TIME=expr
0413C8             3670  ; LOMEM=expr
0413C8             3671  ; HIMEM=expr
0413C8             3672  ;
0413C8 CD B0 18 04 3673  PTR_EX:			CALL    CHANEL
0413CC CD BA 17 04 3674  			CALL    EQUALS
0413D0 7B          3675  			LD      A,E
0413D1 F5          3676  			PUSH    AF
0413D2 CD 0A 03 04 3677  			CALL    EXPRI
0413D6 E5          3678  			PUSH    HL
0413D7 D9          3679  			EXX
0413D8 D1          3680  			POP     DE
0413D9 F1          3681  			POP     AF
0413DA CD A8 43 04 3682  			CALL    PUTPTR
0413DE C3 96 0B 04 3683  			JP      XEQ
0413E2             3684  ;
0413E2 CD BA 17 04 3685  PAGEV_EX:			CALL    EQUALS
0413E6 CD 0A 03 04 3686  			CALL    EXPRI
0413EA D9          3687  			EXX
0413EB 2E 00       3688  			LD      L,0
0413ED 22 14 4D 04 3689  			LD      (PAGE_),HL
0413F1 C3 96 0B 04 3690  			JP      XEQ
0413F5             3691  ;
0413F5 FE 24       3692  TIMEV_EX:			CP      '$'
0413F7 28 13       3693  			JR      Z,TIMEVS_EX
0413F9 CD BA 17 04 3694  			CALL    EQUALS
0413FD CD 0A 03 04 3695  			CALL    EXPRI
041401 E5          3696  			PUSH    HL
041402 D9          3697  			EXX
041403 D1          3698  			POP     DE
041404 CD C7 3E 04 3699  			CALL    PUTIME
041408 C3 96 0B 04 3700  			JP      XEQ
04140C             3701  ;
04140C FD 23       3702  TIMEVS_EX:			INC     IY              ;SKIP '$'
04140E CD BA 17 04 3703  			CALL    EQUALS
041412 CD 15 03 04 3704  			CALL    EXPRS
041416 CD 7C 49 04 3705  			CALL    PUTIMS
04141A C3 96 0B 04 3706  			JP      XEQ
04141E             3707  ;
04141E CD BA 17 04 3708  LOMEMV_EX:			CALL    EQUALS
041422 CD 0A 03 04 3709  			CALL    EXPRI
041426 CD A6 38 04 3710  			CALL    CLEAR
04142A D9          3711  			EXX
04142B 22 1A 4D 04 3712  			LD      (LOMEM),HL
04142F 22 1D 4D 04 3713  			LD      (FREE),HL
041433 C3 96 0B 04 3714  			JP      XEQ
041437             3715  ;
041437 CD BA 17 04 3716  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
04143B CD 0A 03 04 3717  			CALL    EXPRI			; Load the expression into registers
04143F 7D          3718  			LD	A,L			;  A: The MSB of the 24-bit value
041440 D9          3719  			EXX				; HL: The LSW of the 24-bit value
041441 22 4A 4D 04 3720  			LD	(R0),HL
041445 32 4C 4D 04 3721  			LD	(R0+2),A
041449 2A 1D 4D 04 3722  			LD	HL,(FREE)
04144D 11 00 01 00 3723  			LD      DE,256
041451 19          3724  			ADD	HL,DE
041452 EB          3725  			EX	DE,HL			; DE: FREE + 256
041453 2A 4A 4D 04 3726  			LD	HL,(R0)			; HL: The passed expression
041457 AF          3727  			XOR     A
041458 ED 52       3728  			SBC     HL,DE
04145A 19          3729  			ADD     HL,DE			; Do a bounds check
04145B DA 90 37 04 3730  			JP      C,ERROR_         	; Throw the error: "No room"
04145F ED 5B 20 4D 3731  			LD      DE,(HIMEM)
       04          
041464 22 20 4D 04 3732  			LD      (HIMEM),HL
041468 EB          3733  			EX      DE,HL
041469 ED 72       3734  			SBC     HL,SP			; Adjust the stack
04146B C2 96 0B 04 3735  			JP      NZ,XEQ
04146F EB          3736  			EX      DE,HL
041470 F9          3737  			LD      SP,HL           	; Load the SP
041471 C3 96 0B 04 3738  			JP      XEQ
041475             3739  
041475             3740  ; WIDTH expr
041475             3741  ;
041475 CD 0A 03 04 3742  WIDTHV:			CALL    EXPRI
041479 D9          3743  			EXX
04147A 7D          3744  			LD      A,L
04147B 32 3E 4D 04 3745  			LD      (WIDTH),A
04147F C3 96 0B 04 3746  			JP      XEQ
041483             3747  
041483             3748  ; TRACE ON
041483             3749  ; TRACE OFF
041483             3750  ; TRACE line
041483             3751  ;
041483 FD 23       3752  TRACE_EX:			INC     IY
041485 21 00 00 00 3753  			LD      HL,0
041489 FE EE       3754  			CP      TON
04148B 28 0B       3755  			JR      Z,TRACE0
04148D FE 87       3756  			CP      OFF_
04148F 28 08       3757  			JR      Z,TRACE1
041491 FD 2B       3758  			DEC     IY
041493 CD 0A 03 04 3759  			CALL    EXPRI
041497 D9          3760  			EXX
041498 2B          3761  TRACE0:			DEC     HL
041499 22 26 4D 04 3762  TRACE1:			LD      (TRACEN),HL
04149D C3 96 0B 04 3763  			JP      XEQ
0414A1             3764  
0414A1             3765  ; VDU expr,expr;....
0414A1             3766  ;
0414A1 DD 21 00 4B 3767  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0414A6 DD E5       3768  VDU1:			PUSH	IX
0414A8 CD 0A 03 04 3769  			CALL    EXPRI			; Fetch the VDU character
0414AC DD E1       3770  			POP	IX
0414AE D9          3771  			EXX
0414AF DD 75 00    3772  			LD	(IX+0),L		; Write out the character to the buffer
0414B2 DD 23       3773  			INC	IX
0414B4 FD 7E 00    3774  			LD      A,(IY)			;  A: The separator character
0414B7 FE 2C       3775  			CP      ','			; Is it a comma?
0414B9 28 09       3776  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414BB FE 3B       3777  			CP      ';'			; Is it a semicolon?
0414BD 20 07       3778  			JR      NZ,VDU3			; No, so skip to the next expression
0414BF DD 74 00    3779  			LD	(IX+0),H		; Write out the high byte to the buffer
0414C2 DD 23       3780  			INC	IX
0414C4 FD 23       3781  VDU2:			INC     IY			; Skip to the next character
0414C6 CD A4 17 04 3782  VDU3:			CALL    TERMQ			; Skip past white space
0414CA 20 DA       3783  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414CC DD 7D       3784  			LD	A,IXL			;  A: Number of bytes to write out
0414CE B7          3785  			OR	A
0414CF 28 0B       3786  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D1 21 00 4B 04 3787  			LD	HL,BUFFER		; HL: Start of stream
0414D5 01 00 00 00 3788  			LD	BC,0
0414D9 4F          3789  			LD	C,A			; BC: Number of bytes to write out
0414DA 5B DF       3790  			RST.LIL	18h			; Output the buffer to MOS
0414DC C3 96 0B 04 3791  VDU4:			JP      XEQ
0414E0             3792  
0414E0             3793  ; CLOSE channel number
0414E0             3794  ;
0414E0 CD B0 18 04 3795  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414E4 CD 6C 43 04 3796  			CALL    OSSHUT			; Close the channel
0414E8 C3 96 0B 04 3797  			JP      XEQ
0414EC             3798  
0414EC             3799  ; BPUT channel,byte
0414EC             3800  ;
0414EC CD B0 18 04 3801  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414F0 D5          3802  			PUSH    DE			; DE: Channel number
0414F1 CD 22 0A 04 3803  			CALL    COMMA			; Skip to the next expression
0414F5 CD 0A 03 04 3804  			CALL    EXPRI           	; Feth the data
0414F9 D9          3805  			EXX
0414FA 7D          3806  			LD      A,L			; A: The byte to write
0414FB D1          3807  			POP     DE
0414FC CD 7C 43 04 3808  			CALL    OSBPUT			; Write the byte out
041500 C3 96 0B 04 3809  			JP      XEQ
041504             3810  
041504             3811  ; CALL address[,var[,var...]]
041504             3812  ;
041504             3813  ; Note that the parameter table differs from the Z80 version
041504             3814  ; Each entry now takes up 4 bytes, not 3, so the table is now:
041504             3815  ;  -1 byte:  Number of parameters
041504             3816  ; Then, for each parameter:
041504             3817  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
041504             3818  ;  -3 bytes: Parameter address
041504             3819  ;
041504             3820  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
041504             3821  ;
041504 CD 0A 03 04 3822  CALL_:			CALL    EXPRI           	; Fetch the address
041508 7D          3823  			LD	A,L			;  A: MSB of address
041509 D9          3824  			EXX
04150A 22 4A 4D 04 3825  			LD	(R0+0),HL		; HL: LSW of address
04150E 32 4C 4D 04 3826  			LD	(R0+2),A
041512 06 00       3827  			LD      B,0             	;  B: The parameter counter
041514 11 00 4B 04 3828  			LD      DE,BUFFER       	; DE: Vector
041518             3829  ;
041518 CD 70 0A 04 3830  CALL1:			CALL    NXT			; Skip whitespace
04151C FE 2C       3831  			CP      ','			; Check for comma
04151E 20 1B       3832  			JR      NZ,CALL2		; If no more parameters, then jump here
041520 FD 23       3833  			INC     IY			; Skip to the next character
041522 04          3834  			INC     B			; Increment the parameter count
041523 CD 70 0A 04 3835  			CALL    NXT			; Skip whitespace
041527 C5          3836  			PUSH    BC
041528 D5          3837  			PUSH    DE
041529 CD 8E 0C 04 3838  			CALL    VAR_
04152D D1          3839  			POP     DE
04152E C1          3840  			POP     BC
04152F 13          3841  			INC     DE
041530 12          3842  			LD      (DE),A			; Save the parameter type
041531 13          3843  			INC     DE
041532 EB          3844  			EX      DE,HL
041533 ED 1F       3845  			LD	(HL),DE			; Save the parameter address (3 bytes)
041535 23          3846  			INC	HL
041536 23          3847  			INC	HL
041537 23          3848  			INC	HL
041538 EB          3849  			EX      DE,HL
041539 18 DD       3850  			JR      CALL1
04153B             3851  ;
04153B 78          3852  CALL2:			LD      A,B
04153C 32 00 4B 04 3853  			LD      (BUFFER),A      	; Save the parameter count
041540 2A 4A 4D 04 3854  			LD	HL,(R0)			; HL: Address of the code
041544 CD 5E 15 04 3855  			CALL    USR1			; And call it
041548 C3 96 0B 04 3856  			JP      XEQ
04154C             3857  
04154C             3858  ; USR(address)
04154C             3859  ;
04154C CD 25 03 04 3860  USR:			CALL    ITEMI			; Evaluate the expression
041550 7D          3861  			LD	A,L			;  A: MSB of address
041551 D9          3862  			EXX
041552 22 4A 4D 04 3863  			LD	(R0+0),HL		; HL: LSW of address
041556 32 4C 4D 04 3864  			LD	(R0+2),A
04155A 2A 4A 4D 04 3865  			LD	HL,(R0)			; Get the 24-bit address in HL
04155E             3866  ;
04155E E5          3867  USR1:			PUSH    HL              	; Address on stack
04155F FD E3       3868  			EX      (SP),IY
041561 24          3869  			INC     H               	; Check for PAGE &00FFxx
041562 B4          3870  			OR	H
041563 21 CD 15 04 3871  			LD      HL,USR2         	; Return address
041567 E5          3872  			PUSH    HL
041568 DD 21 00 4C 3873  			LD      IX,STAVAR
       04          
04156D CC 32 43 04 3874  			CALL    Z,OSCALL        	; Intercept &00FFxx
041571             3875  ;
041571 DD 4E 18    3876  			LD      C, (IX+24)		; F%
041574 C5          3877  			PUSH    BC
041575             3878  ;
041575 DD 7E 08    3879  			LD	A, (IX+8)		; B% -> MSW
041578 32 4B 4D 04 3880  			LD	(R0+1), A
04157C DD 7E 09    3881  			LD	A, (IX+9)
04157F 32 4C 4D 04 3882  			LD	(R0+2), A
041583 DD 7E 0C    3883  			LD	A, (IX+12)		; C% -> LSB
041586 32 4A 4D 04 3884  			LD	(R0+0), A
04158A ED 4B 4A 4D 3885  			LD	BC, (R0)
       04          
04158F             3886  ;
04158F DD 7E 10    3887  			LD	A, (IX+16)		; D% -> MSW
041592 32 4B 4D 04 3888  			LD	(R0+1), A
041596 DD 7E 11    3889  			LD	A, (IX+17)
041599 32 4C 4D 04 3890  			LD	(R0+2), A
04159D DD 7E 14    3891  			LD	A, (IX+20)		; E% -> LSB
0415A0 32 4A 4D 04 3892  			LD	(R0+0), A
0415A4 ED 5B 4A 4D 3893  			LD	DE, (R0)
       04          
0415A9             3894  ;
0415A9 DD 7E 20    3895  			LD	A, (IX+32)		; H% -> MSW
0415AC 32 4B 4D 04 3896  			LD	(R0+1), A
0415B0 DD 7E 21    3897  			LD	A, (IX+33)
0415B3 32 4C 4D 04 3898  			LD	(R0+2), A
0415B7 DD 7E 30    3899  			LD	A, (IX+48)		; L% -> LSB
0415BA 32 4A 4D 04 3900  			LD	(R0+0), A
0415BE 2A 4A 4D 04 3901  			LD	HL, (R0)
0415C2             3902  ;
0415C2 F1          3903  			POP     AF			; F%
0415C3 DD 7E 04    3904  			LD      A, (IX+4)        	; A%
0415C6             3905  
0415C6 DD 21 00 4B 3906  			LD      IX,BUFFER
       04          
0415CB FD E9       3907  			JP      (IY)            	; Off to user routine
0415CD             3908  ;
0415CD FD E1       3909  USR2:			POP     IY
0415CF AF          3910  			XOR     A
0415D0 4F          3911  			LD      C,A
0415D1 C9          3912  			RET
0415D2             3913  
0415D2             3914  ; PUT port,data
0415D2             3915  ;
0415D2 CD 0A 03 04 3916  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415D6 D9          3917  			EXX
0415D7 E5          3918  			PUSH    HL
0415D8 CD 22 0A 04 3919  			CALL    COMMA
0415DC CD 0A 03 04 3920  			CALL    EXPRI           ;DATA
0415E0 D9          3921  			EXX
0415E1 C1          3922  			POP     BC
0415E2 ED 69       3923  			OUT     (C),L           ;OUTPUT TO PORT BC
0415E4 C3 96 0B 04 3924  			JP      XEQ
0415E8             3925  
0415E8             3926  ; SUBROUTINES -----------------------------------------------------------------
0415E8             3927  
0415E8             3928  ; ASSIGN - Assign a numeric value to a variable.
0415E8             3929  ; Outputs: NC,  Z - OK, numeric.
0415E8             3930  ;          NC, NZ - OK, string.
0415E8             3931  ;           C, NZ - illegal
0415E8             3932  ;
0415E8 CD 6A 3A 04 3933  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415EC D8          3934  			RET     C               	; Return with C if it is an illegal variable
0415ED C4 59 3A 04 3935  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415F1 B7          3936  			OR      A
0415F2 F8          3937  			RET     M               	; Return if type is string (81h)
0415F3 F5          3938  			PUSH    AF              	; It's a numeric type from this point on
0415F4 CD BA 17 04 3939  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415F8 E5          3940  			PUSH    HL
0415F9 CD 02 03 04 3941  			CALL    EXPRN
0415FD DD E1       3942  			POP     IX
0415FF F1          3943  			POP     AF
041600 CB 47       3944  STORE:			BIT     0,A
041602 28 13       3945  			JR      Z,STOREI
041604 BF          3946  			CP      A               	; Set the variable to 0
041605 DD 71 04    3947  STORE5:			LD      (IX+4),C
041608 D9          3948  STORE4:			EXX
041609 DD 75 00    3949  			LD      (IX+0),L
04160C DD 74 01    3950  			LD      (IX+1),H
04160F D9          3951  			EXX
041610 DD 75 02    3952  			LD      (IX+2),L
041613 DD 74 03    3953  			LD      (IX+3),H
041616 C9          3954  			RET
041617 F5          3955  STOREI:			PUSH    AF
041618 0C          3956  			INC     C               ;SPEED - & PRESERVE F'
041619 0D          3957  			DEC     C               ; WHEN CALLED BY FNEND0
04161A C4 62 06 04 3958  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
04161E F1          3959  			POP     AF
04161F FE 04       3960  			CP      4
041621 28 E5       3961  			JR      Z,STORE4
041623 BF          3962  			CP      A               ;SET ZERO
041624 D9          3963  STORE1:			EXX
041625 DD 75 00    3964  			LD      (IX+0),L
041628 D9          3965  			EXX
041629 C9          3966  			RET
04162A             3967  ;
04162A             3968  ; Copy a string from the string accumulator to variable storage on the stack
04162A             3969  ; Parameters:
04162A             3970  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
04162A             3971  ; - IX: Address of the variable storage on the stack
04162A             3972  ;
04162A 21 00 4A 04 3973  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
04162E             3974  ;
04162E             3975  ; Parameters:
04162E             3976  ; As above, but:
04162E             3977  ; - HL: Address of the string to be stored
04162E             3978  ; -  E: The string length
04162E             3979  ; NB:
04162E             3980  ; Strings are mutable
04162E             3981  ; Strings are stored in the following format in the variable:
04162E             3982  ; - Address of the next variable (3 bytes)
04162E             3983  ; - The rest of the variable name - this is zero terminated
04162E             3984  ; - Current string length (byte)
04162E             3985  ; - Maximum (original) string length (byte)
04162E             3986  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
04162E             3987  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
04162E             3988  ;
04162E 1F          3989  STORES:			RRA				; Rotate right to shift bit 0 into carry
04162F 30 5D       3990  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041631 E5          3991  			PUSH    HL			; Stack ACCS
041632             3992  ;
041632             3993  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
041632             3994  ;
041632 D9          3995  			EXX				; This block was a call to LOAD4
041633 DD 6E 00    3996  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
041636 DD 66 01    3997  			LD      H,(IX+1)		; The maximum original string length
041639 D9          3998  			EXX
04163A DD 27 02    3999  			LD	HL,(IX+2)		; Address of the string (24-bit)
04163D             4000  ;
04163D 7B          4001  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
04163E D9          4002  			EXX
04163F 6F          4003  			LD      L,A			; L': Length of string currently stored on the stack
041640 7C          4004  			LD      A,H             	; H': The maximum (original) string length
041641 D9          4005  			EXX
041642 BB          4006  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041643 30 17       4007  			JR      NC,STORS1       	; Yes there is, so skip the next bit
041645             4008  ;
041645             4009  ; At this point we're either initialising a new string or assigning more memory to an existing string
041645             4010  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
041645             4011  ; then the existing and new strings may both exist in memory.
041645             4012  ;
041645 D9          4013  			EXX
041646 65          4014  			LD      H,L			; H: Set the maximum string length to the string length
041647 D9          4015  			EXX
041648 E5          4016  			PUSH    HL
041649 01 00 00 00 4017  			LD	BC, 0
04164D 4F          4018  			LD      C,A			; BC: The maximum (original) string length
04164E 09          4019  			ADD     HL,BC			; Work out whether this is the last string in memory
04164F ED 4B 1D 4D 4020  			LD      BC,(FREE)
       04          
041654 ED 42       4021  			SBC     HL,BC			; Is string last?
041656 E1          4022  			POP     HL
041657 37          4023  			SCF
041658 28 02       4024  			JR      Z,STORS1
04165A             4025  			; LD	HL, BC			; HL=BC
04165A C5          4026  			push bc
04165B E1          4027  			pop hl
04165C             4028  ;
04165C             4029  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
04165C             4030  ; - H': The maximum (original) string length
04165C             4031  ; - L': The actual string length (must be less than H')
04165C             4032  ; - HL: Address of the string in memory
04165C             4033  ;
04165C D9          4034  STORS1:			EXX				; This block was a call to STORE4
04165D DD 75 00    4035  			LD      (IX+0),L		; The actual string length (must be less then H')
041660 DD 74 01    4036  			LD      (IX+1),H		; The maximum (original) string length
041663 D9          4037  			EXX
041664 DD 2F 02    4038  			LD	(IX+2),HL		; The pointer to the original string
041667             4039  ;
041667 01 00 00 00 4040  			LD	BC, 0
04166B 4B          4041  			LD      C,E			; BC: The new string length
04166C EB          4042  			EX      DE,HL
04166D E1          4043  			POP     HL
04166E 0D          4044  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
04166F 0C          4045  			INC     C			; check whether BC is 0 without affecting the carry flag
041670 C8          4046  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041671 ED B0       4047  			LDIR				; Replace the string in memory
041673 D0          4048  			RET     NC
041674 ED 53 1D 4D 4049  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
041679             4050  ;
041679             4051  ; Check whether the stack is full
041679             4052  ;
041679 E5          4053  CHECK:			PUSH    HL
04167A C5          4054  			PUSH	BC
04167B 2A 1D 4D 04 4055  			LD      HL,(FREE)		; HL: Address of first free space byte
04167F 01 00 01 00 4056  			LD	BC,100h			; BC: One page of memory
041683 09          4057  			ADD	HL,BC			; Add a page to FREE
041684 ED 72       4058  			SBC     HL,SP			; And subtract the current SP
041686 C1          4059  			POP	BC
041687 E1          4060  			POP     HL
041688 D8          4061  			RET     C			; The SP is not in the same page, so just return
041689 AF          4062  			XOR     A			; Otherwise
04168A C3 90 37 04 4063  			JP      ERROR_			; Throw error "No room"
04168E             4064  ;
04168E 01 00 00 00 4065  STORS3:			LD	BC,0
041692 4B          4066  			LD      C,E			; BC: String length
041693 DD E5       4067  			PUSH    IX
041695 D1          4068  			POP     DE			; DE: Destination
041696 AF          4069  			XOR     A			; Check if string length is 0
041697 B9          4070  			CP      C
041698 28 02       4071  			JR      Z,STORS5		; Yes, so don't copy
04169A ED B0       4072  			LDIR
04169C 3E 0D       4073  STORS5:			LD      A,CR			; Finally add the terminator
04169E 12          4074  			LD      (DE),A
04169F C9          4075  			RET
0416A0             4076  
0416A0             4077  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0416A0             4078  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0416A0             4079  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0416A0             4080  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0416A0             4081  ;    Inputs: DE addresses parameter list
0416A0             4082  ;            IY addresses dummy variable list
0416A0             4083  ;   Outputs: DE,IY updated
0416A0             4084  ;  Destroys: Everything
0416A0             4085  ;
0416A0 3E FF       4086  ARGUE:			LD      A,-1
0416A2 F5          4087  			PUSH    AF              	; Put marker on the stack
0416A3 FD 23       4088  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416A5 13          4089  			INC     DE
0416A6 D5          4090  			PUSH    DE
0416A7 CD 70 0A 04 4091  			CALL    NXT			; Skip any whitespace
0416AB CD 6A 3A 04 4092  			CALL    GETVAR			; Get the location of the variable in HL/IX
0416AF 38 3F       4093  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B1 C4 59 3A 04 4094  			CALL    NZ,PUTVAR
0416B5 D1          4095  			POP     DE
0416B6 E5          4096  			PUSH    HL              	; VARPTR
0416B7 B7          4097  			OR      A               	; Check the variable type
0416B8 F5          4098  			PUSH    AF
0416B9 D5          4099  			PUSH    DE
0416BA FD E3       4100  			EX      (SP),IY
0416BC FA D4 16 04 4101  			JP      M,ARGUE2        	; Jump here if it is a string
0416C0             4102  ;
0416C0 CD 02 03 04 4103  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416C4 FD E3       4104  			EX      (SP),IY
0416C6 D1          4105  			POP     DE
0416C7 F1          4106  			POP     AF
0416C8 D9          4107  			EXX
0416C9 E5          4108  			PUSH    HL
0416CA D9          4109  			EXX
0416CB E5          4110  			PUSH    HL
0416CC 47          4111  			LD      B,A
0416CD C5          4112  			PUSH    BC
0416CE CD 79 16 04 4113  			CALL    CHECK           	; Check room
0416D2 18 0F       4114  			JR      ARGUE4
0416D4             4115  ;
0416D4 CD 15 03 04 4116  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416D8 FD E3       4117  			EX      (SP),IY
0416DA D9          4118  			EXX
0416DB D1          4119  			POP     DE
0416DC D9          4120  			EXX
0416DD F1          4121  			POP     AF
0416DE CD B4 09 04 4122  			CALL    PUSHS
0416E2 D9          4123  			EXX
0416E3             4124  ;
0416E3 CD 70 0A 04 4125  ARGUE4:			CALL    NXT			; Skip whitespace
0416E7 FE 2C       4126  			CP      ','			; Check to see if the next value is a comma
0416E9 20 0B       4127  			JR      NZ,ARGUE5		; No, so jump here
0416EB 1A          4128  			LD      A,(DE)
0416EC FE 2C       4129  			CP      ','			; Are there any more arguments?
0416EE 28 B3       4130  			JR      Z,ARGUE1        	; Yes, so loop
0416F0             4131  ;
0416F0 3E 1F       4132  ARGERR:			LD      A,31
0416F2 C3 90 37 04 4133  			JP      ERROR_           	; Throw error "Arguments"
0416F6             4134  ;
0416F6 CD 2F 0A 04 4135  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416FA 1A          4136  			LD      A,(DE)
0416FB FE 29       4137  			CP      ')'
0416FD 20 F1       4138  			JR      NZ,ARGERR
0416FF 13          4139  			INC     DE
041700 D9          4140  			EXX
041701 C1          4141  ARGUE6:			POP     BC
041702 78          4142  			LD      A,B
041703 3C          4143  			INC     A
041704 D9          4144  			EXX
041705 C8          4145  			RET     Z               	; Marker popped
041706 D9          4146  			EXX
041707 3D          4147  			DEC     A
041708 FA 18 17 04 4148  			JP      M,ARGUE7        	; If it is a string, then jump here
04170C E1          4149  			POP     HL
04170D D9          4150  			EXX
04170E E1          4151  			POP     HL
04170F D9          4152  			EXX
041710 DD E1       4153  			POP     IX
041712 CD 00 16 04 4154  			CALL    STORE	           	; Write to dummy variable
041716 18 E9       4155  			JR      ARGUE6
041718             4156  ;
041718 CD DE 09 04 4157  ARGUE7:			CALL    POPS
04171C DD E1       4158  			POP     IX
04171E CD 2A 16 04 4159  			CALL    STACCS
041722 18 DD       4160  			JR      ARGUE6
041724             4161  
041724             4162  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
041724             4163  ;   OF A FUNCTION OR PROCEDURE.
041724             4164  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
041724             4165  ;    Inputs: IY is parameters pointer
041724             4166  ;   Outputs: IY updated
041724             4167  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
041724             4168  ;
041724 D1          4169  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
041725             4170  ;
041725 FD 23       4171  SAVLO1:			INC     IY              	; Bump past '(' or ','
041727 CD 70 0A 04 4172  			CALL    NXT			; And also any whitespace
04172B D5          4173  			PUSH    DE			; Push the return address back onto the stack
04172C D9          4174  			EXX
04172D C5          4175  			PUSH    BC
04172E D5          4176  			PUSH    DE
04172F E5          4177  			PUSH    HL
041730 D9          4178  			EXX
041731 CD 8E 0C 04 4179  			CALL    VAR_             	; Dummy variable
041735 D9          4180  			EXX
041736 E1          4181  			POP     HL
041737 D1          4182  			POP     DE
041738 C1          4183  			POP     BC
041739 D9          4184  			EXX
04173A D1          4185  			POP     DE
04173B B7          4186  			OR      A               	; Check the variable type
04173C FA 4F 17 04 4187  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041740 D9          4188  			EXX
041741 E5          4189  			PUSH    HL              	; Save H'L'
041742 D9          4190  			EXX
041743 47          4191  			LD      B,A             	;  B: Variable type
041744 CD 16 04 04 4192  			CALL    LOADN
041748 D9          4193  			EXX
041749 E3          4194  			EX      (SP),HL
04174A D9          4195  			EXX
04174B E5          4196  			PUSH    HL
04174C C5          4197  			PUSH    BC
04174D 18 2D       4198  			JR      SAVLO4
04174F             4199  ;
04174F F5          4200  SAVLO2:			PUSH    AF              	; Save the type (string)
041750 D5          4201  			PUSH    DE
041751 D9          4202  			EXX
041752 E5          4203  			PUSH    HL
041753 D9          4204  			EXX
041754 CD A0 04 04 4205  			CALL    LOADS
041758 D9          4206  			EXX
041759 E1          4207  			POP     HL
04175A D9          4208  			EXX
04175B 01 00 00 00 4209  			LD	BC,0
04175F 4B          4210  			LD      C,E			; BC: String length
041760 D1          4211  			POP     DE
041761 CD 79 16 04 4212  			CALL    CHECK			; Check if there is space on the stack
041765 F1          4213  			POP     AF              	; Level stack
041766 21 00 00 00 4214  			LD      HL,0
04176A ED 42       4215  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
04176C 39          4216  			ADD     HL,SP			; Make space for the string on the stack
04176D F9          4217  			LD      SP,HL
04176E 47          4218  			LD      B,A             	;  B: Variable type
04176F C5          4219  			PUSH    BC
041770 28 0A       4220  			JR      Z,SAVLO4
041772 D5          4221  			PUSH    DE
041773 11 00 4A 04 4222  			LD      DE,ACCS
041777 EB          4223  			EX      DE,HL
041778 45          4224  			LD      B,L
041779 ED B0       4225  			LDIR                    	; Save the string onto the stack
04177B D1          4226  			POP     DE
04177C             4227  ;
04177C DD E5       4228  SAVLO4:			PUSH    IX			; VARPTR
04177E CD 82 17 04 4229  			CALL    SAVLO5
041782             4230  LOCCHK:			EQU     $
041782 CD 79 16 04 4231  SAVLO5:			CALL    CHECK
041786 CD 70 0A 04 4232  			CALL    NXT
04178A FE 2C       4233  			CP      ','             	; Are there any more local variables?
04178C 28 97       4234  			JR      Z,SAVLO1		; Yes, so loop
04178E EB          4235  			EX      DE,HL			; DE -> HL: The return address
04178F E9          4236  			JP      (HL)            	; And effectvely return
041790             4237  ;
041790 FD 7E 00    4238  DELIM:			LD      A,(IY)          	; Assembler delimiter
041793 FE 20       4239  			CP      ' '
041795 C8          4240  			RET     Z
041796 FE 2C       4241  			CP      ','
041798 C8          4242  			RET     Z
041799 FE 29       4243  			CP      ')'
04179B C8          4244  			RET     Z
04179C FE 3B       4245  TERM:			CP      ';'             	; Assembler terminator
04179E C8          4246  			RET     Z
04179F FE 5C       4247  			CP      '\'
0417A1 C8          4248  			RET     Z
0417A2 18 07       4249  			JR      TERM0
0417A4             4250  ;
0417A4 CD 70 0A 04 4251  TERMQ:			CALL    NXT
0417A8 FE 8B       4252  			CP      ELSE_EX_
0417AA D0          4253  			RET     NC
0417AB FE 3A       4254  TERM0:			CP      ':'             	; Assembler seperator
0417AD D0          4255  			RET     NC
0417AE FE 0D       4256  			CP      CR
0417B0 C9          4257  			RET
0417B1             4258  ;
0417B1 CD A4 17 04 4259  SPAN:			CALL    TERMQ
0417B5 C8          4260  			RET     Z
0417B6 FD 23       4261  			INC     IY
0417B8 18 F7       4262  			JR      SPAN
0417BA             4263  ;
0417BA             4264  ; This snippet is used to check whether an expression is followed by an '=' symbol
0417BA             4265  ;
0417BA CD 70 0A 04 4266  EQUALS:			CALL    NXT			; Skip whitespace
0417BE FD 23       4267  			INC     IY			; Skip past the character in question
0417C0 FE 3D       4268  			CP      '='			; Is it '='
0417C2 C8          4269  			RET     Z			; Yes, so return
0417C3 3E 04       4270  			LD      A,4			; Otherwise
0417C5 C3 90 37 04 4271  			JP      ERROR_           	; Throw error "Mistake"
0417C9             4272  ;
0417C9 FE 8A       4273  FORMAT:			CP      TAB
0417CB 28 0D       4274  			JR      Z,DOTAB
0417CD FE 89       4275  			CP      SPC
0417CF 28 40       4276  			JR      Z,DOSPC
0417D1 FE 27       4277  			CP      '''
0417D3 C0          4278  			RET     NZ
0417D4 CD 77 39 04 4279  			CALL    CRLF
0417D8 AF          4280  			XOR     A
0417D9 C9          4281  			RET
0417DA             4282  ;
0417DA C5          4283  DOTAB:			PUSH    BC
0417DB CD 0A 03 04 4284  			CALL    EXPRI
0417DF D9          4285  			EXX
0417E0 C1          4286  			POP     BC
0417E1 FD 7E 00    4287  			LD      A,(IY)
0417E4 FE 2C       4288  			CP      ','
0417E6 28 14       4289  			JR      Z,DOTAB1
0417E8 CD 2F 0A 04 4290  			CALL    BRAKET
0417EC 7D          4291  			LD      A,L
0417ED 21 3D 4D 04 4292  TABIT:			LD      HL,COUNT
0417F1 BE          4293  			CP      (HL)
0417F2 C8          4294  			RET     Z
0417F3 F5          4295  			PUSH    AF
0417F4 DC 77 39 04 4296  			CALL    C,CRLF
0417F8 F1          4297  			POP     AF
0417F9 96          4298  			SUB     (HL)
0417FA 18 1D       4299  			JR      FILL
0417FC FD 23       4300  DOTAB1:			INC     IY
0417FE C5          4301  			PUSH    BC
0417FF E5          4302  			PUSH    HL
041800 CD 0A 03 04 4303  			CALL    EXPRI
041804 D9          4304  			EXX
041805 D1          4305  			POP     DE
041806 C1          4306  			POP     BC
041807 CD 2F 0A 04 4307  			CALL    BRAKET
04180B CD F1 3E 04 4308  			CALL    PUTCSR
04180F AF          4309  			XOR     A
041810 C9          4310  			RET
041811             4311  ;
041811 C5          4312  DOSPC:			PUSH    BC
041812 CD 25 03 04 4313  			CALL    ITEMI
041816 D9          4314  			EXX
041817 7D          4315  			LD      A,L
041818 C1          4316  			POP     BC
041819 B7          4317  FILL:			OR      A
04181A C8          4318  			RET     Z
04181B C5          4319  			PUSH    BC
04181C 47          4320  			LD      B,A
04181D 3E 20       4321  FILL1:			LD      A,' '
04181F CD 7F 39 04 4322  			CALL    OUTCHR
041823 10 F8       4323  			DJNZ    FILL1
041825 C1          4324  			POP     BC
041826 AF          4325  			XOR     A
041827 C9          4326  			RET
041828             4327  ;
041828 21 00 4A 04 4328  PTEXT:			LD      HL,ACCS
04182C 1C          4329  			INC     E
04182D 1D          4330  PTEXT1:			DEC     E
04182E C8          4331  			RET     Z
04182F 7E          4332  			LD      A,(HL)
041830 23          4333  			INC     HL
041831 CD 7F 39 04 4334  			CALL    OUTCHR
041835 18 F6       4335  			JR      PTEXT1
041837             4336  ;
041837 F5          4337  FETCHS:			PUSH    AF
041838 C5          4338  			PUSH    BC
041839 E5          4339  			PUSH    HL
04183A FD E3       4340  			EX      (SP),IY
04183C CD 57 18 04 4341  			CALL    XTRACT
041840 CD 70 0A 04 4342  			CALL    NXT
041844 FD E3       4343  			EX      (SP),IY
041846 E1          4344  			POP     HL
041847 C1          4345  			POP     BC
041848 F1          4346  			POP     AF
041849 C9          4347  			RET
04184A             4348  ;
04184A 11 00 4A 04 4349  LINES:			LD      DE,ACCS
04184E 7E          4350  LINE1S:			LD      A,(HL)
04184F 12          4351  			LD      (DE),A
041850 FE 0D       4352  			CP      CR
041852 C8          4353  			RET     Z
041853 23          4354  			INC     HL
041854 1C          4355  			INC     E
041855 18 F7       4356  			JR      LINE1S
041857             4357  ;
041857 CD 70 0A 04 4358  XTRACT:			CALL    NXT
04185B FE 22       4359  			CP      '"'
04185D FD 23       4360  			INC     IY
04185F CA 67 04 04 4361  			JP      Z,CONS
041863 FD 2B       4362  			DEC     IY
041865 11 00 4A 04 4363  			LD      DE,ACCS
041869 FD 7E 00    4364  XTRAC1:			LD      A,(IY)
04186C 12          4365  			LD      (DE),A
04186D FE 2C       4366  			CP      ','
04186F C8          4367  			RET     Z
041870 FE 0D       4368  			CP      CR
041872 C8          4369  			RET     Z
041873 FD 23       4370  			INC     IY
041875 1C          4371  			INC     E
041876 18 F1       4372  			JR      XTRAC1
041878             4373  
041878             4374  ; Search for a token at the start of a program line
041878             4375  ; - HL: Pointer to the start of a tokenised line in the program area
041878             4376  ; Returns:
041878             4377  ; - HL: Pointer to the
041878             4378  ; -  F: Carry set if not found
041878             4379  ; Corrupts:
041878             4380  ; - BC
041878             4381  ;
041878 01 00 00 00 4382  SEARCH_EX:			LD      BC,0			; Clear BC
04187C             4383  ;
04187C 4E          4384  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
04187D 0C          4385  			INC     C			; Check for 0, i.e. end of program marker
04187E 0D          4386  			DEC     C
04187F 28 0B       4387  			JR      Z,SRCH2_EX         	; Not found the token, so end
041881 23          4388  			INC     HL			; Skip the line length and line number
041882 23          4389  			INC     HL
041883 23          4390  			INC     HL
041884 BE          4391  			CP      (HL)			; Compare with the token
041885 C8          4392  			RET     Z			; Found it, so return with carry not set
041886 0D          4393  			DEC     C			; Skip to the next line
041887 0D          4394  			DEC     C
041888 0D          4395  			DEC     C
041889 09          4396  			ADD     HL,BC
04188A 18 F0       4397  			JR      SRCH1_EX			; Rinse, lather and repeat
04188C             4398  ;
04188C 2B          4399  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
04188D 37          4400  			SCF				; And set the carry flag
04188E C9          4401  			RET
04188F             4402  
04188F             4403  ; Multiply by 4 or 5
04188F             4404  ; This function is used to allocate space for dimensioned variables
04188F             4405  ; This is a 24-bit operation
04188F             4406  ; - DE: Number to multiple
04188F             4407  ; -  A: 04h (Integer) - takes up 4 bytes
04188F             4408  ;       05h (Float)   - takes up 5 bytes
04188F             4409  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
04188F             4410  ; Returns:
04188F             4411  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
04188F             4412  ; -  F: Carry if overflow
04188F             4413  ; Corrupts:
04188F             4414  ; - HL
04188F FE 04       4415  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041891             4416  			; LD	HL,DE
041891 D5          4417  			push de
041892 E1          4418  			pop hl
041893 29          4419  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
041894 D8          4420  			RET     C			; Exit if overflow
041895 29          4421  			ADD     HL,HL			; Multiply by 2 again
041896 D8          4422  			RET     C			; Exit if overflow
041897 EB          4423  			EX      DE,HL			; DE: Product
041898 C8          4424  			RET     Z			; Exit if A = 4
041899 19          4425  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
04189A EB          4426  			EX      DE,HL			; DE: Product
04189B C9          4427  			RET
04189C             4428  
04189C             4429  ; 16-bit unsigned multiply
04189C             4430  ; - HL: Operand 1
04189C             4431  ; - BC: Operand 2
04189C             4432  ; Returns:
04189C             4433  ; - HL: Result
04189C             4434  ; -  F: C if overflow
04189C             4435  ;
04189C C5          4436  MUL16:			PUSH	BC
04189D 51          4437  			LD	D, C			; Set up the registers for the multiplies
04189E 5D          4438  			LD	E, L
04189F 69          4439  			LD	L, C
0418A0 4B          4440  			LD	C, E
0418A1 ED 6C       4441  			MLT	HL			; HL = H * C (*256)
0418A3 ED 5C       4442  			MLT	DE			; DE = L * C
0418A5 ED 4C       4443  			MLT	BC			; BC = B * L (*256)
0418A7 09          4444  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418A8 C1          4445  			POP	BC
0418A9 AF          4446  			XOR	A
0418AA 9C          4447  			SBC	H			; If H is not zero then it's an overflow
0418AB D8          4448  			RET	C
0418AC 65          4449  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418AD 6F          4450  			LD	L, A
0418AE 19          4451  			ADD	HL, DE
0418AF C9          4452  			RET
0418B0             4453  ;
0418B0 CD 70 0A 04 4454  CHANEL:			CALL    NXT			; Skip whitespace
0418B4 FE 23       4455  			CP      '#'			; Check for the '#' symbol
0418B6 3E 2D       4456  			LD      A,45
0418B8 C2 90 37 04 4457  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418BC FD 23       4458  CHNL:			INC     IY             		; Bump past the '#'
0418BE CD 25 03 04 4459  			CALL    ITEMI			; Get the channel number
0418C2 D9          4460  			EXX
0418C3 EB          4461  			EX      DE,HL			; DE: The channel number
0418C4 C9          4462  			RET
0418C5             4463  
0418C5             4464  ; ASSEMBLER -------------------------------------------------------------------
0418C5             4465  
0418C5             4466  ; Language independant control section:
0418C5             4467  ;  Outputs: A=delimiter, carry set if syntax error.
0418C5             4468  ;
0418C5 CD E5 1D 04 4469  ASSEM:			CALL    SKIP
0418C9 FD 23       4470  			INC     IY
0418CB FE 3A       4471  			CP      ':'
0418CD 28 F6       4472  			JR      Z,ASSEM
0418CF FE 5D       4473  			CP      ']'
0418D1 C8          4474  			RET     Z
0418D2 FE 0D       4475  			CP      CR
0418D4 C8          4476  			RET     Z
0418D5 FD 2B       4477  			DEC     IY
0418D7 DD 2A 40 30 4478  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       11          
0418DC 21 40 4D 04 4479  			LD      HL,LISTON
0418E0 CB 76       4480  			BIT     6,(HL)
0418E2 28 05       4481  			JR      Z,ASSEM0
0418E4 DD 2A 3C 30 4482  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       11          
0418E9 DD E5       4483  ASSEM0:			PUSH    IX
0418EB FD E5       4484  			PUSH    IY
0418ED CD 9D 19 04 4485  			CALL    ASMB
0418F1 C1          4486  			POP     BC
0418F2 D1          4487  			POP     DE
0418F3 D8          4488  			RET     C
0418F4 CD E5 1D 04 4489  			CALL    SKIP
0418F8 37          4490  			SCF
0418F9 C0          4491  			RET     NZ
0418FA FD 2B       4492  			DEC     IY
0418FC FD 23       4493  ASSEM3:			INC     IY
0418FE FD 7E 00    4494  			LD      A,(IY)
041901 CD AB 17 04 4495  			CALL    TERM0
041905 20 F5       4496  			JR      NZ,ASSEM3
041907 3A 40 4D 04 4497  			LD      A,(LISTON)
04190B DD E5       4498  			PUSH    IX
04190D E1          4499  			POP     HL
04190E B7          4500  			OR      A
04190F ED 52       4501  			SBC     HL,DE
041911 EB          4502  			EX      DE,HL           	; DE: Number of bytes
041912 E5          4503  			PUSH    HL
041913 2A 40 30 11 4504  			LD      HL,(PC)
041917 E5          4505  			PUSH    HL
041918 19          4506  			ADD     HL,DE
041919 22 40 30 11 4507  			LD      (PC),HL         	; Update PC
04191D CB 77       4508  			BIT     6,A
04191F 28 09       4509  			JR      Z,ASSEM5
041921 2A 3C 30 11 4510  			LD      HL,(OC)
041925 19          4511  			ADD     HL,DE
041926 22 3C 30 11 4512  			LD      (OC),HL         	; Update OC
04192A E1          4513  ASSEM5:			POP     HL              	; Old PC
04192B DD E1       4514  			POP     IX              	; Code here
04192D CB 67       4515  			BIT     4,A
04192F 28 94       4516  			JR      Z,ASSEM
041931 22 4A 4D 04 4517  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
041935 3A 4C 4D 04 4518  			LD	A,(R0+2)		; Print out the address
041939 CD 87 19 04 4519  			CALL	HEX_EX
04193D 7C          4520  			LD      A,H
04193E CD 87 19 04 4521  			CALL    HEX_EX
041942 7D          4522  			LD      A,L
041943 CD 7F 19 04 4523  			CALL    HEXSP
041947 AF          4524  			XOR     A
041948 BB          4525  			CP      E
041949 28 18       4526  			JR      Z,ASSEM2
04194B             4527  ;
04194B 3A 3D 4D 04 4528  ASSEM1:			LD      A,(COUNT)
04194F FE 14       4529  			CP      20
041951 3E 07       4530  			LD      A,7
041953 D4 ED 17 04 4531  			CALL    NC,TABIT        	; Next line
041957 DD 7E 00    4532  			LD      A,(IX)
04195A CD 7F 19 04 4533  			CALL    HEXSP
04195E DD 23       4534  			INC     IX
041960 1D          4535  			DEC     E
041961 20 E8       4536  			JR      NZ,ASSEM1
041963             4537  ;
041963 3E 16       4538  ASSEM2:			LD      A,22			; Tab to the disassembly field
041965 CD ED 17 04 4539  			CALL    TABIT
041969 FD E5       4540  			PUSH    IY
04196B E1          4541  			POP     HL
04196C ED 42       4542  			SBC     HL,BC
04196E 0A          4543  ASSEM4:			LD      A,(BC)
04196F CD 9C 39 04 4544  			CALL    OUT_
041973 03          4545  			INC     BC
041974 2D          4546  			DEC     L
041975 20 F7       4547  			JR      NZ,ASSEM4
041977 CD 77 39 04 4548  			CALL    CRLF
04197B C3 C5 18 04 4549  			JP      ASSEM
04197F             4550  ;
04197F CD 87 19 04 4551  HEXSP:			CALL    HEX_EX
041983 3E 20       4552  			LD      A,' '
041985 18 12       4553  			JR      OUTCH1
041987 F5          4554  HEX_EX:			PUSH    AF
041988 0F          4555  			RRCA
041989 0F          4556  			RRCA
04198A 0F          4557  			RRCA
04198B 0F          4558  			RRCA
04198C CD 91 19 04 4559  			CALL    HEXOUT
041990 F1          4560  			POP     AF
041991 E6 0F       4561  HEXOUT:			AND     0FH
041993 C6 90       4562  			ADD     A,90H
041995 27          4563  			DAA
041996 CE 40       4564  			ADC     A,40H
041998 27          4565  			DAA
041999 C3 9C 39 04 4566  OUTCH1:			JP      OUT_
04199D             4567  
04199D             4568  ; Processor Specific Translation Section:
04199D             4569  ;
04199D             4570  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
04199D             4571  ;                 C: Opcode beig built
04199D             4572  ;                 D: Flags
04199D             4573  ;			Bit 7: Set to 1 if the instruction uses long addressing
04199D             4574  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
04199D             4575  ;                 E: Offset from IX or IY
04199D             4576  ;                HL: Numeric operand value
04199D             4577  ;                IX: Code destination pointer
04199D             4578  ;                IY: Source text pointer
04199D             4579  ;    Inputs: A = initial character
04199D             4580  ;   Outputs: Carry set if syntax error.
04199D             4581  ;
04199D FE 2E       4582  ASMB:			CP      '.'			; Check for a dot; this indicates a label
04199F 20 1F       4583  			JR      NZ,ASMB1		; No, so just process the instruction
0419A1 FD 23       4584  			INC     IY			; Skip past the dot to the label name
0419A3 DD E5       4585  			PUSH    IX			; Store the code destination pointer
0419A5 CD 8E 0C 04 4586  			CALL    VAR_			; Create a variable
0419A9 F5          4587  			PUSH    AF
0419AA CD 93 09 04 4588  			CALL    ZERO			; Zero it
0419AE 3A 42 30 11 4589  			LD	A,(PC+2)
0419B2 6F          4590  			LD	L,A			; The MSB of the 24-bit address
0419B3 D9          4591  			EXX
0419B4 2A 40 30 11 4592  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419B8 D9          4593  			EXX
0419B9 F1          4594  			POP     AF
0419BA CD 00 16 04 4595  			CALL    STORE			; Store the program counter
0419BE DD E1       4596  			POP     IX			; Restore the code destination pointer
0419C0             4597  ;
0419C0 3A 40 4D 04 4598  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419C4 E6 80       4599  			AND	80H
0419C6 57          4600  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419C7 CD E5 1D 04 4601  			CALL    SKIP			; Skip any whitespace
0419CB C8          4602  			RET     Z			; And return if there is nothing further to process
0419CC FE D6       4603  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419CE 0E C4       4604  			LD      C,0C4H			;  A: The base operand
0419D0 FD 23       4605  			INC     IY			; Skip past the token
0419D2 CA 1A 1B 04 4606  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419D6 FD 2B       4607  			DEC     IY			; Skip back, as we're not doing the above at this point
0419D8 21 FC 1D 04 4608  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419DC CD 94 1D 04 4609  			CALL    FIND			; Find the opcode
0419E0 D8          4610  			RET     C			; If not found, then return; carry indicates an error condition
0419E1 48          4611  			LD      C,B     		;  C: A copy of the opcode
0419E2             4612  ;
0419E2             4613  ; GROUP 0: Trivial cases requiring no computation
0419E2             4614  ; GROUP 1: As Group 0, but with "ED" prefix
0419E2             4615  ;
0419E2 D6 44       4616  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419E4 30 08       4617  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419E6 FE CB       4618  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419E8 D4 ED 1C 04 4619  			CALL    NC,ED			; Needs to be prefixed with ED
0419EC 18 76       4620  			JR      BYTE0			; Then write the opcode byte
0419EE             4621  ;
0419EE             4622  ; GROUP 2: BIT, RES, SET
0419EE             4623  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419EE             4624  ;
0419EE D6 0A       4625  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419F0 30 12       4626  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419F2 FE F9       4627  			CP      3-10			;
0419F4 DC 82 1D 04 4628  			CALL    C,BIT_
0419F8 D8          4629  			RET     C
0419F9 CD 53 1D 04 4630  			CALL    REGLO
0419FD D8          4631  			RET     C
0419FE CD F1 1C 04 4632  			CALL    CB
041A02 18 60       4633  			JR      BYTE0
041A04             4634  ;
041A04             4635  ; GROUP 4 - PUSH, POP, EX (SP)
041A04             4636  ;
041A04 D6 03       4637  GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A06 30 07       4638  			JR      NC,GROUP05		; If not in that range, then check GROUP5
041A08 CD 75 1D 04 4639  GROUP04_1:		CALL    PAIR_EX
041A0C D8          4640  			RET     C
041A0D 18 55       4641  			JR      BYTE0
041A0F             4642  ;
041A0F             4643  ; GROUP 5 - SUB, AND, XOR, OR, CP
041A0F             4644  ; GROUP 6 - ADD, ADC, SBC
041A0F             4645  ;
041A0F D6 0A       4646  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A11 30 39       4647  			JR      NC,GROUP07
041A13 FE FD       4648  			CP      5-8
041A15 06 07       4649  			LD      B,7
041A17 D4 01 1D 04 4650  			CALL    NC,OPND			; Get the first operand
041A1B 78          4651  			LD      A,B
041A1C FE 07       4652  			CP      7			; Is the operand 'A'?
041A1E 20 15       4653  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A20             4654  ;
041A20 CD 53 1D 04 4655  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A24 79          4656  			LD      A,C
041A25 30 2E       4657  			JR      NC,BIND1		; If it is a register, then write that out
041A27 EE 46       4658  			XOR     46H			; Handle ADD A,n
041A29 CD F3 1C 04 4659  			CALL    BIND
041A2D CD 33 1D 04 4660  DB_:			CALL    NUMBER
041A31 C3 EC 1A 04 4661  			JP      VAL8
041A35             4662  ;
041A35 E6 3F       4663  GROUP05_HL:		AND     3FH
041A37 FE 0C       4664  			CP      12
041A39 37          4665  			SCF
041A3A C0          4666  			RET     NZ
041A3B 79          4667  			LD      A,C
041A3C FE 80       4668  			CP      80H
041A3E 0E 09       4669  			LD      C,9
041A40 28 C6       4670  			JR      Z,GROUP04_1
041A42 EE 1C       4671  			XOR     1CH
041A44 0F          4672  			RRCA
041A45 4F          4673  			LD      C,A
041A46 CD ED 1C 04 4674  			CALL    ED
041A4A 18 BC       4675  			JR      GROUP04_1
041A4C             4676  ;
041A4C             4677  ; GROUP 7 - INC, DEC
041A4C             4678  ;
041A4C D6 02       4679  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A4E 30 19       4680  			JR      NC,GROUP08
041A50 CD 5A 1D 04 4681  			CALL    REGHI
041A54 79          4682  			LD      A,C
041A55 D2 F3 1C 04 4683  BIND1:			JP      NC,BIND
041A59 EE 64       4684  			XOR     64H
041A5B 07          4685  			RLCA
041A5C 07          4686  			RLCA
041A5D 07          4687  			RLCA
041A5E 4F          4688  			LD      C,A
041A5F CD 7A 1D 04 4689  			CALL    PAIR1_EX
041A63 D8          4690  			RET     C
041A64 79          4691  BYTE0:			LD      A,C
041A65 C3 22 1D 04 4692  			JP      BYTE_
041A69             4693  ;
041A69             4694  ; Group 8: IN0, OUT0
041A69             4695  ;
041A69 D6 02       4696  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A6B 30 2C       4697  			JR	NC,GROUP09
041A6D FE FF       4698  			CP	1-2
041A6F CC 33 1D 04 4699  			CALL    Z,NUMBER		; Fetch number first if OUT
041A73 08          4700  			EX      AF,AF'			; Save flags
041A74 CD 47 1D 04 4701  			CALL    REG			; Get the register value regardless
041A78 D8          4702  			RET     C			; Return if not a register
041A79 08          4703  			EX      AF,AF'			; Restore the flags
041A7A DC 33 1D 04 4704  			CALL    C,NUMBER		; Fetch number last if IN
041A7E 78          4705  			LD	A,B			; Get the register number
041A7F FE 06       4706  			CP	6			; Fail on (HL)
041A81 37          4707  			SCF
041A82 C8          4708  			RET	Z
041A83 FE 08       4709  			CP	8			; Check it is just single pairs only
041A85 3F          4710  			CCF
041A86 D8          4711  			RET	C			; And return if it is an invalid register
041A87 07          4712  			RLCA				; Bind with the operand
041A88 07          4713  			RLCA
041A89 07          4714  			RLCA
041A8A 81          4715  			ADD	A,C
041A8B 4F          4716  			LD	C,A
041A8C CD ED 1C 04 4717  			CALL	ED			; Prefix with ED
041A90 79          4718  			LD	A,C
041A91 CD 22 1D 04 4719  			CALL	BYTE_			; Write out the operand
041A95 C3 EC 1A 04 4720  			JP	VAL8			; Write out the value
041A99             4721  ;
041A99             4722  ; GROUP 9 - IN
041A99             4723  ; GROUP 10 - OUT
041A99             4724  ;
041A99 D6 02       4725  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041A9B 30 25       4726  			JR      NC,GROUP11
041A9D FE FF       4727  			CP      1-2			; Check if Group 9 or Group 1
041A9F CC E1 1C 04 4728  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AA3 08          4729  			EX      AF,AF'			; Save flags
041AA4 CD 5A 1D 04 4730  			CALL    REGHI			; Get the register value regardless
041AA8 D8          4731  			RET     C			; Return if not a register
041AA9 08          4732  			EX      AF,AF'			; Restore the flags
041AAA DC E1 1C 04 4733  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041AAE 24          4734  			INC     H			; If it is IN r,(C) or OUT (C),r then
041AAF 28 B3       4735  			JR      Z,BYTE0			; Just write the operand out
041AB1             4736  ;
041AB1 78          4737  			LD      A,B			; Check the register
041AB2 FE 07       4738  			CP      7
041AB4 37          4739  			SCF
041AB5 C0          4740  			RET     NZ			; If it is not A, then return
041AB6             4741  ;
041AB6 79          4742  			LD      A,C			; Bind the register with the operand
041AB7 EE 03       4743  			XOR     3
041AB9 07          4744  			RLCA
041ABA 07          4745  			RLCA
041ABB 07          4746  			RLCA
041ABC CD 22 1D 04 4747  			CALL    BYTE_			; Write out the operand
041AC0 18 2A       4748  			JR      VAL8			; And the value
041AC2             4749  ;
041AC2             4750  ; GROUP 11 - JR, DJNZ
041AC2             4751  ;
041AC2 D6 02       4752  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041AC4 30 2B       4753  			JR      NC,GROUP12
041AC6 FE FF       4754  			CP      1-2
041AC8 C4 61 1D 04 4755  			CALL    NZ,COND_
041ACC 79          4756  			LD      A,C
041ACD 30 02       4757  			JR      NC,@F
041ACF 3E 18       4758  			LD      A,18H
041AD1 CD 22 1D 04 4759  @@:			CALL    BYTE_
041AD5 CD 33 1D 04 4760  			CALL    NUMBER
041AD9 ED 5B 40 30 4761  			LD      DE,(PC)
       11          
041ADE 13          4762  			INC     DE
041ADF 37          4763  			SCF
041AE0 ED 52       4764  			SBC     HL,DE
041AE2 7D          4765  			LD      A,L
041AE3 17          4766  			RLA
041AE4 9F          4767  			SBC     A,A
041AE5 BC          4768  			CP      H
041AE6 3E 01       4769  TOOFAR:			LD      A,1
041AE8 C2 90 37 04 4770  			JP      NZ,ERROR_		; Throw an "Out of range" error
041AEC 7D          4771  VAL8:			LD      A,L
041AED C3 22 1D 04 4772  			JP      BYTE_
041AF1             4773  ;
041AF1             4774  ; GROUP 12 - JP
041AF1             4775  ;
041AF1 D6 01       4776  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AF3 30 21       4777  			JR	NC,GROUP13
041AF5 CD 47 1C 04 4778  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AF9 D8          4779  			RET	C			; Exit if an invalid suffix is provided
041AFA CD 61 1D 04 4780  			CALL    COND_			; Evaluate the conditions
041AFE 79          4781  			LD      A,C
041AFF 30 0D       4782  			JR      NC,GROUP12_1
041B01 78          4783  			LD      A,B
041B02 E6 3F       4784  			AND     3FH
041B04 FE 06       4785  			CP      6
041B06 3E E9       4786  			LD      A,0E9H
041B08 CA 22 1D 04 4787  			JP      Z,BYTE_
041B0C 3E C3       4788  			LD      A,0C3H
041B0E CD 22 1D 04 4789  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B12 C3 9C 1C 04 4790  			JP	ADDR_			; Output the address
041B16             4791  ;
041B16             4792  ; GROUP 13 - CALL
041B16             4793  ;
041B16 D6 01       4794  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B18 30 0C       4795  			JR	NC,GROUP14
041B1A CD 5F 1C 04 4796  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B1E CD 41 1B 04 4797  			CALL    GROUP15_1		; Output the opcode (with conditions)
041B22 C3 9C 1C 04 4798  			JP	ADDR_			; Output the address
041B26             4799  ;
041B26             4800  ; GROUP 14 - RST
041B26             4801  ;
041B26 D6 01       4802  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B28 30 13       4803  			JR	NC,GROUP15
041B2A CD 5F 1C 04 4804  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B2E D8          4805  			RET	C			; Exit if an invalid suffix provided
041B2F CD 33 1D 04 4806  			CALL    NUMBER
041B33 A1          4807  			AND     C
041B34 B4          4808  			OR      H
041B35 20 AF       4809  			JR      NZ,TOOFAR
041B37 7D          4810  			LD      A,L
041B38 B1          4811  			OR      C
041B39 C3 22 1D 04 4812  	  		JP      BYTE_
041B3D             4813  ;
041B3D             4814  ; GROUP 15 - RET
041B3D             4815  ;
041B3D D6 01       4816  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B3F 30 0F       4817  			JR	NC,GROUP16
041B41 CD 61 1D 04 4818  GROUP15_1:		CALL    COND_
041B45 79          4819  			LD      A,C
041B46 D2 22 1D 04 4820  			JP      NC,BYTE_
041B4A F6 09       4821  			OR      9
041B4C C3 22 1D 04 4822  			JP      BYTE_
041B50             4823  ;
041B50             4824  ; GROUP 16 - LD
041B50             4825  ;
041B50 D6 01       4826  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B52 30 74       4827  			JR	NC,GROUP17
041B54 CD 5F 1C 04 4828  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B58 CD 90 1D 04 4829  			CALL    LDOP			; Check for accumulator loads
041B5C D2 BC 1C 04 4830  			JP      NC,LDA			; Yes, so jump here
041B60 CD 5A 1D 04 4831  			CALL    REGHI
041B64 08          4832  			EX      AF,AF'
041B65 CD E5 1D 04 4833  			CALL    SKIP
041B69 FE 28       4834  			CP      '('			; Check for bracket
041B6B 28 24       4835  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B6D 08          4836  			EX      AF,AF'
041B6E D2 20 1A 04 4837  			JP      NC,GROUP05_1		; Load single register direct; go here
041B72 0E 01       4838  			LD      C,1
041B74 CD 7A 1D 04 4839  			CALL    PAIR1_EX
041B78 D8          4840  			RET     C
041B79 3E 0E       4841  			LD      A,14
041B7B B8          4842  			CP      B
041B7C 47          4843  			LD      B,A
041B7D CC 75 1D 04 4844  			CALL    Z,PAIR_EX
041B81 78          4845  			LD      A,B
041B82 E6 3F       4846  			AND     3FH
041B84 FE 0C       4847  			CP      12
041B86 79          4848  			LD      A,C
041B87 C2 0E 1B 04 4849  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B8B 3E F9       4850  			LD      A,0F9H
041B8D C3 22 1D 04 4851  			JP      BYTE_
041B91             4852  ;
041B91 08          4853  LDIN:			EX      AF,AF'
041B92 C5          4854  			PUSH    BC
041B93 D4 53 1D 04 4855  			CALL    NC,REGLO
041B97 79          4856  			LD      A,C
041B98 C1          4857  			POP     BC
041B99 D2 F3 1C 04 4858  			JP      NC,BIND
041B9D 0E 0A       4859  			LD      C,0AH
041B9F CD 7A 1D 04 4860  			CALL    PAIR1_EX
041BA3 CD C7 1C 04 4861  			CALL    LD16
041BA7 D2 0E 1B 04 4862  			JP      NC,GROUP12_1
041BAB CD 33 1D 04 4863  			CALL    NUMBER
041BAF 0E 02       4864  			LD      C,2
041BB1 CD 75 1D 04 4865  			CALL    PAIR_EX
041BB5 CD C7 1C 04 4866  			CALL    LD16
041BB9 D8          4867  			RET     C
041BBA CD 22 1D 04 4868  			CALL    BYTE_
041BBE CB 7A       4869  			BIT	7,D			; Check the ADL flag
041BC0 C2 B1 1C 04 4870  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BC4 C3 A4 1C 04 4871  			JP      VAL16			; Otherwise use 16-bit addresses
041BC8             4872  ;
041BC8             4873  ; Group 17 - TST
041BC8             4874  ;
041BC8 D6 01       4875  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BCA 30 25       4876  			JR	NC,OPTS
041BCC CD ED 1C 04 4877  			CALL	ED			; Needs to be prefixed with ED
041BD0 CD 47 1D 04 4878  			CALL	REG			; Fetch the register
041BD4 30 0E       4879  			JR	NC,GROUP17_1		; It's just a register
041BD6             4880  ;
041BD6 3E 64       4881  			LD	A,64H			; Opcode for TST n
041BD8 CD 22 1D 04 4882  			CALL	BYTE_			; Write out the opcode
041BDC CD 33 1D 04 4883  			CALL	NUMBER			; Get the number
041BE0 C3 EC 1A 04 4884  			JP	VAL8			; And write that out
041BE4             4885  ;
041BE4 78          4886  GROUP17_1:		LD	A,B			; Check the register rangs
041BE5 FE 08       4887  			CP	8
041BE7 3F          4888  			CCF
041BE8 D8          4889  			RET	C			; Ret with carry flag set for error if out of range
041BE9 07          4890  			RLCA				; Get the opcode value
041BEA 07          4891  			RLCA
041BEB 07          4892  			RLCA
041BEC 81          4893  			ADD	A,C			; Add the opcode base in
041BED C3 22 1D 04 4894  			JP	BYTE_
041BF1             4895  
041BF1             4896  ;
041BF1             4897  ; Assembler directives - OPT, ADL
041BF1             4898  ;
041BF1 D6 02       4899  OPTS:			SUB	2
041BF3 30 2B       4900  			JR	NC, DEFS
041BF5 FE FF       4901  			CP	1-2			; Check for ADL opcode
041BF7 28 13       4902  			JR	Z, ADL_
041BF9             4903  ;
041BF9 CD 33 1D 04 4904  OPT:			CALL    NUMBER			; Fetch the OPT value
041BFD 21 40 4D 04 4905  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041C01 E6 07       4906  			AND	7			; Only interested in the first three bits
041C03 4F          4907  			LD      C,A			; Store the new OPT value in C
041C04 ED 6F       4908  			RLD				; Shift the top nibble of LISTON (OPT) into A
041C06 E6 08       4909  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041C08 B1          4910  			OR	C			; OR in the new value
041C09 ED 67       4911  			RRD				; And shift the nibble back in
041C0B C9          4912  			RET
041C0C             4913  ;
041C0C CD 33 1D 04 4914  ADL_:			CALL	NUMBER			; Fetch the ADL value
041C10 E6 01       4915  			AND	1			; Only interested if it is 0 or 1
041C12 0F          4916  			RRCA				; Rotate to bit 7
041C13 4F          4917  			LD	C,A			; Store in C
041C14 3A 40 4D 04 4918  			LD	A,(LISTON)		; Get the LISTON system variable
041C18 E6 7F       4919  			AND	7Fh			; Clear bit 7
041C1A B1          4920  			OR	C			; OR in the ADL value
041C1B 32 40 4D 04 4921  			LD	(LISTON),A		; Store
041C1F C9          4922  			RET
041C20             4923  ;
041C20             4924  ; DEFB, DEFW, DEFL, DEFM
041C20             4925  ;
041C20 B7          4926  DEFS:			OR	A			; Handle DEFB
041C21 CA 2D 1A 04 4927  			JP	Z, DB_
041C25 3D          4928  			DEC	A			; Handle DEFW
041C26 CA A0 1C 04 4929  			JP	Z, ADDR16
041C2A 3D          4930  			DEC	A			; Handle DEFL
041C2B CA AD 1C 04 4931  			JP	Z, ADDR24
041C2F             4932  ;
041C2F DD E5       4933  			PUSH    IX			; Handle DEFM
041C31 CD 15 03 04 4934  			CALL    EXPRS
041C35 DD E1       4935  			POP     IX
041C37 21 00 4A 04 4936  			LD      HL,ACCS
041C3B AF          4937  @@:			XOR     A
041C3C BB          4938  			CP      E
041C3D C8          4939  			RET     Z
041C3E 7E          4940  			LD      A,(HL)
041C3F 23          4941  			INC     HL
041C40 CD 22 1D 04 4942  			CALL    BYTE_
041C44 1D          4943  			DEC     E
041C45 18 F4       4944  			JR      @B
041C47             4945  
041C47             4946  ;
041C47             4947  ;SUBROUTINES:
041C47             4948  ;
041C47 FD 7E 00    4949  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C4A FE 2E       4950  			CP	'.'
041C4C 28 02       4951  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C4E B7          4952  			OR	A			; Reset the carry flag (no error)
041C4F C9          4953  			RET				; And return
041C50 FD 23       4954  @@:			INC	IY			; Skip the dot
041C52 C5          4955  			PUSH	BC			; Push the operand
041C53 21 7B 20 04 4956  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C57 CD 94 1D 04 4957  			CALL	FIND			; Look up the operand
041C5B 30 24       4958  			JR	NC,EZ80SF_OK
041C5D C1          4959  			POP	BC			; Not found at this point, so will return with a C (error)
041C5E C9          4960  			RET
041C5F             4961  ;
041C5F FD 7E 00    4962  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C62 FE 2E       4963  			CP	'.'
041C64 28 02       4964  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C66 B7          4965  			OR	A			; Reset the carry flag (no error)
041C67 C9          4966  			RET				; And return
041C68 FD 23       4967  @@:			INC	IY 			; Skip the dot
041C6A C5          4968  			PUSH	BC			; Push the operand
041C6B 21 73 20 04 4969  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C6F CD 94 1D 04 4970  			CALL	FIND 			; Look up the operand
041C73 30 0C       4971  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C75 CD 90 1C 04 4972  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C79 CD 94 1D 04 4973  			CALL	FIND
041C7D 30 02       4974  			JR	NC,EZ80SF_OK
041C7F C1          4975  			POP	BC			; Not found at this point, so will return with a C (error)
041C80 C9          4976  			RET
041C81             4977  ;
041C81 78          4978  EZ80SF_OK:		LD	A,B			; The operand value
041C82 D4 22 1D 04 4979  			CALL	NC,BYTE_ 		; Write it out if found
041C86 CB BA       4980  			RES	7,D			; Clear the default ADL mode from the flags
041C88 E6 02       4981  			AND	2			; Check the second half of the suffix (.xxL)
041C8A 0F          4982  			RRCA				; Shift into bit 7
041C8B 0F          4983  			RRCA
041C8C B2          4984  			OR	D			; Or into bit 7 of D
041C8D 57          4985  			LD	D,A
041C8E C1          4986  			POP	BC 			; Restore the operand
041C8F C9          4987  			RET
041C90             4988  ;
041C90 21 84 20 04 4989  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C94 CB 7A       4990  			BIT 	7,D			; if bit 7 of D is 0
041C96 C8          4991  			RET	Z
041C97 21 8F 20 04 4992  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041C9B C9          4993  			RET
041C9C             4994  ;
041C9C CB 7A       4995  ADDR_:			BIT	7,D			; Check the ADL flag
041C9E 20 0D       4996  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CA0             4997  ;
041CA0 CD 33 1D 04 4998  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CA4 CD EC 1A 04 4999  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CA8 7C          5000  			LD      A,H
041CA9 C3 22 1D 04 5001  			JP      BYTE_
041CAD             5002  ;
041CAD CD 33 1D 04 5003  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CB1 CD A4 1C 04 5004  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CB5 D9          5005  			EXX
041CB6 7D          5006  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CB7 D9          5007  			EXX
041CB8 C3 22 1D 04 5008  			JP	BYTE_
041CBC             5009  ;
041CBC FE 04       5010  LDA:			CP      4
041CBE DC ED 1C 04 5011  			CALL    C,ED
041CC2 78          5012  			LD      A,B
041CC3 C3 22 1D 04 5013  			JP      BYTE_
041CC7             5014  ;
041CC7 78          5015  LD16:			LD      A,B
041CC8 38 0F       5016  			JR      C,LD8
041CCA 78          5017  			LD      A,B
041CCB E6 3F       5018  			AND     3FH
041CCD FE 0C       5019  			CP      12
041CCF 79          5020  			LD      A,C
041CD0 C8          5021  			RET     Z
041CD1 CD ED 1C 04 5022  			CALL    ED
041CD5 79          5023  			LD      A,C
041CD6 F6 43       5024  			OR      43H
041CD8 C9          5025  			RET
041CD9             5026  ;
041CD9 FE 07       5027  LD8:			CP      7
041CDB 37          5028  			SCF
041CDC C0          5029  			RET     NZ
041CDD 79          5030  			LD      A,C
041CDE F6 30       5031  			OR      30H
041CE0 C9          5032  			RET
041CE1             5033  ;
041CE1             5034  ; Used in IN and OUT to handle whether the operand is C or a number
041CE1             5035  ;
041CE1 C5          5036  CORN:			PUSH    BC
041CE2 CD 01 1D 04 5037  			CALL    OPND			; Get the operand
041CE6 CB 68       5038  			BIT     5,B
041CE8 C1          5039  			POP     BC
041CE9 28 48       5040  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CEB 26 FF       5041  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CED             5042  ;
041CED 3E ED       5043  ED:			LD      A,0EDH			; Write an ED prefix out
041CEF 18 31       5044  			JR      BYTE_
041CF1             5045  ;
041CF1 3E CB       5046  CB:			LD      A,0CBH
041CF3 FE 76       5047  BIND:			CP      76H
041CF5 37          5048  			SCF
041CF6 C8          5049  			RET     Z               	; Reject LD (HL),(HL)
041CF7 CD 22 1D 04 5050  			CALL    BYTE_
041CFB CB 72       5051  			BIT	6,D			; Check the index bit in flags
041CFD C8          5052  			RET     Z
041CFE 7B          5053  			LD      A,E			; If there is an index, output the offset
041CFF 18 21       5054  			JR      BYTE_
041D01             5055  ;
041D01             5056  ; Search through the operand table
041D01             5057  ; Returns:
041D01             5058  ; - B: The operand type
041D01             5059  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041D01             5060  ; - E: The IX/IY offset
041D01             5061  ; - F: Carry if not found
041D01             5062  ;
041D01 E5          5063  OPND:			PUSH    HL			; Preserve HL
041D02 21 05 20 04 5064  			LD      HL,OPRNDS		; The operands table
041D06 CD 94 1D 04 5065  			CALL    FIND			; Find the operand
041D0A E1          5066  			POP     HL
041D0B D8          5067  			RET     C			; Return if not found
041D0C CB 78       5068  			BIT     7,B			; Check if it is an index register (IX, IY)
041D0E C8          5069  			RET     Z			; Return if it isn't
041D0F CB F2       5070  			SET	6,D			; Set flag to indicate we've got an index
041D11 CB 58       5071  			BIT     3,B			; Check if an offset is required
041D13 E5          5072  			PUSH    HL
041D14 CC 29 1D 04 5073  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D18 5D          5074  			LD      E,L			; E: The offset
041D19 E1          5075  			POP     HL
041D1A 3E DD       5076  			LD	A,DDH			; IX prefix
041D1C CB 70       5077  			BIT     6,B			; If bit 6 is reset then
041D1E 28 02       5078  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D20 3E FD       5079  			LD	A,FDH			; IY prefix
041D22             5080  ;
041D22 DD 77 00    5081  BYTE_:			LD      (IX),A			; Write a byte out
041D25 DD 23       5082  			INC     IX
041D27 B7          5083  			OR      A
041D28 C9          5084  			RET
041D29             5085  ;
041D29 FD 7E 00    5086  OFFSET_EX:			LD      A,(IY)
041D2C FE 29       5087  			CP      ')'
041D2E 21 00 00 00 5088  			LD      HL,0
041D32 C8          5089  			RET     Z
041D33 CD E5 1D 04 5090  NUMBER:			CALL    SKIP
041D37 C5          5091  			PUSH    BC
041D38 D5          5092  			PUSH    DE
041D39 DD E5       5093  			PUSH    IX
041D3B CD 0A 03 04 5094  			CALL    EXPRI
041D3F DD E1       5095  			POP     IX
041D41 D9          5096  			EXX
041D42 D1          5097  			POP     DE
041D43 C1          5098  			POP     BC
041D44 7D          5099  			LD      A,L
041D45 B7          5100  			OR      A
041D46 C9          5101  			RET
041D47             5102  ;
041D47 CD 01 1D 04 5103  REG:			CALL    OPND
041D4B D8          5104  			RET     C
041D4C 78          5105  			LD      A,B
041D4D E6 3F       5106  			AND     3FH
041D4F FE 08       5107  			CP      8
041D51 3F          5108  			CCF
041D52 C9          5109  			RET
041D53             5110  ;
041D53 CD 47 1D 04 5111  REGLO:			CALL    REG
041D57 D8          5112  			RET     C
041D58 18 33       5113  			JR      ORC
041D5A             5114  ;
041D5A CD 47 1D 04 5115  REGHI:			CALL    REG
041D5E D8          5116  			RET     C
041D5F 18 29       5117  			JR      SHL3
041D61             5118  ;
041D61 CD 01 1D 04 5119  COND_:			CALL    OPND
041D65 D8          5120  			RET     C
041D66 78          5121  			LD      A,B
041D67 E6 1F       5122  			AND     1FH
041D69 D6 10       5123  			SUB     16
041D6B 30 1D       5124  			JR      NC,SHL3
041D6D FE F1       5125  			CP      -15
041D6F 37          5126  			SCF
041D70 C0          5127  			RET     NZ
041D71 3E 03       5128  			LD      A,3
041D73 18 15       5129  			JR      SHL3
041D75             5130  ;
041D75 CD 01 1D 04 5131  PAIR_EX:			CALL    OPND
041D79 D8          5132  			RET     C
041D7A 78          5133  PAIR1_EX:			LD      A,B
041D7B E6 0F       5134  			AND     0FH
041D7D D6 08       5135  			SUB     8
041D7F D8          5136  			RET     C
041D80 18 08       5137  			JR      SHL3
041D82             5138  ;
041D82 CD 33 1D 04 5139  BIT_:			CALL    NUMBER
041D86 FE 08       5140  			CP      8
041D88 3F          5141  			CCF
041D89 D8          5142  			RET     C
041D8A 07          5143  SHL3:			RLCA
041D8B 07          5144  			RLCA
041D8C 07          5145  			RLCA
041D8D B1          5146  ORC:			OR      C
041D8E 4F          5147  			LD      C,A
041D8F C9          5148  			RET
041D90             5149  ;
041D90 21 4A 20 04 5150  LDOP:			LD      HL,LDOPS
041D94             5151  
041D94             5152  ;
041D94             5153  ; Look up a value in a table
041D94             5154  ; Parameters:
041D94             5155  ; - IY: Address of the assembly language line in the BASIC program area
041D94             5156  ; - HL: Address of the table
041D94             5157  ; Returns:
041D94             5158  ; - B: The operand code
041D94             5159  ; - F: Carry set if not found
041D94             5160  ;
041D94 CD E5 1D 04 5161  FIND:			CALL    SKIP			; Skip delimiters
041D98             5162  ;
041D98 06 00       5163  EXIT_:			LD      B,0			; Set B to 0
041D9A 37          5164  			SCF				; Set the carry flag
041D9B C8          5165  			RET     Z			; Returns if Z
041D9C             5166  ;
041D9C FE DD       5167  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041D9E 28 04       5168  			JR      Z,FIND0
041DA0 FE 85       5169  			CP      TOR+1			; Special case for tokens AND and OR
041DA2 3F          5170  			CCF
041DA3 D8          5171  			RET     C
041DA4 7E          5172  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DA5 B7          5173  			OR      A
041DA6 28 F0       5174  			JR      Z,EXIT_			; Exit
041DA8 FD AE 00    5175  			XOR     (IY)
041DAB E6 5F       5176  			AND     01011111B
041DAD 28 09       5177  			JR      Z,FIND2
041DAF CB 7E       5178  FIND1:			BIT     7,(HL)
041DB1 23          5179  			INC     HL
041DB2 28 FB       5180  			JR      Z,FIND1
041DB4 23          5181  			INC     HL
041DB5 04          5182  			INC     B
041DB6 18 EC       5183  			JR      FIND0
041DB8             5184  ;
041DB8 FD E5       5185  FIND2:			PUSH    IY
041DBA CB 7E       5186  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DBC FD 23       5187  			INC     IY
041DBE 23          5188  			INC     HL
041DBF 20 11       5189  			JR      NZ,FIND5		; Yes
041DC1 BE          5190  			CP      (HL)
041DC2 CC E4 1D 04 5191  			CALL    Z,SKIP0
041DC6 7E          5192  			LD      A,(HL)
041DC7 FD AE 00    5193  			XOR     (IY)
041DCA E6 5F       5194  			AND     01011111B
041DCC 28 EC       5195  			JR      Z,FIND3
041DCE FD E1       5196  FIND4:			POP     IY
041DD0 18 DD       5197  			JR      FIND1
041DD2             5198  ;
041DD2 CD 90 17 04 5199  FIND5:			CALL    DELIM			; Is it a delimiter?
041DD6 C4 F9 1D 04 5200  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DDA C4 F3 1D 04 5201  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DDE 20 EE       5202  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DE0             5203  ;
041DE0 78          5204  FIND6:			LD      A,B			; At this point we have a token
041DE1 46          5205  			LD      B,(HL)			; Fetch the token type code
041DE2 E1          5206  			POP     HL			; Restore the stack
041DE3 C9          5207  			RET
041DE4             5208  ;
041DE4 23          5209  SKIP0:			INC     HL
041DE5 CD 90 17 04 5210  SKIP:			CALL    DELIM			; Is it a delimiter?
041DE9 C0          5211  			RET     NZ			; No, so return
041DEA CD 9C 17 04 5212  			CALL    TERM			; Is it a terminator?
041DEE C8          5213  			RET     Z			; Yes, so return
041DEF FD 23       5214  			INC     IY			; Increment the basic program counter
041DF1 18 F2       5215  			JR      SKIP			; And loop
041DF3             5216  ;
041DF3 FE 2B       5217  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DF5 C8          5218  			RET     Z
041DF6 FE 2D       5219  			CP      '-'
041DF8 C9          5220  			RET
041DF9             5221  ;
041DF9 FE 2E       5222  DOT:			CP	'.'			; Check if it is a dot character
041DFB C9          5223  			RET
041DFC             5224  ; Z80 opcode list
041DFC             5225  ;
041DFC             5226  ; Group 0: (15 opcodes)
041DFC             5227  ; Trivial cases requiring no computation
041DFC             5228  ;
041DFC 4E 4F 50 00 5229  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E00 52 4C 43 41 5230  			DB	"RLC","A"+80H,07h
       07          
041E05 45 58 00 41 5231  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041E0F 52 52 43 41 5232  			DB	"RRC","A"+80H,0FH
       0F          
041E14 52 4C 41 17 5233  			DB	"RL","A"+80H,17H
041E18 52 52 41 1F 5234  			DB	"RR","A"+80H,1FH
041E1C 44 41 41 27 5235  			DB	"DA","A"+80H,27H
041E20 43 50 4C 2F 5236  			DB	"CP","L"+80H,2FH
041E24 53 43 46 37 5237  			DB	"SC","F"+80H,37H
041E28 43 43 46 3F 5238  			DB	"CC","F"+80H,3FH
041E2C 48 41 4C 54 5239  			DB	"HAL","T"+80H,76H
       76          
041E31 45 58 58 D9 5240  			DB	"EX","X"+80H,D9H
041E35 45 58 00 44 5241  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
041E3E 44 49 F3    5242  			DB	"D","I"+80H,F3H
041E41 45 49 FB    5243  			DB	"E","I"+80H,FBH
041E44             5244  ;
041E44             5245  ; Group 1: (53 opcodes)
041E44             5246  ; As Group 0, but with an ED prefix
041E44             5247  ;
041E44 4E 45 47 44 5248  			DB	"NE","G"+80H,44H	; 0Fh
041E48 49 4D 00 30 5249  			DB	"IM",0,"0"+80H,46H
       46          
041E4D 52 45 54 4E 5250  			DB	"RET","N"+80H,45H
       45          
041E52 4D 4C 54 00 5251  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
041E59 52 45 54 49 5252  			DB	"RET","I"+80H,4DH
       4D          
041E5E 49 4D 00 31 5253  			DB	"IM",0,"1"+80H,56H
       56          
041E63 4D 4C 54 00 5254  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
041E6A 49 4D 00 32 5255  			DB	"IM",0,"2"+80H,5EH
       5E          
041E6F 52 52 44 67 5256  			DB	"RR","D"+80H,67H
041E73 4D 4C 54 00 5257  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
041E7A 4C 44 00 4D 5258  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
041E82 4C 44 00 41 5259  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
041E8A 52 4C 44 6F 5260  			DB	"RL","D"+80H,6FH
041E8E 53 4C 50 76 5261  			DB	"SL","P"+80H,76H
041E92 4D 4C 54 00 5262  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041E99 53 54 4D 49 5263  			DB	"STMI","X"+80H,7DH
       58 7D       
041E9F 52 53 4D 49 5264  			DB	"RSMI","X"+80H,7EH
       58 7E       
041EA5 49 4E 49 4D 5265  			DB	"INI","M"+80H,82H
       82          
041EAA 4F 54 49 4D 5266  			DB	"OTI","M"+80H,83H
       83          
041EAF 49 4E 49 32 5267  			DB	"INI","2"+80H,84H
       84          
041EB4 49 4E 44 4D 5268  			DB	"IND","M"+80H,8AH
       8A          
041EB9 4F 54 44 4D 5269  			DB	"OTD","M"+80H,8BH
       8B          
041EBE 49 4E 44 32 5270  			DB	"IND","2"+80H,8CH
       8C          
041EC3 49 4E 49 4D 5271  			DB	"INIM","R"+80H,92H
       52 92       
041EC9 4F 54 49 4D 5272  			DB	"OTIM","R"+80H,93H
       52 93       
041ECF 49 4E 49 32 5273  			DB	"INI2","R"+80H,94H
       52 94       
041ED5 49 4E 44 4D 5274  			DB	"INDM","R"+80H,9AH
       52 9A       
041EDB 4F 54 44 4D 5275  			DB	"OTDM","R"+80H,9BH
       52 9B       
041EE1 49 4E 44 32 5276  			DB	"IND2","R"+80H,9CH
       52 9C       
041EE7 4C 44 49 A0 5277  			DB	"LD","I"+80H,A0H
041EEB 43 50 49 A1 5278  			DB	"CP","I"+80H,A1H
041EEF 49 4E 49 A2 5279  			DB	"IN","I"+80H,A2H
041EF3 4F 55 54 49 5280  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041EF9 4F 55 54 49 5281  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041EFE 4C 44 44 A8 5282  			DB	"LD","D"+80H,A8H
041F02 43 50 44 A9 5283  			DB	"CP","D"+80H,A9H
041F06 49 4E 44 AA 5284  			DB	"IN","D"+80H,AAH
041F0A 4F 55 54 44 5285  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041F10 4F 55 54 44 5286  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
041F15 4C 44 49 52 5287  			DB	"LDI","R"+80H,B0H
       B0          
041F1A 43 50 49 52 5288  			DB	"CPI","R"+80H,B1H
       B1          
041F1F 49 4E 49 52 5289  			DB	"INI","R"+80H,B2H
       B2          
041F24 4F 54 49 52 5290  			DB	"OTI","R"+80H,B3H
       B3          
041F29 4F 54 49 32 5291  			DB	"OTI2","R"+80H,B4H
       52 B4       
041F2F 4C 44 44 52 5292  			DB	"LDD","R"+80H,B8H
       B8          
041F34 43 50 44 52 5293  			DB	"CPD","R"+80H,B9H
       B9          
041F39 49 4E 44 52 5294  			DB	"IND","R"+80H,BAH
       BA          
041F3E 4F 54 44 52 5295  			DB	"OTD","R"+80H,BBH
       BB          
041F43 4F 54 44 32 5296  			DB	"OTD2","R"+80H,BCH
       52 BC       
041F49 49 4E 49 52 5297  			DB	"INIR","X"+80H,C2H
       58 C2       
041F4F 4F 54 49 52 5298  			DB	"OTIR","X"+80H,C3H
       58 C3       
041F55 49 4E 44 52 5299  			DB	"INDR","X"+80H,CAH
       58 CA       
041F5B 4F 54 44 52 5300  			DB	"OTDR","X"+80H,CBH
       58 CB       
041F61             5301  ;
041F61             5302  ; Group 2: (3 opcodes)
041F61             5303  ;
041F61 42 49 54 40 5304  			DB	"BI","T"+80H,40H	; 44h
041F65 52 45 53 80 5305  			DB	"RE","S"+80H,80H
041F69 53 45 54 C0 5306  			DB	"SE","T"+80H,C0H
041F6D             5307  ;
041F6D             5308  ; Group 3: (7 opcodes)
041F6D             5309  ;
041F6D 52 4C 43 00 5310  			DB	"RL","C"+80H,00H	; 47h
041F71 52 52 43 08 5311  			DB	"RR","C"+80H,08H
041F75 52 4C 10    5312  			DB	"R","L"+80H,10H
041F78 52 52 18    5313  			DB	"R","R"+80H,18H
041F7B 53 4C 41 20 5314  			DB	"SL","A"+80H,20H
041F7F 53 52 41 28 5315  			DB	"SR","A"+80H,28H
041F83 53 52 4C 38 5316  			DB	"SR","L"+80H,38H
041F87             5317  ;
041F87             5318  ; Group 4: (3 opcodes)
041F87             5319  ;
041F87 50 4F 50 C1 5320  			DB	"PO","P"+80H,C1H	; 4Eh
041F8B 50 55 53 48 5321  			DB	"PUS","H"+80H,C5H
       C5          
041F90 45 58 00 28 5322  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
041F97             5323  ;
041F97             5324  ; Group 5: (7 opcodes)
041F97             5325  ;
041F97 53 55 42 90 5326  			DB	"SU","B"+80H,90H	; 51h
041F9B 41 4E 44 A0 5327  			DB	"AN","D"+80H,A0H
041F9F 58 4F 52 A8 5328  			DB	"XO","R"+80H,A8H
041FA3 4F 52 B0    5329  			DB	"O","R"+80H,B0H
041FA6 43 50 B8    5330  			DB	"C","P"+80H,B8H
041FA9 80 A0       5331  			DB	TAND,A0H		; 56h TAND: Tokenised AND
041FAB 84 B0       5332  			DB	TOR,B0H			; 57h TOR: Tokenised OR
041FAD             5333  ;
041FAD             5334  ; Group 6 (3 opcodes)
041FAD             5335  ;
041FAD 41 44 44 80 5336  			DB	"AD","D"+80H,80H	; 58h
041FB1 41 44 43 88 5337  			DB	"AD","C"+80H,88H
041FB5 53 42 43 98 5338  			DB	"SB","C"+80H,98H
041FB9             5339  ;
041FB9             5340  ; Group 7: (2 opcodes)
041FB9             5341  ;
041FB9 49 4E 43 04 5342  			DB	"IN","C"+80H,04H	; 5Bh
041FBD 44 45 43 05 5343  			DB	"DE","C"+80H,05H
041FC1             5344  ;
041FC1             5345  ; Group 8: (2 opcodes)
041FC1             5346  ;
041FC1 49 4E 30 00 5347  			DB	"IN","0"+80H,00H	; 5Dh
041FC5 4F 55 54 30 5348  			DB	"OUT","0"+80H,01H
       01          
041FCA             5349  ;
041FCA             5350  ; Group 9: (1 opcode)
041FCA             5351  ;
041FCA 49 4E 40    5352  			DB	"I","N"+80H,40H		; 5Fh
041FCD             5353  ;
041FCD             5354  ; Group 10: (1 opcode)
041FCD             5355  ;
041FCD 4F 55 54 41 5356  			DB	"OU","T"+80H,41H	; 60h
041FD1             5357  ;
041FD1             5358  ; Group 11: (2 opcodes)
041FD1             5359  ;
041FD1 4A 52 20    5360  			DB	"J","R"+80H,20H		; 61h
041FD4 44 4A 4E 5A 5361  			DB	"DJN","Z"+80H,10H
       10          
041FD9             5362  ;
041FD9             5363  ; Group 12: (1 opcode)
041FD9             5364  ;
041FD9 4A 50 C2    5365  			DB	"J","P"+80H,C2H		; 63h
041FDC             5366  ;
041FDC             5367  ; Group 13: (1 opcode)
041FDC             5368  ;
041FDC 43 41 4C 4C 5369  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041FE1             5370  ;
041FE1             5371  ; Group 14: (1 opcode)
041FE1             5372  ;
041FE1 52 53 54 C7 5373  			DB	"RS","T"+80H,C7H	; 65h
041FE5             5374  ;
041FE5             5375  ; Group 15: (1 opcode)
041FE5             5376  ;
041FE5 52 45 54 C0 5377  			DB	"RE","T"+80H,C0H	; 66h
041FE9             5378  ;
041FE9             5379  ; Group 16: (1 opcode)
041FE9             5380  ;
041FE9 4C 44 40    5381  			DB	"L","D"+80H,40H		; 67h
041FEC             5382  ;
041FEC             5383  ; Group 17: (1 opcode)
041FEC             5384  ;
041FEC 54 53 54 04 5385  			DB	"TS","T"+80H,04H	; 68h
041FF0             5386  
041FF0             5387  ;
041FF0             5388  ; Assembler Directives
041FF0             5389  ;
041FF0 4F 50 54 00 5390  			DB	"OP","T"+80H,00H	; 69h OPT
041FF4 41 44 4C 00 5391  			DB	"AD","L"+80H,00H	; 6Ah ADL
041FF8             5392  ;
041FF8 5D 42 00    5393  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041FFB 5D 57 00    5394  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041FFE 5D 4C 00    5395  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042001 5D 4D 00    5396  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
042004             5397  ;
042004 00          5398  			DB	0
042005             5399  ;
042005             5400  ; Operands
042005             5401  ;
042005 42 00       5402  OPRNDS:			DB	"B"+80H, 00H
042007 43 01       5403  			DB	"C"+80H, 01H
042009 44 02       5404  			DB	"D"+80H, 02H
04200B 45 03       5405  			DB	"E"+80H, 03H
04200D 48 04       5406  			DB	"H"+80H, 04H
04200F 4C 05       5407  			DB	"L"+80H, 05H
042011 28 48 4C 06 5408  			DB	"(H","L"+80H,06H
042015 41 07       5409  			DB	"A"+80H, 07H
042017 28 49 58 86 5410  			DB	"(I","X"+80H,86H
04201B 28 49 59 C6 5411  			DB	"(I","Y"+80H,C6H
04201F             5412  ;
04201F 42 43 08    5413  			DB	"B","C"+80H,08H
042022 44 45 0A    5414  			DB	"D","E"+80H,0AH
042025 48 4C 0C    5415  			DB	"H","L"+80H,0CH
042028 49 58 8C    5416  			DB	"I","X"+80H,8CH
04202B 49 59 CC    5417  			DB	"I","Y"+80H,CCH
04202E 41 46 0E    5418  			DB	"A","F"+80H,0EH
042031 53 50 0E    5419  			DB	"S","P"+80H,0EH
042034             5420  ;
042034 4E 5A 10    5421  			DB	"N","Z"+80H,10H
042037 5A 11       5422  			DB	"Z"+80H,11H
042039 4E 43 12    5423  			DB	"N","C"+80H,12H
04203C 50 4F 14    5424  			DB	"P","O"+80H,14H
04203F 50 45 15    5425  			DB	"P","E"+80H,15H
042042 50 16       5426  			DB	"P"+80H,16H
042044 4D 17       5427  			DB	"M"+80H,17H
042046             5428  ;
042046 28 43 20    5429  			DB	"(","C"+80H,20H
042049             5430  ;
042049 00          5431  			DB	0
04204A             5432  ;
04204A             5433  ; Load operations
04204A             5434  ;
04204A 49 00 41 47 5435  LDOPS:			DB	"I",0,"A"+80H,47H
04204E 52 00 41 4F 5436  			DB	"R",0,"A"+80H,4FH
042052 41 00 49 57 5437  			DB	"A",0,"I"+80H,57H
042056 41 00 52 5F 5438  			DB	"A",0,"R"+80H,5FH
04205A 28 42 43 00 5439  			DB	"(BC",0,"A"+80H,02h
       41 02       
042060 28 44 45 00 5440  			DB	"(DE",0,"A"+80H,12H
       41 12       
042066 41 00 28 42 5441  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
04206C 41 00 28 44 5442  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
042072             5443  ;
042072 00          5444  			DB	0
042073             5445  ;
042073             5446  ; eZ80 addressing mode suffixes
042073             5447  ;
042073             5448  ; Fully qualified suffixes
042073             5449  ;
042073 4C 49 53 49 5450  EZ80SFS_1:		DB	"LI","S"+80H,49H
042077 53 49 4C 52 5451  			DB	"SI","L"+80H,52H
04207B 53 49 53 40 5452  EZ80SFS_2:		DB	"SI","S"+80H,40H
04207F 4C 49 4C 5B 5453  			DB	"LI","L"+80H,5BH
042083             5454  ;
042083 00          5455  			DB	0
042084             5456  ;
042084             5457  ; Shortcuts when ADL mode is 0
042084             5458  ;
042084 53 40       5459  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042086 4C 49       5460  			DB	"L"+80H,49H		; Equivalent to .LIS
042088 49 53 40    5461  			DB	"I","S"+80H,40H		; Equivalent to .SIS
04208B 49 4C 52    5462  			DB	"I","L"+80H,52H		; Equivalent to .SIL
04208E             5463  ;
04208E 00          5464  			DB	0
04208F             5465  ;
04208F             5466  ; Shortcuts when ADL mode is 1
04208F             5467  ;
04208F 53 52       5468  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042091 4C 5B       5469  			DB	"L"+80H,5BH		; Equivalent to .LIL
042093 49 53 49    5470  			DB	"I","S"+80H,49H		; Equivalent to .LIS
042096 49 4C 5B    5471  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
042099             5472  ;
042099 00          5473  			DB	0
04209A             5474  ;
04209A             5475  ; .LIST
04209A             5476  ;
04209A             5477  ; already defined in equs.inc
04209A             5478  ; LF:			EQU     0AH
04209A             5479  ; CR:			EQU     0DH; --- End exec.asm ---
04209A             5480  
04209A             5481  ; --- Begin fpp.asm ---
04209A             5482  ;
04209A             5483  ; Title:	BBC Basic Interpreter - Z80 version
04209A             5484  ;		Z80 Floating Point Package
04209A             5485  ; Author:	(C) Copyright  R.T.Russell  1986
04209A             5486  ; Modified By:	Dean Belfield
04209A             5487  ; Created:	03/05/2022
04209A             5488  ; Last Updated:	07/06/2023
04209A             5489  ;
04209A             5490  ; Modinfo:
04209A             5491  ; 26/10/1986:	Version 0.0
04209A             5492  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
04209A             5493  ; 12/05/2023:	Modified by Dean Belfield
04209A             5494  ; 07/06/2023:	Modified to run in ADL mode
04209A             5495  
04209A             5496  			; .ASSUME	ADL = 1
04209A             5497  
04209A             5498  			; SEGMENT CODE
04209A             5499  
04209A             5500  			; XDEF	FPP
04209A             5501  			; XDEF	DLOAD5
04209A             5502  			; XDEF	DLOAD5_SPL
04209A             5503  ;
04209A             5504  ;BINARY FLOATING POINT REPRESENTATION:
04209A             5505  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04209A             5506  ;    8 BIT EXCESS-128 SIGNED EXPONENT
04209A             5507  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04209A             5508  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04209A             5509  ;
04209A             5510  ;BINARY INTEGER REPRESENTATION:
04209A             5511  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04209A             5512  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
04209A             5513  ;
04209A             5514  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04209A             5515  ;                            EXPONENT - C
04209A             5516  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
04209A             5517  ;                               EXPONENT - B
04209A             5518  
04209A             5519  ;
04209A             5520  ;Error codes:
04209A             5521  ;
04209A             5522  
04209A             5523  BADOP:			EQU     1               ;Bad operation code
04209A             5524  DIVBY0:			EQU     18              ;Division by zero
04209A             5525  TOOBIG_FP:			EQU     20              ;Too big
04209A             5526  NGROOT:			EQU     21              ;Negative root
04209A             5527  LOGRNG:			EQU     22              ;Log range
04209A             5528  ACLOST:			EQU     23              ;Accuracy lost
04209A             5529  EXPRNG:			EQU     24              ;Exp range
04209A             5530  ;
04209A             5531  ;Call entry and despatch code:
04209A             5532  ;
04209A FD E5       5533  FPP:			PUSH    IY              ;Save IY
04209C FD 21 00 00 5534          		LD      IY,0
       00          
0420A1 FD 39       5535          		ADD     IY,SP           ;Save SP in IY
0420A3 CD B3 20 04 5536          		CALL    OP              ;Perform operation
0420A7 BF          5537          		CP      A               ;Good return (Z, NC)
0420A8 FD E1       5538  EXIT_FP_:			POP     IY              ;Restore IY
0420AA C9          5539          		RET                     ;Return to caller
0420AB             5540  ;
0420AB             5541  ;Error exit:
0420AB             5542  ;
0420AB 3E 01       5543  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420AD FD F9       5544  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420AF B7          5545          		OR      A               ;Set NZ
0420B0 37          5546          		SCF                     ;Set C
0420B1 18 F5       5547          		JR      EXIT_FP_
0420B3             5548  ;
0420B3             5549  ;Perform operation or function:
0420B3             5550  ;
0420B3             5551  ; OP:			CP      (RTABLE-DTABLE)/3
0420B3 FE 2A       5552  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420B5             5553  
0420B5 30 F4       5554          		JR      NC,BAD_FP
0420B7             5555          		; CP      (FTABLE-DTABLE)/3
0420B7 FE 10       5556  				CP      FTABLE-DTABLE/3 ; ditto
0420B9 30 08       5557          		JR      NC,DISPAT_FP
0420BB 08          5558          		EX      AF,AF'
0420BC 78          5559          		LD      A,B
0420BD B1          5560          		OR      C               ;Both integer?
0420BE C4 C6 2B 04 5561          		CALL    NZ,FLOATA       ;No, so float both
0420C2 08          5562          		EX      AF,AF'
0420C3 E5          5563  DISPAT_FP:			PUSH    HL
0420C4 21 D6 20 04 5564          		LD      HL,DTABLE
0420C8 C5          5565          		PUSH    BC
0420C9 01 03 00 00 5566  			LD	BC, 3		; C = 3
0420CD 47          5567  			LD	B, A 		; B = op-code
0420CE ED 4C       5568  			MLT 	BC 		;BC = op-code * 3
0420D0 09          5569  			ADD	HL, BC 		;Add to table base
0420D1 ED 27       5570  			LD	HL, (HL)	;Get the routine address (24-bit)
0420D3             5571  
0420D3             5572  ;        		ADD     A, A            ;A = op-code * 2
0420D3             5573  ;        		LD      C,A
0420D3             5574  ;        		LD      B,0             ;BC = op-code * 2
0420D3             5575  ;        		ADD     HL,BC
0420D3             5576  ;        		LD      A,(HL)          ;Get low byte
0420D3             5577  ;        		INC     HL
0420D3             5578  ;        		LD      H,(HL)          ;Get high byte
0420D3             5579  ;        		LD      L,A
0420D3             5580  
0420D3 C1          5581          		POP     BC
0420D4 E3          5582          		EX      (SP),HL
0420D5 C9          5583          		RET                     ;Off to routine
0420D6             5584  ;
0420D6             5585  ;Despatch table:
0420D6             5586  ;
0420D6 88 21 04    5587  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420D9 F6 21 04    5588          		DW24  IBDIV           ;DIV
0420DC 9B 21 04    5589          		DW24  IEOR            ;EOR
0420DF C1 21 04    5590          		DW24  IMOD            ;MOD
0420E2 AE 21 04    5591          		DW24  IOR             ;OR
0420E5 7C 24 04    5592          		DW24  ILE             ;<=
0420E8 8B 24 04    5593          		DW24  INE             ;<>
0420EB 6F 24 04    5594          		DW24  IGE             ;>=
0420EE 54 24 04    5595          		DW24  ILT             ;<
0420F1 98 24 04    5596          		DW24  IEQ             ;=
0420F4 E4 22 04    5597          		DW24  IMUL            ;*
0420F7 1F 22 04    5598          		DW24  IADD            ;+
0420FA 61 24 04    5599          		DW24  IGT             ;>
0420FD 06 22 04    5600          		DW24  ISUB            ;-
042100 9B 23 04    5601          		DW24  IPOW            ;^
042103 91 22 04    5602          		DW24  IDIV            ;/
042106             5603  ;
042106             5604  FTABLE:
042106 AA 24 04    5605  				DW24  ABSV_FP            ;ABS
042109 90 28 04    5606          		DW24  ACS_FP             ;ACS
04210C CE 27 04    5607          		DW24  ASN_FP             ;ASN
04210F FE 27 04    5608          		DW24  ATN_FP             ;ATN
042112 C9 25 04    5609          		DW24  COS_FP             ;COS
042115 D8 24 04    5610          		DW24  DEG_FP             ;DEG
042118 85 26 04    5611          		DW24  EXP_FP             ;EXP
04211B 2C 25 04    5612          		DW24  INT_FP_            ;INT
04211E 23 27 04    5613          		DW24  LN_FP              ;LN
042121 B8 27 04    5614          		DW24  LOG_FP             ;LOG
042124 B6 24 04    5615          		DW24  NOTK_FP            ;NOT
042127 E2 24 04    5616          		DW24  RAD_FP             ;RAD
04212A FD 24 04    5617          		DW24  SGN_FP             ;SGN
04212D D6 25 04    5618          		DW24  SIN_FP             ;SIN
042130 45 25 04    5619          		DW24  SQR_FP             ;SQR
042133 A3 25 04    5620          		DW24  TAN_FP             ;TAN
042136             5621  ;
042136 53 2C 04    5622  		        DW24  ZERO_FP            ;ZERO
042139 5E 26 04    5623          		DW24  FONE_FP            ;FONE
04213C 9D 24 04    5624          		DW24  TRUE_FP            ;TRUE
04213F CA 24 04    5625          		DW24  PI_FP              ;PI
042142             5626  ;
042142 11 25 04    5627  		        DW24  VAL_FP             ;VAL
042145 99 28 04    5628          		DW24  STR_FP             ;STR$
042148             5629  ;
042148 FA 2A 04    5630          		DW24  SFIX_FP            ;FIX
04214B D6 2B 04    5631          		DW24  SFLOAT_FP          ;FLOAT
04214E             5632  ;
04214E 24 2C 04    5633  		        DW24  FTEST_FP           ;TEST
042151 36 2C 04    5634          		DW24  FCOMP_FP           ;COMPARE
042154             5635  ;
042154 84 21 04    5636  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042157 F2 21 04    5637          		DW24  FBDIV           ;DIV
04215A 97 21 04    5638          		DW24  FEOR            ;EOR
04215D BD 21 04    5639          		DW24  FMOD            ;MOD
042160 AA 21 04    5640          		DW24  FFOR             ;OR
042163 76 24 04    5641          		DW24  FLE             ;<=
042166 85 24 04    5642          		DW24  FNE             ;<>
042169 69 24 04    5643          		DW24  FGE             ;>=
04216C 4E 24 04    5644          		DW24  FLT             ;<
04216F 92 24 04    5645          		DW24  FEQ             ;=
042172 3E 23 04    5646          		DW24  FMUL            ;*
042175 2C 22 04    5647          		DW24  FADD            ;+
042178 5B 24 04    5648          		DW24  FGT             ;>
04217B 13 22 04    5649          		DW24  FSUB            ;-
04217E 1B 24 04    5650          		DW24  FPOW            ;^
042181 95 22 04    5651          		DW24  FDIV            ;/
042184             5652  ;
042184             5653  ;       PAGE
042184             5654  ;
042184             5655  ;ARITHMETIC AND LOGICAL OPERATORS:
042184             5656  ;All take two arguments, in HLH'L'C & DED'E'B.
042184             5657  ;Output in HLH'L'C
042184             5658  ;All registers except IX, IY destroyed.
042184             5659  ; (N.B. FPOW destroys IX).
042184             5660  ;
042184             5661  ;FAND - Floating-point AND.
042184             5662  ;IAND - Integer AND.
042184             5663  ;
042184 CD EE 2A 04 5664  FAND:			CALL    FIX2
042188 7C          5665  IAND:			LD      A,H
042189 A2          5666          		AND     D
04218A 67          5667          		LD      H,A
04218B 7D          5668          		LD      A,L
04218C A3          5669          		AND     E
04218D 6F          5670          		LD      L,A
04218E D9          5671          		EXX
04218F 7C          5672          		LD      A,H
042190 A2          5673          		AND     D
042191 67          5674          		LD      H,A
042192 7D          5675          		LD      A,L
042193 A3          5676          		AND     E
042194 6F          5677          		LD      L,A
042195 D9          5678          		EXX
042196 C9          5679          		RET
042197             5680  ;
042197             5681  ;FEOR - Floating-point exclusive-OR.
042197             5682  ;IEOR - Integer exclusive-OR.
042197             5683  ;
042197 CD EE 2A 04 5684  FEOR:			CALL    FIX2
04219B 7C          5685  IEOR:			LD      A,H
04219C AA          5686          		XOR     D
04219D 67          5687          		LD      H,A
04219E 7D          5688          		LD      A,L
04219F AB          5689          		XOR     E
0421A0 6F          5690          		LD      L,A
0421A1 D9          5691          		EXX
0421A2 7C          5692          		LD      A,H
0421A3 AA          5693          		XOR     D
0421A4 67          5694          		LD      H,A
0421A5 7D          5695          		LD      A,L
0421A6 AB          5696          		XOR     E
0421A7 6F          5697          		LD      L,A
0421A8 D9          5698          		EXX
0421A9 C9          5699          		RET
0421AA             5700  ;
0421AA             5701  ;FOR - Floating-point OR.
0421AA             5702  ;IOR - Integer OR.
0421AA             5703  ;
0421AA CD EE 2A 04 5704  FFOR:			CALL    FIX2
0421AE 7C          5705  IOR:			LD      A,H
0421AF B2          5706          		OR      D
0421B0 67          5707          		LD      H,A
0421B1 7D          5708          		LD      A,L
0421B2 B3          5709          		OR      E
0421B3 6F          5710          		LD      L,A
0421B4 D9          5711          		EXX
0421B5 7C          5712          		LD      A,H
0421B6 B2          5713          		OR      D
0421B7 67          5714          		LD      H,A
0421B8 7D          5715          		LD      A,L
0421B9 B3          5716          		OR      E
0421BA 6F          5717          		LD      L,A
0421BB D9          5718          		EXX
0421BC C9          5719          		RET
0421BD             5720  ;
0421BD             5721  ;FMOD - Floating-point remainder.
0421BD             5722  ;IMOD - Integer remainder.
0421BD             5723  ;
0421BD CD EE 2A 04 5724  FMOD:			CALL    FIX2
0421C1 7C          5725  IMOD:			LD      A,H
0421C2 AA          5726          		XOR     D               ;DIV RESULT SIGN
0421C3 CB 7C       5727          		BIT     7,H
0421C5 08          5728          		EX      AF,AF'
0421C6 CB 7C       5729          		BIT     7,H
0421C8 C4 0A 2B 04 5730          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421CC CD 07 2C 04 5731          		CALL    SWAP_FP
0421D0 CB 7C       5732          		BIT     7,H
0421D2 C4 0A 2B 04 5733          		CALL    NZ,NEGATE
0421D6 44          5734          		LD      B,H
0421D7 4D          5735          		LD      C,L
0421D8 21 00 00 00 5736          		LD      HL,0
0421DC D9          5737          		EXX
0421DD 44          5738          		LD      B,H
0421DE 4D          5739          		LD      C,L
0421DF 21 00 00 00 5740          		LD      HL,0
0421E3 3E DF       5741          		LD      A,-33
0421E5 CD 94 2D 04 5742          		CALL    DIVA            ;DIVIDE
0421E9 D9          5743          		EXX
0421EA 0E 00       5744          		LD      C,0             ;INTEGER MARKER
0421EC 08          5745          		EX      AF,AF'
0421ED C8          5746          		RET     Z
0421EE C3 0A 2B 04 5747          		JP      NEGATE
0421F2             5748  ;
0421F2             5749  ;BDIV - Integer division.
0421F2             5750  ;
0421F2 CD EE 2A 04 5751  FBDIV:			CALL    FIX2
0421F6 CD C1 21 04 5752  IBDIV:			CALL    IMOD
0421FA B7          5753          		OR      A
0421FB CD 07 2C 04 5754          		CALL    SWAP_FP
0421FF 0E 00       5755          		LD      C,0
042201 F0          5756          		RET     P
042202 C3 0A 2B 04 5757          		JP      NEGATE
042206             5758  ;
042206             5759  ;ISUB - Integer subtraction.
042206             5760  ;FSUB - Floating point subtraction with rounding.
042206             5761  ;
042206 CD A2 2C 04 5762  ISUB:			CALL    SUB_
04220A E0          5763          		RET     PO
04220B CD 9A 2C 04 5764          		CALL    ADD_
04220F CD CA 2B 04 5765          		CALL    FLOAT2
042213 7A          5766  FSUB:			LD      A,D
042214 EE 80       5767          		XOR     80H             ;CHANGE SIGN THEN ADD
042216 57          5768          		LD      D,A
042217 18 13       5769          		JR      FADD
042219             5770  ;
042219             5771  ;Reverse subtract.
042219             5772  ;
042219 7C          5773  RSUB:			LD      A,H
04221A EE 80       5774          		XOR     80H
04221C 67          5775          		LD      H,A
04221D 18 0D       5776          		JR      FADD
04221F             5777  ;
04221F             5778  ;IADD - Integer addition.
04221F             5779  ;FADD - Floating point addition with rounding.
04221F             5780  ;
04221F CD 9A 2C 04 5781  IADD:			CALL    ADD_
042223 E0          5782          		RET     PO
042224 CD A2 2C 04 5783          		CALL    SUB_
042228 CD CA 2B 04 5784          		CALL    FLOAT2
04222C 05          5785  FADD:			DEC     B
04222D 04          5786          		INC     B
04222E C8          5787          		RET     Z               ;ARG 2 ZERO
04222F 0D          5788          		DEC     C
042230 0C          5789          		INC     C
042231 CA 07 2C 04 5790          		JP      Z,SWAP_FP          ;ARG 1 ZERO
042235 D9          5791          		EXX
042236 01 00 00 00 5792          		LD      BC,0            ;INITIALISE
04223A D9          5793          		EXX
04223B 7C          5794          		LD      A,H
04223C AA          5795          		XOR     D               ;XOR SIGNS
04223D F5          5796          		PUSH    AF
04223E 78          5797          		LD      A,B
04223F B9          5798          		CP      C               ;COMPARE EXPONENTS
042240 DC 07 2C 04 5799          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042244 78          5800          		LD      A,B
042245 CB FC       5801          		SET     7,H             ;IMPLIED 1
042247 C4 DB 2A 04 5802          		CALL    NZ,FIX          ;ALIGN
04224B F1          5803          		POP     AF
04224C 7A          5804          		LD      A,D             ;SIGN OF LARGER
04224D CB FA       5805          		SET     7,D             ;IMPLIED 1
04224F FA 5F 22 04 5806          		JP      M,FADD3         ;SIGNS DIFFERENT
042253 CD 9A 2C 04 5807          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
042257 DC 0F 2C 04 5808          		CALL    C,DIV2          ;NORMALISE
04225B CB FC       5809          		SET     7,H
04225D 18 0D       5810          		JR      FADD4
04225F             5811  ;
04225F CD A2 2C 04 5812  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042263 DC 22 2B 04 5813          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
042267 CD A1 2B 04 5814          		CALL    FLO48
04226B 2F          5815          		CPL                     ;CHANGE RESULT SIGN
04226C D9          5816  FADD4:			EXX
04226D EB          5817          		EX      DE,HL
04226E 21 00 80 00 5818          		LD      HL,8000H
042272 B7          5819          		OR      A               ;CLEAR CARRY
042273 52 ED 42    5820          		SBC.S   HL,BC
042276 EB          5821          		EX      DE,HL
042277 D9          5822          		EXX
042278 CC 01 2C 04 5823          		CALL    Z,ODD           ;ROUND UNBIASSED
04227C DC EF 2B 04 5824          		CALL    C,ADD1_FP          ;ROUND UP
042280 DC 1C 2C 04 5825          		CALL    C,INCC
042284 CB BC       5826          		RES     7,H
042286 0D          5827          		DEC     C
042287 0C          5828          		INC     C
042288 CA 53 2C 04 5829          		JP      Z,ZERO_FP
04228C B7          5830          		OR      A               ;RESULT SIGNQ
04228D F0          5831          		RET     P               ;POSITIVE
04228E CB FC       5832          		SET     7,H             ;NEGATIVE
042290 C9          5833          		RET
042291             5834  ;
042291             5835  ;IDIV - Integer division.
042291             5836  ;FDIV - Floating point division with rounding.
042291             5837  ;
042291 CD CA 2B 04 5838  IDIV:			CALL    FLOAT2
042295 05          5839  FDIV:			DEC     B               ;TEST FOR ZERO
042296 04          5840          		INC     B
042297 3E 12       5841          		LD      A,DIVBY0
042299 CA AD 20 04 5842          		JP      Z,ERROR_FP_         ;"Division by zero"
04229D 0D          5843          		DEC     C               ;TEST FOR ZERO
04229E 0C          5844          		INC     C
04229F C8          5845          		RET     Z
0422A0 7C          5846          		LD      A,H
0422A1 AA          5847          		XOR     D               ;CALC. RESULT SIGN
0422A2 08          5848          		EX      AF,AF'          ;SAVE SIGN
0422A3 CB FA       5849          		SET     7,D             ;REPLACE IMPLIED 1's
0422A5 CB FC       5850          		SET     7,H
0422A7 C5          5851          		PUSH    BC              ;SAVE EXPONENTS
0422A8 42          5852          		LD      B,D             ;LOAD REGISTERS
0422A9 4B          5853          		LD      C,E
0422AA 11 00 00 00 5854          		LD      DE,0
0422AE D9          5855          		EXX
0422AF 42          5856          		LD      B,D
0422B0 4B          5857          		LD      C,E
0422B1 11 00 00 00 5858          		LD      DE,0
0422B5 3E E0       5859          		LD      A,-32           ;LOOP COUNTER
0422B7 CD 94 2D 04 5860          		CALL    DIVA            ;DIVIDE
0422BB D9          5861          		EXX
0422BC CB 7A       5862          		BIT     7,D
0422BE D9          5863          		EXX
0422BF CC B3 2D 04 5864          		CALL    Z,DIVB          ;NORMALISE & INC A
0422C3 EB          5865          		EX      DE,HL
0422C4 D9          5866          		EXX
0422C5 CB 38       5867          		SRL     B               ;DIVISOR/2
0422C7 CB 19       5868          		RR      C
0422C9 B7          5869          		OR      A               ;CLEAR CARRY
0422CA 52 ED 42    5870          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422CD 3F          5871          		CCF
0422CE EB          5872          		EX      DE,HL           ;RESULT IN HLH'L'
0422CF CC 01 2C 04 5873          		CALL    Z,ODD           ;ROUND UNBIASSED
0422D3 DC EF 2B 04 5874          		CALL    C,ADD1_FP          ;ROUND UP
0422D7 C1          5875          		POP     BC              ;RESTORE EXPONENTS
0422D8 DC 1C 2C 04 5876          		CALL    C,INCC
0422DC 1F          5877          		RRA                     ;LSB OF A TO CARRY
0422DD 79          5878          		LD      A,C             ;COMPUTE NEW EXPONENT
0422DE 98          5879          		SBC     A,B
0422DF 3F          5880          		CCF
0422E0 C3 81 23 04 5881          		JP      CHKOVF
0422E4             5882  ;
0422E4             5883  ;IMUL - Integer multiplication.
0422E4             5884  ;
0422E4 7C          5885  IMUL:			LD      A,H
0422E5 AA          5886          		XOR     D
0422E6 08          5887          		EX      AF,AF'          ;SAVE RESULT SIGN
0422E7 CB 7C       5888          		BIT     7,H
0422E9 C4 0A 2B 04 5889          		CALL    NZ,NEGATE
0422ED CD 07 2C 04 5890          		CALL    SWAP_FP
0422F1 CB 7C       5891          		BIT     7,H
0422F3 C4 0A 2B 04 5892          		CALL    NZ,NEGATE
0422F7 44          5893          		LD      B,H
0422F8 4D          5894          		LD      C,L
0422F9 21 00 00 00 5895          		LD      HL,0
0422FD D9          5896          		EXX
0422FE 44          5897          		LD      B,H
0422FF 4D          5898          		LD      C,L
042300 21 00 00 00 5899          		LD      HL,0
042304 3E DF       5900          		LD      A,-33
042306 CD CB 2D 04 5901          		CALL    MULA            ;MULTIPLY
04230A D9          5902          		EXX
04230B 0E BF       5903          		LD      C,191           ;PRESET EXPONENT
04230D CD 2F 2C 04 5904          		CALL    TEST_FP            ;TEST RANGE
042311 20 0F       5905          		JR      NZ,IMUL1        ;TOO BIG
042313 CB 7A       5906          		BIT     7,D
042315 20 0B       5907          		JR      NZ,IMUL1
042317 CD 07 2C 04 5908          		CALL    SWAP_FP
04231B 4A          5909          		LD      C,D             ;INTEGER MARKER
04231C 08          5910          		EX      AF,AF'
04231D F0          5911          		RET     P
04231E C3 0A 2B 04 5912          		JP      NEGATE
042322             5913  ;
042322 0D          5914  IMUL1:			DEC     C
042323 D9          5915          		EXX
042324 CB 23       5916          		SLA     E
042326 CB 12       5917          		RL      D
042328 D9          5918          		EXX
042329 CB 13       5919          		RL      E
04232B CB 12       5920          		RL      D
04232D D9          5921          		EXX
04232E 52 ED 6A    5922          		ADC.S   HL,HL
042331 D9          5923          		EXX
042332 52 ED 6A    5924          		ADC.S   HL,HL
042335 F2 22 23 04 5925          		JP      P,IMUL1         ;NORMALISE
042339 08          5926          		EX      AF,AF'
04233A F8          5927          		RET     M
04233B CB BC       5928          		RES     7,H             ;POSITIVE
04233D C9          5929          		RET
04233E             5930  ;
04233E             5931  ;FMUL - Floating point multiplication with rounding.
04233E             5932  ;
04233E 05          5933  FMUL:			DEC     B               ;TEST FOR ZERO
04233F 04          5934          		INC     B
042340 CA 53 2C 04 5935          		JP      Z,ZERO_FP
042344 0D          5936          		DEC     C               ;TEST FOR ZERO
042345 0C          5937          		INC     C
042346 C8          5938          		RET     Z
042347 7C          5939          		LD      A,H
042348 AA          5940          		XOR     D               ;CALC. RESULT SIGN
042349 08          5941          		EX      AF,AF'
04234A CB FA       5942          		SET     7,D             ;REPLACE IMPLIED 1's
04234C CB FC       5943          		SET     7,H
04234E C5          5944          		PUSH    BC              ;SAVE EXPONENTS
04234F 44          5945          		LD      B,H             ;LOAD REGISTERS
042350 4D          5946          		LD      C,L
042351 21 00 00 00 5947          		LD      HL,0
042355 D9          5948          		EXX
042356 44          5949          		LD      B,H
042357 4D          5950          		LD      C,L
042358 21 00 00 00 5951          		LD      HL,0
04235C 3E E0       5952          		LD      A,-32           ;LOOP COUNTER
04235E CD CB 2D 04 5953          		CALL    MULA            ;MULTIPLY
042362 DC E1 2D 04 5954          		CALL    C,MULB          ;NORMALISE & INC A
042366 D9          5955          		EXX
042367 E5          5956          		PUSH    HL
042368 21 00 80 00 5957          		LD      HL,8000H
04236C B7          5958          		OR      A               ;CLEAR CARRY
04236D 52 ED 52    5959          		SBC.S   HL,DE
042370 E1          5960          		POP     HL
042371 CC 01 2C 04 5961          		CALL    Z,ODD           ;ROUND UNBIASSED
042375 DC EF 2B 04 5962          		CALL    C,ADD1_FP          ;ROUND UP
042379 C1          5963          		POP     BC              ;RESTORE EXPONENTS
04237A DC 1C 2C 04 5964          		CALL    C,INCC
04237E 1F          5965          		RRA                     ;LSB OF A TO CARRY
04237F 79          5966          		LD      A,C             ;COMPUTE NEW EXPONENT
042380 88          5967          		ADC     A,B
042381 38 06       5968  CHKOVF:			JR      C,CHKO1
042383 F2 53 2C 04 5969          		JP      P,ZERO_FP          ;UNDERFLOW
042387 18 04       5970          		JR      CHKO2
042389 FA 1E 2C 04 5971  CHKO1:			JP      M,OFLOW         ;OVERFLOW
04238D C6 80       5972  CHKO2:			ADD     A,80H
04238F 4F          5973          		LD      C,A
042390 CA 53 2C 04 5974          		JP      Z,ZERO_FP
042394 08          5975          		EX      AF,AF'          ;RESTORE SIGN BIT
042395 CB BC       5976          		RES     7,H
042397 F0          5977          		RET     P
042398 CB FC       5978          		SET     7,H
04239A C9          5979          		RET
04239B             5980  ;
04239B             5981  ;IPOW - Integer involution.
04239B             5982  ;
04239B CD 07 2C 04 5983  IPOW:			CALL    SWAP_FP
04239F CB 7C       5984          		BIT     7,H
0423A1 F5          5985          		PUSH    AF              ;SAVE SIGN
0423A2 C4 0A 2B 04 5986          		CALL    NZ,NEGATE
0423A6 48          5987  IPOW0:			LD      C,B
0423A7 06 20       5988          		LD      B,32            ;LOOP COUNTER
0423A9 CD BF 2C 04 5989  IPOW1:			CALL    X2
0423AD 38 08       5990          		JR      C,IPOW2
0423AF 10 F8       5991          		DJNZ    IPOW1
0423B1 F1          5992          		POP     AF
0423B2 D9          5993          		EXX
0423B3 2C          5994          		INC     L               ;RESULT=1
0423B4 D9          5995          		EXX
0423B5 4C          5996          		LD      C,H
0423B6 C9          5997          		RET
0423B7             5998  ;
0423B7 F1          5999  IPOW2:			POP     AF
0423B8 C5          6000          		PUSH    BC
0423B9 EB          6001          		EX      DE,HL
0423BA E5          6002          		PUSH    HL
0423BB D9          6003          		EXX
0423BC EB          6004          		EX      DE,HL
0423BD E5          6005          		PUSH    HL
0423BE D9          6006          		EXX
0423BF DD 21 00 00 6007          		LD      IX,0
       00          
0423C4 DD 39       6008          		ADD     IX,SP
0423C6 28 48       6009          		JR      Z,IPOW4
0423C8 C5          6010          		PUSH    BC
0423C9 D9          6011          		EXX
0423CA D5          6012          		PUSH    DE
0423CB D9          6013          		EXX
0423CC D5          6014          		PUSH    DE
0423CD CD D6 2B 04 6015          		CALL    SFLOAT_FP
0423D1 CD 0A 27 04 6016          		CALL    RECIP
0423D5 DD 71 04    6017          		LD      (IX+4),C
0423D8 D9          6018          		EXX
0423D9 DD 75 00    6019          		LD      (IX+0),L
0423DC DD 74 01    6020          		LD      (IX+1),H
0423DF D9          6021          		EXX
0423E0 DD 75 02    6022          		LD      (IX+2),L
0423E3 DD 74 03    6023          		LD      (IX+3),H
0423E6 18 21       6024          		JR      IPOW5
0423E8             6025  ;
0423E8 C5          6026  IPOW3:			PUSH    BC
0423E9 D9          6027          		EXX
0423EA CB 23       6028          		SLA     E
0423EC CB 12       6029          		RL      D
0423EE D5          6030          		PUSH    DE
0423EF D9          6031          		EXX
0423F0 CB 13       6032          		RL      E
0423F2 CB 12       6033          		RL      D
0423F4 D5          6034          		PUSH    DE
0423F5 3E 0A       6035          		LD      A,'*' & 0FH
0423F7 F5          6036          		PUSH    AF
0423F8 CD D3 2C 04 6037          		CALL    COPY_
0423FC CD B3 20 04 6038          		CALL    OP              ;SQUARE
042400 F1          6039          		POP     AF
042401 CD FF 29 04 6040          		CALL    DLOAD5
042405 DC B3 20 04 6041          		CALL    C,OP            ;MULTIPLY BY X
042409 D1          6042  IPOW5:			POP     DE
04240A D9          6043          		EXX
04240B D1          6044          		POP     DE
04240C D9          6045          		EXX
04240D 79          6046          		LD      A,C
04240E C1          6047          		POP     BC
04240F 4F          6048          		LD      C,A
042410 10 D6       6049  IPOW4:			DJNZ    IPOW3
042412 F1          6050          		POP     AF
042413 F1          6051          		POP     AF
042414 F1          6052          		POP     AF
042415 C9          6053          		RET
042416             6054  ;
042416 F1          6055  FPOW0:			POP     AF
042417 F1          6056          		POP     AF
042418 F1          6057          		POP     AF
042419 18 8B       6058          		JR      IPOW0
04241B             6059  ;
04241B             6060  ;FPOW - Floating-point involution.
04241B             6061  ;
04241B CB 7A       6062  FPOW:			BIT     7,D
04241D F5          6063          		PUSH    AF
04241E CD 07 2C 04 6064          		CALL    SWAP_FP
042422 CD E3 2C 04 6065          		CALL    PUSH5
042426 0D          6066          		DEC     C
042427 0C          6067          		INC     C
042428 28 EC       6068          		JR      Z,FPOW0
04242A 3E 9E       6069          		LD      A,158
04242C B9          6070          		CP      C
04242D 38 0A       6071          		JR      C,FPOW1
04242F 3C          6072          		INC     A
042430 CD DB 2A 04 6073          		CALL    FIX
042434 08          6074          		EX      AF,AF'
042435 F2 16 24 04 6075          		JP      P,FPOW0
042439 CD 07 2C 04 6076  FPOW1:			CALL    SWAP_FP
04243D CD 27 27 04 6077          		CALL    LN0
042441 CD EC 2C 04 6078          		CALL    POP5
042445 F1          6079          		POP     AF
042446 CD 3E 23 04 6080          		CALL    FMUL
04244A C3 89 26 04 6081          		JP      EXP0
04244E             6082  ;
04244E             6083  ;Integer and floating-point compare.
04244E             6084  ;Result is TRUE (-1) or FALSE (0).
04244E             6085  ;
04244E CD 5D 2C 04 6086  FLT:			CALL    FCP
042452 18 04       6087          		JR      ILT1
042454 CD 4F 2C 04 6088  ILT:			CALL    ICP
042458 D0          6089  ILT1:			RET     NC
042459 18 42       6090          		JR      TRUE_FP
04245B             6091  ;
04245B CD 5D 2C 04 6092  FGT:			CALL    FCP
04245F 18 04       6093          		JR      IGT1
042461 CD 4F 2C 04 6094  IGT:			CALL    ICP
042465 C8          6095  IGT1:			RET     Z
042466 D8          6096          		RET     C
042467 18 34       6097          		JR      TRUE_FP
042469             6098  ;
042469 CD 5D 2C 04 6099  FGE:			CALL    FCP
04246D 18 04       6100          		JR      IGE1
04246F CD 4F 2C 04 6101  IGE:			CALL    ICP
042473 D8          6102  IGE1:			RET     C
042474 18 27       6103          		JR      TRUE_FP
042476             6104  ;
042476 CD 5D 2C 04 6105  FLE:			CALL    FCP
04247A 18 04       6106          		JR      ILE1
04247C CD 4F 2C 04 6107  ILE:			CALL    ICP
042480 28 1B       6108  ILE1:			JR      Z,TRUE_FP
042482 D0          6109          		RET     NC
042483 18 18       6110          		JR      TRUE_FP
042485             6111  ;
042485 CD 5D 2C 04 6112  FNE:			CALL    FCP
042489 18 04       6113          		JR      INE1
04248B CD 4F 2C 04 6114  INE:			CALL    ICP
04248F C8          6115  INE1:			RET     Z
042490 18 0B       6116          		JR      TRUE_FP
042492             6117  ;
042492 CD 5D 2C 04 6118  FEQ:			CALL    FCP
042496 18 04       6119          		JR      IEQ1
042498 CD 4F 2C 04 6120  IEQ:			CALL    ICP
04249C C0          6121  IEQ1:			RET     NZ
04249D 21 FF FF FF 6122  TRUE_FP:			LD      HL,-1
0424A1 D9          6123          		EXX
0424A2 21 FF FF FF 6124          		LD      HL,-1
0424A6 D9          6125          		EXX
0424A7 AF          6126          		XOR     A
0424A8 4F          6127          		LD      C,A
0424A9 C9          6128          		RET
0424AA             6129  ;
0424AA             6130  ;FUNCTIONS:
0424AA             6131  ;
0424AA             6132  ;Result returned in HLH'L'C (floating point)
0424AA             6133  ;Result returned in HLH'L' (C=0) (integer)
0424AA             6134  ;All registers except IY destroyed.
0424AA             6135  ;
0424AA             6136  ;ABS - Absolute value
0424AA             6137  ;Result is numeric, variable type.
0424AA             6138  ;
0424AA CB 7C       6139  ABSV_FP:			BIT     7,H
0424AC C8          6140          		RET     Z               ;POSITIVE/ZERO
0424AD 0D          6141          		DEC     C
0424AE 0C          6142          		INC     C
0424AF CA 0A 2B 04 6143          		JP      Z,NEGATE        ;INTEGER
0424B3 CB BC       6144          		RES     7,H
0424B5 C9          6145          		RET
0424B6             6146  ;
0424B6             6147  ;NOT - Complement integer.
0424B6             6148  ;Result is integer numeric.
0424B6             6149  ;
0424B6 CD FA 2A 04 6150  NOTK_FP:			CALL    SFIX_FP
0424BA 7C          6151          		LD      A,H
0424BB 2F          6152          		CPL
0424BC 67          6153          		LD      H,A
0424BD 7D          6154          		LD      A,L
0424BE 2F          6155          		CPL
0424BF 6F          6156          		LD      L,A
0424C0 D9          6157          		EXX
0424C1 7C          6158          		LD      A,H
0424C2 2F          6159          		CPL
0424C3 67          6160          		LD      H,A
0424C4 7D          6161          		LD      A,L
0424C5 2F          6162          		CPL
0424C6 6F          6163          		LD      L,A
0424C7 D9          6164          		EXX
0424C8 AF          6165          		XOR     A               ;NUMERIC MARKER
0424C9 C9          6166          		RET
0424CA             6167  ;
0424CA             6168  ;PI - Return PI (3.141592654)
0424CA             6169  ;Result is floating-point numeric.
0424CA             6170  ;
0424CA 21 0F 49 00 6171  PI_FP:			LD      HL,490FH
0424CE D9          6172          		EXX
0424CF 21 A2 DA 00 6173          		LD      HL,0DAA2H
0424D3 D9          6174          		EXX
0424D4 0E 81       6175          		LD      C,81H
0424D6 AF          6176          		XOR     A               ;NUMERIC MARKER
0424D7 C9          6177          		RET
0424D8             6178  ;
0424D8             6179  ;DEG - Convert radians to degrees
0424D8             6180  ;Result is floating-point numeric.
0424D8             6181  ;
0424D8 CD EC 24 04 6182  DEG_FP:			CALL    FPI180
0424DC CD 3E 23 04 6183          		CALL    FMUL
0424E0 AF          6184          		XOR     A
0424E1 C9          6185          		RET
0424E2             6186  ;
0424E2             6187  ;RAD - Convert degrees to radians
0424E2             6188  ;Result is floating-point numeric.
0424E2             6189  ;
0424E2 CD EC 24 04 6190  RAD_FP:			CALL    FPI180
0424E6 CD 95 22 04 6191          		CALL    FDIV
0424EA AF          6192          		XOR     A
0424EB C9          6193          		RET
0424EC             6194  ;
0424EC             6195  ;180/PI
0424EC             6196  ;
0424EC CD D6 2B 04 6197  FPI180:			CALL    SFLOAT_FP
0424F0 11 2E 65 00 6198          		LD      DE,652EH
0424F4 D9          6199          		EXX
0424F5 11 D3 E0 00 6200          		LD      DE,0E0D3H
0424F9 D9          6201          		EXX
0424FA 06 85       6202          		LD      B,85H
0424FC C9          6203          		RET
0424FD             6204  ;
0424FD             6205  ;SGN - Return -1, 0 or +1
0424FD             6206  ;Result is integer numeric.
0424FD             6207  ;
0424FD CD 2F 2C 04 6208  SGN_FP:			CALL    TEST_FP
042501 B1          6209          		OR      C
042502 C8          6210          		RET     Z               ;ZERO
042503 CB 7C       6211          		BIT     7,H
042505 C2 9D 24 04 6212          		JP      NZ,TRUE_FP         ;-1
042509 CD 53 2C 04 6213          		CALL    ZERO_FP
04250D C3 EF 2B 04 6214          		JP      ADD1_FP            ;1
042511             6215  ;
042511             6216  ;VAL - Return numeric value of string.
042511             6217  ;Input: ASCII string at IX
042511             6218  ;Result is variable type numeric.
042511             6219  ;
042511 CD 6D 2E 04 6220  VAL_FP:			CALL    SIGNQ
042515 F5          6221          		PUSH    AF
042516 CD 1D 2A 04 6222          		CALL    CON_FP
04251A F1          6223          		POP     AF
04251B FE 2D       6224          		CP      '-'
04251D 3E 00       6225          		LD      A,0             ;NUMERIC MARKER
04251F C0          6226          		RET     NZ
042520 0D          6227          		DEC     C
042521 0C          6228          		INC     C
042522 CA 0A 2B 04 6229          		JP      Z,NEGATE        ;ZERO/INTEGER
042526 7C          6230          		LD      A,H
042527 EE 80       6231          		XOR     80H             ;CHANGE SIGN (FP)
042529 67          6232          		LD      H,A
04252A AF          6233          		XOR     A
04252B C9          6234          		RET
04252C             6235  ;
04252C             6236  ;INT - Floor function
04252C             6237  ;Result is integer numeric.
04252C             6238  ;
04252C 0D          6239  INT_FP_:			DEC     C
04252D 0C          6240          		INC     C
04252E C8          6241          		RET     Z               ;ZERO/INTEGER
04252F 3E 9F       6242          		LD      A,159
042531 44          6243          		LD      B,H             ;B7=SIGN BIT
042532 CD DB 2A 04 6244          		CALL    FIX
042536 08          6245          		EX      AF,AF'
042537 A0          6246          		AND     B
042538 FC EF 2B 04 6247          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04253C 78          6248          		LD      A,B
04253D B7          6249          		OR      A
04253E FC 0A 2B 04 6250          		CALL    M,NEGATE
042542 AF          6251          		XOR     A
042543 4F          6252          		LD      C,A
042544 C9          6253          		RET
042545             6254  ;
042545             6255  ;SQR - square root
042545             6256  ;Result is floating-point numeric.
042545             6257  ;
042545 CD D6 2B 04 6258  SQR_FP:			CALL    SFLOAT_FP
042549 CB 7C       6259  SQR0:			BIT     7,H
04254B 3E 15       6260          		LD      A,NGROOT
04254D C2 AD 20 04 6261          		JP      NZ,ERROR_FP_        ;"-ve root"
042551 0D          6262          		DEC     C
042552 0C          6263          		INC     C
042553 C8          6264          		RET     Z               ;ZERO
042554 CB FC       6265          		SET     7,H             ;IMPLIED 1
042556 CB 41       6266          		BIT     0,C
042558 CC 0F 2C 04 6267          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
04255C 79          6268          		LD      A,C
04255D D6 80       6269          		SUB     80H
04255F CB 2F       6270          		SRA     A               ;HALVE EXPONENT
042561 C6 80       6271          		ADD     A,80H
042563 4F          6272          		LD      C,A
042564 C5          6273          		PUSH    BC              ;SAVE EXPONENT
042565 EB          6274          		EX      DE,HL
042566 21 00 00 00 6275          		LD      HL,0
04256A 44          6276          		LD      B,H
04256B 4D          6277          		LD      C,L
04256C D9          6278          		EXX
04256D EB          6279          		EX      DE,HL
04256E 21 00 00 00 6280          		LD      HL,0
042572 44          6281          		LD      B,H
042573 4D          6282          		LD      C,L
042574 3E E1       6283          		LD      A,-31
042576 CD 05 2E 04 6284          		CALL    SQRA            ;ROOT
04257A D9          6285          		EXX
04257B CB 78       6286          		BIT     7,B
04257D D9          6287          		EXX
04257E CC 05 2E 04 6288          		CALL    Z,SQRA          ;NORMALISE & INC A
042582 CD 46 2E 04 6289          		CALL    SQRB
042586 B7          6290          		OR      A               ;CLEAR CARRY
042587 CD B3 2D 04 6291          		CALL    DIVB
04258B CB 1B       6292          		RR      E               ;LSB TO CARRY
04258D 60          6293          		LD      H,B
04258E 69          6294          		LD      L,C
04258F D9          6295          		EXX
042590 60          6296          		LD      H,B
042591 69          6297          		LD      L,C
042592 DC EF 2B 04 6298          		CALL    C,ADD1_FP          ;ROUND UP
042596 C1          6299          		POP     BC              ;RESTORE EXPONENT
042597 DC 1C 2C 04 6300          		CALL    C,INCC
04259B 1F          6301          		RRA
04259C 9F          6302          		SBC     A,A
04259D 81          6303          		ADD     A,C
04259E 4F          6304          		LD      C,A
04259F CB BC       6305          		RES     7,H             ;POSITIVE
0425A1 AF          6306          		XOR     A
0425A2 C9          6307          		RET
0425A3             6308  ;
0425A3             6309  ;TAN - Tangent function
0425A3             6310  ;Result is floating-point numeric.
0425A3             6311  ;
0425A3 CD D6 2B 04 6312  TAN_FP:			CALL    SFLOAT_FP
0425A7 CD E3 2C 04 6313          		CALL    PUSH5
0425AB CD CD 25 04 6314          		CALL    COS0
0425AF CD EC 2C 04 6315          		CALL    POP5
0425B3 CD E3 2C 04 6316          		CALL    PUSH5
0425B7 CD 07 2C 04 6317          		CALL    SWAP_FP
0425BB CD DA 25 04 6318          		CALL    SIN0
0425BF CD EC 2C 04 6319          		CALL    POP5
0425C3 CD 95 22 04 6320          		CALL    FDIV
0425C7 AF          6321          		XOR     A               ;NUMERIC MARKER
0425C8 C9          6322          		RET
0425C9             6323  ;
0425C9             6324  ;COS - Cosine function
0425C9             6325  ;Result is floating-point numeric.
0425C9             6326  ;
0425C9 CD D6 2B 04 6327  COS_FP:			CALL    SFLOAT_FP
0425CD CD 32 2B 04 6328  COS0:			CALL    SCALE
0425D1 1C          6329          		INC     E
0425D2 1C          6330          		INC     E
0425D3 7B          6331          		LD      A,E
0425D4 18 10       6332          		JR      SIN1
0425D6             6333  ;
0425D6             6334  ;SIN - Sine function
0425D6             6335  ;Result is floating-point numeric.
0425D6             6336  ;
0425D6 CD D6 2B 04 6337  SIN_FP:			CALL    SFLOAT_FP
0425DA E5          6338  SIN0:			PUSH    HL              ;H7=SIGN
0425DB CD 32 2B 04 6339          		CALL    SCALE
0425DF F1          6340          		POP     AF
0425E0 07          6341          		RLCA
0425E1 07          6342          		RLCA
0425E2 07          6343          		RLCA
0425E3 E6 04       6344          		AND     4
0425E5 AB          6345          		XOR     E
0425E6 F5          6346  SIN1:			PUSH    AF              ;OCTANT
0425E7 CB BC       6347          		RES     7,H
0425E9 1F          6348          		RRA
0425EA CD 78 26 04 6349          		CALL    PIBY4
0425EE DC 19 22 04 6350          		CALL    C,RSUB          ;X=(PI/4)-X
0425F2 F1          6351          		POP     AF
0425F3 F5          6352          		PUSH    AF
0425F4 E6 03       6353          		AND     3
0425F6 E2 2F 26 04 6354          		JP      PO,SIN2         ;USE COSINE APPROX.
0425FA CD E3 2C 04 6355          		CALL    PUSH5           ;SAVE X
0425FE CD DB 2C 04 6356          		CALL    SQUARE          ;PUSH X*X
042602 CD 20 2D 04 6357          		CALL    POLY
042606 B7 A8       6358          		DW	0A8B7H          ;a(8)
042608 11 36       6359          		DW	3611H
04260A 6D          6360          		DB	6DH
04260B 26 DE       6361          		DW	0DE26H          ;a(6)
04260D 05 D0       6362          		DW	0D005H
04260F 73          6363          		DB	73H
042610 C0 80       6364          		DW	80C0H           ;a(4)
042612 88 08       6365          		DW	888H
042614 79          6366          		DB	79H
042615 9D AA       6367          		DW	0AA9DH          ;a(2)
042617 AA AA       6368          		DW	0AAAAH
042619 7D          6369          		DB	7DH
04261A 00 00       6370          		DW	0               ;a(0)
04261C 00 00       6371          		DW	0
04261E 80          6372          		DB	80H
04261F CD EC 2C 04 6373          		CALL    POP5
042623 CD EC 2C 04 6374          		CALL    POP5
042627 CD 3E 23 04 6375          		CALL    FMUL
04262B C3 54 26 04 6376          		JP      SIN3
04262F             6377  ;
04262F CD DB 2C 04 6378  SIN2:			CALL    SQUARE          ;PUSH X*X
042633 CD 20 2D 04 6379          		CALL    POLY
042637 71 D5       6380          		DW	0D571H          ;b(8)
042639 78 4C       6381          		DW	4C78H
04263B 70          6382          		DB	70H
04263C AF 94       6383          		DW	94AFH           ;b(6)
04263E 03 B6       6384          		DW	0B603H
042640 76          6385          		DB	76H
042641 C8 9C       6386          		DW	9CC8H           ;b(4)
042643 AA 2A       6387          		DW	2AAAH
042645 7B          6388          		DB	7BH
042646 DD FF       6389          		DW	0FFDDH          ;b(2)
042648 FF FF       6390          		DW	0FFFFH
04264A 7E          6391          		DB	7EH
04264B 00 00       6392          		DW	0               ;b(0)
04264D 00 00       6393          		DW	0
04264F 80          6394          		DB	80H
042650 CD EC 2C 04 6395          		CALL    POP5
042654 F1          6396  SIN3:			POP     AF
042655 E6 04       6397          		AND     4
042657 C8          6398          		RET     Z
042658 0D          6399          		DEC     C
042659 0C          6400          		INC     C
04265A C8          6401          		RET     Z               ;ZERO
04265B CB FC       6402          		SET     7,H             ;MAKE NEGATIVE
04265D C9          6403          		RET
04265E             6404  ;
04265E             6405  ;Floating-point one:
04265E             6406  ;
04265E 21 00 00 00 6407  FONE_FP:			LD      HL,0
042662 D9          6408          		EXX
042663 21 00 00 00 6409          		LD      HL,0
042667 D9          6410          		EXX
042668 0E 80       6411          		LD      C,80H
04266A C9          6412          		RET
04266B             6413  ;
04266B 11 00 00 00 6414  DONE:			LD      DE,0
04266F D9          6415          		EXX
042670 11 00 00 00 6416          		LD      DE,0
042674 D9          6417          		EXX
042675 06 80       6418          		LD      B,80H
042677 C9          6419          		RET
042678             6420  ;
042678 11 0F 49 00 6421  PIBY4:			LD      DE,490FH
04267C D9          6422          		EXX
04267D 11 A2 DA 00 6423          		LD      DE,0DAA2H
042681 D9          6424          		EXX
042682 06 7F       6425          		LD      B,7FH
042684 C9          6426          		RET
042685             6427  ;
042685             6428  ;EXP - Exponential function
042685             6429  ;Result is floating-point numeric.
042685             6430  ;
042685 CD D6 2B 04 6431  EXP_FP:			CALL    SFLOAT_FP
042689 CD 16 27 04 6432  EXP0:			CALL    LN2             ;LN(2)
04268D D9          6433          		EXX
04268E 1D          6434  	        	DEC     E
04268F 01 CF D1 00 6435  		        LD      BC,0D1CFH       ;0.6931471805599453
042693 D9          6436          		EXX
042694 E5          6437          		PUSH    HL              ;H7=SIGN
042695 CD 45 2B 04 6438          		CALL    MOD48           ;"MODULUS"
042699 F1          6439          		POP     AF
04269A CB 7B       6440          		BIT     7,E
04269C 28 0B       6441          		JR      Z,EXP1
04269E 17          6442          		RLA
04269F DA 53 2C 04 6443          		JP      C,ZERO_FP
0426A3 3E 18       6444          		LD      A,EXPRNG
0426A5 C3 AD 20 04 6445          		JP      ERROR_FP_           ;"Exp range"
0426A9             6446  ;
0426A9 E6 80       6447  EXP1:			AND     80H
0426AB B3          6448          		OR      E
0426AC F5          6449          		PUSH    AF              ;INTEGER PART
0426AD CB BC       6450          		RES     7,H
0426AF CD E3 2C 04 6451          		CALL    PUSH5           ;PUSH X*LN(2)
0426B3 CD 20 2D 04 6452          		CALL    POLY
0426B7 72 40       6453          		DW	4072H           ;a(7)
0426B9 2E 94       6454          		DW	942EH
0426BB 73          6455          		DB	73H
0426BC 65 6F       6456          		DW	6F65H           ;a(6)
0426BE 4F 2E       6457          		DW	2E4FH
0426C0 76          6458          		DB	76H
0426C1 37 6D       6459          		DW	6D37H           ;a(5)
0426C3 02 88       6460          		DW	8802H
0426C5 79          6461          		DB	79H
0426C6 12 E5       6462          		DW	0E512H          ;a(4)
0426C8 A0 2A       6463          		DW	2AA0H
0426CA 7B          6464          		DB	7BH
0426CB 14 4F       6465          		DW	4F14H           ;a(3)
0426CD AA AA       6466          		DW	0AAAAH
0426CF 7D          6467          		DB	7DH
0426D0 56 FD       6468          		DW	0FD56H          ;a(2)
0426D2 FF 7F       6469          		DW	7FFFH
0426D4 7E          6470          		DB	7EH
0426D5 FE FF       6471          		DW	0FFFEH          ;a(1)
0426D7 FF FF       6472          		DW	0FFFFH
0426D9 7F          6473          		DB	7FH
0426DA 00 00       6474          		DW	0               ;a(0)
0426DC 00 00       6475          		DW	0
0426DE 80          6476          		DB	80H
0426DF CD EC 2C 04 6477          		CALL    POP5
0426E3 F1          6478          		POP     AF
0426E4 F5          6479          		PUSH    AF
0426E5 F4 0A 27 04 6480          		CALL    P,RECIP         ;X=1/X
0426E9 F1          6481          		POP     AF
0426EA F2 F2 26 04 6482          		JP      P,EXP4
0426EE E6 7F       6483          		AND     7FH
0426F0 ED 44       6484          		NEG
0426F2 C6 80       6485  EXP4:			ADD     A,80H
0426F4 81          6486          		ADD     A,C
0426F5 38 06       6487          		JR      C,EXP2
0426F7 F2 53 2C 04 6488          		JP      P,ZERO_FP          ;UNDERFLOW
0426FB 18 04       6489          		JR      EXP3
0426FD FA 1E 2C 04 6490  EXP2:			JP      M,OFLOW         ;OVERFLOW
042701 C6 80       6491  EXP3:			ADD     A,80H
042703 CA 53 2C 04 6492          		JP      Z,ZERO_FP
042707 4F          6493          		LD      C,A
042708 AF          6494          		XOR     A               ;NUMERIC MARKER
042709 C9          6495          		RET
04270A             6496  ;
04270A CD 6B 26 04 6497  RECIP:			CALL    DONE
04270E CD 07 2C 04 6498  RDIV:			CALL    SWAP_FP
042712 C3 95 22 04 6499          		JP      FDIV            ;RECIPROCAL
042716             6500  ;
042716 11 72 31 00 6501  LN2:			LD      DE,3172H        ;LN(2)
04271A D9          6502          		EXX
04271B 11 F8 17 00 6503          		LD      DE,17F8H
04271F D9          6504          		EXX
042720 06 7F       6505          		LD      B,7FH
042722 C9          6506          		RET
042723             6507  ;
042723             6508  ;LN - Natural log.
042723             6509  ;Result is floating-point numeric.
042723             6510  ;
042723 CD D6 2B 04 6511  LN_FP:			CALL    SFLOAT_FP
042727 3E 16       6512  LN0:			LD      A,LOGRNG
042729 CB 7C       6513          		BIT     7,H
04272B C2 AD 20 04 6514          		JP      NZ,ERROR_FP_        ;"Log range"
04272F 0C          6515          		INC     C
042730 0D          6516          		DEC     C
042731 CA AD 20 04 6517          		JP      Z,ERROR_FP_
042735 11 04 35 00 6518          		LD      DE,3504H        ;SQR(2)
042739 D9          6519          		EXX
04273A 11 33 F3 00 6520          		LD      DE,0F333H       ;1.41421356237
04273E D9          6521          		EXX
04273F CD 66 2C 04 6522          		CALL    ICP0            ;MANTISSA>SQR(2)?
042743 79          6523          		LD      A,C             ;EXPONENT
042744 0E 80       6524          		LD      C,80H           ;1 <= X < 2
042746 38 02       6525          		JR      C,LN4
042748 0D          6526          		DEC     C
042749 3C          6527          		INC     A
04274A F5          6528  LN4:			PUSH    AF              ;SAVE EXPONENT
04274B CD F8 2C 04 6529          		CALL    RATIO           ;X=(X-1)/(X+1)
04274F CD E3 2C 04 6530          		CALL    PUSH5
042753 CD DB 2C 04 6531  		        CALL    SQUARE          ;PUSH X*X
042757 CD 20 2D 04 6532          		CALL    POLY
04275B 48 CC       6533          		DW	0CC48H          ;a(9)
04275D FB 74       6534          		DW	74FBH
04275F 7D          6535          		DB	7DH
042760 AF AE       6536          		DW	0AEAFH          ;a(7)
042762 FF 11       6537          		DW	11FFH
042764 7E          6538          		DB	7EH
042765 8C D9       6539          		DW	0D98CH          ;a(5)
042767 CD 4C       6540          		DW	4CCDH
042769 7E          6541          		DB	7EH
04276A E3 A9       6542          		DW	0A9E3H          ;a(3)
04276C AA 2A       6543          		DW	2AAAH
04276E 7F          6544          		DB	7FH
04276F 00 00       6545          		DW	0               ;a(1)
042771 00 00       6546          		DW	0
042773 81          6547          		DB	81H
042774 CD EC 2C 04 6548          		CALL    POP5
042778 CD EC 2C 04 6549          		CALL    POP5
04277C CD 3E 23 04 6550          		CALL    FMUL
042780 F1          6551          		POP     AF              ;EXPONENT
042781 CD E3 2C 04 6552          		CALL    PUSH5
042785 08          6553          		EX      AF,AF'
042786 CD 53 2C 04 6554          		CALL    ZERO_FP
04278A 08          6555          		EX      AF,AF'
04278B D6 80       6556          		SUB     80H
04278D 28 1F       6557          		JR      Z,LN3
04278F 30 02       6558          		JR      NC,LN1
042791 2F          6559          		CPL
042792 3C          6560          		INC     A
042793 67          6561  LN1:			LD      H,A
042794 0E 87       6562          		LD      C,87H
042796 F5          6563          		PUSH    AF
042797 CD B6 2B 04 6564          		CALL    FLOAT_
04279B CB BC       6565          		RES     7,H
04279D CD 16 27 04 6566          		CALL    LN2
0427A1 CD 3E 23 04 6567          		CALL    FMUL
0427A5 F1          6568          		POP     AF
0427A6 30 06       6569          		JR      NC,LN3
0427A8 FA AE 27 04 6570          		JP      M,LN3
0427AC CB FC       6571          		SET     7,H
0427AE CD EC 2C 04 6572  LN3:			CALL    POP5
0427B2 CD 2C 22 04 6573          		CALL    FADD
0427B6 AF          6574          		XOR     A
0427B7 C9          6575          		RET
0427B8             6576  ;
0427B8             6577  ;LOG - base-10 logarithm.
0427B8             6578  ;Result is floating-point numeric.
0427B8             6579  ;
0427B8 CD 23 27 04 6580  LOG_FP:			CALL    LN_FP
0427BC 11 5B 5E 00 6581          		LD      DE,5E5BH        ;LOG(e)
0427C0 D9          6582          		EXX
0427C1 11 A9 D8 00 6583          		LD      DE,0D8A9H
0427C5 D9          6584          		EXX
0427C6 06 7E       6585          		LD      B,7EH
0427C8 CD 3E 23 04 6586          		CALL    FMUL
0427CC AF          6587          		XOR     A
0427CD C9          6588          		RET
0427CE             6589  ;
0427CE             6590  ;ASN - Arc-sine
0427CE             6591  ;Result is floating-point numeric.
0427CE             6592  ;
0427CE CD D6 2B 04 6593  ASN_FP:			CALL    SFLOAT_FP
0427D2 CD E3 2C 04 6594          		CALL    PUSH5
0427D6 CD D3 2C 04 6595          		CALL    COPY_
0427DA CD 3E 23 04 6596          		CALL    FMUL
0427DE CD 6B 26 04 6597          		CALL    DONE
0427E2 CD 19 22 04 6598          		CALL    RSUB
0427E6 CD 49 25 04 6599          		CALL    SQR0
0427EA CD EC 2C 04 6600          		CALL    POP5
0427EE 0C          6601          		INC     C
0427EF 0D          6602          		DEC     C
0427F0 3E 02       6603          		LD      A,2
0427F2 D5          6604          		PUSH    DE
0427F3 CA 78 28 04 6605          		JP      Z,ACS1
0427F7 D1          6606          		POP     DE
0427F8 CD 0E 27 04 6607          		CALL    RDIV
0427FC 18 04       6608          		JR      ATN0
0427FE             6609  ;
0427FE             6610  ;ATN - arc-tangent
0427FE             6611  ;Result is floating-point numeric.
0427FE             6612  ;
0427FE CD D6 2B 04 6613  ATN_FP:			CALL    SFLOAT_FP
042802 E5          6614  ATN0:			PUSH    HL              ;SAVE SIGN
042803 CB BC       6615          		RES     7,H
042805 11 13 54 00 6616          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
042809 D9          6617          		EXX
04280A 11 D0 CC 00 6618          		LD      DE,0CCD0H
04280E D9          6619          		EXX
04280F 06 7E       6620          		LD      B,7EH
042811 CD 63 2C 04 6621          		CALL    FCP0            ;COMPARE
042815 06 00       6622          		LD      B,0
042817 38 22       6623          		JR      C,ATN2
042819 11 82 1A 00 6624          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
04281D D9          6625          		EXX
04281E 11 9A 79 00 6626          		LD      DE,799AH
042822 D9          6627          		EXX
042823 06 81       6628          		LD      B,81H
042825 CD 63 2C 04 6629          		CALL    FCP0            ;COMPARE
042829 38 0A       6630          		JR      C,ATN1
04282B CD 0A 27 04 6631          		CALL    RECIP           ;X=1/X
04282F 06 02       6632          		LD      B,2
042831 C3 3B 28 04 6633          		JP      ATN2
042835 CD F8 2C 04 6634  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042839 06 01       6635          		LD      B,1
04283B C5          6636  ATN2:			PUSH    BC              ;SAVE FLAG
04283C CD E3 2C 04 6637          		CALL    PUSH5
042840 CD DB 2C 04 6638          		CALL    SQUARE          ;PUSH X*X
042844 CD 20 2D 04 6639          		CALL    POLY
042848 35 F3       6640          		DW	0F335H          ;a(13)
04284A D8 37       6641          		DW	37D8H
04284C 7B          6642          		DB	7BH
04284D 91 6B       6643          		DW	6B91H           ;a(11)
04284F B9 AA       6644          		DW	0AAB9H
042851 7C          6645          		DB	7CH
042852 DE 41       6646          		DW	41DEH           ;a(9)
042854 97 61       6647          		DW	6197H
042856 7C          6648          		DB	7CH
042857 7B 9D       6649          		DW	9D7BH           ;a(7)
042859 37 92       6650          		DW	9237H
04285B 7D          6651          		DB	7DH
04285C 5A 2A       6652          		DW	2A5AH           ;a(5)
04285E CC 4C       6653          		DW	4CCCH
042860 7D          6654          		DB	7DH
042861 5C A9       6655          		DW	0A95CH          ;a(3)
042863 AA AA       6656          		DW	0AAAAH
042865 7E          6657          		DB	7EH
042866 00 00       6658          		DW	0               ;a(1)
042868 00 00       6659          		DW	0
04286A 80          6660          		DB	80H
04286B CD EC 2C 04 6661          		CALL    POP5
04286F CD EC 2C 04 6662          		CALL    POP5
042873 CD 3E 23 04 6663          		CALL    FMUL
042877 F1          6664          		POP     AF
042878 CD 78 26 04 6665  ACS1:			CALL    PIBY4           ;PI/4
04287C 1F          6666          		RRA
04287D F5          6667          		PUSH    AF
04287E DC 2C 22 04 6668          		CALL    C,FADD
042882 F1          6669          		POP     AF
042883 04          6670          		INC     B
042884 1F          6671          		RRA
042885 DC 19 22 04 6672          		CALL    C,RSUB
042889 F1          6673          		POP     AF
04288A B7          6674          		OR      A
04288B F0          6675          		RET     P
04288C CB FC       6676          		SET     7,H             ;MAKE NEGATIVE
04288E AF          6677          		XOR     A
04288F C9          6678          		RET
042890             6679  ;
042890             6680  ;ACS - Arc cosine=PI/2-ASN.
042890             6681  ;Result is floating point numeric.
042890             6682  ;
042890 CD CE 27 04 6683  ACS_FP:			CALL    ASN_FP
042894 3E 02       6684          		LD      A,2
042896 F5          6685          		PUSH    AF
042897 18 DF       6686          		JR      ACS1
042899             6687  ;
042899             6688  ;Function STR - convert numeric value to ASCII string.
042899             6689  ;   Inputs: HLH'L'C = integer or floating-point number
042899             6690  ;           DE = address at which to store string
042899             6691  ;           IX = address of @% format control
042899             6692  ;  Outputs: String stored, with NUL terminator
042899             6693  ;
042899             6694  ;First normalise for decimal output:
042899             6695  ;
042899 CD D6 2B 04 6696  STR_FP:			CALL    SFLOAT_FP
04289D 06 00       6697          		LD      B,0             ;DEFAULT PT. POSITION
04289F CB 7C       6698          		BIT     7,H             ;NEGATIVE?
0428A1 28 06       6699          		JR      Z,STR10
0428A3 CB BC       6700          		RES     7,H
0428A5 3E 2D       6701          		LD      A,'-'
0428A7 12          6702          		LD      (DE),A          ;STORE SIGN
0428A8 13          6703          		INC     DE
0428A9 AF          6704  STR10:			XOR     A               ;CLEAR A
0428AA B9          6705          		CP      C
0428AB 28 4E       6706          		JR      Z,STR02          ;ZERO
0428AD D5          6707          		PUSH    DE              ;SAVE TEXT POINTER
0428AE 78          6708          		LD      A,B
0428AF F5          6709  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B0 79          6710          		LD      A,C             ;BINARY EXPONENT
0428B1 FE A1       6711          		CP      161
0428B3 30 1C       6712          		JR      NC,STR14
0428B5 FE 9B       6713          		CP      155
0428B7 30 29       6714          		JR      NC,STR15
0428B9 2F          6715          		CPL
0428BA FE E1       6716          		CP      225
0428BC 38 02       6717          		JR      C,STR13
0428BE 3E F8       6718          		LD      A,-8
0428C0 C6 1C       6719  STR13:			ADD     A,28
0428C2 CD 4F 2D 04 6720          		CALL    POWR10
0428C6 F5          6721          		PUSH    AF
0428C7 CD 3E 23 04 6722          		CALL    FMUL
0428CB F1          6723          		POP     AF
0428CC 47          6724          		LD      B,A
0428CD F1          6725          		POP     AF
0428CE 90          6726          		SUB     B
0428CF 18 DE       6727          		JR      STR11
0428D1 D6 20       6728  STR14:			SUB     32
0428D3 CD 4F 2D 04 6729          		CALL    POWR10
0428D7 F5          6730          		PUSH    AF
0428D8 CD 95 22 04 6731          		CALL    FDIV
0428DC F1          6732          		POP     AF
0428DD 47          6733          		LD      B,A
0428DE F1          6734          		POP     AF
0428DF 80          6735          		ADD     A,B
0428E0 18 CD       6736          		JR      STR11
0428E2 3E 09       6737  STR15:			LD      A,9
0428E4 CD 4F 2D 04 6738          		CALL    POWR10          ;10^9
0428E8 CD 63 2C 04 6739          		CALL    FCP0
0428EC 79          6740          		LD      A,C
0428ED C1          6741          		POP     BC
0428EE 4F          6742          		LD      C,A
0428EF CB FC       6743          		SET     7,H             ;IMPLIED 1
0428F1 DC 8B 2C 04 6744          		CALL    C,X10B          ;X10, DEC B
0428F5 D1          6745          		POP     DE              ;RESTORE TEXT POINTER
0428F6 CB B9       6746          		RES     7,C
0428F8 3E 00       6747          		LD      A,0
0428FA 17          6748          		RLA                     ;PUT CARRY IN LSB
0428FB             6749  ;
0428FB             6750  ;At this point decimal normalisation has been done,
0428FB             6751  ;now convert to decimal digits:
0428FB             6752  ;      AHLH'L' = number in normalised integer form
0428FB             6753  ;            B = decimal place adjustment
0428FB             6754  ;            C = binary place adjustment (29-33)
0428FB             6755  ;
0428FB 0C          6756  STR02:			INC     C
0428FC 08          6757          		EX      AF,AF'          ;SAVE A
0428FD 78          6758          		LD      A,B
0428FE DD CB 02 4E 6759          		BIT     1,(IX+2)
042902 20 08       6760          		JR      NZ,STR20
042904 AF          6761          		XOR     A
042905 DD BE 01    6762          		CP      (IX+1)
042908 28 0B       6763          		JR      Z,STR21
04290A 3E F6       6764          		LD      A,-10
04290C DD 86 01    6765  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
04290F B7          6766          		OR      A               ;CLEAR CARRY
042910 FA 15 29 04 6767          		JP      M,STR21
042914 AF          6768          		XOR     A
042915 F5          6769  STR21:			PUSH    AF
042916 08          6770          		EX      AF,AF'          ;RESTORE A
042917 CD BF 2C 04 6771  STR22:			CALL    X2              ;RL AHLH'L'
04291B 8F          6772          		ADC     A,A
04291C FE 0A       6773          		CP      10
04291E 38 05       6774          		JR      C,STR23
042920 D6 0A       6775          		SUB     10
042922 D9          6776          		EXX
042923 2C          6777          		INC     L               ;SET RESULT BIT
042924 D9          6778          		EXX
042925 0D          6779  STR23:			DEC     C
042926 20 EF       6780          		JR      NZ,STR22        ;32 TIMES
042928 4F          6781          		LD      C,A             ;REMAINDER
042929 7C          6782          		LD      A,H
04292A E6 3F       6783          		AND     3FH             ;CLEAR OUT JUNK
04292C 67          6784          		LD      H,A
04292D F1          6785          		POP     AF
04292E F2 3C 29 04 6786          		JP      P,STR24
042932 3C          6787          		INC     A
042933 20 1C       6788          		JR      NZ,STR26
042935 3E 04       6789          		LD      A,4
042937 B9          6790          		CP      C               ;ROUND UP?
042938 3E 00       6791          		LD      A,0
04293A 18 15       6792          		JR      STR26
04293C F5          6793  STR24:			PUSH    AF
04293D 79          6794          		LD      A,C
04293E CE 30       6795          		ADC     A,'0'           ;ADD CARRY
042940 FE 30       6796          		CP      '0'
042942 28 05       6797          		JR      Z,STR25         ;SUPPRESS ZERO
042944 FE 3A       6798          		CP      '9'+1
042946 3F          6799          		CCF
042947 30 08       6800          		JR      NC,STR26
042949 E3          6801  STR25:			EX      (SP),HL
04294A CB 75       6802          		BIT     6,L             ;ZERO FLAG
04294C E3          6803  		        EX      (SP),HL
04294D 20 05       6804          		JR      NZ,STR27
04294F 3E 30       6805          		LD      A,'0'
042951 3C          6806  STR26:			INC     A               ;SET +VE
042952 3D          6807          		DEC     A
042953 F5          6808          		PUSH    AF              ;PUT ON STACK + CARRY
042954 04          6809  STR27:			INC     B
042955 CD 2F 2C 04 6810          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042959 0E 20       6811          		LD      C,32
04295B 3E 00       6812          		LD      A,0
04295D 20 B8       6813          		JR      NZ,STR22
04295F F1          6814          		POP     AF
042960 F5          6815          		PUSH    AF
042961 3E 00       6816          		LD      A,0
042963 38 B2       6817          		JR      C,STR22
042965             6818  ;
042965             6819  ;At this point, the decimal character string is stored
042965             6820  ; on the stack. Trailing zeroes are suppressed and may
042965             6821  ; need to be replaced.
042965             6822  ;B register holds decimal point position.
042965             6823  ;Now format number and store as ASCII string:
042965             6824  ;
042965 EB          6825  STR3:			EX      DE,HL           ;STRING POINTER
042966 0E FF       6826          		LD      C,-1            ;FLAG "E"
042968 16 01       6827          		LD      D,1
04296A DD 5E 01    6828          		LD      E,(IX+1)        ;f2
04296D DD CB 02 46 6829          		BIT     0,(IX+2)
042971 20 35       6830          		JR      NZ,STR34        ;E MODE
042973 DD CB 02 4E 6831          		BIT     1,(IX+2)
042977 28 12       6832          		JR      Z,STR31
042979 78          6833          		LD      A,B             ;F MODE
04297A B7          6834          		OR      A
04297B 28 05       6835          		JR      Z,STR30
04297D FA 82 29 04 6836          		JP      M,STR30
042981 50          6837          		LD      D,B
042982 7A          6838  STR30:			LD      A,D
042983 DD 86 01    6839          		ADD     A,(IX+1)
042986 5F          6840          		LD      E,A
042987 FE 0B       6841          		CP      11
042989 38 19       6842          		JR      C,STR32
04298B 78          6843  STR31:			LD      A,B             ;G MODE
04298C 11 01 01 00 6844          		LD      DE,101H
042990 B7          6845          		OR      A
042991 FA A8 29 04 6846          		JP      M,STR34
042995 28 0D       6847          		JR      Z,STR32
042997 DD 7E 01    6848          		LD      A,(IX+1)
04299A B7          6849          		OR      A
04299B 20 02       6850          		JR      NZ,STR3A
04299D 3E 0A       6851          		LD      A,10
04299F B8          6852  STR3A:			CP      B
0429A0 38 06       6853          		JR      C,STR34
0429A2 50          6854          		LD      D,B
0429A3 58          6855          		LD      E,B
0429A4 78          6856  STR32:			LD      A,B
0429A5 C6 81       6857          		ADD     A,129
0429A7 4F          6858          		LD      C,A
0429A8 CB FA       6859  STR34:			SET     7,D
0429AA 1D          6860          		DEC     E
0429AB 7A          6861  STR35:			LD      A,D
0429AC B9          6862          		CP      C
0429AD 30 0E       6863          		JR      NC,STR33
0429AF F1          6864  STR36:			POP     AF
0429B0 28 04       6865          		JR      Z,STR37
0429B2 F2 BF 29 04 6866          		JP      P,STR38
0429B6 F5          6867  STR37:			PUSH    AF
0429B7 1C          6868          		INC     E
0429B8 1D          6869          		DEC     E
0429B9 FA D0 29 04 6870          		JP      M,STR4
0429BD 3E 30       6871  STR33:			LD      A,'0'
0429BF 15          6872  STR38:			DEC     D
0429C0 E2 C7 29 04 6873          		JP      PO,STR39
0429C4 36 2E       6874          		LD      (HL),'.'
0429C6 23          6875          		INC     HL
0429C7 77          6876  STR39:			LD      (HL),A
0429C8 23          6877          		INC     HL
0429C9 1D          6878          		DEC     E
0429CA F2 AB 29 04 6879          		JP      P,STR35
0429CE 18 DF       6880          		JR      STR36
0429D0             6881  ;
0429D0 F1          6882  STR4:			POP     AF
0429D1 0C          6883  STR40:			INC     C
0429D2 4D          6884          		LD      C,L
0429D3 20 28       6885          		JR      NZ,STR44
0429D5 36 45       6886          		LD      (HL),'E'        ;EXPONENT
0429D7 23          6887          		INC     HL
0429D8 78          6888          		LD      A,B
0429D9 3D          6889          		DEC     A
0429DA F2 E3 29 04 6890          		JP      P,STR41
0429DE 36 2D       6891          		LD      (HL),'-'
0429E0 23          6892          		INC     HL
0429E1 ED 44       6893          		NEG
0429E3 36 30       6894  STR41:			LD      (HL),'0'
0429E5 28 15       6895          		JR      Z,STR47
0429E7 FE 0A       6896          		CP      10
0429E9 47          6897          		LD      B,A
0429EA 3E 3A       6898          		LD      A,':'
0429EC 38 03       6899          		JR      C,STR42
0429EE 23          6900          		INC     HL
0429EF 36 30       6901          		LD      (HL),'0'
0429F1 34          6902  STR42:			INC     (HL)
0429F2 BE          6903          		CP      (HL)
0429F3 20 05       6904          		JR      NZ,STR43
0429F5 36 30       6905          		LD      (HL),'0'
0429F7 2B          6906          		DEC     HL
0429F8 34          6907          		INC     (HL)
0429F9 23          6908          		INC     HL
0429FA 10 F5       6909  STR43:			DJNZ    STR42
0429FC 23          6910  STR47:			INC     HL
0429FD EB          6911  STR44:			EX      DE,HL
0429FE C9          6912        			RET
0429FF             6913  ;
0429FF             6914  ;Support subroutines:
0429FF             6915  ;
0429FF DD 46 04    6916  DLOAD5:			LD      B,(IX+4)
042A02 D9          6917          		EXX
042A03 DD 5E 00    6918          		LD      E,(IX+0)
042A06 DD 56 01    6919          		LD      D,(IX+1)
042A09 D9          6920          		EXX
042A0A DD 5E 02    6921          		LD      E,(IX+2)
042A0D DD 56 03    6922          		LD      D,(IX+3)
042A10 C9          6923          		RET
042A11             6924  ;
042A11 DD 46 06    6925  DLOAD5_SPL:		LD      B,(IX+6)
042A14 D9          6926  			EXX
042A15 DD 17 00    6927  			LD	DE, (IX+0)
042A18 D9          6928  			EXX
042A19 DD 17 03    6929  			LD	DE, (IX+3)
042A1C C9          6930  			RET
042A1D             6931  ;
042A1D             6932  ;CON_FP - Get unsigned numeric constant from ASCII string.
042A1D             6933  ;   Inputs: ASCII string at (IX).
042A1D             6934  ;  Outputs: Variable-type result in HLH'L'C
042A1D             6935  ;           IX updated (points to delimiter)
042A1D             6936  ;           A7 = 0 (numeric marker)
042A1D             6937  ;
042A1D CD 53 2C 04 6938  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A21 0E 00       6939          		LD      C,0             ;TRUNCATION COUNTER
042A23 CD B1 2A 04 6940          		CALL    UINT          ;GET INTEGER PART
042A27 FE 2E       6941          		CP      '.'
042A29 06 00       6942          		LD      B,0             ;DECL. PLACE COUNTER
042A2B CC AF 2A 04 6943          		CALL    Z,NUMBIX        ;GET FRACTION PART
042A2F FE 45       6944          		CP      'E'
042A31 3E 00       6945          		LD      A,0             ;INITIALISE EXPONENT
042A33 CC 7D 2A 04 6946          		CALL    Z,GETEXP        ;GET EXPONENT
042A37 CB 7C       6947          		BIT     7,H
042A39 20 08       6948          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A3B B7          6949          		OR      A
042A3C 20 05       6950          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A3E B8          6951          		CP      B
042A3F 20 02       6952          		JR      NZ,CON0         ;DECIMAL POINT
042A41 B9          6953          		CP      C
042A42 C8          6954          		RET     Z               ;INTEGER
042A43 90          6955  CON0:			SUB     B
042A44 81          6956          		ADD     A,C
042A45 0E 9F       6957          		LD      C,159
042A47 CD B6 2B 04 6958          		CALL    FLOAT_
042A4B CB BC       6959          		RES     7,H             ;DITCH IMPLIED 1
042A4D B7          6960          		OR      A
042A4E C8          6961          		RET     Z               ;DONE
042A4F FA 5D 2A 04 6962          		JP      M,CON2          ;NEGATIVE EXPONENT
042A53 CD 4F 2D 04 6963          		CALL    POWR10
042A57 CD 3E 23 04 6964          		CALL    FMUL            ;SCALE
042A5B AF          6965          		XOR     A
042A5C C9          6966          		RET
042A5D FE DA       6967  CON2:			CP      -38
042A5F 38 0C       6968          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A61 ED 44       6969          		NEG
042A63 CD 4F 2D 04 6970          		CALL    POWR10
042A67 CD 95 22 04 6971          		CALL    FDIV            ;SCALE
042A6B AF          6972          		XOR     A
042A6C C9          6973          		RET
042A6D F5          6974  CON3:			PUSH    AF
042A6E 3E 26       6975          		LD      A,38
042A70 CD 4F 2D 04 6976          		CALL    POWR10
042A74 CD 95 22 04 6977          		CALL    FDIV
042A78 F1          6978          		POP     AF
042A79 C6 26       6979          		ADD     A,38
042A7B 18 E0       6980          		JR      CON2
042A7D             6981  ;
042A7D             6982  ;GETEXP - Get decimal exponent from string
042A7D             6983  ;     Inputs: ASCII string at (IX)
042A7D             6984  ;             (IX points at 'E')
042A7D             6985  ;             A = initial value
042A7D             6986  ;    Outputs: A = new exponent
042A7D             6987  ;             IX updated.
042A7D             6988  ;   Destroys: A,A',IX,F,F'
042A7D             6989  ;
042A7D C5          6990  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A7E 47          6991          		LD      B,A             ;INITIAL VALUE
042A7F 0E 02       6992          		LD      C,2             ;2 DIGITS MAX
042A81 DD 23       6993          		INC     IX              ;BUMP PAST 'E'
042A83 CD 6D 2E 04 6994          		CALL    SIGNQ
042A87 08          6995          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A88 CD 63 2E 04 6996  GETEX1:			CALL    DIGITQ
042A8C 38 18       6997          		JR      C,GETEX2
042A8E 78          6998          		LD      A,B             ;B=B*10
042A8F 87          6999          		ADD     A,A
042A90 87          7000          		ADD     A,A
042A91 80          7001          		ADD     A,B
042A92 87          7002          		ADD     A,A
042A93 47          7003          		LD      B,A
042A94 DD 7E 00    7004          		LD      A,(IX)          ;GET BACK DIGIT
042A97 DD 23       7005          		INC     IX
042A99 E6 0F       7006          		AND     0FH             ;MASK UNWANTED BITS
042A9B 80          7007          		ADD     A,B             ;ADD IN DIGIT
042A9C 47          7008          		LD      B,A
042A9D 0D          7009          		DEC     C
042A9E F2 88 2A 04 7010          		JP      P,GETEX1
042AA2 06 64       7011          		LD      B,100           ;FORCE OVERFLOW
042AA4 18 E2       7012          		JR      GETEX1
042AA6 08          7013  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AA7 FE 2D       7014          		CP      '-'
042AA9 78          7015          		LD      A,B
042AAA C1          7016          		POP     BC              ;RESTORE
042AAB C0          7017          		RET     NZ
042AAC ED 44       7018          		NEG                     ;NEGATE EXPONENT
042AAE C9          7019          		RET
042AAF             7020  ;
042AAF             7021  ;UINT: Get unsigned integer from string.
042AAF             7022  ;    Inputs: string at (IX)
042AAF             7023  ;            C = truncated digit count
042AAF             7024  ;                (initially zero)
042AAF             7025  ;            B = total digit count
042AAF             7026  ;            HLH'L' = initial value
042AAF             7027  ;   Outputs: HLH'L' = number (binary integer)
042AAF             7028  ;            A = delimiter.
042AAF             7029  ;            B, C & IX updated
042AAF             7030  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042AAF             7031  ;
042AAF DD 23       7032  NUMBIX:			INC     IX
042AB1 CD 63 2E 04 7033  UINT:			CALL    DIGITQ
042AB5 D8          7034          		RET     C
042AB6 04          7035          		INC     B               ;INCREMENT DIGIT COUNT
042AB7 DD 23       7036          		INC     IX
042AB9 CD AC 2C 04 7037          		CALL    X10             ;*10 & COPY OLD VALUE
042ABD 38 15       7038          		JR      C,NUMB1         ;OVERFLOW
042ABF 0D          7039          		DEC     C               ;SEE IF TRUNCATED
042AC0 0C          7040          		INC     C
042AC1 20 11       7041          		JR      NZ,NUMB1        ;IMPORTANT!
042AC3 E6 0F       7042          		AND     0FH
042AC5 D9          7043          		EXX
042AC6 06 00       7044          		LD      B,0
042AC8 4F          7045          		LD      C,A
042AC9 52 09       7046          		ADD.S   HL,BC           ;ADD IN DIGIT
042ACB D9          7047          		EXX
042ACC 30 E3       7048          		JR      NC,UINT
042ACE 52 23       7049          		INC.S   HL              ;CARRY
042AD0 7C          7050          		LD      A,H
042AD1 B5          7051          		OR      L
042AD2 20 DD       7052          		JR      NZ,UINT
042AD4 0C          7053  NUMB1:			INC     C               ;TRUNCATION COUNTER
042AD5 CD 0A 2C 04 7054          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AD9 18 D6       7055          		JR      UINT
042ADB             7056  ;
042ADB             7057  ;FIX - Fix number to specified exponent value.
042ADB             7058  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042ADB             7059  ;            A = desired exponent (A>C)
042ADB             7060  ;   Outputs: HLH'L'C = fixed number (unsigned)
042ADB             7061  ;            fraction shifted into B'C'
042ADB             7062  ;            A'F' positive if integer input
042ADB             7063  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042ADB             7064  ;
042ADB 08          7065  FIX:			EX      AF,AF'
042ADC AF          7066          		XOR     A
042ADD 08          7067          		EX      AF,AF'
042ADE CB FC       7068          		SET     7,H             ;IMPLIED 1
042AE0 CD 0F 2C 04 7069  FIX1:			CALL    DIV2
042AE4 B9          7070          		CP      C
042AE5 C8          7071          		RET     Z
042AE6 D2 E0 2A 04 7072          		JP      NC,FIX1
042AEA C3 1E 2C 04 7073          		JP      OFLOW
042AEE             7074  ;
042AEE             7075  ;SFIX - Convert to integer if necessary.
042AEE             7076  ;    Input: Variable-type number in HLH'L'C
042AEE             7077  ;   Output: Integer in HLH'L', C=0
042AEE             7078  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042AEE             7079  ;
042AEE             7080  ;NEGATE - Negate HLH'L'
042AEE             7081  ;    Destroys: H,L,H',L',F
042AEE             7082  ;
042AEE CD 07 2C 04 7083  FIX2:			CALL    SWAP_FP
042AF2 CD FA 2A 04 7084          		CALL    SFIX_FP
042AF6 CD 07 2C 04 7085          		CALL    SWAP_FP
042AFA 0D          7086  SFIX_FP:			DEC     C
042AFB 0C          7087          		INC     C
042AFC C8          7088          		RET     Z               ;INTEGER/ZERO
042AFD CB 7C       7089          		BIT     7,H             ;SIGN
042AFF F5          7090          		PUSH    AF
042B00 3E 9F       7091          		LD      A,159
042B02 CD DB 2A 04 7092          		CALL    FIX
042B06 F1          7093          		POP     AF
042B07 0E 00       7094          		LD      C,0
042B09 C8          7095          		RET     Z
042B0A B7          7096  NEGATE:			OR      A               ;CLEAR CARRY
042B0B D9          7097          		EXX
042B0C D5          7098  NEG0:			PUSH    DE
042B0D EB          7099          		EX      DE,HL
042B0E 21 00 00 00 7100          		LD      HL,0
042B12 52 ED 52    7101          		SBC.S   HL,DE
042B15 D1          7102          		POP     DE
042B16 D9          7103          		EXX
042B17 D5          7104          		PUSH    DE
042B18 EB          7105          		EX      DE,HL
042B19 21 00 00 00 7106          		LD      HL,0
042B1D 52 ED 52    7107          		SBC.S   HL,DE
042B20 D1          7108          		POP     DE
042B21 C9          7109          		RET
042B22             7110  ;
042B22             7111  ;NEG - Negate HLH'L'B'C'
042B22             7112  ;    Also complements A (used in FADD)
042B22             7113  ;    Destroys: A,H,L,B',C',H',L',F
042B22             7114  ;
042B22 D9          7115  NEG_:			EXX
042B23 2F          7116          		CPL
042B24 E5          7117          		PUSH    HL
042B25 B7          7118          		OR      A               ;CLEAR CARRY
042B26 21 00 00 00 7119          		LD      HL,0
042B2A 52 ED 42    7120          		SBC.S   HL,BC
042B2D 44          7121          		LD      B,H
042B2E 4D          7122          		LD      C,L
042B2F E1          7123          		POP     HL
042B30 18 DA       7124          		JR      NEG0
042B32             7125  ;
042B32             7126  ;SCALE - Trig scaling.
042B32             7127  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B32             7128  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B32             7129  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B32             7130  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B32             7131  ;           E = quotient (bit 7 is sticky)
042B32             7132  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B32             7133  ;FLO48 - Float unsigned number (48 bits)
042B32             7134  ;    Input/output in HLH'L'B'C'C
042B32             7135  ;   Destroys: C,H,L,B',C',H',L',F
042B32             7136  ;
042B32 3E 96       7137  SCALE:			LD      A,150
042B34 B9          7138          		CP      C
042B35 3E 17       7139          		LD      A,ACLOST
042B37 DA AD 20 04 7140          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B3B CD 78 26 04 7141          		CALL    PIBY4
042B3F D9          7142          		EXX
042B40 01 69 21 00 7143          		LD      BC,2169H        ;3.141592653589793238
042B44 D9          7144          		EXX
042B45 CB FA       7145  MOD48:			SET     7,D             ;IMPLIED 1
042B47 CB FC       7146          		SET     7,H
042B49 79          7147          		LD      A,C
042B4A 0E 00       7148          		LD      C,0             ;INIT QUOTIENT
042B4C DD 21 00 00 7149          		LD      IX,0
       00          
042B51 DD E5       7150          		PUSH    IX              ;PUT ZERO ON STACK
042B53 B8          7151          		CP      B
042B54 38 46       7152          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B56 D9          7153  MOD481:			EXX                     ;CARRY=0 HERE
042B57 E3          7154          		EX      (SP),HL
042B58 52 ED 42    7155          		SBC.S   HL,BC
042B5B E3          7156          		EX      (SP),HL
042B5C 52 ED 52    7157          		SBC.S   HL,DE
042B5F D9          7158          		EXX
042B60 52 ED 52    7159          		SBC.S   HL,DE
042B63 30 0C       7160          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B65 D9          7161          		EXX
042B66 E3          7162          		EX      (SP),HL
042B67 52 09       7163          		ADD.S   HL,BC
042B69 E3          7164          		EX      (SP),HL
042B6A 52 ED 5A    7165          		ADC.S   HL,DE
042B6D D9          7166          		EXX
042B6E 52 ED 5A    7167          		ADC.S   HL,DE
042B71 3F          7168  MOD482:			CCF
042B72 CB 11       7169          		RL      C               ;QUOTIENT
042B74 30 02       7170          		JR      NC,MOD483
042B76 CB F9       7171          		SET     7,C             ;STICKY BIT
042B78 3D          7172  MOD483:			DEC     A
042B79 B8          7173          		CP      B
042B7A 38 1F       7174          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B7C E3          7175          		EX      (SP),HL
042B7D 52 29       7176          		ADD.S   HL,HL           ;DIVIDEND * 2
042B7F E3          7177          		EX      (SP),HL
042B80 D9          7178          		EXX
042B81 52 ED 6A    7179          		ADC.S   HL,HL
042B84 D9          7180          		EXX
042B85 52 ED 6A    7181          		ADC.S   HL,HL
042B88 30 CC       7182          		JR      NC,MOD481       ;AGAIN
042B8A B7          7183          		OR      A
042B8B D9          7184          		EXX
042B8C E3          7185          		EX      (SP),HL
042B8D 52 ED 42    7186          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B90 E3          7187          		EX      (SP),HL
042B91 52 ED 52    7188          		SBC.S   HL,DE
042B94 D9          7189          		EXX
042B95 52 ED 52    7190          		SBC.S   HL,DE
042B98 B7          7191          		OR      A
042B99 18 D6       7192          		JR      MOD482
042B9B             7193  ;
042B9B 3C          7194  MOD484:			INC     A
042B9C 59          7195  MOD485:			LD      E,C             ;QUOTIENT
042B9D 4F          7196          		LD      C,A             ;REMAINDER EXPONENT
042B9E D9          7197          		EXX
042B9F C1          7198          		POP     BC
042BA0 D9          7199          		EXX
042BA1 CB 7C       7200  FLO48:			BIT     7,H
042BA3 C0          7201          		RET     NZ
042BA4 D9          7202          		EXX
042BA5 CB 21       7203          		SLA     C
042BA7 CB 10       7204          		RL      B
042BA9 52 ED 6A    7205          		ADC.S   HL,HL
042BAC D9          7206          		EXX
042BAD 52 ED 6A    7207          		ADC.S   HL,HL
042BB0 0D          7208          		DEC     C
042BB1 C2 A1 2B 04 7209          		JP      NZ,FLO48
042BB5 C9          7210          		RET
042BB6             7211  ;
042BB6             7212  ;Float unsigned number
042BB6             7213  ;    Input/output in HLH'L'C
042BB6             7214  ;   Destroys: C,H,L,H',L',F
042BB6             7215  ;
042BB6 CB 7C       7216  FLOAT_:			BIT     7,H
042BB8 C0          7217          		RET     NZ
042BB9 D9          7218          		EXX                     ;SAME AS "X2"
042BBA 52 29       7219          		ADD.S   HL,HL           ;TIME-CRITICAL
042BBC D9          7220          		EXX                     ;REGION
042BBD 52 ED 6A    7221          		ADC.S   HL,HL           ;(BENCHMARKS)
042BC0 0D          7222          		DEC     C
042BC1 C2 B6 2B 04 7223          		JP      NZ,FLOAT_
042BC5 C9          7224          		RET
042BC6             7225  ;
042BC6             7226  ;SFLOAT - Convert to floating-point if necessary.
042BC6             7227  ;    Input: Variable-type number in HLH'L'C
042BC6             7228  ;    Output: Floating-point in HLH'L'C
042BC6             7229  ;    Destroys: A,C,H,L,H',L',F
042BC6             7230  ;
042BC6 08          7231  FLOATA:			EX      AF,AF'
042BC7             7232          		; ADD     A,(RTABLE-DTABLE)/3
042BC7 C6 2A       7233          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BC9 08          7234          		EX      AF,AF'
042BCA CD 07 2C 04 7235  FLOAT2:			CALL    SWAP_FP
042BCE CD D6 2B 04 7236          		CALL    SFLOAT_FP
042BD2 CD 07 2C 04 7237          		CALL    SWAP_FP
042BD6 0D          7238  SFLOAT_FP:			DEC     C
042BD7 0C          7239          		INC     C
042BD8 C0          7240          		RET     NZ              ;ALREADY FLOATING-POINT
042BD9 CD 2F 2C 04 7241          		CALL    TEST_FP
042BDD C8          7242          		RET     Z               ;ZERO
042BDE 7C          7243          		LD      A,H
042BDF B7          7244          		OR      A
042BE0 FC 0A 2B 04 7245          		CALL    M,NEGATE
042BE4 0E 9F       7246          		LD      C,159
042BE6 CD B6 2B 04 7247          		CALL    FLOAT_
042BEA B7          7248          		OR      A
042BEB F8          7249          		RET     M               ;NEGATIVE
042BEC CB BC       7250          		RES     7,H
042BEE C9          7251          		RET
042BEF             7252  ;
042BEF             7253  ;ROUND UP
042BEF             7254  ;Return with carry set if 32-bit overflow
042BEF             7255  ;   Destroys: H,L,B',C',H',L',F
042BEF             7256  ;
042BEF D9          7257  ADD1_FP:			EXX
042BF0 01 01 00 00 7258          		LD      BC,1
042BF4 52 09       7259          		ADD.S   HL,BC
042BF6 D9          7260          		EXX
042BF7 D0          7261          		RET     NC
042BF8 C5          7262          		PUSH    BC
042BF9 01 01 00 00 7263          		LD      BC,1
042BFD 52 09       7264          		ADD.S   HL,BC
042BFF C1          7265          		POP     BC
042C00 C9          7266          		RET
042C01             7267  ;
042C01             7268  ;ODD - Add one if even, leave alone if odd.
042C01             7269  ; (Used to perform unbiassed rounding, i.e.
042C01             7270  ;  number is rounded up half the time)
042C01             7271  ;    Destroys: L',F (carry cleared)
042C01             7272  ;
042C01 B7          7273  ODD:			OR      A               ;CLEAR CARRY
042C02 D9          7274          		EXX
042C03 CB C5       7275          		SET     0,L             ;MAKE ODD
042C05 D9          7276          		EXX
042C06 C9          7277          		RET
042C07             7278  ;
042C07             7279  ;SWAP_FP - Swap arguments.
042C07             7280  ;    Exchanges DE,HL D'E',H'L' and B,C
042C07             7281  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042C07             7282  ;SWAP1 - Swap DEHL with D'E'H'L'
042C07             7283  ;    Destroys: D,E,H,L,D',E',H',L'
042C07             7284  ;
042C07 79          7285  SWAP_FP:			LD      A,C
042C08 48          7286          		LD      C,B
042C09 47          7287          		LD      B,A
042C0A EB          7288  SWAP1:			EX      DE,HL
042C0B D9          7289          		EXX
042C0C EB          7290          		EX      DE,HL
042C0D D9          7291          		EXX
042C0E C9          7292          		RET
042C0F             7293  ;
042C0F             7294  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042C0F             7295  ; INCC - destroys C,F
042C0F             7296  ; OFLOW
042C0F             7297  ;
042C0F CD C8 2C 04 7298  DIV2:			CALL    D2
042C13 D9          7299          		EXX
042C14 CB 18       7300          		RR      B
042C16 CB 19       7301          		RR      C
042C18 08          7302          		EX      AF,AF'
042C19 B0          7303          		OR      B
042C1A 08          7304          		EX      AF,AF'
042C1B D9          7305          		EXX
042C1C 0C          7306  INCC:			INC     C
042C1D C0          7307          		RET     NZ
042C1E 3E 14       7308  OFLOW:			LD      A,TOOBIG_FP
042C20 C3 AD 20 04 7309          		JP      ERROR_FP_           ;"Too big"
042C24             7310  ;
042C24             7311  ; FTEST - Test for zero & sign
042C24             7312  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042C24             7313  ;
042C24 CD 2F 2C 04 7314  FTEST_FP:			CALL    TEST_FP
042C28 C8          7315          		RET     Z
042C29 7C          7316          		LD      A,H
042C2A E6 80       7317          		AND     10000000B
042C2C F6 40       7318          		OR      01000000B
042C2E C9          7319          		RET
042C2F             7320  ;
042C2F             7321  ; TEST_FP - Test HLH'L' for zero.
042C2F             7322  ;     Output: Z-flag set & A=0 if HLH'L'=0
042C2F             7323  ;     Destroys: A,F
042C2F             7324  ;
042C2F 7C          7325  TEST_FP:			LD      A,H
042C30 B5          7326          		OR      L
042C31 D9          7327          		EXX
042C32 B4          7328          		OR      H
042C33 B5          7329          		OR      L
042C34 D9          7330          		EXX
042C35 C9          7331          		RET
042C36             7332  ;
042C36             7333  ; FCOMP - Compare two numbers
042C36             7334  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C36             7335  ;
042C36 78          7336  FCOMP_FP:			LD      A,B
042C37 B1          7337          		OR      C               ;Both integer?
042C38 20 0B       7338          		JR      NZ,FCOMP1
042C3A CD 4F 2C 04 7339          		CALL    ICP
042C3E 3E 00       7340  FCOMP0:			LD      A,0
042C40 C8          7341          		RET     Z               ;Equal
042C41 3E 80       7342          		LD      A,80H
042C43 1F          7343          		RRA
042C44 C9          7344          		RET
042C45             7345  ;
042C45 CD CA 2B 04 7346  FCOMP1:			CALL    FLOAT2          ;Float both
042C49 CD 5D 2C 04 7347          		CALL    FCP
042C4D 18 EF       7348          		JR      FCOMP0
042C4F             7349  ;
042C4F             7350  ; Integer and floating point compare.
042C4F             7351  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C4F             7352  ; Result pre-set to FALSE
042C4F             7353  ; ICP1, FCP1 destroy A,F
042C4F             7354  ;
042C4F             7355  ; ZERO - Return zero.
042C4F             7356  ;  Destroys: A,C,H,L,H',L'
042C4F             7357  ;
042C4F CD 82 2C 04 7358  ICP:			CALL    ICP1
042C53 3E 00       7359  ZERO_FP:			LD      A,0
042C55 D9          7360          		EXX
042C56 67          7361          		LD      H,A
042C57 6F          7362  	       		LD      L,A
042C58 D9          7363          		EXX
042C59 67          7364        			LD      H,A
042C5A 6F          7365       			LD      L,A
042C5B 4F          7366  	    		LD      C,A
042C5C C9          7367          		RET
042C5D             7368  ;
042C5D CD 74 2C 04 7369  FCP:			CALL    FCP1
042C61 18 F0       7370          		JR      ZERO_FP            ;PRESET FALSE
042C63             7371  ;
042C63 79          7372  FCP0:			LD      A,C
042C64 B8          7373          		CP      B               ;COMPARE EXPONENTS
042C65 C0          7374          		RET     NZ
042C66             7375  ICP0:
042C66 52 ED 52    7376  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C69 52 19       7377          		ADD.S   HL,DE
042C6B C0          7378          		RET     NZ
042C6C D9          7379          		EXX
042C6D 52 ED 52    7380          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C70 52 19       7381          		ADD.S   HL,DE
042C72 D9          7382          		EXX
042C73 C9          7383          		RET
042C74             7384  ;
042C74 7C          7385  FCP1:			LD      A,H
042C75 AA          7386          		XOR     D
042C76 7C          7387          		LD      A,H
042C77 17          7388          		RLA
042C78 F8          7389          		RET     M
042C79 30 E8       7390          		JR      NC,FCP0
042C7B CD 63 2C 04 7391          		CALL    FCP0
042C7F C8          7392          		RET     Z               ;** V0.1 BUG FIX
042C80 3F          7393          		CCF
042C81 C9          7394          		RET
042C82             7395  ;
042C82 7C          7396  ICP1:			LD      A,H
042C83 AA          7397          		XOR     D
042C84 F2 66 2C 04 7398          		JP      P,ICP0
042C88 7C          7399          		LD      A,H
042C89 17          7400          		RLA
042C8A C9          7401          		RET
042C8B             7402  ;
042C8B             7403  ; ADD - Integer add.
042C8B             7404  ; Carry, sign & zero flags valid on exit
042C8B             7405  ;     Destroys: H,L,H',L',F
042C8B             7406  ;
042C8B 05          7407  X10B:			DEC     B
042C8C 0C          7408          		INC     C
042C8D CD D4 2C 04 7409  X5:			CALL    COPY0
042C91 CD C7 2C 04 7410          		CALL    D2C
042C95 CD C7 2C 04 7411          		CALL    D2C
042C99 08          7412          		EX      AF,AF'          ;SAVE CARRY
042C9A D9          7413  ADD_:			EXX
042C9B 52 19       7414          		ADD.S   HL,DE
042C9D D9          7415          		EXX
042C9E 52 ED 5A    7416          		ADC.S   HL,DE
042CA1 C9          7417          		RET
042CA2             7418  ;
042CA2             7419  ; SUB - Integer subtract.
042CA2             7420  ; Carry, sign & zero flags valid on exit
042CA2             7421  ;     Destroys: H,L,H',L',F
042CA2             7422  ;
042CA2 D9          7423  SUB_:			EXX
042CA3 B7          7424          		OR      A
042CA4 52 ED 52    7425          		SBC.S   HL,DE
042CA7 D9          7426          		EXX
042CA8 52 ED 52    7427          		SBC.S   HL,DE
042CAB C9          7428          		RET
042CAC             7429  ;
042CAC             7430  ; X10 - unsigned integer * 10
042CAC             7431  ;    Inputs: HLH'L' initial value
042CAC             7432  ;   Outputs: DED'E' = initial HLH'L'
042CAC             7433  ;            Carry bit set if overflow
042CAC             7434  ;            If carry not set HLH'L'=result
042CAC             7435  ;  Destroys: D,E,H,L,D',E',H',L',F
042CAC             7436  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042CAC             7437  ;     Carry set if MSB=1 before shift.
042CAC             7438  ;     Sign set if MSB=1 after shift.
042CAC             7439  ;     Destroys: H,L,H',L',F
042CAC             7440  ;
042CAC CD D4 2C 04 7441  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CB0 CD BF 2C 04 7442          		CALL    X2
042CB4 D8          7443          		RET     C               ;TOO BIG
042CB5 CD BF 2C 04 7444          		CALL    X2
042CB9 D8          7445          		RET     C
042CBA CD 9A 2C 04 7446          		CALL    ADD_
042CBE D8          7447          		RET     C
042CBF D9          7448  X2:			EXX
042CC0 52 29       7449          		ADD.S   HL,HL
042CC2 D9          7450          		EXX
042CC3 52 ED 6A    7451          		ADC.S   HL,HL
042CC6 C9          7452          		RET
042CC7             7453  ;
042CC7             7454  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042CC7             7455  ;     Carry set if LSB=1 before shift.
042CC7             7456  ;     Destroys: H,L,H',L',F
042CC7             7457  ;
042CC7 0C          7458  D2C:			INC     C
042CC8 CB 3C       7459  D2:			SRL     H
042CCA CB 1D       7460          		RR      L
042CCC D9          7461          		EXX
042CCD CB 1C       7462          		RR      H
042CCF CB 1D       7463          		RR      L
042CD1 D9          7464          		EXX
042CD2 C9          7465          		RET
042CD3             7466  ;
042CD3             7467  ; COPY - COPY HLH'L'C INTO DED'E'B
042CD3             7468  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CD3             7469  ;
042CD3 41          7470  COPY_:			LD      B,C
042CD4 54          7471  COPY0:			LD      D,H
042CD5 5D          7472          		LD      E,L
042CD6 D9          7473          		EXX
042CD7 54          7474          		LD      D,H
042CD8 5D          7475          		LD      E,L
042CD9 D9          7476          		EXX
042CDA C9          7477          		RET
042CDB             7478  ;
042CDB             7479  ; SQUARE - PUSH X*X
042CDB             7480  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CDB             7481  ;   Destroys: SP,IX
042CDB             7482  ;
042CDB CD D3 2C 04 7483  SQUARE:			CALL    COPY_
042CDF CD 3E 23 04 7484          		CALL    FMUL
042CE3 DD E1       7485  PUSH5:			POP     IX              ;RETURN ADDRESS
042CE5 C5          7486          		PUSH    BC
042CE6 E5          7487          		PUSH    HL
042CE7 D9          7488          		EXX
042CE8 E5          7489          		PUSH    HL
042CE9 D9          7490          		EXX
042CEA DD E9       7491          		JP      (IX)            ;"RETURN"
042CEC             7492  ;
042CEC             7493  ; POP5 - POP DED'E'B OFF STACK.
042CEC             7494  ;   Destroys: A,B,D,E,D',E',SP,IX
042CEC             7495  ;
042CEC DD E1       7496  POP5:			POP     IX              ;RETURN ADDRESS
042CEE D9          7497          		EXX
042CEF D1          7498          		POP     DE
042CF0 D9          7499          		EXX
042CF1 D1          7500          		POP     DE
042CF2 79          7501          		LD      A,C
042CF3 C1          7502          		POP     BC
042CF4 41          7503          		LD      B,C
042CF5 4F          7504          		LD      C,A
042CF6 DD E9       7505          		JP      (IX)            ;"RETURN"
042CF8             7506  ;
042CF8             7507  ; RATIO - Calculate (X-1)/(X+1)
042CF8             7508  ;     Inputs: X in HLH'L'C
042CF8             7509  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042CF8             7510  ;   Destroys: Everything except IY,SP,I
042CF8             7511  ;
042CF8 CD E3 2C 04 7512  RATIO:			CALL    PUSH5           ;SAVE X
042CFC CD 6B 26 04 7513          		CALL    DONE
042D00 CD 2C 22 04 7514          		CALL    FADD
042D04 CD EC 2C 04 7515          		CALL    POP5            ;RESTORE X
042D08 CD E3 2C 04 7516          		CALL    PUSH5           ;SAVE X+1
042D0C CD 07 2C 04 7517          		CALL    SWAP_FP
042D10 CD 6B 26 04 7518          		CALL    DONE
042D14 CD 13 22 04 7519          		CALL    FSUB
042D18 CD EC 2C 04 7520          		CALL    POP5            ;RESTORE X+1
042D1C C3 95 22 04 7521          		JP      FDIV
042D20             7522  ;
042D20             7523  ; POLY - Evaluate a polynomial.
042D20             7524  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042D20             7525  ;             Polynomial coefficients follow call.
042D20             7526  ;    Outputs: Result in HLH'L'C
042D20             7527  ;   Destroys: Everything except IY,SP,I
042D20             7528  ; Routine terminates on finding a coefficient >=1.
042D20             7529  ; Note: The last coefficient is EXECUTED on return
042D20             7530  ;       so must contain only innocuous bytes!
042D20             7531  ;
042D20 DD 21 03 00 7532  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042D25 DD 39       7533          		ADD     IX, SP
042D27 DD E3       7534          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D29             7535  ;
042D29 CD FF 29 04 7536          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042D2D CD 3E 23 04 7537  POLY1:			CALL    FMUL
042D31 11 05 00 00 7538          		LD      DE, 5				; Skip to the next coefficient
042D35 DD 19       7539          		ADD     IX, DE
042D37 CD FF 29 04 7540          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D3B DD E3       7541          		EX      (SP), IX			; Restore the SP just in case we need to return
042D3D 04          7542          		INC     B
042D3E 05          7543          		DEC     B               		; Test B for end byte (80h)
042D3F FA 2C 22 04 7544          		JP      M,FADD				; Yes, so add and return
042D43 CD 2C 22 04 7545          		CALL    FADD				; No, so add
042D47 CD 11 2A 04 7546          		CALL    DLOAD5_SPL			; Load X from SP
042D4B DD E3       7547          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D4D 18 DE       7548          		JR      POLY1				; And loop
042D4F             7549  ;
042D4F             7550  ; POWR10 - Calculate power of ten.
042D4F             7551  ;     Inputs: A=power of 10 required (A<128)
042D4F             7552  ;             A=binary exponent to be exceeded (A>=128)
042D4F             7553  ;    Outputs: DED'E'B = result
042D4F             7554  ;             A = actual power of ten returned
042D4F             7555  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D4F             7556  ;
042D4F 3C          7557  POWR10:			INC     A
042D50 08          7558          		EX      AF,AF'
042D51 E5          7559          		PUSH    HL
042D52 D9          7560          		EXX
042D53 E5          7561          		PUSH    HL
042D54 D9          7562          		EXX
042D55 CD 6B 26 04 7563          		CALL    DONE
042D59 CD 07 2C 04 7564          		CALL    SWAP_FP
042D5D AF          7565          		XOR     A
042D5E 08          7566  POWR11:			EX      AF,AF'
042D5F 3D          7567          		DEC     A
042D60 28 26       7568          		JR      Z,POWR14        ;EXIT TYPE 1
042D62 F2 6A 2D 04 7569          		JP      P,POWR13
042D66 B9          7570          		CP      C
042D67 38 1F       7571          		JR      C,POWR14        ;EXIT TYPE 2
042D69 3C          7572          		INC     A
042D6A 08          7573  POWR13:			EX      AF,AF'
042D6B 3C          7574          		INC     A
042D6C CB FC       7575          		SET     7,H
042D6E CD 8D 2C 04 7576          		CALL    X5
042D72 30 06       7577          		JR      NC,POWR12
042D74 08          7578          		EX      AF,AF'
042D75 CD C7 2C 04 7579          		CALL    D2C
042D79 08          7580          		EX      AF,AF'
042D7A 08          7581  POWR12:			EX      AF,AF'
042D7B DC EF 2B 04 7582          		CALL    C,ADD1_FP          ;ROUND UP
042D7F 0C          7583          		INC     C
042D80 FA 5E 2D 04 7584          		JP      M,POWR11
042D84 C3 1E 2C 04 7585          		JP      OFLOW
042D88 CD 07 2C 04 7586  POWR14:			CALL    SWAP_FP
042D8C CB BA       7587          		RES     7,D
042D8E D9          7588          		EXX
042D8F E1          7589          		POP     HL
042D90 D9          7590          		EXX
042D91 E1          7591          		POP     HL
042D92 08          7592          		EX      AF,AF'
042D93 C9          7593          		RET
042D94             7594  ;
042D94             7595  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D94             7596  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D94             7597  ;               Remainder in H'L'HL
042D94             7598  ;     Inputs: A = loop counter (normally -32)
042D94             7599  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D94             7600  ;
042D94 B7          7601  DIVA:			OR      A               ;CLEAR CARRY
042D95             7602  DIV0:
042D95 52 ED 42    7603  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D98 D9          7604          		EXX
042D99 52 ED 42    7605          		SBC.S   HL,BC
042D9C D9          7606          		EXX
042D9D 30 07       7607          		JR      NC,DIV1
042D9F 52 09       7608          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA1 D9          7609          		EXX
042DA2 52 ED 4A    7610          		ADC.S   HL,BC
042DA5 D9          7611          		EXX
042DA6 3F          7612  DIV1:			CCF
042DA7 CB 13       7613  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DA9 CB 12       7614          		RL      D
042DAB D9          7615          		EXX
042DAC CB 13       7616          		RL      E
042DAE CB 12       7617          		RL      D
042DB0 D9          7618          		EXX
042DB1 3C          7619          		INC     A
042DB2 F0          7620          		RET     P
042DB3             7621  DIVB:
042DB3 52 ED 6A    7622  			ADC.S   HL,HL           ;DIVIDEND*2
042DB6 D9          7623          		EXX
042DB7 52 ED 6A    7624          		ADC.S   HL,HL
042DBA D9          7625          		EXX
042DBB 30 D8       7626          		JR      NC,DIV0
042DBD B7          7627          		OR      A
042DBE 52 ED 42    7628          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DC1 D9          7629          		EXX
042DC2 52 ED 42    7630          		SBC.S   HL,BC
042DC5 D9          7631          		EXX
042DC6 37          7632          		SCF
042DC7 C3 A7 2D 04 7633          		JP      DIVC
042DCB             7634  ;
042DCB             7635  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042DCB             7636  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042DCB             7637  ;    Inputs: A = loop counter (usually -32)
042DCB             7638  ;            H'L'HL = 0
042DCB             7639  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042DCB             7640  ;
042DCB B7          7641  MULA:			OR      A               ;CLEAR CARRY
042DCC D9          7642  MUL0:			EXX
042DCD CB 1A       7643          		RR      D               ;MULTIPLIER/2
042DCF CB 1B       7644          		RR      E
042DD1 D9          7645          		EXX
042DD2 CB 1A       7646          		RR      D
042DD4 CB 1B       7647          		RR      E
042DD6 30 07       7648          		JR      NC,MUL1
042DD8 52 09       7649          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DDA D9          7650          		EXX
042DDB 52 ED 4A    7651          		ADC.S   HL,BC
042DDE D9          7652          		EXX
042DDF 3C          7653  MUL1:			INC     A
042DE0 F0          7654          		RET     P
042DE1 D9          7655  MULB:			EXX
042DE2 CB 1C       7656          		RR      H               ;PRODUCT/2
042DE4 CB 1D       7657          		RR      L
042DE6 D9          7658          		EXX
042DE7 CB 1C       7659          		RR      H
042DE9 CB 1D       7660          		RR      L
042DEB C3 CC 2D 04 7661          		JP      MUL0
042DEF             7662  ;
042DEF             7663  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DEF             7664  ;     Function: B'C'BC = SQR (D'E'DE)
042DEF             7665  ;     Inputs: A = loop counter (normally -31)
042DEF             7666  ;             B'C'BCH'L'HL initialised to 0
042DEF             7667  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DEF             7668  ;
042DEF             7669  SQR1:
042DEF 52 ED 42    7670  			SBC.S   HL,BC
042DF2 D9          7671          		EXX
042DF3 52 ED 42    7672          		SBC.S   HL,BC
042DF6 D9          7673          		EXX
042DF7 0C          7674          		INC     C
042DF8 30 09       7675          		JR      NC,SQR2
042DFA 0D          7676          		DEC     C
042DFB 52 09       7677          		ADD.S   HL,BC
042DFD D9          7678          		EXX
042DFE 52 ED 4A    7679          		ADC.S   HL,BC
042E01 D9          7680          		EXX
042E02 0D          7681          		DEC     C
042E03 3C          7682  SQR2:			INC     A
042E04 F0          7683          		RET     P
042E05 CB 21       7684  SQRA:			SLA     C
042E07 CB 10       7685          		RL      B
042E09 D9          7686          		EXX
042E0A CB 11       7687          		RL      C
042E0C CB 10       7688          		RL      B
042E0E D9          7689          		EXX
042E0F 0C          7690          		INC     C
042E10 CB 23       7691          		SLA     E
042E12 CB 12       7692          		RL      D
042E14 D9          7693          		EXX
042E15 CB 13       7694          		RL      E
042E17 CB 12       7695          		RL      D
042E19 D9          7696          		EXX
042E1A 52 ED 6A    7697          		ADC.S   HL,HL
042E1D D9          7698          		EXX
042E1E 52 ED 6A    7699          		ADC.S   HL,HL
042E21 D9          7700          		EXX
042E22 CB 23       7701          		SLA     E
042E24 CB 12       7702          		RL      D
042E26 D9          7703          		EXX
042E27 CB 13       7704          		RL      E
042E29 CB 12       7705          		RL      D
042E2B D9          7706          		EXX
042E2C 52 ED 6A    7707          		ADC.S   HL,HL
042E2F D9          7708          		EXX
042E30 52 ED 6A    7709          		ADC.S   HL,HL
042E33 D9          7710          		EXX
042E34 D2 EF 2D 04 7711          		JP      NC,SQR1
042E38 B7          7712  SQR3:			OR      A
042E39 52 ED 42    7713          		SBC.S   HL,BC
042E3C D9          7714          		EXX
042E3D 52 ED 42    7715          		SBC.S   HL,BC
042E40 D9          7716          		EXX
042E41 0C          7717          		INC     C
042E42 C3 03 2E 04 7718          		JP      SQR2
042E46             7719  ;
042E46             7720  SQRB:
042E46 52 29       7721  			ADD.S   HL,HL
042E48 D9          7722          		EXX
042E49 52 ED 6A    7723          		ADC.S   HL,HL
042E4C D9          7724          		EXX
042E4D 38 E9       7725          		JR      C,SQR3
042E4F 3C          7726          		INC     A
042E50 0C          7727          		INC     C
042E51 52 ED 42    7728          		SBC.S   HL,BC
042E54 D9          7729          		EXX
042E55 52 ED 42    7730          		SBC.S   HL,BC
042E58 D9          7731          		EXX
042E59 D0          7732          		RET     NC
042E5A 52 09       7733          		ADD.S   HL,BC
042E5C D9          7734          		EXX
042E5D 52 ED 4A    7735          		ADC.S   HL,BC
042E60 D9          7736          		EXX
042E61 0D          7737          		DEC     C
042E62 C9          7738          		RET
042E63             7739  ;
042E63 DD 7E 00    7740  DIGITQ:			LD      A,(IX)
042E66 FE 3A       7741          		CP      '9'+1
042E68 3F          7742          		CCF
042E69 D8          7743          		RET     C
042E6A FE 30       7744          		CP      '0'
042E6C C9          7745          		RET
042E6D             7746  ;
042E6D DD 7E 00    7747  SIGNQ:			LD      A,(IX)
042E70 DD 23       7748          		INC     IX
042E72 FE 20       7749          		CP      ' '
042E74 28 F7       7750          		JR      Z,SIGNQ
042E76 FE 2B       7751          		CP      '+'
042E78 C8          7752          		RET     Z
042E79 FE 2D       7753          		CP      '-'
042E7B C8          7754          		RET     Z
042E7C DD 2B       7755          		DEC     IX
042E7E C9          7756          		RET; --- End fpp.asm ---
042E7F             7757  
042E7F             7758  ; --- Begin gpio.asm ---
042E7F             7759  ;
042E7F             7760  ; Title:	BBC Basic for AGON - GPIO functions
042E7F             7761  ; Author:	Dean Belfield
042E7F             7762  ; Created:	12/05/2023
042E7F             7763  ; Last Updated:	12/05/2023
042E7F             7764  ;
042E7F             7765  ; Modinfo:
042E7F             7766  
042E7F             7767  			; INCLUDE	"macros.inc"
042E7F             7768  			; INCLUDE	"equs.inc"
042E7F             7769  
042E7F             7770  			; .ASSUME	ADL = 1
042E7F             7771  
042E7F             7772  			; SEGMENT CODE
042E7F             7773  
042E7F             7774  			; XDEF	GPIOB_SETMODE
042E7F             7775  
042E7F             7776  			; XREF	SWITCH_A
042E7F             7777  
042E7F             7778  ;  A: Mode
042E7F             7779  ;  B: Pins
042E7F             7780  ;
042E7F CD 24 3E 04 7781  GPIOB_SETMODE:		CALL	SWITCH_A
042E83 97 2E       7782  			DW	GPIOB_M0	; Output
042E85 BC 2E       7783  			DW	GPIOB_M1	; Input
042E87 DC 2E       7784  			DW	GPIOB_M2	; Open Drain IO
042E89 FC 2E       7785  			DW	GPIOB_M3	; Open Source IO
042E8B 17 2F       7786  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E8D 43 2F       7787  			DW	GPIOB_M5	; Alt Function
042E8F 5E 2F       7788  			DW	GPIOB_M6	; Interrupt, Active Low
042E91 85 2F       7789  			DW	GPIOB_M7	; Interrupt, Active High
042E93 A7 2F       7790  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E95 C9 2F       7791  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E97             7792  
042E97             7793  ; Output
042E97             7794  ;
042E97             7795  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E97 C5          0001M 		PUSH	BC
042E98 78          0002M 		LD	A, val
042E99 2F          0003M 		CPL
042E9A 4F          0004M 		LD	C, A
042E9B ED 38 9B    0005M 		IN0	A, (reg)
042E9E A1          0006M 		AND	C
042E9F ED 39 9B    0007M 		OUT0	(reg), A
042EA2 C1          0008M 		POP	BC
042EA3             7796  			RES_GPIO PB_ALT1, B
042EA3 C5          0001M 		PUSH	BC
042EA4 78          0002M 		LD	A, val
042EA5 2F          0003M 		CPL
042EA6 4F          0004M 		LD	C, A
042EA7 ED 38 9C    0005M 		IN0	A, (reg)
042EAA A1          0006M 		AND	C
042EAB ED 39 9C    0007M 		OUT0	(reg), A
042EAE C1          0008M 		POP	BC
042EAF             7797  			RES_GPIO PB_ALT2, B
042EAF C5          0001M 		PUSH	BC
042EB0 78          0002M 		LD	A, val
042EB1 2F          0003M 		CPL
042EB2 4F          0004M 		LD	C, A
042EB3 ED 38 9D    0005M 		IN0	A, (reg)
042EB6 A1          0006M 		AND	C
042EB7 ED 39 9D    0007M 		OUT0	(reg), A
042EBA C1          0008M 		POP	BC
042EBB C9          7798  			RET
042EBC             7799  
042EBC             7800  ; Input
042EBC             7801  ;
042EBC             7802  GPIOB_M1:		SET_GPIO PB_DDR,  B
042EBC ED 38 9B    0001M 		IN0	A, (reg)
042EBF B0          0002M 		OR	val
042EC0 ED 39 9B    0003M 		OUT0	(reg), A
042EC3             7803  			RES_GPIO PB_ALT1, B
042EC3 C5          0001M 		PUSH	BC
042EC4 78          0002M 		LD	A, val
042EC5 2F          0003M 		CPL
042EC6 4F          0004M 		LD	C, A
042EC7 ED 38 9C    0005M 		IN0	A, (reg)
042ECA A1          0006M 		AND	C
042ECB ED 39 9C    0007M 		OUT0	(reg), A
042ECE C1          0008M 		POP	BC
042ECF             7804  			RES_GPIO PB_ALT2, B
042ECF C5          0001M 		PUSH	BC
042ED0 78          0002M 		LD	A, val
042ED1 2F          0003M 		CPL
042ED2 4F          0004M 		LD	C, A
042ED3 ED 38 9D    0005M 		IN0	A, (reg)
042ED6 A1          0006M 		AND	C
042ED7 ED 39 9D    0007M 		OUT0	(reg), A
042EDA C1          0008M 		POP	BC
042EDB C9          7805  			RET
042EDC             7806  
042EDC             7807  ; Open Drain IO
042EDC             7808  ;
042EDC             7809  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EDC C5          0001M 		PUSH	BC
042EDD 78          0002M 		LD	A, val
042EDE 2F          0003M 		CPL
042EDF 4F          0004M 		LD	C, A
042EE0 ED 38 9B    0005M 		IN0	A, (reg)
042EE3 A1          0006M 		AND	C
042EE4 ED 39 9B    0007M 		OUT0	(reg), A
042EE7 C1          0008M 		POP	BC
042EE8             7810  			SET_GPIO PB_ALT1, B
042EE8 ED 38 9C    0001M 		IN0	A, (reg)
042EEB B0          0002M 		OR	val
042EEC ED 39 9C    0003M 		OUT0	(reg), A
042EEF             7811  			RES_GPIO PB_ALT2, B
042EEF C5          0001M 		PUSH	BC
042EF0 78          0002M 		LD	A, val
042EF1 2F          0003M 		CPL
042EF2 4F          0004M 		LD	C, A
042EF3 ED 38 9D    0005M 		IN0	A, (reg)
042EF6 A1          0006M 		AND	C
042EF7 ED 39 9D    0007M 		OUT0	(reg), A
042EFA C1          0008M 		POP	BC
042EFB C9          7812  			RET
042EFC             7813  
042EFC             7814  ; Open Source IO
042EFC             7815  ;
042EFC             7816  GPIOB_M3:		SET_GPIO PB_DDR,  B
042EFC ED 38 9B    0001M 		IN0	A, (reg)
042EFF B0          0002M 		OR	val
042F00 ED 39 9B    0003M 		OUT0	(reg), A
042F03             7817  			SET_GPIO PB_ALT1, B
042F03 ED 38 9C    0001M 		IN0	A, (reg)
042F06 B0          0002M 		OR	val
042F07 ED 39 9C    0003M 		OUT0	(reg), A
042F0A             7818  			RES_GPIO PB_ALT2, B
042F0A C5          0001M 		PUSH	BC
042F0B 78          0002M 		LD	A, val
042F0C 2F          0003M 		CPL
042F0D 4F          0004M 		LD	C, A
042F0E ED 38 9D    0005M 		IN0	A, (reg)
042F11 A1          0006M 		AND	C
042F12 ED 39 9D    0007M 		OUT0	(reg), A
042F15 C1          0008M 		POP	BC
042F16 C9          7819  			RET
042F17             7820  
042F17             7821  ; Interrupt, Dual Edge
042F17             7822  ;
042F17             7823  GPIOB_M4:		SET_GPIO PB_DR,   B
042F17 ED 38 9A    0001M 		IN0	A, (reg)
042F1A B0          0002M 		OR	val
042F1B ED 39 9A    0003M 		OUT0	(reg), A
042F1E             7824  			RES_GPIO PB_DDR,  B
042F1E C5          0001M 		PUSH	BC
042F1F 78          0002M 		LD	A, val
042F20 2F          0003M 		CPL
042F21 4F          0004M 		LD	C, A
042F22 ED 38 9B    0005M 		IN0	A, (reg)
042F25 A1          0006M 		AND	C
042F26 ED 39 9B    0007M 		OUT0	(reg), A
042F29 C1          0008M 		POP	BC
042F2A             7825  			RES_GPIO PB_ALT1, B
042F2A C5          0001M 		PUSH	BC
042F2B 78          0002M 		LD	A, val
042F2C 2F          0003M 		CPL
042F2D 4F          0004M 		LD	C, A
042F2E ED 38 9C    0005M 		IN0	A, (reg)
042F31 A1          0006M 		AND	C
042F32 ED 39 9C    0007M 		OUT0	(reg), A
042F35 C1          0008M 		POP	BC
042F36             7826  			RES_GPIO PB_ALT2, B
042F36 C5          0001M 		PUSH	BC
042F37 78          0002M 		LD	A, val
042F38 2F          0003M 		CPL
042F39 4F          0004M 		LD	C, A
042F3A ED 38 9D    0005M 		IN0	A, (reg)
042F3D A1          0006M 		AND	C
042F3E ED 39 9D    0007M 		OUT0	(reg), A
042F41 C1          0008M 		POP	BC
042F42 C9          7827  			RET
042F43             7828  
042F43             7829  ; Alt Function
042F43             7830  ;
042F43             7831  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F43 ED 38 9B    0001M 		IN0	A, (reg)
042F46 B0          0002M 		OR	val
042F47 ED 39 9B    0003M 		OUT0	(reg), A
042F4A             7832  			RES_GPIO PB_ALT1, B
042F4A C5          0001M 		PUSH	BC
042F4B 78          0002M 		LD	A, val
042F4C 2F          0003M 		CPL
042F4D 4F          0004M 		LD	C, A
042F4E ED 38 9C    0005M 		IN0	A, (reg)
042F51 A1          0006M 		AND	C
042F52 ED 39 9C    0007M 		OUT0	(reg), A
042F55 C1          0008M 		POP	BC
042F56             7833  			SET_GPIO PB_ALT2, B
042F56 ED 38 9D    0001M 		IN0	A, (reg)
042F59 B0          0002M 		OR	val
042F5A ED 39 9D    0003M 		OUT0	(reg), A
042F5D C9          7834  			RET
042F5E             7835  
042F5E             7836  ; Interrupt, Active Low
042F5E             7837  ;
042F5E             7838  GPIOB_M6:		RES_GPIO PB_DR,   B
042F5E C5          0001M 		PUSH	BC
042F5F 78          0002M 		LD	A, val
042F60 2F          0003M 		CPL
042F61 4F          0004M 		LD	C, A
042F62 ED 38 9A    0005M 		IN0	A, (reg)
042F65 A1          0006M 		AND	C
042F66 ED 39 9A    0007M 		OUT0	(reg), A
042F69 C1          0008M 		POP	BC
042F6A             7839  			RES_GPIO PB_DDR,  B
042F6A C5          0001M 		PUSH	BC
042F6B 78          0002M 		LD	A, val
042F6C 2F          0003M 		CPL
042F6D 4F          0004M 		LD	C, A
042F6E ED 38 9B    0005M 		IN0	A, (reg)
042F71 A1          0006M 		AND	C
042F72 ED 39 9B    0007M 		OUT0	(reg), A
042F75 C1          0008M 		POP	BC
042F76             7840  			SET_GPIO PB_ALT1, B
042F76 ED 38 9C    0001M 		IN0	A, (reg)
042F79 B0          0002M 		OR	val
042F7A ED 39 9C    0003M 		OUT0	(reg), A
042F7D             7841  			SET_GPIO PB_ALT2, B
042F7D ED 38 9D    0001M 		IN0	A, (reg)
042F80 B0          0002M 		OR	val
042F81 ED 39 9D    0003M 		OUT0	(reg), A
042F84 C9          7842  			RET
042F85             7843  
042F85             7844  
042F85             7845  ; Interrupt, Active High
042F85             7846  ;
042F85             7847  GPIOB_M7:		SET_GPIO PB_DR,   B
042F85 ED 38 9A    0001M 		IN0	A, (reg)
042F88 B0          0002M 		OR	val
042F89 ED 39 9A    0003M 		OUT0	(reg), A
042F8C             7848  			RES_GPIO PB_DDR,  B
042F8C C5          0001M 		PUSH	BC
042F8D 78          0002M 		LD	A, val
042F8E 2F          0003M 		CPL
042F8F 4F          0004M 		LD	C, A
042F90 ED 38 9B    0005M 		IN0	A, (reg)
042F93 A1          0006M 		AND	C
042F94 ED 39 9B    0007M 		OUT0	(reg), A
042F97 C1          0008M 		POP	BC
042F98             7849  			SET_GPIO PB_ALT1, B
042F98 ED 38 9C    0001M 		IN0	A, (reg)
042F9B B0          0002M 		OR	val
042F9C ED 39 9C    0003M 		OUT0	(reg), A
042F9F             7850  			SET_GPIO PB_ALT2, B
042F9F ED 38 9D    0001M 		IN0	A, (reg)
042FA2 B0          0002M 		OR	val
042FA3 ED 39 9D    0003M 		OUT0	(reg), A
042FA6 C9          7851  			RET
042FA7             7852  
042FA7             7853  
042FA7             7854  ; Interrupt, Falling Edge
042FA7             7855  ;
042FA7             7856  GPIOB_M8:		RES_GPIO PB_DR,   B
042FA7 C5          0001M 		PUSH	BC
042FA8 78          0002M 		LD	A, val
042FA9 2F          0003M 		CPL
042FAA 4F          0004M 		LD	C, A
042FAB ED 38 9A    0005M 		IN0	A, (reg)
042FAE A1          0006M 		AND	C
042FAF ED 39 9A    0007M 		OUT0	(reg), A
042FB2 C1          0008M 		POP	BC
042FB3             7857  			SET_GPIO PB_DDR,  B
042FB3 ED 38 9B    0001M 		IN0	A, (reg)
042FB6 B0          0002M 		OR	val
042FB7 ED 39 9B    0003M 		OUT0	(reg), A
042FBA             7858  			SET_GPIO PB_ALT1, B
042FBA ED 38 9C    0001M 		IN0	A, (reg)
042FBD B0          0002M 		OR	val
042FBE ED 39 9C    0003M 		OUT0	(reg), A
042FC1             7859  			SET_GPIO PB_ALT2, B
042FC1 ED 38 9D    0001M 		IN0	A, (reg)
042FC4 B0          0002M 		OR	val
042FC5 ED 39 9D    0003M 		OUT0	(reg), A
042FC8 C9          7860  			RET
042FC9             7861  
042FC9             7862  ; Interrupt, Rising Edge
042FC9             7863  ;
042FC9             7864  GPIOB_M9:		SET_GPIO PB_DR,   B
042FC9 ED 38 9A    0001M 		IN0	A, (reg)
042FCC B0          0002M 		OR	val
042FCD ED 39 9A    0003M 		OUT0	(reg), A
042FD0             7865  			SET_GPIO PB_DDR,  B
042FD0 ED 38 9B    0001M 		IN0	A, (reg)
042FD3 B0          0002M 		OR	val
042FD4 ED 39 9B    0003M 		OUT0	(reg), A
042FD7             7866  			SET_GPIO PB_ALT1, B
042FD7 ED 38 9C    0001M 		IN0	A, (reg)
042FDA B0          0002M 		OR	val
042FDB ED 39 9C    0003M 		OUT0	(reg), A
042FDE             7867  			SET_GPIO PB_ALT2, B
042FDE ED 38 9D    0001M 		IN0	A, (reg)
042FE1 B0          0002M 		OR	val
042FE2 ED 39 9D    0003M 		OUT0	(reg), A
042FE5 C9          7868  			RET	; --- End gpio.asm ---
042FE6             7869  
042FE6             7870  ; --- Begin main.asm ---
042FE6             7871  ;
042FE6             7872  ; Title:	BBC Basic Interpreter - Z80 version
042FE6             7873  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FE6             7874  ; Author:	(C) Copyright  R.T.Russell  1984
042FE6             7875  ; Modified By:	Dean Belfield
042FE6             7876  ; Created:	12/05/2023
042FE6             7877  ; Last Updated:	26/11/2023
042FE6             7878  ;
042FE6             7879  ; Modinfo:
042FE6             7880  ; 07/05/1984:	Version 2.3
042FE6             7881  ; 01/03/1987:	Version 3.0
042FE6             7882  ; 03/05/2022:	Modified by Dean Belfield
042FE6             7883  ; 06/06/2023:	Modified to run in ADL mode
042FE6             7884  ; 26/06/2023:	Fixed binary and unary indirection
042FE6             7885  ; 17/08/2023:	Added binary constants
042FE6             7886  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FE6             7887  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FE6             7888  
042FE6             7889  			; .ASSUME	ADL = 1
042FE6             7890  
042FE6             7891  			; INCLUDE	"equs.inc"
042FE6             7892  
042FE6             7893  			; SEGMENT CODE
042FE6             7894  
042FE6             7895  			; XDEF	_main
042FE6             7896  
042FE6             7897  			; XDEF	COLD
042FE6             7898  			; XDEF	WARM
042FE6             7899  			; XDEF	CLOOP
042FE6             7900  			; XDEF	DELETE
042FE6             7901  			; XDEF	LIST_
042FE6             7902  			; XDEF	RENUM
042FE6             7903  			; XDEF	AUTO
042FE6             7904  			; XDEF	NEW
042FE6             7905  			; XDEF	OLD
042FE6             7906  			; XDEF	LOAD
042FE6             7907  			; XDEF	SAVE
042FE6             7908  			; XDEF	ERROR_
042FE6             7909  			; XDEF	EXTERR
042FE6             7910  			; XDEF	LOAD0
042FE6             7911  			; XDEF	CLEAR
042FE6             7912  			; XDEF	CRLF
042FE6             7913  			; XDEF	OUTCHR
042FE6             7914  			; XDEF	OUT_
042FE6             7915  			; XDEF	FINDL
042FE6             7916  			; XDEF	SETLIN
042FE6             7917  			; XDEF	PBCDL
042FE6             7918  			; XDEF	SAYLN
042FE6             7919  			; XDEF	PUTVAR
042FE6             7920  			; XDEF	GETVAR
042FE6             7921  			; XDEF	GETDEF
042FE6             7922  			; XDEF	CREATE
042FE6             7923  			; XDEF	RANGE
042FE6             7924  			; XDEF	LEXAN2
042FE6             7925  			; XDEF	REPORT
042FE6             7926  			; XDEF	TELL
042FE6             7927  			; XDEF	SPACE_
042FE6             7928  			; XDEF	KEYWDS
042FE6             7929  			; XDEF	KEYWDL
042FE6             7930  			; XDEF	ONEDIT
042FE6             7931  			; XDEF	ONEDIT1
042FE6             7932  			; XDEF	LISTIT
042FE6             7933  			; XDEF	CLEAN
042FE6             7934  
042FE6             7935  			; XREF	LISTON
042FE6             7936  			; XREF	ERRTXT
042FE6             7937  			; XREF	OSINIT
042FE6             7938  			; XREF	HIMEM
042FE6             7939  			; XREF	PAGE_
042FE6             7940  			; XREF	CHAIN0
042FE6             7941  			; XREF	PROMPT
042FE6             7942  			; XREF	ERRTRP
042FE6             7943  			; XREF	ERRLIN
042FE6             7944  			; XREF	AUTONO
042FE6             7945  			; XREF	LINENO
042FE6             7946  			; XREF	INCREM
042FE6             7947  			; XREF	OSLINE
042FE6             7948  			; XREF	COUNT
042FE6             7949  			; XREF	NXT
042FE6             7950  			; XREF	BUFFER
042FE6             7951  			; XREF	XEQ
042FE6             7952  			; XREF	TOP
042FE6             7953  			; XREF	EXPRI
042FE6             7954  			; XREF	SEARCH
042FE6             7955  			; XREF	LTRAP
042FE6             7956  			; XREF	LOMEM
042FE6             7957  			; XREF	DECODE
042FE6             7958  			; XREF	EXPRS
042FE6             7959  			; XREF	OSSAVE
042FE6             7960  			; XREF	ERR
042FE6             7961  			; XREF	ERL
042FE6             7962  			; XREF	TRACEN
042FE6             7963  			; XREF	RESET
042FE6             7964  			; XREF	OSSHUT
042FE6             7965  			; XREF	OSLOAD
042FE6             7966  			; XREF	FREE
042FE6             7967  			; XREF	DYNVAR
042FE6             7968  			; XREF	FILL
042FE6             7969  			; XREF	OSWRCH
042FE6             7970  			; XREF	WIDTH
042FE6             7971  			; XREF	COMMA
042FE6             7972  			; XREF	MUL16
042FE6             7973  			; XREF	BRAKET
042FE6             7974  			; XREF	X4OR5
042FE6             7975  			; XREF	LOADN
042FE6             7976  			; XREF	SFIX
042FE6             7977  			; XREF	ITEMI
042FE6             7978  			; XREF	FNPTR
042FE6             7979  			; XREF	PROPTR
042FE6             7980  			; XREF	CHECK
042FE6             7981  			; XREF	TERMQ
042FE6             7982  			; XREF	OSWRCHCH
042FE6             7983  			; XREF	NEWIT
042FE6             7984  			; XREF	BAD
042FE6             7985  			; XREF	RAM_START
042FE6             7986  			; XREF	RAM_END
042FE6             7987  			; XREF	R0
042FE6             7988  			; XREF	STAR_VERSION
042FE6             7989  
042FE6             7990  			; XREF	_end			; In init.asm
042FE6             7991  ;
042FE6             7992  ; A handful of common token IDs
042FE6             7993  ;
042FE6             7994  TERROR_MN:			EQU     85H
042FE6             7995  LINE_MN_:			EQU     86H
042FE6             7996  ELSE_MN_:			EQU     8BH
042FE6             7997  THEN_MN_:			EQU     8CH
042FE6             7998  LINO_MN:			EQU     8DH
042FE6             7999  FN:			EQU     A4H
042FE6             8000  TO_MN:			EQU     B8H
042FE6             8001  REN:			EQU     CCH
042FE6             8002  DATA_MN_:			EQU     DCH
042FE6             8003  DIM:			EQU     DEH
042FE6             8004  FOR:			EQU     E3H
042FE6             8005  GOSUB:			EQU     E4H
042FE6             8006  GOTO:			EQU     E5H
042FE6             8007  TIF:			EQU     E7H
042FE6             8008  LOCAL_:			EQU     EAH
042FE6             8009  NEXT:			EQU     EDH
042FE6             8010  ON_:			EQU     EEH
042FE6             8011  PROC:			EQU     F2H
042FE6             8012  REM:			EQU     F4H
042FE6             8013  REPEAT:			EQU     F5H
042FE6             8014  RESTOR:			EQU     F7H
042FE6             8015  TRACE:			EQU     FCH
042FE6             8016  UNTIL:			EQU     FDH
042FE6             8017  ;
042FE6             8018  ; This defines the block of tokens that are pseudo-variables.
042FE6             8019  ; There are two versions of each token, a GET and a SET
042FE6             8020  
042FE6             8021  ; Name  : GET : SET
042FE6             8022  ; ------:-----:----
042FE6             8023  ; PTR   : 8Fh : CFh
042FE6             8024  ; PAGE  : 90h : D0h
042FE6             8025  ; TIME  : 91h : D1h
042FE6             8026  ; LOMEM : 92h : D2h
042FE6             8027  ; HIMEM : 93h : D3h
042FE6             8028  ;
042FE6             8029  ; Examples:
042FE6             8030  ;   LET A% = PAGE : REM This is the GET version
042FE6             8031  ;   PAGE = 40000  : REM This is the SET version
042FE6             8032  ;
042FE6             8033  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FE6             8034  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FE6             8035  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FE6             8036  
042FE6             8037  ; The main routine
042FE6             8038  ; IXU: argv - pointer to array of parameters
042FE6             8039  ;   C: argc - number of parameters
042FE6             8040  ; Returns:
042FE6             8041  ;  HL: Error code, or 0 if OK
042FE6             8042  ;
042FE6 21 00 4A 04 8043  _main:			LD	HL, ACCS		; Clear the ACCS
042FEA 36 00       8044  			LD	(HL), 0
042FEC 79          8045  			LD	A, C
042FED FE 02       8046  			CP	2
042FEF 28 2D       8047  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF1 38 3F       8048  			JR	C, COLD			; 1 parameter = normal start
042FF3 CD 79 40 04 8049  			CALL	STAR_VERSION
042FF7 CD C0 3D 04 8050  			CALL	TELL
042FFB 55 73 61 67 8051  			DB	"Usage:\n\r"
       65 3A 0A 0D 
043003 52 55 4E 20 8052  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
043016 21 00 00 00 8053  			LD	HL, 0			; The error code
04301A C3 68 00 04 8054  			JP	_end
04301E             8055  ;
04301E DD 27 03    8056  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043021 11 00 4A 04 8057  			LD	DE, ACCS		;  DE: Destination address
043025 7E          8058  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
043026 12          8059  			LD	(DE), A			;
043027 23          8060  			INC	HL			; Increase the source pointer
043028 1C          8061  			INC	E			; We only need to increase E as ACCS is on a page boundary
043029 28 03       8062  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
04302B B7          8063  			OR	A
04302C 20 F7       8064  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
04302E 1D          8065  AUTOLOAD_2:		DEC	E
04302F 3E 0D       8066  			LD	A, CR
043031 12          8067  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
043032             8068  ;
043032 E1          8069  COLD:			POP	HL			; Pop the return address to init off SPS
043033 E5          8070  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043034 21 00 4C 04 8071  			LD	HL, STAVAR		; Cold start
043038 F9          8072  			LD	SP, HL
043039 36 0A       8073  			LD	(HL), 10
04303B 23          8074  			INC	HL
04303C 36 09       8075  			LD	(HL),9
04303E CD B1 3F 04 8076  			CALL    OSINIT			; Call the machine specific OS initialisation routines
043042 ED 53 20 4D 8077  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
043047 22 14 4D 04 8078  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
04304B 3E B7       8079  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
04304D 32 40 4D 04 8080  			LD      (LISTON),A
043051 21 8C 30 04 8081  			LD      HL,NOTICE
043055 22 2F 4D 04 8082  			LD      (ERRTXT),HL
043059 CD 9C 38 04 8083  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
04305D 3A 00 4A 04 8084  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043061 B7          8085  			OR	A
043062 C2 53 0B 04 8086  			JP	NZ,CHAIN0		; Yes, so load and run
043066 CD 79 40 04 8087  			CALL	STAR_VERSION		;
04306A CD C0 3D 04 8088  			CALL    TELL			; Output the welcome message
04306E 42 42 43 20 8089  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
04308C 28 43 29 20 8090  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0430AC 0A 0D 00    8091  			DB	"\n\r", 0
0430AF             8092  ;
0430AF F6          8093  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0430B0             8094  ;
0430B0             8095  ; This is the main entry point for BASIC
0430B0             8096  ;
0430B0 37          8097  CLOOP:			SCF				; See above - not sure why this is here!
0430B1 ED 7B 20 4D 8098  			LD      SP,(HIMEM)
       04          
0430B6 CD 2A 3F 04 8099  			CALL    PROMPT          	; Prompt user
0430BA 21 40 4D 04 8100  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430BE 7E          8101  			LD      A,(HL)			; Fetch the value
0430BF E6 0F       8102  			AND     0FH             	; Bottom nibble: LISTO
0430C1 F6 B0       8103  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430C3 77          8104  			LD      (HL),A			; Store back in
0430C4 ED 62       8105  			SBC     HL,HL           	; HL: 0
0430C6 22 2C 4D 04 8106  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430CA 22 35 4D 04 8107  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430CE             8108  ;
0430CE 2A 29 4D 04 8109  			LD      HL,(AUTONO)		; Get the auto line number
0430D2 22 23 4D 04 8110  			LD      (LINENO),HL		; Store in line number
0430D6 7C          8111  			LD      A,H			; If the auto line number is zero then
0430D7 B5          8112  			OR      L
0430D8 28 1E       8113  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430DA             8114  ;
0430DA             8115  ; This section handles auto line numbering
0430DA             8116  ;
0430DA E5          8117  			PUSH    HL			; Stack the line number
0430DB CD 2B 3A 04 8118  			CALL    PBCD           	 	; Output the line number
0430DF E1          8119  			POP     HL			; Pop the line number back off the stack
0430E0             8120  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0430E0             8121  ;			LD      B,0			; So clear B
0430E0 01 00 00 00 8122  			LD	BC, 0			; Load BC with Increment
0430E4 3A 41 4D 04 8123  			LD	A,(INCREM)
0430E8 4F          8124  			LD	C, A
0430E9 09          8125  			ADD     HL,BC			; Add the increment to the line number
0430EA DA 55 3C 04 8126  			JP      C,TOOBIG		; And error if we wrap
0430EE 22 29 4D 04 8127  			LD      (AUTONO),HL		; Store the new auto line number
0430F2 3E 20       8128  			LD      A,' '			; Print a space
0430F4 CD 7F 39 04 8129  			CALL    OUTCHR
0430F8             8130  ;
0430F8             8131  ; This section invokes the line editor
0430F8             8132  ;
0430F8 21 00 4A 04 8133  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0430FC CD 8F 3E 04 8134  			CALL    OSLINE          	; Call the line editor in MOS
043100 CD 0C 31 04 8135  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
043104 DC 6F 38 04 8136  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
043108 C3 B0 30 04 8137  			JP      CLOOP			; Jump back to immediate mode
04310C             8138  ;
04310C             8139  ; This bit enters the line into memory
04310C             8140  ; Also called from OSLOAD_TXT
04310C             8141  ; Returns:
04310C             8142  ; F: C if a new line has been entered (CLEAN will need to be called)
04310C             8143  ;
04310C AF          8144  ONEDIT1:		XOR     A			; Entry point after *EDIT
04310D 32 3D 4D 04 8145  			LD      (COUNT),A
043111 FD 21 00 4A 8146  			LD      IY,ACCS
       04          
043116 CD 29 3C 04 8147  			CALL    LINNUM			; HL: The line number from the input buffer
04311A CD 70 0A 04 8148  			CALL    NXT			; Skip spaces
04311E 7C          8149  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
04311F B5          8150  			OR      L
043120 28 04       8151  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043122 22 23 4D 04 8152  			LD      (LINENO),HL		; Otherwise store it
043126             8153  ;
043126             8154  ; This bit does the lexical analysis and tokenisation
043126             8155  ;
043126 0E 01       8156  LNZERO:			LD	C,1			; Left mode
043128 11 00 4B 04 8157  			LD      DE,BUFFER		; Buffer for tokenised BASIC
04312C CD CF 3C 04 8158  			CALL    LEXAN2          	; Lexical analysis on the user input
043130 12          8159  			LD      (DE),A          	; Terminator
043131 AF          8160  			XOR     A
043132             8161  ;			LD      B,A
043132             8162  ;			LD      C,E             	; BC: Line length
043132 01 00 00 00 8163  			LD	BC,0
043136 4B          8164  			LD	C,E			; BC: Line length
043137 13          8165  			INC     DE
043138 12          8166  			LD      (DE),A          	; Zero next
043139 2A 23 4D 04 8167  			LD      HL,(LINENO)		; Get the line number
04313D 7C          8168  			LD      A,H			; Is it zero, i.e. a command with no line number?
04313E B5          8169  			OR      L
04313F FD 21 00 4B 8170  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
043144 CA 96 0B 04 8171  			JP      Z,XEQ           	; Execute it
043148             8172  ;
043148             8173  ; This section stores the BASIC line in memory
043148             8174  ;
043148 C5          8175  			PUSH    BC
043149 E5          8176  			PUSH    HL
04314A CD 7B 38 04 8177  			CALL    SETTOP          	; Set TOP sysvar
04314E E1          8178  			POP     HL
04314F CD BF 39 04 8179  			CALL    FINDL			; Find the address of the line
043153 CC 32 38 04 8180  			CALL    Z,DEL			; Delete the existing line if found
043157 C1          8181  			POP     BC
043158 79          8182  			LD      A,C			; Check for the line length being zero, i.e.
043159 B7          8183  			OR      A			; the user has just entered a line number in the command line
04315A C8          8184  			RET	Z 	         	; If so, then don't do anything else
04315B C6 04       8185  			ADD     A,4
04315D 4F          8186  			LD      C,A             	; Length inclusive
04315E D5          8187  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
04315F C5          8188  			PUSH    BC              	; BC: Line length
043160 EB          8189  			EX      DE,HL			; DE: Address of the line in memory
043161 2A 17 4D 04 8190  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043165 E5          8191  			PUSH    HL			; Stack TOP (current TOP value)
043166 09          8192  			ADD     HL,BC			; Add the line length to HL, the new TOP value
043167 E5          8193  			PUSH    HL			; Stack HL (new TOP value)
043168 24          8194  			INC     H			; Add 256 to HL
043169 AF          8195  			XOR     A
04316A ED 72       8196  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04316C E1          8197  			POP     HL			; Pop HL (new TOP value)
04316D D2 90 37 04 8198  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043171 22 17 4D 04 8199  			LD      (TOP),HL		; Store new value of TOP
043175 E3          8200  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043176 E5          8201  			PUSH    HL			; PUSH current TOP value
043177 23          8202  			INC     HL
043178 B7          8203  			OR      A
043179 ED 52       8204  			SBC     HL,DE			; DE: Address of the line in memory
04317B 44          8205  			LD      B,H             	; BC: Amount to move
04317C 4D          8206  			LD      C,L
04317D E1          8207  			POP     HL			; HL: Destination (current TOP value)
04317E D1          8208  			POP     DE			; DE: Source (new TOP value)
04317F 28 02       8209  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043181 ED B8       8210  			LDDR                    	; Otherwise, make space for the new line in the program
043183 C1          8211  ATEND:			POP     BC              	; BC: Line length
043184 D1          8212  			POP     DE              	; DE: Line number
043185 23          8213  			INC     HL			; HL: Destination address
043186 71          8214  			LD      (HL),C          	; Store length
043187 23          8215  			INC     HL
043188 73          8216  			LD      (HL),E          	; Store line number
043189 23          8217  			INC     HL
04318A 72          8218  			LD      (HL),D
04318B 23          8219  			INC     HL
04318C 11 00 4B 04 8220  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
043190 EB          8221  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043191 0D          8222  			DEC     C			; Subtract 3 from the number of bytes to copy to
043192 0D          8223  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
043193 0D          8224  			DEC     C
043194 ED B0       8225  			LDIR                    	; Add the line to the BASIC program
043196 37          8226  			SCF				; To flag we need to call CLEAN
043197 C9          8227  			RET
043198             8228  ;
043198             8229  ; List of tokens and keywords. If a keyword is followed by 0 then
043198             8230  ; it will only match with the keyword followed immediately by
043198             8231  ; a delimiter
043198             8232  ;
043198 80 41 4E 44 8233  KEYWDS:			DB    80H, "AND"
04319C 94 41 42 53 8234  			DB    94H, "ABS"
0431A0 95 41 43 53 8235  			DB    95H, "ACS"
0431A4 96 41 44 56 8236  			DB    96H, "ADVAL"
       41 4C       
0431AA 97 41 53 43 8237  			DB    97H, "ASC"
0431AE 98 41 53 4E 8238  			DB    98H, "ASN"
0431B2 99 41 54 4E 8239  			DB    99H, "ATN"
0431B6 C6 41 55 54 8240  			DB    C6H, "AUTO"
       4F          
0431BB 9A 42 47 45 8241  			DB    9AH, "BGET", 0
       54 00       
0431C1 D5 42 50 55 8242  			DB    D5H, "BPUT", 0
       54 00       
0431C7 FB 43 4F 4C 8243  			DB    FBH, "COLOUR"
       4F 55 52    
0431CE FB 43 4F 4C 8244  			DB    FBH, "COLOR"
       4F 52       
0431D4 D6 43 41 4C 8245  			DB    D6H, "CALL"
       4C          
0431D9 D7 43 48 41 8246  			DB    D7H, "CHAIN"
       49 4E       
0431DF BD 43 48 52 8247  			DB    BDH, "CHR$"
       24          
0431E4 D8 43 4C 45 8248  			DB    D8H, "CLEAR", 0
       41 52 00    
0431EB D9 43 4C 4F 8249  			DB    D9H, "CLOSE", 0
       53 45 00    
0431F2 DA 43 4C 47 8250  			DB    DAH, "CLG", 0
       00          
0431F7 DB 43 4C 53 8251  			DB    DBH, "CLS", 0
       00          
0431FC 9B 43 4F 53 8252  			DB    9BH, "COS"
043200 9C 43 4F 55 8253  			DB    9CH, "COUNT", 0
       4E 54 00    
043207 DC 44 41 54 8254  			DB    DCH, "DATA"
       41          
04320C 9D 44 45 47 8255  			DB    9DH, "DEG"
043210 DD 44 45 46 8256  			DB    DDH, "DEF"
043214 C7 44 45 4C 8257  			DB    C7H, "DELETE"
       45 54 45    
04321B 81 44 49 56 8258  			DB    81H, "DIV"
04321F DE 44 49 4D 8259  			DB    DEH, "DIM"
043223 DF 44 52 41 8260  			DB    DFH, "DRAW"
       57          
043228 E1 45 4E 44 8261  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043231 E0 45 4E 44 8262  			DB    E0H, "END", 0
       00          
043236 E2 45 4E 56 8263  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
04323F 8B 45 4C 53 8264  			DB    8BH, "ELSE"
       45          
043244 A0 45 56 41 8265  			DB    A0H, "EVAL"
       4C          
043249 9E 45 52 4C 8266  			DB    9EH, "ERL", 0
       00          
04324E 85 45 52 52 8267  			DB    85H, "ERROR"
       4F 52       
043254 C5 45 4F 46 8268  			DB    C5H, "EOF", 0
       00          
043259 82 45 4F 52 8269  			DB    82H, "EOR"
04325D 9F 45 52 52 8270  			DB    9FH, "ERR", 0
       00          
043262 A1 45 58 50 8271  			DB    A1H, "EXP"
043266 A2 45 58 54 8272  			DB    A2H, "EXT", 0
       00          
04326B E3 46 4F 52 8273  			DB    E3H, "FOR"
04326F A3 46 41 4C 8274  			DB    A3H, "FALSE", 0
       53 45 00    
043276 A4 46 4E    8275  			DB    A4H, "FN"
043279 E5 47 4F 54 8276  			DB    E5H, "GOTO"
       4F          
04327E BE 47 45 54 8277  			DB    BEH, "GET$"
       24          
043283 A5 47 45 54 8278  			DB    A5H, "GET"
043287 E4 47 4F 53 8279  			DB    E4H, "GOSUB"
       55 42       
04328D E6 47 43 4F 8280  			DB    E6H, "GCOL"
       4C          
043292 93 48 49 4D 8281  			DB    93H, "HIMEM", 0
       45 4D 00    
043299 E8 49 4E 50 8282  			DB    E8H, "INPUT"
       55 54       
04329F E7 49 46    8283  			DB    E7H, "IF"
0432A2 BF 49 4E 4B 8284  			DB    BFH, "INKEY$"
       45 59 24    
0432A9 A6 49 4E 4B 8285  			DB    A6H, "INKEY"
       45 59       
0432AF A8 49 4E 54 8286  			DB    A8H, "INT"
0432B3 A7 49 4E 53 8287  			DB    A7H, "INSTR("
       54 52 28    
0432BA C9 4C 49 53 8288  			DB    C9H, "LIST"
       54          
0432BF 86 4C 49 4E 8289  			DB    86H, "LINE"
       45          
0432C4 C8 4C 4F 41 8290  			DB    C8H, "LOAD"
       44          
0432C9 92 4C 4F 4D 8291  			DB    92H, "LOMEM", 0
       45 4D 00    
0432D0 EA 4C 4F 43 8292  			DB    EAH, "LOCAL"
       41 4C       
0432D6 C0 4C 45 46 8293  			DB    C0H, "LEFT$("
       54 24 28    
0432DD A9 4C 45 4E 8294  			DB    A9H, "LEN"
0432E1 E9 4C 45 54 8295  			DB    E9H, "LET"
0432E5 AB 4C 4F 47 8296  			DB    ABH, "LOG"
0432E9 AA 4C 4E    8297  			DB    AAH, "LN"
0432EC C1 4D 49 44 8298  			DB    C1H, "MID$("
       24 28       
0432F2 EB 4D 4F 44 8299  			DB    EBH, "MODE"
       45          
0432F7 83 4D 4F 44 8300  			DB    83H, "MOD"
0432FB EC 4D 4F 56 8301  			DB    ECH, "MOVE"
       45          
043300 ED 4E 45 58 8302  			DB    EDH, "NEXT"
       54          
043305 CA 4E 45 57 8303  			DB    CAH, "NEW", 0
       00          
04330A AC 4E 4F 54 8304  			DB    ACH, "NOT"
04330E CB 4F 4C 44 8305  			DB    CBH, "OLD", 0
       00          
043313 EE 4F 4E    8306  			DB    EEH, "ON"
043316 87 4F 46 46 8307  			DB    87H, "OFF"
04331A 84 4F 52    8308  			DB    84H, "OR"
04331D 8E 4F 50 45 8309  			DB    8EH, "OPENIN"
       4E 49 4E    
043324 AE 4F 50 45 8310  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
04332C AD 4F 50 45 8311  			DB    ADH, "OPENUP"
       4E 55 50    
043333 FF 4F 53 43 8312  			DB    FFH, "OSCLI"
       4C 49       
043339 F1 50 52 49 8313  			DB    F1H, "PRINT"
       4E 54       
04333F 90 50 41 47 8314  			DB    90H, "PAGE", 0
       45 00       
043345 8F 50 54 52 8315  			DB    8FH, "PTR", 0
       00          
04334A AF 50 49 00 8316  			DB    AFH, "PI", 0
04334E F0 50 4C 4F 8317  			DB    F0H, "PLOT"
       54          
043353 B0 50 4F 49 8318  			DB    B0H, "POINT("
       4E 54 28    
04335A F2 50 52 4F 8319  			DB    F2H, "PROC"
       43          
04335F B1 50 4F 53 8320  			DB    B1H, "POS", 0
       00          
043364 CE 50 55 54 8321  			DB    CEH, "PUT"
043368 F8 52 45 54 8322  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043370 F5 52 45 50 8323  			DB    F5H, "REPEAT"
       45 41 54    
043377 F6 52 45 50 8324  			DB    F6H, "REPORT", 0
       4F 52 54 00 
04337F F3 52 45 41 8325  			DB    F3H, "READ"
       44          
043384 F4 52 45 4D 8326  			DB    F4H, "REM"
043388 F9 52 55 4E 8327  			DB    F9H, "RUN", 0
       00          
04338D B2 52 41 44 8328  			DB    B2H, "RAD"
043391 F7 52 45 53 8329  			DB    F7H, "RESTORE"
       54 4F 52 45 
043399 C2 52 49 47 8330  			DB    C2H, "RIGHT$("
       48 54 24 28 
0433A1 B3 52 4E 44 8331  			DB    B3H, "RND", 0
       00          
0433A6 CC 52 45 4E 8332  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0433AF 88 53 54 45 8333  			DB    88H, "STEP"
       50          
0433B4 CD 53 41 56 8334  			DB    CDH, "SAVE"
       45          
0433B9 B4 53 47 4E 8335  			DB    B4H, "SGN"
0433BD B5 53 49 4E 8336  			DB    B5H, "SIN"
0433C1 B6 53 51 52 8337  			DB    B6H, "SQR"
0433C5 89 53 50 43 8338  			DB    89H, "SPC"
0433C9 C3 53 54 52 8339  			DB    C3H, "STR$"
       24          
0433CE C4 53 54 52 8340  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433D7 D4 53 4F 55 8341  			DB    D4H, "SOUND"
       4E 44       
0433DD FA 53 54 4F 8342  			DB    FAH, "STOP", 0
       50 00       
0433E3 B7 54 41 4E 8343  			DB    B7H, "TAN"
0433E7 8C 54 48 45 8344  			DB    8CH, "THEN"
       4E          
0433EC B8 54 4F    8345  			DB    B8H, "TO"
0433EF 8A 54 41 42 8346  			DB    8AH, "TAB("
       28          
0433F4 FC 54 52 41 8347  			DB    FCH, "TRACE"
       43 45       
0433FA 91 54 49 4D 8348  			DB    91H, "TIME", 0
       45 00       
043400 B9 54 52 55 8349  			DB    B9H, "TRUE", 0
       45 00       
043406 FD 55 4E 54 8350  			DB    FDH, "UNTIL"
       49 4C       
04340C BA 55 53 52 8351  			DB    BAH, "USR"
043410 EF 56 44 55 8352  			DB    EFH, "VDU"
043414 BB 56 41 4C 8353  			DB    BBH, "VAL"
043418 BC 56 50 4F 8354  			DB    BCH, "VPOS", 0
       53 00       
04341E FE 57 49 44 8355  			DB    FEH, "WIDTH"
       54 48       
043424 D3 48 49 4D 8356  			DB    D3H, "HIMEM"
       45 4D       
04342A D2 4C 4F 4D 8357  			DB    D2H, "LOMEM"
       45 4D       
043430 D0 50 41 47 8358  			DB    D0H, "PAGE"
       45          
043435 CF 50 54 52 8359  			DB    CFH, "PTR"
043439 D1 54 49 4D 8360  			DB    D1H, "TIME"
       45          
04343E             8361  ;
04343E             8362  ; These are indexed from the ERRWDS table
04343E             8363  ;
04343E 01 4D 69 73 8364  			DB    01H, "Missing "
       73 69 6E 67 
       20          
043447 02 4E 6F 20 8365  			DB    02H, "No such "
       73 75 63 68 
       20          
043450 03 42 61 64 8366  			DB    03H, "Bad "
       20          
043455 04 20 72 61 8367  			DB    04H, " range"
       6E 67 65    
04345C 05 76 61 72 8368  			DB    05H, "variable"
       69 61 62 6C 
       65          
043465 06 4F 75 74 8369  			DB    06H, "Out of"
       20 6F 66    
04346C 07 4E 6F 20 8370  			DB    07H, "No "
043470 08 20 73 70 8371  			DB    08H, " space"
       61 63 65    
043477             8372  
043477             8373  KEYWDL:			EQU     $-KEYWDS
043477 FF FF       8374  			DW    -1
043479             8375  ;
043479             8376  ; Error messages
043479             8377  ;
043479 07 72 6F 6F 8378  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
04347F 06 04 00    8379  			DB    6, 4, 0			;  1: Out of range
043482 00          8380  			DB    0				;  2: *
043483 00          8381  			DB    0				;  3: *
043484 4D 69 73 74 8382  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
04348C 01 2C 00    8383  			DB    1, ",", 0			;  5: Missing ,
04348F 54 79 70 65 8384  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
04349D 07 A4 00    8385  			DB    7, FN, 0			;  7: No FN
0434A0 00          8386  			DB    0				;  8: *
0434A1 01 22 00    8387  			DB    1, 34, 0			;  9: Missing "
0434A4 03 DE 00    8388  			DB    3, DIM, 0			; 10: Bad DIM
0434A7 DE 08 00    8389  			DB    DIM, 8, 0			; 11: DIM space
0434AA 4E 6F 74 20 8390  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0434B0 07 F2 00    8391  			DB    7, PROC, 0		; 13: No PROC
0434B3 41 72 72 61 8392  			DB    "Array", 0		; 14: Array
       79 00       
0434B9 53 75 62 73 8393  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0434C3 53 79 6E 74 8394  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434D0 45 73 63 61 8395  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434D7 44 69 76 69 8396  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0434E8 53 74 72 69 8397  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0434F8 54 6F 6F 20 8398  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
043500 2D 76 65 20 8399  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
043509 4C 6F 67 04 8400  			DB    "Log", 4, 0		; 22: Log range
       00          
04350E 41 63 63 75 8401  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
04351C 45 78 70 04 8402  			DB    "Exp", 4, 0		; 24: Exp range
       00          
043521 00          8403  			DB    0				; 25: *
043522 02 05 00    8404  			DB    2, 5, 0			; 26: No such variable
043525 01 29 00    8405  			DB    1, ")", 0			; 27: Missing )
043528 03 48 45 58 8406  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
04352D 02 A4 2F F2 8407  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043532 03 63 61 6C 8408  			DB    3, "call", 0		; 30: Bad call
       6C 00       
043538 41 72 67 75 8409  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043542 07 E3 00    8410  			DB    7, FOR, 0			; 32: No FOR
043545 43 61 6E 27 8411  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043553 E3 20 05 00 8412  			DB    FOR, " ", 5, 0		; 34: FOR variable
043557 00          8413  			DB    0				; 35: *
043558 07 B8 00    8414  			DB    7, TO_MN, 0			; 36: No TO
04355B 00          8415  			DB    0				; 37: *
04355C 07 E4 00    8416  			DB    7, GOSUB, 0		; 38: No GOSUB
04355F EE 20 73 79 8417  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
043568 EE 04 00    8418  			DB    ON_, 4, 0			; 40: ON range
04356B 02 6C 69 6E 8419  			DB    2, "line", 0		; 41: No such line
       65 00       
043571 06 20 DC 00 8420  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
043575 07 F5 00    8421  			DB    7, REPEAT, 0		; 43: No REPEAT
043578 00          8422  			DB    0				; 44: *
043579 01 23 00    8423  			DB    1, "#", 0			; 45: Missing #
04357C             8424  ;
04357C             8425  ; COMMANDS:
04357C             8426  ;
04357C             8427  ; DELETE line,line
04357C             8428  ;
04357C CD 7B 38 04 8429  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
043580 CD 83 3C 04 8430  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043584 7E          8431  DELET1:			LD      A,(HL)			; Check whether it's the last line
043585 B7          8432  			OR      A
043586 CA 0D 36 04 8433  			JP      Z,WARMNC		; Yes, so do nothing
04358A 23          8434  			INC     HL			; Skip the line length byte
04358B 11 00 00 00 8435  			LD	DE, 0			; Clear DE
04358F 5E          8436  			LD      E,(HL)			; Fetch the line number in DE
043590 23          8437  			INC     HL
043591 56          8438  			LD      D,(HL)
043592 7A          8439  			LD      A,D			; If the line number is zero then
043593 B3          8440  			OR      E
043594 28 1D       8441  			JR      Z,CLOOP1        	; Do nothing
043596 2B          8442  			DEC     HL			; Decrement BASIC program pointer back to length
043597 2B          8443  			DEC     HL
043598 EB          8444  			EX      DE,HL			; Check if we've gone past the terminating line
043599 37          8445  			SCF
04359A ED 42       8446  			SBC     HL,BC
04359C EB          8447  			EX      DE,HL
04359D 30 6E       8448  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04359F C5          8449  			PUSH    BC
0435A0 CD 32 38 04 8450  			CALL    DEL			; Delete the line pointed to by HL
0435A4 C1          8451  			POP     BC
0435A5 18 DD       8452  			JR      DELET1			; And loop round to the next line
0435A7             8453  ;
0435A7             8454  ; LISTO expr
0435A7             8455  ;
0435A7 FD 23       8456  LISTO:			INC     IY              	; Skip "O" byte
0435A9 CD 0A 03 04 8457  			CALL    EXPRI			; Get expr
0435AD D9          8458  			EXX
0435AE 7D          8459  			LD      A,L
0435AF 32 40 4D 04 8460  			LD      (LISTON),A		; Store in LISTON sysvar
0435B3 C3 B0 30 04 8461  CLOOP1:			JP      CLOOP
0435B7             8462  ;
0435B7             8463  ; LIST
0435B7             8464  ; LIST line
0435B7             8465  ; LIST line,line [IF string]
0435B7             8466  ; LIST ,line
0435B7             8467  ; LIST line,
0435B7             8468  ;
0435B7 FE 4F       8469  LIST_:			CP      'O'			; Check for O (LISTO)
0435B9 28 EC       8470  			JR      Z,LISTO			; and jump to LISTO if zero
0435BB CD 83 3C 04 8471  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435BF CD 70 0A 04 8472  			CALL    NXT			; Skip space
0435C3 FE E7       8473  			CP      TIF             	; Check for IF clause (token IF)
0435C5 3E 00       8474  			LD      A,0             	; Initialise the IF clause string length
0435C7 20 17       8475  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435C9             8476  ;
0435C9 FD 23       8477  			INC     IY              	; Skip the IF token
0435CB CD 70 0A 04 8478  			CALL    NXT             	; And skip any spaces
0435CF EB          8479  			EX      DE,HL			; DE: Address in memory
0435D0 FD E5       8480  			PUSH    IY			; LD IY, HL
0435D2 E1          8481  			POP     HL              	; HL is now the address of the tokenised line
0435D3 3E 0D       8482  			LD      A,CR
0435D5 C5          8483  			PUSH    BC			; Stack the second line number arg
0435D6 01 00 01 00 8484  			LD      BC,256
0435DA ED B1       8485  			CPIR                    	; Locate CR byte
0435DC 79          8486  			LD      A,C
0435DD 2F          8487  			CPL                    	 	; A: Substring length (of IF clause)
0435DE C1          8488  			POP     BC			; Restore the second line number arg
0435DF EB          8489  			EX      DE,HL			; HL: Address in memory
0435E0             8490  ;
0435E0 5F          8491  LISTB:			LD      E,A             	; E: IF clause string length
0435E1 78          8492  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0435E2 B1          8493  			OR      C
0435E3 20 01       8494  			JR      NZ,LISTA		; If there isn't a second line number
0435E5 0B          8495  			DEC     BC			; then we set it to the maximum of 65535
0435E6             8496  ;
0435E6 D9          8497  LISTA:			EXX
0435E7 DD 21 40 4D 8498  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
0435EC 01 00 00 00 8499  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435F0 D9          8500  			EXX
0435F1 3E 14       8501  			LD      A,20			; Number of lines to list
0435F3             8502  ;
0435F3 C5          8503  LISTC:			PUSH    BC              	; Save second line number
0435F4 D5          8504  			PUSH    DE              	; Save IF clause length
0435F5 E5          8505  			PUSH    HL              	; Save BASIC program counter
0435F6 08          8506  			EX      AF,AF'
0435F7             8507  ;
0435F7             8508  ; BBC BASIC for Z80 lines are stored as follows:
0435F7             8509  ;
0435F7             8510  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0435F7             8511  ; - [&00] [&FF] [&FF]: End of program marker
0435F7             8512  ;
0435F7             8513  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0435F7             8514  ;
0435F7 7E          8515  			LD      A,(HL)			; Check for end of program marker
0435F8 B7          8516  			OR      A			; If found
0435F9 28 12       8517  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0435FB             8518  ;
0435FB             8519  ; Check if past terminating line number
0435FB             8520  ;
0435FB 7B          8521  			LD      A,E             	; A: IF clause length
0435FC 23          8522  			INC     HL			; Skip the length byte
0435FD 11 00 00 00 8523  			LD	DE,0			; Clear DE
043601 5E          8524  			LD      E,(HL)			; Fetch the line number in DE
043602 23          8525  			INC     HL
043603 56          8526  			LD      D,(HL)
043604 2B          8527  			DEC     HL			; Step HL back to the length byte
043605 2B          8528  			DEC     HL
043606 D5          8529  			PUSH    DE             	 	; Push the line number on the stack
043607 EB          8530  			EX      DE,HL			; HL: line number
043608 37          8531  			SCF				; Do a 16-bit compare of HL and DE
043609 ED 42       8532  			SBC     HL,BC
04360B EB          8533  			EX      DE,HL
04360C D1          8534  			POP     DE              	; Restore the line number
04360D D2 AF 30 04 8535  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043611 4E          8536  			LD      C,(HL)          	; C: Line length + 4
043612 47          8537  			LD      B,A             	; B: IF clause length
043613             8538  ;
043613             8539  ; Check if "UNLISTABLE":
043613             8540  ;
043613 7A          8541  			LD      A,D			; TODO: What is "UNLISTABLE?"
043614 B3          8542  			OR      E
043615 CA B0 30 04 8543  			JP      Z,CLOOP
043619             8544  ;
043619             8545  ; Check for IF clause:
043619             8546  ;
043619 23          8547  			INC     HL			; Skip the length
04361A 23          8548  			INC     HL			; Skip the line number
04361B 23          8549  			INC     HL              	; HL: Address of the tokenised BASIC line
04361C 0D          8550  			DEC     C			;  C: Line length
04361D 0D          8551  			DEC     C
04361E 0D          8552  			DEC     C
04361F 0D          8553  			DEC     C
043620 D5          8554  			PUSH    DE              	; Save the line number
043621 E5          8555  			PUSH    HL              	; Save the BASIC program address
043622 AF          8556  			XOR     A               	;
043623 B8          8557  			CP      B              	 	; Check for an IF clause (B!=0)
043624 FD E5       8558  			PUSH    IY			; LD IY, DE
043626 D1          8559  			POP     DE              	; DE: Address of the IF clause string in the input buffer
043627 C4 85 07 04 8560  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
04362B E1          8561  			POP     HL              	; Restore BASIC program address
04362C D1          8562  			POP     DE              	; Restore line number
04362D FD E5       8563  			PUSH    IY
04362F CC C2 38 04 8564  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043633 FD E1       8565  			POP     IY
043635             8566  ;
043635 08          8567  			EX      AF,AF'
043636 3D          8568  			DEC     A			; Decrement line list counter
043637 CD A1 3F 04 8569  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
04363B E1          8570  			POP     HL             	 	; Restore BASIC program address to beginning of line
04363C 11 00 00 00 8571  			LD	DE,0
043640 5E          8572  			LD      E,(HL)			; Fetch the length of line in DE
043641 19          8573  			ADD     HL,DE           	; Go to the next line
043642 D1          8574  			POP     DE              	; Restore IF clause length
043643 C1          8575  			POP     BC              	; Restore second line number
043644 18 AD       8576  			JR      LISTC			; Loop back to do next line
043646             8577  ;
043646             8578  ; RENUMBER
043646             8579  ; RENUMBER start
043646             8580  ; RENUMBER start,increment
043646             8581  ; RENUMBER ,increment
043646             8582  ;
043646 CD A6 38 04 8583  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04364A CD 5B 3C 04 8584  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04364E D9          8585  			EXX
04364F 2A 14 4D 04 8586  			LD      HL,(PAGE_)		; HL: Top of program
043653 ED 5B 1A 4D 8587  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
043658             8588  ;
043658             8589  ; Build the table
043658             8590  ;
043658 7E          8591  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043659 B7          8592  			OR      A			; Is it zero, i.e. the end of program marker?
04365A 28 36       8593  			JR      Z,RENUM2		; Yes, so skip to the next part
04365C 23          8594  			INC     HL
04365D 4E          8595  			LD      C,(HL)          	; BC: The OLD line number
04365E 23          8596  			INC     HL
04365F 46          8597  			LD      B,(HL)
043660 78          8598  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043661 B1          8599  			OR      C
043662 CA B0 30 04 8600  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043666 EB          8601  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043667 71          8602  			LD      (HL),C			; Store the OLD line number in the heap
043668 23          8603  			INC     HL
043669 70          8604  			LD      (HL),B
04366A 23          8605  			INC     HL
04366B D9          8606  			EXX				; HL: line number, BC: increment (16-bit values)
04366C E5          8607  			PUSH    HL			; HL: Stack the NEW line number value
04366D 52 09       8608  			ADD.S   HL,BC           	; Add the increment
04366F DA 55 3C 04 8609  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043673 D9          8610  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
043674 C1          8611  			POP     BC			; BC: Pop the NEW line number value off the stack
043675 71          8612  			LD      (HL),C			; Store the NEW line number in the heap
043676 23          8613  			INC     HL
043677 70          8614  			LD      (HL),B
043678 23          8615  			INC     HL
043679 EB          8616  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
04367A 2B          8617  			DEC     HL			; Back up to the line length byte
04367B 2B          8618  			DEC     HL
04367C 01 00 00 00 8619  			LD	BC, 0
043680 4E          8620  			LD      C,(HL)			; BC: Line length
043681 09          8621  			ADD	HL,BC           	; Advance HL to next line
043682 EB          8622  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043683 E5          8623  			PUSH    HL
043684 24          8624  			INC     H			; Increment to next page
043685 ED 72       8625  			SBC     HL,SP			; Subtract from SP
043687 E1          8626  			POP     HL
043688 EB          8627  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043689 38 CD       8628  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
04368B CD A7 37 04 8629  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04368F CC          8630  			DB    	REN
043690 08          8631  			DB    	8
043691 00          8632  			DB    	0
043692             8633  ;
043692             8634  ; At this point a list of BASIC line numbers have been written to the heap
043692             8635  ; as word pairs:
043692             8636  ; - DW: The OLD line number
043692             8637  ; - DW: The NEW line number
043692             8638  ;
043692 EB          8639  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
043693 36 FF       8640  			LD      (HL),-1			; Mark the end with FFFFh
043695 23          8641  			INC     HL
043696 36 FF       8642  			LD      (HL),-1
043698 ED 5B 1A 4D 8643  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
04369D D9          8644  			EXX
04369E 2A 14 4D 04 8645  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436A2 4E          8646  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436A3 79          8647  			LD      A,C			; If it is zero, then no program, so...
0436A4 B7          8648  			OR      A
0436A5 CA AF 30 04 8649  			JP      Z,WARM			; Jump to warm start
0436A9 D9          8650  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436AA EB          8651  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436AB 23          8652  			INC     HL			; Skip to the NEW line number
0436AC 23          8653  			INC     HL
0436AD 5E          8654  			LD      E,(HL)			; DE: The NEW line number
0436AE 23          8655  			INC     HL
0436AF 56          8656  			LD      D,(HL)
0436B0 23          8657  			INC     HL
0436B1 D5          8658  			PUSH    DE			; Stack the NEW line number
0436B2 EB          8659  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436B3 22 23 4D 04 8660  			LD      (LINENO),HL		; Store the line number in LINENO
0436B7 D9          8661  			EXX				; HL: Pointer to the BASIC program area
0436B8 D1          8662  			POP     DE			; DE: The NEW line number
0436B9 23          8663  			INC     HL
0436BA 73          8664  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436BB 23          8665  			INC     HL
0436BC 72          8666  			LD      (HL),D
0436BD 23          8667  			INC     HL
0436BE 0D          8668  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436BF 0D          8669  			DEC     C
0436C0 0D          8670  			DEC     C
0436C1 79          8671  			LD	A,C
0436C2 01 00 00 00 8672  			LD	BC,0
0436C6 4F          8673  			LD	C,A			; BC: Line length
0436C7             8674  ;
0436C7 3E 8D       8675  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436C9 ED B1       8676  			CPIR                    	; Search for the token
0436CB 20 D5       8677  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0436CD             8678  ;
0436CD             8679  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0436CD             8680  ;
0436CD C5          8681  			PUSH    BC			; Stack everything
0436CE E5          8682  			PUSH    HL
0436CF E5          8683  			PUSH    HL			; HL: Pointer to encoded line number
0436D0 FD E1       8684  			POP     IY			; IY: Pointer to encoded line number
0436D2 D9          8685  			EXX
0436D3 CD E6 08 04 8686  			CALL    DECODE			; Decode the encoded line number (in HL')
0436D7 D9          8687  			EXX				; HL: Decoded line number
0436D8 44          8688  			LD      B,H			; BC: Decoded line number
0436D9 4D          8689  			LD      C,L
0436DA 2A 1A 4D 04 8690  			LD      HL,(LOMEM)		; HL: Pointer to heap
0436DE             8691  ;
0436DE             8692  ; This section of code cross-references the decoded (OLD) line number with the list
0436DE             8693  ; created previously in the global heap
0436DE             8694  ;
0436DE 5E          8695  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436DF 23          8696  			INC     HL
0436E0 56          8697  			LD      D,(HL)
0436E1 23          8698  			INC     HL
0436E2 EB          8699  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436E3 B7          8700  			OR      A               	; Clear the carry and...
0436E4 52 ED 42    8701  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436E7 EB          8702  			EX      DE,HL			; HL: Pointer in the global heap
0436E8 5E          8703  			LD      E,(HL)          	; DE: The NEW line number
0436E9 23          8704  			INC     HL
0436EA 56          8705  			LD      D,(HL)
0436EB 23          8706  			INC     HL
0436EC 38 F0       8707  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436EE EB          8708  			EX      DE,HL			; DE: Pointer in the global heap
0436EF 28 1D       8709  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436F1             8710  ;
0436F1 CD C0 3D 04 8711  			CALL    TELL			; Display this error if the line number is not found
0436F5 46 61 69 6C 8712  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0436FF 00          8713  			DB    	0
043700 2A 23 4D 04 8714  			LD      HL,(LINENO)
043704 CD 27 3A 04 8715  			CALL    PBCDL
043708 CD 77 39 04 8716  			CALL    CRLF
04370C 18 07       8717  			JR      RENUM6			; And carry on renumbering
04370E             8718  ;
04370E             8719  ; This snippet re-encodes the line number in the BASIC program
04370E             8720  ;
04370E D1          8721  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
04370F D5          8722  			PUSH    DE
043710 1B          8723  			DEC     DE			; Back up a byte to the LINO token
043711 CD 8C 3D 04 8724  			CALL    ENCODE          	; Re-write the new line number out
043715 E1          8725  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
043716 C1          8726  			POP     BC			; BC: The remaining line length
043717 18 AE       8727  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
043719             8728  ;
043719             8729  ; AUTO
043719             8730  ; AUTO start,increment
043719             8731  ; AUTO start
043719             8732  ; AUTO ,increment
043719             8733  ;
043719 CD 5B 3C 04 8734  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
04371D 22 29 4D 04 8735  			LD      (AUTONO),HL		; Store the start in AUTONO
043721 79          8736  			LD      A,C			; Increment is 8 bit (0-255)
043722 32 41 4D 04 8737  			LD      (INCREM),A		; Store that in INCREM
043726 18 2E       8738  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043728             8739  ;
043728             8740  ; BAD
043728             8741  ; NEW
043728             8742  ;
043728 CD C0 3D 04 8743  BAD:			CALL    TELL            	; Output "Bad program" error
04372C 03          8744  			DB    3				; Token for "BAD"
04372D 70 72 6F 67 8745  			DB    "program"
       72 61 6D    
043734 0D          8746  			DB    CR
043735 0A          8747  			DB    LF
043736 00          8748  			DB    0				; Falls through to NEW
043737             8749  ;
043737 CD 9C 38 04 8750  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
04373B 18 19       8751  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04373D             8752  ;
04373D             8753  ; OLD
04373D             8754  ;
04373D 2A 14 4D 04 8755  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043741 E5          8756  			PUSH    HL			; Stack it
043742 23          8757  			INC     HL			; Skip the potential length byte of first line of code
043743 23          8758  			INC     HL			; And the line number word
043744 23          8759  			INC     HL
043745 01 FC 00 00 8760  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043749 3E 0D       8761  			LD      A,CR
04374B ED B1       8762  			CPIR
04374D 20 D9       8763  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04374F 7D          8764  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043750 E1          8765  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043751 77          8766  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043752 CD 6F 38 04 8767  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043756 C3 B0 30 04 8768  CLOOP0:			JP      CLOOP			; Jump back to the command loop
04375A             8769  ;
04375A             8770  ; LOAD filename
04375A             8771  ;
04375A CD 15 03 04 8772  LOAD:			CALL    EXPRS           	; Get the filename
04375E 3E 0D       8773  			LD      A,CR			; DE points to the last byte of filename in ACCS
043760 12          8774  			LD      (DE),A			; Terminate filename with a CR
043761 CD 4F 38 04 8775  			CALL    LOAD0			; Load the file in, then CLEAN
043765 CD A6 38 04 8776  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043769 18 21       8777  			JR      WARM0			; Jump back to the command loop
04376B             8778  ;
04376B             8779  ; SAVE filename
04376B             8780  ;
04376B CD 7B 38 04 8781  SAVE:			CALL    SETTOP          	; Set TOP sysvar
04376F CD 15 03 04 8782  			CALL    EXPRS           	; Get the filename
043773 3E 0D       8783  			LD      A,CR			; Terminate the filename with a CR
043775 12          8784  			LD      (DE),A
043776 ED 5B 14 4D 8785  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
04377B 2A 17 4D 04 8786  			LD      HL,(TOP)		; HL: Top of program memory
04377F B7          8787  			OR      A			; Calculate program size (TOP-PAGE)
043780 ED 52       8788  			SBC     HL,DE
043782 44          8789  			LD      B,H             	; BC: Length of program in bytes
043783 4D          8790  			LD      C,L
043784 21 00 4A 04 8791  			LD      HL,ACCS			; HL: Address of the filename
043788 CD 6E 42 04 8792  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
04378C C3 AF 30 04 8793  WARM0:			JP      WARM			; Jump back to the command loop
043790             8794  
043790             8795  ;
043790             8796  ; ERROR
043790             8797  ; Called whenever BASIC needs to halt with an error
043790             8798  ; Error messages are indexed from 0
043790             8799  ; Inputs:
043790             8800  ;  A: Error number
043790             8801  ;
043790 ED 7B 20 4D 8802  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
043795 21 79 34 04 8803  			LD      HL,ERRWDS		; Index into the error string table
043799 B7          8804  			OR      A			; We don't need to search for the first error
04379A 28 0A       8805  			JR      Z,ERROR1		; So skip the search routine
04379C             8806  ;
04379C             8807  ; Search the error table for error #A
04379C             8808  ; HL will end up being the pointer into the correct error
04379C             8809  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
04379C             8810  ;
04379C 47          8811  			LD      B,A             	; Store error number in B
04379D 08          8812  			EX      AF,AF'			; Store error number in AF'
04379E AF          8813  			XOR     A
04379F BE          8814  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437A0 23          8815  			INC     HL			; Increment the string pointer
0437A1 20 FC       8816  			JR      NZ,ERROR0		; Loop until with hit a 0
0437A3 10 FA       8817  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0437A5 08          8818  			EX      AF,AF'			; Restore the error number from AF'
0437A6             8819  ;
0437A6             8820  ; At this point HL points to the tokenised error string
0437A6             8821  ;
0437A6 E5          8822  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0437A7             8823  
0437A7             8824  ;
0437A7             8825  ; EXTERR
0437A7             8826  ; Inputs:
0437A7             8827  ;  A: Error number
0437A7             8828  ;
0437A7             8829  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0437A7             8830  ; The error text immediately follows the CALL to EXTERR, for example:
0437A7             8831  ; > CALL  EXTERR
0437A7             8832  ; > DB    "Silly", 0
0437A7             8833  ; So we can get the address of the string by popping the return address off the stack
0437A7             8834  ;
0437A7 E1          8835  EXTERR:			POP     HL			; Pop the error string pointer
0437A8 22 2F 4D 04 8836  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437AC ED 7B 20 4D 8837  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437B1 32 3F 4D 04 8838  			LD      (ERR),A			; Store error number in ERR sysvar
0437B5 CD DE 39 04 8839  			CALL    SETLIN			; Get line number
0437B9 22 33 4D 04 8840  			LD      (ERL),HL		; Store in ERL sysvar
0437BD B7          8841  			OR      A			; Is error number 0?
0437BE 28 0D       8842  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437C0             8843  ;
0437C0 2A 2C 4D 04 8844  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0437C4 7C          8845  			LD      A,H
0437C5 B5          8846  			OR      L
0437C6 E5          8847  			PUSH    HL			; HL: Error line
0437C7 FD E1       8848  			POP     IY			; IY: HL
0437C9 C2 96 0B 04 8849  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437CD             8850  ;
0437CD 21 00 00 00 8851  ERROR2:			LD      HL,0
0437D1 22 29 4D 04 8852  			LD      (AUTONO),HL		; Cancel AUTO
0437D5 22 26 4D 04 8853  			LD      (TRACEN),HL     	; Cancel TRACE
0437D9 CD F7 43 04 8854  			CALL    RESET           	; Reset OPSYS
0437DD CD 77 39 04 8855  			CALL    CRLF			; Output newline
0437E1 CD B2 3D 04 8856  			CALL    REPORT          	; Output the error message
0437E5 CD 12 3A 04 8857  			CALL    SAYLN			; Output " at line nnnn" message.
0437E9 1E 00       8858  			LD      E,0			; Close all files
0437EB DC 6C 43 04 8859  			CALL    C,OSSHUT
0437EF CD 77 39 04 8860  			CALL    CRLF			; Output newline
0437F3 C3 B0 30 04 8861  			JP      CLOOP			; Back to CLOOP
0437F7             8862  ;
0437F7             8863  ; SUBROUTINES:
0437F7             8864  ;
0437F7             8865  ; LEX - SEARCH FOR KEYWORDS
0437F7             8866  ;   Inputs: HL = start of keyword table
0437F7             8867  ;           IY = start of match text
0437F7             8868  ;  Outputs: If found, Z-flag set, A=token.
0437F7             8869  ;           If not found, Z-flag reset, A=(IY).
0437F7             8870  ;           IY updated (if NZ, IY unchanged).
0437F7             8871  ; Destroys: A,B,H,L,IY,F
0437F7             8872  ;
0437F7 21 98 31 04 8873  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0437FB             8874  ;
0437FB FD 7E 00    8875  LEX0:			LD      A,(IY)			; Fetch the character to match
0437FE 46          8876  			LD      B,(HL)			; B: The token from the keywords table
0437FF 23          8877  			INC     HL			; Increment the pointer in the keywords table
043800 BE          8878  			CP      (HL)			; Compare the first characters
043801 28 08       8879  			JR      Z,LEX2			; If there is a match, then skip to LEX2
043803 D8          8880  			RET     C               	; No match, so fail
043804             8881  ;
043804             8882  ; This snippet of code skips to the next token in the KEYWDS table
043804             8883  ;
043804 23          8884  LEX1:			INC     HL			; Increment the pointer
043805 CB 7E       8885  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
043807 28 FB       8886  			JR      Z,LEX1			; No, so loop
043809 18 F0       8887  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
04380B             8888  ;
04380B FD E5       8889  LEX2:			PUSH    IY              	; Save the input pointer
04380D 23          8890  LEX3:			INC     HL			; Increment the keyword pointer
04380E CB 7E       8891  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043810 20 1C       8892  			JR      NZ,LEX6         	; Jump to here as we've found a token
043812 FD 23       8893  			INC     IY			; Increment the text pointer
043814 FD 7E 00    8894  			LD      A,(IY)			; Fetch the character
043817 FE 2E       8895  			CP      '.'			; Is it an abbreviated keyword?
043819 28 13       8896  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
04381B BE          8897  			CP      (HL)			; Compare with the keywords list
04381C 28 EF       8898  			JR      Z,LEX3			; It's a match, so continue checking this keyword
04381E CD AB 3C 04 8899  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043822 38 04       8900  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
043824             8901  ;
043824 FD E1       8902  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
043826 18 DC       8903  			JR      LEX1			; And loop back to start again
043828             8904  ;
043828             8905  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
043828             8906  ; immediately delimited
043828             8907  ;
043828 7E          8908  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
043829 B7          8909  			OR      A			; If it is not zero, then...
04382A 20 F8       8910  			JR      NZ,LEX4			; Keep searching
04382C FD 2B       8911  			DEC     IY			; If it is zero, then skip the input pointer back one byte
04382E             8912  ;
04382E             8913  ; We've found a token at this point
04382E             8914  ;
04382E F1          8915  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
04382F AF          8916  			XOR     A			; Set the Z flag
043830 78          8917  			LD      A,B			; A: The token
043831 C9          8918  			RET
043832             8919  ;
043832             8920  ; DEL - DELETE A PROGRAM LINE.
043832             8921  ;   Inputs: HL addresses program line.
043832             8922  ; Destroys: B,C,F
043832             8923  ;
043832             8924  ; This simply erases the line by moving all of the code after the line to be deleted back over
043832             8925  ; it using an LDIR
043832             8926  ;
043832 D5          8927  DEL:			PUSH    DE
043833 E5          8928  			PUSH    HL
043834 E5          8929  			PUSH    HL			; HL: Address of the program line
043835 06 00       8930  			LD      B,0			; BC: Length of the line
043837 4E          8931  			LD      C,(HL)
043838 09          8932  			ADD     HL,BC			; HL: Advanced to the start of the next line
043839 E5          8933  			PUSH    HL
04383A EB          8934  			EX      DE,HL			; DE: Pointer to the next line
04383B 2A 17 4D 04 8935  			LD      HL,(TOP)		; HL: Pointer to the end of the program
04383F ED 52       8936  			SBC     HL,DE
043841 44          8937  			LD      B,H			; BC: Size of block to move
043842 4D          8938  			LD      C,L
043843 E1          8939  			POP     HL			; HL: Pointer to next line
043844 D1          8940  			POP     DE			; DE: Pointer to this line
043845 ED B0       8941  			LDIR                    	; Delete the line
043847 ED 53 17 4D 8942  			LD      (TOP),DE		; Adjust TOP
       04          
04384C E1          8943  			POP     HL
04384D D1          8944  			POP     DE
04384E C9          8945  			RET
04384F             8946  ;
04384F             8947  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
04384F             8948  ;   Inputs: Filename in ACCS (term CR)
04384F             8949  ; Destroys: A,B,C,D,E,H,L,F
04384F             8950  ;
04384F             8951  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
04384F             8952  ; AND WRITE FF FF, THEN LOAD (TOP).
04384F             8953  ; Destroys: A,B,C,H,L,F
04384F             8954  ;
04384F ED 5B 14 4D 8955  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
043854 21 00 FF FF 8956  			LD      HL,-256
043858 39          8957  			ADD     HL,SP
043859 ED 52       8958  			SBC     HL,DE           	; Find available space
04385B 44          8959  			LD      B,H
04385C 4D          8960  			LD      C,L
04385D 21 00 4A 04 8961  			LD      HL,ACCS
043861 CD D5 41 04 8962  			CALL    OSLOAD          	; Call the OSLOAD function in patch
043865 D4 9C 38 04 8963  			CALL    NC,NEWIT		; If NC then NEW
043869 3E 00       8964  			LD      A,0
04386B D2 90 37 04 8965  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04386F             8966  ;
04386F CD 7B 38 04 8967  CLEAN:			CALL    SETTOP			; Set TOP sysvar
043873 2B          8968  			DEC     HL			; Write out the end of program markers
043874 36 FF       8969  			LD      (HL),-1
043876 2B          8970  			DEC     HL
043877 36 FF       8971  			LD      (HL),-1
043879 18 2B       8972  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
04387B             8973  ;
04387B             8974  ; Set the TOP sysvar; the first free location after the end of the current program
04387B             8975  ; Returns:
04387B             8976  ; - HL: TOP
04387B             8977  ;
04387B 2A 14 4D 04 8978  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04387F 01 00 00 00 8979  			LD	BC, 0			; BC: 0
043883 3E 0D       8980  			LD      A,CR			; End of line marker
043885 4E          8981  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
043886 0C          8982  			INC     C			; Check for zero
043887 0D          8983  			DEC     C
043888 28 0A       8984  			JR      Z,SETOP2		; If it is zero, we've reached the end
04388A 09          8985  			ADD     HL,BC			; Skip to next line
04388B 2B          8986  			DEC     HL			; Check end of previous line
04388C BE          8987  			CP      (HL)
04388D 23          8988  			INC     HL
04388E 28 F5       8989  			JR      Z,SETOP1		; If CR then loop
043890 C3 28 37 04 8990  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043894             8991  ;
043894 23          8992  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
043895 23          8993  			INC     HL			; NB: Called from NEWIT
043896 23          8994  			INC     HL
043897 22 17 4D 04 8995  			LD      (TOP),HL		; Store in TOP sysvar
04389B C9          8996  			RET
04389C             8997  ;
04389C             8998  ; NEWIT - NEW PROGRAM THEN CLEAR
04389C             8999  ;   Destroys: H,L
04389C             9000  ;
04389C             9001  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
04389C             9002  ; FUNCTION AND PROCEDURE POINTERS.
04389C             9003  ;   Destroys: Nothing
04389C             9004  ;
04389C 2A 14 4D 04 9005  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438A0 36 00       9006  			LD      (HL),0			; Stick a 0 in there
0438A2 CD 94 38 04 9007  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438A6             9008  ;
0438A6 E5          9009  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438A7 2A 17 4D 04 9010  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438AB 22 1A 4D 04 9011  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0438AF 22 1D 4D 04 9012  			LD      (FREE),HL		; And the FREE sysvar with that value
0438B3 21 6C 4C 04 9013  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438B7 C5          9014  			PUSH    BC
0438B8             9015  			; LD      B,3*(54+2)		; Loop counter
0438B8 06 A8       9016  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438BA 36 00       9017  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438BC 23          9018  			INC     HL
0438BD 10 FB       9019  			DJNZ    CLEAR1
0438BF C1          9020  			POP     BC
0438C0 E1          9021  			POP     HL			; Restore the BASIC program pointer
0438C1 C9          9022  			RET
0438C2             9023  ;
0438C2             9024  ;LISTIT - LIST A PROGRAM LINE.
0438C2             9025  ;    Inputs: HL addresses line
0438C2             9026  ;            DE = line number (binary)
0438C2             9027  ;            IX = Pointer to LISTON
0438C2             9028  ;             B = FOR/NEXT indent level
0438C2             9029  ;             C = REPEAT/UNTIL indent level
0438C2             9030  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0438C2             9031  ;
0438C2 E5          9032  LISTIT:			PUSH    HL			; Stack the address of the line
0438C3 EB          9033  			EX      DE,HL			; HL: Line number
0438C4 C5          9034  			PUSH    BC
0438C5 CD 2B 3A 04 9035  			CALL    PBCD			; Print the line number
0438C9 C1          9036  			POP     BC
0438CA E1          9037  			POP     HL			; HL: Address of the first token/character
0438CB 7E          9038  			LD      A,(HL)			; Fetch the token
0438CC FE ED       9039  			CP      NEXT			; Is it NEXT...
0438CE CC 58 39 04 9040  			CALL    Z,INDENT		; Yes, so indent in
0438D2 FE FD       9041  			CP      UNTIL			; Or is it UNTIL...
0438D4 CC 58 39 04 9042  			CALL    Z,INDENT		; Yes, so indent in
0438D8 D9          9043  			EXX
0438D9 3E 20       9044  			LD      A,' '
0438DB DD CB 00 46 9045  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0438DF C4 7F 39 04 9046  			CALL    NZ,OUTCHR		; Then print a space after the line number
0438E3 78          9047  			LD      A,B			; Fetch the FOR/NEXT indent level
0438E4 87          9048  			ADD     A,A			; Multiply by 2
0438E5 DD CB 00 4E 9049  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0438E9 C4 19 18 04 9050  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438ED 79          9051  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438EE 87          9052  			ADD     A,A			; Multiply by 2
0438EF DD CB 00 56 9053  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0438F3 C4 19 18 04 9054  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438F7 D9          9055  			EXX
0438F8 7E          9056  			LD      A,(HL)			; Fetch the token
0438F9 FE E3       9057  			CP      FOR			; Is it FOR?
0438FB CC 58 39 04 9058  			CALL    Z,INDENT		; Yes, so indent
0438FF FE F5       9059  			CP      REPEAT			; Is it REPEAT?
043901 CC 58 39 04 9060  			CALL    Z,INDENT		; Yes, so indent
043905 1E 00       9061  			LD      E,0			; E: The quote counter - reset to 0
043907 7E          9062  LIST8:			LD      A,(HL)			; Fetch a character / token byte
043908 23          9063  			INC     HL
043909 FE 0D       9064  			CP      CR			; Is it end of line?
04390B 28 0B       9065  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
04390D FE 22       9066  			CP      34			; Is it a quote character?
04390F 20 01       9067  			JR      NZ,LIST7		; No, so skip to next bit
043911 1C          9068  			INC     E			; Otherwise increment quote counter
043912 CD 47 39 04 9069  LIST7:			CALL    LOUT			; Output the character / token
043916 18 EF       9070  			JR      LIST8			; And repeat
043918             9071  ;
043918             9072  ; DB: Modification for *EDIT
043918             9073  ; Terminate the line with either a CRLF or a NUL character
043918             9074  ;
043918 DD CB 00 5E 9075  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
04391C 28 59       9076  			JR	Z, CRLF			; Yes, so print a CRLF
04391E AF          9077  			XOR	A			; Otherwise print a NUL (0)
04391F C3 30 3F 04 9078  			JP	OSWRCH
043923             9079  ;
043923             9080  ; Decode the 3 byte GOTO type line number
043923             9081  ;
043923 E5          9082  PRLINO:			PUSH    HL			; Swap HL and IY
043924 FD E1       9083  			POP     IY			; IY: Pointer to the line number
043926 C5          9084  			PUSH    BC
043927 CD E6 08 04 9085  			CALL    DECODE			; Decode
04392B C1          9086  			POP     BC
04392C D9          9087  			EXX
04392D C5          9088  			PUSH    BC
04392E CD 27 3A 04 9089  			CALL    PBCDL			; Output the line number
043932 C1          9090  			POP     BC
043933 D9          9091  			EXX
043934 FD E5       9092  			PUSH    IY			; Swap HL and IY
043936 E1          9093  			POP     HL			; HL: Pointer to the next character in the line
043937 C9          9094  			RET
043938             9095  ;
043938             9096  ; DB: Modification for internationalisation
043938             9097  ;
043938 CD 9C 39 04 9098  PRREM:			CALL	OUT_			; Output the REM token
04393C 7E          9099  @@:			LD	A, (HL)			; Fetch the character
04393D FE 0D       9100  			CP	CR			; If it is end of line, then
04393F C8          9101  			RET	Z			; we have finished
043940 CD 7F 39 04 9102  			CALL	OUTCHR			; Ouput the character
043944 23          9103  			INC	HL
043945 18 F5       9104  			JR	@B			; And loop
043947             9105  ;
043947             9106  ; DB: End of modification
043947             9107  ;
043947 CB 43       9108  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043949 20 34       9109  			JR      NZ,OUTCHR		; don't tokenise, just output the character
04394B FE F4       9110  			CP	REM			; DB: Is it REM
04394D 28 E9       9111  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
04394F FE 8D       9112  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043951 28 D0       9113  			JR      Z,PRLINO		; Yes, so decode and print the line number
043953 CD 9C 39 04 9114  			CALL    OUT_			; Output a character / keyword
043957 7E          9115  			LD      A,(HL)			; Fetch the next character
043958             9116  ;
043958             9117  ; This block of code handles the indentation
043958             9118  ; B: Counter for FOR/NEXT indent
043958             9119  ; C: Counter for REPEAT/UNTIL indent
043958             9120  ;
043958 D9          9121  INDENT:			EXX
043959 FE E3       9122  			CP      FOR			; If the token is FOR
04395B 28 09       9123  			JR      Z,IND1			; Then INC B
04395D FE ED       9124  			CP      NEXT			; If it is NEXT
04395F 20 06       9125  			JR      NZ,IND2_		; Then...
043961 05          9126  			DEC     B			; DEC B
043962 F2 67 39 04 9127  			JP      P,IND2_			; If we have gone below 0 then
043966 04          9128  IND1:			INC     B			; Increment back to 0
043967             9129  ;
043967 FE F5       9130  IND2_:			CP      REPEAT			; If the token is REPEAT
043969 28 09       9131  			JR      Z,IND3			; Then INC C
04396B FE FD       9132  			CP      UNTIL			; If it is UNTIL
04396D 20 06       9133  			JR      NZ,IND4			; Then...
04396F 0D          9134  			DEC     C			; DEC C
043970 F2 75 39 04 9135  			JP      P,IND4			; If we have gone below 0 then
043974 0C          9136  IND3:			INC     C			; Incremet back to 0
043975 D9          9137  IND4:			EXX
043976 C9          9138  			RET
043977             9139  ;
043977             9140  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
043977             9141  ;  Destroys: A,F
043977             9142  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
043977             9143  ;    Inputs: A = character
043977             9144  ;  Destroys: A,F
043977             9145  ;
043977 3E 0D       9146  CRLF:			LD      A,CR			; Output CR
043979 CD 7F 39 04 9147  			CALL    OUTCHR
04397D 3E 0A       9148  			LD      A,LF			; Output LF
04397F             9149  ;
04397F CD 30 3F 04 9150  OUTCHR:			CALL    OSWRCH			; Output the character in A
043983 D6 0D       9151  			SUB     CR			; Check for CR
043985 28 06       9152  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
043987 D8          9153  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043988 3A 3D 4D 04 9154  			LD      A,(COUNT)		; Increment the count
04398C 3C          9155  			INC     A
04398D             9156  ;
04398D 32 3D 4D 04 9157  CARRET:			LD      (COUNT),A		; Store the new count value
043991 C8          9158  			RET     Z			; Return if the count has wrapped to 0
043992 E5          9159  			PUSH    HL			; Now check if count = print width
043993 2A 3E 4D 04 9160  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
043997 BD          9161  			CP      L			; L is the width. Compare it with count.
043998 E1          9162  			POP     HL
043999 C0          9163  			RET     NZ			; If we've not hit print width, then just return
04399A 18 DB       9164  			JR      CRLF			; Otherwise output CRLF
04399C             9165  ;
04399C             9166  ; OUT - SEND CHARACTER OR KEYWORD
04399C             9167  ;   Inputs: A = character (>=10, <128)
04399C             9168  ;           A = Token (<10, >=128)
04399C             9169  ;  Destroys: A,F
04399C             9170  ;
04399C FE 8A       9171  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04399E EA 7F 39 04 9172  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439A2             9173  ;
0439A2             9174  ; This bit looks up the character in the KEYWDS token table and expands it
0439A2             9175  ; Note the CP 138; this sets the overflow flag as follows:
0439A2             9176  ;
0439A2             9177  ; NB:
0439A2             9178  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0439A2             9179  ;  2. CP is effectively a SUB; sets the flags without affecting A
0439A2             9180  ;  3. The operation n - -118 ~ n + 118
0439A2             9181  ;
0439A2             9182  ; So:
0439A2             9183  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0439A2             9184  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0439A2             9185  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0439A2             9186  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0439A2             9187  ;
0439A2 C5          9188  			PUSH    BC			; Preserve BC and HL
0439A3 E5          9189  			PUSH    HL
0439A4 21 98 31 04 9190  			LD      HL,KEYWDS		; The list of tokens and keywords
0439A8 01 DF 02 00 9191  			LD      BC,KEYWDL		; The length of the keyword list
0439AC ED B1       9192  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439AE             9193  ;							; At this point HL points to the next byte, the first character of the token
0439AE 7E          9194  TOKEN1:			LD      A,(HL)			; Fetch the character
0439AF 23          9195  			INC     HL			; Increment to the next byte in the token table
0439B0 FE 8A       9196  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439B2 F5          9197  			PUSH    AF			; Then...
0439B3 EC 7F 39 04 9198  			CALL    PE,OUTCHR		; Output the character...
0439B7 F1          9199  			POP     AF			;
0439B8 EA AE 39 04 9200  			JP      PE,TOKEN1		; And loop to the next character
0439BC E1          9201  			POP     HL			; Done, so tidy up the stack and exit
0439BD C1          9202  			POP     BC
0439BE C9          9203  			RET
0439BF             9204  ;
0439BF             9205  ; FINDL - FIND PROGRAM LINE
0439BF             9206  ;   Inputs: HL = line number (binary)
0439BF             9207  ;  Outputs: HL addresses line (if found)
0439BF             9208  ;           DE = line number
0439BF             9209  ;           Z-flag set if found.
0439BF             9210  ; Destroys: A,B,C,D,E,H,L,F
0439BF             9211  ;
0439BF EB          9212  FINDL:			EX      DE,HL			; DE: Line number (binary)
0439C0 2A 14 4D 04 9213  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439C4 AF          9214  			XOR     A               	;  A: 0
0439C5 BE          9215  			CP      (HL)			; Check for end of program marker
0439C6 3C          9216  			INC     A			;  A: 1
0439C7 D0          9217  			RET     NC			; Return with 1 if 0
0439C8 AF          9218  			XOR     A               	; Clear the carry flag
0439C9             9219  ;			LD      B,A			;  B: 0
0439C9 01 00 00 00 9220  			LD	BC, 0			; BC: 0
0439CD             9221  ;
0439CD 4E          9222  FINDL1:			LD      C,(HL)			;  C: The line length
0439CE E5          9223  			PUSH    HL			; Stack the current program counter
0439CF 23          9224  			INC     HL			; Skip to the line number bytes
0439D0 7E          9225  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439D1 23          9226  			INC     HL
0439D2 66          9227  			LD      H,(HL)
0439D3 6F          9228  			LD      L,A
0439D4 52 ED 52    9229  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439D7 E1          9230  			POP     HL			; Get the current program counter
0439D8 D0          9231  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439D9 09          9232  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439DA C3 CD 39 04 9233  			JP      FINDL1			; And loop
0439DE             9234  ;
0439DE             9235  ; SETLIN - Search program for line containing address
0439DE             9236  ;          Update (LINENO)
0439DE             9237  ;   Inputs: Address in (ERRLIN)
0439DE             9238  ;  Outputs: Line number in HL and (LINENO)
0439DE             9239  ; Destroys: B,C,D,E,H,L,F
0439DE             9240  ;
0439DE 01 00 00 00 9241  SETLIN:			LD	BC, 0			; Zero BC for later
0439E2             9242  ;			LD      B, 0			; Zero B for later
0439E2 ED 5B 35 4D 9243  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
0439E7 2A 14 4D 04 9244  			LD      HL, (PAGE_)		; HL: Start of user program area
0439EB B7          9245  			OR      A			; Do a 24 bit compare without destroying HL
0439EC ED 52       9246  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439EE 19          9247  			ADD     HL, DE			;  C: DE > HL
0439EF 30 1B       9248  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439F1             9249  ;
0439F1 4E          9250  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439F2 0C          9251  			INC     C			; This is a way to check for zero without using the accumulator
0439F3 0D          9252  			DEC     C			; If it is zero, then...
0439F4 28 16       9253  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439F6 09          9254  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439F7 ED 52       9255  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0439F9 19          9256  			ADD     HL, DE
0439FA 38 F5       9257  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0439FC ED 42       9258  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0439FE 23          9259  			INC     HL			; Skip the length counter
0439FF 11 00 00 00 9260  			LD	DE, 0			; Zero DE
043A03 5E          9261  			LD      E, (HL)          	; Fetch the line number
043A04 23          9262  			INC     HL
043A05 56          9263  			LD      D, (HL)
043A06 EB          9264  			EX      DE, HL			; HL: The line number
043A07 22 23 4D 04 9265  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A0B C9          9266  			RET
043A0C             9267  ;
043A0C 21 00 00 00 9268  SET3:			LD      HL, 0			; We've not found the line at this point so
043A10 18 F5       9269  			JR      SET2			; Set LINENO to 0
043A12             9270  ;
043A12             9271  ;SAYLN - PRINT " at line nnnn" MESSAGE.
043A12             9272  ;  Outputs: Carry=0 if line number is zero.
043A12             9273  ;           Carry=1 if line number is non-zero.
043A12             9274  ; Destroys: A,B,C,D,E,H,L,F
043A12             9275  ;
043A12 2A 23 4D 04 9276  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A16 7C          9277  			LD      A,H			; If it is zero then
043A17 B5          9278  			OR      L
043A18 C8          9279  			RET     Z			; Don't need to do anything; return with F:C set to 0
043A19 CD C0 3D 04 9280  			CALL    TELL			; Output the error message
043A1D 20 61 74 20 9281  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
043A27 0E 00       9282  PBCDL:			LD      C,0			; C: Leading character (NUL)
043A29 18 02       9283  			JR      PBCD0			; Output the line number; return with F:C set to 1
043A2B             9284  ;
043A2B             9285  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
043A2B             9286  ;   Inputs: HL = number (binary).
043A2B             9287  ;  Outputs: Carry = 1
043A2B             9288  ; Destroys: A,B,C,D,E,H,L,F
043A2B             9289  ;
043A2B 0E 20       9290  PBCD:			LD      C,' '			; C: Leading character (" ")
043A2D 06 05       9291  PBCD0:			LD      B,5			; Number of digits in result
043A2F 11 10 27 00 9292  			LD      DE,10000		; Start off with the 10,000 column
043A33 AF          9293  PBCD1:			XOR     A			; Counter
043A34 ED 52       9294  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A36 3C          9295  			INC     A
043A37 30 FB       9296  			JR      NC,PBCD2
043A39 19          9297  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A3A 3D          9298  			DEC     A			; A: Number of 10,000s
043A3B 28 04       9299  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A3D CB E1       9300  			SET     4,C			; C: Set to '0' ASCII (30h)
043A3F CB E9       9301  			SET     5,C
043A41 B1          9302  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A42 C4 7F 39 04 9303  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A46 78          9304  			LD      A,B			; If on first transition, skip this
043A47 FE 05       9305  			CP      5			; TODO: Need to find out why
043A49 28 06       9306  			JR      Z,PBCD4
043A4B 29          9307  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A4C 54          9308  			LD      D,H			;         : rather than shifting DE right
043A4D 5D          9309  			LD      E,L			;         : This makes a lot of sense
043A4E 29          9310  			ADD     HL,HL			; HL x  4
043A4F 29          9311  			ADD     HL,HL			; HL x  8
043A50 19          9312  			ADD     HL,DE			; HL x 10
043A51 11 E8 03 00 9313  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A55 10 DC       9314  			DJNZ    PBCD1			; Loop until done
043A57 37          9315  			SCF				; SCF set for SAYLN in this module
043A58 C9          9316  			RET
043A59             9317  ;
043A59             9318  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A59             9319  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A59             9320  ;  Outputs: As GETVAR.
043A59             9321  ; Destroys: everything
043A59             9322  ;
043A59 CD DE 3B 04 9323  PUTVAR:			CALL    CREATE			; Create the variable
043A5D FD 7E 00    9324  			LD      A,(IY)			; Fetch the next character
043A60 FE 28       9325  			CP      '('			; Check for bad use of array
043A62 20 70       9326  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A64 3E 0E       9327  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A66 C3 90 37 04 9328  ERROR3:			JP      ERROR_
043A6A             9329  ;
043A6A             9330  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A6A             9331  ;   Inputs: IY addresses first character.
043A6A             9332  ;  Outputs: Carry set and NZ if illegal character.
043A6A             9333  ;           Z-flag set if variable found, then:
043A6A             9334  ;            A = variable type (0,4,5,128 or 129)
043A6A             9335  ;            HL = IX = variable pointer.
043A6A             9336  ;            IY updated
043A6A             9337  ;           If Z-flag & carry reset, then:
043A6A             9338  ;            HL, IY set for subsequent PUTVAR call.
043A6A             9339  ; Destroys: everything
043A6A             9340  ;
043A6A FD 7E 00    9341  GETVAR:			LD      A,(IY)			; Get the first character
043A6D FE 24       9342  			CP      '$'			; Is it a string?
043A6F 28 69       9343  			JR      Z,GETV4			; Yes, so branch here
043A71 FE 21       9344  			CP      '!'			; Is it indirection (32-bit)?
043A73 28 69       9345  			JR      Z,GETV5			; Yes, so branch here
043A75 FE 3F       9346  			CP      '?'			; Is it indirection (8-bit)?
043A77 28 69       9347  			JR      Z,GETV6			; Yes, so branch here
043A79             9348  ;
043A79 CD 48 3B 04 9349  			CALL    LOCATE			; Locate the variable
043A7D C0          9350  			RET     NZ			; And exit here if not found
043A7E             9351  ;
043A7E             9352  ; At this point:
043A7E             9353  ;  HL: Address of variable in memory
043A7E             9354  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043A7E             9355  ;
043A7E FD 7E 00    9356  			LD      A,(IY)			; Further checks
043A81 FE 28       9357  			CP      '('             	; Is it an array?
043A83 20 47       9358  			JR      NZ,GETVX        	; No, so exit
043A85             9359  ;
043A85             9360  ; We are processing an array at this point
043A85             9361  ;
043A85 D5          9362  			PUSH    DE              	; Save the variable type (in D)
043A86 7E          9363  			LD      A,(HL)          	; Fetch the number of dimensions
043A87 B7          9364  			OR      A
043A88 28 DA       9365  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A8A 23          9366  			INC     HL			;
043A8B 11 00 00 00 9367  			LD      DE,0            	; Accumulator
043A8F F5          9368  			PUSH    AF
043A90 FD 23       9369  			INC     IY              	; Skip "("
043A92 18 05       9370  			JR      GETV3
043A94             9371  ;
043A94 F5          9372  GETV2:			PUSH    AF
043A95 CD 22 0A 04 9373  			CALL    COMMA
043A99 E5          9374  GETV3:			PUSH    HL
043A9A D5          9375  			PUSH    DE
043A9B CD 0A 03 04 9376  			CALL    EXPRI			; Get the subscript
043A9F D9          9377  			EXX
043AA0 D1          9378  			POP     DE
043AA1 E3          9379  			EX      (SP),HL
043AA2 4E          9380  			LD      C,(HL)
043AA3 23          9381  			INC     HL
043AA4 46          9382  			LD      B,(HL)
043AA5 23          9383  			INC     HL
043AA6 E3          9384  			EX      (SP),HL
043AA7 EB          9385  			EX      DE,HL
043AA8 D5          9386  			PUSH    DE
043AA9 CD 9C 18 04 9387  			CALL    MUL16			; HL=HL*BC
043AAD D1          9388  			POP     DE
043AAE 19          9389  			ADD     HL,DE
043AAF EB          9390  			EX      DE,HL
043AB0 B7          9391  			OR      A
043AB1 ED 42       9392  			SBC     HL,BC
043AB3 3E 0F       9393  			LD      A,15
043AB5 30 AF       9394  			JR      NC,ERROR3		; Throw a "Subscript" error
043AB7 E1          9395  			POP     HL
043AB8 F1          9396  			POP     AF
043AB9 3D          9397  			DEC     A               	; Dimension counter
043ABA 20 D8       9398  			JR      NZ,GETV2
043ABC CD 2F 0A 04 9399  			CALL    BRAKET          	; Check for closing bracket
043AC0 F1          9400  			POP     AF              	; Restore the type
043AC1 E5          9401  			PUSH    HL
043AC2 CD 8F 18 04 9402  			CALL    X4OR5           	; DE=DE*n
043AC6 E1          9403  			POP     HL
043AC7 19          9404  			ADD     HL,DE
043AC8 57          9405  			LD      D,A             	; The type
043AC9 FD 7E 00    9406  			LD      A,(IY)
043ACC FE 3F       9407  GETVX:			CP      '?'
043ACE 28 1E       9408  			JR      Z,GETV9
043AD0 FE 21       9409  			CP      '!'
043AD2 28 16       9410  			JR      Z,GETV8
043AD4 E5          9411  GETVZ:			PUSH    HL              	; Set exit conditions
043AD5 DD E1       9412  			POP     IX
043AD7 7A          9413  			LD      A,D
043AD8 BF          9414  			CP      A
043AD9 C9          9415  			RET
043ADA             9416  ;
043ADA             9417  ; Process strings, unary & binary indirection:
043ADA             9418  ;
043ADA 3E 80       9419  GETV4:			LD      A,128           	; Static strings
043ADC 18 05       9420  			JR      GETV7
043ADE             9421  ;
043ADE 3E 04       9422  GETV5:			LD      A,4             	; Unary 32-bit indirection
043AE0 18 01       9423  			JR      GETV7
043AE2             9424  ;
043AE2 AF          9425  GETV6:			XOR     A               	; Unary 8-bit indirection
043AE3             9426  ;
043AE3 21 00 00 00 9427  GETV7:			LD      HL,0
043AE7 F5          9428  			PUSH    AF
043AE8 18 24       9429  			JR      GETV0
043AEA             9430  ;
043AEA 06 04       9431  GETV8:			LD      B,4             	; Binary 32-bt indirection
043AEC 18 02       9432  			JR      GETVA
043AEE             9433  ;
043AEE 06 00       9434  GETV9:			LD      B,0             	; Binary 8-bit indirection
043AF0             9435  ;
043AF0 E5          9436  GETVA:			PUSH    HL
043AF1 DD E1       9437  			POP     IX
043AF3 7A          9438  			LD      A,D            		; Fetch the variable type
043AF4 FE 81       9439  			CP      129			; Is it a string?
043AF6 C8          9440  			RET     Z               	; Yes, so exit here
043AF7 C5          9441  			PUSH    BC
043AF8 CD 16 04 04 9442  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043AFC CD 62 06 04 9443  			CALL    SFIX
043B00 7D          9444  			LD	A,L
043B01 D9          9445  			EXX
043B02 22 4A 4D 04 9446  			LD	(R0+0),HL
043B06 32 4C 4D 04 9447  			LD	(R0+2),A
043B0A 2A 4A 4D 04 9448  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B0E             9449  ;
043B0E E5          9450  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B0F FD 23       9451  			INC     IY
043B11 CD 25 03 04 9452  			CALL    ITEMI
043B15 7D          9453  			LD	A,L			;  A: The MSB of the address
043B16 D9          9454  			EXX
043B17 22 4A 4D 04 9455  			LD	(R0+0),HL		; HL: The LSW of the address
043B1B 32 4C 4D 04 9456  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B1F D1          9457  			POP     DE
043B20 F1          9458  			POP     AF
043B21 2A 4A 4D 04 9459  			LD	HL,(R0)			; HL: L'HL
043B25 19          9460  			ADD     HL,DE
043B26 E5          9461  			PUSH    HL
043B27 DD E1       9462  			POP     IX
043B29 BF          9463  			CP      A
043B2A C9          9464  			RET
043B2B             9465  ;
043B2B             9466  ;GETDEF - Find entry for FN or PROC in dynamic area.
043B2B             9467  ;   Inputs: IY addresses byte following "DEF" token.
043B2B             9468  ;  Outputs: Z flag set if found
043B2B             9469  ;           Carry set if neither FN or PROC first.
043B2B             9470  ;           If Z: HL points to entry
043B2B             9471  ;                 IY addresses delimiter
043B2B             9472  ; Destroys: A,D,E,H,L,IY,F
043B2B             9473  ;
043B2B FD 7E 01    9474  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B2E CD AB 3C 04 9475  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B32 D8          9476  			RET     C			; No so return with C set
043B33 FD 7E 00    9477  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B36 21 0E 4D 04 9478  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B3A FE A4       9479  			CP      FN			; Is it the token FN?
043B3C 28 4A       9480  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B3E 21 11 4D 04 9481  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B42 FE F2       9482  			CP      PROC			; Is it the token PROC?
043B44 28 42       9483  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B46 37          9484  			SCF				; No, so just return with C set
043B47 C9          9485  			RET
043B48             9486  ;
043B48             9487  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B48             9488  ; If illegal first character return carry, non-zero.
043B48             9489  ; If found, return no-carry, zero.
043B48             9490  ; If not found, return no-carry, non-zero.
043B48             9491  ;   Inputs: IY=Addresses first character of name.
043B48             9492  ;            A=(IY)
043B48             9493  ;  Outputs:  F=Z set if found, then:
043B48             9494  ;           IY=addresses terminator
043B48             9495  ;           HL=addresses location of variable
043B48             9496  ;            D=type of variable: 4 = integer
043B48             9497  ;                                5 = floating point
043B48             9498  ;                              129 = string
043B48             9499  ; Destroys: A,D,E,H,L,IY,F
043B48             9500  ;
043B48             9501  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B48             9502  ; They can contain any alphanumeric character and underscore (_)
043B48             9503  ; String variables are postfixed with the dollar ($) character
043B48             9504  ; Integer variables are postfixed with the percent (%) character
043B48             9505  ; Static integer variables are named @%, A% to Z%
043B48             9506  ; All other variables are dynamic
043B48             9507  ;
043B48 D6 40       9508  LOCATE:			SUB     '@'			; Check for valid range
043B4A D8          9509  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B4B 21 00 00 00 9510  			LD      HL, 0			; Clear HL
043B4F FE 1B       9511  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B51 30 1E       9512  			JR      NC,LOC0         	; Then branch here
043B53 6F          9513  			LD	L, A			; HL = A
043B54 FD 7E 01    9514  			LD      A,(IY+1)        	; Check the 2nd character
043B57 FE 25       9515  			CP      '%'			; If not "%" then it is not static...
043B59 20 21       9516  			JR      NZ,LOC1         	; Branch here
043B5B FD 7E 02    9517  			LD      A,(IY+2)		; Check the 3rd character
043B5E FE 28       9518  			CP      '('			; If it is "(" (array) then it is not static...
043B60 28 1A       9519  			JR      Z,LOC1          	; Branch here
043B62             9520  ;
043B62             9521  ; At this point we're dealing with a static variable
043B62             9522  ;
043B62 29          9523  			ADD     HL,HL			; HL: Variable index * 4
043B63 29          9524  			ADD	HL,HL
043B64 11 00 4C 04 9525  			LD      DE,STAVAR       	; The static variable area in memory
043B68 19          9526  			ADD     HL,DE			; HL: The address of the static variable
043B69 FD 23       9527  			INC     IY			; Skip the program pointer past the static variable name
043B6B FD 23       9528  			INC     IY
043B6D 16 04       9529  			LD      D,4             	; Set the type to be integer
043B6F AF          9530  			XOR     A			; Set the Z flag
043B70 C9          9531  			RET
043B71             9532  ;
043B71             9533  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B71             9534  ;
043B71 FE 1F       9535  LOC0:			CP      '_'-'@'			; Check the first character is in
043B73 D8          9536  			RET     C			; the range "_" to
043B74 FE 3B       9537  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B76 3F          9538  			CCF				; If it is not in range then
043B77 3D          9539  			DEC     A               	; Set NZ flag and
043B78 D8          9540  			RET     C			; Exit here
043B79 D6 03       9541  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B7B 6F          9542  			LD	L, A			; HL = A
043B7C             9543  ;
043B7C             9544  ; Yes, it's definitely a dynamic variable at this point...
043B7C             9545  ;
043B7C 7D          9546  LOC1:			LD	A, L			; Fetch variable index
043B7D 87          9547  			ADD	A, A			; x 2
043B7E 85          9548  			ADD	A, L			; x 3
043B7F D6 03       9549  			SUB	3			; Subtract 2 TODO: Should be 3
043B81 6F          9550  			LD	L, A
043B82 11 6C 4C 04 9551  			LD      DE, DYNVAR       	; The dynamic variable storage
043B86 D8          9552  			RET	C			; Bounds check to trap for variable '@'
043B87 19          9553  			ADD     HL, DE			; HL: Address of first entry
043B88             9554  ;
043B88             9555  ; Loop through the linked list of variables to find a match
043B88             9556  ;
043B88 ED 17       9557  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B8A E5          9558  			PUSH	HL			; Need to preserve HL for LOC6
043B8B AF          9559  			XOR	A			; Reset carry flag
043B8C ED 62       9560  			SBC	HL, HL			; Set HL to 0
043B8E ED 52       9561  			SBC	HL, DE			; Compare with 0
043B90 E1          9562  			POP	HL			; Restore the original pointer
043B91 28 49       9563  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B93             9564  			; LD	HL, DE			; Make a copy of this pointer in HL
043B93 D5          9565  			push de
043B94 E1          9566  			pop hl ; how was that even possible?
043B95 23          9567  			INC     HL              	; Skip the link (24-bits)
043B96 23          9568  			INC     HL
043B97 23          9569  			INC	HL			; HL: Address of the variable name in DYNVARS
043B98 FD E5       9570  			PUSH    IY			; IY: Address of the variable name in the program
043B9A             9571  ;
043B9A 7E          9572  LOC3:			LD      A,(HL)         		; Compare
043B9B 23          9573  			INC     HL
043B9C FD 23       9574  			INC     IY
043B9E FD BE 00    9575  			CP      (IY)
043BA1 28 F7       9576  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043BA3 B7          9577  			OR      A               	; Have we hit a terminator?
043BA4 28 07       9578  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BA6             9579  ;
043BA6 FD E1       9580  LOC4:			POP     IY			; Restore the pointer in the program
043BA8 EB          9581  			EX      DE, HL			; HL: New pointer in DYNVARS
043BA9 C3 88 3B 04 9582  			JP      LOC2            	; Loop round and try again
043BAD             9583  ;
043BAD             9584  ; We might have located a variable at this point, just need to do a few more tests
043BAD             9585  ;
043BAD FD 2B       9586  LOC5:			DEC     IY
043BAF FD 7E 00    9587  			LD      A,(IY)
043BB2 FE 28       9588  			CP      '('
043BB4 28 15       9589  			JR      Z,LOC5A         	; FOUND
043BB6 FD 23       9590  			INC     IY
043BB8 CD 9F 3C 04 9591  			CALL    RANGE
043BBC 38 0D       9592  			JR      C,LOC5A         	; FOUND
043BBE FE 28       9593  			CP      '('
043BC0 28 E4       9594  			JR      Z,LOC4          	; KEEP LOOKING
043BC2 FD 7E FF    9595  			LD      A,(IY-1)
043BC5 CD AB 3C 04 9596  			CALL    RANGE1
043BC9 30 DB       9597  			JR      NC,LOC4         	; KEEP LOOKING
043BCB D1          9598  LOC5A:			POP     DE
043BCC FD 7E FF    9599  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BCF FE 24       9600  			CP      '$'			; Is it a string?
043BD1 16 81       9601  			LD      D,129			; Yes, so return D = 129
043BD3 C8          9602  			RET     Z
043BD4 FE 25       9603  			CP      '%'			; Is it an integer?
043BD6 16 04       9604  			LD      D,4			; Yes, so return D = 4
043BD8 C8          9605  			RET     Z
043BD9 14          9606  			INC     D			; At this point it must be a float
043BDA BF          9607  			CP      A			; Set the flags
043BDB C9          9608  			RET
043BDC             9609  ;
043BDC             9610  ; The variable is undefined at this point; HL will be zero
043BDC             9611  ;
043BDC 3C          9612  LOC6:			INC     A               	; Set NZ flag
043BDD C9          9613  			RET
043BDE             9614  ;
043BDE             9615  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043BDE             9616  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043BDE             9617  ;  Outputs: As LOCATE, GETDEF.
043BDE             9618  ; Destroys: As LOCATE, GETDEF.
043BDE             9619  ;
043BDE AF          9620  CREATE:			XOR     A
043BDF ED 5B 1D 4D 9621  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043BE4 ED 1F       9622  			LD	(HL), DE		; Store
043BE6 EB          9623  			EX      DE,HL
043BE7 77          9624  			LD      (HL),A			; Clear the link of the new entity
043BE8 23          9625  			INC     HL
043BE9 77          9626  			LD      (HL),A
043BEA 23          9627  			INC     HL
043BEB 77          9628  			LD      (HL),A
043BEC 23          9629  			INC     HL
043BED FD 23       9630  LOC7:			INC     IY
043BEF CD 9F 3C 04 9631  			CALL    RANGE           	; END OF VARIABLE?
043BF3 38 15       9632  			JR      C,LOC8
043BF5 77          9633  			LD      (HL),A
043BF6 23          9634  			INC     HL
043BF7 CD AB 3C 04 9635  			CALL    RANGE1
043BFB 30 F0       9636  			JR      NC,LOC7
043BFD FE 28       9637  			CP      '('
043BFF 28 09       9638  			JR      Z,LOC8
043C01 FD 7E 01    9639  			LD      A,(IY+1)
043C04 FE 28       9640  			CP      '('
043C06 28 E5       9641  			JR      Z,LOC7
043C08 FD 23       9642  			INC     IY
043C0A 36 00       9643  LOC8:			LD      (HL),0          	; TERMINATOR
043C0C 23          9644  			INC     HL
043C0D E5          9645  			PUSH    HL
043C0E CD CC 3B 04 9646  			CALL    TYPE_			; Get the variable type in D
043C12 3E 04       9647  			LD      A,4			; If it is an integer then it takes up 4 bytes
043C14 BA          9648  			CP      D
043C15 28 01       9649  			JR      Z,LOC9			; So skip the next bit
043C17 3C          9650  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C18 36 00       9651  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C1A 23          9652  			INC     HL
043C1B 3D          9653  			DEC     A
043C1C 20 FA       9654  			JR      NZ,LOC9
043C1E 22 1D 4D 04 9655  			LD      (FREE),HL		; Adjust the stack
043C22 CD 79 16 04 9656  			CALL    CHECK			; Check whether we are out of space
043C26 E1          9657  			POP     HL
043C27 AF          9658  			XOR     A
043C28 C9          9659  			RET
043C29             9660  ;
043C29             9661  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043C29             9662  ;   Inputs: IY = Text Pointer
043C29             9663  ;  Outputs: HL = Line number (zero if none)
043C29             9664  ;           IY updated
043C29             9665  ; Destroys: A,D,E,H,L,IY,F
043C29             9666  ;
043C29             9667  ; This bit of code performs a BASE 10 shift to build up the number
043C29             9668  ; So if the string passed is "345", the algorithm does this:
043C29             9669  ;
043C29             9670  ;    HL : Digit	: Operation
043C29             9671  ; ----- : ----- : ---------
043C29             9672  ; 00000 :	:
043C29             9673  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043C29             9674  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043C29             9675  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043C29             9676  ;
043C29             9677  ; The multiply by 10 is done by an unrolled shift and add loop
043C29             9678  ;
043C29 CD 70 0A 04 9679  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C2D 40 21 00 00 9680  			LD.SIS  HL,0			; The running total
043C31 FD 7E 00    9681  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C34 D6 30       9682  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C36 D8          9683  			RET     C			; And return if less than 0
043C37 FE 0A       9684  			CP      10			; Or greater than or equal to 10
043C39 D0          9685  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C3A FD 23       9686  			INC     IY			; Increment the string pointer
043C3C 54          9687  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C3D 5D          9688  			LD      E,L			; Store the original number in DE
043C3E 52 29       9689  			ADD.S   HL,HL           	; *2
043C40 38 13       9690  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C42 52 29       9691  			ADD.S   HL,HL           	; *4S
043C44 38 0F       9692  			JR      C,TOOBIG
043C46 52 19       9693  			ADD.S   HL,DE           	; *5
043C48 38 0B       9694  			JR      C,TOOBIG
043C4A 52 29       9695  			ADD.S   HL,HL           	; *10
043C4C 38 07       9696  			JR      C,TOOBIG
043C4E 5F          9697  			LD      E,A			; A->DE: the digit to add in
043C4F 16 00       9698  			LD      D,0
043C51 52 19       9699  			ADD.S   HL,DE           	; Add in the digit to the running total
043C53 30 DC       9700  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C55             9701  ;
043C55 3E 14       9702  TOOBIG:			LD      A,20
043C57 C3 90 37 04 9703  			JP      ERROR_           	; Error: "Too big"
043C5B             9704  ;
043C5B             9705  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C5B             9706  ;   Inputs: IY = text pointer
043C5B             9707  ;  Outputs: HL = first number (10 by default)
043C5B             9708  ;           BC = second number (10 by default)
043C5B             9709  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C5B             9710  ;
043C5B CD 29 3C 04 9711  PAIR:			CALL    LINNUM          	; Parse the first line number
043C5F 7C          9712  			LD      A,H			; If it is not zero, then...
043C60 B5          9713  			OR      L
043C61 20 02       9714  			JR      NZ,PAIR1		; Skip...
043C63 2E 0A       9715  			LD      L,10			; HL: the default value (10)
043C65             9716  ;
043C65 CD A4 17 04 9717  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C69 FD 23       9718  			INC     IY			; Skip to next character
043C6B E5          9719  			PUSH    HL			; Stack the first line number
043C6C 21 0A 00 00 9720  			LD      HL,10			; HL: the second default (10)
043C70 C4 29 3C 04 9721  			CALL    NZ,LINNUM       	; Parse the second line number
043C74 E3          9722  			EX      (SP),HL			; HL: The first line number (off the stack)
043C75 C1          9723  			POP     BC			; BC: Second line number
043C76 78          9724  			LD      A,B			; If the second line number is not zero then...
043C77 B1          9725  			OR      C			; We're good...
043C78 C0          9726  			RET     NZ			; Exit, otherwise...
043C79 CD A7 37 04 9727  			CALL    EXTERR			; Throw error: "Silly"
043C7D 53 69 6C 6C 9728  			DB    	"Silly", 0
       79 00       
043C83             9729  ;
043C83             9730  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043C83             9731  ;   Inputs: IY = text pointer
043C83             9732  ;  Outputs: HL = points to program text
043C83             9733  ;           BC = second number (0 by default)
043C83             9734  ; Destroys: A,B,C,D,E,H,L,IY,F
043C83             9735  ;
043C83 CD 29 3C 04 9736  DLPAIR:			CALL    LINNUM			; Parse the first line number
043C87 E5          9737  			PUSH    HL			; Stack it
043C88 CD A4 17 04 9738  			CALL    TERMQ			; Check for ELSE, : or CR
043C8C 28 0A       9739  			JR      Z,DLP1			; And exit if so
043C8E FE E7       9740  			CP      TIF			; Is the token IF?
043C90 28 06       9741  			JR      Z,DLP1			; Yes, so skip the next bit...
043C92 FD 23       9742  			INC     IY			; Otherwise...
043C94 CD 29 3C 04 9743  			CALL    LINNUM			; Fetch the second line number
043C98 E3          9744  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043C99 CD BF 39 04 9745  			CALL    FINDL			; HL: Find the address of the line
043C9D C1          9746  			POP     BC			; BC: The second number
043C9E C9          9747  			RET
043C9F             9748  ;
043C9F             9749  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043C9F             9750  ;   Inputs: IY addresses character
043C9F             9751  ;  Outputs: Carry set if out-of-range.
043C9F             9752  ; Destroys: A,F
043C9F             9753  ;
043C9F             9754  ; It is called here to check the following
043C9F             9755  ; In range: "$", "%" and "("
043C9F             9756  ;   Plus all characters in RANGE1 and RANGE2
043C9F             9757  ;
043C9F FD 7E 00    9758  RANGE:			LD      A,(IY)			; Fetch the character
043CA2 FE 24       9759  			CP      '$'			; Postfix for string variable is valid
043CA4 C8          9760  			RET     Z
043CA5 FE 25       9761  			CP      '%'			; Postfix for integer variable is valid
043CA7 C8          9762  			RET     Z
043CA8 FE 28       9763  			CP      '('			; Postfix for array is valid
043CAA C8          9764  			RET     Z
043CAB             9765  ;
043CAB             9766  ; It is called here to check the following
043CAB             9767  ; In range: "0" to "9" and "@"
043CAB             9768  ;   Plus all characters in RANGE2
043CAB             9769  ;
043CAB FE 30       9770  RANGE1:			CP      '0'			; If it is between '0'...
043CAD D8          9771  			RET     C
043CAE FE 3A       9772  			CP      '9'+1			; And '9'...
043CB0 3F          9773  			CCF
043CB1 D0          9774  			RET     NC			; Then it is valid
043CB2 FE 40       9775  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CB4 C8          9776  			RET     Z
043CB5             9777  ;
043CB5             9778  ; It is called here to check the following
043CB5             9779  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043CB5             9780  ;
043CB5 FE 41       9781  RANGE2:			CP      'A'			; If it is between 'A'...
043CB7 D8          9782  			RET     C
043CB8 FE 5B       9783  			CP      'Z'+1			; And 'Z'...
043CBA 3F          9784  			CCF
043CBB D0          9785  			RET     NC			; Then it is valid
043CBC FE 5F       9786  			CP      '_'			; If it is underscore, grave, or between 'a'
043CBE D8          9787  			RET     C
043CBF FE 7B       9788  			CP      'z'+1			; And 'z'
043CC1 3F          9789  			CCF				; Then it is valid
043CC2 C9          9790  			RET
043CC3             9791  ;
043CC3             9792  ; Throw a 'LINE space' error (line too long)
043CC3             9793  ; This is called from LEXAN
043CC3             9794  ;
043CC3 AF          9795  SPACE_: 		XOR     A
043CC4 CD A7 37 04 9796  			CALL    EXTERR          	; "LINE space"
043CC8 86 08 00    9797  			DB    	LINE_MN_, 8, 0
043CCB             9798  ;
043CCB             9799  ; LEXAN - LEXICAL ANALYSIS.
043CCB             9800  ;  Bit 0,C: 1=left, 0=right
043CCB             9801  ;  Bit 2,C: 1=in BINARY
043CCB             9802  ;  Bit 3,C: 1=in HEX
043CCB             9803  ;  Bit 4,C: 1=accept line number
043CCB             9804  ;  Bit 5,C: 1=in variable, FN, PROC
043CCB             9805  ;  Bit 6,C: 1=in REM, DATA, *
043CCB             9806  ;  Bit 7,C: 1=in quotes
043CCB             9807  ;   Inputs: IY addresses source string
043CCB             9808  ;           DE addresses destination string (must be page boundary)
043CCB             9809  ;            C sets initial mode
043CCB             9810  ;  Outputs: DE, IY updated
043CCB             9811  ;            A holds carriage return
043CCB             9812  ;
043CCB 12          9813  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CCC 13          9814  			INC     DE              	; Increment the pointers
043CCD FD 23       9815  			INC     IY			; And fall through to the main function
043CCF             9816  ;
043CCF             9817  ; This is the main entry point
043CCF             9818  ;
043CCF 7B          9819  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CD0 FE FC       9820  			CP      252             	; If it is >= 252 bytes, then...
043CD2 30 EF       9821  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CD4 FD 7E 00    9822  			LD      A,(IY)			; Fetch character from source string
043CD7 FE 0D       9823  			CP      CR			; If it is a CR
043CD9 C8          9824  			RET     Z               	; Then it is end of line; we're done parsing
043CDA CD AB 3C 04 9825  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CDE 30 06       9826  			JR      NC,LEXAN3		; Yes, so skip
043CE0 CB A9       9827  			RES     5,C             	; FLAG: NOT IN VARIABLE
043CE2 CB 99       9828  			RES     3,C             	; FLAG: NOT IN HEX
043CE4 CB 91       9829  			RES	2,C			; FLAG: NOT IN BINARY
043CE6             9830  ;
043CE6 FE 20       9831  LEXAN3:			CP      ' '			; Ignore spaces
043CE8 28 E1       9832  			JR      Z,LEXAN1
043CEA FE 2C       9833  			CP      ','			; Ignore commas
043CEC 28 DD       9834  			JR      Z,LEXAN1
043CEE FE 32       9835  			CP	'2'			; If less than '2'
043CF0 30 02       9836  			JR	NC, @F			; No, so skip
043CF2 CB 91       9837  			RES	2,C			; FLAG: NOT IN BINARY
043CF4 FE 47       9838  @@:			CP      'G'			; If less then 'G'
043CF6 38 02       9839  			JR      C,LEXAN4		; Yes, so skip
043CF8 CB 99       9840  			RES     3,C             	; FLAG: NOT IN HEX
043CFA             9841  ;
043CFA FE 22       9842  LEXAN4:			CP      34			; Is it a quote character?
043CFC 20 05       9843  			JR      NZ,LEXAN5		; No, so skip
043CFE CB 11       9844  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D00 3F          9845  			CCF                     	; Toggle the carry
043D01 CB 19       9846  			RR      C			; And then shifting it back into bit 7 of C
043D03             9847  ;
043D03 CB 61       9848  LEXAN5:			BIT     4,C			; Accept line number?
043D05 28 12       9849  			JR      Z,LEXAN6		; No, so skip
043D07 CB A1       9850  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D09 C5          9851  			PUSH    BC
043D0A D5          9852  			PUSH    DE
043D0B CD 29 3C 04 9853  			CALL    LINNUM         		; Parse the line number to HL
043D0F D1          9854  			POP     DE
043D10 C1          9855  			POP     BC
043D11 7C          9856  			LD      A,H			; If it is not zero
043D12 B5          9857  			OR      L
043D13 C4 8C 3D 04 9858  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D17 18 B6       9859  			JR      LEXAN2          	; And loop
043D19             9860  ;
043D19 0D          9861  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D1A 28 0A       9862  			JR      Z,LEXAN7        	; If so, skip
043D1C 0C          9863  			INC     C			; Otherwise restore C
043D1D 20 AC       9864  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D1F B7          9865  			OR      A			; Set the flags based on the character
043D20 F4 F7 37 04 9866  			CALL    P,LEX           	; Tokenise if A < 128
043D24 18 13       9867  			JR      LEXAN8			; And skip
043D26             9868  ;
043D26             9869  ; Processing the LEFT hand side here
043D26             9870  ;
043D26 FE 2A       9871  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D28 28 17       9872  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D2A B7          9873  			OR      A			; Set the flags based on the character
043D2B F4 F7 37 04 9874  			CALL    P,LEX           	; Tokenise if A < 128
043D2F             9875  ;
043D2F             9876  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043D2F             9877  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043D2F             9878  ; Examples:
043D2F             9879  ;   LET A% = PAGE : REM This is the GET version
043D2F             9880  ;   PAGE = 40000  : REM This is the SET version
043D2F             9881  ;
043D2F FE 8F       9882  			CP      TOKLO			; TOKLO is 8Fh
043D31 38 06       9883  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D33 FE 94       9884  			CP      TOKHI+1			; TOKHI is 93h
043D35 30 02       9885  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D37 C6 40       9886  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D39             9887  ;
043D39 FE F4       9888  LEXAN8:			CP      REM			; If the token is REM
043D3B 28 04       9889  			JR      Z,LEXAN9		; Then stop tokenising
043D3D FE DC       9890  			CP      DATA_MN_			; If it is not DATA then
043D3F 20 02       9891  			JR      NZ,LEXANA		; Skip
043D41 CB F1       9892  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D43             9893  ;
043D43 FE A4       9894  LEXANA:			CP      FN			; If the token is FN
043D45 28 0A       9895  			JR      Z,LEXANB
043D47 FE F2       9896  			CP      PROC			; Or the token is PROC
043D49 28 06       9897  			JR      Z,LEXANB		; Then jump to here
043D4B CD B5 3C 04 9898  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D4F 38 02       9899  			JR      C,LEXANC		; Jump here if out of range
043D51             9900  ;
043D51 CB E9       9901  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D53 FE 26       9902  LEXANC:			CP      '&'			; Check for hex prefix
043D55 20 02       9903  			JR      NZ,LEXAND		; If not, skip
043D57 CB D9       9904  			SET     3,C             	; FLAG: IN HEX
043D59             9905  ;
043D59 FE 25       9906  LEXAND:			CP	'%'			; Check for binary prefix
043D5B 20 02       9907  			JR	NZ,LEXANE		; If not, skip
043D5D CB D1       9908  			SET	2,C			; FLAG: IN BINARY
043D5F             9909  ;
043D5F 21 83 3D 04 9910  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D63 C5          9911  			PUSH    BC
043D64 01 06 00 00 9912  			LD      BC,LIST1L		; The list length
043D68 ED B1       9913  			CPIR				; Check if the token is in this list
043D6A C1          9914  			POP     BC
043D6B 20 02       9915  			JR      NZ,LEXANF		; If not, then skip
043D6D CB E1       9916  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D6F             9917  ;
043D6F 21 87 3D 04 9918  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D73 C5          9919  			PUSH    BC
043D74 01 05 00 00 9920  			LD      BC,LIST2L		; The list length
043D78 ED B1       9921  			CPIR				; Check if the token is in this list
043D7A C1          9922  			POP     BC
043D7B 20 02       9923  			JR      NZ,LEXANG		; If not, then skip
043D7D CB C1       9924  			SET     0,C             	; FLAG: ENTER LEFT MODE
043D7F C3 CB 3C 04 9925  LEXANG:			JP      LEXAN1			; And loop
043D83             9926  
043D83             9927  ;
043D83             9928  ; LIST1: List of tokens that must be followed by line numbers
043D83             9929  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043D83             9930  ;
043D83 E5          9931  LIST1:			DB	GOTO
043D84 E4          9932  			DB	GOSUB
043D85 F7          9933  			DB	RESTOR
043D86 FC          9934  			DB	TRACE
043D87 8C          9935  LIST2:			DB	THEN_MN_
043D88 8B          9936  			DB	ELSE_MN_
043D89             9937  LIST1L:			EQU     $-LIST1
043D89 F5          9938  			DB	REPEAT
043D8A 85          9939  			DB	TERROR_MN
043D8B 3A          9940  			DB    	':'
043D8C             9941  LIST2L:			EQU     $-LIST2
043D8C             9942  ;
043D8C             9943  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043D8C             9944  ;   Inputs: HL=line number, DE=string pointer
043D8C             9945  ;  Outputs: DE updated, BIT 4,C set.
043D8C             9946  ; Destroys: A,B,C,D,E,F
043D8C             9947  ;
043D8C             9948  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043D8C             9949  ;
043D8C             9950  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043D8C             9951  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043D8C             9952  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043D8C             9953  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043D8C             9954  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043D8C             9955  ;
043D8C CB E1       9956  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D8E EB          9957  			EX      DE, HL			; HL: string pointer, DE: line number
043D8F 36 8D       9958  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D91 23          9959  			INC     HL
043D92 7A          9960  			LD      A,D			; Get the high byte
043D93 E6 C0       9961  			AND     0C0H			; Get the top two bits	DD000000
043D95 0F          9962  			RRCA				; Shift right		00DD0000
043D96 0F          9963  			RRCA
043D97 47          9964  			LD      B,A			; Store in B
043D98 7B          9965  			LD      A,E			; Get the low byte
043D99 E6 C0       9966  			AND     0C0H			; Get the top two bits	EE000000
043D9B B0          9967  			OR      B			; Combine with D	EEDD0000
043D9C 0F          9968  			RRCA				; Shift right		00EEDD00
043D9D 0F          9969  			RRCA
043D9E EE 54       9970  			XOR     01010100B		; XOR with 54h
043DA0 77          9971  			LD      (HL),A			; Store this as the second byte
043DA1 23          9972  			INC     HL
043DA2 7B          9973  			LD      A,E			; Get the low byte
043DA3 E6 3F       9974  			AND     3FH			; Strip the top two bits off
043DA5 F6 40       9975  			OR      '@'			; OR with 40h
043DA7 77          9976  			LD      (HL),A			; Store
043DA8 23          9977  			INC     HL
043DA9 7A          9978  			LD      A,D			; Get the high byte
043DAA E6 3F       9979  			AND     3FH			; Strip the top two bits off
043DAC F6 40       9980  			OR      '@'			; OR with 40h
043DAE 77          9981  			LD      (HL),A			; Store
043DAF 23          9982  			INC     HL
043DB0 EB          9983  			EX      DE,HL			; DE: string pointer, HL: line number
043DB1 C9          9984  			RET
043DB2             9985  ;
043DB2             9986  ; TEXT - OUTPUT MESSAGE.
043DB2             9987  ;   Inputs: HL addresses text (terminated by nul)
043DB2             9988  ;  Outputs: HL addresses character following nul.
043DB2             9989  ; Destroys: A,H,L,F
043DB2             9990  ;
043DB2 2A 2F 4D 04 9991  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DB6             9992  ;
043DB6 7E          9993  TEXT_:			LD      A, (HL)			; Fetch the character
043DB7 23          9994  			INC     HL			; Increment pointer to next character
043DB8 B7          9995  			OR      A			; Check for the nul (0) string terminator
043DB9 C8          9996  			RET     Z			; And return if so
043DBA CD 9C 39 04 9997  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DBE 18 F6       9998  			JR      TEXT_			; And loop
043DC0             9999  ;
043DC0             10000  ; TELL - OUTPUT MESSAGE.
043DC0             10001  ;   Inputs: Text follows subroutine call (term=nul)
043DC0             10002  ; Destroys: A,F
043DC0             10003  ;
043DC0             10004  ; Example usage:
043DC0             10005  ;
043DC0             10006  ;	CALL	TELL			Call the function
043DC0             10007  ;	DB	"Hello World", 0	Followed by a zero terminated string
043DC0             10008  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043DC0             10009  ;
043DC0 E3          10010  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DC1 CD B6 3D 04 10011  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DC5 E3          10012  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DC6 C9          10013  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043DC7             10014  
043DC7             10015  ; --- Begin misc.asm ---
043DC7             10016  ;
043DC7             10017  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043DC7             10018  ; Author:	Dean Belfield
043DC7             10019  ; Created:	12/05/2023
043DC7             10020  ; Last Updated:	12/05/2023
043DC7             10021  ;
043DC7             10022  ; Modinfo:
043DC7             10023  
043DC7             10024  			; INCLUDE	"equs.inc"
043DC7             10025  			; INCLUDE	"macros.inc"
043DC7             10026  
043DC7             10027  			; .ASSUME	ADL = 1
043DC7             10028  
043DC7             10029  			; SEGMENT CODE
043DC7             10030  
043DC7             10031  			; XDEF	ASC_TO_NUMBER
043DC7             10032  			; XDEF	SWITCH_A
043DC7             10033  			; XDEF	NULLTOCR
043DC7             10034  			; XDEF	CRTONULL
043DC7             10035  			; XDEF	CSTR_FNAME
043DC7             10036  			; XDEF	CSTR_LINE
043DC7             10037  			; XDEF	CSTR_FINDCH
043DC7             10038  			; XDEF	CSTR_ENDSWITH
043DC7             10039  			; XDEF	CSTR_CAT
043DC7             10040  
043DC7             10041  			; XREF	OSWRCH
043DC7             10042  			; XREF	KEYWDS
043DC7             10043  			; XREF	KEYWDL
043DC7             10044  
043DC7             10045  ; Read a number and convert to binary
043DC7             10046  ; If prefixed with &, will read as hex, otherwise decimal
043DC7             10047  ;   Inputs: HL: Pointer in string buffer
043DC7             10048  ;  Outputs: HL: Updated text pointer
043DC7             10049  ;           DE: Value
043DC7             10050  ;            A: Terminator (spaces skipped)
043DC7             10051  ; Destroys: A,D,E,H,L,F
043DC7             10052  ;
043DC7 C5          10053  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DC8 11 00 00 00 10054  			LD	DE, 0			; Initialise DE
043DCC CD 0E 3E 04 10055  			CALL	SKIPSPC			; Skip whitespace
043DD0 7E          10056  			LD	A, (HL)			; Read first character
043DD1 FE 26       10057  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DD3 20 1F       10058  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DD5 23          10059  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DD6             10060  ;
043DD6 7E          10061  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DD7 CD 1C 3E 04 10062  			CALL    UPPERC			; Convert to uppercase
043DDB D6 30       10063  			SUB	'0'			; Normalise to 0
043DDD 38 2E       10064  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DDF FE 0A       10065  			CP 	10			; Check if >= 10
043DE1 38 06       10066  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DE3 D6 07       10067  			SUB 	7			; Adjust ASCII A-F to nibble
043DE5 FE 10       10068  			CP 	16			; Check for > F
043DE7 30 24       10069  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DE9 EB          10070  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DEA 29          10071  			ADD	HL, HL
043DEB 29          10072  			ADD	HL, HL
043DEC 29          10073  			ADD	HL, HL
043DED 29          10074  			ADD	HL, HL
043DEE EB          10075  			EX	DE, HL
043DEF B3          10076  			OR      E			; OR the new digit in to the least significant nibble
043DF0 5F          10077  			LD      E, A
043DF1 23          10078  			INC     HL			; Onto the next character
043DF2 18 E2       10079  			JR      ASC_TO_NUMBER1		; And loop
043DF4             10080  ;
043DF4 7E          10081  ASC_TO_NUMBER3:		LD	A, (HL)
043DF5 D6 30       10082  			SUB	'0'			; Normalise to 0
043DF7 38 14       10083  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DF9 FE 0A       10084  			CP	10			; Check if >= 10
043DFB 30 10       10085  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043DFD EB          10086  			EX 	DE, HL 			; Stick DE in HL
043DFE 44          10087  			LD	B, H 			; And copy HL into BC
043DFF 4D          10088  			LD	C, L
043E00 29          10089  			ADD	HL, HL 			; x 2
043E01 29          10090  			ADD	HL, HL 			; x 4
043E02 09          10091  			ADD	HL, BC 			; x 5
043E03 29          10092  			ADD	HL, HL 			; x 10
043E04 EB          10093  			EX	DE, HL
043E05             10094  			ADD8U_DE 			; Add A to DE (macro)
043E05 83          0001M 		ADD	A, E
043E06 5F          0002M 		LD	E, A
043E07 8A          0003M 		ADC	A, D
043E08 93          0004M 		SUB	E
043E09 57          0005M 		LD	D, A
043E0A 23          10095  			INC	HL
043E0B 18 E7       10096  			JR	ASC_TO_NUMBER3
043E0D C1          10097  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043E0E             10098  
043E0E             10099  ; Skip a space
043E0E             10100  ; HL: Pointer in string buffer
043E0E             10101  ;
043E0E 7E          10102  SKIPSPC:			LD      A, (HL)
043E0F FE 20       10103  			CP      ' '
043E11 C0          10104  			RET     NZ
043E12 23          10105  			INC     HL
043E13 18 F9       10106  			JR      SKIPSPC
043E15             10107  
043E15             10108  ; Skip a string
043E15             10109  ; HL: Pointer in string buffer
043E15             10110  ;
043E15 7E          10111  SKIPNOTSP:		LD	A, (HL)
043E16 FE 20       10112  			CP	' '
043E18 C8          10113  			RET	Z
043E19 23          10114  			INC	HL
043E1A 18 F9       10115  			JR	SKIPNOTSP
043E1C             10116  
043E1C             10117  ; Convert a character to upper case
043E1C             10118  ;  A: Character to convert
043E1C             10119  ;
043E1C E6 7F       10120  UPPERC:  		AND     7FH
043E1E FE 60       10121  			CP      '`'
043E20 D8          10122  			RET     C
043E21 E6 5F       10123  			AND     5FH			; Convert to upper case
043E23 C9          10124  			RET
043E24             10125  
043E24             10126  ; Switch on A - lookup table immediately after call
043E24             10127  ;  A: Index into lookup table
043E24             10128  ;
043E24 E3          10129  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E25 87          10130  			ADD	A, A			; Multiply A by two
043E26             10131  			ADD8U_HL 			; Add to HL (macro)
043E26 85          0001M 		ADD	A, L
043E27 6F          0002M 		LD	L, A
043E28 8C          0003M 		ADC	A, H
043E29 95          0004M 		SUB	L
043E2A 67          0005M 		LD	H, A
043E2B 7E          10132  			LD	A, (HL)			; follow the call. Fetch an address from the
043E2C 23          10133  			INC	HL 			; table.
043E2D 66          10134  			LD	H, (HL)
043E2E 6F          10135  			LD	L, A
043E2F E3          10136  			EX	(SP), HL		; Swap this new address back, restores HL
043E30 C9          10137  			RET				; Return program control to this new address
043E31             10138  
043E31             10139  ; Convert the buffer to a null terminated string and back
043E31             10140  ; HL: Buffer address
043E31             10141  ;
043E31 C5          10142  NULLTOCR:		PUSH 	BC
043E32 06 00       10143  			LD	B, 0
043E34 0E 0D       10144  			LD	C, CR
043E36 18 05       10145  			JR	CRTONULL0
043E38             10146  ;
043E38 C5          10147  CRTONULL:		PUSH	BC
043E39 06 0D       10148  			LD	B, CR
043E3B 0E 00       10149  			LD	C, 0
043E3D             10150  ;
043E3D E5          10151  CRTONULL0:		PUSH	HL
043E3E 7E          10152  CRTONULL1:		LD	A, (HL)
043E3F B8          10153  			CP 	B
043E40 28 03       10154  			JR	Z, CRTONULL2
043E42 23          10155  			INC	HL
043E43 18 F9       10156  			JR	CRTONULL1
043E45 71          10157  CRTONULL2:		LD	(HL), C
043E46 E1          10158  			POP 	HL
043E47 C1          10159  			POP	BC
043E48 C9          10160  			RET
043E49             10161  
043E49             10162  ; Copy a filename to DE and zero terminate it
043E49             10163  ; HL: Source
043E49             10164  ; DE: Destination (ACCS)
043E49             10165  ;
043E49 7E          10166  CSTR_FNAME:		LD	A, (HL)			; Get source
043E4A FE 20       10167  			CP	32			; Is it space
043E4C 28 09       10168  			JR	Z, @F
043E4E FE 0D       10169  			CP	CR			; Or is it CR
043E50 28 05       10170  			JR	Z, @F
043E52 12          10171  			LD	(DE), A			; No, so store
043E53 23          10172  			INC	HL			; Increment
043E54 13          10173  			INC	DE
043E55 18 F2       10174  			JR	CSTR_FNAME		; And loop
043E57 AF          10175  @@:			XOR	A			; Zero terminate the target string
043E58 12          10176  			LD	(DE), A
043E59 13          10177  			INC	DE			; And point to next free address
043E5A C9          10178  			RET
043E5B             10179  
043E5B             10180  ; Copy a CR terminated line to DE and zero terminate it
043E5B             10181  ; HL: Source
043E5B             10182  ; DE: Destination (ACCS)
043E5B             10183  ;
043E5B 7E          10184  CSTR_LINE:		LD	A, (HL)			; Get source
043E5C FE 0D       10185  			CP	CR			; Is it CR
043E5E 28 05       10186  			JR	Z, @F
043E60 12          10187  			LD	(DE), A			; No, so store
043E61 23          10188  			INC	HL			; Increment
043E62 13          10189  			INC	DE
043E63 18 F6       10190  			JR	CSTR_LINE		; And loop
043E65 AF          10191  @@:			XOR	A			; Zero terminate the target string
043E66 12          10192  			LD	(DE), A
043E67 13          10193  			INC	DE			; And point to next free address
043E68 C9          10194  			RET
043E69             10195  
043E69             10196  ; Find the first occurrence of a character (case sensitive)
043E69             10197  ; HL: Source
043E69             10198  ;  C: Character to find
043E69             10199  ; Returns:
043E69             10200  ; HL: Pointer to character, or end of string marker
043E69             10201  ;
043E69 7E          10202  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E6A B9          10203  			CP	C			; Is it our character?
043E6B C8          10204  			RET	Z			; Yes, so exit
043E6C B7          10205  			OR	A			; Is it the end of string?
043E6D C8          10206  			RET	Z			; Yes, so exit
043E6E 23          10207  			INC	HL
043E6F 18 F8       10208  			JR	CSTR_FINDCH
043E71             10209  
043E71             10210  ; Check whether a string ends with another string (case insensitive)
043E71             10211  ; HL: Source
043E71             10212  ; DE: The substring we want to test with
043E71             10213  ; Returns:
043E71             10214  ;  F: Z if HL ends with DE, otherwise NZ
043E71             10215  ;
043E71 7E          10216  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E72 CD 1C 3E 04 10217  			CALL	UPPERC			; Convert to upper case
043E76 4F          10218  			LD	C, A
043E77 1A          10219  			LD	A, (DE)			; Get the substring byte
043E78 B9          10220  			CP	C
043E79 C0          10221  			RET	NZ			; Return NZ if at any point the strings don't match
043E7A B1          10222  			OR	C			; Check whether both bytes are zero
043E7B C8          10223  			RET	Z			; If so, return, as we have reached the end of both strings
043E7C 23          10224  			INC	HL
043E7D 13          10225  			INC	DE
043E7E 18 F1       10226  			JR	CSTR_ENDSWITH		; And loop
043E80             10227  
043E80             10228  ; Concatenate a string onto the end of another string
043E80             10229  ; HL: Source
043E80             10230  ; DE: Second string
043E80             10231  ;
043E80 7E          10232  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E81 B7          10233  			OR	A
043E82 28 03       10234  			JR	Z, CSTR_CAT_1
043E84 23          10235  			INC	HL
043E85 18 F9       10236  			JR	CSTR_CAT
043E87             10237  ;
043E87 1A          10238  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E88 77          10239  			LD	(HL), A
043E89 B7          10240  			OR	A			; Check for end of string
043E8A C8          10241  			RET	Z			; And return
043E8B 23          10242  			INC	HL
043E8C 13          10243  			INC	DE
043E8D 18 F8       10244  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E8F             10245  
043E8F             10246  ; --- Begin patch.asm ---
043E8F             10247  ;
043E8F             10248  ; Title:	BBC Basic for AGON
043E8F             10249  ; Author:	Dean Belfield
043E8F             10250  ; Created:	12/05/2023
043E8F             10251  ; Last Updated:	15/11/2023
043E8F             10252  ;
043E8F             10253  ; Modinfo:
043E8F             10254  ; 11/07/2023:	Fixed *BYE for ADL mode
043E8F             10255  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043E8F             10256  
043E8F             10257  			; .ASSUME	ADL = 1
043E8F             10258  
043E8F             10259  			; INCLUDE	"equs.inc"
043E8F             10260  			; INCLUDE "macros.inc"
043E8F             10261  			; INCLUDE "mos_api.inc"	; In MOS/src
043E8F             10262  
043E8F             10263  			; SEGMENT CODE
043E8F             10264  
043E8F             10265  			; XDEF	OSWRCH
043E8F             10266  			; XDEF	OSLINE
043E8F             10267  			; XDEF	ESCSET
043E8F             10268  			; XDEF	PUTIME
043E8F             10269  			; XDEF	GETIME
043E8F             10270  			; XDEF	PUTCSR
043E8F             10271  			; XDEF 	GETCSR
043E8F             10272  			; XDEF	OSRDCH
043E8F             10273  			; XDEF	PROMPT
043E8F             10274  			; XDEF	OSKEY
043E8F             10275  			; XDEF	TRAP
043E8F             10276  			; XDEF	LTRAP
043E8F             10277  			; XDEF	OSINIT
043E8F             10278  			; XDEF	OSCLI
043E8F             10279  			; XDEF	OSBPUT
043E8F             10280  			; XDEF	OSBGET
043E8F             10281  			; XDEF	OSSTAT
043E8F             10282  			; XDEF	OSSHUT
043E8F             10283  			; XDEF	OSOPEN
043E8F             10284  			; XDEF	OSCALL
043E8F             10285  			; XDEF	GETPTR
043E8F             10286  			; XDEF	PUTPTR
043E8F             10287  			; XDEF	GETEXT
043E8F             10288  			; XDEF	GETIMS
043E8F             10289  			; XDEF	RESET
043E8F             10290  			; XDEF	OSLOAD
043E8F             10291  			; XDEF	OSSAVE
043E8F             10292  			; XDEF	EXPR_W2
043E8F             10293  			; XDEF	STAR_VERSION
043E8F             10294  
043E8F             10295  			; XREF	_end			; In init.asm
043E8F             10296  
043E8F             10297  			; XREF	ASC_TO_NUMBER
043E8F             10298  			; XREF	RAM_START
043E8F             10299  			; XREF	RAM_END
043E8F             10300  			; XREF	FLAGS
043E8F             10301  			; XREF	ESCAPE
043E8F             10302  			; XREF	USER
043E8F             10303  			; XREF	RAM_Top
043E8F             10304  			; XREF	EXTERR
043E8F             10305  			; XREF	COUNT0
043E8F             10306  			; XREF	EXPRI
043E8F             10307  			; XREF	COMMA
043E8F             10308  			; XREF	XEQ
043E8F             10309  			; XREF	NXT
043E8F             10310  			; XREF	NULLTOCR
043E8F             10311  			; XREF	CRLF
043E8F             10312  			; XREF	CSTR_FNAME
043E8F             10313  			; XREF	CSTR_LINE
043E8F             10314  			; XREF	CSTR_FINDCH
043E8F             10315  			; XREF	CSTR_ENDSWITH
043E8F             10316  			; XREF	CSTR_CAT
043E8F             10317  			; XREF	FINDL
043E8F             10318  			; XREF	OUT_
043E8F             10319  			; XREF	ERROR_
043E8F             10320  			; XREF	ONEDIT
043E8F             10321  			; XREF	TELL
043E8F             10322  			; XREF	OSWRCHPT
043E8F             10323  			; XREF	OSWRCHCH
043E8F             10324  			; XREF	OSWRCHFH
043E8F             10325  			; XREF	LISTON
043E8F             10326  			; XREF	LISTIT
043E8F             10327  			; XREF	PAGE_
043E8F             10328  			; XREF	ONEDIT1
043E8F             10329  			; XREF	CLEAN
043E8F             10330  			; XREF	NEWIT
043E8F             10331  			; XREF	BAD
043E8F             10332  			; XREF	VBLANK_INIT
043E8F             10333  			; XREF	VBLANK_STOP
043E8F             10334  			; XREF	KEYDOWN
043E8F             10335  			; XREF	KEYASCII
043E8F             10336  			; XREF	WIDTH
043E8F             10337  			; XREF	ASSEM
043E8F             10338  
043E8F             10339  ; OSLINE: Invoke the line editor
043E8F             10340  ;
043E8F 1E 01       10341  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E91             10342  
043E91             10343  ; Entry point to line editor that does not clear the buffer
043E91             10344  ;
043E91 FD E5       10345  OSLINE1:		PUSH	IY
043E93 E5          10346  			PUSH	HL			; Buffer address
043E94 01 00 01 00 10347  			LD	BC, 256			; Buffer length
043E98             10348  			MOSCALL	mos_editline		; Call the MOS line editor
043E98 3E 09       0001M 			LD	A, function
043E9A 49 CF       0002M 			RST.LIS	08h
043E9C E1          10349  			POP	HL			; Pop the address
043E9D FD E1       10350  			POP	IY
043E9F F5          10351  			PUSH	AF			; Stack the return value (key pressed)
043EA0 CD 31 3E 04 10352  			CALL	NULLTOCR		; Turn the 0 character to a CR
043EA4 CD 77 39 04 10353  			CALL	CRLF			; Display CRLF
043EA8 F1          10354  			POP	AF
043EA9 FE 1B       10355  			CP	1Bh 			; Check if ESC terminated the input
043EAB CA A7 3F 04 10356  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043EAF 3A 42 4D 04 10357  			LD	A, (FLAGS)		; Otherwise
043EB3 CB BF       10358  			RES	7, A 			; Clear the escape flag
043EB5 32 42 4D 04 10359  			LD	(FLAGS), A
043EB9 CD 7E 41 04 10360  			CALL	WAIT_VBLANK 		; Wait a frame
043EBD AF          10361   			XOR	A			; Return A = 0
043EBE 32 47 4D 04 10362  			LD	(KEYDOWN), A
043EC2 32 48 4D 04 10363  			LD	(KEYASCII), A
043EC6 C9          10364  			RET
043EC7             10365  
043EC7             10366  ; PUTIME: set current time to DE:HL, in centiseconds.
043EC7             10367  ;
043EC7 DD E5       10368  PUTIME:			PUSH 	IX
043EC9             10369  			MOSCALL	mos_sysvars
043EC9 3E 08       0001M 			LD	A, function
043ECB 49 CF       0002M 			RST.LIS	08h
043ECD DD 75 00    10370  			LD	(IX + sysvar_time + 0), L
043ED0 DD 74 01    10371  			LD	(IX + sysvar_time + 1), H
043ED3 DD 73 02    10372  			LD	(IX + sysvar_time + 2), E
043ED6 DD 72 03    10373  			LD	(IX + sysvar_time + 3), D
043ED9 DD E1       10374  			POP	IX
043EDB C9          10375  			RET
043EDC             10376  
043EDC             10377  ; GETIME: return current time in DE:HL, in centiseconds
043EDC             10378  ;
043EDC DD E5       10379  GETIME:			PUSH 	IX
043EDE             10380  			MOSCALL	mos_sysvars
043EDE 3E 08       0001M 			LD	A, function
043EE0 49 CF       0002M 			RST.LIS	08h
043EE2 DD 6E 00    10381  			LD	L, (IX + sysvar_time + 0)
043EE5 DD 66 01    10382  			LD	H, (IX + sysvar_time + 1)
043EE8 DD 5E 02    10383  			LD	E, (IX + sysvar_time + 2)
043EEB DD 56 03    10384  			LD	D, (IX + sysvar_time + 3)
043EEE DD E1       10385  			POP	IX
043EF0 C9          10386  			RET
043EF1             10387  
043EF1             10388  ; PUTCSR: move to cursor to x=DE, y=HL
043EF1             10389  ;
043EF1 3E 1F       10390  PUTCSR:			LD	A, 1Fh			; TAB
043EF3 5B D7       10391  			RST.LIL	10h
043EF5 7B          10392  			LD	A, E			; X
043EF6 5B D7       10393  			RST.LIL 10h
043EF8 7D          10394  			LD	A, L			; Y
043EF9 5B D7       10395  			RST.LIL 10h
043EFB C9          10396  			RET
043EFC             10397  
043EFC             10398  ; GETCSR: return cursor position in x=DE, y=HL
043EFC             10399  ;
043EFC DD E5       10400  GETCSR:			PUSH	IX			; Get the system vars in IX
043EFE             10401  			MOSCALL	mos_sysvars		; Reset the semaphore
043EFE 3E 08       0001M 			LD	A, function
043F00 49 CF       0002M 			RST.LIS	08h
043F02 DD CB 04 86 10402  			RES	0, (IX+sysvar_vpd_pflags)
043F06             10403  			VDU	23
043F06 3E 17       0001M 		LD	A, val
043F08 CD 30 3F 04 0002M 		CALL	OSWRCH
043F0C             10404  			VDU	0
043F0C 3E 00       0001M 		LD	A, val
043F0E CD 30 3F 04 0002M 		CALL	OSWRCH
043F12             10405  			VDU	vdp_cursor
043F12 3E 82       0001M 		LD	A, val
043F14 CD 30 3F 04 0002M 		CALL	OSWRCH
043F18 DD CB 04 46 10406  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F1C 28 FA       10407  			JR	Z, @B			; Wait for the result
043F1E 16 00       10408  			LD 	D, 0
043F20 62          10409  			LD	H, D
043F21 DD 5E 07    10410  			LD	E, (IX + sysvar_cursorX)
043F24 DD 6E 08    10411  			LD	L, (IX + sysvar_cursorY)
043F27 DD E1       10412  			POP	IX
043F29 C9          10413  			RET
043F2A             10414  
043F2A             10415  ; PROMPT: output the input prompt
043F2A             10416  ;
043F2A 3E 3E       10417  PROMPT: 		LD	A,'>'
043F2C C3 30 3F 04 10418  			JP	OSWRCH
043F30             10419  
043F30             10420  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F30             10421  ; A: Character to write
043F30             10422  ;
043F30 E5          10423  OSWRCH:			PUSH	HL
043F31 21 40 4D 04 10424  			LD	HL, LISTON		; Fetch the LISTON variable
043F35 CB 5E       10425  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F37 20 0B       10426  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F39             10427  ;
043F39 2A 45 4D 04 10428  			LD	HL, (OSWRCHCH)		; L: Channel #
043F3D 2D          10429  			DEC	L			; If it is 1
043F3E 28 10       10430  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F40             10431  ;
043F40 E1          10432  			POP	HL			; Otherwise
043F41 5B D7       10433  			RST.LIL	10h			; Output the character to MOS
043F43 C9          10434  			RET
043F44             10435  ;
043F44 2A 43 4D 04 10436  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F48 77          10437  			LD	(HL), A			; Echo the character into the buffer
043F49 23          10438  			INC	HL			; Increment pointer
043F4A 22 43 4D 04 10439  			LD	(OSWRCHPT), HL		; Write pointer back
043F4E E1          10440  			POP	HL
043F4F C9          10441  			RET
043F50             10442  ;
043F50 D5          10443  OSWRCH_FILE:		PUSH	DE
043F51 5C          10444  			LD	E, H			; Filehandle to E
043F52 CD 7C 43 04 10445  			CALL	OSBPUT			; Write the byte out
043F56 D1          10446  			POP	DE
043F57 E1          10447  			POP	HL
043F58 C9          10448  			RET
043F59             10449  
043F59             10450  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F59             10451  ; This is only called in GETS (eval.asm)
043F59             10452  ;
043F59             10453  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F59 3E 00       0001M 			LD	A, function
043F5B 49 CF       0002M 			RST.LIS	08h
043F5D FE 1B       10454  			CP	1Bh
043F5F 28 46       10455  			JR	Z, LTRAP1
043F61 C9          10456  			RET
043F62             10457  
043F62             10458  
043F62             10459  ;OSKEY - Read key with time-limit, test for ESCape.
043F62             10460  ;Main function is carried out in user patch.
043F62             10461  ;   Inputs: HL = time limit (centiseconds)
043F62             10462  ;  Outputs: Carry reset if time-out
043F62             10463  ;           If carry set A = character
043F62             10464  ; Destroys: A,H,L,F
043F62             10465  ;
043F62 CD 93 3F 04 10466  OSKEY:			CALL	READKEY			; Read the keyboard
043F66 28 0A       10467  			JR	Z, @F 			; Skip if we have a key
043F68 7C          10468  			LD	A, H 			; Check loop counter
043F69 B5          10469  			OR 	L
043F6A C8          10470  			RET 	Z 			; Return, we've not got a key at this point
043F6B CD 7E 41 04 10471  			CALL	WAIT_VBLANK 		; Wait a frame
043F6F 2B          10472  			DEC 	HL			; Decrement
043F70 18 F0       10473  			JR	OSKEY 			; And loop
043F72             10474  ;
043F72 21 47 4D 04 10475  @@:			LD	HL, KEYDOWN		; We have a key, so
043F76 36 00       10476  			LD	(HL), 0			; clear the keydown flag
043F78 FE 1B       10477  			CP	1BH			; If we are not pressing ESC,
043F7A 37          10478  			SCF 				; then flag we've got a character
043F7B C0          10479  			RET	NZ
043F7C             10480  ;
043F7C             10481  ; ESCSET
043F7C             10482  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043F7C             10483  ;
043F7C E5          10484  ESCSET: 		PUSH    HL
043F7D 21 42 4D 04 10485          		LD      HL,FLAGS		; Pointer to FLAGS
043F81 CB 76       10486          		BIT     6,(HL)			; If bit 6 is set, then
043F83 20 02       10487          		JR      NZ,ESCDIS		; escape is disabled, so skip
043F85 CB FE       10488          		SET     7,(HL)			; Set bit 7, the escape flag
043F87 E1          10489  ESCDIS: 		POP     HL
043F88 C9          10490          		RET
043F89             10491  ;
043F89             10492  ; ESCTEST
043F89             10493  ; Test for ESC key
043F89             10494  ;
043F89 CD 93 3F 04 10495  ESCTEST:		CALL	READKEY			; Read the keyboard
043F8D C0          10496  			RET	NZ			; Skip if no key is pressed
043F8E FE 1B       10497  			CP	1BH			; If ESC pressed then
043F90 28 EA       10498  			JR	Z,ESCSET		; jump to the escape set routine
043F92 C9          10499  			RET
043F93             10500  
043F93             10501  ; Read the keyboard
043F93             10502  ; Returns:
043F93             10503  ; - A: ASCII of the pressed key
043F93             10504  ; - F: Z if the key is pressed, otherwise NZ
043F93             10505  ;
043F93 3A 47 4D 04 10506  READKEY:		LD	A, (KEYDOWN)		; Get key down
043F97 3D          10507  			DEC	A 			; Set Z flag if keydown is 1
043F98 3A 48 4D 04 10508  			LD	A, (KEYASCII)		; Get key ASCII value
043F9C C9          10509  			RET
043F9D             10510  ;
043F9D             10511  ; TRAP
043F9D             10512  ; This is called whenever BASIC needs to check for ESC
043F9D             10513  ;
043F9D CD 89 3F 04 10514  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FA1             10515  ;
043FA1 3A 42 4D 04 10516  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FA5 B7          10517  			OR	A			; This checks for bit 7; if it is not set then the result will
043FA6 F0          10518  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FA7 21 42 4D 04 10519  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FAB CB BE       10520  			RES	7,(HL)			; Clear the escape pressed flag and
043FAD C3 9B 0C 04 10521  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FB1             10522  
043FB1             10523  ;OSINIT - Initialise RAM mapping etc.
043FB1             10524  ;If BASIC is entered by BBCBASIC FILENAME then file
043FB1             10525  ;FILENAME.BBC is automatically CHAINed.
043FB1             10526  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043FB1             10527  ;            HL = initial value of PAGE (user program)
043FB1             10528  ;            Z-flag reset indicates AUTO-RUN.
043FB1             10529  ;  Destroys: A,D,E,H,L,F
043FB1             10530  ;
043FB1 CD 16 49 04 10531  OSINIT:			CALL	VBLANK_INIT
043FB5 AF          10532  			XOR	A
043FB6 21 00 4E 04 10533  			LD 	HL, USER
043FBA 11 00 00 0B 10534  			LD	DE, RAM_Top
043FBE 5F          10535  			LD	E, A			; Page boundary
043FBF C9          10536  			RET
043FC0             10537  
043FC0             10538  ;
043FC0             10539  ;OSCLI - Process a MOS command
043FC0             10540  ;
043FC0 CD 34 40 04 10541  OSCLI: 			CALL    SKIPSP
043FC4 FE 0D       10542  			CP      CR
043FC6 C8          10543  			RET     Z
043FC7 FE 7C       10544  			CP      '|'
043FC9 C8          10545  			RET     Z
043FCA EB          10546  			EX      DE,HL
043FCB 21 43 40 04 10547  			LD      HL,COMDS
043FCF 1A          10548  OSCLI0:			LD      A,(DE)
043FD0 CD 3B 40 04 10549  			CALL    UPPRC
043FD4 BE          10550  			CP      (HL)
043FD5 28 0B       10551  			JR      Z,OSCLI2
043FD7 38 30       10552  			JR      C,OSCLI6
043FD9 CB 7E       10553  OSCLI1:			BIT     7,(HL)
043FDB 23          10554  			INC     HL
043FDC 28 FB       10555  			JR      Z,OSCLI1
043FDE 23          10556  			INC     HL
043FDF 23          10557  			INC     HL
043FE0 18 ED       10558  			JR      OSCLI0
043FE2             10559  ;
043FE2 D5          10560  OSCLI2:			PUSH    DE
043FE3 13          10561  OSCLI3:			INC     DE
043FE4 23          10562  			INC     HL
043FE5 1A          10563  			LD      A,(DE)
043FE6 CD 3B 40 04 10564  			CALL    UPPRC
043FEA FE 2E       10565  			CP      '.'			; ABBREVIATED?
043FEC 28 0A       10566  			JR      Z,OSCLI4
043FEE AE          10567  			XOR     (HL)
043FEF 28 F2       10568  			JR      Z,OSCLI3
043FF1 FE 80       10569  			CP      80H
043FF3 28 03       10570  			JR      Z,OSCLI4
043FF5 D1          10571  			POP     DE
043FF6 18 E1       10572  			JR      OSCLI1
043FF8             10573  ;
043FF8 F1          10574  OSCLI4:			POP     AF
043FF9 13          10575  		        INC     DE
043FFA CB 7E       10576  OSCLI5:			BIT     7,(HL)
043FFC 23          10577  			INC     HL
043FFD 28 FB       10578  			JR      Z,OSCLI5
043FFF 7E          10579  			LD      A,(HL)
044000 23          10580  			INC     HL
044001 66          10581  			LD      H,(HL)
044002 6F          10582  			LD      L,A
044003 E5          10583  			PUSH    HL
044004 EB          10584  			EX      DE,HL
044005 C3 34 40 04 10585  			JP      SKIPSP
044009             10586  ;
044009 EB          10587  OSCLI6:			EX	DE, HL			; HL: Buffer for command
04400A 11 00 4A 04 10588  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
04400E D5          10589  			PUSH	DE			; Store buffer address
04400F CD 5B 3E 04 10590  			CALL	CSTR_LINE		; Fetch the line
044013 E1          10591  			POP	HL			; HL: Pointer to command string in ACCS
044014 FD E5       10592  			PUSH	IY
044016             10593  			MOSCALL	mos_oscli		; Returns OSCLI error in A
044016 3E 10       0001M 			LD	A, function
044018 49 CF       0002M 			RST.LIS	08h
04401A FD E1       10594  			POP	IY
04401C B7          10595  			OR	A			; 0 means MOS returned OK
04401D C8          10596  			RET	Z			; So don't do anything
04401E C3 58 42 04 10597  			JP 	OSERROR			; Otherwise it's a MOS error
044022             10598  
044022 3E FE       10599  HUH:    		LD      A,254			; Bad command error
044024 CD A7 37 04 10600          		CALL    EXTERR
044028 42 61 64 20 10601          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044033 00          10602          		DEFB    0
044034             10603  
044034 7E          10604  SKIPSP:			LD      A,(HL)
044035 FE 20       10605          		CP      ' '
044037 C0          10606          		RET     NZ
044038 23          10607          		INC     HL
044039 18 F9       10608          		JR      SKIPSP
04403B             10609  
04403B E6 7F       10610  UPPRC:  		AND     7FH
04403D FE 60       10611  			CP      '`'
04403F D8          10612  			RET     C
044040 E6 5F       10613  			AND     5FH			; CONVERT TO UPPER CASE
044042 C9          10614  			RET
044043             10615  
044043             10616  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044043             10617  ; These must be in alphabetical order
044043             10618  ;
044043 41 53 4D    10619  COMDS:  		DB	"AS","M"+80h		; ASM
044046 61 40       10620  			DW	STAR_ASM
044048 42 59 45    10621  			DB	"BY","E"+80h		; BYE
04404B 6D 40       10622  			DW	STAR_BYE
04404D 45 44 49 54 10623  			DB	"EDI","T"+80h		; EDIT
044051 A2 40       10624  			DW	STAR_EDIT
044053 46 58       10625  			DB	"F","X"+80h		; FX
044055 E2 40       10626  			DW	STAR_FX
044057 56 45 52 53 10627  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
04405E 79 40       10628  			DW	STAR_VERSION
044060 FF          10629  			DB	FFh
044061             10630  
044061             10631  ; *ASM string
044061             10632  ;
044061 FD E5       10633  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044063 E5          10634  			PUSH	HL			; HL = IY
044064 FD E1       10635  			POP	IY
044066 CD C5 18 04 10636  			CALL	ASSEM			; Invoke the assembler
04406A FD E1       10637  			POP	IY
04406C C9          10638  			RET
04406D             10639  
04406D             10640  ; *BYE
04406D             10641  ;
04406D CD 2A 49 04 10642  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044071 21 00 00 00 10643  			LD	HL, 0			; The return value
044075 C3 68 00 04 10644  			JP	_end 			; Jump back to the end routine in init.asm
044079             10645  
044079             10646  ; *VERSION
044079             10647  ;
044079 CD C0 3D 04 10648  STAR_VERSION:		CALL    TELL			; Output the welcome message
04407D 42 42 43 20 10649  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0440A1 C9          10650  			RET
0440A2             10651  
0440A2             10652  ; *EDIT linenum
0440A2             10653  ;
0440A2 CD C7 3D 04 10654  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440A6 EB          10655  			EX	DE, HL			; HL: Line number
0440A7 CD BF 39 04 10656  			CALL	FINDL			; HL: Address in RAM of tokenised line
0440AB 3E 29       10657  			LD	A, 41			; F:NZ If the line is not found
0440AD C2 90 37 04 10658  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0440B1             10659  ;
0440B1             10660  ; Use LISTIT to output the line to the ACCS buffer
0440B1             10661  ;
0440B1 23          10662  			INC	HL			; Skip the length byte
0440B2 5E          10663  			LD	E, (HL)			; Fetch the line number
0440B3 23          10664  			INC	HL
0440B4 56          10665  			LD	D, (HL)
0440B5 23          10666  			INC	HL
0440B6 DD 21 00 4A 10667  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0440BB DD 22 43 4D 10668  			LD	(OSWRCHPT), IX
       04          
0440C0 DD 21 40 4D 10669  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0440C5 DD 7E 00    10670  			LD	A, (IX)			; Store that variable
0440C8 F5          10671  			PUSH	AF
0440C9 DD 36 00 09 10672  			LD	(IX), 09h		; Set to echo to buffer
0440CD CD C2 38 04 10673  			CALL	LISTIT
0440D1 F1          10674  			POP	AF
0440D2 DD 77 00    10675  			LD	(IX), A			; Restore the original LISTON variable
0440D5 21 00 4A 04 10676  			LD	HL, ACCS		; HL: ACCS
0440D9 5D          10677  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0440DA CD 91 3E 04 10678  			CALL	OSLINE1			; Invoke the editor
0440DE C3 00 31 04 10679  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440E2             10680  
0440E2             10681  ; OSCLI FX n
0440E2             10682  ;
0440E2 CD C7 3D 04 10683  STAR_FX:		CALL	ASC_TO_NUMBER
0440E6 4B          10684  			LD	C, E			; C: Save FX #
0440E7 CD C7 3D 04 10685  			CALL	ASC_TO_NUMBER
0440EB 7A          10686  			LD	A, D  			; Is first parameter > 255?
0440EC B7          10687  			OR 	A
0440ED 28 03       10688  			JR	Z, STAR_FX1		; Yes, so skip next bit
0440EF EB          10689  			EX	DE, HL 			; Parameter is 16-bit
0440F0 18 07       10690  			JR	STAR_FX2
0440F2             10691  ;
0440F2 43          10692  STAR_FX1:		LD	B, E 			; B: Save First parameter
0440F3 CD C7 3D 04 10693  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0440F7 68          10694  			LD	L, B 			; L: First parameter
0440F8 63          10695  			LD	H, E 			; H: Second parameter
0440F9             10696  ;
0440F9 79          10697  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0440FA             10698  ;
0440FA             10699  ; OSBYTE
0440FA             10700  ;  A: FX #
0440FA             10701  ;  L: First parameter
0440FA             10702  ;  H: Second parameter
0440FA             10703  ;
0440FA FE 0B       10704  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0440FC 28 18       10705  			JR	Z, OSBYTE_0B
0440FE FE 0C       10706  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044100 28 43       10707  			JR	Z, OSBYTE_0C
044102 FE 13       10708  			CP	13H			; *FX 19: Wait for vblank
044104 28 6E       10709  			JR	Z, OSBYTE_13
044106 FE 76       10710  			CP	76H			; *FX 118, n: Set keyboard LED
044108 CA 8F 41 04 10711  			JP	Z, OSBYTE_76
04410C FE A0       10712  			CP	A0H
04410E CA BF 41 04 10713  			JP	Z, OSBYTE_A0
044112 C3 22 40 04 10714  			JP	HUH			; Anything else trips an error
044116             10715  
044116             10716  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
044116             10717  ; Parameters:
044116             10718  ; - HL: Repeat delay
044116             10719  ;
044116             10720  OSBYTE_0B:		VDU	23
044116 3E 17       0001M 		LD	A, val
044118 CD 30 3F 04 0002M 		CALL	OSWRCH
04411C             10721  			VDU	0
04411C 3E 00       0001M 		LD	A, val
04411E CD 30 3F 04 0002M 		CALL	OSWRCH
044122             10722  			VDU	vdp_keystate
044122 3E 88       0001M 		LD	A, val
044124 CD 30 3F 04 0002M 		CALL	OSWRCH
044128             10723  			VDU	L
044128 7D          0001M 		LD	A, val
044129 CD 30 3F 04 0002M 		CALL	OSWRCH
04412D             10724  			VDU	H
04412D 7C          0001M 		LD	A, val
04412E CD 30 3F 04 0002M 		CALL	OSWRCH
044132             10725  			VDU	0
044132 3E 00       0001M 		LD	A, val
044134 CD 30 3F 04 0002M 		CALL	OSWRCH
044138             10726  			VDU 	0
044138 3E 00       0001M 		LD	A, val
04413A CD 30 3F 04 0002M 		CALL	OSWRCH
04413E             10727  			VDU	255
04413E 3E FF       0001M 		LD	A, val
044140 CD 30 3F 04 0002M 		CALL	OSWRCH
044144 C9          10728  			RET
044145             10729  
044145             10730  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
044145             10731  ; Parameters:
044145             10732  ; - HL: Repeat rate
044145             10733  ;
044145             10734  OSBYTE_0C:		VDU	23
044145 3E 17       0001M 		LD	A, val
044147 CD 30 3F 04 0002M 		CALL	OSWRCH
04414B             10735  			VDU	0
04414B 3E 00       0001M 		LD	A, val
04414D CD 30 3F 04 0002M 		CALL	OSWRCH
044151             10736  			VDU	vdp_keystate
044151 3E 88       0001M 		LD	A, val
044153 CD 30 3F 04 0002M 		CALL	OSWRCH
044157             10737  			VDU	0
044157 3E 00       0001M 		LD	A, val
044159 CD 30 3F 04 0002M 		CALL	OSWRCH
04415D             10738  			VDU 	0
04415D 3E 00       0001M 		LD	A, val
04415F CD 30 3F 04 0002M 		CALL	OSWRCH
044163             10739  			VDU	L
044163 7D          0001M 		LD	A, val
044164 CD 30 3F 04 0002M 		CALL	OSWRCH
044168             10740  			VDU	H
044168 7C          0001M 		LD	A, val
044169 CD 30 3F 04 0002M 		CALL	OSWRCH
04416D             10741  			VDU	255
04416D 3E FF       0001M 		LD	A, val
04416F CD 30 3F 04 0002M 		CALL	OSWRCH
044173 C9          10742  			RET
044174             10743  
044174             10744  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
044174             10745  ;
044174 CD 7E 41 04 10746  OSBYTE_13:		CALL	WAIT_VBLANK
044178 2E 00       10747  			LD	L, 0			; Returns 0
04417A C3 7F 05 04 10748  			JP	COUNT0
04417E             10749  ;
04417E DD E5       10750  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
044180             10751  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044180 3E 08       0001M 			LD	A, function
044182 49 CF       0002M 			RST.LIS	08h
044184 DD 7E 00    10752  			LD	A, (IX + sysvar_time + 0)
044187 DD BE 00    10753  @@:			CP 	A, (IX + sysvar_time + 0)
04418A 28 FB       10754  			JR	Z, @B
04418C DD E1       10755  			POP	IX
04418E C9          10756  			RET
04418F             10757  
04418F             10758  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
04418F             10759  ; Parameters:
04418F             10760  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
04418F             10761  ;
04418F             10762  OSBYTE_76:		VDU	23
04418F 3E 17       0001M 		LD	A, val
044191 CD 30 3F 04 0002M 		CALL	OSWRCH
044195             10763  			VDU	0
044195 3E 00       0001M 		LD	A, val
044197 CD 30 3F 04 0002M 		CALL	OSWRCH
04419B             10764  			VDU	vdp_keystate
04419B 3E 88       0001M 		LD	A, val
04419D CD 30 3F 04 0002M 		CALL	OSWRCH
0441A1             10765  			VDU	0
0441A1 3E 00       0001M 		LD	A, val
0441A3 CD 30 3F 04 0002M 		CALL	OSWRCH
0441A7             10766  			VDU 	0
0441A7 3E 00       0001M 		LD	A, val
0441A9 CD 30 3F 04 0002M 		CALL	OSWRCH
0441AD             10767  			VDU	0
0441AD 3E 00       0001M 		LD	A, val
0441AF CD 30 3F 04 0002M 		CALL	OSWRCH
0441B3             10768  			VDU	0
0441B3 3E 00       0001M 		LD	A, val
0441B5 CD 30 3F 04 0002M 		CALL	OSWRCH
0441B9             10769  			VDU	L
0441B9 7D          0001M 		LD	A, val
0441BA CD 30 3F 04 0002M 		CALL	OSWRCH
0441BE C9          10770  			RET
0441BF             10771  
0441BF             10772  ; OSBYTE 0xA0: Fetch system variable
0441BF             10773  ; Parameters:
0441BF             10774  ; - L: The system variable to fetch
0441BF             10775  ;
0441BF DD E5       10776  OSBYTE_A0:		PUSH	IX
0441C1             10777  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441C1 3E 08       0001M 			LD	A, function
0441C3 49 CF       0002M 			RST.LIS	08h
0441C5 01 00 00 00 10778  			LD	BC, 0
0441C9 4D          10779  			LD	C, L			; BCU = L
0441CA DD 09       10780  			ADD	IX, BC			; Add to IX
0441CC DD 6E 00    10781  			LD	L, (IX + 0)		; Fetch the return value
0441CF DD E1       10782  			POP	IX
0441D1 C3 7F 05 04 10783  			JP 	COUNT0
0441D5             10784  
0441D5             10785  ;OSLOAD - Load an area of memory from a file.
0441D5             10786  ;   Inputs: HL addresses filename (CR terminated)
0441D5             10787  ;           DE = address at which to load
0441D5             10788  ;           BC = maximum allowed size (bytes)
0441D5             10789  ;  Outputs: Carry reset indicates no room for file.
0441D5             10790  ; Destroys: A,B,C,D,E,H,L,F
0441D5             10791  ;
0441D5 C5          10792  OSLOAD:			PUSH	BC			; Stack the size
0441D6 D5          10793  			PUSH	DE			; Stack the load address
0441D7 11 00 4A 04 10794  			LD	DE, ACCS		; Buffer address for filename
0441DB CD 49 3E 04 10795  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0441DF 21 00 4A 04 10796  			LD	HL, ACCS		; HL: Filename
0441E3 CD D5 42 04 10797  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441E7 CD E9 42 04 10798  			CALL	EXT_HANDLER		; Get the default handler
0441EB D1          10799  			POP	DE			; Restore the load address
0441EC C1          10800  			POP	BC			; Restore the size
0441ED B7          10801  			OR	A
0441EE 28 60       10802  			JR 	Z, OSLOAD_BBC
0441F0             10803  ;
0441F0             10804  ; Load the file in as a text file
0441F0             10805  ;
0441F0 AF          10806  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441F1 CD 5D 43 04 10807  			CALL	OSOPEN			; Open the file
0441F5 5F          10808  			LD 	E, A 			; The filehandle
0441F6 B7          10809  			OR	A
0441F7 3E 04       10810  			LD	A, 4			; File not found error
0441F9 28 5D       10811  			JR	Z, OSERROR		; Jump to error handler
0441FB CD 9C 38 04 10812  			CALL	NEWIT			; Call NEW to clear the program space
0441FF             10813  ;
0441FF 21 00 4A 04 10814  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044203             10815  ;
044203             10816  ; First skip any whitespace (indents) at the beginning of the input
044203             10817  ;
044203 CD 74 43 04 10818  @@:			CALL	OSBGET			; Read the byte into A
044207 38 1E       10819  			JR	C, OSLOAD_TXT3		; Is it EOF?
044209 FE 0A       10820  			CP	LF 			; Is it LF?
04420B 28 1A       10821  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
04420D FE 21       10822  			CP	21h			; Is it less than or equal to ASCII space?
04420F 38 F2       10823  			JR	C, @B 			; Yes, so keep looping
044211 77          10824  			LD	(HL), A 		; Store the first character
044212 2C          10825  			INC	L
044213             10826  ;
044213             10827  ; Now read the rest of the line in
044213             10828  ;
044213 CD 74 43 04 10829  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
044217 38 2B       10830  			JR	C, OSLOAD_TXT4		; Is it EOF?
044219 FE 20       10831  			CP	20h			; Skip if not an ASCII character
04421B 38 06       10832  			JR	C, @F
04421D 77          10833  			LD	(HL), A 		; Store in the input buffer
04421E 2C          10834  			INC	L			; Increment the buffer pointer
04421F CA 28 37 04 10835  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044223 FE 0A       10836  @@:			CP	LF			; Check for LF
044225 20 EC       10837  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
044227             10838  ;
044227             10839  ; Finally, handle EOL/EOF
044227             10840  ;
044227 36 0D       10841  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
044229 7D          10842  			LD	A, L			; Check for minimum line length
04422A FE 02       10843  			CP	2			; If it is 2 characters or less (including CR)
04422C 38 0A       10844  			JR	C, @F			; Then don't bother entering it
04422E D5          10845  			PUSH	DE			; Preserve the filehandle
04422F CD 0C 31 04 10846  			CALL	ONEDIT1			; Enter the line in memory
044233 DC 6F 38 04 10847  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
044237 D1          10848  			POP	DE
044238 CD 85 43 04 10849  @@:			CALL	OSSTAT			; End of file?
04423C 20 C1       10850  			JR	NZ, OSLOAD_TXT1		; No, so loop
04423E CD 6C 43 04 10851  			CALL	OSSHUT			; Close the file
044242 37          10852  			SCF				; Flag to BASIC that we're good
044243 C9          10853  			RET
044244             10854  ;
044244             10855  ; Special case for BASIC programs with no blank line at the end
044244             10856  ;
044244 FE 20       10857  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044246 38 06       10858  			JR	C, @F
044248 77          10859  			LD	(HL), A			; Store the character
044249 2C          10860  			INC	L
04424A CA 28 37 04 10861  			JP	Z, BAD
04424E 18 D7       10862  @@:			JR	OSLOAD_TXT3
044250             10863  
044250             10864  ;
044250             10865  ; Load the file in as a tokenised binary blob
044250             10866  ;
044250             10867  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044250 3E 01       0001M 			LD	A, function
044252 49 CF       0002M 			RST.LIS	08h
044254 D0          10868  			RET	NC			; If load returns with carry reset - NO ROOM
044255 B7          10869  			OR	A			; If there is no error (A=0)
044256 37          10870  			SCF				; Need to set carry indicating there was room
044257 C8          10871  			RET	Z			; Return
044258             10872  ;
044258 F5          10873  OSERROR:		PUSH	AF			; Handle the MOS error
044259 21 00 4A 04 10874  			LD	HL, ACCS		; Address of the buffer
04425D 01 00 01 00 10875  			LD	BC, 256			; Length of the buffer
044261 5F          10876  			LD	E, A			; The error code
044262             10877  			MOSCALL	mos_getError		; Copy the error message into the buffer
044262 3E 0F       0001M 			LD	A, function
044264 49 CF       0002M 			RST.LIS	08h
044266 F1          10878  			POP	AF
044267 E5          10879  			PUSH	HL			; Stack the address of the error (now in ACCS)
044268 C6 7F       10880  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
04426A C3 A7 37 04 10881  			JP	EXTERR			; Trigger an external error
04426E             10882  
04426E             10883  ;OSSAVE - Save an area of memory to a file.
04426E             10884  ;   Inputs: HL addresses filename (term CR)
04426E             10885  ;           DE = start address of data to save
04426E             10886  ;           BC = length of data to save (bytes)
04426E             10887  ; Destroys: A,B,C,D,E,H,L,F
04426E             10888  ;
04426E C5          10889  OSSAVE:			PUSH	BC			; Stack the size
04426F D5          10890  			PUSH	DE			; Stack the save address
044270 11 00 4A 04 10891  			LD	DE, ACCS		; Buffer address for filename
044274 CD 49 3E 04 10892  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044278 21 00 4A 04 10893  			LD	HL, ACCS		; HL: Filename
04427C CD D5 42 04 10894  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044280 CD E9 42 04 10895  			CALL	EXT_HANDLER		; Get the default handler
044284 D1          10896  			POP	DE			; Restore the save address
044285 C1          10897  			POP	BC			; Restore the size
044286 B7          10898  			OR	A			; Is the extension .BBC
044287 28 44       10899  			JR	Z, OSSAVE_BBC		; Yes, so use that
044289             10900  ;
044289             10901  ; Save the file out as a text file
044289             10902  ;
044289 3A 45 4D 04 10903  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
04428D F5          10904  			PUSH	AF
04428E AF          10905  			XOR	A
04428F 3C          10906  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
044290 32 45 4D 04 10907  			LD	(OSWRCHCH), A
044294 CD 5D 43 04 10908  			CALL	OSOPEN			; Open the file
044298 32 46 4D 04 10909  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
04429C DD 21 40 4D 10910  			LD	IX, LISTON		; Required for LISTIT
       04          
0442A1 2A 14 4D 04 10911  			LD	HL, (PAGE_)		; Get start of program area
0442A5 D9          10912  			EXX
0442A6 01 00 00 00 10913  			LD	BC, 0			; Set the initial indent counters
0442AA D9          10914  			EXX
0442AB 7E          10915  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442AC B7          10916  			OR	A
0442AD 28 0F       10917  			JR	Z, OSSAVE_TXT2
0442AF 23          10918  			INC	HL			; Skip the length byte
0442B0 11 00 00 00 10919  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442B4 5E          10920  			LD	E, (HL)			; Get the line number
0442B5 23          10921  			INC	HL
0442B6 56          10922  			LD	D, (HL)
0442B7 23          10923  			INC	HL
0442B8 CD C2 38 04 10924  			CALL	LISTIT			; List the line
0442BC 18 ED       10925  			JR	OSSAVE_TXT1
0442BE 3A 46 4D 04 10926  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442C2 5F          10927  			LD	E, A
0442C3 CD 6C 43 04 10928  			CALL	OSSHUT			; Close it
0442C7 F1          10929  			POP	AF			; Restore the channel
0442C8 32 45 4D 04 10930  			LD	(OSWRCHCH), A
0442CC C9          10931  			RET
0442CD             10932  ;
0442CD             10933  ; Save the file out as a tokenised binary blob
0442CD             10934  ;
0442CD             10935  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442CD 3E 02       0001M 			LD	A, function
0442CF 49 CF       0002M 			RST.LIS	08h
0442D1 B7          10936  			OR	A			; If there is no error (A=0)
0442D2 C8          10937  			RET	Z			; Just return
0442D3 18 83       10938  			JR	OSERROR			; Trip an error
0442D5             10939  
0442D5             10940  ; Check if an extension is specified in the filename
0442D5             10941  ; Add a default if not specified
0442D5             10942  ; HL: Filename (CSTR format)
0442D5             10943  ;
0442D5 E5          10944  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442D6 0E 2E       10945  			LD	C, '.'			; Search for dot (marks start of extension)
0442D8 CD 69 3E 04 10946  			CALL	CSTR_FINDCH
0442DC B7          10947  			OR	A			; Check for end of string marker
0442DD 20 08       10948  			JR	NZ, @F			; No, so skip as we have an extension at this point
0442DF 11 19 43 04 10949  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442E3 CD 80 3E 04 10950  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442E7 E1          10951  @@:			POP	HL			; Restore the filename pointer
0442E8 C9          10952  			RET
0442E9             10953  
0442E9             10954  ; Check if an extension is valid and, if so, provide a pointer to a handler
0442E9             10955  ; HL: Filename (CSTR format)
0442E9             10956  ; Returns:
0442E9             10957  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0442E9             10958  ;
0442E9 E5          10959  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442EA 0E 2E       10960  			LD	C, '.'			; Find the '.'
0442EC CD 69 3E 04 10961  			CALL	CSTR_FINDCH
0442F0 11 19 43 04 10962  			LD	DE, EXT_LOOKUP		; The lookup table
0442F4             10963  ;
0442F4 E5          10964  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442F5 CD 71 3E 04 10965  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442F9 E1          10966  			POP	HL			; Restore the pointer to the extension
0442FA 28 19       10967  			JR	Z, EXT_HANDLER_2	; We have a match!
0442FC             10968  ;
0442FC 1A          10969  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0442FD 13          10970  			INC	DE
0442FE B7          10971  			OR	A
0442FF 20 FB       10972  			JR	NZ, @B
044301 13          10973  			INC	DE			; Skip the file extension # byte
044302             10974  ;
044302 1A          10975  			LD	A, (DE)			; Are we at the end of the table?
044303 B7          10976  			OR	A
044304 20 EE       10977  			JR	NZ, EXT_HANDLER_1	; No, so loop
044306             10978  ;
044306 3E CC       10979  			LD      A,204			; Throw a "Bad name" error
044308 CD A7 37 04 10980          		CALL    EXTERR
04430C 42 61 64 20 10981          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
044315             10982  ;
044315 13          10983  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
044316 1A          10984  			LD	A, (DE)
044317 E1          10985  			POP	HL			; Restore the filename pointer
044318 C9          10986  			RET
044319             10987  ;
044319             10988  
044319             10989  
044319             10990  ; Extension lookup table
044319             10991  ; CSTR, TYPE
044319             10992  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
044319             10993  ; 	- 1: Human readable plain text
044319             10994  ;
044319 2E 42 42 43 10995  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
04431F 2E 54 58 54 10996  			DB	".TXT", 0, 1
       00 01       
044325 2E 41 53 43 10997  			DB	".ASC", 0, 1
       00 01       
04432B 2E 42 41 53 10998  			DB	".BAS", 0, 1
       00 01       
044331 00          10999  			DB	0			; End of table
044332             11000  
044332             11001  ;OSCALL - Intercept page &FF calls and provide an alternative address
044332             11002  ;
044332             11003  ;&FFF7:	OSCLI	Execute *command.
044332             11004  ;&FFF4:	OSBYTE	Various byte-wide functions.
044332             11005  ;&FFF1:	OSWORD	Various control block functions.
044332             11006  ;&FFEE:	OSWRCH	Write character to output stream.
044332             11007  ;&FFE7:	OSNEWL	Write NewLine to output stream.
044332             11008  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
044332             11009  ;&FFE0:	OSRDCH	Wait for character from input stream.
044332             11010  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
044332             11011  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
044332             11012  ;&FFD7:	OSBGET	Read a byte from an a channel.
044332             11013  ;&FFD4:	OSBPUT	Write a byte to a channel.
044332             11014  ;&FFD1:	OSGBPB	Read and write blocks of data.
044332             11015  ;&FFCE:	OSFIND	Open or close a file.
044332             11016  ;
044332 21 48 43 04 11017  OSCALL:			LD	HL, OSCALL_TABLE
044336 7E          11018  OSCALL_1:		LD	A, (HL)
044337 23          11019  			INC	HL
044338 FE FF       11020  			CP	FFh
04433A C8          11021  			RET	Z
04433B FD BD       11022  			CP	A, IYL
04433D 28 06       11023  			JR	Z, OSCALL_2
04433F D0          11024  			RET	NC
044340 23          11025  			INC	HL
044341 23          11026  			INC	HL
044342 23          11027  			INC	HL
044343 18 F1       11028  			JR	OSCALL_1
044345 ED 31       11029  OSCALL_2:		LD	IY,(HL)
044347 C9          11030  			RET
044348 D4          11031  OSCALL_TABLE:		DB 	D4h
044349 7C 43 04    11032  			DW24 	OSBPUT
04434C D7          11033  			DB 	D7h
04434D 74 43 04    11034  			DW24 	OSBGET
044350 EE          11035  			DB 	EEh
044351 30 3F 04    11036  			DW24 	OSWRCH
044354 F4          11037  			DB	F4h
044355 FA 40 04    11038  			DW24 	OSBYTE
044358 F7          11039  			DB	F7h
044359 C0 3F 04    11040  			DW24	OSCLI
04435C FF          11041  			DB	FFh
04435D             11042  
04435D             11043  ; OSOPEN
04435D             11044  ; HL: Pointer to path
04435D             11045  ;  F: C Z
04435D             11046  ;     x x OPENIN
04435D             11047  ; 	  OPENOUT
04435D             11048  ;     x	  OPENUP
04435D             11049  ; Returns:
04435D             11050  ;  A: Filehandle, 0 if cannot open
04435D             11051  ;
04435D 0E 01       11052  OSOPEN:			LD	C, fa_read
04435F 28 06       11053  			JR	Z, @F
044361 0E 32       11054  			LD	C, fa_write | fa_open_append
044363 38 02       11055  			JR	C, @F
044365 0E 0A       11056  			LD	C, fa_write | fa_create_always
044367             11057  @@:			MOSCALL	mos_fopen
044367 3E 0A       0001M 			LD	A, function
044369 49 CF       0002M 			RST.LIS	08h
04436B C9          11058  			RET
04436C             11059  
04436C             11060  ;OSSHUT - Close disk file(s).
04436C             11061  ; E = file channel
04436C             11062  ;  If E=0 all files are closed (except SPOOL)
04436C             11063  ; Destroys: A,B,C,D,E,H,L,F
04436C             11064  ;
04436C C5          11065  OSSHUT:			PUSH	BC
04436D 4B          11066  			LD	C, E
04436E             11067  			MOSCALL	mos_fclose
04436E 3E 0B       0001M 			LD	A, function
044370 49 CF       0002M 			RST.LIS	08h
044372 C1          11068  			POP	BC
044373 C9          11069  			RET
044374             11070  
044374             11071  ; OSBGET - Read a byte from a random disk file.
044374             11072  ;  E = file channel
044374             11073  ; Returns
044374             11074  ;  A = byte read
044374             11075  ;  Carry set if LAST BYTE of file
044374             11076  ; Destroys: A,B,C,F
044374             11077  ;
044374 C5          11078  OSBGET:			PUSH	BC
044375 4B          11079  			LD	C, E
044376             11080  			MOSCALL	mos_fgetc
044376 3E 0C       0001M 			LD	A, function
044378 49 CF       0002M 			RST.LIS	08h
04437A C1          11081  			POP	BC
04437B C9          11082  			RET
04437C             11083  
04437C             11084  ; OSBPUT - Write a byte to a random disk file.
04437C             11085  ;  E = file channel
04437C             11086  ;  A = byte to write
04437C             11087  ; Destroys: A,B,C,F
04437C             11088  ;
04437C C5          11089  OSBPUT:			PUSH	BC
04437D 4B          11090  			LD	C, E
04437E 47          11091  			LD	B, A
04437F             11092  			MOSCALL	mos_fputc
04437F 3E 0D       0001M 			LD	A, function
044381 49 CF       0002M 			RST.LIS	08h
044383 C1          11093  			POP	BC
044384 C9          11094  			RET
044385             11095  
044385             11096  ; OSSTAT - Read file status
044385             11097  ;  E = file channel
044385             11098  ; Returns
044385             11099  ;  F: Z flag set - EOF
044385             11100  ;  A: If Z then A = 0
044385             11101  ; Destroys: A,D,E,H,L,F
044385             11102  ;
044385 C5          11103  OSSTAT:			PUSH	BC
044386 4B          11104  			LD	C, E
044387             11105  			MOSCALL	mos_feof
044387 3E 0E       0001M 			LD	A, function
044389 49 CF       0002M 			RST.LIS	08h
04438B C1          11106  			POP	BC
04438C FE 01       11107  			CP	1
04438E C9          11108  			RET
04438F             11109  
04438F             11110  ; GETPTR - Return file pointer.
04438F             11111  ;    E = file channel
04438F             11112  ; Returns:
04438F             11113  ; DEHL = pointer (0-&7FFFFF)
04438F             11114  ; Destroys: A,B,C,D,E,H,L,F
04438F             11115  ;
04438F FD E5       11116  GETPTR:			PUSH		IY
044391 4B          11117  			LD		C, E
044392             11118  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044392 3E 19       0001M 			LD	A, function
044394 49 CF       0002M 			RST.LIS	08h
044396 E5          11119  			PUSH		HL
044397 FD E1       11120  			POP		IY		; IYU: Pointer to FIL structure
044399 FD 6E 11    11121  			LD		L, (IY + FIL.fptr + 0)
04439C FD 66 12    11122  			LD		H, (IY + FIL.fptr + 1)
04439F FD 5E 13    11123  			LD		E, (IY + FIL.fptr + 2)
0443A2 FD 56 14    11124  			LD		D, (IY + FIL.fptr + 3)
0443A5 FD E1       11125  			POP		IY
0443A7 C9          11126  			RET
0443A8             11127  
0443A8             11128  ; PUTPTR - Update file pointer.
0443A8             11129  ;    A = file channel
0443A8             11130  ; DEHL = new pointer (0-&7FFFFF)
0443A8             11131  ; Destroys: A,B,C,D,E,H,L,F
0443A8             11132  ;
0443A8 FD E5       11133  PUTPTR:			PUSH		IY
0443AA 4F          11134  			LD		C, A  		; C: Filehandle
0443AB E5          11135  			PUSH		HL
0443AC 21 02 00 00 11136  			LD		HL, 2
0443B0 39          11137  			ADD		HL, SP
0443B1 73          11138  			LD		(HL), E 	; 3rd byte of DWORD set to E
0443B2 E1          11139  			POP		HL
0443B3 5A          11140  			LD		E, D  		; 4th byte passed as E
0443B4             11141  			MOSCALL		mos_flseek
0443B4 3E 1C       0001M 			LD	A, function
0443B6 49 CF       0002M 			RST.LIS	08h
0443B8 FD E1       11142  			POP		IY
0443BA C9          11143  			RET
0443BB             11144  
0443BB             11145  ; GETEXT - Find file size.
0443BB             11146  ;    E = file channel
0443BB             11147  ; Returns:
0443BB             11148  ; DEHL = file size (0-&800000)
0443BB             11149  ; Destroys: A,B,C,D,E,H,L,F
0443BB             11150  ;
0443BB FD E5       11151  GETEXT:         PUSH    IY
0443BD 4B          11152                  LD      C, E
0443BE             11153                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443BE 3E 19       0001M 			LD	A, function
0443C0 49 CF       0002M 			RST.LIS	08h
0443C2 E5          11154                  PUSH    HL
0443C3 FD E1       11155                  POP     IY          ; IYU: Pointer to FIL structure
0443C5             11156                  ; Access the obj.objsize field using the offset values
0443C5 FD 6E 0B    11157                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443C8 FD 66 0C    11158                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443CB FD 5E 0D    11159                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443CE FD 56 0E    11160                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443D1             11161  
0443D1 FD E1       11162                  POP     IY
0443D3 C9          11163  			RET
0443D4             11164  
0443D4             11165  ; GETIMS - Get time from RTC
0443D4             11166  ;
0443D4 FD E5       11167  GETIMS:			PUSH	IY
0443D6 21 00 4A 04 11168  			LD	HL, ACCS 		; Where to store the time string
0443DA             11169  			MOSCALL	mos_getrtc
0443DA 3E 12       0001M 			LD	A, function
0443DC 49 CF       0002M 			RST.LIS	08h
0443DE 11 00 4A 04 11170  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0443E2 5F          11171  			LD	E, A 			;  E: now points to the end of the string
0443E3 FD E1       11172  			POP	IY
0443E5 C9          11173  			RET
0443E6             11174  
0443E6             11175  ; Get two word values from EXPR in DE, HL
0443E6             11176  ; IY: Pointer to expression string
0443E6             11177  ; Returns:
0443E6             11178  ; DE: P1
0443E6             11179  ; HL: P2
0443E6             11180  ;
0443E6 CD 0A 03 04 11181  EXPR_W2:		CALL	EXPRI			; Get first parameter
0443EA D9          11182  			EXX
0443EB E5          11183  			PUSH	HL
0443EC CD 22 0A 04 11184  			CALL	COMMA
0443F0 CD 0A 03 04 11185  			CALL	EXPRI			; Get second parameter
0443F4 D9          11186  			EXX
0443F5 D1          11187  			POP	DE
0443F6 C9          11188  			RET
0443F7             11189  
0443F7             11190  ; Stuff not implemented yet
0443F7             11191  ;
0443F7 C9          11192  RESET:			RET
0443F8             11193  ; --- End patch.asm ---
0443F8             11194  
0443F8             11195  ; --- Begin agon_graphics.asm ---
0443F8             11196  ;
0443F8             11197  ; Title:	BBC Basic for AGON - Graphics stuff
0443F8             11198  ; Author:	Dean Belfield
0443F8             11199  ; Created:	12/05/2023
0443F8             11200  ; Last Updated:	07/06/2023
0443F8             11201  ;
0443F8             11202  ; Modinfo:
0443F8             11203  ; 07/06/2023:	Modified to run in ADL mode
0443F8             11204  
0443F8             11205  			; .ASSUME	ADL = 1
0443F8             11206  
0443F8             11207  			; INCLUDE	"equs.inc"
0443F8             11208  			; INCLUDE "macros.inc"
0443F8             11209  			; INCLUDE "mos_api.inc"	; In MOS/src
0443F8             11210  
0443F8             11211  			; SEGMENT CODE
0443F8             11212  
0443F8             11213  			; XDEF	CLG
0443F8             11214  			; XDEF	CLRSCN
0443F8             11215  			; XDEF	MODE
0443F8             11216  			; XDEF	COLOUR
0443F8             11217  			; XDEF	GCOL
0443F8             11218  			; XDEF	MOVE
0443F8             11219  			; XDEF	PLOT
0443F8             11220  			; XDEF	DRAW
0443F8             11221  			; XDEF	POINT
0443F8             11222  			; XDEF	GETSCHR
0443F8             11223  
0443F8             11224  			; XREF	OSWRCH
0443F8             11225  			; XREF	ASC_TO_NUMBER
0443F8             11226  			; XREF	EXTERR
0443F8             11227  			; XREF	EXPRI
0443F8             11228  			; XREF	COMMA
0443F8             11229  			; XREF	XEQ
0443F8             11230  			; XREF	NXT
0443F8             11231  			; XREF	BRAKET
0443F8             11232  			; XREF	COUNT0
0443F8             11233  			; XREF	CRTONULL
0443F8             11234  			; XREF	NULLTOCR
0443F8             11235  			; XREF	CRLF
0443F8             11236  			; XREF	EXPR_W2
0443F8             11237  			; XREF	INKEY1
0443F8             11238  
0443F8             11239  ; CLG: clears the graphics area
0443F8             11240  ;
0443F8             11241  CLG:			VDU	10h
0443F8 3E 10       0001M 		LD	A, val
0443FA CD 30 3F 04 0002M 		CALL	OSWRCH
0443FE C3 96 0B 04 11242  			JP	XEQ
044402             11243  
044402             11244  ; CLS: clears the text area
044402             11245  ;
044402 3E 0C       11246  CLRSCN:			LD	A, 0Ch
044404 C3 30 3F 04 11247  			JP	OSWRCH
044408             11248  
044408             11249  ; MODE n: Set video mode
044408             11250  ;
044408 DD E5       11251  MODE:			PUSH	IX			; Get the system vars in IX
04440A             11252  			MOSCALL	mos_sysvars		; Reset the semaphore
04440A 3E 08       0001M 			LD	A, function
04440C 49 CF       0002M 			RST.LIS	08h
04440E DD CB 04 A6 11253  			RES	4, (IX+sysvar_vpd_pflags)
044412 CD 0A 03 04 11254  			CALL    EXPRI
044416 D9          11255  			EXX
044417             11256  			VDU	16H			; Mode change
044417 3E 16       0001M 		LD	A, val
044419 CD 30 3F 04 0002M 		CALL	OSWRCH
04441D             11257  			VDU	L
04441D 7D          0001M 		LD	A, val
04441E CD 30 3F 04 0002M 		CALL	OSWRCH
044422             11258  			MOSCALL	mos_sysvars
044422 3E 08       0001M 			LD	A, function
044424 49 CF       0002M 			RST.LIS	08h
044426 DD CB 04 66 11259  @@:			BIT	4, (IX+sysvar_vpd_pflags)
04442A 28 FA       11260  			JR	Z, @B			; Wait for the result
04442C DD E1       11261  			POP	IX
04442E C3 96 0B 04 11262  			JP	XEQ
044432             11263  
044432             11264  ; GET(x,y): Get the ASCII code of a character on screen
044432             11265  ;
044432 FD 23       11266  GETSCHR:		INC	IY
044434 CD 0A 03 04 11267  			CALL    EXPRI      		; Get X coordinate
044438 D9          11268  			EXX
044439 22 00 4A 04 11269  			LD	(VDU_BUFFER+0), HL
04443D CD 22 0A 04 11270  			CALL	COMMA
044441 CD 0A 03 04 11271  			CALL	EXPRI			; Get Y coordinate
044445 D9          11272  			EXX
044446 22 02 4A 04 11273  			LD	(VDU_BUFFER+2), HL
04444A CD 2F 0A 04 11274  			CALL	BRAKET			; Closing bracket
04444E             11275  ;
04444E DD E5       11276  			PUSH	IX			; Get the system vars in IX
044450             11277  			MOSCALL	mos_sysvars		; Reset the semaphore
044450 3E 08       0001M 			LD	A, function
044452 49 CF       0002M 			RST.LIS	08h
044454 DD CB 04 8E 11278  			RES	1, (IX+sysvar_vpd_pflags)
044458             11279  			VDU	23
044458 3E 17       0001M 		LD	A, val
04445A CD 30 3F 04 0002M 		CALL	OSWRCH
04445E             11280  			VDU	0
04445E 3E 00       0001M 		LD	A, val
044460 CD 30 3F 04 0002M 		CALL	OSWRCH
044464             11281  			VDU	vdp_scrchar
044464 3E 83       0001M 		LD	A, val
044466 CD 30 3F 04 0002M 		CALL	OSWRCH
04446A             11282  			VDU	(VDU_BUFFER+0)
04446A 3A 00 4A 04 0001M 		LD	A, val
04446E CD 30 3F 04 0002M 		CALL	OSWRCH
044472             11283  			VDU	(VDU_BUFFER+1)
044472 3A 01 4A 04 0001M 		LD	A, val
044476 CD 30 3F 04 0002M 		CALL	OSWRCH
04447A             11284  			VDU	(VDU_BUFFER+2)
04447A 3A 02 4A 04 0001M 		LD	A, val
04447E CD 30 3F 04 0002M 		CALL	OSWRCH
044482             11285  			VDU	(VDU_BUFFER+3)
044482 3A 03 4A 04 0001M 		LD	A, val
044486 CD 30 3F 04 0002M 		CALL	OSWRCH
04448A DD CB 04 4E 11286  @@:			BIT	1, (IX+sysvar_vpd_pflags)
04448E 28 FA       11287  			JR	Z, @B			; Wait for the result
044490 DD 7E 09    11288  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
044493 B7          11289  			OR	A			; Check for 00h
044494 37          11290  			SCF				; C = character map
044495 20 02       11291  			JR	NZ, @F			; We have a character, so skip next bit
044497 AF          11292  			XOR	A			; Clear carry
044498 3D          11293  			DEC	A			; Set A to FFh
044499 DD E1       11294  @@:			POP	IX
04449B C3 E1 07 04 11295  			JP	INKEY1			; Jump back to the GET command
04449F             11296  
04449F             11297  ; POINT(x,y): Get the pixel colour of a point on screen
04449F             11298  ;
04449F CD 0A 03 04 11299  POINT:			CALL    EXPRI      		; Get X coordinate
0444A3 D9          11300  			EXX
0444A4 22 00 4A 04 11301  			LD	(VDU_BUFFER+0), HL
0444A8 CD 22 0A 04 11302  			CALL	COMMA
0444AC CD 0A 03 04 11303  			CALL	EXPRI			; Get Y coordinate
0444B0 D9          11304  			EXX
0444B1 22 02 4A 04 11305  			LD	(VDU_BUFFER+2), HL
0444B5 CD 2F 0A 04 11306  			CALL	BRAKET			; Closing bracket
0444B9             11307  ;
0444B9 DD E5       11308  			PUSH	IX			; Get the system vars in IX
0444BB             11309  			MOSCALL	mos_sysvars		; Reset the semaphore
0444BB 3E 08       0001M 			LD	A, function
0444BD 49 CF       0002M 			RST.LIS	08h
0444BF DD CB 04 96 11310  			RES	2, (IX+sysvar_vpd_pflags)
0444C3             11311  			VDU	23
0444C3 3E 17       0001M 		LD	A, val
0444C5 CD 30 3F 04 0002M 		CALL	OSWRCH
0444C9             11312  			VDU	0
0444C9 3E 00       0001M 		LD	A, val
0444CB CD 30 3F 04 0002M 		CALL	OSWRCH
0444CF             11313  			VDU	vdp_scrpixel
0444CF 3E 84       0001M 		LD	A, val
0444D1 CD 30 3F 04 0002M 		CALL	OSWRCH
0444D5             11314  			VDU	(VDU_BUFFER+0)
0444D5 3A 00 4A 04 0001M 		LD	A, val
0444D9 CD 30 3F 04 0002M 		CALL	OSWRCH
0444DD             11315  			VDU	(VDU_BUFFER+1)
0444DD 3A 01 4A 04 0001M 		LD	A, val
0444E1 CD 30 3F 04 0002M 		CALL	OSWRCH
0444E5             11316  			VDU	(VDU_BUFFER+2)
0444E5 3A 02 4A 04 0001M 		LD	A, val
0444E9 CD 30 3F 04 0002M 		CALL	OSWRCH
0444ED             11317  			VDU	(VDU_BUFFER+3)
0444ED 3A 03 4A 04 0001M 		LD	A, val
0444F1 CD 30 3F 04 0002M 		CALL	OSWRCH
0444F5 DD CB 04 56 11318  @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444F9 28 FA       11319  			JR	Z, @B			; Wait for the result
0444FB             11320  ;
0444FB             11321  ; Return the data as a 1 byte index
0444FB             11322  ;
0444FB DD 6E 16    11323  			LD	L, (IX+sysvar_scrpixelIndex)
0444FE DD E1       11324  			POP	IX
044500 C3 7F 05 04 11325  			JP	COUNT0
044504             11326  
044504             11327  
044504             11328  ; COLOUR colour
044504             11329  ; COLOUR L,P
044504             11330  ; COLOUR L,R,G,B
044504             11331  ;
044504 CD 0A 03 04 11332  COLOUR:			CALL	EXPRI			; The colour / mode
044508 D9          11333  			EXX
044509 7D          11334  			LD	A, L
04450A 32 00 4A 04 11335  			LD	(VDU_BUFFER+0), A	; Store first parameter
04450E CD 70 0A 04 11336  			CALL	NXT			; Are there any more parameters?
044512 FE 2C       11337  			CP	','
044514 28 12       11338  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
044516             11339  ;
044516             11340  			VDU	11h			; Just set the colour
044516 3E 11       0001M 		LD	A, val
044518 CD 30 3F 04 0002M 		CALL	OSWRCH
04451C             11341  			VDU	(VDU_BUFFER+0)
04451C 3A 00 4A 04 0001M 		LD	A, val
044520 CD 30 3F 04 0002M 		CALL	OSWRCH
044524 C3 96 0B 04 11342  			JP	XEQ
044528             11343  ;
044528 CD 22 0A 04 11344  COLOUR_1:		CALL	COMMA
04452C CD 0A 03 04 11345  			CALL	EXPRI			; Parse R (OR P)
044530 D9          11346  			EXX
044531 7D          11347  			LD	A, L
044532 32 01 4A 04 11348  			LD	(VDU_BUFFER+1), A
044536 CD 70 0A 04 11349  			CALL	NXT			; Are there any more parameters?
04453A FE 2C       11350  			CP	','
04453C 28 2C       11351  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
04453E             11352  ;
04453E             11353  			VDU	13h			; VDU:COLOUR
04453E 3E 13       0001M 		LD	A, val
044540 CD 30 3F 04 0002M 		CALL	OSWRCH
044544             11354  			VDU	(VDU_BUFFER+0)		; Logical Colour
044544 3A 00 4A 04 0001M 		LD	A, val
044548 CD 30 3F 04 0002M 		CALL	OSWRCH
04454C             11355  			VDU	(VDU_BUFFER+1)		; Palette Colour
04454C 3A 01 4A 04 0001M 		LD	A, val
044550 CD 30 3F 04 0002M 		CALL	OSWRCH
044554             11356  			VDU	0			; RGB set to 0
044554 3E 00       0001M 		LD	A, val
044556 CD 30 3F 04 0002M 		CALL	OSWRCH
04455A             11357  			VDU	0
04455A 3E 00       0001M 		LD	A, val
04455C CD 30 3F 04 0002M 		CALL	OSWRCH
044560             11358  			VDU	0
044560 3E 00       0001M 		LD	A, val
044562 CD 30 3F 04 0002M 		CALL	OSWRCH
044566 C3 96 0B 04 11359  			JP	XEQ
04456A             11360  ;
04456A CD 22 0A 04 11361  COLOUR_2:		CALL	COMMA
04456E CD 0A 03 04 11362  			CALL	EXPRI			; Parse G
044572 D9          11363  			EXX
044573 7D          11364  			LD	A, L
044574 32 02 4A 04 11365  			LD	(VDU_BUFFER+2), A
044578 CD 22 0A 04 11366  			CALL	COMMA
04457C CD 0A 03 04 11367  			CALL	EXPRI			; Parse B
044580 D9          11368  			EXX
044581 7D          11369  			LD	A, L
044582 32 03 4A 04 11370  			LD	(VDU_BUFFER+3), A
044586             11371  			VDU	13h			; VDU:COLOUR
044586 3E 13       0001M 		LD	A, val
044588 CD 30 3F 04 0002M 		CALL	OSWRCH
04458C             11372  			VDU	(VDU_BUFFER+0)		; Logical Colour
04458C 3A 00 4A 04 0001M 		LD	A, val
044590 CD 30 3F 04 0002M 		CALL	OSWRCH
044594             11373  			VDU	FFh			; Physical Colour (-1 for RGB mode)
044594 3E FF       0001M 		LD	A, val
044596 CD 30 3F 04 0002M 		CALL	OSWRCH
04459A             11374  			VDU	(VDU_BUFFER+1)		; R
04459A 3A 01 4A 04 0001M 		LD	A, val
04459E CD 30 3F 04 0002M 		CALL	OSWRCH
0445A2             11375  			VDU	(VDU_BUFFER+2)		; G
0445A2 3A 02 4A 04 0001M 		LD	A, val
0445A6 CD 30 3F 04 0002M 		CALL	OSWRCH
0445AA             11376  			VDU	(VDU_BUFFER+3)		; B
0445AA 3A 03 4A 04 0001M 		LD	A, val
0445AE CD 30 3F 04 0002M 		CALL	OSWRCH
0445B2 C3 96 0B 04 11377  			JP	XEQ
0445B6             11378  
0445B6             11379  ; GCOL mode,colour
0445B6             11380  ;
0445B6 CD 0A 03 04 11381  GCOL:			CALL	EXPRI			; Parse MODE
0445BA D9          11382  			EXX
0445BB 7D          11383  			LD	A, L
0445BC 32 00 4A 04 11384  			LD	(VDU_BUFFER+0), A
0445C0 CD 22 0A 04 11385  			CALL	COMMA
0445C4             11386  ;
0445C4 CD 0A 03 04 11387  			CALL	EXPRI			; Parse Colour
0445C8 D9          11388  			EXX
0445C9 7D          11389  			LD	A, L
0445CA 32 01 4A 04 11390  			LD	(VDU_BUFFER+1), A
0445CE             11391  ;
0445CE             11392  			VDU	12h			; VDU:GCOL
0445CE 3E 12       0001M 		LD	A, val
0445D0 CD 30 3F 04 0002M 		CALL	OSWRCH
0445D4             11393  			VDU	(VDU_BUFFER+0)		; Mode
0445D4 3A 00 4A 04 0001M 		LD	A, val
0445D8 CD 30 3F 04 0002M 		CALL	OSWRCH
0445DC             11394  			VDU	(VDU_BUFFER+1)		; Colour
0445DC 3A 01 4A 04 0001M 		LD	A, val
0445E0 CD 30 3F 04 0002M 		CALL	OSWRCH
0445E4 C3 96 0B 04 11395  			JP	XEQ
0445E8             11396  
0445E8             11397  ; PLOT mode,x,y
0445E8             11398  ;
0445E8 CD 0A 03 04 11399  PLOT:			CALL	EXPRI		; Parse mode
0445EC D9          11400  			EXX
0445ED E5          11401  			PUSH	HL		; Push mode (L) onto stack
0445EE CD 22 0A 04 11402  			CALL	COMMA
0445F2 CD E6 43 04 11403  			CALL	EXPR_W2		; Parse X and Y
0445F6 C1          11404  			POP	BC		; Pop mode (C) off stack
0445F7             11405  PLOT_1:			VDU	19H		; VDU code for PLOT
0445F7 3E 19       0001M 		LD	A, val
0445F9 CD 30 3F 04 0002M 		CALL	OSWRCH
0445FD             11406  			VDU	C		;  C: Mode
0445FD 79          0001M 		LD	A, val
0445FE CD 30 3F 04 0002M 		CALL	OSWRCH
044602             11407  			VDU	E		; DE: X
044602 7B          0001M 		LD	A, val
044603 CD 30 3F 04 0002M 		CALL	OSWRCH
044607             11408  			VDU	D
044607 7A          0001M 		LD	A, val
044608 CD 30 3F 04 0002M 		CALL	OSWRCH
04460C             11409  			VDU	L		; HL: Y
04460C 7D          0001M 		LD	A, val
04460D CD 30 3F 04 0002M 		CALL	OSWRCH
044611             11410  			VDU	H
044611 7C          0001M 		LD	A, val
044612 CD 30 3F 04 0002M 		CALL	OSWRCH
044616 C3 96 0B 04 11411  			JP	XEQ
04461A             11412  
04461A             11413  ; MOVE x,y
04461A             11414  ;
04461A CD E6 43 04 11415  MOVE:			CALL	EXPR_W2		; Parse X and Y
04461E 0E 04       11416  			LD	C, 04H		; Plot mode 04H (Move)
044620 18 D5       11417  			JR	PLOT_1		; Plot
044622             11418  
044622             11419  ; DRAW x1,y1
044622             11420  ; DRAW x1,y1,x2,y2
044622             11421  ;
044622 CD E6 43 04 11422  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
044626 CD 70 0A 04 11423  			CALL	NXT		; Are there any more parameters?
04462A FE 2C       11424  			CP	','
04462C 0E 05       11425  			LD	C, 05h		; Code for LINE
04462E 20 C7       11426  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044630             11427  			VDU	19h		; Move to the first coordinates
044630 3E 19       0001M 		LD	A, val
044632 CD 30 3F 04 0002M 		CALL	OSWRCH
044636             11428  			VDU	04h
044636 3E 04       0001M 		LD	A, val
044638 CD 30 3F 04 0002M 		CALL	OSWRCH
04463C             11429  			VDU	E
04463C 7B          0001M 		LD	A, val
04463D CD 30 3F 04 0002M 		CALL	OSWRCH
044641             11430  			VDU	D
044641 7A          0001M 		LD	A, val
044642 CD 30 3F 04 0002M 		CALL	OSWRCH
044646             11431  			VDU	L
044646 7D          0001M 		LD	A, val
044647 CD 30 3F 04 0002M 		CALL	OSWRCH
04464B             11432  			VDU	H
04464B 7C          0001M 		LD	A, val
04464C CD 30 3F 04 0002M 		CALL	OSWRCH
044650 CD 22 0A 04 11433  			CALL	COMMA
044654 C5          11434  			PUSH	BC
044655 CD E6 43 04 11435  			CALL	EXPR_W2		; Get X2 and Y2
044659 C1          11436  			POP	BC
04465A 18 9B       11437  			JR	PLOT_1		; Now DRAW the line to those positions
04465C             11438  
04465C             11439  
04465C             11440  
04465C             11441  ; --- End agon_graphics.asm ---
04465C             11442  
04465C             11443  ; --- Begin agon_sound.asm ---
04465C             11444  ;
04465C             11445  ; Title:	BBC Basic for AGON - Audio stuff
04465C             11446  ; Author:	Dean Belfield
04465C             11447  ; Created:	12/05/2023
04465C             11448  ; Last Updated:	12/05/2023
04465C             11449  ;
04465C             11450  ; Modinfo:
04465C             11451  
04465C             11452  			; .ASSUME	ADL = 1
04465C             11453  
04465C             11454  			; INCLUDE	"equs.inc"
04465C             11455  			; INCLUDE "macros.inc"
04465C             11456  			; INCLUDE "mos_api.inc"	; In MOS/src
04465C             11457  
04465C             11458  			; SEGMENT CODE
04465C             11459  
04465C             11460  			; XDEF	SOUND
04465C             11461  
04465C             11462  			; XREF	COMMA
04465C             11463  			; XREF	EXPR_W2
04465C             11464  			; XREF	XEQ
04465C             11465  			; XREF	LTRAP
04465C             11466  			; XREF	OSWRCH
04465C             11467  			; XREF	VDU_BUFFER
04465C             11468  
04465C             11469  
04465C             11470  ; SOUND channel,volume,pitch,duration
04465C             11471  ; volume: 0 (off) to -15 (full volume)
04465C             11472  ; pitch: 0 - 255
04465C             11473  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
04465C             11474  ;
04465C CD E6 43 04 11475  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044660 7D          11476  			LD	A, L 			;  A: Volume
044661 F5          11477  			PUSH	AF
044662 D5          11478  			PUSH	DE
044663 CD 22 0A 04 11479  			CALL	COMMA
044667 CD E6 43 04 11480  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
04466B 53          11481  			LD	D, E			;  D: Pitch
04466C 5D          11482  			LD	E, L 			;  E: Duration
04466D E1          11483  			POP	HL 			; HL: Channel/Control
04466E F1          11484  			POP	AF
04466F ED 44       11485  			NEG
044671 FE 10       11486  			CP	16			; Check volume is in bounds
044673 D2 96 0B 04 11487  			JP	NC, XEQ			; Out of bounds, do nothing
044677             11488  ;
044677             11489  ; Store	in VDU vars
044677             11490  ;
044677 4F          11491  			LD	C, A			; Store Volume in C
044678 7D          11492  			LD	A, L
044679 32 00 4A 04 11493  			LD	(VDU_BUFFER+0), A	; Channel
04467D AF          11494  			XOR	A
04467E 32 01 4A 04 11495  			LD	(VDU_BUFFER+1), A	; Waveform
044682             11496  ;
044682             11497  ; Calculate the volume
044682             11498  ;
044682 06 06       11499  			LD	B, 6			; C already contains the volume
044684 ED 4C       11500  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
044686 79          11501  			LD	A, C
044687 32 02 4A 04 11502  			LD	(VDU_BUFFER+2), A
04468B             11503  ;
04468B             11504  ; And the frequency
04468B             11505  ;
04468B 4B          11506  			LD	C, E			; Store duration in C
04468C 26 00       11507  			LD	H, 0			; Lookup the frequency
04468E 6A          11508  			LD	L, D
04468F 11 16 47 04 11509  			LD	DE, SOUND_FREQ_LOOKUP
044693 29          11510  			ADD	HL, HL
044694 19          11511  			ADD	HL, DE
044695 7E          11512  			LD	A, (HL)
044696 32 03 4A 04 11513  			LD	(VDU_BUFFER+3), A
04469A 23          11514  			INC	HL
04469B 7E          11515  			LD	A, (HL)
04469C 32 04 4A 04 11516  			LD	(VDU_BUFFER+4), A
0446A0             11517  ;
0446A0             11518  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0446A0             11519  ;
0446A0 06 32       11520  			LD	B, 50			; C contains the duration, so MLT by 50
0446A2 ED 4C       11521  			MLT	BC
0446A4 ED 43 05 4A 11522  			LD	(VDU_BUFFER+5), BC
       04          
0446A9             11523  ;
0446A9 DD E5       11524  			PUSH	IX			; Get the system vars in IX
0446AB             11525  			MOSCALL	mos_sysvars		; Reset the semaphore
0446AB 3E 08       0001M 			LD	A, function
0446AD 49 CF       0002M 			RST.LIS	08h
0446AF 5B DD CB 04 11526  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0446B4             11527  ;
0446B4             11528  			VDU	23			; Send the sound command
0446B4 3E 17       0001M 		LD	A, val
0446B6 CD 30 3F 04 0002M 		CALL	OSWRCH
0446BA             11529  			VDU	0
0446BA 3E 00       0001M 		LD	A, val
0446BC CD 30 3F 04 0002M 		CALL	OSWRCH
0446C0             11530  			VDU	vdp_audio
0446C0 3E 85       0001M 		LD	A, val
0446C2 CD 30 3F 04 0002M 		CALL	OSWRCH
0446C6             11531  			VDU	(VDU_BUFFER+0)		; 0: Channel
0446C6 3A 00 4A 04 0001M 		LD	A, val
0446CA CD 30 3F 04 0002M 		CALL	OSWRCH
0446CE             11532  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446CE 3A 01 4A 04 0001M 		LD	A, val
0446D2 CD 30 3F 04 0002M 		CALL	OSWRCH
0446D6             11533  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446D6 3A 02 4A 04 0001M 		LD	A, val
0446DA CD 30 3F 04 0002M 		CALL	OSWRCH
0446DE             11534  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446DE 3A 03 4A 04 0001M 		LD	A, val
0446E2 CD 30 3F 04 0002M 		CALL	OSWRCH
0446E6             11535  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446E6 3A 04 4A 04 0001M 		LD	A, val
0446EA CD 30 3F 04 0002M 		CALL	OSWRCH
0446EE             11536  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0446EE 3A 05 4A 04 0001M 		LD	A, val
0446F2 CD 30 3F 04 0002M 		CALL	OSWRCH
0446F6             11537  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0446F6 3A 06 4A 04 0001M 		LD	A, val
0446FA CD 30 3F 04 0002M 		CALL	OSWRCH
0446FE             11538  ;
0446FE             11539  ; Wait for acknowledgement
0446FE             11540  ;
0446FE 5B DD CB 04 11541  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
044703 28 F9       11542  			JR	Z, @B			; Wait for the result
044705 CD A1 3F 04 11543  			CALL	LTRAP			; Check for ESC
044709 5B DD 7E 0E 11544  			LD.LIL	A, (IX+sysvar_audioSuccess)
04470D A7          11545  			AND	A			; Check if VDP has queued the note
04470E 28 9F       11546  			JR	Z, SOUND0		; No, so loop back and send again
044710             11547  ;
044710 DD E1       11548  			POP	IX
044712 C3 96 0B 04 11549  			JP	XEQ
044716             11550  
044716             11551  ; Frequency Lookup Table
044716             11552  ; Set up to replicate the BBC Micro audio frequencies
044716             11553  ;
044716             11554  ; Split over 5 complete octaves, with 53 being middle C
044716             11555  ; * C4: 262hz
044716             11556  ; + A4: 440hz
044716             11557  ;
044716             11558  ;	2	3	4	5	6	7	8
044716             11559  ;
044716             11560  ; B	1	49	97	145	193	241
044716             11561  ; A#	0	45	93	141	189	237
044716             11562  ; A		41	89+	137	185	233
044716             11563  ; G#		37	85	133	181	229
044716             11564  ; G		33	81	129	177	225
044716             11565  ; F#		29	77	125	173	221
044716             11566  ; F		25	73	121	169	217
044716             11567  ; E		21	69	117	165	213
044716             11568  ; D#		17	65	113	161	209
044716             11569  ; D		13	61	109	157	205	253
044716             11570  ; C#		9	57	105	153	201	249
044716             11571  ; C		5	53*	101	149	197	245
044716             11572  ;
044716 75 00 76 00 11573  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
044726 89 00 8B 00 11574  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
044736 99 00 9C 00 11575  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
044746 AC 00 AF 00 11576  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
044756 C1 00 C4 00 11577  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
044766 D9 00 DC 00 11578  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
044776 F3 00 F7 00 11579  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
044786 11 01 15 01 11580  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
044796 33 01 37 01 11581  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0447A6 58 01 5D 01 11582  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0447B6 82 01 88 01 11583  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0447C6 B2 01 B8 01 11584  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447D6 E7 01 EE 01 11585  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0447E6 22 02 2A 02 11586  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0447F6 65 02 6E 02 11587  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
044806 B1 02 BB 02 11588  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
044816 05 03 10 03 11589  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
044826 63 03 70 03 11590  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
044836 CE 03 DC 03 11591  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
044846 45 04 55 04 11592  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
044856 CB 04 DD 04 11593  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
044866 62 05 76 05 11594  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
044876 0A 06 21 06 11595  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
044886 C8 06 E1 06 11596  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
044896 9C 07 B8 07 11597  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0448A6 8A 08 A9 08 11598  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0448B6 95 09 B9 09 11599  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0448C6 C2 0A EA 0A 11600  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448D6 13 0C 40 0C 11601  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0448E6 8E 0D C0 0D 11602  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0448F6 36 0F 6F 0F 11603  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
044906 13 11 53 11 11604  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
044916             11605  
044916             11606  
044916             11607  ; --- End agon_sound.asm ---
044916             11608  
044916             11609  ; --- Begin interrupts.asm ---
044916             11610  ;
044916             11611  ; Title:	BBC Basic for AGON - Interrupts
044916             11612  ; Author:	Dean Belfield
044916             11613  ; Created:	12/05/2023
044916             11614  ; Last Updated:	07/06/2023
044916             11615  ;
044916             11616  ; Modinfo:
044916             11617  ; 07/06/2023:	Modified to run in ADL mode
044916             11618  
044916             11619  			; .ASSUME	ADL = 1
044916             11620  
044916             11621  			; INCLUDE	"macros.inc"
044916             11622  			; INCLUDE	"equs.inc"
044916             11623  			; INCLUDE "mos_api.inc"	; In MOS/src
044916             11624  
044916             11625  			; SEGMENT CODE
044916             11626  
044916             11627  			; XDEF	VBLANK_INIT
044916             11628  			; XDEF	VBLANK_STOP
044916             11629  			; XDEF	VBLANK_HANDLER
044916             11630  
044916             11631  			; XREF	ESCSET
044916             11632  			; XREF	KEYDOWN		; In ram.asm
044916             11633  			; XREF	KEYASCII 	; In ram.asm
044916             11634  			; XREF	KEYCOUNT	; In ram.asm
044916             11635  
044916             11636  ; Hook into the MOS VBLANK interrupt
044916             11637  ;
044916 F3          11638  VBLANK_INIT:		DI
044917 21 6B 49 04 11639  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
04491B 1E 32       11640  			LD		E, 32h				; Set up the VBlank Interrupt Vector
04491D             11641  			MOSCALL		mos_setintvector
04491D 3E 14       0001M 			LD	A, function
04491F 49 CF       0002M 			RST.LIS	08h
044921             11642  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044921 EB          11643  			ex de,hl
044922 21 79 49 04 11644  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044926 ED 1F       11645  			LD		(HL), DE			; Self-modify the code
044928 FB          11646  			EI
044929 C9          11647  			RET
04492A             11648  
04492A             11649  ; Unhook the custom VBLANK interrupt
04492A             11650  ;
04492A F3          11651  VBLANK_STOP:		DI
04492B 21 79 49 04 11652  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04492F ED 17       11653  			LD		DE, (HL)
044931 EB          11654  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
044932 1E 32       11655  			LD		E, 32h
044934             11656  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
044934 3E 14       0001M 			LD	A, function
044936 49 CF       0002M 			RST.LIS	08h
044938 FB          11657  			EI
044939 C9          11658  			RET
04493A             11659  
04493A             11660  ; A safe LIS call to ESCSET
04493A             11661  ;
04493A             11662  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
04493A 3E 08       0001M 			LD	A, function
04493C 49 CF       0002M 			RST.LIS	08h
04493E 21 49 4D 04 11663  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044942 DD 7E 19    11664  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
044945 BE          11665  			CP 		(HL)				; with our local copy
044946 20 0A       11666  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044948             11667  ;
044948 AF          11668  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044949 32 48 4D 04 11669  			LD		(KEYASCII), A
04494D 32 47 4D 04 11670  			LD		(KEYDOWN), A
044951 C9          11671  			RET	 					; And return
044952             11672  ;
044952 77          11673  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044953 DD 7E 18    11674  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044956 B7          11675  			OR		A
044957 28 EF       11676  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044959             11677  ;
044959 32 47 4D 04 11678  			LD		(KEYDOWN), A 			; Store the keydown value
04495D DD 7E 05    11679  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044960 32 48 4D 04 11680  			LD		(KEYASCII), A 			; Store locally
044964 FE 1B       11681  			CP		1Bh				; Is it escape?
044966 CC 7C 3F 04 11682  			CALL		Z, ESCSET			; Yes, so set the escape flags
04496A C9          11683  			RET						; Return to the interrupt handler
04496B             11684  
04496B F3          11685  VBLANK_HANDLER:		DI
04496C F5          11686  			PUSH		AF
04496D E5          11687  			PUSH		HL
04496E DD E5       11688  			PUSH		IX
044970 CD 3A 49 04 11689  			CALL		DO_KEYBOARD
044974 DD E1       11690  			POP		IX
044976 E1          11691  			POP		HL
044977 F1          11692  			POP		AF
044978             11693  ;
044978             11694  ; Finally jump to the MOS interrupt
044978             11695  ;
044978 C3 00 00 00 11696  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
04497C             11697  
04497C             11698  ; --- Begin sorry.asm ---
04497C             11699  ;
04497C             11700  ; Title:	BBC Basic Interpreter - Z80 version
04497C             11701  ;		Catch-all for unimplemented functionality
04497C             11702  ; Author:	Dean Belfield
04497C             11703  ; Created:	12/05/2023
04497C             11704  ; Last Updated:	12/05/2023
04497C             11705  ;
04497C             11706  ; Modinfo:
04497C             11707  
04497C             11708  			; .ASSUME	ADL = 1
04497C             11709  
04497C             11710  			; SEGMENT CODE
04497C             11711  
04497C             11712  			; XDEF	ENVEL
04497C             11713  			; XDEF	ADVAL
04497C             11714  			; XDEF	PUTIMS
04497C             11715  
04497C             11716  			; XREF	EXTERR
04497C             11717  
04497C             11718  ENVEL:
04497C             11719  ADVAL:
04497C             11720  PUTIMS:
04497C AF          11721  			XOR     A
04497D CD A7 37 04 11722  			CALL    EXTERR
044981 53 6F 72 72 11723  			DEFB    "Sorry"
       79          
044986 00          11724  			DEFB    0
044987             11725  ; --- End sorry.asm ---
044987             11726  
044987             11727  ; --- Begin ram.asm ---
044987             11728  ;
044987             11729  ; Title:	BBC Basic Interpreter - Z80 version
044987             11730  ;		RAM Module for BBC Basic Interpreter
044987             11731  ;		For use with Version 2.0 of BBC BASIC
044987             11732  ;		Standard CP/M Distribution Version
044987             11733  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
044987             11734  ; Modified By:	Dean Belfield
044987             11735  ; Created:	12/05/2023
044987             11736  ; Last Updated:	26/06/2023
044987             11737  ;
044987             11738  ; Modinfo:
044987             11739  ; 06/06/2023:	Modified to run in ADL mode
044987             11740  ; 26/06/2023:	Added temporary stores R0 and R1
044987             11741  
044987             11742  			; .ASSUME	ADL = 1
044987             11743  
044987             11744  			; DEFINE	LORAM, SPACE = ROM
044987             11745  			; SEGMENT LORAM
044987             11746  
044987             11747  			; XDEF	ACCS
044987             11748  			; XDEF	BUFFER
044987             11749  			; XDEF	STAVAR
044987             11750  			; XDEF	DYNVAR
044987             11751  			; XDEF	FNPTR
044987             11752  			; XDEF	PROPTR
044987             11753  			; XDEF	PAGE_
044987             11754  			; XDEF	TOP
044987             11755  			; XDEF	LOMEM
044987             11756  			; XDEF 	FREE
044987             11757  			; XDEF	HIMEM
044987             11758  			; XDEF	LINENO
044987             11759  			; XDEF	TRACEN
044987             11760  			; XDEF	AUTONO
044987             11761  			; XDEF	ERRTRP
044987             11762  			; XDEF	ERRTXT
044987             11763  			; XDEF	DATPTR
044987             11764  			; XDEF	ERL
044987             11765  			; XDEF	ERRLIN
044987             11766  			; XDEF	RANDOM
044987             11767  			; XDEF	COUNT
044987             11768  			; XDEF	WIDTH
044987             11769  			; XDEF	ERR
044987             11770  			; XDEF	LISTON
044987             11771  			; XDEF	INCREM
044987             11772  
044987             11773  			; XDEF	FLAGS
044987             11774  			; XDEF	OSWRCHPT
044987             11775  			; XDEF	OSWRCHCH
044987             11776  			; XDEF	OSWRCHFH
044987             11777  			; XDEF	KEYDOWN
044987             11778  			; XDEF	KEYASCII
044987             11779  			; XDEF	KEYCOUNT
044987             11780  
044987             11781  			; XDEF	R0
044987             11782  			; XDEF	R1
044987             11783  
044987             11784  			; XDEF	RAM_START
044987             11785  			; XDEF	RAM_END
044987             11786  			; XDEF	USER
044987             11787  
044987 FF FF FF FF 11788  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
044A00             11789  RAM_START:
044A00             11790  ;
044A00 00 00 00 00 11791  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 11792  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 11793  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 11794  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    11795  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    11796  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             11797  ;
044D14 00 00 00    11798  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    11799  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    11800  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    11801  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    11802  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             11803  ;
044D23 00 00 00    11804  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    11805  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    11806  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    11807  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       11808  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       11809  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       11810  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    11811  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 11812  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          11813  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          11814  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          11815  ERR:            BLKB    1,0               ; Error Number
044D40 00          11816  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             11817                                  ; - BIT 0: If set, output a space after the line number
044D41             11818                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             11819                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             11820                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             11821                                  ; OPT FLAG (top nibble)
044D41             11822                                  ; - BIT 4: If set, then list whilst assembling
044D41             11823                                  ; - BIT 5: If set, then assembler errors are reported
044D41             11824                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             11825                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          11826  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             11827  ;
044D42             11828  ; --------------------------------------------------------------------------------------------
044D42             11829  ; BEGIN MODIFIED CODE
044D42             11830  ; --------------------------------------------------------------------------------------------
044D42             11831  ; Originally in equs.inc
044D42             11832  ;
044D42             11833  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
044D42             11834  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
044D42             11835  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044D42             11836  ; --------------------------------------------------------------------------------------------
044D42             11837  ; END MODIFIED CODE
044D42             11838  ; --------------------------------------------------------------------------------------------
044D42             11839  
044D42             11840  ; Extra Agon-implementation specific system variables
044D42             11841  ;
044D42 00          11842  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             11843                                  ; - BIT 7: Set if ESC pressed
044D43             11844                                  ; - BIT 6: Set to disable ESC
044D43 00 00       11845  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          11846  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             11847                                  ; - 0: Console
044D46             11848                                  ; - 1: File
044D46 00          11849  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          11850  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          11851  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          11852  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    11853  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    11854  R1:             BLKB    3,0
044D50             11855  
044D50             11856  ;
044D50             11857  ; This must be at the end
044D50             11858  ;
044D50             11859  RAM_END:
044D50 FF FF FF FF 11860  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
044E00             11861  USER:							; Must be aligned on a page boundary
044E00             11862  	; --- End ram.asm ---
044E00             11863  
