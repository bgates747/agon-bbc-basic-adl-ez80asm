PC     Output      Line
040000             0001  ; --- Begin mos_api.inc ---
040000             0002  ;
040000             0003  ; Title:	AGON MOS - API for user projects
040000             0004  ; Author:	Dean Belfield
040000             0005  ; Created:	03/08/2022
040000             0006  ; Last Updated:	11/11/2023
040000             0007  ;
040000             0008  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0009  ;
040000             0010  ; Modinfo:
040000             0011  ; 05/08/2022:	Added mos_feof
040000             0012  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0013  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0014  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0015  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0016  ; 13/10/2022:	Added mos_oscli
040000             0017  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0018  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0019  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0020  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0021  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0022  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0023  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0024  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0025  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0026  ; 19/05/2023:	Added sysvar_scrMode
040000             0027  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0028  ; 03/08/2023:	Added mos_setkbvector
040000             0029  ; 10/08/2023:	Added mos_getkbmap
040000             0030  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0031  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0032  ;
040000             0033  ; VDP control (VDU 23, 0, n)
040000             0034  ;
040000             0035  vdp_gp:			EQU 	80h
040000             0036  vdp_keycode:		EQU 	81h
040000             0037  vdp_cursor:		EQU	82h
040000             0038  vdp_scrchar:		EQU	83h
040000             0039  vdp_scrpixel:		EQU	84h
040000             0040  vdp_audio:		EQU	85h
040000             0041  vdp_mode:		EQU	86h
040000             0042  vdp_rtc:		EQU	87h
040000             0043  vdp_keystate:		EQU	88h
040000             0044  vdp_logicalcoords:	EQU	C0h
040000             0045  vdp_terminalmode:	EQU	FFh
040000             0046  
040000             0047  ; MOS high level functions
040000             0048  ;
040000             0049  mos_getkey:		EQU	00h
040000             0050  mos_load:		EQU	01h
040000             0051  mos_save:		EQU	02h
040000             0052  mos_cd:			EQU	03h
040000             0053  mos_dir:		EQU	04h
040000             0054  mos_del:		EQU	05h
040000             0055  mos_ren:		EQU	06h
040000             0056  mos_mkdir:		EQU	07h
040000             0057  mos_sysvars:		EQU	08h
040000             0058  mos_editline:		EQU	09h
040000             0059  mos_fopen:		EQU	0Ah
040000             0060  mos_fclose:		EQU	0Bh
040000             0061  mos_fgetc:		EQU	0Ch
040000             0062  mos_fputc:		EQU	0Dh
040000             0063  mos_feof:		EQU	0Eh
040000             0064  mos_getError:		EQU	0Fh
040000             0065  mos_oscli:		EQU	10h
040000             0066  mos_copy:		EQU	11h
040000             0067  mos_getrtc:		EQU	12h
040000             0068  mos_setrtc:		EQU	13h
040000             0069  mos_setintvector:	EQU	14h
040000             0070  mos_uopen:		EQU	15h
040000             0071  mos_uclose:		EQU	16h
040000             0072  mos_ugetc:		EQU	17h
040000             0073  mos_uputc:		EQU 	18h
040000             0074  mos_getfil:		EQU	19h
040000             0075  mos_fread:		EQU	1Ah
040000             0076  mos_fwrite:		EQU	1Bh
040000             0077  mos_flseek:		EQU	1Ch
040000             0078  mos_setkbvector:	EQU	1Dh
040000             0079  mos_getkbmap:		EQU	1Eh
040000             0080  mos_i2c_open:		EQU	1Fh
040000             0081  mos_i2c_close:		EQU	20h
040000             0082  mos_i2c_write:		EQU	21h
040000             0083  mos_i2c_read:		EQU	22h
040000             0084  
040000             0085  
040000             0086  ; FatFS file access functions
040000             0087  ;
040000             0088  ffs_fopen:		EQU	80h
040000             0089  ffs_fclose:		EQU	81h
040000             0090  ffs_fread:		EQU	82h
040000             0091  ffs_fwrite:		EQU	83h
040000             0092  ffs_flseek:		EQU	84h
040000             0093  ffs_ftruncate:		EQU	85h
040000             0094  ffs_fsync:		EQU	86h
040000             0095  ffs_fforward:		EQU	87h
040000             0096  ffs_fexpand:		EQU	88h
040000             0097  ffs_fgets:		EQU	89h
040000             0098  ffs_fputc:		EQU	8Ah
040000             0099  ffs_fputs:		EQU	8Bh
040000             0100  ffs_fprintf:		EQU	8Ch
040000             0101  ffs_ftell:		EQU	8Dh
040000             0102  ffs_feof:		EQU	8Eh
040000             0103  ffs_fsize:		EQU	8Fh
040000             0104  ffs_ferror:		EQU	90h
040000             0105  
040000             0106  ; FatFS directory access functions
040000             0107  ;
040000             0108  ffs_dopen:		EQU	91h
040000             0109  ffs_dclose:		EQU	92h
040000             0110  ffs_dread:		EQU	93h
040000             0111  ffs_dfindfirst:		EQU	94h
040000             0112  ffs_dfindnext:		EQU	95h
040000             0113  
040000             0114  ; FatFS file and directory management functions
040000             0115  ;
040000             0116  ffs_stat:		EQU	96h
040000             0117  ffs_unlink:		EQU	97h
040000             0118  ffs_rename:		EQU	98h
040000             0119  ffs_chmod:		EQU	99h
040000             0120  ffs_utime:		EQU	9Ah
040000             0121  ffs_mkdir:		EQU	9Bh
040000             0122  ffs_chdir:		EQU	9Ch
040000             0123  ffs_chdrive:		EQU	9Dh
040000             0124  ffs_getcwd:		EQU	9Eh
040000             0125  
040000             0126  ; FatFS volume management and system configuration functions
040000             0127  ;
040000             0128  ffs_mount:		EQU	9Fh
040000             0129  ffs_mkfs:		EQU	A0h
040000             0130  ffs_fdisk:		EQU	A1h
040000             0131  ffs_getfree:		EQU	A2h
040000             0132  ffs_getlabel:		EQU	A3h
040000             0133  ffs_setlabel:		EQU	A4h
040000             0134  ffs_setcp:		EQU	A5h
040000             0135  
040000             0136  ; File access modes
040000             0137  ;
040000             0138  fa_read:		EQU	01h
040000             0139  fa_write:		EQU	02h
040000             0140  fa_open_existing:	EQU	00h
040000             0141  fa_create_new:		EQU	04h
040000             0142  fa_create_always:	EQU	08h
040000             0143  fa_open_always:		EQU	10h
040000             0144  fa_open_append:		EQU	30h
040000             0145  
040000             0146  ; System variable indexes for api_sysvars
040000             0147  ; Index into _sysvars in globals.asm
040000             0148  ;
040000             0149  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0150  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0151  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0152  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0153  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0154  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0155  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0156  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0157  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0158  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0159  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0160  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0161  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0162  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0163  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0164  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0165  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0166  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0167  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0168  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0169  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0170  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0171  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0172  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0173  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0174  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0175  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0176  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0177  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0178  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0179  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0180  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0181  ;
040000             0182  ; Flags for the VPD protocol
040000             0183  ;
040000             0184  vdp_pflag_cursor:	EQU	00000001b
040000             0185  vdp_pflag_scrchar:	EQU	00000010b
040000             0186  vdp_pflag_point:	EQU	00000100b
040000             0187  vdp_pflag_audio:	EQU	00001000b
040000             0188  vdp_pflag_mode:		EQU	00010000b
040000             0189  vdp_pflag_rtc:		EQU	00100000b
040000             0190  vdp_pflag_mouse:	EQU	01000000b
040000             0191  ; vdp_pflag_buffered:	EQU	10000000b
040000             0192  
040000             0193  
040000             0194  ; FatFS structures
040000             0195  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0196  ;
040000             0197  ; Object ID and allocation information (FFOBJID)
040000             0198  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0199  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0200  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0201  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0202  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0203  FFOBJID.objsize:  EQU 11   ; Object size
040000             0204  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0205  ;
040000             0206  ; File object structure (FIL)
040000             0207  ;
040000             0208  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0209  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0210  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0211  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0212  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0213  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0214  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0215  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0216  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0217  ;
040000             0218  ; Directory object structure (DIR)
040000             0219  ;
040000             0220  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0221  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0222  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0223  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0224  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0225  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0227  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0228  ;
040000             0229  ; File information structure (FILINFO)
040000             0230  ;
040000             0231  FILINFO.fsize:    EQU 0    ; File size
040000             0232  FILINFO.fdate:    EQU 4    ; Modified date
040000             0233  FILINFO.ftime:    EQU 6    ; Modified time
040000             0234  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0235  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0236  FILINFO.fname:    EQU 22   ; Primary file name
040000             0237  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0238  ;
040000             0239  ; Macro for calling the API
040000             0240  ; Parameters:
040000             0241  ; - function: One of the function numbers listed above
040000             0242  ;
040000             0243  			MACRO MOSCALL	function
040000             0244  			LD	A, function
040000             0245  			RST.LIS	08h
040000             0246  			ENDMACRO 	; --- End mos_api.inc ---
040000             0247  
040000             0248  ; --- Begin macros.inc ---
040000             0249  	; Title:	BBC Basic Interpreter - Z80 version
040000             0250  	;		Useful macros
040000             0251  	; Author:	Dean Belfield
040000             0252  	; Created:	12/05/2023
040000             0253  	; Last Updated:	11/06/2023
040000             0254  	;
040000             0255  	; Modinfo:
040000             0256  	; 11/06/2023:	Modified to run in ADL mode
040000             0257  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0258  
040000             0259  	MACRO EXREG	rp1, rp2
040000             0260  		PUSH	rp1
040000             0261  		POP	rp2
040000             0262  	ENDMACRO
040000             0263  
040000             0264  	; MACRO ADD8U_DE	reg
040000             0265  		MACRO ADD8U_DE
040000             0266  		ADD	A, E
040000             0267  		LD	E, A
040000             0268  		ADC	A, D
040000             0269  		SUB	E
040000             0270  		LD	D, A
040000             0271  	ENDMACRO
040000             0272  
040000             0273  	; MACRO ADD8U_HL	reg
040000             0274  	MACRO ADD8U_HL
040000             0275  		ADD	A, L
040000             0276  		LD	L, A
040000             0277  		ADC	A, H
040000             0278  		SUB	L
040000             0279  		LD	H, A
040000             0280  	ENDMACRO
040000             0281  
040000             0282  	MACRO VDU	val
040000             0283  		LD	A, val
040000             0284  		CALL	OSWRCH
040000             0285  	ENDMACRO
040000             0286  
040000             0287  	MACRO SET_GPIO	reg, val
040000             0288  		IN0	A, (reg)
040000             0289  		OR	val
040000             0290  		OUT0	(reg), A
040000             0291  	ENDMACRO
040000             0292  
040000             0293  	MACRO RES_GPIO	reg, val
040000             0294  		PUSH	BC
040000             0295  		LD	A, val
040000             0296  		CPL
040000             0297  		LD	C, A
040000             0298  		IN0	A, (reg)
040000             0299  		AND	C
040000             0300  		OUT0	(reg), A
040000             0301  		POP	BC
040000             0302  	ENDMACRO
040000             0303  ; --- End macros.inc ---
040000             0304  
040000             0305  ; --- Begin equs.inc ---
040000             0306  ;
040000             0307  ; Title:	BBC Basic for AGON - Equs
040000             0308  ; Author:	Dean Belfield
040000             0309  ; Created:	12/05/2023
040000             0310  ; Last Updated:	08/06/2023
040000             0311  ;
040000             0312  ; Modinfo:
040000             0313  ; 08/06/2023:	Added SIZEW
040000             0314  
040000             0315  			; XREF		STAVAR
040000             0316  			; XREF		ACCS
040000             0317  
040000             0318  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0319  ;Stack_Top:		EQU		0000h	; Stack at top
040000             0320  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0321  
040000             0322  ; For GPIO
040000             0323  ; PA not available on eZ80L92
040000             0324  ;
040000             0325  PA_DR:			EQU		96h
040000             0326  PA_DDR:			EQU		97h
040000             0327  PA_ALT1:		EQU		98h
040000             0328  PA_ALT2:		EQU		99h
040000             0329  PB_DR:          	EQU		9Ah
040000             0330  PB_DDR:        	 	EQU		9Bh
040000             0331  PB_ALT1:        	EQU		9Ch
040000             0332  PB_ALT2:        	EQU		9Dh
040000             0333  PC_DR:          	EQU		9Eh
040000             0334  PC_DDR:         	EQU		9Fh
040000             0335  PC_ALT1:        	EQU		A0h
040000             0336  PC_ALT2:        	EQU		A1h
040000             0337  PD_DR:          	EQU		A2h
040000             0338  PD_DDR:			EQU		A3h
040000             0339  PD_ALT1:		EQU		A4h
040000             0340  PD_ALT2:		EQU		A5h
040000             0341  
040000             0342  GPIOMODE_OUT:		EQU		0	; Output
040000             0343  GPIOMODE_IN:		EQU		1	; Input
040000             0344  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0345  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0346  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0347  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0348  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0349  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0350  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0351  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0352  
040000             0353  ; ; Originally in ram.asm
040000             0354  ; ;
040000             0355  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040000             0356  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040000             0357  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040000             0358  
040000             0359  ; Originally in main.asm
040000             0360  ;
040000             0361  CR:			EQU     0DH
040000             0362  LF:			EQU     0AH
040000             0363  ESC:			EQU     1BH
040000             0364  ; --- End equs.inc ---
040000             0365  
040000             0366  ; --- Begin init.asm ---
040000             0367  ;
040000             0368  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0369  ;		Initialisation Code
040000             0370  ; Author:	Dean Belfield
040000             0371  ; Created:	12/05/2023
040000             0372  ; Last Updated:	26/11/2023
040000             0373  ;
040000             0374  ; Modinfo:
040000             0375  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0376  ; 26/11/2023:	Moved the ram clear routine into here
040000             0377  
040000             0378  			; SEGMENT CODE
040000             0379  
040000             0380  			; XDEF	_end
040000             0381  
040000             0382  			; XREF	_main				; In main.asm
040000             0383  
040000             0384  			; XREF	RAM_START			; In ram.asm
040000             0385  			; XREF	RAM_END
040000             0386  
040000             0387  			; .ASSUME	ADL = 1
040000             0388  
040000             0389  			; INCLUDE	"equs.inc"
040000             0390  
040000             0391  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0392  
040000             0393  ;
040000             0394  ; Start in ADL mode
040000             0395  ;
040000 C3 45 00 04 0396  			JP	_start				; Jump to start
040004             0397  ;
040004             0398  ; The header stuff is from byte 64 onwards
040004             0399  ;
040004 42 42 43 42 0400  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040011             0401  
040011 FF FF FF FF 0402  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0403  
040040 4D 4F 53    0404  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0405  			DB	00h				; MOS header version 0
040044 01          0406  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0407  ;
040045             0408  ; And the code follows on immediately after the header
040045             0409  ;
040045 F5          0410  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0411  			PUSH		BC
040047 D5          0412  			PUSH		DE
040048 DD E5       0413  			PUSH		IX
04004A FD E5       0414  			PUSH		IY
04004C             0415  
04004C ED 73 D7 00 0416  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0417  
040051 DD 21 DA 00 0418  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0419  			PUSH		IX
040058 CD 88 00 04 0420  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0421  			POP		IX			; IX: argv
04005E 06 00       0422  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0423  			CALL		_clear_ram
040064 C3 B6 2F 04 0424  			JP		_main			; Start user code
040068             0425  ;
040068             0426  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0427  ;
040068 ED 7B D7 00 0428  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0429  
04006D FD E1       0430  			POP		IY			; Restore the registers
04006F DD E1       0431  			POP		IX
040071 D1          0432  			POP		DE
040072 C1          0433  			POP		BC
040073 F1          0434  			POP		AF
040074 C9          0435  			RET					; Return to MOS
040075             0436  
040075             0437  ;Clear the application memory
040075             0438  ;
040075 C5          0439  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0440  			LD		HL, RAM_START
04007A 11 01 4A 04 0441  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0442  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0443  			XOR		A
040083 77          0444  			LD		(HL), A
040084 ED B0       0445  			LDIR
040086 C1          0446  			POP		BC
040087 C9          0447  			RET
040088             0448  
040088             0449  ; Parse the parameter string into a C array
040088             0450  ; Parameters
040088             0451  ; - HL: Address of parameter string
040088             0452  ; - IX: Address for array pointer storage
040088             0453  ; Returns:
040088             0454  ; -  C: Number of parameters parsed
040088             0455  ;
040088 01 04 00 04 0456  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0457  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0458  			INC	IX
040091 DD 23       0459  			INC	IX
040093 DD 23       0460  			INC	IX
040095 CD D0 00 04 0461  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0462  ;
040099 01 01 00 00 0463  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0464  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0465  ;
04009F             0466  _parse_params_1:
04009F C5          0467  			PUSH	BC			; Stack ARGC
0400A0 E5          0468  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0469  			CALL	_get_token		; Get the next token
0400A5 79          0470  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0471  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0472  			POP	BC			; ARGC
0400A8 B7          0473  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0474  			RET	Z
0400AA             0475  ;
0400AA DD 1F 00    0476  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0477  			PUSH	HL			; DE=HL
0400AE D1          0478  			POP	DE
0400AF CD D0 00 04 0479  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0480  			XOR	A
0400B4 12          0481  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0482  			INC	IX
0400B7 DD 23       0483  			INC	IX
0400B9 DD 23       0484  			INC	IX			; Advance to next pointer position
0400BB 0C          0485  			INC	C			; Increment ARGC
0400BC 79          0486  			LD	A, C			; Check for C >= A
0400BD B8          0487  			CP	B
0400BE 38 DF       0488  			JR	C, _parse_params_1	; And loop
0400C0 C9          0489  			RET
0400C1             0490  
0400C1             0491  ; Get the next token
0400C1             0492  ; Parameters:
0400C1             0493  ; - HL: Address of parameter string
0400C1             0494  ; Returns:
0400C1             0495  ; - HL: Address of first character after token
0400C1             0496  ; -  C: Length of token (in characters)
0400C1             0497  ;
0400C1 0E 00       0498  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0499  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0500  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0501  			RET 	Z
0400C6 FE 0D       0502  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0503  			RET	Z
0400C9 FE 20       0504  			CP	' '			; Exit if space (end of token)
0400CB C8          0505  			RET	Z
0400CC 23          0506  			INC	HL			; Advance to next character
0400CD 0C          0507  			INC 	C			; Increment length
0400CE 18 F3       0508  			JR	@B
0400D0             0509  
0400D0             0510  ; Skip spaces in the parameter string
0400D0             0511  ; Parameters:
0400D0             0512  ; - HL: Address of parameter string
0400D0             0513  ; Returns:
0400D0             0514  ; - HL: Address of next none-space character
0400D0             0515  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0516  ;
0400D0 7E          0517  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0518  			CP	' '			; Exit if not space
0400D3 C0          0519  			RET	NZ
0400D4 23          0520  			INC	HL			; Advance to next character
0400D5 18 F9       0521  			JR	_skip_spaces		; Increment length
0400D7             0522  
0400D7             0523  ; Storage
0400D7             0524  ;
0400D7             0525  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0526  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers; --- End init.asm ---
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0527  
04010A             0528  ; --- Begin eval.asm ---
04010A             0529  ;
04010A             0530  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0531  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0532  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0533  ; Modified By:	Dean Belfield
04010A             0534  ; Created:	12/05/2023
04010A             0535  ; Last Updated:	17/08/2023
04010A             0536  ;
04010A             0537  ; Modinfo:
04010A             0538  ; 07/06/2023:	Modified to run in ADL mode
04010A             0539  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0540  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0541  ; 17/08/2023:	Added binary constants
04010A             0542  
04010A             0543  			; .ASSUME	ADL = 1
04010A             0544  
04010A             0545  			; INCLUDE	"equs.inc"
04010A             0546  			; INCLUDE "macros.inc"
04010A             0547  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0548  
04010A             0549  			; SEGMENT CODE
04010A             0550  
04010A             0551  			; XDEF	EXPR
04010A             0552  			; XDEF	EXPRN
04010A             0553  			; XDEF	EXPRI
04010A             0554  			; XDEF	EXPRS
04010A             0555  			; XDEF	ITEMI
04010A             0556  			; XDEF	LOADN
04010A             0557  			; XDEF	LOAD4
04010A             0558  			; XDEF	CONS
04010A             0559  			; XDEF	LOADS
04010A             0560  			; XDEF	SFIX
04010A             0561  			; XDEF	VAL0
04010A             0562  			; XDEF	SEARCH
04010A             0563  			; XDEF	SWAP
04010A             0564  			; XDEF	TEST
04010A             0565  			; XDEF	DECODE
04010A             0566  			; XDEF	HEXSTR
04010A             0567  			; XDEF	STR
04010A             0568  			; XDEF	ZERO
04010A             0569  			; XDEF	PUSHS
04010A             0570  			; XDEF	POPS
04010A             0571  			; XDEF	COMMA
04010A             0572  			; XDEF	BRAKET
04010A             0573  			; XDEF	NXT
04010A             0574  			; XDEF	COUNT0
04010A             0575  
04010A             0576  			; XREF	ADVAL
04010A             0577  			; XREF	FN_EX
04010A             0578  			; XREF	POINT
04010A             0579  			; XREF	USR
04010A             0580  			; XREF	SYNTAX
04010A             0581  			; XREF	ERROR_
04010A             0582  			; XREF	CHECK
04010A             0583  			; XREF	GETVAR
04010A             0584  			; XREF	LISTON
04010A             0585  			; XREF	RANGE
04010A             0586  			; XREF	FPP
04010A             0587  			; XREF	GETCSR
04010A             0588  			; XREF	CHANEL
04010A             0589  			; XREF	OSSTAT
04010A             0590  			; XREF	OSBGET
04010A             0591  			; XREF	LOMEM
04010A             0592  			; XREF	HIMEM
04010A             0593  			; XREF	PAGE_
04010A             0594  			; XREF	TOP
04010A             0595  			; XREF	ERL
04010A             0596  			; XREF	ERR
04010A             0597  			; XREF	COUNT
04010A             0598  			; XREF	OSOPEN
04010A             0599  			; XREF	GETEXT
04010A             0600  			; XREF	GETPTR
04010A             0601  			; XREF	GETIME
04010A             0602  			; XREF	GETIMS
04010A             0603  			; XREF	LEXAN2
04010A             0604  			; XREF	RANDOM
04010A             0605  			; XREF	STORE5
04010A             0606  			; XREF	GETSCHR
04010A             0607  			; XREF	OSRDCH
04010A             0608  			; XREF	OSKEY
04010A             0609  			; XREF	INKEY1
04010A             0610  			; XREF	EXTERR
04010A             0611  ;
04010A             0612  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0613  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0614  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0615  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0616  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0617  ;
04010A             0618  ; BINARY INTEGER REPRESENTATION:
04010A             0619  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0620  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0621  ;
04010A             0622  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0623  ;                             EXPONENT - C
04010A             0624  ;
04010A             0625  
04010A             0626  ;
04010A             0627  ; Table of addresses for functions
04010A             0628  ;
04010A             0629  FUNTOK:			EQU	8DH			; First token number
04010A             0630  ;
04010A E6 08 04    0631  FUNTBL:			DW24	DECODE			; Line number
04010D 94 05 04    0632  			DW24	OPENIN			; OPENIN
040110 B6 05 04    0633  			DW24	PTR_EV			; PTR
040113 50 05 04    0634  			DW24	PAGEV			; PAGE
040116 C0 05 04    0635  			DW24	TIMEV			; TIME
040119 3C 05 04    0636  			DW24	LOMEMV			; LOMEM
04011C 46 05 04    0637  			DW24	HIMEMV			; HIMEM
04011F 14 06 04    0638  			DW24	ABSV			; ABS
040122 50 06 04    0639  			DW24	ACS			; ACS
040125 B7 43 04    0640  			DW24	ADVAL			; ADVAL
040128 25 05 04    0641  			DW24	ASC			; ASC
04012B 48 06 04    0642  			DW24	ASN			; ASN
04012E 4C 06 04    0643  			DW24	ATN			; ATN
040131 EE 04 04    0644  			DW24	BGET			; BGET
040134 34 06 04    0645  			DW24	COS			; COS
040137 7B 05 04    0646  			DW24	COUNTV			; COUNT
04013A 1C 06 04    0647  			DW24	DEG			; DEG
04013D 6F 05 04    0648  			DW24	ERLV			; ERL
040140 75 05 04    0649  			DW24	ERRV			; ERR
040143 79 06 04    0650  			DW24	EVAL_			; EVAL
040146 3C 06 04    0651  			DW24	EXP			; EXP
040149 AC 05 04    0652  			DW24	EXT			; EXT
04014C 93 09 04    0653  			DW24	ZERO			; FALSE
04014F 7F 10 04    0654  			DW24	FN_EX			; FN
040152 0C 05 04    0655  			DW24	GET			; GET
040155 FB 04 04    0656  			DW24	INKEY			; INKEY
040158 2B 07 04    0657  			DW24	INSTR			; INSTR(
04015B 28 06 04    0658  			DW24	INT_			; INT
04015E 35 05 04    0659  			DW24	LEN			; LEN
040161 40 06 04    0660  			DW24	LN			; LN
040164 44 06 04    0661  			DW24	LOG			; LOG
040167 18 06 04    0662  			DW24	NOTK			; NOT
04016A 90 05 04    0663  			DW24	OPENUP			; OPENUP
04016D 8D 05 04    0664  			DW24	OPENOT			; OPENOUT
040170 10 06 04    0665  			DW24	PI			; PI
040173 69 44 04    0666  			DW24	POINT			; POINT(
040176 CD 04 04    0667  			DW24	POS			; POS
040179 20 06 04    0668  			DW24	RAD			; RAD
04017C AD 06 04    0669  			DW24	RND			; RND
04017F 24 06 04    0670  			DW24	SGN			; SGN
040182 38 06 04    0671  			DW24	SIN			; SIN
040185 2C 06 04    0672  			DW24	SQR			; SQR
040188 30 06 04    0673  			DW24	TAN			; TAN
04018B 5A 05 04    0674  			DW24	TOPV			; TO(P)
04018E 05 06 04    0675  			DW24	TRUE			; TRUE
040191 22 15 04    0676  			DW24	USR			; USR
040194 6A 06 04    0677  			DW24	VAL			; VAL
040197 D6 04 04    0678  			DW24	VPOS			; VPOS
04019A BF 07 04    0679  			DW24	CHRS			; CHRS
04019D C7 07 04    0680  			DW24	GETS			; GETS
0401A0 D8 07 04    0681  			DW24	INKEYS			; INKEYS
0401A3 5D 08 04    0682  			DW24	LEFTS			; LEFTS(
0401A6 25 08 04    0683  			DW24	MIDS			; MIDS(
0401A9 7D 08 04    0684  			DW24	RIGHTS			; RIGHTS(
0401AC 4A 09 04    0685  			DW24	STRS			; STR$
0401AF 9E 08 04    0686  			DW24	STRING_			; STRINGS(
0401B2 DE 04 04    0687  			DW24	EOF			; EOF
0401B5             0688  ;
0401B5             0689  FUNTBL_END:		EQU	$
0401B5             0690  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0691  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0692  
0401B5             0693  ANDK:			EQU     80H
0401B5             0694  DIVK:			EQU     81H
0401B5             0695  EORK:			EQU     82H
0401B5             0696  MODK:			EQU     83H
0401B5             0697  ORK:			EQU     84H
0401B5             0698  ;
0401B5 F0 05 04    0699  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 F9 05 04    0700  			DW24	SNE			; <>
0401BB E9 05 04    0701  			DW24	SGE			; >=
0401BE DA 05 04    0702  			DW24	SLT			; <
0401C1 00 06 04    0703  			DW24	SEQ			; =
0401C4 E1 05 04    0704  			DW24	SGT			; >
0401C7             0705  ;
0401C7             0706  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0707  ;     Expression type is returned in A'F':
0401C7             0708  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0709  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0710  ; Floating-point or integer result returned in HLH'L'C
0401C7             0711  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0712  ; String result returned in string accumulator, DE set.
0401C7             0713  ;
0401C7             0714  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0715  ;               (2) ^
0401C7             0716  ;               (3) * / MOD DIV
0401C7             0717  ;               (4) + -
0401C7             0718  ;               (5) = <> <= >= > <
0401C7             0719  ;               (6) AND
0401C7             0720  ;               (7) EOR OR
0401C7             0721  
0401C7             0722  ;
0401C7             0723  ; Level 7: EOR and OR
0401C7             0724  ;
0401C7 CD E0 01 04 0725  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0726  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0727  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0728  			CP      ORK			; Is operator OR
0401D1 C0          0729  			RET     NZ			; No, so return
0401D2             0730  ;
0401D2 CD 3E 0A 04 0731  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0732  			CALL    EXPR1           	; Get second operand
0401DA CD 4D 0A 04 0733  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0734  			JR      EXPR0A          	; And continue
0401E0             0735  ;
0401E0             0736  ; Level 6: AND
0401E0             0737  ;
0401E0 CD F5 01 04 0738  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0739  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0740  			RET     NZ			; No, so return
0401E7 CD 3E 0A 04 0741  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0742  			CALL    EXPR2			; Get second operand
0401EF CD 4D 0A 04 0743  			CALL    DOIT			; Do the operation
0401F3 18 EF       0744  			JR      EXPR1A			; And continue
0401F5             0745  ;
0401F5             0746  ; Level 5: Comparisons
0401F5             0747  ;
0401F5 CD 67 02 04 0748  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 15 0A 04 0749  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0750  			RET     NZ			; No, so return
0401FE 47          0751  			LD      B,A			; Store the first operator in B
0401FF FD 23       0752  			INC     IY              	; Bump over operator
040201 CD 70 0A 04 0753  			CALL    NXT			;
040205 CD 15 0A 04 0754  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0755  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0756  			INC     IY			; Bump over operator
04020D B8          0757  			CP      B			; Compare with first
04020E CA 97 0C 04 0758  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0759  			ADD     A,B
040213 47          0760  			LD      B,A			; B: Unique code for the compound operator
040214 78          0761  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0762  			EX      AF,AF'
040216 FA 30 02 04 0763  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0764  			EX      AF,AF'
04021B D6 04       0765  			SUB     4
04021D FE 3A       0766  			CP      '>'-4
04021F 20 02       0767  			JR      NZ,EXPR2C
040221 C6 02       0768  			ADD     A,2
040223 CD 40 0A 04 0769  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0770  			CALL    EXPR3
04022B CD 4D 0A 04 0771  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0772  			RET
040230             0773  ;
040230 08          0774  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0775  			DEC     A
040232 E6 07       0776  			AND     7
040234 CD B4 09 04 0777  			CALL    PUSHS           	; Save string on the stack
040238 F5          0778  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0779  			CALL    EXPR3           	; Get the second string
04023D 08          0780  			EX      AF,AF'
04023E F2 36 03 04 0781  			JP      P,TYPE_EV_
040242 F1          0782  			POP     AF
040243 4B          0783  			LD      C,E             	; Length of string #2
040244 D1          0784  			POP     DE
040245 21 00 00 00 0785  			LD      HL,0
040249 39          0786  			ADD     HL,SP
04024A 43          0787  			LD      B,E             	; Length of string #1
04024B D5          0788  			PUSH    DE
04024C 11 00 4A 04 0789  			LD      DE,ACCS
040250 EB          0790  			EX      DE,HL
040251 CD 7C 0A 04 0791  			CALL    DISPT2
040255 D1          0792  			POP     DE
040256 EB          0793  			EX      DE,HL
040257 7D          0794  			LD	A,L
040258 21 00 00 00 0795  			LD	HL,0
04025C 6F          0796  			LD	L,A
04025D 39          0797  			ADD     HL,SP
04025E F9          0798  			LD      SP,HL
04025F EB          0799  			EX      DE,HL
040260 AF          0800  			XOR     A               	; Numeric marker
040261 4F          0801  			LD      C,A             	; Integer marker
040262 08          0802  			EX      AF,AF'
040263 FD 7E 00    0803  			LD      A,(IY)
040266 C9          0804  			RET
040267             0805  ;
040267             0806  ; Level 4: + and -
040267             0807  ;
040267 CD C4 02 04 0808  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0809  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0810  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0811  			CP      '+'			; Is it "+"?
040271 C0          0812  			RET     NZ			; No, so return
040272 08          0813  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0814  			JP      M,EXPR3S		; Branch here if string
040277 08          0815  			EX      AF,AF'
040278 CD 3E 0A 04 0816  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C4 02 04 0817  			CALL    EXPR4			; Fetch the second operator
040280 CD 4D 0A 04 0818  			CALL    DOIT			; Do the operation
040284 18 E5       0819  			JR      EXPR3A			; And continue
040286             0820  ;
040286 08          0821  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0822  			INC     IY              	; Bump past the "+"
040289 CD B4 09 04 0823  			CALL    PUSHS           	; Save the string on the stack
04028D CD C4 02 04 0824  			CALL    EXPR4           	; Fetch the second operator
040291 08          0825  			EX      AF,AF'
040292 F2 36 03 04 0826  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0827  			LD	BC, 0			; Clear BC
04029A 4B          0828  			LD      C,E             	; C: Length of the second string
04029B D1          0829  			POP     DE
04029C D5          0830  			PUSH    DE
04029D 21 00 4A 04 0831  			LD      HL,ACCS
0402A1             0832  ; BEGIN MISSING FROM BINARY
0402A1             0833  			; LD	A,E			;  E: Length of the first string
0402A1             0834  			; LD      DE,ACCS
0402A1             0835  			; LD	E,A 			; DE: Pointer to the end of the first string
0402A1             0836  ; END MISSING FROM BINARY
0402A1 54          0837  			LD		D,H ; ADDED FROM BINARY
0402A2 79          0838  			LD      A,C
0402A3 B7          0839  			OR      A
0402A4 28 0F       0840  			JR      Z,EXP3S3
0402A6 6F          0841  			LD      L,A             	; Source
0402A7 83          0842  			ADD     A,E
0402A8 5F          0843  			LD      E,A             	; Destination
0402A9 3E 13       0844  			LD      A,19
0402AB DA 60 37 04 0845  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402AF D5          0846  			PUSH    DE
0402B0 1D          0847  			DEC     E
0402B1 2D          0848  			DEC     L
0402B2 ED B8       0849  			LDDR                    	; Copy
0402B4 D1          0850  			POP     DE
0402B5 D9          0851  EXP3S3:			EXX
0402B6 C1          0852  			POP     BC
0402B7 CD DE 09 04 0853  			CALL    POPS            	; Restore from stack
0402BB D9          0854  			EXX
0402BC F6 80       0855  			OR      80H             	; Flag as a string
0402BE 08          0856  			EX      AF,AF'
0402BF FD 7E 00    0857  			LD      A,(IY)			; Fetch the next character
0402C2 18 A7       0858  			JR      EXPR3A			; And continue
0402C4             0859  ;
0402C4             0860  ; Level 3: * / MOD DIV
0402C4             0861  ;
0402C4 CD E5 02 04 0862  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402C8 FE 2A       0863  EXPR4A:			CP      '*'			; "*" is valid
0402CA 28 0B       0864  			JR      Z,EXPR4B
0402CC FE 2F       0865  			CP      '/'			; "/" is valid
0402CE 28 07       0866  			JR      Z,EXPR4B
0402D0 FE 83       0867  			CP      MODK			; MOD token is valid
0402D2 28 03       0868  			JR      Z,EXPR4B
0402D4 FE 81       0869  			CP      DIVK			; DIV token is valid
0402D6 C0          0870  			RET     NZ			; And return if it is anything else
0402D7 CD 3E 0A 04 0871  EXPR4B:			CALL    SAVE_EV
0402DB CD E5 02 04 0872  			CALL    EXPR5
0402DF CD 4D 0A 04 0873  			CALL    DOIT
0402E3 18 E3       0874  			JR      EXPR4A
0402E5             0875  ;
0402E5             0876  ; Level 2: ^
0402E5             0877  ;
0402E5 CD C5 03 04 0878  EXPR5:			CALL    ITEM			; Get variable
0402E9 B7          0879  			OR      A               	; Test type
0402EA 08          0880  			EX      AF,AF'          	; Save type
0402EB CD 70 0A 04 0881  EXPR5A:			CALL    NXT			; Skip spaces
0402EF FE 5E       0882  			CP      '^'			; Is the operator "^"?
0402F1 C0          0883  			RET     NZ			; No, so return
0402F2 CD 3E 0A 04 0884  			CALL    SAVE_EV			; Save first operand
0402F6 CD C5 03 04 0885  			CALL    ITEM			; Get second operand
0402FA B7          0886  			OR      A			; Test type
0402FB 08          0887  			EX      AF,AF'			; Save type
0402FC CD 4D 0A 04 0888  			CALL    DOIT			; Do the operation
040300 18 E9       0889  			JR      EXPR5A			; And continue
040302             0890  ;
040302             0891  ; Evaluate a numeric expression
040302             0892  ;
040302 CD C7 01 04 0893  EXPRN:			CALL    EXPR			; Evaluate expression
040306 08          0894  			EX      AF,AF'			; Get the type
040307 F0          0895  			RET     P			; And return if it is a number
040308 18 2C       0896  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030A             0897  ;
04030A             0898  ; Evaluate a fixed-point expression
04030A             0899  ;
04030A CD C7 01 04 0900  EXPRI:			CALL    EXPR			; Evaluate the expression
04030E 08          0901  			EX      AF,AF'			; Get the type
04030F F2 62 06 04 0902  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040313 18 21       0903  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040315             0904  ;
040315             0905  ; Evaluate a string expression
040315             0906  ;
040315 CD C7 01 04 0907  EXPRS:			CALL    EXPR			; Evaluate the expression
040319 08          0908  			EX      AF,AF'			; Get the type
04031A F8          0909  			RET     M			; And return if it is a string
04031B 18 19       0910  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031D             0911  ;
04031D             0912  ; Get a numeric variable
04031D             0913  ;
04031D CD C5 03 04 0914  ITEMN:			CALL    ITEM			; Get the variable
040321 B7          0915  			OR      A			; Test the type
040322 F0          0916  			RET     P			; And return if it is a number
040323 18 11       0917  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040325             0918  ;
040325             0919  ; Get a fixed-point variable
040325             0920  ;
040325 CD C5 03 04 0921  ITEMI:			CALL    ITEM			; Get the variable
040329 B7          0922  			OR      A			; Test the type
04032A F2 62 06 04 0923  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04032E 18 06       0924  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040330             0925  ;
040330             0926  ; Get a string variable
040330             0927  ;
040330 CD C5 03 04 0928  ITEMS:			CALL    ITEM			; Get the variable
040334 B7          0929  			OR      A			; Test the type
040335 F8          0930  			RET     M			; If it is a string, then return
040336             0931  ;							; Otherwise
040336 3E 06       0932  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
040338 C3 60 37 04 0933  			JP      ERROR_
04033C             0934  ;
04033C             0935  ; Evaluate a bracketed expression
04033C             0936  ;
04033C CD C7 01 04 0937  ITEM1:			CALL    EXPR            	; Evaluate the expression
040340 CD 2F 0A 04 0938  			CALL    BRAKET			; Check for closing bracket
040344 08          0939  			EX      AF,AF'
040345 C9          0940  			RET
040346             0941  ;
040346             0942  ; HEX - Get hexadecimal constant.
040346             0943  ;   Inputs: ASCII string at (IY)
040346             0944  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040346             0945  ;           IY updated (points to delimiter)
040346             0946  ;
040346 CD 93 09 04 0947  HEX:			CALL    ZERO			; Set result to 0
04034A CD F8 09 04 0948  			CALL    HEXDIG			; Fetch the character from IY
04034E 38 1B       0949  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040350 FD 23       0950  HEX1:			INC     IY			; Move pointer to next character
040352 E6 0F       0951  			AND     0FH			; Clear the top nibble
040354 06 04       0952  			LD      B,4			; Loop counter
040356             0953  ;
040356 D9          0954  HEX2:			EXX				; Shift the result left B (4) times. This makes
040357 52 29       0955  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040359 D9          0956  			EXX				; .
04035A 52 ED 6A    0957  			ADC.S   HL,HL			; .
04035D 10 F7       0958  			DJNZ    HEX2			; And loop
04035F D9          0959  			EXX
040360 B5          0960  			OR      L			; OR in the digit
040361 6F          0961  			LD      L,A
040362 D9          0962  			EXX
040363             0963  ;
040363 CD F8 09 04 0964  			CALL    HEXDIG			; Fetch the next character
040367 30 E7       0965  			JR      NC,HEX1			; If it is a HEX digit then loop
040369 AF          0966  			XOR     A			; Clear A
04036A C9          0967  			RET
04036B             0968  ;
04036B 3E 1C       0969  BADHEX:			LD      A,28
04036D C3 60 37 04 0970  			JP      ERROR_          	; Error: "Bad HEX"
040371             0971  ;
040371             0972  ; BIN - Get binary constant.
040371             0973  ;   Inputs: ASCII string at (IY)
040371             0974  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040371             0975  ;           IY updated (points to delimiter)
040371             0976  ;
040371 CD 93 09 04 0977  BIN:			CALL    ZERO			; Set result to 0
040375 CD 0B 0A 04 0978  			CALL	BINDIG			; Fetch the character from IY
040379 38 13       0979  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04037B FD 23       0980  BIN1:			INC	IY			; Move pointer to next character
04037D 0F          0981  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
04037E D9          0982  			EXX				;
04037F 52 ED 6A    0983  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040382 D9          0984  			EXX
040383 52 ED 6A    0985  			ADC.S	HL,HL
040386 CD 0B 0A 04 0986  			CALL	BINDIG			; Fetch the next character
04038A 30 EF       0987  			JR	NC,BIN1
04038C AF          0988  			XOR	A			; Clear A
04038D C9          0989  			RET
04038E             0990  ;
04038E 3E 1C       0991  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040390 CD 77 37 04 0992  			CALL	EXTERR
040394 42 61 64 20 0993  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
04039F             0994  ;
04039F             0995  ; MINUS - Unary minus.
04039F             0996  ;   Inputs: IY = text pointer
04039F             0997  ;  Outputs: Numeric result, same type as argument.
04039F             0998  ;           Result in H'L'HLC
04039F             0999  ;
04039F CD 1D 03 04 1000  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A3 0D          1001  MINUS0:			DEC     C			; Check exponent (C)
0403A4 0C          1002  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403A5 28 06       1003  			JR      Z,NEGATE_EV        	; So do an integer negation
0403A7             1004  ;
0403A7 7C          1005  			LD      A,H			; Do a FP negation by
0403A8 EE 80       1006  			XOR     80H             	; Toggling the sign bit (H)
0403AA 67          1007  			LD      H,A
0403AB AF          1008  			XOR     A               	; Numeric marker
0403AC C9          1009  			RET
0403AD             1010  ;
0403AD D9          1011  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403AE 7C          1012  			LD      A,H			; First do a one's complement by negating all the bytes
0403AF 2F          1013  			CPL
0403B0 67          1014  			LD      H,A
0403B1 7D          1015  			LD      A,L
0403B2 2F          1016  			CPL
0403B3 6F          1017  			LD      L,A
0403B4 D9          1018  			EXX
0403B5 7C          1019  			LD      A,H
0403B6 2F          1020  			CPL
0403B7 67          1021  			LD      H,A
0403B8 7D          1022  			LD      A,L
0403B9 2F          1023  			CPL
0403BA 6F          1024  			LD      L,A
0403BB D9          1025  ADD1:			EXX				; Then add 1
0403BC 23          1026  			INC     HL
0403BD 7C          1027  			LD      A,H
0403BE B5          1028  			OR      L
0403BF D9          1029  			EXX
0403C0 3E 00       1030  			LD      A,0             	; Numeric marker
0403C2 C0          1031  			RET     NZ
0403C3 23          1032  			INC     HL
0403C4 C9          1033  			RET
0403C5             1034  ;
0403C5             1035  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403C5             1036  ; Item type is returned in A:  Bit 7=0 numeric.
0403C5             1037  ;                              Bit 7=1 string.
0403C5             1038  ; Numeric item returned in HLH'L'C.
0403C5             1039  ; String item returned in string accumulator,
0403C5             1040  ;   DE addresses byte after last (E=length).
0403C5             1041  ;
0403C5 CD 4F 16 04 1042  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403C9 CD 70 0A 04 1043  			CALL    NXT			; Skip spaces
0403CD FD 23       1044  			INC     IY			; Move to the prefix character
0403CF FE 26       1045  			CP      '&'			; If `&`
0403D1 CA 46 03 04 1046  			JP      Z,HEX           	; Then get a HEX constant
0403D5 FE 25       1047  			CP	'%'			; If '%'
0403D7 28 98       1048  			JR	Z,BIN			; Then get a BINARY constant
0403D9 FE 2D       1049  			CP      '-'			; If `-`
0403DB 28 C2       1050  			JR      Z,MINUS         	; Then get a negative number
0403DD FE 2B       1051  			CP      '+'			; If `+`
0403DF CA 1D 03 04 1052  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E3 FE 28       1053  			CP      '('			; If `(`
0403E5 CA 3C 03 04 1054  			JP      Z,ITEM1         	; Start of a bracketed expression
0403E9 FE 22       1055  			CP      34			; If `"`
0403EB 28 7A       1056  			JR      Z,CONS          	; Start of a string constant
0403ED FE C6       1057  			CP      TCMD_EV			; Is it out of range of the function table?
0403EF D2 97 0C 04 1058  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F3 FE 8D       1059  			CP      FUNTOK			; If it is in range, then
0403F5 D2 83 0A 04 1060  			JP      NC,DISPAT       	; It's a function
0403F9 FD 2B       1061  			DEC     IY
0403FB FE 3A       1062  			CP      ':'
0403FD 30 0C       1063  			JR      NC,ITEM2		; VARIABLE?
0403FF FE 30       1064  			CP      '0'
040401 D2 8E 04 04 1065  			JP      NC,CON			; NUMERIC CONSTANT
040405 FE 2E       1066  			CP      '.'
040407 CA 8E 04 04 1067  			JP      Z,CON			; NUMERIC CONSTANT
04040B CD 3A 3A 04 1068  ITEM2:			CALL    GETVAR			; VARIABLE
04040F 20 37       1069  			JR      NZ,NOSUCH
040411 B7          1070  			OR      A
040412 FA A0 04 04 1071  			JP      M,LOADS			; STRING VARIABLE
040416 B7          1072  LOADN:			OR      A
040417 28 20       1073  			JR      Z,LOAD1			; BYTE VARIABLE
040419 0E 00       1074  			LD      C,0
04041B CB 47       1075  			BIT     0,A
04041D 28 03       1076  			JR      Z,LOAD4			; INTEGER VARIABLE
04041F DD 4E 04    1077  LOAD5:			LD      C,(IX+4)
040422 D9          1078  LOAD4:			EXX
040423 21 00 00 00 1079  			LD	HL, 0			; TODO: Optimise
040427 DD 6E 00    1080  			LD      L,(IX+0)
04042A DD 66 01    1081  			LD      H,(IX+1)
04042D D9          1082  			EXX
04042E 21 00 00 00 1083  			LD	HL, 0			; TODO: Optimise
040432 DD 6E 02    1084  			LD      L,(IX+2)
040435 DD 66 03    1085  			LD      H,(IX+3)
040438 C9          1086  			RET
040439             1087  ;
040439 21 00 00 00 1088  LOAD1:			LD      HL,0
04043D D9          1089  			EXX
04043E 21 00 00 00 1090  			LD      HL,0			; TODO: Optimise
040442 DD 6E 00    1091  			LD      L,(IX+0)
040445 D9          1092  			EXX
040446 4C          1093  			LD      C,H
040447 C9          1094  			RET
040448             1095  ;
040448 DA 97 0C 04 1096  NOSUCH:			JP      C,SYNTAX
04044C 3A 40 4D 04 1097  			LD      A,(LISTON)
040450 CB 6F       1098  			BIT     5,A
040452 3E 1A       1099  			LD      A,26
040454 20 26       1100  			JR      NZ,ERROR0_EV		; Throw "No such variable"
040456 FD 23       1101  NOS1:			INC     IY
040458 CD 6F 3C 04 1102  			CALL    RANGE
04045C 30 F8       1103  			JR      NC,NOS1
04045E DD 21 40 4C 1104  			LD      IX,PC
       04          
040463 AF          1105  			XOR     A
040464 4F          1106  			LD      C,A
040465 18 BB       1107  			JR      LOAD4
040467             1108  ;
040467             1109  ;CONS - Get string constant from ASCII string.
040467             1110  ;   Inputs: ASCII string at (IY)
040467             1111  ;  Outputs: Result in string accumulator.
040467             1112  ;           D = MS byte of ACCS, E = string length
040467             1113  ;           A7 = 1 (string marker)
040467             1114  ;           IY updated
040467             1115  ;
040467 11 00 4A 04 1116  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04046B FD 7E 00    1117  CONS3:			LD      A,(IY)			; Fetch the first character and
04046E FD 23       1118  			INC     IY			; Increment the pointer
040470 FE 22       1119  			CP      '"'			; Check for start quote
040472 28 0C       1120  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040474             1121  ;
040474 12          1122  CONS1:			LD      (DE),A			; Store the character in the string accumulator
040475 1C          1123  			INC     E			; Increment the string accumulator pointer
040476 FE 0D       1124  			CP      CR			; Is it CR
040478 20 F1       1125  			JR      NZ,CONS3		; No, so keep looping
04047A             1126  ;
04047A 3E 09       1127  			LD      A,9
04047C C3 60 37 04 1128  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040480             1129  ;
040480 FD 7E 00    1130  CONS2:			LD      A,(IY)			; Fetch the next character
040483 FE 22       1131  			CP      '"'			; Check for end quote?
040485 FD 23       1132  			INC     IY			; Increment the pointer
040487 28 EB       1133  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040489 FD 2B       1134  			DEC     IY			;
04048B 3E 80       1135  			LD      A,80H           	; String marker
04048D C9          1136  			RET
04048E             1137  ;
04048E             1138  ;CON - Get unsigned numeric constant from ASCII string.
04048E             1139  ;   Inputs: ASCII string at (IY).
04048E             1140  ;  Outputs: Variable-type result in HLH'L'C
04048E             1141  ;           IY updated (points to delimiter)
04048E             1142  ;           A7 = 0 (numeric marker)
04048E             1143  ;
04048E FD E5       1144  CON:			PUSH    IY
040490 DD E1       1145  			POP     IX
040492 3E 24       1146  			LD      A,36
040494 CD 6A 20 04 1147  			CALL    FPP
040498 38 E2       1148  			JR      C,ERROR0_EV
04049A DD E5       1149  			PUSH    IX
04049C FD E1       1150  			POP     IY
04049E AF          1151  			XOR     A
04049F C9          1152  			RET
0404A0             1153  ;
0404A0 11 00 4A 04 1154  LOADS:			LD      DE,ACCS			; Where to store the string
0404A4 1F          1155  			RRA
0404A5 30 1A       1156  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404A7             1157  ;
0404A7 D9          1158  			EXX				; This block was a call to LOAD4
0404A8 DD 6E 00    1159  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404AB DD 66 01    1160  			LD      H,(IX+1)		; The maximum original string length
0404AE D9          1161  			EXX
0404AF DD 27 02    1162  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B2             1163  ;
0404B2 D9          1164  			EXX
0404B3 7D          1165  			LD      A,L
0404B4 D9          1166  			EXX
0404B5 B7          1167  			OR      A
0404B6 01 00 00 00 1168  			LD	BC,0			; BC: Number of bytes to copy
0404BA 4F          1169  			LD      C,A
0404BB 3E 80       1170  			LD      A,80H           	; String marker
0404BD C8          1171  			RET     Z
0404BE ED B0       1172  			LDIR
0404C0 C9          1173  			RET
0404C1 7E          1174  LOADS2:			LD      A,(HL)
0404C2 12          1175  			LD      (DE),A
0404C3 23          1176  			INC     HL
0404C4 FE 0D       1177  			CP      CR
0404C6 3E 80       1178  			LD      A,80H           	; String marker
0404C8 C8          1179  			RET     Z
0404C9 1C          1180  			INC     E
0404CA 20 F5       1181  			JR      NZ,LOADS2
0404CC C9          1182  			RET                     	; Return null string
0404CD             1183  ;
0404CD             1184  ;VARIABLE-TYPE FUNCTIONS:
0404CD             1185  ;
0404CD             1186  ;Result returned in HLH'L'C (floating point)
0404CD             1187  ;Result returned in HLH'L' (C=0) (integer)
0404CD             1188  ;Result returned in string accumulator & DE (string)
0404CD             1189  ;All registers destroyed.
0404CD             1190  ;IY (text pointer) updated.
0404CD             1191  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404CD             1192  ;
0404CD             1193  ;POS - horizontal cursor position.
0404CD             1194  ;VPOS - vertical cursor position.
0404CD             1195  ;EOF - return status of file.
0404CD             1196  ;BGET - read byte from file.
0404CD             1197  ;INKEY - as GET but wait only n centiseconds.
0404CD             1198  ;GET - wait for keypress and return ASCII value.
0404CD             1199  ;GET(n) - input from Z80 port n.
0404CD             1200  ;ASC - ASCII value of string.
0404CD             1201  ;LEN - length of string.
0404CD             1202  ;LOMEM - location of dynamic variables.
0404CD             1203  ;HIMEM - top of available RAM.
0404CD             1204  ;PAGE - start of current text page.
0404CD             1205  ;TOP - address of first free byte after program.
0404CD             1206  ;ERL - line number where last error occurred.
0404CD             1207  ;ERR - number of last error.
0404CD             1208  ;COUNT - number of printing characters since CR.
0404CD             1209  ;Results are integer numeric.
0404CD             1210  ;
0404CD CD CC 3E 04 1211  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D1 EB          1212  			EX      DE,HL			;  L: The X cursor position
0404D2 C3 81 05 04 1213  			JP      COUNT1			; Return an 8-bit value
0404D6             1214  ;
0404D6 CD CC 3E 04 1215  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DA C3 81 05 04 1216  			JP      COUNT1			; Return an 8-bit value
0404DE             1217  ;
0404DE CD 86 18 04 1218  EOF:			CALL    CHANEL			; Check for EOF
0404E2 CD 44 43 04 1219  			CALL    OSSTAT
0404E6 CA 05 06 04 1220  			JP      Z,TRUE			; Yes, so return true
0404EA C3 93 09 04 1221  			JP      ZERO			; Otherwise return false (zero)
0404EE             1222  ;
0404EE CD 86 18 04 1223  BGET:			CALL    CHANEL          	; Channel number
0404F2 CD 33 43 04 1224  			CALL    OSBGET
0404F6 6F          1225  			LD      L,A
0404F7 C3 7F 05 04 1226  			JP      COUNT0			; Return an 8-bit value
0404FB             1227  ;
0404FB CD 25 03 04 1228  INKEY:			CALL    ITEMI			; Get the argument
0404FF CB 7C       1229  			BIT	7, H			; Check the sign
040501 D9          1230  			EXX				; HL: The argument
040502 C2 EB 07 04 1231  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040506 CD DD 07 04 1232  			CALL	INKEY0 			; Do INKEY(n)
04050A 18 1D       1233  			JR      ASC0			; Return a numeric value
04050C             1234  ;
04050C CD 70 0A 04 1235  GET:			CALL    NXT			; Skip whitespace
040510 FE 28       1236  			CP      '('			; Is it GET(
040512 20 0B       1237  			JR      NZ,GET0			; No, so get a keyboard character
040514 CD 25 03 04 1238  			CALL    ITEMI           	; Yes, so fetch the port address
040518 D9          1239  			EXX
040519 44          1240  			LD      B,H			; BC: The port address
04051A 4D          1241  			LD      C,L
04051B ED 68       1242  			IN      L,(C)           	;  L: Input from port BC
04051D 18 60       1243  			JR      COUNT0			; Return an 8-bit value
04051F             1244  ;
04051F CD C7 07 04 1245  GET0:			CALL    GETS			; Read the keyboard character
040523 18 0A       1246  			JR      ASC1			; And return the value
040525             1247  ;
040525 CD 30 03 04 1248  ASC:			CALL    ITEMS			; Get the string argument argument
040529 AF          1249  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052A BB          1250  			CP      E			; Is the pointer 0
04052B CA 05 06 04 1251  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
04052F 2A 00 4A 04 1252  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040533 18 4A       1253  			JR      COUNT0			; An 8-bit value
040535             1254  ;
040535 CD 30 03 04 1255  LEN:			CALL    ITEMS			; Get the string argument
040539 EB          1256  			EX      DE,HL			; HL: Pointer into ACCS
04053A 18 43       1257  			JR      COUNT0			; Return L
04053C             1258  ;
04053C 2A 1A 4D 04 1259  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040540 3A 1C 4D 04 1260  			LD	A, (LOMEM+2)
040544 18 41       1261  			JR      COUNT2			; A 24-bit value
040546             1262  ;
040546 2A 20 4D 04 1263  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054A 3A 22 4D 04 1264  			LD	A, (HIMEM+2)
04054E 18 37       1265  			JR      COUNT2			; A 24-bit value
040550             1266  ;
040550 2A 14 4D 04 1267  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040554 3A 16 4D 04 1268  			LD	A, (PAGE_+2)		; A 24-bit value
040558 18 2D       1269  			JR      COUNT2
04055A             1270  ;
04055A FD 7E 00    1271  TOPV:			LD      A,(IY)			; Return the TOP system variable
04055D FD 23       1272  			INC     IY              	; Skip "P"
04055F FE 50       1273  			CP      'P'
040561 C2 97 0C 04 1274  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
040565 2A 17 4D 04 1275  			LD      HL,(TOP)
040569 3A 19 4D 04 1276  			LD	A, (TOP+2)
04056D 18 18       1277  			JR      COUNT2
04056F             1278  ;
04056F 2A 33 4D 04 1279  ERLV:			LD      HL,(ERL)		; Return the error line
040573 18 0C       1280  			JR      COUNT1			; A 16-bit value
040575             1281  ;
040575 2A 3F 4D 04 1282  ERRV:			LD      HL,(ERR)		; Return the error value
040579 18 04       1283  			JR      COUNT0			; An 8-bit value
04057B             1284  ;
04057B 2A 3D 4D 04 1285  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
04057F             1286  
04057F 26 00       1287  COUNT0:			LD      H,0			; Return L
040581 D9          1288  COUNT1:			EXX				; Return HL
040582 AF          1289  			XOR     A
040583 4F          1290  			LD      C,A             	; Integer marker
040584 67          1291  			LD      H,A
040585 6F          1292  			LD      L,A
040586 C9          1293  			RET
040587 D9          1294  COUNT2:			EXX
040588 6F          1295  			LD	L,A
040589 AF          1296  			XOR	A
04058A 4F          1297  			LD	C,A			; Integer marker
04058B 67          1298  			LD	H,A
04058C C9          1299  			RET
04058D             1300  ;
04058D             1301  ;OPENIN - Open a file for reading.
04058D             1302  ;OPENOT - Open a file for writing.
04058D             1303  ;OPENUP - Open a file for reading or writing.
04058D             1304  ;Result is integer channel number (0 if error)
04058D             1305  ;
04058D AF          1306  OPENOT:			XOR     A			; Open for writing
04058E 18 06       1307  			JR	OPENIN_1
040590             1308  ;
040590 3E 02       1309  OPENUP:			LD      A,2			; Open for reading / writing
040592 18 02       1310  			JR	OPENIN_1
040594             1311  ;
040594 3E 01       1312  OPENIN:			LD      A,1			; Open for reading
040596             1313  ;
040596 F5          1314  OPENIN_1:		PUSH    AF              	; Save OPEN type
040597 CD 30 03 04 1315  			CALL    ITEMS           	; Fetch the filename
04059B 3E 0D       1316  			LD      A,CR
04059D 12          1317  			LD      (DE),A
04059E F1          1318  			POP     AF              	; Restore the OPEN type
04059F C6 FF       1319  			ADD     A,-1            	; Affect the flags
0405A1 21 00 4A 04 1320  			LD      HL,ACCS
0405A5 CD 1C 43 04 1321  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405A9 6F          1322  			LD      L,A			; L: Channel number
0405AA 18 D3       1323  			JR      COUNT0			; Return channel number to BASIC
0405AC             1324  ;
0405AC             1325  ;EXT - Return length of file.
0405AC             1326  ;PTR_EV - Return current file pointer.
0405AC             1327  ;Results are integer numeric.
0405AC             1328  ;
0405AC CD 86 18 04 1329  EXT:			CALL    CHANEL
0405B0 CD 7A 43 04 1330  			CALL    GETEXT
0405B4 18 15       1331  			JR      TIME0
0405B6             1332  ;
0405B6 CD 86 18 04 1333  PTR_EV:			CALL    CHANEL
0405BA CD 4E 43 04 1334  			CALL    GETPTR
0405BE 18 0B       1335  			JR      TIME0
0405C0             1336  ;
0405C0             1337  ;TIME - Return current value of elapsed time.
0405C0             1338  ;Result is integer numeric.
0405C0             1339  ;
0405C0 FD 7E 00    1340  TIMEV:			LD      A,(IY)
0405C3 FE 24       1341  			CP      '$'
0405C5 28 0A       1342  			JR      Z,TIMEVS
0405C7 CD AC 3E 04 1343  			CALL    GETIME
0405CB D5          1344  TIME0:			PUSH    DE
0405CC D9          1345  			EXX
0405CD E1          1346  			POP     HL
0405CE AF          1347  			XOR     A
0405CF 4F          1348  			LD      C,A
0405D0 C9          1349  			RET
0405D1             1350  ;
0405D1             1351  ;TIME$ - Return date/time string.
0405D1             1352  ;Result is string
0405D1             1353  ;
0405D1 FD 23       1354  TIMEVS:			INC     IY              ;SKIP $
0405D3 CD 93 43 04 1355  			CALL    GETIMS
0405D7 3E 80       1356  			LD      A,80H           ;MARK STRING
0405D9 C9          1357  			RET
0405DA             1358  ;
0405DA             1359  ;String comparison:
0405DA             1360  ;
0405DA CD 8F 09 04 1361  SLT:			CALL    SCP
0405DE D0          1362  			RET     NC
0405DF 18 24       1363  			JR      TRUE
0405E1             1364  ;
0405E1 CD 8F 09 04 1365  SGT:			CALL    SCP
0405E5 C8          1366  			RET     Z
0405E6 D8          1367  			RET     C
0405E7 18 1C       1368  			JR      TRUE
0405E9             1369  ;
0405E9 CD 8F 09 04 1370  SGE:			CALL    SCP
0405ED D8          1371  			RET     C
0405EE 18 15       1372  			JR      TRUE
0405F0             1373  ;
0405F0 CD 8F 09 04 1374  SLE:			CALL    SCP
0405F4 28 0F       1375  			JR      Z,TRUE
0405F6 D0          1376  			RET     NC
0405F7 18 0C       1377  			JR      TRUE
0405F9             1378  ;
0405F9 CD 8F 09 04 1379  SNE:			CALL    SCP
0405FD C8          1380  			RET     Z
0405FE 18 05       1381  			JR      TRUE
040600             1382  ;
040600 CD 8F 09 04 1383  SEQ:			CALL    SCP
040604 C0          1384  			RET     NZ
040605 3E FF       1385  TRUE:			LD      A,-1
040607 D9          1386  			EXX
040608 67          1387  			LD      H,A
040609 6F          1388  			LD      L,A
04060A D9          1389  			EXX
04060B 67          1390  			LD      H,A
04060C 6F          1391  			LD      L,A
04060D 3C          1392  			INC     A
04060E 4F          1393  			LD      C,A
04060F C9          1394  			RET
040610             1395  ;
040610             1396  ;PI - Return PI (3.141592654)
040610             1397  ;Result is floating-point numeric.
040610             1398  ;
040610 3E 23       1399  PI:			LD      A,35
040612 18 44       1400  			JR      FPP1
040614             1401  ;
040614             1402  ;ABS - Absolute value
040614             1403  ;Result is numeric, variable type.
040614             1404  ;
040614 3E 10       1405  ABSV:			LD      A,16
040616 18 3A       1406  			JR      FPPN
040618             1407  ;
040618             1408  ;NOT - Complement integer.
040618             1409  ;Result is integer numeric.
040618             1410  ;
040618 3E 1A       1411  NOTK:			LD      A,26
04061A 18 36       1412  			JR      FPPN
04061C             1413  ;
04061C             1414  ;DEG - Convert radians to degrees
04061C             1415  ;Result is floating-point numeric.
04061C             1416  ;
04061C 3E 15       1417  DEG:			LD      A,21
04061E 18 32       1418  			JR      FPPN
040620             1419  ;
040620             1420  ;RAD - Convert degrees to radians
040620             1421  ;Result is floating-point numeric.
040620             1422  ;
040620 3E 1B       1423  RAD:			LD      A,27
040622 18 2E       1424  			JR      FPPN
040624             1425  ;
040624             1426  ;SGN - Return -1, 0 or +1
040624             1427  ;Result is integer numeric.
040624             1428  ;
040624 3E 1C       1429  SGN:			LD      A,28
040626 18 2A       1430  			JR      FPPN
040628             1431  ;
040628             1432  ;INT - Floor function
040628             1433  ;Result is integer numeric.
040628             1434  ;
040628 3E 17       1435  INT_:			LD      A,23
04062A 18 26       1436  			JR      FPPN
04062C             1437  ;
04062C             1438  ;SQR - square root
04062C             1439  ;Result is floating-point numeric.
04062C             1440  ;
04062C 3E 1E       1441  SQR:			LD      A,30
04062E 18 22       1442  			JR      FPPN
040630             1443  ;
040630             1444  ;TAN - Tangent function
040630             1445  ;Result is floating-point numeric.
040630             1446  ;
040630 3E 1F       1447  TAN:			LD      A,31
040632 18 1E       1448  			JR      FPPN
040634             1449  ;
040634             1450  ;COS - Cosine function
040634             1451  ;Result is floating-point numeric.
040634             1452  ;
040634 3E 14       1453  COS:			LD      A,20
040636 18 1A       1454  			JR      FPPN
040638             1455  ;
040638             1456  ;SIN - Sine function
040638             1457  ;Result is floating-point numeric.
040638             1458  ;
040638 3E 1D       1459  SIN:			LD      A,29
04063A 18 16       1460  			JR      FPPN
04063C             1461  ;
04063C             1462  ;EXP - Exponential function
04063C             1463  ;Result is floating-point numeric.
04063C             1464  ;
04063C 3E 16       1465  EXP:			LD      A,22
04063E 18 12       1466  			JR      FPPN
040640             1467  ;
040640             1468  ;LN - Natural log.
040640             1469  ;Result is floating-point numeric.
040640             1470  ;
040640 3E 18       1471  LN:			LD      A,24
040642 18 0E       1472  			JR      FPPN
040644             1473  ;
040644             1474  ;LOG - base-10 logarithm.
040644             1475  ;Result is floating-point numeric.
040644             1476  ;
040644 3E 19       1477  LOG:			LD      A,25
040646 18 0A       1478  			JR      FPPN
040648             1479  ;
040648             1480  ;ASN - Arc-sine
040648             1481  ;Result is floating-point numeric.
040648             1482  ;
040648 3E 12       1483  ASN:			LD      A,18
04064A 18 06       1484  			JR      FPPN
04064C             1485  ;
04064C             1486  ;ATN - arc-tangent
04064C             1487  ;Result is floating-point numeric.
04064C             1488  ;
04064C 3E 13       1489  ATN:			LD      A,19
04064E 18 02       1490  			JR      FPPN
040650             1491  ;
040650             1492  ;ACS - arc-cosine
040650             1493  ;Result is floating point numeric.
040650             1494  ;
040650 3E 11       1495  ACS:			LD      A,17
040652 F5          1496  FPPN:			PUSH    AF
040653 CD 1D 03 04 1497  			CALL    ITEMN
040657 F1          1498  			POP     AF
040658 CD 6A 20 04 1499  FPP1:			CALL    FPP
04065C DA 60 37 04 1500  			JP      C,ERROR_
040660 AF          1501  			XOR     A
040661 C9          1502  			RET
040662             1503  ;
040662             1504  ;SFIX - Convert to fixed-point notation
040662             1505  ;
040662 3E 26       1506  SFIX:			LD      A,38
040664 18 F2       1507  			JR      FPP1
040666             1508  ;
040666             1509  ;SFLOAT - Convert to floating-point notation
040666             1510  ;
040666 3E 27       1511  SFLOAT:			LD      A,39
040668 18 EE       1512  			JR      FPP1
04066A             1513  ;
04066A             1514  ;VAL - Return numeric value of string.
04066A             1515  ;Result is variable type numeric.
04066A             1516  ;
04066A CD 30 03 04 1517  VAL:			CALL    ITEMS
04066E AF          1518  VAL0:			XOR     A
04066F 12          1519  			LD      (DE),A
040670 DD 21 00 4A 1520  			LD      IX,ACCS
       04          
040675 3E 24       1521  			LD      A,36
040677 18 DF       1522  			JR      FPP1
040679             1523  ;
040679             1524  ;EVAL - Pass string to expression evaluator.
040679             1525  ;Result is variable type (numeric or string).
040679             1526  ;
040679 CD 30 03 04 1527  EVAL_:			CALL    ITEMS
04067D 3E 0D       1528  			LD      A,CR
04067F 12          1529  			LD      (DE),A
040680 FD E5       1530  			PUSH    IY
040682 11 00 4A 04 1531  			LD      DE,ACCS
040686 FD 21 00 4A 1532  			LD      IY,ACCS
       04          
04068B 0E 00       1533  			LD      C,0
04068D CD 9F 3C 04 1534  			CALL    LEXAN2          ;TOKENISE
040691 12          1535  			LD      (DE),A
040692 13          1536  			INC     DE
040693 AF          1537  			XOR     A
040694 CD B4 09 04 1538  			CALL    PUSHS           ;PUT ON STACK
040698 FD 21 03 00 1539  			LD      IY,SIZEW	;WAS 2
       00          
04069D FD 39       1540  			ADD     IY,SP
04069F CD C7 01 04 1541  			CALL    EXPR
0406A3 FD E1       1542  			POP     IY
0406A5 FD 39       1543  			ADD     IY,SP
0406A7 FD F9       1544  			LD      SP,IY           ;ADJUST STACK POINTER
0406A9 FD E1       1545  			POP     IY
0406AB 08          1546  			EX      AF,AF'
0406AC C9          1547  			RET
0406AD             1548  ;
0406AD             1549  ;RND - Random number function.
0406AD             1550  ; RND gives random integer 0-&FFFFFFFF
0406AD             1551  ; RND(-n) seeds random number & returns -n.
0406AD             1552  ; RND(0) returns last value in RND(1) form.
0406AD             1553  ; RND(1) returns floating-point 0-0.99999999.
0406AD             1554  ; RND(n) returns random integer 1-n.
0406AD             1555  ;
0406AD DD 21 38 4D 1556  RND:			LD      IX,RANDOM
       04          
0406B2 CD 70 0A 04 1557  			CALL    NXT
0406B6 FE 28       1558  			CP      '('
0406B8 28 20       1559  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BA CD 1F 04 04 1560  			CALL    LOAD5
0406BE CB 19       1561  RND1:			RR      C
0406C0 06 20       1562  			LD      B,32
0406C2 D9          1563  RND2:			EXX                     ;CALCULATE NEXT
0406C3 52 ED 6A    1564  			ADC.S   HL,HL
0406C6 D9          1565  			EXX
0406C7 52 ED 6A    1566  			ADC.S   HL,HL
0406CA CB 5D       1567  			BIT     3,L
0406CC 28 01       1568  			JR      Z,RND3
0406CE 3F          1569  			CCF
0406CF 10 F1       1570  RND3:			DJNZ    RND2
0406D1 CB 11       1571  RND4:			RL      C               ;SAVE CARRY
0406D3 CD DB 15 04 1572  			CALL    STORE5          ;STORE NEW NUMBER
0406D7 AF          1573  			XOR     A
0406D8 4F          1574  			LD      C,A
0406D9 C9          1575  			RET
0406DA CD 25 03 04 1576  RND5:			CALL    ITEMI
0406DE DD 21 38 4D 1577  			LD      IX,RANDOM
       04          
0406E3 CB 7C       1578  			BIT     7,H             ;NEGATIVE?
0406E5 37          1579  			SCF
0406E6 20 E9       1580  			JR      NZ,RND4         ;SEED
0406E8 CD DF 08 04 1581  			CALL    TEST
0406EC F5          1582  			PUSH    AF
0406ED CD D7 08 04 1583  			CALL    SWAP
0406F1 D9          1584  			EXX
0406F2 CD 1F 04 04 1585  			CALL    LOAD5
0406F6 C4 BE 06 04 1586  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FA D9          1587  			EXX                     ;SCRAMBLE (CARE!)
0406FB 0E 7F       1588  			LD      C,7FH
0406FD CB 7C       1589  RND6:			BIT     7,H             ;FLOAT
0406FF 20 0A       1590  			JR      NZ,RND7
040701 D9          1591  			EXX
040702 52 29       1592  			ADD.S   HL,HL
040704 D9          1593  			EXX
040705 52 ED 6A    1594  			ADC.S   HL,HL
040708 0D          1595  			DEC     C
040709 20 F2       1596  			JR      NZ,RND6
04070B CB BC       1597  RND7:			RES     7,H             ;POSITIVE 0-0.999999
04070D F1          1598  			POP     AF
04070E C8          1599  			RET     Z               ;ZERO ARGUMENT
04070F D9          1600  			EXX
040710 7B          1601  			LD      A,E
040711 3D          1602  			DEC     A
040712 B2          1603  			OR      D
040713 D9          1604  			EXX
040714 B3          1605  			OR      E
040715 B2          1606  			OR      D
040716 C8          1607  			RET     Z               ;ARGUMENT=1
040717 06 00       1608  			LD      B,0             ;INTEGER MARKER
040719 3E 0A       1609  			LD      A,10
04071B CD 6A 20 04 1610  			CALL    FPP             ;MULTIPLY
04071F DA 60 37 04 1611  			JP      C,ERROR_
040723 CD 62 06 04 1612  			CALL    SFIX
040727 C3 BB 03 04 1613  			JP      ADD1
04072B             1614  ;
04072B             1615  ; INSTR - String search.
04072B             1616  ; Result is integer numeric.
04072B             1617  ;
04072B CD 1E 0A 04 1618  INSTR:			CALL    EXPRSC			; Get the first string expression
04072F CD B4 09 04 1619  			CALL    PUSHS           	; Push the string onto the stack
040733 CD 15 03 04 1620  			CALL    EXPRS           	; Get the second string expression
040737 C1          1621  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
040738 21 00 00 00 1622  			LD      HL,0
04073C 39          1623  			ADD     HL,SP           	; HL: Pointer to main string
04073D C5          1624  			PUSH    BC              	;  C: Main string length
04073E 43          1625  			LD      B,E             	;  B: Sub-string length
04073F CD 70 0A 04 1626  			CALL    NXT			; Skip whitespace
040743 FE 2C       1627  			CP      ','			; Check if there is a comma for the third parameter
040745 3E 00       1628  			LD      A,0			;  A: Default start position in string
040747 20 1A       1629  			JR      NZ,INSTR1		; No, so skip the next bit
040749 FD 23       1630  			INC     IY              	; Skip the comma
04074B C5          1631  			PUSH    BC              	; Save the lengths
04074C E5          1632  			PUSH    HL              	; Save the pointer to the main string
04074D CD B4 09 04 1633  			CALL    PUSHS			; Push the string onto the stack
040751 CD 0A 03 04 1634  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
040755 C1          1635  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
040756 CD DE 09 04 1636  			CALL    POPS			; Pop the string off the stack
04075A E1          1637  			POP     HL              	; Restore the pointer to the main string
04075B C1          1638  			POP     BC              	; Restore the lengths
04075C D9          1639  			EXX
04075D 7D          1640  			LD      A,L			; A: The start position in the  string
04075E D9          1641  			EXX
04075F B7          1642  			OR      A			; Set the flags
040760 28 01       1643  			JR      Z,INSTR1		; If it is zero, then skip
040762 3D          1644  			DEC     A
040763 11 00 4A 04 1645  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
040767 CD 85 07 04 1646  			CALL    SEARCH			; Do the search
04076B D1          1647  			POP     DE
04076C 28 03       1648  			JR      Z,INSTR2        	; NB: Carry cleared
04076E ED 62       1649  			SBC     HL,HL
040770 39          1650  			ADD     HL,SP
040771 ED 72       1651  INSTR2:			SBC     HL,SP
040773 EB          1652  			EX      DE,HL
040774 7D          1653  			LD	A,L
040775 21 00 00 00 1654  			LD      HL,0
040779 6F          1655  			LD	L,A
04077A 39          1656  			ADD     HL,SP
04077B F9          1657  			LD      SP,HL
04077C EB          1658  			EX      DE,HL
04077D CD 2F 0A 04 1659  			CALL    BRAKET			; Check for closing bracket
040781 C3 81 05 04 1660  			JP      COUNT1			; Return a numeric integer
040785             1661  ;
040785             1662  ; SEARCH - Search string for sub-string
040785             1663  ;    Inputs: Main string at HL length C
040785             1664  ;            Sub-string  at DE length B
040785             1665  ;            Starting offset A
040785             1666  ;   Outputs: NZ - not found
040785             1667  ;            Z - found at location HL-1
040785             1668  ;            Carry always cleared
040785             1669  ;
040785 C5          1670  SEARCH:			PUSH    BC			; Add the starting offset to HL
040786 01 00 00 00 1671  			LD      BC,0
04078A 4F          1672  			LD      C,A
04078B 09          1673  			ADD     HL,BC           	; New start address
04078C C1          1674  			POP     BC
04078D 91          1675  			SUB     C			; If the starting offset > main string length, then do nothing
04078E 30 2C       1676  			JR      NC,SRCH4
040790 ED 44       1677  			NEG
040792 4F          1678  			LD      C,A             	; Remaining length
040793             1679  ;
040793 C5          1680  SRCH1:			PUSH    BC
040794 79          1681  			LD	A,C
040795 01 00 00 00 1682  			LD	BC,0
040799 4F          1683  			LD	C,A
04079A 1A          1684  			LD      A,(DE)
04079B ED B1       1685  			CPIR                    	; Find the first character
04079D 79          1686  			LD      A,C
04079E C1          1687  			POP     BC
04079F 20 1B       1688  			JR      NZ,SRCH4
0407A1 4F          1689  			LD      C,A
0407A2             1690  ;
0407A2             1691  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A2             1692  ;
0407A2 05          1693  			DEC     B			; Bug fix
0407A3 B8          1694  			CP      B			; Bug fix
0407A4 04          1695  			INC     B			; Bug fix
0407A5 38 15       1696  			JR      C,SRCH4			; Bug fix
0407A7             1697  ;
0407A7 C5          1698  			PUSH    BC
0407A8 D5          1699  			PUSH    DE
0407A9 E5          1700  			PUSH    HL
0407AA 05          1701  			DEC     B
0407AB 28 08       1702  			JR      Z,SRCH3         	; Found!
0407AD 13          1703  SRCH2:			INC     DE
0407AE 1A          1704  			LD      A,(DE)
0407AF BE          1705  			CP      (HL)
0407B0 20 03       1706  			JR      NZ,SRCH3
0407B2 23          1707  			INC     HL
0407B3 10 F8       1708  			DJNZ    SRCH2
0407B5 E1          1709  SRCH3:			POP     HL
0407B6 D1          1710  			POP     DE
0407B7 C1          1711  			POP     BC
0407B8 20 D9       1712  			JR      NZ,SRCH1
0407BA AF          1713  			XOR     A               	; Flags: Z, NC
0407BB C9          1714  			RET                     	; Found
0407BC             1715  ;
0407BC F6 FF       1716  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407BE C9          1717  			RET                     	; Not found
0407BF             1718  ;
0407BF             1719  ;CHRS - Return character with given ASCII value.
0407BF             1720  ;Result is string.
0407BF             1721  ;
0407BF CD 25 03 04 1722  CHRS:			CALL    ITEMI
0407C3 D9          1723  			EXX
0407C4 7D          1724  			LD      A,L
0407C5 18 0E       1725  			JR      GET1
0407C7             1726  ;
0407C7             1727  ;GETS - Return key pressed as stringor character at position (X,Y).
0407C7             1728  ;Result is string.
0407C7             1729  ;
0407C7 CD 70 0A 04 1730  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407CB FE 28       1731  			CP	'('
0407CD CA FC 43 04 1732  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D1 CD 29 3F 04 1733  			CALL    OSRDCH
0407D5 37          1734  GET1:			SCF
0407D6 18 09       1735  			JR      INKEY1
0407D8             1736  ;
0407D8             1737  ; INKEYS - Wait up to n centiseconds for keypress.
0407D8             1738  ;          Return key pressed as string or null
0407D8             1739  ;          string if time elapsed.
0407D8             1740  ; Result is string.
0407D8             1741  ;
0407D8 CD 25 03 04 1742  INKEYS:			CALL    ITEMI			; Fetch the argument
0407DC D9          1743  			EXX
0407DD CD 32 3F 04 1744  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E1 11 00 4A 04 1745  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407E5 12          1746  			LD      (DE),A
0407E6 3E 80       1747  			LD      A,80H
0407E8 D0          1748  			RET     NC
0407E9 1C          1749  			INC     E
0407EA C9          1750  			RET
0407EB             1751  ;
0407EB             1752  ; INKEYM - Check immediately whether a given key is being pressed
0407EB             1753  ; Result is integer numeric
0407EB             1754  ;
0407EB             1755  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407EB 3E 1E       0001M 			LD	A, function
0407ED 49 CF       0002M 			RST.LIS	08h
0407EF 23          1756  			INC	HL			; Index from 0
0407F0 7D          1757  			LD	A, L			; Negate the LSB of the answer
0407F1 ED 44       1758  			NEG
0407F3 4F          1759  			LD	C, A			;  E: The positive keycode value
0407F4 3E 01       1760  			LD	A, 1			; Throw an "Out of range" error
0407F6 FA 60 37 04 1761  			JP	M, ERROR_		; if the argument < - 128
0407FA             1762  ;
0407FA 21 1D 08 04 1763  			LD	HL, BITLOOKUP		; HL: The bit lookup table
0407FE 11 00 00 00 1764  			LD	DE, 0
040802 79          1765  			LD	A, C
040803 E6 07       1766  			AND	00000111b		; Just need the first three bits
040805 5F          1767  			LD	E, A			; DE: The bit number
040806 19          1768  			ADD	HL, DE
040807 46          1769  			LD	B, (HL)			;  B: The mask
040808             1770  ;
040808 79          1771  			LD	A, C			; Fetch the keycode again
040809 E6 78       1772  			AND	01111000b		; And divide by 8
04080B 0F          1773  			RRCA
04080C 0F          1774  			RRCA
04080D 0F          1775  			RRCA
04080E 5F          1776  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04080F DD 19       1777  			ADD	IX, DE			; IX: The address
040811 78          1778  			LD	A, B			;  B: The mask
040812 DD A6 00    1779  			AND	(IX+0)			; Check whether the bit is set
040815 CA 93 09 04 1780  			JP	Z, ZERO			; No, so return 0
040819 C3 05 06 04 1781  			JP	TRUE			; Otherwise return -1
04081D             1782  ;
04081D             1783  ; A bit lookup table
04081D             1784  ;
04081D 01 02 04 08 1785  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040821 10 20 40 80 1786  			DB	10h, 20h, 40h, 80h
040825             1787  ;
040825             1788  ; MID$ - Return sub-string.
040825             1789  ; Result is string.
040825             1790  ;
040825 CD 1E 0A 04 1791  MIDS:			CALL    EXPRSC			; Get the first string expression
040829 CD B4 09 04 1792  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04082D CD 0A 03 04 1793  			CALL    EXPRI			; Get the second expression
040831 C1          1794  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040832 CD DE 09 04 1795  			CALL    POPS			; Pop the string back off the stack to the string accumulator
040836 D9          1796  			EXX
040837 7D          1797  			LD      A,L			; A: The start index
040838 D9          1798  			EXX
040839 B7          1799  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083A 28 0E       1800  			JR      Z,MIDS1
04083C 3D          1801  			DEC     A
04083D 6F          1802  			LD      L,A			; L: The start index - 1
04083E 93          1803  			SUB     E			; Subtract from the string length
04083F 1E 00       1804  			LD      E,0			; Preemptively set the string length to 0
040841 30 07       1805  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040843 ED 44       1806  			NEG				; Negate the answer and
040845 4F          1807  			LD      C,A			; C: Number of bytes to copy
040846 CD 89 08 04 1808  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084A CD 70 0A 04 1809  MIDS1:			CALL    NXT			; Skip whitespace
04084E FE 2C       1810  			CP      ','			; Check for a comma
040850 FD 23       1811  			INC     IY			; Advance to the next character in the BASIC line
040852 28 0D       1812  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040854 FD 2B       1813  			DEC     IY			; Restore the BASIC program pointer
040856 CD 2F 0A 04 1814  			CALL    BRAKET			; Check for a bracket
04085A 3E 80       1815  			LD      A,80H			; String marker
04085C C9          1816  			RET
04085D             1817  ;
04085D             1818  ; LEFT$ - Return left part of string.
04085D             1819  ; Carry cleared if entire string returned.
04085D             1820  ; Result is string.
04085D             1821  ;
04085D CD 1E 0A 04 1822  LEFTS:			CALL    EXPRSC			; Get the first string expression
040861 CD B4 09 04 1823  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040865 CD 0A 03 04 1824  			CALL    EXPRI			; Get the second expression
040869 C1          1825  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086A CD DE 09 04 1826  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04086E CD 2F 0A 04 1827  			CALL    BRAKET			; Check for closing bracket
040872 D9          1828  			EXX
040873 7D          1829  			LD      A,L			; L: The second parameter
040874 D9          1830  			EXX
040875 BB          1831  			CP      E			; Compare with the string length
040876 30 02       1832  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
040878 6B          1833  			LD      L,E             	; For RIGHTS, no effect in LEFTS
040879 5F          1834  LEFT2:			LD      E,A			; E: The new length of string
04087A 3E 80       1835  LEFT3:			LD      A,80H           	; String marker
04087C C9          1836  			RET
04087D             1837  ;
04087D             1838  ; RIGHT$ - Return right part of string.
04087D             1839  ; Result is string.
04087D             1840  ;
04087D CD 5D 08 04 1841  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040881 D0          1842  			RET     NC			; Do nothing if the second parameter is >= string length
040882 1C          1843  			INC     E			; Check for a zero length string
040883 1D          1844  			DEC     E
040884 C8          1845  			RET     Z			; Yes, so do nothing
040885 4B          1846  			LD      C,E			;  C: Number of bytes to copy
040886 7D          1847  			LD      A,L
040887 93          1848  			SUB     E
040888 6F          1849  			LD      L,A			;  L: Index into the string
040889 79          1850  RIGHT1:			LD	A,C
04088A 01 00 00 00 1851  			LD	BC,0
04088E 4F          1852  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
04088F 7D          1853  			LD	A,L
040890 21 00 4A 04 1854  			LD	HL,ACCS
040894 6F          1855  			LD	L,A			; HL: Source (in ACCS)
040895 11 00 4A 04 1856  			LD      DE,ACCS			; DE: Destination (start of ACCS)
040899 ED B0       1857  			LDIR                    	; Copy
04089B 3E 80       1858  			LD      A,80H			; String marker
04089D C9          1859  			RET
04089E             1860  ;
04089E             1861  ; STRINGS - Return n concatenations of a string.
04089E             1862  ; Result is string.
04089E             1863  ;
04089E CD 0A 03 04 1864  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A2 CD 22 0A 04 1865  			CALL    COMMA			; Check for comma
0408A6 D9          1866  			EXX
0408A7 7D          1867  			LD      A,L			; L: Number of iterations of string
0408A8 D9          1868  			EXX
0408A9 F5          1869  			PUSH    AF
0408AA CD 15 03 04 1870  			CALL    EXPRS			; Get the string
0408AE CD 2F 0A 04 1871  			CALL    BRAKET			; Check for closing bracket
0408B2 F1          1872  			POP     AF			; A: Number of iterations of string
0408B3 B7          1873  			OR      A			; Set flags
0408B4 28 C3       1874  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408B6 3D          1875  			DEC     A
0408B7 4F          1876  			LD      C,A			; C: Loop counter
0408B8 3E 80       1877  			LD      A,80H			; String marker
0408BA C8          1878  			RET     Z
0408BB 1C          1879  			INC     E			; Check for empty string
0408BC 1D          1880  			DEC     E
0408BD C8          1881  			RET     Z              		; And return
0408BE 43          1882  			LD      B,E			; B: String length tally
0408BF 21 00 4A 04 1883  			LD	HL,ACCS
0408C3 C5          1884  STRIN1:			PUSH    BC
0408C4 7E          1885  STRIN2:			LD      A,(HL)
0408C5 23          1886  			INC     HL
0408C6 12          1887  			LD      (DE),A
0408C7 1C          1888  			INC     E
0408C8 3E 13       1889  			LD      A,19
0408CA CA 60 37 04 1890  			JP      Z,ERROR_         	; Throw a "String too long" error
0408CE 10 F4       1891  			DJNZ    STRIN2
0408D0 C1          1892  			POP     BC
0408D1 0D          1893  			DEC     C
0408D2 20 EF       1894  			JR      NZ,STRIN1
0408D4 3E 80       1895  			LD      A,80H
0408D6 C9          1896  			RET
0408D7             1897  ;
0408D7             1898  ;SUBROUTINES
0408D7             1899  ;
0408D7             1900  ;SWAP - Swap arguments
0408D7             1901  ;Exchanges DE,HL D'E',H'L' and B,C
0408D7             1902  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408D7             1903  ;
0408D7 79          1904  SWAP:			LD      A,C
0408D8 48          1905  			LD      C,B
0408D9 47          1906  			LD      B,A
0408DA EB          1907  			EX      DE,HL
0408DB D9          1908  			EXX
0408DC EB          1909  			EX      DE,HL
0408DD D9          1910  			EXX
0408DE C9          1911  			RET
0408DF             1912  ;
0408DF             1913  ;TEST - Test HLH'L' for zero
0408DF             1914  ;Outputs: Z-flag set & A=0 if zero
0408DF             1915  ;Destroys: A,F
0408DF             1916  ;
0408DF 7C          1917  TEST:			LD      A,H
0408E0 B5          1918  			OR      L
0408E1 D9          1919  			EXX
0408E2 B4          1920  			OR      H
0408E3 B5          1921  			OR      L
0408E4 D9          1922  			EXX
0408E5 C9          1923  			RET
0408E6             1924  ;
0408E6             1925  ;DECODE - Decode line number in pseudo-binary.
0408E6             1926  ;   Inputs: IY = Text pointer.
0408E6             1927  ;   Outputs: HL=0, H'L'=line number, C=0.
0408E6             1928  ;   Destroys: A,C,H,L,H',L',IY,F
0408E6             1929  ;
0408E6 D9          1930  DECODE:			EXX
0408E7 21 00 00 00 1931  			LD	HL, 0
0408EB FD 7E 00    1932  			LD      A,(IY)
0408EE FD 23       1933  			INC     IY
0408F0 17          1934  			RLA
0408F1 17          1935  			RLA
0408F2 67          1936  			LD      H,A
0408F3 E6 C0       1937  			AND     0C0H
0408F5 FD AE 00    1938  			XOR     (IY)
0408F8 FD 23       1939  			INC     IY
0408FA 6F          1940  			LD      L,A
0408FB 7C          1941  			LD      A,H
0408FC 17          1942  			RLA
0408FD 17          1943  			RLA
0408FE E6 C0       1944  			AND     0C0H
040900 FD AE 00    1945  			XOR     (IY)
040903 FD 23       1946  			INC     IY
040905 67          1947  			LD      H,A
040906 D9          1948  			EXX
040907             1949  ;			XOR     A
040907             1950  ;			LD      C,A
040907             1951  ;			LD      H,A
040907             1952  ;			LD      L,A
040907 21 00 00 00 1953  			LD	HL, 0
04090B 4D          1954  			LD	C, L
04090C C9          1955  			RET
04090D             1956  ;
04090D             1957  ;HEXSTR - convert numeric value to HEX string.
04090D             1958  ;   Inputs: HLH'L'C = integer or floating-point number
04090D             1959  ;  Outputs: String in string accumulator.
04090D             1960  ;           E = string length.  D = ACCS/256
04090D             1961  ;
04090D FD 23       1962  HEXSTS:			INC     IY              ;SKIP TILDE
04090F CD 1D 03 04 1963  			CALL    ITEMN
040913 CD 1A 09 04 1964  			CALL    HEXSTR
040917 3E 80       1965  			LD      A,80H
040919 C9          1966  			RET
04091A             1967  ;
04091A CD 62 06 04 1968  HEXSTR:			CALL    SFIX
04091E 01 08 00 00 1969  			LD      BC,8
040922 11 00 4A 04 1970  			LD      DE,ACCS
040926 C5          1971  HEXST1:			PUSH    BC
040927 06 04       1972  			LD      B,4
040929 AF          1973  			XOR     A
04092A D9          1974  HEXST2:			EXX
04092B 52 29       1975  			ADD.S	HL,HL
04092D D9          1976  			EXX
04092E 52 ED 6A    1977  			ADC.S	HL,HL
040931 17          1978  			RLA
040932 10 F6       1979  			DJNZ    HEXST2
040934 C1          1980  			POP     BC
040935 0D          1981  			DEC     C
040936 F8          1982  			RET     M
040937 28 06       1983  			JR      Z,HEXST3
040939 B7          1984  			OR      A
04093A 20 03       1985  			JR      NZ,HEXST3
04093C B8          1986  			CP      B
04093D 28 E7       1987  			JR      Z,HEXST1
04093F C6 90       1988  HEXST3:			ADD     A,90H
040941 27          1989  			DAA
040942 CE 40       1990  			ADC     A,40H
040944 27          1991  			DAA
040945 12          1992  			LD      (DE),A
040946 13          1993  			INC     DE
040947 47          1994  			LD      B,A
040948 18 DC       1995  			JR      HEXST1
04094A             1996  ;
04094A             1997  ;Function STR - convert numeric value to ASCII string.
04094A             1998  ;   Inputs: HLH'L'C = integer or floating-point number.
04094A             1999  ;  Outputs: String in string accumulator.
04094A             2000  ;           E = length, D = ACCS/256
04094A             2001  ;           A = 80H (type=string)
04094A             2002  ;
04094A             2003  ;First normalise for decimal output:
04094A             2004  ;
04094A CD 70 0A 04 2005  STRS:			CALL    NXT
04094E FE 7E       2006  			CP      '~'
040950 28 BB       2007  			JR      Z,HEXSTS
040952 CD 1D 03 04 2008  			CALL    ITEMN
040956 DD 21 00 4C 2009  			LD      IX,STAVAR
       04          
04095B DD 7E 03    2010  			LD      A,(IX+3)
04095E B7          2011  			OR      A
04095F DD 21 8C 09 2012  			LD      IX,G9-1         ;G9 FORMAT
       04          
040964 28 05       2013  			JR      Z,STR0
040966 DD 21 00 4C 2014  STR:			LD      IX,STAVAR
       04          
04096B 11 00 4A 04 2015  STR0:			LD      DE,ACCS
04096F 3E 25       2016  			LD      A,37
040971 CD 6A 20 04 2017  			CALL    FPP
040975 DA 60 37 04 2018  			JP      C,ERROR_
040979 DD CB 02 46 2019  			BIT     0,(IX+2)
04097D 3E 80       2020  STR1:			LD      A,80H           ;STRING MARKER
04097F C8          2021  			RET     Z
040980 79          2022  			LD      A,C
040981 C6 04       2023  			ADD     A,4
040983 BB          2024  STR2:			CP      E
040984 28 F7       2025  			JR      Z,STR1
040986 EB          2026  			EX      DE,HL
040987 36 20       2027  			LD      (HL),' '        ;TRAILING SPACE
040989 23          2028  			INC     HL
04098A EB          2029  			EX      DE,HL
04098B 18 F6       2030  			JR      STR2
04098D             2031  ;
04098D 09 00       2032  G9:			DW    9
04098F             2033  ;
04098F             2034  ;STRING COMPARE
04098F             2035  ;Compare string (DE) length B with string (HL) length C.
04098F             2036  ;Result preset to false.
04098F             2037  ;
04098F CD 9D 09 04 2038  SCP:			CALL	SCP0
040993             2039  ;
040993 3E 00       2040  ZERO:			LD      A,0
040995 D9          2041  			EXX
040996 67          2042  			LD      H,A
040997 6F          2043  			LD      L,A
040998 D9          2044  			EXX
040999 67          2045  			LD      H,A
04099A 6F          2046  			LD      L,A
04099B 4F          2047  			LD      C,A
04099C C9          2048  			RET
04099D             2049  ;
04099D 04          2050  SCP0:			INC     B
04099E 0C          2051  			INC     C
04099F 05          2052  SCP1:			DEC     B
0409A0 28 0A       2053  			JR      Z,SCP2
0409A2 0D          2054  			DEC     C
0409A3 28 0C       2055  			JR      Z,SCP3
0409A5 1A          2056  			LD      A,(DE)
0409A6 BE          2057  			CP      (HL)
0409A7 C0          2058  			RET     NZ
0409A8 13          2059  			INC     DE
0409A9 23          2060  			INC     HL
0409AA 18 F3       2061  			JR      SCP1
0409AC B7          2062  SCP2:			OR      A
0409AD 0D          2063  			DEC     C
0409AE C8          2064  			RET     Z
0409AF 37          2065  			SCF
0409B0 C9          2066  			RET
0409B1 B7          2067  SCP3:			OR      A
0409B2 0C          2068  			INC     C
0409B3 C9          2069  			RET
0409B4             2070  ;
0409B4             2071  ; PUSHS - SAVE STRING ON STACK.
0409B4             2072  ;     Inputs: String in string accumulator.
0409B4             2073  ;             E = string length.
0409B4             2074  ;             A - saved on stack.
0409B4             2075  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B4             2076  ;
0409B4 CD 4F 16 04 2077  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409B8 DD E1       2078  			POP     IX              	; IX: Return address
0409BA B7          2079  			OR      A               	; Clear the carry flag
0409BB 01 00 00 00 2080  			LD	BC,0			; BC: Length of the string
0409BF 4B          2081  			LD	C,E
0409C0 21 00 4A 04 2082  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C4 11 00 4A 04 2083  			LD	DE,ACCS
0409C8 59          2084  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409C9 ED 52       2085  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409CB 39          2086  			ADD     HL,SP			; Grow the stack
0409CC F9          2087  			LD      SP,HL
0409CD 57          2088  			LD      D,A			;  D: This needs to be set to A for some functions
0409CE             2089  ; BEGIN MISSING FROM BINARY
0409CE             2090  			; LD	B,A			; Stack A and C (the string length)
0409CE             2091  			; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409CE             2092  			; LD	B,0			; Reset B to 0 for the LDIR in this function
0409CE             2093  ; END MISSING FROM BINARY
0409CE D5          2094  			PUSH 	DE ; ADDED FROM BINARY
0409CF 28 0B       2095  			JR      Z,PUSHS1        	; Is it zero length?
0409D1 11 00 4A 04 2096  			LD      DE,ACCS			; DE: Destination
0409D5 EB          2097  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409D6 ED B0       2098  			LDIR	                    	; Copy to stack
0409D8 CD 4F 16 04 2099  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409DC DD E9       2100  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409DE             2101  ;
0409DE             2102  ; POPS - RESTORE STRING FROM STACK.
0409DE             2103  ;     Inputs: C = string length.
0409DE             2104  ;    Outputs: String in string accumulator.
0409DE             2105  ;             E = string length.
0409DE             2106  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409DE             2107  ;
0409DE DD E1       2108  POPS:			POP     IX              	; IX: Return address
0409E0 69          2109  			LD	L,C			; Temporarily store string length in L
0409E1 01 00 00 00 2110  			LD	BC,0
0409E5 4D          2111  			LD	C,L			; BC: Number of bytes to copy
0409E6 21 00 00 00 2112  			LD      HL,0			; HL: 0
0409EA 39          2113  			ADD     HL,SP			; HL: Stack address
0409EB 11 00 4A 04 2114  			LD      DE,ACCS			; DE: Destination
0409EF 0C          2115  			INC     C			; Quick check to see if this is a zero length string
0409F0 0D          2116  			DEC     C
0409F1 28 02       2117  			JR      Z,POPS1         	; Yes it is, so skip
0409F3 ED B0       2118  			LDIR                    	; No, so copy from the stack
0409F5 F9          2119  POPS1:			LD      SP,HL			; Shrink the stack
0409F6 DD E9       2120  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409F8             2121  ;
0409F8 FD 7E 00    2122  HEXDIG:			LD      A,(IY)
0409FB FE 30       2123  			CP      '0'
0409FD D8          2124  			RET     C
0409FE FE 3A       2125  			CP      '9'+1
040A00 3F          2126  			CCF
040A01 D0          2127  			RET     NC
040A02 FE 41       2128  			CP      'A'
040A04 D8          2129  			RET     C
040A05 D6 37       2130  			SUB     'A'-10
040A07 FE 10       2131  			CP      16
040A09 3F          2132  			CCF
040A0A C9          2133  			RET
040A0B             2134  ;
040A0B FD 7E 00    2135  BINDIG:			LD	A,(IY)
040A0E FE 30       2136  			CP	'0'
040A10 D8          2137  			RET	C
040A11 FE 32       2138  			CP	'1'+1
040A13 3F          2139  			CCF
040A14 C9          2140  			RET
040A15             2141  ;
040A15 FE 3E       2142  RELOP?:			CP      '>'
040A17 D0          2143  			RET     NC
040A18 FE 3D       2144  			CP      '='
040A1A D0          2145  			RET     NC
040A1B FE 3C       2146  			CP      '<'
040A1D C9          2147  			RET
040A1E             2148  ;
040A1E CD 15 03 04 2149  EXPRSC:			CALL    EXPRS
040A22 CD 70 0A 04 2150  COMMA:			CALL    NXT
040A26 FD 23       2151  			INC     IY
040A28 FE 2C       2152  			CP      ','
040A2A C8          2153  			RET     Z
040A2B 3E 05       2154  			LD      A,5
040A2D 18 0B       2155  			JR      ERROR1_EV          ;"Missing ,"
040A2F             2156  ;
040A2F CD 70 0A 04 2157  BRAKET:			CALL    NXT
040A33 FD 23       2158  			INC     IY
040A35 FE 29       2159  			CP      ')'
040A37 C8          2160  			RET     Z
040A38 3E 1B       2161  			LD      A,27
040A3A C3 60 37 04 2162  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A3E             2163  ;
040A3E FD 23       2164  SAVE_EV:			INC     IY
040A40 08          2165  SAVE1:			EX      AF,AF'
040A41 FA 36 03 04 2166  			JP      M,TYPE_EV_
040A45 08          2167  			EX      AF,AF'
040A46 E3          2168  			EX      (SP),HL
040A47 D9          2169  			EXX
040A48 E5          2170  			PUSH    HL
040A49 D9          2171  			EXX
040A4A F5          2172  			PUSH    AF
040A4B C5          2173  			PUSH    BC
040A4C E9          2174  			JP      (HL)
040A4D             2175  ;
040A4D 08          2176  DOIT:			EX      AF,AF'
040A4E FA 36 03 04 2177  			JP      M,TYPE_EV_
040A52 D9          2178  			EXX
040A53 C1          2179  			POP     BC              ;RETURN ADDRESS
040A54 D9          2180  			EXX
040A55 79          2181  			LD      A,C
040A56 C1          2182  			POP     BC
040A57 47          2183  			LD      B,A
040A58 F1          2184  			POP     AF              ;OPERATOR
040A59 D9          2185  			EXX
040A5A EB          2186  			EX      DE,HL
040A5B E1          2187  			POP     HL
040A5C D9          2188  			EXX
040A5D EB          2189  			EX      DE,HL
040A5E E1          2190  			POP     HL
040A5F D9          2191  			EXX
040A60 C5          2192  			PUSH    BC
040A61 D9          2193  			EXX
040A62 E6 0F       2194  			AND     0FH
040A64 CD 6A 20 04 2195  			CALL    FPP
040A68 38 D0       2196  			JR      C,ERROR1_EV
040A6A AF          2197  			XOR     A
040A6B 08          2198  			EX      AF,AF'          ;TYPE
040A6C FD 7E 00    2199  			LD      A,(IY)
040A6F C9          2200  			RET
040A70             2201  ;
040A70             2202  ; Skip spaces
040A70             2203  ; - IY: String pointer
040A70             2204  ; Returns:
040A70             2205  ;  - A: The non-space character found
040A70             2206  ; - IY: Points to the character before that
040A70             2207  ;
040A70 FD 7E 00    2208  NXT:			LD      A,(IY)			; Fetch the character
040A73 FE 20       2209  			CP      ' '			; If it is space, then return
040A75 C0          2210  			RET     NZ
040A76 FD 23       2211  			INC     IY			; Increment the pointer and
040A78 C3 70 0A 04 2212  			JP      NXT			; Loop
040A7C             2213  ;
040A7C E5          2214  DISPT2:			PUSH    HL
040A7D 21 B5 01 04 2215  			LD      HL,SOPTBL
040A81 18 07       2216  			JR      DISPT0
040A83             2217  ;
040A83 E5          2218  DISPAT:			PUSH    HL
040A84 D6 8D       2219  			SUB     FUNTOK
040A86 21 0A 01 04 2220  			LD      HL,FUNTBL
040A8A C5          2221  DISPT0:			PUSH    BC
040A8B             2222  
040A8B 01 03 00 00 2223  			LD	BC, 3
040A8F 47          2224  			LD	B, A
040A90 ED 4C       2225  			MLT	BC
040A92 09          2226  			ADD	HL, BC
040A93 ED 27       2227  			LD	HL, (HL)
040A95             2228  
040A95             2229  ;			ADD     A,A
040A95             2230  ;			LD      C,A
040A95             2231  ;			LD      B,0
040A95             2232  ;			ADD     HL,BC
040A95             2233  ;			LD      A,(HL)
040A95             2234  ;			INC     HL
040A95             2235  ;			LD      H,(HL)
040A95             2236  ;			LD      L,A
040A95             2237  
040A95 C1          2238  			POP     BC
040A96 E3          2239  			EX      (SP),HL
040A97 C9          2240  			RET                     ;OFF TO ROUTINE
040A98             2241  
040A98             2242  ; --- End eval.asm ---
040A98             2243  
040A98             2244  ; --- Begin exec.asm ---
040A98             2245  ;
040A98             2246  ; Title:	BBC Basic Interpreter - Z80 version
040A98             2247  ;		Statement Execution & Assembler Module - "EXEC"
040A98             2248  ; Author:	(C) Copyright  R.T.Russell  1984
040A98             2249  ; Modified By:	Dean Belfield
040A98             2250  ; Created:	12/05/2023
040A98             2251  ; Last Updated:	26/06/2023
040A98             2252  ;
040A98             2253  ; Modinfo:
040A98             2254  ; 27/01/1984:	Version 2.1
040A98             2255  ; 02/03/1987:	Version 3.0
040A98             2256  ; 11/06/1987:	Version 3.1
040A98             2257  ; 12/05/2023:	Modified by Dean Belfield
040A98             2258  ; 07/06/2023:	Modified to run in ADL mode
040A98             2259  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040A98             2260  
040A98             2261  			; .ASSUME	ADL = 1
040A98             2262  
040A98             2263  			; INCLUDE	"equs.inc"
040A98             2264  
040A98             2265  			; SEGMENT CODE
040A98             2266  
040A98             2267  			; XDEF	XEQ
040A98             2268  			; XDEF	CHAIN0
040A98             2269  			; XDEF	RUN
040A98             2270  			; XDEF	SYNTAX
040A98             2271  			; XDEF	ESCAPE
040A98             2272  			; XDEF	FN_EX
040A98             2273  			; XDEF	USR
040A98             2274  			; XDEF	STORE5
040A98             2275  			; XDEF	STORE4
040A98             2276  			; XDEF	CHECK
040A98             2277  			; XDEF	TERMQ
040A98             2278  			; XDEF	FILL
040A98             2279  			; XDEF	X4OR5
040A98             2280  			; XDEF	MUL16
040A98             2281  			; XDEF	CHANEL
040A98             2282  			; XDEF	ASSEM
040A98             2283  
040A98             2284  			; XREF	AUTO
040A98             2285  			; XREF	DELETE
040A98             2286  			; XREF	LOAD
040A98             2287  			; XREF	LIST_
040A98             2288  			; XREF	NEW
040A98             2289  			; XREF	OLD
040A98             2290  			; XREF	RENUM
040A98             2291  			; XREF	SAVE
040A98             2292  			; XREF	SOUND
040A98             2293  			; XREF	CLG
040A98             2294  			; XREF	DRAW
040A98             2295  			; XREF	ENVEL
040A98             2296  			; XREF	GCOL
040A98             2297  			; XREF	MODE
040A98             2298  			; XREF	MOVE
040A98             2299  			; XREF	PLOT
040A98             2300  			; XREF	COLOUR
040A98             2301  			; XREF	EXPRS
040A98             2302  			; XREF	HIMEM
040A98             2303  			; XREF	LOAD0
040A98             2304  			; XREF	RANDOM
040A98             2305  			; XREF	CLEAR
040A98             2306  			; XREF	ERRTRP
040A98             2307  			; XREF	PAGE_
040A98             2308  			; XREF	DATAPTR
040A98             2309  			; XREF	ERRLIN
040A98             2310  			; XREF	TRAP
040A98             2311  			; XREF	NXT
040A98             2312  			; XREF	SETLIN
040A98             2313  			; XREF	CLOOP
040A98             2314  			; XREF	OSSHUT
040A98             2315  			; XREF	WARM
040A98             2316  			; XREF	TRACEN
040A98             2317  			; XREF	OUTCHR
040A98             2318  			; XREF	PBCDL
040A98             2319  			; XREF	OSCLI
040A98             2320  			; XREF	LISTON
040A98             2321  			; XREF	GETVAR
040A98             2322  			; XREF	PUTVAR
040A98             2323  			; XREF	DATPTR
040A98             2324  			; XREF	ERROR_
040A98             2325  			; XREF	EXPR
040A98             2326  			; XREF	CREATE
040A98             2327  			; XREF	EXPRI
040A98             2328  			; XREF	BRAKET
040A98             2329  			; XREF	FREE
040A98             2330  			; XREF	OSBPUT
040A98             2331  			; XREF	COUNT
040A98             2332  			; XREF	STR
040A98             2333  			; XREF	HEXSTR
040A98             2334  			; XREF	CRLF
040A98             2335  			; XREF	ITEMI
040A98             2336  			; XREF	FINDL
040A98             2337  			; XREF	TEST
040A98             2338  			; XREF	EXPRN
040A98             2339  			; XREF	DLOAD5
040A98             2340  			; XREF	DLOAD5_SPL
040A98             2341  			; XREF	LOADN
040A98             2342  			; XREF	FPP
040A98             2343  			; XREF	SWAP
040A98             2344  			; XREF	GETDEF
040A98             2345  			; XREF	ZERO
040A98             2346  			; XREF	OSBGET
040A98             2347  			; XREF	BUFFER
040A98             2348  			; XREF	CONS
040A98             2349  			; XREF	VAL0
040A98             2350  			; XREF	OSLINE
040A98             2351  			; XREF	CLRSCN
040A98             2352  			; XREF	TELL
040A98             2353  			; XREF	SAYLN
040A98             2354  			; XREF	REPORT
040A98             2355  			; XREF	PUTPTR
040A98             2356  			; XREF	PUTIME
040A98             2357  			; XREF	PUTIMS
040A98             2358  			; XREF	LOMEM
040A98             2359  			; XREF	WIDTH
040A98             2360  			; XREF	OSWRCH
040A98             2361  			; XREF	COMMA
040A98             2362  			; XREF	OSCALL
040A98             2363  			; XREF	SFIX
040A98             2364  			; XREF	LOAD4
040A98             2365  			; XREF	PUSHS
040A98             2366  			; XREF	POPS
040A98             2367  			; XREF	LOADS
040A98             2368  			; XREF	PUTCSR
040A98             2369  			; XREF	OUT_
040A98             2370  			; XREF	R0
040A98             2371  ;
040A98             2372  ; List of token values used in this module
040A98             2373  ;
040A98             2374  TAND:			EQU     80H
040A98             2375  TOR:			EQU     84H
040A98             2376  TERROR_EX:			EQU     85H
040A98             2377  LINE_EX_:			EQU     86H
040A98             2378  OFF_:			EQU     87H
040A98             2379  STEP:			EQU     88H
040A98             2380  SPC:			EQU     89H
040A98             2381  TAB:			EQU     8AH
040A98             2382  ELSE_EX_:			EQU     8BH
040A98             2383  THEN_EX_:			EQU     8CH
040A98             2384  LINO_EX:			EQU     8DH
040A98             2385  TO_EX:			EQU     B8H
040A98             2386  TCMD_EX:			EQU     C6H
040A98             2387  TCALL:			EQU     D6H
040A98             2388  DATA_EX_:			EQU     DCH
040A98             2389  DEF_:			EQU     DDH
040A98             2390  TGOSUB:			EQU     E4H
040A98             2391  TGOTO:			EQU     E5H
040A98             2392  TON:			EQU     EEH
040A98             2393  TPROC:			EQU     F2H
040A98             2394  TSTOP:			EQU     FAH
040A98             2395  
040A98             2396  ; The command table
040A98             2397  ; Commands are tokens from C6H onwards; this lookup table is used to
040A98             2398  ; run the corresponding function; Note that DATA and DEF both use the same
040A98             2399  ; code as REM
040A98             2400  ;
040A98 E9 36 04    2401  CMDTAB:			DW24  AUTO			; C6H
040A9B 4C 35 04    2402  			DW24  DELETE			; C7H
040A9E 2A 37 04    2403  			DW24  LOAD			; C8H
040AA1 87 35 04    2404  			DW24  LIST_			; C9H
040AA4 07 37 04    2405  			DW24  NEW			; CAH
040AA7 0D 37 04    2406  			DW24  OLD			; CBH
040AAA 16 36 04    2407  			DW24  RENUM			; CCH
040AAD 3B 37 04    2408  			DW24  SAVE			; CDH
040AB0 A8 15 04    2409  			DW24  PUT			; CEH
040AB3 C8 13 04    2410  			DW24  PTR_EX			; CFH
040AB6 E2 13 04    2411  			DW24  PAGEV_EX			; D0H
040AB9 F5 13 04    2412  			DW24  TIMEV_EX			; D1H
040ABC 1E 14 04    2413  			DW24  LOMEMV_EX			; D2H
040ABF 37 14 04    2414  			DW24  HIMEMV_EX			; D3H
040AC2 26 46 04    2415  			DW24  SOUND			; D4H
040AC5 C2 14 04    2416  			DW24  BPUT			; D5H
040AC8 DA 14 04    2417  			DW24  CALL_			; D6H
040ACB 4C 0B 04    2418  			DW24  CHAIN			; D7H
040ACE 97 13 04    2419  			DW24  CLR			; D8H
040AD1 B6 14 04    2420  			DW24  CLOSE			; D9H
040AD4 C2 43 04    2421  			DW24  CLG			; DAH
040AD7 6A 13 04    2422  			DW24  CLS			; DBH
040ADA 2B 0C 04    2423  			DW24  REM_EX             		; DCH: DATA
040ADD 2B 0C 04    2424  			DW24  REM_EX             		; DDH: DEF
040AE0 F1 0C 04    2425  			DW24  DIM_EX			; DEH
040AE3 EC 45 04    2426  			DW24  DRAW			; DFH
040AE6 C6 0B 04    2427  			DW24  END_			; E0H
040AE9 82 11 04    2428  			DW24  ENDPRO			; E1H
040AEC B7 43 04    2429  			DW24  ENVEL			; E2H
040AEF 97 0F 04    2430  			DW24  FOR_EX			; E3H
040AF2 47 0F 04    2431  			DW24  GOSUB_EX			; E4H
040AF5 2B 0F 04    2432  			DW24  GOTO_EX			; E5H
040AF8 80 45 04    2433  			DW24  GCOL			; E6H
040AFB 36 13 04    2434  			DW24  IF_			; E7H
040AFE 24 12 04    2435  			DW24  INPUT			; E8H
040B01 4C 0C 04    2436  			DW24  LET			; E9H
040B04 27 11 04    2437  			DW24  LOCAL_EX_			; EAH
040B07 D2 43 04    2438  			DW24  MODE			; EBH
040B0A E4 45 04    2439  			DW24  MOVE			; ECH
040B0D E5 0F 04    2440  			DW24  NEXT_EX			; EDH
040B10 BE 0E 04    2441  			DW24  ON_EX_			; EEH
040B13 90 14 04    2442  			DW24  VDU			; EFH
040B16 B2 45 04    2443  			DW24  PLOT			; F0H
040B19 C7 0D 04    2444  			DW24  PRINT_			; F1H
040B1C 84 10 04    2445  			DW24  PROC_EX			; F2H
040B1F D6 12 04    2446  			DW24  READ			; F3H
040B22 2B 0C 04    2447  			DW24  REM_EX			; F4H
040B25 67 0F 04    2448  			DW24  REPEAT_EX			; F5H
040B28 8F 13 04    2449  			DW24  REPOR			; F6H
040B2B A1 13 04    2450  			DW24  RESTOR_EX			; F7H
040B2E 55 0F 04    2451  			DW24  RETURN			; F8H
040B31 46 0B 04    2452  			DW24  RUN			; F9H
040B34 77 13 04    2453  			DW24  STOP			; FAH
040B37 CE 44 04    2454  			DW24  COLOUR			; FBH
040B3A 72 14 04    2455  			DW24  TRACE_EX			; FCH
040B3D 71 0F 04    2456  			DW24  UNTIL_EX			; FDH
040B40 64 14 04    2457  			DW24  WIDTHV			; FEH
040B43 11 0C 04    2458  			DW24  CLI             		; FFH: OSCLI
040B46             2459  
040B46             2460  ; RUN
040B46             2461  ; RUN "filename"
040B46             2462  ;
040B46 CD 7A 17 04 2463  RUN:			CALL    TERMQ			; Standalone RUN command?
040B4A 28 10       2464  			JR      Z,RUN0			; Yes, so just RUN the code
040B4C             2465  
040B4C             2466  ; CHAIN "filename"
040B4C             2467  ;
040B4C CD 15 03 04 2468  CHAIN:			CALL    EXPRS			; Get the filename
040B50 3E 0D       2469  			LD      A,CR			; Terminate it with a CR
040B52 12          2470  			LD      (DE),A
040B53 ED 7B 20 4D 2471  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B58 CD 1F 38 04 2472  			CALL    LOAD0			; And load the file in
040B5C             2473  ;
040B5C ED 7B 20 4D 2474  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B61 DD 21 38 4D 2475  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B66 ED 5F       2476  @@:			LD      A, R			; Use the R register to seed the random number generator
040B68 28 FC       2477  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B6A 07          2478  			RLCA				; Rotate it
040B6B 07          2479  			RLCA
040B6C DD 77 03    2480  			LD      (IX+3),A		; And store
040B6F 9F          2481  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B70 DD 77 04    2482  			LD      (IX+4),A		; And store
040B73 CD 76 38 04 2483  			CALL    CLEAR
040B77 21 00 00 00 2484  			LD      HL,0			; Clear the error trap sysvar
040B7B 22 2C 4D 04 2485  			LD      (ERRTRP),HL
040B7F 2A 14 4D 04 2486  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B83 3E DC       2487  			LD      A,DATA_EX_			; The DATA token value
040B85 CD 4E 18 04 2488  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B89 22 31 4D 04 2489  			LD      (DATPTR),HL     	; Set data pointer
040B8D FD 2A 14 4D 2490  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B92             2491  ;
040B92 CD DA 0B 04 2492  XEQ0:			CALL    NEWLIN
040B96 FD 22 35 4D 2493  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040B9B CD 6D 3F 04 2494  			CALL    TRAP           		; Check keyboard
040B9F CD 70 0A 04 2495  XEQ1:			CALL    NXT
040BA3 FD 23       2496  			INC     IY
040BA5 FE 3A       2497  			CP      ':'             	; Seperator
040BA7 28 F6       2498  			JR      Z,XEQ1
040BA9 FE 0D       2499  			CP      CR
040BAB 28 E5       2500  			JR      Z,XEQ0          	; New program line
040BAD D6 C6       2501  			SUB     TCMD_EX
040BAF DA 3A 0C 04 2502  			JP      C,LET0          	; Implied "LET"
040BB3             2503  
040BB3 01 03 00 00 2504  			LD	BC, 3
040BB7 47          2505  			LD	B, A
040BB8 ED 4C       2506  			MLT	BC
040BBA 21 98 0A 04 2507  			LD	HL,CMDTAB
040BBE 09          2508  			ADD	HL, BC
040BBF ED 27       2509  			LD	HL, (HL)		; Table entry
040BC1             2510  
040BC1             2511  ;			ADD     A,A
040BC1             2512  ;			LD      C,A
040BC1             2513  ;			LD      B,0
040BC1             2514  ;			LD      HL,CMDTAB
040BC1             2515  ;			ADD     HL,BC
040BC1             2516  ;			LD      A,(HL)          	; Table entry
040BC1             2517  ;			INC     HL
040BC1             2518  ;			LD      H,(HL)
040BC1             2519  ;			LD      L,A
040BC1             2520  
040BC1 CD 70 0A 04 2521  			CALL    NXT
040BC5 E9          2522  			JP      (HL)            	; Execute the statement
040BC6             2523  
040BC6             2524  ;END
040BC6             2525  ;
040BC6 CD AE 39 04 2526  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BCA 7C          2527  			LD      A,H
040BCB B5          2528  			OR      L               ;DIRECT?
040BCC CA 80 30 04 2529  			JP      Z,CLOOP
040BD0 1E 00       2530  			LD      E,0
040BD2 CD 2B 43 04 2531  			CALL    OSSHUT          ;CLOSE ALL FILES
040BD6 C3 7F 30 04 2532  			JP      WARM            ;"Ready"
040BDA             2533  ;
040BDA FD 7E 00    2534  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BDD 01 03 00 00 2535  			LD      BC,3
040BE1 FD 09       2536  			ADD     IY,BC
040BE3 B7          2537  			OR      A
040BE4 28 E0       2538  			JR      Z,END_           ;LENGTH=0, EXIT
040BE6 2A 26 4D 04 2539  			LD      HL,(TRACEN)
040BEA 7C          2540  			LD      A,H
040BEB B5          2541  			OR      L
040BEC C8          2542  			RET     Z
040BED 11 00 00 00 2543  			LD	DE, 0		;Clear DE
040BF1 FD 56 FF    2544  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BF4 FD 5E FE    2545  			LD      E,(IY-2)
040BF7 ED 52       2546  			SBC     HL,DE
040BF9 D8          2547  			RET     C
040BFA EB          2548  			EX      DE,HL
040BFB 3E 5B       2549  			LD      A,'['           ;TRACE
040BFD CD 4F 39 04 2550  			CALL    OUTCHR
040C01 CD F7 39 04 2551  			CALL    PBCDL
040C05 3E 5D       2552  			LD      A,']'
040C07 CD 4F 39 04 2553  			CALL    OUTCHR
040C0B 3E 20       2554  			LD      A,' '
040C0D C3 4F 39 04 2555  			JP      OUTCHR
040C11             2556  
040C11             2557  ; Routines for each statement -------------------------------------------------
040C11             2558  
040C11             2559  ; OSCLI
040C11             2560  ;
040C11 CD 15 03 04 2561  CLI:			CALL    EXPRS
040C15 3E 0D       2562  			LD      A,CR
040C17 12          2563  			LD      (DE),A
040C18 21 00 4A 04 2564  			LD      HL,ACCS
040C1C CD 90 3F 04 2565  			CALL    OSCLI
040C20 C3 96 0B 04 2566  			JP      XEQ
040C24             2567  
040C24             2568  ; REM, *
040C24             2569  ;
040C24 FD E5       2570  EXT_EX:			PUSH    IY
040C26 E1          2571  			POP     HL
040C27 CD 90 3F 04 2572  			CALL    OSCLI
040C2B FD E5       2573  REM_EX:			PUSH    IY
040C2D E1          2574  			POP     HL
040C2E 3E 0D       2575  			LD      A,CR
040C30 47          2576  			LD      B,A
040C31 ED B1       2577  			CPIR                    ;FIND LINE END
040C33 E5          2578  			PUSH    HL
040C34 FD E1       2579  			POP     IY
040C36 C3 92 0B 04 2580  			JP      XEQ0
040C3A             2581  
040C3A             2582  ; [LET] var = expr
040C3A             2583  ;
040C3A FE C5       2584  LET0:			CP      ELSE_EX_-TCMD_EX
040C3C 28 ED       2585  			JR      Z,REM_EX
040C3E             2586  			; CP      ('*'-TCMD) & 0FFH
040C3E             2587  			; JR      Z,EXT_EX
040C3E             2588  			; CP      ('='-TCMD) & 0FFH
040C3E             2589  			; JR      Z,FNEND
040C3E             2590  			; CP      ('['-TCMD) & 0FFH
040C3E             2591  			; ez80asm doesn't like () in expressions
040C3E FE 64       2592  			CP      '*'-TCMD_EX & 0FFH
040C40 28 E2       2593  			JR      Z,EXT_EX
040C42 FE 77       2594  			CP      '='-TCMD_EX & 0FFH
040C44 28 5B       2595  			JR      Z,FNEND
040C46 FE 95       2596  			CP      '['-TCMD_EX & 0FFH
040C48 28 25       2597  			JR      Z,ASM
040C4A FD 2B       2598  			DEC     IY
040C4C CD BE 15 04 2599  LET:			CALL    ASSIGN			; Assign the variable
040C50 CA 96 0B 04 2600  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C54 38 41       2601  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C56             2602  ;
040C56 F5          2603  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C57 CD 90 17 04 2604  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C5B E5          2605  			PUSH    HL			; HL: Address of the variable
040C5C CD 15 03 04 2606  			CALL    EXPRS
040C60 DD E1       2607  			POP     IX			; IX: Address of the variable
040C62 F1          2608  			POP     AF			; AF: The variable type
040C63 CD 00 16 04 2609  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C67 C3 96 0B 04 2610  XEQR:			JP      XEQ
040C6B             2611  ;
040C6B CD DA 0B 04 2612  ASM0:			CALL    NEWLIN
040C6F FD 22 35 4D 2613  ASM:			LD      (ERRLIN),IY
       04          
040C74 CD 6D 3F 04 2614  			CALL    TRAP
040C78 CD 9B 18 04 2615  			CALL    ASSEM
040C7C 38 19       2616  			JR      C,SYNTAX
040C7E FE 0D       2617  			CP      CR
040C80 28 E9       2618  			JR      Z,ASM0
040C82 21 40 4D 04 2619  			LD      HL,LISTON
040C86 7E          2620  			LD      A,(HL)
040C87 E6 0F       2621  			AND     0FH
040C89 F6 B0       2622  			OR      B0H
040C8B 77          2623  			LD      (HL),A
040C8C 18 D9       2624  			JR      XEQR
040C8E             2625  ;
040C8E CD 3A 3A 04 2626  VAR_:			CALL    GETVAR
040C92 C8          2627  			RET     Z
040C93 D2 29 3A 04 2628  			JP      NC,PUTVAR
040C97 3E 10       2629  SYNTAX:			LD      A,16            ;"Syntax error"
040C99 18 02       2630  			JR	ERROR0_EX
040C9B 3E 11       2631  ESCAPE:			LD      A,17            ;"Escape"
040C9D C3 60 37 04 2632  ERROR0_EX:			JP      ERROR_
040CA1             2633  
040CA1             2634  ; =
040CA1             2635  ;
040CA1 CD C7 01 04 2636  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CA5 43          2637  			LD      B,E
040CA6 EB          2638  			EX      DE,HL
040CA7 D9          2639  			EXX                     ;SAVE RESULT
040CA8 EB          2640  			EX      DE,HL           ; IN DEB'C'D'E'
040CA9 C1          2641  FNEND5:			POP     BC
040CAA 21 58 17 04 2642  			LD      HL,LOCCHK
040CAE B7          2643  			OR      A
040CAF ED 42       2644  			SBC     HL,BC
040CB1 28 1C       2645  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CB3 21 84 10 04 2646  			LD      HL,FNCHK
040CB7 B7          2647  			OR      A
040CB8 ED 42       2648  			SBC     HL,BC
040CBA 3E 07       2649  			LD      A,7
040CBC 20 DF       2650  			JR      NZ,ERROR0_EX       ;"No FN"
040CBE FD E1       2651  			POP     IY
040CC0 FD 22 35 4D 2652  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CC5 EB          2653  			EX      DE,HL
040CC6 D9          2654  			EXX
040CC7 EB          2655  			EX      DE,HL
040CC8 11 00 4A 04 2656  			LD      DE,ACCS
040CCC 58          2657  			LD      E,B
040CCD 08          2658  			EX      AF,AF'
040CCE C9          2659  			RET
040CCF             2660  ;
040CCF DD E1       2661  FNEND0:			POP     IX
040CD1 C1          2662  			POP     BC
040CD2 78          2663  			LD      A,B
040CD3 B7          2664  			OR      A
040CD4 FA E2 0C 04 2665  			JP      M,FNEND1        ;STRING
040CD8 E1          2666  			POP     HL
040CD9 D9          2667  			EXX
040CDA E1          2668  			POP     HL
040CDB D9          2669  			EXX
040CDC CD D6 15 04 2670  			CALL    STORE
040CE0 18 C7       2671  			JR      FNEND5
040CE2 21 00 00 00 2672  FNEND1:			LD      HL,0
040CE6 39          2673  			ADD     HL,SP
040CE7 D5          2674  			PUSH    DE
040CE8 59          2675  			LD      E,C
040CE9 CD 04 16 04 2676  			CALL    STORES
040CED D1          2677  			POP     DE
040CEE F9          2678  			LD      SP,HL
040CEF 18 B8       2679  			JR      FNEND5
040CF1             2680  
040CF1             2681  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF1             2682  ; DIM var expr[,var expr...]
040CF1             2683  ;
040CF1 CD 3A 3A 04 2684  DIM_EX:			CALL    GETVAR          	; Get the variable
040CF5 DA 81 0D 04 2685  			JP      C,BADDIM		; Throw a "Bad Dim" error
040CF9 CA 8B 0D 04 2686  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040CFD CD AE 3B 04 2687  			CALL    CREATE			; Create a new entity
040D01 E5          2688  			PUSH    HL			; HL: Address of the entity
040D02 DD E1       2689  			POP     IX			; IX: Address of the entity
040D04 FD 7E 00    2690  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D07 FE 28       2691  			CP      '('			; Check for opening brackets
040D09 7A          2692  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D0A 20 7F       2693  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D0C             2694  ;
040D0C             2695  ; At this point we're reserving a variable array
040D0C             2696  ;
040D0C E5          2697  			PUSH    HL			; HL: Address of the entity
040D0D F5          2698  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D0E 11 01 00 00 2699  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D12 42          2700  			LD      B,D			;  B: The number of dimensions in the array
040D13             2701  ;
040D13 FD 23       2702  DIM1:			INC     IY			; Skip to the next token
040D15 C5          2703  			PUSH    BC			; Stack the dimension counter
040D16 D5          2704  			PUSH    DE			; Stack the total size of array accumulator
040D17 DD E5       2705  			PUSH    IX			; Stack the entity address
040D19 CD 0A 03 04 2706  			CALL    EXPRI           	; Fetch the size of this dimension
040D1D CB 7C       2707  			BIT     7,H			; If it is negative then
040D1F 20 60       2708  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D21 D9          2709  			EXX
040D22 23          2710  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D23 DD E1       2711  			POP     IX			; IX: The entity address
040D25 DD 23       2712  			INC     IX
040D27 DD 75 00    2713  			LD      (IX),L          	; Save the size of this dimension in the entity
040D2A DD 23       2714  			INC     IX
040D2C DD 74 00    2715  			LD      (IX),H
040D2F C1          2716  			POP     BC
040D30 CD 72 18 04 2717  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D34 38 4F       2718  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D36 EB          2719  			EX      DE,HL           	; DE: The new total size of array accumulator
040D37 C1          2720  			POP     BC
040D38 04          2721  			INC     B               	;  B: The dimension counter; increment
040D39 FD 7E 00    2722  			LD      A,(IY)			; Fetch the nex token
040D3C FE 2C       2723  			CP      ','             	; Check for another dimension in the array
040D3E 28 D3       2724  			JR      Z,DIM1			; And loop
040D40             2725  ;
040D40 CD 2F 0A 04 2726  			CALL    BRAKET          	; Check for closing bracket
040D44 F1          2727  			POP     AF              	; Restore the type
040D45 DD 23       2728  			INC     IX
040D47 DD E3       2729  			EX      (SP),IX
040D49 DD 70 00    2730  			LD      (IX),B          	; Number of dimensions
040D4C CD 65 18 04 2731  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D50 E1          2732  			POP     HL			; Restore the entity address
040D51 38 32       2733  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D53             2734  ;
040D53             2735  ; We now allocate the memory for the array
040D53             2736  ;
040D53 19          2737  DIM3:			ADD     HL,DE
040D54 38 2F       2738  			JR      C,NOROOM
040D56 E5          2739  			PUSH    HL
040D57 24          2740  			INC     H
040D58 28 2B       2741  			JR      Z,NOROOM
040D5A ED 72       2742  			SBC     HL,SP
040D5C 30 27       2743  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D5E E1          2744  			POP     HL
040D5F 22 1D 4D 04 2745  			LD      (FREE),HL
040D63 7A          2746  DIM2:			LD      A,D
040D64 B3          2747  			OR      E
040D65 28 06       2748  			JR      Z,DIM5
040D67 2B          2749  			DEC     HL
040D68 36 00       2750  			LD      (HL),0         		; Initialise the array
040D6A 1B          2751  			DEC     DE
040D6B 18 F6       2752  			JR      DIM2
040D6D CD 70 0A 04 2753  DIM5:			CALL    NXT
040D71 FE 2C       2754  			CP      ','            		; Another variable?
040D73 C2 96 0B 04 2755  			JP      NZ,XEQ
040D77 FD 23       2756  			INC     IY
040D79 CD 70 0A 04 2757  			CALL    NXT
040D7D C3 F1 0C 04 2758  			JP      DIM_EX
040D81             2759  ;
040D81             2760  ; DIM errors
040D81             2761  ;
040D81 3E 0A       2762  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D83 18 02       2763  			JR	ERROR1_EX
040D85 3E 0B       2764  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D87 C3 60 37 04 2765  ERROR1_EX:			JP      ERROR_
040D8B             2766  ;
040D8B             2767  ; At this point we're reserving a block of memory, i.e.
040D8B             2768  ; DIM var expr[,var expr...]
040D8B             2769  ;
040D8B B7          2770  DIM4:			OR      A			;  A: The dimension variable type
040D8C 28 F3       2771  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D8E FA 81 0D 04 2772  			JP      M,BADDIM        	; or a string
040D92 47          2773  			LD      B,A			; Temporarily store the dimension variable type in B
040D93 FD 7E FF    2774  			LD      A,(IY-1)		; Get the last character but one
040D96 FE 29       2775  			CP      ')'			; Check if it is a trailing bracket
040D98 28 E7       2776  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040D9A             2777  ;
040D9A 21 00 00 00 2778  			LD	HL,0			; Clear HL
040D9E 3A 1D 4D 04 2779  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DA2 6F          2780  			LD	L,A
040DA3 3A 1E 4D 04 2781  			LD	A,(FREE+1)
040DA7 67          2782  			LD	H,A
040DA8 78          2783  			LD	A,B			; Restore the dimension variable type
040DA9 D9          2784  			EXX
040DAA 21 00 00 00 2785  			LD	HL,0			; Clear HL
040DAE 47          2786  			LD	B,A			; Temporarily store the dimension variable type in B
040DAF 3A 1F 4D 04 2787  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DB3 6F          2788  			LD	L,A
040DB4 78          2789  			LD	A,B			; Restore the dimension variable type
040DB5 4C          2790  			LD	C,H
040DB6 CD D6 15 04 2791  			CALL    STORE           	; Store the address
040DBA CD 0A 03 04 2792  			CALL    EXPRI			; Get the number of bytes to store
040DBE D9          2793  			EXX
040DBF 23          2794  			INC     HL			; Add one to it
040DC0 EB          2795  			EX      DE,HL
040DC1 2A 1D 4D 04 2796  			LD      HL,(FREE)
040DC5 18 8C       2797  			JR      DIM3			; Continue with the DIM
040DC7             2798  
040DC7             2799  ; PRINT list...
040DC7             2800  ; PRINT #channel,list...
040DC7             2801  ;
040DC7 FE 23       2802  PRINT_:			CP      '#'
040DC9 20 7C       2803  			JR      NZ,PRINT0
040DCB CD 92 18 04 2804  			CALL    CHNL            ;CHANNEL NO. = E
040DCF CD 70 0A 04 2805  PRNTN1:			CALL    NXT
040DD3 FE 2C       2806  			CP      ','
040DD5 C2 96 0B 04 2807  			JP      NZ,XEQ
040DD9 FD 23       2808  			INC     IY
040DDB D5          2809  			PUSH    DE
040DDC CD C7 01 04 2810  			CALL    EXPR            ;ITEM TO PRINT
040DE0 08          2811  			EX      AF,AF'
040DE1 FA 07 0E 04 2812  			JP      M,PRNTN2        ;STRING
040DE5 D1          2813  			POP     DE
040DE6 C5          2814  			PUSH    BC
040DE7 D9          2815  			EXX
040DE8 7D          2816  			LD      A,L
040DE9 D9          2817  			EXX
040DEA CD 3B 43 04 2818  			CALL    OSBPUT
040DEE D9          2819  			EXX
040DEF 7C          2820  			LD      A,H
040DF0 D9          2821  			EXX
040DF1 CD 3B 43 04 2822  			CALL    OSBPUT
040DF5 7D          2823  			LD      A,L
040DF6 CD 3B 43 04 2824  			CALL    OSBPUT
040DFA 7C          2825  			LD      A,H
040DFB CD 3B 43 04 2826  			CALL    OSBPUT
040DFF C1          2827  			POP     BC
040E00 79          2828  			LD      A,C
040E01 CD 3B 43 04 2829  			CALL    OSBPUT
040E05 18 C8       2830  			JR      PRNTN1
040E07 4B          2831  PRNTN2:			LD      C,E
040E08 D1          2832  			POP     DE
040E09 21 00 4A 04 2833  			LD      HL,ACCS
040E0D 0C          2834  			INC     C
040E0E 0D          2835  PRNTN3:			DEC     C
040E0F 28 0A       2836  			JR      Z,PRNTN4
040E11 7E          2837  			LD      A,(HL)
040E12 23          2838  			INC     HL
040E13 C5          2839  			PUSH    BC
040E14 CD 3B 43 04 2840  			CALL    OSBPUT
040E18 C1          2841  			POP     BC
040E19 18 F3       2842  			JR      PRNTN3
040E1B 3E 0D       2843  PRNTN4:			LD      A,CR
040E1D CD 3B 43 04 2844  			CALL    OSBPUT
040E21 18 AC       2845  			JR      PRNTN1
040E23             2846  ;
040E23 06 02       2847  PRINT6:			LD      B,2
040E25 18 27       2848  			JR      PRINTC
040E27 01 00 01 00 2849  PRINT8:			LD      BC,100H
040E2B 18 21       2850  			JR      PRINTC
040E2D 21 00 4C 04 2851  PRINT9:			LD      HL,STAVAR
040E31 AF          2852  			XOR     A
040E32 BE          2853  			CP      (HL)
040E33 28 12       2854  			JR      Z,PRINT0
040E35 3A 3D 4D 04 2855  			LD      A,(COUNT)
040E39 B7          2856  			OR      A
040E3A 28 0B       2857  			JR      Z,PRINT0
040E3C 96          2858  PRINTA:			SUB     (HL)
040E3D 28 08       2859  			JR      Z,PRINT0
040E3F 30 FB       2860  			JR      NC,PRINTA
040E41 ED 44       2861  			NEG
040E43 CD EF 17 04 2862  			CALL    FILL
040E47 3A 00 4C 04 2863  PRINT0:			LD      A,(STAVAR)
040E4B 4F          2864  			LD      C,A             ;PRINTS
040E4C 06 00       2865  			LD      B,0             ;PRINTF
040E4E CD 7A 17 04 2866  PRINTC:			CALL    TERMQ
040E52 28 3F       2867  			JR      Z,PRINT4
040E54 CB 80       2868  			RES     0,B
040E56 FD 23       2869  			INC     IY
040E58 FE 7E       2870  			CP      '~'
040E5A 28 C7       2871  			JR      Z,PRINT6
040E5C FE 3B       2872  			CP      ';'
040E5E 28 C7       2873  			JR      Z,PRINT8
040E60 FE 2C       2874  			CP      ','
040E62 28 C9       2875  			JR      Z,PRINT9
040E64 CD 9F 17 04 2876  			CALL    FORMAT          ;SPC, TAB, '
040E68 28 E4       2877  			JR      Z,PRINTC
040E6A FD 2B       2878  			DEC     IY
040E6C C5          2879  			PUSH    BC
040E6D CD C7 01 04 2880  			CALL    EXPR            ;VARIABLE TYPE
040E71 08          2881  			EX      AF,AF'
040E72 FA 8C 0E 04 2882  			JP      M,PRINT3        ;STRING
040E76 D1          2883  			POP     DE
040E77 D5          2884  			PUSH    DE
040E78 CB 4A       2885  			BIT     1,D
040E7A F5          2886  			PUSH    AF
040E7B CC 66 09 04 2887  			CALL    Z,STR           ;DECIMAL
040E7F F1          2888  			POP     AF
040E80 C4 1A 09 04 2889  			CALL    NZ,HEXSTR       ;HEX
040E84 C1          2890  			POP     BC
040E85 C5          2891  			PUSH    BC
040E86 79          2892  			LD      A,C
040E87 93          2893  			SUB     E
040E88 D4 EF 17 04 2894  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E8C C1          2895  PRINT3:			POP     BC
040E8D CD FE 17 04 2896  			CALL    PTEXT           ;PRINT
040E91 18 BB       2897  			JR      PRINTC
040E93 CB 40       2898  PRINT4:			BIT     0,B
040E95 CC 47 39 04 2899  			CALL    Z,CRLF
040E99 C3 96 0B 04 2900  			JP      XEQ
040E9D             2901  
040E9D             2902  ; ON ERROR statement [:statement...]
040E9D             2903  ; ON ERROR OFF
040E9D             2904  ;
040E9D FD 23       2905  ONERR:			INC     IY              ;SKIP "ERROR"
040E9F 21 00 00 00 2906  			LD      HL,0
040EA3 22 2C 4D 04 2907  			LD      (ERRTRP),HL
040EA7 CD 70 0A 04 2908  			CALL    NXT
040EAB FE 87       2909  			CP      OFF_
040EAD FD 23       2910  			INC     IY
040EAF CA 96 0B 04 2911  			JP      Z,XEQ
040EB3 FD 2B       2912  			DEC     IY
040EB5 FD 22 2C 4D 2913  			LD      (ERRTRP),IY
       04          
040EBA C3 2B 0C 04 2914  			JP      REM_EX
040EBE             2915  
040EBE             2916  ; ON expr GOTO line[,line...] [ELSE statement]
040EBE             2917  ; ON expr GOTO line[,line...] [ELSE line]
040EBE             2918  ; ON expr GOSUB line[,line...] [ELSE statement]
040EBE             2919  ; ON expr GOSUB line[,line...] [ELSE line]
040EBE             2920  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EBE             2921  ;
040EBE FE 85       2922  ON_EX_:			CP      TERROR_EX
040EC0 28 DB       2923  			JR      Z,ONERR         ;"ON ERROR"
040EC2 CD 0A 03 04 2924  			CALL    EXPRI
040EC6 FD 7E 00    2925  			LD      A,(IY)
040EC9 FD 23       2926  			INC     IY
040ECB 1E 2C       2927  			LD      E,','           ;SEPARATOR
040ECD FE E5       2928  			CP      TGOTO
040ECF 28 0B       2929  			JR      Z,ON1
040ED1 FE E4       2930  			CP      TGOSUB
040ED3 28 07       2931  			JR      Z,ON1
040ED5 1E F2       2932  			LD      E,TPROC
040ED7 BB          2933  			CP      E
040ED8 3E 27       2934  			LD      A,39
040EDA 20 45       2935  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EDC 57          2936  ON1:			LD      D,A
040EDD D9          2937  			EXX
040EDE E5          2938  			PUSH    HL
040EDF D9          2939  			EXX
040EE0 C1          2940  			POP     BC              ;ON INDEX
040EE1 78          2941  			LD      A,B
040EE2 B4          2942  			OR      H
040EE3 B5          2943  			OR      L
040EE4 20 2A       2944  			JR      NZ,ON4          ;OUT OF RANGE
040EE6 B1          2945  			OR      C
040EE7 28 27       2946  			JR      Z,ON4
040EE9 0D          2947  			DEC     C
040EEA 28 0E       2948  			JR      Z,ON3           ;INDEX=1
040EEC CD 7A 17 04 2949  ON2:			CALL    TERMQ
040EF0 28 1E       2950  			JR      Z,ON4           ;OUT OF RANGE
040EF2 FD 23       2951  			INC     IY              ;SKIP DELIMITER
040EF4 BB          2952  			CP      E
040EF5 20 F5       2953  			JR      NZ,ON2
040EF7 0D          2954  			DEC     C
040EF8 20 F2       2955  			JR      NZ,ON2
040EFA 7B          2956  ON3:			LD      A,E
040EFB FE F2       2957  			CP      TPROC
040EFD 28 26       2958  			JR      Z,ONPROC
040EFF D5          2959  			PUSH    DE
040F00 CD 25 03 04 2960  			CALL    ITEMI           ;LINE NUMBER
040F04 D1          2961  			POP     DE
040F05 7A          2962  			LD      A,D
040F06 FE E5       2963  			CP      TGOTO
040F08 28 2D       2964  			JR      Z,GOTO2
040F0A CD 87 17 04 2965  			CALL    SPAN            ;SKIP REST OF LIST
040F0E 18 3B       2966  			JR      GOSUB1
040F10             2967  ;
040F10 FD 7E 00    2968  ON4:			LD      A,(IY)
040F13 FD 23       2969  			INC     IY
040F15 FE 8B       2970  			CP      ELSE_EX_
040F17 CA 4B 13 04 2971  			JP      Z,IF1           ;ELSE CLAUSE
040F1B FE 0D       2972  			CP      CR
040F1D 20 F1       2973  			JR      NZ,ON4
040F1F 3E 28       2974  			LD      A,40
040F21 C3 60 37 04 2975  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F25             2976  ;
040F25 3E EE       2977  ONPROC:			LD      A,TON
040F27 C3 84 10 04 2978  			JP      PROC_EX
040F2B             2979  
040F2B             2980  ; GOTO line
040F2B             2981  ;
040F2B CD 25 03 04 2982  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F2F CD 7A 17 04 2983  GOTO1:			CALL    TERMQ			; Check for terminator
040F33 C2 97 0C 04 2984  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F37 D9          2985  GOTO2:			EXX
040F38 CD 8F 39 04 2986  			CALL    FINDL			; HL: Line number - Find the line
040F3C E5          2987  			PUSH    HL			; HL: Address of the line
040F3D FD E1       2988  			POP     IY			; IY = HL
040F3F CA 92 0B 04 2989  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F43 3E 29       2990  			LD      A,41			; Otherwise throw a "No such line" error
040F45 18 DA       2991  			JR      ERROR2_EX
040F47             2992  
040F47             2993  ; GOSUB line
040F47             2994  ; This pushes the following data onto the execution stack
040F47             2995  ; - 3 bytes: Current execution address
040F47             2996  ; - 3 bytes: Marker (the address of label GOSCHK)
040F47             2997  ;
040F47 CD 25 03 04 2998  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F4B FD E5       2999  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F4D CD 4F 16 04 3000  			CALL    CHECK           	; Check there is enough room
040F51 CD 2F 0F 04 3001  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F55             3002  GOSCHK:			EQU     $
040F55             3003  
040F55             3004  ; RETURN
040F55             3005  ; This pops the following data off the execution stack as pushed by GOSUB
040F55             3006  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F55             3007  ; - 3 bytes: The return execution address
040F55             3008  ;
040F55 D1          3009  RETURN:			POP     DE			; Pop the marker off the execution stack
040F56 21 55 0F 04 3010  			LD      HL,GOSCHK		; Compare with GOSCHK
040F5A B7          3011  			OR      A
040F5B ED 52       3012  			SBC     HL,DE
040F5D FD E1       3013  			POP     IY			; Pop the return address off the execution stack
040F5F CA 96 0B 04 3014  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F63 3E 26       3015  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F65 18 BA       3016  			JR      ERROR2_EX
040F67             3017  
040F67             3018  ; REPEAT
040F67             3019  ; This pushes the following data onto the execution stack
040F67             3020  ; - 3 bytes: Current execution address
040F67             3021  ; - 3 bytes: Marker (the address of label REPCHK)
040F67             3022  ;
040F67 FD E5       3023  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F69 CD 4F 16 04 3024  			CALL    CHECK			; Check if there is enough room
040F6D CD 96 0B 04 3025  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F71             3026  REPCHK:			EQU     $
040F71             3027  
040F71             3028  ; UNTIL expr
040F71             3029  ; This pops the following data off the execution stack
040F71             3030  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F71             3031  ; - 3 bytes: The address of the REPEAT instruction
040F71             3032  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F71             3033  ;
040F71 C1          3034  UNTIL_EX:			POP     BC			; Fetch the marker
040F72 C5          3035  			PUSH    BC			; And push it back onto the execution stack
040F73 21 71 0F 04 3036  			LD      HL,REPCHK		; Compare with REPCHK
040F77 B7          3037  			OR      A
040F78 ED 42       3038  			SBC     HL,BC
040F7A 3E 2B       3039  			LD      A,43
040F7C 20 A3       3040  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F7E CD 0A 03 04 3041  			CALL    EXPRI			; Fetch the expression
040F82 CD DF 08 04 3042  			CALL    TEST			; Test if the expression evaluates to zero
040F86 C1          3043  			POP     BC			; Pop the marker
040F87 D1          3044  			POP     DE			; Pop the address of the REPEAT instruction
040F88 20 05       3045  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F8A D5          3046  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F8B C5          3047  			PUSH    BC			; Push the marker back on the stack
040F8C D5          3048  			PUSH    DE			; IY = DE
040F8D FD E1       3049  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F8F C3 96 0B 04 3050  XEQ2:			JP      XEQ			; Continue execution
040F93             3051  
040F93             3052  ; FOR var = expr TO expr [STEP expr]
040F93             3053  ; This pushes the following data onto the execution stack
040F93             3054  ; - 3 bytes: The limit value
040F93             3055  ; - 3 bytes: The step value
040F93             3056  ; - 3 bytes: The current execution address
040F93             3057  ; - 3 bytes: The address of the loop variable
040F93             3058  ; - 3 bytes: Marker (the address of FORCHK)
040F93             3059  ;
040F93 3E 22       3060  FORVAR:			LD      A,34
040F95 18 8A       3061  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F97             3062  ;
040F97 CD BE 15 04 3063  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040F9B 20 F6       3064  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040F9D F5          3065  			PUSH    AF              	; Save the variable type
040F9E FD 7E 00    3066  			LD      A,(IY)			; Check the next token
040FA1 FE B8       3067  			CP      TO_EX			; Compare with the token value for "TO"
040FA3 3E 24       3068  			LD      A,36			; Set the error code to 36 ("No TO")
040FA5 C2 21 0F 04 3069  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FA9 FD 23       3070  			INC     IY			; Skip to the next token
040FAB             3071  ;
040FAB DD E5       3072  			PUSH    IX
040FAD CD 02 03 04 3073  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB1 DD E1       3074  			POP     IX
040FB3 F1          3075  			POP     AF
040FB4 47          3076  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FB5 C5          3077  			PUSH    BC              	; Stack the LIMIT value
040FB6 E5          3078  			PUSH    HL
040FB7 21 00 00 00 3079  			LD      HL,0
040FBB 4C          3080  			LD      C,H
040FBC D9          3081  			EXX
040FBD E5          3082  			PUSH    HL
040FBE             3083  ;
040FBE 21 01 00 00 3084  			LD      HL,1            	; The preset STEP value is 1
040FC2 D9          3085  			EXX
040FC3 FD 7E 00    3086  			LD      A,(IY)			; Fetch the next token
040FC6 FE 88       3087  			CP      STEP			; Compare with the token value for "STEP"
040FC8 20 0A       3088  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FCA             3089  ;
040FCA FD 23       3090  			INC     IY			; Skip past the STEP token
040FCC DD E5       3091  			PUSH    IX
040FCE CD 02 03 04 3092  			CALL    EXPRN          		; Fetch the STEP expression value
040FD2 DD E1       3093  			POP     IX
040FD4             3094  ;
040FD4 C5          3095  FOR1:			PUSH    BC			; Stack the STEP value
040FD5 E5          3096  			PUSH    HL
040FD6 D9          3097  			EXX
040FD7 E5          3098  			PUSH    HL
040FD8 D9          3099  			EXX
040FD9             3100  ;
040FD9 FD E5       3101  			PUSH    IY              	; Stack the current execution address
040FDB DD E5       3102  			PUSH    IX              	; Stack the loop variable
040FDD CD 4F 16 04 3103  			CALL    CHECK
040FE1 CD 96 0B 04 3104  			CALL    XEQ
040FE5             3105  FORCHK:			EQU     $
040FE5             3106  
040FE5             3107  ; NEXT [var[,var...]]
040FE5             3108  ; This pops the following data off the execution stack
040FE5             3109  ; - 3 bytes: Marker (the address of FORCHK)
040FE5             3110  ; - 3 bytes: The address of the loop variable
040FE5             3111  ; - 3 bytes: The current execution address
040FE5             3112  ; - 3 bytes: The step value
040FE5             3113  ; - 3 bytes: The limit value
040FE5             3114  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FE5             3115  ;
040FE5 C1          3116  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FE6 21 E5 0F 04 3117  			LD      HL,FORCHK		; Compare with FORCHK
040FEA B7          3118  			OR      A
040FEB ED 42       3119  			SBC     HL,BC
040FED 3E 20       3120  			LD      A,32
040FEF C2 7B 10 04 3121  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FF3 CD 7A 17 04 3122  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FF7 E1          3123  			POP     HL			; Pop the address of the loop variable off the execution stack
040FF8 E5          3124  			PUSH    HL			; Push it back onto the execution stack
040FF9 C5          3125  			PUSH    BC			; Push the marker back onto the execution stack
040FFA E5          3126  			PUSH    HL			; HL: Address of the loop variable off the stack
040FFB C4 3A 3A 04 3127  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040FFF D1          3128  			POP     DE			; DE: Address of the loop variable off the stack
041000 EB          3129  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041001 B7          3130  			OR      A
041002 ED 52       3131  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041004 20 61       3132  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041006 D5          3133  			PUSH    DE
041007 DD 21 0C 00 3134  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
04100C DD 39       3135  			ADD     IX,SP
04100E CD E1 29 04 3136  			CALL    DLOAD5_SPL      	; Load the STEP value
041012 DD 7E 10    3137  			LD      A,(IX+16)       	; Get the STEP type
041015 DD E1       3138  			POP     IX
041017 CD 16 04 04 3139  			CALL    LOADN           	; Load the LOOP variable
04101B CB 7A       3140  			BIT     7,D             	; Check the sign
04101D F5          3141  			PUSH    AF
04101E 3E 0B       3142  			LD      A,'+' & 0FH
041020 CD 6A 20 04 3143  			CALL    FPP             	; Add the STEP
041024 38 55       3144  			JR      C,ERROR3_EX
041026 F1          3145  			POP     AF              	; Restore TYPE
041027 F5          3146  			PUSH    AF
041028 CD D6 15 04 3147  			CALL    STORE           	; Update the variable
04102C DD 21 15 00 3148  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041031 DD 39       3149  			ADD     IX,SP
041033 CD E1 29 04 3150  			CALL    DLOAD5_SPL      	; Load the LIMIT value
041037 F1          3151  			POP     AF
041038 CC D7 08 04 3152  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
04103C             3153  			; LD      A,0+('<'-4) & 0FH
04103C 3E 08       3154  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04103E CD 6A 20 04 3155  			CALL    FPP             	; Test against the limit
041042 38 37       3156  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041044 24          3157  			INC     H
041045 20 14       3158  			JR      NZ,LOOP_        	; Keep looping
041047 21 1B 00 00 3159  			LD      HL,27			; Adjust the stack
04104B 39          3160  			ADD     HL,SP
04104C F9          3161  			LD      SP,HL
04104D CD 70 0A 04 3162  			CALL    NXT
041051 FE 2C       3163  			CP      ','			; Check for multiple variables
041053 C2 96 0B 04 3164  			JP      NZ,XEQ			; No, so we are done at ths point
041057 FD 23       3165  			INC     IY			; Increment to the next variable
041059 18 8A       3166  			JR      NEXT_EX			; And continue
04105B             3167  ;
04105B C1          3168  LOOP_:			POP     BC
04105C D1          3169  			POP     DE
04105D FD E1       3170  			POP     IY
04105F FD E5       3171  			PUSH    IY
041061 D5          3172  			PUSH    DE
041062 C5          3173  			PUSH    BC
041063 C3 96 0B 04 3174  			JP      XEQ
041067             3175  ;
041067 21 1B 00 00 3176  NEXT1:			LD      HL,27			; TODO: What does this do?
04106B 39          3177  			ADD     HL,SP
04106C F9          3178  			LD      SP,HL			; Adjust the stack
04106D C1          3179  			POP     BC
04106E 21 E5 0F 04 3180  			LD      HL,FORCHK
041072 ED 42       3181  			SBC     HL,BC
041074 E1          3182  			POP     HL              	; Variable pointer
041075 E5          3183  			PUSH    HL
041076 C5          3184  			PUSH    BC
041077 28 89       3185  			JR      Z,NEXT0
041079             3186  ;
041079 3E 21       3187  			LD      A,33
04107B C3 60 37 04 3188  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
04107F             3189  
04107F             3190  ; FNname
04107F             3191  ; N.B. ENTERED WITH A <> TON
04107F             3192  ;
04107F F5          3193  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041080 CD 89 10 04 3194  			CALL    PROC1
041084             3195  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041084             3196  
041084             3197  ; PROCname
041084             3198  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
041084             3199  ; This pushes the following data onto the execution stack
041084             3200  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
041084             3201  ; - 3 bytes: Marker (the address of PROCHK)
041084             3202  ;
041084 F5          3203  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041085 CD 89 10 04 3204  			CALL    PROC1			; and is also space reserved on the stack for the return address
041089             3205  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041089             3206  ;
041089 CD 4F 16 04 3207  PROC1:			CALL    CHECK			; Check there is space for this
04108D FD 2B       3208  			DEC     IY			; Decrement IY to the PROC token
04108F FD E5       3209  			PUSH    IY			; Stack the pointer
041091 CD FB 3A 04 3210  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041095 C1          3211  			POP     BC			; BC = IY
041096 28 41       3212  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041098 3E 1E       3213  			LD      A,30
04109A 38 DF       3214  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
04109C             3215  ;
04109C             3216  ; At this point the PROC/FN has not yet been registered in the dynamic area
04109C             3217  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
04109C             3218  ;
04109C C5          3219  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
04109D 2A 14 4D 04 3220  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A1             3221  ;
0410A1 3E DD       3222  PROC2:			LD      A,DEF_			;  A: The token to search for
0410A3 CD 4E 18 04 3223  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410A7 38 26       3224  			JR      C,PROC3			; Not found, so jump to PROC3
0410A9 E5          3225  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410AA FD E1       3226  			POP     IY			; IY = HL
0410AC FD 23       3227  			INC     IY              	; Skip the DEF token
0410AE CD 70 0A 04 3228  			CALL    NXT			; And any whitespace
0410B2 CD FB 3A 04 3229  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410B6 FD E5       3230  			PUSH    IY
0410B8 D1          3231  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410B9 38 09       3232  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410BB C4 AE 3B 04 3233  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410BF FD E5       3234  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C1 D1          3235  			POP     DE			; DE = IY
0410C2 ED 1F       3236  			LD	(HL),DE			; Save address
0410C4             3237  ;
0410C4 EB          3238  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410C5 3E 0D       3239  			LD      A,CR			; The character to search for
0410C7 01 00 01 00 3240  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410CB ED B1       3241  			CPIR                    	; Skip to next line
0410CD 18 D2       3242  			JR      PROC2			; Rinse, lather and repeat
0410CF             3243  ;
0410CF             3244  ; At this point a DEF has not been found for the PROC/FN
0410CF             3245  ;
0410CF FD E1       3246  PROC3:			POP     IY              	; Restore the execution address
0410D1 CD FB 3A 04 3247  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410D5 3E 1D       3248  			LD      A,29
0410D7 20 A2       3249  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410D9             3250  ;
0410D9             3251  ; At this point we have a PROC/FN entry in the dynamic area
0410D9             3252  ;
0410D9 ED 17       3253  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410DB 21 03 00 00 3254  			LD	HL,3
0410DF 39          3255  			ADD     HL,SP
0410E0 CD 70 0A 04 3256  			CALL    NXT             	; Allow space before "("
0410E4 D5          3257  			PUSH    DE              	; Exchange DE and IY
0410E5 FD E3       3258  			EX      (SP),IY
0410E7 FE 28       3259  			CP      '('             	; Arguments?
0410E9 D1          3260  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410EA 20 20       3261  			JR      NZ,PROC5
0410EC CD 70 0A 04 3262  			CALL    NXT             	; Allow space before "("
0410F0 FE 28       3263  			CP      '('
0410F2 C2 97 0C 04 3264  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410F6 FD E5       3265  			PUSH    IY
0410F8 C1          3266  			POP     BC              	; Save IY in BC
0410F9 D9          3267  			EXX
0410FA CD FA 16 04 3268  			CALL    SAVLOC          	; Save local parameters
0410FE CD 2F 0A 04 3269  			CALL    BRAKET          	; Closing bracket
041102 D9          3270  			EXX
041103 C5          3271  			PUSH    BC
041104 FD E1       3272  			POP     IY              	; Restore IY
041106 E5          3273  			PUSH    HL
041107 CD 76 16 04 3274  			CALL    ARGUE           	; Transfer arguments
04110B E1          3275  			POP     HL
04110C             3276  ;
04110C 23          3277  PROC5:			INC	HL			; Increment to the ON PROC flag address
04110D 7E          3278  			LD	A, (HL)			; And fetch the value
04110E 2B          3279  			DEC 	HL
04110F ED 1F       3280  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041111 FE EE       3281  			CP	TON			; Was it "ON PROC"?
041113 C2 96 0B 04 3282  			JP	NZ, XEQ			; No, so back to XEQ
041117 D5          3283  			PUSH    DE			; Exchange DE and IY
041118 FD E3       3284  			EX      (SP),IY
04111A CD 87 17 04 3285  			CALL    SPAN            	; Skip rest of ON list
04111E FD E3       3286  			EX      (SP),IY			; Exchange DE and IY
041120 D1          3287  			POP     DE
041121 ED 1F       3288  			LD	(HL), DE		; Save the return address
041123 C3 96 0B 04 3289  			JP      XEQ
041127             3290  
041127             3291  ; LOCAL var[,var...]
041127             3292  ;
041127 C1          3293  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041128 C5          3294  			PUSH    BC
041129 21 84 10 04 3295  			LD      HL,FNCHK		; Check if we are in a FN
04112D B7          3296  			OR      A
04112E ED 42       3297  			SBC     HL,BC
041130 28 16       3298  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041132 21 89 10 04 3299  			LD      HL,PROCHK		; Now check if we are in a PROC
041136 B7          3300  			OR      A
041137 ED 42       3301  			SBC     HL,BC
041139 28 0D       3302  			JR      Z,LOCAL1		; Again, all good, we can use local
04113B 21 58 17 04 3303  			LD      HL,LOCCHK		; Finally check for the local parameters marker
04113F B7          3304  			OR      A
041140 ED 42       3305  			SBC     HL,BC			; If it is not present, then
041142 3E 0C       3306  			LD      A,12
041144 C2 60 37 04 3307  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041148             3308  ;
041148             3309  ; At this point we are adding a local variable into a PROC or FN
041148             3310  ;
041148 FD E5       3311  LOCAL1:			PUSH    IY			; IY: BASIC pointer
04114A C1          3312  			POP     BC			; BC: Copy of the BASIC pointer
04114B D9          3313  			EXX
04114C FD 2B       3314  			DEC     IY
04114E CD FA 16 04 3315  			CALL    SAVLOC
041152 D9          3316  			EXX
041153 C5          3317  			PUSH    BC
041154 FD E1       3318  			POP     IY
041156             3319  ;
041156 CD 3A 3A 04 3320  LOCAL2:			CALL    GETVAR			; Get the variable location
04115A C2 97 0C 04 3321  			JP      NZ,SYNTAX
04115E B7          3322  			OR      A               	; Check the variable type (80h = string)
04115F 08          3323  			EX      AF,AF'
041160 CD 93 09 04 3324  			CALL    ZERO			; Zero the variable anyway
041164 08          3325  			EX      AF,AF'
041165 F5          3326  			PUSH    AF
041166 F4 D6 15 04 3327  			CALL    P,STORE         	; Call STORE if it is not a string
04116A F1          3328  			POP     AF
04116B 59          3329  			LD      E,C
04116C FC 04 16 04 3330  			CALL    M,STORES		; Call STORES if it is a string
041170 CD 70 0A 04 3331  			CALL    NXT			; Skip to the next character in the expression
041174 FE 2C       3332  			CP      ','			; Is it a comma?
041176 C2 96 0B 04 3333  			JP      NZ,XEQ			; No, so we're done, carry on executing
04117A FD 23       3334  			INC     IY			; Yes, so skip the comma
04117C CD 70 0A 04 3335  			CALL    NXT			; And any whitespace
041180 18 D4       3336  			JR      LOCAL2			; Then loop back and handle any further local variables
041182             3337  
041182             3338  ; ENDPROC
041182             3339  ;
041182 C1          3340  ENDPRO:			POP     BC			; Pop the check value off the stack
041183 21 58 17 04 3341  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041187 B7          3342  			OR      A
041188 ED 42       3343  			SBC     HL,BC
04118A 28 13       3344  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
04118C             3345  ;
04118C 21 89 10 04 3346  			LD      HL,PROCHK       	; Check if it is the PROC marker
041190 B7          3347  			OR      A
041191 ED 42       3348  			SBC     HL,BC
041193 FD E1       3349  			POP     IY
041195 CA 96 0B 04 3350  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
041199 3E 0D       3351  			LD      A,13			; Otherwise throw the "No PROC" error
04119B C3 60 37 04 3352  			JP      ERROR_
04119F             3353  ;
04119F DD E1       3354  UNSTK:			POP     IX			; Unstack a single local variable
0411A1 C1          3355  			POP     BC
0411A2 78          3356  			LD      A,B
0411A3 B7          3357  			OR      A
0411A4 FA B2 11 04 3358  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411A8 E1          3359  			POP     HL			; Unstack a normal variable
0411A9 D9          3360  			EXX
0411AA E1          3361  			POP     HL
0411AB D9          3362  			EXX
0411AC CD D6 15 04 3363  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B0 18 D0       3364  			JR      ENDPRO			; And loop back to ENDPRO
0411B2             3365  ;
0411B2 21 00 00 00 3366  UNSTK1:			LD      HL,0			; Unstack a string
0411B6 39          3367  			ADD     HL,SP
0411B7 59          3368  			LD      E,C
0411B8 CD 04 16 04 3369  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411BC F9          3370  			LD      SP,HL
0411BD 18 C3       3371  			JR      ENDPRO
0411BF             3372  
0411BF             3373  ; INPUT #channel,var,var...
0411BF             3374  ;
0411BF CD 92 18 04 3375  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411C3 CD 70 0A 04 3376  INPN1:			CALL    NXT
0411C7 FE 2C       3377  			CP      ','
0411C9 C2 96 0B 04 3378  			JP      NZ,XEQ
0411CD FD 23       3379  			INC     IY
0411CF CD 70 0A 04 3380  			CALL    NXT
0411D3 D5          3381  			PUSH    DE
0411D4 CD 8E 0C 04 3382  			CALL    VAR_
0411D8 D1          3383  			POP     DE
0411D9 F5          3384  			PUSH    AF              ;SAVE TYPE
0411DA E5          3385  			PUSH    HL              ;VARPTR
0411DB B7          3386  			OR      A
0411DC FA 08 12 04 3387  			JP      M,INPN2         ;STRING
0411E0 CD 33 43 04 3388  			CALL    OSBGET
0411E4 D9          3389  			EXX
0411E5 6F          3390  			LD      L,A
0411E6 D9          3391  			EXX
0411E7 CD 33 43 04 3392  			CALL    OSBGET
0411EB D9          3393  			EXX
0411EC 67          3394  			LD      H,A
0411ED D9          3395  			EXX
0411EE CD 33 43 04 3396  			CALL    OSBGET
0411F2 6F          3397  			LD      L,A
0411F3 CD 33 43 04 3398  			CALL    OSBGET
0411F7 67          3399  			LD      H,A
0411F8 CD 33 43 04 3400  			CALL    OSBGET
0411FC 4F          3401  			LD      C,A
0411FD DD E1       3402  			POP     IX
0411FF F1          3403  			POP     AF              ;RESTORE TYPE
041200 D5          3404  			PUSH    DE              ;SAVE CHANNEL
041201 CD D6 15 04 3405  			CALL    STORE
041205 D1          3406  			POP     DE
041206 18 BB       3407  			JR      INPN1
041208 21 00 4A 04 3408  INPN2:			LD      HL,ACCS
04120C CD 33 43 04 3409  INPN3:			CALL    OSBGET
041210 FE 0D       3410  			CP      CR
041212 28 04       3411  			JR      Z,INPN4
041214 77          3412  			LD      (HL),A
041215 2C          3413  			INC     L
041216 20 F4       3414  			JR      NZ,INPN3
041218 DD E1       3415  INPN4:			POP     IX
04121A F1          3416  			POP     AF
04121B D5          3417  			PUSH    DE
04121C EB          3418  			EX      DE,HL
04121D CD 00 16 04 3419  			CALL    STACCS
041221 D1          3420  			POP     DE
041222 18 9F       3421  			JR      INPN1
041224             3422  
041224             3423  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3424  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041224             3425  ;
041224 FE 23       3426  INPUT:			CP      '#'
041226 28 97       3427  			JR      Z,INPUTN
041228 0E 00       3428  			LD      C,0             ;FLAG PROMPT
04122A FE 86       3429  			CP      LINE_EX_
04122C 20 04       3430  			JR      NZ,INPUT0
04122E FD 23       3431  			INC     IY              ;SKIP "LINE"
041230 0E 80       3432  			LD      C,80H
041232 21 00 4B 04 3433  INPUT0:			LD      HL,BUFFER
041236 36 0D       3434  			LD      (HL),CR         ;INITIALISE EMPTY
041238 CD 7A 17 04 3435  INPUT1:			CALL    TERMQ
04123C CA 96 0B 04 3436  			JP      Z,XEQ           ;DONE
041240 FD 23       3437  			INC     IY
041242 FE 2C       3438  			CP      ','
041244 28 5C       3439  			JR      Z,INPUT3        ;SKIP COMMA
041246 FE 3B       3440  			CP      ';'
041248 28 58       3441  			JR      Z,INPUT3
04124A E5          3442  			PUSH    HL              ;SAVE BUFFER POINTER
04124B FE 22       3443  			CP      34		;ASCII ""
04124D 20 0C       3444  			JR      NZ,INPUT6
04124F C5          3445  			PUSH    BC
041250 CD 67 04 04 3446  			CALL    CONS
041254 C1          3447  			POP     BC
041255 CD FE 17 04 3448  			CALL    PTEXT           ;PRINT PROMPT
041259 18 06       3449  			JR      INPUT9
04125B CD 9F 17 04 3450  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
04125F 20 05       3451  			JR      NZ,INPUT2
041261 E1          3452  INPUT9:			POP     HL
041262 CB C1       3453  			SET     0,C             ;FLAG NO PROMPT
041264 18 CC       3454  			JR      INPUT0
041266 FD 2B       3455  INPUT2:			DEC     IY
041268 C5          3456  			PUSH    BC
041269 CD 8E 0C 04 3457  			CALL    VAR_
04126D C1          3458  			POP     BC
04126E E1          3459  			POP     HL
04126F F5          3460  			PUSH    AF              ;SAVE TYPE
041270 7E          3461  			LD      A,(HL)
041271 23          3462  			INC     HL
041272 FE 0D       3463  			CP      CR              ;BUFFER EMPTY?
041274 CC A6 12 04 3464  			CALL    Z,REFILL
041278 CB 79       3465  			BIT     7,C
04127A F5          3466  			PUSH    AF
04127B C4 20 18 04 3467  			CALL    NZ,LINES
04127F F1          3468  			POP     AF
041280 CC 0D 18 04 3469  			CALL    Z,FETCHS
041284 F1          3470  			POP     AF              ;RESTORE TYPE
041285 C5          3471  			PUSH    BC
041286 E5          3472  			PUSH    HL
041287 B7          3473  			OR      A
041288 FA 9C 12 04 3474  			JP      M,INPUT4        ;STRING
04128C F5          3475  			PUSH    AF
04128D DD E5       3476  			PUSH    IX
04128F CD 6E 06 04 3477  			CALL    VAL0
041293 DD E1       3478  			POP     IX
041295 F1          3479  			POP     AF
041296 CD D6 15 04 3480  			CALL    STORE
04129A 18 04       3481  			JR      INPUT5
04129C CD 00 16 04 3482  INPUT4:			CALL    STACCS
0412A0 E1          3483  INPUT5:			POP     HL
0412A1 C1          3484  			POP     BC
0412A2 CB 81       3485  INPUT3:			RES     0,C
0412A4 18 92       3486  			JR      INPUT1
0412A6             3487  ;
0412A6 CB 41       3488  REFILL:			BIT     0,C
0412A8 20 0C       3489  			JR      NZ,REFIL0       ;NO PROMPT
0412AA 3E 3F       3490  			LD      A,'?'
0412AC CD 4F 39 04 3491  			CALL    OUTCHR          ;PROMPT
0412B0 3E 20       3492  			LD      A,' '
0412B2 CD 4F 39 04 3493  			CALL    OUTCHR
0412B6 21 00 4B 04 3494  REFIL0:			LD      HL,BUFFER
0412BA C5          3495  			PUSH    BC
0412BB E5          3496  			PUSH    HL
0412BC DD E5       3497  			PUSH    IX
0412BE CD 5F 3E 04 3498  			CALL    OSLINE
0412C2 DD E1       3499  			POP     IX
0412C4 E1          3500  			POP     HL
0412C5 C1          3501  			POP     BC
0412C6 47          3502  			LD      B,A             ;POS AT ENTRY
0412C7 AF          3503  			XOR     A
0412C8 32 3D 4D 04 3504  			LD      (COUNT),A
0412CC B8          3505  			CP      B
0412CD C8          3506  			RET     Z
0412CE 7E          3507  REFIL1:			LD      A,(HL)
0412CF FE 0D       3508  			CP      CR
0412D1 C8          3509  			RET     Z
0412D2 23          3510  			INC     HL
0412D3 10 F9       3511  			DJNZ    REFIL1
0412D5 C9          3512  			RET
0412D6             3513  
0412D6             3514  ; READ var[,var...]
0412D6             3515  ;
0412D6 FE 23       3516  READ:			CP      '#'
0412D8 CA BF 11 04 3517  			JP      Z,INPUTN
0412DC 2A 31 4D 04 3518  			LD      HL,(DATPTR)
0412E0 7E          3519  READ0:			LD      A,(HL)
0412E1 23          3520  			INC     HL              ;SKIP COMMA OR "DATA"
0412E2 FE 0D       3521  			CP      CR              ;END OF DATA STMT?
0412E4 CC 28 13 04 3522  			CALL    Z,GETDAT
0412E8 E5          3523  			PUSH    HL
0412E9 CD 8E 0C 04 3524  			CALL    VAR_
0412ED E1          3525  			POP     HL
0412EE B7          3526  			OR      A
0412EF FA 08 13 04 3527  			JP      M,READ1         ;STRING
0412F3 E5          3528  			PUSH    HL
0412F4 FD E3       3529  			EX      (SP),IY
0412F6 F5          3530  			PUSH    AF              ;SAVE TYPE
0412F7 DD E5       3531  			PUSH    IX
0412F9 CD 02 03 04 3532  			CALL    EXPRN
0412FD DD E1       3533  			POP     IX
0412FF F1          3534  			POP     AF
041300 CD D6 15 04 3535  			CALL    STORE
041304 FD E3       3536  			EX      (SP),IY
041306 18 09       3537  			JR      READ2
041308 CD 0D 18 04 3538  READ1:			CALL    FETCHS
04130C E5          3539  			PUSH    HL
04130D CD 00 16 04 3540  			CALL    STACCS
041311 E1          3541  READ2:			POP     HL
041312 22 31 4D 04 3542  			LD      (DATPTR),HL
041316 CD 70 0A 04 3543  			CALL    NXT
04131A FE 2C       3544  			CP      ','
04131C C2 96 0B 04 3545  			JP      NZ,XEQ
041320 FD 23       3546  			INC     IY
041322 CD 70 0A 04 3547  			CALL    NXT
041326 18 B8       3548  			JR      READ0
041328             3549  ;
041328 3E DC       3550  GETDAT:			LD      A,DATA_EX_
04132A CD 4E 18 04 3551  			CALL    SEARCH_EX
04132E 23          3552  			INC     HL
04132F D0          3553  			RET     NC
041330 3E 2A       3554  			LD      A,42
041332 C3 60 37 04 3555  ERROR4:			JP      ERROR_           ;"Out of DATA"
041336             3556  
041336             3557  ; IF expr statement
041336             3558  ; IF expr THEN statement [ELSE statement]
041336             3559  ; IF expr THEN line [ELSE line]
041336             3560  ;
041336 CD 0A 03 04 3561  IF_:			CALL    EXPRI
04133A CD DF 08 04 3562  			CALL    TEST
04133E 28 19       3563  			JR      Z,IFNOT         ;FALSE
041340 FD 7E 00    3564  			LD      A,(IY)
041343 FE 8C       3565  			CP      THEN_EX_
041345 C2 96 0B 04 3566  			JP      NZ,XEQ
041349 FD 23       3567  			INC     IY              ;SKIP "THEN"
04134B CD 70 0A 04 3568  IF1:			CALL    NXT
04134F FE 8D       3569  			CP      LINO_EX
041351 C2 96 0B 04 3570  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
041355 C3 2B 0F 04 3571  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041359 FD 7E 00    3572  IFNOT:			LD      A,(IY)
04135C FE 0D       3573  			CP      CR
04135E FD 23       3574  			INC     IY
041360 CA 92 0B 04 3575  			JP      Z,XEQ0          ;END OF LINE
041364 FE 8B       3576  			CP      ELSE_EX_
041366 20 F1       3577  			JR      NZ,IFNOT
041368 18 E1       3578  			JR      IF1
04136A             3579  
04136A             3580  ; CLS
04136A             3581  ;
04136A CD CC 43 04 3582  CLS:		CALL    CLRSCN
04136E AF          3583  			XOR     A
04136F 32 3D 4D 04 3584  			LD      (COUNT),A
041373 C3 96 0B 04 3585  			JP      XEQ
041377             3586  
041377             3587  ; STOP
041377             3588  ;
041377 CD 90 3D 04 3589  STOP:			CALL    TELL
04137B 0D          3590  			DB	CR
04137C 0A          3591  			DB	LF
04137D FA          3592  			DB	TSTOP
04137E 00          3593  			DB	0
04137F CD AE 39 04 3594  			CALL    SETLIN          ;FIND CURRENT LINE
041383 CD E2 39 04 3595  			CALL    SAYLN
041387 CD 47 39 04 3596  			CALL    CRLF
04138B C3 80 30 04 3597  			JP      CLOOP
04138F             3598  
04138F             3599  ; REPORT
04138F             3600  ;
04138F CD 82 3D 04 3601  REPOR:			CALL    REPORT
041393 C3 96 0B 04 3602  			JP      XEQ
041397             3603  
041397             3604  ; CLEAR
041397             3605  ;
041397 CD 76 38 04 3606  CLR:			CALL    CLEAR
04139B 2A 14 4D 04 3607  			LD      HL,(PAGE_)
04139F 18 19       3608  			JR      RESTR1
0413A1             3609  
0413A1             3610  ; RESTORE [line]
0413A1             3611  ;
0413A1 2A 14 4D 04 3612  RESTOR_EX:			LD      HL,(PAGE_)
0413A5 CD 7A 17 04 3613  			CALL    TERMQ
0413A9 28 0F       3614  			JR      Z,RESTR1
0413AB CD 25 03 04 3615  			CALL    ITEMI
0413AF D9          3616  			EXX
0413B0 CD 8F 39 04 3617  			CALL    FINDL           ;SEARCH FOR LINE
0413B4 3E 29       3618  			LD      A,41
0413B6 C2 32 13 04 3619  			JP      NZ,ERROR4       ;"No such line"
0413BA 3E DC       3620  RESTR1:			LD      A,DATA_EX_
0413BC CD 4E 18 04 3621  			CALL    SEARCH_EX
0413C0 22 31 4D 04 3622  			LD      (DATPTR),HL
0413C4 C3 96 0B 04 3623  			JP      XEQ
0413C8             3624  
0413C8             3625  ; PTR#channel=expr
0413C8             3626  ; PAGE=expr
0413C8             3627  ; TIME=expr
0413C8             3628  ; LOMEM=expr
0413C8             3629  ; HIMEM=expr
0413C8             3630  ;
0413C8 CD 86 18 04 3631  PTR_EX:			CALL    CHANEL
0413CC CD 90 17 04 3632  			CALL    EQUALS
0413D0 7B          3633  			LD      A,E
0413D1 F5          3634  			PUSH    AF
0413D2 CD 0A 03 04 3635  			CALL    EXPRI
0413D6 E5          3636  			PUSH    HL
0413D7 D9          3637  			EXX
0413D8 D1          3638  			POP     DE
0413D9 F1          3639  			POP     AF
0413DA CD 67 43 04 3640  			CALL    PUTPTR
0413DE C3 96 0B 04 3641  			JP      XEQ
0413E2             3642  ;
0413E2 CD 90 17 04 3643  PAGEV_EX:			CALL    EQUALS
0413E6 CD 0A 03 04 3644  			CALL    EXPRI
0413EA D9          3645  			EXX
0413EB 2E 00       3646  			LD      L,0
0413ED 22 14 4D 04 3647  			LD      (PAGE_),HL
0413F1 C3 96 0B 04 3648  			JP      XEQ
0413F5             3649  ;
0413F5 FE 24       3650  TIMEV_EX:			CP      '$'
0413F7 28 13       3651  			JR      Z,TIMEVS_EX
0413F9 CD 90 17 04 3652  			CALL    EQUALS
0413FD CD 0A 03 04 3653  			CALL    EXPRI
041401 E5          3654  			PUSH    HL
041402 D9          3655  			EXX
041403 D1          3656  			POP     DE
041404 CD 97 3E 04 3657  			CALL    PUTIME
041408 C3 96 0B 04 3658  			JP      XEQ
04140C             3659  ;
04140C FD 23       3660  TIMEVS_EX:			INC     IY              ;SKIP '$'
04140E CD 90 17 04 3661  			CALL    EQUALS
041412 CD 15 03 04 3662  			CALL    EXPRS
041416 CD B7 43 04 3663  			CALL    PUTIMS
04141A C3 96 0B 04 3664  			JP      XEQ
04141E             3665  ;
04141E CD 90 17 04 3666  LOMEMV_EX:			CALL    EQUALS
041422 CD 0A 03 04 3667  			CALL    EXPRI
041426 CD 76 38 04 3668  			CALL    CLEAR
04142A D9          3669  			EXX
04142B 22 1A 4D 04 3670  			LD      (LOMEM),HL
04142F 22 1D 4D 04 3671  			LD      (FREE),HL
041433 C3 96 0B 04 3672  			JP      XEQ
041437             3673  ;
041437 CD 90 17 04 3674  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
04143B CD 0A 03 04 3675  			CALL    EXPRI			; Load the expression into registers
04143F             3676  ; BEGIN MISSING FROM BINARY
04143F             3677  			; LD	A,L			;  A: The MSB of the 24-bit value
04143F             3678  			; EXX				; HL: The LSW of the 24-bit value
04143F             3679  			; LD	(R0),HL
04143F             3680  			; LD	(R0+2),A
04143F             3681  			; LD	HL,(FREE)
04143F             3682  			; LD      DE,256
04143F             3683  			; ADD	HL,DE
04143F             3684  			; EX	DE,HL			; DE: FREE + 256
04143F             3685  			; LD	HL,(R0)			; HL: The passed expression
04143F             3686  ; END MISSING FROM BINARY
04143F             3687  ; BEGIN ADDED FROM BINARY
04143F D9          3688  			exx
041440 ED 5B 1D 4D 3689  			ld de,(FREE)
       04          
041445 14          3690  			inc d
041446             3691  ; END ADDED FROM BINARY
041446 AF          3692  			XOR     A
041447 ED 52       3693  			SBC     HL,DE
041449 19          3694  			ADD     HL,DE			; Do a bounds check
04144A DA 60 37 04 3695  			JP      C,ERROR_         	; Throw the error: "No room"
04144E ED 5B 20 4D 3696  			LD      DE,(HIMEM)
       04          
041453 22 20 4D 04 3697  			LD      (HIMEM),HL
041457 EB          3698  			EX      DE,HL
041458 ED 72       3699  			SBC     HL,SP			; Adjust the stack
04145A C2 96 0B 04 3700  			JP      NZ,XEQ
04145E EB          3701  			EX      DE,HL
04145F F9          3702  			LD      SP,HL           	; Load the SP
041460 C3 96 0B 04 3703  			JP      XEQ
041464             3704  
041464             3705  ; WIDTH expr
041464             3706  ;
041464 CD 0A 03 04 3707  WIDTHV:			CALL    EXPRI
041468 D9          3708  			EXX
041469 7D          3709  			LD      A,L
04146A 32 3E 4D 04 3710  			LD      (WIDTH),A
04146E C3 96 0B 04 3711  			JP      XEQ
041472             3712  
041472             3713  ; TRACE ON
041472             3714  ; TRACE OFF
041472             3715  ; TRACE line
041472             3716  ;
041472 FD 23       3717  TRACE_EX:			INC     IY
041474 21 00 00 00 3718  			LD      HL,0
041478 FE EE       3719  			CP      TON
04147A 28 0B       3720  			JR      Z,TRACE0
04147C FE 87       3721  			CP      OFF_
04147E 28 08       3722  			JR      Z,TRACE1
041480 FD 2B       3723  			DEC     IY
041482 CD 0A 03 04 3724  			CALL    EXPRI
041486 D9          3725  			EXX
041487 2B          3726  TRACE0:			DEC     HL
041488 22 26 4D 04 3727  TRACE1:			LD      (TRACEN),HL
04148C C3 96 0B 04 3728  			JP      XEQ
041490             3729  
041490             3730  ; VDU expr,expr;....
041490             3731  ;
041490             3732  ; BEGIN MISSING FROM BINARY
041490             3733  ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
041490             3734  ; VDU1:			PUSH	IX
041490             3735  ; 			CALL    EXPRI			; Fetch the VDU character
041490             3736  ; 			POP	IX
041490             3737  ; 			EXX
041490             3738  ; 			LD	(IX+0),L		; Write out the character to the buffer
041490             3739  ; 			INC	IX
041490             3740  ; 			LD      A,(IY)			;  A: The separator character
041490             3741  ; 			CP      ','			; Is it a comma?
041490             3742  ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
041490             3743  ; 			CP      ';'			; Is it a semicolon?
041490             3744  ; 			JR      NZ,VDU3			; No, so skip to the next expression
041490             3745  ; 			LD	(IX+0),H		; Write out the high byte to the buffer
041490             3746  ; 			INC	IX
041490             3747  ; VDU2:			INC     IY			; Skip to the next character
041490             3748  ; VDU3:			CALL    TERMQ			; Skip past white space
041490             3749  ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
041490             3750  ; 			LD	A,IXL			;  A: Number of bytes to write out
041490             3751  ; 			OR	A
041490             3752  ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
041490             3753  ; 			LD	HL,BUFFER		; HL: Start of stream
041490             3754  ; 			LD	BC,0
041490             3755  ; 			LD	C,A			; BC: Number of bytes to write out
041490             3756  ; 			RST.LIL	18h			; Output the buffer to MOS
041490             3757  ; END MISSING FROM BINARY
041490             3758  ; BEGIN ADDED FROM BINARY
041490             3759  VDU:
041490 CD 0A 03 04 3760  			call EXPRI
041494 D9          3761  			exx
041495 7D          3762  			ld a,l
041496 CD 00 3F 04 3763  			call OSWRCH
04149A FD 7E 00    3764  			ld a,(iy)
04149D FE 2C       3765  			cp $2c
04149F 28 09       3766  			jr z,$+$0b
0414A1 FE 3B       3767  			cp $3b
0414A3 20 07       3768  			jr nz,$+$09
0414A5 7C          3769  			ld a,h
0414A6 CD 00 3F 04 3770  			call OSWRCH
0414AA FD 23       3771  			inc iy
0414AC CD 7A 17 04 3772  			call TERMQ
0414B0 20 DE       3773  			jr nz,$-$20
0414B2             3774  ; END ADDED FROM BINARY
0414B2 C3 96 0B 04 3775  VDU4:			JP      XEQ
0414B6             3776  
0414B6             3777  ; CLOSE channel number
0414B6             3778  ;
0414B6 CD 86 18 04 3779  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414BA CD 2B 43 04 3780  			CALL    OSSHUT			; Close the channel
0414BE C3 96 0B 04 3781  			JP      XEQ
0414C2             3782  
0414C2             3783  ; BPUT channel,byte
0414C2             3784  ;
0414C2 CD 86 18 04 3785  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414C6 D5          3786  			PUSH    DE			; DE: Channel number
0414C7 CD 22 0A 04 3787  			CALL    COMMA			; Skip to the next expression
0414CB CD 0A 03 04 3788  			CALL    EXPRI           	; Feth the data
0414CF D9          3789  			EXX
0414D0 7D          3790  			LD      A,L			; A: The byte to write
0414D1 D1          3791  			POP     DE
0414D2 CD 3B 43 04 3792  			CALL    OSBPUT			; Write the byte out
0414D6 C3 96 0B 04 3793  			JP      XEQ
0414DA             3794  
0414DA             3795  ; CALL address[,var[,var...]]
0414DA             3796  ;
0414DA             3797  ; Note that the parameter table differs from the Z80 version
0414DA             3798  ; Each entry now takes up 4 bytes, not 3, so the table is now:
0414DA             3799  ;  -1 byte:  Number of parameters
0414DA             3800  ; Then, for each parameter:
0414DA             3801  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
0414DA             3802  ;  -3 bytes: Parameter address
0414DA             3803  ;
0414DA             3804  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
0414DA             3805  ;
0414DA CD 0A 03 04 3806  CALL_:			CALL    EXPRI           	; Fetch the address
0414DE 7D          3807  			LD	A,L			;  A: MSB of address
0414DF D9          3808  			EXX
0414E0 22 4A 4D 04 3809  			LD	(R0+0),HL		; HL: LSW of address
0414E4 32 4C 4D 04 3810  			LD	(R0+2),A
0414E8 06 00       3811  			LD      B,0             	;  B: The parameter counter
0414EA 11 00 4B 04 3812  			LD      DE,BUFFER       	; DE: Vector
0414EE             3813  ;
0414EE CD 70 0A 04 3814  CALL1:			CALL    NXT			; Skip whitespace
0414F2 FE 2C       3815  			CP      ','			; Check for comma
0414F4 20 1B       3816  			JR      NZ,CALL2		; If no more parameters, then jump here
0414F6 FD 23       3817  			INC     IY			; Skip to the next character
0414F8 04          3818  			INC     B			; Increment the parameter count
0414F9 CD 70 0A 04 3819  			CALL    NXT			; Skip whitespace
0414FD C5          3820  			PUSH    BC
0414FE D5          3821  			PUSH    DE
0414FF CD 8E 0C 04 3822  			CALL    VAR_
041503 D1          3823  			POP     DE
041504 C1          3824  			POP     BC
041505 13          3825  			INC     DE
041506 12          3826  			LD      (DE),A			; Save the parameter type
041507 13          3827  			INC     DE
041508 EB          3828  			EX      DE,HL
041509 ED 1F       3829  			LD	(HL),DE			; Save the parameter address (3 bytes)
04150B 23          3830  			INC	HL
04150C 23          3831  			INC	HL
04150D 23          3832  			INC	HL
04150E EB          3833  			EX      DE,HL
04150F 18 DD       3834  			JR      CALL1
041511             3835  ;
041511 78          3836  CALL2:			LD      A,B
041512 32 00 4B 04 3837  			LD      (BUFFER),A      	; Save the parameter count
041516 2A 4A 4D 04 3838  			LD	HL,(R0)			; HL: Address of the code
04151A CD 34 15 04 3839  			CALL    USR1			; And call it
04151E C3 96 0B 04 3840  			JP      XEQ
041522             3841  
041522             3842  ; USR(address)
041522             3843  ;
041522 CD 25 03 04 3844  USR:			CALL    ITEMI			; Evaluate the expression
041526 7D          3845  			LD	A,L			;  A: MSB of address
041527 D9          3846  			EXX
041528 22 4A 4D 04 3847  			LD	(R0+0),HL		; HL: LSW of address
04152C 32 4C 4D 04 3848  			LD	(R0+2),A
041530 2A 4A 4D 04 3849  			LD	HL,(R0)			; Get the 24-bit address in HL
041534             3850  ;
041534 E5          3851  USR1:			PUSH    HL              	; Address on stack
041535 FD E3       3852  			EX      (SP),IY
041537 24          3853  			INC     H               	; Check for PAGE &00FFxx
041538 B4          3854  			OR	H
041539 21 A3 15 04 3855  			LD      HL,USR2         	; Return address
04153D E5          3856  			PUSH    HL
04153E DD 21 00 4C 3857  			LD      IX,STAVAR
       04          
041543 CC F1 42 04 3858  			CALL    Z,OSCALL        	; Intercept &00FFxx
041547             3859  ;
041547 DD 4E 18    3860  			LD      C, (IX+24)		; F%
04154A C5          3861  			PUSH    BC
04154B             3862  ;
04154B DD 7E 08    3863  			LD	A, (IX+8)		; B% -> MSW
04154E 32 4B 4D 04 3864  			LD	(R0+1), A
041552 DD 7E 09    3865  			LD	A, (IX+9)
041555 32 4C 4D 04 3866  			LD	(R0+2), A
041559 DD 7E 0C    3867  			LD	A, (IX+12)		; C% -> LSB
04155C 32 4A 4D 04 3868  			LD	(R0+0), A
041560 ED 4B 4A 4D 3869  			LD	BC, (R0)
       04          
041565             3870  ;
041565 DD 7E 10    3871  			LD	A, (IX+16)		; D% -> MSW
041568 32 4B 4D 04 3872  			LD	(R0+1), A
04156C DD 7E 11    3873  			LD	A, (IX+17)
04156F 32 4C 4D 04 3874  			LD	(R0+2), A
041573 DD 7E 14    3875  			LD	A, (IX+20)		; E% -> LSB
041576 32 4A 4D 04 3876  			LD	(R0+0), A
04157A ED 5B 4A 4D 3877  			LD	DE, (R0)
       04          
04157F             3878  ;
04157F DD 7E 20    3879  			LD	A, (IX+32)		; H% -> MSW
041582 32 4B 4D 04 3880  			LD	(R0+1), A
041586 DD 7E 21    3881  			LD	A, (IX+33)
041589 32 4C 4D 04 3882  			LD	(R0+2), A
04158D DD 7E 30    3883  			LD	A, (IX+48)		; L% -> LSB
041590 32 4A 4D 04 3884  			LD	(R0+0), A
041594 2A 4A 4D 04 3885  			LD	HL, (R0)
041598             3886  ;
041598 F1          3887  			POP     AF			; F%
041599 DD 7E 04    3888  			LD      A, (IX+4)        	; A%
04159C             3889  
04159C DD 21 00 4B 3890  			LD      IX,BUFFER
       04          
0415A1 FD E9       3891  			JP      (IY)            	; Off to user routine
0415A3             3892  ;
0415A3 FD E1       3893  USR2:			POP     IY
0415A5 AF          3894  			XOR     A
0415A6 4F          3895  			LD      C,A
0415A7 C9          3896  			RET
0415A8             3897  
0415A8             3898  ; PUT port,data
0415A8             3899  ;
0415A8 CD 0A 03 04 3900  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415AC D9          3901  			EXX
0415AD E5          3902  			PUSH    HL
0415AE CD 22 0A 04 3903  			CALL    COMMA
0415B2 CD 0A 03 04 3904  			CALL    EXPRI           ;DATA
0415B6 D9          3905  			EXX
0415B7 C1          3906  			POP     BC
0415B8 ED 69       3907  			OUT     (C),L           ;OUTPUT TO PORT BC
0415BA C3 96 0B 04 3908  			JP      XEQ
0415BE             3909  
0415BE             3910  ; SUBROUTINES -----------------------------------------------------------------
0415BE             3911  
0415BE             3912  ; ASSIGN - Assign a numeric value to a variable.
0415BE             3913  ; Outputs: NC,  Z - OK, numeric.
0415BE             3914  ;          NC, NZ - OK, string.
0415BE             3915  ;           C, NZ - illegal
0415BE             3916  ;
0415BE CD 3A 3A 04 3917  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415C2 D8          3918  			RET     C               	; Return with C if it is an illegal variable
0415C3 C4 29 3A 04 3919  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415C7 B7          3920  			OR      A
0415C8 F8          3921  			RET     M               	; Return if type is string (81h)
0415C9 F5          3922  			PUSH    AF              	; It's a numeric type from this point on
0415CA CD 90 17 04 3923  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0415CE E5          3924  			PUSH    HL
0415CF CD 02 03 04 3925  			CALL    EXPRN
0415D3 DD E1       3926  			POP     IX
0415D5 F1          3927  			POP     AF
0415D6 CB 47       3928  STORE:			BIT     0,A
0415D8 28 13       3929  			JR      Z,STOREI
0415DA BF          3930  			CP      A               	; Set the variable to 0
0415DB DD 71 04    3931  STORE5:			LD      (IX+4),C
0415DE D9          3932  STORE4:			EXX
0415DF DD 75 00    3933  			LD      (IX+0),L
0415E2 DD 74 01    3934  			LD      (IX+1),H
0415E5 D9          3935  			EXX
0415E6 DD 75 02    3936  			LD      (IX+2),L
0415E9 DD 74 03    3937  			LD      (IX+3),H
0415EC C9          3938  			RET
0415ED F5          3939  STOREI:			PUSH    AF
0415EE 0C          3940  			INC     C               ;SPEED - & PRESERVE F'
0415EF 0D          3941  			DEC     C               ; WHEN CALLED BY FNEND0
0415F0 C4 62 06 04 3942  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
0415F4 F1          3943  			POP     AF
0415F5 FE 04       3944  			CP      4
0415F7 28 E5       3945  			JR      Z,STORE4
0415F9 BF          3946  			CP      A               ;SET ZERO
0415FA D9          3947  STORE1:			EXX
0415FB DD 75 00    3948  			LD      (IX+0),L
0415FE D9          3949  			EXX
0415FF C9          3950  			RET
041600             3951  ;
041600             3952  ; Copy a string from the string accumulator to variable storage on the stack
041600             3953  ; Parameters:
041600             3954  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041600             3955  ; - IX: Address of the variable storage on the stack
041600             3956  ;
041600 21 00 4A 04 3957  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041604             3958  ;
041604             3959  ; Parameters:
041604             3960  ; As above, but:
041604             3961  ; - HL: Address of the string to be stored
041604             3962  ; -  E: The string length
041604             3963  ; NB:
041604             3964  ; Strings are mutable
041604             3965  ; Strings are stored in the following format in the variable:
041604             3966  ; - Address of the next variable (3 bytes)
041604             3967  ; - The rest of the variable name - this is zero terminated
041604             3968  ; - Current string length (byte)
041604             3969  ; - Maximum (original) string length (byte)
041604             3970  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041604             3971  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041604             3972  ;
041604 1F          3973  STORES:			RRA				; Rotate right to shift bit 0 into carry
041605 30 5D       3974  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041607 E5          3975  			PUSH    HL			; Stack ACCS
041608             3976  ;
041608             3977  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
041608             3978  ;
041608 D9          3979  			EXX				; This block was a call to LOAD4
041609 DD 6E 00    3980  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04160C DD 66 01    3981  			LD      H,(IX+1)		; The maximum original string length
04160F D9          3982  			EXX
041610 DD 27 02    3983  			LD	HL,(IX+2)		; Address of the string (24-bit)
041613             3984  ;
041613 7B          3985  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041614 D9          3986  			EXX
041615 6F          3987  			LD      L,A			; L': Length of string currently stored on the stack
041616 7C          3988  			LD      A,H             	; H': The maximum (original) string length
041617 D9          3989  			EXX
041618 BB          3990  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041619 30 17       3991  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04161B             3992  ;
04161B             3993  ; At this point we're either initialising a new string or assigning more memory to an existing string
04161B             3994  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04161B             3995  ; then the existing and new strings may both exist in memory.
04161B             3996  ;
04161B D9          3997  			EXX
04161C 65          3998  			LD      H,L			; H: Set the maximum string length to the string length
04161D D9          3999  			EXX
04161E E5          4000  			PUSH    HL
04161F 01 00 00 00 4001  			LD	BC, 0
041623 4F          4002  			LD      C,A			; BC: The maximum (original) string length
041624 09          4003  			ADD     HL,BC			; Work out whether this is the last string in memory
041625 ED 4B 1D 4D 4004  			LD      BC,(FREE)
       04          
04162A ED 42       4005  			SBC     HL,BC			; Is string last?
04162C E1          4006  			POP     HL
04162D 37          4007  			SCF
04162E 28 02       4008  			JR      Z,STORS1
041630             4009  			; LD	HL, BC			; HL=BC
041630 C5          4010  			push bc
041631 E1          4011  			pop hl
041632             4012  ;
041632             4013  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041632             4014  ; - H': The maximum (original) string length
041632             4015  ; - L': The actual string length (must be less than H')
041632             4016  ; - HL: Address of the string in memory
041632             4017  ;
041632 D9          4018  STORS1:			EXX				; This block was a call to STORE4
041633 DD 75 00    4019  			LD      (IX+0),L		; The actual string length (must be less then H')
041636 DD 74 01    4020  			LD      (IX+1),H		; The maximum (original) string length
041639 D9          4021  			EXX
04163A DD 2F 02    4022  			LD	(IX+2),HL		; The pointer to the original string
04163D             4023  ;
04163D 01 00 00 00 4024  			LD	BC, 0
041641 4B          4025  			LD      C,E			; BC: The new string length
041642 EB          4026  			EX      DE,HL
041643 E1          4027  			POP     HL
041644 0D          4028  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041645 0C          4029  			INC     C			; check whether BC is 0 without affecting the carry flag
041646 C8          4030  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041647 ED B0       4031  			LDIR				; Replace the string in memory
041649 D0          4032  			RET     NC
04164A ED 53 1D 4D 4033  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
04164F             4034  ;
04164F             4035  ; Check whether the stack is full
04164F             4036  ;
04164F E5          4037  CHECK:			PUSH    HL
041650 C5          4038  			PUSH	BC
041651 2A 1D 4D 04 4039  			LD      HL,(FREE)		; HL: Address of first free space byte
041655 01 00 01 00 4040  			LD	BC,100h			; BC: One page of memory
041659 09          4041  			ADD	HL,BC			; Add a page to FREE
04165A ED 72       4042  			SBC     HL,SP			; And subtract the current SP
04165C C1          4043  			POP	BC
04165D E1          4044  			POP     HL
04165E D8          4045  			RET     C			; The SP is not in the same page, so just return
04165F AF          4046  			XOR     A			; Otherwise
041660 C3 60 37 04 4047  			JP      ERROR_			; Throw error "No room"
041664             4048  ;
041664 01 00 00 00 4049  STORS3:			LD	BC,0
041668 4B          4050  			LD      C,E			; BC: String length
041669 DD E5       4051  			PUSH    IX
04166B D1          4052  			POP     DE			; DE: Destination
04166C AF          4053  			XOR     A			; Check if string length is 0
04166D B9          4054  			CP      C
04166E 28 02       4055  			JR      Z,STORS5		; Yes, so don't copy
041670 ED B0       4056  			LDIR
041672 3E 0D       4057  STORS5:			LD      A,CR			; Finally add the terminator
041674 12          4058  			LD      (DE),A
041675 C9          4059  			RET
041676             4060  
041676             4061  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
041676             4062  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
041676             4063  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
041676             4064  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
041676             4065  ;    Inputs: DE addresses parameter list
041676             4066  ;            IY addresses dummy variable list
041676             4067  ;   Outputs: DE,IY updated
041676             4068  ;  Destroys: Everything
041676             4069  ;
041676 3E FF       4070  ARGUE:			LD      A,-1
041678 F5          4071  			PUSH    AF              	; Put marker on the stack
041679 FD 23       4072  ARGUE1:			INC     IY              	; Bump past '(' or ',''
04167B 13          4073  			INC     DE
04167C D5          4074  			PUSH    DE
04167D CD 70 0A 04 4075  			CALL    NXT			; Skip any whitespace
041681 CD 3A 3A 04 4076  			CALL    GETVAR			; Get the location of the variable in HL/IX
041685 38 3F       4077  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
041687 C4 29 3A 04 4078  			CALL    NZ,PUTVAR
04168B D1          4079  			POP     DE
04168C E5          4080  			PUSH    HL              	; VARPTR
04168D B7          4081  			OR      A               	; Check the variable type
04168E F5          4082  			PUSH    AF
04168F D5          4083  			PUSH    DE
041690 FD E3       4084  			EX      (SP),IY
041692 FA AA 16 04 4085  			JP      M,ARGUE2        	; Jump here if it is a string
041696             4086  ;
041696 CD 02 03 04 4087  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
04169A FD E3       4088  			EX      (SP),IY
04169C D1          4089  			POP     DE
04169D F1          4090  			POP     AF
04169E D9          4091  			EXX
04169F E5          4092  			PUSH    HL
0416A0 D9          4093  			EXX
0416A1 E5          4094  			PUSH    HL
0416A2 47          4095  			LD      B,A
0416A3 C5          4096  			PUSH    BC
0416A4 CD 4F 16 04 4097  			CALL    CHECK           	; Check room
0416A8 18 0F       4098  			JR      ARGUE4
0416AA             4099  ;
0416AA CD 15 03 04 4100  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416AE FD E3       4101  			EX      (SP),IY
0416B0 D9          4102  			EXX
0416B1 D1          4103  			POP     DE
0416B2 D9          4104  			EXX
0416B3 F1          4105  			POP     AF
0416B4 CD B4 09 04 4106  			CALL    PUSHS
0416B8 D9          4107  			EXX
0416B9             4108  ;
0416B9 CD 70 0A 04 4109  ARGUE4:			CALL    NXT			; Skip whitespace
0416BD FE 2C       4110  			CP      ','			; Check to see if the next value is a comma
0416BF 20 0B       4111  			JR      NZ,ARGUE5		; No, so jump here
0416C1 1A          4112  			LD      A,(DE)
0416C2 FE 2C       4113  			CP      ','			; Are there any more arguments?
0416C4 28 B3       4114  			JR      Z,ARGUE1        	; Yes, so loop
0416C6             4115  ;
0416C6 3E 1F       4116  ARGERR:			LD      A,31
0416C8 C3 60 37 04 4117  			JP      ERROR_           	; Throw error "Arguments"
0416CC             4118  ;
0416CC CD 2F 0A 04 4119  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0416D0 1A          4120  			LD      A,(DE)
0416D1 FE 29       4121  			CP      ')'
0416D3 20 F1       4122  			JR      NZ,ARGERR
0416D5 13          4123  			INC     DE
0416D6 D9          4124  			EXX
0416D7 C1          4125  ARGUE6:			POP     BC
0416D8 78          4126  			LD      A,B
0416D9 3C          4127  			INC     A
0416DA D9          4128  			EXX
0416DB C8          4129  			RET     Z               	; Marker popped
0416DC D9          4130  			EXX
0416DD 3D          4131  			DEC     A
0416DE FA EE 16 04 4132  			JP      M,ARGUE7        	; If it is a string, then jump here
0416E2 E1          4133  			POP     HL
0416E3 D9          4134  			EXX
0416E4 E1          4135  			POP     HL
0416E5 D9          4136  			EXX
0416E6 DD E1       4137  			POP     IX
0416E8 CD D6 15 04 4138  			CALL    STORE	           	; Write to dummy variable
0416EC 18 E9       4139  			JR      ARGUE6
0416EE             4140  ;
0416EE CD DE 09 04 4141  ARGUE7:			CALL    POPS
0416F2 DD E1       4142  			POP     IX
0416F4 CD 00 16 04 4143  			CALL    STACCS
0416F8 18 DD       4144  			JR      ARGUE6
0416FA             4145  
0416FA             4146  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
0416FA             4147  ;   OF A FUNCTION OR PROCEDURE.
0416FA             4148  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
0416FA             4149  ;    Inputs: IY is parameters pointer
0416FA             4150  ;   Outputs: IY updated
0416FA             4151  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
0416FA             4152  ;
0416FA D1          4153  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
0416FB             4154  ;
0416FB FD 23       4155  SAVLO1:			INC     IY              	; Bump past '(' or ','
0416FD CD 70 0A 04 4156  			CALL    NXT			; And also any whitespace
041701 D5          4157  			PUSH    DE			; Push the return address back onto the stack
041702 D9          4158  			EXX
041703 C5          4159  			PUSH    BC
041704 D5          4160  			PUSH    DE
041705 E5          4161  			PUSH    HL
041706 D9          4162  			EXX
041707 CD 8E 0C 04 4163  			CALL    VAR_             	; Dummy variable
04170B D9          4164  			EXX
04170C E1          4165  			POP     HL
04170D D1          4166  			POP     DE
04170E C1          4167  			POP     BC
04170F D9          4168  			EXX
041710 D1          4169  			POP     DE
041711 B7          4170  			OR      A               	; Check the variable type
041712 FA 25 17 04 4171  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041716 D9          4172  			EXX
041717 E5          4173  			PUSH    HL              	; Save H'L'
041718 D9          4174  			EXX
041719 47          4175  			LD      B,A             	;  B: Variable type
04171A CD 16 04 04 4176  			CALL    LOADN
04171E D9          4177  			EXX
04171F E3          4178  			EX      (SP),HL
041720 D9          4179  			EXX
041721 E5          4180  			PUSH    HL
041722 C5          4181  			PUSH    BC
041723 18 2D       4182  			JR      SAVLO4
041725             4183  ;
041725 F5          4184  SAVLO2:			PUSH    AF              	; Save the type (string)
041726 D5          4185  			PUSH    DE
041727 D9          4186  			EXX
041728 E5          4187  			PUSH    HL
041729 D9          4188  			EXX
04172A CD A0 04 04 4189  			CALL    LOADS
04172E D9          4190  			EXX
04172F E1          4191  			POP     HL
041730 D9          4192  			EXX
041731 01 00 00 00 4193  			LD	BC,0
041735 4B          4194  			LD      C,E			; BC: String length
041736 D1          4195  			POP     DE
041737 CD 4F 16 04 4196  			CALL    CHECK			; Check if there is space on the stack
04173B F1          4197  			POP     AF              	; Level stack
04173C 21 00 00 00 4198  			LD      HL,0
041740 ED 42       4199  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041742 39          4200  			ADD     HL,SP			; Make space for the string on the stack
041743 F9          4201  			LD      SP,HL
041744 47          4202  			LD      B,A             	;  B: Variable type
041745 C5          4203  			PUSH    BC
041746 28 0A       4204  			JR      Z,SAVLO4
041748 D5          4205  			PUSH    DE
041749 11 00 4A 04 4206  			LD      DE,ACCS
04174D EB          4207  			EX      DE,HL
04174E 45          4208  			LD      B,L
04174F ED B0       4209  			LDIR                    	; Save the string onto the stack
041751 D1          4210  			POP     DE
041752             4211  ;
041752 DD E5       4212  SAVLO4:			PUSH    IX			; VARPTR
041754 CD 58 17 04 4213  			CALL    SAVLO5
041758             4214  LOCCHK:			EQU     $
041758 CD 4F 16 04 4215  SAVLO5:			CALL    CHECK
04175C CD 70 0A 04 4216  			CALL    NXT
041760 FE 2C       4217  			CP      ','             	; Are there any more local variables?
041762 28 97       4218  			JR      Z,SAVLO1		; Yes, so loop
041764 EB          4219  			EX      DE,HL			; DE -> HL: The return address
041765 E9          4220  			JP      (HL)            	; And effectvely return
041766             4221  ;
041766 FD 7E 00    4222  DELIM:			LD      A,(IY)          	; Assembler delimiter
041769 FE 20       4223  			CP      ' '
04176B C8          4224  			RET     Z
04176C FE 2C       4225  			CP      ','
04176E C8          4226  			RET     Z
04176F FE 29       4227  			CP      ')'
041771 C8          4228  			RET     Z
041772 FE 3B       4229  TERM:			CP      ';'             	; Assembler terminator
041774 C8          4230  			RET     Z
041775 FE 5C       4231  			CP      '\'
041777 C8          4232  			RET     Z
041778 18 07       4233  			JR      TERM0
04177A             4234  ;
04177A CD 70 0A 04 4235  TERMQ:			CALL    NXT
04177E FE 8B       4236  			CP      ELSE_EX_
041780 D0          4237  			RET     NC
041781 FE 3A       4238  TERM0:			CP      ':'             	; Assembler seperator
041783 D0          4239  			RET     NC
041784 FE 0D       4240  			CP      CR
041786 C9          4241  			RET
041787             4242  ;
041787 CD 7A 17 04 4243  SPAN:			CALL    TERMQ
04178B C8          4244  			RET     Z
04178C FD 23       4245  			INC     IY
04178E 18 F7       4246  			JR      SPAN
041790             4247  ;
041790             4248  ; This snippet is used to check whether an expression is followed by an '=' symbol
041790             4249  ;
041790 CD 70 0A 04 4250  EQUALS:			CALL    NXT			; Skip whitespace
041794 FD 23       4251  			INC     IY			; Skip past the character in question
041796 FE 3D       4252  			CP      '='			; Is it '='
041798 C8          4253  			RET     Z			; Yes, so return
041799 3E 04       4254  			LD      A,4			; Otherwise
04179B C3 60 37 04 4255  			JP      ERROR_           	; Throw error "Mistake"
04179F             4256  ;
04179F FE 8A       4257  FORMAT:			CP      TAB
0417A1 28 0D       4258  			JR      Z,DOTAB
0417A3 FE 89       4259  			CP      SPC
0417A5 28 40       4260  			JR      Z,DOSPC
0417A7 FE 27       4261  			CP      '''
0417A9 C0          4262  			RET     NZ
0417AA CD 47 39 04 4263  			CALL    CRLF
0417AE AF          4264  			XOR     A
0417AF C9          4265  			RET
0417B0             4266  ;
0417B0 C5          4267  DOTAB:			PUSH    BC
0417B1 CD 0A 03 04 4268  			CALL    EXPRI
0417B5 D9          4269  			EXX
0417B6 C1          4270  			POP     BC
0417B7 FD 7E 00    4271  			LD      A,(IY)
0417BA FE 2C       4272  			CP      ','
0417BC 28 14       4273  			JR      Z,DOTAB1
0417BE CD 2F 0A 04 4274  			CALL    BRAKET
0417C2 7D          4275  			LD      A,L
0417C3 21 3D 4D 04 4276  TABIT:			LD      HL,COUNT
0417C7 BE          4277  			CP      (HL)
0417C8 C8          4278  			RET     Z
0417C9 F5          4279  			PUSH    AF
0417CA DC 47 39 04 4280  			CALL    C,CRLF
0417CE F1          4281  			POP     AF
0417CF 96          4282  			SUB     (HL)
0417D0 18 1D       4283  			JR      FILL
0417D2 FD 23       4284  DOTAB1:			INC     IY
0417D4 C5          4285  			PUSH    BC
0417D5 E5          4286  			PUSH    HL
0417D6 CD 0A 03 04 4287  			CALL    EXPRI
0417DA D9          4288  			EXX
0417DB D1          4289  			POP     DE
0417DC C1          4290  			POP     BC
0417DD CD 2F 0A 04 4291  			CALL    BRAKET
0417E1 CD C1 3E 04 4292  			CALL    PUTCSR
0417E5 AF          4293  			XOR     A
0417E6 C9          4294  			RET
0417E7             4295  ;
0417E7 C5          4296  DOSPC:			PUSH    BC
0417E8 CD 25 03 04 4297  			CALL    ITEMI
0417EC D9          4298  			EXX
0417ED 7D          4299  			LD      A,L
0417EE C1          4300  			POP     BC
0417EF B7          4301  FILL:			OR      A
0417F0 C8          4302  			RET     Z
0417F1 C5          4303  			PUSH    BC
0417F2 47          4304  			LD      B,A
0417F3 3E 20       4305  FILL1:			LD      A,' '
0417F5 CD 4F 39 04 4306  			CALL    OUTCHR
0417F9 10 F8       4307  			DJNZ    FILL1
0417FB C1          4308  			POP     BC
0417FC AF          4309  			XOR     A
0417FD C9          4310  			RET
0417FE             4311  ;
0417FE 21 00 4A 04 4312  PTEXT:			LD      HL,ACCS
041802 1C          4313  			INC     E
041803 1D          4314  PTEXT1:			DEC     E
041804 C8          4315  			RET     Z
041805 7E          4316  			LD      A,(HL)
041806 23          4317  			INC     HL
041807 CD 4F 39 04 4318  			CALL    OUTCHR
04180B 18 F6       4319  			JR      PTEXT1
04180D             4320  ;
04180D F5          4321  FETCHS:			PUSH    AF
04180E C5          4322  			PUSH    BC
04180F E5          4323  			PUSH    HL
041810 FD E3       4324  			EX      (SP),IY
041812 CD 2D 18 04 4325  			CALL    XTRACT
041816 CD 70 0A 04 4326  			CALL    NXT
04181A FD E3       4327  			EX      (SP),IY
04181C E1          4328  			POP     HL
04181D C1          4329  			POP     BC
04181E F1          4330  			POP     AF
04181F C9          4331  			RET
041820             4332  ;
041820 11 00 4A 04 4333  LINES:			LD      DE,ACCS
041824 7E          4334  LINE1S:			LD      A,(HL)
041825 12          4335  			LD      (DE),A
041826 FE 0D       4336  			CP      CR
041828 C8          4337  			RET     Z
041829 23          4338  			INC     HL
04182A 1C          4339  			INC     E
04182B 18 F7       4340  			JR      LINE1S
04182D             4341  ;
04182D CD 70 0A 04 4342  XTRACT:			CALL    NXT
041831 FE 22       4343  			CP      '"'
041833 FD 23       4344  			INC     IY
041835 CA 67 04 04 4345  			JP      Z,CONS
041839 FD 2B       4346  			DEC     IY
04183B 11 00 4A 04 4347  			LD      DE,ACCS
04183F FD 7E 00    4348  XTRAC1:			LD      A,(IY)
041842 12          4349  			LD      (DE),A
041843 FE 2C       4350  			CP      ','
041845 C8          4351  			RET     Z
041846 FE 0D       4352  			CP      CR
041848 C8          4353  			RET     Z
041849 FD 23       4354  			INC     IY
04184B 1C          4355  			INC     E
04184C 18 F1       4356  			JR      XTRAC1
04184E             4357  
04184E             4358  ; Search for a token at the start of a program line
04184E             4359  ; - HL: Pointer to the start of a tokenised line in the program area
04184E             4360  ; Returns:
04184E             4361  ; - HL: Pointer to the
04184E             4362  ; -  F: Carry set if not found
04184E             4363  ; Corrupts:
04184E             4364  ; - BC
04184E             4365  ;
04184E 01 00 00 00 4366  SEARCH_EX:			LD      BC,0			; Clear BC
041852             4367  ;
041852 4E          4368  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041853 0C          4369  			INC     C			; Check for 0, i.e. end of program marker
041854 0D          4370  			DEC     C
041855 28 0B       4371  			JR      Z,SRCH2_EX         	; Not found the token, so end
041857 23          4372  			INC     HL			; Skip the line length and line number
041858 23          4373  			INC     HL
041859 23          4374  			INC     HL
04185A BE          4375  			CP      (HL)			; Compare with the token
04185B C8          4376  			RET     Z			; Found it, so return with carry not set
04185C 0D          4377  			DEC     C			; Skip to the next line
04185D 0D          4378  			DEC     C
04185E 0D          4379  			DEC     C
04185F 09          4380  			ADD     HL,BC
041860 18 F0       4381  			JR      SRCH1_EX			; Rinse, lather and repeat
041862             4382  ;
041862 2B          4383  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041863 37          4384  			SCF				; And set the carry flag
041864 C9          4385  			RET
041865             4386  
041865             4387  ; Multiply by 4 or 5
041865             4388  ; This function is used to allocate space for dimensioned variables
041865             4389  ; This is a 24-bit operation
041865             4390  ; - DE: Number to multiple
041865             4391  ; -  A: 04h (Integer) - takes up 4 bytes
041865             4392  ;       05h (Float)   - takes up 5 bytes
041865             4393  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
041865             4394  ; Returns:
041865             4395  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
041865             4396  ; -  F: Carry if overflow
041865             4397  ; Corrupts:
041865             4398  ; - HL
041865 FE 04       4399  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041867             4400  			; LD	HL,DE
041867 D5          4401  			push de
041868 E1          4402  			pop hl
041869 29          4403  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04186A D8          4404  			RET     C			; Exit if overflow
04186B 29          4405  			ADD     HL,HL			; Multiply by 2 again
04186C D8          4406  			RET     C			; Exit if overflow
04186D EB          4407  			EX      DE,HL			; DE: Product
04186E C8          4408  			RET     Z			; Exit if A = 4
04186F 19          4409  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
041870 EB          4410  			EX      DE,HL			; DE: Product
041871 C9          4411  			RET
041872             4412  
041872             4413  ; 16-bit unsigned multiply
041872             4414  ; - HL: Operand 1
041872             4415  ; - BC: Operand 2
041872             4416  ; Returns:
041872             4417  ; - HL: Result
041872             4418  ; -  F: C if overflow
041872             4419  ;
041872 C5          4420  MUL16:			PUSH	BC
041873 51          4421  			LD	D, C			; Set up the registers for the multiplies
041874 5D          4422  			LD	E, L
041875 69          4423  			LD	L, C
041876 4B          4424  			LD	C, E
041877 ED 6C       4425  			MLT	HL			; HL = H * C (*256)
041879 ED 5C       4426  			MLT	DE			; DE = L * C
04187B ED 4C       4427  			MLT	BC			; BC = B * L (*256)
04187D 09          4428  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
04187E C1          4429  			POP	BC
04187F AF          4430  			XOR	A
041880 9C          4431  			SBC	H			; If H is not zero then it's an overflow
041881 D8          4432  			RET	C
041882 65          4433  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
041883 6F          4434  			LD	L, A
041884 19          4435  			ADD	HL, DE
041885 C9          4436  			RET
041886             4437  ;
041886 CD 70 0A 04 4438  CHANEL:			CALL    NXT			; Skip whitespace
04188A FE 23       4439  			CP      '#'			; Check for the '#' symbol
04188C 3E 2D       4440  			LD      A,45
04188E C2 60 37 04 4441  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
041892 FD 23       4442  CHNL:			INC     IY             		; Bump past the '#'
041894 CD 25 03 04 4443  			CALL    ITEMI			; Get the channel number
041898 D9          4444  			EXX
041899 EB          4445  			EX      DE,HL			; DE: The channel number
04189A C9          4446  			RET
04189B             4447  
04189B             4448  ; ASSEMBLER -------------------------------------------------------------------
04189B             4449  
04189B             4450  ; Language independant control section:
04189B             4451  ;  Outputs: A=delimiter, carry set if syntax error.
04189B             4452  ;
04189B CD B5 1D 04 4453  ASSEM:			CALL    SKIP
04189F FD 23       4454  			INC     IY
0418A1 FE 3A       4455  			CP      ':'
0418A3 28 F6       4456  			JR      Z,ASSEM
0418A5 FE 5D       4457  			CP      ']'
0418A7 C8          4458  			RET     Z
0418A8 FE 0D       4459  			CP      CR
0418AA C8          4460  			RET     Z
0418AB FD 2B       4461  			DEC     IY
0418AD DD 2A 40 4C 4462  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       04          
0418B2 21 40 4D 04 4463  			LD      HL,LISTON
0418B6 CB 76       4464  			BIT     6,(HL)
0418B8 28 05       4465  			JR      Z,ASSEM0
0418BA DD 2A 3C 4C 4466  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       04          
0418BF DD E5       4467  ASSEM0:			PUSH    IX
0418C1 FD E5       4468  			PUSH    IY
0418C3 CD 73 19 04 4469  			CALL    ASMB
0418C7 C1          4470  			POP     BC
0418C8 D1          4471  			POP     DE
0418C9 D8          4472  			RET     C
0418CA CD B5 1D 04 4473  			CALL    SKIP
0418CE 37          4474  			SCF
0418CF C0          4475  			RET     NZ
0418D0 FD 2B       4476  			DEC     IY
0418D2 FD 23       4477  ASSEM3:			INC     IY
0418D4 FD 7E 00    4478  			LD      A,(IY)
0418D7 CD 81 17 04 4479  			CALL    TERM0
0418DB 20 F5       4480  			JR      NZ,ASSEM3
0418DD 3A 40 4D 04 4481  			LD      A,(LISTON)
0418E1 DD E5       4482  			PUSH    IX
0418E3 E1          4483  			POP     HL
0418E4 B7          4484  			OR      A
0418E5 ED 52       4485  			SBC     HL,DE
0418E7 EB          4486  			EX      DE,HL           	; DE: Number of bytes
0418E8 E5          4487  			PUSH    HL
0418E9 2A 40 4C 04 4488  			LD      HL,(PC)
0418ED E5          4489  			PUSH    HL
0418EE 19          4490  			ADD     HL,DE
0418EF 22 40 4C 04 4491  			LD      (PC),HL         	; Update PC
0418F3 CB 77       4492  			BIT     6,A
0418F5 28 09       4493  			JR      Z,ASSEM5
0418F7 2A 3C 4C 04 4494  			LD      HL,(OC)
0418FB 19          4495  			ADD     HL,DE
0418FC 22 3C 4C 04 4496  			LD      (OC),HL         	; Update OC
041900 E1          4497  ASSEM5:			POP     HL              	; Old PC
041901 DD E1       4498  			POP     IX              	; Code here
041903 CB 67       4499  			BIT     4,A
041905 28 94       4500  			JR      Z,ASSEM
041907 22 4A 4D 04 4501  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04190B 3A 4C 4D 04 4502  			LD	A,(R0+2)		; Print out the address
04190F CD 5D 19 04 4503  			CALL	HEX_EX
041913 7C          4504  			LD      A,H
041914 CD 5D 19 04 4505  			CALL    HEX_EX
041918 7D          4506  			LD      A,L
041919 CD 55 19 04 4507  			CALL    HEXSP
04191D AF          4508  			XOR     A
04191E BB          4509  			CP      E
04191F 28 18       4510  			JR      Z,ASSEM2
041921             4511  ;
041921 3A 3D 4D 04 4512  ASSEM1:			LD      A,(COUNT)
041925 FE 14       4513  			CP      20
041927 3E 07       4514  			LD      A,7
041929 D4 C3 17 04 4515  			CALL    NC,TABIT        	; Next line
04192D DD 7E 00    4516  			LD      A,(IX)
041930 CD 55 19 04 4517  			CALL    HEXSP
041934 DD 23       4518  			INC     IX
041936 1D          4519  			DEC     E
041937 20 E8       4520  			JR      NZ,ASSEM1
041939             4521  ;
041939 3E 16       4522  ASSEM2:			LD      A,22			; Tab to the disassembly field
04193B CD C3 17 04 4523  			CALL    TABIT
04193F FD E5       4524  			PUSH    IY
041941 E1          4525  			POP     HL
041942 ED 42       4526  			SBC     HL,BC
041944 0A          4527  ASSEM4:			LD      A,(BC)
041945 CD 6C 39 04 4528  			CALL    OUT_
041949 03          4529  			INC     BC
04194A 2D          4530  			DEC     L
04194B 20 F7       4531  			JR      NZ,ASSEM4
04194D CD 47 39 04 4532  			CALL    CRLF
041951 C3 9B 18 04 4533  			JP      ASSEM
041955             4534  ;
041955 CD 5D 19 04 4535  HEXSP:			CALL    HEX_EX
041959 3E 20       4536  			LD      A,' '
04195B 18 12       4537  			JR      OUTCH1
04195D F5          4538  HEX_EX:			PUSH    AF
04195E 0F          4539  			RRCA
04195F 0F          4540  			RRCA
041960 0F          4541  			RRCA
041961 0F          4542  			RRCA
041962 CD 67 19 04 4543  			CALL    HEXOUT
041966 F1          4544  			POP     AF
041967 E6 0F       4545  HEXOUT:			AND     0FH
041969 C6 90       4546  			ADD     A,90H
04196B 27          4547  			DAA
04196C CE 40       4548  			ADC     A,40H
04196E 27          4549  			DAA
04196F C3 6C 39 04 4550  OUTCH1:			JP      OUT_
041973             4551  
041973             4552  ; Processor Specific Translation Section:
041973             4553  ;
041973             4554  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
041973             4555  ;                 C: Opcode beig built
041973             4556  ;                 D: Flags
041973             4557  ;			Bit 7: Set to 1 if the instruction uses long addressing
041973             4558  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
041973             4559  ;                 E: Offset from IX or IY
041973             4560  ;                HL: Numeric operand value
041973             4561  ;                IX: Code destination pointer
041973             4562  ;                IY: Source text pointer
041973             4563  ;    Inputs: A = initial character
041973             4564  ;   Outputs: Carry set if syntax error.
041973             4565  ;
041973 FE 2E       4566  ASMB:			CP      '.'			; Check for a dot; this indicates a label
041975 20 1F       4567  			JR      NZ,ASMB1		; No, so just process the instruction
041977 FD 23       4568  			INC     IY			; Skip past the dot to the label name
041979 DD E5       4569  			PUSH    IX			; Store the code destination pointer
04197B CD 8E 0C 04 4570  			CALL    VAR_			; Create a variable
04197F F5          4571  			PUSH    AF
041980 CD 93 09 04 4572  			CALL    ZERO			; Zero it
041984 3A 42 4C 04 4573  			LD	A,(PC+2)
041988 6F          4574  			LD	L,A			; The MSB of the 24-bit address
041989 D9          4575  			EXX
04198A 2A 40 4C 04 4576  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
04198E D9          4577  			EXX
04198F F1          4578  			POP     AF
041990 CD D6 15 04 4579  			CALL    STORE			; Store the program counter
041994 DD E1       4580  			POP     IX			; Restore the code destination pointer
041996             4581  ;
041996 3A 40 4D 04 4582  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
04199A E6 80       4583  			AND	80H
04199C 57          4584  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
04199D CD B5 1D 04 4585  			CALL    SKIP			; Skip any whitespace
0419A1 C8          4586  			RET     Z			; And return if there is nothing further to process
0419A2 FE D6       4587  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419A4 0E C4       4588  			LD      C,0C4H			;  A: The base operand
0419A6 FD 23       4589  			INC     IY			; Skip past the token
0419A8 CA EA 1A 04 4590  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419AC FD 2B       4591  			DEC     IY			; Skip back, as we're not doing the above at this point
0419AE 21 CC 1D 04 4592  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419B2 CD 64 1D 04 4593  			CALL    FIND			; Find the opcode
0419B6 D8          4594  			RET     C			; If not found, then return; carry indicates an error condition
0419B7 48          4595  			LD      C,B     		;  C: A copy of the opcode
0419B8             4596  ;
0419B8             4597  ; GROUP 0: Trivial cases requiring no computation
0419B8             4598  ; GROUP 1: As Group 0, but with "ED" prefix
0419B8             4599  ;
0419B8 D6 44       4600  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419BA 30 08       4601  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419BC FE CB       4602  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419BE D4 BD 1C 04 4603  			CALL    NC,ED			; Needs to be prefixed with ED
0419C2 18 76       4604  			JR      BYTE0			; Then write the opcode byte
0419C4             4605  ;
0419C4             4606  ; GROUP 2: BIT, RES, SET
0419C4             4607  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419C4             4608  ;
0419C4 D6 0A       4609  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419C6 30 12       4610  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419C8 FE F9       4611  			CP      3-10			;
0419CA DC 52 1D 04 4612  			CALL    C,BIT_
0419CE D8          4613  			RET     C
0419CF CD 23 1D 04 4614  			CALL    REGLO
0419D3 D8          4615  			RET     C
0419D4 CD C1 1C 04 4616  			CALL    CB
0419D8 18 60       4617  			JR      BYTE0
0419DA             4618  ;
0419DA             4619  ; GROUP 4 - PUSH, POP, EX (SP)
0419DA             4620  ;
0419DA D6 03       4621  GROUP04:		SUB     3			; The number of opcodes in GROUP4
0419DC 30 07       4622  			JR      NC,GROUP05		; If not in that range, then check GROUP5
0419DE CD 45 1D 04 4623  GROUP04_1:		CALL    PAIR_EX
0419E2 D8          4624  			RET     C
0419E3 18 55       4625  			JR      BYTE0
0419E5             4626  ;
0419E5             4627  ; GROUP 5 - SUB, AND, XOR, OR, CP
0419E5             4628  ; GROUP 6 - ADD, ADC, SBC
0419E5             4629  ;
0419E5 D6 0A       4630  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0419E7 30 39       4631  			JR      NC,GROUP07
0419E9 FE FD       4632  			CP      5-8
0419EB 06 07       4633  			LD      B,7
0419ED D4 D1 1C 04 4634  			CALL    NC,OPND			; Get the first operand
0419F1 78          4635  			LD      A,B
0419F2 FE 07       4636  			CP      7			; Is the operand 'A'?
0419F4 20 15       4637  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0419F6             4638  ;
0419F6 CD 23 1D 04 4639  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0419FA 79          4640  			LD      A,C
0419FB 30 2E       4641  			JR      NC,BIND1		; If it is a register, then write that out
0419FD EE 46       4642  			XOR     46H			; Handle ADD A,n
0419FF CD C3 1C 04 4643  			CALL    BIND
041A03 CD 03 1D 04 4644  DB_:			CALL    NUMBER
041A07 C3 BC 1A 04 4645  			JP      VAL8
041A0B             4646  ;
041A0B E6 3F       4647  GROUP05_HL:		AND     3FH
041A0D FE 0C       4648  			CP      12
041A0F 37          4649  			SCF
041A10 C0          4650  			RET     NZ
041A11 79          4651  			LD      A,C
041A12 FE 80       4652  			CP      80H
041A14 0E 09       4653  			LD      C,9
041A16 28 C6       4654  			JR      Z,GROUP04_1
041A18 EE 1C       4655  			XOR     1CH
041A1A 0F          4656  			RRCA
041A1B 4F          4657  			LD      C,A
041A1C CD BD 1C 04 4658  			CALL    ED
041A20 18 BC       4659  			JR      GROUP04_1
041A22             4660  ;
041A22             4661  ; GROUP 7 - INC, DEC
041A22             4662  ;
041A22 D6 02       4663  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A24 30 19       4664  			JR      NC,GROUP08
041A26 CD 2A 1D 04 4665  			CALL    REGHI
041A2A 79          4666  			LD      A,C
041A2B D2 C3 1C 04 4667  BIND1:			JP      NC,BIND
041A2F EE 64       4668  			XOR     64H
041A31 07          4669  			RLCA
041A32 07          4670  			RLCA
041A33 07          4671  			RLCA
041A34 4F          4672  			LD      C,A
041A35 CD 4A 1D 04 4673  			CALL    PAIR1_EX
041A39 D8          4674  			RET     C
041A3A 79          4675  BYTE0:			LD      A,C
041A3B C3 F2 1C 04 4676  			JP      BYTE_
041A3F             4677  ;
041A3F             4678  ; Group 8: IN0, OUT0
041A3F             4679  ;
041A3F D6 02       4680  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A41 30 26       4681  			JR	NC,GROUP09
041A43 FE FF       4682  			CP	1-2
041A45 CC 03 1D 04 4683  			CALL    Z,NUMBER		; Fetch number first if OUT
041A49 08          4684  			EX      AF,AF'			; Save flags
041A4A CD 17 1D 04 4685  			CALL    REG			; Get the register value regardless
041A4E D8          4686  			RET     C			; Return if not a register
041A4F 08          4687  			EX      AF,AF'			; Restore the flags
041A50 DC 03 1D 04 4688  			CALL    C,NUMBER		; Fetch number last if IN
041A54 78          4689  			LD	A,B			; Get the register number
041A55 FE 06       4690  			CP	6			; Fail on (HL)
041A57 37          4691  			SCF
041A58 C8          4692  			RET	Z
041A59 FE 08       4693  			CP	8			; Check it is just single pairs only
041A5B 3F          4694  			CCF
041A5C D8          4695  			RET	C			; And return if it is an invalid register
041A5D 07          4696  			RLCA				; Bind with the operand
041A5E 07          4697  			RLCA
041A5F 07          4698  			RLCA
041A60 81          4699  			ADD	A,C
041A61             4700  ; BEGIN NOT IN BINARY
041A61             4701  			; LD	C,A
041A61             4702  			; CALL	ED			; Prefix with ED
041A61             4703  			; LD	A,C
041A61             4704  ; END NOT IN BINARY
041A61 CD F2 1C 04 4705  			CALL	BYTE_			; Write out the operand
041A65 C3 BC 1A 04 4706  			JP	VAL8			; Write out the value
041A69             4707  ;
041A69             4708  ; GROUP 9 - IN
041A69             4709  ; GROUP 10 - OUT
041A69             4710  ;
041A69 D6 02       4711  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041A6B 30 25       4712  			JR      NC,GROUP11
041A6D FE FF       4713  			CP      1-2			; Check if Group 9 or Group 1
041A6F CC B1 1C 04 4714  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041A73 08          4715  			EX      AF,AF'			; Save flags
041A74 CD 2A 1D 04 4716  			CALL    REGHI			; Get the register value regardless
041A78 D8          4717  			RET     C			; Return if not a register
041A79 08          4718  			EX      AF,AF'			; Restore the flags
041A7A DC B1 1C 04 4719  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041A7E 24          4720  			INC     H			; If it is IN r,(C) or OUT (C),r then
041A7F 28 B9       4721  			JR      Z,BYTE0			; Just write the operand out
041A81             4722  ;
041A81 78          4723  			LD      A,B			; Check the register
041A82 FE 07       4724  			CP      7
041A84 37          4725  			SCF
041A85 C0          4726  			RET     NZ			; If it is not A, then return
041A86             4727  ;
041A86 79          4728  			LD      A,C			; Bind the register with the operand
041A87 EE 03       4729  			XOR     3
041A89 07          4730  			RLCA
041A8A 07          4731  			RLCA
041A8B 07          4732  			RLCA
041A8C CD F2 1C 04 4733  			CALL    BYTE_			; Write out the operand
041A90 18 2A       4734  			JR      VAL8			; And the value
041A92             4735  ;
041A92             4736  ; GROUP 11 - JR, DJNZ
041A92             4737  ;
041A92 D6 02       4738  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041A94 30 2B       4739  			JR      NC,GROUP12
041A96 FE FF       4740  			CP      1-2
041A98 C4 31 1D 04 4741  			CALL    NZ,COND_
041A9C 79          4742  			LD      A,C
041A9D 30 02       4743  			JR      NC,@F
041A9F 3E 18       4744  			LD      A,18H
041AA1 CD F2 1C 04 4745  @@:			CALL    BYTE_
041AA5 CD 03 1D 04 4746  			CALL    NUMBER
041AA9 ED 5B 40 4C 4747  			LD      DE,(PC)
       04          
041AAE 13          4748  			INC     DE
041AAF 37          4749  			SCF
041AB0 ED 52       4750  			SBC     HL,DE
041AB2 7D          4751  			LD      A,L
041AB3 17          4752  			RLA
041AB4 9F          4753  			SBC     A,A
041AB5 BC          4754  			CP      H
041AB6 3E 01       4755  TOOFAR:			LD      A,1
041AB8 C2 60 37 04 4756  			JP      NZ,ERROR_		; Throw an "Out of range" error
041ABC 7D          4757  VAL8:			LD      A,L
041ABD C3 F2 1C 04 4758  			JP      BYTE_
041AC1             4759  ;
041AC1             4760  ; GROUP 12 - JP
041AC1             4761  ;
041AC1 D6 01       4762  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AC3 30 21       4763  			JR	NC,GROUP13
041AC5 CD 17 1C 04 4764  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041AC9 D8          4765  			RET	C			; Exit if an invalid suffix is provided
041ACA CD 31 1D 04 4766  			CALL    COND_			; Evaluate the conditions
041ACE 79          4767  			LD      A,C
041ACF 30 0D       4768  			JR      NC,GROUP12_1
041AD1 78          4769  			LD      A,B
041AD2 E6 3F       4770  			AND     3FH
041AD4 FE 06       4771  			CP      6
041AD6 3E E9       4772  			LD      A,0E9H
041AD8 CA F2 1C 04 4773  			JP      Z,BYTE_
041ADC 3E C3       4774  			LD      A,0C3H
041ADE CD F2 1C 04 4775  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041AE2 C3 6C 1C 04 4776  			JP	ADDR_			; Output the address
041AE6             4777  ;
041AE6             4778  ; GROUP 13 - CALL
041AE6             4779  ;
041AE6 D6 01       4780  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041AE8 30 0C       4781  			JR	NC,GROUP14
041AEA CD 2F 1C 04 4782  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041AEE CD 11 1B 04 4783  			CALL    GROUP15_1		; Output the opcode (with conditions)
041AF2 C3 6C 1C 04 4784  			JP	ADDR_			; Output the address
041AF6             4785  ;
041AF6             4786  ; GROUP 14 - RST
041AF6             4787  ;
041AF6 D6 01       4788  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041AF8 30 13       4789  			JR	NC,GROUP15
041AFA CD 2F 1C 04 4790  			CALL	EZ80SF_FULL		; Evaluate the suffix
041AFE D8          4791  			RET	C			; Exit if an invalid suffix provided
041AFF CD 03 1D 04 4792  			CALL    NUMBER
041B03 A1          4793  			AND     C
041B04 B4          4794  			OR      H
041B05 20 AF       4795  			JR      NZ,TOOFAR
041B07 7D          4796  			LD      A,L
041B08 B1          4797  			OR      C
041B09 C3 F2 1C 04 4798  	  		JP      BYTE_
041B0D             4799  ;
041B0D             4800  ; GROUP 15 - RET
041B0D             4801  ;
041B0D D6 01       4802  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B0F 30 0F       4803  			JR	NC,GROUP16
041B11 CD 31 1D 04 4804  GROUP15_1:		CALL    COND_
041B15 79          4805  			LD      A,C
041B16 D2 F2 1C 04 4806  			JP      NC,BYTE_
041B1A F6 09       4807  			OR      9
041B1C C3 F2 1C 04 4808  			JP      BYTE_
041B20             4809  ;
041B20             4810  ; GROUP 16 - LD
041B20             4811  ;
041B20 D6 01       4812  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B22 30 74       4813  			JR	NC,GROUP17
041B24 CD 2F 1C 04 4814  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B28 CD 60 1D 04 4815  			CALL    LDOP			; Check for accumulator loads
041B2C D2 8C 1C 04 4816  			JP      NC,LDA			; Yes, so jump here
041B30 CD 2A 1D 04 4817  			CALL    REGHI
041B34 08          4818  			EX      AF,AF'
041B35 CD B5 1D 04 4819  			CALL    SKIP
041B39 FE 28       4820  			CP      '('			; Check for bracket
041B3B 28 24       4821  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B3D 08          4822  			EX      AF,AF'
041B3E D2 F6 19 04 4823  			JP      NC,GROUP05_1		; Load single register direct; go here
041B42 0E 01       4824  			LD      C,1
041B44 CD 4A 1D 04 4825  			CALL    PAIR1_EX
041B48 D8          4826  			RET     C
041B49 3E 0E       4827  			LD      A,14
041B4B B8          4828  			CP      B
041B4C 47          4829  			LD      B,A
041B4D CC 45 1D 04 4830  			CALL    Z,PAIR_EX
041B51 78          4831  			LD      A,B
041B52 E6 3F       4832  			AND     3FH
041B54 FE 0C       4833  			CP      12
041B56 79          4834  			LD      A,C
041B57 C2 DE 1A 04 4835  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B5B 3E F9       4836  			LD      A,0F9H
041B5D C3 F2 1C 04 4837  			JP      BYTE_
041B61             4838  ;
041B61 08          4839  LDIN:			EX      AF,AF'
041B62 C5          4840  			PUSH    BC
041B63 D4 23 1D 04 4841  			CALL    NC,REGLO
041B67 79          4842  			LD      A,C
041B68 C1          4843  			POP     BC
041B69 D2 C3 1C 04 4844  			JP      NC,BIND
041B6D 0E 0A       4845  			LD      C,0AH
041B6F CD 4A 1D 04 4846  			CALL    PAIR1_EX
041B73 CD 97 1C 04 4847  			CALL    LD16
041B77 D2 DE 1A 04 4848  			JP      NC,GROUP12_1
041B7B CD 03 1D 04 4849  			CALL    NUMBER
041B7F 0E 02       4850  			LD      C,2
041B81 CD 45 1D 04 4851  			CALL    PAIR_EX
041B85 CD 97 1C 04 4852  			CALL    LD16
041B89 D8          4853  			RET     C
041B8A CD F2 1C 04 4854  			CALL    BYTE_
041B8E CB 7A       4855  			BIT	7,D			; Check the ADL flag
041B90 C2 81 1C 04 4856  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041B94 C3 74 1C 04 4857  			JP      VAL16			; Otherwise use 16-bit addresses
041B98             4858  ;
041B98             4859  ; Group 17 - TST
041B98             4860  ;
041B98 D6 01       4861  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041B9A 30 25       4862  			JR	NC,OPTS
041B9C CD BD 1C 04 4863  			CALL	ED			; Needs to be prefixed with ED
041BA0 CD 17 1D 04 4864  			CALL	REG			; Fetch the register
041BA4 30 0E       4865  			JR	NC,GROUP17_1		; It's just a register
041BA6             4866  ;
041BA6 3E 64       4867  			LD	A,64H			; Opcode for TST n
041BA8 CD F2 1C 04 4868  			CALL	BYTE_			; Write out the opcode
041BAC CD 03 1D 04 4869  			CALL	NUMBER			; Get the number
041BB0 C3 BC 1A 04 4870  			JP	VAL8			; And write that out
041BB4             4871  ;
041BB4 78          4872  GROUP17_1:		LD	A,B			; Check the register rangs
041BB5 FE 08       4873  			CP	8
041BB7 3F          4874  			CCF
041BB8 D8          4875  			RET	C			; Ret with carry flag set for error if out of range
041BB9 07          4876  			RLCA				; Get the opcode value
041BBA 07          4877  			RLCA
041BBB 07          4878  			RLCA
041BBC 81          4879  			ADD	A,C			; Add the opcode base in
041BBD C3 F2 1C 04 4880  			JP	BYTE_
041BC1             4881  
041BC1             4882  ;
041BC1             4883  ; Assembler directives - OPT, ADL
041BC1             4884  ;
041BC1 D6 02       4885  OPTS:			SUB	2
041BC3 30 2B       4886  			JR	NC, DEFS
041BC5 FE FF       4887  			CP	1-2			; Check for ADL opcode
041BC7 28 13       4888  			JR	Z, ADL_
041BC9             4889  ;
041BC9 CD 03 1D 04 4890  OPT:			CALL    NUMBER			; Fetch the OPT value
041BCD 21 40 4D 04 4891  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041BD1 E6 07       4892  			AND	7			; Only interested in the first three bits
041BD3 4F          4893  			LD      C,A			; Store the new OPT value in C
041BD4 ED 6F       4894  			RLD				; Shift the top nibble of LISTON (OPT) into A
041BD6 E6 08       4895  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041BD8 B1          4896  			OR	C			; OR in the new value
041BD9 ED 67       4897  			RRD				; And shift the nibble back in
041BDB C9          4898  			RET
041BDC             4899  ;
041BDC CD 03 1D 04 4900  ADL_:			CALL	NUMBER			; Fetch the ADL value
041BE0 E6 01       4901  			AND	1			; Only interested if it is 0 or 1
041BE2 0F          4902  			RRCA				; Rotate to bit 7
041BE3 4F          4903  			LD	C,A			; Store in C
041BE4 3A 40 4D 04 4904  			LD	A,(LISTON)		; Get the LISTON system variable
041BE8 E6 7F       4905  			AND	7Fh			; Clear bit 7
041BEA B1          4906  			OR	C			; OR in the ADL value
041BEB 32 40 4D 04 4907  			LD	(LISTON),A		; Store
041BEF C9          4908  			RET
041BF0             4909  ;
041BF0             4910  ; DEFB, DEFW, DEFL, DEFM
041BF0             4911  ;
041BF0 B7          4912  DEFS:			OR	A			; Handle DEFB
041BF1 CA 03 1A 04 4913  			JP	Z, DB_
041BF5 3D          4914  			DEC	A			; Handle DEFW
041BF6 CA 70 1C 04 4915  			JP	Z, ADDR16
041BFA 3D          4916  			DEC	A			; Handle DEFL
041BFB CA 7D 1C 04 4917  			JP	Z, ADDR24
041BFF             4918  ;
041BFF DD E5       4919  			PUSH    IX			; Handle DEFM
041C01 CD 15 03 04 4920  			CALL    EXPRS
041C05 DD E1       4921  			POP     IX
041C07 21 00 4A 04 4922  			LD      HL,ACCS
041C0B AF          4923  @@:			XOR     A
041C0C BB          4924  			CP      E
041C0D C8          4925  			RET     Z
041C0E 7E          4926  			LD      A,(HL)
041C0F 23          4927  			INC     HL
041C10 CD F2 1C 04 4928  			CALL    BYTE_
041C14 1D          4929  			DEC     E
041C15 18 F4       4930  			JR      @B
041C17             4931  
041C17             4932  ;
041C17             4933  ;SUBROUTINES:
041C17             4934  ;
041C17 FD 7E 00    4935  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C1A FE 2E       4936  			CP	'.'
041C1C 28 02       4937  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C1E B7          4938  			OR	A			; Reset the carry flag (no error)
041C1F C9          4939  			RET				; And return
041C20 FD 23       4940  @@:			INC	IY			; Skip the dot
041C22 C5          4941  			PUSH	BC			; Push the operand
041C23 21 4B 20 04 4942  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C27 CD 64 1D 04 4943  			CALL	FIND			; Look up the operand
041C2B 30 24       4944  			JR	NC,EZ80SF_OK
041C2D C1          4945  			POP	BC			; Not found at this point, so will return with a C (error)
041C2E C9          4946  			RET
041C2F             4947  ;
041C2F FD 7E 00    4948  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C32 FE 2E       4949  			CP	'.'
041C34 28 02       4950  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C36 B7          4951  			OR	A			; Reset the carry flag (no error)
041C37 C9          4952  			RET				; And return
041C38 FD 23       4953  @@:			INC	IY 			; Skip the dot
041C3A C5          4954  			PUSH	BC			; Push the operand
041C3B 21 43 20 04 4955  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C3F CD 64 1D 04 4956  			CALL	FIND 			; Look up the operand
041C43 30 0C       4957  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C45 CD 60 1C 04 4958  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C49 CD 64 1D 04 4959  			CALL	FIND
041C4D 30 02       4960  			JR	NC,EZ80SF_OK
041C4F C1          4961  			POP	BC			; Not found at this point, so will return with a C (error)
041C50 C9          4962  			RET
041C51             4963  ;
041C51 78          4964  EZ80SF_OK:		LD	A,B			; The operand value
041C52 D4 F2 1C 04 4965  			CALL	NC,BYTE_ 		; Write it out if found
041C56 CB BA       4966  			RES	7,D			; Clear the default ADL mode from the flags
041C58 E6 02       4967  			AND	2			; Check the second half of the suffix (.xxL)
041C5A 0F          4968  			RRCA				; Shift into bit 7
041C5B 0F          4969  			RRCA
041C5C B2          4970  			OR	D			; Or into bit 7 of D
041C5D 57          4971  			LD	D,A
041C5E C1          4972  			POP	BC 			; Restore the operand
041C5F C9          4973  			RET
041C60             4974  ;
041C60 21 54 20 04 4975  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C64 CB 7A       4976  			BIT 	7,D			; if bit 7 of D is 0
041C66 C8          4977  			RET	Z
041C67 21 5F 20 04 4978  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041C6B C9          4979  			RET
041C6C             4980  ;
041C6C CB 7A       4981  ADDR_:			BIT	7,D			; Check the ADL flag
041C6E 20 0D       4982  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041C70             4983  ;
041C70 CD 03 1D 04 4984  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041C74 CD BC 1A 04 4985  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041C78 7C          4986  			LD      A,H
041C79 C3 F2 1C 04 4987  			JP      BYTE_
041C7D             4988  ;
041C7D CD 03 1D 04 4989  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041C81 CD 74 1C 04 4990  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041C85 D9          4991  			EXX
041C86 7D          4992  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041C87 D9          4993  			EXX
041C88 C3 F2 1C 04 4994  			JP	BYTE_
041C8C             4995  ;
041C8C FE 04       4996  LDA:			CP      4
041C8E DC BD 1C 04 4997  			CALL    C,ED
041C92 78          4998  			LD      A,B
041C93 C3 F2 1C 04 4999  			JP      BYTE_
041C97             5000  ;
041C97 78          5001  LD16:			LD      A,B
041C98 38 0F       5002  			JR      C,LD8
041C9A 78          5003  			LD      A,B
041C9B E6 3F       5004  			AND     3FH
041C9D FE 0C       5005  			CP      12
041C9F 79          5006  			LD      A,C
041CA0 C8          5007  			RET     Z
041CA1 CD BD 1C 04 5008  			CALL    ED
041CA5 79          5009  			LD      A,C
041CA6 F6 43       5010  			OR      43H
041CA8 C9          5011  			RET
041CA9             5012  ;
041CA9 FE 07       5013  LD8:			CP      7
041CAB 37          5014  			SCF
041CAC C0          5015  			RET     NZ
041CAD 79          5016  			LD      A,C
041CAE F6 30       5017  			OR      30H
041CB0 C9          5018  			RET
041CB1             5019  ;
041CB1             5020  ; Used in IN and OUT to handle whether the operand is C or a number
041CB1             5021  ;
041CB1 C5          5022  CORN:			PUSH    BC
041CB2 CD D1 1C 04 5023  			CALL    OPND			; Get the operand
041CB6 CB 68       5024  			BIT     5,B
041CB8 C1          5025  			POP     BC
041CB9 28 48       5026  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CBB 26 FF       5027  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CBD             5028  ;
041CBD 3E ED       5029  ED:			LD      A,0EDH			; Write an ED prefix out
041CBF 18 31       5030  			JR      BYTE_
041CC1             5031  ;
041CC1 3E CB       5032  CB:			LD      A,0CBH
041CC3 FE 76       5033  BIND:			CP      76H
041CC5 37          5034  			SCF
041CC6 C8          5035  			RET     Z               	; Reject LD (HL),(HL)
041CC7 CD F2 1C 04 5036  			CALL    BYTE_
041CCB CB 72       5037  			BIT	6,D			; Check the index bit in flags
041CCD C8          5038  			RET     Z
041CCE 7B          5039  			LD      A,E			; If there is an index, output the offset
041CCF 18 21       5040  			JR      BYTE_
041CD1             5041  ;
041CD1             5042  ; Search through the operand table
041CD1             5043  ; Returns:
041CD1             5044  ; - B: The operand type
041CD1             5045  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041CD1             5046  ; - E: The IX/IY offset
041CD1             5047  ; - F: Carry if not found
041CD1             5048  ;
041CD1 E5          5049  OPND:			PUSH    HL			; Preserve HL
041CD2 21 D5 1F 04 5050  			LD      HL,OPRNDS		; The operands table
041CD6 CD 64 1D 04 5051  			CALL    FIND			; Find the operand
041CDA E1          5052  			POP     HL
041CDB D8          5053  			RET     C			; Return if not found
041CDC CB 78       5054  			BIT     7,B			; Check if it is an index register (IX, IY)
041CDE C8          5055  			RET     Z			; Return if it isn't
041CDF CB F2       5056  			SET	6,D			; Set flag to indicate we've got an index
041CE1 CB 58       5057  			BIT     3,B			; Check if an offset is required
041CE3 E5          5058  			PUSH    HL
041CE4 CC F9 1C 04 5059  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041CE8 5D          5060  			LD      E,L			; E: The offset
041CE9 E1          5061  			POP     HL
041CEA 3E DD       5062  			LD	A,DDH			; IX prefix
041CEC CB 70       5063  			BIT     6,B			; If bit 6 is reset then
041CEE 28 02       5064  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041CF0 3E FD       5065  			LD	A,FDH			; IY prefix
041CF2             5066  ;
041CF2 DD 77 00    5067  BYTE_:			LD      (IX),A			; Write a byte out
041CF5 DD 23       5068  			INC     IX
041CF7 B7          5069  			OR      A
041CF8 C9          5070  			RET
041CF9             5071  ;
041CF9 FD 7E 00    5072  OFFSET_EX:			LD      A,(IY)
041CFC FE 29       5073  			CP      ')'
041CFE 21 00 00 00 5074  			LD      HL,0
041D02 C8          5075  			RET     Z
041D03 CD B5 1D 04 5076  NUMBER:			CALL    SKIP
041D07 C5          5077  			PUSH    BC
041D08 D5          5078  			PUSH    DE
041D09 DD E5       5079  			PUSH    IX
041D0B CD 0A 03 04 5080  			CALL    EXPRI
041D0F DD E1       5081  			POP     IX
041D11 D9          5082  			EXX
041D12 D1          5083  			POP     DE
041D13 C1          5084  			POP     BC
041D14 7D          5085  			LD      A,L
041D15 B7          5086  			OR      A
041D16 C9          5087  			RET
041D17             5088  ;
041D17 CD D1 1C 04 5089  REG:			CALL    OPND
041D1B D8          5090  			RET     C
041D1C 78          5091  			LD      A,B
041D1D E6 3F       5092  			AND     3FH
041D1F FE 08       5093  			CP      8
041D21 3F          5094  			CCF
041D22 C9          5095  			RET
041D23             5096  ;
041D23 CD 17 1D 04 5097  REGLO:			CALL    REG
041D27 D8          5098  			RET     C
041D28 18 33       5099  			JR      ORC
041D2A             5100  ;
041D2A CD 17 1D 04 5101  REGHI:			CALL    REG
041D2E D8          5102  			RET     C
041D2F 18 29       5103  			JR      SHL3
041D31             5104  ;
041D31 CD D1 1C 04 5105  COND_:			CALL    OPND
041D35 D8          5106  			RET     C
041D36 78          5107  			LD      A,B
041D37 E6 1F       5108  			AND     1FH
041D39 D6 10       5109  			SUB     16
041D3B 30 1D       5110  			JR      NC,SHL3
041D3D FE F1       5111  			CP      -15
041D3F 37          5112  			SCF
041D40 C0          5113  			RET     NZ
041D41 3E 03       5114  			LD      A,3
041D43 18 15       5115  			JR      SHL3
041D45             5116  ;
041D45 CD D1 1C 04 5117  PAIR_EX:			CALL    OPND
041D49 D8          5118  			RET     C
041D4A 78          5119  PAIR1_EX:			LD      A,B
041D4B E6 0F       5120  			AND     0FH
041D4D D6 08       5121  			SUB     8
041D4F D8          5122  			RET     C
041D50 18 08       5123  			JR      SHL3
041D52             5124  ;
041D52 CD 03 1D 04 5125  BIT_:			CALL    NUMBER
041D56 FE 08       5126  			CP      8
041D58 3F          5127  			CCF
041D59 D8          5128  			RET     C
041D5A 07          5129  SHL3:			RLCA
041D5B 07          5130  			RLCA
041D5C 07          5131  			RLCA
041D5D B1          5132  ORC:			OR      C
041D5E 4F          5133  			LD      C,A
041D5F C9          5134  			RET
041D60             5135  ;
041D60 21 1A 20 04 5136  LDOP:			LD      HL,LDOPS
041D64             5137  
041D64             5138  ;
041D64             5139  ; Look up a value in a table
041D64             5140  ; Parameters:
041D64             5141  ; - IY: Address of the assembly language line in the BASIC program area
041D64             5142  ; - HL: Address of the table
041D64             5143  ; Returns:
041D64             5144  ; - B: The operand code
041D64             5145  ; - F: Carry set if not found
041D64             5146  ;
041D64 CD B5 1D 04 5147  FIND:			CALL    SKIP			; Skip delimiters
041D68             5148  ;
041D68 06 00       5149  EXIT_:			LD      B,0			; Set B to 0
041D6A 37          5150  			SCF				; Set the carry flag
041D6B C8          5151  			RET     Z			; Returns if Z
041D6C             5152  ;
041D6C FE DD       5153  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041D6E 28 04       5154  			JR      Z,FIND0
041D70 FE 85       5155  			CP      TOR+1			; Special case for tokens AND and OR
041D72 3F          5156  			CCF
041D73 D8          5157  			RET     C
041D74 7E          5158  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041D75 B7          5159  			OR      A
041D76 28 F0       5160  			JR      Z,EXIT_			; Exit
041D78 FD AE 00    5161  			XOR     (IY)
041D7B E6 5F       5162  			AND     01011111B
041D7D 28 09       5163  			JR      Z,FIND2
041D7F CB 7E       5164  FIND1:			BIT     7,(HL)
041D81 23          5165  			INC     HL
041D82 28 FB       5166  			JR      Z,FIND1
041D84 23          5167  			INC     HL
041D85 04          5168  			INC     B
041D86 18 EC       5169  			JR      FIND0
041D88             5170  ;
041D88 FD E5       5171  FIND2:			PUSH    IY
041D8A CB 7E       5172  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041D8C FD 23       5173  			INC     IY
041D8E 23          5174  			INC     HL
041D8F 20 11       5175  			JR      NZ,FIND5		; Yes
041D91 BE          5176  			CP      (HL)
041D92 CC B4 1D 04 5177  			CALL    Z,SKIP0
041D96 7E          5178  			LD      A,(HL)
041D97 FD AE 00    5179  			XOR     (IY)
041D9A E6 5F       5180  			AND     01011111B
041D9C 28 EC       5181  			JR      Z,FIND3
041D9E FD E1       5182  FIND4:			POP     IY
041DA0 18 DD       5183  			JR      FIND1
041DA2             5184  ;
041DA2 CD 66 17 04 5185  FIND5:			CALL    DELIM			; Is it a delimiter?
041DA6 C4 C9 1D 04 5186  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DAA C4 C3 1D 04 5187  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DAE 20 EE       5188  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DB0             5189  ;
041DB0 78          5190  FIND6:			LD      A,B			; At this point we have a token
041DB1 46          5191  			LD      B,(HL)			; Fetch the token type code
041DB2 E1          5192  			POP     HL			; Restore the stack
041DB3 C9          5193  			RET
041DB4             5194  ;
041DB4 23          5195  SKIP0:			INC     HL
041DB5 CD 66 17 04 5196  SKIP:			CALL    DELIM			; Is it a delimiter?
041DB9 C0          5197  			RET     NZ			; No, so return
041DBA CD 72 17 04 5198  			CALL    TERM			; Is it a terminator?
041DBE C8          5199  			RET     Z			; Yes, so return
041DBF FD 23       5200  			INC     IY			; Increment the basic program counter
041DC1 18 F2       5201  			JR      SKIP			; And loop
041DC3             5202  ;
041DC3 FE 2B       5203  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DC5 C8          5204  			RET     Z
041DC6 FE 2D       5205  			CP      '-'
041DC8 C9          5206  			RET
041DC9             5207  ;
041DC9 FE 2E       5208  DOT:			CP	'.'			; Check if it is a dot character
041DCB C9          5209  			RET
041DCC             5210  ; Z80 opcode list
041DCC             5211  ;
041DCC             5212  ; Group 0: (15 opcodes)
041DCC             5213  ; Trivial cases requiring no computation
041DCC             5214  ;
041DCC             5215  ; BEGIN REFACTOR FROM BINARY
041DCC             5216  ; OPCODS:
041DCC             5217  ; 			DB	"NO","P"+80H,00h	; # 00h
041DCC             5218  ; 			DB	"RLC","A"+80H,07h
041DCC             5219  ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
041DCC             5220  ; 			DB	"RRC","A"+80H,0FH
041DCC             5221  ; 			DB	"RL","A"+80H,17H
041DCC             5222  ; 			DB	"RR","A"+80H,1FH
041DCC             5223  ; 			DB	"DA","A"+80H,27H
041DCC             5224  ; 			DB	"CP","L"+80H,2FH
041DCC             5225  ; 			DB	"SC","F"+80H,37H
041DCC             5226  ; 			DB	"CC","F"+80H,3FH
041DCC             5227  ; 			DB	"HAL","T"+80H,76H
041DCC             5228  ; 			DB	"EX","X"+80H,D9H
041DCC             5229  ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
041DCC             5230  ; 			DB	"D","I"+80H,F3H
041DCC             5231  ; 			DB	"E","I"+80H,FBH
041DCC             5232  ; ;
041DCC             5233  ; ; Group 1: (53 opcodes)
041DCC             5234  ; ; As Group 0, but with an ED prefix
041DCC             5235  ; ;
041DCC             5236  ; 			DB	"NE","G"+80H,44H	; 0Fh
041DCC             5237  ; 			DB	"IM",0,"0"+80H,46H
041DCC             5238  ; 			DB	"RET","N"+80H,45H
041DCC             5239  ; 			DB	"MLT",0,"B","C"+80H,4CH
041DCC             5240  ; 			DB	"RET","I"+80H,4DH
041DCC             5241  ; 			DB	"IM",0,"1"+80H,56H
041DCC             5242  ; 			DB	"MLT",0,"D","E"+80H,5CH
041DCC             5243  ; 			DB	"IM",0,"2"+80H,5EH
041DCC             5244  ; 			DB	"RR","D"+80H,67H
041DCC             5245  ; 			DB	"MLT",0,"H","L"+80H,6CH
041DCC             5246  ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
041DCC             5247  ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
041DCC             5248  ; 			DB	"RL","D"+80H,6FH
041DCC             5249  ; 			DB	"SL","P"+80H,76H
041DCC             5250  ; 			DB	"MLT",0,"S","P"+80H,7CH
041DCC             5251  ; 			DB	"STMI","X"+80H,7DH
041DCC             5252  ; 			DB	"RSMI","X"+80H,7EH
041DCC             5253  ; 			DB	"INI","M"+80H,82H
041DCC             5254  ; 			DB	"OTI","M"+80H,83H
041DCC             5255  ; 			DB	"INI","2"+80H,84H
041DCC             5256  ; 			DB	"IND","M"+80H,8AH
041DCC             5257  ; 			DB	"OTD","M"+80H,8BH
041DCC             5258  ; 			DB	"IND","2"+80H,8CH
041DCC             5259  ; 			DB	"INIM","R"+80H,92H
041DCC             5260  ; 			DB	"OTIM","R"+80H,93H
041DCC             5261  ; 			DB	"INI2","R"+80H,94H
041DCC             5262  ; 			DB	"INDM","R"+80H,9AH
041DCC             5263  ; 			DB	"OTDM","R"+80H,9BH
041DCC             5264  ; 			DB	"IND2","R"+80H,9CH
041DCC             5265  ; 			DB	"LD","I"+80H,A0H
041DCC             5266  ; 			DB	"CP","I"+80H,A1H
041DCC             5267  ; 			DB	"IN","I"+80H,A2H
041DCC             5268  ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041DCC             5269  ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041DCC             5270  ; 			DB	"LD","D"+80H,A8H
041DCC             5271  ; 			DB	"CP","D"+80H,A9H
041DCC             5272  ; 			DB	"IN","D"+80H,AAH
041DCC             5273  ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041DCC             5274  ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041DCC             5275  ; 			DB	"LDI","R"+80H,B0H
041DCC             5276  ; 			DB	"CPI","R"+80H,B1H
041DCC             5277  ; 			DB	"INI","R"+80H,B2H
041DCC             5278  ; 			DB	"OTI","R"+80H,B3H
041DCC             5279  ; 			DB	"OTI2","R"+80H,B4H
041DCC             5280  ; 			DB	"LDD","R"+80H,B8H
041DCC             5281  ; 			DB	"CPD","R"+80H,B9H
041DCC             5282  ; 			DB	"IND","R"+80H,BAH
041DCC             5283  ; 			DB	"OTD","R"+80H,BBH
041DCC             5284  ; 			DB	"OTD2","R"+80H,BCH
041DCC             5285  ; 			DB	"INIR","X"+80H,C2H
041DCC             5286  ; 			DB	"OTIR","X"+80H,C3H
041DCC             5287  ; 			DB	"INDR","X"+80H,CAH
041DCC             5288  ; 			DB	"OTDR","X"+80H,CBH
041DCC             5289  ; ;
041DCC             5290  ; ; Group 2: (3 opcodes)
041DCC             5291  ; ;
041DCC             5292  ; 			DB	"BI","T"+80H,40H	; 44h
041DCC             5293  ; 			DB	"RE","S"+80H,80H
041DCC             5294  ; 			DB	"SE","T"+80H,C0H
041DCC             5295  ; ;
041DCC             5296  ; ; Group 3: (7 opcodes)
041DCC             5297  ; ;
041DCC             5298  ; 			DB	"RL","C"+80H,00H	; 47h
041DCC             5299  ; 			DB	"RR","C"+80H,08H
041DCC             5300  ; 			DB	"R","L"+80H,10H
041DCC             5301  ; 			DB	"R","R"+80H,18H
041DCC             5302  ; 			DB	"SL","A"+80H,20H
041DCC             5303  ; 			DB	"SR","A"+80H,28H
041DCC             5304  ; 			DB	"SR","L"+80H,38H
041DCC             5305  ; ;
041DCC             5306  ; ; Group 4: (3 opcodes)
041DCC             5307  ; ;
041DCC             5308  ; 			DB	"PO","P"+80H,C1H	; 4Eh
041DCC             5309  ; 			DB	"PUS","H"+80H,C5H
041DCC             5310  ; 			DB	"EX",0,"(S","P"+80H,E3H
041DCC             5311  ; ;
041DCC             5312  ; ; Group 5: (7 opcodes)
041DCC             5313  ; ;
041DCC             5314  ; 			DB	"SU","B"+80H,90H	; 51h
041DCC             5315  ; 			DB	"AN","D"+80H,A0H
041DCC             5316  ; 			DB	"XO","R"+80H,A8H
041DCC             5317  ; 			DB	"O","R"+80H,B0H
041DCC             5318  ; 			DB	"C","P"+80H,B8H
041DCC             5319  ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
041DCC             5320  ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
041DCC             5321  ; ;
041DCC             5322  ; ; Group 6 (3 opcodes)
041DCC             5323  ; ;
041DCC             5324  ; 			DB	"AD","D"+80H,80H	; 58h
041DCC             5325  ; 			DB	"AD","C"+80H,88H
041DCC             5326  ; 			DB	"SB","C"+80H,98H
041DCC             5327  ; ;
041DCC             5328  ; ; Group 7: (2 opcodes)
041DCC             5329  ; ;
041DCC             5330  ; 			DB	"IN","C"+80H,04H	; 5Bh
041DCC             5331  ; 			DB	"DE","C"+80H,05H
041DCC             5332  ; ;
041DCC             5333  ; ; Group 8: (2 opcodes)
041DCC             5334  ; ;
041DCC             5335  ; 			DB	"IN","0"+80H,00H	; 5Dh
041DCC             5336  ; 			DB	"OUT","0"+80H,01H
041DCC             5337  ; ;
041DCC             5338  ; ; Group 9: (1 opcode)
041DCC             5339  ; ;
041DCC             5340  ; 			DB	"I","N"+80H,40H		; 5Fh
041DCC             5341  ; ;
041DCC             5342  ; ; Group 10: (1 opcode)
041DCC             5343  ; ;
041DCC             5344  ; 			DB	"OU","T"+80H,41H	; 60h
041DCC             5345  ; ;
041DCC             5346  ; ; Group 11: (2 opcodes)
041DCC             5347  ; ;
041DCC             5348  ; 			DB	"J","R"+80H,20H		; 61h
041DCC             5349  ; 			DB	"DJN","Z"+80H,10H
041DCC             5350  ; ;
041DCC             5351  ; ; Group 12: (1 opcode)
041DCC             5352  ; ;
041DCC             5353  ; 			DB	"J","P"+80H,C2H		; 63h
041DCC             5354  ; ;
041DCC             5355  ; ; Group 13: (1 opcode)
041DCC             5356  ; ;
041DCC             5357  ; 			DB	"CAL","L"+80H,C4H	; 64h
041DCC             5358  ; ;
041DCC             5359  ; ; Group 14: (1 opcode)
041DCC             5360  ; ;
041DCC             5361  ; 			DB	"RS","T"+80H,C7H	; 65h
041DCC             5362  ; ;
041DCC             5363  ; ; Group 15: (1 opcode)
041DCC             5364  ; ;
041DCC             5365  ; 			DB	"RE","T"+80H,C0H	; 66h
041DCC             5366  ; ;
041DCC             5367  ; ; Group 16: (1 opcode)
041DCC             5368  ; ;
041DCC             5369  ; 			DB	"L","D"+80H,40H		; 67h
041DCC             5370  ; ;
041DCC             5371  ; ; Group 17: (1 opcode)
041DCC             5372  ; ;
041DCC             5373  ; 			DB	"TS","T"+80H,04H	; 68h
041DCC             5374  
041DCC             5375  ; ;
041DCC             5376  ; ; Assembler Directives
041DCC             5377  ; ;
041DCC             5378  ; 			DB	"OP","T"+80H,00H	; 69h OPT
041DCC             5379  ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
041DCC             5380  ; ;
041DCC             5381  ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041DCC             5382  ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041DCC             5383  ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041DCC             5384  ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
041DCC             5385  ; ;
041DCC             5386  ; 			DB	0
041DCC             5387  ; ;
041DCC             5388  ; ; Operands
041DCC             5389  ; ;
041DCC             5390  ; OPRNDS:			DB	"B"+80H, 00H
041DCC             5391  ; 			DB	"C"+80H, 01H
041DCC             5392  ; 			DB	"D"+80H, 02H
041DCC             5393  ; 			DB	"E"+80H, 03H
041DCC             5394  ; 			DB	"H"+80H, 04H
041DCC             5395  ; 			DB	"L"+80H, 05H
041DCC             5396  ; 			DB	"(H","L"+80H,06H
041DCC             5397  ; 			DB	"A"+80H, 07H
041DCC             5398  ; 			DB	"(I","X"+80H,86H
041DCC             5399  ; 			DB	"(I","Y"+80H,C6H
041DCC             5400  ; ;
041DCC             5401  ; 			DB	"B","C"+80H,08H
041DCC             5402  ; 			DB	"D","E"+80H,0AH
041DCC             5403  ; 			DB	"H","L"+80H,0CH
041DCC             5404  ; 			DB	"I","X"+80H,8CH
041DCC             5405  ; 			DB	"I","Y"+80H,CCH
041DCC             5406  ; 			DB	"A","F"+80H,0EH
041DCC             5407  ; 			DB	"S","P"+80H,0EH
041DCC             5408  ; ;
041DCC             5409  ; 			DB	"N","Z"+80H,10H
041DCC             5410  ; 			DB	"Z"+80H,11H
041DCC             5411  ; 			DB	"N","C"+80H,12H
041DCC             5412  ; 			DB	"P","O"+80H,14H
041DCC             5413  ; 			DB	"P","E"+80H,15H
041DCC             5414  ; 			DB	"P"+80H,16H
041DCC             5415  ; 			DB	"M"+80H,17H
041DCC             5416  ; ;
041DCC             5417  ; 			DB	"(","C"+80H,20H
041DCC             5418  ; ;
041DCC             5419  ; 			DB	0
041DCC             5420  ; ;
041DCC             5421  ; ; Load operations
041DCC             5422  ; ;
041DCC             5423  ; LDOPS:			DB	"I",0,"A"+80H,47H
041DCC             5424  ; 			DB	"R",0,"A"+80H,4FH
041DCC             5425  ; 			DB	"A",0,"I"+80H,57H
041DCC             5426  ; 			DB	"A",0,"R"+80H,5FH
041DCC             5427  ; 			DB	"(BC",0,"A"+80H,02h
041DCC             5428  ; 			DB	"(DE",0,"A"+80H,12H
041DCC             5429  ; 			DB	"A",0,"(B","C"+80H,0AH
041DCC             5430  ; 			DB	"A",0,"(D","E"+80H,1AH
041DCC             5431  ; ;
041DCC             5432  ; 			DB	0
041DCC             5433  ; ;
041DCC             5434  ; ; eZ80 addressing mode suffixes
041DCC             5435  ; ;
041DCC             5436  ; ; Fully qualified suffixes
041DCC             5437  ; ;
041DCC             5438  ; EZ80SFS_1:		DB	"LI","S"+80H,49H
041DCC             5439  ; 			DB	"SI","L"+80H,52H
041DCC             5440  ; EZ80SFS_2:		DB	"SI","S"+80H,40H
041DCC             5441  ; 			DB	"LI","L"+80H,5BH
041DCC             5442  ; ;
041DCC             5443  ; 			DB	0
041DCC             5444  ; ;
041DCC             5445  ; ; Shortcuts when ADL mode is 0
041DCC             5446  ; ;
041DCC             5447  ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
041DCC             5448  ; 			DB	"L"+80H,49H		; Equivalent to .LIS
041DCC             5449  ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
041DCC             5450  ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
041DCC             5451  ; ;
041DCC             5452  ; 			DB	0
041DCC             5453  ; ;
041DCC             5454  ; ; Shortcuts when ADL mode is 1
041DCC             5455  ; ;
041DCC             5456  ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
041DCC             5457  ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
041DCC             5458  ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
041DCC             5459  ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
041DCC             5460  ; ;
041DCC             5461  ; 			DB	0
041DCC             5462  ; END REFACTOR FROM BINARY
041DCC             5463  ; BEGIN INSERT FROM BINARY
041DCC             5464  ;
041DCC             5465  ; Trivial cases requiring no computation
041DCC             5466  OPCODS:
041DCC 4E          5467  	db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
041DCD 4F          5468  	db 0x4f ; 041DCD
041DCE D0          5469  	db 0xd0 ; 041DCE
041DCF 00          5470  	db 0x00 ; 041DCF
041DD0 52          5471  	db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
041DD1 4C          5472  	db 0x4c ; 041DD1
041DD2 43          5473  	db 0x43 ; 041DD2
041DD3 C1          5474  	db 0xc1 ; 041DD3
041DD4 07          5475  	db 0x07 ; 041DD4
041DD5 45          5476  	db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
041DD6 58          5477  	db 0x58 ; 041DD6
041DD7 00          5478  	db 0x00 ; 041DD7
041DD8 41          5479  	db 0x41 ; 041DD8
041DD9 46          5480  	db 0x46 ; 041DD9
041DDA 00          5481  	db 0x00 ; 041DDA
041DDB 41          5482  	db 0x41 ; 041DDB
041DDC 46          5483  	db 0x46 ; 041DDC
041DDD A7          5484  	db 0xa7 ; 041DDD
041DDE 08          5485  	db 0x08 ; 041DDE
041DDF 52          5486  	db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
041DE0 52          5487  	db 0x52 ; 041DE0
041DE1 43          5488  	db 0x43 ; 041DE1
041DE2 C1          5489  	db 0xc1 ; 041DE2
041DE3 0F          5490  	db 0x0f ; 041DE3
041DE4 52          5491  	db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
041DE5 4C          5492  	db 0x4c ; 041DE5
041DE6 C1          5493  	db 0xc1 ; 041DE6
041DE7 17          5494  	db 0x17 ; 041DE7
041DE8 52          5495  	db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
041DE9 52          5496  	db 0x52 ; 041DE9
041DEA C1          5497  	db 0xc1 ; 041DEA
041DEB 1F          5498  	db 0x1f ; 041DEB
041DEC 44          5499  	db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
041DED 41          5500  	db 0x41 ; 041DED
041DEE C1          5501  	db 0xc1 ; 041DEE
041DEF 27          5502  	db 0x27 ; 041DEF
041DF0 43          5503  	db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
041DF1 50          5504  	db 0x50 ; 041DF1
041DF2 CC          5505  	db 0xcc ; 041DF2
041DF3 2F          5506  	db 0x2f ; 041DF3
041DF4 53          5507  	db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
041DF5 43          5508  	db 0x43 ; 041DF5
041DF6 C6          5509  	db 0xc6 ; 041DF6
041DF7 37          5510  	db 0x37 ; 041DF7
041DF8 43          5511  	db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
041DF9 43          5512  	db 0x43 ; 041DF9
041DFA C6          5513  	db 0xc6 ; 041DFA
041DFB 3F          5514  	db 0x3f ; 041DFB
041DFC 48          5515  	db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
041DFD 41          5516  	db 0x41 ; 041DFD
041DFE 4C          5517  	db 0x4c ; 041DFE
041DFF D4          5518  	db 0xd4 ; 041DFF
041E00 76          5519  	db 0x76 ; 041E00
041E01 45          5520  	db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
041E02 58          5521  	db 0x58 ; 041E02
041E03 D8          5522  	db 0xd8 ; 041E03
041E04 D9          5523  	db 0xd9 ; 041E04
041E05 45          5524  	db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
041E06 58          5525  	db 0x58 ; 041E06
041E07 00          5526  	db 0x00 ; 041E07
041E08 44          5527  	db 0x44 ; 041E08
041E09 45          5528  	db 0x45 ; 041E09
041E0A 00          5529  	db 0x00 ; 041E0A
041E0B 48          5530  	db 0x48 ; 041E0B
041E0C CC          5531  	db 0xcc ; 041E0C
041E0D EB          5532  	db 0xeb ; 041E0D
041E0E 44          5533  	db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
041E0F C9          5534  	db 0xc9 ; 041E0F
041E10 F3          5535  	db 0xf3 ; 041E10
041E11 45          5536  	db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
041E12 C9          5537  	db 0xc9 ; 041E12
041E13 FB          5538  	db 0xfb ; 041E13
041E14             5539  ;
041E14             5540  ; Group 1: (53 opcodes)
041E14             5541  ; As Group 0, but with an ED prefix
041E14             5542  ;
041E14 4E          5543  	db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
041E15 45          5544  	db 0x45 ; 041E15
041E16 C7          5545  	db 0xc7 ; 041E16
041E17 44          5546  	db 0x44 ; 041E17
041E18 49          5547  	db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
041E19 4D          5548  	db 0x4d ; 041E19
041E1A 00          5549  	db 0x00 ; 041E1A
041E1B B0          5550  	db 0xb0 ; 041E1B
041E1C 46          5551  	db 0x46 ; 041E1C
041E1D 52          5552  	db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
041E1E 45          5553  	db 0x45 ; 041E1E
041E1F 54          5554  	db 0x54 ; 041E1F
041E20 CE          5555  	db 0xce ; 041E20
041E21 45          5556  	db 0x45 ; 041E21
041E22 4D          5557  	db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
041E23 4C          5558  	db 0x4c ; 041E23
041E24 54          5559  	db 0x54 ; 041E24
041E25 00          5560  	db 0x00 ; 041E25
041E26 42          5561  	db 0x42 ; 041E26
041E27 C3          5562  	db 0xc3 ; 041E27
041E28 4C          5563  	db 0x4c ; 041E28
041E29 52          5564  	db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
041E2A 45          5565  	db 0x45 ; 041E2A
041E2B 54          5566  	db 0x54 ; 041E2B
041E2C C9          5567  	db 0xc9 ; 041E2C
041E2D 4D          5568  	db 0x4d ; 041E2D
041E2E 49          5569  	db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
041E2F 4D          5570  	db 0x4d ; 041E2F
041E30 00          5571  	db 0x00 ; 041E30
041E31 B1          5572  	db 0xb1 ; 041E31
041E32 56          5573  	db 0x56 ; 041E32
041E33 4D          5574  	db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
041E34 4C          5575  	db 0x4c ; 041E34
041E35 54          5576  	db 0x54 ; 041E35
041E36 00          5577  	db 0x00 ; 041E36
041E37 44          5578  	db 0x44 ; 041E37
041E38 C5          5579  	db 0xc5 ; 041E38
041E39 5C          5580  	db 0x5c ; 041E39
041E3A 49          5581  	db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
041E3B 4D          5582  	db 0x4d ; 041E3B
041E3C 00          5583  	db 0x00 ; 041E3C
041E3D B2          5584  	db 0xb2 ; 041E3D
041E3E 5E          5585  	db 0x5e ; 041E3E
041E3F 52          5586  	db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
041E40 52          5587  	db 0x52 ; 041E40
041E41 C4          5588  	db 0xc4 ; 041E41
041E42 67          5589  	db 0x67 ; 041E42
041E43 4D          5590  	db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
041E44 4C          5591  	db 0x4c ; 041E44
041E45 54          5592  	db 0x54 ; 041E45
041E46 00          5593  	db 0x00 ; 041E46
041E47 48          5594  	db 0x48 ; 041E47
041E48 CC          5595  	db 0xcc ; 041E48
041E49 6C          5596  	db 0x6c ; 041E49
041E4A 4C          5597  	db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
041E4B 44          5598  	db 0x44 ; 041E4B
041E4C 00          5599  	db 0x00 ; 041E4C
041E4D 4D          5600  	db 0x4d ; 041E4D
041E4E 42          5601  	db 0x42 ; 041E4E
041E4F 00          5602  	db 0x00 ; 041E4F
041E50 C1          5603  	db 0xc1 ; 041E50
041E51 6D          5604  	db 0x6d ; 041E51
041E52 4C          5605  	db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
041E53 44          5606  	db 0x44 ; 041E53
041E54 00          5607  	db 0x00 ; 041E54
041E55 41          5608  	db 0x41 ; 041E55
041E56 00          5609  	db 0x00 ; 041E56
041E57 4D          5610  	db 0x4d ; 041E57
041E58 C2          5611  	db 0xc2 ; 041E58
041E59 6E          5612  	db 0x6e ; 041E59
041E5A 52          5613  	db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
041E5B 4C          5614  	db 0x4c ; 041E5B
041E5C C4          5615  	db 0xc4 ; 041E5C
041E5D 6F          5616  	db 0x6f ; 041E5D
041E5E 53          5617  	db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
041E5F 4C          5618  	db 0x4c ; 041E5F
041E60 D0          5619  	db 0xd0 ; 041E60
041E61 76          5620  	db 0x76 ; 041E61
041E62 4D          5621  	db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
041E63 4C          5622  	db 0x4c ; 041E63
041E64 54          5623  	db 0x54 ; 041E64
041E65 00          5624  	db 0x00 ; 041E65
041E66 53          5625  	db 0x53 ; 041E66
041E67 D0          5626  	db 0xd0 ; 041E67
041E68 7C          5627  	db 0x7c ; 041E68
041E69 53          5628  	db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
041E6A 54          5629  	db 0x54 ; 041E6A
041E6B 4D          5630  	db 0x4d ; 041E6B
041E6C 49          5631  	db 0x49 ; 041E6C
041E6D D8          5632  	db 0xd8 ; 041E6D
041E6E 7D          5633  	db 0x7d ; 041E6E
041E6F 52          5634  	db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
041E70 53          5635  	db 0x53 ; 041E70
041E71 4D          5636  	db 0x4d ; 041E71
041E72 49          5637  	db 0x49 ; 041E72
041E73 D8          5638  	db 0xd8 ; 041E73
041E74 7E          5639  	db 0x7e ; 041E74
041E75 49          5640  	db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
041E76 4E          5641  	db 0x4e ; 041E76
041E77 49          5642  	db 0x49 ; 041E77
041E78 CD          5643  	db 0xcd ; 041E78
041E79 82          5644  	db 0x82 ; 041E79
041E7A 4F          5645  	db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
041E7B 54          5646  	db 0x54 ; 041E7B
041E7C 49          5647  	db 0x49 ; 041E7C
041E7D CD          5648  	db 0xcd ; 041E7D
041E7E 83          5649  	db 0x83 ; 041E7E
041E7F 49          5650  	db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
041E80 4E          5651  	db 0x4e ; 041E80
041E81 49          5652  	db 0x49 ; 041E81
041E82 B2          5653  	db 0xb2 ; 041E82
041E83 84          5654  	db 0x84 ; 041E83
041E84 49          5655  	db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
041E85 4E          5656  	db 0x4e ; 041E85
041E86 44          5657  	db 0x44 ; 041E86
041E87 CD          5658  	db 0xcd ; 041E87
041E88 8A          5659  	db 0x8a ; 041E88
041E89 4F          5660  	db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
041E8A 54          5661  	db 0x54 ; 041E8A
041E8B 44          5662  	db 0x44 ; 041E8B
041E8C CD          5663  	db 0xcd ; 041E8C
041E8D 8B          5664  	db 0x8b ; 041E8D
041E8E 49          5665  	db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
041E8F 4E          5666  	db 0x4e ; 041E8F
041E90 44          5667  	db 0x44 ; 041E90
041E91 B2          5668  	db 0xb2 ; 041E91
041E92 8C          5669  	db 0x8c ; 041E92
041E93 49          5670  	db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
041E94 4E          5671  	db 0x4e ; 041E94
041E95 49          5672  	db 0x49 ; 041E95
041E96 4D          5673  	db 0x4d ; 041E96
041E97 D2          5674  	db 0xd2 ; 041E97
041E98 92          5675  	db 0x92 ; 041E98
041E99 4F          5676  	db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
041E9A 54          5677  	db 0x54 ; 041E9A
041E9B 49          5678  	db 0x49 ; 041E9B
041E9C 4D          5679  	db 0x4d ; 041E9C
041E9D D2          5680  	db 0xd2 ; 041E9D
041E9E 93          5681  	db 0x93 ; 041E9E
041E9F 49          5682  	db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
041EA0 4E          5683  	db 0x4e ; 041EA0
041EA1 49          5684  	db 0x49 ; 041EA1
041EA2 32          5685  	db 0x32 ; 041EA2
041EA3 D2          5686  	db 0xd2 ; 041EA3
041EA4 94          5687  	db 0x94 ; 041EA4
041EA5 49          5688  	db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
041EA6 4E          5689  	db 0x4e ; 041EA6
041EA7 44          5690  	db 0x44 ; 041EA7
041EA8 4D          5691  	db 0x4d ; 041EA8
041EA9 D2          5692  	db 0xd2 ; 041EA9
041EAA 9A          5693  	db 0x9a ; 041EAA
041EAB 4F          5694  	db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
041EAC 54          5695  	db 0x54 ; 041EAC
041EAD 44          5696  	db 0x44 ; 041EAD
041EAE 4D          5697  	db 0x4d ; 041EAE
041EAF D2          5698  	db 0xd2 ; 041EAF
041EB0 9B          5699  	db 0x9b ; 041EB0
041EB1 49          5700  	db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
041EB2 4E          5701  	db 0x4e ; 041EB2
041EB3 44          5702  	db 0x44 ; 041EB3
041EB4 32          5703  	db 0x32 ; 041EB4
041EB5 D2          5704  	db 0xd2 ; 041EB5
041EB6 9C          5705  	db 0x9c ; 041EB6
041EB7 4C          5706  	db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
041EB8 44          5707  	db 0x44 ; 041EB8
041EB9 C9          5708  	db 0xc9 ; 041EB9
041EBA A0          5709  	db 0xa0 ; 041EBA
041EBB 43          5710  	db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
041EBC 50          5711  	db 0x50 ; 041EBC
041EBD C9          5712  	db 0xc9 ; 041EBD
041EBE A1          5713  	db 0xa1 ; 041EBE
041EBF 49          5714  	db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
041EC0 4E          5715  	db 0x4e ; 041EC0
041EC1 C9          5716  	db 0xc9 ; 041EC1
041EC2 A2          5717  	db 0xa2 ; 041EC2
041EC3 4F          5718  	db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
041EC4 55          5719  	db 0x55 ; 041EC4
041EC5 54          5720  	db 0x54 ; 041EC5
041EC6 49          5721  	db 0x49 ; 041EC6
041EC7 B2          5722  	db 0xb2 ; 041EC7
041EC8 A4          5723  	db 0xa4 ; 041EC8
041EC9 4F          5724  	db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
041ECA 55          5725  	db 0x55 ; 041ECA
041ECB 54          5726  	db 0x54 ; 041ECB
041ECC C9          5727  	db 0xc9 ; 041ECC
041ECD A3          5728  	db 0xa3 ; 041ECD
041ECE 4C          5729  	db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
041ECF 44          5730  	db 0x44 ; 041ECF
041ED0 C4          5731  	db 0xc4 ; 041ED0
041ED1 A8          5732  	db 0xa8 ; 041ED1
041ED2 43          5733  	db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
041ED3 50          5734  	db 0x50 ; 041ED3
041ED4 C4          5735  	db 0xc4 ; 041ED4
041ED5 A9          5736  	db 0xa9 ; 041ED5
041ED6 49          5737  	db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
041ED7 4E          5738  	db 0x4e ; 041ED7
041ED8 C4          5739  	db 0xc4 ; 041ED8
041ED9 AA          5740  	db 0xaa ; 041ED9
041EDA 4F          5741  	db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
041EDB 55          5742  	db 0x55 ; 041EDB
041EDC 54          5743  	db 0x54 ; 041EDC
041EDD 44          5744  	db 0x44 ; 041EDD
041EDE B2          5745  	db 0xb2 ; 041EDE
041EDF AC          5746  	db 0xac ; 041EDF
041EE0 4F          5747  	db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
041EE1 55          5748  	db 0x55 ; 041EE1
041EE2 54          5749  	db 0x54 ; 041EE2
041EE3 C4          5750  	db 0xc4 ; 041EE3
041EE4 AB          5751  	db 0xab ; 041EE4
041EE5 4C          5752  	db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
041EE6 44          5753  	db 0x44 ; 041EE6
041EE7 49          5754  	db 0x49 ; 041EE7
041EE8 D2          5755  	db 0xd2 ; 041EE8
041EE9 B0          5756  	db 0xb0 ; 041EE9
041EEA 43          5757  	db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
041EEB 50          5758  	db 0x50 ; 041EEB
041EEC 49          5759  	db 0x49 ; 041EEC
041EED D2          5760  	db 0xd2 ; 041EED
041EEE B1          5761  	db 0xb1 ; 041EEE
041EEF 49          5762  	db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
041EF0 4E          5763  	db 0x4e ; 041EF0
041EF1 49          5764  	db 0x49 ; 041EF1
041EF2 D2          5765  	db 0xd2 ; 041EF2
041EF3 B2          5766  	db 0xb2 ; 041EF3
041EF4 4F          5767  	db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
041EF5 54          5768  	db 0x54 ; 041EF5
041EF6 49          5769  	db 0x49 ; 041EF6
041EF7 D2          5770  	db 0xd2 ; 041EF7
041EF8 B3          5771  	db 0xb3 ; 041EF8
041EF9 4F          5772  	db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
041EFA 54          5773  	db 0x54 ; 041EFA
041EFB 49          5774  	db 0x49 ; 041EFB
041EFC 32          5775  	db 0x32 ; 041EFC
041EFD D2          5776  	db 0xd2 ; 041EFD
041EFE B4          5777  	db 0xb4 ; 041EFE
041EFF 4C          5778  	db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
041F00 44          5779  	db 0x44 ; 041F00
041F01 44          5780  	db 0x44 ; 041F01
041F02 D2          5781  	db 0xd2 ; 041F02
041F03 B8          5782  	db 0xb8 ; 041F03
041F04 43          5783  	db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
041F05 50          5784  	db 0x50 ; 041F05
041F06 44          5785  	db 0x44 ; 041F06
041F07 D2          5786  	db 0xd2 ; 041F07
041F08 B9          5787  	db 0xb9 ; 041F08
041F09 49          5788  	db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
041F0A 4E          5789  	db 0x4e ; 041F0A
041F0B 44          5790  	db 0x44 ; 041F0B
041F0C D2          5791  	db 0xd2 ; 041F0C
041F0D BA          5792  	db 0xba ; 041F0D
041F0E 4F          5793  	db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
041F0F 54          5794  	db 0x54 ; 041F0F
041F10 44          5795  	db 0x44 ; 041F10
041F11 D2          5796  	db 0xd2 ; 041F11
041F12 BB          5797  	db 0xbb ; 041F12
041F13 4F          5798  	db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
041F14 54          5799  	db 0x54 ; 041F14
041F15 44          5800  	db 0x44 ; 041F15
041F16 32          5801  	db 0x32 ; 041F16
041F17 D2          5802  	db 0xd2 ; 041F17
041F18 BC          5803  	db 0xbc ; 041F18
041F19 49          5804  	db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
041F1A 4E          5805  	db 0x4e ; 041F1A
041F1B 49          5806  	db 0x49 ; 041F1B
041F1C 52          5807  	db 0x52 ; 041F1C
041F1D D8          5808  	db 0xd8 ; 041F1D
041F1E C2          5809  	db 0xc2 ; 041F1E
041F1F 4F          5810  	db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
041F20 54          5811  	db 0x54 ; 041F20
041F21 49          5812  	db 0x49 ; 041F21
041F22 52          5813  	db 0x52 ; 041F22
041F23 D8          5814  	db 0xd8 ; 041F23
041F24 C3          5815  	db 0xc3 ; 041F24
041F25 49          5816  	db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
041F26 4E          5817  	db 0x4e ; 041F26
041F27 44          5818  	db 0x44 ; 041F27
041F28 52          5819  	db 0x52 ; 041F28
041F29 D8          5820  	db 0xd8 ; 041F29
041F2A CA          5821  	db 0xca ; 041F2A
041F2B 4F          5822  	db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
041F2C 54          5823  	db 0x54 ; 041F2C
041F2D 44          5824  	db 0x44 ; 041F2D
041F2E 52          5825  	db 0x52 ; 041F2E
041F2F D8          5826  	db 0xd8 ; 041F2F
041F30 CB          5827  	db 0xcb ; 041F30
041F31             5828  ;
041F31             5829  ; Group 2: (3 opcodes)
041F31             5830  ;
041F31 42          5831  	db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
041F32 49          5832  	db 0x49 ; 041F32
041F33 D4          5833  	db 0xd4 ; 041F33
041F34 40          5834  	db 0x40 ; 041F34
041F35 52          5835  	db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
041F36 45          5836  	db 0x45 ; 041F36
041F37 D3          5837  	db 0xd3 ; 041F37
041F38 80          5838  	db 0x80 ; 041F38
041F39 53          5839  	db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
041F3A 45          5840  	db 0x45 ; 041F3A
041F3B D4          5841  	db 0xd4 ; 041F3B
041F3C C0          5842  	db 0xc0 ; 041F3C
041F3D             5843  ;
041F3D             5844  ; Group 3: (7 opcodes)
041F3D             5845  ;
041F3D 52          5846  	db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
041F3E 4C          5847  	db 0x4c ; 041F3E
041F3F C3          5848  	db 0xc3 ; 041F3F
041F40 00          5849  	db 0x00 ; 041F40
041F41 52          5850  	db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
041F42 52          5851  	db 0x52 ; 041F42
041F43 C3          5852  	db 0xc3 ; 041F43
041F44 08          5853  	db 0x08 ; 041F44
041F45 52          5854  	db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
041F46 CC          5855  	db 0xcc ; 041F46
041F47 10          5856  	db 0x10 ; 041F47
041F48 52          5857  	db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
041F49 D2          5858  	db 0xd2 ; 041F49
041F4A 18          5859  	db 0x18 ; 041F4A
041F4B 53          5860  	db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
041F4C 4C          5861  	db 0x4c ; 041F4C
041F4D C1          5862  	db 0xc1 ; 041F4D
041F4E 20          5863  	db 0x20 ; 041F4E
041F4F 53          5864  	db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
041F50 52          5865  	db 0x52 ; 041F50
041F51 C1          5866  	db 0xc1 ; 041F51
041F52 28          5867  	db 0x28 ; 041F52
041F53 53          5868  	db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
041F54 52          5869  	db 0x52 ; 041F54
041F55 CC          5870  	db 0xcc ; 041F55
041F56 38          5871  	db 0x38 ; 041F56
041F57             5872  ;
041F57             5873  ; Group 4: (3 opcodes)
041F57             5874  ;
041F57 50          5875  	db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
041F58 4F          5876  	db 0x4f ; 041F58
041F59 D0          5877  	db 0xd0 ; 041F59
041F5A C1          5878  	db 0xc1 ; 041F5A
041F5B 50          5879  	db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
041F5C 55          5880  	db 0x55 ; 041F5C
041F5D 53          5881  	db 0x53 ; 041F5D
041F5E C8          5882  	db 0xc8 ; 041F5E
041F5F C5          5883  	db 0xc5 ; 041F5F
041F60 45          5884  	db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
041F61 58          5885  	db 0x58 ; 041F61
041F62 00          5886  	db 0x00 ; 041F62
041F63 28          5887  	db 0x28 ; 041F63
041F64 53          5888  	db 0x53 ; 041F64
041F65 D0          5889  	db 0xd0 ; 041F65
041F66 E3          5890  	db 0xe3 ; 041F66
041F67             5891  ;
041F67             5892  ; Group 5: (7 opcodes)
041F67             5893  ;
041F67 53          5894  	db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
041F68 55          5895  	db 0x55 ; 041F68
041F69 C2          5896  	db 0xc2 ; 041F69
041F6A 90          5897  	db 0x90 ; 041F6A
041F6B 41          5898  	db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
041F6C 4E          5899  	db 0x4e ; 041F6C
041F6D C4          5900  	db 0xc4 ; 041F6D
041F6E A0          5901  	db 0xa0 ; 041F6E
041F6F 58          5902  	db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
041F70 4F          5903  	db 0x4f ; 041F70
041F71 D2          5904  	db 0xd2 ; 041F71
041F72 A8          5905  	db 0xa8 ; 041F72
041F73 4F          5906  	db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
041F74 D2          5907  	db 0xd2 ; 041F74
041F75 B0          5908  	db 0xb0 ; 041F75
041F76 43          5909  	db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
041F77 D0          5910  	db 0xd0 ; 041F77
041F78 B8          5911  	db 0xb8 ; 041F78
041F79 80          5912  	db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
041F7A A0          5913  	db 0xa0 ; 041F7A
041F7B 84          5914  	db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
041F7C B0          5915  	db 0xb0 ; 041F7C
041F7D             5916  ;
041F7D             5917  ; Group 6 (3 opcodes)
041F7D             5918  ;
041F7D 41          5919  	db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
041F7E 44          5920  	db 0x44 ; 041F7E
041F7F C4          5921  	db 0xc4 ; 041F7F
041F80 80          5922  	db 0x80 ; 041F80
041F81 41          5923  	db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
041F82 44          5924  	db 0x44 ; 041F82
041F83 C3          5925  	db 0xc3 ; 041F83
041F84 88          5926  	db 0x88 ; 041F84
041F85 53          5927  	db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
041F86 42          5928  	db 0x42 ; 041F86
041F87 C3          5929  	db 0xc3 ; 041F87
041F88 98          5930  	db 0x98 ; 041F88
041F89             5931  ;
041F89             5932  ; Group 7: (2 opcodes)
041F89             5933  ;
041F89 49          5934  	db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
041F8A 4E          5935  	db 0x4e ; 041F8A
041F8B C3          5936  	db 0xc3 ; 041F8B
041F8C 04          5937  	db 0x04 ; 041F8C
041F8D 44          5938  	db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
041F8E 45          5939  	db 0x45 ; 041F8E
041F8F C3          5940  	db 0xc3 ; 041F8F
041F90 05          5941  	db 0x05 ; 041F90
041F91             5942  ;
041F91             5943  ; Group 8: (2 opcodes)
041F91             5944  ;
041F91 49          5945  	db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
041F92 4E          5946  	db 0x4e ; 041F92
041F93 B0          5947  	db 0xb0 ; 041F93
041F94 00          5948  	db 0x00 ; 041F94
041F95 4F          5949  	db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
041F96 55          5950  	db 0x55 ; 041F96
041F97 54          5951  	db 0x54 ; 041F97
041F98 B0          5952  	db 0xb0 ; 041F98
041F99 01          5953  	db 0x01 ; 041F99
041F9A             5954  ;
041F9A             5955  ; Group 9: (1 opcode)
041F9A             5956  ;
041F9A 49          5957  	db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
041F9B CE          5958  	db 0xce ; 041F9B
041F9C 40          5959  	db 0x40 ; 041F9C
041F9D             5960  ;
041F9D             5961  ; Group 10: (1 opcode)
041F9D             5962  ;
041F9D 4F          5963  	db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
041F9E 55          5964  	db 0x55 ; 041F9E
041F9F D4          5965  	db 0xd4 ; 041F9F
041FA0 41          5966  	db 0x41 ; 041FA0
041FA1             5967  ;
041FA1             5968  ; Group 11: (2 opcodes)
041FA1             5969  ;
041FA1 4A          5970  	db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
041FA2 D2          5971  	db 0xd2 ; 041FA2
041FA3 20          5972  	db 0x20 ; 041FA3
041FA4 44          5973  	db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
041FA5 4A          5974  	db 0x4a ; 041FA5
041FA6 4E          5975  	db 0x4e ; 041FA6
041FA7 DA          5976  	db 0xda ; 041FA7
041FA8 10          5977  	db 0x10 ; 041FA8
041FA9             5978  ;
041FA9             5979  ; Group 12: (1 opcode)
041FA9             5980  ;
041FA9 4A          5981  	db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
041FAA D0          5982  	db 0xd0 ; 041FAA
041FAB C2          5983  	db 0xc2 ; 041FAB
041FAC             5984  ;
041FAC             5985  ; Group 13: (1 opcode)
041FAC             5986  ;
041FAC 43          5987  	db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
041FAD 41          5988  	db 0x41 ; 041FAD
041FAE 4C          5989  	db 0x4c ; 041FAE
041FAF CC          5990  	db 0xcc ; 041FAF
041FB0 C4          5991  	db 0xc4 ; 041FB0
041FB1             5992  ;
041FB1             5993  ; Group 14: (1 opcode)
041FB1             5994  ;
041FB1 52          5995  	db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
041FB2 53          5996  	db 0x53 ; 041FB2
041FB3 D4          5997  	db 0xd4 ; 041FB3
041FB4 C7          5998  	db 0xc7 ; 041FB4
041FB5             5999  ;
041FB5             6000  ; Group 15: (1 opcode)
041FB5             6001  ;
041FB5 52          6002  	db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
041FB6 45          6003  	db 0x45 ; 041FB6
041FB7 D4          6004  	db 0xd4 ; 041FB7
041FB8 C0          6005  	db 0xc0 ; 041FB8
041FB9             6006  ;
041FB9             6007  ; Group 16: (1 opcode)
041FB9             6008  ;
041FB9 4C          6009  	db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
041FBA C4          6010  	db 0xc4 ; 041FBA
041FBB 40          6011  	db 0x40 ; 041FBB
041FBC             6012  ;
041FBC             6013  ; Group 17: (1 opcode)
041FBC             6014  ;
041FBC 54          6015  	db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
041FBD 53          6016  	db 0x53 ; 041FBD
041FBE D4          6017  	db 0xd4 ; 041FBE
041FBF 04          6018  	db 0x04 ; 041FBF
041FC0             6019  ;
041FC0             6020  ; Assembler Directives
041FC0             6021  ;
041FC0 4F          6022  	db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
041FC1 50          6023  	db 0x50 ; 041FC1
041FC2 D4          6024  	db 0xd4 ; 041FC2
041FC3 00          6025  	db 0x00 ; 041FC3
041FC4 41          6026  	db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
041FC5 44          6027  	db 0x44 ; 041FC5
041FC6 CC          6028  	db 0xcc ; 041FC6
041FC7 00          6029  	db 0x00 ; 041FC7
041FC8 5D          6030  	db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041FC9 C2          6031  	db 0xc2 ; 041FC9
041FCA 00          6032  	db 0x00 ; 041FCA
041FCB 5D          6033  	db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041FCC D7          6034  	db 0xd7 ; 041FCC
041FCD 00          6035  	db 0x00 ; 041FCD
041FCE 5D          6036  	db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041FCF CC          6037  	db 0xcc ; 041FCF
041FD0 00          6038  	db 0x00 ; 041FD0
041FD1 5D          6039  	db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
041FD2 CD          6040  	db 0xcd ; 041FD2
041FD3 00          6041  	db 0x00 ; 041FD3
041FD4 00          6042  	db 0x00 ; 041FD4 00      5426 DB	0
041FD5             6043  ;
041FD5             6044  ; Operands
041FD5             6045  ;
041FD5             6046  OPRNDS:
041FD5 C2          6047  	db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
041FD6 00          6048  	db 0x00 ; 041FD6
041FD7 C3          6049  	db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
041FD8 01          6050  	db 0x01 ; 041FD8
041FD9 C4          6051  	db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
041FDA 02          6052  	db 0x02 ; 041FDA
041FDB C5          6053  	db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
041FDC 03          6054  	db 0x03 ; 041FDC
041FDD C8          6055  	db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
041FDE 04          6056  	db 0x04 ; 041FDE
041FDF CC          6057  	db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
041FE0 05          6058  	db 0x05 ; 041FE0
041FE1 28          6059  	db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
041FE2 48          6060  	db 0x48 ; 041FE2
041FE3 CC          6061  	db 0xcc ; 041FE3
041FE4 06          6062  	db 0x06 ; 041FE4
041FE5 C1          6063  	db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
041FE6 07          6064  	db 0x07 ; 041FE6
041FE7 28          6065  	db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
041FE8 49          6066  	db 0x49 ; 041FE8
041FE9 D8          6067  	db 0xd8 ; 041FE9
041FEA 86          6068  	db 0x86 ; 041FEA
041FEB 28          6069  	db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
041FEC 49          6070  	db 0x49 ; 041FEC
041FED D9          6071  	db 0xd9 ; 041FED
041FEE C6          6072  	db 0xc6 ; 041FEE
041FEF 42          6073  	db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
041FF0 C3          6074  	db 0xc3 ; 041FF0
041FF1 08          6075  	db 0x08 ; 041FF1
041FF2 44          6076  	db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
041FF3 C5          6077  	db 0xc5 ; 041FF3
041FF4 0A          6078  	db 0x0a ; 041FF4
041FF5 48          6079  	db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
041FF6 CC          6080  	db 0xcc ; 041FF6
041FF7 0C          6081  	db 0x0c ; 041FF7
041FF8 49          6082  	db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
041FF9 D8          6083  	db 0xd8 ; 041FF9
041FFA 8C          6084  	db 0x8c ; 041FFA
041FFB 49          6085  	db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
041FFC D9          6086  	db 0xd9 ; 041FFC
041FFD CC          6087  	db 0xcc ; 041FFD
041FFE 41          6088  	db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
041FFF C6          6089  	db 0xc6 ; 041FFF
042000 0E          6090  	db 0x0e ; 042000
042001 53          6091  	db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
042002 D0          6092  	db 0xd0 ; 042002
042003 0E          6093  	db 0x0e ; 042003
042004 4E          6094  	db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
042005 DA          6095  	db 0xda ; 042005
042006 10          6096  	db 0x10 ; 042006
042007 DA          6097  	db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
042008 11          6098  	db 0x11 ; 042008
042009 4E          6099  	db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
04200A C3          6100  	db 0xc3 ; 04200A
04200B 12          6101  	db 0x12 ; 04200B
04200C 50          6102  	db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
04200D CF          6103  	db 0xcf ; 04200D
04200E 14          6104  	db 0x14 ; 04200E
04200F 50          6105  	db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
042010 C5          6106  	db 0xc5 ; 042010
042011 15          6107  	db 0x15 ; 042011
042012 D0          6108  	db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
042013 16          6109  	db 0x16 ; 042013
042014 CD          6110  	db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
042015 17          6111  	db 0x17 ; 042015
042016 28          6112  	db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
042017 C3          6113  	db 0xc3 ; 042017
042018 20          6114  	db 0x20 ; 042018
042019 00          6115  	db 0x00 ; 042019 00      5459 DB	0
04201A             6116  ;
04201A             6117  ; Load operations
04201A             6118  ;
04201A             6119  LDOPS:
04201A 49          6120  	db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
04201B 00          6121  	db 0x00 ; 04201B
04201C C1          6122  	db 0xc1 ; 04201C
04201D 47          6123  	db 0x47 ; 04201D
04201E 52          6124  	db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
04201F 00          6125  	db 0x00 ; 04201F
042020 C1          6126  	db 0xc1 ; 042020
042021 4F          6127  	db 0x4f ; 042021
042022 41          6128  	db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
042023 00          6129  	db 0x00 ; 042023
042024 C9          6130  	db 0xc9 ; 042024
042025 57          6131  	db 0x57 ; 042025
042026 41          6132  	db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
042027 00          6133  	db 0x00 ; 042027
042028 D2          6134  	db 0xd2 ; 042028
042029 5F          6135  	db 0x5f ; 042029
04202A 28          6136  	db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
04202B 42          6137  	db 0x42 ; 04202B
04202C 43          6138  	db 0x43 ; 04202C
04202D 00          6139  	db 0x00 ; 04202D
04202E C1          6140  	db 0xc1 ; 04202E
04202F 02          6141  	db 0x02 ; 04202F
042030 28          6142  	db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
042031 44          6143  	db 0x44 ; 042031
042032 45          6144  	db 0x45 ; 042032
042033 00          6145  	db 0x00 ; 042033
042034 C1          6146  	db 0xc1 ; 042034
042035 12          6147  	db 0x12 ; 042035
042036 41          6148  	db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
042037 00          6149  	db 0x00 ; 042037
042038 28          6150  	db 0x28 ; 042038
042039 42          6151  	db 0x42 ; 042039
04203A C3          6152  	db 0xc3 ; 04203A
04203B 0A          6153  	db 0x0a ; 04203B
04203C 41          6154  	db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
04203D 00          6155  	db 0x00 ; 04203D
04203E 28          6156  	db 0x28 ; 04203E
04203F 44          6157  	db 0x44 ; 04203F
042040 C5          6158  	db 0xc5 ; 042040
042041 1A          6159  	db 0x1a ; 042041
042042 00          6160  	db 0x00 ; 042042 00      5472 DB	0
042043             6161  ;
042043             6162  ; eZ80 addressing mode suffixes
042043             6163  ;
042043             6164  ; Fully qualified suffixes
042043             6165  ;
042043             6166  EZ80SFS_1:
042043 4C          6167  	db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
042044 49          6168  	db 0x49 ; 042044
042045 D3          6169  	db 0xd3 ; 042045
042046 49          6170  	db 0x49 ; 042046
042047 53          6171  	db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
042048 49          6172  	db 0x49 ; 042048
042049 CC          6173  	db 0xcc ; 042049
04204A 52          6174  	db 0x52 ; 04204A
04204B             6175  
04204B             6176  EZ80SFS_2:
04204B 53          6177  	db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
04204C 49          6178  	db 0x49 ; 04204C
04204D D3          6179  	db 0xd3 ; 04204D
04204E 40          6180  	db 0x40 ; 04204E
04204F 4C          6181  	db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
042050 49          6182  	db 0x49 ; 042050
042051 CC          6183  	db 0xcc ; 042051
042052 5B          6184  	db 0x5b ; 042052
042053 00          6185  	db 0x00 ; 042053 00      5483 DB	0
042054             6186  ;
042054             6187  ; Shortcuts when ADL mode is 0
042054             6188  ;
042054             6189  EZ80SFS_ADL0:
042054 D3          6190  	db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042055 40          6191  	db 0x40 ; 042055
042056 CC          6192  	db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
042057 49          6193  	db 0x49 ; 042057
042058 49          6194  	db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
042059 D3          6195  	db 0xd3 ; 042059
04205A 40          6196  	db 0x40 ; 04205A
04205B 49          6197  	db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
04205C CC          6198  	db 0xcc ; 04205C
04205D 52          6199  	db 0x52 ; 04205D
04205E 00          6200  	db 0x00 ; 04205E 00      5492 DB	0
04205F             6201  ;
04205F             6202  ; Shortcuts when ADL mode is 1
04205F             6203  ;
04205F             6204  EZ80SFS_ADL1:
04205F D3          6205  	db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042060 52          6206  	db 0x52 ; 042060
042061 CC          6207  	db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
042062 5B          6208  	db 0x5b ; 042062
042063 49          6209  	db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
042064 D3          6210  	db 0xd3 ; 042064
042065 49          6211  	db 0x49 ; 042065
042066 49          6212  	db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
042067 CC          6213  	db 0xcc ; 042067
042068 5B          6214  	db 0x5b ; 042068
042069 00          6215  	db 0x00 ; 042069 00      5501 DB	0
04206A             6216  ; END INSERT FROM BINARY
04206A             6217  ;
04206A             6218  ; .LIST
04206A             6219  ;
04206A             6220  ; already defined in equs.inc
04206A             6221  ; LF:			EQU     0AH
04206A             6222  ; CR:			EQU     0DH; --- End exec.asm ---
04206A             6223  
04206A             6224  ; --- Begin fpp.asm ---
04206A             6225  ;
04206A             6226  ; Title:	BBC Basic Interpreter - Z80 version
04206A             6227  ;		Z80 Floating Point Package
04206A             6228  ; Author:	(C) Copyright  R.T.Russell  1986
04206A             6229  ; Modified By:	Dean Belfield
04206A             6230  ; Created:	03/05/2022
04206A             6231  ; Last Updated:	07/06/2023
04206A             6232  ;
04206A             6233  ; Modinfo:
04206A             6234  ; 26/10/1986:	Version 0.0
04206A             6235  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
04206A             6236  ; 12/05/2023:	Modified by Dean Belfield
04206A             6237  ; 07/06/2023:	Modified to run in ADL mode
04206A             6238  
04206A             6239  			; .ASSUME	ADL = 1
04206A             6240  
04206A             6241  			; SEGMENT CODE
04206A             6242  
04206A             6243  			; XDEF	FPP
04206A             6244  			; XDEF	DLOAD5
04206A             6245  			; XDEF	DLOAD5_SPL
04206A             6246  ;
04206A             6247  ;BINARY FLOATING POINT REPRESENTATION:
04206A             6248  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04206A             6249  ;    8 BIT EXCESS-128 SIGNED EXPONENT
04206A             6250  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04206A             6251  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04206A             6252  ;
04206A             6253  ;BINARY INTEGER REPRESENTATION:
04206A             6254  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04206A             6255  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
04206A             6256  ;
04206A             6257  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04206A             6258  ;                            EXPONENT - C
04206A             6259  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
04206A             6260  ;                               EXPONENT - B
04206A             6261  
04206A             6262  ;
04206A             6263  ;Error codes:
04206A             6264  ;
04206A             6265  
04206A             6266  BADOP:			EQU     1               ;Bad operation code
04206A             6267  DIVBY0:			EQU     18              ;Division by zero
04206A             6268  TOOBIG_FP:			EQU     20              ;Too big
04206A             6269  NGROOT:			EQU     21              ;Negative root
04206A             6270  LOGRNG:			EQU     22              ;Log range
04206A             6271  ACLOST:			EQU     23              ;Accuracy lost
04206A             6272  EXPRNG:			EQU     24              ;Exp range
04206A             6273  ;
04206A             6274  ;Call entry and despatch code:
04206A             6275  ;
04206A FD E5       6276  FPP:			PUSH    IY              ;Save IY
04206C FD 21 00 00 6277          		LD      IY,0
       00          
042071 FD 39       6278          		ADD     IY,SP           ;Save SP in IY
042073 CD 83 20 04 6279          		CALL    OP              ;Perform operation
042077 BF          6280          		CP      A               ;Good return (Z, NC)
042078 FD E1       6281  EXIT_FP_:			POP     IY              ;Restore IY
04207A C9          6282          		RET                     ;Return to caller
04207B             6283  ;
04207B             6284  ;Error exit:
04207B             6285  ;
04207B 3E 01       6286  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
04207D FD F9       6287  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
04207F B7          6288          		OR      A               ;Set NZ
042080 37          6289          		SCF                     ;Set C
042081 18 F5       6290          		JR      EXIT_FP_
042083             6291  ;
042083             6292  ;Perform operation or function:
042083             6293  ;
042083             6294  ; OP:			CP      (RTABLE-DTABLE)/3
042083 FE 2A       6295  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042085             6296  
042085 30 F4       6297          		JR      NC,BAD_FP
042087             6298          		; CP      (FTABLE-DTABLE)/3
042087 FE 10       6299  				CP      FTABLE-DTABLE/3 ; ditto
042089 30 08       6300          		JR      NC,DISPAT_FP
04208B 08          6301          		EX      AF,AF'
04208C 78          6302          		LD      A,B
04208D B1          6303          		OR      C               ;Both integer?
04208E C4 96 2B 04 6304          		CALL    NZ,FLOATA       ;No, so float both
042092 08          6305          		EX      AF,AF'
042093 E5          6306  DISPAT_FP:			PUSH    HL
042094 21 A6 20 04 6307          		LD      HL,DTABLE
042098 C5          6308          		PUSH    BC
042099 01 03 00 00 6309  			LD	BC, 3		; C = 3
04209D 47          6310  			LD	B, A 		; B = op-code
04209E ED 4C       6311  			MLT 	BC 		;BC = op-code * 3
0420A0 09          6312  			ADD	HL, BC 		;Add to table base
0420A1 ED 27       6313  			LD	HL, (HL)	;Get the routine address (24-bit)
0420A3             6314  
0420A3             6315  ;        		ADD     A, A            ;A = op-code * 2
0420A3             6316  ;        		LD      C,A
0420A3             6317  ;        		LD      B,0             ;BC = op-code * 2
0420A3             6318  ;        		ADD     HL,BC
0420A3             6319  ;        		LD      A,(HL)          ;Get low byte
0420A3             6320  ;        		INC     HL
0420A3             6321  ;        		LD      H,(HL)          ;Get high byte
0420A3             6322  ;        		LD      L,A
0420A3             6323  
0420A3 C1          6324          		POP     BC
0420A4 E3          6325          		EX      (SP),HL
0420A5 C9          6326          		RET                     ;Off to routine
0420A6             6327  ;
0420A6             6328  ;Despatch table:
0420A6             6329  ;
0420A6 58 21 04    6330  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420A9 C6 21 04    6331          		DW24  IBDIV           ;DIV
0420AC 6B 21 04    6332          		DW24  IEOR            ;EOR
0420AF 91 21 04    6333          		DW24  IMOD            ;MOD
0420B2 7E 21 04    6334          		DW24  IOR             ;OR
0420B5 4C 24 04    6335          		DW24  ILE             ;<=
0420B8 5B 24 04    6336          		DW24  INE             ;<>
0420BB 3F 24 04    6337          		DW24  IGE             ;>=
0420BE 24 24 04    6338          		DW24  ILT             ;<
0420C1 68 24 04    6339          		DW24  IEQ             ;=
0420C4 B4 22 04    6340          		DW24  IMUL            ;*
0420C7 EF 21 04    6341          		DW24  IADD            ;+
0420CA 31 24 04    6342          		DW24  IGT             ;>
0420CD D6 21 04    6343          		DW24  ISUB            ;-
0420D0 6B 23 04    6344          		DW24  IPOW            ;^
0420D3 61 22 04    6345          		DW24  IDIV            ;/
0420D6             6346  ;
0420D6             6347  FTABLE:
0420D6 7A 24 04    6348  				DW24  ABSV_FP            ;ABS
0420D9 60 28 04    6349          		DW24  ACS_FP             ;ACS
0420DC 9E 27 04    6350          		DW24  ASN_FP             ;ASN
0420DF CE 27 04    6351          		DW24  ATN_FP             ;ATN
0420E2 99 25 04    6352          		DW24  COS_FP             ;COS
0420E5 A8 24 04    6353          		DW24  DEG_FP             ;DEG
0420E8 55 26 04    6354          		DW24  EXP_FP             ;EXP
0420EB FC 24 04    6355          		DW24  INT_FP_            ;INT
0420EE F3 26 04    6356          		DW24  LN_FP              ;LN
0420F1 88 27 04    6357          		DW24  LOG_FP             ;LOG
0420F4 86 24 04    6358          		DW24  NOTK_FP            ;NOT
0420F7 B2 24 04    6359          		DW24  RAD_FP             ;RAD
0420FA CD 24 04    6360          		DW24  SGN_FP             ;SGN
0420FD A6 25 04    6361          		DW24  SIN_FP             ;SIN
042100 15 25 04    6362          		DW24  SQR_FP             ;SQR
042103 73 25 04    6363          		DW24  TAN_FP             ;TAN
042106             6364  ;
042106 23 2C 04    6365  		        DW24  ZERO_FP            ;ZERO
042109 2E 26 04    6366          		DW24  FONE_FP            ;FONE
04210C 6D 24 04    6367          		DW24  TRUE_FP            ;TRUE
04210F 9A 24 04    6368          		DW24  PI_FP              ;PI
042112             6369  ;
042112 E1 24 04    6370  		        DW24  VAL_FP             ;VAL
042115 69 28 04    6371          		DW24  STR_FP             ;STR$
042118             6372  ;
042118 CA 2A 04    6373          		DW24  SFIX_FP            ;FIX
04211B A6 2B 04    6374          		DW24  SFLOAT_FP          ;FLOAT
04211E             6375  ;
04211E F4 2B 04    6376  		        DW24  FTEST_FP           ;TEST
042121 06 2C 04    6377          		DW24  FCOMP_FP           ;COMPARE
042124             6378  ;
042124 54 21 04    6379  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042127 C2 21 04    6380          		DW24  FBDIV           ;DIV
04212A 67 21 04    6381          		DW24  FEOR            ;EOR
04212D 8D 21 04    6382          		DW24  FMOD            ;MOD
042130 7A 21 04    6383          		DW24  FFOR             ;OR
042133 46 24 04    6384          		DW24  FLE             ;<=
042136 55 24 04    6385          		DW24  FNE             ;<>
042139 39 24 04    6386          		DW24  FGE             ;>=
04213C 1E 24 04    6387          		DW24  FLT             ;<
04213F 62 24 04    6388          		DW24  FEQ             ;=
042142 0E 23 04    6389          		DW24  FMUL            ;*
042145 FC 21 04    6390          		DW24  FADD            ;+
042148 2B 24 04    6391          		DW24  FGT             ;>
04214B E3 21 04    6392          		DW24  FSUB            ;-
04214E EB 23 04    6393          		DW24  FPOW            ;^
042151 65 22 04    6394          		DW24  FDIV            ;/
042154             6395  ;
042154             6396  ;       PAGE
042154             6397  ;
042154             6398  ;ARITHMETIC AND LOGICAL OPERATORS:
042154             6399  ;All take two arguments, in HLH'L'C & DED'E'B.
042154             6400  ;Output in HLH'L'C
042154             6401  ;All registers except IX, IY destroyed.
042154             6402  ; (N.B. FPOW destroys IX).
042154             6403  ;
042154             6404  ;FAND - Floating-point AND.
042154             6405  ;IAND - Integer AND.
042154             6406  ;
042154 CD BE 2A 04 6407  FAND:			CALL    FIX2
042158 7C          6408  IAND:			LD      A,H
042159 A2          6409          		AND     D
04215A 67          6410          		LD      H,A
04215B 7D          6411          		LD      A,L
04215C A3          6412          		AND     E
04215D 6F          6413          		LD      L,A
04215E D9          6414          		EXX
04215F 7C          6415          		LD      A,H
042160 A2          6416          		AND     D
042161 67          6417          		LD      H,A
042162 7D          6418          		LD      A,L
042163 A3          6419          		AND     E
042164 6F          6420          		LD      L,A
042165 D9          6421          		EXX
042166 C9          6422          		RET
042167             6423  ;
042167             6424  ;FEOR - Floating-point exclusive-OR.
042167             6425  ;IEOR - Integer exclusive-OR.
042167             6426  ;
042167 CD BE 2A 04 6427  FEOR:			CALL    FIX2
04216B 7C          6428  IEOR:			LD      A,H
04216C AA          6429          		XOR     D
04216D 67          6430          		LD      H,A
04216E 7D          6431          		LD      A,L
04216F AB          6432          		XOR     E
042170 6F          6433          		LD      L,A
042171 D9          6434          		EXX
042172 7C          6435          		LD      A,H
042173 AA          6436          		XOR     D
042174 67          6437          		LD      H,A
042175 7D          6438          		LD      A,L
042176 AB          6439          		XOR     E
042177 6F          6440          		LD      L,A
042178 D9          6441          		EXX
042179 C9          6442          		RET
04217A             6443  ;
04217A             6444  ;FOR - Floating-point OR.
04217A             6445  ;IOR - Integer OR.
04217A             6446  ;
04217A CD BE 2A 04 6447  FFOR:			CALL    FIX2
04217E 7C          6448  IOR:			LD      A,H
04217F B2          6449          		OR      D
042180 67          6450          		LD      H,A
042181 7D          6451          		LD      A,L
042182 B3          6452          		OR      E
042183 6F          6453          		LD      L,A
042184 D9          6454          		EXX
042185 7C          6455          		LD      A,H
042186 B2          6456          		OR      D
042187 67          6457          		LD      H,A
042188 7D          6458          		LD      A,L
042189 B3          6459          		OR      E
04218A 6F          6460          		LD      L,A
04218B D9          6461          		EXX
04218C C9          6462          		RET
04218D             6463  ;
04218D             6464  ;FMOD - Floating-point remainder.
04218D             6465  ;IMOD - Integer remainder.
04218D             6466  ;
04218D CD BE 2A 04 6467  FMOD:			CALL    FIX2
042191 7C          6468  IMOD:			LD      A,H
042192 AA          6469          		XOR     D               ;DIV RESULT SIGN
042193 CB 7C       6470          		BIT     7,H
042195 08          6471          		EX      AF,AF'
042196 CB 7C       6472          		BIT     7,H
042198 C4 DA 2A 04 6473          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
04219C CD D7 2B 04 6474          		CALL    SWAP_FP
0421A0 CB 7C       6475          		BIT     7,H
0421A2 C4 DA 2A 04 6476          		CALL    NZ,NEGATE
0421A6 44          6477          		LD      B,H
0421A7 4D          6478          		LD      C,L
0421A8 21 00 00 00 6479          		LD      HL,0
0421AC D9          6480          		EXX
0421AD 44          6481          		LD      B,H
0421AE 4D          6482          		LD      C,L
0421AF 21 00 00 00 6483          		LD      HL,0
0421B3 3E DF       6484          		LD      A,-33
0421B5 CD 64 2D 04 6485          		CALL    DIVA            ;DIVIDE
0421B9 D9          6486          		EXX
0421BA 0E 00       6487          		LD      C,0             ;INTEGER MARKER
0421BC 08          6488          		EX      AF,AF'
0421BD C8          6489          		RET     Z
0421BE C3 DA 2A 04 6490          		JP      NEGATE
0421C2             6491  ;
0421C2             6492  ;BDIV - Integer division.
0421C2             6493  ;
0421C2 CD BE 2A 04 6494  FBDIV:			CALL    FIX2
0421C6 CD 91 21 04 6495  IBDIV:			CALL    IMOD
0421CA B7          6496          		OR      A
0421CB CD D7 2B 04 6497          		CALL    SWAP_FP
0421CF 0E 00       6498          		LD      C,0
0421D1 F0          6499          		RET     P
0421D2 C3 DA 2A 04 6500          		JP      NEGATE
0421D6             6501  ;
0421D6             6502  ;ISUB - Integer subtraction.
0421D6             6503  ;FSUB - Floating point subtraction with rounding.
0421D6             6504  ;
0421D6 CD 72 2C 04 6505  ISUB:			CALL    SUB_
0421DA E0          6506          		RET     PO
0421DB CD 6A 2C 04 6507          		CALL    ADD_
0421DF CD 9A 2B 04 6508          		CALL    FLOAT2
0421E3 7A          6509  FSUB:			LD      A,D
0421E4 EE 80       6510          		XOR     80H             ;CHANGE SIGN THEN ADD
0421E6 57          6511          		LD      D,A
0421E7 18 13       6512          		JR      FADD
0421E9             6513  ;
0421E9             6514  ;Reverse subtract.
0421E9             6515  ;
0421E9 7C          6516  RSUB:			LD      A,H
0421EA EE 80       6517          		XOR     80H
0421EC 67          6518          		LD      H,A
0421ED 18 0D       6519          		JR      FADD
0421EF             6520  ;
0421EF             6521  ;IADD - Integer addition.
0421EF             6522  ;FADD - Floating point addition with rounding.
0421EF             6523  ;
0421EF CD 6A 2C 04 6524  IADD:			CALL    ADD_
0421F3 E0          6525          		RET     PO
0421F4 CD 72 2C 04 6526          		CALL    SUB_
0421F8 CD 9A 2B 04 6527          		CALL    FLOAT2
0421FC 05          6528  FADD:			DEC     B
0421FD 04          6529          		INC     B
0421FE C8          6530          		RET     Z               ;ARG 2 ZERO
0421FF 0D          6531          		DEC     C
042200 0C          6532          		INC     C
042201 CA D7 2B 04 6533          		JP      Z,SWAP_FP          ;ARG 1 ZERO
042205 D9          6534          		EXX
042206 01 00 00 00 6535          		LD      BC,0            ;INITIALISE
04220A D9          6536          		EXX
04220B 7C          6537          		LD      A,H
04220C AA          6538          		XOR     D               ;XOR SIGNS
04220D F5          6539          		PUSH    AF
04220E 78          6540          		LD      A,B
04220F B9          6541          		CP      C               ;COMPARE EXPONENTS
042210 DC D7 2B 04 6542          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
042214 78          6543          		LD      A,B
042215 CB FC       6544          		SET     7,H             ;IMPLIED 1
042217 C4 AB 2A 04 6545          		CALL    NZ,FIX          ;ALIGN
04221B F1          6546          		POP     AF
04221C 7A          6547          		LD      A,D             ;SIGN OF LARGER
04221D CB FA       6548          		SET     7,D             ;IMPLIED 1
04221F FA 2F 22 04 6549          		JP      M,FADD3         ;SIGNS DIFFERENT
042223 CD 6A 2C 04 6550          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
042227 DC DF 2B 04 6551          		CALL    C,DIV2          ;NORMALISE
04222B CB FC       6552          		SET     7,H
04222D 18 0D       6553          		JR      FADD4
04222F             6554  ;
04222F CD 72 2C 04 6555  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
042233 DC F2 2A 04 6556          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
042237 CD 71 2B 04 6557          		CALL    FLO48
04223B 2F          6558          		CPL                     ;CHANGE RESULT SIGN
04223C D9          6559  FADD4:			EXX
04223D EB          6560          		EX      DE,HL
04223E 21 00 80 00 6561          		LD      HL,8000H
042242 B7          6562          		OR      A               ;CLEAR CARRY
042243 52 ED 42    6563          		SBC.S   HL,BC
042246 EB          6564          		EX      DE,HL
042247 D9          6565          		EXX
042248 CC D1 2B 04 6566          		CALL    Z,ODD           ;ROUND UNBIASSED
04224C DC BF 2B 04 6567          		CALL    C,ADD1_FP          ;ROUND UP
042250 DC EC 2B 04 6568          		CALL    C,INCC
042254 CB BC       6569          		RES     7,H
042256 0D          6570          		DEC     C
042257 0C          6571          		INC     C
042258 CA 23 2C 04 6572          		JP      Z,ZERO_FP
04225C B7          6573          		OR      A               ;RESULT SIGNQ
04225D F0          6574          		RET     P               ;POSITIVE
04225E CB FC       6575          		SET     7,H             ;NEGATIVE
042260 C9          6576          		RET
042261             6577  ;
042261             6578  ;IDIV - Integer division.
042261             6579  ;FDIV - Floating point division with rounding.
042261             6580  ;
042261 CD 9A 2B 04 6581  IDIV:			CALL    FLOAT2
042265 05          6582  FDIV:			DEC     B               ;TEST FOR ZERO
042266 04          6583          		INC     B
042267 3E 12       6584          		LD      A,DIVBY0
042269 CA 7D 20 04 6585          		JP      Z,ERROR_FP_         ;"Division by zero"
04226D 0D          6586          		DEC     C               ;TEST FOR ZERO
04226E 0C          6587          		INC     C
04226F C8          6588          		RET     Z
042270 7C          6589          		LD      A,H
042271 AA          6590          		XOR     D               ;CALC. RESULT SIGN
042272 08          6591          		EX      AF,AF'          ;SAVE SIGN
042273 CB FA       6592          		SET     7,D             ;REPLACE IMPLIED 1's
042275 CB FC       6593          		SET     7,H
042277 C5          6594          		PUSH    BC              ;SAVE EXPONENTS
042278 42          6595          		LD      B,D             ;LOAD REGISTERS
042279 4B          6596          		LD      C,E
04227A 11 00 00 00 6597          		LD      DE,0
04227E D9          6598          		EXX
04227F 42          6599          		LD      B,D
042280 4B          6600          		LD      C,E
042281 11 00 00 00 6601          		LD      DE,0
042285 3E E0       6602          		LD      A,-32           ;LOOP COUNTER
042287 CD 64 2D 04 6603          		CALL    DIVA            ;DIVIDE
04228B D9          6604          		EXX
04228C CB 7A       6605          		BIT     7,D
04228E D9          6606          		EXX
04228F CC 83 2D 04 6607          		CALL    Z,DIVB          ;NORMALISE & INC A
042293 EB          6608          		EX      DE,HL
042294 D9          6609          		EXX
042295 CB 38       6610          		SRL     B               ;DIVISOR/2
042297 CB 19       6611          		RR      C
042299 B7          6612          		OR      A               ;CLEAR CARRY
04229A 52 ED 42    6613          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
04229D 3F          6614          		CCF
04229E EB          6615          		EX      DE,HL           ;RESULT IN HLH'L'
04229F CC D1 2B 04 6616          		CALL    Z,ODD           ;ROUND UNBIASSED
0422A3 DC BF 2B 04 6617          		CALL    C,ADD1_FP          ;ROUND UP
0422A7 C1          6618          		POP     BC              ;RESTORE EXPONENTS
0422A8 DC EC 2B 04 6619          		CALL    C,INCC
0422AC 1F          6620          		RRA                     ;LSB OF A TO CARRY
0422AD 79          6621          		LD      A,C             ;COMPUTE NEW EXPONENT
0422AE 98          6622          		SBC     A,B
0422AF 3F          6623          		CCF
0422B0 C3 51 23 04 6624          		JP      CHKOVF
0422B4             6625  ;
0422B4             6626  ;IMUL - Integer multiplication.
0422B4             6627  ;
0422B4 7C          6628  IMUL:			LD      A,H
0422B5 AA          6629          		XOR     D
0422B6 08          6630          		EX      AF,AF'          ;SAVE RESULT SIGN
0422B7 CB 7C       6631          		BIT     7,H
0422B9 C4 DA 2A 04 6632          		CALL    NZ,NEGATE
0422BD CD D7 2B 04 6633          		CALL    SWAP_FP
0422C1 CB 7C       6634          		BIT     7,H
0422C3 C4 DA 2A 04 6635          		CALL    NZ,NEGATE
0422C7 44          6636          		LD      B,H
0422C8 4D          6637          		LD      C,L
0422C9 21 00 00 00 6638          		LD      HL,0
0422CD D9          6639          		EXX
0422CE 44          6640          		LD      B,H
0422CF 4D          6641          		LD      C,L
0422D0 21 00 00 00 6642          		LD      HL,0
0422D4 3E DF       6643          		LD      A,-33
0422D6 CD 9B 2D 04 6644          		CALL    MULA            ;MULTIPLY
0422DA D9          6645          		EXX
0422DB 0E BF       6646          		LD      C,191           ;PRESET EXPONENT
0422DD CD FF 2B 04 6647          		CALL    TEST_FP            ;TEST RANGE
0422E1 20 0F       6648          		JR      NZ,IMUL1        ;TOO BIG
0422E3 CB 7A       6649          		BIT     7,D
0422E5 20 0B       6650          		JR      NZ,IMUL1
0422E7 CD D7 2B 04 6651          		CALL    SWAP_FP
0422EB 4A          6652          		LD      C,D             ;INTEGER MARKER
0422EC 08          6653          		EX      AF,AF'
0422ED F0          6654          		RET     P
0422EE C3 DA 2A 04 6655          		JP      NEGATE
0422F2             6656  ;
0422F2 0D          6657  IMUL1:			DEC     C
0422F3 D9          6658          		EXX
0422F4 CB 23       6659          		SLA     E
0422F6 CB 12       6660          		RL      D
0422F8 D9          6661          		EXX
0422F9 CB 13       6662          		RL      E
0422FB CB 12       6663          		RL      D
0422FD D9          6664          		EXX
0422FE 52 ED 6A    6665          		ADC.S   HL,HL
042301 D9          6666          		EXX
042302 52 ED 6A    6667          		ADC.S   HL,HL
042305 F2 F2 22 04 6668          		JP      P,IMUL1         ;NORMALISE
042309 08          6669          		EX      AF,AF'
04230A F8          6670          		RET     M
04230B CB BC       6671          		RES     7,H             ;POSITIVE
04230D C9          6672          		RET
04230E             6673  ;
04230E             6674  ;FMUL - Floating point multiplication with rounding.
04230E             6675  ;
04230E 05          6676  FMUL:			DEC     B               ;TEST FOR ZERO
04230F 04          6677          		INC     B
042310 CA 23 2C 04 6678          		JP      Z,ZERO_FP
042314 0D          6679          		DEC     C               ;TEST FOR ZERO
042315 0C          6680          		INC     C
042316 C8          6681          		RET     Z
042317 7C          6682          		LD      A,H
042318 AA          6683          		XOR     D               ;CALC. RESULT SIGN
042319 08          6684          		EX      AF,AF'
04231A CB FA       6685          		SET     7,D             ;REPLACE IMPLIED 1's
04231C CB FC       6686          		SET     7,H
04231E C5          6687          		PUSH    BC              ;SAVE EXPONENTS
04231F 44          6688          		LD      B,H             ;LOAD REGISTERS
042320 4D          6689          		LD      C,L
042321 21 00 00 00 6690          		LD      HL,0
042325 D9          6691          		EXX
042326 44          6692          		LD      B,H
042327 4D          6693          		LD      C,L
042328 21 00 00 00 6694          		LD      HL,0
04232C 3E E0       6695          		LD      A,-32           ;LOOP COUNTER
04232E CD 9B 2D 04 6696          		CALL    MULA            ;MULTIPLY
042332 DC B1 2D 04 6697          		CALL    C,MULB          ;NORMALISE & INC A
042336 D9          6698          		EXX
042337 E5          6699          		PUSH    HL
042338 21 00 80 00 6700          		LD      HL,8000H
04233C B7          6701          		OR      A               ;CLEAR CARRY
04233D 52 ED 52    6702          		SBC.S   HL,DE
042340 E1          6703          		POP     HL
042341 CC D1 2B 04 6704          		CALL    Z,ODD           ;ROUND UNBIASSED
042345 DC BF 2B 04 6705          		CALL    C,ADD1_FP          ;ROUND UP
042349 C1          6706          		POP     BC              ;RESTORE EXPONENTS
04234A DC EC 2B 04 6707          		CALL    C,INCC
04234E 1F          6708          		RRA                     ;LSB OF A TO CARRY
04234F 79          6709          		LD      A,C             ;COMPUTE NEW EXPONENT
042350 88          6710          		ADC     A,B
042351 38 06       6711  CHKOVF:			JR      C,CHKO1
042353 F2 23 2C 04 6712          		JP      P,ZERO_FP          ;UNDERFLOW
042357 18 04       6713          		JR      CHKO2
042359 FA EE 2B 04 6714  CHKO1:			JP      M,OFLOW         ;OVERFLOW
04235D C6 80       6715  CHKO2:			ADD     A,80H
04235F 4F          6716          		LD      C,A
042360 CA 23 2C 04 6717          		JP      Z,ZERO_FP
042364 08          6718          		EX      AF,AF'          ;RESTORE SIGN BIT
042365 CB BC       6719          		RES     7,H
042367 F0          6720          		RET     P
042368 CB FC       6721          		SET     7,H
04236A C9          6722          		RET
04236B             6723  ;
04236B             6724  ;IPOW - Integer involution.
04236B             6725  ;
04236B CD D7 2B 04 6726  IPOW:			CALL    SWAP_FP
04236F CB 7C       6727          		BIT     7,H
042371 F5          6728          		PUSH    AF              ;SAVE SIGN
042372 C4 DA 2A 04 6729          		CALL    NZ,NEGATE
042376 48          6730  IPOW0:			LD      C,B
042377 06 20       6731          		LD      B,32            ;LOOP COUNTER
042379 CD 8F 2C 04 6732  IPOW1:			CALL    X2
04237D 38 08       6733          		JR      C,IPOW2
04237F 10 F8       6734          		DJNZ    IPOW1
042381 F1          6735          		POP     AF
042382 D9          6736          		EXX
042383 2C          6737          		INC     L               ;RESULT=1
042384 D9          6738          		EXX
042385 4C          6739          		LD      C,H
042386 C9          6740          		RET
042387             6741  ;
042387 F1          6742  IPOW2:			POP     AF
042388 C5          6743          		PUSH    BC
042389 EB          6744          		EX      DE,HL
04238A E5          6745          		PUSH    HL
04238B D9          6746          		EXX
04238C EB          6747          		EX      DE,HL
04238D E5          6748          		PUSH    HL
04238E D9          6749          		EXX
04238F DD 21 00 00 6750          		LD      IX,0
       00          
042394 DD 39       6751          		ADD     IX,SP
042396 28 48       6752          		JR      Z,IPOW4
042398 C5          6753          		PUSH    BC
042399 D9          6754          		EXX
04239A D5          6755          		PUSH    DE
04239B D9          6756          		EXX
04239C D5          6757          		PUSH    DE
04239D CD A6 2B 04 6758          		CALL    SFLOAT_FP
0423A1 CD DA 26 04 6759          		CALL    RECIP
0423A5 DD 71 04    6760          		LD      (IX+4),C
0423A8 D9          6761          		EXX
0423A9 DD 75 00    6762          		LD      (IX+0),L
0423AC DD 74 01    6763          		LD      (IX+1),H
0423AF D9          6764          		EXX
0423B0 DD 75 02    6765          		LD      (IX+2),L
0423B3 DD 74 03    6766          		LD      (IX+3),H
0423B6 18 21       6767          		JR      IPOW5
0423B8             6768  ;
0423B8 C5          6769  IPOW3:			PUSH    BC
0423B9 D9          6770          		EXX
0423BA CB 23       6771          		SLA     E
0423BC CB 12       6772          		RL      D
0423BE D5          6773          		PUSH    DE
0423BF D9          6774          		EXX
0423C0 CB 13       6775          		RL      E
0423C2 CB 12       6776          		RL      D
0423C4 D5          6777          		PUSH    DE
0423C5 3E 0A       6778          		LD      A,'*' & 0FH
0423C7 F5          6779          		PUSH    AF
0423C8 CD A3 2C 04 6780          		CALL    COPY_
0423CC CD 83 20 04 6781          		CALL    OP              ;SQUARE
0423D0 F1          6782          		POP     AF
0423D1 CD CF 29 04 6783          		CALL    DLOAD5
0423D5 DC 83 20 04 6784          		CALL    C,OP            ;MULTIPLY BY X
0423D9 D1          6785  IPOW5:			POP     DE
0423DA D9          6786          		EXX
0423DB D1          6787          		POP     DE
0423DC D9          6788          		EXX
0423DD 79          6789          		LD      A,C
0423DE C1          6790          		POP     BC
0423DF 4F          6791          		LD      C,A
0423E0 10 D6       6792  IPOW4:			DJNZ    IPOW3
0423E2 F1          6793          		POP     AF
0423E3 F1          6794          		POP     AF
0423E4 F1          6795          		POP     AF
0423E5 C9          6796          		RET
0423E6             6797  ;
0423E6 F1          6798  FPOW0:			POP     AF
0423E7 F1          6799          		POP     AF
0423E8 F1          6800          		POP     AF
0423E9 18 8B       6801          		JR      IPOW0
0423EB             6802  ;
0423EB             6803  ;FPOW - Floating-point involution.
0423EB             6804  ;
0423EB CB 7A       6805  FPOW:			BIT     7,D
0423ED F5          6806          		PUSH    AF
0423EE CD D7 2B 04 6807          		CALL    SWAP_FP
0423F2 CD B3 2C 04 6808          		CALL    PUSH5
0423F6 0D          6809          		DEC     C
0423F7 0C          6810          		INC     C
0423F8 28 EC       6811          		JR      Z,FPOW0
0423FA 3E 9E       6812          		LD      A,158
0423FC B9          6813          		CP      C
0423FD 38 0A       6814          		JR      C,FPOW1
0423FF 3C          6815          		INC     A
042400 CD AB 2A 04 6816          		CALL    FIX
042404 08          6817          		EX      AF,AF'
042405 F2 E6 23 04 6818          		JP      P,FPOW0
042409 CD D7 2B 04 6819  FPOW1:			CALL    SWAP_FP
04240D CD F7 26 04 6820          		CALL    LN0
042411 CD BC 2C 04 6821          		CALL    POP5
042415 F1          6822          		POP     AF
042416 CD 0E 23 04 6823          		CALL    FMUL
04241A C3 59 26 04 6824          		JP      EXP0
04241E             6825  ;
04241E             6826  ;Integer and floating-point compare.
04241E             6827  ;Result is TRUE (-1) or FALSE (0).
04241E             6828  ;
04241E CD 2D 2C 04 6829  FLT:			CALL    FCP
042422 18 04       6830          		JR      ILT1
042424 CD 1F 2C 04 6831  ILT:			CALL    ICP
042428 D0          6832  ILT1:			RET     NC
042429 18 42       6833          		JR      TRUE_FP
04242B             6834  ;
04242B CD 2D 2C 04 6835  FGT:			CALL    FCP
04242F 18 04       6836          		JR      IGT1
042431 CD 1F 2C 04 6837  IGT:			CALL    ICP
042435 C8          6838  IGT1:			RET     Z
042436 D8          6839          		RET     C
042437 18 34       6840          		JR      TRUE_FP
042439             6841  ;
042439 CD 2D 2C 04 6842  FGE:			CALL    FCP
04243D 18 04       6843          		JR      IGE1
04243F CD 1F 2C 04 6844  IGE:			CALL    ICP
042443 D8          6845  IGE1:			RET     C
042444 18 27       6846          		JR      TRUE_FP
042446             6847  ;
042446 CD 2D 2C 04 6848  FLE:			CALL    FCP
04244A 18 04       6849          		JR      ILE1
04244C CD 1F 2C 04 6850  ILE:			CALL    ICP
042450 28 1B       6851  ILE1:			JR      Z,TRUE_FP
042452 D0          6852          		RET     NC
042453 18 18       6853          		JR      TRUE_FP
042455             6854  ;
042455 CD 2D 2C 04 6855  FNE:			CALL    FCP
042459 18 04       6856          		JR      INE1
04245B CD 1F 2C 04 6857  INE:			CALL    ICP
04245F C8          6858  INE1:			RET     Z
042460 18 0B       6859          		JR      TRUE_FP
042462             6860  ;
042462 CD 2D 2C 04 6861  FEQ:			CALL    FCP
042466 18 04       6862          		JR      IEQ1
042468 CD 1F 2C 04 6863  IEQ:			CALL    ICP
04246C C0          6864  IEQ1:			RET     NZ
04246D 21 FF FF FF 6865  TRUE_FP:			LD      HL,-1
042471 D9          6866          		EXX
042472 21 FF FF FF 6867          		LD      HL,-1
042476 D9          6868          		EXX
042477 AF          6869          		XOR     A
042478 4F          6870          		LD      C,A
042479 C9          6871          		RET
04247A             6872  ;
04247A             6873  ;FUNCTIONS:
04247A             6874  ;
04247A             6875  ;Result returned in HLH'L'C (floating point)
04247A             6876  ;Result returned in HLH'L' (C=0) (integer)
04247A             6877  ;All registers except IY destroyed.
04247A             6878  ;
04247A             6879  ;ABS - Absolute value
04247A             6880  ;Result is numeric, variable type.
04247A             6881  ;
04247A CB 7C       6882  ABSV_FP:			BIT     7,H
04247C C8          6883          		RET     Z               ;POSITIVE/ZERO
04247D 0D          6884          		DEC     C
04247E 0C          6885          		INC     C
04247F CA DA 2A 04 6886          		JP      Z,NEGATE        ;INTEGER
042483 CB BC       6887          		RES     7,H
042485 C9          6888          		RET
042486             6889  ;
042486             6890  ;NOT - Complement integer.
042486             6891  ;Result is integer numeric.
042486             6892  ;
042486 CD CA 2A 04 6893  NOTK_FP:			CALL    SFIX_FP
04248A 7C          6894          		LD      A,H
04248B 2F          6895          		CPL
04248C 67          6896          		LD      H,A
04248D 7D          6897          		LD      A,L
04248E 2F          6898          		CPL
04248F 6F          6899          		LD      L,A
042490 D9          6900          		EXX
042491 7C          6901          		LD      A,H
042492 2F          6902          		CPL
042493 67          6903          		LD      H,A
042494 7D          6904          		LD      A,L
042495 2F          6905          		CPL
042496 6F          6906          		LD      L,A
042497 D9          6907          		EXX
042498 AF          6908          		XOR     A               ;NUMERIC MARKER
042499 C9          6909          		RET
04249A             6910  ;
04249A             6911  ;PI - Return PI (3.141592654)
04249A             6912  ;Result is floating-point numeric.
04249A             6913  ;
04249A 21 0F 49 00 6914  PI_FP:			LD      HL,490FH
04249E D9          6915          		EXX
04249F 21 A2 DA 00 6916          		LD      HL,0DAA2H
0424A3 D9          6917          		EXX
0424A4 0E 81       6918          		LD      C,81H
0424A6 AF          6919          		XOR     A               ;NUMERIC MARKER
0424A7 C9          6920          		RET
0424A8             6921  ;
0424A8             6922  ;DEG - Convert radians to degrees
0424A8             6923  ;Result is floating-point numeric.
0424A8             6924  ;
0424A8 CD BC 24 04 6925  DEG_FP:			CALL    FPI180
0424AC CD 0E 23 04 6926          		CALL    FMUL
0424B0 AF          6927          		XOR     A
0424B1 C9          6928          		RET
0424B2             6929  ;
0424B2             6930  ;RAD - Convert degrees to radians
0424B2             6931  ;Result is floating-point numeric.
0424B2             6932  ;
0424B2 CD BC 24 04 6933  RAD_FP:			CALL    FPI180
0424B6 CD 65 22 04 6934          		CALL    FDIV
0424BA AF          6935          		XOR     A
0424BB C9          6936          		RET
0424BC             6937  ;
0424BC             6938  ;180/PI
0424BC             6939  ;
0424BC CD A6 2B 04 6940  FPI180:			CALL    SFLOAT_FP
0424C0 11 2E 65 00 6941          		LD      DE,652EH
0424C4 D9          6942          		EXX
0424C5 11 D3 E0 00 6943          		LD      DE,0E0D3H
0424C9 D9          6944          		EXX
0424CA 06 85       6945          		LD      B,85H
0424CC C9          6946          		RET
0424CD             6947  ;
0424CD             6948  ;SGN - Return -1, 0 or +1
0424CD             6949  ;Result is integer numeric.
0424CD             6950  ;
0424CD CD FF 2B 04 6951  SGN_FP:			CALL    TEST_FP
0424D1 B1          6952          		OR      C
0424D2 C8          6953          		RET     Z               ;ZERO
0424D3 CB 7C       6954          		BIT     7,H
0424D5 C2 6D 24 04 6955          		JP      NZ,TRUE_FP         ;-1
0424D9 CD 23 2C 04 6956          		CALL    ZERO_FP
0424DD C3 BF 2B 04 6957          		JP      ADD1_FP            ;1
0424E1             6958  ;
0424E1             6959  ;VAL - Return numeric value of string.
0424E1             6960  ;Input: ASCII string at IX
0424E1             6961  ;Result is variable type numeric.
0424E1             6962  ;
0424E1 CD 3D 2E 04 6963  VAL_FP:			CALL    SIGNQ
0424E5 F5          6964          		PUSH    AF
0424E6 CD ED 29 04 6965          		CALL    CON_FP
0424EA F1          6966          		POP     AF
0424EB FE 2D       6967          		CP      '-'
0424ED 3E 00       6968          		LD      A,0             ;NUMERIC MARKER
0424EF C0          6969          		RET     NZ
0424F0 0D          6970          		DEC     C
0424F1 0C          6971          		INC     C
0424F2 CA DA 2A 04 6972          		JP      Z,NEGATE        ;ZERO/INTEGER
0424F6 7C          6973          		LD      A,H
0424F7 EE 80       6974          		XOR     80H             ;CHANGE SIGN (FP)
0424F9 67          6975          		LD      H,A
0424FA AF          6976          		XOR     A
0424FB C9          6977          		RET
0424FC             6978  ;
0424FC             6979  ;INT - Floor function
0424FC             6980  ;Result is integer numeric.
0424FC             6981  ;
0424FC 0D          6982  INT_FP_:			DEC     C
0424FD 0C          6983          		INC     C
0424FE C8          6984          		RET     Z               ;ZERO/INTEGER
0424FF 3E 9F       6985          		LD      A,159
042501 44          6986          		LD      B,H             ;B7=SIGN BIT
042502 CD AB 2A 04 6987          		CALL    FIX
042506 08          6988          		EX      AF,AF'
042507 A0          6989          		AND     B
042508 FC BF 2B 04 6990          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04250C 78          6991          		LD      A,B
04250D B7          6992          		OR      A
04250E FC DA 2A 04 6993          		CALL    M,NEGATE
042512 AF          6994          		XOR     A
042513 4F          6995          		LD      C,A
042514 C9          6996          		RET
042515             6997  ;
042515             6998  ;SQR - square root
042515             6999  ;Result is floating-point numeric.
042515             7000  ;
042515 CD A6 2B 04 7001  SQR_FP:			CALL    SFLOAT_FP
042519 CB 7C       7002  SQR0:			BIT     7,H
04251B 3E 15       7003          		LD      A,NGROOT
04251D C2 7D 20 04 7004          		JP      NZ,ERROR_FP_        ;"-ve root"
042521 0D          7005          		DEC     C
042522 0C          7006          		INC     C
042523 C8          7007          		RET     Z               ;ZERO
042524 CB FC       7008          		SET     7,H             ;IMPLIED 1
042526 CB 41       7009          		BIT     0,C
042528 CC DF 2B 04 7010          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
04252C 79          7011          		LD      A,C
04252D D6 80       7012          		SUB     80H
04252F CB 2F       7013          		SRA     A               ;HALVE EXPONENT
042531 C6 80       7014          		ADD     A,80H
042533 4F          7015          		LD      C,A
042534 C5          7016          		PUSH    BC              ;SAVE EXPONENT
042535 EB          7017          		EX      DE,HL
042536 21 00 00 00 7018          		LD      HL,0
04253A 44          7019          		LD      B,H
04253B 4D          7020          		LD      C,L
04253C D9          7021          		EXX
04253D EB          7022          		EX      DE,HL
04253E 21 00 00 00 7023          		LD      HL,0
042542 44          7024          		LD      B,H
042543 4D          7025          		LD      C,L
042544 3E E1       7026          		LD      A,-31
042546 CD D5 2D 04 7027          		CALL    SQRA            ;ROOT
04254A D9          7028          		EXX
04254B CB 78       7029          		BIT     7,B
04254D D9          7030          		EXX
04254E CC D5 2D 04 7031          		CALL    Z,SQRA          ;NORMALISE & INC A
042552 CD 16 2E 04 7032          		CALL    SQRB
042556 B7          7033          		OR      A               ;CLEAR CARRY
042557 CD 83 2D 04 7034          		CALL    DIVB
04255B CB 1B       7035          		RR      E               ;LSB TO CARRY
04255D 60          7036          		LD      H,B
04255E 69          7037          		LD      L,C
04255F D9          7038          		EXX
042560 60          7039          		LD      H,B
042561 69          7040          		LD      L,C
042562 DC BF 2B 04 7041          		CALL    C,ADD1_FP          ;ROUND UP
042566 C1          7042          		POP     BC              ;RESTORE EXPONENT
042567 DC EC 2B 04 7043          		CALL    C,INCC
04256B 1F          7044          		RRA
04256C 9F          7045          		SBC     A,A
04256D 81          7046          		ADD     A,C
04256E 4F          7047          		LD      C,A
04256F CB BC       7048          		RES     7,H             ;POSITIVE
042571 AF          7049          		XOR     A
042572 C9          7050          		RET
042573             7051  ;
042573             7052  ;TAN - Tangent function
042573             7053  ;Result is floating-point numeric.
042573             7054  ;
042573 CD A6 2B 04 7055  TAN_FP:			CALL    SFLOAT_FP
042577 CD B3 2C 04 7056          		CALL    PUSH5
04257B CD 9D 25 04 7057          		CALL    COS0
04257F CD BC 2C 04 7058          		CALL    POP5
042583 CD B3 2C 04 7059          		CALL    PUSH5
042587 CD D7 2B 04 7060          		CALL    SWAP_FP
04258B CD AA 25 04 7061          		CALL    SIN0
04258F CD BC 2C 04 7062          		CALL    POP5
042593 CD 65 22 04 7063          		CALL    FDIV
042597 AF          7064          		XOR     A               ;NUMERIC MARKER
042598 C9          7065          		RET
042599             7066  ;
042599             7067  ;COS - Cosine function
042599             7068  ;Result is floating-point numeric.
042599             7069  ;
042599 CD A6 2B 04 7070  COS_FP:			CALL    SFLOAT_FP
04259D CD 02 2B 04 7071  COS0:			CALL    SCALE
0425A1 1C          7072          		INC     E
0425A2 1C          7073          		INC     E
0425A3 7B          7074          		LD      A,E
0425A4 18 10       7075          		JR      SIN1
0425A6             7076  ;
0425A6             7077  ;SIN - Sine function
0425A6             7078  ;Result is floating-point numeric.
0425A6             7079  ;
0425A6 CD A6 2B 04 7080  SIN_FP:			CALL    SFLOAT_FP
0425AA E5          7081  SIN0:			PUSH    HL              ;H7=SIGN
0425AB CD 02 2B 04 7082          		CALL    SCALE
0425AF F1          7083          		POP     AF
0425B0 07          7084          		RLCA
0425B1 07          7085          		RLCA
0425B2 07          7086          		RLCA
0425B3 E6 04       7087          		AND     4
0425B5 AB          7088          		XOR     E
0425B6 F5          7089  SIN1:			PUSH    AF              ;OCTANT
0425B7 CB BC       7090          		RES     7,H
0425B9 1F          7091          		RRA
0425BA CD 48 26 04 7092          		CALL    PIBY4
0425BE DC E9 21 04 7093          		CALL    C,RSUB          ;X=(PI/4)-X
0425C2 F1          7094          		POP     AF
0425C3 F5          7095          		PUSH    AF
0425C4 E6 03       7096          		AND     3
0425C6 E2 FF 25 04 7097          		JP      PO,SIN2         ;USE COSINE APPROX.
0425CA CD B3 2C 04 7098          		CALL    PUSH5           ;SAVE X
0425CE CD AB 2C 04 7099          		CALL    SQUARE          ;PUSH X*X
0425D2 CD F0 2C 04 7100          		CALL    POLY
0425D6 B7 A8       7101          		DW	0A8B7H          ;a(8)
0425D8 11 36       7102          		DW	3611H
0425DA 6D          7103          		DB	6DH
0425DB 26 DE       7104          		DW	0DE26H          ;a(6)
0425DD 05 D0       7105          		DW	0D005H
0425DF 73          7106          		DB	73H
0425E0 C0 80       7107          		DW	80C0H           ;a(4)
0425E2 88 08       7108          		DW	888H
0425E4 79          7109          		DB	79H
0425E5 9D AA       7110          		DW	0AA9DH          ;a(2)
0425E7 AA AA       7111          		DW	0AAAAH
0425E9 7D          7112          		DB	7DH
0425EA 00 00       7113          		DW	0               ;a(0)
0425EC 00 00       7114          		DW	0
0425EE 80          7115          		DB	80H
0425EF CD BC 2C 04 7116          		CALL    POP5
0425F3 CD BC 2C 04 7117          		CALL    POP5
0425F7 CD 0E 23 04 7118          		CALL    FMUL
0425FB C3 24 26 04 7119          		JP      SIN3
0425FF             7120  ;
0425FF CD AB 2C 04 7121  SIN2:			CALL    SQUARE          ;PUSH X*X
042603 CD F0 2C 04 7122          		CALL    POLY
042607 71 D5       7123          		DW	0D571H          ;b(8)
042609 78 4C       7124          		DW	4C78H
04260B 70          7125          		DB	70H
04260C AF 94       7126          		DW	94AFH           ;b(6)
04260E 03 B6       7127          		DW	0B603H
042610 76          7128          		DB	76H
042611 C8 9C       7129          		DW	9CC8H           ;b(4)
042613 AA 2A       7130          		DW	2AAAH
042615 7B          7131          		DB	7BH
042616 DD FF       7132          		DW	0FFDDH          ;b(2)
042618 FF FF       7133          		DW	0FFFFH
04261A 7E          7134          		DB	7EH
04261B 00 00       7135          		DW	0               ;b(0)
04261D 00 00       7136          		DW	0
04261F 80          7137          		DB	80H
042620 CD BC 2C 04 7138          		CALL    POP5
042624 F1          7139  SIN3:			POP     AF
042625 E6 04       7140          		AND     4
042627 C8          7141          		RET     Z
042628 0D          7142          		DEC     C
042629 0C          7143          		INC     C
04262A C8          7144          		RET     Z               ;ZERO
04262B CB FC       7145          		SET     7,H             ;MAKE NEGATIVE
04262D C9          7146          		RET
04262E             7147  ;
04262E             7148  ;Floating-point one:
04262E             7149  ;
04262E 21 00 00 00 7150  FONE_FP:			LD      HL,0
042632 D9          7151          		EXX
042633 21 00 00 00 7152          		LD      HL,0
042637 D9          7153          		EXX
042638 0E 80       7154          		LD      C,80H
04263A C9          7155          		RET
04263B             7156  ;
04263B 11 00 00 00 7157  DONE:			LD      DE,0
04263F D9          7158          		EXX
042640 11 00 00 00 7159          		LD      DE,0
042644 D9          7160          		EXX
042645 06 80       7161          		LD      B,80H
042647 C9          7162          		RET
042648             7163  ;
042648 11 0F 49 00 7164  PIBY4:			LD      DE,490FH
04264C D9          7165          		EXX
04264D 11 A2 DA 00 7166          		LD      DE,0DAA2H
042651 D9          7167          		EXX
042652 06 7F       7168          		LD      B,7FH
042654 C9          7169          		RET
042655             7170  ;
042655             7171  ;EXP - Exponential function
042655             7172  ;Result is floating-point numeric.
042655             7173  ;
042655 CD A6 2B 04 7174  EXP_FP:			CALL    SFLOAT_FP
042659 CD E6 26 04 7175  EXP0:			CALL    LN2             ;LN(2)
04265D D9          7176          		EXX
04265E 1D          7177  	        	DEC     E
04265F 01 CF D1 00 7178  		        LD      BC,0D1CFH       ;0.6931471805599453
042663 D9          7179          		EXX
042664 E5          7180          		PUSH    HL              ;H7=SIGN
042665 CD 15 2B 04 7181          		CALL    MOD48           ;"MODULUS"
042669 F1          7182          		POP     AF
04266A CB 7B       7183          		BIT     7,E
04266C 28 0B       7184          		JR      Z,EXP1
04266E 17          7185          		RLA
04266F DA 23 2C 04 7186          		JP      C,ZERO_FP
042673 3E 18       7187          		LD      A,EXPRNG
042675 C3 7D 20 04 7188          		JP      ERROR_FP_           ;"Exp range"
042679             7189  ;
042679 E6 80       7190  EXP1:			AND     80H
04267B B3          7191          		OR      E
04267C F5          7192          		PUSH    AF              ;INTEGER PART
04267D CB BC       7193          		RES     7,H
04267F CD B3 2C 04 7194          		CALL    PUSH5           ;PUSH X*LN(2)
042683 CD F0 2C 04 7195          		CALL    POLY
042687 72 40       7196          		DW	4072H           ;a(7)
042689 2E 94       7197          		DW	942EH
04268B 73          7198          		DB	73H
04268C 65 6F       7199          		DW	6F65H           ;a(6)
04268E 4F 2E       7200          		DW	2E4FH
042690 76          7201          		DB	76H
042691 37 6D       7202          		DW	6D37H           ;a(5)
042693 02 88       7203          		DW	8802H
042695 79          7204          		DB	79H
042696 12 E5       7205          		DW	0E512H          ;a(4)
042698 A0 2A       7206          		DW	2AA0H
04269A 7B          7207          		DB	7BH
04269B 14 4F       7208          		DW	4F14H           ;a(3)
04269D AA AA       7209          		DW	0AAAAH
04269F 7D          7210          		DB	7DH
0426A0 56 FD       7211          		DW	0FD56H          ;a(2)
0426A2 FF 7F       7212          		DW	7FFFH
0426A4 7E          7213          		DB	7EH
0426A5 FE FF       7214          		DW	0FFFEH          ;a(1)
0426A7 FF FF       7215          		DW	0FFFFH
0426A9 7F          7216          		DB	7FH
0426AA 00 00       7217          		DW	0               ;a(0)
0426AC 00 00       7218          		DW	0
0426AE 80          7219          		DB	80H
0426AF CD BC 2C 04 7220          		CALL    POP5
0426B3 F1          7221          		POP     AF
0426B4 F5          7222          		PUSH    AF
0426B5 F4 DA 26 04 7223          		CALL    P,RECIP         ;X=1/X
0426B9 F1          7224          		POP     AF
0426BA F2 C2 26 04 7225          		JP      P,EXP4
0426BE E6 7F       7226          		AND     7FH
0426C0 ED 44       7227          		NEG
0426C2 C6 80       7228  EXP4:			ADD     A,80H
0426C4 81          7229          		ADD     A,C
0426C5 38 06       7230          		JR      C,EXP2
0426C7 F2 23 2C 04 7231          		JP      P,ZERO_FP          ;UNDERFLOW
0426CB 18 04       7232          		JR      EXP3
0426CD FA EE 2B 04 7233  EXP2:			JP      M,OFLOW         ;OVERFLOW
0426D1 C6 80       7234  EXP3:			ADD     A,80H
0426D3 CA 23 2C 04 7235          		JP      Z,ZERO_FP
0426D7 4F          7236          		LD      C,A
0426D8 AF          7237          		XOR     A               ;NUMERIC MARKER
0426D9 C9          7238          		RET
0426DA             7239  ;
0426DA CD 3B 26 04 7240  RECIP:			CALL    DONE
0426DE CD D7 2B 04 7241  RDIV:			CALL    SWAP_FP
0426E2 C3 65 22 04 7242          		JP      FDIV            ;RECIPROCAL
0426E6             7243  ;
0426E6 11 72 31 00 7244  LN2:			LD      DE,3172H        ;LN(2)
0426EA D9          7245          		EXX
0426EB 11 F8 17 00 7246          		LD      DE,17F8H
0426EF D9          7247          		EXX
0426F0 06 7F       7248          		LD      B,7FH
0426F2 C9          7249          		RET
0426F3             7250  ;
0426F3             7251  ;LN - Natural log.
0426F3             7252  ;Result is floating-point numeric.
0426F3             7253  ;
0426F3 CD A6 2B 04 7254  LN_FP:			CALL    SFLOAT_FP
0426F7 3E 16       7255  LN0:			LD      A,LOGRNG
0426F9 CB 7C       7256          		BIT     7,H
0426FB C2 7D 20 04 7257          		JP      NZ,ERROR_FP_        ;"Log range"
0426FF 0C          7258          		INC     C
042700 0D          7259          		DEC     C
042701 CA 7D 20 04 7260          		JP      Z,ERROR_FP_
042705 11 04 35 00 7261          		LD      DE,3504H        ;SQR(2)
042709 D9          7262          		EXX
04270A 11 33 F3 00 7263          		LD      DE,0F333H       ;1.41421356237
04270E D9          7264          		EXX
04270F CD 36 2C 04 7265          		CALL    ICP0            ;MANTISSA>SQR(2)?
042713 79          7266          		LD      A,C             ;EXPONENT
042714 0E 80       7267          		LD      C,80H           ;1 <= X < 2
042716 38 02       7268          		JR      C,LN4
042718 0D          7269          		DEC     C
042719 3C          7270          		INC     A
04271A F5          7271  LN4:			PUSH    AF              ;SAVE EXPONENT
04271B CD C8 2C 04 7272          		CALL    RATIO           ;X=(X-1)/(X+1)
04271F CD B3 2C 04 7273          		CALL    PUSH5
042723 CD AB 2C 04 7274  		        CALL    SQUARE          ;PUSH X*X
042727 CD F0 2C 04 7275          		CALL    POLY
04272B 48 CC       7276          		DW	0CC48H          ;a(9)
04272D FB 74       7277          		DW	74FBH
04272F 7D          7278          		DB	7DH
042730 AF AE       7279          		DW	0AEAFH          ;a(7)
042732 FF 11       7280          		DW	11FFH
042734 7E          7281          		DB	7EH
042735 8C D9       7282          		DW	0D98CH          ;a(5)
042737 CD 4C       7283          		DW	4CCDH
042739 7E          7284          		DB	7EH
04273A E3 A9       7285          		DW	0A9E3H          ;a(3)
04273C AA 2A       7286          		DW	2AAAH
04273E 7F          7287          		DB	7FH
04273F 00 00       7288          		DW	0               ;a(1)
042741 00 00       7289          		DW	0
042743 81          7290          		DB	81H
042744 CD BC 2C 04 7291          		CALL    POP5
042748 CD BC 2C 04 7292          		CALL    POP5
04274C CD 0E 23 04 7293          		CALL    FMUL
042750 F1          7294          		POP     AF              ;EXPONENT
042751 CD B3 2C 04 7295          		CALL    PUSH5
042755 08          7296          		EX      AF,AF'
042756 CD 23 2C 04 7297          		CALL    ZERO_FP
04275A 08          7298          		EX      AF,AF'
04275B D6 80       7299          		SUB     80H
04275D 28 1F       7300          		JR      Z,LN3
04275F 30 02       7301          		JR      NC,LN1
042761 2F          7302          		CPL
042762 3C          7303          		INC     A
042763 67          7304  LN1:			LD      H,A
042764 0E 87       7305          		LD      C,87H
042766 F5          7306          		PUSH    AF
042767 CD 86 2B 04 7307          		CALL    FLOAT_
04276B CB BC       7308          		RES     7,H
04276D CD E6 26 04 7309          		CALL    LN2
042771 CD 0E 23 04 7310          		CALL    FMUL
042775 F1          7311          		POP     AF
042776 30 06       7312          		JR      NC,LN3
042778 FA 7E 27 04 7313          		JP      M,LN3
04277C CB FC       7314          		SET     7,H
04277E CD BC 2C 04 7315  LN3:			CALL    POP5
042782 CD FC 21 04 7316          		CALL    FADD
042786 AF          7317          		XOR     A
042787 C9          7318          		RET
042788             7319  ;
042788             7320  ;LOG - base-10 logarithm.
042788             7321  ;Result is floating-point numeric.
042788             7322  ;
042788 CD F3 26 04 7323  LOG_FP:			CALL    LN_FP
04278C 11 5B 5E 00 7324          		LD      DE,5E5BH        ;LOG(e)
042790 D9          7325          		EXX
042791 11 A9 D8 00 7326          		LD      DE,0D8A9H
042795 D9          7327          		EXX
042796 06 7E       7328          		LD      B,7EH
042798 CD 0E 23 04 7329          		CALL    FMUL
04279C AF          7330          		XOR     A
04279D C9          7331          		RET
04279E             7332  ;
04279E             7333  ;ASN - Arc-sine
04279E             7334  ;Result is floating-point numeric.
04279E             7335  ;
04279E CD A6 2B 04 7336  ASN_FP:			CALL    SFLOAT_FP
0427A2 CD B3 2C 04 7337          		CALL    PUSH5
0427A6 CD A3 2C 04 7338          		CALL    COPY_
0427AA CD 0E 23 04 7339          		CALL    FMUL
0427AE CD 3B 26 04 7340          		CALL    DONE
0427B2 CD E9 21 04 7341          		CALL    RSUB
0427B6 CD 19 25 04 7342          		CALL    SQR0
0427BA CD BC 2C 04 7343          		CALL    POP5
0427BE 0C          7344          		INC     C
0427BF 0D          7345          		DEC     C
0427C0 3E 02       7346          		LD      A,2
0427C2 D5          7347          		PUSH    DE
0427C3 CA 48 28 04 7348          		JP      Z,ACS1
0427C7 D1          7349          		POP     DE
0427C8 CD DE 26 04 7350          		CALL    RDIV
0427CC 18 04       7351          		JR      ATN0
0427CE             7352  ;
0427CE             7353  ;ATN - arc-tangent
0427CE             7354  ;Result is floating-point numeric.
0427CE             7355  ;
0427CE CD A6 2B 04 7356  ATN_FP:			CALL    SFLOAT_FP
0427D2 E5          7357  ATN0:			PUSH    HL              ;SAVE SIGN
0427D3 CB BC       7358          		RES     7,H
0427D5 11 13 54 00 7359          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0427D9 D9          7360          		EXX
0427DA 11 D0 CC 00 7361          		LD      DE,0CCD0H
0427DE D9          7362          		EXX
0427DF 06 7E       7363          		LD      B,7EH
0427E1 CD 33 2C 04 7364          		CALL    FCP0            ;COMPARE
0427E5 06 00       7365          		LD      B,0
0427E7 38 22       7366          		JR      C,ATN2
0427E9 11 82 1A 00 7367          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0427ED D9          7368          		EXX
0427EE 11 9A 79 00 7369          		LD      DE,799AH
0427F2 D9          7370          		EXX
0427F3 06 81       7371          		LD      B,81H
0427F5 CD 33 2C 04 7372          		CALL    FCP0            ;COMPARE
0427F9 38 0A       7373          		JR      C,ATN1
0427FB CD DA 26 04 7374          		CALL    RECIP           ;X=1/X
0427FF 06 02       7375          		LD      B,2
042801 C3 0B 28 04 7376          		JP      ATN2
042805 CD C8 2C 04 7377  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042809 06 01       7378          		LD      B,1
04280B C5          7379  ATN2:			PUSH    BC              ;SAVE FLAG
04280C CD B3 2C 04 7380          		CALL    PUSH5
042810 CD AB 2C 04 7381          		CALL    SQUARE          ;PUSH X*X
042814 CD F0 2C 04 7382          		CALL    POLY
042818 35 F3       7383          		DW	0F335H          ;a(13)
04281A D8 37       7384          		DW	37D8H
04281C 7B          7385          		DB	7BH
04281D 91 6B       7386          		DW	6B91H           ;a(11)
04281F B9 AA       7387          		DW	0AAB9H
042821 7C          7388          		DB	7CH
042822 DE 41       7389          		DW	41DEH           ;a(9)
042824 97 61       7390          		DW	6197H
042826 7C          7391          		DB	7CH
042827 7B 9D       7392          		DW	9D7BH           ;a(7)
042829 37 92       7393          		DW	9237H
04282B 7D          7394          		DB	7DH
04282C 5A 2A       7395          		DW	2A5AH           ;a(5)
04282E CC 4C       7396          		DW	4CCCH
042830 7D          7397          		DB	7DH
042831 5C A9       7398          		DW	0A95CH          ;a(3)
042833 AA AA       7399          		DW	0AAAAH
042835 7E          7400          		DB	7EH
042836 00 00       7401          		DW	0               ;a(1)
042838 00 00       7402          		DW	0
04283A 80          7403          		DB	80H
04283B CD BC 2C 04 7404          		CALL    POP5
04283F CD BC 2C 04 7405          		CALL    POP5
042843 CD 0E 23 04 7406          		CALL    FMUL
042847 F1          7407          		POP     AF
042848 CD 48 26 04 7408  ACS1:			CALL    PIBY4           ;PI/4
04284C 1F          7409          		RRA
04284D F5          7410          		PUSH    AF
04284E DC FC 21 04 7411          		CALL    C,FADD
042852 F1          7412          		POP     AF
042853 04          7413          		INC     B
042854 1F          7414          		RRA
042855 DC E9 21 04 7415          		CALL    C,RSUB
042859 F1          7416          		POP     AF
04285A B7          7417          		OR      A
04285B F0          7418          		RET     P
04285C CB FC       7419          		SET     7,H             ;MAKE NEGATIVE
04285E AF          7420          		XOR     A
04285F C9          7421          		RET
042860             7422  ;
042860             7423  ;ACS - Arc cosine=PI/2-ASN.
042860             7424  ;Result is floating point numeric.
042860             7425  ;
042860 CD 9E 27 04 7426  ACS_FP:			CALL    ASN_FP
042864 3E 02       7427          		LD      A,2
042866 F5          7428          		PUSH    AF
042867 18 DF       7429          		JR      ACS1
042869             7430  ;
042869             7431  ;Function STR - convert numeric value to ASCII string.
042869             7432  ;   Inputs: HLH'L'C = integer or floating-point number
042869             7433  ;           DE = address at which to store string
042869             7434  ;           IX = address of @% format control
042869             7435  ;  Outputs: String stored, with NUL terminator
042869             7436  ;
042869             7437  ;First normalise for decimal output:
042869             7438  ;
042869 CD A6 2B 04 7439  STR_FP:			CALL    SFLOAT_FP
04286D 06 00       7440          		LD      B,0             ;DEFAULT PT. POSITION
04286F CB 7C       7441          		BIT     7,H             ;NEGATIVE?
042871 28 06       7442          		JR      Z,STR10
042873 CB BC       7443          		RES     7,H
042875 3E 2D       7444          		LD      A,'-'
042877 12          7445          		LD      (DE),A          ;STORE SIGN
042878 13          7446          		INC     DE
042879 AF          7447  STR10:			XOR     A               ;CLEAR A
04287A B9          7448          		CP      C
04287B 28 4E       7449          		JR      Z,STR02          ;ZERO
04287D D5          7450          		PUSH    DE              ;SAVE TEXT POINTER
04287E 78          7451          		LD      A,B
04287F F5          7452  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
042880 79          7453          		LD      A,C             ;BINARY EXPONENT
042881 FE A1       7454          		CP      161
042883 30 1C       7455          		JR      NC,STR14
042885 FE 9B       7456          		CP      155
042887 30 29       7457          		JR      NC,STR15
042889 2F          7458          		CPL
04288A FE E1       7459          		CP      225
04288C 38 02       7460          		JR      C,STR13
04288E 3E F8       7461          		LD      A,-8
042890 C6 1C       7462  STR13:			ADD     A,28
042892 CD 1F 2D 04 7463          		CALL    POWR10
042896 F5          7464          		PUSH    AF
042897 CD 0E 23 04 7465          		CALL    FMUL
04289B F1          7466          		POP     AF
04289C 47          7467          		LD      B,A
04289D F1          7468          		POP     AF
04289E 90          7469          		SUB     B
04289F 18 DE       7470          		JR      STR11
0428A1 D6 20       7471  STR14:			SUB     32
0428A3 CD 1F 2D 04 7472          		CALL    POWR10
0428A7 F5          7473          		PUSH    AF
0428A8 CD 65 22 04 7474          		CALL    FDIV
0428AC F1          7475          		POP     AF
0428AD 47          7476          		LD      B,A
0428AE F1          7477          		POP     AF
0428AF 80          7478          		ADD     A,B
0428B0 18 CD       7479          		JR      STR11
0428B2 3E 09       7480  STR15:			LD      A,9
0428B4 CD 1F 2D 04 7481          		CALL    POWR10          ;10^9
0428B8 CD 33 2C 04 7482          		CALL    FCP0
0428BC 79          7483          		LD      A,C
0428BD C1          7484          		POP     BC
0428BE 4F          7485          		LD      C,A
0428BF CB FC       7486          		SET     7,H             ;IMPLIED 1
0428C1 DC 5B 2C 04 7487          		CALL    C,X10B          ;X10, DEC B
0428C5 D1          7488          		POP     DE              ;RESTORE TEXT POINTER
0428C6 CB B9       7489          		RES     7,C
0428C8 3E 00       7490          		LD      A,0
0428CA 17          7491          		RLA                     ;PUT CARRY IN LSB
0428CB             7492  ;
0428CB             7493  ;At this point decimal normalisation has been done,
0428CB             7494  ;now convert to decimal digits:
0428CB             7495  ;      AHLH'L' = number in normalised integer form
0428CB             7496  ;            B = decimal place adjustment
0428CB             7497  ;            C = binary place adjustment (29-33)
0428CB             7498  ;
0428CB 0C          7499  STR02:			INC     C
0428CC 08          7500          		EX      AF,AF'          ;SAVE A
0428CD 78          7501          		LD      A,B
0428CE DD CB 02 4E 7502          		BIT     1,(IX+2)
0428D2 20 08       7503          		JR      NZ,STR20
0428D4 AF          7504          		XOR     A
0428D5 DD BE 01    7505          		CP      (IX+1)
0428D8 28 0B       7506          		JR      Z,STR21
0428DA 3E F6       7507          		LD      A,-10
0428DC DD 86 01    7508  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0428DF B7          7509          		OR      A               ;CLEAR CARRY
0428E0 FA E5 28 04 7510          		JP      M,STR21
0428E4 AF          7511          		XOR     A
0428E5 F5          7512  STR21:			PUSH    AF
0428E6 08          7513          		EX      AF,AF'          ;RESTORE A
0428E7 CD 8F 2C 04 7514  STR22:			CALL    X2              ;RL AHLH'L'
0428EB 8F          7515          		ADC     A,A
0428EC FE 0A       7516          		CP      10
0428EE 38 05       7517          		JR      C,STR23
0428F0 D6 0A       7518          		SUB     10
0428F2 D9          7519          		EXX
0428F3 2C          7520          		INC     L               ;SET RESULT BIT
0428F4 D9          7521          		EXX
0428F5 0D          7522  STR23:			DEC     C
0428F6 20 EF       7523          		JR      NZ,STR22        ;32 TIMES
0428F8 4F          7524          		LD      C,A             ;REMAINDER
0428F9 7C          7525          		LD      A,H
0428FA E6 3F       7526          		AND     3FH             ;CLEAR OUT JUNK
0428FC 67          7527          		LD      H,A
0428FD F1          7528          		POP     AF
0428FE F2 0C 29 04 7529          		JP      P,STR24
042902 3C          7530          		INC     A
042903 20 1C       7531          		JR      NZ,STR26
042905 3E 04       7532          		LD      A,4
042907 B9          7533          		CP      C               ;ROUND UP?
042908 3E 00       7534          		LD      A,0
04290A 18 15       7535          		JR      STR26
04290C F5          7536  STR24:			PUSH    AF
04290D 79          7537          		LD      A,C
04290E CE 30       7538          		ADC     A,'0'           ;ADD CARRY
042910 FE 30       7539          		CP      '0'
042912 28 05       7540          		JR      Z,STR25         ;SUPPRESS ZERO
042914 FE 3A       7541          		CP      '9'+1
042916 3F          7542          		CCF
042917 30 08       7543          		JR      NC,STR26
042919 E3          7544  STR25:			EX      (SP),HL
04291A CB 75       7545          		BIT     6,L             ;ZERO FLAG
04291C E3          7546  		        EX      (SP),HL
04291D 20 05       7547          		JR      NZ,STR27
04291F 3E 30       7548          		LD      A,'0'
042921 3C          7549  STR26:			INC     A               ;SET +VE
042922 3D          7550          		DEC     A
042923 F5          7551          		PUSH    AF              ;PUT ON STACK + CARRY
042924 04          7552  STR27:			INC     B
042925 CD FF 2B 04 7553          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042929 0E 20       7554          		LD      C,32
04292B 3E 00       7555          		LD      A,0
04292D 20 B8       7556          		JR      NZ,STR22
04292F F1          7557          		POP     AF
042930 F5          7558          		PUSH    AF
042931 3E 00       7559          		LD      A,0
042933 38 B2       7560          		JR      C,STR22
042935             7561  ;
042935             7562  ;At this point, the decimal character string is stored
042935             7563  ; on the stack. Trailing zeroes are suppressed and may
042935             7564  ; need to be replaced.
042935             7565  ;B register holds decimal point position.
042935             7566  ;Now format number and store as ASCII string:
042935             7567  ;
042935 EB          7568  STR3:			EX      DE,HL           ;STRING POINTER
042936 0E FF       7569          		LD      C,-1            ;FLAG "E"
042938 16 01       7570          		LD      D,1
04293A DD 5E 01    7571          		LD      E,(IX+1)        ;f2
04293D DD CB 02 46 7572          		BIT     0,(IX+2)
042941 20 35       7573          		JR      NZ,STR34        ;E MODE
042943 DD CB 02 4E 7574          		BIT     1,(IX+2)
042947 28 12       7575          		JR      Z,STR31
042949 78          7576          		LD      A,B             ;F MODE
04294A B7          7577          		OR      A
04294B 28 05       7578          		JR      Z,STR30
04294D FA 52 29 04 7579          		JP      M,STR30
042951 50          7580          		LD      D,B
042952 7A          7581  STR30:			LD      A,D
042953 DD 86 01    7582          		ADD     A,(IX+1)
042956 5F          7583          		LD      E,A
042957 FE 0B       7584          		CP      11
042959 38 19       7585          		JR      C,STR32
04295B 78          7586  STR31:			LD      A,B             ;G MODE
04295C 11 01 01 00 7587          		LD      DE,101H
042960 B7          7588          		OR      A
042961 FA 78 29 04 7589          		JP      M,STR34
042965 28 0D       7590          		JR      Z,STR32
042967 DD 7E 01    7591          		LD      A,(IX+1)
04296A B7          7592          		OR      A
04296B 20 02       7593          		JR      NZ,STR3A
04296D 3E 0A       7594          		LD      A,10
04296F B8          7595  STR3A:			CP      B
042970 38 06       7596          		JR      C,STR34
042972 50          7597          		LD      D,B
042973 58          7598          		LD      E,B
042974 78          7599  STR32:			LD      A,B
042975 C6 81       7600          		ADD     A,129
042977 4F          7601          		LD      C,A
042978 CB FA       7602  STR34:			SET     7,D
04297A 1D          7603          		DEC     E
04297B 7A          7604  STR35:			LD      A,D
04297C B9          7605          		CP      C
04297D 30 0E       7606          		JR      NC,STR33
04297F F1          7607  STR36:			POP     AF
042980 28 04       7608          		JR      Z,STR37
042982 F2 8F 29 04 7609          		JP      P,STR38
042986 F5          7610  STR37:			PUSH    AF
042987 1C          7611          		INC     E
042988 1D          7612          		DEC     E
042989 FA A0 29 04 7613          		JP      M,STR4
04298D 3E 30       7614  STR33:			LD      A,'0'
04298F 15          7615  STR38:			DEC     D
042990 E2 97 29 04 7616          		JP      PO,STR39
042994 36 2E       7617          		LD      (HL),'.'
042996 23          7618          		INC     HL
042997 77          7619  STR39:			LD      (HL),A
042998 23          7620          		INC     HL
042999 1D          7621          		DEC     E
04299A F2 7B 29 04 7622          		JP      P,STR35
04299E 18 DF       7623          		JR      STR36
0429A0             7624  ;
0429A0 F1          7625  STR4:			POP     AF
0429A1 0C          7626  STR40:			INC     C
0429A2 4D          7627          		LD      C,L
0429A3 20 28       7628          		JR      NZ,STR44
0429A5 36 45       7629          		LD      (HL),'E'        ;EXPONENT
0429A7 23          7630          		INC     HL
0429A8 78          7631          		LD      A,B
0429A9 3D          7632          		DEC     A
0429AA F2 B3 29 04 7633          		JP      P,STR41
0429AE 36 2D       7634          		LD      (HL),'-'
0429B0 23          7635          		INC     HL
0429B1 ED 44       7636          		NEG
0429B3 36 30       7637  STR41:			LD      (HL),'0'
0429B5 28 15       7638          		JR      Z,STR47
0429B7 FE 0A       7639          		CP      10
0429B9 47          7640          		LD      B,A
0429BA 3E 3A       7641          		LD      A,':'
0429BC 38 03       7642          		JR      C,STR42
0429BE 23          7643          		INC     HL
0429BF 36 30       7644          		LD      (HL),'0'
0429C1 34          7645  STR42:			INC     (HL)
0429C2 BE          7646          		CP      (HL)
0429C3 20 05       7647          		JR      NZ,STR43
0429C5 36 30       7648          		LD      (HL),'0'
0429C7 2B          7649          		DEC     HL
0429C8 34          7650          		INC     (HL)
0429C9 23          7651          		INC     HL
0429CA 10 F5       7652  STR43:			DJNZ    STR42
0429CC 23          7653  STR47:			INC     HL
0429CD EB          7654  STR44:			EX      DE,HL
0429CE C9          7655        			RET
0429CF             7656  ;
0429CF             7657  ;Support subroutines:
0429CF             7658  ;
0429CF DD 46 04    7659  DLOAD5:			LD      B,(IX+4)
0429D2 D9          7660          		EXX
0429D3 DD 5E 00    7661          		LD      E,(IX+0)
0429D6 DD 56 01    7662          		LD      D,(IX+1)
0429D9 D9          7663          		EXX
0429DA DD 5E 02    7664          		LD      E,(IX+2)
0429DD DD 56 03    7665          		LD      D,(IX+3)
0429E0 C9          7666          		RET
0429E1             7667  ;
0429E1 DD 46 06    7668  DLOAD5_SPL:		LD      B,(IX+6)
0429E4 D9          7669  			EXX
0429E5 DD 17 00    7670  			LD	DE, (IX+0)
0429E8 D9          7671  			EXX
0429E9 DD 17 03    7672  			LD	DE, (IX+3)
0429EC C9          7673  			RET
0429ED             7674  ;
0429ED             7675  ;CON_FP - Get unsigned numeric constant from ASCII string.
0429ED             7676  ;   Inputs: ASCII string at (IX).
0429ED             7677  ;  Outputs: Variable-type result in HLH'L'C
0429ED             7678  ;           IX updated (points to delimiter)
0429ED             7679  ;           A7 = 0 (numeric marker)
0429ED             7680  ;
0429ED CD 23 2C 04 7681  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0429F1 0E 00       7682          		LD      C,0             ;TRUNCATION COUNTER
0429F3 CD 81 2A 04 7683          		CALL    UINT          ;GET INTEGER PART
0429F7 FE 2E       7684          		CP      '.'
0429F9 06 00       7685          		LD      B,0             ;DECL. PLACE COUNTER
0429FB CC 7F 2A 04 7686          		CALL    Z,NUMBIX        ;GET FRACTION PART
0429FF FE 45       7687          		CP      'E'
042A01 3E 00       7688          		LD      A,0             ;INITIALISE EXPONENT
042A03 CC 4D 2A 04 7689          		CALL    Z,GETEXP        ;GET EXPONENT
042A07 CB 7C       7690          		BIT     7,H
042A09 20 08       7691          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A0B B7          7692          		OR      A
042A0C 20 05       7693          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A0E B8          7694          		CP      B
042A0F 20 02       7695          		JR      NZ,CON0         ;DECIMAL POINT
042A11 B9          7696          		CP      C
042A12 C8          7697          		RET     Z               ;INTEGER
042A13 90          7698  CON0:			SUB     B
042A14 81          7699          		ADD     A,C
042A15 0E 9F       7700          		LD      C,159
042A17 CD 86 2B 04 7701          		CALL    FLOAT_
042A1B CB BC       7702          		RES     7,H             ;DITCH IMPLIED 1
042A1D B7          7703          		OR      A
042A1E C8          7704          		RET     Z               ;DONE
042A1F FA 2D 2A 04 7705          		JP      M,CON2          ;NEGATIVE EXPONENT
042A23 CD 1F 2D 04 7706          		CALL    POWR10
042A27 CD 0E 23 04 7707          		CALL    FMUL            ;SCALE
042A2B AF          7708          		XOR     A
042A2C C9          7709          		RET
042A2D FE DA       7710  CON2:			CP      -38
042A2F 38 0C       7711          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A31 ED 44       7712          		NEG
042A33 CD 1F 2D 04 7713          		CALL    POWR10
042A37 CD 65 22 04 7714          		CALL    FDIV            ;SCALE
042A3B AF          7715          		XOR     A
042A3C C9          7716          		RET
042A3D F5          7717  CON3:			PUSH    AF
042A3E 3E 26       7718          		LD      A,38
042A40 CD 1F 2D 04 7719          		CALL    POWR10
042A44 CD 65 22 04 7720          		CALL    FDIV
042A48 F1          7721          		POP     AF
042A49 C6 26       7722          		ADD     A,38
042A4B 18 E0       7723          		JR      CON2
042A4D             7724  ;
042A4D             7725  ;GETEXP - Get decimal exponent from string
042A4D             7726  ;     Inputs: ASCII string at (IX)
042A4D             7727  ;             (IX points at 'E')
042A4D             7728  ;             A = initial value
042A4D             7729  ;    Outputs: A = new exponent
042A4D             7730  ;             IX updated.
042A4D             7731  ;   Destroys: A,A',IX,F,F'
042A4D             7732  ;
042A4D C5          7733  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A4E 47          7734          		LD      B,A             ;INITIAL VALUE
042A4F 0E 02       7735          		LD      C,2             ;2 DIGITS MAX
042A51 DD 23       7736          		INC     IX              ;BUMP PAST 'E'
042A53 CD 3D 2E 04 7737          		CALL    SIGNQ
042A57 08          7738          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A58 CD 33 2E 04 7739  GETEX1:			CALL    DIGITQ
042A5C 38 18       7740          		JR      C,GETEX2
042A5E 78          7741          		LD      A,B             ;B=B*10
042A5F 87          7742          		ADD     A,A
042A60 87          7743          		ADD     A,A
042A61 80          7744          		ADD     A,B
042A62 87          7745          		ADD     A,A
042A63 47          7746          		LD      B,A
042A64 DD 7E 00    7747          		LD      A,(IX)          ;GET BACK DIGIT
042A67 DD 23       7748          		INC     IX
042A69 E6 0F       7749          		AND     0FH             ;MASK UNWANTED BITS
042A6B 80          7750          		ADD     A,B             ;ADD IN DIGIT
042A6C 47          7751          		LD      B,A
042A6D 0D          7752          		DEC     C
042A6E F2 58 2A 04 7753          		JP      P,GETEX1
042A72 06 64       7754          		LD      B,100           ;FORCE OVERFLOW
042A74 18 E2       7755          		JR      GETEX1
042A76 08          7756  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042A77 FE 2D       7757          		CP      '-'
042A79 78          7758          		LD      A,B
042A7A C1          7759          		POP     BC              ;RESTORE
042A7B C0          7760          		RET     NZ
042A7C ED 44       7761          		NEG                     ;NEGATE EXPONENT
042A7E C9          7762          		RET
042A7F             7763  ;
042A7F             7764  ;UINT: Get unsigned integer from string.
042A7F             7765  ;    Inputs: string at (IX)
042A7F             7766  ;            C = truncated digit count
042A7F             7767  ;                (initially zero)
042A7F             7768  ;            B = total digit count
042A7F             7769  ;            HLH'L' = initial value
042A7F             7770  ;   Outputs: HLH'L' = number (binary integer)
042A7F             7771  ;            A = delimiter.
042A7F             7772  ;            B, C & IX updated
042A7F             7773  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042A7F             7774  ;
042A7F DD 23       7775  NUMBIX:			INC     IX
042A81 CD 33 2E 04 7776  UINT:			CALL    DIGITQ
042A85 D8          7777          		RET     C
042A86 04          7778          		INC     B               ;INCREMENT DIGIT COUNT
042A87 DD 23       7779          		INC     IX
042A89 CD 7C 2C 04 7780          		CALL    X10             ;*10 & COPY OLD VALUE
042A8D 38 15       7781          		JR      C,NUMB1         ;OVERFLOW
042A8F 0D          7782          		DEC     C               ;SEE IF TRUNCATED
042A90 0C          7783          		INC     C
042A91 20 11       7784          		JR      NZ,NUMB1        ;IMPORTANT!
042A93 E6 0F       7785          		AND     0FH
042A95 D9          7786          		EXX
042A96 06 00       7787          		LD      B,0
042A98 4F          7788          		LD      C,A
042A99 52 09       7789          		ADD.S   HL,BC           ;ADD IN DIGIT
042A9B D9          7790          		EXX
042A9C 30 E3       7791          		JR      NC,UINT
042A9E 52 23       7792          		INC.S   HL              ;CARRY
042AA0 7C          7793          		LD      A,H
042AA1 B5          7794          		OR      L
042AA2 20 DD       7795          		JR      NZ,UINT
042AA4 0C          7796  NUMB1:			INC     C               ;TRUNCATION COUNTER
042AA5 CD DA 2B 04 7797          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AA9 18 D6       7798          		JR      UINT
042AAB             7799  ;
042AAB             7800  ;FIX - Fix number to specified exponent value.
042AAB             7801  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AAB             7802  ;            A = desired exponent (A>C)
042AAB             7803  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AAB             7804  ;            fraction shifted into B'C'
042AAB             7805  ;            A'F' positive if integer input
042AAB             7806  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AAB             7807  ;
042AAB 08          7808  FIX:			EX      AF,AF'
042AAC AF          7809          		XOR     A
042AAD 08          7810          		EX      AF,AF'
042AAE CB FC       7811          		SET     7,H             ;IMPLIED 1
042AB0 CD DF 2B 04 7812  FIX1:			CALL    DIV2
042AB4 B9          7813          		CP      C
042AB5 C8          7814          		RET     Z
042AB6 D2 B0 2A 04 7815          		JP      NC,FIX1
042ABA C3 EE 2B 04 7816          		JP      OFLOW
042ABE             7817  ;
042ABE             7818  ;SFIX - Convert to integer if necessary.
042ABE             7819  ;    Input: Variable-type number in HLH'L'C
042ABE             7820  ;   Output: Integer in HLH'L', C=0
042ABE             7821  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042ABE             7822  ;
042ABE             7823  ;NEGATE - Negate HLH'L'
042ABE             7824  ;    Destroys: H,L,H',L',F
042ABE             7825  ;
042ABE CD D7 2B 04 7826  FIX2:			CALL    SWAP_FP
042AC2 CD CA 2A 04 7827          		CALL    SFIX_FP
042AC6 CD D7 2B 04 7828          		CALL    SWAP_FP
042ACA 0D          7829  SFIX_FP:			DEC     C
042ACB 0C          7830          		INC     C
042ACC C8          7831          		RET     Z               ;INTEGER/ZERO
042ACD CB 7C       7832          		BIT     7,H             ;SIGN
042ACF F5          7833          		PUSH    AF
042AD0 3E 9F       7834          		LD      A,159
042AD2 CD AB 2A 04 7835          		CALL    FIX
042AD6 F1          7836          		POP     AF
042AD7 0E 00       7837          		LD      C,0
042AD9 C8          7838          		RET     Z
042ADA B7          7839  NEGATE:			OR      A               ;CLEAR CARRY
042ADB D9          7840          		EXX
042ADC D5          7841  NEG0:			PUSH    DE
042ADD EB          7842          		EX      DE,HL
042ADE 21 00 00 00 7843          		LD      HL,0
042AE2 52 ED 52    7844          		SBC.S   HL,DE
042AE5 D1          7845          		POP     DE
042AE6 D9          7846          		EXX
042AE7 D5          7847          		PUSH    DE
042AE8 EB          7848          		EX      DE,HL
042AE9 21 00 00 00 7849          		LD      HL,0
042AED 52 ED 52    7850          		SBC.S   HL,DE
042AF0 D1          7851          		POP     DE
042AF1 C9          7852          		RET
042AF2             7853  ;
042AF2             7854  ;NEG - Negate HLH'L'B'C'
042AF2             7855  ;    Also complements A (used in FADD)
042AF2             7856  ;    Destroys: A,H,L,B',C',H',L',F
042AF2             7857  ;
042AF2 D9          7858  NEG_:			EXX
042AF3 2F          7859          		CPL
042AF4 E5          7860          		PUSH    HL
042AF5 B7          7861          		OR      A               ;CLEAR CARRY
042AF6 21 00 00 00 7862          		LD      HL,0
042AFA 52 ED 42    7863          		SBC.S   HL,BC
042AFD 44          7864          		LD      B,H
042AFE 4D          7865          		LD      C,L
042AFF E1          7866          		POP     HL
042B00 18 DA       7867          		JR      NEG0
042B02             7868  ;
042B02             7869  ;SCALE - Trig scaling.
042B02             7870  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B02             7871  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B02             7872  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B02             7873  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B02             7874  ;           E = quotient (bit 7 is sticky)
042B02             7875  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B02             7876  ;FLO48 - Float unsigned number (48 bits)
042B02             7877  ;    Input/output in HLH'L'B'C'C
042B02             7878  ;   Destroys: C,H,L,B',C',H',L',F
042B02             7879  ;
042B02 3E 96       7880  SCALE:			LD      A,150
042B04 B9          7881          		CP      C
042B05 3E 17       7882          		LD      A,ACLOST
042B07 DA 7D 20 04 7883          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B0B CD 48 26 04 7884          		CALL    PIBY4
042B0F D9          7885          		EXX
042B10 01 69 21 00 7886          		LD      BC,2169H        ;3.141592653589793238
042B14 D9          7887          		EXX
042B15 CB FA       7888  MOD48:			SET     7,D             ;IMPLIED 1
042B17 CB FC       7889          		SET     7,H
042B19 79          7890          		LD      A,C
042B1A 0E 00       7891          		LD      C,0             ;INIT QUOTIENT
042B1C DD 21 00 00 7892          		LD      IX,0
       00          
042B21 DD E5       7893          		PUSH    IX              ;PUT ZERO ON STACK
042B23 B8          7894          		CP      B
042B24 38 46       7895          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B26 D9          7896  MOD481:			EXX                     ;CARRY=0 HERE
042B27 E3          7897          		EX      (SP),HL
042B28 52 ED 42    7898          		SBC.S   HL,BC
042B2B E3          7899          		EX      (SP),HL
042B2C 52 ED 52    7900          		SBC.S   HL,DE
042B2F D9          7901          		EXX
042B30 52 ED 52    7902          		SBC.S   HL,DE
042B33 30 0C       7903          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B35 D9          7904          		EXX
042B36 E3          7905          		EX      (SP),HL
042B37 52 09       7906          		ADD.S   HL,BC
042B39 E3          7907          		EX      (SP),HL
042B3A 52 ED 5A    7908          		ADC.S   HL,DE
042B3D D9          7909          		EXX
042B3E 52 ED 5A    7910          		ADC.S   HL,DE
042B41 3F          7911  MOD482:			CCF
042B42 CB 11       7912          		RL      C               ;QUOTIENT
042B44 30 02       7913          		JR      NC,MOD483
042B46 CB F9       7914          		SET     7,C             ;STICKY BIT
042B48 3D          7915  MOD483:			DEC     A
042B49 B8          7916          		CP      B
042B4A 38 1F       7917          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B4C E3          7918          		EX      (SP),HL
042B4D 52 29       7919          		ADD.S   HL,HL           ;DIVIDEND * 2
042B4F E3          7920          		EX      (SP),HL
042B50 D9          7921          		EXX
042B51 52 ED 6A    7922          		ADC.S   HL,HL
042B54 D9          7923          		EXX
042B55 52 ED 6A    7924          		ADC.S   HL,HL
042B58 30 CC       7925          		JR      NC,MOD481       ;AGAIN
042B5A B7          7926          		OR      A
042B5B D9          7927          		EXX
042B5C E3          7928          		EX      (SP),HL
042B5D 52 ED 42    7929          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B60 E3          7930          		EX      (SP),HL
042B61 52 ED 52    7931          		SBC.S   HL,DE
042B64 D9          7932          		EXX
042B65 52 ED 52    7933          		SBC.S   HL,DE
042B68 B7          7934          		OR      A
042B69 18 D6       7935          		JR      MOD482
042B6B             7936  ;
042B6B 3C          7937  MOD484:			INC     A
042B6C 59          7938  MOD485:			LD      E,C             ;QUOTIENT
042B6D 4F          7939          		LD      C,A             ;REMAINDER EXPONENT
042B6E D9          7940          		EXX
042B6F C1          7941          		POP     BC
042B70 D9          7942          		EXX
042B71 CB 7C       7943  FLO48:			BIT     7,H
042B73 C0          7944          		RET     NZ
042B74 D9          7945          		EXX
042B75 CB 21       7946          		SLA     C
042B77 CB 10       7947          		RL      B
042B79 52 ED 6A    7948          		ADC.S   HL,HL
042B7C D9          7949          		EXX
042B7D 52 ED 6A    7950          		ADC.S   HL,HL
042B80 0D          7951          		DEC     C
042B81 C2 71 2B 04 7952          		JP      NZ,FLO48
042B85 C9          7953          		RET
042B86             7954  ;
042B86             7955  ;Float unsigned number
042B86             7956  ;    Input/output in HLH'L'C
042B86             7957  ;   Destroys: C,H,L,H',L',F
042B86             7958  ;
042B86 CB 7C       7959  FLOAT_:			BIT     7,H
042B88 C0          7960          		RET     NZ
042B89 D9          7961          		EXX                     ;SAME AS "X2"
042B8A 52 29       7962          		ADD.S   HL,HL           ;TIME-CRITICAL
042B8C D9          7963          		EXX                     ;REGION
042B8D 52 ED 6A    7964          		ADC.S   HL,HL           ;(BENCHMARKS)
042B90 0D          7965          		DEC     C
042B91 C2 86 2B 04 7966          		JP      NZ,FLOAT_
042B95 C9          7967          		RET
042B96             7968  ;
042B96             7969  ;SFLOAT - Convert to floating-point if necessary.
042B96             7970  ;    Input: Variable-type number in HLH'L'C
042B96             7971  ;    Output: Floating-point in HLH'L'C
042B96             7972  ;    Destroys: A,C,H,L,H',L',F
042B96             7973  ;
042B96 08          7974  FLOATA:			EX      AF,AF'
042B97             7975          		; ADD     A,(RTABLE-DTABLE)/3
042B97 C6 2A       7976          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042B99 08          7977          		EX      AF,AF'
042B9A CD D7 2B 04 7978  FLOAT2:			CALL    SWAP_FP
042B9E CD A6 2B 04 7979          		CALL    SFLOAT_FP
042BA2 CD D7 2B 04 7980          		CALL    SWAP_FP
042BA6 0D          7981  SFLOAT_FP:			DEC     C
042BA7 0C          7982          		INC     C
042BA8 C0          7983          		RET     NZ              ;ALREADY FLOATING-POINT
042BA9 CD FF 2B 04 7984          		CALL    TEST_FP
042BAD C8          7985          		RET     Z               ;ZERO
042BAE 7C          7986          		LD      A,H
042BAF B7          7987          		OR      A
042BB0 FC DA 2A 04 7988          		CALL    M,NEGATE
042BB4 0E 9F       7989          		LD      C,159
042BB6 CD 86 2B 04 7990          		CALL    FLOAT_
042BBA B7          7991          		OR      A
042BBB F8          7992          		RET     M               ;NEGATIVE
042BBC CB BC       7993          		RES     7,H
042BBE C9          7994          		RET
042BBF             7995  ;
042BBF             7996  ;ROUND UP
042BBF             7997  ;Return with carry set if 32-bit overflow
042BBF             7998  ;   Destroys: H,L,B',C',H',L',F
042BBF             7999  ;
042BBF D9          8000  ADD1_FP:			EXX
042BC0 01 01 00 00 8001          		LD      BC,1
042BC4 52 09       8002          		ADD.S   HL,BC
042BC6 D9          8003          		EXX
042BC7 D0          8004          		RET     NC
042BC8 C5          8005          		PUSH    BC
042BC9 01 01 00 00 8006          		LD      BC,1
042BCD 52 09       8007          		ADD.S   HL,BC
042BCF C1          8008          		POP     BC
042BD0 C9          8009          		RET
042BD1             8010  ;
042BD1             8011  ;ODD - Add one if even, leave alone if odd.
042BD1             8012  ; (Used to perform unbiassed rounding, i.e.
042BD1             8013  ;  number is rounded up half the time)
042BD1             8014  ;    Destroys: L',F (carry cleared)
042BD1             8015  ;
042BD1 B7          8016  ODD:			OR      A               ;CLEAR CARRY
042BD2 D9          8017          		EXX
042BD3 CB C5       8018          		SET     0,L             ;MAKE ODD
042BD5 D9          8019          		EXX
042BD6 C9          8020          		RET
042BD7             8021  ;
042BD7             8022  ;SWAP_FP - Swap arguments.
042BD7             8023  ;    Exchanges DE,HL D'E',H'L' and B,C
042BD7             8024  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042BD7             8025  ;SWAP1 - Swap DEHL with D'E'H'L'
042BD7             8026  ;    Destroys: D,E,H,L,D',E',H',L'
042BD7             8027  ;
042BD7 79          8028  SWAP_FP:			LD      A,C
042BD8 48          8029          		LD      C,B
042BD9 47          8030          		LD      B,A
042BDA EB          8031  SWAP1:			EX      DE,HL
042BDB D9          8032          		EXX
042BDC EB          8033          		EX      DE,HL
042BDD D9          8034          		EXX
042BDE C9          8035          		RET
042BDF             8036  ;
042BDF             8037  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042BDF             8038  ; INCC - destroys C,F
042BDF             8039  ; OFLOW
042BDF             8040  ;
042BDF CD 98 2C 04 8041  DIV2:			CALL    D2
042BE3 D9          8042          		EXX
042BE4 CB 18       8043          		RR      B
042BE6 CB 19       8044          		RR      C
042BE8 08          8045          		EX      AF,AF'
042BE9 B0          8046          		OR      B
042BEA 08          8047          		EX      AF,AF'
042BEB D9          8048          		EXX
042BEC 0C          8049  INCC:			INC     C
042BED C0          8050          		RET     NZ
042BEE 3E 14       8051  OFLOW:			LD      A,TOOBIG_FP
042BF0 C3 7D 20 04 8052          		JP      ERROR_FP_           ;"Too big"
042BF4             8053  ;
042BF4             8054  ; FTEST - Test for zero & sign
042BF4             8055  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042BF4             8056  ;
042BF4 CD FF 2B 04 8057  FTEST_FP:			CALL    TEST_FP
042BF8 C8          8058          		RET     Z
042BF9 7C          8059          		LD      A,H
042BFA E6 80       8060          		AND     10000000B
042BFC F6 40       8061          		OR      01000000B
042BFE C9          8062          		RET
042BFF             8063  ;
042BFF             8064  ; TEST_FP - Test HLH'L' for zero.
042BFF             8065  ;     Output: Z-flag set & A=0 if HLH'L'=0
042BFF             8066  ;     Destroys: A,F
042BFF             8067  ;
042BFF 7C          8068  TEST_FP:			LD      A,H
042C00 B5          8069          		OR      L
042C01 D9          8070          		EXX
042C02 B4          8071          		OR      H
042C03 B5          8072          		OR      L
042C04 D9          8073          		EXX
042C05 C9          8074          		RET
042C06             8075  ;
042C06             8076  ; FCOMP - Compare two numbers
042C06             8077  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C06             8078  ;
042C06 78          8079  FCOMP_FP:			LD      A,B
042C07 B1          8080          		OR      C               ;Both integer?
042C08 20 0B       8081          		JR      NZ,FCOMP1
042C0A CD 1F 2C 04 8082          		CALL    ICP
042C0E 3E 00       8083  FCOMP0:			LD      A,0
042C10 C8          8084          		RET     Z               ;Equal
042C11 3E 80       8085          		LD      A,80H
042C13 1F          8086          		RRA
042C14 C9          8087          		RET
042C15             8088  ;
042C15 CD 9A 2B 04 8089  FCOMP1:			CALL    FLOAT2          ;Float both
042C19 CD 2D 2C 04 8090          		CALL    FCP
042C1D 18 EF       8091          		JR      FCOMP0
042C1F             8092  ;
042C1F             8093  ; Integer and floating point compare.
042C1F             8094  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C1F             8095  ; Result pre-set to FALSE
042C1F             8096  ; ICP1, FCP1 destroy A,F
042C1F             8097  ;
042C1F             8098  ; ZERO - Return zero.
042C1F             8099  ;  Destroys: A,C,H,L,H',L'
042C1F             8100  ;
042C1F CD 52 2C 04 8101  ICP:			CALL    ICP1
042C23 3E 00       8102  ZERO_FP:			LD      A,0
042C25 D9          8103          		EXX
042C26 67          8104          		LD      H,A
042C27 6F          8105  	       		LD      L,A
042C28 D9          8106          		EXX
042C29 67          8107        			LD      H,A
042C2A 6F          8108       			LD      L,A
042C2B 4F          8109  	    		LD      C,A
042C2C C9          8110          		RET
042C2D             8111  ;
042C2D CD 44 2C 04 8112  FCP:			CALL    FCP1
042C31 18 F0       8113          		JR      ZERO_FP            ;PRESET FALSE
042C33             8114  ;
042C33 79          8115  FCP0:			LD      A,C
042C34 B8          8116          		CP      B               ;COMPARE EXPONENTS
042C35 C0          8117          		RET     NZ
042C36             8118  ICP0:
042C36 52 ED 52    8119  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C39 52 19       8120          		ADD.S   HL,DE
042C3B C0          8121          		RET     NZ
042C3C D9          8122          		EXX
042C3D 52 ED 52    8123          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C40 52 19       8124          		ADD.S   HL,DE
042C42 D9          8125          		EXX
042C43 C9          8126          		RET
042C44             8127  ;
042C44 7C          8128  FCP1:			LD      A,H
042C45 AA          8129          		XOR     D
042C46 7C          8130          		LD      A,H
042C47 17          8131          		RLA
042C48 F8          8132          		RET     M
042C49 30 E8       8133          		JR      NC,FCP0
042C4B CD 33 2C 04 8134          		CALL    FCP0
042C4F C8          8135          		RET     Z               ;** V0.1 BUG FIX
042C50 3F          8136          		CCF
042C51 C9          8137          		RET
042C52             8138  ;
042C52 7C          8139  ICP1:			LD      A,H
042C53 AA          8140          		XOR     D
042C54 F2 36 2C 04 8141          		JP      P,ICP0
042C58 7C          8142          		LD      A,H
042C59 17          8143          		RLA
042C5A C9          8144          		RET
042C5B             8145  ;
042C5B             8146  ; ADD - Integer add.
042C5B             8147  ; Carry, sign & zero flags valid on exit
042C5B             8148  ;     Destroys: H,L,H',L',F
042C5B             8149  ;
042C5B 05          8150  X10B:			DEC     B
042C5C 0C          8151          		INC     C
042C5D CD A4 2C 04 8152  X5:			CALL    COPY0
042C61 CD 97 2C 04 8153          		CALL    D2C
042C65 CD 97 2C 04 8154          		CALL    D2C
042C69 08          8155          		EX      AF,AF'          ;SAVE CARRY
042C6A D9          8156  ADD_:			EXX
042C6B 52 19       8157          		ADD.S   HL,DE
042C6D D9          8158          		EXX
042C6E 52 ED 5A    8159          		ADC.S   HL,DE
042C71 C9          8160          		RET
042C72             8161  ;
042C72             8162  ; SUB - Integer subtract.
042C72             8163  ; Carry, sign & zero flags valid on exit
042C72             8164  ;     Destroys: H,L,H',L',F
042C72             8165  ;
042C72 D9          8166  SUB_:			EXX
042C73 B7          8167          		OR      A
042C74 52 ED 52    8168          		SBC.S   HL,DE
042C77 D9          8169          		EXX
042C78 52 ED 52    8170          		SBC.S   HL,DE
042C7B C9          8171          		RET
042C7C             8172  ;
042C7C             8173  ; X10 - unsigned integer * 10
042C7C             8174  ;    Inputs: HLH'L' initial value
042C7C             8175  ;   Outputs: DED'E' = initial HLH'L'
042C7C             8176  ;            Carry bit set if overflow
042C7C             8177  ;            If carry not set HLH'L'=result
042C7C             8178  ;  Destroys: D,E,H,L,D',E',H',L',F
042C7C             8179  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042C7C             8180  ;     Carry set if MSB=1 before shift.
042C7C             8181  ;     Sign set if MSB=1 after shift.
042C7C             8182  ;     Destroys: H,L,H',L',F
042C7C             8183  ;
042C7C CD A4 2C 04 8184  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042C80 CD 8F 2C 04 8185          		CALL    X2
042C84 D8          8186          		RET     C               ;TOO BIG
042C85 CD 8F 2C 04 8187          		CALL    X2
042C89 D8          8188          		RET     C
042C8A CD 6A 2C 04 8189          		CALL    ADD_
042C8E D8          8190          		RET     C
042C8F D9          8191  X2:			EXX
042C90 52 29       8192          		ADD.S   HL,HL
042C92 D9          8193          		EXX
042C93 52 ED 6A    8194          		ADC.S   HL,HL
042C96 C9          8195          		RET
042C97             8196  ;
042C97             8197  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042C97             8198  ;     Carry set if LSB=1 before shift.
042C97             8199  ;     Destroys: H,L,H',L',F
042C97             8200  ;
042C97 0C          8201  D2C:			INC     C
042C98 CB 3C       8202  D2:			SRL     H
042C9A CB 1D       8203          		RR      L
042C9C D9          8204          		EXX
042C9D CB 1C       8205          		RR      H
042C9F CB 1D       8206          		RR      L
042CA1 D9          8207          		EXX
042CA2 C9          8208          		RET
042CA3             8209  ;
042CA3             8210  ; COPY - COPY HLH'L'C INTO DED'E'B
042CA3             8211  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CA3             8212  ;
042CA3 41          8213  COPY_:			LD      B,C
042CA4 54          8214  COPY0:			LD      D,H
042CA5 5D          8215          		LD      E,L
042CA6 D9          8216          		EXX
042CA7 54          8217          		LD      D,H
042CA8 5D          8218          		LD      E,L
042CA9 D9          8219          		EXX
042CAA C9          8220          		RET
042CAB             8221  ;
042CAB             8222  ; SQUARE - PUSH X*X
042CAB             8223  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CAB             8224  ;   Destroys: SP,IX
042CAB             8225  ;
042CAB CD A3 2C 04 8226  SQUARE:			CALL    COPY_
042CAF CD 0E 23 04 8227          		CALL    FMUL
042CB3 DD E1       8228  PUSH5:			POP     IX              ;RETURN ADDRESS
042CB5 C5          8229          		PUSH    BC
042CB6 E5          8230          		PUSH    HL
042CB7 D9          8231          		EXX
042CB8 E5          8232          		PUSH    HL
042CB9 D9          8233          		EXX
042CBA DD E9       8234          		JP      (IX)            ;"RETURN"
042CBC             8235  ;
042CBC             8236  ; POP5 - POP DED'E'B OFF STACK.
042CBC             8237  ;   Destroys: A,B,D,E,D',E',SP,IX
042CBC             8238  ;
042CBC DD E1       8239  POP5:			POP     IX              ;RETURN ADDRESS
042CBE D9          8240          		EXX
042CBF D1          8241          		POP     DE
042CC0 D9          8242          		EXX
042CC1 D1          8243          		POP     DE
042CC2 79          8244          		LD      A,C
042CC3 C1          8245          		POP     BC
042CC4 41          8246          		LD      B,C
042CC5 4F          8247          		LD      C,A
042CC6 DD E9       8248          		JP      (IX)            ;"RETURN"
042CC8             8249  ;
042CC8             8250  ; RATIO - Calculate (X-1)/(X+1)
042CC8             8251  ;     Inputs: X in HLH'L'C
042CC8             8252  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042CC8             8253  ;   Destroys: Everything except IY,SP,I
042CC8             8254  ;
042CC8 CD B3 2C 04 8255  RATIO:			CALL    PUSH5           ;SAVE X
042CCC CD 3B 26 04 8256          		CALL    DONE
042CD0 CD FC 21 04 8257          		CALL    FADD
042CD4 CD BC 2C 04 8258          		CALL    POP5            ;RESTORE X
042CD8 CD B3 2C 04 8259          		CALL    PUSH5           ;SAVE X+1
042CDC CD D7 2B 04 8260          		CALL    SWAP_FP
042CE0 CD 3B 26 04 8261          		CALL    DONE
042CE4 CD E3 21 04 8262          		CALL    FSUB
042CE8 CD BC 2C 04 8263          		CALL    POP5            ;RESTORE X+1
042CEC C3 65 22 04 8264          		JP      FDIV
042CF0             8265  ;
042CF0             8266  ; POLY - Evaluate a polynomial.
042CF0             8267  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042CF0             8268  ;             Polynomial coefficients follow call.
042CF0             8269  ;    Outputs: Result in HLH'L'C
042CF0             8270  ;   Destroys: Everything except IY,SP,I
042CF0             8271  ; Routine terminates on finding a coefficient >=1.
042CF0             8272  ; Note: The last coefficient is EXECUTED on return
042CF0             8273  ;       so must contain only innocuous bytes!
042CF0             8274  ;
042CF0 DD 21 03 00 8275  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042CF5 DD 39       8276          		ADD     IX, SP
042CF7 DD E3       8277          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042CF9             8278  ;
042CF9 CD CF 29 04 8279          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042CFD CD 0E 23 04 8280  POLY1:			CALL    FMUL
042D01 11 05 00 00 8281          		LD      DE, 5				; Skip to the next coefficient
042D05 DD 19       8282          		ADD     IX, DE
042D07 CD CF 29 04 8283          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D0B DD E3       8284          		EX      (SP), IX			; Restore the SP just in case we need to return
042D0D 04          8285          		INC     B
042D0E 05          8286          		DEC     B               		; Test B for end byte (80h)
042D0F FA FC 21 04 8287          		JP      M,FADD				; Yes, so add and return
042D13 CD FC 21 04 8288          		CALL    FADD				; No, so add
042D17 CD E1 29 04 8289          		CALL    DLOAD5_SPL			; Load X from SP
042D1B DD E3       8290          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D1D 18 DE       8291          		JR      POLY1				; And loop
042D1F             8292  ;
042D1F             8293  ; POWR10 - Calculate power of ten.
042D1F             8294  ;     Inputs: A=power of 10 required (A<128)
042D1F             8295  ;             A=binary exponent to be exceeded (A>=128)
042D1F             8296  ;    Outputs: DED'E'B = result
042D1F             8297  ;             A = actual power of ten returned
042D1F             8298  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D1F             8299  ;
042D1F 3C          8300  POWR10:			INC     A
042D20 08          8301          		EX      AF,AF'
042D21 E5          8302          		PUSH    HL
042D22 D9          8303          		EXX
042D23 E5          8304          		PUSH    HL
042D24 D9          8305          		EXX
042D25 CD 3B 26 04 8306          		CALL    DONE
042D29 CD D7 2B 04 8307          		CALL    SWAP_FP
042D2D AF          8308          		XOR     A
042D2E 08          8309  POWR11:			EX      AF,AF'
042D2F 3D          8310          		DEC     A
042D30 28 26       8311          		JR      Z,POWR14        ;EXIT TYPE 1
042D32 F2 3A 2D 04 8312          		JP      P,POWR13
042D36 B9          8313          		CP      C
042D37 38 1F       8314          		JR      C,POWR14        ;EXIT TYPE 2
042D39 3C          8315          		INC     A
042D3A 08          8316  POWR13:			EX      AF,AF'
042D3B 3C          8317          		INC     A
042D3C CB FC       8318          		SET     7,H
042D3E CD 5D 2C 04 8319          		CALL    X5
042D42 30 06       8320          		JR      NC,POWR12
042D44 08          8321          		EX      AF,AF'
042D45 CD 97 2C 04 8322          		CALL    D2C
042D49 08          8323          		EX      AF,AF'
042D4A 08          8324  POWR12:			EX      AF,AF'
042D4B DC BF 2B 04 8325          		CALL    C,ADD1_FP          ;ROUND UP
042D4F 0C          8326          		INC     C
042D50 FA 2E 2D 04 8327          		JP      M,POWR11
042D54 C3 EE 2B 04 8328          		JP      OFLOW
042D58 CD D7 2B 04 8329  POWR14:			CALL    SWAP_FP
042D5C CB BA       8330          		RES     7,D
042D5E D9          8331          		EXX
042D5F E1          8332          		POP     HL
042D60 D9          8333          		EXX
042D61 E1          8334          		POP     HL
042D62 08          8335          		EX      AF,AF'
042D63 C9          8336          		RET
042D64             8337  ;
042D64             8338  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D64             8339  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D64             8340  ;               Remainder in H'L'HL
042D64             8341  ;     Inputs: A = loop counter (normally -32)
042D64             8342  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D64             8343  ;
042D64 B7          8344  DIVA:			OR      A               ;CLEAR CARRY
042D65             8345  DIV0:
042D65 52 ED 42    8346  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D68 D9          8347          		EXX
042D69 52 ED 42    8348          		SBC.S   HL,BC
042D6C D9          8349          		EXX
042D6D 30 07       8350          		JR      NC,DIV1
042D6F 52 09       8351          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042D71 D9          8352          		EXX
042D72 52 ED 4A    8353          		ADC.S   HL,BC
042D75 D9          8354          		EXX
042D76 3F          8355  DIV1:			CCF
042D77 CB 13       8356  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042D79 CB 12       8357          		RL      D
042D7B D9          8358          		EXX
042D7C CB 13       8359          		RL      E
042D7E CB 12       8360          		RL      D
042D80 D9          8361          		EXX
042D81 3C          8362          		INC     A
042D82 F0          8363          		RET     P
042D83             8364  DIVB:
042D83 52 ED 6A    8365  			ADC.S   HL,HL           ;DIVIDEND*2
042D86 D9          8366          		EXX
042D87 52 ED 6A    8367          		ADC.S   HL,HL
042D8A D9          8368          		EXX
042D8B 30 D8       8369          		JR      NC,DIV0
042D8D B7          8370          		OR      A
042D8E 52 ED 42    8371          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042D91 D9          8372          		EXX
042D92 52 ED 42    8373          		SBC.S   HL,BC
042D95 D9          8374          		EXX
042D96 37          8375          		SCF
042D97 C3 77 2D 04 8376          		JP      DIVC
042D9B             8377  ;
042D9B             8378  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042D9B             8379  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042D9B             8380  ;    Inputs: A = loop counter (usually -32)
042D9B             8381  ;            H'L'HL = 0
042D9B             8382  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042D9B             8383  ;
042D9B B7          8384  MULA:			OR      A               ;CLEAR CARRY
042D9C D9          8385  MUL0:			EXX
042D9D CB 1A       8386          		RR      D               ;MULTIPLIER/2
042D9F CB 1B       8387          		RR      E
042DA1 D9          8388          		EXX
042DA2 CB 1A       8389          		RR      D
042DA4 CB 1B       8390          		RR      E
042DA6 30 07       8391          		JR      NC,MUL1
042DA8 52 09       8392          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DAA D9          8393          		EXX
042DAB 52 ED 4A    8394          		ADC.S   HL,BC
042DAE D9          8395          		EXX
042DAF 3C          8396  MUL1:			INC     A
042DB0 F0          8397          		RET     P
042DB1 D9          8398  MULB:			EXX
042DB2 CB 1C       8399          		RR      H               ;PRODUCT/2
042DB4 CB 1D       8400          		RR      L
042DB6 D9          8401          		EXX
042DB7 CB 1C       8402          		RR      H
042DB9 CB 1D       8403          		RR      L
042DBB C3 9C 2D 04 8404          		JP      MUL0
042DBF             8405  ;
042DBF             8406  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DBF             8407  ;     Function: B'C'BC = SQR (D'E'DE)
042DBF             8408  ;     Inputs: A = loop counter (normally -31)
042DBF             8409  ;             B'C'BCH'L'HL initialised to 0
042DBF             8410  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DBF             8411  ;
042DBF             8412  SQR1:
042DBF 52 ED 42    8413  			SBC.S   HL,BC
042DC2 D9          8414          		EXX
042DC3 52 ED 42    8415          		SBC.S   HL,BC
042DC6 D9          8416          		EXX
042DC7 0C          8417          		INC     C
042DC8 30 09       8418          		JR      NC,SQR2
042DCA 0D          8419          		DEC     C
042DCB 52 09       8420          		ADD.S   HL,BC
042DCD D9          8421          		EXX
042DCE 52 ED 4A    8422          		ADC.S   HL,BC
042DD1 D9          8423          		EXX
042DD2 0D          8424          		DEC     C
042DD3 3C          8425  SQR2:			INC     A
042DD4 F0          8426          		RET     P
042DD5 CB 21       8427  SQRA:			SLA     C
042DD7 CB 10       8428          		RL      B
042DD9 D9          8429          		EXX
042DDA CB 11       8430          		RL      C
042DDC CB 10       8431          		RL      B
042DDE D9          8432          		EXX
042DDF 0C          8433          		INC     C
042DE0 CB 23       8434          		SLA     E
042DE2 CB 12       8435          		RL      D
042DE4 D9          8436          		EXX
042DE5 CB 13       8437          		RL      E
042DE7 CB 12       8438          		RL      D
042DE9 D9          8439          		EXX
042DEA 52 ED 6A    8440          		ADC.S   HL,HL
042DED D9          8441          		EXX
042DEE 52 ED 6A    8442          		ADC.S   HL,HL
042DF1 D9          8443          		EXX
042DF2 CB 23       8444          		SLA     E
042DF4 CB 12       8445          		RL      D
042DF6 D9          8446          		EXX
042DF7 CB 13       8447          		RL      E
042DF9 CB 12       8448          		RL      D
042DFB D9          8449          		EXX
042DFC 52 ED 6A    8450          		ADC.S   HL,HL
042DFF D9          8451          		EXX
042E00 52 ED 6A    8452          		ADC.S   HL,HL
042E03 D9          8453          		EXX
042E04 D2 BF 2D 04 8454          		JP      NC,SQR1
042E08 B7          8455  SQR3:			OR      A
042E09 52 ED 42    8456          		SBC.S   HL,BC
042E0C D9          8457          		EXX
042E0D 52 ED 42    8458          		SBC.S   HL,BC
042E10 D9          8459          		EXX
042E11 0C          8460          		INC     C
042E12 C3 D3 2D 04 8461          		JP      SQR2
042E16             8462  ;
042E16             8463  SQRB:
042E16 52 29       8464  			ADD.S   HL,HL
042E18 D9          8465          		EXX
042E19 52 ED 6A    8466          		ADC.S   HL,HL
042E1C D9          8467          		EXX
042E1D 38 E9       8468          		JR      C,SQR3
042E1F 3C          8469          		INC     A
042E20 0C          8470          		INC     C
042E21 52 ED 42    8471          		SBC.S   HL,BC
042E24 D9          8472          		EXX
042E25 52 ED 42    8473          		SBC.S   HL,BC
042E28 D9          8474          		EXX
042E29 D0          8475          		RET     NC
042E2A 52 09       8476          		ADD.S   HL,BC
042E2C D9          8477          		EXX
042E2D 52 ED 4A    8478          		ADC.S   HL,BC
042E30 D9          8479          		EXX
042E31 0D          8480          		DEC     C
042E32 C9          8481          		RET
042E33             8482  ;
042E33 DD 7E 00    8483  DIGITQ:			LD      A,(IX)
042E36 FE 3A       8484          		CP      '9'+1
042E38 3F          8485          		CCF
042E39 D8          8486          		RET     C
042E3A FE 30       8487          		CP      '0'
042E3C C9          8488          		RET
042E3D             8489  ;
042E3D DD 7E 00    8490  SIGNQ:			LD      A,(IX)
042E40 DD 23       8491          		INC     IX
042E42 FE 20       8492          		CP      ' '
042E44 28 F7       8493          		JR      Z,SIGNQ
042E46 FE 2B       8494          		CP      '+'
042E48 C8          8495          		RET     Z
042E49 FE 2D       8496          		CP      '-'
042E4B C8          8497          		RET     Z
042E4C DD 2B       8498          		DEC     IX
042E4E C9          8499          		RET; --- End fpp.asm ---
042E4F             8500  
042E4F             8501  ; --- Begin gpio.asm ---
042E4F             8502  ;
042E4F             8503  ; Title:	BBC Basic for AGON - GPIO functions
042E4F             8504  ; Author:	Dean Belfield
042E4F             8505  ; Created:	12/05/2023
042E4F             8506  ; Last Updated:	12/05/2023
042E4F             8507  ;
042E4F             8508  ; Modinfo:
042E4F             8509  
042E4F             8510  			; INCLUDE	"macros.inc"
042E4F             8511  			; INCLUDE	"equs.inc"
042E4F             8512  
042E4F             8513  			; .ASSUME	ADL = 1
042E4F             8514  
042E4F             8515  			; SEGMENT CODE
042E4F             8516  
042E4F             8517  			; XDEF	GPIOB_SETMODE
042E4F             8518  
042E4F             8519  			; XREF	SWITCH_A
042E4F             8520  
042E4F             8521  ;  A: Mode
042E4F             8522  ;  B: Pins
042E4F             8523  ;
042E4F CD F4 3D 04 8524  GPIOB_SETMODE:		CALL	SWITCH_A
042E53 67 2E       8525  			DW	GPIOB_M0	; Output
042E55 8C 2E       8526  			DW	GPIOB_M1	; Input
042E57 AC 2E       8527  			DW	GPIOB_M2	; Open Drain IO
042E59 CC 2E       8528  			DW	GPIOB_M3	; Open Source IO
042E5B E7 2E       8529  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E5D 13 2F       8530  			DW	GPIOB_M5	; Alt Function
042E5F 2E 2F       8531  			DW	GPIOB_M6	; Interrupt, Active Low
042E61 55 2F       8532  			DW	GPIOB_M7	; Interrupt, Active High
042E63 77 2F       8533  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E65 99 2F       8534  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E67             8535  
042E67             8536  ; Output
042E67             8537  ;
042E67             8538  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E67 C5          0001M 		PUSH	BC
042E68 78          0002M 		LD	A, val
042E69 2F          0003M 		CPL
042E6A 4F          0004M 		LD	C, A
042E6B ED 38 9B    0005M 		IN0	A, (reg)
042E6E A1          0006M 		AND	C
042E6F ED 39 9B    0007M 		OUT0	(reg), A
042E72 C1          0008M 		POP	BC
042E73             8539  			RES_GPIO PB_ALT1, B
042E73 C5          0001M 		PUSH	BC
042E74 78          0002M 		LD	A, val
042E75 2F          0003M 		CPL
042E76 4F          0004M 		LD	C, A
042E77 ED 38 9C    0005M 		IN0	A, (reg)
042E7A A1          0006M 		AND	C
042E7B ED 39 9C    0007M 		OUT0	(reg), A
042E7E C1          0008M 		POP	BC
042E7F             8540  			RES_GPIO PB_ALT2, B
042E7F C5          0001M 		PUSH	BC
042E80 78          0002M 		LD	A, val
042E81 2F          0003M 		CPL
042E82 4F          0004M 		LD	C, A
042E83 ED 38 9D    0005M 		IN0	A, (reg)
042E86 A1          0006M 		AND	C
042E87 ED 39 9D    0007M 		OUT0	(reg), A
042E8A C1          0008M 		POP	BC
042E8B C9          8541  			RET
042E8C             8542  
042E8C             8543  ; Input
042E8C             8544  ;
042E8C             8545  GPIOB_M1:		SET_GPIO PB_DDR,  B
042E8C ED 38 9B    0001M 		IN0	A, (reg)
042E8F B0          0002M 		OR	val
042E90 ED 39 9B    0003M 		OUT0	(reg), A
042E93             8546  			RES_GPIO PB_ALT1, B
042E93 C5          0001M 		PUSH	BC
042E94 78          0002M 		LD	A, val
042E95 2F          0003M 		CPL
042E96 4F          0004M 		LD	C, A
042E97 ED 38 9C    0005M 		IN0	A, (reg)
042E9A A1          0006M 		AND	C
042E9B ED 39 9C    0007M 		OUT0	(reg), A
042E9E C1          0008M 		POP	BC
042E9F             8547  			RES_GPIO PB_ALT2, B
042E9F C5          0001M 		PUSH	BC
042EA0 78          0002M 		LD	A, val
042EA1 2F          0003M 		CPL
042EA2 4F          0004M 		LD	C, A
042EA3 ED 38 9D    0005M 		IN0	A, (reg)
042EA6 A1          0006M 		AND	C
042EA7 ED 39 9D    0007M 		OUT0	(reg), A
042EAA C1          0008M 		POP	BC
042EAB C9          8548  			RET
042EAC             8549  
042EAC             8550  ; Open Drain IO
042EAC             8551  ;
042EAC             8552  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EAC C5          0001M 		PUSH	BC
042EAD 78          0002M 		LD	A, val
042EAE 2F          0003M 		CPL
042EAF 4F          0004M 		LD	C, A
042EB0 ED 38 9B    0005M 		IN0	A, (reg)
042EB3 A1          0006M 		AND	C
042EB4 ED 39 9B    0007M 		OUT0	(reg), A
042EB7 C1          0008M 		POP	BC
042EB8             8553  			SET_GPIO PB_ALT1, B
042EB8 ED 38 9C    0001M 		IN0	A, (reg)
042EBB B0          0002M 		OR	val
042EBC ED 39 9C    0003M 		OUT0	(reg), A
042EBF             8554  			RES_GPIO PB_ALT2, B
042EBF C5          0001M 		PUSH	BC
042EC0 78          0002M 		LD	A, val
042EC1 2F          0003M 		CPL
042EC2 4F          0004M 		LD	C, A
042EC3 ED 38 9D    0005M 		IN0	A, (reg)
042EC6 A1          0006M 		AND	C
042EC7 ED 39 9D    0007M 		OUT0	(reg), A
042ECA C1          0008M 		POP	BC
042ECB C9          8555  			RET
042ECC             8556  
042ECC             8557  ; Open Source IO
042ECC             8558  ;
042ECC             8559  GPIOB_M3:		SET_GPIO PB_DDR,  B
042ECC ED 38 9B    0001M 		IN0	A, (reg)
042ECF B0          0002M 		OR	val
042ED0 ED 39 9B    0003M 		OUT0	(reg), A
042ED3             8560  			SET_GPIO PB_ALT1, B
042ED3 ED 38 9C    0001M 		IN0	A, (reg)
042ED6 B0          0002M 		OR	val
042ED7 ED 39 9C    0003M 		OUT0	(reg), A
042EDA             8561  			RES_GPIO PB_ALT2, B
042EDA C5          0001M 		PUSH	BC
042EDB 78          0002M 		LD	A, val
042EDC 2F          0003M 		CPL
042EDD 4F          0004M 		LD	C, A
042EDE ED 38 9D    0005M 		IN0	A, (reg)
042EE1 A1          0006M 		AND	C
042EE2 ED 39 9D    0007M 		OUT0	(reg), A
042EE5 C1          0008M 		POP	BC
042EE6 C9          8562  			RET
042EE7             8563  
042EE7             8564  ; Interrupt, Dual Edge
042EE7             8565  ;
042EE7             8566  GPIOB_M4:		SET_GPIO PB_DR,   B
042EE7 ED 38 9A    0001M 		IN0	A, (reg)
042EEA B0          0002M 		OR	val
042EEB ED 39 9A    0003M 		OUT0	(reg), A
042EEE             8567  			RES_GPIO PB_DDR,  B
042EEE C5          0001M 		PUSH	BC
042EEF 78          0002M 		LD	A, val
042EF0 2F          0003M 		CPL
042EF1 4F          0004M 		LD	C, A
042EF2 ED 38 9B    0005M 		IN0	A, (reg)
042EF5 A1          0006M 		AND	C
042EF6 ED 39 9B    0007M 		OUT0	(reg), A
042EF9 C1          0008M 		POP	BC
042EFA             8568  			RES_GPIO PB_ALT1, B
042EFA C5          0001M 		PUSH	BC
042EFB 78          0002M 		LD	A, val
042EFC 2F          0003M 		CPL
042EFD 4F          0004M 		LD	C, A
042EFE ED 38 9C    0005M 		IN0	A, (reg)
042F01 A1          0006M 		AND	C
042F02 ED 39 9C    0007M 		OUT0	(reg), A
042F05 C1          0008M 		POP	BC
042F06             8569  			RES_GPIO PB_ALT2, B
042F06 C5          0001M 		PUSH	BC
042F07 78          0002M 		LD	A, val
042F08 2F          0003M 		CPL
042F09 4F          0004M 		LD	C, A
042F0A ED 38 9D    0005M 		IN0	A, (reg)
042F0D A1          0006M 		AND	C
042F0E ED 39 9D    0007M 		OUT0	(reg), A
042F11 C1          0008M 		POP	BC
042F12 C9          8570  			RET
042F13             8571  
042F13             8572  ; Alt Function
042F13             8573  ;
042F13             8574  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F13 ED 38 9B    0001M 		IN0	A, (reg)
042F16 B0          0002M 		OR	val
042F17 ED 39 9B    0003M 		OUT0	(reg), A
042F1A             8575  			RES_GPIO PB_ALT1, B
042F1A C5          0001M 		PUSH	BC
042F1B 78          0002M 		LD	A, val
042F1C 2F          0003M 		CPL
042F1D 4F          0004M 		LD	C, A
042F1E ED 38 9C    0005M 		IN0	A, (reg)
042F21 A1          0006M 		AND	C
042F22 ED 39 9C    0007M 		OUT0	(reg), A
042F25 C1          0008M 		POP	BC
042F26             8576  			SET_GPIO PB_ALT2, B
042F26 ED 38 9D    0001M 		IN0	A, (reg)
042F29 B0          0002M 		OR	val
042F2A ED 39 9D    0003M 		OUT0	(reg), A
042F2D C9          8577  			RET
042F2E             8578  
042F2E             8579  ; Interrupt, Active Low
042F2E             8580  ;
042F2E             8581  GPIOB_M6:		RES_GPIO PB_DR,   B
042F2E C5          0001M 		PUSH	BC
042F2F 78          0002M 		LD	A, val
042F30 2F          0003M 		CPL
042F31 4F          0004M 		LD	C, A
042F32 ED 38 9A    0005M 		IN0	A, (reg)
042F35 A1          0006M 		AND	C
042F36 ED 39 9A    0007M 		OUT0	(reg), A
042F39 C1          0008M 		POP	BC
042F3A             8582  			RES_GPIO PB_DDR,  B
042F3A C5          0001M 		PUSH	BC
042F3B 78          0002M 		LD	A, val
042F3C 2F          0003M 		CPL
042F3D 4F          0004M 		LD	C, A
042F3E ED 38 9B    0005M 		IN0	A, (reg)
042F41 A1          0006M 		AND	C
042F42 ED 39 9B    0007M 		OUT0	(reg), A
042F45 C1          0008M 		POP	BC
042F46             8583  			SET_GPIO PB_ALT1, B
042F46 ED 38 9C    0001M 		IN0	A, (reg)
042F49 B0          0002M 		OR	val
042F4A ED 39 9C    0003M 		OUT0	(reg), A
042F4D             8584  			SET_GPIO PB_ALT2, B
042F4D ED 38 9D    0001M 		IN0	A, (reg)
042F50 B0          0002M 		OR	val
042F51 ED 39 9D    0003M 		OUT0	(reg), A
042F54 C9          8585  			RET
042F55             8586  
042F55             8587  
042F55             8588  ; Interrupt, Active High
042F55             8589  ;
042F55             8590  GPIOB_M7:		SET_GPIO PB_DR,   B
042F55 ED 38 9A    0001M 		IN0	A, (reg)
042F58 B0          0002M 		OR	val
042F59 ED 39 9A    0003M 		OUT0	(reg), A
042F5C             8591  			RES_GPIO PB_DDR,  B
042F5C C5          0001M 		PUSH	BC
042F5D 78          0002M 		LD	A, val
042F5E 2F          0003M 		CPL
042F5F 4F          0004M 		LD	C, A
042F60 ED 38 9B    0005M 		IN0	A, (reg)
042F63 A1          0006M 		AND	C
042F64 ED 39 9B    0007M 		OUT0	(reg), A
042F67 C1          0008M 		POP	BC
042F68             8592  			SET_GPIO PB_ALT1, B
042F68 ED 38 9C    0001M 		IN0	A, (reg)
042F6B B0          0002M 		OR	val
042F6C ED 39 9C    0003M 		OUT0	(reg), A
042F6F             8593  			SET_GPIO PB_ALT2, B
042F6F ED 38 9D    0001M 		IN0	A, (reg)
042F72 B0          0002M 		OR	val
042F73 ED 39 9D    0003M 		OUT0	(reg), A
042F76 C9          8594  			RET
042F77             8595  
042F77             8596  
042F77             8597  ; Interrupt, Falling Edge
042F77             8598  ;
042F77             8599  GPIOB_M8:		RES_GPIO PB_DR,   B
042F77 C5          0001M 		PUSH	BC
042F78 78          0002M 		LD	A, val
042F79 2F          0003M 		CPL
042F7A 4F          0004M 		LD	C, A
042F7B ED 38 9A    0005M 		IN0	A, (reg)
042F7E A1          0006M 		AND	C
042F7F ED 39 9A    0007M 		OUT0	(reg), A
042F82 C1          0008M 		POP	BC
042F83             8600  			SET_GPIO PB_DDR,  B
042F83 ED 38 9B    0001M 		IN0	A, (reg)
042F86 B0          0002M 		OR	val
042F87 ED 39 9B    0003M 		OUT0	(reg), A
042F8A             8601  			SET_GPIO PB_ALT1, B
042F8A ED 38 9C    0001M 		IN0	A, (reg)
042F8D B0          0002M 		OR	val
042F8E ED 39 9C    0003M 		OUT0	(reg), A
042F91             8602  			SET_GPIO PB_ALT2, B
042F91 ED 38 9D    0001M 		IN0	A, (reg)
042F94 B0          0002M 		OR	val
042F95 ED 39 9D    0003M 		OUT0	(reg), A
042F98 C9          8603  			RET
042F99             8604  
042F99             8605  ; Interrupt, Rising Edge
042F99             8606  ;
042F99             8607  GPIOB_M9:		SET_GPIO PB_DR,   B
042F99 ED 38 9A    0001M 		IN0	A, (reg)
042F9C B0          0002M 		OR	val
042F9D ED 39 9A    0003M 		OUT0	(reg), A
042FA0             8608  			SET_GPIO PB_DDR,  B
042FA0 ED 38 9B    0001M 		IN0	A, (reg)
042FA3 B0          0002M 		OR	val
042FA4 ED 39 9B    0003M 		OUT0	(reg), A
042FA7             8609  			SET_GPIO PB_ALT1, B
042FA7 ED 38 9C    0001M 		IN0	A, (reg)
042FAA B0          0002M 		OR	val
042FAB ED 39 9C    0003M 		OUT0	(reg), A
042FAE             8610  			SET_GPIO PB_ALT2, B
042FAE ED 38 9D    0001M 		IN0	A, (reg)
042FB1 B0          0002M 		OR	val
042FB2 ED 39 9D    0003M 		OUT0	(reg), A
042FB5 C9          8611  			RET	; --- End gpio.asm ---
042FB6             8612  
042FB6             8613  ; --- Begin main.asm ---
042FB6             8614  ;
042FB6             8615  ; Title:	BBC Basic Interpreter - Z80 version
042FB6             8616  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FB6             8617  ; Author:	(C) Copyright  R.T.Russell  1984
042FB6             8618  ; Modified By:	Dean Belfield
042FB6             8619  ; Created:	12/05/2023
042FB6             8620  ; Last Updated:	26/11/2023
042FB6             8621  ;
042FB6             8622  ; Modinfo:
042FB6             8623  ; 07/05/1984:	Version 2.3
042FB6             8624  ; 01/03/1987:	Version 3.0
042FB6             8625  ; 03/05/2022:	Modified by Dean Belfield
042FB6             8626  ; 06/06/2023:	Modified to run in ADL mode
042FB6             8627  ; 26/06/2023:	Fixed binary and unary indirection
042FB6             8628  ; 17/08/2023:	Added binary constants
042FB6             8629  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FB6             8630  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FB6             8631  
042FB6             8632  			; .ASSUME	ADL = 1
042FB6             8633  
042FB6             8634  			; INCLUDE	"equs.inc"
042FB6             8635  
042FB6             8636  			; SEGMENT CODE
042FB6             8637  
042FB6             8638  			; XDEF	_main
042FB6             8639  
042FB6             8640  			; XDEF	COLD
042FB6             8641  			; XDEF	WARM
042FB6             8642  			; XDEF	CLOOP
042FB6             8643  			; XDEF	DELETE
042FB6             8644  			; XDEF	LIST_
042FB6             8645  			; XDEF	RENUM
042FB6             8646  			; XDEF	AUTO
042FB6             8647  			; XDEF	NEW
042FB6             8648  			; XDEF	OLD
042FB6             8649  			; XDEF	LOAD
042FB6             8650  			; XDEF	SAVE
042FB6             8651  			; XDEF	ERROR_
042FB6             8652  			; XDEF	EXTERR
042FB6             8653  			; XDEF	LOAD0
042FB6             8654  			; XDEF	CLEAR
042FB6             8655  			; XDEF	CRLF
042FB6             8656  			; XDEF	OUTCHR
042FB6             8657  			; XDEF	OUT_
042FB6             8658  			; XDEF	FINDL
042FB6             8659  			; XDEF	SETLIN
042FB6             8660  			; XDEF	PBCDL
042FB6             8661  			; XDEF	SAYLN
042FB6             8662  			; XDEF	PUTVAR
042FB6             8663  			; XDEF	GETVAR
042FB6             8664  			; XDEF	GETDEF
042FB6             8665  			; XDEF	CREATE
042FB6             8666  			; XDEF	RANGE
042FB6             8667  			; XDEF	LEXAN2
042FB6             8668  			; XDEF	REPORT
042FB6             8669  			; XDEF	TELL
042FB6             8670  			; XDEF	SPACE_
042FB6             8671  			; XDEF	KEYWDS
042FB6             8672  			; XDEF	KEYWDL
042FB6             8673  			; XDEF	ONEDIT
042FB6             8674  			; XDEF	ONEDIT1
042FB6             8675  			; XDEF	LISTIT
042FB6             8676  			; XDEF	CLEAN
042FB6             8677  
042FB6             8678  			; XREF	LISTON
042FB6             8679  			; XREF	ERRTXT
042FB6             8680  			; XREF	OSINIT
042FB6             8681  			; XREF	HIMEM
042FB6             8682  			; XREF	PAGE_
042FB6             8683  			; XREF	CHAIN0
042FB6             8684  			; XREF	PROMPT
042FB6             8685  			; XREF	ERRTRP
042FB6             8686  			; XREF	ERRLIN
042FB6             8687  			; XREF	AUTONO
042FB6             8688  			; XREF	LINENO
042FB6             8689  			; XREF	INCREM
042FB6             8690  			; XREF	OSLINE
042FB6             8691  			; XREF	COUNT
042FB6             8692  			; XREF	NXT
042FB6             8693  			; XREF	BUFFER
042FB6             8694  			; XREF	XEQ
042FB6             8695  			; XREF	TOP
042FB6             8696  			; XREF	EXPRI
042FB6             8697  			; XREF	SEARCH
042FB6             8698  			; XREF	LTRAP
042FB6             8699  			; XREF	LOMEM
042FB6             8700  			; XREF	DECODE
042FB6             8701  			; XREF	EXPRS
042FB6             8702  			; XREF	OSSAVE
042FB6             8703  			; XREF	ERR
042FB6             8704  			; XREF	ERL
042FB6             8705  			; XREF	TRACEN
042FB6             8706  			; XREF	RESET
042FB6             8707  			; XREF	OSSHUT
042FB6             8708  			; XREF	OSLOAD
042FB6             8709  			; XREF	FREE
042FB6             8710  			; XREF	DYNVAR
042FB6             8711  			; XREF	FILL
042FB6             8712  			; XREF	OSWRCH
042FB6             8713  			; XREF	WIDTH
042FB6             8714  			; XREF	COMMA
042FB6             8715  			; XREF	MUL16
042FB6             8716  			; XREF	BRAKET
042FB6             8717  			; XREF	X4OR5
042FB6             8718  			; XREF	LOADN
042FB6             8719  			; XREF	SFIX
042FB6             8720  			; XREF	ITEMI
042FB6             8721  			; XREF	FNPTR
042FB6             8722  			; XREF	PROPTR
042FB6             8723  			; XREF	CHECK
042FB6             8724  			; XREF	TERMQ
042FB6             8725  			; XREF	OSWRCHCH
042FB6             8726  			; XREF	NEWIT
042FB6             8727  			; XREF	BAD
042FB6             8728  			; XREF	RAM_START
042FB6             8729  			; XREF	RAM_END
042FB6             8730  			; XREF	R0
042FB6             8731  			; XREF	STAR_VERSION
042FB6             8732  
042FB6             8733  			; XREF	_end			; In init.asm
042FB6             8734  ;
042FB6             8735  ; A handful of common token IDs
042FB6             8736  ;
042FB6             8737  TERROR_MN:			EQU     85H
042FB6             8738  LINE_MN_:			EQU     86H
042FB6             8739  ELSE_MN_:			EQU     8BH
042FB6             8740  THEN_MN_:			EQU     8CH
042FB6             8741  LINO_MN:			EQU     8DH
042FB6             8742  FN:			EQU     A4H
042FB6             8743  TO_MN:			EQU     B8H
042FB6             8744  REN:			EQU     CCH
042FB6             8745  DATA_MN_:			EQU     DCH
042FB6             8746  DIM:			EQU     DEH
042FB6             8747  FOR:			EQU     E3H
042FB6             8748  GOSUB:			EQU     E4H
042FB6             8749  GOTO:			EQU     E5H
042FB6             8750  TIF:			EQU     E7H
042FB6             8751  LOCAL_:			EQU     EAH
042FB6             8752  NEXT:			EQU     EDH
042FB6             8753  ON_:			EQU     EEH
042FB6             8754  PROC:			EQU     F2H
042FB6             8755  REM:			EQU     F4H
042FB6             8756  REPEAT:			EQU     F5H
042FB6             8757  RESTOR:			EQU     F7H
042FB6             8758  TRACE:			EQU     FCH
042FB6             8759  UNTIL:			EQU     FDH
042FB6             8760  ;
042FB6             8761  ; This defines the block of tokens that are pseudo-variables.
042FB6             8762  ; There are two versions of each token, a GET and a SET
042FB6             8763  
042FB6             8764  ; Name  : GET : SET
042FB6             8765  ; ------:-----:----
042FB6             8766  ; PTR   : 8Fh : CFh
042FB6             8767  ; PAGE  : 90h : D0h
042FB6             8768  ; TIME  : 91h : D1h
042FB6             8769  ; LOMEM : 92h : D2h
042FB6             8770  ; HIMEM : 93h : D3h
042FB6             8771  ;
042FB6             8772  ; Examples:
042FB6             8773  ;   LET A% = PAGE : REM This is the GET version
042FB6             8774  ;   PAGE = 40000  : REM This is the SET version
042FB6             8775  ;
042FB6             8776  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FB6             8777  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FB6             8778  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FB6             8779  
042FB6             8780  ; The main routine
042FB6             8781  ; IXU: argv - pointer to array of parameters
042FB6             8782  ;   C: argc - number of parameters
042FB6             8783  ; Returns:
042FB6             8784  ;  HL: Error code, or 0 if OK
042FB6             8785  ;
042FB6 21 00 4A 04 8786  _main:			LD	HL, ACCS		; Clear the ACCS
042FBA 36 00       8787  			LD	(HL), 0
042FBC 79          8788  			LD	A, C
042FBD FE 02       8789  			CP	2
042FBF 28 2D       8790  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FC1 38 3F       8791  			JR	C, COLD			; 1 parameter = normal start
042FC3 CD 38 40 04 8792  			CALL	STAR_VERSION
042FC7 CD 90 3D 04 8793  			CALL	TELL
042FCB 55 73 61 67 8794  			DB	"Usage:\n\r"
       65 3A 0A 0D 
042FD3 52 55 4E 20 8795  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
042FE6 21 00 00 00 8796  			LD	HL, 0			; The error code
042FEA C3 68 00 04 8797  			JP	_end
042FEE             8798  ;
042FEE DD 27 03    8799  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
042FF1 11 00 4A 04 8800  			LD	DE, ACCS		;  DE: Destination address
042FF5 7E          8801  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
042FF6 12          8802  			LD	(DE), A			;
042FF7 23          8803  			INC	HL			; Increase the source pointer
042FF8 1C          8804  			INC	E			; We only need to increase E as ACCS is on a page boundary
042FF9 28 03       8805  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
042FFB B7          8806  			OR	A
042FFC 20 F7       8807  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
042FFE 1D          8808  AUTOLOAD_2:		DEC	E
042FFF 3E 0D       8809  			LD	A, CR
043001 12          8810  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
043002             8811  ;
043002 E1          8812  COLD:			POP	HL			; Pop the return address to init off SPS
043003 E5          8813  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043004 21 00 4C 04 8814  			LD	HL, STAVAR		; Cold start
043008 F9          8815  			LD	SP, HL
043009 36 0A       8816  			LD	(HL), 10
04300B 23          8817  			INC	HL
04300C 36 09       8818  			LD	(HL),9
04300E CD 81 3F 04 8819  			CALL    OSINIT			; Call the machine specific OS initialisation routines
043012 ED 53 20 4D 8820  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
043017 22 14 4D 04 8821  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
04301B 3E B7       8822  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
04301D 32 40 4D 04 8823  			LD      (LISTON),A
043021 21 5C 30 04 8824  			LD      HL,NOTICE
043025 22 2F 4D 04 8825  			LD      (ERRTXT),HL
043029 CD 6C 38 04 8826  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
04302D 3A 00 4A 04 8827  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043031 B7          8828  			OR	A
043032 C2 53 0B 04 8829  			JP	NZ,CHAIN0		; Yes, so load and run
043036 CD 38 40 04 8830  			CALL	STAR_VERSION		;
04303A CD 90 3D 04 8831  			CALL    TELL			; Output the welcome message
04303E 42 42 43 20 8832  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
04305C 28 43 29 20 8833  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
04307C 0A 0D 00    8834  			DB	"\n\r", 0
04307F             8835  ;
04307F F6          8836  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
043080             8837  ;
043080             8838  ; This is the main entry point for BASIC
043080             8839  ;
043080 37          8840  CLOOP:			SCF				; See above - not sure why this is here!
043081 ED 7B 20 4D 8841  			LD      SP,(HIMEM)
       04          
043086 CD FA 3E 04 8842  			CALL    PROMPT          	; Prompt user
04308A 21 40 4D 04 8843  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
04308E 7E          8844  			LD      A,(HL)			; Fetch the value
04308F E6 0F       8845  			AND     0FH             	; Bottom nibble: LISTO
043091 F6 B0       8846  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
043093 77          8847  			LD      (HL),A			; Store back in
043094 ED 62       8848  			SBC     HL,HL           	; HL: 0
043096 22 2C 4D 04 8849  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
04309A 22 35 4D 04 8850  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
04309E             8851  ;
04309E 2A 29 4D 04 8852  			LD      HL,(AUTONO)		; Get the auto line number
0430A2 22 23 4D 04 8853  			LD      (LINENO),HL		; Store in line number
0430A6 7C          8854  			LD      A,H			; If the auto line number is zero then
0430A7 B5          8855  			OR      L
0430A8 28 1E       8856  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0430AA             8857  ;
0430AA             8858  ; This section handles auto line numbering
0430AA             8859  ;
0430AA E5          8860  			PUSH    HL			; Stack the line number
0430AB CD FB 39 04 8861  			CALL    PBCD           	 	; Output the line number
0430AF E1          8862  			POP     HL			; Pop the line number back off the stack
0430B0             8863  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0430B0             8864  ;			LD      B,0			; So clear B
0430B0 01 00 00 00 8865  			LD	BC, 0			; Load BC with Increment
0430B4 3A 41 4D 04 8866  			LD	A,(INCREM)
0430B8 4F          8867  			LD	C, A
0430B9 09          8868  			ADD     HL,BC			; Add the increment to the line number
0430BA DA 25 3C 04 8869  			JP      C,TOOBIG		; And error if we wrap
0430BE 22 29 4D 04 8870  			LD      (AUTONO),HL		; Store the new auto line number
0430C2 3E 20       8871  			LD      A,' '			; Print a space
0430C4 CD 4F 39 04 8872  			CALL    OUTCHR
0430C8             8873  ;
0430C8             8874  ; This section invokes the line editor
0430C8             8875  ;
0430C8 21 00 4A 04 8876  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0430CC CD 5F 3E 04 8877  			CALL    OSLINE          	; Call the line editor in MOS
0430D0 CD DC 30 04 8878  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0430D4 DC 3F 38 04 8879  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0430D8 C3 80 30 04 8880  			JP      CLOOP			; Jump back to immediate mode
0430DC             8881  ;
0430DC             8882  ; This bit enters the line into memory
0430DC             8883  ; Also called from OSLOAD_TXT
0430DC             8884  ; Returns:
0430DC             8885  ; F: C if a new line has been entered (CLEAN will need to be called)
0430DC             8886  ;
0430DC AF          8887  ONEDIT1:		XOR     A			; Entry point after *EDIT
0430DD 32 3D 4D 04 8888  			LD      (COUNT),A
0430E1 FD 21 00 4A 8889  			LD      IY,ACCS
       04          
0430E6 CD F9 3B 04 8890  			CALL    LINNUM			; HL: The line number from the input buffer
0430EA CD 70 0A 04 8891  			CALL    NXT			; Skip spaces
0430EE 7C          8892  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0430EF B5          8893  			OR      L
0430F0 28 04       8894  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0430F2 22 23 4D 04 8895  			LD      (LINENO),HL		; Otherwise store it
0430F6             8896  ;
0430F6             8897  ; This bit does the lexical analysis and tokenisation
0430F6             8898  ;
0430F6 0E 01       8899  LNZERO:			LD	C,1			; Left mode
0430F8 11 00 4B 04 8900  			LD      DE,BUFFER		; Buffer for tokenised BASIC
0430FC CD 9F 3C 04 8901  			CALL    LEXAN2          	; Lexical analysis on the user input
043100 12          8902  			LD      (DE),A          	; Terminator
043101 AF          8903  			XOR     A
043102             8904  ;			LD      B,A
043102             8905  ;			LD      C,E             	; BC: Line length
043102 01 00 00 00 8906  			LD	BC,0
043106 4B          8907  			LD	C,E			; BC: Line length
043107 13          8908  			INC     DE
043108 12          8909  			LD      (DE),A          	; Zero next
043109 2A 23 4D 04 8910  			LD      HL,(LINENO)		; Get the line number
04310D 7C          8911  			LD      A,H			; Is it zero, i.e. a command with no line number?
04310E B5          8912  			OR      L
04310F FD 21 00 4B 8913  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
043114 CA 96 0B 04 8914  			JP      Z,XEQ           	; Execute it
043118             8915  ;
043118             8916  ; This section stores the BASIC line in memory
043118             8917  ;
043118 C5          8918  			PUSH    BC
043119 E5          8919  			PUSH    HL
04311A CD 4B 38 04 8920  			CALL    SETTOP          	; Set TOP sysvar
04311E E1          8921  			POP     HL
04311F CD 8F 39 04 8922  			CALL    FINDL			; Find the address of the line
043123 CC 02 38 04 8923  			CALL    Z,DEL			; Delete the existing line if found
043127 C1          8924  			POP     BC
043128 79          8925  			LD      A,C			; Check for the line length being zero, i.e.
043129 B7          8926  			OR      A			; the user has just entered a line number in the command line
04312A C8          8927  			RET	Z 	         	; If so, then don't do anything else
04312B C6 04       8928  			ADD     A,4
04312D 4F          8929  			LD      C,A             	; Length inclusive
04312E D5          8930  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
04312F C5          8931  			PUSH    BC              	; BC: Line length
043130 EB          8932  			EX      DE,HL			; DE: Address of the line in memory
043131 2A 17 4D 04 8933  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043135 E5          8934  			PUSH    HL			; Stack TOP (current TOP value)
043136 09          8935  			ADD     HL,BC			; Add the line length to HL, the new TOP value
043137 E5          8936  			PUSH    HL			; Stack HL (new TOP value)
043138 24          8937  			INC     H			; Add 256 to HL
043139 AF          8938  			XOR     A
04313A ED 72       8939  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
04313C E1          8940  			POP     HL			; Pop HL (new TOP value)
04313D D2 60 37 04 8941  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043141 22 17 4D 04 8942  			LD      (TOP),HL		; Store new value of TOP
043145 E3          8943  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043146 E5          8944  			PUSH    HL			; PUSH current TOP value
043147 23          8945  			INC     HL
043148 B7          8946  			OR      A
043149 ED 52       8947  			SBC     HL,DE			; DE: Address of the line in memory
04314B 44          8948  			LD      B,H             	; BC: Amount to move
04314C 4D          8949  			LD      C,L
04314D E1          8950  			POP     HL			; HL: Destination (current TOP value)
04314E D1          8951  			POP     DE			; DE: Source (new TOP value)
04314F 28 02       8952  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043151 ED B8       8953  			LDDR                    	; Otherwise, make space for the new line in the program
043153 C1          8954  ATEND:			POP     BC              	; BC: Line length
043154 D1          8955  			POP     DE              	; DE: Line number
043155 23          8956  			INC     HL			; HL: Destination address
043156 71          8957  			LD      (HL),C          	; Store length
043157 23          8958  			INC     HL
043158 73          8959  			LD      (HL),E          	; Store line number
043159 23          8960  			INC     HL
04315A 72          8961  			LD      (HL),D
04315B 23          8962  			INC     HL
04315C 11 00 4B 04 8963  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
043160 EB          8964  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043161 0D          8965  			DEC     C			; Subtract 3 from the number of bytes to copy to
043162 0D          8966  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
043163 0D          8967  			DEC     C
043164 ED B0       8968  			LDIR                    	; Add the line to the BASIC program
043166 37          8969  			SCF				; To flag we need to call CLEAN
043167 C9          8970  			RET
043168             8971  ;
043168             8972  ; List of tokens and keywords. If a keyword is followed by 0 then
043168             8973  ; it will only match with the keyword followed immediately by
043168             8974  ; a delimiter
043168             8975  ;
043168 80 41 4E 44 8976  KEYWDS:			DB    80H, "AND"
04316C 94 41 42 53 8977  			DB    94H, "ABS"
043170 95 41 43 53 8978  			DB    95H, "ACS"
043174 96 41 44 56 8979  			DB    96H, "ADVAL"
       41 4C       
04317A 97 41 53 43 8980  			DB    97H, "ASC"
04317E 98 41 53 4E 8981  			DB    98H, "ASN"
043182 99 41 54 4E 8982  			DB    99H, "ATN"
043186 C6 41 55 54 8983  			DB    C6H, "AUTO"
       4F          
04318B 9A 42 47 45 8984  			DB    9AH, "BGET", 0
       54 00       
043191 D5 42 50 55 8985  			DB    D5H, "BPUT", 0
       54 00       
043197 FB 43 4F 4C 8986  			DB    FBH, "COLOUR"
       4F 55 52    
04319E FB 43 4F 4C 8987  			DB    FBH, "COLOR"
       4F 52       
0431A4 D6 43 41 4C 8988  			DB    D6H, "CALL"
       4C          
0431A9 D7 43 48 41 8989  			DB    D7H, "CHAIN"
       49 4E       
0431AF BD 43 48 52 8990  			DB    BDH, "CHR$"
       24          
0431B4 D8 43 4C 45 8991  			DB    D8H, "CLEAR", 0
       41 52 00    
0431BB D9 43 4C 4F 8992  			DB    D9H, "CLOSE", 0
       53 45 00    
0431C2 DA 43 4C 47 8993  			DB    DAH, "CLG", 0
       00          
0431C7 DB 43 4C 53 8994  			DB    DBH, "CLS", 0
       00          
0431CC 9B 43 4F 53 8995  			DB    9BH, "COS"
0431D0 9C 43 4F 55 8996  			DB    9CH, "COUNT", 0
       4E 54 00    
0431D7 DC 44 41 54 8997  			DB    DCH, "DATA"
       41          
0431DC 9D 44 45 47 8998  			DB    9DH, "DEG"
0431E0 DD 44 45 46 8999  			DB    DDH, "DEF"
0431E4 C7 44 45 4C 9000  			DB    C7H, "DELETE"
       45 54 45    
0431EB 81 44 49 56 9001  			DB    81H, "DIV"
0431EF DE 44 49 4D 9002  			DB    DEH, "DIM"
0431F3 DF 44 52 41 9003  			DB    DFH, "DRAW"
       57          
0431F8 E1 45 4E 44 9004  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043201 E0 45 4E 44 9005  			DB    E0H, "END", 0
       00          
043206 E2 45 4E 56 9006  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
04320F 8B 45 4C 53 9007  			DB    8BH, "ELSE"
       45          
043214 A0 45 56 41 9008  			DB    A0H, "EVAL"
       4C          
043219 9E 45 52 4C 9009  			DB    9EH, "ERL", 0
       00          
04321E 85 45 52 52 9010  			DB    85H, "ERROR"
       4F 52       
043224 C5 45 4F 46 9011  			DB    C5H, "EOF", 0
       00          
043229 82 45 4F 52 9012  			DB    82H, "EOR"
04322D 9F 45 52 52 9013  			DB    9FH, "ERR", 0
       00          
043232 A1 45 58 50 9014  			DB    A1H, "EXP"
043236 A2 45 58 54 9015  			DB    A2H, "EXT", 0
       00          
04323B E3 46 4F 52 9016  			DB    E3H, "FOR"
04323F A3 46 41 4C 9017  			DB    A3H, "FALSE", 0
       53 45 00    
043246 A4 46 4E    9018  			DB    A4H, "FN"
043249 E5 47 4F 54 9019  			DB    E5H, "GOTO"
       4F          
04324E BE 47 45 54 9020  			DB    BEH, "GET$"
       24          
043253 A5 47 45 54 9021  			DB    A5H, "GET"
043257 E4 47 4F 53 9022  			DB    E4H, "GOSUB"
       55 42       
04325D E6 47 43 4F 9023  			DB    E6H, "GCOL"
       4C          
043262 93 48 49 4D 9024  			DB    93H, "HIMEM", 0
       45 4D 00    
043269 E8 49 4E 50 9025  			DB    E8H, "INPUT"
       55 54       
04326F E7 49 46    9026  			DB    E7H, "IF"
043272 BF 49 4E 4B 9027  			DB    BFH, "INKEY$"
       45 59 24    
043279 A6 49 4E 4B 9028  			DB    A6H, "INKEY"
       45 59       
04327F A8 49 4E 54 9029  			DB    A8H, "INT"
043283 A7 49 4E 53 9030  			DB    A7H, "INSTR("
       54 52 28    
04328A C9 4C 49 53 9031  			DB    C9H, "LIST"
       54          
04328F 86 4C 49 4E 9032  			DB    86H, "LINE"
       45          
043294 C8 4C 4F 41 9033  			DB    C8H, "LOAD"
       44          
043299 92 4C 4F 4D 9034  			DB    92H, "LOMEM", 0
       45 4D 00    
0432A0 EA 4C 4F 43 9035  			DB    EAH, "LOCAL"
       41 4C       
0432A6 C0 4C 45 46 9036  			DB    C0H, "LEFT$("
       54 24 28    
0432AD A9 4C 45 4E 9037  			DB    A9H, "LEN"
0432B1 E9 4C 45 54 9038  			DB    E9H, "LET"
0432B5 AB 4C 4F 47 9039  			DB    ABH, "LOG"
0432B9 AA 4C 4E    9040  			DB    AAH, "LN"
0432BC C1 4D 49 44 9041  			DB    C1H, "MID$("
       24 28       
0432C2 EB 4D 4F 44 9042  			DB    EBH, "MODE"
       45          
0432C7 83 4D 4F 44 9043  			DB    83H, "MOD"
0432CB EC 4D 4F 56 9044  			DB    ECH, "MOVE"
       45          
0432D0 ED 4E 45 58 9045  			DB    EDH, "NEXT"
       54          
0432D5 CA 4E 45 57 9046  			DB    CAH, "NEW", 0
       00          
0432DA AC 4E 4F 54 9047  			DB    ACH, "NOT"
0432DE CB 4F 4C 44 9048  			DB    CBH, "OLD", 0
       00          
0432E3 EE 4F 4E    9049  			DB    EEH, "ON"
0432E6 87 4F 46 46 9050  			DB    87H, "OFF"
0432EA 84 4F 52    9051  			DB    84H, "OR"
0432ED 8E 4F 50 45 9052  			DB    8EH, "OPENIN"
       4E 49 4E    
0432F4 AE 4F 50 45 9053  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0432FC AD 4F 50 45 9054  			DB    ADH, "OPENUP"
       4E 55 50    
043303 FF 4F 53 43 9055  			DB    FFH, "OSCLI"
       4C 49       
043309 F1 50 52 49 9056  			DB    F1H, "PRINT"
       4E 54       
04330F 90 50 41 47 9057  			DB    90H, "PAGE", 0
       45 00       
043315 8F 50 54 52 9058  			DB    8FH, "PTR", 0
       00          
04331A AF 50 49 00 9059  			DB    AFH, "PI", 0
04331E F0 50 4C 4F 9060  			DB    F0H, "PLOT"
       54          
043323 B0 50 4F 49 9061  			DB    B0H, "POINT("
       4E 54 28    
04332A F2 50 52 4F 9062  			DB    F2H, "PROC"
       43          
04332F B1 50 4F 53 9063  			DB    B1H, "POS", 0
       00          
043334 CE 50 55 54 9064  			DB    CEH, "PUT"
043338 F8 52 45 54 9065  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043340 F5 52 45 50 9066  			DB    F5H, "REPEAT"
       45 41 54    
043347 F6 52 45 50 9067  			DB    F6H, "REPORT", 0
       4F 52 54 00 
04334F F3 52 45 41 9068  			DB    F3H, "READ"
       44          
043354 F4 52 45 4D 9069  			DB    F4H, "REM"
043358 F9 52 55 4E 9070  			DB    F9H, "RUN", 0
       00          
04335D B2 52 41 44 9071  			DB    B2H, "RAD"
043361 F7 52 45 53 9072  			DB    F7H, "RESTORE"
       54 4F 52 45 
043369 C2 52 49 47 9073  			DB    C2H, "RIGHT$("
       48 54 24 28 
043371 B3 52 4E 44 9074  			DB    B3H, "RND", 0
       00          
043376 CC 52 45 4E 9075  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
04337F 88 53 54 45 9076  			DB    88H, "STEP"
       50          
043384 CD 53 41 56 9077  			DB    CDH, "SAVE"
       45          
043389 B4 53 47 4E 9078  			DB    B4H, "SGN"
04338D B5 53 49 4E 9079  			DB    B5H, "SIN"
043391 B6 53 51 52 9080  			DB    B6H, "SQR"
043395 89 53 50 43 9081  			DB    89H, "SPC"
043399 C3 53 54 52 9082  			DB    C3H, "STR$"
       24          
04339E C4 53 54 52 9083  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433A7 D4 53 4F 55 9084  			DB    D4H, "SOUND"
       4E 44       
0433AD FA 53 54 4F 9085  			DB    FAH, "STOP", 0
       50 00       
0433B3 B7 54 41 4E 9086  			DB    B7H, "TAN"
0433B7 8C 54 48 45 9087  			DB    8CH, "THEN"
       4E          
0433BC B8 54 4F    9088  			DB    B8H, "TO"
0433BF 8A 54 41 42 9089  			DB    8AH, "TAB("
       28          
0433C4 FC 54 52 41 9090  			DB    FCH, "TRACE"
       43 45       
0433CA 91 54 49 4D 9091  			DB    91H, "TIME", 0
       45 00       
0433D0 B9 54 52 55 9092  			DB    B9H, "TRUE", 0
       45 00       
0433D6 FD 55 4E 54 9093  			DB    FDH, "UNTIL"
       49 4C       
0433DC BA 55 53 52 9094  			DB    BAH, "USR"
0433E0 EF 56 44 55 9095  			DB    EFH, "VDU"
0433E4 BB 56 41 4C 9096  			DB    BBH, "VAL"
0433E8 BC 56 50 4F 9097  			DB    BCH, "VPOS", 0
       53 00       
0433EE FE 57 49 44 9098  			DB    FEH, "WIDTH"
       54 48       
0433F4 D3 48 49 4D 9099  			DB    D3H, "HIMEM"
       45 4D       
0433FA D2 4C 4F 4D 9100  			DB    D2H, "LOMEM"
       45 4D       
043400 D0 50 41 47 9101  			DB    D0H, "PAGE"
       45          
043405 CF 50 54 52 9102  			DB    CFH, "PTR"
043409 D1 54 49 4D 9103  			DB    D1H, "TIME"
       45          
04340E             9104  ;
04340E             9105  ; These are indexed from the ERRWDS table
04340E             9106  ;
04340E 01 4D 69 73 9107  			DB    01H, "Missing "
       73 69 6E 67 
       20          
043417 02 4E 6F 20 9108  			DB    02H, "No such "
       73 75 63 68 
       20          
043420 03 42 61 64 9109  			DB    03H, "Bad "
       20          
043425 04 20 72 61 9110  			DB    04H, " range"
       6E 67 65    
04342C 05 76 61 72 9111  			DB    05H, "variable"
       69 61 62 6C 
       65          
043435 06 4F 75 74 9112  			DB    06H, "Out of"
       20 6F 66    
04343C 07 4E 6F 20 9113  			DB    07H, "No "
043440 08 20 73 70 9114  			DB    08H, " space"
       61 63 65    
043447             9115  
043447             9116  KEYWDL:			EQU     $-KEYWDS
043447 FF FF       9117  			DW    -1
043449             9118  ;
043449             9119  ; Error messages
043449             9120  ;
043449 07 72 6F 6F 9121  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
04344F 06 04 00    9122  			DB    6, 4, 0			;  1: Out of range
043452 00          9123  			DB    0				;  2: *
043453 00          9124  			DB    0				;  3: *
043454 4D 69 73 74 9125  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
04345C 01 2C 00    9126  			DB    1, ",", 0			;  5: Missing ,
04345F 54 79 70 65 9127  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
04346D 07 A4 00    9128  			DB    7, FN, 0			;  7: No FN
043470 00          9129  			DB    0				;  8: *
043471 01 22 00    9130  			DB    1, 34, 0			;  9: Missing "
043474 03 DE 00    9131  			DB    3, DIM, 0			; 10: Bad DIM
043477 DE 08 00    9132  			DB    DIM, 8, 0			; 11: DIM space
04347A 4E 6F 74 20 9133  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
043480 07 F2 00    9134  			DB    7, PROC, 0		; 13: No PROC
043483 41 72 72 61 9135  			DB    "Array", 0		; 14: Array
       79 00       
043489 53 75 62 73 9136  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
043493 53 79 6E 74 9137  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434A0 45 73 63 61 9138  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434A7 44 69 76 69 9139  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0434B8 53 74 72 69 9140  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0434C8 54 6F 6F 20 9141  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
0434D0 2D 76 65 20 9142  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
0434D9 4C 6F 67 04 9143  			DB    "Log", 4, 0		; 22: Log range
       00          
0434DE 41 63 63 75 9144  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
0434EC 45 78 70 04 9145  			DB    "Exp", 4, 0		; 24: Exp range
       00          
0434F1 00          9146  			DB    0				; 25: *
0434F2 02 05 00    9147  			DB    2, 5, 0			; 26: No such variable
0434F5 01 29 00    9148  			DB    1, ")", 0			; 27: Missing )
0434F8 03 48 45 58 9149  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
0434FD 02 A4 2F F2 9150  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043502 03 63 61 6C 9151  			DB    3, "call", 0		; 30: Bad call
       6C 00       
043508 41 72 67 75 9152  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043512 07 E3 00    9153  			DB    7, FOR, 0			; 32: No FOR
043515 43 61 6E 27 9154  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043523 E3 20 05 00 9155  			DB    FOR, " ", 5, 0		; 34: FOR variable
043527 00          9156  			DB    0				; 35: *
043528 07 B8 00    9157  			DB    7, TO_MN, 0			; 36: No TO
04352B 00          9158  			DB    0				; 37: *
04352C 07 E4 00    9159  			DB    7, GOSUB, 0		; 38: No GOSUB
04352F EE 20 73 79 9160  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
043538 EE 04 00    9161  			DB    ON_, 4, 0			; 40: ON range
04353B 02 6C 69 6E 9162  			DB    2, "line", 0		; 41: No such line
       65 00       
043541 06 20 DC 00 9163  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
043545 07 F5 00    9164  			DB    7, REPEAT, 0		; 43: No REPEAT
043548 00          9165  			DB    0				; 44: *
043549 01 23 00    9166  			DB    1, "#", 0			; 45: Missing #
04354C             9167  ;
04354C             9168  ; COMMANDS:
04354C             9169  ;
04354C             9170  ; DELETE line,line
04354C             9171  ;
04354C CD 4B 38 04 9172  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
043550 CD 53 3C 04 9173  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
043554 7E          9174  DELET1:			LD      A,(HL)			; Check whether it's the last line
043555 B7          9175  			OR      A
043556 CA DD 35 04 9176  			JP      Z,WARMNC		; Yes, so do nothing
04355A 23          9177  			INC     HL			; Skip the line length byte
04355B 11 00 00 00 9178  			LD	DE, 0			; Clear DE
04355F 5E          9179  			LD      E,(HL)			; Fetch the line number in DE
043560 23          9180  			INC     HL
043561 56          9181  			LD      D,(HL)
043562 7A          9182  			LD      A,D			; If the line number is zero then
043563 B3          9183  			OR      E
043564 28 1D       9184  			JR      Z,CLOOP1        	; Do nothing
043566 2B          9185  			DEC     HL			; Decrement BASIC program pointer back to length
043567 2B          9186  			DEC     HL
043568 EB          9187  			EX      DE,HL			; Check if we've gone past the terminating line
043569 37          9188  			SCF
04356A ED 42       9189  			SBC     HL,BC
04356C EB          9190  			EX      DE,HL
04356D 30 6E       9191  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04356F C5          9192  			PUSH    BC
043570 CD 02 38 04 9193  			CALL    DEL			; Delete the line pointed to by HL
043574 C1          9194  			POP     BC
043575 18 DD       9195  			JR      DELET1			; And loop round to the next line
043577             9196  ;
043577             9197  ; LISTO expr
043577             9198  ;
043577 FD 23       9199  LISTO:			INC     IY              	; Skip "O" byte
043579 CD 0A 03 04 9200  			CALL    EXPRI			; Get expr
04357D D9          9201  			EXX
04357E 7D          9202  			LD      A,L
04357F 32 40 4D 04 9203  			LD      (LISTON),A		; Store in LISTON sysvar
043583 C3 80 30 04 9204  CLOOP1:			JP      CLOOP
043587             9205  ;
043587             9206  ; LIST
043587             9207  ; LIST line
043587             9208  ; LIST line,line [IF string]
043587             9209  ; LIST ,line
043587             9210  ; LIST line,
043587             9211  ;
043587 FE 4F       9212  LIST_:			CP      'O'			; Check for O (LISTO)
043589 28 EC       9213  			JR      Z,LISTO			; and jump to LISTO if zero
04358B CD 53 3C 04 9214  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04358F CD 70 0A 04 9215  			CALL    NXT			; Skip space
043593 FE E7       9216  			CP      TIF             	; Check for IF clause (token IF)
043595 3E 00       9217  			LD      A,0             	; Initialise the IF clause string length
043597 20 17       9218  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
043599             9219  ;
043599 FD 23       9220  			INC     IY              	; Skip the IF token
04359B CD 70 0A 04 9221  			CALL    NXT             	; And skip any spaces
04359F EB          9222  			EX      DE,HL			; DE: Address in memory
0435A0 FD E5       9223  			PUSH    IY			; LD IY, HL
0435A2 E1          9224  			POP     HL              	; HL is now the address of the tokenised line
0435A3 3E 0D       9225  			LD      A,CR
0435A5 C5          9226  			PUSH    BC			; Stack the second line number arg
0435A6 01 00 01 00 9227  			LD      BC,256
0435AA ED B1       9228  			CPIR                    	; Locate CR byte
0435AC 79          9229  			LD      A,C
0435AD 2F          9230  			CPL                    	 	; A: Substring length (of IF clause)
0435AE C1          9231  			POP     BC			; Restore the second line number arg
0435AF EB          9232  			EX      DE,HL			; HL: Address in memory
0435B0             9233  ;
0435B0 5F          9234  LISTB:			LD      E,A             	; E: IF clause string length
0435B1 78          9235  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0435B2 B1          9236  			OR      C
0435B3 20 01       9237  			JR      NZ,LISTA		; If there isn't a second line number
0435B5 0B          9238  			DEC     BC			; then we set it to the maximum of 65535
0435B6             9239  ;
0435B6 D9          9240  LISTA:			EXX
0435B7 DD 21 40 4D 9241  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
0435BC 01 00 00 00 9242  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0435C0 D9          9243  			EXX
0435C1 3E 14       9244  			LD      A,20			; Number of lines to list
0435C3             9245  ;
0435C3 C5          9246  LISTC:			PUSH    BC              	; Save second line number
0435C4 D5          9247  			PUSH    DE              	; Save IF clause length
0435C5 E5          9248  			PUSH    HL              	; Save BASIC program counter
0435C6 08          9249  			EX      AF,AF'
0435C7             9250  ;
0435C7             9251  ; BBC BASIC for Z80 lines are stored as follows:
0435C7             9252  ;
0435C7             9253  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0435C7             9254  ; - [&00] [&FF] [&FF]: End of program marker
0435C7             9255  ;
0435C7             9256  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0435C7             9257  ;
0435C7 7E          9258  			LD      A,(HL)			; Check for end of program marker
0435C8 B7          9259  			OR      A			; If found
0435C9 28 12       9260  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0435CB             9261  ;
0435CB             9262  ; Check if past terminating line number
0435CB             9263  ;
0435CB 7B          9264  			LD      A,E             	; A: IF clause length
0435CC 23          9265  			INC     HL			; Skip the length byte
0435CD 11 00 00 00 9266  			LD	DE,0			; Clear DE
0435D1 5E          9267  			LD      E,(HL)			; Fetch the line number in DE
0435D2 23          9268  			INC     HL
0435D3 56          9269  			LD      D,(HL)
0435D4 2B          9270  			DEC     HL			; Step HL back to the length byte
0435D5 2B          9271  			DEC     HL
0435D6 D5          9272  			PUSH    DE             	 	; Push the line number on the stack
0435D7 EB          9273  			EX      DE,HL			; HL: line number
0435D8 37          9274  			SCF				; Do a 16-bit compare of HL and DE
0435D9 ED 42       9275  			SBC     HL,BC
0435DB EB          9276  			EX      DE,HL
0435DC D1          9277  			POP     DE              	; Restore the line number
0435DD D2 7F 30 04 9278  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0435E1 4E          9279  			LD      C,(HL)          	; C: Line length + 4
0435E2 47          9280  			LD      B,A             	; B: IF clause length
0435E3             9281  ;
0435E3             9282  ; Check if "UNLISTABLE":
0435E3             9283  ;
0435E3 7A          9284  			LD      A,D			; TODO: What is "UNLISTABLE?"
0435E4 B3          9285  			OR      E
0435E5 CA 80 30 04 9286  			JP      Z,CLOOP
0435E9             9287  ;
0435E9             9288  ; Check for IF clause:
0435E9             9289  ;
0435E9 23          9290  			INC     HL			; Skip the length
0435EA 23          9291  			INC     HL			; Skip the line number
0435EB 23          9292  			INC     HL              	; HL: Address of the tokenised BASIC line
0435EC 0D          9293  			DEC     C			;  C: Line length
0435ED 0D          9294  			DEC     C
0435EE 0D          9295  			DEC     C
0435EF 0D          9296  			DEC     C
0435F0 D5          9297  			PUSH    DE              	; Save the line number
0435F1 E5          9298  			PUSH    HL              	; Save the BASIC program address
0435F2 AF          9299  			XOR     A               	;
0435F3 B8          9300  			CP      B              	 	; Check for an IF clause (B!=0)
0435F4 FD E5       9301  			PUSH    IY			; LD IY, DE
0435F6 D1          9302  			POP     DE              	; DE: Address of the IF clause string in the input buffer
0435F7 C4 85 07 04 9303  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0435FB E1          9304  			POP     HL              	; Restore BASIC program address
0435FC D1          9305  			POP     DE              	; Restore line number
0435FD FD E5       9306  			PUSH    IY
0435FF CC 92 38 04 9307  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043603 FD E1       9308  			POP     IY
043605             9309  ;
043605 08          9310  			EX      AF,AF'
043606 3D          9311  			DEC     A			; Decrement line list counter
043607 CD 71 3F 04 9312  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
04360B E1          9313  			POP     HL             	 	; Restore BASIC program address to beginning of line
04360C 11 00 00 00 9314  			LD	DE,0
043610 5E          9315  			LD      E,(HL)			; Fetch the length of line in DE
043611 19          9316  			ADD     HL,DE           	; Go to the next line
043612 D1          9317  			POP     DE              	; Restore IF clause length
043613 C1          9318  			POP     BC              	; Restore second line number
043614 18 AD       9319  			JR      LISTC			; Loop back to do next line
043616             9320  ;
043616             9321  ; RENUMBER
043616             9322  ; RENUMBER start
043616             9323  ; RENUMBER start,increment
043616             9324  ; RENUMBER ,increment
043616             9325  ;
043616 CD 76 38 04 9326  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04361A CD 2B 3C 04 9327  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04361E D9          9328  			EXX
04361F 2A 14 4D 04 9329  			LD      HL,(PAGE_)		; HL: Top of program
043623 ED 5B 1A 4D 9330  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
043628             9331  ;
043628             9332  ; Build the table
043628             9333  ;
043628 7E          9334  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
043629 B7          9335  			OR      A			; Is it zero, i.e. the end of program marker?
04362A 28 36       9336  			JR      Z,RENUM2		; Yes, so skip to the next part
04362C 23          9337  			INC     HL
04362D 4E          9338  			LD      C,(HL)          	; BC: The OLD line number
04362E 23          9339  			INC     HL
04362F 46          9340  			LD      B,(HL)
043630 78          9341  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043631 B1          9342  			OR      C
043632 CA 80 30 04 9343  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
043636 EB          9344  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043637 71          9345  			LD      (HL),C			; Store the OLD line number in the heap
043638 23          9346  			INC     HL
043639 70          9347  			LD      (HL),B
04363A 23          9348  			INC     HL
04363B D9          9349  			EXX				; HL: line number, BC: increment (16-bit values)
04363C E5          9350  			PUSH    HL			; HL: Stack the NEW line number value
04363D 52 09       9351  			ADD.S   HL,BC           	; Add the increment
04363F DA 25 3C 04 9352  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043643 D9          9353  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
043644 C1          9354  			POP     BC			; BC: Pop the NEW line number value off the stack
043645 71          9355  			LD      (HL),C			; Store the NEW line number in the heap
043646 23          9356  			INC     HL
043647 70          9357  			LD      (HL),B
043648 23          9358  			INC     HL
043649 EB          9359  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
04364A 2B          9360  			DEC     HL			; Back up to the line length byte
04364B 2B          9361  			DEC     HL
04364C 01 00 00 00 9362  			LD	BC, 0
043650 4E          9363  			LD      C,(HL)			; BC: Line length
043651 09          9364  			ADD	HL,BC           	; Advance HL to next line
043652 EB          9365  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
043653 E5          9366  			PUSH    HL
043654 24          9367  			INC     H			; Increment to next page
043655 ED 72       9368  			SBC     HL,SP			; Subtract from SP
043657 E1          9369  			POP     HL
043658 EB          9370  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
043659 38 CD       9371  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
04365B CD 77 37 04 9372  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04365F CC          9373  			DB    	REN
043660 08          9374  			DB    	8
043661 00          9375  			DB    	0
043662             9376  ;
043662             9377  ; At this point a list of BASIC line numbers have been written to the heap
043662             9378  ; as word pairs:
043662             9379  ; - DW: The OLD line number
043662             9380  ; - DW: The NEW line number
043662             9381  ;
043662 EB          9382  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
043663 36 FF       9383  			LD      (HL),-1			; Mark the end with FFFFh
043665 23          9384  			INC     HL
043666 36 FF       9385  			LD      (HL),-1
043668 ED 5B 1A 4D 9386  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
04366D D9          9387  			EXX
04366E 2A 14 4D 04 9388  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
043672 4E          9389  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
043673 79          9390  			LD      A,C			; If it is zero, then no program, so...
043674 B7          9391  			OR      A
043675 CA 7F 30 04 9392  			JP      Z,WARM			; Jump to warm start
043679 D9          9393  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
04367A EB          9394  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
04367B 23          9395  			INC     HL			; Skip to the NEW line number
04367C 23          9396  			INC     HL
04367D 5E          9397  			LD      E,(HL)			; DE: The NEW line number
04367E 23          9398  			INC     HL
04367F 56          9399  			LD      D,(HL)
043680 23          9400  			INC     HL
043681 D5          9401  			PUSH    DE			; Stack the NEW line number
043682 EB          9402  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
043683 22 23 4D 04 9403  			LD      (LINENO),HL		; Store the line number in LINENO
043687 D9          9404  			EXX				; HL: Pointer to the BASIC program area
043688 D1          9405  			POP     DE			; DE: The NEW line number
043689 23          9406  			INC     HL
04368A 73          9407  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
04368B 23          9408  			INC     HL
04368C 72          9409  			LD      (HL),D
04368D 23          9410  			INC     HL
04368E 0D          9411  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
04368F 0D          9412  			DEC     C
043690 0D          9413  			DEC     C
043691 79          9414  			LD	A,C
043692 01 00 00 00 9415  			LD	BC,0
043696 4F          9416  			LD	C,A			; BC: Line length
043697             9417  ;
043697 3E 8D       9418  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
043699 ED B1       9419  			CPIR                    	; Search for the token
04369B 20 D5       9420  			JR      NZ,RENUM3		; If not found, then loop to process the next line
04369D             9421  ;
04369D             9422  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
04369D             9423  ;
04369D C5          9424  			PUSH    BC			; Stack everything
04369E E5          9425  			PUSH    HL
04369F E5          9426  			PUSH    HL			; HL: Pointer to encoded line number
0436A0 FD E1       9427  			POP     IY			; IY: Pointer to encoded line number
0436A2 D9          9428  			EXX
0436A3 CD E6 08 04 9429  			CALL    DECODE			; Decode the encoded line number (in HL')
0436A7 D9          9430  			EXX				; HL: Decoded line number
0436A8 44          9431  			LD      B,H			; BC: Decoded line number
0436A9 4D          9432  			LD      C,L
0436AA 2A 1A 4D 04 9433  			LD      HL,(LOMEM)		; HL: Pointer to heap
0436AE             9434  ;
0436AE             9435  ; This section of code cross-references the decoded (OLD) line number with the list
0436AE             9436  ; created previously in the global heap
0436AE             9437  ;
0436AE 5E          9438  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0436AF 23          9439  			INC     HL
0436B0 56          9440  			LD      D,(HL)
0436B1 23          9441  			INC     HL
0436B2 EB          9442  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0436B3 B7          9443  			OR      A               	; Clear the carry and...
0436B4 52 ED 42    9444  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0436B7 EB          9445  			EX      DE,HL			; HL: Pointer in the global heap
0436B8 5E          9446  			LD      E,(HL)          	; DE: The NEW line number
0436B9 23          9447  			INC     HL
0436BA 56          9448  			LD      D,(HL)
0436BB 23          9449  			INC     HL
0436BC 38 F0       9450  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0436BE EB          9451  			EX      DE,HL			; DE: Pointer in the global heap
0436BF 28 1D       9452  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0436C1             9453  ;
0436C1 CD 90 3D 04 9454  			CALL    TELL			; Display this error if the line number is not found
0436C5 46 61 69 6C 9455  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0436CF 00          9456  			DB    	0
0436D0 2A 23 4D 04 9457  			LD      HL,(LINENO)
0436D4 CD F7 39 04 9458  			CALL    PBCDL
0436D8 CD 47 39 04 9459  			CALL    CRLF
0436DC 18 07       9460  			JR      RENUM6			; And carry on renumbering
0436DE             9461  ;
0436DE             9462  ; This snippet re-encodes the line number in the BASIC program
0436DE             9463  ;
0436DE D1          9464  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0436DF D5          9465  			PUSH    DE
0436E0 1B          9466  			DEC     DE			; Back up a byte to the LINO token
0436E1 CD 5C 3D 04 9467  			CALL    ENCODE          	; Re-write the new line number out
0436E5 E1          9468  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0436E6 C1          9469  			POP     BC			; BC: The remaining line length
0436E7 18 AE       9470  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0436E9             9471  ;
0436E9             9472  ; AUTO
0436E9             9473  ; AUTO start,increment
0436E9             9474  ; AUTO start
0436E9             9475  ; AUTO ,increment
0436E9             9476  ;
0436E9 CD 2B 3C 04 9477  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0436ED 22 29 4D 04 9478  			LD      (AUTONO),HL		; Store the start in AUTONO
0436F1 79          9479  			LD      A,C			; Increment is 8 bit (0-255)
0436F2 32 41 4D 04 9480  			LD      (INCREM),A		; Store that in INCREM
0436F6 18 2E       9481  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0436F8             9482  ;
0436F8             9483  ; BAD
0436F8             9484  ; NEW
0436F8             9485  ;
0436F8 CD 90 3D 04 9486  BAD:			CALL    TELL            	; Output "Bad program" error
0436FC 03          9487  			DB    3				; Token for "BAD"
0436FD 70 72 6F 67 9488  			DB    "program"
       72 61 6D    
043704 0D          9489  			DB    CR
043705 0A          9490  			DB    LF
043706 00          9491  			DB    0				; Falls through to NEW
043707             9492  ;
043707 CD 6C 38 04 9493  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
04370B 18 19       9494  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04370D             9495  ;
04370D             9496  ; OLD
04370D             9497  ;
04370D 2A 14 4D 04 9498  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043711 E5          9499  			PUSH    HL			; Stack it
043712 23          9500  			INC     HL			; Skip the potential length byte of first line of code
043713 23          9501  			INC     HL			; And the line number word
043714 23          9502  			INC     HL
043715 01 FC 00 00 9503  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
043719 3E 0D       9504  			LD      A,CR
04371B ED B1       9505  			CPIR
04371D 20 D9       9506  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04371F 7D          9507  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043720 E1          9508  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043721 77          9509  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043722 CD 3F 38 04 9510  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043726 C3 80 30 04 9511  CLOOP0:			JP      CLOOP			; Jump back to the command loop
04372A             9512  ;
04372A             9513  ; LOAD filename
04372A             9514  ;
04372A CD 15 03 04 9515  LOAD:			CALL    EXPRS           	; Get the filename
04372E 3E 0D       9516  			LD      A,CR			; DE points to the last byte of filename in ACCS
043730 12          9517  			LD      (DE),A			; Terminate filename with a CR
043731 CD 1F 38 04 9518  			CALL    LOAD0			; Load the file in, then CLEAN
043735 CD 76 38 04 9519  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
043739 18 21       9520  			JR      WARM0			; Jump back to the command loop
04373B             9521  ;
04373B             9522  ; SAVE filename
04373B             9523  ;
04373B CD 4B 38 04 9524  SAVE:			CALL    SETTOP          	; Set TOP sysvar
04373F CD 15 03 04 9525  			CALL    EXPRS           	; Get the filename
043743 3E 0D       9526  			LD      A,CR			; Terminate the filename with a CR
043745 12          9527  			LD      (DE),A
043746 ED 5B 14 4D 9528  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
04374B 2A 17 4D 04 9529  			LD      HL,(TOP)		; HL: Top of program memory
04374F B7          9530  			OR      A			; Calculate program size (TOP-PAGE)
043750 ED 52       9531  			SBC     HL,DE
043752 44          9532  			LD      B,H             	; BC: Length of program in bytes
043753 4D          9533  			LD      C,L
043754 21 00 4A 04 9534  			LD      HL,ACCS			; HL: Address of the filename
043758 CD 2D 42 04 9535  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
04375C C3 7F 30 04 9536  WARM0:			JP      WARM			; Jump back to the command loop
043760             9537  
043760             9538  ;
043760             9539  ; ERROR
043760             9540  ; Called whenever BASIC needs to halt with an error
043760             9541  ; Error messages are indexed from 0
043760             9542  ; Inputs:
043760             9543  ;  A: Error number
043760             9544  ;
043760 ED 7B 20 4D 9545  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
043765 21 49 34 04 9546  			LD      HL,ERRWDS		; Index into the error string table
043769 B7          9547  			OR      A			; We don't need to search for the first error
04376A 28 0A       9548  			JR      Z,ERROR1		; So skip the search routine
04376C             9549  ;
04376C             9550  ; Search the error table for error #A
04376C             9551  ; HL will end up being the pointer into the correct error
04376C             9552  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
04376C             9553  ;
04376C 47          9554  			LD      B,A             	; Store error number in B
04376D 08          9555  			EX      AF,AF'			; Store error number in AF'
04376E AF          9556  			XOR     A
04376F BE          9557  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
043770 23          9558  			INC     HL			; Increment the string pointer
043771 20 FC       9559  			JR      NZ,ERROR0		; Loop until with hit a 0
043773 10 FA       9560  			DJNZ    ERROR0			; Decrements the error number and loop until 0
043775 08          9561  			EX      AF,AF'			; Restore the error number from AF'
043776             9562  ;
043776             9563  ; At this point HL points to the tokenised error string
043776             9564  ;
043776 E5          9565  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
043777             9566  
043777             9567  ;
043777             9568  ; EXTERR
043777             9569  ; Inputs:
043777             9570  ;  A: Error number
043777             9571  ;
043777             9572  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
043777             9573  ; The error text immediately follows the CALL to EXTERR, for example:
043777             9574  ; > CALL  EXTERR
043777             9575  ; > DB    "Silly", 0
043777             9576  ; So we can get the address of the string by popping the return address off the stack
043777             9577  ;
043777 E1          9578  EXTERR:			POP     HL			; Pop the error string pointer
043778 22 2F 4D 04 9579  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
04377C ED 7B 20 4D 9580  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
043781 32 3F 4D 04 9581  			LD      (ERR),A			; Store error number in ERR sysvar
043785 CD AE 39 04 9582  			CALL    SETLIN			; Get line number
043789 22 33 4D 04 9583  			LD      (ERL),HL		; Store in ERL sysvar
04378D B7          9584  			OR      A			; Is error number 0?
04378E 28 0D       9585  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
043790             9586  ;
043790 2A 2C 4D 04 9587  			LD      HL,(ERRTRP)		; Check whether the error is trapped
043794 7C          9588  			LD      A,H
043795 B5          9589  			OR      L
043796 E5          9590  			PUSH    HL			; HL: Error line
043797 FD E1       9591  			POP     IY			; IY: HL
043799 C2 96 0B 04 9592  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
04379D             9593  ;
04379D 21 00 00 00 9594  ERROR2:			LD      HL,0
0437A1 22 29 4D 04 9595  			LD      (AUTONO),HL		; Cancel AUTO
0437A5 22 26 4D 04 9596  			LD      (TRACEN),HL     	; Cancel TRACE
0437A9 CD B6 43 04 9597  			CALL    RESET           	; Reset OPSYS
0437AD CD 47 39 04 9598  			CALL    CRLF			; Output newline
0437B1 CD 82 3D 04 9599  			CALL    REPORT          	; Output the error message
0437B5 CD E2 39 04 9600  			CALL    SAYLN			; Output " at line nnnn" message.
0437B9 1E 00       9601  			LD      E,0			; Close all files
0437BB DC 2B 43 04 9602  			CALL    C,OSSHUT
0437BF CD 47 39 04 9603  			CALL    CRLF			; Output newline
0437C3 C3 80 30 04 9604  			JP      CLOOP			; Back to CLOOP
0437C7             9605  ;
0437C7             9606  ; SUBROUTINES:
0437C7             9607  ;
0437C7             9608  ; LEX - SEARCH FOR KEYWORDS
0437C7             9609  ;   Inputs: HL = start of keyword table
0437C7             9610  ;           IY = start of match text
0437C7             9611  ;  Outputs: If found, Z-flag set, A=token.
0437C7             9612  ;           If not found, Z-flag reset, A=(IY).
0437C7             9613  ;           IY updated (if NZ, IY unchanged).
0437C7             9614  ; Destroys: A,B,H,L,IY,F
0437C7             9615  ;
0437C7 21 68 31 04 9616  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0437CB             9617  ;
0437CB FD 7E 00    9618  LEX0:			LD      A,(IY)			; Fetch the character to match
0437CE 46          9619  			LD      B,(HL)			; B: The token from the keywords table
0437CF 23          9620  			INC     HL			; Increment the pointer in the keywords table
0437D0 BE          9621  			CP      (HL)			; Compare the first characters
0437D1 28 08       9622  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0437D3 D8          9623  			RET     C               	; No match, so fail
0437D4             9624  ;
0437D4             9625  ; This snippet of code skips to the next token in the KEYWDS table
0437D4             9626  ;
0437D4 23          9627  LEX1:			INC     HL			; Increment the pointer
0437D5 CB 7E       9628  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0437D7 28 FB       9629  			JR      Z,LEX1			; No, so loop
0437D9 18 F0       9630  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0437DB             9631  ;
0437DB FD E5       9632  LEX2:			PUSH    IY              	; Save the input pointer
0437DD 23          9633  LEX3:			INC     HL			; Increment the keyword pointer
0437DE CB 7E       9634  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0437E0 20 1C       9635  			JR      NZ,LEX6         	; Jump to here as we've found a token
0437E2 FD 23       9636  			INC     IY			; Increment the text pointer
0437E4 FD 7E 00    9637  			LD      A,(IY)			; Fetch the character
0437E7 FE 2E       9638  			CP      '.'			; Is it an abbreviated keyword?
0437E9 28 13       9639  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0437EB BE          9640  			CP      (HL)			; Compare with the keywords list
0437EC 28 EF       9641  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0437EE CD 7B 3C 04 9642  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0437F2 38 04       9643  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0437F4             9644  ;
0437F4 FD E1       9645  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0437F6 18 DC       9646  			JR      LEX1			; And loop back to start again
0437F8             9647  ;
0437F8             9648  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0437F8             9649  ; immediately delimited
0437F8             9650  ;
0437F8 7E          9651  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0437F9 B7          9652  			OR      A			; If it is not zero, then...
0437FA 20 F8       9653  			JR      NZ,LEX4			; Keep searching
0437FC FD 2B       9654  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0437FE             9655  ;
0437FE             9656  ; We've found a token at this point
0437FE             9657  ;
0437FE F1          9658  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0437FF AF          9659  			XOR     A			; Set the Z flag
043800 78          9660  			LD      A,B			; A: The token
043801 C9          9661  			RET
043802             9662  ;
043802             9663  ; DEL - DELETE A PROGRAM LINE.
043802             9664  ;   Inputs: HL addresses program line.
043802             9665  ; Destroys: B,C,F
043802             9666  ;
043802             9667  ; This simply erases the line by moving all of the code after the line to be deleted back over
043802             9668  ; it using an LDIR
043802             9669  ;
043802 D5          9670  DEL:			PUSH    DE
043803 E5          9671  			PUSH    HL
043804 E5          9672  			PUSH    HL			; HL: Address of the program line
043805 06 00       9673  			LD      B,0			; BC: Length of the line
043807 4E          9674  			LD      C,(HL)
043808 09          9675  			ADD     HL,BC			; HL: Advanced to the start of the next line
043809 E5          9676  			PUSH    HL
04380A EB          9677  			EX      DE,HL			; DE: Pointer to the next line
04380B 2A 17 4D 04 9678  			LD      HL,(TOP)		; HL: Pointer to the end of the program
04380F ED 52       9679  			SBC     HL,DE
043811 44          9680  			LD      B,H			; BC: Size of block to move
043812 4D          9681  			LD      C,L
043813 E1          9682  			POP     HL			; HL: Pointer to next line
043814 D1          9683  			POP     DE			; DE: Pointer to this line
043815 ED B0       9684  			LDIR                    	; Delete the line
043817 ED 53 17 4D 9685  			LD      (TOP),DE		; Adjust TOP
       04          
04381C E1          9686  			POP     HL
04381D D1          9687  			POP     DE
04381E C9          9688  			RET
04381F             9689  ;
04381F             9690  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
04381F             9691  ;   Inputs: Filename in ACCS (term CR)
04381F             9692  ; Destroys: A,B,C,D,E,H,L,F
04381F             9693  ;
04381F             9694  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
04381F             9695  ; AND WRITE FF FF, THEN LOAD (TOP).
04381F             9696  ; Destroys: A,B,C,H,L,F
04381F             9697  ;
04381F ED 5B 14 4D 9698  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
043824 21 00 FF FF 9699  			LD      HL,-256
043828 39          9700  			ADD     HL,SP
043829 ED 52       9701  			SBC     HL,DE           	; Find available space
04382B 44          9702  			LD      B,H
04382C 4D          9703  			LD      C,L
04382D 21 00 4A 04 9704  			LD      HL,ACCS
043831 CD 94 41 04 9705  			CALL    OSLOAD          	; Call the OSLOAD function in patch
043835 D4 6C 38 04 9706  			CALL    NC,NEWIT		; If NC then NEW
043839 3E 00       9707  			LD      A,0
04383B D2 60 37 04 9708  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04383F             9709  ;
04383F CD 4B 38 04 9710  CLEAN:			CALL    SETTOP			; Set TOP sysvar
043843 2B          9711  			DEC     HL			; Write out the end of program markers
043844 36 FF       9712  			LD      (HL),-1
043846 2B          9713  			DEC     HL
043847 36 FF       9714  			LD      (HL),-1
043849 18 2B       9715  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
04384B             9716  ;
04384B             9717  ; Set the TOP sysvar; the first free location after the end of the current program
04384B             9718  ; Returns:
04384B             9719  ; - HL: TOP
04384B             9720  ;
04384B 2A 14 4D 04 9721  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04384F 01 00 00 00 9722  			LD	BC, 0			; BC: 0
043853 3E 0D       9723  			LD      A,CR			; End of line marker
043855 4E          9724  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
043856 0C          9725  			INC     C			; Check for zero
043857 0D          9726  			DEC     C
043858 28 0A       9727  			JR      Z,SETOP2		; If it is zero, we've reached the end
04385A 09          9728  			ADD     HL,BC			; Skip to next line
04385B 2B          9729  			DEC     HL			; Check end of previous line
04385C BE          9730  			CP      (HL)
04385D 23          9731  			INC     HL
04385E 28 F5       9732  			JR      Z,SETOP1		; If CR then loop
043860 C3 F8 36 04 9733  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
043864             9734  ;
043864 23          9735  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
043865 23          9736  			INC     HL			; NB: Called from NEWIT
043866 23          9737  			INC     HL
043867 22 17 4D 04 9738  			LD      (TOP),HL		; Store in TOP sysvar
04386B C9          9739  			RET
04386C             9740  ;
04386C             9741  ; NEWIT - NEW PROGRAM THEN CLEAR
04386C             9742  ;   Destroys: H,L
04386C             9743  ;
04386C             9744  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
04386C             9745  ; FUNCTION AND PROCEDURE POINTERS.
04386C             9746  ;   Destroys: Nothing
04386C             9747  ;
04386C 2A 14 4D 04 9748  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
043870 36 00       9749  			LD      (HL),0			; Stick a 0 in there
043872 CD 64 38 04 9750  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
043876             9751  ;
043876 E5          9752  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
043877 2A 17 4D 04 9753  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
04387B 22 1A 4D 04 9754  			LD      (LOMEM),HL		; Set the LOMEM sysvar
04387F 22 1D 4D 04 9755  			LD      (FREE),HL		; And the FREE sysvar with that value
043883 21 6C 4C 04 9756  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
043887 C5          9757  			PUSH    BC
043888             9758  			; LD      B,3*(54+2)		; Loop counter
043888 06 A8       9759  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
04388A 36 00       9760  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
04388C 23          9761  			INC     HL
04388D 10 FB       9762  			DJNZ    CLEAR1
04388F C1          9763  			POP     BC
043890 E1          9764  			POP     HL			; Restore the BASIC program pointer
043891 C9          9765  			RET
043892             9766  ;
043892             9767  ;LISTIT - LIST A PROGRAM LINE.
043892             9768  ;    Inputs: HL addresses line
043892             9769  ;            DE = line number (binary)
043892             9770  ;            IX = Pointer to LISTON
043892             9771  ;             B = FOR/NEXT indent level
043892             9772  ;             C = REPEAT/UNTIL indent level
043892             9773  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
043892             9774  ;
043892 E5          9775  LISTIT:			PUSH    HL			; Stack the address of the line
043893 EB          9776  			EX      DE,HL			; HL: Line number
043894 C5          9777  			PUSH    BC
043895 CD FB 39 04 9778  			CALL    PBCD			; Print the line number
043899 C1          9779  			POP     BC
04389A E1          9780  			POP     HL			; HL: Address of the first token/character
04389B 7E          9781  			LD      A,(HL)			; Fetch the token
04389C FE ED       9782  			CP      NEXT			; Is it NEXT...
04389E CC 28 39 04 9783  			CALL    Z,INDENT		; Yes, so indent in
0438A2 FE FD       9784  			CP      UNTIL			; Or is it UNTIL...
0438A4 CC 28 39 04 9785  			CALL    Z,INDENT		; Yes, so indent in
0438A8 D9          9786  			EXX
0438A9 3E 20       9787  			LD      A,' '
0438AB DD CB 00 46 9788  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0438AF C4 4F 39 04 9789  			CALL    NZ,OUTCHR		; Then print a space after the line number
0438B3 78          9790  			LD      A,B			; Fetch the FOR/NEXT indent level
0438B4 87          9791  			ADD     A,A			; Multiply by 2
0438B5 DD CB 00 4E 9792  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0438B9 C4 EF 17 04 9793  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0438BD 79          9794  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0438BE 87          9795  			ADD     A,A			; Multiply by 2
0438BF DD CB 00 56 9796  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0438C3 C4 EF 17 04 9797  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0438C7 D9          9798  			EXX
0438C8 7E          9799  			LD      A,(HL)			; Fetch the token
0438C9 FE E3       9800  			CP      FOR			; Is it FOR?
0438CB CC 28 39 04 9801  			CALL    Z,INDENT		; Yes, so indent
0438CF FE F5       9802  			CP      REPEAT			; Is it REPEAT?
0438D1 CC 28 39 04 9803  			CALL    Z,INDENT		; Yes, so indent
0438D5 1E 00       9804  			LD      E,0			; E: The quote counter - reset to 0
0438D7 7E          9805  LIST8:			LD      A,(HL)			; Fetch a character / token byte
0438D8 23          9806  			INC     HL
0438D9 FE 0D       9807  			CP      CR			; Is it end of line?
0438DB 28 0B       9808  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0438DD FE 22       9809  			CP      34			; Is it a quote character?
0438DF 20 01       9810  			JR      NZ,LIST7		; No, so skip to next bit
0438E1 1C          9811  			INC     E			; Otherwise increment quote counter
0438E2 CD 17 39 04 9812  LIST7:			CALL    LOUT			; Output the character / token
0438E6 18 EF       9813  			JR      LIST8			; And repeat
0438E8             9814  ;
0438E8             9815  ; DB: Modification for *EDIT
0438E8             9816  ; Terminate the line with either a CRLF or a NUL character
0438E8             9817  ;
0438E8 DD CB 00 5E 9818  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0438EC 28 59       9819  			JR	Z, CRLF			; Yes, so print a CRLF
0438EE AF          9820  			XOR	A			; Otherwise print a NUL (0)
0438EF C3 00 3F 04 9821  			JP	OSWRCH
0438F3             9822  ;
0438F3             9823  ; Decode the 3 byte GOTO type line number
0438F3             9824  ;
0438F3 E5          9825  PRLINO:			PUSH    HL			; Swap HL and IY
0438F4 FD E1       9826  			POP     IY			; IY: Pointer to the line number
0438F6 C5          9827  			PUSH    BC
0438F7 CD E6 08 04 9828  			CALL    DECODE			; Decode
0438FB C1          9829  			POP     BC
0438FC D9          9830  			EXX
0438FD C5          9831  			PUSH    BC
0438FE CD F7 39 04 9832  			CALL    PBCDL			; Output the line number
043902 C1          9833  			POP     BC
043903 D9          9834  			EXX
043904 FD E5       9835  			PUSH    IY			; Swap HL and IY
043906 E1          9836  			POP     HL			; HL: Pointer to the next character in the line
043907 C9          9837  			RET
043908             9838  ;
043908             9839  ; DB: Modification for internationalisation
043908             9840  ;
043908 CD 6C 39 04 9841  PRREM:			CALL	OUT_			; Output the REM token
04390C 7E          9842  @@:			LD	A, (HL)			; Fetch the character
04390D FE 0D       9843  			CP	CR			; If it is end of line, then
04390F C8          9844  			RET	Z			; we have finished
043910 CD 4F 39 04 9845  			CALL	OUTCHR			; Ouput the character
043914 23          9846  			INC	HL
043915 18 F5       9847  			JR	@B			; And loop
043917             9848  ;
043917             9849  ; DB: End of modification
043917             9850  ;
043917 CB 43       9851  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
043919 20 34       9852  			JR      NZ,OUTCHR		; don't tokenise, just output the character
04391B FE F4       9853  			CP	REM			; DB: Is it REM
04391D 28 E9       9854  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
04391F FE 8D       9855  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
043921 28 D0       9856  			JR      Z,PRLINO		; Yes, so decode and print the line number
043923 CD 6C 39 04 9857  			CALL    OUT_			; Output a character / keyword
043927 7E          9858  			LD      A,(HL)			; Fetch the next character
043928             9859  ;
043928             9860  ; This block of code handles the indentation
043928             9861  ; B: Counter for FOR/NEXT indent
043928             9862  ; C: Counter for REPEAT/UNTIL indent
043928             9863  ;
043928 D9          9864  INDENT:			EXX
043929 FE E3       9865  			CP      FOR			; If the token is FOR
04392B 28 09       9866  			JR      Z,IND1			; Then INC B
04392D FE ED       9867  			CP      NEXT			; If it is NEXT
04392F 20 06       9868  			JR      NZ,IND2_		; Then...
043931 05          9869  			DEC     B			; DEC B
043932 F2 37 39 04 9870  			JP      P,IND2_			; If we have gone below 0 then
043936 04          9871  IND1:			INC     B			; Increment back to 0
043937             9872  ;
043937 FE F5       9873  IND2_:			CP      REPEAT			; If the token is REPEAT
043939 28 09       9874  			JR      Z,IND3			; Then INC C
04393B FE FD       9875  			CP      UNTIL			; If it is UNTIL
04393D 20 06       9876  			JR      NZ,IND4			; Then...
04393F 0D          9877  			DEC     C			; DEC C
043940 F2 45 39 04 9878  			JP      P,IND4			; If we have gone below 0 then
043944 0C          9879  IND3:			INC     C			; Incremet back to 0
043945 D9          9880  IND4:			EXX
043946 C9          9881  			RET
043947             9882  ;
043947             9883  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
043947             9884  ;  Destroys: A,F
043947             9885  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
043947             9886  ;    Inputs: A = character
043947             9887  ;  Destroys: A,F
043947             9888  ;
043947 3E 0D       9889  CRLF:			LD      A,CR			; Output CR
043949 CD 4F 39 04 9890  			CALL    OUTCHR
04394D 3E 0A       9891  			LD      A,LF			; Output LF
04394F             9892  ;
04394F CD 00 3F 04 9893  OUTCHR:			CALL    OSWRCH			; Output the character in A
043953 D6 0D       9894  			SUB     CR			; Check for CR
043955 28 06       9895  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
043957 D8          9896  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
043958 3A 3D 4D 04 9897  			LD      A,(COUNT)		; Increment the count
04395C 3C          9898  			INC     A
04395D             9899  ;
04395D 32 3D 4D 04 9900  CARRET:			LD      (COUNT),A		; Store the new count value
043961 C8          9901  			RET     Z			; Return if the count has wrapped to 0
043962 E5          9902  			PUSH    HL			; Now check if count = print width
043963 2A 3E 4D 04 9903  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
043967 BD          9904  			CP      L			; L is the width. Compare it with count.
043968 E1          9905  			POP     HL
043969 C0          9906  			RET     NZ			; If we've not hit print width, then just return
04396A 18 DB       9907  			JR      CRLF			; Otherwise output CRLF
04396C             9908  ;
04396C             9909  ; OUT - SEND CHARACTER OR KEYWORD
04396C             9910  ;   Inputs: A = character (>=10, <128)
04396C             9911  ;           A = Token (<10, >=128)
04396C             9912  ;  Destroys: A,F
04396C             9913  ;
04396C FE 8A       9914  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04396E EA 4F 39 04 9915  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
043972             9916  ;
043972             9917  ; This bit looks up the character in the KEYWDS token table and expands it
043972             9918  ; Note the CP 138; this sets the overflow flag as follows:
043972             9919  ;
043972             9920  ; NB:
043972             9921  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
043972             9922  ;  2. CP is effectively a SUB; sets the flags without affecting A
043972             9923  ;  3. The operation n - -118 ~ n + 118
043972             9924  ;
043972             9925  ; So:
043972             9926  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
043972             9927  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
043972             9928  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
043972             9929  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
043972             9930  ;
043972 C5          9931  			PUSH    BC			; Preserve BC and HL
043973 E5          9932  			PUSH    HL
043974 21 68 31 04 9933  			LD      HL,KEYWDS		; The list of tokens and keywords
043978 01 DF 02 00 9934  			LD      BC,KEYWDL		; The length of the keyword list
04397C ED B1       9935  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
04397E             9936  ;							; At this point HL points to the next byte, the first character of the token
04397E 7E          9937  TOKEN1:			LD      A,(HL)			; Fetch the character
04397F 23          9938  			INC     HL			; Increment to the next byte in the token table
043980 FE 8A       9939  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
043982 F5          9940  			PUSH    AF			; Then...
043983 EC 4F 39 04 9941  			CALL    PE,OUTCHR		; Output the character...
043987 F1          9942  			POP     AF			;
043988 EA 7E 39 04 9943  			JP      PE,TOKEN1		; And loop to the next character
04398C E1          9944  			POP     HL			; Done, so tidy up the stack and exit
04398D C1          9945  			POP     BC
04398E C9          9946  			RET
04398F             9947  ;
04398F             9948  ; FINDL - FIND PROGRAM LINE
04398F             9949  ;   Inputs: HL = line number (binary)
04398F             9950  ;  Outputs: HL addresses line (if found)
04398F             9951  ;           DE = line number
04398F             9952  ;           Z-flag set if found.
04398F             9953  ; Destroys: A,B,C,D,E,H,L,F
04398F             9954  ;
04398F EB          9955  FINDL:			EX      DE,HL			; DE: Line number (binary)
043990 2A 14 4D 04 9956  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
043994 AF          9957  			XOR     A               	;  A: 0
043995 BE          9958  			CP      (HL)			; Check for end of program marker
043996 3C          9959  			INC     A			;  A: 1
043997 D0          9960  			RET     NC			; Return with 1 if 0
043998 AF          9961  			XOR     A               	; Clear the carry flag
043999             9962  ;			LD      B,A			;  B: 0
043999 01 00 00 00 9963  			LD	BC, 0			; BC: 0
04399D             9964  ;
04399D 4E          9965  FINDL1:			LD      C,(HL)			;  C: The line length
04399E E5          9966  			PUSH    HL			; Stack the current program counter
04399F 23          9967  			INC     HL			; Skip to the line number bytes
0439A0 7E          9968  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439A1 23          9969  			INC     HL
0439A2 66          9970  			LD      H,(HL)
0439A3 6F          9971  			LD      L,A
0439A4 52 ED 52    9972  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439A7 E1          9973  			POP     HL			; Get the current program counter
0439A8 D0          9974  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439A9 09          9975  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0439AA C3 9D 39 04 9976  			JP      FINDL1			; And loop
0439AE             9977  ;
0439AE             9978  ; SETLIN - Search program for line containing address
0439AE             9979  ;          Update (LINENO)
0439AE             9980  ;   Inputs: Address in (ERRLIN)
0439AE             9981  ;  Outputs: Line number in HL and (LINENO)
0439AE             9982  ; Destroys: B,C,D,E,H,L,F
0439AE             9983  ;
0439AE 01 00 00 00 9984  SETLIN:			LD	BC, 0			; Zero BC for later
0439B2             9985  ;			LD      B, 0			; Zero B for later
0439B2 ED 5B 35 4D 9986  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
0439B7 2A 14 4D 04 9987  			LD      HL, (PAGE_)		; HL: Start of user program area
0439BB B7          9988  			OR      A			; Do a 24 bit compare without destroying HL
0439BC ED 52       9989  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0439BE 19          9990  			ADD     HL, DE			;  C: DE > HL
0439BF 30 1B       9991  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0439C1             9992  ;
0439C1 4E          9993  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0439C2 0C          9994  			INC     C			; This is a way to check for zero without using the accumulator
0439C3 0D          9995  			DEC     C			; If it is zero, then...
0439C4 28 16       9996  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0439C6 09          9997  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0439C7 ED 52       9998  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0439C9 19          9999  			ADD     HL, DE
0439CA 38 F5       10000  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0439CC ED 42       10001  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0439CE 23          10002  			INC     HL			; Skip the length counter
0439CF 11 00 00 00 10003  			LD	DE, 0			; Zero DE
0439D3 5E          10004  			LD      E, (HL)          	; Fetch the line number
0439D4 23          10005  			INC     HL
0439D5 56          10006  			LD      D, (HL)
0439D6 EB          10007  			EX      DE, HL			; HL: The line number
0439D7 22 23 4D 04 10008  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0439DB C9          10009  			RET
0439DC             10010  ;
0439DC 21 00 00 00 10011  SET3:			LD      HL, 0			; We've not found the line at this point so
0439E0 18 F5       10012  			JR      SET2			; Set LINENO to 0
0439E2             10013  ;
0439E2             10014  ;SAYLN - PRINT " at line nnnn" MESSAGE.
0439E2             10015  ;  Outputs: Carry=0 if line number is zero.
0439E2             10016  ;           Carry=1 if line number is non-zero.
0439E2             10017  ; Destroys: A,B,C,D,E,H,L,F
0439E2             10018  ;
0439E2 2A 23 4D 04 10019  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0439E6 7C          10020  			LD      A,H			; If it is zero then
0439E7 B5          10021  			OR      L
0439E8 C8          10022  			RET     Z			; Don't need to do anything; return with F:C set to 0
0439E9 CD 90 3D 04 10023  			CALL    TELL			; Output the error message
0439ED 20 61 74 20 10024  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
0439F7 0E 00       10025  PBCDL:			LD      C,0			; C: Leading character (NUL)
0439F9 18 02       10026  			JR      PBCD0			; Output the line number; return with F:C set to 1
0439FB             10027  ;
0439FB             10028  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
0439FB             10029  ;   Inputs: HL = number (binary).
0439FB             10030  ;  Outputs: Carry = 1
0439FB             10031  ; Destroys: A,B,C,D,E,H,L,F
0439FB             10032  ;
0439FB 0E 20       10033  PBCD:			LD      C,' '			; C: Leading character (" ")
0439FD 06 05       10034  PBCD0:			LD      B,5			; Number of digits in result
0439FF 11 10 27 00 10035  			LD      DE,10000		; Start off with the 10,000 column
043A03 AF          10036  PBCD1:			XOR     A			; Counter
043A04 ED 52       10037  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A06 3C          10038  			INC     A
043A07 30 FB       10039  			JR      NC,PBCD2
043A09 19          10040  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A0A 3D          10041  			DEC     A			; A: Number of 10,000s
043A0B 28 04       10042  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A0D CB E1       10043  			SET     4,C			; C: Set to '0' ASCII (30h)
043A0F CB E9       10044  			SET     5,C
043A11 B1          10045  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A12 C4 4F 39 04 10046  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A16 78          10047  			LD      A,B			; If on first transition, skip this
043A17 FE 05       10048  			CP      5			; TODO: Need to find out why
043A19 28 06       10049  			JR      Z,PBCD4
043A1B 29          10050  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A1C 54          10051  			LD      D,H			;         : rather than shifting DE right
043A1D 5D          10052  			LD      E,L			;         : This makes a lot of sense
043A1E 29          10053  			ADD     HL,HL			; HL x  4
043A1F 29          10054  			ADD     HL,HL			; HL x  8
043A20 19          10055  			ADD     HL,DE			; HL x 10
043A21 11 E8 03 00 10056  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A25 10 DC       10057  			DJNZ    PBCD1			; Loop until done
043A27 37          10058  			SCF				; SCF set for SAYLN in this module
043A28 C9          10059  			RET
043A29             10060  ;
043A29             10061  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A29             10062  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A29             10063  ;  Outputs: As GETVAR.
043A29             10064  ; Destroys: everything
043A29             10065  ;
043A29 CD AE 3B 04 10066  PUTVAR:			CALL    CREATE			; Create the variable
043A2D FD 7E 00    10067  			LD      A,(IY)			; Fetch the next character
043A30 FE 28       10068  			CP      '('			; Check for bad use of array
043A32 20 70       10069  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A34 3E 0E       10070  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A36 C3 60 37 04 10071  ERROR3:			JP      ERROR_
043A3A             10072  ;
043A3A             10073  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A3A             10074  ;   Inputs: IY addresses first character.
043A3A             10075  ;  Outputs: Carry set and NZ if illegal character.
043A3A             10076  ;           Z-flag set if variable found, then:
043A3A             10077  ;            A = variable type (0,4,5,128 or 129)
043A3A             10078  ;            HL = IX = variable pointer.
043A3A             10079  ;            IY updated
043A3A             10080  ;           If Z-flag & carry reset, then:
043A3A             10081  ;            HL, IY set for subsequent PUTVAR call.
043A3A             10082  ; Destroys: everything
043A3A             10083  ;
043A3A FD 7E 00    10084  GETVAR:			LD      A,(IY)			; Get the first character
043A3D FE 24       10085  			CP      '$'			; Is it a string?
043A3F 28 69       10086  			JR      Z,GETV4			; Yes, so branch here
043A41 FE 21       10087  			CP      '!'			; Is it indirection (32-bit)?
043A43 28 69       10088  			JR      Z,GETV5			; Yes, so branch here
043A45 FE 3F       10089  			CP      '?'			; Is it indirection (8-bit)?
043A47 28 69       10090  			JR      Z,GETV6			; Yes, so branch here
043A49             10091  ;
043A49 CD 18 3B 04 10092  			CALL    LOCATE			; Locate the variable
043A4D C0          10093  			RET     NZ			; And exit here if not found
043A4E             10094  ;
043A4E             10095  ; At this point:
043A4E             10096  ;  HL: Address of variable in memory
043A4E             10097  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043A4E             10098  ;
043A4E FD 7E 00    10099  			LD      A,(IY)			; Further checks
043A51 FE 28       10100  			CP      '('             	; Is it an array?
043A53 20 47       10101  			JR      NZ,GETVX        	; No, so exit
043A55             10102  ;
043A55             10103  ; We are processing an array at this point
043A55             10104  ;
043A55 D5          10105  			PUSH    DE              	; Save the variable type (in D)
043A56 7E          10106  			LD      A,(HL)          	; Fetch the number of dimensions
043A57 B7          10107  			OR      A
043A58 28 DA       10108  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043A5A 23          10109  			INC     HL			;
043A5B 11 00 00 00 10110  			LD      DE,0            	; Accumulator
043A5F F5          10111  			PUSH    AF
043A60 FD 23       10112  			INC     IY              	; Skip "("
043A62 18 05       10113  			JR      GETV3
043A64             10114  ;
043A64 F5          10115  GETV2:			PUSH    AF
043A65 CD 22 0A 04 10116  			CALL    COMMA
043A69 E5          10117  GETV3:			PUSH    HL
043A6A D5          10118  			PUSH    DE
043A6B CD 0A 03 04 10119  			CALL    EXPRI			; Get the subscript
043A6F D9          10120  			EXX
043A70 D1          10121  			POP     DE
043A71 E3          10122  			EX      (SP),HL
043A72 4E          10123  			LD      C,(HL)
043A73 23          10124  			INC     HL
043A74 46          10125  			LD      B,(HL)
043A75 23          10126  			INC     HL
043A76 E3          10127  			EX      (SP),HL
043A77 EB          10128  			EX      DE,HL
043A78 D5          10129  			PUSH    DE
043A79 CD 72 18 04 10130  			CALL    MUL16			; HL=HL*BC
043A7D D1          10131  			POP     DE
043A7E 19          10132  			ADD     HL,DE
043A7F EB          10133  			EX      DE,HL
043A80 B7          10134  			OR      A
043A81 ED 42       10135  			SBC     HL,BC
043A83 3E 0F       10136  			LD      A,15
043A85 30 AF       10137  			JR      NC,ERROR3		; Throw a "Subscript" error
043A87 E1          10138  			POP     HL
043A88 F1          10139  			POP     AF
043A89 3D          10140  			DEC     A               	; Dimension counter
043A8A 20 D8       10141  			JR      NZ,GETV2
043A8C CD 2F 0A 04 10142  			CALL    BRAKET          	; Check for closing bracket
043A90 F1          10143  			POP     AF              	; Restore the type
043A91 E5          10144  			PUSH    HL
043A92 CD 65 18 04 10145  			CALL    X4OR5           	; DE=DE*n
043A96 E1          10146  			POP     HL
043A97 19          10147  			ADD     HL,DE
043A98 57          10148  			LD      D,A             	; The type
043A99 FD 7E 00    10149  			LD      A,(IY)
043A9C FE 3F       10150  GETVX:			CP      '?'
043A9E 28 1E       10151  			JR      Z,GETV9
043AA0 FE 21       10152  			CP      '!'
043AA2 28 16       10153  			JR      Z,GETV8
043AA4 E5          10154  GETVZ:			PUSH    HL              	; Set exit conditions
043AA5 DD E1       10155  			POP     IX
043AA7 7A          10156  			LD      A,D
043AA8 BF          10157  			CP      A
043AA9 C9          10158  			RET
043AAA             10159  ;
043AAA             10160  ; Process strings, unary & binary indirection:
043AAA             10161  ;
043AAA 3E 80       10162  GETV4:			LD      A,128           	; Static strings
043AAC 18 05       10163  			JR      GETV7
043AAE             10164  ;
043AAE 3E 04       10165  GETV5:			LD      A,4             	; Unary 32-bit indirection
043AB0 18 01       10166  			JR      GETV7
043AB2             10167  ;
043AB2 AF          10168  GETV6:			XOR     A               	; Unary 8-bit indirection
043AB3             10169  ;
043AB3 21 00 00 00 10170  GETV7:			LD      HL,0
043AB7 F5          10171  			PUSH    AF
043AB8 18 24       10172  			JR      GETV0
043ABA             10173  ;
043ABA 06 04       10174  GETV8:			LD      B,4             	; Binary 32-bt indirection
043ABC 18 02       10175  			JR      GETVA
043ABE             10176  ;
043ABE 06 00       10177  GETV9:			LD      B,0             	; Binary 8-bit indirection
043AC0             10178  ;
043AC0 E5          10179  GETVA:			PUSH    HL
043AC1 DD E1       10180  			POP     IX
043AC3 7A          10181  			LD      A,D            		; Fetch the variable type
043AC4 FE 81       10182  			CP      129			; Is it a string?
043AC6 C8          10183  			RET     Z               	; Yes, so exit here
043AC7 C5          10184  			PUSH    BC
043AC8 CD 16 04 04 10185  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043ACC CD 62 06 04 10186  			CALL    SFIX
043AD0 7D          10187  			LD	A,L
043AD1 D9          10188  			EXX
043AD2 22 4A 4D 04 10189  			LD	(R0+0),HL
043AD6 32 4C 4D 04 10190  			LD	(R0+2),A
043ADA 2A 4A 4D 04 10191  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043ADE             10192  ;
043ADE E5          10193  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043ADF FD 23       10194  			INC     IY
043AE1 CD 25 03 04 10195  			CALL    ITEMI
043AE5 7D          10196  			LD	A,L			;  A: The MSB of the address
043AE6 D9          10197  			EXX
043AE7 22 4A 4D 04 10198  			LD	(R0+0),HL		; HL: The LSW of the address
043AEB 32 4C 4D 04 10199  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043AEF D1          10200  			POP     DE
043AF0 F1          10201  			POP     AF
043AF1 2A 4A 4D 04 10202  			LD	HL,(R0)			; HL: L'HL
043AF5 19          10203  			ADD     HL,DE
043AF6 E5          10204  			PUSH    HL
043AF7 DD E1       10205  			POP     IX
043AF9 BF          10206  			CP      A
043AFA C9          10207  			RET
043AFB             10208  ;
043AFB             10209  ;GETDEF - Find entry for FN or PROC in dynamic area.
043AFB             10210  ;   Inputs: IY addresses byte following "DEF" token.
043AFB             10211  ;  Outputs: Z flag set if found
043AFB             10212  ;           Carry set if neither FN or PROC first.
043AFB             10213  ;           If Z: HL points to entry
043AFB             10214  ;                 IY addresses delimiter
043AFB             10215  ; Destroys: A,D,E,H,L,IY,F
043AFB             10216  ;
043AFB FD 7E 01    10217  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043AFE CD 7B 3C 04 10218  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B02 D8          10219  			RET     C			; No so return with C set
043B03 FD 7E 00    10220  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B06 21 0E 4D 04 10221  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B0A FE A4       10222  			CP      FN			; Is it the token FN?
043B0C 28 4A       10223  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B0E 21 11 4D 04 10224  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B12 FE F2       10225  			CP      PROC			; Is it the token PROC?
043B14 28 42       10226  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B16 37          10227  			SCF				; No, so just return with C set
043B17 C9          10228  			RET
043B18             10229  ;
043B18             10230  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B18             10231  ; If illegal first character return carry, non-zero.
043B18             10232  ; If found, return no-carry, zero.
043B18             10233  ; If not found, return no-carry, non-zero.
043B18             10234  ;   Inputs: IY=Addresses first character of name.
043B18             10235  ;            A=(IY)
043B18             10236  ;  Outputs:  F=Z set if found, then:
043B18             10237  ;           IY=addresses terminator
043B18             10238  ;           HL=addresses location of variable
043B18             10239  ;            D=type of variable: 4 = integer
043B18             10240  ;                                5 = floating point
043B18             10241  ;                              129 = string
043B18             10242  ; Destroys: A,D,E,H,L,IY,F
043B18             10243  ;
043B18             10244  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B18             10245  ; They can contain any alphanumeric character and underscore (_)
043B18             10246  ; String variables are postfixed with the dollar ($) character
043B18             10247  ; Integer variables are postfixed with the percent (%) character
043B18             10248  ; Static integer variables are named @%, A% to Z%
043B18             10249  ; All other variables are dynamic
043B18             10250  ;
043B18 D6 40       10251  LOCATE:			SUB     '@'			; Check for valid range
043B1A D8          10252  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B1B 21 00 00 00 10253  			LD      HL, 0			; Clear HL
043B1F FE 1B       10254  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B21 30 1E       10255  			JR      NC,LOC0         	; Then branch here
043B23 6F          10256  			LD	L, A			; HL = A
043B24 FD 7E 01    10257  			LD      A,(IY+1)        	; Check the 2nd character
043B27 FE 25       10258  			CP      '%'			; If not "%" then it is not static...
043B29 20 21       10259  			JR      NZ,LOC1         	; Branch here
043B2B FD 7E 02    10260  			LD      A,(IY+2)		; Check the 3rd character
043B2E FE 28       10261  			CP      '('			; If it is "(" (array) then it is not static...
043B30 28 1A       10262  			JR      Z,LOC1          	; Branch here
043B32             10263  ;
043B32             10264  ; At this point we're dealing with a static variable
043B32             10265  ;
043B32 29          10266  			ADD     HL,HL			; HL: Variable index * 4
043B33 29          10267  			ADD	HL,HL
043B34 11 00 4C 04 10268  			LD      DE,STAVAR       	; The static variable area in memory
043B38 19          10269  			ADD     HL,DE			; HL: The address of the static variable
043B39 FD 23       10270  			INC     IY			; Skip the program pointer past the static variable name
043B3B FD 23       10271  			INC     IY
043B3D 16 04       10272  			LD      D,4             	; Set the type to be integer
043B3F AF          10273  			XOR     A			; Set the Z flag
043B40 C9          10274  			RET
043B41             10275  ;
043B41             10276  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B41             10277  ;
043B41 FE 1F       10278  LOC0:			CP      '_'-'@'			; Check the first character is in
043B43 D8          10279  			RET     C			; the range "_" to
043B44 FE 3B       10280  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B46 3F          10281  			CCF				; If it is not in range then
043B47 3D          10282  			DEC     A               	; Set NZ flag and
043B48 D8          10283  			RET     C			; Exit here
043B49 D6 03       10284  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043B4B 6F          10285  			LD	L, A			; HL = A
043B4C             10286  ;
043B4C             10287  ; Yes, it's definitely a dynamic variable at this point...
043B4C             10288  ;
043B4C 7D          10289  LOC1:			LD	A, L			; Fetch variable index
043B4D 87          10290  			ADD	A, A			; x 2
043B4E 85          10291  			ADD	A, L			; x 3
043B4F D6 03       10292  			SUB	3			; Subtract 2 TODO: Should be 3
043B51 6F          10293  			LD	L, A
043B52 11 6C 4C 04 10294  			LD      DE, DYNVAR       	; The dynamic variable storage
043B56 D8          10295  			RET	C			; Bounds check to trap for variable '@'
043B57 19          10296  			ADD     HL, DE			; HL: Address of first entry
043B58             10297  ;
043B58             10298  ; Loop through the linked list of variables to find a match
043B58             10299  ;
043B58 ED 17       10300  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043B5A E5          10301  			PUSH	HL			; Need to preserve HL for LOC6
043B5B AF          10302  			XOR	A			; Reset carry flag
043B5C ED 62       10303  			SBC	HL, HL			; Set HL to 0
043B5E ED 52       10304  			SBC	HL, DE			; Compare with 0
043B60 E1          10305  			POP	HL			; Restore the original pointer
043B61 28 49       10306  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043B63             10307  			; LD	HL, DE			; Make a copy of this pointer in HL
043B63 D5          10308  			push de
043B64 E1          10309  			pop hl ; how was that even possible?
043B65 23          10310  			INC     HL              	; Skip the link (24-bits)
043B66 23          10311  			INC     HL
043B67 23          10312  			INC	HL			; HL: Address of the variable name in DYNVARS
043B68 FD E5       10313  			PUSH    IY			; IY: Address of the variable name in the program
043B6A             10314  ;
043B6A 7E          10315  LOC3:			LD      A,(HL)         		; Compare
043B6B 23          10316  			INC     HL
043B6C FD 23       10317  			INC     IY
043B6E FD BE 00    10318  			CP      (IY)
043B71 28 F7       10319  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043B73 B7          10320  			OR      A               	; Have we hit a terminator?
043B74 28 07       10321  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043B76             10322  ;
043B76 FD E1       10323  LOC4:			POP     IY			; Restore the pointer in the program
043B78 EB          10324  			EX      DE, HL			; HL: New pointer in DYNVARS
043B79 C3 58 3B 04 10325  			JP      LOC2            	; Loop round and try again
043B7D             10326  ;
043B7D             10327  ; We might have located a variable at this point, just need to do a few more tests
043B7D             10328  ;
043B7D FD 2B       10329  LOC5:			DEC     IY
043B7F FD 7E 00    10330  			LD      A,(IY)
043B82 FE 28       10331  			CP      '('
043B84 28 15       10332  			JR      Z,LOC5A         	; FOUND
043B86 FD 23       10333  			INC     IY
043B88 CD 6F 3C 04 10334  			CALL    RANGE
043B8C 38 0D       10335  			JR      C,LOC5A         	; FOUND
043B8E FE 28       10336  			CP      '('
043B90 28 E4       10337  			JR      Z,LOC4          	; KEEP LOOKING
043B92 FD 7E FF    10338  			LD      A,(IY-1)
043B95 CD 7B 3C 04 10339  			CALL    RANGE1
043B99 30 DB       10340  			JR      NC,LOC4         	; KEEP LOOKING
043B9B D1          10341  LOC5A:			POP     DE
043B9C FD 7E FF    10342  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043B9F FE 24       10343  			CP      '$'			; Is it a string?
043BA1 16 81       10344  			LD      D,129			; Yes, so return D = 129
043BA3 C8          10345  			RET     Z
043BA4 FE 25       10346  			CP      '%'			; Is it an integer?
043BA6 16 04       10347  			LD      D,4			; Yes, so return D = 4
043BA8 C8          10348  			RET     Z
043BA9 14          10349  			INC     D			; At this point it must be a float
043BAA BF          10350  			CP      A			; Set the flags
043BAB C9          10351  			RET
043BAC             10352  ;
043BAC             10353  ; The variable is undefined at this point; HL will be zero
043BAC             10354  ;
043BAC 3C          10355  LOC6:			INC     A               	; Set NZ flag
043BAD C9          10356  			RET
043BAE             10357  ;
043BAE             10358  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043BAE             10359  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043BAE             10360  ;  Outputs: As LOCATE, GETDEF.
043BAE             10361  ; Destroys: As LOCATE, GETDEF.
043BAE             10362  ;
043BAE AF          10363  CREATE:			XOR     A
043BAF ED 5B 1D 4D 10364  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043BB4 ED 1F       10365  			LD	(HL), DE		; Store
043BB6 EB          10366  			EX      DE,HL
043BB7 77          10367  			LD      (HL),A			; Clear the link of the new entity
043BB8 23          10368  			INC     HL
043BB9 77          10369  			LD      (HL),A
043BBA 23          10370  			INC     HL
043BBB 77          10371  			LD      (HL),A
043BBC 23          10372  			INC     HL
043BBD FD 23       10373  LOC7:			INC     IY
043BBF CD 6F 3C 04 10374  			CALL    RANGE           	; END OF VARIABLE?
043BC3 38 15       10375  			JR      C,LOC8
043BC5 77          10376  			LD      (HL),A
043BC6 23          10377  			INC     HL
043BC7 CD 7B 3C 04 10378  			CALL    RANGE1
043BCB 30 F0       10379  			JR      NC,LOC7
043BCD FE 28       10380  			CP      '('
043BCF 28 09       10381  			JR      Z,LOC8
043BD1 FD 7E 01    10382  			LD      A,(IY+1)
043BD4 FE 28       10383  			CP      '('
043BD6 28 E5       10384  			JR      Z,LOC7
043BD8 FD 23       10385  			INC     IY
043BDA 36 00       10386  LOC8:			LD      (HL),0          	; TERMINATOR
043BDC 23          10387  			INC     HL
043BDD E5          10388  			PUSH    HL
043BDE CD 9C 3B 04 10389  			CALL    TYPE_			; Get the variable type in D
043BE2 3E 04       10390  			LD      A,4			; If it is an integer then it takes up 4 bytes
043BE4 BA          10391  			CP      D
043BE5 28 01       10392  			JR      Z,LOC9			; So skip the next bit
043BE7 3C          10393  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043BE8 36 00       10394  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043BEA 23          10395  			INC     HL
043BEB 3D          10396  			DEC     A
043BEC 20 FA       10397  			JR      NZ,LOC9
043BEE 22 1D 4D 04 10398  			LD      (FREE),HL		; Adjust the stack
043BF2 CD 4F 16 04 10399  			CALL    CHECK			; Check whether we are out of space
043BF6 E1          10400  			POP     HL
043BF7 AF          10401  			XOR     A
043BF8 C9          10402  			RET
043BF9             10403  ;
043BF9             10404  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043BF9             10405  ;   Inputs: IY = Text Pointer
043BF9             10406  ;  Outputs: HL = Line number (zero if none)
043BF9             10407  ;           IY updated
043BF9             10408  ; Destroys: A,D,E,H,L,IY,F
043BF9             10409  ;
043BF9             10410  ; This bit of code performs a BASE 10 shift to build up the number
043BF9             10411  ; So if the string passed is "345", the algorithm does this:
043BF9             10412  ;
043BF9             10413  ;    HL : Digit	: Operation
043BF9             10414  ; ----- : ----- : ---------
043BF9             10415  ; 00000 :	:
043BF9             10416  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043BF9             10417  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043BF9             10418  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043BF9             10419  ;
043BF9             10420  ; The multiply by 10 is done by an unrolled shift and add loop
043BF9             10421  ;
043BF9 CD 70 0A 04 10422  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043BFD 40 21 00 00 10423  			LD.SIS  HL,0			; The running total
043C01 FD 7E 00    10424  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C04 D6 30       10425  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C06 D8          10426  			RET     C			; And return if less than 0
043C07 FE 0A       10427  			CP      10			; Or greater than or equal to 10
043C09 D0          10428  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C0A FD 23       10429  			INC     IY			; Increment the string pointer
043C0C 54          10430  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C0D 5D          10431  			LD      E,L			; Store the original number in DE
043C0E 52 29       10432  			ADD.S   HL,HL           	; *2
043C10 38 13       10433  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C12 52 29       10434  			ADD.S   HL,HL           	; *4S
043C14 38 0F       10435  			JR      C,TOOBIG
043C16 52 19       10436  			ADD.S   HL,DE           	; *5
043C18 38 0B       10437  			JR      C,TOOBIG
043C1A 52 29       10438  			ADD.S   HL,HL           	; *10
043C1C 38 07       10439  			JR      C,TOOBIG
043C1E 5F          10440  			LD      E,A			; A->DE: the digit to add in
043C1F 16 00       10441  			LD      D,0
043C21 52 19       10442  			ADD.S   HL,DE           	; Add in the digit to the running total
043C23 30 DC       10443  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C25             10444  ;
043C25 3E 14       10445  TOOBIG:			LD      A,20
043C27 C3 60 37 04 10446  			JP      ERROR_           	; Error: "Too big"
043C2B             10447  ;
043C2B             10448  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C2B             10449  ;   Inputs: IY = text pointer
043C2B             10450  ;  Outputs: HL = first number (10 by default)
043C2B             10451  ;           BC = second number (10 by default)
043C2B             10452  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C2B             10453  ;
043C2B CD F9 3B 04 10454  PAIR:			CALL    LINNUM          	; Parse the first line number
043C2F 7C          10455  			LD      A,H			; If it is not zero, then...
043C30 B5          10456  			OR      L
043C31 20 02       10457  			JR      NZ,PAIR1		; Skip...
043C33 2E 0A       10458  			LD      L,10			; HL: the default value (10)
043C35             10459  ;
043C35 CD 7A 17 04 10460  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C39 FD 23       10461  			INC     IY			; Skip to next character
043C3B E5          10462  			PUSH    HL			; Stack the first line number
043C3C 21 0A 00 00 10463  			LD      HL,10			; HL: the second default (10)
043C40 C4 F9 3B 04 10464  			CALL    NZ,LINNUM       	; Parse the second line number
043C44 E3          10465  			EX      (SP),HL			; HL: The first line number (off the stack)
043C45 C1          10466  			POP     BC			; BC: Second line number
043C46 78          10467  			LD      A,B			; If the second line number is not zero then...
043C47 B1          10468  			OR      C			; We're good...
043C48 C0          10469  			RET     NZ			; Exit, otherwise...
043C49 CD 77 37 04 10470  			CALL    EXTERR			; Throw error: "Silly"
043C4D 53 69 6C 6C 10471  			DB    	"Silly", 0
       79 00       
043C53             10472  ;
043C53             10473  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043C53             10474  ;   Inputs: IY = text pointer
043C53             10475  ;  Outputs: HL = points to program text
043C53             10476  ;           BC = second number (0 by default)
043C53             10477  ; Destroys: A,B,C,D,E,H,L,IY,F
043C53             10478  ;
043C53 CD F9 3B 04 10479  DLPAIR:			CALL    LINNUM			; Parse the first line number
043C57 E5          10480  			PUSH    HL			; Stack it
043C58 CD 7A 17 04 10481  			CALL    TERMQ			; Check for ELSE, : or CR
043C5C 28 0A       10482  			JR      Z,DLP1			; And exit if so
043C5E FE E7       10483  			CP      TIF			; Is the token IF?
043C60 28 06       10484  			JR      Z,DLP1			; Yes, so skip the next bit...
043C62 FD 23       10485  			INC     IY			; Otherwise...
043C64 CD F9 3B 04 10486  			CALL    LINNUM			; Fetch the second line number
043C68 E3          10487  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043C69 CD 8F 39 04 10488  			CALL    FINDL			; HL: Find the address of the line
043C6D C1          10489  			POP     BC			; BC: The second number
043C6E C9          10490  			RET
043C6F             10491  ;
043C6F             10492  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043C6F             10493  ;   Inputs: IY addresses character
043C6F             10494  ;  Outputs: Carry set if out-of-range.
043C6F             10495  ; Destroys: A,F
043C6F             10496  ;
043C6F             10497  ; It is called here to check the following
043C6F             10498  ; In range: "$", "%" and "("
043C6F             10499  ;   Plus all characters in RANGE1 and RANGE2
043C6F             10500  ;
043C6F FD 7E 00    10501  RANGE:			LD      A,(IY)			; Fetch the character
043C72 FE 24       10502  			CP      '$'			; Postfix for string variable is valid
043C74 C8          10503  			RET     Z
043C75 FE 25       10504  			CP      '%'			; Postfix for integer variable is valid
043C77 C8          10505  			RET     Z
043C78 FE 28       10506  			CP      '('			; Postfix for array is valid
043C7A C8          10507  			RET     Z
043C7B             10508  ;
043C7B             10509  ; It is called here to check the following
043C7B             10510  ; In range: "0" to "9" and "@"
043C7B             10511  ;   Plus all characters in RANGE2
043C7B             10512  ;
043C7B FE 30       10513  RANGE1:			CP      '0'			; If it is between '0'...
043C7D D8          10514  			RET     C
043C7E FE 3A       10515  			CP      '9'+1			; And '9'...
043C80 3F          10516  			CCF
043C81 D0          10517  			RET     NC			; Then it is valid
043C82 FE 40       10518  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043C84 C8          10519  			RET     Z
043C85             10520  ;
043C85             10521  ; It is called here to check the following
043C85             10522  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043C85             10523  ;
043C85 FE 41       10524  RANGE2:			CP      'A'			; If it is between 'A'...
043C87 D8          10525  			RET     C
043C88 FE 5B       10526  			CP      'Z'+1			; And 'Z'...
043C8A 3F          10527  			CCF
043C8B D0          10528  			RET     NC			; Then it is valid
043C8C FE 5F       10529  			CP      '_'			; If it is underscore, grave, or between 'a'
043C8E D8          10530  			RET     C
043C8F FE 7B       10531  			CP      'z'+1			; And 'z'
043C91 3F          10532  			CCF				; Then it is valid
043C92 C9          10533  			RET
043C93             10534  ;
043C93             10535  ; Throw a 'LINE space' error (line too long)
043C93             10536  ; This is called from LEXAN
043C93             10537  ;
043C93 AF          10538  SPACE_: 		XOR     A
043C94 CD 77 37 04 10539  			CALL    EXTERR          	; "LINE space"
043C98 86 08 00    10540  			DB    	LINE_MN_, 8, 0
043C9B             10541  ;
043C9B             10542  ; LEXAN - LEXICAL ANALYSIS.
043C9B             10543  ;  Bit 0,C: 1=left, 0=right
043C9B             10544  ;  Bit 2,C: 1=in BINARY
043C9B             10545  ;  Bit 3,C: 1=in HEX
043C9B             10546  ;  Bit 4,C: 1=accept line number
043C9B             10547  ;  Bit 5,C: 1=in variable, FN, PROC
043C9B             10548  ;  Bit 6,C: 1=in REM, DATA, *
043C9B             10549  ;  Bit 7,C: 1=in quotes
043C9B             10550  ;   Inputs: IY addresses source string
043C9B             10551  ;           DE addresses destination string (must be page boundary)
043C9B             10552  ;            C sets initial mode
043C9B             10553  ;  Outputs: DE, IY updated
043C9B             10554  ;            A holds carriage return
043C9B             10555  ;
043C9B 12          10556  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043C9C 13          10557  			INC     DE              	; Increment the pointers
043C9D FD 23       10558  			INC     IY			; And fall through to the main function
043C9F             10559  ;
043C9F             10560  ; This is the main entry point
043C9F             10561  ;
043C9F 7B          10562  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CA0 FE FC       10563  			CP      252             	; If it is >= 252 bytes, then...
043CA2 30 EF       10564  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CA4 FD 7E 00    10565  			LD      A,(IY)			; Fetch character from source string
043CA7 FE 0D       10566  			CP      CR			; If it is a CR
043CA9 C8          10567  			RET     Z               	; Then it is end of line; we're done parsing
043CAA CD 7B 3C 04 10568  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043CAE 30 06       10569  			JR      NC,LEXAN3		; Yes, so skip
043CB0 CB A9       10570  			RES     5,C             	; FLAG: NOT IN VARIABLE
043CB2 CB 99       10571  			RES     3,C             	; FLAG: NOT IN HEX
043CB4 CB 91       10572  			RES	2,C			; FLAG: NOT IN BINARY
043CB6             10573  ;
043CB6 FE 20       10574  LEXAN3:			CP      ' '			; Ignore spaces
043CB8 28 E1       10575  			JR      Z,LEXAN1
043CBA FE 2C       10576  			CP      ','			; Ignore commas
043CBC 28 DD       10577  			JR      Z,LEXAN1
043CBE FE 32       10578  			CP	'2'			; If less than '2'
043CC0 30 02       10579  			JR	NC, @F			; No, so skip
043CC2 CB 91       10580  			RES	2,C			; FLAG: NOT IN BINARY
043CC4 FE 47       10581  @@:			CP      'G'			; If less then 'G'
043CC6 38 02       10582  			JR      C,LEXAN4		; Yes, so skip
043CC8 CB 99       10583  			RES     3,C             	; FLAG: NOT IN HEX
043CCA             10584  ;
043CCA FE 22       10585  LEXAN4:			CP      34			; Is it a quote character?
043CCC 20 05       10586  			JR      NZ,LEXAN5		; No, so skip
043CCE CB 11       10587  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043CD0 3F          10588  			CCF                     	; Toggle the carry
043CD1 CB 19       10589  			RR      C			; And then shifting it back into bit 7 of C
043CD3             10590  ;
043CD3 CB 61       10591  LEXAN5:			BIT     4,C			; Accept line number?
043CD5 28 12       10592  			JR      Z,LEXAN6		; No, so skip
043CD7 CB A1       10593  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043CD9 C5          10594  			PUSH    BC
043CDA D5          10595  			PUSH    DE
043CDB CD F9 3B 04 10596  			CALL    LINNUM         		; Parse the line number to HL
043CDF D1          10597  			POP     DE
043CE0 C1          10598  			POP     BC
043CE1 7C          10599  			LD      A,H			; If it is not zero
043CE2 B5          10600  			OR      L
043CE3 C4 5C 3D 04 10601  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043CE7 18 B6       10602  			JR      LEXAN2          	; And loop
043CE9             10603  ;
043CE9 0D          10604  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043CEA 28 0A       10605  			JR      Z,LEXAN7        	; If so, skip
043CEC 0C          10606  			INC     C			; Otherwise restore C
043CED 20 AC       10607  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043CEF B7          10608  			OR      A			; Set the flags based on the character
043CF0 F4 C7 37 04 10609  			CALL    P,LEX           	; Tokenise if A < 128
043CF4 18 13       10610  			JR      LEXAN8			; And skip
043CF6             10611  ;
043CF6             10612  ; Processing the LEFT hand side here
043CF6             10613  ;
043CF6 FE 2A       10614  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043CF8 28 17       10615  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043CFA B7          10616  			OR      A			; Set the flags based on the character
043CFB F4 C7 37 04 10617  			CALL    P,LEX           	; Tokenise if A < 128
043CFF             10618  ;
043CFF             10619  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043CFF             10620  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043CFF             10621  ; Examples:
043CFF             10622  ;   LET A% = PAGE : REM This is the GET version
043CFF             10623  ;   PAGE = 40000  : REM This is the SET version
043CFF             10624  ;
043CFF FE 8F       10625  			CP      TOKLO			; TOKLO is 8Fh
043D01 38 06       10626  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D03 FE 94       10627  			CP      TOKHI+1			; TOKHI is 93h
043D05 30 02       10628  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D07 C6 40       10629  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D09             10630  ;
043D09 FE F4       10631  LEXAN8:			CP      REM			; If the token is REM
043D0B 28 04       10632  			JR      Z,LEXAN9		; Then stop tokenising
043D0D FE DC       10633  			CP      DATA_MN_			; If it is not DATA then
043D0F 20 02       10634  			JR      NZ,LEXANA		; Skip
043D11 CB F1       10635  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D13             10636  ;
043D13 FE A4       10637  LEXANA:			CP      FN			; If the token is FN
043D15 28 0A       10638  			JR      Z,LEXANB
043D17 FE F2       10639  			CP      PROC			; Or the token is PROC
043D19 28 06       10640  			JR      Z,LEXANB		; Then jump to here
043D1B CD 85 3C 04 10641  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D1F 38 02       10642  			JR      C,LEXANC		; Jump here if out of range
043D21             10643  ;
043D21 CB E9       10644  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D23 FE 26       10645  LEXANC:			CP      '&'			; Check for hex prefix
043D25 20 02       10646  			JR      NZ,LEXAND		; If not, skip
043D27 CB D9       10647  			SET     3,C             	; FLAG: IN HEX
043D29             10648  ;
043D29 FE 25       10649  LEXAND:			CP	'%'			; Check for binary prefix
043D2B 20 02       10650  			JR	NZ,LEXANE		; If not, skip
043D2D CB D1       10651  			SET	2,C			; FLAG: IN BINARY
043D2F             10652  ;
043D2F 21 53 3D 04 10653  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D33 C5          10654  			PUSH    BC
043D34 01 06 00 00 10655  			LD      BC,LIST1L		; The list length
043D38 ED B1       10656  			CPIR				; Check if the token is in this list
043D3A C1          10657  			POP     BC
043D3B 20 02       10658  			JR      NZ,LEXANF		; If not, then skip
043D3D CB E1       10659  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D3F             10660  ;
043D3F 21 57 3D 04 10661  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D43 C5          10662  			PUSH    BC
043D44 01 05 00 00 10663  			LD      BC,LIST2L		; The list length
043D48 ED B1       10664  			CPIR				; Check if the token is in this list
043D4A C1          10665  			POP     BC
043D4B 20 02       10666  			JR      NZ,LEXANG		; If not, then skip
043D4D CB C1       10667  			SET     0,C             	; FLAG: ENTER LEFT MODE
043D4F C3 9B 3C 04 10668  LEXANG:			JP      LEXAN1			; And loop
043D53             10669  
043D53             10670  ;
043D53             10671  ; LIST1: List of tokens that must be followed by line numbers
043D53             10672  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043D53             10673  ;
043D53 E5          10674  LIST1:			DB	GOTO
043D54 E4          10675  			DB	GOSUB
043D55 F7          10676  			DB	RESTOR
043D56 FC          10677  			DB	TRACE
043D57 8C          10678  LIST2:			DB	THEN_MN_
043D58 8B          10679  			DB	ELSE_MN_
043D59             10680  LIST1L:			EQU     $-LIST1
043D59 F5          10681  			DB	REPEAT
043D5A 85          10682  			DB	TERROR_MN
043D5B 3A          10683  			DB    	':'
043D5C             10684  LIST2L:			EQU     $-LIST2
043D5C             10685  ;
043D5C             10686  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043D5C             10687  ;   Inputs: HL=line number, DE=string pointer
043D5C             10688  ;  Outputs: DE updated, BIT 4,C set.
043D5C             10689  ; Destroys: A,B,C,D,E,F
043D5C             10690  ;
043D5C             10691  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043D5C             10692  ;
043D5C             10693  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043D5C             10694  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043D5C             10695  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043D5C             10696  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043D5C             10697  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043D5C             10698  ;
043D5C CB E1       10699  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043D5E EB          10700  			EX      DE, HL			; HL: string pointer, DE: line number
043D5F 36 8D       10701  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
043D61 23          10702  			INC     HL
043D62 7A          10703  			LD      A,D			; Get the high byte
043D63 E6 C0       10704  			AND     0C0H			; Get the top two bits	DD000000
043D65 0F          10705  			RRCA				; Shift right		00DD0000
043D66 0F          10706  			RRCA
043D67 47          10707  			LD      B,A			; Store in B
043D68 7B          10708  			LD      A,E			; Get the low byte
043D69 E6 C0       10709  			AND     0C0H			; Get the top two bits	EE000000
043D6B B0          10710  			OR      B			; Combine with D	EEDD0000
043D6C 0F          10711  			RRCA				; Shift right		00EEDD00
043D6D 0F          10712  			RRCA
043D6E EE 54       10713  			XOR     01010100B		; XOR with 54h
043D70 77          10714  			LD      (HL),A			; Store this as the second byte
043D71 23          10715  			INC     HL
043D72 7B          10716  			LD      A,E			; Get the low byte
043D73 E6 3F       10717  			AND     3FH			; Strip the top two bits off
043D75 F6 40       10718  			OR      '@'			; OR with 40h
043D77 77          10719  			LD      (HL),A			; Store
043D78 23          10720  			INC     HL
043D79 7A          10721  			LD      A,D			; Get the high byte
043D7A E6 3F       10722  			AND     3FH			; Strip the top two bits off
043D7C F6 40       10723  			OR      '@'			; OR with 40h
043D7E 77          10724  			LD      (HL),A			; Store
043D7F 23          10725  			INC     HL
043D80 EB          10726  			EX      DE,HL			; DE: string pointer, HL: line number
043D81 C9          10727  			RET
043D82             10728  ;
043D82             10729  ; TEXT - OUTPUT MESSAGE.
043D82             10730  ;   Inputs: HL addresses text (terminated by nul)
043D82             10731  ;  Outputs: HL addresses character following nul.
043D82             10732  ; Destroys: A,H,L,F
043D82             10733  ;
043D82 2A 2F 4D 04 10734  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043D86             10735  ;
043D86 7E          10736  TEXT_:			LD      A, (HL)			; Fetch the character
043D87 23          10737  			INC     HL			; Increment pointer to next character
043D88 B7          10738  			OR      A			; Check for the nul (0) string terminator
043D89 C8          10739  			RET     Z			; And return if so
043D8A CD 6C 39 04 10740  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043D8E 18 F6       10741  			JR      TEXT_			; And loop
043D90             10742  ;
043D90             10743  ; TELL - OUTPUT MESSAGE.
043D90             10744  ;   Inputs: Text follows subroutine call (term=nul)
043D90             10745  ; Destroys: A,F
043D90             10746  ;
043D90             10747  ; Example usage:
043D90             10748  ;
043D90             10749  ;	CALL	TELL			Call the function
043D90             10750  ;	DB	"Hello World", 0	Followed by a zero terminated string
043D90             10751  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043D90             10752  ;
043D90 E3          10753  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043D91 CD 86 3D 04 10754  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043D95 E3          10755  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043D96 C9          10756  			RET				; at this point we'll return to the first instruction after the message; --- End main.asm ---
043D97             10757  
043D97             10758  ; --- Begin misc.asm ---
043D97             10759  ;
043D97             10760  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043D97             10761  ; Author:	Dean Belfield
043D97             10762  ; Created:	12/05/2023
043D97             10763  ; Last Updated:	12/05/2023
043D97             10764  ;
043D97             10765  ; Modinfo:
043D97             10766  
043D97             10767  			; INCLUDE	"equs.inc"
043D97             10768  			; INCLUDE	"macros.inc"
043D97             10769  
043D97             10770  			; .ASSUME	ADL = 1
043D97             10771  
043D97             10772  			; SEGMENT CODE
043D97             10773  
043D97             10774  			; XDEF	ASC_TO_NUMBER
043D97             10775  			; XDEF	SWITCH_A
043D97             10776  			; XDEF	NULLTOCR
043D97             10777  			; XDEF	CRTONULL
043D97             10778  			; XDEF	CSTR_FNAME
043D97             10779  			; XDEF	CSTR_LINE
043D97             10780  			; XDEF	CSTR_FINDCH
043D97             10781  			; XDEF	CSTR_ENDSWITH
043D97             10782  			; XDEF	CSTR_CAT
043D97             10783  
043D97             10784  			; XREF	OSWRCH
043D97             10785  			; XREF	KEYWDS
043D97             10786  			; XREF	KEYWDL
043D97             10787  
043D97             10788  ; Read a number and convert to binary
043D97             10789  ; If prefixed with &, will read as hex, otherwise decimal
043D97             10790  ;   Inputs: HL: Pointer in string buffer
043D97             10791  ;  Outputs: HL: Updated text pointer
043D97             10792  ;           DE: Value
043D97             10793  ;            A: Terminator (spaces skipped)
043D97             10794  ; Destroys: A,D,E,H,L,F
043D97             10795  ;
043D97 C5          10796  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043D98 11 00 00 00 10797  			LD	DE, 0			; Initialise DE
043D9C CD DE 3D 04 10798  			CALL	SKIPSPC			; Skip whitespace
043DA0 7E          10799  			LD	A, (HL)			; Read first character
043DA1 FE 26       10800  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DA3 20 1F       10801  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DA5 23          10802  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DA6             10803  ;
043DA6 7E          10804  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DA7 CD EC 3D 04 10805  			CALL    UPPERC			; Convert to uppercase
043DAB D6 30       10806  			SUB	'0'			; Normalise to 0
043DAD 38 2E       10807  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DAF FE 0A       10808  			CP 	10			; Check if >= 10
043DB1 38 06       10809  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043DB3 D6 07       10810  			SUB 	7			; Adjust ASCII A-F to nibble
043DB5 FE 10       10811  			CP 	16			; Check for > F
043DB7 30 24       10812  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043DB9 EB          10813  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043DBA 29          10814  			ADD	HL, HL
043DBB 29          10815  			ADD	HL, HL
043DBC 29          10816  			ADD	HL, HL
043DBD 29          10817  			ADD	HL, HL
043DBE EB          10818  			EX	DE, HL
043DBF B3          10819  			OR      E			; OR the new digit in to the least significant nibble
043DC0 5F          10820  			LD      E, A
043DC1 23          10821  			INC     HL			; Onto the next character
043DC2 18 E2       10822  			JR      ASC_TO_NUMBER1		; And loop
043DC4             10823  ;
043DC4 7E          10824  ASC_TO_NUMBER3:		LD	A, (HL)
043DC5 D6 30       10825  			SUB	'0'			; Normalise to 0
043DC7 38 14       10826  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043DC9 FE 0A       10827  			CP	10			; Check if >= 10
043DCB 30 10       10828  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043DCD EB          10829  			EX 	DE, HL 			; Stick DE in HL
043DCE 44          10830  			LD	B, H 			; And copy HL into BC
043DCF 4D          10831  			LD	C, L
043DD0 29          10832  			ADD	HL, HL 			; x 2
043DD1 29          10833  			ADD	HL, HL 			; x 4
043DD2 09          10834  			ADD	HL, BC 			; x 5
043DD3 29          10835  			ADD	HL, HL 			; x 10
043DD4 EB          10836  			EX	DE, HL
043DD5             10837  			ADD8U_DE 			; Add A to DE (macro)
043DD5 83          0001M 		ADD	A, E
043DD6 5F          0002M 		LD	E, A
043DD7 8A          0003M 		ADC	A, D
043DD8 93          0004M 		SUB	E
043DD9 57          0005M 		LD	D, A
043DDA 23          10838  			INC	HL
043DDB 18 E7       10839  			JR	ASC_TO_NUMBER3
043DDD C1          10840  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043DDE             10841  
043DDE             10842  ; Skip a space
043DDE             10843  ; HL: Pointer in string buffer
043DDE             10844  ;
043DDE 7E          10845  SKIPSPC:			LD      A, (HL)
043DDF FE 20       10846  			CP      ' '
043DE1 C0          10847  			RET     NZ
043DE2 23          10848  			INC     HL
043DE3 18 F9       10849  			JR      SKIPSPC
043DE5             10850  
043DE5             10851  ; Skip a string
043DE5             10852  ; HL: Pointer in string buffer
043DE5             10853  ;
043DE5 7E          10854  SKIPNOTSP:		LD	A, (HL)
043DE6 FE 20       10855  			CP	' '
043DE8 C8          10856  			RET	Z
043DE9 23          10857  			INC	HL
043DEA 18 F9       10858  			JR	SKIPNOTSP
043DEC             10859  
043DEC             10860  ; Convert a character to upper case
043DEC             10861  ;  A: Character to convert
043DEC             10862  ;
043DEC E6 7F       10863  UPPERC:  		AND     7FH
043DEE FE 60       10864  			CP      '`'
043DF0 D8          10865  			RET     C
043DF1 E6 5F       10866  			AND     5FH			; Convert to upper case
043DF3 C9          10867  			RET
043DF4             10868  
043DF4             10869  ; Switch on A - lookup table immediately after call
043DF4             10870  ;  A: Index into lookup table
043DF4             10871  ;
043DF4 E3          10872  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043DF5 87          10873  			ADD	A, A			; Multiply A by two
043DF6             10874  			ADD8U_HL 			; Add to HL (macro)
043DF6 85          0001M 		ADD	A, L
043DF7 6F          0002M 		LD	L, A
043DF8 8C          0003M 		ADC	A, H
043DF9 95          0004M 		SUB	L
043DFA 67          0005M 		LD	H, A
043DFB 7E          10875  			LD	A, (HL)			; follow the call. Fetch an address from the
043DFC 23          10876  			INC	HL 			; table.
043DFD 66          10877  			LD	H, (HL)
043DFE 6F          10878  			LD	L, A
043DFF E3          10879  			EX	(SP), HL		; Swap this new address back, restores HL
043E00 C9          10880  			RET				; Return program control to this new address
043E01             10881  
043E01             10882  ; Convert the buffer to a null terminated string and back
043E01             10883  ; HL: Buffer address
043E01             10884  ;
043E01 C5          10885  NULLTOCR:		PUSH 	BC
043E02 06 00       10886  			LD	B, 0
043E04 0E 0D       10887  			LD	C, CR
043E06 18 05       10888  			JR	CRTONULL0
043E08             10889  ;
043E08 C5          10890  CRTONULL:		PUSH	BC
043E09 06 0D       10891  			LD	B, CR
043E0B 0E 00       10892  			LD	C, 0
043E0D             10893  ;
043E0D E5          10894  CRTONULL0:		PUSH	HL
043E0E 7E          10895  CRTONULL1:		LD	A, (HL)
043E0F B8          10896  			CP 	B
043E10 28 03       10897  			JR	Z, CRTONULL2
043E12 23          10898  			INC	HL
043E13 18 F9       10899  			JR	CRTONULL1
043E15 71          10900  CRTONULL2:		LD	(HL), C
043E16 E1          10901  			POP 	HL
043E17 C1          10902  			POP	BC
043E18 C9          10903  			RET
043E19             10904  
043E19             10905  ; Copy a filename to DE and zero terminate it
043E19             10906  ; HL: Source
043E19             10907  ; DE: Destination (ACCS)
043E19             10908  ;
043E19 7E          10909  CSTR_FNAME:		LD	A, (HL)			; Get source
043E1A FE 20       10910  			CP	32			; Is it space
043E1C 28 09       10911  			JR	Z, @F
043E1E FE 0D       10912  			CP	CR			; Or is it CR
043E20 28 05       10913  			JR	Z, @F
043E22 12          10914  			LD	(DE), A			; No, so store
043E23 23          10915  			INC	HL			; Increment
043E24 13          10916  			INC	DE
043E25 18 F2       10917  			JR	CSTR_FNAME		; And loop
043E27 AF          10918  @@:			XOR	A			; Zero terminate the target string
043E28 12          10919  			LD	(DE), A
043E29 13          10920  			INC	DE			; And point to next free address
043E2A C9          10921  			RET
043E2B             10922  
043E2B             10923  ; Copy a CR terminated line to DE and zero terminate it
043E2B             10924  ; HL: Source
043E2B             10925  ; DE: Destination (ACCS)
043E2B             10926  ;
043E2B 7E          10927  CSTR_LINE:		LD	A, (HL)			; Get source
043E2C FE 0D       10928  			CP	CR			; Is it CR
043E2E 28 05       10929  			JR	Z, @F
043E30 12          10930  			LD	(DE), A			; No, so store
043E31 23          10931  			INC	HL			; Increment
043E32 13          10932  			INC	DE
043E33 18 F6       10933  			JR	CSTR_LINE		; And loop
043E35 AF          10934  @@:			XOR	A			; Zero terminate the target string
043E36 12          10935  			LD	(DE), A
043E37 13          10936  			INC	DE			; And point to next free address
043E38 C9          10937  			RET
043E39             10938  
043E39             10939  ; Find the first occurrence of a character (case sensitive)
043E39             10940  ; HL: Source
043E39             10941  ;  C: Character to find
043E39             10942  ; Returns:
043E39             10943  ; HL: Pointer to character, or end of string marker
043E39             10944  ;
043E39 7E          10945  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E3A B9          10946  			CP	C			; Is it our character?
043E3B C8          10947  			RET	Z			; Yes, so exit
043E3C B7          10948  			OR	A			; Is it the end of string?
043E3D C8          10949  			RET	Z			; Yes, so exit
043E3E 23          10950  			INC	HL
043E3F 18 F8       10951  			JR	CSTR_FINDCH
043E41             10952  
043E41             10953  ; Check whether a string ends with another string (case insensitive)
043E41             10954  ; HL: Source
043E41             10955  ; DE: The substring we want to test with
043E41             10956  ; Returns:
043E41             10957  ;  F: Z if HL ends with DE, otherwise NZ
043E41             10958  ;
043E41 7E          10959  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E42 CD EC 3D 04 10960  			CALL	UPPERC			; Convert to upper case
043E46 4F          10961  			LD	C, A
043E47 1A          10962  			LD	A, (DE)			; Get the substring byte
043E48 B9          10963  			CP	C
043E49 C0          10964  			RET	NZ			; Return NZ if at any point the strings don't match
043E4A B1          10965  			OR	C			; Check whether both bytes are zero
043E4B C8          10966  			RET	Z			; If so, return, as we have reached the end of both strings
043E4C 23          10967  			INC	HL
043E4D 13          10968  			INC	DE
043E4E 18 F1       10969  			JR	CSTR_ENDSWITH		; And loop
043E50             10970  
043E50             10971  ; Concatenate a string onto the end of another string
043E50             10972  ; HL: Source
043E50             10973  ; DE: Second string
043E50             10974  ;
043E50 7E          10975  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043E51 B7          10976  			OR	A
043E52 28 03       10977  			JR	Z, CSTR_CAT_1
043E54 23          10978  			INC	HL
043E55 18 F9       10979  			JR	CSTR_CAT
043E57             10980  ;
043E57 1A          10981  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043E58 77          10982  			LD	(HL), A
043E59 B7          10983  			OR	A			; Check for end of string
043E5A C8          10984  			RET	Z			; And return
043E5B 23          10985  			INC	HL
043E5C 13          10986  			INC	DE
043E5D 18 F8       10987  			JR	CSTR_CAT_1		; Loop until finished						; --- End misc.asm ---
043E5F             10988  
043E5F             10989  ; --- Begin patch.asm ---
043E5F             10990  ;
043E5F             10991  ; Title:	BBC Basic for AGON
043E5F             10992  ; Author:	Dean Belfield
043E5F             10993  ; Created:	12/05/2023
043E5F             10994  ; Last Updated:	15/11/2023
043E5F             10995  ;
043E5F             10996  ; Modinfo:
043E5F             10997  ; 11/07/2023:	Fixed *BYE for ADL mode
043E5F             10998  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043E5F             10999  
043E5F             11000  			; .ASSUME	ADL = 1
043E5F             11001  
043E5F             11002  			; INCLUDE	"equs.inc"
043E5F             11003  			; INCLUDE "macros.inc"
043E5F             11004  			; INCLUDE "mos_api.inc"	; In MOS/src
043E5F             11005  
043E5F             11006  			; SEGMENT CODE
043E5F             11007  
043E5F             11008  			; XDEF	OSWRCH
043E5F             11009  			; XDEF	OSLINE
043E5F             11010  			; XDEF	ESCSET
043E5F             11011  			; XDEF	PUTIME
043E5F             11012  			; XDEF	GETIME
043E5F             11013  			; XDEF	PUTCSR
043E5F             11014  			; XDEF 	GETCSR
043E5F             11015  			; XDEF	OSRDCH
043E5F             11016  			; XDEF	PROMPT
043E5F             11017  			; XDEF	OSKEY
043E5F             11018  			; XDEF	TRAP
043E5F             11019  			; XDEF	LTRAP
043E5F             11020  			; XDEF	OSINIT
043E5F             11021  			; XDEF	OSCLI
043E5F             11022  			; XDEF	OSBPUT
043E5F             11023  			; XDEF	OSBGET
043E5F             11024  			; XDEF	OSSTAT
043E5F             11025  			; XDEF	OSSHUT
043E5F             11026  			; XDEF	OSOPEN
043E5F             11027  			; XDEF	OSCALL
043E5F             11028  			; XDEF	GETPTR
043E5F             11029  			; XDEF	PUTPTR
043E5F             11030  			; XDEF	GETEXT
043E5F             11031  			; XDEF	GETIMS
043E5F             11032  			; XDEF	RESET
043E5F             11033  			; XDEF	OSLOAD
043E5F             11034  			; XDEF	OSSAVE
043E5F             11035  			; XDEF	EXPR_W2
043E5F             11036  			; XDEF	STAR_VERSION
043E5F             11037  
043E5F             11038  			; XREF	_end			; In init.asm
043E5F             11039  
043E5F             11040  			; XREF	ASC_TO_NUMBER
043E5F             11041  			; XREF	RAM_START
043E5F             11042  			; XREF	RAM_END
043E5F             11043  			; XREF	FLAGS
043E5F             11044  			; XREF	ESCAPE
043E5F             11045  			; XREF	USER
043E5F             11046  			; XREF	RAM_Top
043E5F             11047  			; XREF	EXTERR
043E5F             11048  			; XREF	COUNT0
043E5F             11049  			; XREF	EXPRI
043E5F             11050  			; XREF	COMMA
043E5F             11051  			; XREF	XEQ
043E5F             11052  			; XREF	NXT
043E5F             11053  			; XREF	NULLTOCR
043E5F             11054  			; XREF	CRLF
043E5F             11055  			; XREF	CSTR_FNAME
043E5F             11056  			; XREF	CSTR_LINE
043E5F             11057  			; XREF	CSTR_FINDCH
043E5F             11058  			; XREF	CSTR_ENDSWITH
043E5F             11059  			; XREF	CSTR_CAT
043E5F             11060  			; XREF	FINDL
043E5F             11061  			; XREF	OUT_
043E5F             11062  			; XREF	ERROR_
043E5F             11063  			; XREF	ONEDIT
043E5F             11064  			; XREF	TELL
043E5F             11065  			; XREF	OSWRCHPT
043E5F             11066  			; XREF	OSWRCHCH
043E5F             11067  			; XREF	OSWRCHFH
043E5F             11068  			; XREF	LISTON
043E5F             11069  			; XREF	LISTIT
043E5F             11070  			; XREF	PAGE_
043E5F             11071  			; XREF	ONEDIT1
043E5F             11072  			; XREF	CLEAN
043E5F             11073  			; XREF	NEWIT
043E5F             11074  			; XREF	BAD
043E5F             11075  			; XREF	VBLANK_INIT
043E5F             11076  			; XREF	VBLANK_STOP
043E5F             11077  			; XREF	KEYDOWN
043E5F             11078  			; XREF	KEYASCII
043E5F             11079  			; XREF	WIDTH
043E5F             11080  			; XREF	ASSEM
043E5F             11081  
043E5F             11082  ; OSLINE: Invoke the line editor
043E5F             11083  ;
043E5F 1E 01       11084  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043E61             11085  
043E61             11086  ; Entry point to line editor that does not clear the buffer
043E61             11087  ;
043E61 FD E5       11088  OSLINE1:		PUSH	IY
043E63 E5          11089  			PUSH	HL			; Buffer address
043E64 01 00 01 00 11090  			LD	BC, 256			; Buffer length
043E68             11091  			MOSCALL	mos_editline		; Call the MOS line editor
043E68 3E 09       0001M 			LD	A, function
043E6A 49 CF       0002M 			RST.LIS	08h
043E6C E1          11092  			POP	HL			; Pop the address
043E6D FD E1       11093  			POP	IY
043E6F F5          11094  			PUSH	AF			; Stack the return value (key pressed)
043E70 CD 01 3E 04 11095  			CALL	NULLTOCR		; Turn the 0 character to a CR
043E74 CD 47 39 04 11096  			CALL	CRLF			; Display CRLF
043E78 F1          11097  			POP	AF
043E79 FE 1B       11098  			CP	1Bh 			; Check if ESC terminated the input
043E7B CA 77 3F 04 11099  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043E7F 3A 42 4D 04 11100  			LD	A, (FLAGS)		; Otherwise
043E83 CB BF       11101  			RES	7, A 			; Clear the escape flag
043E85 32 42 4D 04 11102  			LD	(FLAGS), A
043E89 CD 3D 41 04 11103  			CALL	WAIT_VBLANK 		; Wait a frame
043E8D AF          11104   			XOR	A			; Return A = 0
043E8E 32 47 4D 04 11105  			LD	(KEYDOWN), A
043E92 32 48 4D 04 11106  			LD	(KEYASCII), A
043E96 C9          11107  			RET
043E97             11108  
043E97             11109  ; PUTIME: set current time to DE:HL, in centiseconds.
043E97             11110  ;
043E97 DD E5       11111  PUTIME:			PUSH 	IX
043E99             11112  			MOSCALL	mos_sysvars
043E99 3E 08       0001M 			LD	A, function
043E9B 49 CF       0002M 			RST.LIS	08h
043E9D DD 75 00    11113  			LD	(IX + sysvar_time + 0), L
043EA0 DD 74 01    11114  			LD	(IX + sysvar_time + 1), H
043EA3 DD 73 02    11115  			LD	(IX + sysvar_time + 2), E
043EA6 DD 72 03    11116  			LD	(IX + sysvar_time + 3), D
043EA9 DD E1       11117  			POP	IX
043EAB C9          11118  			RET
043EAC             11119  
043EAC             11120  ; GETIME: return current time in DE:HL, in centiseconds
043EAC             11121  ;
043EAC DD E5       11122  GETIME:			PUSH 	IX
043EAE             11123  			MOSCALL	mos_sysvars
043EAE 3E 08       0001M 			LD	A, function
043EB0 49 CF       0002M 			RST.LIS	08h
043EB2 DD 6E 00    11124  			LD	L, (IX + sysvar_time + 0)
043EB5 DD 66 01    11125  			LD	H, (IX + sysvar_time + 1)
043EB8 DD 5E 02    11126  			LD	E, (IX + sysvar_time + 2)
043EBB DD 56 03    11127  			LD	D, (IX + sysvar_time + 3)
043EBE DD E1       11128  			POP	IX
043EC0 C9          11129  			RET
043EC1             11130  
043EC1             11131  ; PUTCSR: move to cursor to x=DE, y=HL
043EC1             11132  ;
043EC1 3E 1F       11133  PUTCSR:			LD	A, 1Fh			; TAB
043EC3 5B D7       11134  			RST.LIL	10h
043EC5 7B          11135  			LD	A, E			; X
043EC6 5B D7       11136  			RST.LIL 10h
043EC8 7D          11137  			LD	A, L			; Y
043EC9 5B D7       11138  			RST.LIL 10h
043ECB C9          11139  			RET
043ECC             11140  
043ECC             11141  ; GETCSR: return cursor position in x=DE, y=HL
043ECC             11142  ;
043ECC DD E5       11143  GETCSR:			PUSH	IX			; Get the system vars in IX
043ECE             11144  			MOSCALL	mos_sysvars		; Reset the semaphore
043ECE 3E 08       0001M 			LD	A, function
043ED0 49 CF       0002M 			RST.LIS	08h
043ED2 DD CB 04 86 11145  			RES	0, (IX+sysvar_vpd_pflags)
043ED6             11146  			VDU	23
043ED6 3E 17       0001M 		LD	A, val
043ED8 CD 00 3F 04 0002M 		CALL	OSWRCH
043EDC             11147  			VDU	0
043EDC 3E 00       0001M 		LD	A, val
043EDE CD 00 3F 04 0002M 		CALL	OSWRCH
043EE2             11148  			VDU	vdp_cursor
043EE2 3E 82       0001M 		LD	A, val
043EE4 CD 00 3F 04 0002M 		CALL	OSWRCH
043EE8 DD CB 04 46 11149  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043EEC 28 FA       11150  			JR	Z, @B			; Wait for the result
043EEE 16 00       11151  			LD 	D, 0
043EF0 62          11152  			LD	H, D
043EF1 DD 5E 07    11153  			LD	E, (IX + sysvar_cursorX)
043EF4 DD 6E 08    11154  			LD	L, (IX + sysvar_cursorY)
043EF7 DD E1       11155  			POP	IX
043EF9 C9          11156  			RET
043EFA             11157  
043EFA             11158  ; PROMPT: output the input prompt
043EFA             11159  ;
043EFA 3E 3E       11160  PROMPT: 		LD	A,'>'
043EFC C3 00 3F 04 11161  			JP	OSWRCH
043F00             11162  
043F00             11163  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F00             11164  ; A: Character to write
043F00             11165  ;
043F00 E5          11166  OSWRCH:			PUSH	HL
043F01 21 40 4D 04 11167  			LD	HL, LISTON		; Fetch the LISTON variable
043F05 CB 5E       11168  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F07 20 0B       11169  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F09             11170  ;
043F09 2A 45 4D 04 11171  			LD	HL, (OSWRCHCH)		; L: Channel #
043F0D 2D          11172  			DEC	L			; If it is 1
043F0E 28 10       11173  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F10             11174  ;
043F10 E1          11175  			POP	HL			; Otherwise
043F11 5B D7       11176  			RST.LIL	10h			; Output the character to MOS
043F13 C9          11177  			RET
043F14             11178  ;
043F14 2A 43 4D 04 11179  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F18 77          11180  			LD	(HL), A			; Echo the character into the buffer
043F19 23          11181  			INC	HL			; Increment pointer
043F1A 22 43 4D 04 11182  			LD	(OSWRCHPT), HL		; Write pointer back
043F1E E1          11183  			POP	HL
043F1F C9          11184  			RET
043F20             11185  ;
043F20 D5          11186  OSWRCH_FILE:		PUSH	DE
043F21 5C          11187  			LD	E, H			; Filehandle to E
043F22 CD 3B 43 04 11188  			CALL	OSBPUT			; Write the byte out
043F26 D1          11189  			POP	DE
043F27 E1          11190  			POP	HL
043F28 C9          11191  			RET
043F29             11192  
043F29             11193  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F29             11194  ; This is only called in GETS (eval.asm)
043F29             11195  ;
043F29             11196  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F29 3E 00       0001M 			LD	A, function
043F2B 49 CF       0002M 			RST.LIS	08h
043F2D FE 1B       11197  			CP	1Bh
043F2F 28 46       11198  			JR	Z, LTRAP1
043F31 C9          11199  			RET
043F32             11200  
043F32             11201  
043F32             11202  ;OSKEY - Read key with time-limit, test for ESCape.
043F32             11203  ;Main function is carried out in user patch.
043F32             11204  ;   Inputs: HL = time limit (centiseconds)
043F32             11205  ;  Outputs: Carry reset if time-out
043F32             11206  ;           If carry set A = character
043F32             11207  ; Destroys: A,H,L,F
043F32             11208  ;
043F32 CD 63 3F 04 11209  OSKEY:			CALL	READKEY			; Read the keyboard
043F36 28 0A       11210  			JR	Z, @F 			; Skip if we have a key
043F38 7C          11211  			LD	A, H 			; Check loop counter
043F39 B5          11212  			OR 	L
043F3A C8          11213  			RET 	Z 			; Return, we've not got a key at this point
043F3B CD 3D 41 04 11214  			CALL	WAIT_VBLANK 		; Wait a frame
043F3F 2B          11215  			DEC 	HL			; Decrement
043F40 18 F0       11216  			JR	OSKEY 			; And loop
043F42             11217  ;
043F42 21 47 4D 04 11218  @@:			LD	HL, KEYDOWN		; We have a key, so
043F46 36 00       11219  			LD	(HL), 0			; clear the keydown flag
043F48 FE 1B       11220  			CP	1BH			; If we are not pressing ESC,
043F4A 37          11221  			SCF 				; then flag we've got a character
043F4B C0          11222  			RET	NZ
043F4C             11223  ;
043F4C             11224  ; ESCSET
043F4C             11225  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043F4C             11226  ;
043F4C E5          11227  ESCSET: 		PUSH    HL
043F4D 21 42 4D 04 11228          		LD      HL,FLAGS		; Pointer to FLAGS
043F51 CB 76       11229          		BIT     6,(HL)			; If bit 6 is set, then
043F53 20 02       11230          		JR      NZ,ESCDIS		; escape is disabled, so skip
043F55 CB FE       11231          		SET     7,(HL)			; Set bit 7, the escape flag
043F57 E1          11232  ESCDIS: 		POP     HL
043F58 C9          11233          		RET
043F59             11234  ;
043F59             11235  ; ESCTEST
043F59             11236  ; Test for ESC key
043F59             11237  ;
043F59 CD 63 3F 04 11238  ESCTEST:		CALL	READKEY			; Read the keyboard
043F5D C0          11239  			RET	NZ			; Skip if no key is pressed
043F5E FE 1B       11240  			CP	1BH			; If ESC pressed then
043F60 28 EA       11241  			JR	Z,ESCSET		; jump to the escape set routine
043F62 C9          11242  			RET
043F63             11243  
043F63             11244  ; Read the keyboard
043F63             11245  ; Returns:
043F63             11246  ; - A: ASCII of the pressed key
043F63             11247  ; - F: Z if the key is pressed, otherwise NZ
043F63             11248  ;
043F63 3A 47 4D 04 11249  READKEY:		LD	A, (KEYDOWN)		; Get key down
043F67 3D          11250  			DEC	A 			; Set Z flag if keydown is 1
043F68 3A 48 4D 04 11251  			LD	A, (KEYASCII)		; Get key ASCII value
043F6C C9          11252  			RET
043F6D             11253  ;
043F6D             11254  ; TRAP
043F6D             11255  ; This is called whenever BASIC needs to check for ESC
043F6D             11256  ;
043F6D CD 59 3F 04 11257  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043F71             11258  ;
043F71 3A 42 4D 04 11259  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043F75 B7          11260  			OR	A			; This checks for bit 7; if it is not set then the result will
043F76 F0          11261  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043F77 21 42 4D 04 11262  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043F7B CB BE       11263  			RES	7,(HL)			; Clear the escape pressed flag and
043F7D C3 9B 0C 04 11264  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043F81             11265  
043F81             11266  ;OSINIT - Initialise RAM mapping etc.
043F81             11267  ;If BASIC is entered by BBCBASIC FILENAME then file
043F81             11268  ;FILENAME.BBC is automatically CHAINed.
043F81             11269  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043F81             11270  ;            HL = initial value of PAGE (user program)
043F81             11271  ;            Z-flag reset indicates AUTO-RUN.
043F81             11272  ;  Destroys: A,D,E,H,L,F
043F81             11273  ;
043F81 CD E0 48 04 11274  OSINIT:			CALL	VBLANK_INIT
043F85 AF          11275  			XOR	A
043F86 21 00 4E 04 11276  			LD 	HL, USER
043F8A 11 00 00 0B 11277  			LD	DE, RAM_Top
043F8E 5F          11278  			LD	E, A			; Page boundary
043F8F C9          11279  			RET
043F90             11280  
043F90             11281  ;
043F90             11282  ;OSCLI - Process a MOS command
043F90             11283  ;
043F90 CD 04 40 04 11284  OSCLI: 			CALL    SKIPSP
043F94 FE 0D       11285  			CP      CR
043F96 C8          11286  			RET     Z
043F97 FE 7C       11287  			CP      '|'
043F99 C8          11288  			RET     Z
043F9A EB          11289  			EX      DE,HL
043F9B 21 13 40 04 11290  			LD      HL,COMDS
043F9F 1A          11291  OSCLI0:			LD      A,(DE)
043FA0 CD 0B 40 04 11292  			CALL    UPPRC
043FA4 BE          11293  			CP      (HL)
043FA5 28 0B       11294  			JR      Z,OSCLI2
043FA7 38 30       11295  			JR      C,OSCLI6
043FA9 CB 7E       11296  OSCLI1:			BIT     7,(HL)
043FAB 23          11297  			INC     HL
043FAC 28 FB       11298  			JR      Z,OSCLI1
043FAE 23          11299  			INC     HL
043FAF 23          11300  			INC     HL
043FB0 18 ED       11301  			JR      OSCLI0
043FB2             11302  ;
043FB2 D5          11303  OSCLI2:			PUSH    DE
043FB3 13          11304  OSCLI3:			INC     DE
043FB4 23          11305  			INC     HL
043FB5 1A          11306  			LD      A,(DE)
043FB6 CD 0B 40 04 11307  			CALL    UPPRC
043FBA FE 2E       11308  			CP      '.'			; ABBREVIATED?
043FBC 28 0A       11309  			JR      Z,OSCLI4
043FBE AE          11310  			XOR     (HL)
043FBF 28 F2       11311  			JR      Z,OSCLI3
043FC1 FE 80       11312  			CP      80H
043FC3 28 03       11313  			JR      Z,OSCLI4
043FC5 D1          11314  			POP     DE
043FC6 18 E1       11315  			JR      OSCLI1
043FC8             11316  ;
043FC8 F1          11317  OSCLI4:			POP     AF
043FC9 13          11318  		        INC     DE
043FCA CB 7E       11319  OSCLI5:			BIT     7,(HL)
043FCC 23          11320  			INC     HL
043FCD 28 FB       11321  			JR      Z,OSCLI5
043FCF 7E          11322  			LD      A,(HL)
043FD0 23          11323  			INC     HL
043FD1 66          11324  			LD      H,(HL)
043FD2 6F          11325  			LD      L,A
043FD3 E5          11326  			PUSH    HL
043FD4 EB          11327  			EX      DE,HL
043FD5 C3 04 40 04 11328  			JP      SKIPSP
043FD9             11329  ;
043FD9 EB          11330  OSCLI6:			EX	DE, HL			; HL: Buffer for command
043FDA 11 00 4A 04 11331  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
043FDE D5          11332  			PUSH	DE			; Store buffer address
043FDF CD 2B 3E 04 11333  			CALL	CSTR_LINE		; Fetch the line
043FE3 E1          11334  			POP	HL			; HL: Pointer to command string in ACCS
043FE4 FD E5       11335  			PUSH	IY
043FE6             11336  			MOSCALL	mos_oscli		; Returns OSCLI error in A
043FE6 3E 10       0001M 			LD	A, function
043FE8 49 CF       0002M 			RST.LIS	08h
043FEA FD E1       11337  			POP	IY
043FEC B7          11338  			OR	A			; 0 means MOS returned OK
043FED C8          11339  			RET	Z			; So don't do anything
043FEE C3 17 42 04 11340  			JP 	OSERROR			; Otherwise it's a MOS error
043FF2             11341  
043FF2 3E FE       11342  HUH:    		LD      A,254			; Bad command error
043FF4 CD 77 37 04 11343          		CALL    EXTERR
043FF8 42 61 64 20 11344          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044003 00          11345          		DEFB    0
044004             11346  
044004 7E          11347  SKIPSP:			LD      A,(HL)
044005 FE 20       11348          		CP      ' '
044007 C0          11349          		RET     NZ
044008 23          11350          		INC     HL
044009 18 F9       11351          		JR      SKIPSP
04400B             11352  
04400B E6 7F       11353  UPPRC:  		AND     7FH
04400D FE 60       11354  			CP      '`'
04400F D8          11355  			RET     C
044010 E6 5F       11356  			AND     5FH			; CONVERT TO UPPER CASE
044012 C9          11357  			RET
044013             11358  
044013             11359  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044013             11360  ; These must be in alphabetical order
044013             11361  ;
044013             11362  ; BEGIN NOT FOUND IN BINARY
044013             11363  ; COMDS:  		DB	"AS","M"+80h		; ASM
044013             11364  ; 			DW	STAR_ASM
044013             11365  ; 			DB	"BY","E"+80h		; BYE
044013             11366  ; 			DW	STAR_BYE
044013             11367  ; 			DB	"EDI","T"+80h		; EDIT
044013             11368  ; 			DW	STAR_EDIT
044013             11369  ; 			DB	"F","X"+80h		; FX
044013             11370  ; 			DW	STAR_FX
044013             11371  ; 			DB	"VERSIO","N"+80h	; VERSION
044013             11372  ; 			DW	STAR_VERSION
044013             11373  ; 			DB	FFh
044013             11374  ; END NOT FOUND IN BINARY
044013             11375  ; BEGIN INSERTED FROM BINARY
044013             11376  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044013             11377  ; These must be in alphabetical order
044013             11378  ;
044013             11379  COMDS:
044013 42          11380  	db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
044014 59          11381  	db 0x59 ; 044014
044015 C5          11382  	db 0xc5 ; 044015
044016 2C          11383  	db 0x2c ; 044016 31     11405 DW	STAR_ASM
044017 40          11384  	db 0x40 ; 044017
044018 45          11385  	db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
044019 44          11386  	db 0x44 ; 044019
04401A 49          11387  	db 0x49 ; 04401A
04401B D4          11388  	db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
04401C 61          11389  	db 0x61 ; 04401C
04401D 40          11390  	db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
04401E 46          11391  	db 0x46 ; 04401E
04401F D8          11392  	db 0xd8 ; 04401F
044020 A1          11393  	db 0xa1 ; 044020
044021 40          11394  	db 0x40 ; 044021 72     11409 DW	STAR_EDIT
044022 56          11395  	db 0x56 ; 044022
044023 45          11396  	db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
044024 52          11397  	db 0x52 ; 044024
044025 53          11398  	db 0x53 ; 044025 B2     11411 DW	STAR_FX
044026 49          11399  	db 0x49 ; 044026
044027 4F          11400  	db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
044028 CE          11401  	db 0xce ; 044028
044029 38          11402  	db 0x38 ; 044029
04402A 40          11403  	db 0x40 ; 04402A
04402B FF          11404  	db 0xff ; 04402B
04402C             11405  ; END INSERTED FROM BINARY
04402C             11406  
04402C             11407  ; BEGIN NOT FOUND IN BINARY
04402C             11408  ; ; *ASM string
04402C             11409  ; ;
04402C             11410  ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
04402C             11411  ; 			PUSH	HL			; HL = IY
04402C             11412  ; 			POP	IY
04402C             11413  ; 			CALL	ASSEM			; Invoke the assembler
04402C             11414  ; 			POP	IY
04402C             11415  ; 			RET
04402C             11416  ; END NOT FOUND IN BINARY
04402C             11417  
04402C             11418  ; *BYE
04402C             11419  ;
04402C CD F4 48 04 11420  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044030 21 00 00 00 11421  			LD	HL, 0			; The return value
044034 C3 68 00 04 11422  			JP	_end 			; Jump back to the end routine in init.asm
044038             11423  
044038             11424  ; *VERSION
044038             11425  ;
044038 CD 90 3D 04 11426  STAR_VERSION:		CALL    TELL			; Output the welcome message
04403C 42 42 43 20 11427  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
044060 C9          11428  			RET
044061             11429  
044061             11430  ; *EDIT linenum
044061             11431  ;
044061 CD 97 3D 04 11432  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
044065 EB          11433  			EX	DE, HL			; HL: Line number
044066 CD 8F 39 04 11434  			CALL	FINDL			; HL: Address in RAM of tokenised line
04406A 3E 29       11435  			LD	A, 41			; F:NZ If the line is not found
04406C C2 60 37 04 11436  			JP	NZ, ERROR_		; Do error 41: No such line in that case
044070             11437  ;
044070             11438  ; Use LISTIT to output the line to the ACCS buffer
044070             11439  ;
044070 23          11440  			INC	HL			; Skip the length byte
044071 5E          11441  			LD	E, (HL)			; Fetch the line number
044072 23          11442  			INC	HL
044073 56          11443  			LD	D, (HL)
044074 23          11444  			INC	HL
044075 DD 21 00 4A 11445  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
04407A DD 22 43 4D 11446  			LD	(OSWRCHPT), IX
       04          
04407F DD 21 40 4D 11447  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
044084 DD 7E 00    11448  			LD	A, (IX)			; Store that variable
044087 F5          11449  			PUSH	AF
044088 DD 36 00 09 11450  			LD	(IX), 09h		; Set to echo to buffer
04408C CD 92 38 04 11451  			CALL	LISTIT
044090 F1          11452  			POP	AF
044091 DD 77 00    11453  			LD	(IX), A			; Restore the original LISTON variable
044094 21 00 4A 04 11454  			LD	HL, ACCS		; HL: ACCS
044098 5D          11455  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044099 CD 61 3E 04 11456  			CALL	OSLINE1			; Invoke the editor
04409D C3 D0 30 04 11457  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0440A1             11458  
0440A1             11459  ; OSCLI FX n
0440A1             11460  ;
0440A1 CD 97 3D 04 11461  STAR_FX:		CALL	ASC_TO_NUMBER
0440A5 4B          11462  			LD	C, E			; C: Save FX #
0440A6 CD 97 3D 04 11463  			CALL	ASC_TO_NUMBER
0440AA 7A          11464  			LD	A, D  			; Is first parameter > 255?
0440AB B7          11465  			OR 	A
0440AC 28 03       11466  			JR	Z, STAR_FX1		; Yes, so skip next bit
0440AE EB          11467  			EX	DE, HL 			; Parameter is 16-bit
0440AF 18 07       11468  			JR	STAR_FX2
0440B1             11469  ;
0440B1 43          11470  STAR_FX1:		LD	B, E 			; B: Save First parameter
0440B2 CD 97 3D 04 11471  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0440B6 68          11472  			LD	L, B 			; L: First parameter
0440B7 63          11473  			LD	H, E 			; H: Second parameter
0440B8             11474  ;
0440B8 79          11475  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0440B9             11476  ;
0440B9             11477  ; OSBYTE
0440B9             11478  ;  A: FX #
0440B9             11479  ;  L: First parameter
0440B9             11480  ;  H: Second parameter
0440B9             11481  ;
0440B9 FE 0B       11482  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0440BB 28 18       11483  			JR	Z, OSBYTE_0B
0440BD FE 0C       11484  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0440BF 28 43       11485  			JR	Z, OSBYTE_0C
0440C1 FE 13       11486  			CP	13H			; *FX 19: Wait for vblank
0440C3 28 6E       11487  			JR	Z, OSBYTE_13
0440C5 FE 76       11488  			CP	76H			; *FX 118, n: Set keyboard LED
0440C7 CA 4E 41 04 11489  			JP	Z, OSBYTE_76
0440CB FE A0       11490  			CP	A0H
0440CD CA 7E 41 04 11491  			JP	Z, OSBYTE_A0
0440D1 C3 F2 3F 04 11492  			JP	HUH			; Anything else trips an error
0440D5             11493  
0440D5             11494  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0440D5             11495  ; Parameters:
0440D5             11496  ; - HL: Repeat delay
0440D5             11497  ;
0440D5             11498  OSBYTE_0B:		VDU	23
0440D5 3E 17       0001M 		LD	A, val
0440D7 CD 00 3F 04 0002M 		CALL	OSWRCH
0440DB             11499  			VDU	0
0440DB 3E 00       0001M 		LD	A, val
0440DD CD 00 3F 04 0002M 		CALL	OSWRCH
0440E1             11500  			VDU	vdp_keystate
0440E1 3E 88       0001M 		LD	A, val
0440E3 CD 00 3F 04 0002M 		CALL	OSWRCH
0440E7             11501  			VDU	L
0440E7 7D          0001M 		LD	A, val
0440E8 CD 00 3F 04 0002M 		CALL	OSWRCH
0440EC             11502  			VDU	H
0440EC 7C          0001M 		LD	A, val
0440ED CD 00 3F 04 0002M 		CALL	OSWRCH
0440F1             11503  			VDU	0
0440F1 3E 00       0001M 		LD	A, val
0440F3 CD 00 3F 04 0002M 		CALL	OSWRCH
0440F7             11504  			VDU 	0
0440F7 3E 00       0001M 		LD	A, val
0440F9 CD 00 3F 04 0002M 		CALL	OSWRCH
0440FD             11505  			VDU	255
0440FD 3E FF       0001M 		LD	A, val
0440FF CD 00 3F 04 0002M 		CALL	OSWRCH
044103 C9          11506  			RET
044104             11507  
044104             11508  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
044104             11509  ; Parameters:
044104             11510  ; - HL: Repeat rate
044104             11511  ;
044104             11512  OSBYTE_0C:		VDU	23
044104 3E 17       0001M 		LD	A, val
044106 CD 00 3F 04 0002M 		CALL	OSWRCH
04410A             11513  			VDU	0
04410A 3E 00       0001M 		LD	A, val
04410C CD 00 3F 04 0002M 		CALL	OSWRCH
044110             11514  			VDU	vdp_keystate
044110 3E 88       0001M 		LD	A, val
044112 CD 00 3F 04 0002M 		CALL	OSWRCH
044116             11515  			VDU	0
044116 3E 00       0001M 		LD	A, val
044118 CD 00 3F 04 0002M 		CALL	OSWRCH
04411C             11516  			VDU 	0
04411C 3E 00       0001M 		LD	A, val
04411E CD 00 3F 04 0002M 		CALL	OSWRCH
044122             11517  			VDU	L
044122 7D          0001M 		LD	A, val
044123 CD 00 3F 04 0002M 		CALL	OSWRCH
044127             11518  			VDU	H
044127 7C          0001M 		LD	A, val
044128 CD 00 3F 04 0002M 		CALL	OSWRCH
04412C             11519  			VDU	255
04412C 3E FF       0001M 		LD	A, val
04412E CD 00 3F 04 0002M 		CALL	OSWRCH
044132 C9          11520  			RET
044133             11521  
044133             11522  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
044133             11523  ;
044133 CD 3D 41 04 11524  OSBYTE_13:		CALL	WAIT_VBLANK
044137 2E 00       11525  			LD	L, 0			; Returns 0
044139 C3 7F 05 04 11526  			JP	COUNT0
04413D             11527  ;
04413D DD E5       11528  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
04413F             11529  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
04413F 3E 08       0001M 			LD	A, function
044141 49 CF       0002M 			RST.LIS	08h
044143 DD 7E 00    11530  			LD	A, (IX + sysvar_time + 0)
044146 DD BE 00    11531  @@:			CP 	A, (IX + sysvar_time + 0)
044149 28 FB       11532  			JR	Z, @B
04414B DD E1       11533  			POP	IX
04414D C9          11534  			RET
04414E             11535  
04414E             11536  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
04414E             11537  ; Parameters:
04414E             11538  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
04414E             11539  ;
04414E             11540  OSBYTE_76:		VDU	23
04414E 3E 17       0001M 		LD	A, val
044150 CD 00 3F 04 0002M 		CALL	OSWRCH
044154             11541  			VDU	0
044154 3E 00       0001M 		LD	A, val
044156 CD 00 3F 04 0002M 		CALL	OSWRCH
04415A             11542  			VDU	vdp_keystate
04415A 3E 88       0001M 		LD	A, val
04415C CD 00 3F 04 0002M 		CALL	OSWRCH
044160             11543  			VDU	0
044160 3E 00       0001M 		LD	A, val
044162 CD 00 3F 04 0002M 		CALL	OSWRCH
044166             11544  			VDU 	0
044166 3E 00       0001M 		LD	A, val
044168 CD 00 3F 04 0002M 		CALL	OSWRCH
04416C             11545  			VDU	0
04416C 3E 00       0001M 		LD	A, val
04416E CD 00 3F 04 0002M 		CALL	OSWRCH
044172             11546  			VDU	0
044172 3E 00       0001M 		LD	A, val
044174 CD 00 3F 04 0002M 		CALL	OSWRCH
044178             11547  			VDU	L
044178 7D          0001M 		LD	A, val
044179 CD 00 3F 04 0002M 		CALL	OSWRCH
04417D C9          11548  			RET
04417E             11549  
04417E             11550  ; OSBYTE 0xA0: Fetch system variable
04417E             11551  ; Parameters:
04417E             11552  ; - L: The system variable to fetch
04417E             11553  ;
04417E DD E5       11554  OSBYTE_A0:		PUSH	IX
044180             11555  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044180 3E 08       0001M 			LD	A, function
044182 49 CF       0002M 			RST.LIS	08h
044184 01 00 00 00 11556  			LD	BC, 0
044188 4D          11557  			LD	C, L			; BCU = L
044189 DD 09       11558  			ADD	IX, BC			; Add to IX
04418B DD 6E 00    11559  			LD	L, (IX + 0)		; Fetch the return value
04418E DD E1       11560  			POP	IX
044190 C3 7F 05 04 11561  			JP 	COUNT0
044194             11562  
044194             11563  ;OSLOAD - Load an area of memory from a file.
044194             11564  ;   Inputs: HL addresses filename (CR terminated)
044194             11565  ;           DE = address at which to load
044194             11566  ;           BC = maximum allowed size (bytes)
044194             11567  ;  Outputs: Carry reset indicates no room for file.
044194             11568  ; Destroys: A,B,C,D,E,H,L,F
044194             11569  ;
044194 C5          11570  OSLOAD:			PUSH	BC			; Stack the size
044195 D5          11571  			PUSH	DE			; Stack the load address
044196 11 00 4A 04 11572  			LD	DE, ACCS		; Buffer address for filename
04419A CD 19 3E 04 11573  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04419E 21 00 4A 04 11574  			LD	HL, ACCS		; HL: Filename
0441A2 CD 94 42 04 11575  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0441A6 CD A8 42 04 11576  			CALL	EXT_HANDLER		; Get the default handler
0441AA D1          11577  			POP	DE			; Restore the load address
0441AB C1          11578  			POP	BC			; Restore the size
0441AC B7          11579  			OR	A
0441AD 28 60       11580  			JR 	Z, OSLOAD_BBC
0441AF             11581  ;
0441AF             11582  ; Load the file in as a text file
0441AF             11583  ;
0441AF AF          11584  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0441B0 CD 1C 43 04 11585  			CALL	OSOPEN			; Open the file
0441B4 5F          11586  			LD 	E, A 			; The filehandle
0441B5 B7          11587  			OR	A
0441B6 3E 04       11588  			LD	A, 4			; File not found error
0441B8 28 5D       11589  			JR	Z, OSERROR		; Jump to error handler
0441BA CD 6C 38 04 11590  			CALL	NEWIT			; Call NEW to clear the program space
0441BE             11591  ;
0441BE 21 00 4A 04 11592  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0441C2             11593  ;
0441C2             11594  ; First skip any whitespace (indents) at the beginning of the input
0441C2             11595  ;
0441C2 CD 33 43 04 11596  @@:			CALL	OSBGET			; Read the byte into A
0441C6 38 1E       11597  			JR	C, OSLOAD_TXT3		; Is it EOF?
0441C8 FE 0A       11598  			CP	LF 			; Is it LF?
0441CA 28 1A       11599  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0441CC FE 21       11600  			CP	21h			; Is it less than or equal to ASCII space?
0441CE 38 F2       11601  			JR	C, @B 			; Yes, so keep looping
0441D0 77          11602  			LD	(HL), A 		; Store the first character
0441D1 2C          11603  			INC	L
0441D2             11604  ;
0441D2             11605  ; Now read the rest of the line in
0441D2             11606  ;
0441D2 CD 33 43 04 11607  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0441D6 38 2B       11608  			JR	C, OSLOAD_TXT4		; Is it EOF?
0441D8 FE 20       11609  			CP	20h			; Skip if not an ASCII character
0441DA 38 06       11610  			JR	C, @F
0441DC 77          11611  			LD	(HL), A 		; Store in the input buffer
0441DD 2C          11612  			INC	L			; Increment the buffer pointer
0441DE CA F8 36 04 11613  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0441E2 FE 0A       11614  @@:			CP	LF			; Check for LF
0441E4 20 EC       11615  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0441E6             11616  ;
0441E6             11617  ; Finally, handle EOL/EOF
0441E6             11618  ;
0441E6 36 0D       11619  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0441E8 7D          11620  			LD	A, L			; Check for minimum line length
0441E9 FE 02       11621  			CP	2			; If it is 2 characters or less (including CR)
0441EB 38 0A       11622  			JR	C, @F			; Then don't bother entering it
0441ED D5          11623  			PUSH	DE			; Preserve the filehandle
0441EE CD DC 30 04 11624  			CALL	ONEDIT1			; Enter the line in memory
0441F2 DC 3F 38 04 11625  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0441F6 D1          11626  			POP	DE
0441F7 CD 44 43 04 11627  @@:			CALL	OSSTAT			; End of file?
0441FB 20 C1       11628  			JR	NZ, OSLOAD_TXT1		; No, so loop
0441FD CD 2B 43 04 11629  			CALL	OSSHUT			; Close the file
044201 37          11630  			SCF				; Flag to BASIC that we're good
044202 C9          11631  			RET
044203             11632  ;
044203             11633  ; Special case for BASIC programs with no blank line at the end
044203             11634  ;
044203 FE 20       11635  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044205 38 06       11636  			JR	C, @F
044207 77          11637  			LD	(HL), A			; Store the character
044208 2C          11638  			INC	L
044209 CA F8 36 04 11639  			JP	Z, BAD
04420D 18 D7       11640  @@:			JR	OSLOAD_TXT3
04420F             11641  
04420F             11642  ;
04420F             11643  ; Load the file in as a tokenised binary blob
04420F             11644  ;
04420F             11645  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
04420F 3E 01       0001M 			LD	A, function
044211 49 CF       0002M 			RST.LIS	08h
044213 D0          11646  			RET	NC			; If load returns with carry reset - NO ROOM
044214 B7          11647  			OR	A			; If there is no error (A=0)
044215 37          11648  			SCF				; Need to set carry indicating there was room
044216 C8          11649  			RET	Z			; Return
044217             11650  ;
044217 F5          11651  OSERROR:		PUSH	AF			; Handle the MOS error
044218 21 00 4A 04 11652  			LD	HL, ACCS		; Address of the buffer
04421C 01 00 01 00 11653  			LD	BC, 256			; Length of the buffer
044220 5F          11654  			LD	E, A			; The error code
044221             11655  			MOSCALL	mos_getError		; Copy the error message into the buffer
044221 3E 0F       0001M 			LD	A, function
044223 49 CF       0002M 			RST.LIS	08h
044225 F1          11656  			POP	AF
044226 E5          11657  			PUSH	HL			; Stack the address of the error (now in ACCS)
044227 C6 7F       11658  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044229 C3 77 37 04 11659  			JP	EXTERR			; Trigger an external error
04422D             11660  
04422D             11661  ;OSSAVE - Save an area of memory to a file.
04422D             11662  ;   Inputs: HL addresses filename (term CR)
04422D             11663  ;           DE = start address of data to save
04422D             11664  ;           BC = length of data to save (bytes)
04422D             11665  ; Destroys: A,B,C,D,E,H,L,F
04422D             11666  ;
04422D C5          11667  OSSAVE:			PUSH	BC			; Stack the size
04422E D5          11668  			PUSH	DE			; Stack the save address
04422F 11 00 4A 04 11669  			LD	DE, ACCS		; Buffer address for filename
044233 CD 19 3E 04 11670  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044237 21 00 4A 04 11671  			LD	HL, ACCS		; HL: Filename
04423B CD 94 42 04 11672  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04423F CD A8 42 04 11673  			CALL	EXT_HANDLER		; Get the default handler
044243 D1          11674  			POP	DE			; Restore the save address
044244 C1          11675  			POP	BC			; Restore the size
044245 B7          11676  			OR	A			; Is the extension .BBC
044246 28 44       11677  			JR	Z, OSSAVE_BBC		; Yes, so use that
044248             11678  ;
044248             11679  ; Save the file out as a text file
044248             11680  ;
044248 3A 45 4D 04 11681  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
04424C F5          11682  			PUSH	AF
04424D AF          11683  			XOR	A
04424E 3C          11684  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
04424F 32 45 4D 04 11685  			LD	(OSWRCHCH), A
044253 CD 1C 43 04 11686  			CALL	OSOPEN			; Open the file
044257 32 46 4D 04 11687  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
04425B DD 21 40 4D 11688  			LD	IX, LISTON		; Required for LISTIT
       04          
044260 2A 14 4D 04 11689  			LD	HL, (PAGE_)		; Get start of program area
044264 D9          11690  			EXX
044265 01 00 00 00 11691  			LD	BC, 0			; Set the initial indent counters
044269 D9          11692  			EXX
04426A 7E          11693  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
04426B B7          11694  			OR	A
04426C 28 0F       11695  			JR	Z, OSSAVE_TXT2
04426E 23          11696  			INC	HL			; Skip the length byte
04426F 11 00 00 00 11697  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
044273 5E          11698  			LD	E, (HL)			; Get the line number
044274 23          11699  			INC	HL
044275 56          11700  			LD	D, (HL)
044276 23          11701  			INC	HL
044277 CD 92 38 04 11702  			CALL	LISTIT			; List the line
04427B 18 ED       11703  			JR	OSSAVE_TXT1
04427D 3A 46 4D 04 11704  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
044281 5F          11705  			LD	E, A
044282 CD 2B 43 04 11706  			CALL	OSSHUT			; Close it
044286 F1          11707  			POP	AF			; Restore the channel
044287 32 45 4D 04 11708  			LD	(OSWRCHCH), A
04428B C9          11709  			RET
04428C             11710  ;
04428C             11711  ; Save the file out as a tokenised binary blob
04428C             11712  ;
04428C             11713  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
04428C 3E 02       0001M 			LD	A, function
04428E 49 CF       0002M 			RST.LIS	08h
044290 B7          11714  			OR	A			; If there is no error (A=0)
044291 C8          11715  			RET	Z			; Just return
044292 18 83       11716  			JR	OSERROR			; Trip an error
044294             11717  
044294             11718  ; Check if an extension is specified in the filename
044294             11719  ; Add a default if not specified
044294             11720  ; HL: Filename (CSTR format)
044294             11721  ;
044294 E5          11722  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044295 0E 2E       11723  			LD	C, '.'			; Search for dot (marks start of extension)
044297 CD 39 3E 04 11724  			CALL	CSTR_FINDCH
04429B B7          11725  			OR	A			; Check for end of string marker
04429C 20 08       11726  			JR	NZ, @F			; No, so skip as we have an extension at this point
04429E 11 D8 42 04 11727  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0442A2 CD 50 3E 04 11728  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0442A6 E1          11729  @@:			POP	HL			; Restore the filename pointer
0442A7 C9          11730  			RET
0442A8             11731  
0442A8             11732  ; Check if an extension is valid and, if so, provide a pointer to a handler
0442A8             11733  ; HL: Filename (CSTR format)
0442A8             11734  ; Returns:
0442A8             11735  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0442A8             11736  ;
0442A8 E5          11737  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0442A9 0E 2E       11738  			LD	C, '.'			; Find the '.'
0442AB CD 39 3E 04 11739  			CALL	CSTR_FINDCH
0442AF 11 D8 42 04 11740  			LD	DE, EXT_LOOKUP		; The lookup table
0442B3             11741  ;
0442B3 E5          11742  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0442B4 CD 41 3E 04 11743  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0442B8 E1          11744  			POP	HL			; Restore the pointer to the extension
0442B9 28 19       11745  			JR	Z, EXT_HANDLER_2	; We have a match!
0442BB             11746  ;
0442BB 1A          11747  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0442BC 13          11748  			INC	DE
0442BD B7          11749  			OR	A
0442BE 20 FB       11750  			JR	NZ, @B
0442C0 13          11751  			INC	DE			; Skip the file extension # byte
0442C1             11752  ;
0442C1 1A          11753  			LD	A, (DE)			; Are we at the end of the table?
0442C2 B7          11754  			OR	A
0442C3 20 EE       11755  			JR	NZ, EXT_HANDLER_1	; No, so loop
0442C5             11756  ;
0442C5 3E CC       11757  			LD      A,204			; Throw a "Bad name" error
0442C7 CD 77 37 04 11758          		CALL    EXTERR
0442CB 42 61 64 20 11759          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0442D4             11760  ;
0442D4 13          11761  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0442D5 1A          11762  			LD	A, (DE)
0442D6 E1          11763  			POP	HL			; Restore the filename pointer
0442D7 C9          11764  			RET
0442D8             11765  ;
0442D8             11766  
0442D8             11767  
0442D8             11768  ; Extension lookup table
0442D8             11769  ; CSTR, TYPE
0442D8             11770  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0442D8             11771  ; 	- 1: Human readable plain text
0442D8             11772  ;
0442D8 2E 42 42 43 11773  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0442DE 2E 54 58 54 11774  			DB	".TXT", 0, 1
       00 01       
0442E4 2E 41 53 43 11775  			DB	".ASC", 0, 1
       00 01       
0442EA 2E 42 41 53 11776  			DB	".BAS", 0, 1
       00 01       
0442F0 00          11777  			DB	0			; End of table
0442F1             11778  
0442F1             11779  ;OSCALL - Intercept page &FF calls and provide an alternative address
0442F1             11780  ;
0442F1             11781  ;&FFF7:	OSCLI	Execute *command.
0442F1             11782  ;&FFF4:	OSBYTE	Various byte-wide functions.
0442F1             11783  ;&FFF1:	OSWORD	Various control block functions.
0442F1             11784  ;&FFEE:	OSWRCH	Write character to output stream.
0442F1             11785  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0442F1             11786  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0442F1             11787  ;&FFE0:	OSRDCH	Wait for character from input stream.
0442F1             11788  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0442F1             11789  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0442F1             11790  ;&FFD7:	OSBGET	Read a byte from an a channel.
0442F1             11791  ;&FFD4:	OSBPUT	Write a byte to a channel.
0442F1             11792  ;&FFD1:	OSGBPB	Read and write blocks of data.
0442F1             11793  ;&FFCE:	OSFIND	Open or close a file.
0442F1             11794  ;
0442F1 21 07 43 04 11795  OSCALL:			LD	HL, OSCALL_TABLE
0442F5 7E          11796  OSCALL_1:		LD	A, (HL)
0442F6 23          11797  			INC	HL
0442F7 FE FF       11798  			CP	FFh
0442F9 C8          11799  			RET	Z
0442FA FD BD       11800  			CP	A, IYL
0442FC 28 06       11801  			JR	Z, OSCALL_2
0442FE D0          11802  			RET	NC
0442FF 23          11803  			INC	HL
044300 23          11804  			INC	HL
044301 23          11805  			INC	HL
044302 18 F1       11806  			JR	OSCALL_1
044304 ED 31       11807  OSCALL_2:		LD	IY,(HL)
044306 C9          11808  			RET
044307 D4          11809  OSCALL_TABLE:		DB 	D4h
044308 3B 43 04    11810  			DW24 	OSBPUT
04430B D7          11811  			DB 	D7h
04430C 33 43 04    11812  			DW24 	OSBGET
04430F EE          11813  			DB 	EEh
044310 00 3F 04    11814  			DW24 	OSWRCH
044313 F4          11815  			DB	F4h
044314 B9 40 04    11816  			DW24 	OSBYTE
044317 F7          11817  			DB	F7h
044318 90 3F 04    11818  			DW24	OSCLI
04431B FF          11819  			DB	FFh
04431C             11820  
04431C             11821  ; OSOPEN
04431C             11822  ; HL: Pointer to path
04431C             11823  ;  F: C Z
04431C             11824  ;     x x OPENIN
04431C             11825  ; 	  OPENOUT
04431C             11826  ;     x	  OPENUP
04431C             11827  ; Returns:
04431C             11828  ;  A: Filehandle, 0 if cannot open
04431C             11829  ;
04431C 0E 01       11830  OSOPEN:			LD	C, fa_read
04431E 28 06       11831  			JR	Z, @F
044320 0E 32       11832  			LD	C, fa_write | fa_open_append
044322 38 02       11833  			JR	C, @F
044324 0E 0A       11834  			LD	C, fa_write | fa_create_always
044326             11835  @@:			MOSCALL	mos_fopen
044326 3E 0A       0001M 			LD	A, function
044328 49 CF       0002M 			RST.LIS	08h
04432A C9          11836  			RET
04432B             11837  
04432B             11838  ;OSSHUT - Close disk file(s).
04432B             11839  ; E = file channel
04432B             11840  ;  If E=0 all files are closed (except SPOOL)
04432B             11841  ; Destroys: A,B,C,D,E,H,L,F
04432B             11842  ;
04432B C5          11843  OSSHUT:			PUSH	BC
04432C 4B          11844  			LD	C, E
04432D             11845  			MOSCALL	mos_fclose
04432D 3E 0B       0001M 			LD	A, function
04432F 49 CF       0002M 			RST.LIS	08h
044331 C1          11846  			POP	BC
044332 C9          11847  			RET
044333             11848  
044333             11849  ; OSBGET - Read a byte from a random disk file.
044333             11850  ;  E = file channel
044333             11851  ; Returns
044333             11852  ;  A = byte read
044333             11853  ;  Carry set if LAST BYTE of file
044333             11854  ; Destroys: A,B,C,F
044333             11855  ;
044333 C5          11856  OSBGET:			PUSH	BC
044334 4B          11857  			LD	C, E
044335             11858  			MOSCALL	mos_fgetc
044335 3E 0C       0001M 			LD	A, function
044337 49 CF       0002M 			RST.LIS	08h
044339 C1          11859  			POP	BC
04433A C9          11860  			RET
04433B             11861  
04433B             11862  ; OSBPUT - Write a byte to a random disk file.
04433B             11863  ;  E = file channel
04433B             11864  ;  A = byte to write
04433B             11865  ; Destroys: A,B,C,F
04433B             11866  ;
04433B C5          11867  OSBPUT:			PUSH	BC
04433C 4B          11868  			LD	C, E
04433D 47          11869  			LD	B, A
04433E             11870  			MOSCALL	mos_fputc
04433E 3E 0D       0001M 			LD	A, function
044340 49 CF       0002M 			RST.LIS	08h
044342 C1          11871  			POP	BC
044343 C9          11872  			RET
044344             11873  
044344             11874  ; OSSTAT - Read file status
044344             11875  ;  E = file channel
044344             11876  ; Returns
044344             11877  ;  F: Z flag set - EOF
044344             11878  ;  A: If Z then A = 0
044344             11879  ; Destroys: A,D,E,H,L,F
044344             11880  ;
044344 C5          11881  OSSTAT:			PUSH	BC
044345 4B          11882  			LD	C, E
044346             11883  			MOSCALL	mos_feof
044346 3E 0E       0001M 			LD	A, function
044348 49 CF       0002M 			RST.LIS	08h
04434A C1          11884  			POP	BC
04434B FE 01       11885  			CP	1
04434D C9          11886  			RET
04434E             11887  
04434E             11888  ; GETPTR - Return file pointer.
04434E             11889  ;    E = file channel
04434E             11890  ; Returns:
04434E             11891  ; DEHL = pointer (0-&7FFFFF)
04434E             11892  ; Destroys: A,B,C,D,E,H,L,F
04434E             11893  ;
04434E FD E5       11894  GETPTR:			PUSH		IY
044350 4B          11895  			LD		C, E
044351             11896  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044351 3E 19       0001M 			LD	A, function
044353 49 CF       0002M 			RST.LIS	08h
044355 E5          11897  			PUSH		HL
044356 FD E1       11898  			POP		IY		; IYU: Pointer to FIL structure
044358 FD 6E 11    11899  			LD		L, (IY + FIL.fptr + 0)
04435B FD 66 12    11900  			LD		H, (IY + FIL.fptr + 1)
04435E FD 5E 13    11901  			LD		E, (IY + FIL.fptr + 2)
044361 FD 56 14    11902  			LD		D, (IY + FIL.fptr + 3)
044364 FD E1       11903  			POP		IY
044366 C9          11904  			RET
044367             11905  
044367             11906  ; PUTPTR - Update file pointer.
044367             11907  ;    A = file channel
044367             11908  ; DEHL = new pointer (0-&7FFFFF)
044367             11909  ; Destroys: A,B,C,D,E,H,L,F
044367             11910  ;
044367 FD E5       11911  PUTPTR:			PUSH		IY
044369 4F          11912  			LD		C, A  		; C: Filehandle
04436A E5          11913  			PUSH		HL
04436B 21 02 00 00 11914  			LD		HL, 2
04436F 39          11915  			ADD		HL, SP
044370 73          11916  			LD		(HL), E 	; 3rd byte of DWORD set to E
044371 E1          11917  			POP		HL
044372 5A          11918  			LD		E, D  		; 4th byte passed as E
044373             11919  			MOSCALL		mos_flseek
044373 3E 1C       0001M 			LD	A, function
044375 49 CF       0002M 			RST.LIS	08h
044377 FD E1       11920  			POP		IY
044379 C9          11921  			RET
04437A             11922  
04437A             11923  ; GETEXT - Find file size.
04437A             11924  ;    E = file channel
04437A             11925  ; Returns:
04437A             11926  ; DEHL = file size (0-&800000)
04437A             11927  ; Destroys: A,B,C,D,E,H,L,F
04437A             11928  ;
04437A FD E5       11929  GETEXT:         PUSH    IY
04437C 4B          11930                  LD      C, E
04437D             11931                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
04437D 3E 19       0001M 			LD	A, function
04437F 49 CF       0002M 			RST.LIS	08h
044381 E5          11932                  PUSH    HL
044382 FD E1       11933                  POP     IY          ; IYU: Pointer to FIL structure
044384             11934                  ; Access the obj.objsize field using the offset values
044384 FD 6E 0B    11935                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
044387 FD 66 0C    11936                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
04438A FD 5E 0D    11937                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
04438D FD 56 0E    11938                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
044390             11939  
044390 FD E1       11940                  POP     IY
044392 C9          11941  			RET
044393             11942  
044393             11943  ; GETIMS - Get time from RTC
044393             11944  ;
044393 FD E5       11945  GETIMS:			PUSH	IY
044395 21 00 4A 04 11946  			LD	HL, ACCS 		; Where to store the time string
044399             11947  			MOSCALL	mos_getrtc
044399 3E 12       0001M 			LD	A, function
04439B 49 CF       0002M 			RST.LIS	08h
04439D 11 00 4A 04 11948  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0443A1 5F          11949  			LD	E, A 			;  E: now points to the end of the string
0443A2 FD E1       11950  			POP	IY
0443A4 C9          11951  			RET
0443A5             11952  
0443A5             11953  ; Get two word values from EXPR in DE, HL
0443A5             11954  ; IY: Pointer to expression string
0443A5             11955  ; Returns:
0443A5             11956  ; DE: P1
0443A5             11957  ; HL: P2
0443A5             11958  ;
0443A5 CD 0A 03 04 11959  EXPR_W2:		CALL	EXPRI			; Get first parameter
0443A9 D9          11960  			EXX
0443AA E5          11961  			PUSH	HL
0443AB CD 22 0A 04 11962  			CALL	COMMA
0443AF CD 0A 03 04 11963  			CALL	EXPRI			; Get second parameter
0443B3 D9          11964  			EXX
0443B4 D1          11965  			POP	DE
0443B5 C9          11966  			RET
0443B6             11967  
0443B6             11968  ; Stuff not implemented yet
0443B6             11969  ;
0443B6 C9          11970  RESET:			RET; --- End patch.asm ---
0443B7             11971  
0443B7             11972  ; --- Begin sorry.asm ---
0443B7             11973  ;
0443B7             11974  ; Title:	BBC Basic Interpreter - Z80 version
0443B7             11975  ;		Catch-all for unimplemented functionality
0443B7             11976  ; Author:	Dean Belfield
0443B7             11977  ; Created:	12/05/2023
0443B7             11978  ; Last Updated:	12/05/2023
0443B7             11979  ;
0443B7             11980  ; Modinfo:
0443B7             11981  
0443B7             11982  			; .ASSUME	ADL = 1
0443B7             11983  
0443B7             11984  			; SEGMENT CODE
0443B7             11985  
0443B7             11986  			; XDEF	ENVEL
0443B7             11987  			; XDEF	ADVAL
0443B7             11988  			; XDEF	PUTIMS
0443B7             11989  
0443B7             11990  			; XREF	EXTERR
0443B7             11991  
0443B7             11992  ENVEL:
0443B7             11993  ADVAL:
0443B7             11994  PUTIMS:
0443B7 AF          11995  			XOR     A
0443B8 CD 77 37 04 11996  			CALL    EXTERR
0443BC 53 6F 72 72 11997  			DEFB    "Sorry"
       79          
0443C1 00          11998  			DEFB    0
0443C2             11999  ; --- End sorry.asm ---
0443C2             12000  
0443C2             12001  ; --- Begin agon_graphics.asm ---
0443C2             12002  ;
0443C2             12003  ; Title:	BBC Basic for AGON - Graphics stuff
0443C2             12004  ; Author:	Dean Belfield
0443C2             12005  ; Created:	12/05/2023
0443C2             12006  ; Last Updated:	07/06/2023
0443C2             12007  ;
0443C2             12008  ; Modinfo:
0443C2             12009  ; 07/06/2023:	Modified to run in ADL mode
0443C2             12010  
0443C2             12011  			; .ASSUME	ADL = 1
0443C2             12012  
0443C2             12013  			; INCLUDE	"equs.inc"
0443C2             12014  			; INCLUDE "macros.inc"
0443C2             12015  			; INCLUDE "mos_api.inc"	; In MOS/src
0443C2             12016  
0443C2             12017  			; SEGMENT CODE
0443C2             12018  
0443C2             12019  			; XDEF	CLG
0443C2             12020  			; XDEF	CLRSCN
0443C2             12021  			; XDEF	MODE
0443C2             12022  			; XDEF	COLOUR
0443C2             12023  			; XDEF	GCOL
0443C2             12024  			; XDEF	MOVE
0443C2             12025  			; XDEF	PLOT
0443C2             12026  			; XDEF	DRAW
0443C2             12027  			; XDEF	POINT
0443C2             12028  			; XDEF	GETSCHR
0443C2             12029  
0443C2             12030  			; XREF	OSWRCH
0443C2             12031  			; XREF	ASC_TO_NUMBER
0443C2             12032  			; XREF	EXTERR
0443C2             12033  			; XREF	EXPRI
0443C2             12034  			; XREF	COMMA
0443C2             12035  			; XREF	XEQ
0443C2             12036  			; XREF	NXT
0443C2             12037  			; XREF	BRAKET
0443C2             12038  			; XREF	COUNT0
0443C2             12039  			; XREF	CRTONULL
0443C2             12040  			; XREF	NULLTOCR
0443C2             12041  			; XREF	CRLF
0443C2             12042  			; XREF	EXPR_W2
0443C2             12043  			; XREF	INKEY1
0443C2             12044  
0443C2             12045  ; CLG: clears the graphics area
0443C2             12046  ;
0443C2             12047  CLG:
0443C2             12048  
0443C2             12049  			VDU	10h
0443C2 3E 10       0001M 		LD	A, val
0443C4 CD 00 3F 04 0002M 		CALL	OSWRCH
0443C8 C3 96 0B 04 12050  			JP	XEQ
0443CC             12051  
0443CC             12052  ; CLS: clears the text area
0443CC             12053  ;
0443CC 3E 0C       12054  CLRSCN:			LD	A, 0Ch
0443CE C3 00 3F 04 12055  			JP	OSWRCH
0443D2             12056  
0443D2             12057  ; MODE n: Set video mode
0443D2             12058  ;
0443D2 DD E5       12059  MODE:			PUSH	IX			; Get the system vars in IX
0443D4             12060  			MOSCALL	mos_sysvars		; Reset the semaphore
0443D4 3E 08       0001M 			LD	A, function
0443D6 49 CF       0002M 			RST.LIS	08h
0443D8 DD CB 04 A6 12061  			RES	4, (IX+sysvar_vpd_pflags)
0443DC CD 0A 03 04 12062  			CALL    EXPRI
0443E0 D9          12063  			EXX
0443E1             12064  			VDU	16H			; Mode change
0443E1 3E 16       0001M 		LD	A, val
0443E3 CD 00 3F 04 0002M 		CALL	OSWRCH
0443E7             12065  			VDU	L
0443E7 7D          0001M 		LD	A, val
0443E8 CD 00 3F 04 0002M 		CALL	OSWRCH
0443EC             12066  			MOSCALL	mos_sysvars
0443EC 3E 08       0001M 			LD	A, function
0443EE 49 CF       0002M 			RST.LIS	08h
0443F0 DD CB 04 66 12067  @@:			BIT	4, (IX+sysvar_vpd_pflags)
0443F4 28 FA       12068  			JR	Z, @B			; Wait for the result
0443F6 DD E1       12069  			POP	IX
0443F8 C3 96 0B 04 12070  			JP	XEQ
0443FC             12071  
0443FC             12072  ; GET(x,y): Get the ASCII code of a character on screen
0443FC             12073  ;
0443FC FD 23       12074  GETSCHR:		INC	IY
0443FE CD 0A 03 04 12075  			CALL    EXPRI      		; Get X coordinate
044402 D9          12076  			EXX
044403 22 00 4A 04 12077  			LD	(VDU_BUFFER+0), HL
044407 CD 22 0A 04 12078  			CALL	COMMA
04440B CD 0A 03 04 12079  			CALL	EXPRI			; Get Y coordinate
04440F D9          12080  			EXX
044410 22 02 4A 04 12081  			LD	(VDU_BUFFER+2), HL
044414 CD 2F 0A 04 12082  			CALL	BRAKET			; Closing bracket
044418             12083  ;
044418 DD E5       12084  			PUSH	IX			; Get the system vars in IX
04441A             12085  			MOSCALL	mos_sysvars		; Reset the semaphore
04441A 3E 08       0001M 			LD	A, function
04441C 49 CF       0002M 			RST.LIS	08h
04441E DD CB 04 8E 12086  			RES	1, (IX+sysvar_vpd_pflags)
044422             12087  			VDU	23
044422 3E 17       0001M 		LD	A, val
044424 CD 00 3F 04 0002M 		CALL	OSWRCH
044428             12088  			VDU	0
044428 3E 00       0001M 		LD	A, val
04442A CD 00 3F 04 0002M 		CALL	OSWRCH
04442E             12089  			VDU	vdp_scrchar
04442E 3E 83       0001M 		LD	A, val
044430 CD 00 3F 04 0002M 		CALL	OSWRCH
044434             12090  			VDU	(VDU_BUFFER+0)
044434 3A 00 4A 04 0001M 		LD	A, val
044438 CD 00 3F 04 0002M 		CALL	OSWRCH
04443C             12091  			VDU	(VDU_BUFFER+1)
04443C 3A 01 4A 04 0001M 		LD	A, val
044440 CD 00 3F 04 0002M 		CALL	OSWRCH
044444             12092  			VDU	(VDU_BUFFER+2)
044444 3A 02 4A 04 0001M 		LD	A, val
044448 CD 00 3F 04 0002M 		CALL	OSWRCH
04444C             12093  			VDU	(VDU_BUFFER+3)
04444C 3A 03 4A 04 0001M 		LD	A, val
044450 CD 00 3F 04 0002M 		CALL	OSWRCH
044454 DD CB 04 4E 12094  @@:			BIT	1, (IX+sysvar_vpd_pflags)
044458 28 FA       12095  			JR	Z, @B			; Wait for the result
04445A DD 7E 09    12096  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
04445D B7          12097  			OR	A			; Check for 00h
04445E 37          12098  			SCF				; C = character map
04445F 20 02       12099  			JR	NZ, @F			; We have a character, so skip next bit
044461 AF          12100  			XOR	A			; Clear carry
044462 3D          12101  			DEC	A			; Set A to FFh
044463 DD E1       12102  @@:			POP	IX
044465 C3 E1 07 04 12103  			JP	INKEY1			; Jump back to the GET command
044469             12104  
044469             12105  ; POINT(x,y): Get the pixel colour of a point on screen
044469             12106  ;
044469 CD 0A 03 04 12107  POINT:			CALL    EXPRI      		; Get X coordinate
04446D D9          12108  			EXX
04446E 22 00 4A 04 12109  			LD	(VDU_BUFFER+0), HL
044472 CD 22 0A 04 12110  			CALL	COMMA
044476 CD 0A 03 04 12111  			CALL	EXPRI			; Get Y coordinate
04447A D9          12112  			EXX
04447B 22 02 4A 04 12113  			LD	(VDU_BUFFER+2), HL
04447F CD 2F 0A 04 12114  			CALL	BRAKET			; Closing bracket
044483             12115  ;
044483 DD E5       12116  			PUSH	IX			; Get the system vars in IX
044485             12117  			MOSCALL	mos_sysvars		; Reset the semaphore
044485 3E 08       0001M 			LD	A, function
044487 49 CF       0002M 			RST.LIS	08h
044489 DD CB 04 96 12118  			RES	2, (IX+sysvar_vpd_pflags)
04448D             12119  			VDU	23
04448D 3E 17       0001M 		LD	A, val
04448F CD 00 3F 04 0002M 		CALL	OSWRCH
044493             12120  			VDU	0
044493 3E 00       0001M 		LD	A, val
044495 CD 00 3F 04 0002M 		CALL	OSWRCH
044499             12121  			VDU	vdp_scrpixel
044499 3E 84       0001M 		LD	A, val
04449B CD 00 3F 04 0002M 		CALL	OSWRCH
04449F             12122  			VDU	(VDU_BUFFER+0)
04449F 3A 00 4A 04 0001M 		LD	A, val
0444A3 CD 00 3F 04 0002M 		CALL	OSWRCH
0444A7             12123  			VDU	(VDU_BUFFER+1)
0444A7 3A 01 4A 04 0001M 		LD	A, val
0444AB CD 00 3F 04 0002M 		CALL	OSWRCH
0444AF             12124  			VDU	(VDU_BUFFER+2)
0444AF 3A 02 4A 04 0001M 		LD	A, val
0444B3 CD 00 3F 04 0002M 		CALL	OSWRCH
0444B7             12125  			VDU	(VDU_BUFFER+3)
0444B7 3A 03 4A 04 0001M 		LD	A, val
0444BB CD 00 3F 04 0002M 		CALL	OSWRCH
0444BF DD CB 04 56 12126  @@:			BIT	2, (IX+sysvar_vpd_pflags)
0444C3 28 FA       12127  			JR	Z, @B			; Wait for the result
0444C5             12128  ;
0444C5             12129  ; Return the data as a 1 byte index
0444C5             12130  ;
0444C5 DD 6E 16    12131  			LD	L, (IX+sysvar_scrpixelIndex)
0444C8 DD E1       12132  			POP	IX
0444CA C3 7F 05 04 12133  			JP	COUNT0
0444CE             12134  
0444CE             12135  
0444CE             12136  ; COLOUR colour
0444CE             12137  ; COLOUR L,P
0444CE             12138  ; COLOUR L,R,G,B
0444CE             12139  ;
0444CE CD 0A 03 04 12140  COLOUR:			CALL	EXPRI			; The colour / mode
0444D2 D9          12141  			EXX
0444D3 7D          12142  			LD	A, L
0444D4 32 00 4A 04 12143  			LD	(VDU_BUFFER+0), A	; Store first parameter
0444D8 CD 70 0A 04 12144  			CALL	NXT			; Are there any more parameters?
0444DC FE 2C       12145  			CP	','
0444DE 28 12       12146  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0444E0             12147  ;
0444E0             12148  			VDU	11h			; Just set the colour
0444E0 3E 11       0001M 		LD	A, val
0444E2 CD 00 3F 04 0002M 		CALL	OSWRCH
0444E6             12149  			VDU	(VDU_BUFFER+0)
0444E6 3A 00 4A 04 0001M 		LD	A, val
0444EA CD 00 3F 04 0002M 		CALL	OSWRCH
0444EE C3 96 0B 04 12150  			JP	XEQ
0444F2             12151  ;
0444F2 CD 22 0A 04 12152  COLOUR_1:		CALL	COMMA
0444F6 CD 0A 03 04 12153  			CALL	EXPRI			; Parse R (OR P)
0444FA D9          12154  			EXX
0444FB 7D          12155  			LD	A, L
0444FC 32 01 4A 04 12156  			LD	(VDU_BUFFER+1), A
044500 CD 70 0A 04 12157  			CALL	NXT			; Are there any more parameters?
044504 FE 2C       12158  			CP	','
044506 28 2C       12159  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044508             12160  ;
044508             12161  			VDU	13h			; VDU:COLOUR
044508 3E 13       0001M 		LD	A, val
04450A CD 00 3F 04 0002M 		CALL	OSWRCH
04450E             12162  			VDU	(VDU_BUFFER+0)		; Logical Colour
04450E 3A 00 4A 04 0001M 		LD	A, val
044512 CD 00 3F 04 0002M 		CALL	OSWRCH
044516             12163  			VDU	(VDU_BUFFER+1)		; Palette Colour
044516 3A 01 4A 04 0001M 		LD	A, val
04451A CD 00 3F 04 0002M 		CALL	OSWRCH
04451E             12164  			VDU	0			; RGB set to 0
04451E 3E 00       0001M 		LD	A, val
044520 CD 00 3F 04 0002M 		CALL	OSWRCH
044524             12165  			VDU	0
044524 3E 00       0001M 		LD	A, val
044526 CD 00 3F 04 0002M 		CALL	OSWRCH
04452A             12166  			VDU	0
04452A 3E 00       0001M 		LD	A, val
04452C CD 00 3F 04 0002M 		CALL	OSWRCH
044530 C3 96 0B 04 12167  			JP	XEQ
044534             12168  ;
044534 CD 22 0A 04 12169  COLOUR_2:		CALL	COMMA
044538 CD 0A 03 04 12170  			CALL	EXPRI			; Parse G
04453C D9          12171  			EXX
04453D 7D          12172  			LD	A, L
04453E 32 02 4A 04 12173  			LD	(VDU_BUFFER+2), A
044542 CD 22 0A 04 12174  			CALL	COMMA
044546 CD 0A 03 04 12175  			CALL	EXPRI			; Parse B
04454A D9          12176  			EXX
04454B 7D          12177  			LD	A, L
04454C 32 03 4A 04 12178  			LD	(VDU_BUFFER+3), A
044550             12179  			VDU	13h			; VDU:COLOUR
044550 3E 13       0001M 		LD	A, val
044552 CD 00 3F 04 0002M 		CALL	OSWRCH
044556             12180  			VDU	(VDU_BUFFER+0)		; Logical Colour
044556 3A 00 4A 04 0001M 		LD	A, val
04455A CD 00 3F 04 0002M 		CALL	OSWRCH
04455E             12181  			VDU	FFh			; Physical Colour (-1 for RGB mode)
04455E 3E FF       0001M 		LD	A, val
044560 CD 00 3F 04 0002M 		CALL	OSWRCH
044564             12182  			VDU	(VDU_BUFFER+1)		; R
044564 3A 01 4A 04 0001M 		LD	A, val
044568 CD 00 3F 04 0002M 		CALL	OSWRCH
04456C             12183  			VDU	(VDU_BUFFER+2)		; G
04456C 3A 02 4A 04 0001M 		LD	A, val
044570 CD 00 3F 04 0002M 		CALL	OSWRCH
044574             12184  			VDU	(VDU_BUFFER+3)		; B
044574 3A 03 4A 04 0001M 		LD	A, val
044578 CD 00 3F 04 0002M 		CALL	OSWRCH
04457C C3 96 0B 04 12185  			JP	XEQ
044580             12186  
044580             12187  ; GCOL mode,colour
044580             12188  ;
044580 CD 0A 03 04 12189  GCOL:			CALL	EXPRI			; Parse MODE
044584 D9          12190  			EXX
044585 7D          12191  			LD	A, L
044586 32 00 4A 04 12192  			LD	(VDU_BUFFER+0), A
04458A CD 22 0A 04 12193  			CALL	COMMA
04458E             12194  ;
04458E CD 0A 03 04 12195  			CALL	EXPRI			; Parse Colour
044592 D9          12196  			EXX
044593 7D          12197  			LD	A, L
044594 32 01 4A 04 12198  			LD	(VDU_BUFFER+1), A
044598             12199  ;
044598             12200  			VDU	12h			; VDU:GCOL
044598 3E 12       0001M 		LD	A, val
04459A CD 00 3F 04 0002M 		CALL	OSWRCH
04459E             12201  			VDU	(VDU_BUFFER+0)		; Mode
04459E 3A 00 4A 04 0001M 		LD	A, val
0445A2 CD 00 3F 04 0002M 		CALL	OSWRCH
0445A6             12202  			VDU	(VDU_BUFFER+1)		; Colour
0445A6 3A 01 4A 04 0001M 		LD	A, val
0445AA CD 00 3F 04 0002M 		CALL	OSWRCH
0445AE C3 96 0B 04 12203  			JP	XEQ
0445B2             12204  
0445B2             12205  ; PLOT mode,x,y
0445B2             12206  ;
0445B2 CD 0A 03 04 12207  PLOT:			CALL	EXPRI		; Parse mode
0445B6 D9          12208  			EXX
0445B7 E5          12209  			PUSH	HL		; Push mode (L) onto stack
0445B8 CD 22 0A 04 12210  			CALL	COMMA
0445BC CD A5 43 04 12211  			CALL	EXPR_W2		; Parse X and Y
0445C0 C1          12212  			POP	BC		; Pop mode (C) off stack
0445C1             12213  PLOT_1:			VDU	19H		; VDU code for PLOT
0445C1 3E 19       0001M 		LD	A, val
0445C3 CD 00 3F 04 0002M 		CALL	OSWRCH
0445C7             12214  			VDU	C		;  C: Mode
0445C7 79          0001M 		LD	A, val
0445C8 CD 00 3F 04 0002M 		CALL	OSWRCH
0445CC             12215  			VDU	E		; DE: X
0445CC 7B          0001M 		LD	A, val
0445CD CD 00 3F 04 0002M 		CALL	OSWRCH
0445D1             12216  			VDU	D
0445D1 7A          0001M 		LD	A, val
0445D2 CD 00 3F 04 0002M 		CALL	OSWRCH
0445D6             12217  			VDU	L		; HL: Y
0445D6 7D          0001M 		LD	A, val
0445D7 CD 00 3F 04 0002M 		CALL	OSWRCH
0445DB             12218  			VDU	H
0445DB 7C          0001M 		LD	A, val
0445DC CD 00 3F 04 0002M 		CALL	OSWRCH
0445E0 C3 96 0B 04 12219  			JP	XEQ
0445E4             12220  
0445E4             12221  ; MOVE x,y
0445E4             12222  ;
0445E4 CD A5 43 04 12223  MOVE:			CALL	EXPR_W2		; Parse X and Y
0445E8 0E 04       12224  			LD	C, 04H		; Plot mode 04H (Move)
0445EA 18 D5       12225  			JR	PLOT_1		; Plot
0445EC             12226  
0445EC             12227  ; DRAW x1,y1
0445EC             12228  ; DRAW x1,y1,x2,y2
0445EC             12229  ;
0445EC CD A5 43 04 12230  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0445F0 CD 70 0A 04 12231  			CALL	NXT		; Are there any more parameters?
0445F4 FE 2C       12232  			CP	','
0445F6 0E 05       12233  			LD	C, 05h		; Code for LINE
0445F8 20 C7       12234  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0445FA             12235  			VDU	19h		; Move to the first coordinates
0445FA 3E 19       0001M 		LD	A, val
0445FC CD 00 3F 04 0002M 		CALL	OSWRCH
044600             12236  			VDU	04h
044600 3E 04       0001M 		LD	A, val
044602 CD 00 3F 04 0002M 		CALL	OSWRCH
044606             12237  			VDU	E
044606 7B          0001M 		LD	A, val
044607 CD 00 3F 04 0002M 		CALL	OSWRCH
04460B             12238  			VDU	D
04460B 7A          0001M 		LD	A, val
04460C CD 00 3F 04 0002M 		CALL	OSWRCH
044610             12239  			VDU	L
044610 7D          0001M 		LD	A, val
044611 CD 00 3F 04 0002M 		CALL	OSWRCH
044615             12240  			VDU	H
044615 7C          0001M 		LD	A, val
044616 CD 00 3F 04 0002M 		CALL	OSWRCH
04461A CD 22 0A 04 12241  			CALL	COMMA
04461E C5          12242  			PUSH	BC
04461F CD A5 43 04 12243  			CALL	EXPR_W2		; Get X2 and Y2
044623 C1          12244  			POP	BC
044624 18 9B       12245  			JR	PLOT_1		; Now DRAW the line to those positions
044626             12246  
044626             12247  
044626             12248  
044626             12249  ; --- End agon_graphics.asm ---
044626             12250  
044626             12251  ; --- Begin agon_sound.asm ---
044626             12252  ;
044626             12253  ; Title:	BBC Basic for AGON - Audio stuff
044626             12254  ; Author:	Dean Belfield
044626             12255  ; Created:	12/05/2023
044626             12256  ; Last Updated:	12/05/2023
044626             12257  ;
044626             12258  ; Modinfo:
044626             12259  
044626             12260  			; .ASSUME	ADL = 1
044626             12261  
044626             12262  			; INCLUDE	"equs.inc"
044626             12263  			; INCLUDE "macros.inc"
044626             12264  			; INCLUDE "mos_api.inc"	; In MOS/src
044626             12265  
044626             12266  			; SEGMENT CODE
044626             12267  
044626             12268  			; XDEF	SOUND
044626             12269  
044626             12270  			; XREF	COMMA
044626             12271  			; XREF	EXPR_W2
044626             12272  			; XREF	XEQ
044626             12273  			; XREF	LTRAP
044626             12274  			; XREF	OSWRCH
044626             12275  			; XREF	VDU_BUFFER
044626             12276  
044626             12277  
044626             12278  ; SOUND channel,volume,pitch,duration
044626             12279  ; volume: 0 (off) to -15 (full volume)
044626             12280  ; pitch: 0 - 255
044626             12281  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
044626             12282  ;
044626 CD A5 43 04 12283  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
04462A 7D          12284  			LD	A, L 			;  A: Volume
04462B F5          12285  			PUSH	AF
04462C D5          12286  			PUSH	DE
04462D CD 22 0A 04 12287  			CALL	COMMA
044631 CD A5 43 04 12288  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
044635 53          12289  			LD	D, E			;  D: Pitch
044636 5D          12290  			LD	E, L 			;  E: Duration
044637 E1          12291  			POP	HL 			; HL: Channel/Control
044638 F1          12292  			POP	AF
044639 ED 44       12293  			NEG
04463B FE 10       12294  			CP	16			; Check volume is in bounds
04463D D2 96 0B 04 12295  			JP	NC, XEQ			; Out of bounds, do nothing
044641             12296  ;
044641             12297  ; Store	in VDU vars
044641             12298  ;
044641 4F          12299  			LD	C, A			; Store Volume in C
044642 7D          12300  			LD	A, L
044643 32 00 4A 04 12301  			LD	(VDU_BUFFER+0), A	; Channel
044647 AF          12302  			XOR	A
044648 32 01 4A 04 12303  			LD	(VDU_BUFFER+1), A	; Waveform
04464C             12304  ;
04464C             12305  ; Calculate the volume
04464C             12306  ;
04464C 06 06       12307  			LD	B, 6			; C already contains the volume
04464E ED 4C       12308  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
044650 79          12309  			LD	A, C
044651 32 02 4A 04 12310  			LD	(VDU_BUFFER+2), A
044655             12311  ;
044655             12312  ; And the frequency
044655             12313  ;
044655 4B          12314  			LD	C, E			; Store duration in C
044656 26 00       12315  			LD	H, 0			; Lookup the frequency
044658 6A          12316  			LD	L, D
044659 11 E0 46 04 12317  			LD	DE, SOUND_FREQ_LOOKUP
04465D 29          12318  			ADD	HL, HL
04465E 19          12319  			ADD	HL, DE
04465F 7E          12320  			LD	A, (HL)
044660 32 03 4A 04 12321  			LD	(VDU_BUFFER+3), A
044664 23          12322  			INC	HL
044665 7E          12323  			LD	A, (HL)
044666 32 04 4A 04 12324  			LD	(VDU_BUFFER+4), A
04466A             12325  ;
04466A             12326  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
04466A             12327  ;
04466A 06 32       12328  			LD	B, 50			; C contains the duration, so MLT by 50
04466C ED 4C       12329  			MLT	BC
04466E ED 43 05 4A 12330  			LD	(VDU_BUFFER+5), BC
       04          
044673             12331  ;
044673 DD E5       12332  			PUSH	IX			; Get the system vars in IX
044675             12333  			MOSCALL	mos_sysvars		; Reset the semaphore
044675 3E 08       0001M 			LD	A, function
044677 49 CF       0002M 			RST.LIS	08h
044679 5B DD CB 04 12334  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
04467E             12335  ;
04467E             12336  			VDU	23			; Send the sound command
04467E 3E 17       0001M 		LD	A, val
044680 CD 00 3F 04 0002M 		CALL	OSWRCH
044684             12337  			VDU	0
044684 3E 00       0001M 		LD	A, val
044686 CD 00 3F 04 0002M 		CALL	OSWRCH
04468A             12338  			VDU	vdp_audio
04468A 3E 85       0001M 		LD	A, val
04468C CD 00 3F 04 0002M 		CALL	OSWRCH
044690             12339  			VDU	(VDU_BUFFER+0)		; 0: Channel
044690 3A 00 4A 04 0001M 		LD	A, val
044694 CD 00 3F 04 0002M 		CALL	OSWRCH
044698             12340  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
044698 3A 01 4A 04 0001M 		LD	A, val
04469C CD 00 3F 04 0002M 		CALL	OSWRCH
0446A0             12341  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446A0 3A 02 4A 04 0001M 		LD	A, val
0446A4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446A8             12342  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0446A8 3A 03 4A 04 0001M 		LD	A, val
0446AC CD 00 3F 04 0002M 		CALL	OSWRCH
0446B0             12343  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0446B0 3A 04 4A 04 0001M 		LD	A, val
0446B4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446B8             12344  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0446B8 3A 05 4A 04 0001M 		LD	A, val
0446BC CD 00 3F 04 0002M 		CALL	OSWRCH
0446C0             12345  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0446C0 3A 06 4A 04 0001M 		LD	A, val
0446C4 CD 00 3F 04 0002M 		CALL	OSWRCH
0446C8             12346  ;
0446C8             12347  ; Wait for acknowledgement
0446C8             12348  ;
0446C8 5B DD CB 04 12349  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
0446CD 28 F9       12350  			JR	Z, @B			; Wait for the result
0446CF CD 71 3F 04 12351  			CALL	LTRAP			; Check for ESC
0446D3 5B DD 7E 0E 12352  			LD.LIL	A, (IX+sysvar_audioSuccess)
0446D7 A7          12353  			AND	A			; Check if VDP has queued the note
0446D8 28 9F       12354  			JR	Z, SOUND0		; No, so loop back and send again
0446DA             12355  ;
0446DA DD E1       12356  			POP	IX
0446DC C3 96 0B 04 12357  			JP	XEQ
0446E0             12358  
0446E0             12359  ; Frequency Lookup Table
0446E0             12360  ; Set up to replicate the BBC Micro audio frequencies
0446E0             12361  ;
0446E0             12362  ; Split over 5 complete octaves, with 53 being middle C
0446E0             12363  ; * C4: 262hz
0446E0             12364  ; + A4: 440hz
0446E0             12365  ;
0446E0             12366  ;	2	3	4	5	6	7	8
0446E0             12367  ;
0446E0             12368  ; B	1	49	97	145	193	241
0446E0             12369  ; A#	0	45	93	141	189	237
0446E0             12370  ; A		41	89+	137	185	233
0446E0             12371  ; G#		37	85	133	181	229
0446E0             12372  ; G		33	81	129	177	225
0446E0             12373  ; F#		29	77	125	173	221
0446E0             12374  ; F		25	73	121	169	217
0446E0             12375  ; E		21	69	117	165	213
0446E0             12376  ; D#		17	65	113	161	209
0446E0             12377  ; D		13	61	109	157	205	253
0446E0             12378  ; C#		9	57	105	153	201	249
0446E0             12379  ; C		5	53*	101	149	197	245
0446E0             12380  ;
0446E0 75 00 76 00 12381  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
0446F0 89 00 8B 00 12382  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
044700 99 00 9C 00 12383  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
044710 AC 00 AF 00 12384  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
044720 C1 00 C4 00 12385  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
044730 D9 00 DC 00 12386  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
044740 F3 00 F7 00 12387  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
044750 11 01 15 01 12388  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
044760 33 01 37 01 12389  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
044770 58 01 5D 01 12390  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
044780 82 01 88 01 12391  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
044790 B2 01 B8 01 12392  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447A0 E7 01 EE 01 12393  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0447B0 22 02 2A 02 12394  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0447C0 65 02 6E 02 12395  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
0447D0 B1 02 BB 02 12396  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
0447E0 05 03 10 03 12397  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
0447F0 63 03 70 03 12398  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
044800 CE 03 DC 03 12399  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
044810 45 04 55 04 12400  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
044820 CB 04 DD 04 12401  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
044830 62 05 76 05 12402  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
044840 0A 06 21 06 12403  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
044850 C8 06 E1 06 12404  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
044860 9C 07 B8 07 12405  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
044870 8A 08 A9 08 12406  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
044880 95 09 B9 09 12407  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
044890 C2 0A EA 0A 12408  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448A0 13 0C 40 0C 12409  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0448B0 8E 0D C0 0D 12410  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0448C0 36 0F 6F 0F 12411  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
0448D0 13 11 53 11 12412  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
0448E0             12413  
0448E0             12414  
0448E0             12415  ; --- End agon_sound.asm ---
0448E0             12416  
0448E0             12417  ; --- Begin interrupts.asm ---
0448E0             12418  ;
0448E0             12419  ; Title:	BBC Basic for AGON - Interrupts
0448E0             12420  ; Author:	Dean Belfield
0448E0             12421  ; Created:	12/05/2023
0448E0             12422  ; Last Updated:	07/06/2023
0448E0             12423  ;
0448E0             12424  ; Modinfo:
0448E0             12425  ; 07/06/2023:	Modified to run in ADL mode
0448E0             12426  
0448E0             12427  			; .ASSUME	ADL = 1
0448E0             12428  
0448E0             12429  			; INCLUDE	"macros.inc"
0448E0             12430  			; INCLUDE	"equs.inc"
0448E0             12431  			; INCLUDE "mos_api.inc"	; In MOS/src
0448E0             12432  
0448E0             12433  			; SEGMENT CODE
0448E0             12434  
0448E0             12435  			; XDEF	VBLANK_INIT
0448E0             12436  			; XDEF	VBLANK_STOP
0448E0             12437  			; XDEF	VBLANK_HANDLER
0448E0             12438  
0448E0             12439  			; XREF	ESCSET
0448E0             12440  			; XREF	KEYDOWN		; In ram.asm
0448E0             12441  			; XREF	KEYASCII 	; In ram.asm
0448E0             12442  			; XREF	KEYCOUNT	; In ram.asm
0448E0             12443  
0448E0             12444  ; Hook into the MOS VBLANK interrupt
0448E0             12445  ;
0448E0 F3          12446  VBLANK_INIT:		DI
0448E1 21 35 49 04 12447  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0448E5 1E 32       12448  			LD		E, 32h				; Set up the VBlank Interrupt Vector
0448E7             12449  			MOSCALL		mos_setintvector
0448E7 3E 14       0001M 			LD	A, function
0448E9 49 CF       0002M 			RST.LIS	08h
0448EB             12450  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0448EB EB          12451  			ex de,hl
0448EC 21 43 49 04 12452  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448F0 ED 1F       12453  			LD		(HL), DE			; Self-modify the code
0448F2 FB          12454  			EI
0448F3 C9          12455  			RET
0448F4             12456  
0448F4             12457  ; Unhook the custom VBLANK interrupt
0448F4             12458  ;
0448F4 F3          12459  VBLANK_STOP:		DI
0448F5 21 43 49 04 12460  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0448F9 ED 17       12461  			LD		DE, (HL)
0448FB EB          12462  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
0448FC 1E 32       12463  			LD		E, 32h
0448FE             12464  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0448FE 3E 14       0001M 			LD	A, function
044900 49 CF       0002M 			RST.LIS	08h
044902 FB          12465  			EI
044903 C9          12466  			RET
044904             12467  
044904             12468  ; A safe LIS call to ESCSET
044904             12469  ;
044904             12470  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044904 3E 08       0001M 			LD	A, function
044906 49 CF       0002M 			RST.LIS	08h
044908 21 49 4D 04 12471  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04490C DD 7E 19    12472  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04490F BE          12473  			CP 		(HL)				; with our local copy
044910 20 0A       12474  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044912             12475  ;
044912 AF          12476  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044913 32 48 4D 04 12477  			LD		(KEYASCII), A
044917 32 47 4D 04 12478  			LD		(KEYDOWN), A
04491B C9          12479  			RET	 					; And return
04491C             12480  ;
04491C 77          12481  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04491D DD 7E 18    12482  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044920 B7          12483  			OR		A
044921 28 EF       12484  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044923             12485  ;
044923 32 47 4D 04 12486  			LD		(KEYDOWN), A 			; Store the keydown value
044927 DD 7E 05    12487  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
04492A 32 48 4D 04 12488  			LD		(KEYASCII), A 			; Store locally
04492E FE 1B       12489  			CP		1Bh				; Is it escape?
044930 CC 4C 3F 04 12490  			CALL		Z, ESCSET			; Yes, so set the escape flags
044934 C9          12491  			RET						; Return to the interrupt handler
044935             12492  
044935 F3          12493  VBLANK_HANDLER:		DI
044936 F5          12494  			PUSH		AF
044937 E5          12495  			PUSH		HL
044938 DD E5       12496  			PUSH		IX
04493A CD 04 49 04 12497  			CALL		DO_KEYBOARD
04493E DD E1       12498  			POP		IX
044940 E1          12499  			POP		HL
044941 F1          12500  			POP		AF
044942             12501  ;
044942             12502  ; Finally jump to the MOS interrupt
044942             12503  ;
044942 C3 00 00 00 12504  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT				; --- End interrupts.asm ---
044946             12505  
044946             12506  ; --- Begin ram.asm ---
044946             12507  ;
044946             12508  ; Title:	BBC Basic Interpreter - Z80 version
044946             12509  ;		RAM Module for BBC Basic Interpreter
044946             12510  ;		For use with Version 2.0 of BBC BASIC
044946             12511  ;		Standard CP/M Distribution Version
044946             12512  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
044946             12513  ; Modified By:	Dean Belfield
044946             12514  ; Created:	12/05/2023
044946             12515  ; Last Updated:	26/06/2023
044946             12516  ;
044946             12517  ; Modinfo:
044946             12518  ; 06/06/2023:	Modified to run in ADL mode
044946             12519  ; 26/06/2023:	Added temporary stores R0 and R1
044946             12520  
044946             12521  			; .ASSUME	ADL = 1
044946             12522  
044946             12523  			; DEFINE	LORAM, SPACE = ROM
044946             12524  			; SEGMENT LORAM
044946             12525  
044946             12526  			; XDEF	ACCS
044946             12527  			; XDEF	BUFFER
044946             12528  			; XDEF	STAVAR
044946             12529  			; XDEF	DYNVAR
044946             12530  			; XDEF	FNPTR
044946             12531  			; XDEF	PROPTR
044946             12532  			; XDEF	PAGE_
044946             12533  			; XDEF	TOP
044946             12534  			; XDEF	LOMEM
044946             12535  			; XDEF 	FREE
044946             12536  			; XDEF	HIMEM
044946             12537  			; XDEF	LINENO
044946             12538  			; XDEF	TRACEN
044946             12539  			; XDEF	AUTONO
044946             12540  			; XDEF	ERRTRP
044946             12541  			; XDEF	ERRTXT
044946             12542  			; XDEF	DATPTR
044946             12543  			; XDEF	ERL
044946             12544  			; XDEF	ERRLIN
044946             12545  			; XDEF	RANDOM
044946             12546  			; XDEF	COUNT
044946             12547  			; XDEF	WIDTH
044946             12548  			; XDEF	ERR
044946             12549  			; XDEF	LISTON
044946             12550  			; XDEF	INCREM
044946             12551  
044946             12552  			; XDEF	FLAGS
044946             12553  			; XDEF	OSWRCHPT
044946             12554  			; XDEF	OSWRCHCH
044946             12555  			; XDEF	OSWRCHFH
044946             12556  			; XDEF	KEYDOWN
044946             12557  			; XDEF	KEYASCII
044946             12558  			; XDEF	KEYCOUNT
044946             12559  
044946             12560  			; XDEF	R0
044946             12561  			; XDEF	R1
044946             12562  
044946             12563  			; XDEF	RAM_START
044946             12564  			; XDEF	RAM_END
044946             12565  			; XDEF	USER
044946             12566  
044946             12567  end_binary: ;  for assemble.py to know where to truncate the binary file
044946 FF FF FF FF 12568  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
044A00             12569  RAM_START:
044A00             12570  ;
044A00 00 00 00 00 12571  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 12572  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 12573  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 12574  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    12575  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    12576  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             12577  ;
044D14 00 00 00    12578  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    12579  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    12580  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    12581  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    12582  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             12583  ;
044D23 00 00 00    12584  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    12585  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    12586  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    12587  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       12588  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       12589  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       12590  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    12591  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 12592  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          12593  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          12594  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          12595  ERR:            BLKB    1,0               ; Error Number
044D40 00          12596  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             12597                                  ; - BIT 0: If set, output a space after the line number
044D41             12598                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             12599                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             12600                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             12601                                  ; OPT FLAG (top nibble)
044D41             12602                                  ; - BIT 4: If set, then list whilst assembling
044D41             12603                                  ; - BIT 5: If set, then assembler errors are reported
044D41             12604                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             12605                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          12606  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             12607  ;
044D42             12608  ; --------------------------------------------------------------------------------------------
044D42             12609  ; BEGIN MODIFIED CODE
044D42             12610  ; --------------------------------------------------------------------------------------------
044D42             12611  ; Originally in equs.inc
044D42             12612  ;
044D42             12613  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
044D42             12614  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
044D42             12615  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044D42             12616  ; --------------------------------------------------------------------------------------------
044D42             12617  ; END MODIFIED CODE
044D42             12618  ; --------------------------------------------------------------------------------------------
044D42             12619  
044D42             12620  ; Extra Agon-implementation specific system variables
044D42             12621  ;
044D42 00          12622  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             12623                                  ; - BIT 7: Set if ESC pressed
044D43             12624                                  ; - BIT 6: Set to disable ESC
044D43 00 00       12625  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          12626  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             12627                                  ; - 0: Console
044D46             12628                                  ; - 1: File
044D46 00          12629  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          12630  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          12631  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          12632  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    12633  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    12634  R1:             BLKB    3,0
044D50             12635  
044D50             12636  ;
044D50             12637  ; This must be at the end
044D50             12638  ;
044D50             12639  RAM_END:
044D50 FF FF FF FF 12640  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
044E00             12641  USER:							; Must be aligned on a page boundary
044E00             12642  	; --- End ram.asm ---
044E00             12643  
