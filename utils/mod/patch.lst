PC     Output      Line
040000 C3 55 00 00 0001  SKIP_AHEAD: JP BEGIN_HEREISH-0x040000
040004             0002  
040004             0003  ; Begin mos_api.inc
040004             0004  ;
040004             0005  ; Title:	AGON MOS - API for user projects
040004             0006  ; Author:	Dean Belfield
040004             0007  ; Created:	03/08/2022
040004             0008  ; Last Updated:	11/11/2023
040004             0009  ;
040004             0010  ; Modinfo:
040004             0011  ; 05/08/2022:	Added mos_feof
040004             0012  ; 09/08/2022:	Added system variables: cursorX, cursorY
040004             0013  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040004             0014  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040004             0015  ; 24/09/2022:	Added mos_getError, mos_mkdir
040004             0016  ; 13/10/2022:	Added mos_oscli
040004             0017  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040004             0018  ; 04/03/2023:	Added sysvar_scrpixelIndex
040004             0019  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040004             0020  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040004             0021  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040004             0022  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040004             0023  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040004             0024  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040004             0025  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040004             0026  ; 19/05/2023:	Added sysvar_scrMode
040004             0027  ; 05/06/2023:	Added sysvar_rtcEnable
040004             0028  ; 03/08/2023:	Added mos_setkbvector
040004             0029  ; 10/08/2023:	Added mos_getkbmap
040004             0030  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040004             0031  
040004             0032  ; VDP control (VDU 23, 0, n)
040004             0033  ;
040004             0034  vdp_gp:			EQU 	80h
040004             0035  vdp_keycode:		EQU 	81h
040004             0036  vdp_cursor:		EQU	82h
040004             0037  vdp_scrchar:		EQU	83h
040004             0038  vdp_scrpixel:		EQU	84h
040004             0039  vdp_audio:		EQU	85h
040004             0040  vdp_mode:		EQU	86h
040004             0041  vdp_rtc:		EQU	87h
040004             0042  vdp_keystate:		EQU	88h
040004             0043  vdp_logicalcoords:	EQU	C0h
040004             0044  vdp_terminalmode:	EQU	FFh
040004             0045  
040004             0046  ; MOS high level functions
040004             0047  ;
040004             0048  mos_getkey:		EQU	00h
040004             0049  mos_load:		EQU	01h
040004             0050  mos_save:		EQU	02h
040004             0051  mos_cd:			EQU	03h
040004             0052  mos_dir:		EQU	04h
040004             0053  mos_del:		EQU	05h
040004             0054  mos_ren:		EQU	06h
040004             0055  mos_mkdir:		EQU	07h
040004             0056  mos_sysvars:		EQU	08h
040004             0057  mos_editline:		EQU	09h
040004             0058  mos_fopen:		EQU	0Ah
040004             0059  mos_fclose:		EQU	0Bh
040004             0060  mos_fgetc:		EQU	0Ch
040004             0061  mos_fputc:		EQU	0Dh
040004             0062  mos_feof:		EQU	0Eh
040004             0063  mos_getError:		EQU	0Fh
040004             0064  mos_oscli:		EQU	10h
040004             0065  mos_copy:		EQU	11h
040004             0066  mos_getrtc:		EQU	12h
040004             0067  mos_setrtc:		EQU	13h
040004             0068  mos_setintvector:	EQU	14h
040004             0069  mos_uopen:		EQU	15h
040004             0070  mos_uclose:		EQU	16h
040004             0071  mos_ugetc:		EQU	17h
040004             0072  mos_uputc:		EQU 	18h
040004             0073  mos_getfil:		EQU	19h
040004             0074  mos_fread:		EQU	1Ah
040004             0075  mos_fwrite:		EQU	1Bh
040004             0076  mos_flseek:		EQU	1Ch
040004             0077  mos_setkbvector:	EQU	1Dh
040004             0078  mos_getkbmap:		EQU	1Eh
040004             0079  mos_i2c_open:		EQU	1Fh
040004             0080  mos_i2c_close:		EQU	20h
040004             0081  mos_i2c_write:		EQU	21h
040004             0082  mos_i2c_read:		EQU	22h
040004             0083  
040004             0084  
040004             0085  ; FatFS file access functions
040004             0086  ;
040004             0087  ffs_fopen:		EQU	80h
040004             0088  ffs_fclose:		EQU	81h
040004             0089  ffs_fread:		EQU	82h
040004             0090  ffs_fwrite:		EQU	83h
040004             0091  ffs_flseek:		EQU	84h
040004             0092  ffs_ftruncate:		EQU	85h
040004             0093  ffs_fsync:		EQU	86h
040004             0094  ffs_fforward:		EQU	87h
040004             0095  ffs_fexpand:		EQU	88h
040004             0096  ffs_fgets:		EQU	89h
040004             0097  ffs_fputc:		EQU	8Ah
040004             0098  ffs_fputs:		EQU	8Bh
040004             0099  ffs_fprintf:		EQU	8Ch
040004             0100  ffs_ftell:		EQU	8Dh
040004             0101  ffs_feof:		EQU	8Eh
040004             0102  ffs_fsize:		EQU	8Fh
040004             0103  ffs_ferror:		EQU	90h
040004             0104  
040004             0105  ; FatFS directory access functions
040004             0106  ;
040004             0107  ffs_dopen:		EQU	91h
040004             0108  ffs_dclose:		EQU	92h
040004             0109  ffs_dread:		EQU	93h
040004             0110  ffs_dfindfirst:		EQU	94h
040004             0111  ffs_dfindnext:		EQU	95h
040004             0112  
040004             0113  ; FatFS file and directory management functions
040004             0114  ;
040004             0115  ffs_stat:		EQU	96h
040004             0116  ffs_unlink:		EQU	97h
040004             0117  ffs_rename:		EQU	98h
040004             0118  ffs_chmod:		EQU	99h
040004             0119  ffs_utime:		EQU	9Ah
040004             0120  ffs_mkdir:		EQU	9Bh
040004             0121  ffs_chdir:		EQU	9Ch
040004             0122  ffs_chdrive:		EQU	9Dh
040004             0123  ffs_getcwd:		EQU	9Eh
040004             0124  
040004             0125  ; FatFS volume management and system configuration functions
040004             0126  ;
040004             0127  ffs_mount:		EQU	9Fh
040004             0128  ffs_mkfs:		EQU	A0h
040004             0129  ffs_fdisk:		EQU	A1h
040004             0130  ffs_getfree:		EQU	A2h
040004             0131  ffs_getlabel:		EQU	A3h
040004             0132  ffs_setlabel:		EQU	A4h
040004             0133  ffs_setcp:		EQU	A5h
040004             0134  
040004             0135  ; File access modes
040004             0136  ;
040004             0137  fa_read:		EQU	01h
040004             0138  fa_write:		EQU	02h
040004             0139  fa_open_existing:	EQU	00h
040004             0140  fa_create_new:		EQU	04h
040004             0141  fa_create_always:	EQU	08h
040004             0142  fa_open_always:		EQU	10h
040004             0143  fa_open_append:		EQU	30h
040004             0144  
040004             0145  ; System variable indexes for api_sysvars
040004             0146  ; Index into _sysvars in globals.asm
040004             0147  ;
040004             0148  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040004             0149  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040004             0150  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040004             0151  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040004             0152  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040004             0153  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040004             0154  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040004             0155  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040004             0156  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040004             0157  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040004             0158  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040004             0159  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040004             0160  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040004             0161  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040004             0162  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040004             0163  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040004             0164  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040004             0165  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040004             0166  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040004             0167  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040004             0168  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040004             0169  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040004             0170  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040004             0171  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040004             0172  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040004             0173  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040004             0174  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040004             0175  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040004             0176  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040004             0177  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040004             0178  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040004             0179  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040004             0180  
040004             0181  ; Flags for the VPD protocol
040004             0182  ;
040004             0183  vdp_pflag_cursor:	EQU	00000001b
040004             0184  vdp_pflag_scrchar:	EQU	00000010b
040004             0185  vdp_pflag_point:	EQU	00000100b
040004             0186  vdp_pflag_audio:	EQU	00001000b
040004             0187  vdp_pflag_mode:		EQU	00010000b
040004             0188  vdp_pflag_rtc:		EQU	00100000b
040004             0189  vdp_pflag_mouse:	EQU	01000000b
040004             0190  ; vdp_pflag_buffered:	EQU	10000000b
040004             0191  
040004             0192  ;
040004             0193  ; FatFS structures
040004             0194  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040004             0195  ;
040004             0196  ; Object ID and allocation information (FFOBJID)
040004             0197  ;
040004             0198  ; FFOBJID	.STRUCT
040004             0199  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040004             0200  ; 	id:		DS	2	; Hosting volume mount ID
040004             0201  ; 	attr:		DS	1	; Object attribute
040004             0202  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040004             0203  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040004             0204  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040004             0205  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040004             0206  ; ;
040004             0207  ; ; File object structure (FIL)
040004             0208  ; ;
040004             0209  ; FIL .STRUCT
040004             0210  ; 	obj:		.TAG	FFOBJID	; Object identifier
040004             0211  ; 	flag:		DS	1	; File status flags
040004             0212  ; 	err:		DS	1	; Abort flag (error code)
040004             0213  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040004             0214  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040004             0215  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040004             0216  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040004             0217  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040004             0218  ; FIL_SIZE .ENDSTRUCT FIL
040004             0219  ; ;
040004             0220  ; ; Directory object structure (DIR)
040004             0221  ; ;
040004             0222  ; DIR .STRUCT
040004             0223  ; 	obj:		.TAG	FFOBJID	; Object identifier
040004             0224  ; 	dptr:		DS	4	; Current read/write offset
040004             0225  ; 	clust:		DS	4	; Current cluster
040004             0226  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040004             0227  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040004             0228  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040004             0229  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040004             0230  ; DIR_SIZE .ENDSTRUCT DIR
040004             0231  ; ;
040004             0232  ; ; File information structure (FILINFO)
040004             0233  ; ;
040004             0234  ; FILINFO .STRUCT
040004             0235  ; 	fsize:		DS 	4	; File size
040004             0236  ; 	fdate:		DS	2	; Modified date
040004             0237  ; 	ftime:		DS	2	; Modified time
040004             0238  ; 	fattrib:	DS	1	; File attribute
040004             0239  ; 	altname:	DS	13	; Alternative file name
040004             0240  ; 	fname:		DS	256	; Primary file name
040004             0241  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040004             0242  
040004             0243  ; FFOBJID offsets
040004             0244  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040004             0245  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040004             0246  FFOBJID.attr:     EQU 5    ; Object attribute
040004             0247  FFOBJID.stat:     EQU 6    ; Object chain status
040004             0248  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040004             0249  FFOBJID.objsize:  EQU 11   ; Object size
040004             0250  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040004             0251  
040004             0252  ; FIL offsets (including FFOBJID fields)
040004             0253  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040004             0254  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040004             0255  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040004             0256  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040004             0257  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040004             0258  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040004             0259  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040004             0260  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040004             0261  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040004             0262  
040004             0263  ; DIR offsets (including FFOBJID fields)
040004             0264  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040004             0265  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040004             0266  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040004             0267  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040004             0268  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040004             0269  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040004             0270  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040004             0271  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040004             0272  
040004             0273  ; FILINFO offsets
040004             0274  FILINFO.fsize:    EQU 0    ; File size
040004             0275  FILINFO.fdate:    EQU 4    ; Modified date
040004             0276  FILINFO.ftime:    EQU 6    ; Modified time
040004             0277  FILINFO.fattrib:  EQU 8    ; File attribute
040004             0278  FILINFO.altname:  EQU 9    ; Alternative file name
040004             0279  FILINFO.fname:    EQU 22   ; Primary file name
040004             0280  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040004             0281  
040004             0282  ;
040004             0283  ; Macro for calling the API
040004             0284  ; Parameters:
040004             0285  ; - function: One of the function numbers listed above
040004             0286  ;
040004             0287  			MACRO MOSCALL	function
040004             0288  			LD	A, function
040004             0289  			RST.LIS	08h
040004             0290  			ENDMACRO
040004             0291  ; End mos_api.inc
040004             0292  
040004             0293  ; Begin macros.inc
040004             0294  	; Title:	BBC Basic Interpreter - Z80 version
040004             0295  	;		Useful macros
040004             0296  	; Author:	Dean Belfield
040004             0297  	; Created:	12/05/2023
040004             0298  	; Last Updated:	11/06/2023
040004             0299  	;
040004             0300  	; Modinfo:
040004             0301  	; 11/06/2023:	Modified to run in ADL mode
040004             0302  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040004             0303  
040004             0304  	MACRO EXREG	rp1, rp2
040004             0305  		PUSH	rp1
040004             0306  		POP	rp2
040004             0307  	ENDMACRO
040004             0308  
040004             0309  	; MACRO ADD8U_DE	reg
040004             0310  		MACRO ADD8U_DE
040004             0311  		ADD	A, E
040004             0312  		LD	E, A
040004             0313  		ADC	A, D
040004             0314  		SUB	E
040004             0315  		LD	D, A
040004             0316  	ENDMACRO
040004             0317  
040004             0318  	; MACRO ADD8U_HL	reg
040004             0319  	MACRO ADD8U_HL
040004             0320  		ADD	A, L
040004             0321  		LD	L, A
040004             0322  		ADC	A, H
040004             0323  		SUB	L
040004             0324  		LD	H, A
040004             0325  	ENDMACRO
040004             0326  
040004             0327  	MACRO VDU	val
040004             0328  		LD	A, val
040004             0329  		CALL	OSWRCH
040004             0330  	ENDMACRO
040004             0331  
040004             0332  	MACRO SET_GPIO	reg, val
040004             0333  		IN0	A, (reg)
040004             0334  		OR	val
040004             0335  		OUT0	(reg), A
040004             0336  	ENDMACRO
040004             0337  
040004             0338  	MACRO RES_GPIO	reg, val
040004             0339  		PUSH	BC
040004             0340  		LD	A, val
040004             0341  		CPL
040004             0342  		LD	C, A
040004             0343  		IN0	A, (reg)
040004             0344  		AND	C
040004             0345  		OUT0	(reg), A
040004             0346  		POP	BC
040004             0347  	ENDMACRO
040004             0348  
040004             0349  ; End macros.inc
040004             0350  
040004             0351  ; Begin equs_top.inc
040004             0352  ; --- Begin equs.inc ---
040004             0353  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040004             0354  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040004             0355  PA_DR:			EQU		96h
040004             0356  PA_DDR:			EQU		97h
040004             0357  PA_ALT1:		EQU		98h
040004             0358  PA_ALT2:		EQU		99h
040004             0359  PB_DR:          	EQU		9Ah
040004             0360  PB_DDR:        	 	EQU		9Bh
040004             0361  PB_ALT1:        	EQU		9Ch
040004             0362  PB_ALT2:        	EQU		9Dh
040004             0363  PC_DR:          	EQU		9Eh
040004             0364  PC_DDR:         	EQU		9Fh
040004             0365  PC_ALT1:        	EQU		A0h
040004             0366  PC_ALT2:        	EQU		A1h
040004             0367  PD_DR:          	EQU		A2h
040004             0368  PD_DDR:			EQU		A3h
040004             0369  PD_ALT1:		EQU		A4h
040004             0370  PD_ALT2:		EQU		A5h
040004             0371  GPIOMODE_OUT:		EQU		0	; Output
040004             0372  GPIOMODE_IN:		EQU		1	; Input
040004             0373  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040004             0374  GPIOMODE_SIO:		EQU		3	; Open Source IO
040004             0375  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040004             0376  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040004             0377  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040004             0378  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040004             0379  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040004             0380  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040004             0381  CR:			EQU     0DH
040004             0382  LF:			EQU     0AH
040004             0383  ESC:			EQU     1BH
040004             0384  ; --- End equs.inc ---
040004             0385  
040004             0386  ; --- Begin eval.asm ---
040004             0387  FUNTOK:			EQU	8DH			; First token number
040004             0388  ANDK:			EQU     80H
040004             0389  DIVK:			EQU     81H
040004             0390  EORK:			EQU     82H
040004             0391  MODK:			EQU     83H
040004             0392  ORK:			EQU     84H
040004             0393  ; --- End eval.asm ---
040004             0394  
040004             0395  ; --- Begin exec.asm ---
040004             0396  ; --- End exec.asm ---
040004             0397  
040004             0398  ; --- Begin fpp.asm ---
040004             0399  BADOP:			EQU     1               ;Bad operation code
040004             0400  DIVBY0:			EQU     18              ;Division by zero
040004             0401  TOOBIG_FP:			EQU     20              ;Too big
040004             0402  NGROOT:			EQU     21              ;Negative root
040004             0403  LOGRNG:			EQU     22              ;Log range
040004             0404  ACLOST:			EQU     23              ;Accuracy lost
040004             0405  EXPRNG:			EQU     24              ;Exp range
040004             0406  ; --- End fpp.asm ---
040004             0407  
040004             0408  ; --- Begin init.asm ---
040004             0409  ; --- End init.asm ---
040004             0410  
040004             0411  ; --- Begin main.asm ---
040004             0412  DATA_:	EQU     DCH
040004             0413  DEF_:	EQU     DDH
040004             0414  DIM:	EQU     DEH
040004             0415  ELSE_:	EQU     8BH
040004             0416  FN:	EQU     A4H
040004             0417  FOR:	EQU     E3H
040004             0418  GOSUB:	EQU     E4H
040004             0419  GOTO:	EQU     E5H
040004             0420  LINE_:	EQU     86H
040004             0421  LINO:	EQU     8DH
040004             0422  LOCAL_:	EQU     EAH
040004             0423  NEXT:	EQU     EDH
040004             0424  OFF_:	EQU     87H
040004             0425  ON_:	EQU     EEH
040004             0426  PROC:	EQU     F2H
040004             0427  REM:	EQU     F4H
040004             0428  REN:	EQU     CCH
040004             0429  REPEAT:	EQU     F5H
040004             0430  RESTOR:	EQU     F7H
040004             0431  SPC:	EQU     89H
040004             0432  STEP:	EQU     88H
040004             0433  TAB:	EQU     8AH
040004             0434  TAND:	EQU     80H
040004             0435  TCALL:	EQU     D6H
040004             0436  TERROR:	EQU     85H
040004             0437  TGOSUB:	EQU     E4H
040004             0438  TGOTO:	EQU     E5H
040004             0439  THEN:	EQU     8CH
040004             0440  TIF:	EQU     E7H
040004             0441  TO:	EQU     B8H
040004             0442  TON:	EQU     EEH
040004             0443  TOR:	EQU     84H
040004             0444  TPROC:	EQU     F2H
040004             0445  TRACE:	EQU     FCH
040004             0446  TSTOP:	EQU     FAH
040004             0447  UNTIL:	EQU     FDH
040004             0448  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040004             0449  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040004             0450  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040004             0451  ; --- End main.asm ---
040004             0452  
040004             0453  ; End equs_top.inc
040004             0454  
040004             0455  ; Defined in misc.asm
040004 00 00 04    0456  ASC_TO_NUMBER: DL 0x040000
040007             0457  ; Defined in exec.asm
040007 00 00 04    0458  ASSEM: DL 0x040000
04000A             0459  ; Defined in main.asm
04000A 00 00 04    0460  BAD: DL 0x040000
04000D 00 00 04    0461  CLEAN: DL 0x040000
040010             0462  ; Defined in eval.asm
040010 00 00 04    0463  COMMA: DL 0x040000
040013             0464  ; Defined in eval.asm
040013 00 00 04    0465  COUNT0: DL 0x040000
040016             0466  ; Defined in main.asm
040016 00 00 04    0467  CRLF: DL 0x040000
040019             0468  ; Defined in misc.asm
040019 00 00 04    0469  CSTR_CAT: DL 0x040000
04001C             0470  ; Defined in misc.asm
04001C 00 00 04    0471  CSTR_ENDSWITH: DL 0x040000
04001F             0472  ; Defined in misc.asm
04001F 00 00 04    0473  CSTR_FINDCH: DL 0x040000
040022             0474  ; Defined in misc.asm
040022 00 00 04    0475  CSTR_FNAME: DL 0x040000
040025             0476  ; Defined in misc.asm
040025 00 00 04    0477  CSTR_LINE: DL 0x040000
040028             0478  ; Defined in main.asm
040028 00 00 04    0479  ERROR_: DL 0x040000
04002B             0480  ; Defined in exec.asm
04002B 00 00 04    0481  ESCAPE: DL 0x040000
04002E             0482  ; Defined in eval.asm
04002E 00 00 04    0483  EXPRI: DL 0x040000
040031             0484  ; Defined in main.asm
040031 00 00 04    0485  EXTERR: DL 0x040000
040034             0486  ; Defined in main.asm
040034 00 00 04    0487  FINDL: DL 0x040000
040037             0488  ; Defined in main.asm
040037 00 00 04    0489  LISTIT: DL 0x040000
04003A             0490  ; Defined in main.asm
04003A 00 00 04    0491  NEWIT: DL 0x040000
04003D             0492  ; Defined in misc.asm
04003D 00 00 04    0493  NULLTOCR: DL 0x040000
040040             0494  ; Defined in main.asm
040040 00 00 04    0495  ONEDIT: DL 0x040000
040043             0496  ; Defined in main.asm
040043 00 00 04    0497  ONEDIT1: DL 0x040000
040046             0498  ; Defined in main.asm
040046 00 00 04    0499  TELL: DL 0x040000
040049             0500  ; Defined in interrupts.asm
040049 00 00 04    0501  VBLANK_INIT: DL 0x040000
04004C             0502  ; Defined in interrupts.asm
04004C 00 00 04    0503  VBLANK_STOP: DL 0x040000
04004F             0504  ; Defined in exec.asm
04004F 00 00 04    0505  VDU: DL 0x040000
040052             0506  ; Defined in init.asm
040052 00 00 04    0507  _end: DL 0x040000
040055             0508  
040055             0509  BEGIN_HEREISH:
040055             0510  
040055             0511  ;
040055             0512  ; Title:	BBC Basic for AGON
040055             0513  ; Author:	Dean Belfield
040055             0514  ; Created:	12/05/2023
040055             0515  ; Last Updated:	15/11/2023
040055             0516  ;
040055             0517  ; Modinfo:
040055             0518  ; 11/07/2023:	Fixed *BYE for ADL mode
040055             0519  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
040055             0520  
040055             0521  			; .ASSUME	ADL = 1
040055             0522  
040055             0523  			; INCLUDE	"equs.inc"
040055             0524  			; INCLUDE "macros.inc"
040055             0525  			; INCLUDE "mos_api.inc"	; In MOS/src
040055             0526  
040055             0527  			; SEGMENT CODE
040055             0528  
040055             0529  			; XDEF	OSWRCH
040055             0530  			; XDEF	OSLINE
040055             0531  			; XDEF	ESCSET
040055             0532  			; XDEF	PUTIME
040055             0533  			; XDEF	GETIME
040055             0534  			; XDEF	PUTCSR
040055             0535  			; XDEF 	GETCSR
040055             0536  			; XDEF	OSRDCH
040055             0537  			; XDEF	PROMPT
040055             0538  			; XDEF	OSKEY
040055             0539  			; XDEF	TRAP
040055             0540  			; XDEF	LTRAP
040055             0541  			; XDEF	OSINIT
040055             0542  			; XDEF	OSCLI
040055             0543  			; XDEF	OSBPUT
040055             0544  			; XDEF	OSBGET
040055             0545  			; XDEF	OSSTAT
040055             0546  			; XDEF	OSSHUT
040055             0547  			; XDEF	OSOPEN
040055             0548  			; XDEF	OSCALL
040055             0549  			; XDEF	GETPTR
040055             0550  			; XDEF	PUTPTR
040055             0551  			; XDEF	GETEXT
040055             0552  			; XDEF	GETIMS
040055             0553  			; XDEF	RESET
040055             0554  			; XDEF	OSLOAD
040055             0555  			; XDEF	OSSAVE
040055             0556  			; XDEF	EXPR_W2
040055             0557  			; XDEF	STAR_VERSION
040055             0558  
040055             0559  			; XREF	_end			; In init.asm
040055             0560  
040055             0561  			; XREF	ASC_TO_NUMBER
040055             0562  			; XREF	RAM_START
040055             0563  			; XREF	RAM_END
040055             0564  			; XREF	FLAGS
040055             0565  			; XREF	ESCAPE
040055             0566  			; XREF	USER
040055             0567  			; XREF	RAM_Top
040055             0568  			; XREF	EXTERR
040055             0569  			; XREF	COUNT0
040055             0570  			; XREF	EXPRI
040055             0571  			; XREF	COMMA
040055             0572  			; XREF	XEQ
040055             0573  			; XREF	NXT
040055             0574  			; XREF	NULLTOCR
040055             0575  			; XREF	CRLF
040055             0576  			; XREF	CSTR_FNAME
040055             0577  			; XREF	CSTR_LINE
040055             0578  			; XREF	CSTR_FINDCH
040055             0579  			; XREF	CSTR_ENDSWITH
040055             0580  			; XREF	CSTR_CAT
040055             0581  			; XREF	FINDL
040055             0582  			; XREF	OUT_
040055             0583  			; XREF	ERROR_
040055             0584  			; XREF	ONEDIT
040055             0585  			; XREF	TELL
040055             0586  			; XREF	OSWRCHPT
040055             0587  			; XREF	OSWRCHCH
040055             0588  			; XREF	OSWRCHFH
040055             0589  			; XREF	LISTON
040055             0590  			; XREF	LISTIT
040055             0591  			; XREF	PAGE_
040055             0592  			; XREF	ONEDIT1
040055             0593  			; XREF	CLEAN
040055             0594  			; XREF	NEWIT
040055             0595  			; XREF	BAD
040055             0596  			; XREF	VBLANK_INIT
040055             0597  			; XREF	VBLANK_STOP
040055             0598  			; XREF	KEYDOWN
040055             0599  			; XREF	KEYASCII
040055             0600  			; XREF	WIDTH
040055             0601  			; XREF	ASSEM
040055             0602  
040055             0603  ; OSLINE: Invoke the line editor
040055             0604  ;
040055 1E 01       0605  OSLINE:			LD 	E, 1			; Default is to clear the buffer
040057             0606  
040057             0607  ; Entry point to line editor that does not clear the buffer
040057             0608  ;
040057 FD E5       0609  OSLINE1:		PUSH	IY
040059 E5          0610  			PUSH	HL			; Buffer address
04005A 01 00 01 00 0611  			LD	BC, 256			; Buffer length
04005E             0612  			MOSCALL	mos_editline		; Call the MOS line editor
04005E 3E 09       0001M 			LD	A, function
040060 49 CF       0002M 			RST.LIS	08h
040062 E1          0613  			POP	HL			; Pop the address
040063 FD E1       0614  			POP	IY
040065 F5          0615  			PUSH	AF			; Stack the return value (key pressed)
040066 CD 3D 00 04 0616  			CALL	NULLTOCR		; Turn the 0 character to a CR
04006A CD 16 00 04 0617  			CALL	CRLF			; Display CRLF
04006E F1          0618  			POP	AF
04006F FE 1B       0619  			CP	1Bh 			; Check if ESC terminated the input
040071 CA 6D 01 04 0620  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
040075 3A 42 09 04 0621  			LD	A, (FLAGS)		; Otherwise
040079 CB BF       0622  			RES	7, A 			; Clear the escape flag
04007B 32 42 09 04 0623  			LD	(FLAGS), A
04007F CD 44 03 04 0624  			CALL	WAIT_VBLANK 		; Wait a frame
040083 AF          0625   			XOR	A			; Return A = 0
040084 32 47 09 04 0626  			LD	(KEYDOWN), A
040088 32 48 09 04 0627  			LD	(KEYASCII), A
04008C C9          0628  			RET
04008D             0629  
04008D             0630  ; PUTIME: set current time to DE:HL, in centiseconds.
04008D             0631  ;
04008D DD E5       0632  PUTIME:			PUSH 	IX
04008F             0633  			MOSCALL	mos_sysvars
04008F 3E 08       0001M 			LD	A, function
040091 49 CF       0002M 			RST.LIS	08h
040093 DD 75 00    0634  			LD	(IX + sysvar_time + 0), L
040096 DD 74 01    0635  			LD	(IX + sysvar_time + 1), H
040099 DD 73 02    0636  			LD	(IX + sysvar_time + 2), E
04009C DD 72 03    0637  			LD	(IX + sysvar_time + 3), D
04009F DD E1       0638  			POP	IX
0400A1 C9          0639  			RET
0400A2             0640  
0400A2             0641  ; GETIME: return current time in DE:HL, in centiseconds
0400A2             0642  ;
0400A2 DD E5       0643  GETIME:			PUSH 	IX
0400A4             0644  			MOSCALL	mos_sysvars
0400A4 3E 08       0001M 			LD	A, function
0400A6 49 CF       0002M 			RST.LIS	08h
0400A8 DD 6E 00    0645  			LD	L, (IX + sysvar_time + 0)
0400AB DD 66 01    0646  			LD	H, (IX + sysvar_time + 1)
0400AE DD 5E 02    0647  			LD	E, (IX + sysvar_time + 2)
0400B1 DD 56 03    0648  			LD	D, (IX + sysvar_time + 3)
0400B4 DD E1       0649  			POP	IX
0400B6 C9          0650  			RET
0400B7             0651  
0400B7             0652  ; PUTCSR: move to cursor to x=DE, y=HL
0400B7             0653  ;
0400B7 3E 1F       0654  PUTCSR:			LD	A, 1Fh			; TAB
0400B9 5B D7       0655  			RST.LIL	10h
0400BB 7B          0656  			LD	A, E			; X
0400BC 5B D7       0657  			RST.LIL 10h
0400BE 7D          0658  			LD	A, L			; Y
0400BF 5B D7       0659  			RST.LIL 10h
0400C1 C9          0660  			RET
0400C2             0661  
0400C2             0662  ; GETCSR: return cursor position in x=DE, y=HL
0400C2             0663  ;
0400C2 DD E5       0664  GETCSR:			PUSH	IX			; Get the system vars in IX
0400C4             0665  			MOSCALL	mos_sysvars		; Reset the semaphore
0400C4 3E 08       0001M 			LD	A, function
0400C6 49 CF       0002M 			RST.LIS	08h
0400C8 DD CB 04 86 0666  			RES	0, (IX+sysvar_vpd_pflags)
0400CC             0667  			VDU	23
0400CC 3E 17       0001M 		LD	A, val
0400CE CD F6 00 04 0002M 		CALL	OSWRCH
0400D2             0668  			VDU	0
0400D2 3E 00       0001M 		LD	A, val
0400D4 CD F6 00 04 0002M 		CALL	OSWRCH
0400D8             0669  			VDU	vdp_cursor
0400D8 3E 82       0001M 		LD	A, val
0400DA CD F6 00 04 0002M 		CALL	OSWRCH
0400DE DD CB 04 46 0670  @@:			BIT	0, (IX+sysvar_vpd_pflags)
0400E2 28 FA       0671  			JR	Z, @B			; Wait for the result
0400E4 16 00       0672  			LD 	D, 0
0400E6 62          0673  			LD	H, D
0400E7 DD 5E 07    0674  			LD	E, (IX + sysvar_cursorX)
0400EA DD 6E 08    0675  			LD	L, (IX + sysvar_cursorY)
0400ED DD E1       0676  			POP	IX
0400EF C9          0677  			RET
0400F0             0678  
0400F0             0679  ; PROMPT: output the input prompt
0400F0             0680  ;
0400F0 3E 3E       0681  PROMPT: 		LD	A,'>'
0400F2 C3 F6 00 04 0682  			JP	OSWRCH
0400F6             0683  
0400F6             0684  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0400F6             0685  ; A: Character to write
0400F6             0686  ;
0400F6 E5          0687  OSWRCH:			PUSH	HL
0400F7 21 40 09 04 0688  			LD	HL, LISTON		; Fetch the LISTON variable
0400FB CB 5E       0689  			BIT	3, (HL)			; Check whether we are in *EDIT mode
0400FD 20 0B       0690  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0400FF             0691  ;
0400FF 2A 45 09 04 0692  			LD	HL, (OSWRCHCH)		; L: Channel #
040103 2D          0693  			DEC	L			; If it is 1
040104 28 10       0694  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
040106             0695  ;
040106 E1          0696  			POP	HL			; Otherwise
040107 5B D7       0697  			RST.LIL	10h			; Output the character to MOS
040109 C9          0698  			RET
04010A             0699  ;
04010A 2A 43 09 04 0700  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
04010E 77          0701  			LD	(HL), A			; Echo the character into the buffer
04010F 23          0702  			INC	HL			; Increment pointer
040110 22 43 09 04 0703  			LD	(OSWRCHPT), HL		; Write pointer back
040114 E1          0704  			POP	HL
040115 C9          0705  			RET
040116             0706  ;
040116 D5          0707  OSWRCH_FILE:		PUSH	DE
040117 5C          0708  			LD	E, H			; Filehandle to E
040118 CD 42 05 04 0709  			CALL	OSBPUT			; Write the byte out
04011C D1          0710  			POP	DE
04011D E1          0711  			POP	HL
04011E C9          0712  			RET
04011F             0713  
04011F             0714  ; OSRDCH: Read a character in from the ESP32 keyboard handler
04011F             0715  ; This is only called in GETS (eval.asm)
04011F             0716  ;
04011F             0717  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
04011F 3E 00       0001M 			LD	A, function
040121 49 CF       0002M 			RST.LIS	08h
040123 FE 1B       0718  			CP	1Bh
040125 28 46       0719  			JR	Z, LTRAP1
040127 C9          0720  			RET
040128             0721  
040128             0722  
040128             0723  ;OSKEY - Read key with time-limit, test for ESCape.
040128             0724  ;Main function is carried out in user patch.
040128             0725  ;   Inputs: HL = time limit (centiseconds)
040128             0726  ;  Outputs: Carry reset if time-out
040128             0727  ;           If carry set A = character
040128             0728  ; Destroys: A,H,L,F
040128             0729  ;
040128 CD 59 01 04 0730  OSKEY:			CALL	READKEY			; Read the keyboard
04012C 28 0A       0731  			JR	Z, @F 			; Skip if we have a key
04012E 7C          0732  			LD	A, H 			; Check loop counter
04012F B5          0733  			OR 	L
040130 C8          0734  			RET 	Z 			; Return, we've not got a key at this point
040131 CD 44 03 04 0735  			CALL	WAIT_VBLANK 		; Wait a frame
040135 2B          0736  			DEC 	HL			; Decrement
040136 18 F0       0737  			JR	OSKEY 			; And loop
040138             0738  ;
040138 21 47 09 04 0739  @@:			LD	HL, KEYDOWN		; We have a key, so
04013C 36 00       0740  			LD	(HL), 0			; clear the keydown flag
04013E FE 1B       0741  			CP	1BH			; If we are not pressing ESC,
040140 37          0742  			SCF 				; then flag we've got a character
040141 C0          0743  			RET	NZ
040142             0744  ;
040142             0745  ; ESCSET
040142             0746  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
040142             0747  ;
040142 E5          0748  ESCSET: 		PUSH    HL
040143 21 42 09 04 0749          		LD      HL,FLAGS		; Pointer to FLAGS
040147 CB 76       0750          		BIT     6,(HL)			; If bit 6 is set, then
040149 20 02       0751          		JR      NZ,ESCDIS		; escape is disabled, so skip
04014B CB FE       0752          		SET     7,(HL)			; Set bit 7, the escape flag
04014D E1          0753  ESCDIS: 		POP     HL
04014E C9          0754          		RET
04014F             0755  ;
04014F             0756  ; ESCTEST
04014F             0757  ; Test for ESC key
04014F             0758  ;
04014F CD 59 01 04 0759  ESCTEST:		CALL	READKEY			; Read the keyboard
040153 C0          0760  			RET	NZ			; Skip if no key is pressed
040154 FE 1B       0761  			CP	1BH			; If ESC pressed then
040156 28 EA       0762  			JR	Z,ESCSET		; jump to the escape set routine
040158 C9          0763  			RET
040159             0764  
040159             0765  ; Read the keyboard
040159             0766  ; Returns:
040159             0767  ; - A: ASCII of the pressed key
040159             0768  ; - F: Z if the key is pressed, otherwise NZ
040159             0769  ;
040159 3A 47 09 04 0770  READKEY:		LD	A, (KEYDOWN)		; Get key down
04015D 3D          0771  			DEC	A 			; Set Z flag if keydown is 1
04015E 3A 48 09 04 0772  			LD	A, (KEYASCII)		; Get key ASCII value
040162 C9          0773  			RET
040163             0774  ;
040163             0775  ; TRAP
040163             0776  ; This is called whenever BASIC needs to check for ESC
040163             0777  ;
040163 CD 4F 01 04 0778  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
040167             0779  ;
040167 3A 42 09 04 0780  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
04016B B7          0781  			OR	A			; This checks for bit 7; if it is not set then the result will
04016C F0          0782  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
04016D 21 42 09 04 0783  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
040171 CB BE       0784  			RES	7,(HL)			; Clear the escape pressed flag and
040173 C3 2B 00 04 0785  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
040177             0786  
040177             0787  ;OSINIT - Initialise RAM mapping etc.
040177             0788  ;If BASIC is entered by BBCBASIC FILENAME then file
040177             0789  ;FILENAME.BBC is automatically CHAINed.
040177             0790  ;   Outputs: DE = initial value of HIMEM (top of RAM)
040177             0791  ;            HL = initial value of PAGE (user program)
040177             0792  ;            Z-flag reset indicates AUTO-RUN.
040177             0793  ;  Destroys: A,D,E,H,L,F
040177             0794  ;
040177 CD 49 00 04 0795  OSINIT:			CALL	VBLANK_INIT
04017B AF          0796  			XOR	A
04017C 21 00 0A 04 0797  			LD 	HL, USER
040180 11 00 00 0B 0798  			LD	DE, RAM_Top
040184 5F          0799  			LD	E, A			; Page boundary
040185 C9          0800  			RET
040186             0801  
040186             0802  ;
040186             0803  ;OSCLI - Process a MOS command
040186             0804  ;
040186 CD FA 01 04 0805  OSCLI: 			CALL    SKIPSP
04018A FE 0D       0806  			CP      CR
04018C C8          0807  			RET     Z
04018D FE 7C       0808  			CP      '|'
04018F C8          0809  			RET     Z
040190 EB          0810  			EX      DE,HL
040191 21 09 02 04 0811  			LD      HL,COMDS
040195 1A          0812  OSCLI0:			LD      A,(DE)
040196 CD 01 02 04 0813  			CALL    UPPRC
04019A BE          0814  			CP      (HL)
04019B 28 0B       0815  			JR      Z,OSCLI2
04019D 38 30       0816  			JR      C,OSCLI6
04019F CB 7E       0817  OSCLI1:			BIT     7,(HL)
0401A1 23          0818  			INC     HL
0401A2 28 FB       0819  			JR      Z,OSCLI1
0401A4 23          0820  			INC     HL
0401A5 23          0821  			INC     HL
0401A6 18 ED       0822  			JR      OSCLI0
0401A8             0823  ;
0401A8 D5          0824  OSCLI2:			PUSH    DE
0401A9 13          0825  OSCLI3:			INC     DE
0401AA 23          0826  			INC     HL
0401AB 1A          0827  			LD      A,(DE)
0401AC CD 01 02 04 0828  			CALL    UPPRC
0401B0 FE 2E       0829  			CP      '.'			; ABBREVIATED?
0401B2 28 0A       0830  			JR      Z,OSCLI4
0401B4 AE          0831  			XOR     (HL)
0401B5 28 F2       0832  			JR      Z,OSCLI3
0401B7 FE 80       0833  			CP      80H
0401B9 28 03       0834  			JR      Z,OSCLI4
0401BB D1          0835  			POP     DE
0401BC 18 E1       0836  			JR      OSCLI1
0401BE             0837  ;
0401BE F1          0838  OSCLI4:			POP     AF
0401BF 13          0839  		        INC     DE
0401C0 CB 7E       0840  OSCLI5:			BIT     7,(HL)
0401C2 23          0841  			INC     HL
0401C3 28 FB       0842  			JR      Z,OSCLI5
0401C5 7E          0843  			LD      A,(HL)
0401C6 23          0844  			INC     HL
0401C7 66          0845  			LD      H,(HL)
0401C8 6F          0846  			LD      L,A
0401C9 E5          0847  			PUSH    HL
0401CA EB          0848  			EX      DE,HL
0401CB C3 FA 01 04 0849  			JP      SKIPSP
0401CF             0850  ;
0401CF EB          0851  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0401D0 11 00 06 04 0852  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0401D4 D5          0853  			PUSH	DE			; Store buffer address
0401D5 CD 25 00 04 0854  			CALL	CSTR_LINE		; Fetch the line
0401D9 E1          0855  			POP	HL			; HL: Pointer to command string in ACCS
0401DA FD E5       0856  			PUSH	IY
0401DC             0857  			MOSCALL	mos_oscli		; Returns OSCLI error in A
0401DC 3E 10       0001M 			LD	A, function
0401DE 49 CF       0002M 			RST.LIS	08h
0401E0 FD E1       0858  			POP	IY
0401E2 B7          0859  			OR	A			; 0 means MOS returned OK
0401E3 C8          0860  			RET	Z			; So don't do anything
0401E4 C3 1E 04 04 0861  			JP 	OSERROR			; Otherwise it's a MOS error
0401E8             0862  
0401E8 3E FE       0863  HUH:    		LD      A,254			; Bad command error
0401EA CD 31 00 04 0864          		CALL    EXTERR
0401EE 42 61 64 20 0865          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0401F9 00          0866          		DEFB    0
0401FA             0867  
0401FA 7E          0868  SKIPSP:			LD      A,(HL)
0401FB FE 20       0869          		CP      ' '
0401FD C0          0870          		RET     NZ
0401FE 23          0871          		INC     HL
0401FF 18 F9       0872          		JR      SKIPSP
040201             0873  
040201 E6 7F       0874  UPPRC:  		AND     7FH
040203 FE 60       0875  			CP      '`'
040205 D8          0876  			RET     C
040206 E6 5F       0877  			AND     5FH			; CONVERT TO UPPER CASE
040208 C9          0878  			RET
040209             0879  
040209             0880  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
040209             0881  ; These must be in alphabetical order
040209             0882  ;
040209 41 53 4D    0883  COMDS:  		DB	"AS","M"+80h		; ASM
04020C 27 02       0884  			DW	STAR_ASM
04020E 42 59 45    0885  			DB	"BY","E"+80h		; BYE
040211 33 02       0886  			DW	STAR_BYE
040213 45 44 49 54 0887  			DB	"EDI","T"+80h		; EDIT
040217 68 02       0888  			DW	STAR_EDIT
040219 46 58       0889  			DB	"F","X"+80h		; FX
04021B A8 02       0890  			DW	STAR_FX
04021D 56 45 52 53 0891  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
040224 3F 02       0892  			DW	STAR_VERSION
040226 FF          0893  			DB	FFh
040227             0894  
040227             0895  ; *ASM string
040227             0896  ;
040227 FD E5       0897  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
040229 E5          0898  			PUSH	HL			; HL = IY
04022A FD E1       0899  			POP	IY
04022C CD 07 00 04 0900  			CALL	ASSEM			; Invoke the assembler
040230 FD E1       0901  			POP	IY
040232 C9          0902  			RET
040233             0903  
040233             0904  ; *BYE
040233             0905  ;
040233 CD 4C 00 04 0906  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
040237 21 00 00 00 0907  			LD	HL, 0			; The return value
04023B C3 52 00 04 0908  			JP	_end 			; Jump back to the end routine in init.asm
04023F             0909  
04023F             0910  ; *VERSION
04023F             0911  ;
04023F CD 46 00 04 0912  STAR_VERSION:		CALL    TELL			; Output the welcome message
040243 42 42 43 20 0913  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
040267 C9          0914  			RET
040268             0915  
040268             0916  ; *EDIT linenum
040268             0917  ;
040268 CD 04 00 04 0918  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
04026C EB          0919  			EX	DE, HL			; HL: Line number
04026D CD 34 00 04 0920  			CALL	FINDL			; HL: Address in RAM of tokenised line
040271 3E 29       0921  			LD	A, 41			; F:NZ If the line is not found
040273 C2 28 00 04 0922  			JP	NZ, ERROR_		; Do error 41: No such line in that case
040277             0923  ;
040277             0924  ; Use LISTIT to output the line to the ACCS buffer
040277             0925  ;
040277 23          0926  			INC	HL			; Skip the length byte
040278 5E          0927  			LD	E, (HL)			; Fetch the line number
040279 23          0928  			INC	HL
04027A 56          0929  			LD	D, (HL)
04027B 23          0930  			INC	HL
04027C DD 21 00 06 0931  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
040281 DD 22 43 09 0932  			LD	(OSWRCHPT), IX
       04          
040286 DD 21 40 09 0933  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
04028B DD 7E 00    0934  			LD	A, (IX)			; Store that variable
04028E F5          0935  			PUSH	AF
04028F DD 36 00 09 0936  			LD	(IX), 09h		; Set to echo to buffer
040293 CD 37 00 04 0937  			CALL	LISTIT
040297 F1          0938  			POP	AF
040298 DD 77 00    0939  			LD	(IX), A			; Restore the original LISTON variable
04029B 21 00 06 04 0940  			LD	HL, ACCS		; HL: ACCS
04029F 5D          0941  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0402A0 CD 57 00 04 0942  			CALL	OSLINE1			; Invoke the editor
0402A4 C3 40 00 04 0943  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0402A8             0944  
0402A8             0945  ; OSCLI FX n
0402A8             0946  ;
0402A8 CD 04 00 04 0947  STAR_FX:		CALL	ASC_TO_NUMBER
0402AC 4B          0948  			LD	C, E			; C: Save FX #
0402AD CD 04 00 04 0949  			CALL	ASC_TO_NUMBER
0402B1 7A          0950  			LD	A, D  			; Is first parameter > 255?
0402B2 B7          0951  			OR 	A
0402B3 28 03       0952  			JR	Z, STAR_FX1		; Yes, so skip next bit
0402B5 EB          0953  			EX	DE, HL 			; Parameter is 16-bit
0402B6 18 07       0954  			JR	STAR_FX2
0402B8             0955  ;
0402B8 43          0956  STAR_FX1:		LD	B, E 			; B: Save First parameter
0402B9 CD 04 00 04 0957  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0402BD 68          0958  			LD	L, B 			; L: First parameter
0402BE 63          0959  			LD	H, E 			; H: Second parameter
0402BF             0960  ;
0402BF 79          0961  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0402C0             0962  ;
0402C0             0963  ; OSBYTE
0402C0             0964  ;  A: FX #
0402C0             0965  ;  L: First parameter
0402C0             0966  ;  H: Second parameter
0402C0             0967  ;
0402C0 FE 0B       0968  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0402C2 28 18       0969  			JR	Z, OSBYTE_0B
0402C4 FE 0C       0970  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0402C6 28 43       0971  			JR	Z, OSBYTE_0C
0402C8 FE 13       0972  			CP	13H			; *FX 19: Wait for vblank
0402CA 28 6E       0973  			JR	Z, OSBYTE_13
0402CC FE 76       0974  			CP	76H			; *FX 118, n: Set keyboard LED
0402CE CA 55 03 04 0975  			JP	Z, OSBYTE_76
0402D2 FE A0       0976  			CP	A0H
0402D4 CA 85 03 04 0977  			JP	Z, OSBYTE_A0
0402D8 C3 E8 01 04 0978  			JP	HUH			; Anything else trips an error
0402DC             0979  
0402DC             0980  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0402DC             0981  ; Parameters:
0402DC             0982  ; - HL: Repeat delay
0402DC             0983  ;
0402DC             0984  OSBYTE_0B:		VDU	23
0402DC 3E 17       0001M 		LD	A, val
0402DE CD F6 00 04 0002M 		CALL	OSWRCH
0402E2             0985  			VDU	0
0402E2 3E 00       0001M 		LD	A, val
0402E4 CD F6 00 04 0002M 		CALL	OSWRCH
0402E8             0986  			VDU	vdp_keystate
0402E8 3E 88       0001M 		LD	A, val
0402EA CD F6 00 04 0002M 		CALL	OSWRCH
0402EE             0987  			VDU	L
0402EE 7D          0001M 		LD	A, val
0402EF CD F6 00 04 0002M 		CALL	OSWRCH
0402F3             0988  			VDU	H
0402F3 7C          0001M 		LD	A, val
0402F4 CD F6 00 04 0002M 		CALL	OSWRCH
0402F8             0989  			VDU	0
0402F8 3E 00       0001M 		LD	A, val
0402FA CD F6 00 04 0002M 		CALL	OSWRCH
0402FE             0990  			VDU 	0
0402FE 3E 00       0001M 		LD	A, val
040300 CD F6 00 04 0002M 		CALL	OSWRCH
040304             0991  			VDU	255
040304 3E FF       0001M 		LD	A, val
040306 CD F6 00 04 0002M 		CALL	OSWRCH
04030A C9          0992  			RET
04030B             0993  
04030B             0994  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
04030B             0995  ; Parameters:
04030B             0996  ; - HL: Repeat rate
04030B             0997  ;
04030B             0998  OSBYTE_0C:		VDU	23
04030B 3E 17       0001M 		LD	A, val
04030D CD F6 00 04 0002M 		CALL	OSWRCH
040311             0999  			VDU	0
040311 3E 00       0001M 		LD	A, val
040313 CD F6 00 04 0002M 		CALL	OSWRCH
040317             1000  			VDU	vdp_keystate
040317 3E 88       0001M 		LD	A, val
040319 CD F6 00 04 0002M 		CALL	OSWRCH
04031D             1001  			VDU	0
04031D 3E 00       0001M 		LD	A, val
04031F CD F6 00 04 0002M 		CALL	OSWRCH
040323             1002  			VDU 	0
040323 3E 00       0001M 		LD	A, val
040325 CD F6 00 04 0002M 		CALL	OSWRCH
040329             1003  			VDU	L
040329 7D          0001M 		LD	A, val
04032A CD F6 00 04 0002M 		CALL	OSWRCH
04032E             1004  			VDU	H
04032E 7C          0001M 		LD	A, val
04032F CD F6 00 04 0002M 		CALL	OSWRCH
040333             1005  			VDU	255
040333 3E FF       0001M 		LD	A, val
040335 CD F6 00 04 0002M 		CALL	OSWRCH
040339 C9          1006  			RET
04033A             1007  
04033A             1008  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
04033A             1009  ;
04033A CD 44 03 04 1010  OSBYTE_13:		CALL	WAIT_VBLANK
04033E 2E 00       1011  			LD	L, 0			; Returns 0
040340 C3 13 00 04 1012  			JP	COUNT0
040344             1013  ;
040344 DD E5       1014  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
040346             1015  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
040346 3E 08       0001M 			LD	A, function
040348 49 CF       0002M 			RST.LIS	08h
04034A DD 7E 00    1016  			LD	A, (IX + sysvar_time + 0)
04034D DD BE 00    1017  @@:			CP 	A, (IX + sysvar_time + 0)
040350 28 FB       1018  			JR	Z, @B
040352 DD E1       1019  			POP	IX
040354 C9          1020  			RET
040355             1021  
040355             1022  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
040355             1023  ; Parameters:
040355             1024  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
040355             1025  ;
040355             1026  OSBYTE_76:		VDU	23
040355 3E 17       0001M 		LD	A, val
040357 CD F6 00 04 0002M 		CALL	OSWRCH
04035B             1027  			VDU	0
04035B 3E 00       0001M 		LD	A, val
04035D CD F6 00 04 0002M 		CALL	OSWRCH
040361             1028  			VDU	vdp_keystate
040361 3E 88       0001M 		LD	A, val
040363 CD F6 00 04 0002M 		CALL	OSWRCH
040367             1029  			VDU	0
040367 3E 00       0001M 		LD	A, val
040369 CD F6 00 04 0002M 		CALL	OSWRCH
04036D             1030  			VDU 	0
04036D 3E 00       0001M 		LD	A, val
04036F CD F6 00 04 0002M 		CALL	OSWRCH
040373             1031  			VDU	0
040373 3E 00       0001M 		LD	A, val
040375 CD F6 00 04 0002M 		CALL	OSWRCH
040379             1032  			VDU	0
040379 3E 00       0001M 		LD	A, val
04037B CD F6 00 04 0002M 		CALL	OSWRCH
04037F             1033  			VDU	L
04037F 7D          0001M 		LD	A, val
040380 CD F6 00 04 0002M 		CALL	OSWRCH
040384 C9          1034  			RET
040385             1035  
040385             1036  ; OSBYTE 0xA0: Fetch system variable
040385             1037  ; Parameters:
040385             1038  ; - L: The system variable to fetch
040385             1039  ;
040385 DD E5       1040  OSBYTE_A0:		PUSH	IX
040387             1041  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
040387 3E 08       0001M 			LD	A, function
040389 49 CF       0002M 			RST.LIS	08h
04038B 01 00 00 00 1042  			LD	BC, 0
04038F 4D          1043  			LD	C, L			; BCU = L
040390 DD 09       1044  			ADD	IX, BC			; Add to IX
040392 DD 6E 00    1045  			LD	L, (IX + 0)		; Fetch the return value
040395 DD E1       1046  			POP	IX
040397 C3 13 00 04 1047  			JP 	COUNT0
04039B             1048  
04039B             1049  ;OSLOAD - Load an area of memory from a file.
04039B             1050  ;   Inputs: HL addresses filename (CR terminated)
04039B             1051  ;           DE = address at which to load
04039B             1052  ;           BC = maximum allowed size (bytes)
04039B             1053  ;  Outputs: Carry reset indicates no room for file.
04039B             1054  ; Destroys: A,B,C,D,E,H,L,F
04039B             1055  ;
04039B C5          1056  OSLOAD:			PUSH	BC			; Stack the size
04039C D5          1057  			PUSH	DE			; Stack the load address
04039D 11 00 06 04 1058  			LD	DE, ACCS		; Buffer address for filename
0403A1 CD 22 00 04 1059  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0403A5 21 00 06 04 1060  			LD	HL, ACCS		; HL: Filename
0403A9 CD 9B 04 04 1061  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0403AD CD AF 04 04 1062  			CALL	EXT_HANDLER		; Get the default handler
0403B1 D1          1063  			POP	DE			; Restore the load address
0403B2 C1          1064  			POP	BC			; Restore the size
0403B3 B7          1065  			OR	A
0403B4 28 60       1066  			JR 	Z, OSLOAD_BBC
0403B6             1067  ;
0403B6             1068  ; Load the file in as a text file
0403B6             1069  ;
0403B6 AF          1070  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0403B7 CD 23 05 04 1071  			CALL	OSOPEN			; Open the file
0403BB 5F          1072  			LD 	E, A 			; The filehandle
0403BC B7          1073  			OR	A
0403BD 3E 04       1074  			LD	A, 4			; File not found error
0403BF 28 5D       1075  			JR	Z, OSERROR		; Jump to error handler
0403C1 CD 3A 00 04 1076  			CALL	NEWIT			; Call NEW to clear the program space
0403C5             1077  ;
0403C5 21 00 06 04 1078  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0403C9             1079  ;
0403C9             1080  ; First skip any whitespace (indents) at the beginning of the input
0403C9             1081  ;
0403C9 CD 3A 05 04 1082  @@:			CALL	OSBGET			; Read the byte into A
0403CD 38 1E       1083  			JR	C, OSLOAD_TXT3		; Is it EOF?
0403CF FE 0A       1084  			CP	LF 			; Is it LF?
0403D1 28 1A       1085  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0403D3 FE 21       1086  			CP	21h			; Is it less than or equal to ASCII space?
0403D5 38 F2       1087  			JR	C, @B 			; Yes, so keep looping
0403D7 77          1088  			LD	(HL), A 		; Store the first character
0403D8 2C          1089  			INC	L
0403D9             1090  ;
0403D9             1091  ; Now read the rest of the line in
0403D9             1092  ;
0403D9 CD 3A 05 04 1093  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0403DD 38 2B       1094  			JR	C, OSLOAD_TXT4		; Is it EOF?
0403DF FE 20       1095  			CP	20h			; Skip if not an ASCII character
0403E1 38 06       1096  			JR	C, @F
0403E3 77          1097  			LD	(HL), A 		; Store in the input buffer
0403E4 2C          1098  			INC	L			; Increment the buffer pointer
0403E5 CA 0A 00 04 1099  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0403E9 FE 0A       1100  @@:			CP	LF			; Check for LF
0403EB 20 EC       1101  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0403ED             1102  ;
0403ED             1103  ; Finally, handle EOL/EOF
0403ED             1104  ;
0403ED 36 0D       1105  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0403EF 7D          1106  			LD	A, L			; Check for minimum line length
0403F0 FE 02       1107  			CP	2			; If it is 2 characters or less (including CR)
0403F2 38 0A       1108  			JR	C, @F			; Then don't bother entering it
0403F4 D5          1109  			PUSH	DE			; Preserve the filehandle
0403F5 CD 43 00 04 1110  			CALL	ONEDIT1			; Enter the line in memory
0403F9 DC 0D 00 04 1111  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0403FD D1          1112  			POP	DE
0403FE CD 4B 05 04 1113  @@:			CALL	OSSTAT			; End of file?
040402 20 C1       1114  			JR	NZ, OSLOAD_TXT1		; No, so loop
040404 CD 32 05 04 1115  			CALL	OSSHUT			; Close the file
040408 37          1116  			SCF				; Flag to BASIC that we're good
040409 C9          1117  			RET
04040A             1118  ;
04040A             1119  ; Special case for BASIC programs with no blank line at the end
04040A             1120  ;
04040A FE 20       1121  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
04040C 38 06       1122  			JR	C, @F
04040E 77          1123  			LD	(HL), A			; Store the character
04040F 2C          1124  			INC	L
040410 CA 0A 00 04 1125  			JP	Z, BAD
040414 18 D7       1126  @@:			JR	OSLOAD_TXT3
040416             1127  
040416             1128  ;
040416             1129  ; Load the file in as a tokenised binary blob
040416             1130  ;
040416             1131  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
040416 3E 01       0001M 			LD	A, function
040418 49 CF       0002M 			RST.LIS	08h
04041A D0          1132  			RET	NC			; If load returns with carry reset - NO ROOM
04041B B7          1133  			OR	A			; If there is no error (A=0)
04041C 37          1134  			SCF				; Need to set carry indicating there was room
04041D C8          1135  			RET	Z			; Return
04041E             1136  ;
04041E F5          1137  OSERROR:		PUSH	AF			; Handle the MOS error
04041F 21 00 06 04 1138  			LD	HL, ACCS		; Address of the buffer
040423 01 00 01 00 1139  			LD	BC, 256			; Length of the buffer
040427 5F          1140  			LD	E, A			; The error code
040428             1141  			MOSCALL	mos_getError		; Copy the error message into the buffer
040428 3E 0F       0001M 			LD	A, function
04042A 49 CF       0002M 			RST.LIS	08h
04042C F1          1142  			POP	AF
04042D E5          1143  			PUSH	HL			; Stack the address of the error (now in ACCS)
04042E C6 7F       1144  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
040430 C3 31 00 04 1145  			JP	EXTERR			; Trigger an external error
040434             1146  
040434             1147  ;OSSAVE - Save an area of memory to a file.
040434             1148  ;   Inputs: HL addresses filename (term CR)
040434             1149  ;           DE = start address of data to save
040434             1150  ;           BC = length of data to save (bytes)
040434             1151  ; Destroys: A,B,C,D,E,H,L,F
040434             1152  ;
040434 C5          1153  OSSAVE:			PUSH	BC			; Stack the size
040435 D5          1154  			PUSH	DE			; Stack the save address
040436 11 00 06 04 1155  			LD	DE, ACCS		; Buffer address for filename
04043A CD 22 00 04 1156  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04043E 21 00 06 04 1157  			LD	HL, ACCS		; HL: Filename
040442 CD 9B 04 04 1158  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
040446 CD AF 04 04 1159  			CALL	EXT_HANDLER		; Get the default handler
04044A D1          1160  			POP	DE			; Restore the save address
04044B C1          1161  			POP	BC			; Restore the size
04044C B7          1162  			OR	A			; Is the extension .BBC
04044D 28 44       1163  			JR	Z, OSSAVE_BBC		; Yes, so use that
04044F             1164  ;
04044F             1165  ; Save the file out as a text file
04044F             1166  ;
04044F 3A 45 09 04 1167  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
040453 F5          1168  			PUSH	AF
040454 AF          1169  			XOR	A
040455 3C          1170  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
040456 32 45 09 04 1171  			LD	(OSWRCHCH), A
04045A CD 23 05 04 1172  			CALL	OSOPEN			; Open the file
04045E 32 46 09 04 1173  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
040462 DD 21 40 09 1174  			LD	IX, LISTON		; Required for LISTIT
       04          
040467 2A 14 09 04 1175  			LD	HL, (PAGE_)		; Get start of program area
04046B D9          1176  			EXX
04046C 01 00 00 00 1177  			LD	BC, 0			; Set the initial indent counters
040470 D9          1178  			EXX
040471 7E          1179  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
040472 B7          1180  			OR	A
040473 28 0F       1181  			JR	Z, OSSAVE_TXT2
040475 23          1182  			INC	HL			; Skip the length byte
040476 11 00 00 00 1183  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
04047A 5E          1184  			LD	E, (HL)			; Get the line number
04047B 23          1185  			INC	HL
04047C 56          1186  			LD	D, (HL)
04047D 23          1187  			INC	HL
04047E CD 37 00 04 1188  			CALL	LISTIT			; List the line
040482 18 ED       1189  			JR	OSSAVE_TXT1
040484 3A 46 09 04 1190  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
040488 5F          1191  			LD	E, A
040489 CD 32 05 04 1192  			CALL	OSSHUT			; Close it
04048D F1          1193  			POP	AF			; Restore the channel
04048E 32 45 09 04 1194  			LD	(OSWRCHCH), A
040492 C9          1195  			RET
040493             1196  ;
040493             1197  ; Save the file out as a tokenised binary blob
040493             1198  ;
040493             1199  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
040493 3E 02       0001M 			LD	A, function
040495 49 CF       0002M 			RST.LIS	08h
040497 B7          1200  			OR	A			; If there is no error (A=0)
040498 C8          1201  			RET	Z			; Just return
040499 18 83       1202  			JR	OSERROR			; Trip an error
04049B             1203  
04049B             1204  ; Check if an extension is specified in the filename
04049B             1205  ; Add a default if not specified
04049B             1206  ; HL: Filename (CSTR format)
04049B             1207  ;
04049B E5          1208  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
04049C 0E 2E       1209  			LD	C, '.'			; Search for dot (marks start of extension)
04049E CD 1F 00 04 1210  			CALL	CSTR_FINDCH
0404A2 B7          1211  			OR	A			; Check for end of string marker
0404A3 20 08       1212  			JR	NZ, @F			; No, so skip as we have an extension at this point
0404A5 11 DF 04 04 1213  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0404A9 CD 19 00 04 1214  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0404AD E1          1215  @@:			POP	HL			; Restore the filename pointer
0404AE C9          1216  			RET
0404AF             1217  
0404AF             1218  ; Check if an extension is valid and, if so, provide a pointer to a handler
0404AF             1219  ; HL: Filename (CSTR format)
0404AF             1220  ; Returns:
0404AF             1221  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0404AF             1222  ;
0404AF E5          1223  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0404B0 0E 2E       1224  			LD	C, '.'			; Find the '.'
0404B2 CD 1F 00 04 1225  			CALL	CSTR_FINDCH
0404B6 11 DF 04 04 1226  			LD	DE, EXT_LOOKUP		; The lookup table
0404BA             1227  ;
0404BA E5          1228  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0404BB CD 1C 00 04 1229  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0404BF E1          1230  			POP	HL			; Restore the pointer to the extension
0404C0 28 19       1231  			JR	Z, EXT_HANDLER_2	; We have a match!
0404C2             1232  ;
0404C2 1A          1233  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0404C3 13          1234  			INC	DE
0404C4 B7          1235  			OR	A
0404C5 20 FB       1236  			JR	NZ, @B
0404C7 13          1237  			INC	DE			; Skip the file extension # byte
0404C8             1238  ;
0404C8 1A          1239  			LD	A, (DE)			; Are we at the end of the table?
0404C9 B7          1240  			OR	A
0404CA 20 EE       1241  			JR	NZ, EXT_HANDLER_1	; No, so loop
0404CC             1242  ;
0404CC 3E CC       1243  			LD      A,204			; Throw a "Bad name" error
0404CE CD 31 00 04 1244          		CALL    EXTERR
0404D2 42 61 64 20 1245          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0404DB             1246  ;
0404DB 13          1247  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0404DC 1A          1248  			LD	A, (DE)
0404DD E1          1249  			POP	HL			; Restore the filename pointer
0404DE C9          1250  			RET
0404DF             1251  ;
0404DF             1252  
0404DF             1253  
0404DF             1254  ; Extension lookup table
0404DF             1255  ; CSTR, TYPE
0404DF             1256  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0404DF             1257  ; 	- 1: Human readable plain text
0404DF             1258  ;
0404DF 2E 42 42 43 1259  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0404E5 2E 54 58 54 1260  			DB	".TXT", 0, 1
       00 01       
0404EB 2E 41 53 43 1261  			DB	".ASC", 0, 1
       00 01       
0404F1 2E 42 41 53 1262  			DB	".BAS", 0, 1
       00 01       
0404F7 00          1263  			DB	0			; End of table
0404F8             1264  
0404F8             1265  ;OSCALL - Intercept page &FF calls and provide an alternative address
0404F8             1266  ;
0404F8             1267  ;&FFF7:	OSCLI	Execute *command.
0404F8             1268  ;&FFF4:	OSBYTE	Various byte-wide functions.
0404F8             1269  ;&FFF1:	OSWORD	Various control block functions.
0404F8             1270  ;&FFEE:	OSWRCH	Write character to output stream.
0404F8             1271  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0404F8             1272  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0404F8             1273  ;&FFE0:	OSRDCH	Wait for character from input stream.
0404F8             1274  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0404F8             1275  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0404F8             1276  ;&FFD7:	OSBGET	Read a byte from an a channel.
0404F8             1277  ;&FFD4:	OSBPUT	Write a byte to a channel.
0404F8             1278  ;&FFD1:	OSGBPB	Read and write blocks of data.
0404F8             1279  ;&FFCE:	OSFIND	Open or close a file.
0404F8             1280  ;
0404F8 21 0E 05 04 1281  OSCALL:			LD	HL, OSCALL_TABLE
0404FC 7E          1282  OSCALL_1:		LD	A, (HL)
0404FD 23          1283  			INC	HL
0404FE FE FF       1284  			CP	FFh
040500 C8          1285  			RET	Z
040501 FD BD       1286  			CP	A, IYL
040503 28 06       1287  			JR	Z, OSCALL_2
040505 D0          1288  			RET	NC
040506 23          1289  			INC	HL
040507 23          1290  			INC	HL
040508 23          1291  			INC	HL
040509 18 F1       1292  			JR	OSCALL_1
04050B ED 31       1293  OSCALL_2:		LD	IY,(HL)
04050D C9          1294  			RET
04050E D4          1295  OSCALL_TABLE:		DB 	D4h
04050F 42 05 04    1296  			DW24 	OSBPUT
040512 D7          1297  			DB 	D7h
040513 3A 05 04    1298  			DW24 	OSBGET
040516 EE          1299  			DB 	EEh
040517 F6 00 04    1300  			DW24 	OSWRCH
04051A F4          1301  			DB	F4h
04051B C0 02 04    1302  			DW24 	OSBYTE
04051E F7          1303  			DB	F7h
04051F 86 01 04    1304  			DW24	OSCLI
040522 FF          1305  			DB	FFh
040523             1306  
040523             1307  ; OSOPEN
040523             1308  ; HL: Pointer to path
040523             1309  ;  F: C Z
040523             1310  ;     x x OPENIN
040523             1311  ; 	  OPENOUT
040523             1312  ;     x	  OPENUP
040523             1313  ; Returns:
040523             1314  ;  A: Filehandle, 0 if cannot open
040523             1315  ;
040523 0E 01       1316  OSOPEN:			LD	C, fa_read
040525 28 06       1317  			JR	Z, @F
040527 0E 32       1318  			LD	C, fa_write | fa_open_append
040529 38 02       1319  			JR	C, @F
04052B 0E 0A       1320  			LD	C, fa_write | fa_create_always
04052D             1321  @@:			MOSCALL	mos_fopen
04052D 3E 0A       0001M 			LD	A, function
04052F 49 CF       0002M 			RST.LIS	08h
040531 C9          1322  			RET
040532             1323  
040532             1324  ;OSSHUT - Close disk file(s).
040532             1325  ; E = file channel
040532             1326  ;  If E=0 all files are closed (except SPOOL)
040532             1327  ; Destroys: A,B,C,D,E,H,L,F
040532             1328  ;
040532 C5          1329  OSSHUT:			PUSH	BC
040533 4B          1330  			LD	C, E
040534             1331  			MOSCALL	mos_fclose
040534 3E 0B       0001M 			LD	A, function
040536 49 CF       0002M 			RST.LIS	08h
040538 C1          1332  			POP	BC
040539 C9          1333  			RET
04053A             1334  
04053A             1335  ; OSBGET - Read a byte from a random disk file.
04053A             1336  ;  E = file channel
04053A             1337  ; Returns
04053A             1338  ;  A = byte read
04053A             1339  ;  Carry set if LAST BYTE of file
04053A             1340  ; Destroys: A,B,C,F
04053A             1341  ;
04053A C5          1342  OSBGET:			PUSH	BC
04053B 4B          1343  			LD	C, E
04053C             1344  			MOSCALL	mos_fgetc
04053C 3E 0C       0001M 			LD	A, function
04053E 49 CF       0002M 			RST.LIS	08h
040540 C1          1345  			POP	BC
040541 C9          1346  			RET
040542             1347  
040542             1348  ; OSBPUT - Write a byte to a random disk file.
040542             1349  ;  E = file channel
040542             1350  ;  A = byte to write
040542             1351  ; Destroys: A,B,C,F
040542             1352  ;
040542 C5          1353  OSBPUT:			PUSH	BC
040543 4B          1354  			LD	C, E
040544 47          1355  			LD	B, A
040545             1356  			MOSCALL	mos_fputc
040545 3E 0D       0001M 			LD	A, function
040547 49 CF       0002M 			RST.LIS	08h
040549 C1          1357  			POP	BC
04054A C9          1358  			RET
04054B             1359  
04054B             1360  ; OSSTAT - Read file status
04054B             1361  ;  E = file channel
04054B             1362  ; Returns
04054B             1363  ;  F: Z flag set - EOF
04054B             1364  ;  A: If Z then A = 0
04054B             1365  ; Destroys: A,D,E,H,L,F
04054B             1366  ;
04054B C5          1367  OSSTAT:			PUSH	BC
04054C 4B          1368  			LD	C, E
04054D             1369  			MOSCALL	mos_feof
04054D 3E 0E       0001M 			LD	A, function
04054F 49 CF       0002M 			RST.LIS	08h
040551 C1          1370  			POP	BC
040552 FE 01       1371  			CP	1
040554 C9          1372  			RET
040555             1373  
040555             1374  ; GETPTR - Return file pointer.
040555             1375  ;    E = file channel
040555             1376  ; Returns:
040555             1377  ; DEHL = pointer (0-&7FFFFF)
040555             1378  ; Destroys: A,B,C,D,E,H,L,F
040555             1379  ;
040555 FD E5       1380  GETPTR:			PUSH		IY
040557 4B          1381  			LD		C, E
040558             1382  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
040558 3E 19       0001M 			LD	A, function
04055A 49 CF       0002M 			RST.LIS	08h
04055C E5          1383  			PUSH		HL
04055D FD E1       1384  			POP		IY		; IYU: Pointer to FIL structure
04055F FD 6E 11    1385  			LD		L, (IY + FIL.fptr + 0)
040562 FD 66 12    1386  			LD		H, (IY + FIL.fptr + 1)
040565 FD 5E 13    1387  			LD		E, (IY + FIL.fptr + 2)
040568 FD 56 14    1388  			LD		D, (IY + FIL.fptr + 3)
04056B FD E1       1389  			POP		IY
04056D C9          1390  			RET
04056E             1391  
04056E             1392  ; PUTPTR - Update file pointer.
04056E             1393  ;    A = file channel
04056E             1394  ; DEHL = new pointer (0-&7FFFFF)
04056E             1395  ; Destroys: A,B,C,D,E,H,L,F
04056E             1396  ;
04056E FD E5       1397  PUTPTR:			PUSH		IY
040570 4F          1398  			LD		C, A  		; C: Filehandle
040571 E5          1399  			PUSH		HL
040572 21 02 00 00 1400  			LD		HL, 2
040576 39          1401  			ADD		HL, SP
040577 73          1402  			LD		(HL), E 	; 3rd byte of DWORD set to E
040578 E1          1403  			POP		HL
040579 5A          1404  			LD		E, D  		; 4th byte passed as E
04057A             1405  			MOSCALL		mos_flseek
04057A 3E 1C       0001M 			LD	A, function
04057C 49 CF       0002M 			RST.LIS	08h
04057E FD E1       1406  			POP		IY
040580 C9          1407  			RET
040581             1408  
040581             1409  ; GETEXT - Find file size.
040581             1410  ;    E = file channel
040581             1411  ; Returns:
040581             1412  ; DEHL = file size (0-&800000)
040581             1413  ; Destroys: A,B,C,D,E,H,L,F
040581             1414  ;
040581 FD E5       1415  GETEXT:         PUSH    IY
040583 4B          1416                  LD      C, E
040584             1417                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
040584 3E 19       0001M 			LD	A, function
040586 49 CF       0002M 			RST.LIS	08h
040588 E5          1418                  PUSH    HL
040589 FD E1       1419                  POP     IY          ; IYU: Pointer to FIL structure
04058B             1420                  ; Access the obj.objsize field using the offset values
04058B FD 6E 0B    1421                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
04058E FD 66 0C    1422                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
040591 FD 5E 0D    1423                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
040594 FD 56 0E    1424                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
040597             1425  
040597 FD E1       1426                  POP     IY
040599 C9          1427  			RET
04059A             1428  
04059A             1429  ; GETIMS - Get time from RTC
04059A             1430  ;
04059A FD E5       1431  GETIMS:			PUSH	IY
04059C 21 00 06 04 1432  			LD	HL, ACCS 		; Where to store the time string
0405A0             1433  			MOSCALL	mos_getrtc
0405A0 3E 12       0001M 			LD	A, function
0405A2 49 CF       0002M 			RST.LIS	08h
0405A4 11 00 06 04 1434  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0405A8 5F          1435  			LD	E, A 			;  E: now points to the end of the string
0405A9 FD E1       1436  			POP	IY
0405AB C9          1437  			RET
0405AC             1438  
0405AC             1439  ; Get two word values from EXPR in DE, HL
0405AC             1440  ; IY: Pointer to expression string
0405AC             1441  ; Returns:
0405AC             1442  ; DE: P1
0405AC             1443  ; HL: P2
0405AC             1444  ;
0405AC CD 2E 00 04 1445  EXPR_W2:		CALL	EXPRI			; Get first parameter
0405B0 D9          1446  			EXX
0405B1 E5          1447  			PUSH	HL
0405B2 CD 10 00 04 1448  			CALL	COMMA
0405B6 CD 2E 00 04 1449  			CALL	EXPRI			; Get second parameter
0405BA D9          1450  			EXX
0405BB D1          1451  			POP	DE
0405BC C9          1452  			RET
0405BD             1453  
0405BD             1454  ; Stuff not implemented yet
0405BD             1455  ;
0405BD C9          1456  RESET:			RET
0405BE             1457  
0405BE             1458  ; Begin ram.asm
0405BE             1459  ;
0405BE             1460  ; Title:	BBC Basic Interpreter - Z80 version
0405BE             1461  ;		RAM Module for BBC Basic Interpreter
0405BE             1462  ;		For use with Version 2.0 of BBC BASIC
0405BE             1463  ;		Standard CP/M Distribution Version
0405BE             1464  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0405BE             1465  ; Modified By:	Dean Belfield
0405BE             1466  ; Created:	12/05/2023
0405BE             1467  ; Last Updated:	26/06/2023
0405BE             1468  ;
0405BE             1469  ; Modinfo:
0405BE             1470  ; 06/06/2023:	Modified to run in ADL mode
0405BE             1471  ; 26/06/2023:	Added temporary stores R0 and R1
0405BE             1472  
0405BE             1473  			; .ASSUME	ADL = 1
0405BE             1474  
0405BE             1475  			; DEFINE	LORAM, SPACE = ROM
0405BE             1476  			; SEGMENT LORAM
0405BE             1477  
0405BE             1478  			; XDEF	ACCS
0405BE             1479  			; XDEF	BUFFER
0405BE             1480  			; XDEF	STAVAR
0405BE             1481  			; XDEF	DYNVAR
0405BE             1482  			; XDEF	FNPTR
0405BE             1483  			; XDEF	PROPTR
0405BE             1484  			; XDEF	PAGE_
0405BE             1485  			; XDEF	TOP
0405BE             1486  			; XDEF	LOMEM
0405BE             1487  			; XDEF 	FREE
0405BE             1488  			; XDEF	HIMEM
0405BE             1489  			; XDEF	LINENO
0405BE             1490  			; XDEF	TRACEN
0405BE             1491  			; XDEF	AUTONO
0405BE             1492  			; XDEF	ERRTRP
0405BE             1493  			; XDEF	ERRTXT
0405BE             1494  			; XDEF	DATPTR
0405BE             1495  			; XDEF	ERL
0405BE             1496  			; XDEF	ERRLIN
0405BE             1497  			; XDEF	RANDOM
0405BE             1498  			; XDEF	COUNT
0405BE             1499  			; XDEF	WIDTH
0405BE             1500  			; XDEF	ERR
0405BE             1501  			; XDEF	LISTON
0405BE             1502  			; XDEF	INCREM
0405BE             1503  
0405BE             1504  			; XDEF	FLAGS
0405BE             1505  			; XDEF	OSWRCHPT
0405BE             1506  			; XDEF	OSWRCHCH
0405BE             1507  			; XDEF	OSWRCHFH
0405BE             1508  			; XDEF	KEYDOWN
0405BE             1509  			; XDEF	KEYASCII
0405BE             1510  			; XDEF	KEYCOUNT
0405BE             1511  
0405BE             1512  			; XDEF	R0
0405BE             1513  			; XDEF	R1
0405BE             1514  
0405BE             1515  			; XDEF	RAM_START
0405BE             1516  			; XDEF	RAM_END
0405BE             1517  			; XDEF	USER
0405BE             1518  
0405BE FF FF FF FF 1519  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
040600             1520  RAM_START:
040600             1521  ;
040600 00 00 00 00 1522  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040700 00 00 00 00 1523  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040800 00 00 00 00 1524  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04086C 00 00 00 00 1525  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
04090E 00 00 00    1526  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
040911 00 00 00    1527  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
040914             1528  ;
040914 00 00 00    1529  PAGE_:          BLKB    3,0               ; Start of User Program
040917 00 00 00    1530  TOP:            BLKB    3,0               ; First Location after User Program
04091A 00 00 00    1531  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
04091D 00 00 00    1532  FREE:           BLKB    3,0               ; First Free Space Byte
040920 00 00 00    1533  HIMEM:          BLKB    3,0               ; First Protected Byte
040923             1534  ;
040923 00 00 00    1535  LINENO:         BLKB    3,0               ; Line Number
040926 00 00 00    1536  TRACEN:         BLKB    3,0               ; Trace Flag
040929 00 00 00    1537  AUTONO:         BLKB    3,0               ; Auto Flag
04092C 00 00 00    1538  ERRTRP:         BLKB    3,0               ; Error Trap
04092F 00 00       1539  ERRTXT:         BLKB    2,0               ; Error Message Pointer
040931 00 00       1540  DATPTR:         BLKB    2,0               ; Data Pointer
040933 00 00       1541  ERL:            BLKB    2,0               ; Error Line
040935 00 00 00    1542  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
040938 00 00 00 00 1543  RANDOM:         BLKB    5,0               ; Random Number
       00          
04093D 00          1544  COUNT:          BLKB    1,0               ; Print Position
04093E 00          1545  WIDTH:          BLKB    1,0               ; Print Width
04093F 00          1546  ERR:            BLKB    1,0               ; Error Number
040940 00          1547  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
040941             1548                                  ; - BIT 0: If set, output a space after the line number
040941             1549                                  ; - BIT 1: If set, then indent FOR/NEXT loops
040941             1550                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
040941             1551                                  ; - BIT 3: If set, then output to buffer for *EDIT
040941             1552                                  ; OPT FLAG (top nibble)
040941             1553                                  ; - BIT 4: If set, then list whilst assembling
040941             1554                                  ; - BIT 5: If set, then assembler errors are reported
040941             1555                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
040941             1556                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040941 00          1557  INCREM:         BLKB    1,0               ; Auto-Increment Value
040942             1558  ;
040942             1559  ; Extra Agon-implementation specific system variables
040942             1560  ;
040942 00          1561  FLAGS:          BLKB    1,0       ; Miscellaneous flags
040943             1562                                  ; - BIT 7: Set if ESC pressed
040943             1563                                  ; - BIT 6: Set to disable ESC
040943 00 00       1564  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
040945 00          1565  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
040946             1566                                  ; - 0: Console
040946             1567                                  ; - 1: File
040946 00          1568  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
040947 00          1569  KEYDOWN:        BLKB    1,0       ; Keydown flag
040948 00          1570  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
040949 00          1571  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
04094A 00 00 00    1572  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
04094D 00 00 00    1573  R1:             BLKB    3,0
040950             1574  
040950             1575  ;
040950             1576  ; This must be at the end
040950             1577  ;
040950             1578  RAM_END:
040950             1579  ; moved to user.asm
040950             1580  ; 			ALIGN	256
040950             1581  ; USER:							; Must be aligned on a page boundary
040950             1582  
040950             1583  ; End ram.asm
040950             1584  
040950             1585  ; Begin user.asm
040950             1586  ; this must be the last include to allow unbounded user space for programs
040950             1587  
040950             1588  			; .ASSUME	ADL = 1
040950             1589  
040950 FF FF FF FF 1590  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040A00             1591  USER:							; Must be aligned on a page boundary
040A00             1592  ; End user.asm
040A00             1593  
040A00             1594  ; Begin equs_bottom.inc
040A00             1595  ; --- Begin equs.inc ---
040A00             1596  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
040A00             1597  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
040A00             1598  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040A00             1599  ; --- End equs.inc ---
040A00             1600  
040A00             1601  ; --- Begin eval.asm ---
040A00             1602  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
040A00             1603  ; 041DFA D6 C6       0258*  			SUB     TCMD
040A00             1604  
040A00             1605  ; --- End eval.asm ---
040A00             1606  
040A00             1607  ; --- Begin exec.asm ---
040A00             1608  ; --- End exec.asm ---
040A00             1609  
040A00             1610  ; --- Begin fpp.asm ---
040A00             1611  ; --- End fpp.asm ---
040A00             1612  
040A00             1613  ; --- Begin init.asm ---
040A00             1614  ; --- End init.asm ---
040A00             1615  
040A00             1616  ; --- Begin main.asm ---
040A00             1617  ; --- End main.asm ---
040A00             1618  
040A00             1619  ; --- Begin mos_api.inc ---
040A00             1620  ; --- End mos_api.inc ---
040A00             1621  
040A00             1622  
040A00             1623  ; End equs_bottom.inc
040A00             1624  
