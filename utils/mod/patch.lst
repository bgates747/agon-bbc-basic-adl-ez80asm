PC     Output      Line
040000 C3 A1 04 00 0001   SKIP_AHEAD: JP BEGIN_HEREISH-0x040000
040004             0002   
040004             0003       include "../src/mos_api.inc"
040004             0001*  ;
040004             0002*  ; Title:	AGON MOS - API for user projects
040004             0003*  ; Author:	Dean Belfield
040004             0004*  ; Created:	03/08/2022
040004             0005*  ; Last Updated:	11/11/2023
040004             0006*  ;
040004             0007*  ; Modinfo:
040004             0008*  ; 05/08/2022:	Added mos_feof
040004             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040004             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040004             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040004             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040004             0013*  ; 13/10/2022:	Added mos_oscli
040004             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040004             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040004             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040004             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040004             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040004             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040004             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040004             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040004             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040004             0023*  ; 19/05/2023:	Added sysvar_scrMode
040004             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040004             0025*  ; 03/08/2023:	Added mos_setkbvector
040004             0026*  ; 10/08/2023:	Added mos_getkbmap
040004             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040004             0028*  
040004             0029*  ; VDP control (VDU 23, 0, n)
040004             0030*  ;
040004             0031*  vdp_gp:			EQU 	80h
040004             0032*  vdp_keycode:		EQU 	81h
040004             0033*  vdp_cursor:		EQU	82h
040004             0034*  vdp_scrchar:		EQU	83h
040004             0035*  vdp_scrpixel:		EQU	84h
040004             0036*  vdp_audio:		EQU	85h
040004             0037*  vdp_mode:		EQU	86h
040004             0038*  vdp_rtc:		EQU	87h
040004             0039*  vdp_keystate:		EQU	88h
040004             0040*  vdp_logicalcoords:	EQU	C0h
040004             0041*  vdp_terminalmode:	EQU	FFh
040004             0042*  
040004             0043*  ; MOS high level functions
040004             0044*  ;
040004             0045*  mos_getkey:		EQU	00h
040004             0046*  mos_load:		EQU	01h
040004             0047*  mos_save:		EQU	02h
040004             0048*  mos_cd:			EQU	03h
040004             0049*  mos_dir:		EQU	04h
040004             0050*  mos_del:		EQU	05h
040004             0051*  mos_ren:		EQU	06h
040004             0052*  mos_mkdir:		EQU	07h
040004             0053*  mos_sysvars:		EQU	08h
040004             0054*  mos_editline:		EQU	09h
040004             0055*  mos_fopen:		EQU	0Ah
040004             0056*  mos_fclose:		EQU	0Bh
040004             0057*  mos_fgetc:		EQU	0Ch
040004             0058*  mos_fputc:		EQU	0Dh
040004             0059*  mos_feof:		EQU	0Eh
040004             0060*  mos_getError:		EQU	0Fh
040004             0061*  mos_oscli:		EQU	10h
040004             0062*  mos_copy:		EQU	11h
040004             0063*  mos_getrtc:		EQU	12h
040004             0064*  mos_setrtc:		EQU	13h
040004             0065*  mos_setintvector:	EQU	14h
040004             0066*  mos_uopen:		EQU	15h
040004             0067*  mos_uclose:		EQU	16h
040004             0068*  mos_ugetc:		EQU	17h
040004             0069*  mos_uputc:		EQU 	18h
040004             0070*  mos_getfil:		EQU	19h
040004             0071*  mos_fread:		EQU	1Ah
040004             0072*  mos_fwrite:		EQU	1Bh
040004             0073*  mos_flseek:		EQU	1Ch
040004             0074*  mos_setkbvector:	EQU	1Dh
040004             0075*  mos_getkbmap:		EQU	1Eh
040004             0076*  mos_i2c_open:		EQU	1Fh
040004             0077*  mos_i2c_close:		EQU	20h
040004             0078*  mos_i2c_write:		EQU	21h
040004             0079*  mos_i2c_read:		EQU	22h
040004             0080*  
040004             0081*  
040004             0082*  ; FatFS file access functions
040004             0083*  ;
040004             0084*  ffs_fopen:		EQU	80h
040004             0085*  ffs_fclose:		EQU	81h
040004             0086*  ffs_fread:		EQU	82h
040004             0087*  ffs_fwrite:		EQU	83h
040004             0088*  ffs_flseek:		EQU	84h
040004             0089*  ffs_ftruncate:		EQU	85h
040004             0090*  ffs_fsync:		EQU	86h
040004             0091*  ffs_fforward:		EQU	87h
040004             0092*  ffs_fexpand:		EQU	88h
040004             0093*  ffs_fgets:		EQU	89h
040004             0094*  ffs_fputc:		EQU	8Ah
040004             0095*  ffs_fputs:		EQU	8Bh
040004             0096*  ffs_fprintf:		EQU	8Ch
040004             0097*  ffs_ftell:		EQU	8Dh
040004             0098*  ffs_feof:		EQU	8Eh
040004             0099*  ffs_fsize:		EQU	8Fh
040004             0100*  ffs_ferror:		EQU	90h
040004             0101*  
040004             0102*  ; FatFS directory access functions
040004             0103*  ;
040004             0104*  ffs_dopen:		EQU	91h
040004             0105*  ffs_dclose:		EQU	92h
040004             0106*  ffs_dread:		EQU	93h
040004             0107*  ffs_dfindfirst:		EQU	94h
040004             0108*  ffs_dfindnext:		EQU	95h
040004             0109*  
040004             0110*  ; FatFS file and directory management functions
040004             0111*  ;
040004             0112*  ffs_stat:		EQU	96h
040004             0113*  ffs_unlink:		EQU	97h
040004             0114*  ffs_rename:		EQU	98h
040004             0115*  ffs_chmod:		EQU	99h
040004             0116*  ffs_utime:		EQU	9Ah
040004             0117*  ffs_mkdir:		EQU	9Bh
040004             0118*  ffs_chdir:		EQU	9Ch
040004             0119*  ffs_chdrive:		EQU	9Dh
040004             0120*  ffs_getcwd:		EQU	9Eh
040004             0121*  
040004             0122*  ; FatFS volume management and system configuration functions
040004             0123*  ;
040004             0124*  ffs_mount:		EQU	9Fh
040004             0125*  ffs_mkfs:		EQU	A0h
040004             0126*  ffs_fdisk:		EQU	A1h
040004             0127*  ffs_getfree:		EQU	A2h
040004             0128*  ffs_getlabel:		EQU	A3h
040004             0129*  ffs_setlabel:		EQU	A4h
040004             0130*  ffs_setcp:		EQU	A5h
040004             0131*  
040004             0132*  ; File access modes
040004             0133*  ;
040004             0134*  fa_read:		EQU	01h
040004             0135*  fa_write:		EQU	02h
040004             0136*  fa_open_existing:	EQU	00h
040004             0137*  fa_create_new:		EQU	04h
040004             0138*  fa_create_always:	EQU	08h
040004             0139*  fa_open_always:		EQU	10h
040004             0140*  fa_open_append:		EQU	30h
040004             0141*  
040004             0142*  ; System variable indexes for api_sysvars
040004             0143*  ; Index into _sysvars in globals.asm
040004             0144*  ;
040004             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040004             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040004             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040004             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040004             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040004             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040004             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040004             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040004             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040004             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040004             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040004             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040004             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040004             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040004             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040004             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040004             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040004             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040004             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040004             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040004             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040004             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040004             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040004             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040004             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040004             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040004             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040004             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040004             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040004             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040004             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040004             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040004             0177*  
040004             0178*  ; Flags for the VPD protocol
040004             0179*  ;
040004             0180*  vdp_pflag_cursor:	EQU	00000001b
040004             0181*  vdp_pflag_scrchar:	EQU	00000010b
040004             0182*  vdp_pflag_point:	EQU	00000100b
040004             0183*  vdp_pflag_audio:	EQU	00001000b
040004             0184*  vdp_pflag_mode:		EQU	00010000b
040004             0185*  vdp_pflag_rtc:		EQU	00100000b
040004             0186*  vdp_pflag_mouse:	EQU	01000000b
040004             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040004             0188*  
040004             0189*  ;
040004             0190*  ; FatFS structures
040004             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040004             0192*  ;
040004             0193*  ; Object ID and allocation information (FFOBJID)
040004             0194*  ;
040004             0195*  ; FFOBJID	.STRUCT
040004             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040004             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040004             0198*  ; 	attr:		DS	1	; Object attribute
040004             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040004             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040004             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040004             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040004             0203*  ; ;
040004             0204*  ; ; File object structure (FIL)
040004             0205*  ; ;
040004             0206*  ; FIL .STRUCT
040004             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040004             0208*  ; 	flag:		DS	1	; File status flags
040004             0209*  ; 	err:		DS	1	; Abort flag (error code)
040004             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040004             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040004             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040004             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040004             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040004             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040004             0216*  ; ;
040004             0217*  ; ; Directory object structure (DIR)
040004             0218*  ; ;
040004             0219*  ; DIR .STRUCT
040004             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040004             0221*  ; 	dptr:		DS	4	; Current read/write offset
040004             0222*  ; 	clust:		DS	4	; Current cluster
040004             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040004             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040004             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040004             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040004             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040004             0228*  ; ;
040004             0229*  ; ; File information structure (FILINFO)
040004             0230*  ; ;
040004             0231*  ; FILINFO .STRUCT
040004             0232*  ; 	fsize:		DS 	4	; File size
040004             0233*  ; 	fdate:		DS	2	; Modified date
040004             0234*  ; 	ftime:		DS	2	; Modified time
040004             0235*  ; 	fattrib:	DS	1	; File attribute
040004             0236*  ; 	altname:	DS	13	; Alternative file name
040004             0237*  ; 	fname:		DS	256	; Primary file name
040004             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040004             0239*  
040004             0240*  ; FFOBJID offsets
040004             0241*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040004             0242*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040004             0243*  FFOBJID.attr:     EQU 5    ; Object attribute
040004             0244*  FFOBJID.stat:     EQU 6    ; Object chain status
040004             0245*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040004             0246*  FFOBJID.objsize:  EQU 11   ; Object size
040004             0247*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040004             0248*  
040004             0249*  ; FIL offsets (including FFOBJID fields)
040004             0250*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040004             0251*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040004             0252*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040004             0253*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040004             0254*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040004             0255*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040004             0256*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040004             0257*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040004             0258*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040004             0259*  
040004             0260*  ; DIR offsets (including FFOBJID fields)
040004             0261*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040004             0262*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040004             0263*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040004             0264*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040004             0265*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040004             0266*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040004             0267*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040004             0268*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040004             0269*  
040004             0270*  ; FILINFO offsets
040004             0271*  FILINFO.fsize:    EQU 0    ; File size
040004             0272*  FILINFO.fdate:    EQU 4    ; Modified date
040004             0273*  FILINFO.ftime:    EQU 6    ; Modified time
040004             0274*  FILINFO.fattrib:  EQU 8    ; File attribute
040004             0275*  FILINFO.altname:  EQU 9    ; Alternative file name
040004             0276*  FILINFO.fname:    EQU 22   ; Primary file name
040004             0277*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040004             0278*  
040004             0279*  ;
040004             0280*  ; Macro for calling the API
040004             0281*  ; Parameters:
040004             0282*  ; - function: One of the function numbers listed above
040004             0283*  ;
040004             0284*  			MACRO MOSCALL	function
040004             0285*  			LD	A, function
040004             0286*  			RST.LIS	08h
040004             0287*  			ENDMACRO
040004             0004       include "../src/macros.inc"
040004             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040004             0002*  	;		Useful macros
040004             0003*  	; Author:	Dean Belfield
040004             0004*  	; Created:	12/05/2023
040004             0005*  	; Last Updated:	11/06/2023
040004             0006*  	;
040004             0007*  	; Modinfo:
040004             0008*  	; 11/06/2023:	Modified to run in ADL mode
040004             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040004             0010*  
040004             0011*  	MACRO EXREG	rp1, rp2
040004             0012*  		PUSH	rp1
040004             0013*  		POP	rp2
040004             0014*  	ENDMACRO
040004             0015*  
040004             0016*  	; MACRO ADD8U_DE	reg
040004             0017*  		MACRO ADD8U_DE
040004             0018*  		ADD	A, E
040004             0019*  		LD	E, A
040004             0020*  		ADC	A, D
040004             0021*  		SUB	E
040004             0022*  		LD	D, A
040004             0023*  	ENDMACRO
040004             0024*  
040004             0025*  	; MACRO ADD8U_HL	reg
040004             0026*  	MACRO ADD8U_HL
040004             0027*  		ADD	A, L
040004             0028*  		LD	L, A
040004             0029*  		ADC	A, H
040004             0030*  		SUB	L
040004             0031*  		LD	H, A
040004             0032*  	ENDMACRO
040004             0033*  
040004             0034*  	MACRO VDU	val
040004             0035*  		LD	A, val
040004             0036*  		CALL	OSWRCH
040004             0037*  	ENDMACRO
040004             0038*  
040004             0039*  	MACRO SET_GPIO	reg, val
040004             0040*  		IN0	A, (reg)
040004             0041*  		OR	val
040004             0042*  		OUT0	(reg), A
040004             0043*  	ENDMACRO
040004             0044*  
040004             0045*  	MACRO RES_GPIO	reg, val
040004             0046*  		PUSH	BC
040004             0047*  		LD	A, val
040004             0048*  		CPL
040004             0049*  		LD	C, A
040004             0050*  		IN0	A, (reg)
040004             0051*  		AND	C
040004             0052*  		OUT0	(reg), A
040004             0053*  		POP	BC
040004             0054*  	ENDMACRO
040004             0005       include "../src/ram.asm"
040004             0001*  ;
040004             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040004             0003*  ;		RAM Module for BBC Basic Interpreter
040004             0004*  ;		For use with Version 2.0 of BBC BASIC
040004             0005*  ;		Standard CP/M Distribution Version
040004             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
040004             0007*  ; Modified By:	Dean Belfield
040004             0008*  ; Created:	12/05/2023
040004             0009*  ; Last Updated:	26/06/2023
040004             0010*  ;
040004             0011*  ; Modinfo:
040004             0012*  ; 06/06/2023:	Modified to run in ADL mode
040004             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
040004             0014*  
040004             0015*  			; .ASSUME	ADL = 1
040004             0016*  
040004             0017*  			; DEFINE	LORAM, SPACE = ROM
040004             0018*  			; SEGMENT LORAM
040004             0019*  
040004             0020*  			; XDEF	ACCS
040004             0021*  			; XDEF	BUFFER
040004             0022*  			; XDEF	STAVAR
040004             0023*  			; XDEF	DYNVAR
040004             0024*  			; XDEF	FNPTR
040004             0025*  			; XDEF	PROPTR
040004             0026*  			; XDEF	PAGE_
040004             0027*  			; XDEF	TOP
040004             0028*  			; XDEF	LOMEM
040004             0029*  			; XDEF 	FREE
040004             0030*  			; XDEF	HIMEM
040004             0031*  			; XDEF	LINENO
040004             0032*  			; XDEF	TRACEN
040004             0033*  			; XDEF	AUTONO
040004             0034*  			; XDEF	ERRTRP
040004             0035*  			; XDEF	ERRTXT
040004             0036*  			; XDEF	DATPTR
040004             0037*  			; XDEF	ERL
040004             0038*  			; XDEF	ERRLIN
040004             0039*  			; XDEF	RANDOM
040004             0040*  			; XDEF	COUNT
040004             0041*  			; XDEF	WIDTH
040004             0042*  			; XDEF	ERR
040004             0043*  			; XDEF	LISTON
040004             0044*  			; XDEF	INCREM
040004             0045*  
040004             0046*  			; XDEF	FLAGS
040004             0047*  			; XDEF	OSWRCHPT
040004             0048*  			; XDEF	OSWRCHCH
040004             0049*  			; XDEF	OSWRCHFH
040004             0050*  			; XDEF	KEYDOWN
040004             0051*  			; XDEF	KEYASCII
040004             0052*  			; XDEF	KEYCOUNT
040004             0053*  
040004             0054*  			; XDEF	R0
040004             0055*  			; XDEF	R1
040004             0056*  
040004             0057*  			; XDEF	RAM_START
040004             0058*  			; XDEF	RAM_END
040004             0059*  			; XDEF	USER
040004             0060*  
040004 FF FF FF FF 0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040100             0062*  RAM_START:
040100             0063*  ;
040100             0064*  ACCS:			DS		256             ; String Accumulator
040200             0065*  BUFFER:			DS		256             ; String Input Buffer
040300             0066*  STAVAR:			DS	 	27*4            ; Static Variables
04036C             0067*  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
04040E             0068*  FNPTR:  		DS    		3               ; Dynamic Function Pointers
040411             0069*  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
040414             0070*  ;
040414             0071*  PAGE_:   		DS		3               ; Start of User Program
040417             0072*  TOP:    		DS		3               ; First Location after User Program
04041A             0073*  LOMEM:  		DS		3               ; Start of Dynamic Storage
04041D             0074*  FREE:   		DS		3               ; First Free Space Byte
040420             0075*  HIMEM:  		DS		3               ; First Protected Byte
040423             0076*  ;
040423             0077*  LINENO: 		DS		3               ; Line Number
040426             0078*  TRACEN:			DS		3               ; Trace Flag
040429             0079*  AUTONO:			DS		3               ; Auto Flag
04042C             0080*  ERRTRP:			DS		3               ; Error Trap
04042F             0081*  ERRTXT:			DS		2               ; Error Message Pointer
040431             0082*  DATPTR:			DS		2               ; Data Pointer
040433             0083*  ERL:			DS		2               ; Error Line
040435             0084*  ERRLIN:			DS		3               ; The "ON ERROR" Line
040438             0085*  RANDOM:			DS		5               ; Random Number
04043D             0086*  COUNT:			DS		1               ; Print Position
04043E             0087*  WIDTH:			DS		1               ; Print Width
04043F             0088*  ERR:			DS		1               ; Error Number
040440             0089*  LISTON:			DS		1               ; LISTO (bottom nibble)
040441             0090*  							; - BIT 0: If set, output a space after the line number
040441             0091*  							; - BIT 1: If set, then indent FOR/NEXT loops
040441             0092*  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
040441             0093*  							; - BIT 3: If set, then output to buffer for *EDIT
040441             0094*  							; OPT FLAG (top nibble)
040441             0095*  							; - BIT 4: If set, then list whilst assembling
040441             0096*  							; - BIT 5: If set, then assembler errors are reported
040441             0097*  							; - BIT 6: If set, then place the code starting at address pointed to by O%
040441             0098*  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040441             0099*  INCREM:			DS		1               ; Auto-Increment Value
040442             0100*  ;
040442             0101*  ; Extra Agon-implementation specific system variables
040442             0102*  ;
040442             0103*  FLAGS:			DS		1		; Miscellaneous flags
040443             0104*  							; - BIT 7: Set if ESC pressed
040443             0105*  							; - BIT 6: Set to disable ESC
040443             0106*  OSWRCHPT:		DS		2		; Pointer for *EDIT
040445             0107*  OSWRCHCH:		DS		1		; Channel of OSWRCH
040446             0108*  							; - 0: Console
040446             0109*  							; - 1: File
040446             0110*  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
040447             0111*  KEYDOWN:		DS		1		; Keydown flag
040448             0112*  KEYASCII:		DS		1		; ASCII code of pressed key
040449             0113*  KEYCOUNT:		DS		1		; Counts every time a key is pressed
04044A             0114*  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
04044D             0115*  R1:			DS		3		;
040450             0116*  ;
040450             0117*  ; This must be at the end
040450             0118*  ;
040450             0119*  RAM_END:
040450             0120*  ; moved to user.asm
040450             0121*  ; 			ALIGN	256
040450             0122*  ; USER:							; Must be aligned on a page boundary
040450             0123*  
040450             0006       include "../src/equs.inc"
040450             0001*  ;
040450             0002*  ; Title:	BBC Basic for AGON - Equs
040450             0003*  ; Author:	Dean Belfield
040450             0004*  ; Created:	12/05/2023
040450             0005*  ; Last Updated:	08/06/2023
040450             0006*  ;
040450             0007*  ; Modinfo:
040450             0008*  ; 08/06/2023:	Added SIZEW
040450             0009*  
040450             0010*  			; XREF		STAVAR
040450             0011*  			; XREF		ACCS
040450             0012*  
040450             0013*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040450             0014*  ;Stack_Top:		EQU		0000h	; Stack at top
040450             0015*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040450             0016*  
040450             0017*  ; For GPIO
040450             0018*  ; PA not available on eZ80L92
040450             0019*  ;
040450             0020*  PA_DR:			EQU		96h
040450             0021*  PA_DDR:			EQU		97h
040450             0022*  PA_ALT1:		EQU		98h
040450             0023*  PA_ALT2:		EQU		99h
040450             0024*  PB_DR:          	EQU		9Ah
040450             0025*  PB_DDR:        	 	EQU		9Bh
040450             0026*  PB_ALT1:        	EQU		9Ch
040450             0027*  PB_ALT2:        	EQU		9Dh
040450             0028*  PC_DR:          	EQU		9Eh
040450             0029*  PC_DDR:         	EQU		9Fh
040450             0030*  PC_ALT1:        	EQU		A0h
040450             0031*  PC_ALT2:        	EQU		A1h
040450             0032*  PD_DR:          	EQU		A2h
040450             0033*  PD_DDR:			EQU		A3h
040450             0034*  PD_ALT1:		EQU		A4h
040450             0035*  PD_ALT2:		EQU		A5h
040450             0036*  
040450             0037*  GPIOMODE_OUT:		EQU		0	; Output
040450             0038*  GPIOMODE_IN:		EQU		1	; Input
040450             0039*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040450             0040*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040450             0041*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040450             0042*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040450             0043*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040450             0044*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040450             0045*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040450             0046*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040450             0047*  
040450             0048*  ; Originally in ram.asm
040450             0049*  ;
040450             0050*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040450             0051*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040450             0052*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040450             0053*  
040450             0054*  ; Originally in main.asm
040450             0055*  ;
040450             0056*  CR:			EQU     0DH
040450             0057*  LF:			EQU     0AH
040450             0058*  ESC:			EQU     1BH
040450             0007   
040450 00 00 04    0008   CLEAN: DL 0x040000
040453             0009   ; Defined in misc.asm
040453 00 00 04    0010   ASC_TO_NUMBER: DL 0x040000
040456             0011   ; Defined in exec.asm
040456 00 00 04    0012   ASSEM: DL 0x040000
040459             0013   ; Defined in main.asm
040459 00 00 04    0014   BAD: DL 0x040000
04045C             0015   ; Defined in eval.asm
04045C 00 00 04    0016   COMMA: DL 0x040000
04045F             0017   ; Defined in eval.asm
04045F 00 00 04    0018   COUNT0: DL 0x040000
040462             0019   ; Defined in main.asm
040462 00 00 04    0020   CRLF: DL 0x040000
040465             0021   ; Defined in misc.asm
040465 00 00 04    0022   CSTR_CAT: DL 0x040000
040468             0023   ; Defined in misc.asm
040468 00 00 04    0024   CSTR_ENDSWITH: DL 0x040000
04046B             0025   ; Defined in misc.asm
04046B 00 00 04    0026   CSTR_FINDCH: DL 0x040000
04046E             0027   ; Defined in misc.asm
04046E 00 00 04    0028   CSTR_FNAME: DL 0x040000
040471             0029   ; Defined in misc.asm
040471 00 00 04    0030   CSTR_LINE: DL 0x040000
040474             0031   ; Defined in main.asm
040474 00 00 04    0032   ERROR_: DL 0x040000
040477             0033   ; Defined in exec.asm
040477 00 00 04    0034   ESCAPE: DL 0x040000
04047A             0035   ; Defined in eval.asm
04047A 00 00 04    0036   EXPRI: DL 0x040000
04047D             0037   ; Defined in main.asm
04047D 00 00 04    0038   EXTERR: DL 0x040000
040480             0039   ; Defined in main.asm
040480 00 00 04    0040   FINDL: DL 0x040000
040483             0041   ; Defined in main.asm
040483 00 00 04    0042   LISTIT: DL 0x040000
040486             0043   ; Defined in main.asm
040486 00 00 04    0044   NEWIT: DL 0x040000
040489             0045   ; Defined in misc.asm
040489 00 00 04    0046   NULLTOCR: DL 0x040000
04048C             0047   ; Defined in main.asm
04048C 00 00 04    0048   ONEDIT: DL 0x040000
04048F             0049   ; Defined in main.asm
04048F 00 00 04    0050   ONEDIT1: DL 0x040000
040492             0051   ; Defined in main.asm
040492 00 00 04    0052   TELL: DL 0x040000
040495             0053   ; Defined in user.asm
040495 00 00 04    0054   USER: DL 0x040000
040498             0055   ; Defined in interrupts.asm
040498 00 00 04    0056   VBLANK_INIT: DL 0x040000
04049B             0057   ; Defined in interrupts.asm
04049B 00 00 04    0058   VBLANK_STOP: DL 0x040000
04049E             0059   ; Defined in init.asm
04049E 00 00 04    0060   _end: DL 0x040000
0404A1             0061   
0404A1             0062   BEGIN_HEREISH:
0404A1             0063       include "../src/patch.asm"
0404A1             0001*  ;
0404A1             0002*  ; Title:	BBC Basic for AGON
0404A1             0003*  ; Author:	Dean Belfield
0404A1             0004*  ; Created:	12/05/2023
0404A1             0005*  ; Last Updated:	15/11/2023
0404A1             0006*  ;
0404A1             0007*  ; Modinfo:
0404A1             0008*  ; 11/07/2023:	Fixed *BYE for ADL mode
0404A1             0009*  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
0404A1             0010*  
0404A1             0011*  			; .ASSUME	ADL = 1
0404A1             0012*  
0404A1             0013*  			; INCLUDE	"equs.inc"
0404A1             0014*  			; INCLUDE "macros.inc"
0404A1             0015*  			; INCLUDE "mos_api.inc"	; In MOS/src
0404A1             0016*  
0404A1             0017*  			; SEGMENT CODE
0404A1             0018*  
0404A1             0019*  			; XDEF	OSWRCH
0404A1             0020*  			; XDEF	OSLINE
0404A1             0021*  			; XDEF	ESCSET
0404A1             0022*  			; XDEF	PUTIME
0404A1             0023*  			; XDEF	GETIME
0404A1             0024*  			; XDEF	PUTCSR
0404A1             0025*  			; XDEF 	GETCSR
0404A1             0026*  			; XDEF	OSRDCH
0404A1             0027*  			; XDEF	PROMPT
0404A1             0028*  			; XDEF	OSKEY
0404A1             0029*  			; XDEF	TRAP
0404A1             0030*  			; XDEF	LTRAP
0404A1             0031*  			; XDEF	OSINIT
0404A1             0032*  			; XDEF	OSCLI
0404A1             0033*  			; XDEF	OSBPUT
0404A1             0034*  			; XDEF	OSBGET
0404A1             0035*  			; XDEF	OSSTAT
0404A1             0036*  			; XDEF	OSSHUT
0404A1             0037*  			; XDEF	OSOPEN
0404A1             0038*  			; XDEF	OSCALL
0404A1             0039*  			; XDEF	GETPTR
0404A1             0040*  			; XDEF	PUTPTR
0404A1             0041*  			; XDEF	GETEXT
0404A1             0042*  			; XDEF	GETIMS
0404A1             0043*  			; XDEF	RESET
0404A1             0044*  			; XDEF	OSLOAD
0404A1             0045*  			; XDEF	OSSAVE
0404A1             0046*  			; XDEF	EXPR_W2
0404A1             0047*  			; XDEF	STAR_VERSION
0404A1             0048*  
0404A1             0049*  			; XREF	_end			; In init.asm
0404A1             0050*  
0404A1             0051*  			; XREF	ASC_TO_NUMBER
0404A1             0052*  			; XREF	RAM_START
0404A1             0053*  			; XREF	RAM_END
0404A1             0054*  			; XREF	FLAGS
0404A1             0055*  			; XREF	ESCAPE
0404A1             0056*  			; XREF	USER
0404A1             0057*  			; XREF	RAM_Top
0404A1             0058*  			; XREF	EXTERR
0404A1             0059*  			; XREF	COUNT0
0404A1             0060*  			; XREF	EXPRI
0404A1             0061*  			; XREF	COMMA
0404A1             0062*  			; XREF	XEQ
0404A1             0063*  			; XREF	NXT
0404A1             0064*  			; XREF	NULLTOCR
0404A1             0065*  			; XREF	CRLF
0404A1             0066*  			; XREF	CSTR_FNAME
0404A1             0067*  			; XREF	CSTR_LINE
0404A1             0068*  			; XREF	CSTR_FINDCH
0404A1             0069*  			; XREF	CSTR_ENDSWITH
0404A1             0070*  			; XREF	CSTR_CAT
0404A1             0071*  			; XREF	FINDL
0404A1             0072*  			; XREF	OUT_
0404A1             0073*  			; XREF	ERROR_
0404A1             0074*  			; XREF	ONEDIT
0404A1             0075*  			; XREF	TELL
0404A1             0076*  			; XREF	OSWRCHPT
0404A1             0077*  			; XREF	OSWRCHCH
0404A1             0078*  			; XREF	OSWRCHFH
0404A1             0079*  			; XREF	LISTON
0404A1             0080*  			; XREF	LISTIT
0404A1             0081*  			; XREF	PAGE_
0404A1             0082*  			; XREF	ONEDIT1
0404A1             0083*  			; XREF	CLEAN
0404A1             0084*  			; XREF	NEWIT
0404A1             0085*  			; XREF	BAD
0404A1             0086*  			; XREF	VBLANK_INIT
0404A1             0087*  			; XREF	VBLANK_STOP
0404A1             0088*  			; XREF	KEYDOWN
0404A1             0089*  			; XREF	KEYASCII
0404A1             0090*  			; XREF	WIDTH
0404A1             0091*  			; XREF	ASSEM
0404A1             0092*  
0404A1             0093*  ; OSLINE: Invoke the line editor
0404A1             0094*  ;
0404A1 1E 01       0095*  OSLINE:			LD 	E, 1			; Default is to clear the buffer
0404A3             0096*  
0404A3             0097*  ; Entry point to line editor that does not clear the buffer
0404A3             0098*  ;
0404A3 FD E5       0099*  OSLINE1:		PUSH	IY
0404A5 E5          0100*  			PUSH	HL			; Buffer address
0404A6 01 00 01 00 0101*  			LD	BC, 256			; Buffer length
0404AA             0102*  			MOSCALL	mos_editline		; Call the MOS line editor
0404AA 3E 09       0001*M 			LD	A, function
0404AC 49 CF       0002*M 			RST.LIS	08h
0404AE E1          0103*  			POP	HL			; Pop the address
0404AF FD E1       0104*  			POP	IY
0404B1 F5          0105*  			PUSH	AF			; Stack the return value (key pressed)
0404B2 CD 89 04 04 0106*  			CALL	NULLTOCR		; Turn the 0 character to a CR
0404B6 CD 62 04 04 0107*  			CALL	CRLF			; Display CRLF
0404BA F1          0108*  			POP	AF
0404BB FE 1B       0109*  			CP	1Bh 			; Check if ESC terminated the input
0404BD CA B9 05 04 0110*  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
0404C1 3A 42 04 04 0111*  			LD	A, (FLAGS)		; Otherwise
0404C5 CB BF       0112*  			RES	7, A 			; Clear the escape flag
0404C7 32 42 04 04 0113*  			LD	(FLAGS), A
0404CB CD 90 07 04 0114*  			CALL	WAIT_VBLANK 		; Wait a frame
0404CF AF          0115*   			XOR	A			; Return A = 0
0404D0 32 47 04 04 0116*  			LD	(KEYDOWN), A
0404D4 32 48 04 04 0117*  			LD	(KEYASCII), A
0404D8 C9          0118*  			RET
0404D9             0119*  
0404D9             0120*  ; PUTIME: set current time to DE:HL, in centiseconds.
0404D9             0121*  ;
0404D9 DD E5       0122*  PUTIME:			PUSH 	IX
0404DB             0123*  			MOSCALL	mos_sysvars
0404DB 3E 08       0001*M 			LD	A, function
0404DD 49 CF       0002*M 			RST.LIS	08h
0404DF DD 75 00    0124*  			LD	(IX + sysvar_time + 0), L
0404E2 DD 74 01    0125*  			LD	(IX + sysvar_time + 1), H
0404E5 DD 73 02    0126*  			LD	(IX + sysvar_time + 2), E
0404E8 DD 72 03    0127*  			LD	(IX + sysvar_time + 3), D
0404EB DD E1       0128*  			POP	IX
0404ED C9          0129*  			RET
0404EE             0130*  
0404EE             0131*  ; GETIME: return current time in DE:HL, in centiseconds
0404EE             0132*  ;
0404EE DD E5       0133*  GETIME:			PUSH 	IX
0404F0             0134*  			MOSCALL	mos_sysvars
0404F0 3E 08       0001*M 			LD	A, function
0404F2 49 CF       0002*M 			RST.LIS	08h
0404F4 DD 6E 00    0135*  			LD	L, (IX + sysvar_time + 0)
0404F7 DD 66 01    0136*  			LD	H, (IX + sysvar_time + 1)
0404FA DD 5E 02    0137*  			LD	E, (IX + sysvar_time + 2)
0404FD DD 56 03    0138*  			LD	D, (IX + sysvar_time + 3)
040500 DD E1       0139*  			POP	IX
040502 C9          0140*  			RET
040503             0141*  
040503             0142*  ; PUTCSR: move to cursor to x=DE, y=HL
040503             0143*  ;
040503 3E 1F       0144*  PUTCSR:			LD	A, 1Fh			; TAB
040505 5B D7       0145*  			RST.LIL	10h
040507 7B          0146*  			LD	A, E			; X
040508 5B D7       0147*  			RST.LIL 10h
04050A 7D          0148*  			LD	A, L			; Y
04050B 5B D7       0149*  			RST.LIL 10h
04050D C9          0150*  			RET
04050E             0151*  
04050E             0152*  ; GETCSR: return cursor position in x=DE, y=HL
04050E             0153*  ;
04050E DD E5       0154*  GETCSR:			PUSH	IX			; Get the system vars in IX
040510             0155*  			MOSCALL	mos_sysvars		; Reset the semaphore
040510 3E 08       0001*M 			LD	A, function
040512 49 CF       0002*M 			RST.LIS	08h
040514 DD CB 04 86 0156*  			RES	0, (IX+sysvar_vpd_pflags)
040518             0157*  			VDU	23
040518 3E 17       0001*M 		LD	A, val
04051A CD 42 05 04 0002*M 		CALL	OSWRCH
04051E             0158*  			VDU	0
04051E 3E 00       0001*M 		LD	A, val
040520 CD 42 05 04 0002*M 		CALL	OSWRCH
040524             0159*  			VDU	vdp_cursor
040524 3E 82       0001*M 		LD	A, val
040526 CD 42 05 04 0002*M 		CALL	OSWRCH
04052A DD CB 04 46 0160*  @@:			BIT	0, (IX+sysvar_vpd_pflags)
04052E 28 FA       0161*  			JR	Z, @B			; Wait for the result
040530 16 00       0162*  			LD 	D, 0
040532 62          0163*  			LD	H, D
040533 DD 5E 07    0164*  			LD	E, (IX + sysvar_cursorX)
040536 DD 6E 08    0165*  			LD	L, (IX + sysvar_cursorY)
040539 DD E1       0166*  			POP	IX
04053B C9          0167*  			RET
04053C             0168*  
04053C             0169*  ; PROMPT: output the input prompt
04053C             0170*  ;
04053C 3E 3E       0171*  PROMPT: 		LD	A,'>'
04053E C3 42 05 04 0172*  			JP	OSWRCH
040542             0173*  
040542             0174*  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
040542             0175*  ; A: Character to write
040542             0176*  ;
040542 E5          0177*  OSWRCH:			PUSH	HL
040543 21 40 04 04 0178*  			LD	HL, LISTON		; Fetch the LISTON variable
040547 CB 5E       0179*  			BIT	3, (HL)			; Check whether we are in *EDIT mode
040549 20 0B       0180*  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
04054B             0181*  ;
04054B 2A 45 04 04 0182*  			LD	HL, (OSWRCHCH)		; L: Channel #
04054F 2D          0183*  			DEC	L			; If it is 1
040550 28 10       0184*  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
040552             0185*  ;
040552 E1          0186*  			POP	HL			; Otherwise
040553 5B D7       0187*  			RST.LIL	10h			; Output the character to MOS
040555 C9          0188*  			RET
040556             0189*  ;
040556 2A 43 04 04 0190*  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
04055A 77          0191*  			LD	(HL), A			; Echo the character into the buffer
04055B 23          0192*  			INC	HL			; Increment pointer
04055C 22 43 04 04 0193*  			LD	(OSWRCHPT), HL		; Write pointer back
040560 E1          0194*  			POP	HL
040561 C9          0195*  			RET
040562             0196*  ;
040562 D5          0197*  OSWRCH_FILE:		PUSH	DE
040563 5C          0198*  			LD	E, H			; Filehandle to E
040564 CD 8E 09 04 0199*  			CALL	OSBPUT			; Write the byte out
040568 D1          0200*  			POP	DE
040569 E1          0201*  			POP	HL
04056A C9          0202*  			RET
04056B             0203*  
04056B             0204*  ; OSRDCH: Read a character in from the ESP32 keyboard handler
04056B             0205*  ; This is only called in GETS (eval.asm)
04056B             0206*  ;
04056B             0207*  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
04056B 3E 00       0001*M 			LD	A, function
04056D 49 CF       0002*M 			RST.LIS	08h
04056F FE 1B       0208*  			CP	1Bh
040571 28 46       0209*  			JR	Z, LTRAP1
040573 C9          0210*  			RET
040574             0211*  
040574             0212*  
040574             0213*  ;OSKEY - Read key with time-limit, test for ESCape.
040574             0214*  ;Main function is carried out in user patch.
040574             0215*  ;   Inputs: HL = time limit (centiseconds)
040574             0216*  ;  Outputs: Carry reset if time-out
040574             0217*  ;           If carry set A = character
040574             0218*  ; Destroys: A,H,L,F
040574             0219*  ;
040574 CD A5 05 04 0220*  OSKEY:			CALL	READKEY			; Read the keyboard
040578 28 0A       0221*  			JR	Z, @F 			; Skip if we have a key
04057A 7C          0222*  			LD	A, H 			; Check loop counter
04057B B5          0223*  			OR 	L
04057C C8          0224*  			RET 	Z 			; Return, we've not got a key at this point
04057D CD 90 07 04 0225*  			CALL	WAIT_VBLANK 		; Wait a frame
040581 2B          0226*  			DEC 	HL			; Decrement
040582 18 F0       0227*  			JR	OSKEY 			; And loop
040584             0228*  ;
040584 21 47 04 04 0229*  @@:			LD	HL, KEYDOWN		; We have a key, so
040588 36 00       0230*  			LD	(HL), 0			; clear the keydown flag
04058A FE 1B       0231*  			CP	1BH			; If we are not pressing ESC,
04058C 37          0232*  			SCF 				; then flag we've got a character
04058D C0          0233*  			RET	NZ
04058E             0234*  ;
04058E             0235*  ; ESCSET
04058E             0236*  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
04058E             0237*  ;
04058E E5          0238*  ESCSET: 		PUSH    HL
04058F 21 42 04 04 0239*          		LD      HL,FLAGS		; Pointer to FLAGS
040593 CB 76       0240*          		BIT     6,(HL)			; If bit 6 is set, then
040595 20 02       0241*          		JR      NZ,ESCDIS		; escape is disabled, so skip
040597 CB FE       0242*          		SET     7,(HL)			; Set bit 7, the escape flag
040599 E1          0243*  ESCDIS: 		POP     HL
04059A C9          0244*          		RET
04059B             0245*  ;
04059B             0246*  ; ESCTEST
04059B             0247*  ; Test for ESC key
04059B             0248*  ;
04059B CD A5 05 04 0249*  ESCTEST:		CALL	READKEY			; Read the keyboard
04059F C0          0250*  			RET	NZ			; Skip if no key is pressed
0405A0 FE 1B       0251*  			CP	1BH			; If ESC pressed then
0405A2 28 EA       0252*  			JR	Z,ESCSET		; jump to the escape set routine
0405A4 C9          0253*  			RET
0405A5             0254*  
0405A5             0255*  ; Read the keyboard
0405A5             0256*  ; Returns:
0405A5             0257*  ; - A: ASCII of the pressed key
0405A5             0258*  ; - F: Z if the key is pressed, otherwise NZ
0405A5             0259*  ;
0405A5 3A 47 04 04 0260*  READKEY:		LD	A, (KEYDOWN)		; Get key down
0405A9 3D          0261*  			DEC	A 			; Set Z flag if keydown is 1
0405AA 3A 48 04 04 0262*  			LD	A, (KEYASCII)		; Get key ASCII value
0405AE C9          0263*  			RET
0405AF             0264*  ;
0405AF             0265*  ; TRAP
0405AF             0266*  ; This is called whenever BASIC needs to check for ESC
0405AF             0267*  ;
0405AF CD 9B 05 04 0268*  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
0405B3             0269*  ;
0405B3 3A 42 04 04 0270*  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
0405B7 B7          0271*  			OR	A			; This checks for bit 7; if it is not set then the result will
0405B8 F0          0272*  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
0405B9 21 42 04 04 0273*  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
0405BD CB BE       0274*  			RES	7,(HL)			; Clear the escape pressed flag and
0405BF C3 77 04 04 0275*  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0405C3             0276*  
0405C3             0277*  ;OSINIT - Initialise RAM mapping etc.
0405C3             0278*  ;If BASIC is entered by BBCBASIC FILENAME then file
0405C3             0279*  ;FILENAME.BBC is automatically CHAINed.
0405C3             0280*  ;   Outputs: DE = initial value of HIMEM (top of RAM)
0405C3             0281*  ;            HL = initial value of PAGE (user program)
0405C3             0282*  ;            Z-flag reset indicates AUTO-RUN.
0405C3             0283*  ;  Destroys: A,D,E,H,L,F
0405C3             0284*  ;
0405C3 CD 98 04 04 0285*  OSINIT:			CALL	VBLANK_INIT
0405C7 AF          0286*  			XOR	A
0405C8 21 95 04 04 0287*  			LD 	HL, USER
0405CC 11 00 00 0B 0288*  			LD	DE, RAM_Top
0405D0 5F          0289*  			LD	E, A			; Page boundary
0405D1 C9          0290*  			RET
0405D2             0291*  
0405D2             0292*  ;
0405D2             0293*  ;OSCLI - Process a MOS command
0405D2             0294*  ;
0405D2 CD 46 06 04 0295*  OSCLI: 			CALL    SKIPSP
0405D6 FE 0D       0296*  			CP      CR
0405D8 C8          0297*  			RET     Z
0405D9 FE 7C       0298*  			CP      '|'
0405DB C8          0299*  			RET     Z
0405DC EB          0300*  			EX      DE,HL
0405DD 21 55 06 04 0301*  			LD      HL,COMDS
0405E1 1A          0302*  OSCLI0:			LD      A,(DE)
0405E2 CD 4D 06 04 0303*  			CALL    UPPRC
0405E6 BE          0304*  			CP      (HL)
0405E7 28 0B       0305*  			JR      Z,OSCLI2
0405E9 38 30       0306*  			JR      C,OSCLI6
0405EB CB 7E       0307*  OSCLI1:			BIT     7,(HL)
0405ED 23          0308*  			INC     HL
0405EE 28 FB       0309*  			JR      Z,OSCLI1
0405F0 23          0310*  			INC     HL
0405F1 23          0311*  			INC     HL
0405F2 18 ED       0312*  			JR      OSCLI0
0405F4             0313*  ;
0405F4 D5          0314*  OSCLI2:			PUSH    DE
0405F5 13          0315*  OSCLI3:			INC     DE
0405F6 23          0316*  			INC     HL
0405F7 1A          0317*  			LD      A,(DE)
0405F8 CD 4D 06 04 0318*  			CALL    UPPRC
0405FC FE 2E       0319*  			CP      '.'			; ABBREVIATED?
0405FE 28 0A       0320*  			JR      Z,OSCLI4
040600 AE          0321*  			XOR     (HL)
040601 28 F2       0322*  			JR      Z,OSCLI3
040603 FE 80       0323*  			CP      80H
040605 28 03       0324*  			JR      Z,OSCLI4
040607 D1          0325*  			POP     DE
040608 18 E1       0326*  			JR      OSCLI1
04060A             0327*  ;
04060A F1          0328*  OSCLI4:			POP     AF
04060B 13          0329*  		        INC     DE
04060C CB 7E       0330*  OSCLI5:			BIT     7,(HL)
04060E 23          0331*  			INC     HL
04060F 28 FB       0332*  			JR      Z,OSCLI5
040611 7E          0333*  			LD      A,(HL)
040612 23          0334*  			INC     HL
040613 66          0335*  			LD      H,(HL)
040614 6F          0336*  			LD      L,A
040615 E5          0337*  			PUSH    HL
040616 EB          0338*  			EX      DE,HL
040617 C3 46 06 04 0339*  			JP      SKIPSP
04061B             0340*  ;
04061B EB          0341*  OSCLI6:			EX	DE, HL			; HL: Buffer for command
04061C 11 00 01 04 0342*  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
040620 D5          0343*  			PUSH	DE			; Store buffer address
040621 CD 71 04 04 0344*  			CALL	CSTR_LINE		; Fetch the line
040625 E1          0345*  			POP	HL			; HL: Pointer to command string in ACCS
040626 FD E5       0346*  			PUSH	IY
040628             0347*  			MOSCALL	mos_oscli		; Returns OSCLI error in A
040628 3E 10       0001*M 			LD	A, function
04062A 49 CF       0002*M 			RST.LIS	08h
04062C FD E1       0348*  			POP	IY
04062E B7          0349*  			OR	A			; 0 means MOS returned OK
04062F C8          0350*  			RET	Z			; So don't do anything
040630 C3 6A 08 04 0351*  			JP 	OSERROR			; Otherwise it's a MOS error
040634             0352*  
040634 3E FE       0353*  HUH:    		LD      A,254			; Bad command error
040636 CD 7D 04 04 0354*          		CALL    EXTERR
04063A 42 61 64 20 0355*          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
040645 00          0356*          		DEFB    0
040646             0357*  
040646 7E          0358*  SKIPSP:			LD      A,(HL)
040647 FE 20       0359*          		CP      ' '
040649 C0          0360*          		RET     NZ
04064A 23          0361*          		INC     HL
04064B 18 F9       0362*          		JR      SKIPSP
04064D             0363*  
04064D E6 7F       0364*  UPPRC:  		AND     7FH
04064F FE 60       0365*  			CP      '`'
040651 D8          0366*  			RET     C
040652 E6 5F       0367*  			AND     5FH			; CONVERT TO UPPER CASE
040654 C9          0368*  			RET
040655             0369*  
040655             0370*  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
040655             0371*  ; These must be in alphabetical order
040655             0372*  ;
040655             0373*  COMDS:
040655 41 53 4D    0374*  			DB	"AS","M"+80h		; ASM
040658 73 06       0375*  			DW	STAR_ASM
04065A 42 59 45    0376*  			DB	"BY","E"+80h		; BYE
04065D 7F 06       0377*  			DW	STAR_BYE
04065F 45 44 49 54 0378*  			DB	"EDI","T"+80h		; EDIT
040663 B4 06       0379*  			DW	STAR_EDIT
040665 46 58       0380*  			DB	"F","X"+80h		; FX
040667 F4 06       0381*  			DW	STAR_FX
040669 56 45 52 53 0382*  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
040670 8B 06       0383*  			DW	STAR_VERSION
040672 FF          0384*  			DB	FFh
040673             0385*  
040673             0386*  			; DB	"AS","M"+80h		; ASM
040673             0387*  			; dl	STAR_ASM
040673             0388*  			; DB	"BY","E"+80h		; BYE
040673             0389*  			; dl	STAR_BYE
040673             0390*  			; DB	"EDI","T"+80h		; EDIT
040673             0391*  			; dl	STAR_EDIT
040673             0392*  			; DB	"F","X"+80h		; FX
040673             0393*  			; dl	STAR_FX
040673             0394*  			; DB	"VERSIO","N"+80h	; VERSION
040673             0395*  			; dl	STAR_VERSION
040673             0396*  			; DB	FFh
040673             0397*  
040673             0398*  ; *ASM string
040673             0399*  ;
040673 FD E5       0400*  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
040675 E5          0401*  			PUSH	HL			; HL = IY
040676 FD E1       0402*  			POP	IY
040678 CD 56 04 04 0403*  			CALL	ASSEM			; Invoke the assembler
04067C FD E1       0404*  			POP	IY
04067E C9          0405*  			RET
04067F             0406*  
04067F             0407*  ; *BYE
04067F             0408*  ;
04067F CD 9B 04 04 0409*  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
040683 21 00 00 00 0410*  			LD	HL, 0			; The return value
040687 C3 9E 04 04 0411*  			JP	_end 			; Jump back to the end routine in init.asm
04068B             0412*  
04068B             0413*  ; *VERSION
04068B             0414*  ;
04068B CD 92 04 04 0415*  STAR_VERSION:		CALL    TELL			; Output the welcome message
04068F 42 42 43 20 0416*  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0406B3 C9          0417*  			RET
0406B4             0418*  
0406B4             0419*  ; *EDIT linenum
0406B4             0420*  ;
0406B4 CD 53 04 04 0421*  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0406B8 EB          0422*  			EX	DE, HL			; HL: Line number
0406B9 CD 80 04 04 0423*  			CALL	FINDL			; HL: Address in RAM of tokenised line
0406BD 3E 29       0424*  			LD	A, 41			; F:NZ If the line is not found
0406BF C2 74 04 04 0425*  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0406C3             0426*  ;
0406C3             0427*  ; Use LISTIT to output the line to the ACCS buffer
0406C3             0428*  ;
0406C3 23          0429*  			INC	HL			; Skip the length byte
0406C4 5E          0430*  			LD	E, (HL)			; Fetch the line number
0406C5 23          0431*  			INC	HL
0406C6 56          0432*  			LD	D, (HL)
0406C7 23          0433*  			INC	HL
0406C8 DD 21 00 01 0434*  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0406CD DD 22 43 04 0435*  			LD	(OSWRCHPT), IX
       04          
0406D2 DD 21 40 04 0436*  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0406D7 DD 7E 00    0437*  			LD	A, (IX)			; Store that variable
0406DA F5          0438*  			PUSH	AF
0406DB DD 36 00 09 0439*  			LD	(IX), 09h		; Set to echo to buffer
0406DF CD 83 04 04 0440*  			CALL	LISTIT
0406E3 F1          0441*  			POP	AF
0406E4 DD 77 00    0442*  			LD	(IX), A			; Restore the original LISTON variable
0406E7 21 00 01 04 0443*  			LD	HL, ACCS		; HL: ACCS
0406EB 5D          0444*  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0406EC CD A3 04 04 0445*  			CALL	OSLINE1			; Invoke the editor
0406F0 C3 8C 04 04 0446*  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0406F4             0447*  
0406F4             0448*  ; OSCLI FX n
0406F4             0449*  ;
0406F4 CD 53 04 04 0450*  STAR_FX:		CALL	ASC_TO_NUMBER
0406F8 4B          0451*  			LD	C, E			; C: Save FX #
0406F9 CD 53 04 04 0452*  			CALL	ASC_TO_NUMBER
0406FD 7A          0453*  			LD	A, D  			; Is first parameter > 255?
0406FE B7          0454*  			OR 	A
0406FF 28 03       0455*  			JR	Z, STAR_FX1		; Yes, so skip next bit
040701 EB          0456*  			EX	DE, HL 			; Parameter is 16-bit
040702 18 07       0457*  			JR	STAR_FX2
040704             0458*  ;
040704 43          0459*  STAR_FX1:		LD	B, E 			; B: Save First parameter
040705 CD 53 04 04 0460*  			CALL	ASC_TO_NUMBER		; Fetch second parameter
040709 68          0461*  			LD	L, B 			; L: First parameter
04070A 63          0462*  			LD	H, E 			; H: Second parameter
04070B             0463*  ;
04070B 79          0464*  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
04070C             0465*  ;
04070C             0466*  ; OSBYTE
04070C             0467*  ;  A: FX #
04070C             0468*  ;  L: First parameter
04070C             0469*  ;  H: Second parameter
04070C             0470*  ;
04070C FE 0B       0471*  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
04070E 28 18       0472*  			JR	Z, OSBYTE_0B
040710 FE 0C       0473*  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
040712 28 43       0474*  			JR	Z, OSBYTE_0C
040714 FE 13       0475*  			CP	13H			; *FX 19: Wait for vblank
040716 28 6E       0476*  			JR	Z, OSBYTE_13
040718 FE 76       0477*  			CP	76H			; *FX 118, n: Set keyboard LED
04071A CA A1 07 04 0478*  			JP	Z, OSBYTE_76
04071E FE A0       0479*  			CP	A0H
040720 CA D1 07 04 0480*  			JP	Z, OSBYTE_A0
040724 C3 34 06 04 0481*  			JP	HUH			; Anything else trips an error
040728             0482*  
040728             0483*  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
040728             0484*  ; Parameters:
040728             0485*  ; - HL: Repeat delay
040728             0486*  ;
040728             0487*  OSBYTE_0B:		VDU	23
040728 3E 17       0001*M 		LD	A, val
04072A CD 42 05 04 0002*M 		CALL	OSWRCH
04072E             0488*  			VDU	0
04072E 3E 00       0001*M 		LD	A, val
040730 CD 42 05 04 0002*M 		CALL	OSWRCH
040734             0489*  			VDU	vdp_keystate
040734 3E 88       0001*M 		LD	A, val
040736 CD 42 05 04 0002*M 		CALL	OSWRCH
04073A             0490*  			VDU	L
04073A 7D          0001*M 		LD	A, val
04073B CD 42 05 04 0002*M 		CALL	OSWRCH
04073F             0491*  			VDU	H
04073F 7C          0001*M 		LD	A, val
040740 CD 42 05 04 0002*M 		CALL	OSWRCH
040744             0492*  			VDU	0
040744 3E 00       0001*M 		LD	A, val
040746 CD 42 05 04 0002*M 		CALL	OSWRCH
04074A             0493*  			VDU 	0
04074A 3E 00       0001*M 		LD	A, val
04074C CD 42 05 04 0002*M 		CALL	OSWRCH
040750             0494*  			VDU	255
040750 3E FF       0001*M 		LD	A, val
040752 CD 42 05 04 0002*M 		CALL	OSWRCH
040756 C9          0495*  			RET
040757             0496*  
040757             0497*  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
040757             0498*  ; Parameters:
040757             0499*  ; - HL: Repeat rate
040757             0500*  ;
040757             0501*  OSBYTE_0C:		VDU	23
040757 3E 17       0001*M 		LD	A, val
040759 CD 42 05 04 0002*M 		CALL	OSWRCH
04075D             0502*  			VDU	0
04075D 3E 00       0001*M 		LD	A, val
04075F CD 42 05 04 0002*M 		CALL	OSWRCH
040763             0503*  			VDU	vdp_keystate
040763 3E 88       0001*M 		LD	A, val
040765 CD 42 05 04 0002*M 		CALL	OSWRCH
040769             0504*  			VDU	0
040769 3E 00       0001*M 		LD	A, val
04076B CD 42 05 04 0002*M 		CALL	OSWRCH
04076F             0505*  			VDU 	0
04076F 3E 00       0001*M 		LD	A, val
040771 CD 42 05 04 0002*M 		CALL	OSWRCH
040775             0506*  			VDU	L
040775 7D          0001*M 		LD	A, val
040776 CD 42 05 04 0002*M 		CALL	OSWRCH
04077A             0507*  			VDU	H
04077A 7C          0001*M 		LD	A, val
04077B CD 42 05 04 0002*M 		CALL	OSWRCH
04077F             0508*  			VDU	255
04077F 3E FF       0001*M 		LD	A, val
040781 CD 42 05 04 0002*M 		CALL	OSWRCH
040785 C9          0509*  			RET
040786             0510*  
040786             0511*  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
040786             0512*  ;
040786 CD 90 07 04 0513*  OSBYTE_13:		CALL	WAIT_VBLANK
04078A 2E 00       0514*  			LD	L, 0			; Returns 0
04078C C3 5F 04 04 0515*  			JP	COUNT0
040790             0516*  ;
040790 DD E5       0517*  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
040792             0518*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
040792 3E 08       0001*M 			LD	A, function
040794 49 CF       0002*M 			RST.LIS	08h
040796 DD 7E 00    0519*  			LD	A, (IX + sysvar_time + 0)
040799 DD BE 00    0520*  @@:			CP 	A, (IX + sysvar_time + 0)
04079C 28 FB       0521*  			JR	Z, @B
04079E DD E1       0522*  			POP	IX
0407A0 C9          0523*  			RET
0407A1             0524*  
0407A1             0525*  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0407A1             0526*  ; Parameters:
0407A1             0527*  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0407A1             0528*  ;
0407A1             0529*  OSBYTE_76:		VDU	23
0407A1 3E 17       0001*M 		LD	A, val
0407A3 CD 42 05 04 0002*M 		CALL	OSWRCH
0407A7             0530*  			VDU	0
0407A7 3E 00       0001*M 		LD	A, val
0407A9 CD 42 05 04 0002*M 		CALL	OSWRCH
0407AD             0531*  			VDU	vdp_keystate
0407AD 3E 88       0001*M 		LD	A, val
0407AF CD 42 05 04 0002*M 		CALL	OSWRCH
0407B3             0532*  			VDU	0
0407B3 3E 00       0001*M 		LD	A, val
0407B5 CD 42 05 04 0002*M 		CALL	OSWRCH
0407B9             0533*  			VDU 	0
0407B9 3E 00       0001*M 		LD	A, val
0407BB CD 42 05 04 0002*M 		CALL	OSWRCH
0407BF             0534*  			VDU	0
0407BF 3E 00       0001*M 		LD	A, val
0407C1 CD 42 05 04 0002*M 		CALL	OSWRCH
0407C5             0535*  			VDU	0
0407C5 3E 00       0001*M 		LD	A, val
0407C7 CD 42 05 04 0002*M 		CALL	OSWRCH
0407CB             0536*  			VDU	L
0407CB 7D          0001*M 		LD	A, val
0407CC CD 42 05 04 0002*M 		CALL	OSWRCH
0407D0 C9          0537*  			RET
0407D1             0538*  
0407D1             0539*  ; OSBYTE 0xA0: Fetch system variable
0407D1             0540*  ; Parameters:
0407D1             0541*  ; - L: The system variable to fetch
0407D1             0542*  ;
0407D1 DD E5       0543*  OSBYTE_A0:		PUSH	IX
0407D3             0544*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0407D3 3E 08       0001*M 			LD	A, function
0407D5 49 CF       0002*M 			RST.LIS	08h
0407D7 01 00 00 00 0545*  			LD	BC, 0
0407DB 4D          0546*  			LD	C, L			; BCU = L
0407DC DD 09       0547*  			ADD	IX, BC			; Add to IX
0407DE DD 6E 00    0548*  			LD	L, (IX + 0)		; Fetch the return value
0407E1 DD E1       0549*  			POP	IX
0407E3 C3 5F 04 04 0550*  			JP 	COUNT0
0407E7             0551*  
0407E7             0552*  ;OSLOAD - Load an area of memory from a file.
0407E7             0553*  ;   Inputs: HL addresses filename (CR terminated)
0407E7             0554*  ;           DE = address at which to load
0407E7             0555*  ;           BC = maximum allowed size (bytes)
0407E7             0556*  ;  Outputs: Carry reset indicates no room for file.
0407E7             0557*  ; Destroys: A,B,C,D,E,H,L,F
0407E7             0558*  ;
0407E7 C5          0559*  OSLOAD:			PUSH	BC			; Stack the size
0407E8 D5          0560*  			PUSH	DE			; Stack the load address
0407E9 11 00 01 04 0561*  			LD	DE, ACCS		; Buffer address for filename
0407ED CD 6E 04 04 0562*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0407F1 21 00 01 04 0563*  			LD	HL, ACCS		; HL: Filename
0407F5 CD E7 08 04 0564*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0407F9 CD FB 08 04 0565*  			CALL	EXT_HANDLER		; Get the default handler
0407FD D1          0566*  			POP	DE			; Restore the load address
0407FE C1          0567*  			POP	BC			; Restore the size
0407FF B7          0568*  			OR	A
040800 28 60       0569*  			JR 	Z, OSLOAD_BBC
040802             0570*  ;
040802             0571*  ; Load the file in as a text file
040802             0572*  ;
040802 AF          0573*  OSLOAD_TXT:		XOR	A			; Set file attributes to read
040803 CD 6F 09 04 0574*  			CALL	OSOPEN			; Open the file
040807 5F          0575*  			LD 	E, A 			; The filehandle
040808 B7          0576*  			OR	A
040809 3E 04       0577*  			LD	A, 4			; File not found error
04080B 28 5D       0578*  			JR	Z, OSERROR		; Jump to error handler
04080D CD 86 04 04 0579*  			CALL	NEWIT			; Call NEW to clear the program space
040811             0580*  ;
040811 21 00 01 04 0581*  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
040815             0582*  ;
040815             0583*  ; First skip any whitespace (indents) at the beginning of the input
040815             0584*  ;
040815 CD 86 09 04 0585*  @@:			CALL	OSBGET			; Read the byte into A
040819 38 1E       0586*  			JR	C, OSLOAD_TXT3		; Is it EOF?
04081B FE 0A       0587*  			CP	LF 			; Is it LF?
04081D 28 1A       0588*  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
04081F FE 21       0589*  			CP	21h			; Is it less than or equal to ASCII space?
040821 38 F2       0590*  			JR	C, @B 			; Yes, so keep looping
040823 77          0591*  			LD	(HL), A 		; Store the first character
040824 2C          0592*  			INC	L
040825             0593*  ;
040825             0594*  ; Now read the rest of the line in
040825             0595*  ;
040825 CD 86 09 04 0596*  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
040829 38 2B       0597*  			JR	C, OSLOAD_TXT4		; Is it EOF?
04082B FE 20       0598*  			CP	20h			; Skip if not an ASCII character
04082D 38 06       0599*  			JR	C, @F
04082F 77          0600*  			LD	(HL), A 		; Store in the input buffer
040830 2C          0601*  			INC	L			; Increment the buffer pointer
040831 CA 59 04 04 0602*  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
040835 FE 0A       0603*  @@:			CP	LF			; Check for LF
040837 20 EC       0604*  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
040839             0605*  ;
040839             0606*  ; Finally, handle EOL/EOF
040839             0607*  ;
040839 36 0D       0608*  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
04083B 7D          0609*  			LD	A, L			; Check for minimum line length
04083C FE 02       0610*  			CP	2			; If it is 2 characters or less (including CR)
04083E 38 0A       0611*  			JR	C, @F			; Then don't bother entering it
040840 D5          0612*  			PUSH	DE			; Preserve the filehandle
040841 CD 8F 04 04 0613*  			CALL	ONEDIT1			; Enter the line in memory
040845 DC 50 04 04 0614*  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
040849 D1          0615*  			POP	DE
04084A CD 97 09 04 0616*  @@:			CALL	OSSTAT			; End of file?
04084E 20 C1       0617*  			JR	NZ, OSLOAD_TXT1		; No, so loop
040850 CD 7E 09 04 0618*  			CALL	OSSHUT			; Close the file
040854 37          0619*  			SCF				; Flag to BASIC that we're good
040855 C9          0620*  			RET
040856             0621*  ;
040856             0622*  ; Special case for BASIC programs with no blank line at the end
040856             0623*  ;
040856 FE 20       0624*  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
040858 38 06       0625*  			JR	C, @F
04085A 77          0626*  			LD	(HL), A			; Store the character
04085B 2C          0627*  			INC	L
04085C CA 59 04 04 0628*  			JP	Z, BAD
040860 18 D7       0629*  @@:			JR	OSLOAD_TXT3
040862             0630*  
040862             0631*  ;
040862             0632*  ; Load the file in as a tokenised binary blob
040862             0633*  ;
040862             0634*  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
040862 3E 01       0001*M 			LD	A, function
040864 49 CF       0002*M 			RST.LIS	08h
040866 D0          0635*  			RET	NC			; If load returns with carry reset - NO ROOM
040867 B7          0636*  			OR	A			; If there is no error (A=0)
040868 37          0637*  			SCF				; Need to set carry indicating there was room
040869 C8          0638*  			RET	Z			; Return
04086A             0639*  ;
04086A F5          0640*  OSERROR:		PUSH	AF			; Handle the MOS error
04086B 21 00 01 04 0641*  			LD	HL, ACCS		; Address of the buffer
04086F 01 00 01 00 0642*  			LD	BC, 256			; Length of the buffer
040873 5F          0643*  			LD	E, A			; The error code
040874             0644*  			MOSCALL	mos_getError		; Copy the error message into the buffer
040874 3E 0F       0001*M 			LD	A, function
040876 49 CF       0002*M 			RST.LIS	08h
040878 F1          0645*  			POP	AF
040879 E5          0646*  			PUSH	HL			; Stack the address of the error (now in ACCS)
04087A C6 7F       0647*  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
04087C C3 7D 04 04 0648*  			JP	EXTERR			; Trigger an external error
040880             0649*  
040880             0650*  ;OSSAVE - Save an area of memory to a file.
040880             0651*  ;   Inputs: HL addresses filename (term CR)
040880             0652*  ;           DE = start address of data to save
040880             0653*  ;           BC = length of data to save (bytes)
040880             0654*  ; Destroys: A,B,C,D,E,H,L,F
040880             0655*  ;
040880 C5          0656*  OSSAVE:			PUSH	BC			; Stack the size
040881 D5          0657*  			PUSH	DE			; Stack the save address
040882 11 00 01 04 0658*  			LD	DE, ACCS		; Buffer address for filename
040886 CD 6E 04 04 0659*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04088A 21 00 01 04 0660*  			LD	HL, ACCS		; HL: Filename
04088E CD E7 08 04 0661*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
040892 CD FB 08 04 0662*  			CALL	EXT_HANDLER		; Get the default handler
040896 D1          0663*  			POP	DE			; Restore the save address
040897 C1          0664*  			POP	BC			; Restore the size
040898 B7          0665*  			OR	A			; Is the extension .BBC
040899 28 44       0666*  			JR	Z, OSSAVE_BBC		; Yes, so use that
04089B             0667*  ;
04089B             0668*  ; Save the file out as a text file
04089B             0669*  ;
04089B 3A 45 04 04 0670*  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
04089F F5          0671*  			PUSH	AF
0408A0 AF          0672*  			XOR	A
0408A1 3C          0673*  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0408A2 32 45 04 04 0674*  			LD	(OSWRCHCH), A
0408A6 CD 6F 09 04 0675*  			CALL	OSOPEN			; Open the file
0408AA 32 46 04 04 0676*  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0408AE DD 21 40 04 0677*  			LD	IX, LISTON		; Required for LISTIT
       04          
0408B3 2A 14 04 04 0678*  			LD	HL, (PAGE_)		; Get start of program area
0408B7 D9          0679*  			EXX
0408B8 01 00 00 00 0680*  			LD	BC, 0			; Set the initial indent counters
0408BC D9          0681*  			EXX
0408BD 7E          0682*  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0408BE B7          0683*  			OR	A
0408BF 28 0F       0684*  			JR	Z, OSSAVE_TXT2
0408C1 23          0685*  			INC	HL			; Skip the length byte
0408C2 11 00 00 00 0686*  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0408C6 5E          0687*  			LD	E, (HL)			; Get the line number
0408C7 23          0688*  			INC	HL
0408C8 56          0689*  			LD	D, (HL)
0408C9 23          0690*  			INC	HL
0408CA CD 83 04 04 0691*  			CALL	LISTIT			; List the line
0408CE 18 ED       0692*  			JR	OSSAVE_TXT1
0408D0 3A 46 04 04 0693*  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0408D4 5F          0694*  			LD	E, A
0408D5 CD 7E 09 04 0695*  			CALL	OSSHUT			; Close it
0408D9 F1          0696*  			POP	AF			; Restore the channel
0408DA 32 45 04 04 0697*  			LD	(OSWRCHCH), A
0408DE C9          0698*  			RET
0408DF             0699*  ;
0408DF             0700*  ; Save the file out as a tokenised binary blob
0408DF             0701*  ;
0408DF             0702*  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0408DF 3E 02       0001*M 			LD	A, function
0408E1 49 CF       0002*M 			RST.LIS	08h
0408E3 B7          0703*  			OR	A			; If there is no error (A=0)
0408E4 C8          0704*  			RET	Z			; Just return
0408E5 18 83       0705*  			JR	OSERROR			; Trip an error
0408E7             0706*  
0408E7             0707*  ; Check if an extension is specified in the filename
0408E7             0708*  ; Add a default if not specified
0408E7             0709*  ; HL: Filename (CSTR format)
0408E7             0710*  ;
0408E7 E5          0711*  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0408E8 0E 2E       0712*  			LD	C, '.'			; Search for dot (marks start of extension)
0408EA CD 6B 04 04 0713*  			CALL	CSTR_FINDCH
0408EE B7          0714*  			OR	A			; Check for end of string marker
0408EF 20 08       0715*  			JR	NZ, @F			; No, so skip as we have an extension at this point
0408F1 11 2B 09 04 0716*  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0408F5 CD 65 04 04 0717*  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0408F9 E1          0718*  @@:			POP	HL			; Restore the filename pointer
0408FA C9          0719*  			RET
0408FB             0720*  
0408FB             0721*  ; Check if an extension is valid and, if so, provide a pointer to a handler
0408FB             0722*  ; HL: Filename (CSTR format)
0408FB             0723*  ; Returns:
0408FB             0724*  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0408FB             0725*  ;
0408FB E5          0726*  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0408FC 0E 2E       0727*  			LD	C, '.'			; Find the '.'
0408FE CD 6B 04 04 0728*  			CALL	CSTR_FINDCH
040902 11 2B 09 04 0729*  			LD	DE, EXT_LOOKUP		; The lookup table
040906             0730*  ;
040906 E5          0731*  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
040907 CD 68 04 04 0732*  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
04090B E1          0733*  			POP	HL			; Restore the pointer to the extension
04090C 28 19       0734*  			JR	Z, EXT_HANDLER_2	; We have a match!
04090E             0735*  ;
04090E 1A          0736*  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
04090F 13          0737*  			INC	DE
040910 B7          0738*  			OR	A
040911 20 FB       0739*  			JR	NZ, @B
040913 13          0740*  			INC	DE			; Skip the file extension # byte
040914             0741*  ;
040914 1A          0742*  			LD	A, (DE)			; Are we at the end of the table?
040915 B7          0743*  			OR	A
040916 20 EE       0744*  			JR	NZ, EXT_HANDLER_1	; No, so loop
040918             0745*  ;
040918 3E CC       0746*  			LD      A,204			; Throw a "Bad name" error
04091A CD 7D 04 04 0747*          		CALL    EXTERR
04091E 42 61 64 20 0748*          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
040927             0749*  ;
040927 13          0750*  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
040928 1A          0751*  			LD	A, (DE)
040929 E1          0752*  			POP	HL			; Restore the filename pointer
04092A C9          0753*  			RET
04092B             0754*  ;
04092B             0755*  
04092B             0756*  
04092B             0757*  ; Extension lookup table
04092B             0758*  ; CSTR, TYPE
04092B             0759*  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
04092B             0760*  ; 	- 1: Human readable plain text
04092B             0761*  ;
04092B 2E 42 42 43 0762*  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
040931 2E 54 58 54 0763*  			DB	".TXT", 0, 1
       00 01       
040937 2E 41 53 43 0764*  			DB	".ASC", 0, 1
       00 01       
04093D 2E 42 41 53 0765*  			DB	".BAS", 0, 1
       00 01       
040943 00          0766*  			DB	0			; End of table
040944             0767*  
040944             0768*  ;OSCALL - Intercept page &FF calls and provide an alternative address
040944             0769*  ;
040944             0770*  ;&FFF7:	OSCLI	Execute *command.
040944             0771*  ;&FFF4:	OSBYTE	Various byte-wide functions.
040944             0772*  ;&FFF1:	OSWORD	Various control block functions.
040944             0773*  ;&FFEE:	OSWRCH	Write character to output stream.
040944             0774*  ;&FFE7:	OSNEWL	Write NewLine to output stream.
040944             0775*  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
040944             0776*  ;&FFE0:	OSRDCH	Wait for character from input stream.
040944             0777*  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
040944             0778*  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
040944             0779*  ;&FFD7:	OSBGET	Read a byte from an a channel.
040944             0780*  ;&FFD4:	OSBPUT	Write a byte to a channel.
040944             0781*  ;&FFD1:	OSGBPB	Read and write blocks of data.
040944             0782*  ;&FFCE:	OSFIND	Open or close a file.
040944             0783*  ;
040944 21 5A 09 04 0784*  OSCALL:			LD	HL, OSCALL_TABLE
040948 7E          0785*  OSCALL_1:		LD	A, (HL)
040949 23          0786*  			INC	HL
04094A FE FF       0787*  			CP	FFh
04094C C8          0788*  			RET	Z
04094D FD BD       0789*  			CP	A, IYL
04094F 28 06       0790*  			JR	Z, OSCALL_2
040951 D0          0791*  			RET	NC
040952 23          0792*  			INC	HL
040953 23          0793*  			INC	HL
040954 23          0794*  			INC	HL
040955 18 F1       0795*  			JR	OSCALL_1
040957 ED 31       0796*  OSCALL_2:		LD	IY,(HL)
040959 C9          0797*  			RET
04095A D4          0798*  OSCALL_TABLE:		DB 	D4h
04095B 8E 09 04    0799*  			DW24 	OSBPUT
04095E D7          0800*  			DB 	D7h
04095F 86 09 04    0801*  			DW24 	OSBGET
040962 EE          0802*  			DB 	EEh
040963 42 05 04    0803*  			DW24 	OSWRCH
040966 F4          0804*  			DB	F4h
040967 0C 07 04    0805*  			DW24 	OSBYTE
04096A F7          0806*  			DB	F7h
04096B D2 05 04    0807*  			DW24	OSCLI
04096E FF          0808*  			DB	FFh
04096F             0809*  
04096F             0810*  ; OSOPEN
04096F             0811*  ; HL: Pointer to path
04096F             0812*  ;  F: C Z
04096F             0813*  ;     x x OPENIN
04096F             0814*  ; 	  OPENOUT
04096F             0815*  ;     x	  OPENUP
04096F             0816*  ; Returns:
04096F             0817*  ;  A: Filehandle, 0 if cannot open
04096F             0818*  ;
04096F 0E 01       0819*  OSOPEN:			LD	C, fa_read
040971 28 06       0820*  			JR	Z, @F
040973 0E 32       0821*  			LD	C, fa_write | fa_open_append
040975 38 02       0822*  			JR	C, @F
040977 0E 0A       0823*  			LD	C, fa_write | fa_create_always
040979             0824*  @@:			MOSCALL	mos_fopen
040979 3E 0A       0001*M 			LD	A, function
04097B 49 CF       0002*M 			RST.LIS	08h
04097D C9          0825*  			RET
04097E             0826*  
04097E             0827*  ;OSSHUT - Close disk file(s).
04097E             0828*  ; E = file channel
04097E             0829*  ;  If E=0 all files are closed (except SPOOL)
04097E             0830*  ; Destroys: A,B,C,D,E,H,L,F
04097E             0831*  ;
04097E C5          0832*  OSSHUT:			PUSH	BC
04097F 4B          0833*  			LD	C, E
040980             0834*  			MOSCALL	mos_fclose
040980 3E 0B       0001*M 			LD	A, function
040982 49 CF       0002*M 			RST.LIS	08h
040984 C1          0835*  			POP	BC
040985 C9          0836*  			RET
040986             0837*  
040986             0838*  ; OSBGET - Read a byte from a random disk file.
040986             0839*  ;  E = file channel
040986             0840*  ; Returns
040986             0841*  ;  A = byte read
040986             0842*  ;  Carry set if LAST BYTE of file
040986             0843*  ; Destroys: A,B,C,F
040986             0844*  ;
040986 C5          0845*  OSBGET:			PUSH	BC
040987 4B          0846*  			LD	C, E
040988             0847*  			MOSCALL	mos_fgetc
040988 3E 0C       0001*M 			LD	A, function
04098A 49 CF       0002*M 			RST.LIS	08h
04098C C1          0848*  			POP	BC
04098D C9          0849*  			RET
04098E             0850*  
04098E             0851*  ; OSBPUT - Write a byte to a random disk file.
04098E             0852*  ;  E = file channel
04098E             0853*  ;  A = byte to write
04098E             0854*  ; Destroys: A,B,C,F
04098E             0855*  ;
04098E C5          0856*  OSBPUT:			PUSH	BC
04098F 4B          0857*  			LD	C, E
040990 47          0858*  			LD	B, A
040991             0859*  			MOSCALL	mos_fputc
040991 3E 0D       0001*M 			LD	A, function
040993 49 CF       0002*M 			RST.LIS	08h
040995 C1          0860*  			POP	BC
040996 C9          0861*  			RET
040997             0862*  
040997             0863*  ; OSSTAT - Read file status
040997             0864*  ;  E = file channel
040997             0865*  ; Returns
040997             0866*  ;  F: Z flag set - EOF
040997             0867*  ;  A: If Z then A = 0
040997             0868*  ; Destroys: A,D,E,H,L,F
040997             0869*  ;
040997 C5          0870*  OSSTAT:			PUSH	BC
040998 4B          0871*  			LD	C, E
040999             0872*  			MOSCALL	mos_feof
040999 3E 0E       0001*M 			LD	A, function
04099B 49 CF       0002*M 			RST.LIS	08h
04099D C1          0873*  			POP	BC
04099E FE 01       0874*  			CP	1
0409A0 C9          0875*  			RET
0409A1             0876*  
0409A1             0877*  ; GETPTR - Return file pointer.
0409A1             0878*  ;    E = file channel
0409A1             0879*  ; Returns:
0409A1             0880*  ; DEHL = pointer (0-&7FFFFF)
0409A1             0881*  ; Destroys: A,B,C,D,E,H,L,F
0409A1             0882*  ;
0409A1 FD E5       0883*  GETPTR:			PUSH		IY
0409A3 4B          0884*  			LD		C, E
0409A4             0885*  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0409A4 3E 19       0001*M 			LD	A, function
0409A6 49 CF       0002*M 			RST.LIS	08h
0409A8 E5          0886*  			PUSH		HL
0409A9 FD E1       0887*  			POP		IY		; IYU: Pointer to FIL structure
0409AB FD 6E 11    0888*  			LD		L, (IY + FIL.fptr + 0)
0409AE FD 66 12    0889*  			LD		H, (IY + FIL.fptr + 1)
0409B1 FD 5E 13    0890*  			LD		E, (IY + FIL.fptr + 2)
0409B4 FD 56 14    0891*  			LD		D, (IY + FIL.fptr + 3)
0409B7 FD E1       0892*  			POP		IY
0409B9 C9          0893*  			RET
0409BA             0894*  
0409BA             0895*  ; PUTPTR - Update file pointer.
0409BA             0896*  ;    A = file channel
0409BA             0897*  ; DEHL = new pointer (0-&7FFFFF)
0409BA             0898*  ; Destroys: A,B,C,D,E,H,L,F
0409BA             0899*  ;
0409BA FD E5       0900*  PUTPTR:			PUSH		IY
0409BC 4F          0901*  			LD		C, A  		; C: Filehandle
0409BD E5          0902*  			PUSH		HL
0409BE 21 02 00 00 0903*  			LD		HL, 2
0409C2 39          0904*  			ADD		HL, SP
0409C3 73          0905*  			LD		(HL), E 	; 3rd byte of DWORD set to E
0409C4 E1          0906*  			POP		HL
0409C5 5A          0907*  			LD		E, D  		; 4th byte passed as E
0409C6             0908*  			MOSCALL		mos_flseek
0409C6 3E 1C       0001*M 			LD	A, function
0409C8 49 CF       0002*M 			RST.LIS	08h
0409CA FD E1       0909*  			POP		IY
0409CC C9          0910*  			RET
0409CD             0911*  
0409CD             0912*  ; GETEXT - Find file size.
0409CD             0913*  ;    E = file channel
0409CD             0914*  ; Returns:
0409CD             0915*  ; DEHL = file size (0-&800000)
0409CD             0916*  ; Destroys: A,B,C,D,E,H,L,F
0409CD             0917*  ;
0409CD FD E5       0918*  GETEXT:         PUSH    IY
0409CF 4B          0919*                  LD      C, E
0409D0             0920*                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0409D0 3E 19       0001*M 			LD	A, function
0409D2 49 CF       0002*M 			RST.LIS	08h
0409D4 E5          0921*                  PUSH    HL
0409D5 FD E1       0922*                  POP     IY          ; IYU: Pointer to FIL structure
0409D7             0923*                  ; Access the obj.objsize field using the offset values
0409D7 FD 6E 0B    0924*                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0409DA FD 66 0C    0925*                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0409DD FD 5E 0D    0926*                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0409E0 FD 56 0E    0927*                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0409E3             0928*  
0409E3 FD E1       0929*                  POP     IY
0409E5 C9          0930*  			RET
0409E6             0931*  
0409E6             0932*  ; GETIMS - Get time from RTC
0409E6             0933*  ;
0409E6 FD E5       0934*  GETIMS:			PUSH	IY
0409E8 21 00 01 04 0935*  			LD	HL, ACCS 		; Where to store the time string
0409EC             0936*  			MOSCALL	mos_getrtc
0409EC 3E 12       0001*M 			LD	A, function
0409EE 49 CF       0002*M 			RST.LIS	08h
0409F0 11 00 01 04 0937*  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0409F4 5F          0938*  			LD	E, A 			;  E: now points to the end of the string
0409F5 FD E1       0939*  			POP	IY
0409F7 C9          0940*  			RET
0409F8             0941*  
0409F8             0942*  ; Get two word values from EXPR in DE, HL
0409F8             0943*  ; IY: Pointer to expression string
0409F8             0944*  ; Returns:
0409F8             0945*  ; DE: P1
0409F8             0946*  ; HL: P2
0409F8             0947*  ;
0409F8 CD 7A 04 04 0948*  EXPR_W2:		CALL	EXPRI			; Get first parameter
0409FC D9          0949*  			EXX
0409FD E5          0950*  			PUSH	HL
0409FE CD 5C 04 04 0951*  			CALL	COMMA
040A02 CD 7A 04 04 0952*  			CALL	EXPRI			; Get second parameter
040A06 D9          0953*  			EXX
040A07 D1          0954*  			POP	DE
040A08 C9          0955*  			RET
040A09             0956*  
040A09             0957*  ; Stuff not implemented yet
040A09             0958*  ;
040A09 C9          0959*  RESET:			RET
