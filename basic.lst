PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ; FFOBJID offsets
040000             0241*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0242*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0243*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0244*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0245*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0246*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0247*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0248*  
040000             0249*  ; FIL offsets (including FFOBJID fields)
040000             0250*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0251*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0252*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0253*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0254*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0255*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0256*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0257*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0258*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0259*  
040000             0260*  ; DIR offsets (including FFOBJID fields)
040000             0261*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0262*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0263*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0264*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0265*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0266*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0267*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0268*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0269*  
040000             0270*  ; FILINFO offsets
040000             0271*  FILINFO.fsize:    EQU 0    ; File size
040000             0272*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0273*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0274*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0275*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0276*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0277*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0278*  
040000             0279*  ;
040000             0280*  ; Macro for calling the API
040000             0281*  ; Parameters:
040000             0282*  ; - function: One of the function numbers listed above
040000             0283*  ;
040000             0284*  			MACRO MOSCALL	function
040000             0285*  			LD	A, function
040000             0286*  			RST.LIS	08h
040000             0287*  			ENDMACRO
040000             0002       include "macros.inc"
040000             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040000             0002*  	;		Useful macros
040000             0003*  	; Author:	Dean Belfield
040000             0004*  	; Created:	12/05/2023
040000             0005*  	; Last Updated:	11/06/2023
040000             0006*  	;
040000             0007*  	; Modinfo:
040000             0008*  	; 11/06/2023:	Modified to run in ADL mode
040000             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0010*  
040000             0011*  	MACRO EXREG	rp1, rp2
040000             0012*  		PUSH	rp1
040000             0013*  		POP	rp2
040000             0014*  	ENDMACRO
040000             0015*  
040000             0016*  	; MACRO ADD8U_DE	reg
040000             0017*  		MACRO ADD8U_DE
040000             0018*  		ADD	A, E
040000             0019*  		LD	E, A
040000             0020*  		ADC	A, D
040000             0021*  		SUB	E
040000             0022*  		LD	D, A
040000             0023*  	ENDMACRO
040000             0024*  
040000             0025*  	; MACRO ADD8U_HL	reg
040000             0026*  	MACRO ADD8U_HL
040000             0027*  		ADD	A, L
040000             0028*  		LD	L, A
040000             0029*  		ADC	A, H
040000             0030*  		SUB	L
040000             0031*  		LD	H, A
040000             0032*  	ENDMACRO
040000             0033*  
040000             0034*  	MACRO VDU	val
040000             0035*  		LD	A, val
040000             0036*  		CALL	OSWRCH
040000             0037*  	ENDMACRO
040000             0038*  
040000             0039*  	MACRO SET_GPIO	reg, val
040000             0040*  		IN0	A, (reg)
040000             0041*  		OR	val
040000             0042*  		OUT0	(reg), A
040000             0043*  	ENDMACRO
040000             0044*  
040000             0045*  	MACRO RES_GPIO	reg, val
040000             0046*  		PUSH	BC
040000             0047*  		LD	A, val
040000             0048*  		CPL
040000             0049*  		LD	C, A
040000             0050*  		IN0	A, (reg)
040000             0051*  		AND	C
040000             0052*  		OUT0	(reg), A
040000             0053*  		POP	BC
040000             0054*  	ENDMACRO
040000             0003       include "equs_top.inc"
040000             0001*  ; --- Begin equs.inc ---
040000             0002*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040000             0003*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040000             0004*  PA_DR:			EQU		96h
040000             0005*  PA_DDR:			EQU		97h
040000             0006*  PA_ALT1:		EQU		98h
040000             0007*  PA_ALT2:		EQU		99h
040000             0008*  PB_DR:          	EQU		9Ah
040000             0009*  PB_DDR:        	 	EQU		9Bh
040000             0010*  PB_ALT1:        	EQU		9Ch
040000             0011*  PB_ALT2:        	EQU		9Dh
040000             0012*  PC_DR:          	EQU		9Eh
040000             0013*  PC_DDR:         	EQU		9Fh
040000             0014*  PC_ALT1:        	EQU		A0h
040000             0015*  PC_ALT2:        	EQU		A1h
040000             0016*  PD_DR:          	EQU		A2h
040000             0017*  PD_DDR:			EQU		A3h
040000             0018*  PD_ALT1:		EQU		A4h
040000             0019*  PD_ALT2:		EQU		A5h
040000             0020*  GPIOMODE_OUT:		EQU		0	; Output
040000             0021*  GPIOMODE_IN:		EQU		1	; Input
040000             0022*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0023*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0024*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0025*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0026*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0027*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0028*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0029*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0030*  CR:			EQU     0DH
040000             0031*  LF:			EQU     0AH
040000             0032*  ESC:			EQU     1BH
040000             0033*  ; --- End equs.inc ---
040000             0034*  
040000             0035*  ; --- Begin eval.asm ---
040000             0036*  FUNTOK:			EQU	8DH			; First token number
040000             0037*  ANDK:			EQU     80H
040000             0038*  DIVK:			EQU     81H
040000             0039*  EORK:			EQU     82H
040000             0040*  MODK:			EQU     83H
040000             0041*  ORK:			EQU     84H
040000             0042*  ; --- End eval.asm ---
040000             0043*  
040000             0044*  ; --- Begin exec.asm ---
040000             0045*  ; --- End exec.asm ---
040000             0046*  
040000             0047*  ; --- Begin fpp.asm ---
040000             0048*  BADOP:			EQU     1               ;Bad operation code
040000             0049*  DIVBY0:			EQU     18              ;Division by zero
040000             0050*  TOOBIG_FP:			EQU     20              ;Too big
040000             0051*  NGROOT:			EQU     21              ;Negative root
040000             0052*  LOGRNG:			EQU     22              ;Log range
040000             0053*  ACLOST:			EQU     23              ;Accuracy lost
040000             0054*  EXPRNG:			EQU     24              ;Exp range
040000             0055*  ; --- End fpp.asm ---
040000             0056*  
040000             0057*  ; --- Begin init.asm ---
040000             0058*  ; --- End init.asm ---
040000             0059*  
040000             0060*  ; --- Begin main.asm ---
040000             0061*  DATA_:	EQU     DCH
040000             0062*  DEF_:	EQU     DDH
040000             0063*  DIM:	EQU     DEH
040000             0064*  ELSE_:	EQU     8BH
040000             0065*  FN:	EQU     A4H
040000             0066*  FOR:	EQU     E3H
040000             0067*  GOSUB:	EQU     E4H
040000             0068*  GOTO:	EQU     E5H
040000             0069*  LINE_:	EQU     86H
040000             0070*  LINO:	EQU     8DH
040000             0071*  LOCAL_:	EQU     EAH
040000             0072*  NEXT:	EQU     EDH
040000             0073*  OFF_:	EQU     87H
040000             0074*  ON_:	EQU     EEH
040000             0075*  PROC:	EQU     F2H
040000             0076*  REM:	EQU     F4H
040000             0077*  REN:	EQU     CCH
040000             0078*  REPEAT:	EQU     F5H
040000             0079*  RESTOR:	EQU     F7H
040000             0080*  SPC:	EQU     89H
040000             0081*  STEP:	EQU     88H
040000             0082*  TAB:	EQU     8AH
040000             0083*  TAND:	EQU     80H
040000             0084*  TCALL:	EQU     D6H
040000             0085*  TERROR:	EQU     85H
040000             0086*  TGOSUB:	EQU     E4H
040000             0087*  TGOTO:	EQU     E5H
040000             0088*  THEN:	EQU     8CH
040000             0089*  TIF:	EQU     E7H
040000             0090*  TO:	EQU     B8H
040000             0091*  TON:	EQU     EEH
040000             0092*  TOR:	EQU     84H
040000             0093*  TPROC:	EQU     F2H
040000             0094*  TRACE:	EQU     FCH
040000             0095*  TSTOP:	EQU     FAH
040000             0096*  UNTIL:	EQU     FDH
040000             0097*  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040000             0098*  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040000             0099*  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040000             0100*  ; --- End main.asm ---
040000             0004       include "init.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0003*  ;		Initialisation Code
040000             0004*  ; Author:	Dean Belfield
040000             0005*  ; Created:	12/05/2023
040000             0006*  ; Last Updated:	26/11/2023
040000             0007*  ;
040000             0008*  ; Modinfo:
040000             0009*  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0010*  ; 26/11/2023:	Moved the ram clear routine into here
040000             0011*  
040000             0012*  			; SEGMENT CODE
040000             0013*  
040000             0014*  			; XDEF	_end
040000             0015*  
040000             0016*  			; XREF	_main				; In main.asm
040000             0017*  
040000             0018*  			; XREF	RAM_START			; In ram.asm
040000             0019*  			; XREF	RAM_END
040000             0020*  
040000             0021*  			.ASSUME	ADL = 1
040000             0022*  
040000             0023*  			; INCLUDE	"equs.inc"
040000             0024*  
040000             0025*  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0026*  
040000             0027*  ;
040000             0028*  ; Start in ADL mode
040000             0029*  ;
040000 C3 45 00 04 0030*  			JP	_start				; Jump to start
040004             0031*  ;
040004             0032*  ; The header stuff is from byte 64 onwards
040004             0033*  ;
040004 62 62 63 62 0034*  _exec_name:		DB	"bbcbasic24ez.bin", 0		; The executable name, only used in argv
       61 73 69 63 
       32 34 65 7A 
       2E 62 69 6E 
       00          
040015             0035*  
040015 00 00 00 00 0036*  			ALIGN	64
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
040040             0037*  
040040 4D 4F 53    0038*  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0039*  			DB	00h				; MOS header version 0
040044 01          0040*  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0041*  ;
040045             0042*  ; And the code follows on immediately after the header
040045             0043*  ;
040045 F5          0044*  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0045*  			PUSH		BC
040047 D5          0046*  			PUSH		DE
040048 DD E5       0047*  			PUSH		IX
04004A FD E5       0048*  			PUSH		IY
04004C             0049*  
04004C ED 73 D7 00 0050*  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0051*  
040051 DD 21 DA 00 0052*  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0053*  			PUSH		IX
040058 CD 88 00 04 0054*  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0055*  			POP		IX			; IX: argv
04005E 06 00       0056*  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0057*  			CALL		_clear_ram
040064 C3 EE 2F 04 0058*  			JP		_main			; Start user code
040068             0059*  ;
040068             0060*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0061*  ;
040068 ED 7B D7 00 0062*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0063*  
04006D FD E1       0064*  			POP		IY			; Restore the registers
04006F DD E1       0065*  			POP		IX
040071 D1          0066*  			POP		DE
040072 C1          0067*  			POP		BC
040073 F1          0068*  			POP		AF
040074 C9          0069*  			RET					; Return to MOS
040075             0070*  
040075             0071*  ;Clear the application memory
040075             0072*  ;
040075 C5          0073*  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0074*  			LD		HL, RAM_START
04007A 11 01 4A 04 0075*  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0076*  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0077*  			XOR		A
040083 77          0078*  			LD		(HL), A
040084 ED B0       0079*  			LDIR
040086 C1          0080*  			POP		BC
040087 C9          0081*  			RET
040088             0082*  
040088             0083*  ; Parse the parameter string into a C array
040088             0084*  ; Parameters
040088             0085*  ; - HL: Address of parameter string
040088             0086*  ; - IX: Address for array pointer storage
040088             0087*  ; Returns:
040088             0088*  ; -  C: Number of parameters parsed
040088             0089*  ;
040088 01 04 00 04 0090*  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0091*  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0092*  			INC	IX
040091 DD 23       0093*  			INC	IX
040093 DD 23       0094*  			INC	IX
040095 CD D0 00 04 0095*  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0096*  ;
040099 01 01 00 00 0097*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0098*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0099*  ;
04009F             0100*  _parse_params_1:
04009F C5          0101*  			PUSH	BC			; Stack ARGC
0400A0 E5          0102*  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0103*  			CALL	_get_token		; Get the next token
0400A5 79          0104*  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0105*  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0106*  			POP	BC			; ARGC
0400A8 B7          0107*  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0108*  			RET	Z
0400AA             0109*  ;
0400AA DD 1F 00    0110*  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0111*  			PUSH	HL			; DE=HL
0400AE D1          0112*  			POP	DE
0400AF CD D0 00 04 0113*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0114*  			XOR	A
0400B4 12          0115*  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0116*  			INC	IX
0400B7 DD 23       0117*  			INC	IX
0400B9 DD 23       0118*  			INC	IX			; Advance to next pointer position
0400BB 0C          0119*  			INC	C			; Increment ARGC
0400BC 79          0120*  			LD	A, C			; Check for C >= A
0400BD B8          0121*  			CP	B
0400BE 38 DF       0122*  			JR	C, _parse_params_1	; And loop
0400C0 C9          0123*  			RET
0400C1             0124*  
0400C1             0125*  ; Get the next token
0400C1             0126*  ; Parameters:
0400C1             0127*  ; - HL: Address of parameter string
0400C1             0128*  ; Returns:
0400C1             0129*  ; - HL: Address of first character after token
0400C1             0130*  ; -  C: Length of token (in characters)
0400C1             0131*  ;
0400C1 0E 00       0132*  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0133*  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0134*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0135*  			RET 	Z
0400C6 FE 0D       0136*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0137*  			RET	Z
0400C9 FE 20       0138*  			CP	' '			; Exit if space (end of token)
0400CB C8          0139*  			RET	Z
0400CC 23          0140*  			INC	HL			; Advance to next character
0400CD 0C          0141*  			INC 	C			; Increment length
0400CE 18 F3       0142*  			JR	@B
0400D0             0143*  
0400D0             0144*  ; Skip spaces in the parameter string
0400D0             0145*  ; Parameters:
0400D0             0146*  ; - HL: Address of parameter string
0400D0             0147*  ; Returns:
0400D0             0148*  ; - HL: Address of next none-space character
0400D0             0149*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0150*  ;
0400D0 7E          0151*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0152*  			CP	' '			; Exit if not space
0400D3 C0          0153*  			RET	NZ
0400D4 23          0154*  			INC	HL			; Advance to next character
0400D5 18 F9       0155*  			JR	_skip_spaces		; Increment length
0400D7             0156*  
0400D7             0157*  ; Storage
0400D7             0158*  ;
0400D7             0159*  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0160*  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0005   
04010A             0006       include "eval.asm"
04010A             0001*  ;
04010A             0002*  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0003*  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04010A             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0005*  ; Modified By:	Dean Belfield
04010A             0006*  ; Created:	12/05/2023
04010A             0007*  ; Last Updated:	17/08/2023
04010A             0008*  ;
04010A             0009*  ; Modinfo:
04010A             0010*  ; 07/06/2023:	Modified to run in ADL mode
04010A             0011*  ; 26/06/2023:	Fixed HEX and HEXSTR
04010A             0012*  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04010A             0013*  ; 17/08/2023:	Added binary constants
04010A             0014*  
04010A             0015*  			; .ASSUME	ADL = 1
04010A             0016*  
04010A             0017*  			; INCLUDE	"equs.inc"
04010A             0018*  			; INCLUDE "macros.inc"
04010A             0019*  			; INCLUDE "mos_api.inc"	; In MOS/src
04010A             0020*  
04010A             0021*  			; SEGMENT CODE
04010A             0022*  
04010A             0023*  			; XDEF	EXPR
04010A             0024*  			; XDEF	EXPRN
04010A             0025*  			; XDEF	EXPRI
04010A             0026*  			; XDEF	EXPRS
04010A             0027*  			; XDEF	ITEMI
04010A             0028*  			; XDEF	LOADN
04010A             0029*  			; XDEF	LOAD4
04010A             0030*  			; XDEF	CONS
04010A             0031*  			; XDEF	LOADS
04010A             0032*  			; XDEF	SFIX
04010A             0033*  			; XDEF	VAL0
04010A             0034*  			; XDEF	SEARCH
04010A             0035*  			; XDEF	SWAP
04010A             0036*  			; XDEF	TEST
04010A             0037*  			; XDEF	DECODE
04010A             0038*  			; XDEF	HEXSTR
04010A             0039*  			; XDEF	STR
04010A             0040*  			; XDEF	ZERO
04010A             0041*  			; XDEF	PUSHS
04010A             0042*  			; XDEF	POPS
04010A             0043*  			; XDEF	COMMA
04010A             0044*  			; XDEF	BRAKET
04010A             0045*  			; XDEF	NXT
04010A             0046*  			; XDEF	COUNT0
04010A             0047*  
04010A             0048*  			; XREF	ADVAL
04010A             0049*  			; XREF	FN_EX
04010A             0050*  			; XREF	POINT
04010A             0051*  			; XREF	USR
04010A             0052*  			; XREF	SYNTAX
04010A             0053*  			; XREF	ERROR_
04010A             0054*  			; XREF	CHECK
04010A             0055*  			; XREF	GETVAR
04010A             0056*  			; XREF	LISTON
04010A             0057*  			; XREF	RANGE
04010A             0058*  			; XREF	FPP
04010A             0059*  			; XREF	GETCSR
04010A             0060*  			; XREF	CHANEL
04010A             0061*  			; XREF	OSSTAT
04010A             0062*  			; XREF	OSBGET
04010A             0063*  			; XREF	LOMEM
04010A             0064*  			; XREF	HIMEM
04010A             0065*  			; XREF	PAGE_
04010A             0066*  			; XREF	TOP
04010A             0067*  			; XREF	ERL
04010A             0068*  			; XREF	ERR
04010A             0069*  			; XREF	COUNT
04010A             0070*  			; XREF	OSOPEN
04010A             0071*  			; XREF	GETEXT
04010A             0072*  			; XREF	GETPTR
04010A             0073*  			; XREF	GETIME
04010A             0074*  			; XREF	GETIMS
04010A             0075*  			; XREF	LEXAN2
04010A             0076*  			; XREF	RANDOM
04010A             0077*  			; XREF	STORE5
04010A             0078*  			; XREF	GETSCHR
04010A             0079*  			; XREF	OSRDCH
04010A             0080*  			; XREF	OSKEY
04010A             0081*  			; XREF	INKEY1
04010A             0082*  			; XREF	EXTERR
04010A             0083*  ;
04010A             0084*  ; BINARY FLOATING POINT REPRESENTATION:
04010A             0085*  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04010A             0086*  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04010A             0087*  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04010A             0088*  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04010A             0089*  ;
04010A             0090*  ; BINARY INTEGER REPRESENTATION:
04010A             0091*  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04010A             0092*  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04010A             0093*  ;
04010A             0094*  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04010A             0095*  ;                             EXPONENT - C
04010A             0096*  ;
04010A             0097*  
04010A             0098*  ;
04010A             0099*  ; Table of addresses for functions
04010A             0100*  ;
04010A             0101*  ; FUNTOK:			EQU	8DH			; First token number
04010A             0102*  ;
04010A EB 08 04    0103*  FUNTBL:			DW24	DECODE			; Line number
04010D 99 05 04    0104*  			DW24	OPENIN			; OPENIN
040110 BB 05 04    0105*  			DW24	PTR_EV			; PTR
040113 55 05 04    0106*  			DW24	PAGEV			; PAGE
040116 C5 05 04    0107*  			DW24	TIMEV			; TIME
040119 41 05 04    0108*  			DW24	LOMEMV			; LOMEM
04011C 4B 05 04    0109*  			DW24	HIMEMV			; HIMEM
04011F 19 06 04    0110*  			DW24	ABSV			; ABS
040122 55 06 04    0111*  			DW24	ACS			; ACS
040125 A2 49 04    0112*  			DW24	ADVAL			; ADVAL
040128 2A 05 04    0113*  			DW24	ASC			; ASC
04012B 4D 06 04    0114*  			DW24	ASN			; ASN
04012E 51 06 04    0115*  			DW24	ATN			; ATN
040131 F3 04 04    0116*  			DW24	BGET			; BGET
040134 39 06 04    0117*  			DW24	COS			; COS
040137 80 05 04    0118*  			DW24	COUNTV			; COUNT
04013A 21 06 04    0119*  			DW24	DEG			; DEG
04013D 74 05 04    0120*  			DW24	ERLV			; ERL
040140 7A 05 04    0121*  			DW24	ERRV			; ERR
040143 7E 06 04    0122*  			DW24	EVAL_			; EVAL
040146 41 06 04    0123*  			DW24	EXP			; EXP
040149 B1 05 04    0124*  			DW24	EXT			; EXT
04014C 98 09 04    0125*  			DW24	ZERO			; FALSE
04014F 87 10 04    0126*  			DW24	FN_EX			; FN
040152 11 05 04    0127*  			DW24	GET			; GET
040155 00 05 04    0128*  			DW24	INKEY			; INKEY
040158 30 07 04    0129*  			DW24	INSTR			; INSTR(
04015B 2D 06 04    0130*  			DW24	INT_			; INT
04015E 3A 05 04    0131*  			DW24	LEN			; LEN
040161 45 06 04    0132*  			DW24	LN			; LN
040164 49 06 04    0133*  			DW24	LOG			; LOG
040167 1D 06 04    0134*  			DW24	NOTK			; NOT
04016A 95 05 04    0135*  			DW24	OPENUP			; OPENUP
04016D 92 05 04    0136*  			DW24	OPENOT			; OPENOUT
040170 15 06 04    0137*  			DW24	PI			; PI
040173 C5 44 04    0138*  			DW24	POINT			; POINT(
040176 D2 04 04    0139*  			DW24	POS			; POS
040179 25 06 04    0140*  			DW24	RAD			; RAD
04017C B2 06 04    0141*  			DW24	RND			; RND
04017F 29 06 04    0142*  			DW24	SGN			; SGN
040182 3D 06 04    0143*  			DW24	SIN			; SIN
040185 31 06 04    0144*  			DW24	SQR			; SQR
040188 35 06 04    0145*  			DW24	TAN			; TAN
04018B 5F 05 04    0146*  			DW24	TOPV			; TO(P)
04018E 0A 06 04    0147*  			DW24	TRUE			; TRUE
040191 54 15 04    0148*  			DW24	USR			; USR
040194 6F 06 04    0149*  			DW24	VAL			; VAL
040197 DB 04 04    0150*  			DW24	VPOS			; VPOS
04019A C4 07 04    0151*  			DW24	CHRS			; CHRS
04019D CC 07 04    0152*  			DW24	GETS			; GETS
0401A0 DD 07 04    0153*  			DW24	INKEYS			; INKEYS
0401A3 62 08 04    0154*  			DW24	LEFTS			; LEFTS(
0401A6 2A 08 04    0155*  			DW24	MIDS			; MIDS(
0401A9 82 08 04    0156*  			DW24	RIGHTS			; RIGHTS(
0401AC 4F 09 04    0157*  			DW24	STRS			; STR$
0401AF A3 08 04    0158*  			DW24	STRING_			; STRINGS(
0401B2 E3 04 04    0159*  			DW24	EOF			; EOF
0401B5             0160*  ;
0401B5             0161*  FUNTBL_END:		EQU	$
0401B5             0162*  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0401B5             0163*  ; TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0401B5             0164*  ;
0401B5             0165*  ; ANDK:			EQU     80H
0401B5             0166*  ; DIVK:			EQU     81H
0401B5             0167*  ; EORK:			EQU     82H
0401B5             0168*  ; MODK:			EQU     83H
0401B5             0169*  ; ORK:			EQU     84H
0401B5             0170*  ;
0401B5 F5 05 04    0171*  SOPTBL:			DW24	SLE			; <= (STRING)
0401B8 FE 05 04    0172*  			DW24	SNE			; <>
0401BB EE 05 04    0173*  			DW24	SGE			; >=
0401BE DF 05 04    0174*  			DW24	SLT			; <
0401C1 05 06 04    0175*  			DW24	SEQ			; =
0401C4 E6 05 04    0176*  			DW24	SGT			; >
0401C7             0177*  ;
0401C7             0178*  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0401C7             0179*  ;     Expression type is returned in A'F':
0401C7             0180*  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0401C7             0181*  ;         String - A' bit 7=1, F' sign bit set.
0401C7             0182*  ; Floating-point or integer result returned in HLH'L'C
0401C7             0183*  ; Integer result denoted by C=0 and HLH'L' non-zero.
0401C7             0184*  ; String result returned in string accumulator, DE set.
0401C7             0185*  ;
0401C7             0186*  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0401C7             0187*  ;               (2) ^
0401C7             0188*  ;               (3) * / MOD DIV
0401C7             0189*  ;               (4) + -
0401C7             0190*  ;               (5) = <> <= >= > <
0401C7             0191*  ;               (6) AND
0401C7             0192*  ;               (7) EOR OR
0401C7             0193*  
0401C7             0194*  ;
0401C7             0195*  ; Level 7: EOR and OR
0401C7             0196*  ;
0401C7 CD E0 01 04 0197*  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0401CB FE 82       0198*  EXPR0A:			CP      EORK            	; Is operator EOR?
0401CD 28 03       0199*  			JR      Z,EXPR0B		; Yes, so skip to next bit
0401CF FE 84       0200*  			CP      ORK			; Is operator OR
0401D1 C0          0201*  			RET     NZ			; No, so return
0401D2             0202*  ;
0401D2 CD 46 0A 04 0203*  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0401D6 CD E0 01 04 0204*  			CALL    EXPR1           	; Get second operand
0401DA CD 55 0A 04 0205*  			CALL    DOIT            	; Do the operation
0401DE 18 EB       0206*  			JR      EXPR0A          	; And continue
0401E0             0207*  ;
0401E0             0208*  ; Level 6: AND
0401E0             0209*  ;
0401E0 CD F5 01 04 0210*  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0401E4 FE 80       0211*  EXPR1A:			CP      ANDK			; Is operator AND?
0401E6 C0          0212*  			RET     NZ			; No, so return
0401E7 CD 46 0A 04 0213*  			CALL    SAVE_EV			; Save first operand
0401EB CD F5 01 04 0214*  			CALL    EXPR2			; Get second operand
0401EF CD 55 0A 04 0215*  			CALL    DOIT			; Do the operation
0401F3 18 EF       0216*  			JR      EXPR1A			; And continue
0401F5             0217*  ;
0401F5             0218*  ; Level 5: Comparisons
0401F5             0219*  ;
0401F5 CD 67 02 04 0220*  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0401F9 CD 1D 0A 04 0221*  			CALL    RELOP?			; Is it ">", "=" or "<"?
0401FD C0          0222*  			RET     NZ			; No, so return
0401FE 47          0223*  			LD      B,A			; Store the first operator in B
0401FF FD 23       0224*  			INC     IY              	; Bump over operator
040201 CD 78 0A 04 0225*  			CALL    NXT			;
040205 CD 1D 0A 04 0226*  			CALL    RELOP?          	; Is it a compound operator?
040209 20 09       0227*  			JR      NZ,EXPR2B		; No, so skip next bit
04020B FD 23       0228*  			INC     IY			; Bump over operator
04020D B8          0229*  			CP      B			; Compare with first
04020E CA 9F 0C 04 0230*  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040212 80          0231*  			ADD     A,B
040213 47          0232*  			LD      B,A			; B: Unique code for the compound operator
040214 78          0233*  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040215 08          0234*  			EX      AF,AF'
040216 FA 30 02 04 0235*  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04021A 08          0236*  			EX      AF,AF'
04021B D6 04       0237*  			SUB     4
04021D FE 3A       0238*  			CP      '>'-4
04021F 20 02       0239*  			JR      NZ,EXPR2C
040221 C6 02       0240*  			ADD     A,2
040223 CD 48 0A 04 0241*  EXPR2C:			CALL    SAVE1
040227 CD 67 02 04 0242*  			CALL    EXPR3
04022B CD 55 0A 04 0243*  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04022F C9          0244*  			RET
040230             0245*  ;
040230 08          0246*  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040231 3D          0247*  			DEC     A
040232 E6 07       0248*  			AND     7
040234 CD B9 09 04 0249*  			CALL    PUSHS           	; Save string on the stack
040238 F5          0250*  			PUSH    AF              	; Save the operator
040239 CD 67 02 04 0251*  			CALL    EXPR3           	; Get the second string
04023D 08          0252*  			EX      AF,AF'
04023E F2 3B 03 04 0253*  			JP      P,TYPE_EV_
040242 F1          0254*  			POP     AF
040243 4B          0255*  			LD      C,E             	; Length of string #2
040244 D1          0256*  			POP     DE
040245 21 00 00 00 0257*  			LD      HL,0
040249 39          0258*  			ADD     HL,SP
04024A 43          0259*  			LD      B,E             	; Length of string #1
04024B D5          0260*  			PUSH    DE
04024C 11 00 4A 04 0261*  			LD      DE,ACCS
040250 EB          0262*  			EX      DE,HL
040251 CD 84 0A 04 0263*  			CALL    DISPT2
040255 D1          0264*  			POP     DE
040256 EB          0265*  			EX      DE,HL
040257 7D          0266*  			LD	A,L
040258 21 00 00 00 0267*  			LD	HL,0
04025C 6F          0268*  			LD	L,A
04025D 39          0269*  			ADD     HL,SP
04025E F9          0270*  			LD      SP,HL
04025F EB          0271*  			EX      DE,HL
040260 AF          0272*  			XOR     A               	; Numeric marker
040261 4F          0273*  			LD      C,A             	; Integer marker
040262 08          0274*  			EX      AF,AF'
040263 FD 7E 00    0275*  			LD      A,(IY)
040266 C9          0276*  			RET
040267             0277*  ;
040267             0278*  ; Level 4: + and -
040267             0279*  ;
040267 CD C9 02 04 0280*  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04026B FE 2D       0281*  EXPR3A:			CP      '-'			; Is it "-"?
04026D 28 09       0282*  			JR      Z,EXPR3B		; Yes, so skip the next bit
04026F FE 2B       0283*  			CP      '+'			; Is it "+"?
040271 C0          0284*  			RET     NZ			; No, so return
040272 08          0285*  			EX      AF,AF'			; Get the type
040273 FA 86 02 04 0286*  			JP      M,EXPR3S		; Branch here if string
040277 08          0287*  			EX      AF,AF'
040278 CD 46 0A 04 0288*  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04027C CD C9 02 04 0289*  			CALL    EXPR4			; Fetch the second operator
040280 CD 55 0A 04 0290*  			CALL    DOIT			; Do the operation
040284 18 E5       0291*  			JR      EXPR3A			; And continue
040286             0292*  ;
040286 08          0293*  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040287 FD 23       0294*  			INC     IY              	; Bump past the "+"
040289 CD B9 09 04 0295*  			CALL    PUSHS           	; Save the string on the stack
04028D CD C9 02 04 0296*  			CALL    EXPR4           	; Fetch the second operator
040291 08          0297*  			EX      AF,AF'
040292 F2 3B 03 04 0298*  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
040296 01 00 00 00 0299*  			LD	BC, 0			; Clear BC
04029A 4B          0300*  			LD      C,E             	; C: Length of the second string
04029B D1          0301*  			POP     DE
04029C D5          0302*  			PUSH    DE
04029D 21 00 4A 04 0303*  			LD      HL,ACCS
0402A1 7B          0304*  			LD	A,E			;  E: Length of the first string
0402A2 11 00 4A 04 0305*  			LD      DE,ACCS
0402A6 5F          0306*  			LD	E,A 			; DE: Pointer to the end of the first string
0402A7 79          0307*  			LD      A,C
0402A8 B7          0308*  			OR      A
0402A9 28 0F       0309*  			JR      Z,EXP3S3
0402AB 6F          0310*  			LD      L,A             	; Source
0402AC 83          0311*  			ADD     A,E
0402AD 5F          0312*  			LD      E,A             	; Destination
0402AE 3E 13       0313*  			LD      A,19
0402B0 DA B6 37 04 0314*  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0402B4 D5          0315*  			PUSH    DE
0402B5 1D          0316*  			DEC     E
0402B6 2D          0317*  			DEC     L
0402B7 ED B8       0318*  			LDDR                    	; Copy
0402B9 D1          0319*  			POP     DE
0402BA D9          0320*  EXP3S3:			EXX
0402BB C1          0321*  			POP     BC
0402BC CD E6 09 04 0322*  			CALL    POPS            	; Restore from stack
0402C0 D9          0323*  			EXX
0402C1 F6 80       0324*  			OR      80H             	; Flag as a string
0402C3 08          0325*  			EX      AF,AF'
0402C4 FD 7E 00    0326*  			LD      A,(IY)			; Fetch the next character
0402C7 18 A2       0327*  			JR      EXPR3A			; And continue
0402C9             0328*  ;
0402C9             0329*  ; Level 3: * / MOD DIV
0402C9             0330*  ;
0402C9 CD EA 02 04 0331*  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0402CD FE 2A       0332*  EXPR4A:			CP      '*'			; "*" is valid
0402CF 28 0B       0333*  			JR      Z,EXPR4B
0402D1 FE 2F       0334*  			CP      '/'			; "/" is valid
0402D3 28 07       0335*  			JR      Z,EXPR4B
0402D5 FE 83       0336*  			CP      MODK			; MOD token is valid
0402D7 28 03       0337*  			JR      Z,EXPR4B
0402D9 FE 81       0338*  			CP      DIVK			; DIV token is valid
0402DB C0          0339*  			RET     NZ			; And return if it is anything else
0402DC CD 46 0A 04 0340*  EXPR4B:			CALL    SAVE_EV
0402E0 CD EA 02 04 0341*  			CALL    EXPR5
0402E4 CD 55 0A 04 0342*  			CALL    DOIT
0402E8 18 E3       0343*  			JR      EXPR4A
0402EA             0344*  ;
0402EA             0345*  ; Level 2: ^
0402EA             0346*  ;
0402EA CD CA 03 04 0347*  EXPR5:			CALL    ITEM			; Get variable
0402EE B7          0348*  			OR      A               	; Test type
0402EF 08          0349*  			EX      AF,AF'          	; Save type
0402F0 CD 78 0A 04 0350*  EXPR5A:			CALL    NXT			; Skip spaces
0402F4 FE 5E       0351*  			CP      '^'			; Is the operator "^"?
0402F6 C0          0352*  			RET     NZ			; No, so return
0402F7 CD 46 0A 04 0353*  			CALL    SAVE_EV			; Save first operand
0402FB CD CA 03 04 0354*  			CALL    ITEM			; Get second operand
0402FF B7          0355*  			OR      A			; Test type
040300 08          0356*  			EX      AF,AF'			; Save type
040301 CD 55 0A 04 0357*  			CALL    DOIT			; Do the operation
040305 18 E9       0358*  			JR      EXPR5A			; And continue
040307             0359*  ;
040307             0360*  ; Evaluate a numeric expression
040307             0361*  ;
040307 CD C7 01 04 0362*  EXPRN:			CALL    EXPR			; Evaluate expression
04030B 08          0363*  			EX      AF,AF'			; Get the type
04030C F0          0364*  			RET     P			; And return if it is a number
04030D 18 2C       0365*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04030F             0366*  ;
04030F             0367*  ; Evaluate a fixed-point expression
04030F             0368*  ;
04030F CD C7 01 04 0369*  EXPRI:			CALL    EXPR			; Evaluate the expression
040313 08          0370*  			EX      AF,AF'			; Get the type
040314 F2 67 06 04 0371*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040318 18 21       0372*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04031A             0373*  ;
04031A             0374*  ; Evaluate a string expression
04031A             0375*  ;
04031A CD C7 01 04 0376*  EXPRS:			CALL    EXPR			; Evaluate the expression
04031E 08          0377*  			EX      AF,AF'			; Get the type
04031F F8          0378*  			RET     M			; And return if it is a string
040320 18 19       0379*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040322             0380*  ;
040322             0381*  ; Get a numeric variable
040322             0382*  ;
040322 CD CA 03 04 0383*  ITEMN:			CALL    ITEM			; Get the variable
040326 B7          0384*  			OR      A			; Test the type
040327 F0          0385*  			RET     P			; And return if it is a number
040328 18 11       0386*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04032A             0387*  ;
04032A             0388*  ; Get a fixed-point variable
04032A             0389*  ;
04032A CD CA 03 04 0390*  ITEMI:			CALL    ITEM			; Get the variable
04032E B7          0391*  			OR      A			; Test the type
04032F F2 67 06 04 0392*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040333 18 06       0393*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
040335             0394*  ;
040335             0395*  ; Get a string variable
040335             0396*  ;
040335 CD CA 03 04 0397*  ITEMS:			CALL    ITEM			; Get the variable
040339 B7          0398*  			OR      A			; Test the type
04033A F8          0399*  			RET     M			; If it is a string, then return
04033B             0400*  ;							; Otherwise
04033B 3E 06       0401*  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
04033D C3 B6 37 04 0402*  			JP      ERROR_
040341             0403*  ;
040341             0404*  ; Evaluate a bracketed expression
040341             0405*  ;
040341 CD C7 01 04 0406*  ITEM1:			CALL    EXPR            	; Evaluate the expression
040345 CD 37 0A 04 0407*  			CALL    BRAKET			; Check for closing bracket
040349 08          0408*  			EX      AF,AF'
04034A C9          0409*  			RET
04034B             0410*  ;
04034B             0411*  ; HEX - Get hexadecimal constant.
04034B             0412*  ;   Inputs: ASCII string at (IY)
04034B             0413*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
04034B             0414*  ;           IY updated (points to delimiter)
04034B             0415*  ;
04034B CD 98 09 04 0416*  HEX:			CALL    ZERO			; Set result to 0
04034F CD 00 0A 04 0417*  			CALL    HEXDIG			; Fetch the character from IY
040353 38 1B       0418*  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
040355 FD 23       0419*  HEX1:			INC     IY			; Move pointer to next character
040357 E6 0F       0420*  			AND     0FH			; Clear the top nibble
040359 06 04       0421*  			LD      B,4			; Loop counter
04035B             0422*  ;
04035B D9          0423*  HEX2:			EXX				; Shift the result left B (4) times. This makes
04035C 52 29       0424*  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
04035E D9          0425*  			EXX				; .
04035F 52 ED 6A    0426*  			ADC.S   HL,HL			; .
040362 10 F7       0427*  			DJNZ    HEX2			; And loop
040364 D9          0428*  			EXX
040365 B5          0429*  			OR      L			; OR in the digit
040366 6F          0430*  			LD      L,A
040367 D9          0431*  			EXX
040368             0432*  ;
040368 CD 00 0A 04 0433*  			CALL    HEXDIG			; Fetch the next character
04036C 30 E7       0434*  			JR      NC,HEX1			; If it is a HEX digit then loop
04036E AF          0435*  			XOR     A			; Clear A
04036F C9          0436*  			RET
040370             0437*  ;
040370 3E 1C       0438*  BADHEX:			LD      A,28
040372 C3 B6 37 04 0439*  			JP      ERROR_          	; Error: "Bad HEX"
040376             0440*  ;
040376             0441*  ; BIN - Get binary constant.
040376             0442*  ;   Inputs: ASCII string at (IY)
040376             0443*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040376             0444*  ;           IY updated (points to delimiter)
040376             0445*  ;
040376 CD 98 09 04 0446*  BIN:			CALL    ZERO			; Set result to 0
04037A CD 13 0A 04 0447*  			CALL	BINDIG			; Fetch the character from IY
04037E 38 13       0448*  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
040380 FD 23       0449*  BIN1:			INC	IY			; Move pointer to next character
040382 0F          0450*  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
040383 D9          0451*  			EXX				;
040384 52 ED 6A    0452*  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040387 D9          0453*  			EXX
040388 52 ED 6A    0454*  			ADC.S	HL,HL
04038B CD 13 0A 04 0455*  			CALL	BINDIG			; Fetch the next character
04038F 30 EF       0456*  			JR	NC,BIN1
040391 AF          0457*  			XOR	A			; Clear A
040392 C9          0458*  			RET
040393             0459*  ;
040393 3E 1C       0460*  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
040395 CD CD 37 04 0461*  			CALL	EXTERR
040399 42 61 64 20 0462*  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0403A4             0463*  ;
0403A4             0464*  ; MINUS - Unary minus.
0403A4             0465*  ;   Inputs: IY = text pointer
0403A4             0466*  ;  Outputs: Numeric result, same type as argument.
0403A4             0467*  ;           Result in H'L'HLC
0403A4             0468*  ;
0403A4 CD 22 03 04 0469*  MINUS:			CALL    ITEMN			; Get the numeric argument
0403A8 0D          0470*  MINUS0:			DEC     C			; Check exponent (C)
0403A9 0C          0471*  			INC     C			; If it is zero, then it's either a FP zero or an integer
0403AA 28 06       0472*  			JR      Z,NEGATE_EV        	; So do an integer negation
0403AC             0473*  ;
0403AC 7C          0474*  			LD      A,H			; Do a FP negation by
0403AD EE 80       0475*  			XOR     80H             	; Toggling the sign bit (H)
0403AF 67          0476*  			LD      H,A
0403B0 AF          0477*  			XOR     A               	; Numeric marker
0403B1 C9          0478*  			RET
0403B2             0479*  ;
0403B2 D9          0480*  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0403B3 7C          0481*  			LD      A,H			; First do a one's complement by negating all the bytes
0403B4 2F          0482*  			CPL
0403B5 67          0483*  			LD      H,A
0403B6 7D          0484*  			LD      A,L
0403B7 2F          0485*  			CPL
0403B8 6F          0486*  			LD      L,A
0403B9 D9          0487*  			EXX
0403BA 7C          0488*  			LD      A,H
0403BB 2F          0489*  			CPL
0403BC 67          0490*  			LD      H,A
0403BD 7D          0491*  			LD      A,L
0403BE 2F          0492*  			CPL
0403BF 6F          0493*  			LD      L,A
0403C0 D9          0494*  ADD1:			EXX				; Then add 1
0403C1 23          0495*  			INC     HL
0403C2 7C          0496*  			LD      A,H
0403C3 B5          0497*  			OR      L
0403C4 D9          0498*  			EXX
0403C5 3E 00       0499*  			LD      A,0             	; Numeric marker
0403C7 C0          0500*  			RET     NZ
0403C8 23          0501*  			INC     HL
0403C9 C9          0502*  			RET
0403CA             0503*  ;
0403CA             0504*  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0403CA             0505*  ; Item type is returned in A:  Bit 7=0 numeric.
0403CA             0506*  ;                              Bit 7=1 string.
0403CA             0507*  ; Numeric item returned in HLH'L'C.
0403CA             0508*  ; String item returned in string accumulator,
0403CA             0509*  ;   DE addresses byte after last (E=length).
0403CA             0510*  ;
0403CA CD 81 16 04 0511*  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0403CE CD 78 0A 04 0512*  			CALL    NXT			; Skip spaces
0403D2 FD 23       0513*  			INC     IY			; Move to the prefix character
0403D4 FE 26       0514*  			CP      '&'			; If `&`
0403D6 CA 4B 03 04 0515*  			JP      Z,HEX           	; Then get a HEX constant
0403DA FE 25       0516*  			CP	'%'			; If '%'
0403DC 28 98       0517*  			JR	Z,BIN			; Then get a BINARY constant
0403DE FE 2D       0518*  			CP      '-'			; If `-`
0403E0 28 C2       0519*  			JR      Z,MINUS         	; Then get a negative number
0403E2 FE 2B       0520*  			CP      '+'			; If `+`
0403E4 CA 22 03 04 0521*  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0403E8 FE 28       0522*  			CP      '('			; If `(`
0403EA CA 41 03 04 0523*  			JP      Z,ITEM1         	; Start of a bracketed expression
0403EE FE 22       0524*  			CP      34			; If `"`
0403F0 28 7A       0525*  			JR      Z,CONS          	; Start of a string constant
0403F2 FE C6       0526*  			CP      TCMD			; Is it out of range of the function table?
0403F4 D2 9F 0C 04 0527*  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0403F8 FE 8D       0528*  			CP      FUNTOK			; If it is in range, then
0403FA D2 8B 0A 04 0529*  			JP      NC,DISPAT       	; It's a function
0403FE FD 2B       0530*  			DEC     IY
040400 FE 3A       0531*  			CP      ':'
040402 30 0C       0532*  			JR      NC,ITEM2		; VARIABLE?
040404 FE 30       0533*  			CP      '0'
040406 D2 93 04 04 0534*  			JP      NC,CON			; NUMERIC CONSTANT
04040A FE 2E       0535*  			CP      '.'
04040C CA 93 04 04 0536*  			JP      Z,CON			; NUMERIC CONSTANT
040410 CD 90 3A 04 0537*  ITEM2:			CALL    GETVAR			; VARIABLE
040414 20 37       0538*  			JR      NZ,NOSUCH
040416 B7          0539*  			OR      A
040417 FA A5 04 04 0540*  			JP      M,LOADS			; STRING VARIABLE
04041B B7          0541*  LOADN:			OR      A
04041C 28 20       0542*  			JR      Z,LOAD1			; BYTE VARIABLE
04041E 0E 00       0543*  			LD      C,0
040420 CB 47       0544*  			BIT     0,A
040422 28 03       0545*  			JR      Z,LOAD4			; INTEGER VARIABLE
040424 DD 4E 04    0546*  LOAD5:			LD      C,(IX+4)
040427 D9          0547*  LOAD4:			EXX
040428 21 00 00 00 0548*  			LD	HL, 0			; TODO: Optimise
04042C DD 6E 00    0549*  			LD      L,(IX+0)
04042F DD 66 01    0550*  			LD      H,(IX+1)
040432 D9          0551*  			EXX
040433 21 00 00 00 0552*  			LD	HL, 0			; TODO: Optimise
040437 DD 6E 02    0553*  			LD      L,(IX+2)
04043A DD 66 03    0554*  			LD      H,(IX+3)
04043D C9          0555*  			RET
04043E             0556*  ;
04043E 21 00 00 00 0557*  LOAD1:			LD      HL,0
040442 D9          0558*  			EXX
040443 21 00 00 00 0559*  			LD      HL,0			; TODO: Optimise
040447 DD 6E 00    0560*  			LD      L,(IX+0)
04044A D9          0561*  			EXX
04044B 4C          0562*  			LD      C,H
04044C C9          0563*  			RET
04044D             0564*  ;
04044D DA 9F 0C 04 0565*  NOSUCH:			JP      C,SYNTAX
040451 3A 40 4D 04 0566*  			LD      A,(LISTON)
040455 CB 6F       0567*  			BIT     5,A
040457 3E 1A       0568*  			LD      A,26
040459 20 26       0569*  			JR      NZ,ERROR0_EV		; Throw "No such variable"
04045B FD 23       0570*  NOS1:			INC     IY
04045D CD C5 3C 04 0571*  			CALL    RANGE
040461 30 F8       0572*  			JR      NC,NOS1
040463 DD 21 40 4C 0573*  			LD      IX,PC
       04          
040468 AF          0574*  			XOR     A
040469 4F          0575*  			LD      C,A
04046A 18 BB       0576*  			JR      LOAD4
04046C             0577*  ;
04046C             0578*  ;CONS - Get string constant from ASCII string.
04046C             0579*  ;   Inputs: ASCII string at (IY)
04046C             0580*  ;  Outputs: Result in string accumulator.
04046C             0581*  ;           D = MS byte of ACCS, E = string length
04046C             0582*  ;           A7 = 1 (string marker)
04046C             0583*  ;           IY updated
04046C             0584*  ;
04046C 11 00 4A 04 0585*  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040470 FD 7E 00    0586*  CONS3:			LD      A,(IY)			; Fetch the first character and
040473 FD 23       0587*  			INC     IY			; Increment the pointer
040475 FE 22       0588*  			CP      '"'			; Check for start quote
040477 28 0C       0589*  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040479             0590*  ;
040479 12          0591*  CONS1:			LD      (DE),A			; Store the character in the string accumulator
04047A 1C          0592*  			INC     E			; Increment the string accumulator pointer
04047B FE 0D       0593*  			CP      CR			; Is it CR
04047D 20 F1       0594*  			JR      NZ,CONS3		; No, so keep looping
04047F             0595*  ;
04047F 3E 09       0596*  			LD      A,9
040481 C3 B6 37 04 0597*  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
040485             0598*  ;
040485 FD 7E 00    0599*  CONS2:			LD      A,(IY)			; Fetch the next character
040488 FE 22       0600*  			CP      '"'			; Check for end quote?
04048A FD 23       0601*  			INC     IY			; Increment the pointer
04048C 28 EB       0602*  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
04048E FD 2B       0603*  			DEC     IY			;
040490 3E 80       0604*  			LD      A,80H           	; String marker
040492 C9          0605*  			RET
040493             0606*  ;
040493             0607*  ;CON - Get unsigned numeric constant from ASCII string.
040493             0608*  ;   Inputs: ASCII string at (IY).
040493             0609*  ;  Outputs: Variable-type result in HLH'L'C
040493             0610*  ;           IY updated (points to delimiter)
040493             0611*  ;           A7 = 0 (numeric marker)
040493             0612*  ;
040493 FD E5       0613*  CON:			PUSH    IY
040495 DD E1       0614*  			POP     IX
040497 3E 24       0615*  			LD      A,36
040499 CD A2 20 04 0616*  			CALL    FPP
04049D 38 E2       0617*  			JR      C,ERROR0_EV
04049F DD E5       0618*  			PUSH    IX
0404A1 FD E1       0619*  			POP     IY
0404A3 AF          0620*  			XOR     A
0404A4 C9          0621*  			RET
0404A5             0622*  ;
0404A5 11 00 4A 04 0623*  LOADS:			LD      DE,ACCS			; Where to store the string
0404A9 1F          0624*  			RRA
0404AA 30 1A       0625*  			JR      NC,LOADS2       	; Skip if it is a fixed string
0404AC             0626*  ;
0404AC D9          0627*  			EXX				; This block was a call to LOAD4
0404AD DD 6E 00    0628*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0404B0 DD 66 01    0629*  			LD      H,(IX+1)		; The maximum original string length
0404B3 D9          0630*  			EXX
0404B4 DD 27 02    0631*  			LD	HL,(IX+2)		; Address of the string (24-bit)
0404B7             0632*  ;
0404B7 D9          0633*  			EXX
0404B8 7D          0634*  			LD      A,L
0404B9 D9          0635*  			EXX
0404BA B7          0636*  			OR      A
0404BB 01 00 00 00 0637*  			LD	BC,0			; BC: Number of bytes to copy
0404BF 4F          0638*  			LD      C,A
0404C0 3E 80       0639*  			LD      A,80H           	; String marker
0404C2 C8          0640*  			RET     Z
0404C3 ED B0       0641*  			LDIR
0404C5 C9          0642*  			RET
0404C6 7E          0643*  LOADS2:			LD      A,(HL)
0404C7 12          0644*  			LD      (DE),A
0404C8 23          0645*  			INC     HL
0404C9 FE 0D       0646*  			CP      CR
0404CB 3E 80       0647*  			LD      A,80H           	; String marker
0404CD C8          0648*  			RET     Z
0404CE 1C          0649*  			INC     E
0404CF 20 F5       0650*  			JR      NZ,LOADS2
0404D1 C9          0651*  			RET                     	; Return null string
0404D2             0652*  ;
0404D2             0653*  ;VARIABLE-TYPE FUNCTIONS:
0404D2             0654*  ;
0404D2             0655*  ;Result returned in HLH'L'C (floating point)
0404D2             0656*  ;Result returned in HLH'L' (C=0) (integer)
0404D2             0657*  ;Result returned in string accumulator & DE (string)
0404D2             0658*  ;All registers destroyed.
0404D2             0659*  ;IY (text pointer) updated.
0404D2             0660*  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0404D2             0661*  ;
0404D2             0662*  ;POS - horizontal cursor position.
0404D2             0663*  ;VPOS - vertical cursor position.
0404D2             0664*  ;EOF - return status of file.
0404D2             0665*  ;BGET - read byte from file.
0404D2             0666*  ;INKEY - as GET but wait only n centiseconds.
0404D2             0667*  ;GET - wait for keypress and return ASCII value.
0404D2             0668*  ;GET(n) - input from Z80 port n.
0404D2             0669*  ;ASC - ASCII value of string.
0404D2             0670*  ;LEN - length of string.
0404D2             0671*  ;LOMEM - location of dynamic variables.
0404D2             0672*  ;HIMEM - top of available RAM.
0404D2             0673*  ;PAGE - start of current text page.
0404D2             0674*  ;TOP - address of first free byte after program.
0404D2             0675*  ;ERL - line number where last error occurred.
0404D2             0676*  ;ERR - number of last error.
0404D2             0677*  ;COUNT - number of printing characters since CR.
0404D2             0678*  ;Results are integer numeric.
0404D2             0679*  ;
0404D2 CD 22 3F 04 0680*  POS:			CALL    GETCSR			; Return the horizontal cursor position
0404D6 EB          0681*  			EX      DE,HL			;  L: The X cursor position
0404D7 C3 86 05 04 0682*  			JP      COUNT1			; Return an 8-bit value
0404DB             0683*  ;
0404DB CD 22 3F 04 0684*  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0404DF C3 86 05 04 0685*  			JP      COUNT1			; Return an 8-bit value
0404E3             0686*  ;
0404E3 CD B8 18 04 0687*  EOF:			CALL    CHANEL			; Check for EOF
0404E7 CD AB 43 04 0688*  			CALL    OSSTAT
0404EB CA 0A 06 04 0689*  			JP      Z,TRUE			; Yes, so return true
0404EF C3 98 09 04 0690*  			JP      ZERO			; Otherwise return false (zero)
0404F3             0691*  ;
0404F3 CD B8 18 04 0692*  BGET:			CALL    CHANEL          	; Channel number
0404F7 CD 9A 43 04 0693*  			CALL    OSBGET
0404FB 6F          0694*  			LD      L,A
0404FC C3 84 05 04 0695*  			JP      COUNT0			; Return an 8-bit value
040500             0696*  ;
040500 CD 2A 03 04 0697*  INKEY:			CALL    ITEMI			; Get the argument
040504 CB 7C       0698*  			BIT	7, H			; Check the sign
040506 D9          0699*  			EXX				; HL: The argument
040507 C2 F0 07 04 0700*  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
04050B CD E2 07 04 0701*  			CALL	INKEY0 			; Do INKEY(n)
04050F 18 1D       0702*  			JR      ASC0			; Return a numeric value
040511             0703*  ;
040511 CD 78 0A 04 0704*  GET:			CALL    NXT			; Skip whitespace
040515 FE 28       0705*  			CP      '('			; Is it GET(
040517 20 0B       0706*  			JR      NZ,GET0			; No, so get a keyboard character
040519 CD 2A 03 04 0707*  			CALL    ITEMI           	; Yes, so fetch the port address
04051D D9          0708*  			EXX
04051E 44          0709*  			LD      B,H			; BC: The port address
04051F 4D          0710*  			LD      C,L
040520 ED 68       0711*  			IN      L,(C)           	;  L: Input from port BC
040522 18 60       0712*  			JR      COUNT0			; Return an 8-bit value
040524             0713*  ;
040524 CD CC 07 04 0714*  GET0:			CALL    GETS			; Read the keyboard character
040528 18 0A       0715*  			JR      ASC1			; And return the value
04052A             0716*  ;
04052A CD 35 03 04 0717*  ASC:			CALL    ITEMS			; Get the string argument argument
04052E AF          0718*  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04052F BB          0719*  			CP      E			; Is the pointer 0
040530 CA 0A 06 04 0720*  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
040534 2A 00 4A 04 0721*  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040538 18 4A       0722*  			JR      COUNT0			; An 8-bit value
04053A             0723*  ;
04053A CD 35 03 04 0724*  LEN:			CALL    ITEMS			; Get the string argument
04053E EB          0725*  			EX      DE,HL			; HL: Pointer into ACCS
04053F 18 43       0726*  			JR      COUNT0			; Return L
040541             0727*  ;
040541 2A 1A 4D 04 0728*  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040545 3A 1C 4D 04 0729*  			LD	A, (LOMEM+2)
040549 18 41       0730*  			JR      COUNT2			; A 24-bit value
04054B             0731*  ;
04054B 2A 20 4D 04 0732*  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04054F 3A 22 4D 04 0733*  			LD	A, (HIMEM+2)
040553 18 37       0734*  			JR      COUNT2			; A 24-bit value
040555             0735*  ;
040555 2A 14 4D 04 0736*  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040559 3A 16 4D 04 0737*  			LD	A, (PAGE_+2)		; A 24-bit value
04055D 18 2D       0738*  			JR      COUNT2
04055F             0739*  ;
04055F FD 7E 00    0740*  TOPV:			LD      A,(IY)			; Return the TOP system variable
040562 FD 23       0741*  			INC     IY              	; Skip "P"
040564 FE 50       0742*  			CP      'P'
040566 C2 9F 0C 04 0743*  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
04056A 2A 17 4D 04 0744*  			LD      HL,(TOP)
04056E 3A 19 4D 04 0745*  			LD	A, (TOP+2)
040572 18 18       0746*  			JR      COUNT2
040574             0747*  ;
040574 2A 33 4D 04 0748*  ERLV:			LD      HL,(ERL)		; Return the error line
040578 18 0C       0749*  			JR      COUNT1			; A 16-bit value
04057A             0750*  ;
04057A 2A 3F 4D 04 0751*  ERRV:			LD      HL,(ERR)		; Return the error value
04057E 18 04       0752*  			JR      COUNT0			; An 8-bit value
040580             0753*  ;
040580 2A 3D 4D 04 0754*  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
040584             0755*  
040584 26 00       0756*  COUNT0:			LD      H,0			; Return L
040586 D9          0757*  COUNT1:			EXX				; Return HL
040587 AF          0758*  			XOR     A
040588 4F          0759*  			LD      C,A             	; Integer marker
040589 67          0760*  			LD      H,A
04058A 6F          0761*  			LD      L,A
04058B C9          0762*  			RET
04058C D9          0763*  COUNT2:			EXX
04058D 6F          0764*  			LD	L,A
04058E AF          0765*  			XOR	A
04058F 4F          0766*  			LD	C,A			; Integer marker
040590 67          0767*  			LD	H,A
040591 C9          0768*  			RET
040592             0769*  ;
040592             0770*  ;OPENIN - Open a file for reading.
040592             0771*  ;OPENOT - Open a file for writing.
040592             0772*  ;OPENUP - Open a file for reading or writing.
040592             0773*  ;Result is integer channel number (0 if error)
040592             0774*  ;
040592 AF          0775*  OPENOT:			XOR     A			; Open for writing
040593 18 06       0776*  			JR	OPENIN_1
040595             0777*  ;
040595 3E 02       0778*  OPENUP:			LD      A,2			; Open for reading / writing
040597 18 02       0779*  			JR	OPENIN_1
040599             0780*  ;
040599 3E 01       0781*  OPENIN:			LD      A,1			; Open for reading
04059B             0782*  ;
04059B F5          0783*  OPENIN_1:		PUSH    AF              	; Save OPEN type
04059C CD 35 03 04 0784*  			CALL    ITEMS           	; Fetch the filename
0405A0 3E 0D       0785*  			LD      A,CR
0405A2 12          0786*  			LD      (DE),A
0405A3 F1          0787*  			POP     AF              	; Restore the OPEN type
0405A4 C6 FF       0788*  			ADD     A,-1            	; Affect the flags
0405A6 21 00 4A 04 0789*  			LD      HL,ACCS
0405AA CD 83 43 04 0790*  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0405AE 6F          0791*  			LD      L,A			; L: Channel number
0405AF 18 D3       0792*  			JR      COUNT0			; Return channel number to BASIC
0405B1             0793*  ;
0405B1             0794*  ;EXT - Return length of file.
0405B1             0795*  ;PTR_EV - Return current file pointer.
0405B1             0796*  ;Results are integer numeric.
0405B1             0797*  ;
0405B1 CD B8 18 04 0798*  EXT:			CALL    CHANEL
0405B5 CD E1 43 04 0799*  			CALL    GETEXT
0405B9 18 15       0800*  			JR      TIME0
0405BB             0801*  ;
0405BB CD B8 18 04 0802*  PTR_EV:			CALL    CHANEL
0405BF CD B5 43 04 0803*  			CALL    GETPTR
0405C3 18 0B       0804*  			JR      TIME0
0405C5             0805*  ;
0405C5             0806*  ;TIME - Return current value of elapsed time.
0405C5             0807*  ;Result is integer numeric.
0405C5             0808*  ;
0405C5 FD 7E 00    0809*  TIMEV:			LD      A,(IY)
0405C8 FE 24       0810*  			CP      '$'
0405CA 28 0A       0811*  			JR      Z,TIMEVS
0405CC CD 02 3F 04 0812*  			CALL    GETIME
0405D0 D5          0813*  TIME0:			PUSH    DE
0405D1 D9          0814*  			EXX
0405D2 E1          0815*  			POP     HL
0405D3 AF          0816*  			XOR     A
0405D4 4F          0817*  			LD      C,A
0405D5 C9          0818*  			RET
0405D6             0819*  ;
0405D6             0820*  ;TIME$ - Return date/time string.
0405D6             0821*  ;Result is string
0405D6             0822*  ;
0405D6 FD 23       0823*  TIMEVS:			INC     IY              ;SKIP $
0405D8 CD FA 43 04 0824*  			CALL    GETIMS
0405DC 3E 80       0825*  			LD      A,80H           ;MARK STRING
0405DE C9          0826*  			RET
0405DF             0827*  ;
0405DF             0828*  ;String comparison:
0405DF             0829*  ;
0405DF CD 94 09 04 0830*  SLT:			CALL    SCP
0405E3 D0          0831*  			RET     NC
0405E4 18 24       0832*  			JR      TRUE
0405E6             0833*  ;
0405E6 CD 94 09 04 0834*  SGT:			CALL    SCP
0405EA C8          0835*  			RET     Z
0405EB D8          0836*  			RET     C
0405EC 18 1C       0837*  			JR      TRUE
0405EE             0838*  ;
0405EE CD 94 09 04 0839*  SGE:			CALL    SCP
0405F2 D8          0840*  			RET     C
0405F3 18 15       0841*  			JR      TRUE
0405F5             0842*  ;
0405F5 CD 94 09 04 0843*  SLE:			CALL    SCP
0405F9 28 0F       0844*  			JR      Z,TRUE
0405FB D0          0845*  			RET     NC
0405FC 18 0C       0846*  			JR      TRUE
0405FE             0847*  ;
0405FE CD 94 09 04 0848*  SNE:			CALL    SCP
040602 C8          0849*  			RET     Z
040603 18 05       0850*  			JR      TRUE
040605             0851*  ;
040605 CD 94 09 04 0852*  SEQ:			CALL    SCP
040609 C0          0853*  			RET     NZ
04060A 3E FF       0854*  TRUE:			LD      A,-1
04060C D9          0855*  			EXX
04060D 67          0856*  			LD      H,A
04060E 6F          0857*  			LD      L,A
04060F D9          0858*  			EXX
040610 67          0859*  			LD      H,A
040611 6F          0860*  			LD      L,A
040612 3C          0861*  			INC     A
040613 4F          0862*  			LD      C,A
040614 C9          0863*  			RET
040615             0864*  ;
040615             0865*  ;PI - Return PI (3.141592654)
040615             0866*  ;Result is floating-point numeric.
040615             0867*  ;
040615 3E 23       0868*  PI:			LD      A,35
040617 18 44       0869*  			JR      FPP1
040619             0870*  ;
040619             0871*  ;ABS - Absolute value
040619             0872*  ;Result is numeric, variable type.
040619             0873*  ;
040619 3E 10       0874*  ABSV:			LD      A,16
04061B 18 3A       0875*  			JR      FPPN
04061D             0876*  ;
04061D             0877*  ;NOT - Complement integer.
04061D             0878*  ;Result is integer numeric.
04061D             0879*  ;
04061D 3E 1A       0880*  NOTK:			LD      A,26
04061F 18 36       0881*  			JR      FPPN
040621             0882*  ;
040621             0883*  ;DEG - Convert radians to degrees
040621             0884*  ;Result is floating-point numeric.
040621             0885*  ;
040621 3E 15       0886*  DEG:			LD      A,21
040623 18 32       0887*  			JR      FPPN
040625             0888*  ;
040625             0889*  ;RAD - Convert degrees to radians
040625             0890*  ;Result is floating-point numeric.
040625             0891*  ;
040625 3E 1B       0892*  RAD:			LD      A,27
040627 18 2E       0893*  			JR      FPPN
040629             0894*  ;
040629             0895*  ;SGN - Return -1, 0 or +1
040629             0896*  ;Result is integer numeric.
040629             0897*  ;
040629 3E 1C       0898*  SGN:			LD      A,28
04062B 18 2A       0899*  			JR      FPPN
04062D             0900*  ;
04062D             0901*  ;INT - Floor function
04062D             0902*  ;Result is integer numeric.
04062D             0903*  ;
04062D 3E 17       0904*  INT_:			LD      A,23
04062F 18 26       0905*  			JR      FPPN
040631             0906*  ;
040631             0907*  ;SQR - square root
040631             0908*  ;Result is floating-point numeric.
040631             0909*  ;
040631 3E 1E       0910*  SQR:			LD      A,30
040633 18 22       0911*  			JR      FPPN
040635             0912*  ;
040635             0913*  ;TAN - Tangent function
040635             0914*  ;Result is floating-point numeric.
040635             0915*  ;
040635 3E 1F       0916*  TAN:			LD      A,31
040637 18 1E       0917*  			JR      FPPN
040639             0918*  ;
040639             0919*  ;COS - Cosine function
040639             0920*  ;Result is floating-point numeric.
040639             0921*  ;
040639 3E 14       0922*  COS:			LD      A,20
04063B 18 1A       0923*  			JR      FPPN
04063D             0924*  ;
04063D             0925*  ;SIN - Sine function
04063D             0926*  ;Result is floating-point numeric.
04063D             0927*  ;
04063D 3E 1D       0928*  SIN:			LD      A,29
04063F 18 16       0929*  			JR      FPPN
040641             0930*  ;
040641             0931*  ;EXP - Exponential function
040641             0932*  ;Result is floating-point numeric.
040641             0933*  ;
040641 3E 16       0934*  EXP:			LD      A,22
040643 18 12       0935*  			JR      FPPN
040645             0936*  ;
040645             0937*  ;LN - Natural log.
040645             0938*  ;Result is floating-point numeric.
040645             0939*  ;
040645 3E 18       0940*  LN:			LD      A,24
040647 18 0E       0941*  			JR      FPPN
040649             0942*  ;
040649             0943*  ;LOG - base-10 logarithm.
040649             0944*  ;Result is floating-point numeric.
040649             0945*  ;
040649 3E 19       0946*  LOG:			LD      A,25
04064B 18 0A       0947*  			JR      FPPN
04064D             0948*  ;
04064D             0949*  ;ASN - Arc-sine
04064D             0950*  ;Result is floating-point numeric.
04064D             0951*  ;
04064D 3E 12       0952*  ASN:			LD      A,18
04064F 18 06       0953*  			JR      FPPN
040651             0954*  ;
040651             0955*  ;ATN - arc-tangent
040651             0956*  ;Result is floating-point numeric.
040651             0957*  ;
040651 3E 13       0958*  ATN:			LD      A,19
040653 18 02       0959*  			JR      FPPN
040655             0960*  ;
040655             0961*  ;ACS - arc-cosine
040655             0962*  ;Result is floating point numeric.
040655             0963*  ;
040655 3E 11       0964*  ACS:			LD      A,17
040657 F5          0965*  FPPN:			PUSH    AF
040658 CD 22 03 04 0966*  			CALL    ITEMN
04065C F1          0967*  			POP     AF
04065D CD A2 20 04 0968*  FPP1:			CALL    FPP
040661 DA B6 37 04 0969*  			JP      C,ERROR_
040665 AF          0970*  			XOR     A
040666 C9          0971*  			RET
040667             0972*  ;
040667             0973*  ;SFIX - Convert to fixed-point notation
040667             0974*  ;
040667 3E 26       0975*  SFIX:			LD      A,38
040669 18 F2       0976*  			JR      FPP1
04066B             0977*  ;
04066B             0978*  ;SFLOAT - Convert to floating-point notation
04066B             0979*  ;
04066B 3E 27       0980*  SFLOAT:			LD      A,39
04066D 18 EE       0981*  			JR      FPP1
04066F             0982*  ;
04066F             0983*  ;VAL - Return numeric value of string.
04066F             0984*  ;Result is variable type numeric.
04066F             0985*  ;
04066F CD 35 03 04 0986*  VAL:			CALL    ITEMS
040673 AF          0987*  VAL0:			XOR     A
040674 12          0988*  			LD      (DE),A
040675 DD 21 00 4A 0989*  			LD      IX,ACCS
       04          
04067A 3E 24       0990*  			LD      A,36
04067C 18 DF       0991*  			JR      FPP1
04067E             0992*  ;
04067E             0993*  ;EVAL - Pass string to expression evaluator.
04067E             0994*  ;Result is variable type (numeric or string).
04067E             0995*  ;
04067E CD 35 03 04 0996*  EVAL_:			CALL    ITEMS
040682 3E 0D       0997*  			LD      A,CR
040684 12          0998*  			LD      (DE),A
040685 FD E5       0999*  			PUSH    IY
040687 11 00 4A 04 1000*  			LD      DE,ACCS
04068B FD 21 00 4A 1001*  			LD      IY,ACCS
       04          
040690 0E 00       1002*  			LD      C,0
040692 CD F5 3C 04 1003*  			CALL    LEXAN2          ;TOKENISE
040696 12          1004*  			LD      (DE),A
040697 13          1005*  			INC     DE
040698 AF          1006*  			XOR     A
040699 CD B9 09 04 1007*  			CALL    PUSHS           ;PUT ON STACK
04069D FD 21 03 00 1008*  			LD      IY,SIZEW	;WAS 2
       00          
0406A2 FD 39       1009*  			ADD     IY,SP
0406A4 CD C7 01 04 1010*  			CALL    EXPR
0406A8 FD E1       1011*  			POP     IY
0406AA FD 39       1012*  			ADD     IY,SP
0406AC FD F9       1013*  			LD      SP,IY           ;ADJUST STACK POINTER
0406AE FD E1       1014*  			POP     IY
0406B0 08          1015*  			EX      AF,AF'
0406B1 C9          1016*  			RET
0406B2             1017*  ;
0406B2             1018*  ;RND - Random number function.
0406B2             1019*  ; RND gives random integer 0-&FFFFFFFF
0406B2             1020*  ; RND(-n) seeds random number & returns -n.
0406B2             1021*  ; RND(0) returns last value in RND(1) form.
0406B2             1022*  ; RND(1) returns floating-point 0-0.99999999.
0406B2             1023*  ; RND(n) returns random integer 1-n.
0406B2             1024*  ;
0406B2 DD 21 38 4D 1025*  RND:			LD      IX,RANDOM
       04          
0406B7 CD 78 0A 04 1026*  			CALL    NXT
0406BB FE 28       1027*  			CP      '('
0406BD 28 20       1028*  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0406BF CD 24 04 04 1029*  			CALL    LOAD5
0406C3 CB 19       1030*  RND1:			RR      C
0406C5 06 20       1031*  			LD      B,32
0406C7 D9          1032*  RND2:			EXX                     ;CALCULATE NEXT
0406C8 52 ED 6A    1033*  			ADC.S   HL,HL
0406CB D9          1034*  			EXX
0406CC 52 ED 6A    1035*  			ADC.S   HL,HL
0406CF CB 5D       1036*  			BIT     3,L
0406D1 28 01       1037*  			JR      Z,RND3
0406D3 3F          1038*  			CCF
0406D4 10 F1       1039*  RND3:			DJNZ    RND2
0406D6 CB 11       1040*  RND4:			RL      C               ;SAVE CARRY
0406D8 CD 0D 16 04 1041*  			CALL    STORE5          ;STORE NEW NUMBER
0406DC AF          1042*  			XOR     A
0406DD 4F          1043*  			LD      C,A
0406DE C9          1044*  			RET
0406DF CD 2A 03 04 1045*  RND5:			CALL    ITEMI
0406E3 DD 21 38 4D 1046*  			LD      IX,RANDOM
       04          
0406E8 CB 7C       1047*  			BIT     7,H             ;NEGATIVE?
0406EA 37          1048*  			SCF
0406EB 20 E9       1049*  			JR      NZ,RND4         ;SEED
0406ED CD E4 08 04 1050*  			CALL    TEST
0406F1 F5          1051*  			PUSH    AF
0406F2 CD DC 08 04 1052*  			CALL    SWAP
0406F6 D9          1053*  			EXX
0406F7 CD 24 04 04 1054*  			CALL    LOAD5
0406FB C4 C3 06 04 1055*  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0406FF D9          1056*  			EXX                     ;SCRAMBLE (CARE!)
040700 0E 7F       1057*  			LD      C,7FH
040702 CB 7C       1058*  RND6:			BIT     7,H             ;FLOAT
040704 20 0A       1059*  			JR      NZ,RND7
040706 D9          1060*  			EXX
040707 52 29       1061*  			ADD.S   HL,HL
040709 D9          1062*  			EXX
04070A 52 ED 6A    1063*  			ADC.S   HL,HL
04070D 0D          1064*  			DEC     C
04070E 20 F2       1065*  			JR      NZ,RND6
040710 CB BC       1066*  RND7:			RES     7,H             ;POSITIVE 0-0.999999
040712 F1          1067*  			POP     AF
040713 C8          1068*  			RET     Z               ;ZERO ARGUMENT
040714 D9          1069*  			EXX
040715 7B          1070*  			LD      A,E
040716 3D          1071*  			DEC     A
040717 B2          1072*  			OR      D
040718 D9          1073*  			EXX
040719 B3          1074*  			OR      E
04071A B2          1075*  			OR      D
04071B C8          1076*  			RET     Z               ;ARGUMENT=1
04071C 06 00       1077*  			LD      B,0             ;INTEGER MARKER
04071E 3E 0A       1078*  			LD      A,10
040720 CD A2 20 04 1079*  			CALL    FPP             ;MULTIPLY
040724 DA B6 37 04 1080*  			JP      C,ERROR_
040728 CD 67 06 04 1081*  			CALL    SFIX
04072C C3 C0 03 04 1082*  			JP      ADD1
040730             1083*  ;
040730             1084*  ; INSTR - String search.
040730             1085*  ; Result is integer numeric.
040730             1086*  ;
040730 CD 26 0A 04 1087*  INSTR:			CALL    EXPRSC			; Get the first string expression
040734 CD B9 09 04 1088*  			CALL    PUSHS           	; Push the string onto the stack
040738 CD 1A 03 04 1089*  			CALL    EXPRS           	; Get the second string expression
04073C C1          1090*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
04073D 21 00 00 00 1091*  			LD      HL,0
040741 39          1092*  			ADD     HL,SP           	; HL: Pointer to main string
040742 C5          1093*  			PUSH    BC              	;  C: Main string length
040743 43          1094*  			LD      B,E             	;  B: Sub-string length
040744 CD 78 0A 04 1095*  			CALL    NXT			; Skip whitespace
040748 FE 2C       1096*  			CP      ','			; Check if there is a comma for the third parameter
04074A 3E 00       1097*  			LD      A,0			;  A: Default start position in string
04074C 20 1A       1098*  			JR      NZ,INSTR1		; No, so skip the next bit
04074E FD 23       1099*  			INC     IY              	; Skip the comma
040750 C5          1100*  			PUSH    BC              	; Save the lengths
040751 E5          1101*  			PUSH    HL              	; Save the pointer to the main string
040752 CD B9 09 04 1102*  			CALL    PUSHS			; Push the string onto the stack
040756 CD 0F 03 04 1103*  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
04075A C1          1104*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
04075B CD E6 09 04 1105*  			CALL    POPS			; Pop the string off the stack
04075F E1          1106*  			POP     HL              	; Restore the pointer to the main string
040760 C1          1107*  			POP     BC              	; Restore the lengths
040761 D9          1108*  			EXX
040762 7D          1109*  			LD      A,L			; A: The start position in the  string
040763 D9          1110*  			EXX
040764 B7          1111*  			OR      A			; Set the flags
040765 28 01       1112*  			JR      Z,INSTR1		; If it is zero, then skip
040767 3D          1113*  			DEC     A
040768 11 00 4A 04 1114*  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
04076C CD 8A 07 04 1115*  			CALL    SEARCH			; Do the search
040770 D1          1116*  			POP     DE
040771 28 03       1117*  			JR      Z,INSTR2        	; NB: Carry cleared
040773 ED 62       1118*  			SBC     HL,HL
040775 39          1119*  			ADD     HL,SP
040776 ED 72       1120*  INSTR2:			SBC     HL,SP
040778 EB          1121*  			EX      DE,HL
040779 7D          1122*  			LD	A,L
04077A 21 00 00 00 1123*  			LD      HL,0
04077E 6F          1124*  			LD	L,A
04077F 39          1125*  			ADD     HL,SP
040780 F9          1126*  			LD      SP,HL
040781 EB          1127*  			EX      DE,HL
040782 CD 37 0A 04 1128*  			CALL    BRAKET			; Check for closing bracket
040786 C3 86 05 04 1129*  			JP      COUNT1			; Return a numeric integer
04078A             1130*  ;
04078A             1131*  ; SEARCH - Search string for sub-string
04078A             1132*  ;    Inputs: Main string at HL length C
04078A             1133*  ;            Sub-string  at DE length B
04078A             1134*  ;            Starting offset A
04078A             1135*  ;   Outputs: NZ - not found
04078A             1136*  ;            Z - found at location HL-1
04078A             1137*  ;            Carry always cleared
04078A             1138*  ;
04078A C5          1139*  SEARCH:			PUSH    BC			; Add the starting offset to HL
04078B 01 00 00 00 1140*  			LD      BC,0
04078F 4F          1141*  			LD      C,A
040790 09          1142*  			ADD     HL,BC           	; New start address
040791 C1          1143*  			POP     BC
040792 91          1144*  			SUB     C			; If the starting offset > main string length, then do nothing
040793 30 2C       1145*  			JR      NC,SRCH4
040795 ED 44       1146*  			NEG
040797 4F          1147*  			LD      C,A             	; Remaining length
040798             1148*  ;
040798 C5          1149*  SRCH1:			PUSH    BC
040799 79          1150*  			LD	A,C
04079A 01 00 00 00 1151*  			LD	BC,0
04079E 4F          1152*  			LD	C,A
04079F 1A          1153*  			LD      A,(DE)
0407A0 ED B1       1154*  			CPIR                    	; Find the first character
0407A2 79          1155*  			LD      A,C
0407A3 C1          1156*  			POP     BC
0407A4 20 1B       1157*  			JR      NZ,SRCH4
0407A6 4F          1158*  			LD      C,A
0407A7             1159*  ;
0407A7             1160*  ; This block of four instructions was commented as a bug fix by R.T.Russell
0407A7             1161*  ;
0407A7 05          1162*  			DEC     B			; Bug fix
0407A8 B8          1163*  			CP      B			; Bug fix
0407A9 04          1164*  			INC     B			; Bug fix
0407AA 38 15       1165*  			JR      C,SRCH4			; Bug fix
0407AC             1166*  ;
0407AC C5          1167*  			PUSH    BC
0407AD D5          1168*  			PUSH    DE
0407AE E5          1169*  			PUSH    HL
0407AF 05          1170*  			DEC     B
0407B0 28 08       1171*  			JR      Z,SRCH3         	; Found!
0407B2 13          1172*  SRCH2:			INC     DE
0407B3 1A          1173*  			LD      A,(DE)
0407B4 BE          1174*  			CP      (HL)
0407B5 20 03       1175*  			JR      NZ,SRCH3
0407B7 23          1176*  			INC     HL
0407B8 10 F8       1177*  			DJNZ    SRCH2
0407BA E1          1178*  SRCH3:			POP     HL
0407BB D1          1179*  			POP     DE
0407BC C1          1180*  			POP     BC
0407BD 20 D9       1181*  			JR      NZ,SRCH1
0407BF AF          1182*  			XOR     A               	; Flags: Z, NC
0407C0 C9          1183*  			RET                     	; Found
0407C1             1184*  ;
0407C1 F6 FF       1185*  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0407C3 C9          1186*  			RET                     	; Not found
0407C4             1187*  ;
0407C4             1188*  ;CHRS - Return character with given ASCII value.
0407C4             1189*  ;Result is string.
0407C4             1190*  ;
0407C4 CD 2A 03 04 1191*  CHRS:			CALL    ITEMI
0407C8 D9          1192*  			EXX
0407C9 7D          1193*  			LD      A,L
0407CA 18 0E       1194*  			JR      GET1
0407CC             1195*  ;
0407CC             1196*  ;GETS - Return key pressed as stringor character at position (X,Y).
0407CC             1197*  ;Result is string.
0407CC             1198*  ;
0407CC CD 78 0A 04 1199*  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0407D0 FE 28       1200*  			CP	'('
0407D2 CA 58 44 04 1201*  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0407D6 CD 7F 3F 04 1202*  			CALL    OSRDCH
0407DA 37          1203*  GET1:			SCF
0407DB 18 09       1204*  			JR      INKEY1
0407DD             1205*  ;
0407DD             1206*  ; INKEYS - Wait up to n centiseconds for keypress.
0407DD             1207*  ;          Return key pressed as string or null
0407DD             1208*  ;          string if time elapsed.
0407DD             1209*  ; Result is string.
0407DD             1210*  ;
0407DD CD 2A 03 04 1211*  INKEYS:			CALL    ITEMI			; Fetch the argument
0407E1 D9          1212*  			EXX
0407E2 CD 88 3F 04 1213*  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0407E6 11 00 4A 04 1214*  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0407EA 12          1215*  			LD      (DE),A
0407EB 3E 80       1216*  			LD      A,80H
0407ED D0          1217*  			RET     NC
0407EE 1C          1218*  			INC     E
0407EF C9          1219*  			RET
0407F0             1220*  ;
0407F0             1221*  ; INKEYM - Check immediately whether a given key is being pressed
0407F0             1222*  ; Result is integer numeric
0407F0             1223*  ;
0407F0             1224*  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0407F0 3E 1E       0001*M 			LD	A, function
0407F2 49 CF       0002*M 			RST.LIS	08h
0407F4 23          1225*  			INC	HL			; Index from 0
0407F5 7D          1226*  			LD	A, L			; Negate the LSB of the answer
0407F6 ED 44       1227*  			NEG
0407F8 4F          1228*  			LD	C, A			;  E: The positive keycode value
0407F9 3E 01       1229*  			LD	A, 1			; Throw an "Out of range" error
0407FB FA B6 37 04 1230*  			JP	M, ERROR_		; if the argument < - 128
0407FF             1231*  ;
0407FF 21 22 08 04 1232*  			LD	HL, BITLOOKUP		; HL: The bit lookup table
040803 11 00 00 00 1233*  			LD	DE, 0
040807 79          1234*  			LD	A, C
040808 E6 07       1235*  			AND	00000111b		; Just need the first three bits
04080A 5F          1236*  			LD	E, A			; DE: The bit number
04080B 19          1237*  			ADD	HL, DE
04080C 46          1238*  			LD	B, (HL)			;  B: The mask
04080D             1239*  ;
04080D 79          1240*  			LD	A, C			; Fetch the keycode again
04080E E6 78       1241*  			AND	01111000b		; And divide by 8
040810 0F          1242*  			RRCA
040811 0F          1243*  			RRCA
040812 0F          1244*  			RRCA
040813 5F          1245*  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
040814 DD 19       1246*  			ADD	IX, DE			; IX: The address
040816 78          1247*  			LD	A, B			;  B: The mask
040817 DD A6 00    1248*  			AND	(IX+0)			; Check whether the bit is set
04081A CA 98 09 04 1249*  			JP	Z, ZERO			; No, so return 0
04081E C3 0A 06 04 1250*  			JP	TRUE			; Otherwise return -1
040822             1251*  ;
040822             1252*  ; A bit lookup table
040822             1253*  ;
040822 01 02 04 08 1254*  BITLOOKUP:		DB	01h, 02h, 04h, 08h
040826 10 20 40 80 1255*  			DB	10h, 20h, 40h, 80h
04082A             1256*  ;
04082A             1257*  ; MID$ - Return sub-string.
04082A             1258*  ; Result is string.
04082A             1259*  ;
04082A CD 26 0A 04 1260*  MIDS:			CALL    EXPRSC			; Get the first string expression
04082E CD B9 09 04 1261*  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
040832 CD 0F 03 04 1262*  			CALL    EXPRI			; Get the second expression
040836 C1          1263*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
040837 CD E6 09 04 1264*  			CALL    POPS			; Pop the string back off the stack to the string accumulator
04083B D9          1265*  			EXX
04083C 7D          1266*  			LD      A,L			; A: The start index
04083D D9          1267*  			EXX
04083E B7          1268*  			OR      A			; If the start index is 0, then we don't need to do the next bit
04083F 28 0E       1269*  			JR      Z,MIDS1
040841 3D          1270*  			DEC     A
040842 6F          1271*  			LD      L,A			; L: The start index - 1
040843 93          1272*  			SUB     E			; Subtract from the string length
040844 1E 00       1273*  			LD      E,0			; Preemptively set the string length to 0
040846 30 07       1274*  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
040848 ED 44       1275*  			NEG				; Negate the answer and
04084A 4F          1276*  			LD      C,A			; C: Number of bytes to copy
04084B CD 8E 08 04 1277*  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04084F CD 78 0A 04 1278*  MIDS1:			CALL    NXT			; Skip whitespace
040853 FE 2C       1279*  			CP      ','			; Check for a comma
040855 FD 23       1280*  			INC     IY			; Advance to the next character in the BASIC line
040857 28 0D       1281*  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
040859 FD 2B       1282*  			DEC     IY			; Restore the BASIC program pointer
04085B CD 37 0A 04 1283*  			CALL    BRAKET			; Check for a bracket
04085F 3E 80       1284*  			LD      A,80H			; String marker
040861 C9          1285*  			RET
040862             1286*  ;
040862             1287*  ; LEFT$ - Return left part of string.
040862             1288*  ; Carry cleared if entire string returned.
040862             1289*  ; Result is string.
040862             1290*  ;
040862 CD 26 0A 04 1291*  LEFTS:			CALL    EXPRSC			; Get the first string expression
040866 CD B9 09 04 1292*  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04086A CD 0F 03 04 1293*  			CALL    EXPRI			; Get the second expression
04086E C1          1294*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04086F CD E6 09 04 1295*  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
040873 CD 37 0A 04 1296*  			CALL    BRAKET			; Check for closing bracket
040877 D9          1297*  			EXX
040878 7D          1298*  			LD      A,L			; L: The second parameter
040879 D9          1299*  			EXX
04087A BB          1300*  			CP      E			; Compare with the string length
04087B 30 02       1301*  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
04087D 6B          1302*  			LD      L,E             	; For RIGHTS, no effect in LEFTS
04087E 5F          1303*  LEFT2:			LD      E,A			; E: The new length of string
04087F 3E 80       1304*  LEFT3:			LD      A,80H           	; String marker
040881 C9          1305*  			RET
040882             1306*  ;
040882             1307*  ; RIGHT$ - Return right part of string.
040882             1308*  ; Result is string.
040882             1309*  ;
040882 CD 62 08 04 1310*  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
040886 D0          1311*  			RET     NC			; Do nothing if the second parameter is >= string length
040887 1C          1312*  			INC     E			; Check for a zero length string
040888 1D          1313*  			DEC     E
040889 C8          1314*  			RET     Z			; Yes, so do nothing
04088A 4B          1315*  			LD      C,E			;  C: Number of bytes to copy
04088B 7D          1316*  			LD      A,L
04088C 93          1317*  			SUB     E
04088D 6F          1318*  			LD      L,A			;  L: Index into the string
04088E 79          1319*  RIGHT1:			LD	A,C
04088F 01 00 00 00 1320*  			LD	BC,0
040893 4F          1321*  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
040894 7D          1322*  			LD	A,L
040895 21 00 4A 04 1323*  			LD	HL,ACCS
040899 6F          1324*  			LD	L,A			; HL: Source (in ACCS)
04089A 11 00 4A 04 1325*  			LD      DE,ACCS			; DE: Destination (start of ACCS)
04089E ED B0       1326*  			LDIR                    	; Copy
0408A0 3E 80       1327*  			LD      A,80H			; String marker
0408A2 C9          1328*  			RET
0408A3             1329*  ;
0408A3             1330*  ; STRINGS - Return n concatenations of a string.
0408A3             1331*  ; Result is string.
0408A3             1332*  ;
0408A3 CD 0F 03 04 1333*  STRING_:		CALL    EXPRI			; Get number of times to replicate
0408A7 CD 2A 0A 04 1334*  			CALL    COMMA			; Check for comma
0408AB D9          1335*  			EXX
0408AC 7D          1336*  			LD      A,L			; L: Number of iterations of string
0408AD D9          1337*  			EXX
0408AE F5          1338*  			PUSH    AF
0408AF CD 1A 03 04 1339*  			CALL    EXPRS			; Get the string
0408B3 CD 37 0A 04 1340*  			CALL    BRAKET			; Check for closing bracket
0408B7 F1          1341*  			POP     AF			; A: Number of iterations of string
0408B8 B7          1342*  			OR      A			; Set flags
0408B9 28 C3       1343*  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0408BB 3D          1344*  			DEC     A
0408BC 4F          1345*  			LD      C,A			; C: Loop counter
0408BD 3E 80       1346*  			LD      A,80H			; String marker
0408BF C8          1347*  			RET     Z
0408C0 1C          1348*  			INC     E			; Check for empty string
0408C1 1D          1349*  			DEC     E
0408C2 C8          1350*  			RET     Z              		; And return
0408C3 43          1351*  			LD      B,E			; B: String length tally
0408C4 21 00 4A 04 1352*  			LD	HL,ACCS
0408C8 C5          1353*  STRIN1:			PUSH    BC
0408C9 7E          1354*  STRIN2:			LD      A,(HL)
0408CA 23          1355*  			INC     HL
0408CB 12          1356*  			LD      (DE),A
0408CC 1C          1357*  			INC     E
0408CD 3E 13       1358*  			LD      A,19
0408CF CA B6 37 04 1359*  			JP      Z,ERROR_         	; Throw a "String too long" error
0408D3 10 F4       1360*  			DJNZ    STRIN2
0408D5 C1          1361*  			POP     BC
0408D6 0D          1362*  			DEC     C
0408D7 20 EF       1363*  			JR      NZ,STRIN1
0408D9 3E 80       1364*  			LD      A,80H
0408DB C9          1365*  			RET
0408DC             1366*  ;
0408DC             1367*  ;SUBROUTINES
0408DC             1368*  ;
0408DC             1369*  ;SWAP - Swap arguments
0408DC             1370*  ;Exchanges DE,HL D'E',H'L' and B,C
0408DC             1371*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0408DC             1372*  ;
0408DC 79          1373*  SWAP:			LD      A,C
0408DD 48          1374*  			LD      C,B
0408DE 47          1375*  			LD      B,A
0408DF EB          1376*  			EX      DE,HL
0408E0 D9          1377*  			EXX
0408E1 EB          1378*  			EX      DE,HL
0408E2 D9          1379*  			EXX
0408E3 C9          1380*  			RET
0408E4             1381*  ;
0408E4             1382*  ;TEST - Test HLH'L' for zero
0408E4             1383*  ;Outputs: Z-flag set & A=0 if zero
0408E4             1384*  ;Destroys: A,F
0408E4             1385*  ;
0408E4 7C          1386*  TEST:			LD      A,H
0408E5 B5          1387*  			OR      L
0408E6 D9          1388*  			EXX
0408E7 B4          1389*  			OR      H
0408E8 B5          1390*  			OR      L
0408E9 D9          1391*  			EXX
0408EA C9          1392*  			RET
0408EB             1393*  ;
0408EB             1394*  ;DECODE - Decode line number in pseudo-binary.
0408EB             1395*  ;   Inputs: IY = Text pointer.
0408EB             1396*  ;   Outputs: HL=0, H'L'=line number, C=0.
0408EB             1397*  ;   Destroys: A,C,H,L,H',L',IY,F
0408EB             1398*  ;
0408EB D9          1399*  DECODE:			EXX
0408EC 21 00 00 00 1400*  			LD	HL, 0
0408F0 FD 7E 00    1401*  			LD      A,(IY)
0408F3 FD 23       1402*  			INC     IY
0408F5 17          1403*  			RLA
0408F6 17          1404*  			RLA
0408F7 67          1405*  			LD      H,A
0408F8 E6 C0       1406*  			AND     0C0H
0408FA FD AE 00    1407*  			XOR     (IY)
0408FD FD 23       1408*  			INC     IY
0408FF 6F          1409*  			LD      L,A
040900 7C          1410*  			LD      A,H
040901 17          1411*  			RLA
040902 17          1412*  			RLA
040903 E6 C0       1413*  			AND     0C0H
040905 FD AE 00    1414*  			XOR     (IY)
040908 FD 23       1415*  			INC     IY
04090A 67          1416*  			LD      H,A
04090B D9          1417*  			EXX
04090C             1418*  ;			XOR     A
04090C             1419*  ;			LD      C,A
04090C             1420*  ;			LD      H,A
04090C             1421*  ;			LD      L,A
04090C 21 00 00 00 1422*  			LD	HL, 0
040910 4D          1423*  			LD	C, L
040911 C9          1424*  			RET
040912             1425*  ;
040912             1426*  ;HEXSTR - convert numeric value to HEX string.
040912             1427*  ;   Inputs: HLH'L'C = integer or floating-point number
040912             1428*  ;  Outputs: String in string accumulator.
040912             1429*  ;           E = string length.  D = ACCS/256
040912             1430*  ;
040912 FD 23       1431*  HEXSTS:			INC     IY              ;SKIP TILDE
040914 CD 22 03 04 1432*  			CALL    ITEMN
040918 CD 1F 09 04 1433*  			CALL    HEXSTR
04091C 3E 80       1434*  			LD      A,80H
04091E C9          1435*  			RET
04091F             1436*  ;
04091F CD 67 06 04 1437*  HEXSTR:			CALL    SFIX
040923 01 08 00 00 1438*  			LD      BC,8
040927 11 00 4A 04 1439*  			LD      DE,ACCS
04092B C5          1440*  HEXST1:			PUSH    BC
04092C 06 04       1441*  			LD      B,4
04092E AF          1442*  			XOR     A
04092F D9          1443*  HEXST2:			EXX
040930 52 29       1444*  			ADD.S	HL,HL
040932 D9          1445*  			EXX
040933 52 ED 6A    1446*  			ADC.S	HL,HL
040936 17          1447*  			RLA
040937 10 F6       1448*  			DJNZ    HEXST2
040939 C1          1449*  			POP     BC
04093A 0D          1450*  			DEC     C
04093B F8          1451*  			RET     M
04093C 28 06       1452*  			JR      Z,HEXST3
04093E B7          1453*  			OR      A
04093F 20 03       1454*  			JR      NZ,HEXST3
040941 B8          1455*  			CP      B
040942 28 E7       1456*  			JR      Z,HEXST1
040944 C6 90       1457*  HEXST3:			ADD     A,90H
040946 27          1458*  			DAA
040947 CE 40       1459*  			ADC     A,40H
040949 27          1460*  			DAA
04094A 12          1461*  			LD      (DE),A
04094B 13          1462*  			INC     DE
04094C 47          1463*  			LD      B,A
04094D 18 DC       1464*  			JR      HEXST1
04094F             1465*  ;
04094F             1466*  ;Function STR - convert numeric value to ASCII string.
04094F             1467*  ;   Inputs: HLH'L'C = integer or floating-point number.
04094F             1468*  ;  Outputs: String in string accumulator.
04094F             1469*  ;           E = length, D = ACCS/256
04094F             1470*  ;           A = 80H (type=string)
04094F             1471*  ;
04094F             1472*  ;First normalise for decimal output:
04094F             1473*  ;
04094F CD 78 0A 04 1474*  STRS:			CALL    NXT
040953 FE 7E       1475*  			CP      '~'
040955 28 BB       1476*  			JR      Z,HEXSTS
040957 CD 22 03 04 1477*  			CALL    ITEMN
04095B DD 21 00 4C 1478*  			LD      IX,STAVAR
       04          
040960 DD 7E 03    1479*  			LD      A,(IX+3)
040963 B7          1480*  			OR      A
040964 DD 21 91 09 1481*  			LD      IX,G9-1         ;G9 FORMAT
       04          
040969 28 05       1482*  			JR      Z,STR0
04096B DD 21 00 4C 1483*  STR:			LD      IX,STAVAR
       04          
040970 11 00 4A 04 1484*  STR0:			LD      DE,ACCS
040974 3E 25       1485*  			LD      A,37
040976 CD A2 20 04 1486*  			CALL    FPP
04097A DA B6 37 04 1487*  			JP      C,ERROR_
04097E DD CB 02 46 1488*  			BIT     0,(IX+2)
040982 3E 80       1489*  STR1:			LD      A,80H           ;STRING MARKER
040984 C8          1490*  			RET     Z
040985 79          1491*  			LD      A,C
040986 C6 04       1492*  			ADD     A,4
040988 BB          1493*  STR2:			CP      E
040989 28 F7       1494*  			JR      Z,STR1
04098B EB          1495*  			EX      DE,HL
04098C 36 20       1496*  			LD      (HL),' '        ;TRAILING SPACE
04098E 23          1497*  			INC     HL
04098F EB          1498*  			EX      DE,HL
040990 18 F6       1499*  			JR      STR2
040992             1500*  ;
040992 09 00       1501*  G9:			DW    9
040994             1502*  ;
040994             1503*  ;STRING COMPARE
040994             1504*  ;Compare string (DE) length B with string (HL) length C.
040994             1505*  ;Result preset to false.
040994             1506*  ;
040994 CD A2 09 04 1507*  SCP:			CALL	SCP0
040998             1508*  ;
040998 3E 00       1509*  ZERO:			LD      A,0
04099A D9          1510*  			EXX
04099B 67          1511*  			LD      H,A
04099C 6F          1512*  			LD      L,A
04099D D9          1513*  			EXX
04099E 67          1514*  			LD      H,A
04099F 6F          1515*  			LD      L,A
0409A0 4F          1516*  			LD      C,A
0409A1 C9          1517*  			RET
0409A2             1518*  ;
0409A2 04          1519*  SCP0:			INC     B
0409A3 0C          1520*  			INC     C
0409A4 05          1521*  SCP1:			DEC     B
0409A5 28 0A       1522*  			JR      Z,SCP2
0409A7 0D          1523*  			DEC     C
0409A8 28 0C       1524*  			JR      Z,SCP3
0409AA 1A          1525*  			LD      A,(DE)
0409AB BE          1526*  			CP      (HL)
0409AC C0          1527*  			RET     NZ
0409AD 13          1528*  			INC     DE
0409AE 23          1529*  			INC     HL
0409AF 18 F3       1530*  			JR      SCP1
0409B1 B7          1531*  SCP2:			OR      A
0409B2 0D          1532*  			DEC     C
0409B3 C8          1533*  			RET     Z
0409B4 37          1534*  			SCF
0409B5 C9          1535*  			RET
0409B6 B7          1536*  SCP3:			OR      A
0409B7 0C          1537*  			INC     C
0409B8 C9          1538*  			RET
0409B9             1539*  ;
0409B9             1540*  ; PUSHS - SAVE STRING ON STACK.
0409B9             1541*  ;     Inputs: String in string accumulator.
0409B9             1542*  ;             E = string length.
0409B9             1543*  ;             A - saved on stack.
0409B9             1544*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409B9             1545*  ;
0409B9 CD 81 16 04 1546*  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0409BD DD E1       1547*  			POP     IX              	; IX: Return address
0409BF B7          1548*  			OR      A               	; Clear the carry flag
0409C0 01 00 00 00 1549*  			LD	BC,0			; BC: Length of the string
0409C4 4B          1550*  			LD	C,E
0409C5 21 00 4A 04 1551*  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0409C9 11 00 4A 04 1552*  			LD	DE,ACCS
0409CD 59          1553*  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0409CE ED 52       1554*  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0409D0 39          1555*  			ADD     HL,SP			; Grow the stack
0409D1 F9          1556*  			LD      SP,HL
0409D2 57          1557*  			LD      D,A			;  D: This needs to be set to A for some functions
0409D3 47          1558*  			LD	B,A			; Stack A and C (the string length)
0409D4 C5          1559*  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0409D5 06 00       1560*  			LD	B,0			; Reset B to 0 for the LDIR in this function
0409D7 28 0B       1561*  			JR      Z,PUSHS1        	; Is it zero length?
0409D9 11 00 4A 04 1562*  			LD      DE,ACCS			; DE: Destination
0409DD EB          1563*  			EX      DE,HL			; HL: Destination, DE: Address on stack
0409DE ED B0       1564*  			LDIR	                    	; Copy to stack
0409E0 CD 81 16 04 1565*  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0409E4 DD E9       1566*  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0409E6             1567*  ;
0409E6             1568*  ; POPS - RESTORE STRING FROM STACK.
0409E6             1569*  ;     Inputs: C = string length.
0409E6             1570*  ;    Outputs: String in string accumulator.
0409E6             1571*  ;             E = string length.
0409E6             1572*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0409E6             1573*  ;
0409E6 DD E1       1574*  POPS:			POP     IX              	; IX: Return address
0409E8 69          1575*  			LD	L,C			; Temporarily store string length in L
0409E9 01 00 00 00 1576*  			LD	BC,0
0409ED 4D          1577*  			LD	C,L			; BC: Number of bytes to copy
0409EE 21 00 00 00 1578*  			LD      HL,0			; HL: 0
0409F2 39          1579*  			ADD     HL,SP			; HL: Stack address
0409F3 11 00 4A 04 1580*  			LD      DE,ACCS			; DE: Destination
0409F7 0C          1581*  			INC     C			; Quick check to see if this is a zero length string
0409F8 0D          1582*  			DEC     C
0409F9 28 02       1583*  			JR      Z,POPS1         	; Yes it is, so skip
0409FB ED B0       1584*  			LDIR                    	; No, so copy from the stack
0409FD F9          1585*  POPS1:			LD      SP,HL			; Shrink the stack
0409FE DD E9       1586*  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
040A00             1587*  ;
040A00 FD 7E 00    1588*  HEXDIG:			LD      A,(IY)
040A03 FE 30       1589*  			CP      '0'
040A05 D8          1590*  			RET     C
040A06 FE 3A       1591*  			CP      '9'+1
040A08 3F          1592*  			CCF
040A09 D0          1593*  			RET     NC
040A0A FE 41       1594*  			CP      'A'
040A0C D8          1595*  			RET     C
040A0D D6 37       1596*  			SUB     'A'-10
040A0F FE 10       1597*  			CP      16
040A11 3F          1598*  			CCF
040A12 C9          1599*  			RET
040A13             1600*  ;
040A13 FD 7E 00    1601*  BINDIG:			LD	A,(IY)
040A16 FE 30       1602*  			CP	'0'
040A18 D8          1603*  			RET	C
040A19 FE 32       1604*  			CP	'1'+1
040A1B 3F          1605*  			CCF
040A1C C9          1606*  			RET
040A1D             1607*  ;
040A1D FE 3E       1608*  RELOP?:			CP      '>'
040A1F D0          1609*  			RET     NC
040A20 FE 3D       1610*  			CP      '='
040A22 D0          1611*  			RET     NC
040A23 FE 3C       1612*  			CP      '<'
040A25 C9          1613*  			RET
040A26             1614*  ;
040A26 CD 1A 03 04 1615*  EXPRSC:			CALL    EXPRS
040A2A CD 78 0A 04 1616*  COMMA:			CALL    NXT
040A2E FD 23       1617*  			INC     IY
040A30 FE 2C       1618*  			CP      ','
040A32 C8          1619*  			RET     Z
040A33 3E 05       1620*  			LD      A,5
040A35 18 0B       1621*  			JR      ERROR1_EV          ;"Missing ,"
040A37             1622*  ;
040A37 CD 78 0A 04 1623*  BRAKET:			CALL    NXT
040A3B FD 23       1624*  			INC     IY
040A3D FE 29       1625*  			CP      ')'
040A3F C8          1626*  			RET     Z
040A40 3E 1B       1627*  			LD      A,27
040A42 C3 B6 37 04 1628*  ERROR1_EV:			JP      ERROR_           ;"Missing )"
040A46             1629*  ;
040A46 FD 23       1630*  SAVE_EV:			INC     IY
040A48 08          1631*  SAVE1:			EX      AF,AF'
040A49 FA 3B 03 04 1632*  			JP      M,TYPE_EV_
040A4D 08          1633*  			EX      AF,AF'
040A4E E3          1634*  			EX      (SP),HL
040A4F D9          1635*  			EXX
040A50 E5          1636*  			PUSH    HL
040A51 D9          1637*  			EXX
040A52 F5          1638*  			PUSH    AF
040A53 C5          1639*  			PUSH    BC
040A54 E9          1640*  			JP      (HL)
040A55             1641*  ;
040A55 08          1642*  DOIT:			EX      AF,AF'
040A56 FA 3B 03 04 1643*  			JP      M,TYPE_EV_
040A5A D9          1644*  			EXX
040A5B C1          1645*  			POP     BC              ;RETURN ADDRESS
040A5C D9          1646*  			EXX
040A5D 79          1647*  			LD      A,C
040A5E C1          1648*  			POP     BC
040A5F 47          1649*  			LD      B,A
040A60 F1          1650*  			POP     AF              ;OPERATOR
040A61 D9          1651*  			EXX
040A62 EB          1652*  			EX      DE,HL
040A63 E1          1653*  			POP     HL
040A64 D9          1654*  			EXX
040A65 EB          1655*  			EX      DE,HL
040A66 E1          1656*  			POP     HL
040A67 D9          1657*  			EXX
040A68 C5          1658*  			PUSH    BC
040A69 D9          1659*  			EXX
040A6A E6 0F       1660*  			AND     0FH
040A6C CD A2 20 04 1661*  			CALL    FPP
040A70 38 D0       1662*  			JR      C,ERROR1_EV
040A72 AF          1663*  			XOR     A
040A73 08          1664*  			EX      AF,AF'          ;TYPE
040A74 FD 7E 00    1665*  			LD      A,(IY)
040A77 C9          1666*  			RET
040A78             1667*  ;
040A78             1668*  ; Skip spaces
040A78             1669*  ; - IY: String pointer
040A78             1670*  ; Returns:
040A78             1671*  ;  - A: The non-space character found
040A78             1672*  ; - IY: Points to the character before that
040A78             1673*  ;
040A78 FD 7E 00    1674*  NXT:			LD      A,(IY)			; Fetch the character
040A7B FE 20       1675*  			CP      ' '			; If it is space, then return
040A7D C0          1676*  			RET     NZ
040A7E FD 23       1677*  			INC     IY			; Increment the pointer and
040A80 C3 78 0A 04 1678*  			JP      NXT			; Loop
040A84             1679*  ;
040A84 E5          1680*  DISPT2:			PUSH    HL
040A85 21 B5 01 04 1681*  			LD      HL,SOPTBL
040A89 18 07       1682*  			JR      DISPT0
040A8B             1683*  ;
040A8B E5          1684*  DISPAT:			PUSH    HL
040A8C D6 8D       1685*  			SUB     FUNTOK
040A8E 21 0A 01 04 1686*  			LD      HL,FUNTBL
040A92 C5          1687*  DISPT0:			PUSH    BC
040A93             1688*  
040A93 01 03 00 00 1689*  			LD	BC, 3
040A97 47          1690*  			LD	B, A
040A98 ED 4C       1691*  			MLT	BC
040A9A 09          1692*  			ADD	HL, BC
040A9B ED 27       1693*  			LD	HL, (HL)
040A9D             1694*  
040A9D             1695*  ;			ADD     A,A
040A9D             1696*  ;			LD      C,A
040A9D             1697*  ;			LD      B,0
040A9D             1698*  ;			ADD     HL,BC
040A9D             1699*  ;			LD      A,(HL)
040A9D             1700*  ;			INC     HL
040A9D             1701*  ;			LD      H,(HL)
040A9D             1702*  ;			LD      L,A
040A9D             1703*  
040A9D C1          1704*  			POP     BC
040A9E E3          1705*  			EX      (SP),HL
040A9F C9          1706*  			RET                     ;OFF TO ROUTINE
040AA0             1707*  
040AA0             0007       include "exec.asm"
040AA0             0001*  ;
040AA0             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040AA0             0003*  ;		Statement Execution & Assembler Module - "EXEC"
040AA0             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
040AA0             0005*  ; Modified By:	Dean Belfield
040AA0             0006*  ; Created:	12/05/2023
040AA0             0007*  ; Last Updated:	26/06/2023
040AA0             0008*  ;
040AA0             0009*  ; Modinfo:
040AA0             0010*  ; 27/01/1984:	Version 2.1
040AA0             0011*  ; 02/03/1987:	Version 3.0
040AA0             0012*  ; 11/06/1987:	Version 3.1
040AA0             0013*  ; 12/05/2023:	Modified by Dean Belfield
040AA0             0014*  ; 07/06/2023:	Modified to run in ADL mode
040AA0             0015*  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040AA0             0016*  
040AA0             0017*  			; .ASSUME	ADL = 1
040AA0             0018*  
040AA0             0019*  			; INCLUDE	"equs.inc"
040AA0             0020*  
040AA0             0021*  			; SEGMENT CODE
040AA0             0022*  
040AA0             0023*  			; XDEF	XEQ
040AA0             0024*  			; XDEF	CHAIN0
040AA0             0025*  			; XDEF	RUN
040AA0             0026*  			; XDEF	SYNTAX
040AA0             0027*  			; XDEF	ESCAPE
040AA0             0028*  			; XDEF	FN_EX
040AA0             0029*  			; XDEF	USR
040AA0             0030*  			; XDEF	STORE5
040AA0             0031*  			; XDEF	STORE4
040AA0             0032*  			; XDEF	CHECK
040AA0             0033*  			; XDEF	TERMQ
040AA0             0034*  			; XDEF	FILL
040AA0             0035*  			; XDEF	X4OR5
040AA0             0036*  			; XDEF	MUL16
040AA0             0037*  			; XDEF	CHANEL
040AA0             0038*  			; XDEF	ASSEM
040AA0             0039*  
040AA0             0040*  			; XREF	AUTO
040AA0             0041*  			; XREF	DELETE
040AA0             0042*  			; XREF	LOAD
040AA0             0043*  			; XREF	LIST_
040AA0             0044*  			; XREF	NEW
040AA0             0045*  			; XREF	OLD
040AA0             0046*  			; XREF	RENUM
040AA0             0047*  			; XREF	SAVE
040AA0             0048*  			; XREF	SOUND
040AA0             0049*  			; XREF	CLG
040AA0             0050*  			; XREF	DRAW
040AA0             0051*  			; XREF	ENVEL
040AA0             0052*  			; XREF	GCOL
040AA0             0053*  			; XREF	MODE
040AA0             0054*  			; XREF	MOVE
040AA0             0055*  			; XREF	PLOT
040AA0             0056*  			; XREF	COLOUR
040AA0             0057*  			; XREF	EXPRS
040AA0             0058*  			; XREF	HIMEM
040AA0             0059*  			; XREF	LOAD0
040AA0             0060*  			; XREF	RANDOM
040AA0             0061*  			; XREF	CLEAR
040AA0             0062*  			; XREF	ERRTRP
040AA0             0063*  			; XREF	PAGE_
040AA0             0064*  			; XREF	DATAPTR
040AA0             0065*  			; XREF	ERRLIN
040AA0             0066*  			; XREF	TRAP
040AA0             0067*  			; XREF	NXT
040AA0             0068*  			; XREF	SETLIN
040AA0             0069*  			; XREF	CLOOP
040AA0             0070*  			; XREF	OSSHUT
040AA0             0071*  			; XREF	WARM
040AA0             0072*  			; XREF	TRACEN
040AA0             0073*  			; XREF	OUTCHR
040AA0             0074*  			; XREF	PBCDL
040AA0             0075*  			; XREF	OSCLI
040AA0             0076*  			; XREF	LISTON
040AA0             0077*  			; XREF	GETVAR
040AA0             0078*  			; XREF	PUTVAR
040AA0             0079*  			; XREF	DATPTR
040AA0             0080*  			; XREF	ERROR_
040AA0             0081*  			; XREF	EXPR
040AA0             0082*  			; XREF	CREATE
040AA0             0083*  			; XREF	EXPRI
040AA0             0084*  			; XREF	BRAKET
040AA0             0085*  			; XREF	FREE
040AA0             0086*  			; XREF	OSBPUT
040AA0             0087*  			; XREF	COUNT
040AA0             0088*  			; XREF	STR
040AA0             0089*  			; XREF	HEXSTR
040AA0             0090*  			; XREF	CRLF
040AA0             0091*  			; XREF	ITEMI
040AA0             0092*  			; XREF	FINDL
040AA0             0093*  			; XREF	TEST
040AA0             0094*  			; XREF	EXPRN
040AA0             0095*  			; XREF	DLOAD5
040AA0             0096*  			; XREF	DLOAD5_SPL
040AA0             0097*  			; XREF	LOADN
040AA0             0098*  			; XREF	FPP
040AA0             0099*  			; XREF	SWAP
040AA0             0100*  			; XREF	GETDEF
040AA0             0101*  			; XREF	ZERO
040AA0             0102*  			; XREF	OSBGET
040AA0             0103*  			; XREF	BUFFER
040AA0             0104*  			; XREF	CONS
040AA0             0105*  			; XREF	VAL0
040AA0             0106*  			; XREF	OSLINE
040AA0             0107*  			; XREF	CLRSCN
040AA0             0108*  			; XREF	TELL
040AA0             0109*  			; XREF	SAYLN
040AA0             0110*  			; XREF	REPORT
040AA0             0111*  			; XREF	PUTPTR
040AA0             0112*  			; XREF	PUTIME
040AA0             0113*  			; XREF	PUTIMS
040AA0             0114*  			; XREF	LOMEM
040AA0             0115*  			; XREF	WIDTH
040AA0             0116*  			; XREF	OSWRCH
040AA0             0117*  			; XREF	COMMA
040AA0             0118*  			; XREF	OSCALL
040AA0             0119*  			; XREF	SFIX
040AA0             0120*  			; XREF	LOAD4
040AA0             0121*  			; XREF	PUSHS
040AA0             0122*  			; XREF	POPS
040AA0             0123*  			; XREF	LOADS
040AA0             0124*  			; XREF	PUTCSR
040AA0             0125*  			; XREF	OUT_
040AA0             0126*  			; XREF	R0
040AA0             0127*  ;
040AA0             0128*  ; List of token values used in this module
040AA0             0129*  ; consolidated with the token values in main.asm
040AA0             0130*  ; TAND:			EQU     80H
040AA0             0131*  ; TOR:			EQU     84H
040AA0             0132*  ; TERROR:			EQU     85H
040AA0             0133*  ; LINE_:			EQU     86H
040AA0             0134*  ; OFF_:			EQU     87H
040AA0             0135*  ; STEP:			EQU     88H
040AA0             0136*  ; SPC:			EQU     89H
040AA0             0137*  ; TAB:			EQU     8AH
040AA0             0138*  ; ELSE_:			EQU     8BH
040AA0             0139*  ; THEN:			EQU     8CH
040AA0             0140*  ; LINO:			EQU     8DH
040AA0             0141*  ; TO:				EQU     B8H
040AA0             0142*  ; TCALL:			EQU     D6H
040AA0             0143*  ; DATA_:			EQU     DCH
040AA0             0144*  ; DEF_:			EQU     DDH
040AA0             0145*  ; TGOSUB:			EQU     E4H
040AA0             0146*  ; TGOTO:			EQU     E5H
040AA0             0147*  ; TON:			EQU     EEH
040AA0             0148*  ; TPROC:			EQU     F2H
040AA0             0149*  ; TSTOP:			EQU     FAH
040AA0             0150*  
040AA0             0151*  ; TCMD:			EQU     C6H ; in eval.asm
040AA0             0152*  
040AA0             0153*  ; The command table
040AA0             0154*  ; Commands are tokens from C6H onwards; this lookup table is used to
040AA0             0155*  ; run the corresponding function; Note that DATA and DEF both use the same
040AA0             0156*  ; code as REM
040AA0             0157*  ;
040AA0 3F 37 04    0158*  CMDTAB:			DW24  AUTO			; C6H
040AA3 A2 35 04    0159*  			DW24  DELETE			; C7H
040AA6 80 37 04    0160*  			DW24  LOAD			; C8H
040AA9 DD 35 04    0161*  			DW24  LIST_			; C9H
040AAC 5D 37 04    0162*  			DW24  NEW			; CAH
040AAF 63 37 04    0163*  			DW24  OLD			; CBH
040AB2 6C 36 04    0164*  			DW24  RENUM			; CCH
040AB5 91 37 04    0165*  			DW24  SAVE			; CDH
040AB8 DA 15 04    0166*  			DW24  PUT			; CEH
040ABB D0 13 04    0167*  			DW24  PTR_EX			; CFH
040ABE EA 13 04    0168*  			DW24  PAGEV_EX			; D0H
040AC1 FD 13 04    0169*  			DW24  TIMEV_EX			; D1H
040AC4 26 14 04    0170*  			DW24  LOMEMV_EX			; D2H
040AC7 3F 14 04    0171*  			DW24  HIMEMV_EX			; D3H
040ACA 82 46 04    0172*  			DW24  SOUND			; D4H
040ACD F4 14 04    0173*  			DW24  BPUT			; D5H
040AD0 0C 15 04    0174*  			DW24  CALL_			; D6H
040AD3 54 0B 04    0175*  			DW24  CHAIN			; D7H
040AD6 9F 13 04    0176*  			DW24  CLR			; D8H
040AD9 E8 14 04    0177*  			DW24  CLOSE			; D9H
040ADC 1E 44 04    0178*  			DW24  CLG			; DAH
040ADF 72 13 04    0179*  			DW24  CLS			; DBH
040AE2 33 0C 04    0180*  			DW24  REM_EX             		; DCH: DATA
040AE5 33 0C 04    0181*  			DW24  REM_EX             		; DDH: DEF
040AE8 F9 0C 04    0182*  			DW24  DIM_EX			; DEH
040AEB 48 46 04    0183*  			DW24  DRAW			; DFH
040AEE CE 0B 04    0184*  			DW24  END_			; E0H
040AF1 8A 11 04    0185*  			DW24  ENDPRO			; E1H
040AF4 A2 49 04    0186*  			DW24  ENVEL			; E2H
040AF7 9F 0F 04    0187*  			DW24  FOR_EX			; E3H
040AFA 4F 0F 04    0188*  			DW24  GOSUB_EX			; E4H
040AFD 33 0F 04    0189*  			DW24  GOTO_EX			; E5H
040B00 DC 45 04    0190*  			DW24  GCOL			; E6H
040B03 3E 13 04    0191*  			DW24  IF_			; E7H
040B06 2C 12 04    0192*  			DW24  INPUT			; E8H
040B09 54 0C 04    0193*  			DW24  LET			; E9H
040B0C 2F 11 04    0194*  			DW24  LOCAL_EX_			; EAH
040B0F 2E 44 04    0195*  			DW24  MODE			; EBH
040B12 40 46 04    0196*  			DW24  MOVE			; ECH
040B15 ED 0F 04    0197*  			DW24  NEXT_EX			; EDH
040B18 C6 0E 04    0198*  			DW24  ON_EX_			; EEH
040B1B A9 14 04    0199*  			DW24  VDU			; EFH
040B1E 0E 46 04    0200*  			DW24  PLOT			; F0H
040B21 CF 0D 04    0201*  			DW24  PRINT_			; F1H
040B24 8C 10 04    0202*  			DW24  PROC_EX			; F2H
040B27 DE 12 04    0203*  			DW24  READ			; F3H
040B2A 33 0C 04    0204*  			DW24  REM_EX			; F4H
040B2D 6F 0F 04    0205*  			DW24  REPEAT_EX			; F5H
040B30 97 13 04    0206*  			DW24  REPOR			; F6H
040B33 A9 13 04    0207*  			DW24  RESTOR_EX			; F7H
040B36 5D 0F 04    0208*  			DW24  RETURN			; F8H
040B39 4E 0B 04    0209*  			DW24  RUN			; F9H
040B3C 7F 13 04    0210*  			DW24  STOP			; FAH
040B3F 2A 45 04    0211*  			DW24  COLOUR			; FBH
040B42 8B 14 04    0212*  			DW24  TRACE_EX			; FCH
040B45 79 0F 04    0213*  			DW24  UNTIL_EX			; FDH
040B48 7D 14 04    0214*  			DW24  WIDTHV			; FEH
040B4B 19 0C 04    0215*  			DW24  CLI             		; FFH: OSCLI
040B4E             0216*  
040B4E             0217*  ; RUN
040B4E             0218*  ; RUN "filename"
040B4E             0219*  ;
040B4E CD AC 17 04 0220*  RUN:			CALL    TERMQ			; Standalone RUN command?
040B52 28 10       0221*  			JR      Z,RUN0			; Yes, so just RUN the code
040B54             0222*  
040B54             0223*  ; CHAIN "filename"
040B54             0224*  ;
040B54 CD 1A 03 04 0225*  CHAIN:			CALL    EXPRS			; Get the filename
040B58 3E 0D       0226*  			LD      A,CR			; Terminate it with a CR
040B5A 12          0227*  			LD      (DE),A
040B5B ED 7B 20 4D 0228*  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
040B60 CD 75 38 04 0229*  			CALL    LOAD0			; And load the file in
040B64             0230*  ;
040B64 ED 7B 20 4D 0231*  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
040B69 DD 21 38 4D 0232*  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
040B6E ED 5F       0233*  @@:			LD      A, R			; Use the R register to seed the random number generator
040B70 28 FC       0234*  			JR      Z, @B			; Loop unti we get a non-zero value in A
040B72 07          0235*  			RLCA				; Rotate it
040B73 07          0236*  			RLCA
040B74 DD 77 03    0237*  			LD      (IX+3),A		; And store
040B77 9F          0238*  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
040B78 DD 77 04    0239*  			LD      (IX+4),A		; And store
040B7B CD CC 38 04 0240*  			CALL    CLEAR
040B7F 21 00 00 00 0241*  			LD      HL,0			; Clear the error trap sysvar
040B83 22 2C 4D 04 0242*  			LD      (ERRTRP),HL
040B87 2A 14 4D 04 0243*  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
040B8B 3E DC       0244*  			LD      A,DATA_			; The DATA token value
040B8D CD 80 18 04 0245*  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
040B91 22 31 4D 04 0246*  			LD      (DATPTR),HL     	; Set data pointer
040B95 FD 2A 14 4D 0247*  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
040B9A             0248*  ;
040B9A CD E2 0B 04 0249*  XEQ0:			CALL    NEWLIN
040B9E FD 22 35 4D 0250*  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040BA3 CD C3 3F 04 0251*  			CALL    TRAP           		; Check keyboard
040BA7 CD 78 0A 04 0252*  XEQ1:			CALL    NXT
040BAB FD 23       0253*  			INC     IY
040BAD FE 3A       0254*  			CP      ':'             	; Seperator
040BAF 28 F6       0255*  			JR      Z,XEQ1
040BB1 FE 0D       0256*  			CP      CR
040BB3 28 E5       0257*  			JR      Z,XEQ0          	; New program line
040BB5 D6 C6       0258*  			SUB     TCMD
040BB7 DA 42 0C 04 0259*  			JP      C,LET0          	; Implied "LET"
040BBB             0260*  
040BBB 01 03 00 00 0261*  			LD	BC, 3
040BBF 47          0262*  			LD	B, A
040BC0 ED 4C       0263*  			MLT	BC
040BC2 21 A0 0A 04 0264*  			LD	HL,CMDTAB
040BC6 09          0265*  			ADD	HL, BC
040BC7 ED 27       0266*  			LD	HL, (HL)		; Table entry
040BC9             0267*  
040BC9             0268*  ;			ADD     A,A
040BC9             0269*  ;			LD      C,A
040BC9             0270*  ;			LD      B,0
040BC9             0271*  ;			LD      HL,CMDTAB
040BC9             0272*  ;			ADD     HL,BC
040BC9             0273*  ;			LD      A,(HL)          	; Table entry
040BC9             0274*  ;			INC     HL
040BC9             0275*  ;			LD      H,(HL)
040BC9             0276*  ;			LD      L,A
040BC9             0277*  
040BC9 CD 78 0A 04 0278*  			CALL    NXT
040BCD E9          0279*  			JP      (HL)            	; Execute the statement
040BCE             0280*  
040BCE             0281*  ;END
040BCE             0282*  ;
040BCE CD 04 3A 04 0283*  END_:			CALL    SETLIN          ;FIND CURRENT LINE
040BD2 7C          0284*  			LD      A,H
040BD3 B5          0285*  			OR      L               ;DIRECT?
040BD4 CA D6 30 04 0286*  			JP      Z,CLOOP
040BD8 1E 00       0287*  			LD      E,0
040BDA CD 92 43 04 0288*  			CALL    OSSHUT          ;CLOSE ALL FILES
040BDE C3 D5 30 04 0289*  			JP      WARM            ;"Ready"
040BE2             0290*  ;
040BE2 FD 7E 00    0291*  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040BE5 01 03 00 00 0292*  			LD      BC,3
040BE9 FD 09       0293*  			ADD     IY,BC
040BEB B7          0294*  			OR      A
040BEC 28 E0       0295*  			JR      Z,END_           ;LENGTH=0, EXIT
040BEE 2A 26 4D 04 0296*  			LD      HL,(TRACEN)
040BF2 7C          0297*  			LD      A,H
040BF3 B5          0298*  			OR      L
040BF4 C8          0299*  			RET     Z
040BF5 11 00 00 00 0300*  			LD	DE, 0		;Clear DE
040BF9 FD 56 FF    0301*  			LD      D,(IY-1)        ;DE = LINE NUMBER
040BFC FD 5E FE    0302*  			LD      E,(IY-2)
040BFF ED 52       0303*  			SBC     HL,DE
040C01 D8          0304*  			RET     C
040C02 EB          0305*  			EX      DE,HL
040C03 3E 5B       0306*  			LD      A,'['           ;TRACE
040C05 CD A5 39 04 0307*  			CALL    OUTCHR
040C09 CD 4D 3A 04 0308*  			CALL    PBCDL
040C0D 3E 5D       0309*  			LD      A,']'
040C0F CD A5 39 04 0310*  			CALL    OUTCHR
040C13 3E 20       0311*  			LD      A,' '
040C15 C3 A5 39 04 0312*  			JP      OUTCHR
040C19             0313*  
040C19             0314*  ; Routines for each statement -------------------------------------------------
040C19             0315*  
040C19             0316*  ; OSCLI
040C19             0317*  ;
040C19 CD 1A 03 04 0318*  CLI:			CALL    EXPRS
040C1D 3E 0D       0319*  			LD      A,CR
040C1F 12          0320*  			LD      (DE),A
040C20 21 00 4A 04 0321*  			LD      HL,ACCS
040C24 CD E6 3F 04 0322*  			CALL    OSCLI
040C28 C3 9E 0B 04 0323*  			JP      XEQ
040C2C             0324*  
040C2C             0325*  ; REM, *
040C2C             0326*  ;
040C2C FD E5       0327*  EXT_EX:			PUSH    IY
040C2E E1          0328*  			POP     HL
040C2F CD E6 3F 04 0329*  			CALL    OSCLI
040C33 FD E5       0330*  REM_EX:			PUSH    IY
040C35 E1          0331*  			POP     HL
040C36 3E 0D       0332*  			LD      A,CR
040C38 47          0333*  			LD      B,A
040C39 ED B1       0334*  			CPIR                    ;FIND LINE END
040C3B E5          0335*  			PUSH    HL
040C3C FD E1       0336*  			POP     IY
040C3E C3 9A 0B 04 0337*  			JP      XEQ0
040C42             0338*  
040C42             0339*  ; [LET] var = expr
040C42             0340*  ;
040C42 FE C5       0341*  LET0:			CP      ELSE_-TCMD
040C44 28 ED       0342*  			JR      Z,REM_EX
040C46             0343*  			; CP      ('*'-TCMD) & 0FFH
040C46             0344*  			; JR      Z,EXT_EX
040C46             0345*  			; CP      ('='-TCMD) & 0FFH
040C46             0346*  			; JR      Z,FNEND
040C46             0347*  			; CP      ('['-TCMD) & 0FFH
040C46             0348*  			; ez80asm doesn't like () in expressions
040C46 FE 64       0349*  			CP      '*'-TCMD & 0FFH
040C48 28 E2       0350*  			JR      Z,EXT_EX
040C4A FE 77       0351*  			CP      '='-TCMD & 0FFH
040C4C 28 5B       0352*  			JR      Z,FNEND
040C4E FE 95       0353*  			CP      '['-TCMD & 0FFH
040C50 28 25       0354*  			JR      Z,ASM
040C52 FD 2B       0355*  			DEC     IY
040C54 CD F0 15 04 0356*  LET:			CALL    ASSIGN			; Assign the variable
040C58 CA 9E 0B 04 0357*  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
040C5C 38 41       0358*  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
040C5E             0359*  ;
040C5E F5          0360*  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
040C5F CD C2 17 04 0361*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040C63 E5          0362*  			PUSH    HL			; HL: Address of the variable
040C64 CD 1A 03 04 0363*  			CALL    EXPRS
040C68 DD E1       0364*  			POP     IX			; IX: Address of the variable
040C6A F1          0365*  			POP     AF			; AF: The variable type
040C6B CD 32 16 04 0366*  			CALL    STACCS			; Copy the string from ACCS to the variable area
040C6F C3 9E 0B 04 0367*  XEQR:			JP      XEQ
040C73             0368*  ;
040C73 CD E2 0B 04 0369*  ASM0:			CALL    NEWLIN
040C77 FD 22 35 4D 0370*  ASM:			LD      (ERRLIN),IY
       04          
040C7C CD C3 3F 04 0371*  			CALL    TRAP
040C80 CD CD 18 04 0372*  			CALL    ASSEM
040C84 38 19       0373*  			JR      C,SYNTAX
040C86 FE 0D       0374*  			CP      CR
040C88 28 E9       0375*  			JR      Z,ASM0
040C8A 21 40 4D 04 0376*  			LD      HL,LISTON
040C8E 7E          0377*  			LD      A,(HL)
040C8F E6 0F       0378*  			AND     0FH
040C91 F6 B0       0379*  			OR      B0H
040C93 77          0380*  			LD      (HL),A
040C94 18 D9       0381*  			JR      XEQR
040C96             0382*  ;
040C96 CD 90 3A 04 0383*  VAR_:			CALL    GETVAR
040C9A C8          0384*  			RET     Z
040C9B D2 7F 3A 04 0385*  			JP      NC,PUTVAR
040C9F 3E 10       0386*  SYNTAX:			LD      A,16            ;"Syntax error"
040CA1 18 02       0387*  			JR	ERROR0_EX
040CA3 3E 11       0388*  ESCAPE:			LD      A,17            ;"Escape"
040CA5 C3 B6 37 04 0389*  ERROR0_EX:			JP      ERROR_
040CA9             0390*  
040CA9             0391*  ; =
040CA9             0392*  ;
040CA9 CD C7 01 04 0393*  FNEND:			CALL    EXPR            ;FUNCTION RESULT
040CAD 43          0394*  			LD      B,E
040CAE EB          0395*  			EX      DE,HL
040CAF D9          0396*  			EXX                     ;SAVE RESULT
040CB0 EB          0397*  			EX      DE,HL           ; IN DEB'C'D'E'
040CB1 C1          0398*  FNEND5:			POP     BC
040CB2 21 8A 17 04 0399*  			LD      HL,LOCCHK
040CB6 B7          0400*  			OR      A
040CB7 ED 42       0401*  			SBC     HL,BC
040CB9 28 1C       0402*  			JR      Z,FNEND0        ;LOCAL VARIABLE
040CBB 21 8C 10 04 0403*  			LD      HL,FNCHK
040CBF B7          0404*  			OR      A
040CC0 ED 42       0405*  			SBC     HL,BC
040CC2 3E 07       0406*  			LD      A,7
040CC4 20 DF       0407*  			JR      NZ,ERROR0_EX       ;"No FN"
040CC6 FD E1       0408*  			POP     IY
040CC8 FD 22 35 4D 0409*  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
040CCD EB          0410*  			EX      DE,HL
040CCE D9          0411*  			EXX
040CCF EB          0412*  			EX      DE,HL
040CD0 11 00 4A 04 0413*  			LD      DE,ACCS
040CD4 58          0414*  			LD      E,B
040CD5 08          0415*  			EX      AF,AF'
040CD6 C9          0416*  			RET
040CD7             0417*  ;
040CD7 DD E1       0418*  FNEND0:			POP     IX
040CD9 C1          0419*  			POP     BC
040CDA 78          0420*  			LD      A,B
040CDB B7          0421*  			OR      A
040CDC FA EA 0C 04 0422*  			JP      M,FNEND1        ;STRING
040CE0 E1          0423*  			POP     HL
040CE1 D9          0424*  			EXX
040CE2 E1          0425*  			POP     HL
040CE3 D9          0426*  			EXX
040CE4 CD 08 16 04 0427*  			CALL    STORE
040CE8 18 C7       0428*  			JR      FNEND5
040CEA 21 00 00 00 0429*  FNEND1:			LD      HL,0
040CEE 39          0430*  			ADD     HL,SP
040CEF D5          0431*  			PUSH    DE
040CF0 59          0432*  			LD      E,C
040CF1 CD 36 16 04 0433*  			CALL    STORES
040CF5 D1          0434*  			POP     DE
040CF6 F9          0435*  			LD      SP,HL
040CF7 18 B8       0436*  			JR      FNEND5
040CF9             0437*  
040CF9             0438*  ; DIM var(dim1[,dim2[,...]])[,var(...]
040CF9             0439*  ; DIM var expr[,var expr...]
040CF9             0440*  ;
040CF9 CD 90 3A 04 0441*  DIM_EX:			CALL    GETVAR          	; Get the variable
040CFD DA 89 0D 04 0442*  			JP      C,BADDIM		; Throw a "Bad Dim" error
040D01 CA 93 0D 04 0443*  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040D05 CD 04 3C 04 0444*  			CALL    CREATE			; Create a new entity
040D09 E5          0445*  			PUSH    HL			; HL: Address of the entity
040D0A DD E1       0446*  			POP     IX			; IX: Address of the entity
040D0C FD 7E 00    0447*  			LD      A,(IY)			; Fetch the next character from the tokenised string
040D0F FE 28       0448*  			CP      '('			; Check for opening brackets
040D11 7A          0449*  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040D12 20 7F       0450*  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040D14             0451*  ;
040D14             0452*  ; At this point we're reserving a variable array
040D14             0453*  ;
040D14 E5          0454*  			PUSH    HL			; HL: Address of the entity
040D15 F5          0455*  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040D16 11 01 00 00 0456*  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
040D1A 42          0457*  			LD      B,D			;  B: The number of dimensions in the array
040D1B             0458*  ;
040D1B FD 23       0459*  DIM1:			INC     IY			; Skip to the next token
040D1D C5          0460*  			PUSH    BC			; Stack the dimension counter
040D1E D5          0461*  			PUSH    DE			; Stack the total size of array accumulator
040D1F DD E5       0462*  			PUSH    IX			; Stack the entity address
040D21 CD 0F 03 04 0463*  			CALL    EXPRI           	; Fetch the size of this dimension
040D25 CB 7C       0464*  			BIT     7,H			; If it is negative then
040D27 20 60       0465*  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040D29 D9          0466*  			EXX
040D2A 23          0467*  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
040D2B DD E1       0468*  			POP     IX			; IX: The entity address
040D2D DD 23       0469*  			INC     IX
040D2F DD 75 00    0470*  			LD      (IX),L          	; Save the size of this dimension in the entity
040D32 DD 23       0471*  			INC     IX
040D34 DD 74 00    0472*  			LD      (IX),H
040D37 C1          0473*  			POP     BC
040D38 CD A4 18 04 0474*  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
040D3C 38 4F       0475*  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
040D3E EB          0476*  			EX      DE,HL           	; DE: The new total size of array accumulator
040D3F C1          0477*  			POP     BC
040D40 04          0478*  			INC     B               	;  B: The dimension counter; increment
040D41 FD 7E 00    0479*  			LD      A,(IY)			; Fetch the nex token
040D44 FE 2C       0480*  			CP      ','             	; Check for another dimension in the array
040D46 28 D3       0481*  			JR      Z,DIM1			; And loop
040D48             0482*  ;
040D48 CD 37 0A 04 0483*  			CALL    BRAKET          	; Check for closing bracket
040D4C F1          0484*  			POP     AF              	; Restore the type
040D4D DD 23       0485*  			INC     IX
040D4F DD E3       0486*  			EX      (SP),IX
040D51 DD 70 00    0487*  			LD      (IX),B          	; Number of dimensions
040D54 CD 97 18 04 0488*  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
040D58 E1          0489*  			POP     HL			; Restore the entity address
040D59 38 32       0490*  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
040D5B             0491*  ;
040D5B             0492*  ; We now allocate the memory for the array
040D5B             0493*  ;
040D5B 19          0494*  DIM3:			ADD     HL,DE
040D5C 38 2F       0495*  			JR      C,NOROOM
040D5E E5          0496*  			PUSH    HL
040D5F 24          0497*  			INC     H
040D60 28 2B       0498*  			JR      Z,NOROOM
040D62 ED 72       0499*  			SBC     HL,SP
040D64 30 27       0500*  			JR      NC,NOROOM       	; Throw an "Out of Space" error
040D66 E1          0501*  			POP     HL
040D67 22 1D 4D 04 0502*  			LD      (FREE),HL
040D6B 7A          0503*  DIM2:			LD      A,D
040D6C B3          0504*  			OR      E
040D6D 28 06       0505*  			JR      Z,DIM5
040D6F 2B          0506*  			DEC     HL
040D70 36 00       0507*  			LD      (HL),0         		; Initialise the array
040D72 1B          0508*  			DEC     DE
040D73 18 F6       0509*  			JR      DIM2
040D75 CD 78 0A 04 0510*  DIM5:			CALL    NXT
040D79 FE 2C       0511*  			CP      ','            		; Another variable?
040D7B C2 9E 0B 04 0512*  			JP      NZ,XEQ
040D7F FD 23       0513*  			INC     IY
040D81 CD 78 0A 04 0514*  			CALL    NXT
040D85 C3 F9 0C 04 0515*  			JP      DIM_EX
040D89             0516*  ;
040D89             0517*  ; DIM errors
040D89             0518*  ;
040D89 3E 0A       0519*  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
040D8B 18 02       0520*  			JR	ERROR1_EX
040D8D 3E 0B       0521*  NOROOM:			LD      A,11            	; Throw a "DIM space" error
040D8F C3 B6 37 04 0522*  ERROR1_EX:			JP      ERROR_
040D93             0523*  ;
040D93             0524*  ; At this point we're reserving a block of memory, i.e.
040D93             0525*  ; DIM var expr[,var expr...]
040D93             0526*  ;
040D93 B7          0527*  DIM4:			OR      A			;  A: The dimension variable type
040D94 28 F3       0528*  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
040D96 FA 89 0D 04 0529*  			JP      M,BADDIM        	; or a string
040D9A 47          0530*  			LD      B,A			; Temporarily store the dimension variable type in B
040D9B FD 7E FF    0531*  			LD      A,(IY-1)		; Get the last character but one
040D9E FE 29       0532*  			CP      ')'			; Check if it is a trailing bracket
040DA0 28 E7       0533*  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040DA2             0534*  ;
040DA2 21 00 00 00 0535*  			LD	HL,0			; Clear HL
040DA6 3A 1D 4D 04 0536*  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
040DAA 6F          0537*  			LD	L,A
040DAB 3A 1E 4D 04 0538*  			LD	A,(FREE+1)
040DAF 67          0539*  			LD	H,A
040DB0 78          0540*  			LD	A,B			; Restore the dimension variable type
040DB1 D9          0541*  			EXX
040DB2 21 00 00 00 0542*  			LD	HL,0			; Clear HL
040DB6 47          0543*  			LD	B,A			; Temporarily store the dimension variable type in B
040DB7 3A 1F 4D 04 0544*  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
040DBB 6F          0545*  			LD	L,A
040DBC 78          0546*  			LD	A,B			; Restore the dimension variable type
040DBD 4C          0547*  			LD	C,H
040DBE CD 08 16 04 0548*  			CALL    STORE           	; Store the address
040DC2 CD 0F 03 04 0549*  			CALL    EXPRI			; Get the number of bytes to store
040DC6 D9          0550*  			EXX
040DC7 23          0551*  			INC     HL			; Add one to it
040DC8 EB          0552*  			EX      DE,HL
040DC9 2A 1D 4D 04 0553*  			LD      HL,(FREE)
040DCD 18 8C       0554*  			JR      DIM3			; Continue with the DIM
040DCF             0555*  
040DCF             0556*  ; PRINT list...
040DCF             0557*  ; PRINT #channel,list...
040DCF             0558*  ;
040DCF FE 23       0559*  PRINT_:			CP      '#'
040DD1 20 7C       0560*  			JR      NZ,PRINT0
040DD3 CD C4 18 04 0561*  			CALL    CHNL            ;CHANNEL NO. = E
040DD7 CD 78 0A 04 0562*  PRNTN1:			CALL    NXT
040DDB FE 2C       0563*  			CP      ','
040DDD C2 9E 0B 04 0564*  			JP      NZ,XEQ
040DE1 FD 23       0565*  			INC     IY
040DE3 D5          0566*  			PUSH    DE
040DE4 CD C7 01 04 0567*  			CALL    EXPR            ;ITEM TO PRINT
040DE8 08          0568*  			EX      AF,AF'
040DE9 FA 0F 0E 04 0569*  			JP      M,PRNTN2        ;STRING
040DED D1          0570*  			POP     DE
040DEE C5          0571*  			PUSH    BC
040DEF D9          0572*  			EXX
040DF0 7D          0573*  			LD      A,L
040DF1 D9          0574*  			EXX
040DF2 CD A2 43 04 0575*  			CALL    OSBPUT
040DF6 D9          0576*  			EXX
040DF7 7C          0577*  			LD      A,H
040DF8 D9          0578*  			EXX
040DF9 CD A2 43 04 0579*  			CALL    OSBPUT
040DFD 7D          0580*  			LD      A,L
040DFE CD A2 43 04 0581*  			CALL    OSBPUT
040E02 7C          0582*  			LD      A,H
040E03 CD A2 43 04 0583*  			CALL    OSBPUT
040E07 C1          0584*  			POP     BC
040E08 79          0585*  			LD      A,C
040E09 CD A2 43 04 0586*  			CALL    OSBPUT
040E0D 18 C8       0587*  			JR      PRNTN1
040E0F 4B          0588*  PRNTN2:			LD      C,E
040E10 D1          0589*  			POP     DE
040E11 21 00 4A 04 0590*  			LD      HL,ACCS
040E15 0C          0591*  			INC     C
040E16 0D          0592*  PRNTN3:			DEC     C
040E17 28 0A       0593*  			JR      Z,PRNTN4
040E19 7E          0594*  			LD      A,(HL)
040E1A 23          0595*  			INC     HL
040E1B C5          0596*  			PUSH    BC
040E1C CD A2 43 04 0597*  			CALL    OSBPUT
040E20 C1          0598*  			POP     BC
040E21 18 F3       0599*  			JR      PRNTN3
040E23 3E 0D       0600*  PRNTN4:			LD      A,CR
040E25 CD A2 43 04 0601*  			CALL    OSBPUT
040E29 18 AC       0602*  			JR      PRNTN1
040E2B             0603*  ;
040E2B 06 02       0604*  PRINT6:			LD      B,2
040E2D 18 27       0605*  			JR      PRINTC
040E2F 01 00 01 00 0606*  PRINT8:			LD      BC,100H
040E33 18 21       0607*  			JR      PRINTC
040E35 21 00 4C 04 0608*  PRINT9:			LD      HL,STAVAR
040E39 AF          0609*  			XOR     A
040E3A BE          0610*  			CP      (HL)
040E3B 28 12       0611*  			JR      Z,PRINT0
040E3D 3A 3D 4D 04 0612*  			LD      A,(COUNT)
040E41 B7          0613*  			OR      A
040E42 28 0B       0614*  			JR      Z,PRINT0
040E44 96          0615*  PRINTA:			SUB     (HL)
040E45 28 08       0616*  			JR      Z,PRINT0
040E47 30 FB       0617*  			JR      NC,PRINTA
040E49 ED 44       0618*  			NEG
040E4B CD 21 18 04 0619*  			CALL    FILL
040E4F 3A 00 4C 04 0620*  PRINT0:			LD      A,(STAVAR)
040E53 4F          0621*  			LD      C,A             ;PRINTS
040E54 06 00       0622*  			LD      B,0             ;PRINTF
040E56 CD AC 17 04 0623*  PRINTC:			CALL    TERMQ
040E5A 28 3F       0624*  			JR      Z,PRINT4
040E5C CB 80       0625*  			RES     0,B
040E5E FD 23       0626*  			INC     IY
040E60 FE 7E       0627*  			CP      '~'
040E62 28 C7       0628*  			JR      Z,PRINT6
040E64 FE 3B       0629*  			CP      ';'
040E66 28 C7       0630*  			JR      Z,PRINT8
040E68 FE 2C       0631*  			CP      ','
040E6A 28 C9       0632*  			JR      Z,PRINT9
040E6C CD D1 17 04 0633*  			CALL    FORMAT          ;SPC, TAB, '
040E70 28 E4       0634*  			JR      Z,PRINTC
040E72 FD 2B       0635*  			DEC     IY
040E74 C5          0636*  			PUSH    BC
040E75 CD C7 01 04 0637*  			CALL    EXPR            ;VARIABLE TYPE
040E79 08          0638*  			EX      AF,AF'
040E7A FA 94 0E 04 0639*  			JP      M,PRINT3        ;STRING
040E7E D1          0640*  			POP     DE
040E7F D5          0641*  			PUSH    DE
040E80 CB 4A       0642*  			BIT     1,D
040E82 F5          0643*  			PUSH    AF
040E83 CC 6B 09 04 0644*  			CALL    Z,STR           ;DECIMAL
040E87 F1          0645*  			POP     AF
040E88 C4 1F 09 04 0646*  			CALL    NZ,HEXSTR       ;HEX
040E8C C1          0647*  			POP     BC
040E8D C5          0648*  			PUSH    BC
040E8E 79          0649*  			LD      A,C
040E8F 93          0650*  			SUB     E
040E90 D4 21 18 04 0651*  			CALL    NC,FILL         ;RIGHT JUSTIFY
040E94 C1          0652*  PRINT3:			POP     BC
040E95 CD 30 18 04 0653*  			CALL    PTEXT           ;PRINT
040E99 18 BB       0654*  			JR      PRINTC
040E9B CB 40       0655*  PRINT4:			BIT     0,B
040E9D CC 9D 39 04 0656*  			CALL    Z,CRLF
040EA1 C3 9E 0B 04 0657*  			JP      XEQ
040EA5             0658*  
040EA5             0659*  ; ON ERROR statement [:statement...]
040EA5             0660*  ; ON ERROR OFF
040EA5             0661*  ;
040EA5 FD 23       0662*  ONERR:			INC     IY              ;SKIP "ERROR"
040EA7 21 00 00 00 0663*  			LD      HL,0
040EAB 22 2C 4D 04 0664*  			LD      (ERRTRP),HL
040EAF CD 78 0A 04 0665*  			CALL    NXT
040EB3 FE 87       0666*  			CP      OFF_
040EB5 FD 23       0667*  			INC     IY
040EB7 CA 9E 0B 04 0668*  			JP      Z,XEQ
040EBB FD 2B       0669*  			DEC     IY
040EBD FD 22 2C 4D 0670*  			LD      (ERRTRP),IY
       04          
040EC2 C3 33 0C 04 0671*  			JP      REM_EX
040EC6             0672*  
040EC6             0673*  ; ON expr GOTO line[,line...] [ELSE statement]
040EC6             0674*  ; ON expr GOTO line[,line...] [ELSE line]
040EC6             0675*  ; ON expr GOSUB line[,line...] [ELSE statement]
040EC6             0676*  ; ON expr GOSUB line[,line...] [ELSE line]
040EC6             0677*  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040EC6             0678*  ;
040EC6 FE 85       0679*  ON_EX_:			CP      TERROR
040EC8 28 DB       0680*  			JR      Z,ONERR         ;"ON ERROR"
040ECA CD 0F 03 04 0681*  			CALL    EXPRI
040ECE FD 7E 00    0682*  			LD      A,(IY)
040ED1 FD 23       0683*  			INC     IY
040ED3 1E 2C       0684*  			LD      E,','           ;SEPARATOR
040ED5 FE E5       0685*  			CP      TGOTO
040ED7 28 0B       0686*  			JR      Z,ON1
040ED9 FE E4       0687*  			CP      TGOSUB
040EDB 28 07       0688*  			JR      Z,ON1
040EDD 1E F2       0689*  			LD      E,TPROC
040EDF BB          0690*  			CP      E
040EE0 3E 27       0691*  			LD      A,39
040EE2 20 45       0692*  			JR      NZ,ERROR2_EX       ;"ON syntax"
040EE4 57          0693*  ON1:			LD      D,A
040EE5 D9          0694*  			EXX
040EE6 E5          0695*  			PUSH    HL
040EE7 D9          0696*  			EXX
040EE8 C1          0697*  			POP     BC              ;ON INDEX
040EE9 78          0698*  			LD      A,B
040EEA B4          0699*  			OR      H
040EEB B5          0700*  			OR      L
040EEC 20 2A       0701*  			JR      NZ,ON4          ;OUT OF RANGE
040EEE B1          0702*  			OR      C
040EEF 28 27       0703*  			JR      Z,ON4
040EF1 0D          0704*  			DEC     C
040EF2 28 0E       0705*  			JR      Z,ON3           ;INDEX=1
040EF4 CD AC 17 04 0706*  ON2:			CALL    TERMQ
040EF8 28 1E       0707*  			JR      Z,ON4           ;OUT OF RANGE
040EFA FD 23       0708*  			INC     IY              ;SKIP DELIMITER
040EFC BB          0709*  			CP      E
040EFD 20 F5       0710*  			JR      NZ,ON2
040EFF 0D          0711*  			DEC     C
040F00 20 F2       0712*  			JR      NZ,ON2
040F02 7B          0713*  ON3:			LD      A,E
040F03 FE F2       0714*  			CP      TPROC
040F05 28 26       0715*  			JR      Z,ONPROC
040F07 D5          0716*  			PUSH    DE
040F08 CD 2A 03 04 0717*  			CALL    ITEMI           ;LINE NUMBER
040F0C D1          0718*  			POP     DE
040F0D 7A          0719*  			LD      A,D
040F0E FE E5       0720*  			CP      TGOTO
040F10 28 2D       0721*  			JR      Z,GOTO2
040F12 CD B9 17 04 0722*  			CALL    SPAN            ;SKIP REST OF LIST
040F16 18 3B       0723*  			JR      GOSUB1
040F18             0724*  ;
040F18 FD 7E 00    0725*  ON4:			LD      A,(IY)
040F1B FD 23       0726*  			INC     IY
040F1D FE 8B       0727*  			CP      ELSE_
040F1F CA 53 13 04 0728*  			JP      Z,IF1           ;ELSE CLAUSE
040F23 FE 0D       0729*  			CP      CR
040F25 20 F1       0730*  			JR      NZ,ON4
040F27 3E 28       0731*  			LD      A,40
040F29 C3 B6 37 04 0732*  ERROR2_EX:			JP      ERROR_           ;"ON range"
040F2D             0733*  ;
040F2D 3E EE       0734*  ONPROC:			LD      A,TON
040F2F C3 8C 10 04 0735*  			JP      PROC_EX
040F33             0736*  
040F33             0737*  ; GOTO line
040F33             0738*  ;
040F33 CD 2A 03 04 0739*  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
040F37 CD AC 17 04 0740*  GOTO1:			CALL    TERMQ			; Check for terminator
040F3B C2 9F 0C 04 0741*  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
040F3F D9          0742*  GOTO2:			EXX
040F40 CD E5 39 04 0743*  			CALL    FINDL			; HL: Line number - Find the line
040F44 E5          0744*  			PUSH    HL			; HL: Address of the line
040F45 FD E1       0745*  			POP     IY			; IY = HL
040F47 CA 9A 0B 04 0746*  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
040F4B 3E 29       0747*  			LD      A,41			; Otherwise throw a "No such line" error
040F4D 18 DA       0748*  			JR      ERROR2_EX
040F4F             0749*  
040F4F             0750*  ; GOSUB line
040F4F             0751*  ; This pushes the following data onto the execution stack
040F4F             0752*  ; - 3 bytes: Current execution address
040F4F             0753*  ; - 3 bytes: Marker (the address of label GOSCHK)
040F4F             0754*  ;
040F4F CD 2A 03 04 0755*  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
040F53 FD E5       0756*  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
040F55 CD 81 16 04 0757*  			CALL    CHECK           	; Check there is enough room
040F59 CD 37 0F 04 0758*  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
040F5D             0759*  GOSCHK:			EQU     $
040F5D             0760*  
040F5D             0761*  ; RETURN
040F5D             0762*  ; This pops the following data off the execution stack as pushed by GOSUB
040F5D             0763*  ; - 3 bytes: Marker (should be the address of label GOSCHK)
040F5D             0764*  ; - 3 bytes: The return execution address
040F5D             0765*  ;
040F5D D1          0766*  RETURN:			POP     DE			; Pop the marker off the execution stack
040F5E 21 5D 0F 04 0767*  			LD      HL,GOSCHK		; Compare with GOSCHK
040F62 B7          0768*  			OR      A
040F63 ED 52       0769*  			SBC     HL,DE
040F65 FD E1       0770*  			POP     IY			; Pop the return address off the execution stack
040F67 CA 9E 0B 04 0771*  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
040F6B 3E 26       0772*  			LD      A,38			; Otherwise throw a "No GOSUB" error
040F6D 18 BA       0773*  			JR      ERROR2_EX
040F6F             0774*  
040F6F             0775*  ; REPEAT
040F6F             0776*  ; This pushes the following data onto the execution stack
040F6F             0777*  ; - 3 bytes: Current execution address
040F6F             0778*  ; - 3 bytes: Marker (the address of label REPCHK)
040F6F             0779*  ;
040F6F FD E5       0780*  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
040F71 CD 81 16 04 0781*  			CALL    CHECK			; Check if there is enough room
040F75 CD 9E 0B 04 0782*  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
040F79             0783*  REPCHK:			EQU     $
040F79             0784*  
040F79             0785*  ; UNTIL expr
040F79             0786*  ; This pops the following data off the execution stack
040F79             0787*  ; - 3 bytes: Marker (should be the address of label REPCHK)
040F79             0788*  ; - 3 bytes: The address of the REPEAT instruction
040F79             0789*  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
040F79             0790*  ;
040F79 C1          0791*  UNTIL_EX:			POP     BC			; Fetch the marker
040F7A C5          0792*  			PUSH    BC			; And push it back onto the execution stack
040F7B 21 79 0F 04 0793*  			LD      HL,REPCHK		; Compare with REPCHK
040F7F B7          0794*  			OR      A
040F80 ED 42       0795*  			SBC     HL,BC
040F82 3E 2B       0796*  			LD      A,43
040F84 20 A3       0797*  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
040F86 CD 0F 03 04 0798*  			CALL    EXPRI			; Fetch the expression
040F8A CD E4 08 04 0799*  			CALL    TEST			; Test if the expression evaluates to zero
040F8E C1          0800*  			POP     BC			; Pop the marker
040F8F D1          0801*  			POP     DE			; Pop the address of the REPEAT instruction
040F90 20 05       0802*  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
040F92 D5          0803*  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
040F93 C5          0804*  			PUSH    BC			; Push the marker back on the stack
040F94 D5          0805*  			PUSH    DE			; IY = DE
040F95 FD E1       0806*  			POP     IY			; This sets the execution address back to the REPEAT instruction
040F97 C3 9E 0B 04 0807*  XEQ2:			JP      XEQ			; Continue execution
040F9B             0808*  
040F9B             0809*  ; FOR var = expr TO expr [STEP expr]
040F9B             0810*  ; This pushes the following data onto the execution stack
040F9B             0811*  ; - 3 bytes: The limit value
040F9B             0812*  ; - 3 bytes: The step value
040F9B             0813*  ; - 3 bytes: The current execution address
040F9B             0814*  ; - 3 bytes: The address of the loop variable
040F9B             0815*  ; - 3 bytes: Marker (the address of FORCHK)
040F9B             0816*  ;
040F9B 3E 22       0817*  FORVAR:			LD      A,34
040F9D 18 8A       0818*  			JR      ERROR2_EX          	; Throw "FOR variable" error
040F9F             0819*  ;
040F9F CD F0 15 04 0820*  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
040FA3 20 F6       0821*  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040FA5 F5          0822*  			PUSH    AF              	; Save the variable type
040FA6 FD 7E 00    0823*  			LD      A,(IY)			; Check the next token
040FA9 FE B8       0824*  			CP      TO			; Compare with the token value for "TO"
040FAB 3E 24       0825*  			LD      A,36			; Set the error code to 36 ("No TO")
040FAD C2 29 0F 04 0826*  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
040FB1 FD 23       0827*  			INC     IY			; Skip to the next token
040FB3             0828*  ;
040FB3 DD E5       0829*  			PUSH    IX
040FB5 CD 07 03 04 0830*  			CALL    EXPRN           	; Fetch the LIMIT expression value
040FB9 DD E1       0831*  			POP     IX
040FBB F1          0832*  			POP     AF
040FBC 47          0833*  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
040FBD C5          0834*  			PUSH    BC              	; Stack the LIMIT value
040FBE E5          0835*  			PUSH    HL
040FBF 21 00 00 00 0836*  			LD      HL,0
040FC3 4C          0837*  			LD      C,H
040FC4 D9          0838*  			EXX
040FC5 E5          0839*  			PUSH    HL
040FC6             0840*  ;
040FC6 21 01 00 00 0841*  			LD      HL,1            	; The preset STEP value is 1
040FCA D9          0842*  			EXX
040FCB FD 7E 00    0843*  			LD      A,(IY)			; Fetch the next token
040FCE FE 88       0844*  			CP      STEP			; Compare with the token value for "STEP"
040FD0 20 0A       0845*  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040FD2             0846*  ;
040FD2 FD 23       0847*  			INC     IY			; Skip past the STEP token
040FD4 DD E5       0848*  			PUSH    IX
040FD6 CD 07 03 04 0849*  			CALL    EXPRN          		; Fetch the STEP expression value
040FDA DD E1       0850*  			POP     IX
040FDC             0851*  ;
040FDC C5          0852*  FOR1:			PUSH    BC			; Stack the STEP value
040FDD E5          0853*  			PUSH    HL
040FDE D9          0854*  			EXX
040FDF E5          0855*  			PUSH    HL
040FE0 D9          0856*  			EXX
040FE1             0857*  ;
040FE1 FD E5       0858*  			PUSH    IY              	; Stack the current execution address
040FE3 DD E5       0859*  			PUSH    IX              	; Stack the loop variable
040FE5 CD 81 16 04 0860*  			CALL    CHECK
040FE9 CD 9E 0B 04 0861*  			CALL    XEQ
040FED             0862*  FORCHK:			EQU     $
040FED             0863*  
040FED             0864*  ; NEXT [var[,var...]]
040FED             0865*  ; This pops the following data off the execution stack
040FED             0866*  ; - 3 bytes: Marker (the address of FORCHK)
040FED             0867*  ; - 3 bytes: The address of the loop variable
040FED             0868*  ; - 3 bytes: The current execution address
040FED             0869*  ; - 3 bytes: The step value
040FED             0870*  ; - 3 bytes: The limit value
040FED             0871*  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
040FED             0872*  ;
040FED C1          0873*  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
040FEE 21 ED 0F 04 0874*  			LD      HL,FORCHK		; Compare with FORCHK
040FF2 B7          0875*  			OR      A
040FF3 ED 42       0876*  			SBC     HL,BC
040FF5 3E 20       0877*  			LD      A,32
040FF7 C2 83 10 04 0878*  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
040FFB CD AC 17 04 0879*  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
040FFF E1          0880*  			POP     HL			; Pop the address of the loop variable off the execution stack
041000 E5          0881*  			PUSH    HL			; Push it back onto the execution stack
041001 C5          0882*  			PUSH    BC			; Push the marker back onto the execution stack
041002 E5          0883*  			PUSH    HL			; HL: Address of the loop variable off the stack
041003 C4 90 3A 04 0884*  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041007 D1          0885*  			POP     DE			; DE: Address of the loop variable off the stack
041008 EB          0886*  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041009 B7          0887*  			OR      A
04100A ED 52       0888*  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
04100C 20 61       0889*  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
04100E D5          0890*  			PUSH    DE
04100F DD 21 0C 00 0891*  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
041014 DD 39       0892*  			ADD     IX,SP
041016 CD 19 2A 04 0893*  			CALL    DLOAD5_SPL      	; Load the STEP value
04101A DD 7E 10    0894*  			LD      A,(IX+16)       	; Get the STEP type
04101D DD E1       0895*  			POP     IX
04101F CD 1B 04 04 0896*  			CALL    LOADN           	; Load the LOOP variable
041023 CB 7A       0897*  			BIT     7,D             	; Check the sign
041025 F5          0898*  			PUSH    AF
041026 3E 0B       0899*  			LD      A,'+' & 0FH
041028 CD A2 20 04 0900*  			CALL    FPP             	; Add the STEP
04102C 38 55       0901*  			JR      C,ERROR3_EX
04102E F1          0902*  			POP     AF              	; Restore TYPE
04102F F5          0903*  			PUSH    AF
041030 CD 08 16 04 0904*  			CALL    STORE           	; Update the variable
041034 DD 21 15 00 0905*  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041039 DD 39       0906*  			ADD     IX,SP
04103B CD 19 2A 04 0907*  			CALL    DLOAD5_SPL      	; Load the LIMIT value
04103F F1          0908*  			POP     AF
041040 CC DC 08 04 0909*  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
041044             0910*  			; LD      A,0+('<'-4) & 0FH
041044 3E 08       0911*  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041046 CD A2 20 04 0912*  			CALL    FPP             	; Test against the limit
04104A 38 37       0913*  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
04104C 24          0914*  			INC     H
04104D 20 14       0915*  			JR      NZ,LOOP_        	; Keep looping
04104F 21 1B 00 00 0916*  			LD      HL,27			; Adjust the stack
041053 39          0917*  			ADD     HL,SP
041054 F9          0918*  			LD      SP,HL
041055 CD 78 0A 04 0919*  			CALL    NXT
041059 FE 2C       0920*  			CP      ','			; Check for multiple variables
04105B C2 9E 0B 04 0921*  			JP      NZ,XEQ			; No, so we are done at ths point
04105F FD 23       0922*  			INC     IY			; Increment to the next variable
041061 18 8A       0923*  			JR      NEXT_EX			; And continue
041063             0924*  ;
041063 C1          0925*  LOOP_:			POP     BC
041064 D1          0926*  			POP     DE
041065 FD E1       0927*  			POP     IY
041067 FD E5       0928*  			PUSH    IY
041069 D5          0929*  			PUSH    DE
04106A C5          0930*  			PUSH    BC
04106B C3 9E 0B 04 0931*  			JP      XEQ
04106F             0932*  ;
04106F 21 1B 00 00 0933*  NEXT1:			LD      HL,27			; TODO: What does this do?
041073 39          0934*  			ADD     HL,SP
041074 F9          0935*  			LD      SP,HL			; Adjust the stack
041075 C1          0936*  			POP     BC
041076 21 ED 0F 04 0937*  			LD      HL,FORCHK
04107A ED 42       0938*  			SBC     HL,BC
04107C E1          0939*  			POP     HL              	; Variable pointer
04107D E5          0940*  			PUSH    HL
04107E C5          0941*  			PUSH    BC
04107F 28 89       0942*  			JR      Z,NEXT0
041081             0943*  ;
041081 3E 21       0944*  			LD      A,33
041083 C3 B6 37 04 0945*  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041087             0946*  
041087             0947*  ; FNname
041087             0948*  ; N.B. ENTERED WITH A <> TON
041087             0949*  ;
041087 F5          0950*  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041088 CD 91 10 04 0951*  			CALL    PROC1
04108C             0952*  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
04108C             0953*  
04108C             0954*  ; PROCname
04108C             0955*  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
04108C             0956*  ; This pushes the following data onto the execution stack
04108C             0957*  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
04108C             0958*  ; - 3 bytes: Marker (the address of PROCHK)
04108C             0959*  ;
04108C F5          0960*  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
04108D CD 91 10 04 0961*  			CALL    PROC1			; and is also space reserved on the stack for the return address
041091             0962*  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041091             0963*  ;
041091 CD 81 16 04 0964*  PROC1:			CALL    CHECK			; Check there is space for this
041095 FD 2B       0965*  			DEC     IY			; Decrement IY to the PROC token
041097 FD E5       0966*  			PUSH    IY			; Stack the pointer
041099 CD 51 3B 04 0967*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
04109D C1          0968*  			POP     BC			; BC = IY
04109E 28 41       0969*  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0410A0 3E 1E       0970*  			LD      A,30
0410A2 38 DF       0971*  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0410A4             0972*  ;
0410A4             0973*  ; At this point the PROC/FN has not yet been registered in the dynamic area
0410A4             0974*  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0410A4             0975*  ;
0410A4 C5          0976*  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0410A5 2A 14 4D 04 0977*  			LD      HL,(PAGE_)		; HL: Start of program memory
0410A9             0978*  ;
0410A9 3E DD       0979*  PROC2:			LD      A,DEF_			;  A: The token to search for
0410AB CD 80 18 04 0980*  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0410AF 38 26       0981*  			JR      C,PROC3			; Not found, so jump to PROC3
0410B1 E5          0982*  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0410B2 FD E1       0983*  			POP     IY			; IY = HL
0410B4 FD 23       0984*  			INC     IY              	; Skip the DEF token
0410B6 CD 78 0A 04 0985*  			CALL    NXT			; And any whitespace
0410BA CD 51 3B 04 0986*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410BE FD E5       0987*  			PUSH    IY
0410C0 D1          0988*  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0410C1 38 09       0989*  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0410C3 C4 04 3C 04 0990*  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0410C7 FD E5       0991*  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0410C9 D1          0992*  			POP     DE			; DE = IY
0410CA ED 1F       0993*  			LD	(HL),DE			; Save address
0410CC             0994*  ;
0410CC EB          0995*  PROC6:			EX      DE,HL			; HL: Address of the procedure
0410CD 3E 0D       0996*  			LD      A,CR			; The character to search for
0410CF 01 00 01 00 0997*  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0410D3 ED B1       0998*  			CPIR                    	; Skip to next line
0410D5 18 D2       0999*  			JR      PROC2			; Rinse, lather and repeat
0410D7             1000*  ;
0410D7             1001*  ; At this point a DEF has not been found for the PROC/FN
0410D7             1002*  ;
0410D7 FD E1       1003*  PROC3:			POP     IY              	; Restore the execution address
0410D9 CD 51 3B 04 1004*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0410DD 3E 1D       1005*  			LD      A,29
0410DF 20 A2       1006*  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0410E1             1007*  ;
0410E1             1008*  ; At this point we have a PROC/FN entry in the dynamic area
0410E1             1009*  ;
0410E1 ED 17       1010*  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0410E3 21 03 00 00 1011*  			LD	HL,3
0410E7 39          1012*  			ADD     HL,SP
0410E8 CD 78 0A 04 1013*  			CALL    NXT             	; Allow space before "("
0410EC D5          1014*  			PUSH    DE              	; Exchange DE and IY
0410ED FD E3       1015*  			EX      (SP),IY
0410EF FE 28       1016*  			CP      '('             	; Arguments?
0410F1 D1          1017*  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0410F2 20 20       1018*  			JR      NZ,PROC5
0410F4 CD 78 0A 04 1019*  			CALL    NXT             	; Allow space before "("
0410F8 FE 28       1020*  			CP      '('
0410FA C2 9F 0C 04 1021*  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0410FE FD E5       1022*  			PUSH    IY
041100 C1          1023*  			POP     BC              	; Save IY in BC
041101 D9          1024*  			EXX
041102 CD 2C 17 04 1025*  			CALL    SAVLOC          	; Save local parameters
041106 CD 37 0A 04 1026*  			CALL    BRAKET          	; Closing bracket
04110A D9          1027*  			EXX
04110B C5          1028*  			PUSH    BC
04110C FD E1       1029*  			POP     IY              	; Restore IY
04110E E5          1030*  			PUSH    HL
04110F CD A8 16 04 1031*  			CALL    ARGUE           	; Transfer arguments
041113 E1          1032*  			POP     HL
041114             1033*  ;
041114 23          1034*  PROC5:			INC	HL			; Increment to the ON PROC flag address
041115 7E          1035*  			LD	A, (HL)			; And fetch the value
041116 2B          1036*  			DEC 	HL
041117 ED 1F       1037*  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041119 FE EE       1038*  			CP	TON			; Was it "ON PROC"?
04111B C2 9E 0B 04 1039*  			JP	NZ, XEQ			; No, so back to XEQ
04111F D5          1040*  			PUSH    DE			; Exchange DE and IY
041120 FD E3       1041*  			EX      (SP),IY
041122 CD B9 17 04 1042*  			CALL    SPAN            	; Skip rest of ON list
041126 FD E3       1043*  			EX      (SP),IY			; Exchange DE and IY
041128 D1          1044*  			POP     DE
041129 ED 1F       1045*  			LD	(HL), DE		; Save the return address
04112B C3 9E 0B 04 1046*  			JP      XEQ
04112F             1047*  
04112F             1048*  ; LOCAL var[,var...]
04112F             1049*  ;
04112F C1          1050*  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041130 C5          1051*  			PUSH    BC
041131 21 8C 10 04 1052*  			LD      HL,FNCHK		; Check if we are in a FN
041135 B7          1053*  			OR      A
041136 ED 42       1054*  			SBC     HL,BC
041138 28 16       1055*  			JR      Z,LOCAL1		; Yes, so all good, we can use local
04113A 21 91 10 04 1056*  			LD      HL,PROCHK		; Now check if we are in a PROC
04113E B7          1057*  			OR      A
04113F ED 42       1058*  			SBC     HL,BC
041141 28 0D       1059*  			JR      Z,LOCAL1		; Again, all good, we can use local
041143 21 8A 17 04 1060*  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041147 B7          1061*  			OR      A
041148 ED 42       1062*  			SBC     HL,BC			; If it is not present, then
04114A 3E 0C       1063*  			LD      A,12
04114C C2 B6 37 04 1064*  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041150             1065*  ;
041150             1066*  ; At this point we are adding a local variable into a PROC or FN
041150             1067*  ;
041150 FD E5       1068*  LOCAL1:			PUSH    IY			; IY: BASIC pointer
041152 C1          1069*  			POP     BC			; BC: Copy of the BASIC pointer
041153 D9          1070*  			EXX
041154 FD 2B       1071*  			DEC     IY
041156 CD 2C 17 04 1072*  			CALL    SAVLOC
04115A D9          1073*  			EXX
04115B C5          1074*  			PUSH    BC
04115C FD E1       1075*  			POP     IY
04115E             1076*  ;
04115E CD 90 3A 04 1077*  LOCAL2:			CALL    GETVAR			; Get the variable location
041162 C2 9F 0C 04 1078*  			JP      NZ,SYNTAX
041166 B7          1079*  			OR      A               	; Check the variable type (80h = string)
041167 08          1080*  			EX      AF,AF'
041168 CD 98 09 04 1081*  			CALL    ZERO			; Zero the variable anyway
04116C 08          1082*  			EX      AF,AF'
04116D F5          1083*  			PUSH    AF
04116E F4 08 16 04 1084*  			CALL    P,STORE         	; Call STORE if it is not a string
041172 F1          1085*  			POP     AF
041173 59          1086*  			LD      E,C
041174 FC 36 16 04 1087*  			CALL    M,STORES		; Call STORES if it is a string
041178 CD 78 0A 04 1088*  			CALL    NXT			; Skip to the next character in the expression
04117C FE 2C       1089*  			CP      ','			; Is it a comma?
04117E C2 9E 0B 04 1090*  			JP      NZ,XEQ			; No, so we're done, carry on executing
041182 FD 23       1091*  			INC     IY			; Yes, so skip the comma
041184 CD 78 0A 04 1092*  			CALL    NXT			; And any whitespace
041188 18 D4       1093*  			JR      LOCAL2			; Then loop back and handle any further local variables
04118A             1094*  
04118A             1095*  ; ENDPROC
04118A             1096*  ;
04118A C1          1097*  ENDPRO:			POP     BC			; Pop the check value off the stack
04118B 21 8A 17 04 1098*  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
04118F B7          1099*  			OR      A
041190 ED 42       1100*  			SBC     HL,BC
041192 28 13       1101*  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041194             1102*  ;
041194 21 91 10 04 1103*  			LD      HL,PROCHK       	; Check if it is the PROC marker
041198 B7          1104*  			OR      A
041199 ED 42       1105*  			SBC     HL,BC
04119B FD E1       1106*  			POP     IY
04119D CA 9E 0B 04 1107*  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0411A1 3E 0D       1108*  			LD      A,13			; Otherwise throw the "No PROC" error
0411A3 C3 B6 37 04 1109*  			JP      ERROR_
0411A7             1110*  ;
0411A7 DD E1       1111*  UNSTK:			POP     IX			; Unstack a single local variable
0411A9 C1          1112*  			POP     BC
0411AA 78          1113*  			LD      A,B
0411AB B7          1114*  			OR      A
0411AC FA BA 11 04 1115*  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0411B0 E1          1116*  			POP     HL			; Unstack a normal variable
0411B1 D9          1117*  			EXX
0411B2 E1          1118*  			POP     HL
0411B3 D9          1119*  			EXX
0411B4 CD 08 16 04 1120*  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0411B8 18 D0       1121*  			JR      ENDPRO			; And loop back to ENDPRO
0411BA             1122*  ;
0411BA 21 00 00 00 1123*  UNSTK1:			LD      HL,0			; Unstack a string
0411BE 39          1124*  			ADD     HL,SP
0411BF 59          1125*  			LD      E,C
0411C0 CD 36 16 04 1126*  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0411C4 F9          1127*  			LD      SP,HL
0411C5 18 C3       1128*  			JR      ENDPRO
0411C7             1129*  
0411C7             1130*  ; INPUT #channel,var,var...
0411C7             1131*  ;
0411C7 CD C4 18 04 1132*  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0411CB CD 78 0A 04 1133*  INPN1:			CALL    NXT
0411CF FE 2C       1134*  			CP      ','
0411D1 C2 9E 0B 04 1135*  			JP      NZ,XEQ
0411D5 FD 23       1136*  			INC     IY
0411D7 CD 78 0A 04 1137*  			CALL    NXT
0411DB D5          1138*  			PUSH    DE
0411DC CD 96 0C 04 1139*  			CALL    VAR_
0411E0 D1          1140*  			POP     DE
0411E1 F5          1141*  			PUSH    AF              ;SAVE TYPE
0411E2 E5          1142*  			PUSH    HL              ;VARPTR
0411E3 B7          1143*  			OR      A
0411E4 FA 10 12 04 1144*  			JP      M,INPN2         ;STRING
0411E8 CD 9A 43 04 1145*  			CALL    OSBGET
0411EC D9          1146*  			EXX
0411ED 6F          1147*  			LD      L,A
0411EE D9          1148*  			EXX
0411EF CD 9A 43 04 1149*  			CALL    OSBGET
0411F3 D9          1150*  			EXX
0411F4 67          1151*  			LD      H,A
0411F5 D9          1152*  			EXX
0411F6 CD 9A 43 04 1153*  			CALL    OSBGET
0411FA 6F          1154*  			LD      L,A
0411FB CD 9A 43 04 1155*  			CALL    OSBGET
0411FF 67          1156*  			LD      H,A
041200 CD 9A 43 04 1157*  			CALL    OSBGET
041204 4F          1158*  			LD      C,A
041205 DD E1       1159*  			POP     IX
041207 F1          1160*  			POP     AF              ;RESTORE TYPE
041208 D5          1161*  			PUSH    DE              ;SAVE CHANNEL
041209 CD 08 16 04 1162*  			CALL    STORE
04120D D1          1163*  			POP     DE
04120E 18 BB       1164*  			JR      INPN1
041210 21 00 4A 04 1165*  INPN2:			LD      HL,ACCS
041214 CD 9A 43 04 1166*  INPN3:			CALL    OSBGET
041218 FE 0D       1167*  			CP      CR
04121A 28 04       1168*  			JR      Z,INPN4
04121C 77          1169*  			LD      (HL),A
04121D 2C          1170*  			INC     L
04121E 20 F4       1171*  			JR      NZ,INPN3
041220 DD E1       1172*  INPN4:			POP     IX
041222 F1          1173*  			POP     AF
041223 D5          1174*  			PUSH    DE
041224 EB          1175*  			EX      DE,HL
041225 CD 32 16 04 1176*  			CALL    STACCS
041229 D1          1177*  			POP     DE
04122A 18 9F       1178*  			JR      INPN1
04122C             1179*  
04122C             1180*  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             1181*  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04122C             1182*  ;
04122C FE 23       1183*  INPUT:			CP      '#'
04122E 28 97       1184*  			JR      Z,INPUTN
041230 0E 00       1185*  			LD      C,0             ;FLAG PROMPT
041232 FE 86       1186*  			CP      LINE_
041234 20 04       1187*  			JR      NZ,INPUT0
041236 FD 23       1188*  			INC     IY              ;SKIP "LINE"
041238 0E 80       1189*  			LD      C,80H
04123A 21 00 4B 04 1190*  INPUT0:			LD      HL,BUFFER
04123E 36 0D       1191*  			LD      (HL),CR         ;INITIALISE EMPTY
041240 CD AC 17 04 1192*  INPUT1:			CALL    TERMQ
041244 CA 9E 0B 04 1193*  			JP      Z,XEQ           ;DONE
041248 FD 23       1194*  			INC     IY
04124A FE 2C       1195*  			CP      ','
04124C 28 5C       1196*  			JR      Z,INPUT3        ;SKIP COMMA
04124E FE 3B       1197*  			CP      ';'
041250 28 58       1198*  			JR      Z,INPUT3
041252 E5          1199*  			PUSH    HL              ;SAVE BUFFER POINTER
041253 FE 22       1200*  			CP      34		;ASCII ""
041255 20 0C       1201*  			JR      NZ,INPUT6
041257 C5          1202*  			PUSH    BC
041258 CD 6C 04 04 1203*  			CALL    CONS
04125C C1          1204*  			POP     BC
04125D CD 30 18 04 1205*  			CALL    PTEXT           ;PRINT PROMPT
041261 18 06       1206*  			JR      INPUT9
041263 CD D1 17 04 1207*  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041267 20 05       1208*  			JR      NZ,INPUT2
041269 E1          1209*  INPUT9:			POP     HL
04126A CB C1       1210*  			SET     0,C             ;FLAG NO PROMPT
04126C 18 CC       1211*  			JR      INPUT0
04126E FD 2B       1212*  INPUT2:			DEC     IY
041270 C5          1213*  			PUSH    BC
041271 CD 96 0C 04 1214*  			CALL    VAR_
041275 C1          1215*  			POP     BC
041276 E1          1216*  			POP     HL
041277 F5          1217*  			PUSH    AF              ;SAVE TYPE
041278 7E          1218*  			LD      A,(HL)
041279 23          1219*  			INC     HL
04127A FE 0D       1220*  			CP      CR              ;BUFFER EMPTY?
04127C CC AE 12 04 1221*  			CALL    Z,REFILL
041280 CB 79       1222*  			BIT     7,C
041282 F5          1223*  			PUSH    AF
041283 C4 52 18 04 1224*  			CALL    NZ,LINES
041287 F1          1225*  			POP     AF
041288 CC 3F 18 04 1226*  			CALL    Z,FETCHS
04128C F1          1227*  			POP     AF              ;RESTORE TYPE
04128D C5          1228*  			PUSH    BC
04128E E5          1229*  			PUSH    HL
04128F B7          1230*  			OR      A
041290 FA A4 12 04 1231*  			JP      M,INPUT4        ;STRING
041294 F5          1232*  			PUSH    AF
041295 DD E5       1233*  			PUSH    IX
041297 CD 73 06 04 1234*  			CALL    VAL0
04129B DD E1       1235*  			POP     IX
04129D F1          1236*  			POP     AF
04129E CD 08 16 04 1237*  			CALL    STORE
0412A2 18 04       1238*  			JR      INPUT5
0412A4 CD 32 16 04 1239*  INPUT4:			CALL    STACCS
0412A8 E1          1240*  INPUT5:			POP     HL
0412A9 C1          1241*  			POP     BC
0412AA CB 81       1242*  INPUT3:			RES     0,C
0412AC 18 92       1243*  			JR      INPUT1
0412AE             1244*  ;
0412AE CB 41       1245*  REFILL:			BIT     0,C
0412B0 20 0C       1246*  			JR      NZ,REFIL0       ;NO PROMPT
0412B2 3E 3F       1247*  			LD      A,'?'
0412B4 CD A5 39 04 1248*  			CALL    OUTCHR          ;PROMPT
0412B8 3E 20       1249*  			LD      A,' '
0412BA CD A5 39 04 1250*  			CALL    OUTCHR
0412BE 21 00 4B 04 1251*  REFIL0:			LD      HL,BUFFER
0412C2 C5          1252*  			PUSH    BC
0412C3 E5          1253*  			PUSH    HL
0412C4 DD E5       1254*  			PUSH    IX
0412C6 CD B5 3E 04 1255*  			CALL    OSLINE
0412CA DD E1       1256*  			POP     IX
0412CC E1          1257*  			POP     HL
0412CD C1          1258*  			POP     BC
0412CE 47          1259*  			LD      B,A             ;POS AT ENTRY
0412CF AF          1260*  			XOR     A
0412D0 32 3D 4D 04 1261*  			LD      (COUNT),A
0412D4 B8          1262*  			CP      B
0412D5 C8          1263*  			RET     Z
0412D6 7E          1264*  REFIL1:			LD      A,(HL)
0412D7 FE 0D       1265*  			CP      CR
0412D9 C8          1266*  			RET     Z
0412DA 23          1267*  			INC     HL
0412DB 10 F9       1268*  			DJNZ    REFIL1
0412DD C9          1269*  			RET
0412DE             1270*  
0412DE             1271*  ; READ var[,var...]
0412DE             1272*  ;
0412DE FE 23       1273*  READ:			CP      '#'
0412E0 CA C7 11 04 1274*  			JP      Z,INPUTN
0412E4 2A 31 4D 04 1275*  			LD      HL,(DATPTR)
0412E8 7E          1276*  READ0:			LD      A,(HL)
0412E9 23          1277*  			INC     HL              ;SKIP COMMA OR "DATA"
0412EA FE 0D       1278*  			CP      CR              ;END OF DATA STMT?
0412EC CC 30 13 04 1279*  			CALL    Z,GETDAT
0412F0 E5          1280*  			PUSH    HL
0412F1 CD 96 0C 04 1281*  			CALL    VAR_
0412F5 E1          1282*  			POP     HL
0412F6 B7          1283*  			OR      A
0412F7 FA 10 13 04 1284*  			JP      M,READ1         ;STRING
0412FB E5          1285*  			PUSH    HL
0412FC FD E3       1286*  			EX      (SP),IY
0412FE F5          1287*  			PUSH    AF              ;SAVE TYPE
0412FF DD E5       1288*  			PUSH    IX
041301 CD 07 03 04 1289*  			CALL    EXPRN
041305 DD E1       1290*  			POP     IX
041307 F1          1291*  			POP     AF
041308 CD 08 16 04 1292*  			CALL    STORE
04130C FD E3       1293*  			EX      (SP),IY
04130E 18 09       1294*  			JR      READ2
041310 CD 3F 18 04 1295*  READ1:			CALL    FETCHS
041314 E5          1296*  			PUSH    HL
041315 CD 32 16 04 1297*  			CALL    STACCS
041319 E1          1298*  READ2:			POP     HL
04131A 22 31 4D 04 1299*  			LD      (DATPTR),HL
04131E CD 78 0A 04 1300*  			CALL    NXT
041322 FE 2C       1301*  			CP      ','
041324 C2 9E 0B 04 1302*  			JP      NZ,XEQ
041328 FD 23       1303*  			INC     IY
04132A CD 78 0A 04 1304*  			CALL    NXT
04132E 18 B8       1305*  			JR      READ0
041330             1306*  ;
041330 3E DC       1307*  GETDAT:			LD      A,DATA_
041332 CD 80 18 04 1308*  			CALL    SEARCH_EX
041336 23          1309*  			INC     HL
041337 D0          1310*  			RET     NC
041338 3E 2A       1311*  			LD      A,42
04133A C3 B6 37 04 1312*  ERROR4:			JP      ERROR_           ;"Out of DATA"
04133E             1313*  
04133E             1314*  ; IF expr statement
04133E             1315*  ; IF expr THEN statement [ELSE statement]
04133E             1316*  ; IF expr THEN line [ELSE line]
04133E             1317*  ;
04133E CD 0F 03 04 1318*  IF_:			CALL    EXPRI
041342 CD E4 08 04 1319*  			CALL    TEST
041346 28 19       1320*  			JR      Z,IFNOT         ;FALSE
041348 FD 7E 00    1321*  			LD      A,(IY)
04134B FE 8C       1322*  			CP      THEN
04134D C2 9E 0B 04 1323*  			JP      NZ,XEQ
041351 FD 23       1324*  			INC     IY              ;SKIP "THEN"
041353 CD 78 0A 04 1325*  IF1:			CALL    NXT
041357 FE 8D       1326*  			CP      LINO
041359 C2 9E 0B 04 1327*  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
04135D C3 33 0F 04 1328*  			JP      GOTO_EX            ;LINE NO. FOLLOWS
041361 FD 7E 00    1329*  IFNOT:			LD      A,(IY)
041364 FE 0D       1330*  			CP      CR
041366 FD 23       1331*  			INC     IY
041368 CA 9A 0B 04 1332*  			JP      Z,XEQ0          ;END OF LINE
04136C FE 8B       1333*  			CP      ELSE_
04136E 20 F1       1334*  			JR      NZ,IFNOT
041370 18 E1       1335*  			JR      IF1
041372             1336*  
041372             1337*  ; CLS
041372             1338*  ;
041372 CD 28 44 04 1339*  CLS:		CALL    CLRSCN
041376 AF          1340*  			XOR     A
041377 32 3D 4D 04 1341*  			LD      (COUNT),A
04137B C3 9E 0B 04 1342*  			JP      XEQ
04137F             1343*  
04137F             1344*  ; STOP
04137F             1345*  ;
04137F CD E6 3D 04 1346*  STOP:			CALL    TELL
041383 0D          1347*  			DB	CR
041384 0A          1348*  			DB	LF
041385 FA          1349*  			DB	TSTOP
041386 00          1350*  			DB	0
041387 CD 04 3A 04 1351*  			CALL    SETLIN          ;FIND CURRENT LINE
04138B CD 38 3A 04 1352*  			CALL    SAYLN
04138F CD 9D 39 04 1353*  			CALL    CRLF
041393 C3 D6 30 04 1354*  			JP      CLOOP
041397             1355*  
041397             1356*  ; REPORT
041397             1357*  ;
041397 CD D8 3D 04 1358*  REPOR:			CALL    REPORT
04139B C3 9E 0B 04 1359*  			JP      XEQ
04139F             1360*  
04139F             1361*  ; CLEAR
04139F             1362*  ;
04139F CD CC 38 04 1363*  CLR:			CALL    CLEAR
0413A3 2A 14 4D 04 1364*  			LD      HL,(PAGE_)
0413A7 18 19       1365*  			JR      RESTR1
0413A9             1366*  
0413A9             1367*  ; RESTORE [line]
0413A9             1368*  ;
0413A9 2A 14 4D 04 1369*  RESTOR_EX:			LD      HL,(PAGE_)
0413AD CD AC 17 04 1370*  			CALL    TERMQ
0413B1 28 0F       1371*  			JR      Z,RESTR1
0413B3 CD 2A 03 04 1372*  			CALL    ITEMI
0413B7 D9          1373*  			EXX
0413B8 CD E5 39 04 1374*  			CALL    FINDL           ;SEARCH FOR LINE
0413BC 3E 29       1375*  			LD      A,41
0413BE C2 3A 13 04 1376*  			JP      NZ,ERROR4       ;"No such line"
0413C2 3E DC       1377*  RESTR1:			LD      A,DATA_
0413C4 CD 80 18 04 1378*  			CALL    SEARCH_EX
0413C8 22 31 4D 04 1379*  			LD      (DATPTR),HL
0413CC C3 9E 0B 04 1380*  			JP      XEQ
0413D0             1381*  
0413D0             1382*  ; PTR#channel=expr
0413D0             1383*  ; PAGE=expr
0413D0             1384*  ; TIME=expr
0413D0             1385*  ; LOMEM=expr
0413D0             1386*  ; HIMEM=expr
0413D0             1387*  ;
0413D0 CD B8 18 04 1388*  PTR_EX:			CALL    CHANEL
0413D4 CD C2 17 04 1389*  			CALL    EQUALS
0413D8 7B          1390*  			LD      A,E
0413D9 F5          1391*  			PUSH    AF
0413DA CD 0F 03 04 1392*  			CALL    EXPRI
0413DE E5          1393*  			PUSH    HL
0413DF D9          1394*  			EXX
0413E0 D1          1395*  			POP     DE
0413E1 F1          1396*  			POP     AF
0413E2 CD CE 43 04 1397*  			CALL    PUTPTR
0413E6 C3 9E 0B 04 1398*  			JP      XEQ
0413EA             1399*  ;
0413EA CD C2 17 04 1400*  PAGEV_EX:			CALL    EQUALS
0413EE CD 0F 03 04 1401*  			CALL    EXPRI
0413F2 D9          1402*  			EXX
0413F3 2E 00       1403*  			LD      L,0
0413F5 22 14 4D 04 1404*  			LD      (PAGE_),HL
0413F9 C3 9E 0B 04 1405*  			JP      XEQ
0413FD             1406*  ;
0413FD FE 24       1407*  TIMEV_EX:			CP      '$'
0413FF 28 13       1408*  			JR      Z,TIMEVS_EX
041401 CD C2 17 04 1409*  			CALL    EQUALS
041405 CD 0F 03 04 1410*  			CALL    EXPRI
041409 E5          1411*  			PUSH    HL
04140A D9          1412*  			EXX
04140B D1          1413*  			POP     DE
04140C CD ED 3E 04 1414*  			CALL    PUTIME
041410 C3 9E 0B 04 1415*  			JP      XEQ
041414             1416*  ;
041414 FD 23       1417*  TIMEVS_EX:			INC     IY              ;SKIP '$'
041416 CD C2 17 04 1418*  			CALL    EQUALS
04141A CD 1A 03 04 1419*  			CALL    EXPRS
04141E CD A2 49 04 1420*  			CALL    PUTIMS
041422 C3 9E 0B 04 1421*  			JP      XEQ
041426             1422*  ;
041426 CD C2 17 04 1423*  LOMEMV_EX:			CALL    EQUALS
04142A CD 0F 03 04 1424*  			CALL    EXPRI
04142E CD CC 38 04 1425*  			CALL    CLEAR
041432 D9          1426*  			EXX
041433 22 1A 4D 04 1427*  			LD      (LOMEM),HL
041437 22 1D 4D 04 1428*  			LD      (FREE),HL
04143B C3 9E 0B 04 1429*  			JP      XEQ
04143F             1430*  ;
04143F CD C2 17 04 1431*  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
041443 CD 0F 03 04 1432*  			CALL    EXPRI			; Load the expression into registers
041447 7D          1433*  			LD	A,L			;  A: The MSB of the 24-bit value
041448 D9          1434*  			EXX				; HL: The LSW of the 24-bit value
041449 22 4A 4D 04 1435*  			LD	(R0),HL
04144D 32 4C 4D 04 1436*  			LD	(R0+2),A
041451 2A 1D 4D 04 1437*  			LD	HL,(FREE)
041455 11 00 01 00 1438*  			LD      DE,256
041459 19          1439*  			ADD	HL,DE
04145A EB          1440*  			EX	DE,HL			; DE: FREE + 256
04145B 2A 4A 4D 04 1441*  			LD	HL,(R0)			; HL: The passed expression
04145F AF          1442*  			XOR     A
041460 ED 52       1443*  			SBC     HL,DE
041462 19          1444*  			ADD     HL,DE			; Do a bounds check
041463 DA B6 37 04 1445*  			JP      C,ERROR_         	; Throw the error: "No room"
041467 ED 5B 20 4D 1446*  			LD      DE,(HIMEM)
       04          
04146C 22 20 4D 04 1447*  			LD      (HIMEM),HL
041470 EB          1448*  			EX      DE,HL
041471 ED 72       1449*  			SBC     HL,SP			; Adjust the stack
041473 C2 9E 0B 04 1450*  			JP      NZ,XEQ
041477 EB          1451*  			EX      DE,HL
041478 F9          1452*  			LD      SP,HL           	; Load the SP
041479 C3 9E 0B 04 1453*  			JP      XEQ
04147D             1454*  
04147D             1455*  ; WIDTH expr
04147D             1456*  ;
04147D CD 0F 03 04 1457*  WIDTHV:			CALL    EXPRI
041481 D9          1458*  			EXX
041482 7D          1459*  			LD      A,L
041483 32 3E 4D 04 1460*  			LD      (WIDTH),A
041487 C3 9E 0B 04 1461*  			JP      XEQ
04148B             1462*  
04148B             1463*  ; TRACE ON
04148B             1464*  ; TRACE OFF
04148B             1465*  ; TRACE line
04148B             1466*  ;
04148B FD 23       1467*  TRACE_EX:			INC     IY
04148D 21 00 00 00 1468*  			LD      HL,0
041491 FE EE       1469*  			CP      TON
041493 28 0B       1470*  			JR      Z,TRACE0
041495 FE 87       1471*  			CP      OFF_
041497 28 08       1472*  			JR      Z,TRACE1
041499 FD 2B       1473*  			DEC     IY
04149B CD 0F 03 04 1474*  			CALL    EXPRI
04149F D9          1475*  			EXX
0414A0 2B          1476*  TRACE0:			DEC     HL
0414A1 22 26 4D 04 1477*  TRACE1:			LD      (TRACEN),HL
0414A5 C3 9E 0B 04 1478*  			JP      XEQ
0414A9             1479*  
0414A9             1480*  ; VDU expr,expr;....
0414A9             1481*  ;
0414A9 DD 21 00 4B 1482*  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0414AE DD E5       1483*  VDU1:			PUSH	IX
0414B0 CD 0F 03 04 1484*  			CALL    EXPRI			; Fetch the VDU character
0414B4 DD E1       1485*  			POP	IX
0414B6 D9          1486*  			EXX
0414B7 DD 75 00    1487*  			LD	(IX+0),L		; Write out the character to the buffer
0414BA DD 23       1488*  			INC	IX
0414BC FD 7E 00    1489*  			LD      A,(IY)			;  A: The separator character
0414BF FE 2C       1490*  			CP      ','			; Is it a comma?
0414C1 28 09       1491*  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0414C3 FE 3B       1492*  			CP      ';'			; Is it a semicolon?
0414C5 20 07       1493*  			JR      NZ,VDU3			; No, so skip to the next expression
0414C7 DD 74 00    1494*  			LD	(IX+0),H		; Write out the high byte to the buffer
0414CA DD 23       1495*  			INC	IX
0414CC FD 23       1496*  VDU2:			INC     IY			; Skip to the next character
0414CE CD AC 17 04 1497*  VDU3:			CALL    TERMQ			; Skip past white space
0414D2 20 DA       1498*  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0414D4 DD 7D       1499*  			LD	A,IXL			;  A: Number of bytes to write out
0414D6 B7          1500*  			OR	A
0414D7 28 0B       1501*  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0414D9 21 00 4B 04 1502*  			LD	HL,BUFFER		; HL: Start of stream
0414DD 01 00 00 00 1503*  			LD	BC,0
0414E1 4F          1504*  			LD	C,A			; BC: Number of bytes to write out
0414E2 5B DF       1505*  			RST.LIL	18h			; Output the buffer to MOS
0414E4 C3 9E 0B 04 1506*  VDU4:			JP      XEQ
0414E8             1507*  
0414E8             1508*  ; CLOSE channel number
0414E8             1509*  ;
0414E8 CD B8 18 04 1510*  CLOSE:			CALL    CHANEL			; Fetch the channel number
0414EC CD 92 43 04 1511*  			CALL    OSSHUT			; Close the channel
0414F0 C3 9E 0B 04 1512*  			JP      XEQ
0414F4             1513*  
0414F4             1514*  ; BPUT channel,byte
0414F4             1515*  ;
0414F4 CD B8 18 04 1516*  BPUT:			CALL    CHANEL          	; Fetch the channel number
0414F8 D5          1517*  			PUSH    DE			; DE: Channel number
0414F9 CD 2A 0A 04 1518*  			CALL    COMMA			; Skip to the next expression
0414FD CD 0F 03 04 1519*  			CALL    EXPRI           	; Feth the data
041501 D9          1520*  			EXX
041502 7D          1521*  			LD      A,L			; A: The byte to write
041503 D1          1522*  			POP     DE
041504 CD A2 43 04 1523*  			CALL    OSBPUT			; Write the byte out
041508 C3 9E 0B 04 1524*  			JP      XEQ
04150C             1525*  
04150C             1526*  ; CALL address[,var[,var...]]
04150C             1527*  ;
04150C             1528*  ; Note that the parameter table differs from the Z80 version
04150C             1529*  ; Each entry now takes up 4 bytes, not 3, so the table is now:
04150C             1530*  ;  -1 byte:  Number of parameters
04150C             1531*  ; Then, for each parameter:
04150C             1532*  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
04150C             1533*  ;  -3 bytes: Parameter address
04150C             1534*  ;
04150C             1535*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
04150C             1536*  ;
04150C CD 0F 03 04 1537*  CALL_:			CALL    EXPRI           	; Fetch the address
041510 7D          1538*  			LD	A,L			;  A: MSB of address
041511 D9          1539*  			EXX
041512 22 4A 4D 04 1540*  			LD	(R0+0),HL		; HL: LSW of address
041516 32 4C 4D 04 1541*  			LD	(R0+2),A
04151A 06 00       1542*  			LD      B,0             	;  B: The parameter counter
04151C 11 00 4B 04 1543*  			LD      DE,BUFFER       	; DE: Vector
041520             1544*  ;
041520 CD 78 0A 04 1545*  CALL1:			CALL    NXT			; Skip whitespace
041524 FE 2C       1546*  			CP      ','			; Check for comma
041526 20 1B       1547*  			JR      NZ,CALL2		; If no more parameters, then jump here
041528 FD 23       1548*  			INC     IY			; Skip to the next character
04152A 04          1549*  			INC     B			; Increment the parameter count
04152B CD 78 0A 04 1550*  			CALL    NXT			; Skip whitespace
04152F C5          1551*  			PUSH    BC
041530 D5          1552*  			PUSH    DE
041531 CD 96 0C 04 1553*  			CALL    VAR_
041535 D1          1554*  			POP     DE
041536 C1          1555*  			POP     BC
041537 13          1556*  			INC     DE
041538 12          1557*  			LD      (DE),A			; Save the parameter type
041539 13          1558*  			INC     DE
04153A EB          1559*  			EX      DE,HL
04153B ED 1F       1560*  			LD	(HL),DE			; Save the parameter address (3 bytes)
04153D 23          1561*  			INC	HL
04153E 23          1562*  			INC	HL
04153F 23          1563*  			INC	HL
041540 EB          1564*  			EX      DE,HL
041541 18 DD       1565*  			JR      CALL1
041543             1566*  ;
041543 78          1567*  CALL2:			LD      A,B
041544 32 00 4B 04 1568*  			LD      (BUFFER),A      	; Save the parameter count
041548 2A 4A 4D 04 1569*  			LD	HL,(R0)			; HL: Address of the code
04154C CD 66 15 04 1570*  			CALL    USR1			; And call it
041550 C3 9E 0B 04 1571*  			JP      XEQ
041554             1572*  
041554             1573*  ; USR(address)
041554             1574*  ;
041554 CD 2A 03 04 1575*  USR:			CALL    ITEMI			; Evaluate the expression
041558 7D          1576*  			LD	A,L			;  A: MSB of address
041559 D9          1577*  			EXX
04155A 22 4A 4D 04 1578*  			LD	(R0+0),HL		; HL: LSW of address
04155E 32 4C 4D 04 1579*  			LD	(R0+2),A
041562 2A 4A 4D 04 1580*  			LD	HL,(R0)			; Get the 24-bit address in HL
041566             1581*  ;
041566 E5          1582*  USR1:			PUSH    HL              	; Address on stack
041567 FD E3       1583*  			EX      (SP),IY
041569 24          1584*  			INC     H               	; Check for PAGE &00FFxx
04156A B4          1585*  			OR	H
04156B 21 D5 15 04 1586*  			LD      HL,USR2         	; Return address
04156F E5          1587*  			PUSH    HL
041570 DD 21 00 4C 1588*  			LD      IX,STAVAR
       04          
041575 CC 58 43 04 1589*  			CALL    Z,OSCALL        	; Intercept &00FFxx
041579             1590*  ;
041579 DD 4E 18    1591*  			LD      C, (IX+24)		; F%
04157C C5          1592*  			PUSH    BC
04157D             1593*  ;
04157D DD 7E 08    1594*  			LD	A, (IX+8)		; B% -> MSW
041580 32 4B 4D 04 1595*  			LD	(R0+1), A
041584 DD 7E 09    1596*  			LD	A, (IX+9)
041587 32 4C 4D 04 1597*  			LD	(R0+2), A
04158B DD 7E 0C    1598*  			LD	A, (IX+12)		; C% -> LSB
04158E 32 4A 4D 04 1599*  			LD	(R0+0), A
041592 ED 4B 4A 4D 1600*  			LD	BC, (R0)
       04          
041597             1601*  ;
041597 DD 7E 10    1602*  			LD	A, (IX+16)		; D% -> MSW
04159A 32 4B 4D 04 1603*  			LD	(R0+1), A
04159E DD 7E 11    1604*  			LD	A, (IX+17)
0415A1 32 4C 4D 04 1605*  			LD	(R0+2), A
0415A5 DD 7E 14    1606*  			LD	A, (IX+20)		; E% -> LSB
0415A8 32 4A 4D 04 1607*  			LD	(R0+0), A
0415AC ED 5B 4A 4D 1608*  			LD	DE, (R0)
       04          
0415B1             1609*  ;
0415B1 DD 7E 20    1610*  			LD	A, (IX+32)		; H% -> MSW
0415B4 32 4B 4D 04 1611*  			LD	(R0+1), A
0415B8 DD 7E 21    1612*  			LD	A, (IX+33)
0415BB 32 4C 4D 04 1613*  			LD	(R0+2), A
0415BF DD 7E 30    1614*  			LD	A, (IX+48)		; L% -> LSB
0415C2 32 4A 4D 04 1615*  			LD	(R0+0), A
0415C6 2A 4A 4D 04 1616*  			LD	HL, (R0)
0415CA             1617*  ;
0415CA F1          1618*  			POP     AF			; F%
0415CB DD 7E 04    1619*  			LD      A, (IX+4)        	; A%
0415CE             1620*  
0415CE DD 21 00 4B 1621*  			LD      IX,BUFFER
       04          
0415D3 FD E9       1622*  			JP      (IY)            	; Off to user routine
0415D5             1623*  ;
0415D5 FD E1       1624*  USR2:			POP     IY
0415D7 AF          1625*  			XOR     A
0415D8 4F          1626*  			LD      C,A
0415D9 C9          1627*  			RET
0415DA             1628*  
0415DA             1629*  ; PUT port,data
0415DA             1630*  ;
0415DA CD 0F 03 04 1631*  PUT:			CALL    EXPRI           ;PORT ADDRESS
0415DE D9          1632*  			EXX
0415DF E5          1633*  			PUSH    HL
0415E0 CD 2A 0A 04 1634*  			CALL    COMMA
0415E4 CD 0F 03 04 1635*  			CALL    EXPRI           ;DATA
0415E8 D9          1636*  			EXX
0415E9 C1          1637*  			POP     BC
0415EA ED 69       1638*  			OUT     (C),L           ;OUTPUT TO PORT BC
0415EC C3 9E 0B 04 1639*  			JP      XEQ
0415F0             1640*  
0415F0             1641*  ; SUBROUTINES -----------------------------------------------------------------
0415F0             1642*  
0415F0             1643*  ; ASSIGN - Assign a numeric value to a variable.
0415F0             1644*  ; Outputs: NC,  Z - OK, numeric.
0415F0             1645*  ;          NC, NZ - OK, string.
0415F0             1646*  ;           C, NZ - illegal
0415F0             1647*  ;
0415F0 CD 90 3A 04 1648*  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0415F4 D8          1649*  			RET     C               	; Return with C if it is an illegal variable
0415F5 C4 7F 3A 04 1650*  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0415F9 B7          1651*  			OR      A
0415FA F8          1652*  			RET     M               	; Return if type is string (81h)
0415FB F5          1653*  			PUSH    AF              	; It's a numeric type from this point on
0415FC CD C2 17 04 1654*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041600 E5          1655*  			PUSH    HL
041601 CD 07 03 04 1656*  			CALL    EXPRN
041605 DD E1       1657*  			POP     IX
041607 F1          1658*  			POP     AF
041608 CB 47       1659*  STORE:			BIT     0,A
04160A 28 13       1660*  			JR      Z,STOREI
04160C BF          1661*  			CP      A               	; Set the variable to 0
04160D DD 71 04    1662*  STORE5:			LD      (IX+4),C
041610 D9          1663*  STORE4:			EXX
041611 DD 75 00    1664*  			LD      (IX+0),L
041614 DD 74 01    1665*  			LD      (IX+1),H
041617 D9          1666*  			EXX
041618 DD 75 02    1667*  			LD      (IX+2),L
04161B DD 74 03    1668*  			LD      (IX+3),H
04161E C9          1669*  			RET
04161F F5          1670*  STOREI:			PUSH    AF
041620 0C          1671*  			INC     C               ;SPEED - & PRESERVE F'
041621 0D          1672*  			DEC     C               ; WHEN CALLED BY FNEND0
041622 C4 67 06 04 1673*  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
041626 F1          1674*  			POP     AF
041627 FE 04       1675*  			CP      4
041629 28 E5       1676*  			JR      Z,STORE4
04162B BF          1677*  			CP      A               ;SET ZERO
04162C D9          1678*  STORE1:			EXX
04162D DD 75 00    1679*  			LD      (IX+0),L
041630 D9          1680*  			EXX
041631 C9          1681*  			RET
041632             1682*  ;
041632             1683*  ; Copy a string from the string accumulator to variable storage on the stack
041632             1684*  ; Parameters:
041632             1685*  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041632             1686*  ; - IX: Address of the variable storage on the stack
041632             1687*  ;
041632 21 00 4A 04 1688*  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041636             1689*  ;
041636             1690*  ; Parameters:
041636             1691*  ; As above, but:
041636             1692*  ; - HL: Address of the string to be stored
041636             1693*  ; -  E: The string length
041636             1694*  ; NB:
041636             1695*  ; Strings are mutable
041636             1696*  ; Strings are stored in the following format in the variable:
041636             1697*  ; - Address of the next variable (3 bytes)
041636             1698*  ; - The rest of the variable name - this is zero terminated
041636             1699*  ; - Current string length (byte)
041636             1700*  ; - Maximum (original) string length (byte)
041636             1701*  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041636             1702*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041636             1703*  ;
041636 1F          1704*  STORES:			RRA				; Rotate right to shift bit 0 into carry
041637 30 5D       1705*  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041639 E5          1706*  			PUSH    HL			; Stack ACCS
04163A             1707*  ;
04163A             1708*  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
04163A             1709*  ;
04163A D9          1710*  			EXX				; This block was a call to LOAD4
04163B DD 6E 00    1711*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04163E DD 66 01    1712*  			LD      H,(IX+1)		; The maximum original string length
041641 D9          1713*  			EXX
041642 DD 27 02    1714*  			LD	HL,(IX+2)		; Address of the string (24-bit)
041645             1715*  ;
041645 7B          1716*  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041646 D9          1717*  			EXX
041647 6F          1718*  			LD      L,A			; L': Length of string currently stored on the stack
041648 7C          1719*  			LD      A,H             	; H': The maximum (original) string length
041649 D9          1720*  			EXX
04164A BB          1721*  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
04164B 30 17       1722*  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04164D             1723*  ;
04164D             1724*  ; At this point we're either initialising a new string or assigning more memory to an existing string
04164D             1725*  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04164D             1726*  ; then the existing and new strings may both exist in memory.
04164D             1727*  ;
04164D D9          1728*  			EXX
04164E 65          1729*  			LD      H,L			; H: Set the maximum string length to the string length
04164F D9          1730*  			EXX
041650 E5          1731*  			PUSH    HL
041651 01 00 00 00 1732*  			LD	BC, 0
041655 4F          1733*  			LD      C,A			; BC: The maximum (original) string length
041656 09          1734*  			ADD     HL,BC			; Work out whether this is the last string in memory
041657 ED 4B 1D 4D 1735*  			LD      BC,(FREE)
       04          
04165C ED 42       1736*  			SBC     HL,BC			; Is string last?
04165E E1          1737*  			POP     HL
04165F 37          1738*  			SCF
041660 28 02       1739*  			JR      Z,STORS1
041662             1740*  			; LD	HL, BC			; HL=BC
041662 C5          1741*  			push bc
041663 E1          1742*  			pop hl
041664             1743*  ;
041664             1744*  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041664             1745*  ; - H': The maximum (original) string length
041664             1746*  ; - L': The actual string length (must be less than H')
041664             1747*  ; - HL: Address of the string in memory
041664             1748*  ;
041664 D9          1749*  STORS1:			EXX				; This block was a call to STORE4
041665 DD 75 00    1750*  			LD      (IX+0),L		; The actual string length (must be less then H')
041668 DD 74 01    1751*  			LD      (IX+1),H		; The maximum (original) string length
04166B D9          1752*  			EXX
04166C DD 2F 02    1753*  			LD	(IX+2),HL		; The pointer to the original string
04166F             1754*  ;
04166F 01 00 00 00 1755*  			LD	BC, 0
041673 4B          1756*  			LD      C,E			; BC: The new string length
041674 EB          1757*  			EX      DE,HL
041675 E1          1758*  			POP     HL
041676 0D          1759*  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041677 0C          1760*  			INC     C			; check whether BC is 0 without affecting the carry flag
041678 C8          1761*  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041679 ED B0       1762*  			LDIR				; Replace the string in memory
04167B D0          1763*  			RET     NC
04167C ED 53 1D 4D 1764*  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
041681             1765*  ;
041681             1766*  ; Check whether the stack is full
041681             1767*  ;
041681 E5          1768*  CHECK:			PUSH    HL
041682 C5          1769*  			PUSH	BC
041683 2A 1D 4D 04 1770*  			LD      HL,(FREE)		; HL: Address of first free space byte
041687 01 00 01 00 1771*  			LD	BC,100h			; BC: One page of memory
04168B 09          1772*  			ADD	HL,BC			; Add a page to FREE
04168C ED 72       1773*  			SBC     HL,SP			; And subtract the current SP
04168E C1          1774*  			POP	BC
04168F E1          1775*  			POP     HL
041690 D8          1776*  			RET     C			; The SP is not in the same page, so just return
041691 AF          1777*  			XOR     A			; Otherwise
041692 C3 B6 37 04 1778*  			JP      ERROR_			; Throw error "No room"
041696             1779*  ;
041696 01 00 00 00 1780*  STORS3:			LD	BC,0
04169A 4B          1781*  			LD      C,E			; BC: String length
04169B DD E5       1782*  			PUSH    IX
04169D D1          1783*  			POP     DE			; DE: Destination
04169E AF          1784*  			XOR     A			; Check if string length is 0
04169F B9          1785*  			CP      C
0416A0 28 02       1786*  			JR      Z,STORS5		; Yes, so don't copy
0416A2 ED B0       1787*  			LDIR
0416A4 3E 0D       1788*  STORS5:			LD      A,CR			; Finally add the terminator
0416A6 12          1789*  			LD      (DE),A
0416A7 C9          1790*  			RET
0416A8             1791*  
0416A8             1792*  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0416A8             1793*  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0416A8             1794*  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0416A8             1795*  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0416A8             1796*  ;    Inputs: DE addresses parameter list
0416A8             1797*  ;            IY addresses dummy variable list
0416A8             1798*  ;   Outputs: DE,IY updated
0416A8             1799*  ;  Destroys: Everything
0416A8             1800*  ;
0416A8 3E FF       1801*  ARGUE:			LD      A,-1
0416AA F5          1802*  			PUSH    AF              	; Put marker on the stack
0416AB FD 23       1803*  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0416AD 13          1804*  			INC     DE
0416AE D5          1805*  			PUSH    DE
0416AF CD 78 0A 04 1806*  			CALL    NXT			; Skip any whitespace
0416B3 CD 90 3A 04 1807*  			CALL    GETVAR			; Get the location of the variable in HL/IX
0416B7 38 3F       1808*  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0416B9 C4 7F 3A 04 1809*  			CALL    NZ,PUTVAR
0416BD D1          1810*  			POP     DE
0416BE E5          1811*  			PUSH    HL              	; VARPTR
0416BF B7          1812*  			OR      A               	; Check the variable type
0416C0 F5          1813*  			PUSH    AF
0416C1 D5          1814*  			PUSH    DE
0416C2 FD E3       1815*  			EX      (SP),IY
0416C4 FA DC 16 04 1816*  			JP      M,ARGUE2        	; Jump here if it is a string
0416C8             1817*  ;
0416C8 CD 07 03 04 1818*  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0416CC FD E3       1819*  			EX      (SP),IY
0416CE D1          1820*  			POP     DE
0416CF F1          1821*  			POP     AF
0416D0 D9          1822*  			EXX
0416D1 E5          1823*  			PUSH    HL
0416D2 D9          1824*  			EXX
0416D3 E5          1825*  			PUSH    HL
0416D4 47          1826*  			LD      B,A
0416D5 C5          1827*  			PUSH    BC
0416D6 CD 81 16 04 1828*  			CALL    CHECK           	; Check room
0416DA 18 0F       1829*  			JR      ARGUE4
0416DC             1830*  ;
0416DC CD 1A 03 04 1831*  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0416E0 FD E3       1832*  			EX      (SP),IY
0416E2 D9          1833*  			EXX
0416E3 D1          1834*  			POP     DE
0416E4 D9          1835*  			EXX
0416E5 F1          1836*  			POP     AF
0416E6 CD B9 09 04 1837*  			CALL    PUSHS
0416EA D9          1838*  			EXX
0416EB             1839*  ;
0416EB CD 78 0A 04 1840*  ARGUE4:			CALL    NXT			; Skip whitespace
0416EF FE 2C       1841*  			CP      ','			; Check to see if the next value is a comma
0416F1 20 0B       1842*  			JR      NZ,ARGUE5		; No, so jump here
0416F3 1A          1843*  			LD      A,(DE)
0416F4 FE 2C       1844*  			CP      ','			; Are there any more arguments?
0416F6 28 B3       1845*  			JR      Z,ARGUE1        	; Yes, so loop
0416F8             1846*  ;
0416F8 3E 1F       1847*  ARGERR:			LD      A,31
0416FA C3 B6 37 04 1848*  			JP      ERROR_           	; Throw error "Arguments"
0416FE             1849*  ;
0416FE CD 37 0A 04 1850*  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
041702 1A          1851*  			LD      A,(DE)
041703 FE 29       1852*  			CP      ')'
041705 20 F1       1853*  			JR      NZ,ARGERR
041707 13          1854*  			INC     DE
041708 D9          1855*  			EXX
041709 C1          1856*  ARGUE6:			POP     BC
04170A 78          1857*  			LD      A,B
04170B 3C          1858*  			INC     A
04170C D9          1859*  			EXX
04170D C8          1860*  			RET     Z               	; Marker popped
04170E D9          1861*  			EXX
04170F 3D          1862*  			DEC     A
041710 FA 20 17 04 1863*  			JP      M,ARGUE7        	; If it is a string, then jump here
041714 E1          1864*  			POP     HL
041715 D9          1865*  			EXX
041716 E1          1866*  			POP     HL
041717 D9          1867*  			EXX
041718 DD E1       1868*  			POP     IX
04171A CD 08 16 04 1869*  			CALL    STORE	           	; Write to dummy variable
04171E 18 E9       1870*  			JR      ARGUE6
041720             1871*  ;
041720 CD E6 09 04 1872*  ARGUE7:			CALL    POPS
041724 DD E1       1873*  			POP     IX
041726 CD 32 16 04 1874*  			CALL    STACCS
04172A 18 DD       1875*  			JR      ARGUE6
04172C             1876*  
04172C             1877*  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
04172C             1878*  ;   OF A FUNCTION OR PROCEDURE.
04172C             1879*  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
04172C             1880*  ;    Inputs: IY is parameters pointer
04172C             1881*  ;   Outputs: IY updated
04172C             1882*  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
04172C             1883*  ;
04172C D1          1884*  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
04172D             1885*  ;
04172D FD 23       1886*  SAVLO1:			INC     IY              	; Bump past '(' or ','
04172F CD 78 0A 04 1887*  			CALL    NXT			; And also any whitespace
041733 D5          1888*  			PUSH    DE			; Push the return address back onto the stack
041734 D9          1889*  			EXX
041735 C5          1890*  			PUSH    BC
041736 D5          1891*  			PUSH    DE
041737 E5          1892*  			PUSH    HL
041738 D9          1893*  			EXX
041739 CD 96 0C 04 1894*  			CALL    VAR_             	; Dummy variable
04173D D9          1895*  			EXX
04173E E1          1896*  			POP     HL
04173F D1          1897*  			POP     DE
041740 C1          1898*  			POP     BC
041741 D9          1899*  			EXX
041742 D1          1900*  			POP     DE
041743 B7          1901*  			OR      A               	; Check the variable type
041744 FA 57 17 04 1902*  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
041748 D9          1903*  			EXX
041749 E5          1904*  			PUSH    HL              	; Save H'L'
04174A D9          1905*  			EXX
04174B 47          1906*  			LD      B,A             	;  B: Variable type
04174C CD 1B 04 04 1907*  			CALL    LOADN
041750 D9          1908*  			EXX
041751 E3          1909*  			EX      (SP),HL
041752 D9          1910*  			EXX
041753 E5          1911*  			PUSH    HL
041754 C5          1912*  			PUSH    BC
041755 18 2D       1913*  			JR      SAVLO4
041757             1914*  ;
041757 F5          1915*  SAVLO2:			PUSH    AF              	; Save the type (string)
041758 D5          1916*  			PUSH    DE
041759 D9          1917*  			EXX
04175A E5          1918*  			PUSH    HL
04175B D9          1919*  			EXX
04175C CD A5 04 04 1920*  			CALL    LOADS
041760 D9          1921*  			EXX
041761 E1          1922*  			POP     HL
041762 D9          1923*  			EXX
041763 01 00 00 00 1924*  			LD	BC,0
041767 4B          1925*  			LD      C,E			; BC: String length
041768 D1          1926*  			POP     DE
041769 CD 81 16 04 1927*  			CALL    CHECK			; Check if there is space on the stack
04176D F1          1928*  			POP     AF              	; Level stack
04176E 21 00 00 00 1929*  			LD      HL,0
041772 ED 42       1930*  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
041774 39          1931*  			ADD     HL,SP			; Make space for the string on the stack
041775 F9          1932*  			LD      SP,HL
041776 47          1933*  			LD      B,A             	;  B: Variable type
041777 C5          1934*  			PUSH    BC
041778 28 0A       1935*  			JR      Z,SAVLO4
04177A D5          1936*  			PUSH    DE
04177B 11 00 4A 04 1937*  			LD      DE,ACCS
04177F EB          1938*  			EX      DE,HL
041780 45          1939*  			LD      B,L
041781 ED B0       1940*  			LDIR                    	; Save the string onto the stack
041783 D1          1941*  			POP     DE
041784             1942*  ;
041784 DD E5       1943*  SAVLO4:			PUSH    IX			; VARPTR
041786 CD 8A 17 04 1944*  			CALL    SAVLO5
04178A             1945*  LOCCHK:			EQU     $
04178A CD 81 16 04 1946*  SAVLO5:			CALL    CHECK
04178E CD 78 0A 04 1947*  			CALL    NXT
041792 FE 2C       1948*  			CP      ','             	; Are there any more local variables?
041794 28 97       1949*  			JR      Z,SAVLO1		; Yes, so loop
041796 EB          1950*  			EX      DE,HL			; DE -> HL: The return address
041797 E9          1951*  			JP      (HL)            	; And effectvely return
041798             1952*  ;
041798 FD 7E 00    1953*  DELIM:			LD      A,(IY)          	; Assembler delimiter
04179B FE 20       1954*  			CP      ' '
04179D C8          1955*  			RET     Z
04179E FE 2C       1956*  			CP      ','
0417A0 C8          1957*  			RET     Z
0417A1 FE 29       1958*  			CP      ')'
0417A3 C8          1959*  			RET     Z
0417A4 FE 3B       1960*  TERM:			CP      ';'             	; Assembler terminator
0417A6 C8          1961*  			RET     Z
0417A7 FE 5C       1962*  			CP      '\'
0417A9 C8          1963*  			RET     Z
0417AA 18 07       1964*  			JR      TERM0
0417AC             1965*  ;
0417AC CD 78 0A 04 1966*  TERMQ:			CALL    NXT
0417B0 FE 8B       1967*  			CP      ELSE_
0417B2 D0          1968*  			RET     NC
0417B3 FE 3A       1969*  TERM0:			CP      ':'             	; Assembler seperator
0417B5 D0          1970*  			RET     NC
0417B6 FE 0D       1971*  			CP      CR
0417B8 C9          1972*  			RET
0417B9             1973*  ;
0417B9 CD AC 17 04 1974*  SPAN:			CALL    TERMQ
0417BD C8          1975*  			RET     Z
0417BE FD 23       1976*  			INC     IY
0417C0 18 F7       1977*  			JR      SPAN
0417C2             1978*  ;
0417C2             1979*  ; This snippet is used to check whether an expression is followed by an '=' symbol
0417C2             1980*  ;
0417C2 CD 78 0A 04 1981*  EQUALS:			CALL    NXT			; Skip whitespace
0417C6 FD 23       1982*  			INC     IY			; Skip past the character in question
0417C8 FE 3D       1983*  			CP      '='			; Is it '='
0417CA C8          1984*  			RET     Z			; Yes, so return
0417CB 3E 04       1985*  			LD      A,4			; Otherwise
0417CD C3 B6 37 04 1986*  			JP      ERROR_           	; Throw error "Mistake"
0417D1             1987*  ;
0417D1 FE 8A       1988*  FORMAT:			CP      TAB
0417D3 28 0D       1989*  			JR      Z,DOTAB
0417D5 FE 89       1990*  			CP      SPC
0417D7 28 40       1991*  			JR      Z,DOSPC
0417D9 FE 27       1992*  			CP      '''
0417DB C0          1993*  			RET     NZ
0417DC CD 9D 39 04 1994*  			CALL    CRLF
0417E0 AF          1995*  			XOR     A
0417E1 C9          1996*  			RET
0417E2             1997*  ;
0417E2 C5          1998*  DOTAB:			PUSH    BC
0417E3 CD 0F 03 04 1999*  			CALL    EXPRI
0417E7 D9          2000*  			EXX
0417E8 C1          2001*  			POP     BC
0417E9 FD 7E 00    2002*  			LD      A,(IY)
0417EC FE 2C       2003*  			CP      ','
0417EE 28 14       2004*  			JR      Z,DOTAB1
0417F0 CD 37 0A 04 2005*  			CALL    BRAKET
0417F4 7D          2006*  			LD      A,L
0417F5 21 3D 4D 04 2007*  TABIT:			LD      HL,COUNT
0417F9 BE          2008*  			CP      (HL)
0417FA C8          2009*  			RET     Z
0417FB F5          2010*  			PUSH    AF
0417FC DC 9D 39 04 2011*  			CALL    C,CRLF
041800 F1          2012*  			POP     AF
041801 96          2013*  			SUB     (HL)
041802 18 1D       2014*  			JR      FILL
041804 FD 23       2015*  DOTAB1:			INC     IY
041806 C5          2016*  			PUSH    BC
041807 E5          2017*  			PUSH    HL
041808 CD 0F 03 04 2018*  			CALL    EXPRI
04180C D9          2019*  			EXX
04180D D1          2020*  			POP     DE
04180E C1          2021*  			POP     BC
04180F CD 37 0A 04 2022*  			CALL    BRAKET
041813 CD 17 3F 04 2023*  			CALL    PUTCSR
041817 AF          2024*  			XOR     A
041818 C9          2025*  			RET
041819             2026*  ;
041819 C5          2027*  DOSPC:			PUSH    BC
04181A CD 2A 03 04 2028*  			CALL    ITEMI
04181E D9          2029*  			EXX
04181F 7D          2030*  			LD      A,L
041820 C1          2031*  			POP     BC
041821 B7          2032*  FILL:			OR      A
041822 C8          2033*  			RET     Z
041823 C5          2034*  			PUSH    BC
041824 47          2035*  			LD      B,A
041825 3E 20       2036*  FILL1:			LD      A,' '
041827 CD A5 39 04 2037*  			CALL    OUTCHR
04182B 10 F8       2038*  			DJNZ    FILL1
04182D C1          2039*  			POP     BC
04182E AF          2040*  			XOR     A
04182F C9          2041*  			RET
041830             2042*  ;
041830 21 00 4A 04 2043*  PTEXT:			LD      HL,ACCS
041834 1C          2044*  			INC     E
041835 1D          2045*  PTEXT1:			DEC     E
041836 C8          2046*  			RET     Z
041837 7E          2047*  			LD      A,(HL)
041838 23          2048*  			INC     HL
041839 CD A5 39 04 2049*  			CALL    OUTCHR
04183D 18 F6       2050*  			JR      PTEXT1
04183F             2051*  ;
04183F F5          2052*  FETCHS:			PUSH    AF
041840 C5          2053*  			PUSH    BC
041841 E5          2054*  			PUSH    HL
041842 FD E3       2055*  			EX      (SP),IY
041844 CD 5F 18 04 2056*  			CALL    XTRACT
041848 CD 78 0A 04 2057*  			CALL    NXT
04184C FD E3       2058*  			EX      (SP),IY
04184E E1          2059*  			POP     HL
04184F C1          2060*  			POP     BC
041850 F1          2061*  			POP     AF
041851 C9          2062*  			RET
041852             2063*  ;
041852 11 00 4A 04 2064*  LINES:			LD      DE,ACCS
041856 7E          2065*  LINE1S:			LD      A,(HL)
041857 12          2066*  			LD      (DE),A
041858 FE 0D       2067*  			CP      CR
04185A C8          2068*  			RET     Z
04185B 23          2069*  			INC     HL
04185C 1C          2070*  			INC     E
04185D 18 F7       2071*  			JR      LINE1S
04185F             2072*  ;
04185F CD 78 0A 04 2073*  XTRACT:			CALL    NXT
041863 FE 22       2074*  			CP      '"'
041865 FD 23       2075*  			INC     IY
041867 CA 6C 04 04 2076*  			JP      Z,CONS
04186B FD 2B       2077*  			DEC     IY
04186D 11 00 4A 04 2078*  			LD      DE,ACCS
041871 FD 7E 00    2079*  XTRAC1:			LD      A,(IY)
041874 12          2080*  			LD      (DE),A
041875 FE 2C       2081*  			CP      ','
041877 C8          2082*  			RET     Z
041878 FE 0D       2083*  			CP      CR
04187A C8          2084*  			RET     Z
04187B FD 23       2085*  			INC     IY
04187D 1C          2086*  			INC     E
04187E 18 F1       2087*  			JR      XTRAC1
041880             2088*  
041880             2089*  ; Search for a token at the start of a program line
041880             2090*  ; - HL: Pointer to the start of a tokenised line in the program area
041880             2091*  ; Returns:
041880             2092*  ; - HL: Pointer to the
041880             2093*  ; -  F: Carry set if not found
041880             2094*  ; Corrupts:
041880             2095*  ; - BC
041880             2096*  ;
041880 01 00 00 00 2097*  SEARCH_EX:			LD      BC,0			; Clear BC
041884             2098*  ;
041884 4E          2099*  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
041885 0C          2100*  			INC     C			; Check for 0, i.e. end of program marker
041886 0D          2101*  			DEC     C
041887 28 0B       2102*  			JR      Z,SRCH2_EX         	; Not found the token, so end
041889 23          2103*  			INC     HL			; Skip the line length and line number
04188A 23          2104*  			INC     HL
04188B 23          2105*  			INC     HL
04188C BE          2106*  			CP      (HL)			; Compare with the token
04188D C8          2107*  			RET     Z			; Found it, so return with carry not set
04188E 0D          2108*  			DEC     C			; Skip to the next line
04188F 0D          2109*  			DEC     C
041890 0D          2110*  			DEC     C
041891 09          2111*  			ADD     HL,BC
041892 18 F0       2112*  			JR      SRCH1_EX			; Rinse, lather and repeat
041894             2113*  ;
041894 2B          2114*  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
041895 37          2115*  			SCF				; And set the carry flag
041896 C9          2116*  			RET
041897             2117*  
041897             2118*  ; Multiply by 4 or 5
041897             2119*  ; This function is used to allocate space for dimensioned variables
041897             2120*  ; This is a 24-bit operation
041897             2121*  ; - DE: Number to multiple
041897             2122*  ; -  A: 04h (Integer) - takes up 4 bytes
041897             2123*  ;       05h (Float)   - takes up 5 bytes
041897             2124*  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
041897             2125*  ; Returns:
041897             2126*  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
041897             2127*  ; -  F: Carry if overflow
041897             2128*  ; Corrupts:
041897             2129*  ; - HL
041897 FE 04       2130*  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
041899             2131*  			; LD	HL,DE
041899 D5          2132*  			push de
04189A E1          2133*  			pop hl
04189B 29          2134*  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04189C D8          2135*  			RET     C			; Exit if overflow
04189D 29          2136*  			ADD     HL,HL			; Multiply by 2 again
04189E D8          2137*  			RET     C			; Exit if overflow
04189F EB          2138*  			EX      DE,HL			; DE: Product
0418A0 C8          2139*  			RET     Z			; Exit if A = 4
0418A1 19          2140*  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0418A2 EB          2141*  			EX      DE,HL			; DE: Product
0418A3 C9          2142*  			RET
0418A4             2143*  
0418A4             2144*  ; 16-bit unsigned multiply
0418A4             2145*  ; - HL: Operand 1
0418A4             2146*  ; - BC: Operand 2
0418A4             2147*  ; Returns:
0418A4             2148*  ; - HL: Result
0418A4             2149*  ; -  F: C if overflow
0418A4             2150*  ;
0418A4 C5          2151*  MUL16:			PUSH	BC
0418A5 51          2152*  			LD	D, C			; Set up the registers for the multiplies
0418A6 5D          2153*  			LD	E, L
0418A7 69          2154*  			LD	L, C
0418A8 4B          2155*  			LD	C, E
0418A9 ED 6C       2156*  			MLT	HL			; HL = H * C (*256)
0418AB ED 5C       2157*  			MLT	DE			; DE = L * C
0418AD ED 4C       2158*  			MLT	BC			; BC = B * L (*256)
0418AF 09          2159*  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0418B0 C1          2160*  			POP	BC
0418B1 AF          2161*  			XOR	A
0418B2 9C          2162*  			SBC	H			; If H is not zero then it's an overflow
0418B3 D8          2163*  			RET	C
0418B4 65          2164*  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0418B5 6F          2165*  			LD	L, A
0418B6 19          2166*  			ADD	HL, DE
0418B7 C9          2167*  			RET
0418B8             2168*  ;
0418B8 CD 78 0A 04 2169*  CHANEL:			CALL    NXT			; Skip whitespace
0418BC FE 23       2170*  			CP      '#'			; Check for the '#' symbol
0418BE 3E 2D       2171*  			LD      A,45
0418C0 C2 B6 37 04 2172*  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0418C4 FD 23       2173*  CHNL:			INC     IY             		; Bump past the '#'
0418C6 CD 2A 03 04 2174*  			CALL    ITEMI			; Get the channel number
0418CA D9          2175*  			EXX
0418CB EB          2176*  			EX      DE,HL			; DE: The channel number
0418CC C9          2177*  			RET
0418CD             2178*  
0418CD             2179*  ; ASSEMBLER -------------------------------------------------------------------
0418CD             2180*  
0418CD             2181*  ; Language independant control section:
0418CD             2182*  ;  Outputs: A=delimiter, carry set if syntax error.
0418CD             2183*  ;
0418CD CD ED 1D 04 2184*  ASSEM:			CALL    SKIP
0418D1 FD 23       2185*  			INC     IY
0418D3 FE 3A       2186*  			CP      ':'
0418D5 28 F6       2187*  			JR      Z,ASSEM
0418D7 FE 5D       2188*  			CP      ']'
0418D9 C8          2189*  			RET     Z
0418DA FE 0D       2190*  			CP      CR
0418DC C8          2191*  			RET     Z
0418DD FD 2B       2192*  			DEC     IY
0418DF DD 2A 40 4C 2193*  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       04          
0418E4 21 40 4D 04 2194*  			LD      HL,LISTON
0418E8 CB 76       2195*  			BIT     6,(HL)
0418EA 28 05       2196*  			JR      Z,ASSEM0
0418EC DD 2A 3C 4C 2197*  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       04          
0418F1 DD E5       2198*  ASSEM0:			PUSH    IX
0418F3 FD E5       2199*  			PUSH    IY
0418F5 CD A5 19 04 2200*  			CALL    ASMB
0418F9 C1          2201*  			POP     BC
0418FA D1          2202*  			POP     DE
0418FB D8          2203*  			RET     C
0418FC CD ED 1D 04 2204*  			CALL    SKIP
041900 37          2205*  			SCF
041901 C0          2206*  			RET     NZ
041902 FD 2B       2207*  			DEC     IY
041904 FD 23       2208*  ASSEM3:			INC     IY
041906 FD 7E 00    2209*  			LD      A,(IY)
041909 CD B3 17 04 2210*  			CALL    TERM0
04190D 20 F5       2211*  			JR      NZ,ASSEM3
04190F 3A 40 4D 04 2212*  			LD      A,(LISTON)
041913 DD E5       2213*  			PUSH    IX
041915 E1          2214*  			POP     HL
041916 B7          2215*  			OR      A
041917 ED 52       2216*  			SBC     HL,DE
041919 EB          2217*  			EX      DE,HL           	; DE: Number of bytes
04191A E5          2218*  			PUSH    HL
04191B 2A 40 4C 04 2219*  			LD      HL,(PC)
04191F E5          2220*  			PUSH    HL
041920 19          2221*  			ADD     HL,DE
041921 22 40 4C 04 2222*  			LD      (PC),HL         	; Update PC
041925 CB 77       2223*  			BIT     6,A
041927 28 09       2224*  			JR      Z,ASSEM5
041929 2A 3C 4C 04 2225*  			LD      HL,(OC)
04192D 19          2226*  			ADD     HL,DE
04192E 22 3C 4C 04 2227*  			LD      (OC),HL         	; Update OC
041932 E1          2228*  ASSEM5:			POP     HL              	; Old PC
041933 DD E1       2229*  			POP     IX              	; Code here
041935 CB 67       2230*  			BIT     4,A
041937 28 94       2231*  			JR      Z,ASSEM
041939 22 4A 4D 04 2232*  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04193D 3A 4C 4D 04 2233*  			LD	A,(R0+2)		; Print out the address
041941 CD 8F 19 04 2234*  			CALL	HEX_EX
041945 7C          2235*  			LD      A,H
041946 CD 8F 19 04 2236*  			CALL    HEX_EX
04194A 7D          2237*  			LD      A,L
04194B CD 87 19 04 2238*  			CALL    HEXSP
04194F AF          2239*  			XOR     A
041950 BB          2240*  			CP      E
041951 28 18       2241*  			JR      Z,ASSEM2
041953             2242*  ;
041953 3A 3D 4D 04 2243*  ASSEM1:			LD      A,(COUNT)
041957 FE 14       2244*  			CP      20
041959 3E 07       2245*  			LD      A,7
04195B D4 F5 17 04 2246*  			CALL    NC,TABIT        	; Next line
04195F DD 7E 00    2247*  			LD      A,(IX)
041962 CD 87 19 04 2248*  			CALL    HEXSP
041966 DD 23       2249*  			INC     IX
041968 1D          2250*  			DEC     E
041969 20 E8       2251*  			JR      NZ,ASSEM1
04196B             2252*  ;
04196B 3E 16       2253*  ASSEM2:			LD      A,22			; Tab to the disassembly field
04196D CD F5 17 04 2254*  			CALL    TABIT
041971 FD E5       2255*  			PUSH    IY
041973 E1          2256*  			POP     HL
041974 ED 42       2257*  			SBC     HL,BC
041976 0A          2258*  ASSEM4:			LD      A,(BC)
041977 CD C2 39 04 2259*  			CALL    OUT_
04197B 03          2260*  			INC     BC
04197C 2D          2261*  			DEC     L
04197D 20 F7       2262*  			JR      NZ,ASSEM4
04197F CD 9D 39 04 2263*  			CALL    CRLF
041983 C3 CD 18 04 2264*  			JP      ASSEM
041987             2265*  ;
041987 CD 8F 19 04 2266*  HEXSP:			CALL    HEX_EX
04198B 3E 20       2267*  			LD      A,' '
04198D 18 12       2268*  			JR      OUTCH1
04198F F5          2269*  HEX_EX:			PUSH    AF
041990 0F          2270*  			RRCA
041991 0F          2271*  			RRCA
041992 0F          2272*  			RRCA
041993 0F          2273*  			RRCA
041994 CD 99 19 04 2274*  			CALL    HEXOUT
041998 F1          2275*  			POP     AF
041999 E6 0F       2276*  HEXOUT:			AND     0FH
04199B C6 90       2277*  			ADD     A,90H
04199D 27          2278*  			DAA
04199E CE 40       2279*  			ADC     A,40H
0419A0 27          2280*  			DAA
0419A1 C3 C2 39 04 2281*  OUTCH1:			JP      OUT_
0419A5             2282*  
0419A5             2283*  ; Processor Specific Translation Section:
0419A5             2284*  ;
0419A5             2285*  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0419A5             2286*  ;                 C: Opcode beig built
0419A5             2287*  ;                 D: Flags
0419A5             2288*  ;			Bit 7: Set to 1 if the instruction uses long addressing
0419A5             2289*  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0419A5             2290*  ;                 E: Offset from IX or IY
0419A5             2291*  ;                HL: Numeric operand value
0419A5             2292*  ;                IX: Code destination pointer
0419A5             2293*  ;                IY: Source text pointer
0419A5             2294*  ;    Inputs: A = initial character
0419A5             2295*  ;   Outputs: Carry set if syntax error.
0419A5             2296*  ;
0419A5 FE 2E       2297*  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0419A7 20 1F       2298*  			JR      NZ,ASMB1		; No, so just process the instruction
0419A9 FD 23       2299*  			INC     IY			; Skip past the dot to the label name
0419AB DD E5       2300*  			PUSH    IX			; Store the code destination pointer
0419AD CD 96 0C 04 2301*  			CALL    VAR_			; Create a variable
0419B1 F5          2302*  			PUSH    AF
0419B2 CD 98 09 04 2303*  			CALL    ZERO			; Zero it
0419B6 3A 42 4C 04 2304*  			LD	A,(PC+2)
0419BA 6F          2305*  			LD	L,A			; The MSB of the 24-bit address
0419BB D9          2306*  			EXX
0419BC 2A 40 4C 04 2307*  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0419C0 D9          2308*  			EXX
0419C1 F1          2309*  			POP     AF
0419C2 CD 08 16 04 2310*  			CALL    STORE			; Store the program counter
0419C6 DD E1       2311*  			POP     IX			; Restore the code destination pointer
0419C8             2312*  ;
0419C8 3A 40 4D 04 2313*  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0419CC E6 80       2314*  			AND	80H
0419CE 57          2315*  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0419CF CD ED 1D 04 2316*  			CALL    SKIP			; Skip any whitespace
0419D3 C8          2317*  			RET     Z			; And return if there is nothing further to process
0419D4 FE D6       2318*  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0419D6 0E C4       2319*  			LD      C,0C4H			;  A: The base operand
0419D8 FD 23       2320*  			INC     IY			; Skip past the token
0419DA CA 22 1B 04 2321*  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0419DE FD 2B       2322*  			DEC     IY			; Skip back, as we're not doing the above at this point
0419E0 21 04 1E 04 2323*  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0419E4 CD 9C 1D 04 2324*  			CALL    FIND			; Find the opcode
0419E8 D8          2325*  			RET     C			; If not found, then return; carry indicates an error condition
0419E9 48          2326*  			LD      C,B     		;  C: A copy of the opcode
0419EA             2327*  ;
0419EA             2328*  ; GROUP 0: Trivial cases requiring no computation
0419EA             2329*  ; GROUP 1: As Group 0, but with "ED" prefix
0419EA             2330*  ;
0419EA D6 44       2331*  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0419EC 30 08       2332*  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0419EE FE CB       2333*  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0419F0 D4 F5 1C 04 2334*  			CALL    NC,ED			; Needs to be prefixed with ED
0419F4 18 76       2335*  			JR      BYTE0			; Then write the opcode byte
0419F6             2336*  ;
0419F6             2337*  ; GROUP 2: BIT, RES, SET
0419F6             2338*  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0419F6             2339*  ;
0419F6 D6 0A       2340*  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0419F8 30 12       2341*  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0419FA FE F9       2342*  			CP      3-10			;
0419FC DC 8A 1D 04 2343*  			CALL    C,BIT_
041A00 D8          2344*  			RET     C
041A01 CD 5B 1D 04 2345*  			CALL    REGLO
041A05 D8          2346*  			RET     C
041A06 CD F9 1C 04 2347*  			CALL    CB
041A0A 18 60       2348*  			JR      BYTE0
041A0C             2349*  ;
041A0C             2350*  ; GROUP 4 - PUSH, POP, EX (SP)
041A0C             2351*  ;
041A0C D6 03       2352*  GROUP04:		SUB     3			; The number of opcodes in GROUP4
041A0E 30 07       2353*  			JR      NC,GROUP05		; If not in that range, then check GROUP5
041A10 CD 7D 1D 04 2354*  GROUP04_1:		CALL    PAIR_EX
041A14 D8          2355*  			RET     C
041A15 18 55       2356*  			JR      BYTE0
041A17             2357*  ;
041A17             2358*  ; GROUP 5 - SUB, AND, XOR, OR, CP
041A17             2359*  ; GROUP 6 - ADD, ADC, SBC
041A17             2360*  ;
041A17 D6 0A       2361*  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041A19 30 39       2362*  			JR      NC,GROUP07
041A1B FE FD       2363*  			CP      5-8
041A1D 06 07       2364*  			LD      B,7
041A1F D4 09 1D 04 2365*  			CALL    NC,OPND			; Get the first operand
041A23 78          2366*  			LD      A,B
041A24 FE 07       2367*  			CP      7			; Is the operand 'A'?
041A26 20 15       2368*  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041A28             2369*  ;
041A28 CD 5B 1D 04 2370*  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
041A2C 79          2371*  			LD      A,C
041A2D 30 2E       2372*  			JR      NC,BIND1		; If it is a register, then write that out
041A2F EE 46       2373*  			XOR     46H			; Handle ADD A,n
041A31 CD FB 1C 04 2374*  			CALL    BIND
041A35 CD 3B 1D 04 2375*  DB_:			CALL    NUMBER
041A39 C3 F4 1A 04 2376*  			JP      VAL8
041A3D             2377*  ;
041A3D E6 3F       2378*  GROUP05_HL:		AND     3FH
041A3F FE 0C       2379*  			CP      12
041A41 37          2380*  			SCF
041A42 C0          2381*  			RET     NZ
041A43 79          2382*  			LD      A,C
041A44 FE 80       2383*  			CP      80H
041A46 0E 09       2384*  			LD      C,9
041A48 28 C6       2385*  			JR      Z,GROUP04_1
041A4A EE 1C       2386*  			XOR     1CH
041A4C 0F          2387*  			RRCA
041A4D 4F          2388*  			LD      C,A
041A4E CD F5 1C 04 2389*  			CALL    ED
041A52 18 BC       2390*  			JR      GROUP04_1
041A54             2391*  ;
041A54             2392*  ; GROUP 7 - INC, DEC
041A54             2393*  ;
041A54 D6 02       2394*  GROUP07:		SUB     2			; The number of opcodes in GROUP7
041A56 30 19       2395*  			JR      NC,GROUP08
041A58 CD 62 1D 04 2396*  			CALL    REGHI
041A5C 79          2397*  			LD      A,C
041A5D D2 FB 1C 04 2398*  BIND1:			JP      NC,BIND
041A61 EE 64       2399*  			XOR     64H
041A63 07          2400*  			RLCA
041A64 07          2401*  			RLCA
041A65 07          2402*  			RLCA
041A66 4F          2403*  			LD      C,A
041A67 CD 82 1D 04 2404*  			CALL    PAIR1_EX
041A6B D8          2405*  			RET     C
041A6C 79          2406*  BYTE0:			LD      A,C
041A6D C3 2A 1D 04 2407*  			JP      BYTE_
041A71             2408*  ;
041A71             2409*  ; Group 8: IN0, OUT0
041A71             2410*  ;
041A71 D6 02       2411*  GROUP08:		SUB	2			; The number of opcodes in GROUP8
041A73 30 2C       2412*  			JR	NC,GROUP09
041A75 FE FF       2413*  			CP	1-2
041A77 CC 3B 1D 04 2414*  			CALL    Z,NUMBER		; Fetch number first if OUT
041A7B 08          2415*  			EX      AF,AF'			; Save flags
041A7C CD 4F 1D 04 2416*  			CALL    REG			; Get the register value regardless
041A80 D8          2417*  			RET     C			; Return if not a register
041A81 08          2418*  			EX      AF,AF'			; Restore the flags
041A82 DC 3B 1D 04 2419*  			CALL    C,NUMBER		; Fetch number last if IN
041A86 78          2420*  			LD	A,B			; Get the register number
041A87 FE 06       2421*  			CP	6			; Fail on (HL)
041A89 37          2422*  			SCF
041A8A C8          2423*  			RET	Z
041A8B FE 08       2424*  			CP	8			; Check it is just single pairs only
041A8D 3F          2425*  			CCF
041A8E D8          2426*  			RET	C			; And return if it is an invalid register
041A8F 07          2427*  			RLCA				; Bind with the operand
041A90 07          2428*  			RLCA
041A91 07          2429*  			RLCA
041A92 81          2430*  			ADD	A,C
041A93 4F          2431*  			LD	C,A
041A94 CD F5 1C 04 2432*  			CALL	ED			; Prefix with ED
041A98 79          2433*  			LD	A,C
041A99 CD 2A 1D 04 2434*  			CALL	BYTE_			; Write out the operand
041A9D C3 F4 1A 04 2435*  			JP	VAL8			; Write out the value
041AA1             2436*  ;
041AA1             2437*  ; GROUP 9 - IN
041AA1             2438*  ; GROUP 10 - OUT
041AA1             2439*  ;
041AA1 D6 02       2440*  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041AA3 30 25       2441*  			JR      NC,GROUP11
041AA5 FE FF       2442*  			CP      1-2			; Check if Group 9 or Group 1
041AA7 CC E9 1C 04 2443*  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
041AAB 08          2444*  			EX      AF,AF'			; Save flags
041AAC CD 62 1D 04 2445*  			CALL    REGHI			; Get the register value regardless
041AB0 D8          2446*  			RET     C			; Return if not a register
041AB1 08          2447*  			EX      AF,AF'			; Restore the flags
041AB2 DC E9 1C 04 2448*  			CALL    C,CORN			; Call CORN if Group 9 (IN)
041AB6 24          2449*  			INC     H			; If it is IN r,(C) or OUT (C),r then
041AB7 28 B3       2450*  			JR      Z,BYTE0			; Just write the operand out
041AB9             2451*  ;
041AB9 78          2452*  			LD      A,B			; Check the register
041ABA FE 07       2453*  			CP      7
041ABC 37          2454*  			SCF
041ABD C0          2455*  			RET     NZ			; If it is not A, then return
041ABE             2456*  ;
041ABE 79          2457*  			LD      A,C			; Bind the register with the operand
041ABF EE 03       2458*  			XOR     3
041AC1 07          2459*  			RLCA
041AC2 07          2460*  			RLCA
041AC3 07          2461*  			RLCA
041AC4 CD 2A 1D 04 2462*  			CALL    BYTE_			; Write out the operand
041AC8 18 2A       2463*  			JR      VAL8			; And the value
041ACA             2464*  ;
041ACA             2465*  ; GROUP 11 - JR, DJNZ
041ACA             2466*  ;
041ACA D6 02       2467*  GROUP11:		SUB     2			; The number of opcodes in GROUP11
041ACC 30 2B       2468*  			JR      NC,GROUP12
041ACE FE FF       2469*  			CP      1-2
041AD0 C4 69 1D 04 2470*  			CALL    NZ,COND_
041AD4 79          2471*  			LD      A,C
041AD5 30 02       2472*  			JR      NC,@F
041AD7 3E 18       2473*  			LD      A,18H
041AD9 CD 2A 1D 04 2474*  @@:			CALL    BYTE_
041ADD CD 3B 1D 04 2475*  			CALL    NUMBER
041AE1 ED 5B 40 4C 2476*  			LD      DE,(PC)
       04          
041AE6 13          2477*  			INC     DE
041AE7 37          2478*  			SCF
041AE8 ED 52       2479*  			SBC     HL,DE
041AEA 7D          2480*  			LD      A,L
041AEB 17          2481*  			RLA
041AEC 9F          2482*  			SBC     A,A
041AED BC          2483*  			CP      H
041AEE 3E 01       2484*  TOOFAR:			LD      A,1
041AF0 C2 B6 37 04 2485*  			JP      NZ,ERROR_		; Throw an "Out of range" error
041AF4 7D          2486*  VAL8:			LD      A,L
041AF5 C3 2A 1D 04 2487*  			JP      BYTE_
041AF9             2488*  ;
041AF9             2489*  ; GROUP 12 - JP
041AF9             2490*  ;
041AF9 D6 01       2491*  GROUP12:		SUB	1			; The number of opcodes in GROUP12
041AFB 30 21       2492*  			JR	NC,GROUP13
041AFD CD 4F 1C 04 2493*  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041B01 D8          2494*  			RET	C			; Exit if an invalid suffix is provided
041B02 CD 69 1D 04 2495*  			CALL    COND_			; Evaluate the conditions
041B06 79          2496*  			LD      A,C
041B07 30 0D       2497*  			JR      NC,GROUP12_1
041B09 78          2498*  			LD      A,B
041B0A E6 3F       2499*  			AND     3FH
041B0C FE 06       2500*  			CP      6
041B0E 3E E9       2501*  			LD      A,0E9H
041B10 CA 2A 1D 04 2502*  			JP      Z,BYTE_
041B14 3E C3       2503*  			LD      A,0C3H
041B16 CD 2A 1D 04 2504*  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
041B1A C3 A4 1C 04 2505*  			JP	ADDR_			; Output the address
041B1E             2506*  ;
041B1E             2507*  ; GROUP 13 - CALL
041B1E             2508*  ;
041B1E D6 01       2509*  GROUP13:		SUB	1			; The number of opcodes in GROUP13
041B20 30 0C       2510*  			JR	NC,GROUP14
041B22 CD 67 1C 04 2511*  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041B26 CD 49 1B 04 2512*  			CALL    GROUP15_1		; Output the opcode (with conditions)
041B2A C3 A4 1C 04 2513*  			JP	ADDR_			; Output the address
041B2E             2514*  ;
041B2E             2515*  ; GROUP 14 - RST
041B2E             2516*  ;
041B2E D6 01       2517*  GROUP14:		SUB	1			; The number of opcodes in GROUP14
041B30 30 13       2518*  			JR	NC,GROUP15
041B32 CD 67 1C 04 2519*  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B36 D8          2520*  			RET	C			; Exit if an invalid suffix provided
041B37 CD 3B 1D 04 2521*  			CALL    NUMBER
041B3B A1          2522*  			AND     C
041B3C B4          2523*  			OR      H
041B3D 20 AF       2524*  			JR      NZ,TOOFAR
041B3F 7D          2525*  			LD      A,L
041B40 B1          2526*  			OR      C
041B41 C3 2A 1D 04 2527*  	  		JP      BYTE_
041B45             2528*  ;
041B45             2529*  ; GROUP 15 - RET
041B45             2530*  ;
041B45 D6 01       2531*  GROUP15:		SUB	1			; The number of opcodes in GROUP15
041B47 30 0F       2532*  			JR	NC,GROUP16
041B49 CD 69 1D 04 2533*  GROUP15_1:		CALL    COND_
041B4D 79          2534*  			LD      A,C
041B4E D2 2A 1D 04 2535*  			JP      NC,BYTE_
041B52 F6 09       2536*  			OR      9
041B54 C3 2A 1D 04 2537*  			JP      BYTE_
041B58             2538*  ;
041B58             2539*  ; GROUP 16 - LD
041B58             2540*  ;
041B58 D6 01       2541*  GROUP16:		SUB	1			; The number of opcodes in GROUP16
041B5A 30 74       2542*  			JR	NC,GROUP17
041B5C CD 67 1C 04 2543*  			CALL	EZ80SF_FULL		; Evaluate the suffix
041B60 CD 98 1D 04 2544*  			CALL    LDOP			; Check for accumulator loads
041B64 D2 C4 1C 04 2545*  			JP      NC,LDA			; Yes, so jump here
041B68 CD 62 1D 04 2546*  			CALL    REGHI
041B6C 08          2547*  			EX      AF,AF'
041B6D CD ED 1D 04 2548*  			CALL    SKIP
041B71 FE 28       2549*  			CP      '('			; Check for bracket
041B73 28 24       2550*  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
041B75 08          2551*  			EX      AF,AF'
041B76 D2 28 1A 04 2552*  			JP      NC,GROUP05_1		; Load single register direct; go here
041B7A 0E 01       2553*  			LD      C,1
041B7C CD 82 1D 04 2554*  			CALL    PAIR1_EX
041B80 D8          2555*  			RET     C
041B81 3E 0E       2556*  			LD      A,14
041B83 B8          2557*  			CP      B
041B84 47          2558*  			LD      B,A
041B85 CC 7D 1D 04 2559*  			CALL    Z,PAIR_EX
041B89 78          2560*  			LD      A,B
041B8A E6 3F       2561*  			AND     3FH
041B8C FE 0C       2562*  			CP      12
041B8E 79          2563*  			LD      A,C
041B8F C2 16 1B 04 2564*  			JP      NZ,GROUP12_1		; Load register pair direct; go here
041B93 3E F9       2565*  			LD      A,0F9H
041B95 C3 2A 1D 04 2566*  			JP      BYTE_
041B99             2567*  ;
041B99 08          2568*  LDIN:			EX      AF,AF'
041B9A C5          2569*  			PUSH    BC
041B9B D4 5B 1D 04 2570*  			CALL    NC,REGLO
041B9F 79          2571*  			LD      A,C
041BA0 C1          2572*  			POP     BC
041BA1 D2 FB 1C 04 2573*  			JP      NC,BIND
041BA5 0E 0A       2574*  			LD      C,0AH
041BA7 CD 82 1D 04 2575*  			CALL    PAIR1_EX
041BAB CD CF 1C 04 2576*  			CALL    LD16
041BAF D2 16 1B 04 2577*  			JP      NC,GROUP12_1
041BB3 CD 3B 1D 04 2578*  			CALL    NUMBER
041BB7 0E 02       2579*  			LD      C,2
041BB9 CD 7D 1D 04 2580*  			CALL    PAIR_EX
041BBD CD CF 1C 04 2581*  			CALL    LD16
041BC1 D8          2582*  			RET     C
041BC2 CD 2A 1D 04 2583*  			CALL    BYTE_
041BC6 CB 7A       2584*  			BIT	7,D			; Check the ADL flag
041BC8 C2 B9 1C 04 2585*  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
041BCC C3 AC 1C 04 2586*  			JP      VAL16			; Otherwise use 16-bit addresses
041BD0             2587*  ;
041BD0             2588*  ; Group 17 - TST
041BD0             2589*  ;
041BD0 D6 01       2590*  GROUP17:		SUB	1			; The number of opcodes in GROUP17
041BD2 30 25       2591*  			JR	NC,OPTS
041BD4 CD F5 1C 04 2592*  			CALL	ED			; Needs to be prefixed with ED
041BD8 CD 4F 1D 04 2593*  			CALL	REG			; Fetch the register
041BDC 30 0E       2594*  			JR	NC,GROUP17_1		; It's just a register
041BDE             2595*  ;
041BDE 3E 64       2596*  			LD	A,64H			; Opcode for TST n
041BE0 CD 2A 1D 04 2597*  			CALL	BYTE_			; Write out the opcode
041BE4 CD 3B 1D 04 2598*  			CALL	NUMBER			; Get the number
041BE8 C3 F4 1A 04 2599*  			JP	VAL8			; And write that out
041BEC             2600*  ;
041BEC 78          2601*  GROUP17_1:		LD	A,B			; Check the register rangs
041BED FE 08       2602*  			CP	8
041BEF 3F          2603*  			CCF
041BF0 D8          2604*  			RET	C			; Ret with carry flag set for error if out of range
041BF1 07          2605*  			RLCA				; Get the opcode value
041BF2 07          2606*  			RLCA
041BF3 07          2607*  			RLCA
041BF4 81          2608*  			ADD	A,C			; Add the opcode base in
041BF5 C3 2A 1D 04 2609*  			JP	BYTE_
041BF9             2610*  
041BF9             2611*  ;
041BF9             2612*  ; Assembler directives - OPT, ADL
041BF9             2613*  ;
041BF9 D6 02       2614*  OPTS:			SUB	2
041BFB 30 2B       2615*  			JR	NC, DEFS
041BFD FE FF       2616*  			CP	1-2			; Check for ADL opcode
041BFF 28 13       2617*  			JR	Z, ADL_
041C01             2618*  ;
041C01 CD 3B 1D 04 2619*  OPT:			CALL    NUMBER			; Fetch the OPT value
041C05 21 40 4D 04 2620*  			LD      HL,LISTON		; Address of the LISTON/OPT flag
041C09 E6 07       2621*  			AND	7			; Only interested in the first three bits
041C0B 4F          2622*  			LD      C,A			; Store the new OPT value in C
041C0C ED 6F       2623*  			RLD				; Shift the top nibble of LISTON (OPT) into A
041C0E E6 08       2624*  			AND	8			; Clear the bottom three bits, preserving the ADL bit
041C10 B1          2625*  			OR	C			; OR in the new value
041C11 ED 67       2626*  			RRD				; And shift the nibble back in
041C13 C9          2627*  			RET
041C14             2628*  ;
041C14 CD 3B 1D 04 2629*  ADL_:			CALL	NUMBER			; Fetch the ADL value
041C18 E6 01       2630*  			AND	1			; Only interested if it is 0 or 1
041C1A 0F          2631*  			RRCA				; Rotate to bit 7
041C1B 4F          2632*  			LD	C,A			; Store in C
041C1C 3A 40 4D 04 2633*  			LD	A,(LISTON)		; Get the LISTON system variable
041C20 E6 7F       2634*  			AND	7Fh			; Clear bit 7
041C22 B1          2635*  			OR	C			; OR in the ADL value
041C23 32 40 4D 04 2636*  			LD	(LISTON),A		; Store
041C27 C9          2637*  			RET
041C28             2638*  ;
041C28             2639*  ; DEFB, DEFW, DEFL, DEFM
041C28             2640*  ;
041C28 B7          2641*  DEFS:			OR	A			; Handle DEFB
041C29 CA 35 1A 04 2642*  			JP	Z, DB_
041C2D 3D          2643*  			DEC	A			; Handle DEFW
041C2E CA A8 1C 04 2644*  			JP	Z, ADDR16
041C32 3D          2645*  			DEC	A			; Handle DEFL
041C33 CA B5 1C 04 2646*  			JP	Z, ADDR24
041C37             2647*  ;
041C37 DD E5       2648*  			PUSH    IX			; Handle DEFM
041C39 CD 1A 03 04 2649*  			CALL    EXPRS
041C3D DD E1       2650*  			POP     IX
041C3F 21 00 4A 04 2651*  			LD      HL,ACCS
041C43 AF          2652*  @@:			XOR     A
041C44 BB          2653*  			CP      E
041C45 C8          2654*  			RET     Z
041C46 7E          2655*  			LD      A,(HL)
041C47 23          2656*  			INC     HL
041C48 CD 2A 1D 04 2657*  			CALL    BYTE_
041C4C 1D          2658*  			DEC     E
041C4D 18 F4       2659*  			JR      @B
041C4F             2660*  
041C4F             2661*  ;
041C4F             2662*  ;SUBROUTINES:
041C4F             2663*  ;
041C4F FD 7E 00    2664*  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
041C52 FE 2E       2665*  			CP	'.'
041C54 28 02       2666*  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
041C56 B7          2667*  			OR	A			; Reset the carry flag (no error)
041C57 C9          2668*  			RET				; And return
041C58 FD 23       2669*  @@:			INC	IY			; Skip the dot
041C5A C5          2670*  			PUSH	BC			; Push the operand
041C5B 21 83 20 04 2671*  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
041C5F CD 9C 1D 04 2672*  			CALL	FIND			; Look up the operand
041C63 30 24       2673*  			JR	NC,EZ80SF_OK
041C65 C1          2674*  			POP	BC			; Not found at this point, so will return with a C (error)
041C66 C9          2675*  			RET
041C67             2676*  ;
041C67 FD 7E 00    2677*  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
041C6A FE 2E       2678*  			CP	'.'
041C6C 28 02       2679*  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
041C6E B7          2680*  			OR	A			; Reset the carry flag (no error)
041C6F C9          2681*  			RET				; And return
041C70 FD 23       2682*  @@:			INC	IY 			; Skip the dot
041C72 C5          2683*  			PUSH	BC			; Push the operand
041C73 21 7B 20 04 2684*  			LD	HL,EZ80SFS_1		; First check the fully qualified table
041C77 CD 9C 1D 04 2685*  			CALL	FIND 			; Look up the operand
041C7B 30 0C       2686*  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
041C7D CD 98 1C 04 2687*  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
041C81 CD 9C 1D 04 2688*  			CALL	FIND
041C85 30 02       2689*  			JR	NC,EZ80SF_OK
041C87 C1          2690*  			POP	BC			; Not found at this point, so will return with a C (error)
041C88 C9          2691*  			RET
041C89             2692*  ;
041C89 78          2693*  EZ80SF_OK:		LD	A,B			; The operand value
041C8A D4 2A 1D 04 2694*  			CALL	NC,BYTE_ 		; Write it out if found
041C8E CB BA       2695*  			RES	7,D			; Clear the default ADL mode from the flags
041C90 E6 02       2696*  			AND	2			; Check the second half of the suffix (.xxL)
041C92 0F          2697*  			RRCA				; Shift into bit 7
041C93 0F          2698*  			RRCA
041C94 B2          2699*  			OR	D			; Or into bit 7 of D
041C95 57          2700*  			LD	D,A
041C96 C1          2701*  			POP	BC 			; Restore the operand
041C97 C9          2702*  			RET
041C98             2703*  ;
041C98 21 8C 20 04 2704*  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
041C9C CB 7A       2705*  			BIT 	7,D			; if bit 7 of D is 0
041C9E C8          2706*  			RET	Z
041C9F 21 97 20 04 2707*  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041CA3 C9          2708*  			RET
041CA4             2709*  ;
041CA4 CB 7A       2710*  ADDR_:			BIT	7,D			; Check the ADL flag
041CA6 20 0D       2711*  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041CA8             2712*  ;
041CA8 CD 3B 1D 04 2713*  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
041CAC CD F4 1A 04 2714*  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041CB0 7C          2715*  			LD      A,H
041CB1 C3 2A 1D 04 2716*  			JP      BYTE_
041CB5             2717*  ;
041CB5 CD 3B 1D 04 2718*  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041CB9 CD AC 1C 04 2719*  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
041CBD D9          2720*  			EXX
041CBE 7D          2721*  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
041CBF D9          2722*  			EXX
041CC0 C3 2A 1D 04 2723*  			JP	BYTE_
041CC4             2724*  ;
041CC4 FE 04       2725*  LDA:			CP      4
041CC6 DC F5 1C 04 2726*  			CALL    C,ED
041CCA 78          2727*  			LD      A,B
041CCB C3 2A 1D 04 2728*  			JP      BYTE_
041CCF             2729*  ;
041CCF 78          2730*  LD16:			LD      A,B
041CD0 38 0F       2731*  			JR      C,LD8
041CD2 78          2732*  			LD      A,B
041CD3 E6 3F       2733*  			AND     3FH
041CD5 FE 0C       2734*  			CP      12
041CD7 79          2735*  			LD      A,C
041CD8 C8          2736*  			RET     Z
041CD9 CD F5 1C 04 2737*  			CALL    ED
041CDD 79          2738*  			LD      A,C
041CDE F6 43       2739*  			OR      43H
041CE0 C9          2740*  			RET
041CE1             2741*  ;
041CE1 FE 07       2742*  LD8:			CP      7
041CE3 37          2743*  			SCF
041CE4 C0          2744*  			RET     NZ
041CE5 79          2745*  			LD      A,C
041CE6 F6 30       2746*  			OR      30H
041CE8 C9          2747*  			RET
041CE9             2748*  ;
041CE9             2749*  ; Used in IN and OUT to handle whether the operand is C or a number
041CE9             2750*  ;
041CE9 C5          2751*  CORN:			PUSH    BC
041CEA CD 09 1D 04 2752*  			CALL    OPND			; Get the operand
041CEE CB 68       2753*  			BIT     5,B
041CF0 C1          2754*  			POP     BC
041CF1 28 48       2755*  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041CF3 26 FF       2756*  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041CF5             2757*  ;
041CF5 3E ED       2758*  ED:			LD      A,0EDH			; Write an ED prefix out
041CF7 18 31       2759*  			JR      BYTE_
041CF9             2760*  ;
041CF9 3E CB       2761*  CB:			LD      A,0CBH
041CFB FE 76       2762*  BIND:			CP      76H
041CFD 37          2763*  			SCF
041CFE C8          2764*  			RET     Z               	; Reject LD (HL),(HL)
041CFF CD 2A 1D 04 2765*  			CALL    BYTE_
041D03 CB 72       2766*  			BIT	6,D			; Check the index bit in flags
041D05 C8          2767*  			RET     Z
041D06 7B          2768*  			LD      A,E			; If there is an index, output the offset
041D07 18 21       2769*  			JR      BYTE_
041D09             2770*  ;
041D09             2771*  ; Search through the operand table
041D09             2772*  ; Returns:
041D09             2773*  ; - B: The operand type
041D09             2774*  ; - D: Bit 7: 0 = no prefix, 1 = prefix
041D09             2775*  ; - E: The IX/IY offset
041D09             2776*  ; - F: Carry if not found
041D09             2777*  ;
041D09 E5          2778*  OPND:			PUSH    HL			; Preserve HL
041D0A 21 0D 20 04 2779*  			LD      HL,OPRNDS		; The operands table
041D0E CD 9C 1D 04 2780*  			CALL    FIND			; Find the operand
041D12 E1          2781*  			POP     HL
041D13 D8          2782*  			RET     C			; Return if not found
041D14 CB 78       2783*  			BIT     7,B			; Check if it is an index register (IX, IY)
041D16 C8          2784*  			RET     Z			; Return if it isn't
041D17 CB F2       2785*  			SET	6,D			; Set flag to indicate we've got an index
041D19 CB 58       2786*  			BIT     3,B			; Check if an offset is required
041D1B E5          2787*  			PUSH    HL
041D1C CC 31 1D 04 2788*  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
041D20 5D          2789*  			LD      E,L			; E: The offset
041D21 E1          2790*  			POP     HL
041D22 3E DD       2791*  			LD	A,DDH			; IX prefix
041D24 CB 70       2792*  			BIT     6,B			; If bit 6 is reset then
041D26 28 02       2793*  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041D28 3E FD       2794*  			LD	A,FDH			; IY prefix
041D2A             2795*  ;
041D2A DD 77 00    2796*  BYTE_:			LD      (IX),A			; Write a byte out
041D2D DD 23       2797*  			INC     IX
041D2F B7          2798*  			OR      A
041D30 C9          2799*  			RET
041D31             2800*  ;
041D31 FD 7E 00    2801*  OFFSET_EX:			LD      A,(IY)
041D34 FE 29       2802*  			CP      ')'
041D36 21 00 00 00 2803*  			LD      HL,0
041D3A C8          2804*  			RET     Z
041D3B CD ED 1D 04 2805*  NUMBER:			CALL    SKIP
041D3F C5          2806*  			PUSH    BC
041D40 D5          2807*  			PUSH    DE
041D41 DD E5       2808*  			PUSH    IX
041D43 CD 0F 03 04 2809*  			CALL    EXPRI
041D47 DD E1       2810*  			POP     IX
041D49 D9          2811*  			EXX
041D4A D1          2812*  			POP     DE
041D4B C1          2813*  			POP     BC
041D4C 7D          2814*  			LD      A,L
041D4D B7          2815*  			OR      A
041D4E C9          2816*  			RET
041D4F             2817*  ;
041D4F CD 09 1D 04 2818*  REG:			CALL    OPND
041D53 D8          2819*  			RET     C
041D54 78          2820*  			LD      A,B
041D55 E6 3F       2821*  			AND     3FH
041D57 FE 08       2822*  			CP      8
041D59 3F          2823*  			CCF
041D5A C9          2824*  			RET
041D5B             2825*  ;
041D5B CD 4F 1D 04 2826*  REGLO:			CALL    REG
041D5F D8          2827*  			RET     C
041D60 18 33       2828*  			JR      ORC
041D62             2829*  ;
041D62 CD 4F 1D 04 2830*  REGHI:			CALL    REG
041D66 D8          2831*  			RET     C
041D67 18 29       2832*  			JR      SHL3
041D69             2833*  ;
041D69 CD 09 1D 04 2834*  COND_:			CALL    OPND
041D6D D8          2835*  			RET     C
041D6E 78          2836*  			LD      A,B
041D6F E6 1F       2837*  			AND     1FH
041D71 D6 10       2838*  			SUB     16
041D73 30 1D       2839*  			JR      NC,SHL3
041D75 FE F1       2840*  			CP      -15
041D77 37          2841*  			SCF
041D78 C0          2842*  			RET     NZ
041D79 3E 03       2843*  			LD      A,3
041D7B 18 15       2844*  			JR      SHL3
041D7D             2845*  ;
041D7D CD 09 1D 04 2846*  PAIR_EX:			CALL    OPND
041D81 D8          2847*  			RET     C
041D82 78          2848*  PAIR1_EX:			LD      A,B
041D83 E6 0F       2849*  			AND     0FH
041D85 D6 08       2850*  			SUB     8
041D87 D8          2851*  			RET     C
041D88 18 08       2852*  			JR      SHL3
041D8A             2853*  ;
041D8A CD 3B 1D 04 2854*  BIT_:			CALL    NUMBER
041D8E FE 08       2855*  			CP      8
041D90 3F          2856*  			CCF
041D91 D8          2857*  			RET     C
041D92 07          2858*  SHL3:			RLCA
041D93 07          2859*  			RLCA
041D94 07          2860*  			RLCA
041D95 B1          2861*  ORC:			OR      C
041D96 4F          2862*  			LD      C,A
041D97 C9          2863*  			RET
041D98             2864*  ;
041D98 21 52 20 04 2865*  LDOP:			LD      HL,LDOPS
041D9C             2866*  
041D9C             2867*  ;
041D9C             2868*  ; Look up a value in a table
041D9C             2869*  ; Parameters:
041D9C             2870*  ; - IY: Address of the assembly language line in the BASIC program area
041D9C             2871*  ; - HL: Address of the table
041D9C             2872*  ; Returns:
041D9C             2873*  ; - B: The operand code
041D9C             2874*  ; - F: Carry set if not found
041D9C             2875*  ;
041D9C CD ED 1D 04 2876*  FIND:			CALL    SKIP			; Skip delimiters
041DA0             2877*  ;
041DA0 06 00       2878*  EXIT_:			LD      B,0			; Set B to 0
041DA2 37          2879*  			SCF				; Set the carry flag
041DA3 C8          2880*  			RET     Z			; Returns if Z
041DA4             2881*  ;
041DA4 FE DD       2882*  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041DA6 28 04       2883*  			JR      Z,FIND0
041DA8 FE 85       2884*  			CP      TOR+1			; Special case for tokens AND and OR
041DAA 3F          2885*  			CCF
041DAB D8          2886*  			RET     C
041DAC 7E          2887*  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
041DAD B7          2888*  			OR      A
041DAE 28 F0       2889*  			JR      Z,EXIT_			; Exit
041DB0 FD AE 00    2890*  			XOR     (IY)
041DB3 E6 5F       2891*  			AND     01011111B
041DB5 28 09       2892*  			JR      Z,FIND2
041DB7 CB 7E       2893*  FIND1:			BIT     7,(HL)
041DB9 23          2894*  			INC     HL
041DBA 28 FB       2895*  			JR      Z,FIND1
041DBC 23          2896*  			INC     HL
041DBD 04          2897*  			INC     B
041DBE 18 EC       2898*  			JR      FIND0
041DC0             2899*  ;
041DC0 FD E5       2900*  FIND2:			PUSH    IY
041DC2 CB 7E       2901*  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041DC4 FD 23       2902*  			INC     IY
041DC6 23          2903*  			INC     HL
041DC7 20 11       2904*  			JR      NZ,FIND5		; Yes
041DC9 BE          2905*  			CP      (HL)
041DCA CC EC 1D 04 2906*  			CALL    Z,SKIP0
041DCE 7E          2907*  			LD      A,(HL)
041DCF FD AE 00    2908*  			XOR     (IY)
041DD2 E6 5F       2909*  			AND     01011111B
041DD4 28 EC       2910*  			JR      Z,FIND3
041DD6 FD E1       2911*  FIND4:			POP     IY
041DD8 18 DD       2912*  			JR      FIND1
041DDA             2913*  ;
041DDA CD 98 17 04 2914*  FIND5:			CALL    DELIM			; Is it a delimiter?
041DDE C4 01 1E 04 2915*  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041DE2 C4 FB 1D 04 2916*  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041DE6 20 EE       2917*  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041DE8             2918*  ;
041DE8 78          2919*  FIND6:			LD      A,B			; At this point we have a token
041DE9 46          2920*  			LD      B,(HL)			; Fetch the token type code
041DEA E1          2921*  			POP     HL			; Restore the stack
041DEB C9          2922*  			RET
041DEC             2923*  ;
041DEC 23          2924*  SKIP0:			INC     HL
041DED CD 98 17 04 2925*  SKIP:			CALL    DELIM			; Is it a delimiter?
041DF1 C0          2926*  			RET     NZ			; No, so return
041DF2 CD A4 17 04 2927*  			CALL    TERM			; Is it a terminator?
041DF6 C8          2928*  			RET     Z			; Yes, so return
041DF7 FD 23       2929*  			INC     IY			; Increment the basic program counter
041DF9 18 F2       2930*  			JR      SKIP			; And loop
041DFB             2931*  ;
041DFB FE 2B       2932*  SIGN:			CP      '+'			; Check whether the character is a sign symbol
041DFD C8          2933*  			RET     Z
041DFE FE 2D       2934*  			CP      '-'
041E00 C9          2935*  			RET
041E01             2936*  ;
041E01 FE 2E       2937*  DOT:			CP	'.'			; Check if it is a dot character
041E03 C9          2938*  			RET
041E04             2939*  ; Z80 opcode list
041E04             2940*  ;
041E04             2941*  ; Group 0: (15 opcodes)
041E04             2942*  ; Trivial cases requiring no computation
041E04             2943*  ;
041E04 4E 4F 50 00 2944*  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041E08 52 4C 43 41 2945*  			DB	"RLC","A"+80H,07h
       07          
041E0D 45 58 00 41 2946*  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041E17 52 52 43 41 2947*  			DB	"RRC","A"+80H,0FH
       0F          
041E1C 52 4C 41 17 2948*  			DB	"RL","A"+80H,17H
041E20 52 52 41 1F 2949*  			DB	"RR","A"+80H,1FH
041E24 44 41 41 27 2950*  			DB	"DA","A"+80H,27H
041E28 43 50 4C 2F 2951*  			DB	"CP","L"+80H,2FH
041E2C 53 43 46 37 2952*  			DB	"SC","F"+80H,37H
041E30 43 43 46 3F 2953*  			DB	"CC","F"+80H,3FH
041E34 48 41 4C 54 2954*  			DB	"HAL","T"+80H,76H
       76          
041E39 45 58 58 D9 2955*  			DB	"EX","X"+80H,D9H
041E3D 45 58 00 44 2956*  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
041E46 44 49 F3    2957*  			DB	"D","I"+80H,F3H
041E49 45 49 FB    2958*  			DB	"E","I"+80H,FBH
041E4C             2959*  ;
041E4C             2960*  ; Group 1: (53 opcodes)
041E4C             2961*  ; As Group 0, but with an ED prefix
041E4C             2962*  ;
041E4C 4E 45 47 44 2963*  			DB	"NE","G"+80H,44H	; 0Fh
041E50 49 4D 00 30 2964*  			DB	"IM",0,"0"+80H,46H
       46          
041E55 52 45 54 4E 2965*  			DB	"RET","N"+80H,45H
       45          
041E5A 4D 4C 54 00 2966*  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
041E61 52 45 54 49 2967*  			DB	"RET","I"+80H,4DH
       4D          
041E66 49 4D 00 31 2968*  			DB	"IM",0,"1"+80H,56H
       56          
041E6B 4D 4C 54 00 2969*  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
041E72 49 4D 00 32 2970*  			DB	"IM",0,"2"+80H,5EH
       5E          
041E77 52 52 44 67 2971*  			DB	"RR","D"+80H,67H
041E7B 4D 4C 54 00 2972*  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
041E82 4C 44 00 4D 2973*  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
041E8A 4C 44 00 41 2974*  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
041E92 52 4C 44 6F 2975*  			DB	"RL","D"+80H,6FH
041E96 53 4C 50 76 2976*  			DB	"SL","P"+80H,76H
041E9A 4D 4C 54 00 2977*  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041EA1 53 54 4D 49 2978*  			DB	"STMI","X"+80H,7DH
       58 7D       
041EA7 52 53 4D 49 2979*  			DB	"RSMI","X"+80H,7EH
       58 7E       
041EAD 49 4E 49 4D 2980*  			DB	"INI","M"+80H,82H
       82          
041EB2 4F 54 49 4D 2981*  			DB	"OTI","M"+80H,83H
       83          
041EB7 49 4E 49 32 2982*  			DB	"INI","2"+80H,84H
       84          
041EBC 49 4E 44 4D 2983*  			DB	"IND","M"+80H,8AH
       8A          
041EC1 4F 54 44 4D 2984*  			DB	"OTD","M"+80H,8BH
       8B          
041EC6 49 4E 44 32 2985*  			DB	"IND","2"+80H,8CH
       8C          
041ECB 49 4E 49 4D 2986*  			DB	"INIM","R"+80H,92H
       52 92       
041ED1 4F 54 49 4D 2987*  			DB	"OTIM","R"+80H,93H
       52 93       
041ED7 49 4E 49 32 2988*  			DB	"INI2","R"+80H,94H
       52 94       
041EDD 49 4E 44 4D 2989*  			DB	"INDM","R"+80H,9AH
       52 9A       
041EE3 4F 54 44 4D 2990*  			DB	"OTDM","R"+80H,9BH
       52 9B       
041EE9 49 4E 44 32 2991*  			DB	"IND2","R"+80H,9CH
       52 9C       
041EEF 4C 44 49 A0 2992*  			DB	"LD","I"+80H,A0H
041EF3 43 50 49 A1 2993*  			DB	"CP","I"+80H,A1H
041EF7 49 4E 49 A2 2994*  			DB	"IN","I"+80H,A2H
041EFB 4F 55 54 49 2995*  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041F01 4F 55 54 49 2996*  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041F06 4C 44 44 A8 2997*  			DB	"LD","D"+80H,A8H
041F0A 43 50 44 A9 2998*  			DB	"CP","D"+80H,A9H
041F0E 49 4E 44 AA 2999*  			DB	"IN","D"+80H,AAH
041F12 4F 55 54 44 3000*  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041F18 4F 55 54 44 3001*  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
041F1D 4C 44 49 52 3002*  			DB	"LDI","R"+80H,B0H
       B0          
041F22 43 50 49 52 3003*  			DB	"CPI","R"+80H,B1H
       B1          
041F27 49 4E 49 52 3004*  			DB	"INI","R"+80H,B2H
       B2          
041F2C 4F 54 49 52 3005*  			DB	"OTI","R"+80H,B3H
       B3          
041F31 4F 54 49 32 3006*  			DB	"OTI2","R"+80H,B4H
       52 B4       
041F37 4C 44 44 52 3007*  			DB	"LDD","R"+80H,B8H
       B8          
041F3C 43 50 44 52 3008*  			DB	"CPD","R"+80H,B9H
       B9          
041F41 49 4E 44 52 3009*  			DB	"IND","R"+80H,BAH
       BA          
041F46 4F 54 44 52 3010*  			DB	"OTD","R"+80H,BBH
       BB          
041F4B 4F 54 44 32 3011*  			DB	"OTD2","R"+80H,BCH
       52 BC       
041F51 49 4E 49 52 3012*  			DB	"INIR","X"+80H,C2H
       58 C2       
041F57 4F 54 49 52 3013*  			DB	"OTIR","X"+80H,C3H
       58 C3       
041F5D 49 4E 44 52 3014*  			DB	"INDR","X"+80H,CAH
       58 CA       
041F63 4F 54 44 52 3015*  			DB	"OTDR","X"+80H,CBH
       58 CB       
041F69             3016*  ;
041F69             3017*  ; Group 2: (3 opcodes)
041F69             3018*  ;
041F69 42 49 54 40 3019*  			DB	"BI","T"+80H,40H	; 44h
041F6D 52 45 53 80 3020*  			DB	"RE","S"+80H,80H
041F71 53 45 54 C0 3021*  			DB	"SE","T"+80H,C0H
041F75             3022*  ;
041F75             3023*  ; Group 3: (7 opcodes)
041F75             3024*  ;
041F75 52 4C 43 00 3025*  			DB	"RL","C"+80H,00H	; 47h
041F79 52 52 43 08 3026*  			DB	"RR","C"+80H,08H
041F7D 52 4C 10    3027*  			DB	"R","L"+80H,10H
041F80 52 52 18    3028*  			DB	"R","R"+80H,18H
041F83 53 4C 41 20 3029*  			DB	"SL","A"+80H,20H
041F87 53 52 41 28 3030*  			DB	"SR","A"+80H,28H
041F8B 53 52 4C 38 3031*  			DB	"SR","L"+80H,38H
041F8F             3032*  ;
041F8F             3033*  ; Group 4: (3 opcodes)
041F8F             3034*  ;
041F8F 50 4F 50 C1 3035*  			DB	"PO","P"+80H,C1H	; 4Eh
041F93 50 55 53 48 3036*  			DB	"PUS","H"+80H,C5H
       C5          
041F98 45 58 00 28 3037*  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
041F9F             3038*  ;
041F9F             3039*  ; Group 5: (7 opcodes)
041F9F             3040*  ;
041F9F 53 55 42 90 3041*  			DB	"SU","B"+80H,90H	; 51h
041FA3 41 4E 44 A0 3042*  			DB	"AN","D"+80H,A0H
041FA7 58 4F 52 A8 3043*  			DB	"XO","R"+80H,A8H
041FAB 4F 52 B0    3044*  			DB	"O","R"+80H,B0H
041FAE 43 50 B8    3045*  			DB	"C","P"+80H,B8H
041FB1 80 A0       3046*  			DB	TAND,A0H		; 56h TAND: Tokenised AND
041FB3 84 B0       3047*  			DB	TOR,B0H			; 57h TOR: Tokenised OR
041FB5             3048*  ;
041FB5             3049*  ; Group 6 (3 opcodes)
041FB5             3050*  ;
041FB5 41 44 44 80 3051*  			DB	"AD","D"+80H,80H	; 58h
041FB9 41 44 43 88 3052*  			DB	"AD","C"+80H,88H
041FBD 53 42 43 98 3053*  			DB	"SB","C"+80H,98H
041FC1             3054*  ;
041FC1             3055*  ; Group 7: (2 opcodes)
041FC1             3056*  ;
041FC1 49 4E 43 04 3057*  			DB	"IN","C"+80H,04H	; 5Bh
041FC5 44 45 43 05 3058*  			DB	"DE","C"+80H,05H
041FC9             3059*  ;
041FC9             3060*  ; Group 8: (2 opcodes)
041FC9             3061*  ;
041FC9 49 4E 30 00 3062*  			DB	"IN","0"+80H,00H	; 5Dh
041FCD 4F 55 54 30 3063*  			DB	"OUT","0"+80H,01H
       01          
041FD2             3064*  ;
041FD2             3065*  ; Group 9: (1 opcode)
041FD2             3066*  ;
041FD2 49 4E 40    3067*  			DB	"I","N"+80H,40H		; 5Fh
041FD5             3068*  ;
041FD5             3069*  ; Group 10: (1 opcode)
041FD5             3070*  ;
041FD5 4F 55 54 41 3071*  			DB	"OU","T"+80H,41H	; 60h
041FD9             3072*  ;
041FD9             3073*  ; Group 11: (2 opcodes)
041FD9             3074*  ;
041FD9 4A 52 20    3075*  			DB	"J","R"+80H,20H		; 61h
041FDC 44 4A 4E 5A 3076*  			DB	"DJN","Z"+80H,10H
       10          
041FE1             3077*  ;
041FE1             3078*  ; Group 12: (1 opcode)
041FE1             3079*  ;
041FE1 4A 50 C2    3080*  			DB	"J","P"+80H,C2H		; 63h
041FE4             3081*  ;
041FE4             3082*  ; Group 13: (1 opcode)
041FE4             3083*  ;
041FE4 43 41 4C 4C 3084*  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041FE9             3085*  ;
041FE9             3086*  ; Group 14: (1 opcode)
041FE9             3087*  ;
041FE9 52 53 54 C7 3088*  			DB	"RS","T"+80H,C7H	; 65h
041FED             3089*  ;
041FED             3090*  ; Group 15: (1 opcode)
041FED             3091*  ;
041FED 52 45 54 C0 3092*  			DB	"RE","T"+80H,C0H	; 66h
041FF1             3093*  ;
041FF1             3094*  ; Group 16: (1 opcode)
041FF1             3095*  ;
041FF1 4C 44 40    3096*  			DB	"L","D"+80H,40H		; 67h
041FF4             3097*  ;
041FF4             3098*  ; Group 17: (1 opcode)
041FF4             3099*  ;
041FF4 54 53 54 04 3100*  			DB	"TS","T"+80H,04H	; 68h
041FF8             3101*  
041FF8             3102*  ;
041FF8             3103*  ; Assembler Directives
041FF8             3104*  ;
041FF8 4F 50 54 00 3105*  			DB	"OP","T"+80H,00H	; 69h OPT
041FFC 41 44 4C 00 3106*  			DB	"AD","L"+80H,00H	; 6Ah ADL
042000             3107*  ;
042000 5D 42 00    3108*  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
042003 5D 57 00    3109*  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042006 5D 4C 00    3110*  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042009 5D 4D 00    3111*  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
04200C             3112*  ;
04200C 00          3113*  			DB	0
04200D             3114*  ;
04200D             3115*  ; Operands
04200D             3116*  ;
04200D 42 00       3117*  OPRNDS:			DB	"B"+80H, 00H
04200F 43 01       3118*  			DB	"C"+80H, 01H
042011 44 02       3119*  			DB	"D"+80H, 02H
042013 45 03       3120*  			DB	"E"+80H, 03H
042015 48 04       3121*  			DB	"H"+80H, 04H
042017 4C 05       3122*  			DB	"L"+80H, 05H
042019 28 48 4C 06 3123*  			DB	"(H","L"+80H,06H
04201D 41 07       3124*  			DB	"A"+80H, 07H
04201F 28 49 58 86 3125*  			DB	"(I","X"+80H,86H
042023 28 49 59 C6 3126*  			DB	"(I","Y"+80H,C6H
042027             3127*  ;
042027 42 43 08    3128*  			DB	"B","C"+80H,08H
04202A 44 45 0A    3129*  			DB	"D","E"+80H,0AH
04202D 48 4C 0C    3130*  			DB	"H","L"+80H,0CH
042030 49 58 8C    3131*  			DB	"I","X"+80H,8CH
042033 49 59 CC    3132*  			DB	"I","Y"+80H,CCH
042036 41 46 0E    3133*  			DB	"A","F"+80H,0EH
042039 53 50 0E    3134*  			DB	"S","P"+80H,0EH
04203C             3135*  ;
04203C 4E 5A 10    3136*  			DB	"N","Z"+80H,10H
04203F 5A 11       3137*  			DB	"Z"+80H,11H
042041 4E 43 12    3138*  			DB	"N","C"+80H,12H
042044 50 4F 14    3139*  			DB	"P","O"+80H,14H
042047 50 45 15    3140*  			DB	"P","E"+80H,15H
04204A 50 16       3141*  			DB	"P"+80H,16H
04204C 4D 17       3142*  			DB	"M"+80H,17H
04204E             3143*  ;
04204E 28 43 20    3144*  			DB	"(","C"+80H,20H
042051             3145*  ;
042051 00          3146*  			DB	0
042052             3147*  ;
042052             3148*  ; Load operations
042052             3149*  ;
042052 49 00 41 47 3150*  LDOPS:			DB	"I",0,"A"+80H,47H
042056 52 00 41 4F 3151*  			DB	"R",0,"A"+80H,4FH
04205A 41 00 49 57 3152*  			DB	"A",0,"I"+80H,57H
04205E 41 00 52 5F 3153*  			DB	"A",0,"R"+80H,5FH
042062 28 42 43 00 3154*  			DB	"(BC",0,"A"+80H,02h
       41 02       
042068 28 44 45 00 3155*  			DB	"(DE",0,"A"+80H,12H
       41 12       
04206E 41 00 28 42 3156*  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
042074 41 00 28 44 3157*  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
04207A             3158*  ;
04207A 00          3159*  			DB	0
04207B             3160*  ;
04207B             3161*  ; eZ80 addressing mode suffixes
04207B             3162*  ;
04207B             3163*  ; Fully qualified suffixes
04207B             3164*  ;
04207B 4C 49 53 49 3165*  EZ80SFS_1:		DB	"LI","S"+80H,49H
04207F 53 49 4C 52 3166*  			DB	"SI","L"+80H,52H
042083 53 49 53 40 3167*  EZ80SFS_2:		DB	"SI","S"+80H,40H
042087 4C 49 4C 5B 3168*  			DB	"LI","L"+80H,5BH
04208B             3169*  ;
04208B 00          3170*  			DB	0
04208C             3171*  ;
04208C             3172*  ; Shortcuts when ADL mode is 0
04208C             3173*  ;
04208C 53 40       3174*  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
04208E 4C 49       3175*  			DB	"L"+80H,49H		; Equivalent to .LIS
042090 49 53 40    3176*  			DB	"I","S"+80H,40H		; Equivalent to .SIS
042093 49 4C 52    3177*  			DB	"I","L"+80H,52H		; Equivalent to .SIL
042096             3178*  ;
042096 00          3179*  			DB	0
042097             3180*  ;
042097             3181*  ; Shortcuts when ADL mode is 1
042097             3182*  ;
042097 53 52       3183*  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042099 4C 5B       3184*  			DB	"L"+80H,5BH		; Equivalent to .LIL
04209B 49 53 49    3185*  			DB	"I","S"+80H,49H		; Equivalent to .LIS
04209E 49 4C 5B    3186*  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0420A1             3187*  ;
0420A1 00          3188*  			DB	0
0420A2             3189*  ;
0420A2             3190*  ; .LIST
0420A2             3191*  ;
0420A2             3192*  ; already defined in equs.inc
0420A2             3193*  ; LF:			EQU     0AH
0420A2             3194*  ; CR:			EQU     0DH
0420A2             0008       include "fpp.asm"
0420A2             0001*  ;
0420A2             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0420A2             0003*  ;		Z80 Floating Point Package
0420A2             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
0420A2             0005*  ; Modified By:	Dean Belfield
0420A2             0006*  ; Created:	03/05/2022
0420A2             0007*  ; Last Updated:	07/06/2023
0420A2             0008*  ;
0420A2             0009*  ; Modinfo:
0420A2             0010*  ; 26/10/1986:	Version 0.0
0420A2             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0420A2             0012*  ; 12/05/2023:	Modified by Dean Belfield
0420A2             0013*  ; 07/06/2023:	Modified to run in ADL mode
0420A2             0014*  
0420A2             0015*  			; .ASSUME	ADL = 1
0420A2             0016*  
0420A2             0017*  			; SEGMENT CODE
0420A2             0018*  
0420A2             0019*  			; XDEF	FPP
0420A2             0020*  			; XDEF	DLOAD5
0420A2             0021*  			; XDEF	DLOAD5_SPL
0420A2             0022*  ;
0420A2             0023*  ;BINARY FLOATING POINT REPRESENTATION:
0420A2             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0420A2             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0420A2             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0420A2             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0420A2             0028*  ;
0420A2             0029*  ;BINARY INTEGER REPRESENTATION:
0420A2             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0420A2             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0420A2             0032*  ;
0420A2             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0420A2             0034*  ;                            EXPONENT - C
0420A2             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0420A2             0036*  ;                               EXPONENT - B
0420A2             0037*  
0420A2             0038*  ;
0420A2             0039*  ;Error codes:
0420A2             0040*  ;
0420A2             0041*  
0420A2             0042*  ; BADOP:			EQU     1               ;Bad operation code
0420A2             0043*  ; DIVBY0:			EQU     18              ;Division by zero
0420A2             0044*  ; TOOBIG_FP:			EQU     20              ;Too big
0420A2             0045*  ; NGROOT:			EQU     21              ;Negative root
0420A2             0046*  ; LOGRNG:			EQU     22              ;Log range
0420A2             0047*  ; ACLOST:			EQU     23              ;Accuracy lost
0420A2             0048*  ; EXPRNG:			EQU     24              ;Exp range
0420A2             0049*  ;
0420A2             0050*  ;Call entry and despatch code:
0420A2             0051*  ;
0420A2 FD E5       0052*  FPP:			PUSH    IY              ;Save IY
0420A4 FD 21 00 00 0053*          		LD      IY,0
       00          
0420A9 FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
0420AB CD BB 20 04 0055*          		CALL    OP              ;Perform operation
0420AF BF          0056*          		CP      A               ;Good return (Z, NC)
0420B0 FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
0420B2 C9          0058*          		RET                     ;Return to caller
0420B3             0059*  ;
0420B3             0060*  ;Error exit:
0420B3             0061*  ;
0420B3 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0420B5 FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0420B7 B7          0064*          		OR      A               ;Set NZ
0420B8 37          0065*          		SCF                     ;Set C
0420B9 18 F5       0066*          		JR      EXIT_FP_
0420BB             0067*  ;
0420BB             0068*  ;Perform operation or function:
0420BB             0069*  ;
0420BB             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
0420BB FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0420BD             0072*  
0420BD 30 F4       0073*          		JR      NC,BAD_FP
0420BF             0074*          		; CP      (FTABLE-DTABLE)/3
0420BF FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
0420C1 30 08       0076*          		JR      NC,DISPAT_FP
0420C3 08          0077*          		EX      AF,AF'
0420C4 78          0078*          		LD      A,B
0420C5 B1          0079*          		OR      C               ;Both integer?
0420C6 C4 CE 2B 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
0420CA 08          0081*          		EX      AF,AF'
0420CB E5          0082*  DISPAT_FP:			PUSH    HL
0420CC 21 DE 20 04 0083*          		LD      HL,DTABLE
0420D0 C5          0084*          		PUSH    BC
0420D1 01 03 00 00 0085*  			LD	BC, 3		; C = 3
0420D5 47          0086*  			LD	B, A 		; B = op-code
0420D6 ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
0420D8 09          0088*  			ADD	HL, BC 		;Add to table base
0420D9 ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
0420DB             0090*  
0420DB             0091*  ;        		ADD     A, A            ;A = op-code * 2
0420DB             0092*  ;        		LD      C,A
0420DB             0093*  ;        		LD      B,0             ;BC = op-code * 2
0420DB             0094*  ;        		ADD     HL,BC
0420DB             0095*  ;        		LD      A,(HL)          ;Get low byte
0420DB             0096*  ;        		INC     HL
0420DB             0097*  ;        		LD      H,(HL)          ;Get high byte
0420DB             0098*  ;        		LD      L,A
0420DB             0099*  
0420DB C1          0100*          		POP     BC
0420DC E3          0101*          		EX      (SP),HL
0420DD C9          0102*          		RET                     ;Off to routine
0420DE             0103*  ;
0420DE             0104*  ;Despatch table:
0420DE             0105*  ;
0420DE 90 21 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
0420E1 FE 21 04    0107*          		DW24  IBDIV           ;DIV
0420E4 A3 21 04    0108*          		DW24  IEOR            ;EOR
0420E7 C9 21 04    0109*          		DW24  IMOD            ;MOD
0420EA B6 21 04    0110*          		DW24  IOR             ;OR
0420ED 84 24 04    0111*          		DW24  ILE             ;<=
0420F0 93 24 04    0112*          		DW24  INE             ;<>
0420F3 77 24 04    0113*          		DW24  IGE             ;>=
0420F6 5C 24 04    0114*          		DW24  ILT             ;<
0420F9 A0 24 04    0115*          		DW24  IEQ             ;=
0420FC EC 22 04    0116*          		DW24  IMUL            ;*
0420FF 27 22 04    0117*          		DW24  IADD            ;+
042102 69 24 04    0118*          		DW24  IGT             ;>
042105 0E 22 04    0119*          		DW24  ISUB            ;-
042108 A3 23 04    0120*          		DW24  IPOW            ;^
04210B 99 22 04    0121*          		DW24  IDIV            ;/
04210E             0122*  ;
04210E             0123*  FTABLE:
04210E B2 24 04    0124*  				DW24  ABSV_FP            ;ABS
042111 98 28 04    0125*          		DW24  ACS_FP             ;ACS
042114 D6 27 04    0126*          		DW24  ASN_FP             ;ASN
042117 06 28 04    0127*          		DW24  ATN_FP             ;ATN
04211A D1 25 04    0128*          		DW24  COS_FP             ;COS
04211D E0 24 04    0129*          		DW24  DEG_FP             ;DEG
042120 8D 26 04    0130*          		DW24  EXP_FP             ;EXP
042123 34 25 04    0131*          		DW24  INT_FP_            ;INT
042126 2B 27 04    0132*          		DW24  LN_FP              ;LN
042129 C0 27 04    0133*          		DW24  LOG_FP             ;LOG
04212C BE 24 04    0134*          		DW24  NOTK_FP            ;NOT
04212F EA 24 04    0135*          		DW24  RAD_FP             ;RAD
042132 05 25 04    0136*          		DW24  SGN_FP             ;SGN
042135 DE 25 04    0137*          		DW24  SIN_FP             ;SIN
042138 4D 25 04    0138*          		DW24  SQR_FP             ;SQR
04213B AB 25 04    0139*          		DW24  TAN_FP             ;TAN
04213E             0140*  ;
04213E 5B 2C 04    0141*  		        DW24  ZERO_FP            ;ZERO
042141 66 26 04    0142*          		DW24  FONE_FP            ;FONE
042144 A5 24 04    0143*          		DW24  TRUE_FP            ;TRUE
042147 D2 24 04    0144*          		DW24  PI_FP              ;PI
04214A             0145*  ;
04214A 19 25 04    0146*  		        DW24  VAL_FP             ;VAL
04214D A1 28 04    0147*          		DW24  STR_FP             ;STR$
042150             0148*  ;
042150 02 2B 04    0149*          		DW24  SFIX_FP            ;FIX
042153 DE 2B 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
042156             0151*  ;
042156 2C 2C 04    0152*  		        DW24  FTEST_FP           ;TEST
042159 3E 2C 04    0153*          		DW24  FCOMP_FP           ;COMPARE
04215C             0154*  ;
04215C 8C 21 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04215F FA 21 04    0156*          		DW24  FBDIV           ;DIV
042162 9F 21 04    0157*          		DW24  FEOR            ;EOR
042165 C5 21 04    0158*          		DW24  FMOD            ;MOD
042168 B2 21 04    0159*          		DW24  FFOR             ;OR
04216B 7E 24 04    0160*          		DW24  FLE             ;<=
04216E 8D 24 04    0161*          		DW24  FNE             ;<>
042171 71 24 04    0162*          		DW24  FGE             ;>=
042174 56 24 04    0163*          		DW24  FLT             ;<
042177 9A 24 04    0164*          		DW24  FEQ             ;=
04217A 46 23 04    0165*          		DW24  FMUL            ;*
04217D 34 22 04    0166*          		DW24  FADD            ;+
042180 63 24 04    0167*          		DW24  FGT             ;>
042183 1B 22 04    0168*          		DW24  FSUB            ;-
042186 23 24 04    0169*          		DW24  FPOW            ;^
042189 9D 22 04    0170*          		DW24  FDIV            ;/
04218C             0171*  ;
04218C             0172*  ;       PAGE
04218C             0173*  ;
04218C             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
04218C             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
04218C             0176*  ;Output in HLH'L'C
04218C             0177*  ;All registers except IX, IY destroyed.
04218C             0178*  ; (N.B. FPOW destroys IX).
04218C             0179*  ;
04218C             0180*  ;FAND - Floating-point AND.
04218C             0181*  ;IAND - Integer AND.
04218C             0182*  ;
04218C CD F6 2A 04 0183*  FAND:			CALL    FIX2
042190 7C          0184*  IAND:			LD      A,H
042191 A2          0185*          		AND     D
042192 67          0186*          		LD      H,A
042193 7D          0187*          		LD      A,L
042194 A3          0188*          		AND     E
042195 6F          0189*          		LD      L,A
042196 D9          0190*          		EXX
042197 7C          0191*          		LD      A,H
042198 A2          0192*          		AND     D
042199 67          0193*          		LD      H,A
04219A 7D          0194*          		LD      A,L
04219B A3          0195*          		AND     E
04219C 6F          0196*          		LD      L,A
04219D D9          0197*          		EXX
04219E C9          0198*          		RET
04219F             0199*  ;
04219F             0200*  ;FEOR - Floating-point exclusive-OR.
04219F             0201*  ;IEOR - Integer exclusive-OR.
04219F             0202*  ;
04219F CD F6 2A 04 0203*  FEOR:			CALL    FIX2
0421A3 7C          0204*  IEOR:			LD      A,H
0421A4 AA          0205*          		XOR     D
0421A5 67          0206*          		LD      H,A
0421A6 7D          0207*          		LD      A,L
0421A7 AB          0208*          		XOR     E
0421A8 6F          0209*          		LD      L,A
0421A9 D9          0210*          		EXX
0421AA 7C          0211*          		LD      A,H
0421AB AA          0212*          		XOR     D
0421AC 67          0213*          		LD      H,A
0421AD 7D          0214*          		LD      A,L
0421AE AB          0215*          		XOR     E
0421AF 6F          0216*          		LD      L,A
0421B0 D9          0217*          		EXX
0421B1 C9          0218*          		RET
0421B2             0219*  ;
0421B2             0220*  ;FFOR - Floating-point OR.
0421B2             0221*  ;IOR - Integer OR.
0421B2             0222*  ;
0421B2 CD F6 2A 04 0223*  FFOR:			CALL    FIX2
0421B6 7C          0224*  IOR:			LD      A,H
0421B7 B2          0225*          		OR      D
0421B8 67          0226*          		LD      H,A
0421B9 7D          0227*          		LD      A,L
0421BA B3          0228*          		OR      E
0421BB 6F          0229*          		LD      L,A
0421BC D9          0230*          		EXX
0421BD 7C          0231*          		LD      A,H
0421BE B2          0232*          		OR      D
0421BF 67          0233*          		LD      H,A
0421C0 7D          0234*          		LD      A,L
0421C1 B3          0235*          		OR      E
0421C2 6F          0236*          		LD      L,A
0421C3 D9          0237*          		EXX
0421C4 C9          0238*          		RET
0421C5             0239*  ;
0421C5             0240*  ;FMOD - Floating-point remainder.
0421C5             0241*  ;IMOD - Integer remainder.
0421C5             0242*  ;
0421C5 CD F6 2A 04 0243*  FMOD:			CALL    FIX2
0421C9 7C          0244*  IMOD:			LD      A,H
0421CA AA          0245*          		XOR     D               ;DIV RESULT SIGN
0421CB CB 7C       0246*          		BIT     7,H
0421CD 08          0247*          		EX      AF,AF'
0421CE CB 7C       0248*          		BIT     7,H
0421D0 C4 12 2B 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0421D4 CD 0F 2C 04 0250*          		CALL    SWAP_FP
0421D8 CB 7C       0251*          		BIT     7,H
0421DA C4 12 2B 04 0252*          		CALL    NZ,NEGATE
0421DE 44          0253*          		LD      B,H
0421DF 4D          0254*          		LD      C,L
0421E0 21 00 00 00 0255*          		LD      HL,0
0421E4 D9          0256*          		EXX
0421E5 44          0257*          		LD      B,H
0421E6 4D          0258*          		LD      C,L
0421E7 21 00 00 00 0259*          		LD      HL,0
0421EB 3E DF       0260*          		LD      A,-33
0421ED CD 9C 2D 04 0261*          		CALL    DIVA            ;DIVIDE
0421F1 D9          0262*          		EXX
0421F2 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
0421F4 08          0264*          		EX      AF,AF'
0421F5 C8          0265*          		RET     Z
0421F6 C3 12 2B 04 0266*          		JP      NEGATE
0421FA             0267*  ;
0421FA             0268*  ;BDIV - Integer division.
0421FA             0269*  ;
0421FA CD F6 2A 04 0270*  FBDIV:			CALL    FIX2
0421FE CD C9 21 04 0271*  IBDIV:			CALL    IMOD
042202 B7          0272*          		OR      A
042203 CD 0F 2C 04 0273*          		CALL    SWAP_FP
042207 0E 00       0274*          		LD      C,0
042209 F0          0275*          		RET     P
04220A C3 12 2B 04 0276*          		JP      NEGATE
04220E             0277*  ;
04220E             0278*  ;ISUB - Integer subtraction.
04220E             0279*  ;FSUB - Floating point subtraction with rounding.
04220E             0280*  ;
04220E CD AA 2C 04 0281*  ISUB:			CALL    SUB_
042212 E0          0282*          		RET     PO
042213 CD A2 2C 04 0283*          		CALL    ADD_
042217 CD D2 2B 04 0284*          		CALL    FLOAT2
04221B 7A          0285*  FSUB:			LD      A,D
04221C EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
04221E 57          0287*          		LD      D,A
04221F 18 13       0288*          		JR      FADD
042221             0289*  ;
042221             0290*  ;Reverse subtract.
042221             0291*  ;
042221 7C          0292*  RSUB:			LD      A,H
042222 EE 80       0293*          		XOR     80H
042224 67          0294*          		LD      H,A
042225 18 0D       0295*          		JR      FADD
042227             0296*  ;
042227             0297*  ;IADD - Integer addition.
042227             0298*  ;FADD - Floating point addition with rounding.
042227             0299*  ;
042227 CD A2 2C 04 0300*  IADD:			CALL    ADD_
04222B E0          0301*          		RET     PO
04222C CD AA 2C 04 0302*          		CALL    SUB_
042230 CD D2 2B 04 0303*          		CALL    FLOAT2
042234 05          0304*  FADD:			DEC     B
042235 04          0305*          		INC     B
042236 C8          0306*          		RET     Z               ;ARG 2 ZERO
042237 0D          0307*          		DEC     C
042238 0C          0308*          		INC     C
042239 CA 0F 2C 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
04223D D9          0310*          		EXX
04223E 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
042242 D9          0312*          		EXX
042243 7C          0313*          		LD      A,H
042244 AA          0314*          		XOR     D               ;XOR SIGNS
042245 F5          0315*          		PUSH    AF
042246 78          0316*          		LD      A,B
042247 B9          0317*          		CP      C               ;COMPARE EXPONENTS
042248 DC 0F 2C 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
04224C 78          0319*          		LD      A,B
04224D CB FC       0320*          		SET     7,H             ;IMPLIED 1
04224F C4 E3 2A 04 0321*          		CALL    NZ,FIX          ;ALIGN
042253 F1          0322*          		POP     AF
042254 7A          0323*          		LD      A,D             ;SIGN OF LARGER
042255 CB FA       0324*          		SET     7,D             ;IMPLIED 1
042257 FA 67 22 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
04225B CD A2 2C 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04225F DC 17 2C 04 0327*          		CALL    C,DIV2          ;NORMALISE
042263 CB FC       0328*          		SET     7,H
042265 18 0D       0329*          		JR      FADD4
042267             0330*  ;
042267 CD AA 2C 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
04226B DC 2A 2B 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04226F CD A9 2B 04 0333*          		CALL    FLO48
042273 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
042274 D9          0335*  FADD4:			EXX
042275 EB          0336*          		EX      DE,HL
042276 21 00 80 00 0337*          		LD      HL,8000H
04227A B7          0338*          		OR      A               ;CLEAR CARRY
04227B 52 ED 42    0339*          		SBC.S   HL,BC
04227E EB          0340*          		EX      DE,HL
04227F D9          0341*          		EXX
042280 CC 09 2C 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
042284 DC F7 2B 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
042288 DC 24 2C 04 0344*          		CALL    C,INCC
04228C CB BC       0345*          		RES     7,H
04228E 0D          0346*          		DEC     C
04228F 0C          0347*          		INC     C
042290 CA 5B 2C 04 0348*          		JP      Z,ZERO_FP
042294 B7          0349*          		OR      A               ;RESULT SIGNQ
042295 F0          0350*          		RET     P               ;POSITIVE
042296 CB FC       0351*          		SET     7,H             ;NEGATIVE
042298 C9          0352*          		RET
042299             0353*  ;
042299             0354*  ;IDIV - Integer division.
042299             0355*  ;FDIV - Floating point division with rounding.
042299             0356*  ;
042299 CD D2 2B 04 0357*  IDIV:			CALL    FLOAT2
04229D 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
04229E 04          0359*          		INC     B
04229F 3E 12       0360*          		LD      A,DIVBY0
0422A1 CA B5 20 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
0422A5 0D          0362*          		DEC     C               ;TEST FOR ZERO
0422A6 0C          0363*          		INC     C
0422A7 C8          0364*          		RET     Z
0422A8 7C          0365*          		LD      A,H
0422A9 AA          0366*          		XOR     D               ;CALC. RESULT SIGN
0422AA 08          0367*          		EX      AF,AF'          ;SAVE SIGN
0422AB CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
0422AD CB FC       0369*          		SET     7,H
0422AF C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
0422B0 42          0371*          		LD      B,D             ;LOAD REGISTERS
0422B1 4B          0372*          		LD      C,E
0422B2 11 00 00 00 0373*          		LD      DE,0
0422B6 D9          0374*          		EXX
0422B7 42          0375*          		LD      B,D
0422B8 4B          0376*          		LD      C,E
0422B9 11 00 00 00 0377*          		LD      DE,0
0422BD 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
0422BF CD 9C 2D 04 0379*          		CALL    DIVA            ;DIVIDE
0422C3 D9          0380*          		EXX
0422C4 CB 7A       0381*          		BIT     7,D
0422C6 D9          0382*          		EXX
0422C7 CC BB 2D 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
0422CB EB          0384*          		EX      DE,HL
0422CC D9          0385*          		EXX
0422CD CB 38       0386*          		SRL     B               ;DIVISOR/2
0422CF CB 19       0387*          		RR      C
0422D1 B7          0388*          		OR      A               ;CLEAR CARRY
0422D2 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0422D5 3F          0390*          		CCF
0422D6 EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
0422D7 CC 09 2C 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
0422DB DC F7 2B 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
0422DF C1          0394*          		POP     BC              ;RESTORE EXPONENTS
0422E0 DC 24 2C 04 0395*          		CALL    C,INCC
0422E4 1F          0396*          		RRA                     ;LSB OF A TO CARRY
0422E5 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
0422E6 98          0398*          		SBC     A,B
0422E7 3F          0399*          		CCF
0422E8 C3 89 23 04 0400*          		JP      CHKOVF
0422EC             0401*  ;
0422EC             0402*  ;IMUL - Integer multiplication.
0422EC             0403*  ;
0422EC 7C          0404*  IMUL:			LD      A,H
0422ED AA          0405*          		XOR     D
0422EE 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
0422EF CB 7C       0407*          		BIT     7,H
0422F1 C4 12 2B 04 0408*          		CALL    NZ,NEGATE
0422F5 CD 0F 2C 04 0409*          		CALL    SWAP_FP
0422F9 CB 7C       0410*          		BIT     7,H
0422FB C4 12 2B 04 0411*          		CALL    NZ,NEGATE
0422FF 44          0412*          		LD      B,H
042300 4D          0413*          		LD      C,L
042301 21 00 00 00 0414*          		LD      HL,0
042305 D9          0415*          		EXX
042306 44          0416*          		LD      B,H
042307 4D          0417*          		LD      C,L
042308 21 00 00 00 0418*          		LD      HL,0
04230C 3E DF       0419*          		LD      A,-33
04230E CD D3 2D 04 0420*          		CALL    MULA            ;MULTIPLY
042312 D9          0421*          		EXX
042313 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
042315 CD 37 2C 04 0423*          		CALL    TEST_FP            ;TEST RANGE
042319 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
04231B CB 7A       0425*          		BIT     7,D
04231D 20 0B       0426*          		JR      NZ,IMUL1
04231F CD 0F 2C 04 0427*          		CALL    SWAP_FP
042323 4A          0428*          		LD      C,D             ;INTEGER MARKER
042324 08          0429*          		EX      AF,AF'
042325 F0          0430*          		RET     P
042326 C3 12 2B 04 0431*          		JP      NEGATE
04232A             0432*  ;
04232A 0D          0433*  IMUL1:			DEC     C
04232B D9          0434*          		EXX
04232C CB 23       0435*          		SLA     E
04232E CB 12       0436*          		RL      D
042330 D9          0437*          		EXX
042331 CB 13       0438*          		RL      E
042333 CB 12       0439*          		RL      D
042335 D9          0440*          		EXX
042336 52 ED 6A    0441*          		ADC.S   HL,HL
042339 D9          0442*          		EXX
04233A 52 ED 6A    0443*          		ADC.S   HL,HL
04233D F2 2A 23 04 0444*          		JP      P,IMUL1         ;NORMALISE
042341 08          0445*          		EX      AF,AF'
042342 F8          0446*          		RET     M
042343 CB BC       0447*          		RES     7,H             ;POSITIVE
042345 C9          0448*          		RET
042346             0449*  ;
042346             0450*  ;FMUL - Floating point multiplication with rounding.
042346             0451*  ;
042346 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
042347 04          0453*          		INC     B
042348 CA 5B 2C 04 0454*          		JP      Z,ZERO_FP
04234C 0D          0455*          		DEC     C               ;TEST FOR ZERO
04234D 0C          0456*          		INC     C
04234E C8          0457*          		RET     Z
04234F 7C          0458*          		LD      A,H
042350 AA          0459*          		XOR     D               ;CALC. RESULT SIGN
042351 08          0460*          		EX      AF,AF'
042352 CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
042354 CB FC       0462*          		SET     7,H
042356 C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
042357 44          0464*          		LD      B,H             ;LOAD REGISTERS
042358 4D          0465*          		LD      C,L
042359 21 00 00 00 0466*          		LD      HL,0
04235D D9          0467*          		EXX
04235E 44          0468*          		LD      B,H
04235F 4D          0469*          		LD      C,L
042360 21 00 00 00 0470*          		LD      HL,0
042364 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
042366 CD D3 2D 04 0472*          		CALL    MULA            ;MULTIPLY
04236A DC E9 2D 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
04236E D9          0474*          		EXX
04236F E5          0475*          		PUSH    HL
042370 21 00 80 00 0476*          		LD      HL,8000H
042374 B7          0477*          		OR      A               ;CLEAR CARRY
042375 52 ED 52    0478*          		SBC.S   HL,DE
042378 E1          0479*          		POP     HL
042379 CC 09 2C 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
04237D DC F7 2B 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
042381 C1          0482*          		POP     BC              ;RESTORE EXPONENTS
042382 DC 24 2C 04 0483*          		CALL    C,INCC
042386 1F          0484*          		RRA                     ;LSB OF A TO CARRY
042387 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
042388 88          0486*          		ADC     A,B
042389 38 06       0487*  CHKOVF:			JR      C,CHKO1
04238B F2 5B 2C 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
04238F 18 04       0489*          		JR      CHKO2
042391 FA 26 2C 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
042395 C6 80       0491*  CHKO2:			ADD     A,80H
042397 4F          0492*          		LD      C,A
042398 CA 5B 2C 04 0493*          		JP      Z,ZERO_FP
04239C 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
04239D CB BC       0495*          		RES     7,H
04239F F0          0496*          		RET     P
0423A0 CB FC       0497*          		SET     7,H
0423A2 C9          0498*          		RET
0423A3             0499*  ;
0423A3             0500*  ;IPOW - Integer involution.
0423A3             0501*  ;
0423A3 CD 0F 2C 04 0502*  IPOW:			CALL    SWAP_FP
0423A7 CB 7C       0503*          		BIT     7,H
0423A9 F5          0504*          		PUSH    AF              ;SAVE SIGN
0423AA C4 12 2B 04 0505*          		CALL    NZ,NEGATE
0423AE 48          0506*  IPOW0:			LD      C,B
0423AF 06 20       0507*          		LD      B,32            ;LOOP COUNTER
0423B1 CD C7 2C 04 0508*  IPOW1:			CALL    X2
0423B5 38 08       0509*          		JR      C,IPOW2
0423B7 10 F8       0510*          		DJNZ    IPOW1
0423B9 F1          0511*          		POP     AF
0423BA D9          0512*          		EXX
0423BB 2C          0513*          		INC     L               ;RESULT=1
0423BC D9          0514*          		EXX
0423BD 4C          0515*          		LD      C,H
0423BE C9          0516*          		RET
0423BF             0517*  ;
0423BF F1          0518*  IPOW2:			POP     AF
0423C0 C5          0519*          		PUSH    BC
0423C1 EB          0520*          		EX      DE,HL
0423C2 E5          0521*          		PUSH    HL
0423C3 D9          0522*          		EXX
0423C4 EB          0523*          		EX      DE,HL
0423C5 E5          0524*          		PUSH    HL
0423C6 D9          0525*          		EXX
0423C7 DD 21 00 00 0526*          		LD      IX,0
       00          
0423CC DD 39       0527*          		ADD     IX,SP
0423CE 28 48       0528*          		JR      Z,IPOW4
0423D0 C5          0529*          		PUSH    BC
0423D1 D9          0530*          		EXX
0423D2 D5          0531*          		PUSH    DE
0423D3 D9          0532*          		EXX
0423D4 D5          0533*          		PUSH    DE
0423D5 CD DE 2B 04 0534*          		CALL    SFLOAT_FP
0423D9 CD 12 27 04 0535*          		CALL    RECIP
0423DD DD 71 04    0536*          		LD      (IX+4),C
0423E0 D9          0537*          		EXX
0423E1 DD 75 00    0538*          		LD      (IX+0),L
0423E4 DD 74 01    0539*          		LD      (IX+1),H
0423E7 D9          0540*          		EXX
0423E8 DD 75 02    0541*          		LD      (IX+2),L
0423EB DD 74 03    0542*          		LD      (IX+3),H
0423EE 18 21       0543*          		JR      IPOW5
0423F0             0544*  ;
0423F0 C5          0545*  IPOW3:			PUSH    BC
0423F1 D9          0546*          		EXX
0423F2 CB 23       0547*          		SLA     E
0423F4 CB 12       0548*          		RL      D
0423F6 D5          0549*          		PUSH    DE
0423F7 D9          0550*          		EXX
0423F8 CB 13       0551*          		RL      E
0423FA CB 12       0552*          		RL      D
0423FC D5          0553*          		PUSH    DE
0423FD 3E 0A       0554*          		LD      A,'*' & 0FH
0423FF F5          0555*          		PUSH    AF
042400 CD DB 2C 04 0556*          		CALL    COPY_
042404 CD BB 20 04 0557*          		CALL    OP              ;SQUARE
042408 F1          0558*          		POP     AF
042409 CD 07 2A 04 0559*          		CALL    DLOAD5
04240D DC BB 20 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
042411 D1          0561*  IPOW5:			POP     DE
042412 D9          0562*          		EXX
042413 D1          0563*          		POP     DE
042414 D9          0564*          		EXX
042415 79          0565*          		LD      A,C
042416 C1          0566*          		POP     BC
042417 4F          0567*          		LD      C,A
042418 10 D6       0568*  IPOW4:			DJNZ    IPOW3
04241A F1          0569*          		POP     AF
04241B F1          0570*          		POP     AF
04241C F1          0571*          		POP     AF
04241D C9          0572*          		RET
04241E             0573*  ;
04241E F1          0574*  FPOW0:			POP     AF
04241F F1          0575*          		POP     AF
042420 F1          0576*          		POP     AF
042421 18 8B       0577*          		JR      IPOW0
042423             0578*  ;
042423             0579*  ;FPOW - Floating-point involution.
042423             0580*  ;
042423 CB 7A       0581*  FPOW:			BIT     7,D
042425 F5          0582*          		PUSH    AF
042426 CD 0F 2C 04 0583*          		CALL    SWAP_FP
04242A CD EB 2C 04 0584*          		CALL    PUSH5
04242E 0D          0585*          		DEC     C
04242F 0C          0586*          		INC     C
042430 28 EC       0587*          		JR      Z,FPOW0
042432 3E 9E       0588*          		LD      A,158
042434 B9          0589*          		CP      C
042435 38 0A       0590*          		JR      C,FPOW1
042437 3C          0591*          		INC     A
042438 CD E3 2A 04 0592*          		CALL    FIX
04243C 08          0593*          		EX      AF,AF'
04243D F2 1E 24 04 0594*          		JP      P,FPOW0
042441 CD 0F 2C 04 0595*  FPOW1:			CALL    SWAP_FP
042445 CD 2F 27 04 0596*          		CALL    LN0
042449 CD F4 2C 04 0597*          		CALL    POP5
04244D F1          0598*          		POP     AF
04244E CD 46 23 04 0599*          		CALL    FMUL
042452 C3 91 26 04 0600*          		JP      EXP0
042456             0601*  ;
042456             0602*  ;Integer and floating-point compare.
042456             0603*  ;Result is TRUE (-1) or FALSE (0).
042456             0604*  ;
042456 CD 65 2C 04 0605*  FLT:			CALL    FCP
04245A 18 04       0606*          		JR      ILT1
04245C CD 57 2C 04 0607*  ILT:			CALL    ICP
042460 D0          0608*  ILT1:			RET     NC
042461 18 42       0609*          		JR      TRUE_FP
042463             0610*  ;
042463 CD 65 2C 04 0611*  FGT:			CALL    FCP
042467 18 04       0612*          		JR      IGT1
042469 CD 57 2C 04 0613*  IGT:			CALL    ICP
04246D C8          0614*  IGT1:			RET     Z
04246E D8          0615*          		RET     C
04246F 18 34       0616*          		JR      TRUE_FP
042471             0617*  ;
042471 CD 65 2C 04 0618*  FGE:			CALL    FCP
042475 18 04       0619*          		JR      IGE1
042477 CD 57 2C 04 0620*  IGE:			CALL    ICP
04247B D8          0621*  IGE1:			RET     C
04247C 18 27       0622*          		JR      TRUE_FP
04247E             0623*  ;
04247E CD 65 2C 04 0624*  FLE:			CALL    FCP
042482 18 04       0625*          		JR      ILE1
042484 CD 57 2C 04 0626*  ILE:			CALL    ICP
042488 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
04248A D0          0628*          		RET     NC
04248B 18 18       0629*          		JR      TRUE_FP
04248D             0630*  ;
04248D CD 65 2C 04 0631*  FNE:			CALL    FCP
042491 18 04       0632*          		JR      INE1
042493 CD 57 2C 04 0633*  INE:			CALL    ICP
042497 C8          0634*  INE1:			RET     Z
042498 18 0B       0635*          		JR      TRUE_FP
04249A             0636*  ;
04249A CD 65 2C 04 0637*  FEQ:			CALL    FCP
04249E 18 04       0638*          		JR      IEQ1
0424A0 CD 57 2C 04 0639*  IEQ:			CALL    ICP
0424A4 C0          0640*  IEQ1:			RET     NZ
0424A5 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
0424A9 D9          0642*          		EXX
0424AA 21 FF FF FF 0643*          		LD      HL,-1
0424AE D9          0644*          		EXX
0424AF AF          0645*          		XOR     A
0424B0 4F          0646*          		LD      C,A
0424B1 C9          0647*          		RET
0424B2             0648*  ;
0424B2             0649*  ;FUNCTIONS:
0424B2             0650*  ;
0424B2             0651*  ;Result returned in HLH'L'C (floating point)
0424B2             0652*  ;Result returned in HLH'L' (C=0) (integer)
0424B2             0653*  ;All registers except IY destroyed.
0424B2             0654*  ;
0424B2             0655*  ;ABS - Absolute value
0424B2             0656*  ;Result is numeric, variable type.
0424B2             0657*  ;
0424B2 CB 7C       0658*  ABSV_FP:			BIT     7,H
0424B4 C8          0659*          		RET     Z               ;POSITIVE/ZERO
0424B5 0D          0660*          		DEC     C
0424B6 0C          0661*          		INC     C
0424B7 CA 12 2B 04 0662*          		JP      Z,NEGATE        ;INTEGER
0424BB CB BC       0663*          		RES     7,H
0424BD C9          0664*          		RET
0424BE             0665*  ;
0424BE             0666*  ;NOT - Complement integer.
0424BE             0667*  ;Result is integer numeric.
0424BE             0668*  ;
0424BE CD 02 2B 04 0669*  NOTK_FP:			CALL    SFIX_FP
0424C2 7C          0670*          		LD      A,H
0424C3 2F          0671*          		CPL
0424C4 67          0672*          		LD      H,A
0424C5 7D          0673*          		LD      A,L
0424C6 2F          0674*          		CPL
0424C7 6F          0675*          		LD      L,A
0424C8 D9          0676*          		EXX
0424C9 7C          0677*          		LD      A,H
0424CA 2F          0678*          		CPL
0424CB 67          0679*          		LD      H,A
0424CC 7D          0680*          		LD      A,L
0424CD 2F          0681*          		CPL
0424CE 6F          0682*          		LD      L,A
0424CF D9          0683*          		EXX
0424D0 AF          0684*          		XOR     A               ;NUMERIC MARKER
0424D1 C9          0685*          		RET
0424D2             0686*  ;
0424D2             0687*  ;PI - Return PI (3.141592654)
0424D2             0688*  ;Result is floating-point numeric.
0424D2             0689*  ;
0424D2 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
0424D6 D9          0691*          		EXX
0424D7 21 A2 DA 00 0692*          		LD      HL,0DAA2H
0424DB D9          0693*          		EXX
0424DC 0E 81       0694*          		LD      C,81H
0424DE AF          0695*          		XOR     A               ;NUMERIC MARKER
0424DF C9          0696*          		RET
0424E0             0697*  ;
0424E0             0698*  ;DEG - Convert radians to degrees
0424E0             0699*  ;Result is floating-point numeric.
0424E0             0700*  ;
0424E0 CD F4 24 04 0701*  DEG_FP:			CALL    FPI180
0424E4 CD 46 23 04 0702*          		CALL    FMUL
0424E8 AF          0703*          		XOR     A
0424E9 C9          0704*          		RET
0424EA             0705*  ;
0424EA             0706*  ;RAD - Convert degrees to radians
0424EA             0707*  ;Result is floating-point numeric.
0424EA             0708*  ;
0424EA CD F4 24 04 0709*  RAD_FP:			CALL    FPI180
0424EE CD 9D 22 04 0710*          		CALL    FDIV
0424F2 AF          0711*          		XOR     A
0424F3 C9          0712*          		RET
0424F4             0713*  ;
0424F4             0714*  ;180/PI
0424F4             0715*  ;
0424F4 CD DE 2B 04 0716*  FPI180:			CALL    SFLOAT_FP
0424F8 11 2E 65 00 0717*          		LD      DE,652EH
0424FC D9          0718*          		EXX
0424FD 11 D3 E0 00 0719*          		LD      DE,0E0D3H
042501 D9          0720*          		EXX
042502 06 85       0721*          		LD      B,85H
042504 C9          0722*          		RET
042505             0723*  ;
042505             0724*  ;SGN - Return -1, 0 or +1
042505             0725*  ;Result is integer numeric.
042505             0726*  ;
042505 CD 37 2C 04 0727*  SGN_FP:			CALL    TEST_FP
042509 B1          0728*          		OR      C
04250A C8          0729*          		RET     Z               ;ZERO
04250B CB 7C       0730*          		BIT     7,H
04250D C2 A5 24 04 0731*          		JP      NZ,TRUE_FP         ;-1
042511 CD 5B 2C 04 0732*          		CALL    ZERO_FP
042515 C3 F7 2B 04 0733*          		JP      ADD1_FP            ;1
042519             0734*  ;
042519             0735*  ;VAL - Return numeric value of string.
042519             0736*  ;Input: ASCII string at IX
042519             0737*  ;Result is variable type numeric.
042519             0738*  ;
042519 CD 75 2E 04 0739*  VAL_FP:			CALL    SIGNQ
04251D F5          0740*          		PUSH    AF
04251E CD 25 2A 04 0741*          		CALL    CON_FP
042522 F1          0742*          		POP     AF
042523 FE 2D       0743*          		CP      '-'
042525 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
042527 C0          0745*          		RET     NZ
042528 0D          0746*          		DEC     C
042529 0C          0747*          		INC     C
04252A CA 12 2B 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
04252E 7C          0749*          		LD      A,H
04252F EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
042531 67          0751*          		LD      H,A
042532 AF          0752*          		XOR     A
042533 C9          0753*          		RET
042534             0754*  ;
042534             0755*  ;INT - Floor function
042534             0756*  ;Result is integer numeric.
042534             0757*  ;
042534 0D          0758*  INT_FP_:			DEC     C
042535 0C          0759*          		INC     C
042536 C8          0760*          		RET     Z               ;ZERO/INTEGER
042537 3E 9F       0761*          		LD      A,159
042539 44          0762*          		LD      B,H             ;B7=SIGN BIT
04253A CD E3 2A 04 0763*          		CALL    FIX
04253E 08          0764*          		EX      AF,AF'
04253F A0          0765*          		AND     B
042540 FC F7 2B 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
042544 78          0767*          		LD      A,B
042545 B7          0768*          		OR      A
042546 FC 12 2B 04 0769*          		CALL    M,NEGATE
04254A AF          0770*          		XOR     A
04254B 4F          0771*          		LD      C,A
04254C C9          0772*          		RET
04254D             0773*  ;
04254D             0774*  ;SQR - square root
04254D             0775*  ;Result is floating-point numeric.
04254D             0776*  ;
04254D CD DE 2B 04 0777*  SQR_FP:			CALL    SFLOAT_FP
042551 CB 7C       0778*  SQR0:			BIT     7,H
042553 3E 15       0779*          		LD      A,NGROOT
042555 C2 B5 20 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
042559 0D          0781*          		DEC     C
04255A 0C          0782*          		INC     C
04255B C8          0783*          		RET     Z               ;ZERO
04255C CB FC       0784*          		SET     7,H             ;IMPLIED 1
04255E CB 41       0785*          		BIT     0,C
042560 CC 17 2C 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
042564 79          0787*          		LD      A,C
042565 D6 80       0788*          		SUB     80H
042567 CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
042569 C6 80       0790*          		ADD     A,80H
04256B 4F          0791*          		LD      C,A
04256C C5          0792*          		PUSH    BC              ;SAVE EXPONENT
04256D EB          0793*          		EX      DE,HL
04256E 21 00 00 00 0794*          		LD      HL,0
042572 44          0795*          		LD      B,H
042573 4D          0796*          		LD      C,L
042574 D9          0797*          		EXX
042575 EB          0798*          		EX      DE,HL
042576 21 00 00 00 0799*          		LD      HL,0
04257A 44          0800*          		LD      B,H
04257B 4D          0801*          		LD      C,L
04257C 3E E1       0802*          		LD      A,-31
04257E CD 0D 2E 04 0803*          		CALL    SQRA            ;ROOT
042582 D9          0804*          		EXX
042583 CB 78       0805*          		BIT     7,B
042585 D9          0806*          		EXX
042586 CC 0D 2E 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
04258A CD 4E 2E 04 0808*          		CALL    SQRB
04258E B7          0809*          		OR      A               ;CLEAR CARRY
04258F CD BB 2D 04 0810*          		CALL    DIVB
042593 CB 1B       0811*          		RR      E               ;LSB TO CARRY
042595 60          0812*          		LD      H,B
042596 69          0813*          		LD      L,C
042597 D9          0814*          		EXX
042598 60          0815*          		LD      H,B
042599 69          0816*          		LD      L,C
04259A DC F7 2B 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
04259E C1          0818*          		POP     BC              ;RESTORE EXPONENT
04259F DC 24 2C 04 0819*          		CALL    C,INCC
0425A3 1F          0820*          		RRA
0425A4 9F          0821*          		SBC     A,A
0425A5 81          0822*          		ADD     A,C
0425A6 4F          0823*          		LD      C,A
0425A7 CB BC       0824*          		RES     7,H             ;POSITIVE
0425A9 AF          0825*          		XOR     A
0425AA C9          0826*          		RET
0425AB             0827*  ;
0425AB             0828*  ;TAN - Tangent function
0425AB             0829*  ;Result is floating-point numeric.
0425AB             0830*  ;
0425AB CD DE 2B 04 0831*  TAN_FP:			CALL    SFLOAT_FP
0425AF CD EB 2C 04 0832*          		CALL    PUSH5
0425B3 CD D5 25 04 0833*          		CALL    COS0
0425B7 CD F4 2C 04 0834*          		CALL    POP5
0425BB CD EB 2C 04 0835*          		CALL    PUSH5
0425BF CD 0F 2C 04 0836*          		CALL    SWAP_FP
0425C3 CD E2 25 04 0837*          		CALL    SIN0
0425C7 CD F4 2C 04 0838*          		CALL    POP5
0425CB CD 9D 22 04 0839*          		CALL    FDIV
0425CF AF          0840*          		XOR     A               ;NUMERIC MARKER
0425D0 C9          0841*          		RET
0425D1             0842*  ;
0425D1             0843*  ;COS - Cosine function
0425D1             0844*  ;Result is floating-point numeric.
0425D1             0845*  ;
0425D1 CD DE 2B 04 0846*  COS_FP:			CALL    SFLOAT_FP
0425D5 CD 3A 2B 04 0847*  COS0:			CALL    SCALE
0425D9 1C          0848*          		INC     E
0425DA 1C          0849*          		INC     E
0425DB 7B          0850*          		LD      A,E
0425DC 18 10       0851*          		JR      SIN1
0425DE             0852*  ;
0425DE             0853*  ;SIN - Sine function
0425DE             0854*  ;Result is floating-point numeric.
0425DE             0855*  ;
0425DE CD DE 2B 04 0856*  SIN_FP:			CALL    SFLOAT_FP
0425E2 E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
0425E3 CD 3A 2B 04 0858*          		CALL    SCALE
0425E7 F1          0859*          		POP     AF
0425E8 07          0860*          		RLCA
0425E9 07          0861*          		RLCA
0425EA 07          0862*          		RLCA
0425EB E6 04       0863*          		AND     4
0425ED AB          0864*          		XOR     E
0425EE F5          0865*  SIN1:			PUSH    AF              ;OCTANT
0425EF CB BC       0866*          		RES     7,H
0425F1 1F          0867*          		RRA
0425F2 CD 80 26 04 0868*          		CALL    PIBY4
0425F6 DC 21 22 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
0425FA F1          0870*          		POP     AF
0425FB F5          0871*          		PUSH    AF
0425FC E6 03       0872*          		AND     3
0425FE E2 37 26 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
042602 CD EB 2C 04 0874*          		CALL    PUSH5           ;SAVE X
042606 CD E3 2C 04 0875*          		CALL    SQUARE          ;PUSH X*X
04260A CD 28 2D 04 0876*          		CALL    POLY
04260E B7 A8       0877*          		DW	0A8B7H          ;a(8)
042610 11 36       0878*          		DW	3611H
042612 6D          0879*          		DB	6DH
042613 26 DE       0880*          		DW	0DE26H          ;a(6)
042615 05 D0       0881*          		DW	0D005H
042617 73          0882*          		DB	73H
042618 C0 80       0883*          		DW	80C0H           ;a(4)
04261A 88 08       0884*          		DW	888H
04261C 79          0885*          		DB	79H
04261D 9D AA       0886*          		DW	0AA9DH          ;a(2)
04261F AA AA       0887*          		DW	0AAAAH
042621 7D          0888*          		DB	7DH
042622 00 00       0889*          		DW	0               ;a(0)
042624 00 00       0890*          		DW	0
042626 80          0891*          		DB	80H
042627 CD F4 2C 04 0892*          		CALL    POP5
04262B CD F4 2C 04 0893*          		CALL    POP5
04262F CD 46 23 04 0894*          		CALL    FMUL
042633 C3 5C 26 04 0895*          		JP      SIN3
042637             0896*  ;
042637 CD E3 2C 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
04263B CD 28 2D 04 0898*          		CALL    POLY
04263F 71 D5       0899*          		DW	0D571H          ;b(8)
042641 78 4C       0900*          		DW	4C78H
042643 70          0901*          		DB	70H
042644 AF 94       0902*          		DW	94AFH           ;b(6)
042646 03 B6       0903*          		DW	0B603H
042648 76          0904*          		DB	76H
042649 C8 9C       0905*          		DW	9CC8H           ;b(4)
04264B AA 2A       0906*          		DW	2AAAH
04264D 7B          0907*          		DB	7BH
04264E DD FF       0908*          		DW	0FFDDH          ;b(2)
042650 FF FF       0909*          		DW	0FFFFH
042652 7E          0910*          		DB	7EH
042653 00 00       0911*          		DW	0               ;b(0)
042655 00 00       0912*          		DW	0
042657 80          0913*          		DB	80H
042658 CD F4 2C 04 0914*          		CALL    POP5
04265C F1          0915*  SIN3:			POP     AF
04265D E6 04       0916*          		AND     4
04265F C8          0917*          		RET     Z
042660 0D          0918*          		DEC     C
042661 0C          0919*          		INC     C
042662 C8          0920*          		RET     Z               ;ZERO
042663 CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
042665 C9          0922*          		RET
042666             0923*  ;
042666             0924*  ;Floating-point one:
042666             0925*  ;
042666 21 00 00 00 0926*  FONE_FP:			LD      HL,0
04266A D9          0927*          		EXX
04266B 21 00 00 00 0928*          		LD      HL,0
04266F D9          0929*          		EXX
042670 0E 80       0930*          		LD      C,80H
042672 C9          0931*          		RET
042673             0932*  ;
042673 11 00 00 00 0933*  DONE:			LD      DE,0
042677 D9          0934*          		EXX
042678 11 00 00 00 0935*          		LD      DE,0
04267C D9          0936*          		EXX
04267D 06 80       0937*          		LD      B,80H
04267F C9          0938*          		RET
042680             0939*  ;
042680 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
042684 D9          0941*          		EXX
042685 11 A2 DA 00 0942*          		LD      DE,0DAA2H
042689 D9          0943*          		EXX
04268A 06 7F       0944*          		LD      B,7FH
04268C C9          0945*          		RET
04268D             0946*  ;
04268D             0947*  ;EXP - Exponential function
04268D             0948*  ;Result is floating-point numeric.
04268D             0949*  ;
04268D CD DE 2B 04 0950*  EXP_FP:			CALL    SFLOAT_FP
042691 CD 1E 27 04 0951*  EXP0:			CALL    LN2             ;LN(2)
042695 D9          0952*          		EXX
042696 1D          0953*  	        	DEC     E
042697 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
04269B D9          0955*          		EXX
04269C E5          0956*          		PUSH    HL              ;H7=SIGN
04269D CD 4D 2B 04 0957*          		CALL    MOD48           ;"MODULUS"
0426A1 F1          0958*          		POP     AF
0426A2 CB 7B       0959*          		BIT     7,E
0426A4 28 0B       0960*          		JR      Z,EXP1
0426A6 17          0961*          		RLA
0426A7 DA 5B 2C 04 0962*          		JP      C,ZERO_FP
0426AB 3E 18       0963*          		LD      A,EXPRNG
0426AD C3 B5 20 04 0964*          		JP      ERROR_FP_           ;"Exp range"
0426B1             0965*  ;
0426B1 E6 80       0966*  EXP1:			AND     80H
0426B3 B3          0967*          		OR      E
0426B4 F5          0968*          		PUSH    AF              ;INTEGER PART
0426B5 CB BC       0969*          		RES     7,H
0426B7 CD EB 2C 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
0426BB CD 28 2D 04 0971*          		CALL    POLY
0426BF 72 40       0972*          		DW	4072H           ;a(7)
0426C1 2E 94       0973*          		DW	942EH
0426C3 73          0974*          		DB	73H
0426C4 65 6F       0975*          		DW	6F65H           ;a(6)
0426C6 4F 2E       0976*          		DW	2E4FH
0426C8 76          0977*          		DB	76H
0426C9 37 6D       0978*          		DW	6D37H           ;a(5)
0426CB 02 88       0979*          		DW	8802H
0426CD 79          0980*          		DB	79H
0426CE 12 E5       0981*          		DW	0E512H          ;a(4)
0426D0 A0 2A       0982*          		DW	2AA0H
0426D2 7B          0983*          		DB	7BH
0426D3 14 4F       0984*          		DW	4F14H           ;a(3)
0426D5 AA AA       0985*          		DW	0AAAAH
0426D7 7D          0986*          		DB	7DH
0426D8 56 FD       0987*          		DW	0FD56H          ;a(2)
0426DA FF 7F       0988*          		DW	7FFFH
0426DC 7E          0989*          		DB	7EH
0426DD FE FF       0990*          		DW	0FFFEH          ;a(1)
0426DF FF FF       0991*          		DW	0FFFFH
0426E1 7F          0992*          		DB	7FH
0426E2 00 00       0993*          		DW	0               ;a(0)
0426E4 00 00       0994*          		DW	0
0426E6 80          0995*          		DB	80H
0426E7 CD F4 2C 04 0996*          		CALL    POP5
0426EB F1          0997*          		POP     AF
0426EC F5          0998*          		PUSH    AF
0426ED F4 12 27 04 0999*          		CALL    P,RECIP         ;X=1/X
0426F1 F1          1000*          		POP     AF
0426F2 F2 FA 26 04 1001*          		JP      P,EXP4
0426F6 E6 7F       1002*          		AND     7FH
0426F8 ED 44       1003*          		NEG
0426FA C6 80       1004*  EXP4:			ADD     A,80H
0426FC 81          1005*          		ADD     A,C
0426FD 38 06       1006*          		JR      C,EXP2
0426FF F2 5B 2C 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
042703 18 04       1008*          		JR      EXP3
042705 FA 26 2C 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
042709 C6 80       1010*  EXP3:			ADD     A,80H
04270B CA 5B 2C 04 1011*          		JP      Z,ZERO_FP
04270F 4F          1012*          		LD      C,A
042710 AF          1013*          		XOR     A               ;NUMERIC MARKER
042711 C9          1014*          		RET
042712             1015*  ;
042712 CD 73 26 04 1016*  RECIP:			CALL    DONE
042716 CD 0F 2C 04 1017*  RDIV:			CALL    SWAP_FP
04271A C3 9D 22 04 1018*          		JP      FDIV            ;RECIPROCAL
04271E             1019*  ;
04271E 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
042722 D9          1021*          		EXX
042723 11 F8 17 00 1022*          		LD      DE,17F8H
042727 D9          1023*          		EXX
042728 06 7F       1024*          		LD      B,7FH
04272A C9          1025*          		RET
04272B             1026*  ;
04272B             1027*  ;LN - Natural log.
04272B             1028*  ;Result is floating-point numeric.
04272B             1029*  ;
04272B CD DE 2B 04 1030*  LN_FP:			CALL    SFLOAT_FP
04272F 3E 16       1031*  LN0:			LD      A,LOGRNG
042731 CB 7C       1032*          		BIT     7,H
042733 C2 B5 20 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
042737 0C          1034*          		INC     C
042738 0D          1035*          		DEC     C
042739 CA B5 20 04 1036*          		JP      Z,ERROR_FP_
04273D 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
042741 D9          1038*          		EXX
042742 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
042746 D9          1040*          		EXX
042747 CD 6E 2C 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
04274B 79          1042*          		LD      A,C             ;EXPONENT
04274C 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
04274E 38 02       1044*          		JR      C,LN4
042750 0D          1045*          		DEC     C
042751 3C          1046*          		INC     A
042752 F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
042753 CD 00 2D 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
042757 CD EB 2C 04 1049*          		CALL    PUSH5
04275B CD E3 2C 04 1050*  		        CALL    SQUARE          ;PUSH X*X
04275F CD 28 2D 04 1051*          		CALL    POLY
042763 48 CC       1052*          		DW	0CC48H          ;a(9)
042765 FB 74       1053*          		DW	74FBH
042767 7D          1054*          		DB	7DH
042768 AF AE       1055*          		DW	0AEAFH          ;a(7)
04276A FF 11       1056*          		DW	11FFH
04276C 7E          1057*          		DB	7EH
04276D 8C D9       1058*          		DW	0D98CH          ;a(5)
04276F CD 4C       1059*          		DW	4CCDH
042771 7E          1060*          		DB	7EH
042772 E3 A9       1061*          		DW	0A9E3H          ;a(3)
042774 AA 2A       1062*          		DW	2AAAH
042776 7F          1063*          		DB	7FH
042777 00 00       1064*          		DW	0               ;a(1)
042779 00 00       1065*          		DW	0
04277B 81          1066*          		DB	81H
04277C CD F4 2C 04 1067*          		CALL    POP5
042780 CD F4 2C 04 1068*          		CALL    POP5
042784 CD 46 23 04 1069*          		CALL    FMUL
042788 F1          1070*          		POP     AF              ;EXPONENT
042789 CD EB 2C 04 1071*          		CALL    PUSH5
04278D 08          1072*          		EX      AF,AF'
04278E CD 5B 2C 04 1073*          		CALL    ZERO_FP
042792 08          1074*          		EX      AF,AF'
042793 D6 80       1075*          		SUB     80H
042795 28 1F       1076*          		JR      Z,LN3
042797 30 02       1077*          		JR      NC,LN1
042799 2F          1078*          		CPL
04279A 3C          1079*          		INC     A
04279B 67          1080*  LN1:			LD      H,A
04279C 0E 87       1081*          		LD      C,87H
04279E F5          1082*          		PUSH    AF
04279F CD BE 2B 04 1083*          		CALL    FLOAT_
0427A3 CB BC       1084*          		RES     7,H
0427A5 CD 1E 27 04 1085*          		CALL    LN2
0427A9 CD 46 23 04 1086*          		CALL    FMUL
0427AD F1          1087*          		POP     AF
0427AE 30 06       1088*          		JR      NC,LN3
0427B0 FA B6 27 04 1089*          		JP      M,LN3
0427B4 CB FC       1090*          		SET     7,H
0427B6 CD F4 2C 04 1091*  LN3:			CALL    POP5
0427BA CD 34 22 04 1092*          		CALL    FADD
0427BE AF          1093*          		XOR     A
0427BF C9          1094*          		RET
0427C0             1095*  ;
0427C0             1096*  ;LOG - base-10 logarithm.
0427C0             1097*  ;Result is floating-point numeric.
0427C0             1098*  ;
0427C0 CD 2B 27 04 1099*  LOG_FP:			CALL    LN_FP
0427C4 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
0427C8 D9          1101*          		EXX
0427C9 11 A9 D8 00 1102*          		LD      DE,0D8A9H
0427CD D9          1103*          		EXX
0427CE 06 7E       1104*          		LD      B,7EH
0427D0 CD 46 23 04 1105*          		CALL    FMUL
0427D4 AF          1106*          		XOR     A
0427D5 C9          1107*          		RET
0427D6             1108*  ;
0427D6             1109*  ;ASN - Arc-sine
0427D6             1110*  ;Result is floating-point numeric.
0427D6             1111*  ;
0427D6 CD DE 2B 04 1112*  ASN_FP:			CALL    SFLOAT_FP
0427DA CD EB 2C 04 1113*          		CALL    PUSH5
0427DE CD DB 2C 04 1114*          		CALL    COPY_
0427E2 CD 46 23 04 1115*          		CALL    FMUL
0427E6 CD 73 26 04 1116*          		CALL    DONE
0427EA CD 21 22 04 1117*          		CALL    RSUB
0427EE CD 51 25 04 1118*          		CALL    SQR0
0427F2 CD F4 2C 04 1119*          		CALL    POP5
0427F6 0C          1120*          		INC     C
0427F7 0D          1121*          		DEC     C
0427F8 3E 02       1122*          		LD      A,2
0427FA D5          1123*          		PUSH    DE
0427FB CA 80 28 04 1124*          		JP      Z,ACS1
0427FF D1          1125*          		POP     DE
042800 CD 16 27 04 1126*          		CALL    RDIV
042804 18 04       1127*          		JR      ATN0
042806             1128*  ;
042806             1129*  ;ATN - arc-tangent
042806             1130*  ;Result is floating-point numeric.
042806             1131*  ;
042806 CD DE 2B 04 1132*  ATN_FP:			CALL    SFLOAT_FP
04280A E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
04280B CB BC       1134*          		RES     7,H
04280D 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
042811 D9          1136*          		EXX
042812 11 D0 CC 00 1137*          		LD      DE,0CCD0H
042816 D9          1138*          		EXX
042817 06 7E       1139*          		LD      B,7EH
042819 CD 6B 2C 04 1140*          		CALL    FCP0            ;COMPARE
04281D 06 00       1141*          		LD      B,0
04281F 38 22       1142*          		JR      C,ATN2
042821 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
042825 D9          1144*          		EXX
042826 11 9A 79 00 1145*          		LD      DE,799AH
04282A D9          1146*          		EXX
04282B 06 81       1147*          		LD      B,81H
04282D CD 6B 2C 04 1148*          		CALL    FCP0            ;COMPARE
042831 38 0A       1149*          		JR      C,ATN1
042833 CD 12 27 04 1150*          		CALL    RECIP           ;X=1/X
042837 06 02       1151*          		LD      B,2
042839 C3 43 28 04 1152*          		JP      ATN2
04283D CD 00 2D 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042841 06 01       1154*          		LD      B,1
042843 C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
042844 CD EB 2C 04 1156*          		CALL    PUSH5
042848 CD E3 2C 04 1157*          		CALL    SQUARE          ;PUSH X*X
04284C CD 28 2D 04 1158*          		CALL    POLY
042850 35 F3       1159*          		DW	0F335H          ;a(13)
042852 D8 37       1160*          		DW	37D8H
042854 7B          1161*          		DB	7BH
042855 91 6B       1162*          		DW	6B91H           ;a(11)
042857 B9 AA       1163*          		DW	0AAB9H
042859 7C          1164*          		DB	7CH
04285A DE 41       1165*          		DW	41DEH           ;a(9)
04285C 97 61       1166*          		DW	6197H
04285E 7C          1167*          		DB	7CH
04285F 7B 9D       1168*          		DW	9D7BH           ;a(7)
042861 37 92       1169*          		DW	9237H
042863 7D          1170*          		DB	7DH
042864 5A 2A       1171*          		DW	2A5AH           ;a(5)
042866 CC 4C       1172*          		DW	4CCCH
042868 7D          1173*          		DB	7DH
042869 5C A9       1174*          		DW	0A95CH          ;a(3)
04286B AA AA       1175*          		DW	0AAAAH
04286D 7E          1176*          		DB	7EH
04286E 00 00       1177*          		DW	0               ;a(1)
042870 00 00       1178*          		DW	0
042872 80          1179*          		DB	80H
042873 CD F4 2C 04 1180*          		CALL    POP5
042877 CD F4 2C 04 1181*          		CALL    POP5
04287B CD 46 23 04 1182*          		CALL    FMUL
04287F F1          1183*          		POP     AF
042880 CD 80 26 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
042884 1F          1185*          		RRA
042885 F5          1186*          		PUSH    AF
042886 DC 34 22 04 1187*          		CALL    C,FADD
04288A F1          1188*          		POP     AF
04288B 04          1189*          		INC     B
04288C 1F          1190*          		RRA
04288D DC 21 22 04 1191*          		CALL    C,RSUB
042891 F1          1192*          		POP     AF
042892 B7          1193*          		OR      A
042893 F0          1194*          		RET     P
042894 CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
042896 AF          1196*          		XOR     A
042897 C9          1197*          		RET
042898             1198*  ;
042898             1199*  ;ACS - Arc cosine=PI/2-ASN.
042898             1200*  ;Result is floating point numeric.
042898             1201*  ;
042898 CD D6 27 04 1202*  ACS_FP:			CALL    ASN_FP
04289C 3E 02       1203*          		LD      A,2
04289E F5          1204*          		PUSH    AF
04289F 18 DF       1205*          		JR      ACS1
0428A1             1206*  ;
0428A1             1207*  ;Function STR - convert numeric value to ASCII string.
0428A1             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
0428A1             1209*  ;           DE = address at which to store string
0428A1             1210*  ;           IX = address of @% format control
0428A1             1211*  ;  Outputs: String stored, with NUL terminator
0428A1             1212*  ;
0428A1             1213*  ;First normalise for decimal output:
0428A1             1214*  ;
0428A1 CD DE 2B 04 1215*  STR_FP:			CALL    SFLOAT_FP
0428A5 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
0428A7 CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
0428A9 28 06       1218*          		JR      Z,STR10
0428AB CB BC       1219*          		RES     7,H
0428AD 3E 2D       1220*          		LD      A,'-'
0428AF 12          1221*          		LD      (DE),A          ;STORE SIGN
0428B0 13          1222*          		INC     DE
0428B1 AF          1223*  STR10:			XOR     A               ;CLEAR A
0428B2 B9          1224*          		CP      C
0428B3 28 4E       1225*          		JR      Z,STR02          ;ZERO
0428B5 D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
0428B6 78          1227*          		LD      A,B
0428B7 F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0428B8 79          1229*          		LD      A,C             ;BINARY EXPONENT
0428B9 FE A1       1230*          		CP      161
0428BB 30 1C       1231*          		JR      NC,STR14
0428BD FE 9B       1232*          		CP      155
0428BF 30 29       1233*          		JR      NC,STR15
0428C1 2F          1234*          		CPL
0428C2 FE E1       1235*          		CP      225
0428C4 38 02       1236*          		JR      C,STR13
0428C6 3E F8       1237*          		LD      A,-8
0428C8 C6 1C       1238*  STR13:			ADD     A,28
0428CA CD 57 2D 04 1239*          		CALL    POWR10
0428CE F5          1240*          		PUSH    AF
0428CF CD 46 23 04 1241*          		CALL    FMUL
0428D3 F1          1242*          		POP     AF
0428D4 47          1243*          		LD      B,A
0428D5 F1          1244*          		POP     AF
0428D6 90          1245*          		SUB     B
0428D7 18 DE       1246*          		JR      STR11
0428D9 D6 20       1247*  STR14:			SUB     32
0428DB CD 57 2D 04 1248*          		CALL    POWR10
0428DF F5          1249*          		PUSH    AF
0428E0 CD 9D 22 04 1250*          		CALL    FDIV
0428E4 F1          1251*          		POP     AF
0428E5 47          1252*          		LD      B,A
0428E6 F1          1253*          		POP     AF
0428E7 80          1254*          		ADD     A,B
0428E8 18 CD       1255*          		JR      STR11
0428EA 3E 09       1256*  STR15:			LD      A,9
0428EC CD 57 2D 04 1257*          		CALL    POWR10          ;10^9
0428F0 CD 6B 2C 04 1258*          		CALL    FCP0
0428F4 79          1259*          		LD      A,C
0428F5 C1          1260*          		POP     BC
0428F6 4F          1261*          		LD      C,A
0428F7 CB FC       1262*          		SET     7,H             ;IMPLIED 1
0428F9 DC 93 2C 04 1263*          		CALL    C,X10B          ;X10, DEC B
0428FD D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
0428FE CB B9       1265*          		RES     7,C
042900 3E 00       1266*          		LD      A,0
042902 17          1267*          		RLA                     ;PUT CARRY IN LSB
042903             1268*  ;
042903             1269*  ;At this point decimal normalisation has been done,
042903             1270*  ;now convert to decimal digits:
042903             1271*  ;      AHLH'L' = number in normalised integer form
042903             1272*  ;            B = decimal place adjustment
042903             1273*  ;            C = binary place adjustment (29-33)
042903             1274*  ;
042903 0C          1275*  STR02:			INC     C
042904 08          1276*          		EX      AF,AF'          ;SAVE A
042905 78          1277*          		LD      A,B
042906 DD CB 02 4E 1278*          		BIT     1,(IX+2)
04290A 20 08       1279*          		JR      NZ,STR20
04290C AF          1280*          		XOR     A
04290D DD BE 01    1281*          		CP      (IX+1)
042910 28 0B       1282*          		JR      Z,STR21
042912 3E F6       1283*          		LD      A,-10
042914 DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042917 B7          1285*          		OR      A               ;CLEAR CARRY
042918 FA 1D 29 04 1286*          		JP      M,STR21
04291C AF          1287*          		XOR     A
04291D F5          1288*  STR21:			PUSH    AF
04291E 08          1289*          		EX      AF,AF'          ;RESTORE A
04291F CD C7 2C 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
042923 8F          1291*          		ADC     A,A
042924 FE 0A       1292*          		CP      10
042926 38 05       1293*          		JR      C,STR23
042928 D6 0A       1294*          		SUB     10
04292A D9          1295*          		EXX
04292B 2C          1296*          		INC     L               ;SET RESULT BIT
04292C D9          1297*          		EXX
04292D 0D          1298*  STR23:			DEC     C
04292E 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
042930 4F          1300*          		LD      C,A             ;REMAINDER
042931 7C          1301*          		LD      A,H
042932 E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
042934 67          1303*          		LD      H,A
042935 F1          1304*          		POP     AF
042936 F2 44 29 04 1305*          		JP      P,STR24
04293A 3C          1306*          		INC     A
04293B 20 1C       1307*          		JR      NZ,STR26
04293D 3E 04       1308*          		LD      A,4
04293F B9          1309*          		CP      C               ;ROUND UP?
042940 3E 00       1310*          		LD      A,0
042942 18 15       1311*          		JR      STR26
042944 F5          1312*  STR24:			PUSH    AF
042945 79          1313*          		LD      A,C
042946 CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
042948 FE 30       1315*          		CP      '0'
04294A 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
04294C FE 3A       1317*          		CP      '9'+1
04294E 3F          1318*          		CCF
04294F 30 08       1319*          		JR      NC,STR26
042951 E3          1320*  STR25:			EX      (SP),HL
042952 CB 75       1321*          		BIT     6,L             ;ZERO FLAG
042954 E3          1322*  		        EX      (SP),HL
042955 20 05       1323*          		JR      NZ,STR27
042957 3E 30       1324*          		LD      A,'0'
042959 3C          1325*  STR26:			INC     A               ;SET +VE
04295A 3D          1326*          		DEC     A
04295B F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
04295C 04          1328*  STR27:			INC     B
04295D CD 37 2C 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
042961 0E 20       1330*          		LD      C,32
042963 3E 00       1331*          		LD      A,0
042965 20 B8       1332*          		JR      NZ,STR22
042967 F1          1333*          		POP     AF
042968 F5          1334*          		PUSH    AF
042969 3E 00       1335*          		LD      A,0
04296B 38 B2       1336*          		JR      C,STR22
04296D             1337*  ;
04296D             1338*  ;At this point, the decimal character string is stored
04296D             1339*  ; on the stack. Trailing zeroes are suppressed and may
04296D             1340*  ; need to be replaced.
04296D             1341*  ;B register holds decimal point position.
04296D             1342*  ;Now format number and store as ASCII string:
04296D             1343*  ;
04296D EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
04296E 0E FF       1345*          		LD      C,-1            ;FLAG "E"
042970 16 01       1346*          		LD      D,1
042972 DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
042975 DD CB 02 46 1348*          		BIT     0,(IX+2)
042979 20 35       1349*          		JR      NZ,STR34        ;E MODE
04297B DD CB 02 4E 1350*          		BIT     1,(IX+2)
04297F 28 12       1351*          		JR      Z,STR31
042981 78          1352*          		LD      A,B             ;F MODE
042982 B7          1353*          		OR      A
042983 28 05       1354*          		JR      Z,STR30
042985 FA 8A 29 04 1355*          		JP      M,STR30
042989 50          1356*          		LD      D,B
04298A 7A          1357*  STR30:			LD      A,D
04298B DD 86 01    1358*          		ADD     A,(IX+1)
04298E 5F          1359*          		LD      E,A
04298F FE 0B       1360*          		CP      11
042991 38 19       1361*          		JR      C,STR32
042993 78          1362*  STR31:			LD      A,B             ;G MODE
042994 11 01 01 00 1363*          		LD      DE,101H
042998 B7          1364*          		OR      A
042999 FA B0 29 04 1365*          		JP      M,STR34
04299D 28 0D       1366*          		JR      Z,STR32
04299F DD 7E 01    1367*          		LD      A,(IX+1)
0429A2 B7          1368*          		OR      A
0429A3 20 02       1369*          		JR      NZ,STR3A
0429A5 3E 0A       1370*          		LD      A,10
0429A7 B8          1371*  STR3A:			CP      B
0429A8 38 06       1372*          		JR      C,STR34
0429AA 50          1373*          		LD      D,B
0429AB 58          1374*          		LD      E,B
0429AC 78          1375*  STR32:			LD      A,B
0429AD C6 81       1376*          		ADD     A,129
0429AF 4F          1377*          		LD      C,A
0429B0 CB FA       1378*  STR34:			SET     7,D
0429B2 1D          1379*          		DEC     E
0429B3 7A          1380*  STR35:			LD      A,D
0429B4 B9          1381*          		CP      C
0429B5 30 0E       1382*          		JR      NC,STR33
0429B7 F1          1383*  STR36:			POP     AF
0429B8 28 04       1384*          		JR      Z,STR37
0429BA F2 C7 29 04 1385*          		JP      P,STR38
0429BE F5          1386*  STR37:			PUSH    AF
0429BF 1C          1387*          		INC     E
0429C0 1D          1388*          		DEC     E
0429C1 FA D8 29 04 1389*          		JP      M,STR4
0429C5 3E 30       1390*  STR33:			LD      A,'0'
0429C7 15          1391*  STR38:			DEC     D
0429C8 E2 CF 29 04 1392*          		JP      PO,STR39
0429CC 36 2E       1393*          		LD      (HL),'.'
0429CE 23          1394*          		INC     HL
0429CF 77          1395*  STR39:			LD      (HL),A
0429D0 23          1396*          		INC     HL
0429D1 1D          1397*          		DEC     E
0429D2 F2 B3 29 04 1398*          		JP      P,STR35
0429D6 18 DF       1399*          		JR      STR36
0429D8             1400*  ;
0429D8 F1          1401*  STR4:			POP     AF
0429D9 0C          1402*  STR40:			INC     C
0429DA 4D          1403*          		LD      C,L
0429DB 20 28       1404*          		JR      NZ,STR44
0429DD 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
0429DF 23          1406*          		INC     HL
0429E0 78          1407*          		LD      A,B
0429E1 3D          1408*          		DEC     A
0429E2 F2 EB 29 04 1409*          		JP      P,STR41
0429E6 36 2D       1410*          		LD      (HL),'-'
0429E8 23          1411*          		INC     HL
0429E9 ED 44       1412*          		NEG
0429EB 36 30       1413*  STR41:			LD      (HL),'0'
0429ED 28 15       1414*          		JR      Z,STR47
0429EF FE 0A       1415*          		CP      10
0429F1 47          1416*          		LD      B,A
0429F2 3E 3A       1417*          		LD      A,':'
0429F4 38 03       1418*          		JR      C,STR42
0429F6 23          1419*          		INC     HL
0429F7 36 30       1420*          		LD      (HL),'0'
0429F9 34          1421*  STR42:			INC     (HL)
0429FA BE          1422*          		CP      (HL)
0429FB 20 05       1423*          		JR      NZ,STR43
0429FD 36 30       1424*          		LD      (HL),'0'
0429FF 2B          1425*          		DEC     HL
042A00 34          1426*          		INC     (HL)
042A01 23          1427*          		INC     HL
042A02 10 F5       1428*  STR43:			DJNZ    STR42
042A04 23          1429*  STR47:			INC     HL
042A05 EB          1430*  STR44:			EX      DE,HL
042A06 C9          1431*        			RET
042A07             1432*  ;
042A07             1433*  ;Support subroutines:
042A07             1434*  ;
042A07 DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
042A0A D9          1436*          		EXX
042A0B DD 5E 00    1437*          		LD      E,(IX+0)
042A0E DD 56 01    1438*          		LD      D,(IX+1)
042A11 D9          1439*          		EXX
042A12 DD 5E 02    1440*          		LD      E,(IX+2)
042A15 DD 56 03    1441*          		LD      D,(IX+3)
042A18 C9          1442*          		RET
042A19             1443*  ;
042A19 DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
042A1C D9          1445*  			EXX
042A1D DD 17 00    1446*  			LD	DE, (IX+0)
042A20 D9          1447*  			EXX
042A21 DD 17 03    1448*  			LD	DE, (IX+3)
042A24 C9          1449*  			RET
042A25             1450*  ;
042A25             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
042A25             1452*  ;   Inputs: ASCII string at (IX).
042A25             1453*  ;  Outputs: Variable-type result in HLH'L'C
042A25             1454*  ;           IX updated (points to delimiter)
042A25             1455*  ;           A7 = 0 (numeric marker)
042A25             1456*  ;
042A25 CD 5B 2C 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
042A29 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
042A2B CD B9 2A 04 1459*          		CALL    UINT          ;GET INTEGER PART
042A2F FE 2E       1460*          		CP      '.'
042A31 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
042A33 CC B7 2A 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
042A37 FE 45       1463*          		CP      'E'
042A39 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
042A3B CC 85 2A 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
042A3F CB 7C       1466*          		BIT     7,H
042A41 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
042A43 B7          1468*          		OR      A
042A44 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
042A46 B8          1470*          		CP      B
042A47 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
042A49 B9          1472*          		CP      C
042A4A C8          1473*          		RET     Z               ;INTEGER
042A4B 90          1474*  CON0:			SUB     B
042A4C 81          1475*          		ADD     A,C
042A4D 0E 9F       1476*          		LD      C,159
042A4F CD BE 2B 04 1477*          		CALL    FLOAT_
042A53 CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
042A55 B7          1479*          		OR      A
042A56 C8          1480*          		RET     Z               ;DONE
042A57 FA 65 2A 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
042A5B CD 57 2D 04 1482*          		CALL    POWR10
042A5F CD 46 23 04 1483*          		CALL    FMUL            ;SCALE
042A63 AF          1484*          		XOR     A
042A64 C9          1485*          		RET
042A65 FE DA       1486*  CON2:			CP      -38
042A67 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
042A69 ED 44       1488*          		NEG
042A6B CD 57 2D 04 1489*          		CALL    POWR10
042A6F CD 9D 22 04 1490*          		CALL    FDIV            ;SCALE
042A73 AF          1491*          		XOR     A
042A74 C9          1492*          		RET
042A75 F5          1493*  CON3:			PUSH    AF
042A76 3E 26       1494*          		LD      A,38
042A78 CD 57 2D 04 1495*          		CALL    POWR10
042A7C CD 9D 22 04 1496*          		CALL    FDIV
042A80 F1          1497*          		POP     AF
042A81 C6 26       1498*          		ADD     A,38
042A83 18 E0       1499*          		JR      CON2
042A85             1500*  ;
042A85             1501*  ;GETEXP - Get decimal exponent from string
042A85             1502*  ;     Inputs: ASCII string at (IX)
042A85             1503*  ;             (IX points at 'E')
042A85             1504*  ;             A = initial value
042A85             1505*  ;    Outputs: A = new exponent
042A85             1506*  ;             IX updated.
042A85             1507*  ;   Destroys: A,A',IX,F,F'
042A85             1508*  ;
042A85 C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
042A86 47          1510*          		LD      B,A             ;INITIAL VALUE
042A87 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
042A89 DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
042A8B CD 75 2E 04 1513*          		CALL    SIGNQ
042A8F 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
042A90 CD 6B 2E 04 1515*  GETEX1:			CALL    DIGITQ
042A94 38 18       1516*          		JR      C,GETEX2
042A96 78          1517*          		LD      A,B             ;B=B*10
042A97 87          1518*          		ADD     A,A
042A98 87          1519*          		ADD     A,A
042A99 80          1520*          		ADD     A,B
042A9A 87          1521*          		ADD     A,A
042A9B 47          1522*          		LD      B,A
042A9C DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
042A9F DD 23       1524*          		INC     IX
042AA1 E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
042AA3 80          1526*          		ADD     A,B             ;ADD IN DIGIT
042AA4 47          1527*          		LD      B,A
042AA5 0D          1528*          		DEC     C
042AA6 F2 90 2A 04 1529*          		JP      P,GETEX1
042AAA 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
042AAC 18 E2       1531*          		JR      GETEX1
042AAE 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
042AAF FE 2D       1533*          		CP      '-'
042AB1 78          1534*          		LD      A,B
042AB2 C1          1535*          		POP     BC              ;RESTORE
042AB3 C0          1536*          		RET     NZ
042AB4 ED 44       1537*          		NEG                     ;NEGATE EXPONENT
042AB6 C9          1538*          		RET
042AB7             1539*  ;
042AB7             1540*  ;UINT: Get unsigned integer from string.
042AB7             1541*  ;    Inputs: string at (IX)
042AB7             1542*  ;            C = truncated digit count
042AB7             1543*  ;                (initially zero)
042AB7             1544*  ;            B = total digit count
042AB7             1545*  ;            HLH'L' = initial value
042AB7             1546*  ;   Outputs: HLH'L' = number (binary integer)
042AB7             1547*  ;            A = delimiter.
042AB7             1548*  ;            B, C & IX updated
042AB7             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042AB7             1550*  ;
042AB7 DD 23       1551*  NUMBIX:			INC     IX
042AB9 CD 6B 2E 04 1552*  UINT:			CALL    DIGITQ
042ABD D8          1553*          		RET     C
042ABE 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
042ABF DD 23       1555*          		INC     IX
042AC1 CD B4 2C 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
042AC5 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
042AC7 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
042AC8 0C          1559*          		INC     C
042AC9 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
042ACB E6 0F       1561*          		AND     0FH
042ACD D9          1562*          		EXX
042ACE 06 00       1563*          		LD      B,0
042AD0 4F          1564*          		LD      C,A
042AD1 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
042AD3 D9          1566*          		EXX
042AD4 30 E3       1567*          		JR      NC,UINT
042AD6 52 23       1568*          		INC.S   HL              ;CARRY
042AD8 7C          1569*          		LD      A,H
042AD9 B5          1570*          		OR      L
042ADA 20 DD       1571*          		JR      NZ,UINT
042ADC 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
042ADD CD 12 2C 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
042AE1 18 D6       1574*          		JR      UINT
042AE3             1575*  ;
042AE3             1576*  ;FIX - Fix number to specified exponent value.
042AE3             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
042AE3             1578*  ;            A = desired exponent (A>C)
042AE3             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
042AE3             1580*  ;            fraction shifted into B'C'
042AE3             1581*  ;            A'F' positive if integer input
042AE3             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
042AE3             1583*  ;
042AE3 08          1584*  FIX:			EX      AF,AF'
042AE4 AF          1585*          		XOR     A
042AE5 08          1586*          		EX      AF,AF'
042AE6 CB FC       1587*          		SET     7,H             ;IMPLIED 1
042AE8 CD 17 2C 04 1588*  FIX1:			CALL    DIV2
042AEC B9          1589*          		CP      C
042AED C8          1590*          		RET     Z
042AEE D2 E8 2A 04 1591*          		JP      NC,FIX1
042AF2 C3 26 2C 04 1592*          		JP      OFLOW
042AF6             1593*  ;
042AF6             1594*  ;SFIX - Convert to integer if necessary.
042AF6             1595*  ;    Input: Variable-type number in HLH'L'C
042AF6             1596*  ;   Output: Integer in HLH'L', C=0
042AF6             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
042AF6             1598*  ;
042AF6             1599*  ;NEGATE - Negate HLH'L'
042AF6             1600*  ;    Destroys: H,L,H',L',F
042AF6             1601*  ;
042AF6 CD 0F 2C 04 1602*  FIX2:			CALL    SWAP_FP
042AFA CD 02 2B 04 1603*          		CALL    SFIX_FP
042AFE CD 0F 2C 04 1604*          		CALL    SWAP_FP
042B02 0D          1605*  SFIX_FP:			DEC     C
042B03 0C          1606*          		INC     C
042B04 C8          1607*          		RET     Z               ;INTEGER/ZERO
042B05 CB 7C       1608*          		BIT     7,H             ;SIGN
042B07 F5          1609*          		PUSH    AF
042B08 3E 9F       1610*          		LD      A,159
042B0A CD E3 2A 04 1611*          		CALL    FIX
042B0E F1          1612*          		POP     AF
042B0F 0E 00       1613*          		LD      C,0
042B11 C8          1614*          		RET     Z
042B12 B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
042B13 D9          1616*          		EXX
042B14 D5          1617*  NEG0:			PUSH    DE
042B15 EB          1618*          		EX      DE,HL
042B16 21 00 00 00 1619*          		LD      HL,0
042B1A 52 ED 52    1620*          		SBC.S   HL,DE
042B1D D1          1621*          		POP     DE
042B1E D9          1622*          		EXX
042B1F D5          1623*          		PUSH    DE
042B20 EB          1624*          		EX      DE,HL
042B21 21 00 00 00 1625*          		LD      HL,0
042B25 52 ED 52    1626*          		SBC.S   HL,DE
042B28 D1          1627*          		POP     DE
042B29 C9          1628*          		RET
042B2A             1629*  ;
042B2A             1630*  ;NEG - Negate HLH'L'B'C'
042B2A             1631*  ;    Also complements A (used in FADD)
042B2A             1632*  ;    Destroys: A,H,L,B',C',H',L',F
042B2A             1633*  ;
042B2A D9          1634*  NEG_:			EXX
042B2B 2F          1635*          		CPL
042B2C E5          1636*          		PUSH    HL
042B2D B7          1637*          		OR      A               ;CLEAR CARRY
042B2E 21 00 00 00 1638*          		LD      HL,0
042B32 52 ED 42    1639*          		SBC.S   HL,BC
042B35 44          1640*          		LD      B,H
042B36 4D          1641*          		LD      C,L
042B37 E1          1642*          		POP     HL
042B38 18 DA       1643*          		JR      NEG0
042B3A             1644*  ;
042B3A             1645*  ;SCALE - Trig scaling.
042B3A             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
042B3A             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
042B3A             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
042B3A             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
042B3A             1650*  ;           E = quotient (bit 7 is sticky)
042B3A             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
042B3A             1652*  ;FLO48 - Float unsigned number (48 bits)
042B3A             1653*  ;    Input/output in HLH'L'B'C'C
042B3A             1654*  ;   Destroys: C,H,L,B',C',H',L',F
042B3A             1655*  ;
042B3A 3E 96       1656*  SCALE:			LD      A,150
042B3C B9          1657*          		CP      C
042B3D 3E 17       1658*          		LD      A,ACLOST
042B3F DA B5 20 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
042B43 CD 80 26 04 1660*          		CALL    PIBY4
042B47 D9          1661*          		EXX
042B48 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
042B4C D9          1663*          		EXX
042B4D CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
042B4F CB FC       1665*          		SET     7,H
042B51 79          1666*          		LD      A,C
042B52 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
042B54 DD 21 00 00 1668*          		LD      IX,0
       00          
042B59 DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
042B5B B8          1670*          		CP      B
042B5C 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
042B5E D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
042B5F E3          1673*          		EX      (SP),HL
042B60 52 ED 42    1674*          		SBC.S   HL,BC
042B63 E3          1675*          		EX      (SP),HL
042B64 52 ED 52    1676*          		SBC.S   HL,DE
042B67 D9          1677*          		EXX
042B68 52 ED 52    1678*          		SBC.S   HL,DE
042B6B 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
042B6D D9          1680*          		EXX
042B6E E3          1681*          		EX      (SP),HL
042B6F 52 09       1682*          		ADD.S   HL,BC
042B71 E3          1683*          		EX      (SP),HL
042B72 52 ED 5A    1684*          		ADC.S   HL,DE
042B75 D9          1685*          		EXX
042B76 52 ED 5A    1686*          		ADC.S   HL,DE
042B79 3F          1687*  MOD482:			CCF
042B7A CB 11       1688*          		RL      C               ;QUOTIENT
042B7C 30 02       1689*          		JR      NC,MOD483
042B7E CB F9       1690*          		SET     7,C             ;STICKY BIT
042B80 3D          1691*  MOD483:			DEC     A
042B81 B8          1692*          		CP      B
042B82 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
042B84 E3          1694*          		EX      (SP),HL
042B85 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
042B87 E3          1696*          		EX      (SP),HL
042B88 D9          1697*          		EXX
042B89 52 ED 6A    1698*          		ADC.S   HL,HL
042B8C D9          1699*          		EXX
042B8D 52 ED 6A    1700*          		ADC.S   HL,HL
042B90 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
042B92 B7          1702*          		OR      A
042B93 D9          1703*          		EXX
042B94 E3          1704*          		EX      (SP),HL
042B95 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
042B98 E3          1706*          		EX      (SP),HL
042B99 52 ED 52    1707*          		SBC.S   HL,DE
042B9C D9          1708*          		EXX
042B9D 52 ED 52    1709*          		SBC.S   HL,DE
042BA0 B7          1710*          		OR      A
042BA1 18 D6       1711*          		JR      MOD482
042BA3             1712*  ;
042BA3 3C          1713*  MOD484:			INC     A
042BA4 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
042BA5 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
042BA6 D9          1716*          		EXX
042BA7 C1          1717*          		POP     BC
042BA8 D9          1718*          		EXX
042BA9 CB 7C       1719*  FLO48:			BIT     7,H
042BAB C0          1720*          		RET     NZ
042BAC D9          1721*          		EXX
042BAD CB 21       1722*          		SLA     C
042BAF CB 10       1723*          		RL      B
042BB1 52 ED 6A    1724*          		ADC.S   HL,HL
042BB4 D9          1725*          		EXX
042BB5 52 ED 6A    1726*          		ADC.S   HL,HL
042BB8 0D          1727*          		DEC     C
042BB9 C2 A9 2B 04 1728*          		JP      NZ,FLO48
042BBD C9          1729*          		RET
042BBE             1730*  ;
042BBE             1731*  ;Float unsigned number
042BBE             1732*  ;    Input/output in HLH'L'C
042BBE             1733*  ;   Destroys: C,H,L,H',L',F
042BBE             1734*  ;
042BBE CB 7C       1735*  FLOAT_:			BIT     7,H
042BC0 C0          1736*          		RET     NZ
042BC1 D9          1737*          		EXX                     ;SAME AS "X2"
042BC2 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
042BC4 D9          1739*          		EXX                     ;REGION
042BC5 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
042BC8 0D          1741*          		DEC     C
042BC9 C2 BE 2B 04 1742*          		JP      NZ,FLOAT_
042BCD C9          1743*          		RET
042BCE             1744*  ;
042BCE             1745*  ;SFLOAT - Convert to floating-point if necessary.
042BCE             1746*  ;    Input: Variable-type number in HLH'L'C
042BCE             1747*  ;    Output: Floating-point in HLH'L'C
042BCE             1748*  ;    Destroys: A,C,H,L,H',L',F
042BCE             1749*  ;
042BCE 08          1750*  FLOATA:			EX      AF,AF'
042BCF             1751*          		; ADD     A,(RTABLE-DTABLE)/3
042BCF C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042BD1 08          1753*          		EX      AF,AF'
042BD2 CD 0F 2C 04 1754*  FLOAT2:			CALL    SWAP_FP
042BD6 CD DE 2B 04 1755*          		CALL    SFLOAT_FP
042BDA CD 0F 2C 04 1756*          		CALL    SWAP_FP
042BDE 0D          1757*  SFLOAT_FP:			DEC     C
042BDF 0C          1758*          		INC     C
042BE0 C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
042BE1 CD 37 2C 04 1760*          		CALL    TEST_FP
042BE5 C8          1761*          		RET     Z               ;ZERO
042BE6 7C          1762*          		LD      A,H
042BE7 B7          1763*          		OR      A
042BE8 FC 12 2B 04 1764*          		CALL    M,NEGATE
042BEC 0E 9F       1765*          		LD      C,159
042BEE CD BE 2B 04 1766*          		CALL    FLOAT_
042BF2 B7          1767*          		OR      A
042BF3 F8          1768*          		RET     M               ;NEGATIVE
042BF4 CB BC       1769*          		RES     7,H
042BF6 C9          1770*          		RET
042BF7             1771*  ;
042BF7             1772*  ;ROUND UP
042BF7             1773*  ;Return with carry set if 32-bit overflow
042BF7             1774*  ;   Destroys: H,L,B',C',H',L',F
042BF7             1775*  ;
042BF7 D9          1776*  ADD1_FP:			EXX
042BF8 01 01 00 00 1777*          		LD      BC,1
042BFC 52 09       1778*          		ADD.S   HL,BC
042BFE D9          1779*          		EXX
042BFF D0          1780*          		RET     NC
042C00 C5          1781*          		PUSH    BC
042C01 01 01 00 00 1782*          		LD      BC,1
042C05 52 09       1783*          		ADD.S   HL,BC
042C07 C1          1784*          		POP     BC
042C08 C9          1785*          		RET
042C09             1786*  ;
042C09             1787*  ;ODD - Add one if even, leave alone if odd.
042C09             1788*  ; (Used to perform unbiassed rounding, i.e.
042C09             1789*  ;  number is rounded up half the time)
042C09             1790*  ;    Destroys: L',F (carry cleared)
042C09             1791*  ;
042C09 B7          1792*  ODD:			OR      A               ;CLEAR CARRY
042C0A D9          1793*          		EXX
042C0B CB C5       1794*          		SET     0,L             ;MAKE ODD
042C0D D9          1795*          		EXX
042C0E C9          1796*          		RET
042C0F             1797*  ;
042C0F             1798*  ;SWAP_FP - Swap arguments.
042C0F             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
042C0F             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
042C0F             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
042C0F             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
042C0F             1803*  ;
042C0F 79          1804*  SWAP_FP:			LD      A,C
042C10 48          1805*          		LD      C,B
042C11 47          1806*          		LD      B,A
042C12 EB          1807*  SWAP1:			EX      DE,HL
042C13 D9          1808*          		EXX
042C14 EB          1809*          		EX      DE,HL
042C15 D9          1810*          		EXX
042C16 C9          1811*          		RET
042C17             1812*  ;
042C17             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
042C17             1814*  ; INCC - destroys C,F
042C17             1815*  ; OFLOW
042C17             1816*  ;
042C17 CD D0 2C 04 1817*  DIV2:			CALL    D2
042C1B D9          1818*          		EXX
042C1C CB 18       1819*          		RR      B
042C1E CB 19       1820*          		RR      C
042C20 08          1821*          		EX      AF,AF'
042C21 B0          1822*          		OR      B
042C22 08          1823*          		EX      AF,AF'
042C23 D9          1824*          		EXX
042C24 0C          1825*  INCC:			INC     C
042C25 C0          1826*          		RET     NZ
042C26 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
042C28 C3 B5 20 04 1828*          		JP      ERROR_FP_           ;"Too big"
042C2C             1829*  ;
042C2C             1830*  ; FTEST - Test for zero & sign
042C2C             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
042C2C             1832*  ;
042C2C CD 37 2C 04 1833*  FTEST_FP:			CALL    TEST_FP
042C30 C8          1834*          		RET     Z
042C31 7C          1835*          		LD      A,H
042C32 E6 80       1836*          		AND     10000000B
042C34 F6 40       1837*          		OR      01000000B
042C36 C9          1838*          		RET
042C37             1839*  ;
042C37             1840*  ; TEST_FP - Test HLH'L' for zero.
042C37             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
042C37             1842*  ;     Destroys: A,F
042C37             1843*  ;
042C37 7C          1844*  TEST_FP:			LD      A,H
042C38 B5          1845*          		OR      L
042C39 D9          1846*          		EXX
042C3A B4          1847*          		OR      H
042C3B B5          1848*          		OR      L
042C3C D9          1849*          		EXX
042C3D C9          1850*          		RET
042C3E             1851*  ;
042C3E             1852*  ; FCOMP - Compare two numbers
042C3E             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
042C3E             1854*  ;
042C3E 78          1855*  FCOMP_FP:			LD      A,B
042C3F B1          1856*          		OR      C               ;Both integer?
042C40 20 0B       1857*          		JR      NZ,FCOMP1
042C42 CD 57 2C 04 1858*          		CALL    ICP
042C46 3E 00       1859*  FCOMP0:			LD      A,0
042C48 C8          1860*          		RET     Z               ;Equal
042C49 3E 80       1861*          		LD      A,80H
042C4B 1F          1862*          		RRA
042C4C C9          1863*          		RET
042C4D             1864*  ;
042C4D CD D2 2B 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
042C51 CD 65 2C 04 1866*          		CALL    FCP
042C55 18 EF       1867*          		JR      FCOMP0
042C57             1868*  ;
042C57             1869*  ; Integer and floating point compare.
042C57             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
042C57             1871*  ; Result pre-set to FALSE
042C57             1872*  ; ICP1, FCP1 destroy A,F
042C57             1873*  ;
042C57             1874*  ; ZERO - Return zero.
042C57             1875*  ;  Destroys: A,C,H,L,H',L'
042C57             1876*  ;
042C57 CD 8A 2C 04 1877*  ICP:			CALL    ICP1
042C5B 3E 00       1878*  ZERO_FP:			LD      A,0
042C5D D9          1879*          		EXX
042C5E 67          1880*          		LD      H,A
042C5F 6F          1881*  	       		LD      L,A
042C60 D9          1882*          		EXX
042C61 67          1883*        			LD      H,A
042C62 6F          1884*       			LD      L,A
042C63 4F          1885*  	    		LD      C,A
042C64 C9          1886*          		RET
042C65             1887*  ;
042C65 CD 7C 2C 04 1888*  FCP:			CALL    FCP1
042C69 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
042C6B             1890*  ;
042C6B 79          1891*  FCP0:			LD      A,C
042C6C B8          1892*          		CP      B               ;COMPARE EXPONENTS
042C6D C0          1893*          		RET     NZ
042C6E             1894*  ICP0:
042C6E 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
042C71 52 19       1896*          		ADD.S   HL,DE
042C73 C0          1897*          		RET     NZ
042C74 D9          1898*          		EXX
042C75 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
042C78 52 19       1900*          		ADD.S   HL,DE
042C7A D9          1901*          		EXX
042C7B C9          1902*          		RET
042C7C             1903*  ;
042C7C 7C          1904*  FCP1:			LD      A,H
042C7D AA          1905*          		XOR     D
042C7E 7C          1906*          		LD      A,H
042C7F 17          1907*          		RLA
042C80 F8          1908*          		RET     M
042C81 30 E8       1909*          		JR      NC,FCP0
042C83 CD 6B 2C 04 1910*          		CALL    FCP0
042C87 C8          1911*          		RET     Z               ;** V0.1 BUG FIX
042C88 3F          1912*          		CCF
042C89 C9          1913*          		RET
042C8A             1914*  ;
042C8A 7C          1915*  ICP1:			LD      A,H
042C8B AA          1916*          		XOR     D
042C8C F2 6E 2C 04 1917*          		JP      P,ICP0
042C90 7C          1918*          		LD      A,H
042C91 17          1919*          		RLA
042C92 C9          1920*          		RET
042C93             1921*  ;
042C93             1922*  ; ADD - Integer add.
042C93             1923*  ; Carry, sign & zero flags valid on exit
042C93             1924*  ;     Destroys: H,L,H',L',F
042C93             1925*  ;
042C93 05          1926*  X10B:			DEC     B
042C94 0C          1927*          		INC     C
042C95 CD DC 2C 04 1928*  X5:			CALL    COPY0
042C99 CD CF 2C 04 1929*          		CALL    D2C
042C9D CD CF 2C 04 1930*          		CALL    D2C
042CA1 08          1931*          		EX      AF,AF'          ;SAVE CARRY
042CA2 D9          1932*  ADD_:			EXX
042CA3 52 19       1933*          		ADD.S   HL,DE
042CA5 D9          1934*          		EXX
042CA6 52 ED 5A    1935*          		ADC.S   HL,DE
042CA9 C9          1936*          		RET
042CAA             1937*  ;
042CAA             1938*  ; SUB - Integer subtract.
042CAA             1939*  ; Carry, sign & zero flags valid on exit
042CAA             1940*  ;     Destroys: H,L,H',L',F
042CAA             1941*  ;
042CAA D9          1942*  SUB_:			EXX
042CAB B7          1943*          		OR      A
042CAC 52 ED 52    1944*          		SBC.S   HL,DE
042CAF D9          1945*          		EXX
042CB0 52 ED 52    1946*          		SBC.S   HL,DE
042CB3 C9          1947*          		RET
042CB4             1948*  ;
042CB4             1949*  ; X10 - unsigned integer * 10
042CB4             1950*  ;    Inputs: HLH'L' initial value
042CB4             1951*  ;   Outputs: DED'E' = initial HLH'L'
042CB4             1952*  ;            Carry bit set if overflow
042CB4             1953*  ;            If carry not set HLH'L'=result
042CB4             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
042CB4             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
042CB4             1956*  ;     Carry set if MSB=1 before shift.
042CB4             1957*  ;     Sign set if MSB=1 after shift.
042CB4             1958*  ;     Destroys: H,L,H',L',F
042CB4             1959*  ;
042CB4 CD DC 2C 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
042CB8 CD C7 2C 04 1961*          		CALL    X2
042CBC D8          1962*          		RET     C               ;TOO BIG
042CBD CD C7 2C 04 1963*          		CALL    X2
042CC1 D8          1964*          		RET     C
042CC2 CD A2 2C 04 1965*          		CALL    ADD_
042CC6 D8          1966*          		RET     C
042CC7 D9          1967*  X2:			EXX
042CC8 52 29       1968*          		ADD.S   HL,HL
042CCA D9          1969*          		EXX
042CCB 52 ED 6A    1970*          		ADC.S   HL,HL
042CCE C9          1971*          		RET
042CCF             1972*  ;
042CCF             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
042CCF             1974*  ;     Carry set if LSB=1 before shift.
042CCF             1975*  ;     Destroys: H,L,H',L',F
042CCF             1976*  ;
042CCF 0C          1977*  D2C:			INC     C
042CD0 CB 3C       1978*  D2:			SRL     H
042CD2 CB 1D       1979*          		RR      L
042CD4 D9          1980*          		EXX
042CD5 CB 1C       1981*          		RR      H
042CD7 CB 1D       1982*          		RR      L
042CD9 D9          1983*          		EXX
042CDA C9          1984*          		RET
042CDB             1985*  ;
042CDB             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
042CDB             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
042CDB             1988*  ;
042CDB 41          1989*  COPY_:			LD      B,C
042CDC 54          1990*  COPY0:			LD      D,H
042CDD 5D          1991*          		LD      E,L
042CDE D9          1992*          		EXX
042CDF 54          1993*          		LD      D,H
042CE0 5D          1994*          		LD      E,L
042CE1 D9          1995*          		EXX
042CE2 C9          1996*          		RET
042CE3             1997*  ;
042CE3             1998*  ; SQUARE - PUSH X*X
042CE3             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
042CE3             2000*  ;   Destroys: SP,IX
042CE3             2001*  ;
042CE3 CD DB 2C 04 2002*  SQUARE:			CALL    COPY_
042CE7 CD 46 23 04 2003*          		CALL    FMUL
042CEB DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
042CED C5          2005*          		PUSH    BC
042CEE E5          2006*          		PUSH    HL
042CEF D9          2007*          		EXX
042CF0 E5          2008*          		PUSH    HL
042CF1 D9          2009*          		EXX
042CF2 DD E9       2010*          		JP      (IX)            ;"RETURN"
042CF4             2011*  ;
042CF4             2012*  ; POP5 - POP DED'E'B OFF STACK.
042CF4             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
042CF4             2014*  ;
042CF4 DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
042CF6 D9          2016*          		EXX
042CF7 D1          2017*          		POP     DE
042CF8 D9          2018*          		EXX
042CF9 D1          2019*          		POP     DE
042CFA 79          2020*          		LD      A,C
042CFB C1          2021*          		POP     BC
042CFC 41          2022*          		LD      B,C
042CFD 4F          2023*          		LD      C,A
042CFE DD E9       2024*          		JP      (IX)            ;"RETURN"
042D00             2025*  ;
042D00             2026*  ; RATIO - Calculate (X-1)/(X+1)
042D00             2027*  ;     Inputs: X in HLH'L'C
042D00             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
042D00             2029*  ;   Destroys: Everything except IY,SP,I
042D00             2030*  ;
042D00 CD EB 2C 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
042D04 CD 73 26 04 2032*          		CALL    DONE
042D08 CD 34 22 04 2033*          		CALL    FADD
042D0C CD F4 2C 04 2034*          		CALL    POP5            ;RESTORE X
042D10 CD EB 2C 04 2035*          		CALL    PUSH5           ;SAVE X+1
042D14 CD 0F 2C 04 2036*          		CALL    SWAP_FP
042D18 CD 73 26 04 2037*          		CALL    DONE
042D1C CD 1B 22 04 2038*          		CALL    FSUB
042D20 CD F4 2C 04 2039*          		CALL    POP5            ;RESTORE X+1
042D24 C3 9D 22 04 2040*          		JP      FDIV
042D28             2041*  ;
042D28             2042*  ; POLY - Evaluate a polynomial.
042D28             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
042D28             2044*  ;             Polynomial coefficients follow call.
042D28             2045*  ;    Outputs: Result in HLH'L'C
042D28             2046*  ;   Destroys: Everything except IY,SP,I
042D28             2047*  ; Routine terminates on finding a coefficient >=1.
042D28             2048*  ; Note: The last coefficient is EXECUTED on return
042D28             2049*  ;       so must contain only innocuous bytes!
042D28             2050*  ;
042D28 DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
042D2D DD 39       2052*          		ADD     IX, SP
042D2F DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D31             2054*  ;
042D31 CD 07 2A 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
042D35 CD 46 23 04 2056*  POLY1:			CALL    FMUL
042D39 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
042D3D DD 19       2058*          		ADD     IX, DE
042D3F CD 07 2A 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
042D43 DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
042D45 04          2061*          		INC     B
042D46 05          2062*          		DEC     B               		; Test B for end byte (80h)
042D47 FA 34 22 04 2063*          		JP      M,FADD				; Yes, so add and return
042D4B CD 34 22 04 2064*          		CALL    FADD				; No, so add
042D4F CD 19 2A 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
042D53 DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
042D55 18 DE       2067*          		JR      POLY1				; And loop
042D57             2068*  ;
042D57             2069*  ; POWR10 - Calculate power of ten.
042D57             2070*  ;     Inputs: A=power of 10 required (A<128)
042D57             2071*  ;             A=binary exponent to be exceeded (A>=128)
042D57             2072*  ;    Outputs: DED'E'B = result
042D57             2073*  ;             A = actual power of ten returned
042D57             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
042D57             2075*  ;
042D57 3C          2076*  POWR10:			INC     A
042D58 08          2077*          		EX      AF,AF'
042D59 E5          2078*          		PUSH    HL
042D5A D9          2079*          		EXX
042D5B E5          2080*          		PUSH    HL
042D5C D9          2081*          		EXX
042D5D CD 73 26 04 2082*          		CALL    DONE
042D61 CD 0F 2C 04 2083*          		CALL    SWAP_FP
042D65 AF          2084*          		XOR     A
042D66 08          2085*  POWR11:			EX      AF,AF'
042D67 3D          2086*          		DEC     A
042D68 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
042D6A F2 72 2D 04 2088*          		JP      P,POWR13
042D6E B9          2089*          		CP      C
042D6F 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
042D71 3C          2091*          		INC     A
042D72 08          2092*  POWR13:			EX      AF,AF'
042D73 3C          2093*          		INC     A
042D74 CB FC       2094*          		SET     7,H
042D76 CD 95 2C 04 2095*          		CALL    X5
042D7A 30 06       2096*          		JR      NC,POWR12
042D7C 08          2097*          		EX      AF,AF'
042D7D CD CF 2C 04 2098*          		CALL    D2C
042D81 08          2099*          		EX      AF,AF'
042D82 08          2100*  POWR12:			EX      AF,AF'
042D83 DC F7 2B 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
042D87 0C          2102*          		INC     C
042D88 FA 66 2D 04 2103*          		JP      M,POWR11
042D8C C3 26 2C 04 2104*          		JP      OFLOW
042D90 CD 0F 2C 04 2105*  POWR14:			CALL    SWAP_FP
042D94 CB BA       2106*          		RES     7,D
042D96 D9          2107*          		EXX
042D97 E1          2108*          		POP     HL
042D98 D9          2109*          		EXX
042D99 E1          2110*          		POP     HL
042D9A 08          2111*          		EX      AF,AF'
042D9B C9          2112*          		RET
042D9C             2113*  ;
042D9C             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
042D9C             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
042D9C             2116*  ;               Remainder in H'L'HL
042D9C             2117*  ;     Inputs: A = loop counter (normally -32)
042D9C             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
042D9C             2119*  ;
042D9C B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
042D9D             2121*  DIV0:
042D9D 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DA0 D9          2123*          		EXX
042DA1 52 ED 42    2124*          		SBC.S   HL,BC
042DA4 D9          2125*          		EXX
042DA5 30 07       2126*          		JR      NC,DIV1
042DA7 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042DA9 D9          2128*          		EXX
042DAA 52 ED 4A    2129*          		ADC.S   HL,BC
042DAD D9          2130*          		EXX
042DAE 3F          2131*  DIV1:			CCF
042DAF CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
042DB1 CB 12       2133*          		RL      D
042DB3 D9          2134*          		EXX
042DB4 CB 13       2135*          		RL      E
042DB6 CB 12       2136*          		RL      D
042DB8 D9          2137*          		EXX
042DB9 3C          2138*          		INC     A
042DBA F0          2139*          		RET     P
042DBB             2140*  DIVB:
042DBB 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
042DBE D9          2142*          		EXX
042DBF 52 ED 6A    2143*          		ADC.S   HL,HL
042DC2 D9          2144*          		EXX
042DC3 30 D8       2145*          		JR      NC,DIV0
042DC5 B7          2146*          		OR      A
042DC6 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042DC9 D9          2148*          		EXX
042DCA 52 ED 42    2149*          		SBC.S   HL,BC
042DCD D9          2150*          		EXX
042DCE 37          2151*          		SCF
042DCF C3 AF 2D 04 2152*          		JP      DIVC
042DD3             2153*  ;
042DD3             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042DD3             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042DD3             2156*  ;    Inputs: A = loop counter (usually -32)
042DD3             2157*  ;            H'L'HL = 0
042DD3             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
042DD3             2159*  ;
042DD3 B7          2160*  MULA:			OR      A               ;CLEAR CARRY
042DD4 D9          2161*  MUL0:			EXX
042DD5 CB 1A       2162*          		RR      D               ;MULTIPLIER/2
042DD7 CB 1B       2163*          		RR      E
042DD9 D9          2164*          		EXX
042DDA CB 1A       2165*          		RR      D
042DDC CB 1B       2166*          		RR      E
042DDE 30 07       2167*          		JR      NC,MUL1
042DE0 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042DE2 D9          2169*          		EXX
042DE3 52 ED 4A    2170*          		ADC.S   HL,BC
042DE6 D9          2171*          		EXX
042DE7 3C          2172*  MUL1:			INC     A
042DE8 F0          2173*          		RET     P
042DE9 D9          2174*  MULB:			EXX
042DEA CB 1C       2175*          		RR      H               ;PRODUCT/2
042DEC CB 1D       2176*          		RR      L
042DEE D9          2177*          		EXX
042DEF CB 1C       2178*          		RR      H
042DF1 CB 1D       2179*          		RR      L
042DF3 C3 D4 2D 04 2180*          		JP      MUL0
042DF7             2181*  ;
042DF7             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042DF7             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
042DF7             2184*  ;     Inputs: A = loop counter (normally -31)
042DF7             2185*  ;             B'C'BCH'L'HL initialised to 0
042DF7             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042DF7             2187*  ;
042DF7             2188*  SQR1:
042DF7 52 ED 42    2189*  			SBC.S   HL,BC
042DFA D9          2190*          		EXX
042DFB 52 ED 42    2191*          		SBC.S   HL,BC
042DFE D9          2192*          		EXX
042DFF 0C          2193*          		INC     C
042E00 30 09       2194*          		JR      NC,SQR2
042E02 0D          2195*          		DEC     C
042E03 52 09       2196*          		ADD.S   HL,BC
042E05 D9          2197*          		EXX
042E06 52 ED 4A    2198*          		ADC.S   HL,BC
042E09 D9          2199*          		EXX
042E0A 0D          2200*          		DEC     C
042E0B 3C          2201*  SQR2:			INC     A
042E0C F0          2202*          		RET     P
042E0D CB 21       2203*  SQRA:			SLA     C
042E0F CB 10       2204*          		RL      B
042E11 D9          2205*          		EXX
042E12 CB 11       2206*          		RL      C
042E14 CB 10       2207*          		RL      B
042E16 D9          2208*          		EXX
042E17 0C          2209*          		INC     C
042E18 CB 23       2210*          		SLA     E
042E1A CB 12       2211*          		RL      D
042E1C D9          2212*          		EXX
042E1D CB 13       2213*          		RL      E
042E1F CB 12       2214*          		RL      D
042E21 D9          2215*          		EXX
042E22 52 ED 6A    2216*          		ADC.S   HL,HL
042E25 D9          2217*          		EXX
042E26 52 ED 6A    2218*          		ADC.S   HL,HL
042E29 D9          2219*          		EXX
042E2A CB 23       2220*          		SLA     E
042E2C CB 12       2221*          		RL      D
042E2E D9          2222*          		EXX
042E2F CB 13       2223*          		RL      E
042E31 CB 12       2224*          		RL      D
042E33 D9          2225*          		EXX
042E34 52 ED 6A    2226*          		ADC.S   HL,HL
042E37 D9          2227*          		EXX
042E38 52 ED 6A    2228*          		ADC.S   HL,HL
042E3B D9          2229*          		EXX
042E3C D2 F7 2D 04 2230*          		JP      NC,SQR1
042E40 B7          2231*  SQR3:			OR      A
042E41 52 ED 42    2232*          		SBC.S   HL,BC
042E44 D9          2233*          		EXX
042E45 52 ED 42    2234*          		SBC.S   HL,BC
042E48 D9          2235*          		EXX
042E49 0C          2236*          		INC     C
042E4A C3 0B 2E 04 2237*          		JP      SQR2
042E4E             2238*  ;
042E4E             2239*  SQRB:
042E4E 52 29       2240*  			ADD.S   HL,HL
042E50 D9          2241*          		EXX
042E51 52 ED 6A    2242*          		ADC.S   HL,HL
042E54 D9          2243*          		EXX
042E55 38 E9       2244*          		JR      C,SQR3
042E57 3C          2245*          		INC     A
042E58 0C          2246*          		INC     C
042E59 52 ED 42    2247*          		SBC.S   HL,BC
042E5C D9          2248*          		EXX
042E5D 52 ED 42    2249*          		SBC.S   HL,BC
042E60 D9          2250*          		EXX
042E61 D0          2251*          		RET     NC
042E62 52 09       2252*          		ADD.S   HL,BC
042E64 D9          2253*          		EXX
042E65 52 ED 4A    2254*          		ADC.S   HL,BC
042E68 D9          2255*          		EXX
042E69 0D          2256*          		DEC     C
042E6A C9          2257*          		RET
042E6B             2258*  ;
042E6B DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
042E6E FE 3A       2260*          		CP      '9'+1
042E70 3F          2261*          		CCF
042E71 D8          2262*          		RET     C
042E72 FE 30       2263*          		CP      '0'
042E74 C9          2264*          		RET
042E75             2265*  ;
042E75 DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
042E78 DD 23       2267*          		INC     IX
042E7A FE 20       2268*          		CP      ' '
042E7C 28 F7       2269*          		JR      Z,SIGNQ
042E7E FE 2B       2270*          		CP      '+'
042E80 C8          2271*          		RET     Z
042E81 FE 2D       2272*          		CP      '-'
042E83 C8          2273*          		RET     Z
042E84 DD 2B       2274*          		DEC     IX
042E86 C9          2275*          		RET
042E87             0009       include "gpio.asm"
042E87             0001*  ;
042E87             0002*  ; Title:	BBC Basic for AGON - GPIO functions
042E87             0003*  ; Author:	Dean Belfield
042E87             0004*  ; Created:	12/05/2023
042E87             0005*  ; Last Updated:	12/05/2023
042E87             0006*  ;
042E87             0007*  ; Modinfo:
042E87             0008*  
042E87             0009*  			; INCLUDE	"macros.inc"
042E87             0010*  			; INCLUDE	"equs.inc"
042E87             0011*  
042E87             0012*  			; .ASSUME	ADL = 1
042E87             0013*  
042E87             0014*  			; SEGMENT CODE
042E87             0015*  
042E87             0016*  			; XDEF	GPIOB_SETMODE
042E87             0017*  
042E87             0018*  			; XREF	SWITCH_A
042E87             0019*  
042E87             0020*  ;  A: Mode
042E87             0021*  ;  B: Pins
042E87             0022*  ;
042E87 CD 4A 3E 04 0023*  GPIOB_SETMODE:		CALL	SWITCH_A
042E8B 9F 2E       0024*  			DW	GPIOB_M0	; Output
042E8D C4 2E       0025*  			DW	GPIOB_M1	; Input
042E8F E4 2E       0026*  			DW	GPIOB_M2	; Open Drain IO
042E91 04 2F       0027*  			DW	GPIOB_M3	; Open Source IO
042E93 1F 2F       0028*  			DW	GPIOB_M4	; Interrupt, Dual Edge
042E95 4B 2F       0029*  			DW	GPIOB_M5	; Alt Function
042E97 66 2F       0030*  			DW	GPIOB_M6	; Interrupt, Active Low
042E99 8D 2F       0031*  			DW	GPIOB_M7	; Interrupt, Active High
042E9B AF 2F       0032*  			DW	GPIOB_M8	; Interrupt, Falling Edge
042E9D D1 2F       0033*  			DW	GPIOB_M9	; Interrupt, Rising Edge
042E9F             0034*  
042E9F             0035*  ; Output
042E9F             0036*  ;
042E9F             0037*  GPIOB_M0:		RES_GPIO PB_DDR,  B
042E9F C5          0001*M 		PUSH	BC
042EA0 78          0002*M 		LD	A, val
042EA1 2F          0003*M 		CPL
042EA2 4F          0004*M 		LD	C, A
042EA3 ED 38 9B    0005*M 		IN0	A, (reg)
042EA6 A1          0006*M 		AND	C
042EA7 ED 39 9B    0007*M 		OUT0	(reg), A
042EAA C1          0008*M 		POP	BC
042EAB             0038*  			RES_GPIO PB_ALT1, B
042EAB C5          0001*M 		PUSH	BC
042EAC 78          0002*M 		LD	A, val
042EAD 2F          0003*M 		CPL
042EAE 4F          0004*M 		LD	C, A
042EAF ED 38 9C    0005*M 		IN0	A, (reg)
042EB2 A1          0006*M 		AND	C
042EB3 ED 39 9C    0007*M 		OUT0	(reg), A
042EB6 C1          0008*M 		POP	BC
042EB7             0039*  			RES_GPIO PB_ALT2, B
042EB7 C5          0001*M 		PUSH	BC
042EB8 78          0002*M 		LD	A, val
042EB9 2F          0003*M 		CPL
042EBA 4F          0004*M 		LD	C, A
042EBB ED 38 9D    0005*M 		IN0	A, (reg)
042EBE A1          0006*M 		AND	C
042EBF ED 39 9D    0007*M 		OUT0	(reg), A
042EC2 C1          0008*M 		POP	BC
042EC3 C9          0040*  			RET
042EC4             0041*  
042EC4             0042*  ; Input
042EC4             0043*  ;
042EC4             0044*  GPIOB_M1:		SET_GPIO PB_DDR,  B
042EC4 ED 38 9B    0001*M 		IN0	A, (reg)
042EC7 B0          0002*M 		OR	val
042EC8 ED 39 9B    0003*M 		OUT0	(reg), A
042ECB             0045*  			RES_GPIO PB_ALT1, B
042ECB C5          0001*M 		PUSH	BC
042ECC 78          0002*M 		LD	A, val
042ECD 2F          0003*M 		CPL
042ECE 4F          0004*M 		LD	C, A
042ECF ED 38 9C    0005*M 		IN0	A, (reg)
042ED2 A1          0006*M 		AND	C
042ED3 ED 39 9C    0007*M 		OUT0	(reg), A
042ED6 C1          0008*M 		POP	BC
042ED7             0046*  			RES_GPIO PB_ALT2, B
042ED7 C5          0001*M 		PUSH	BC
042ED8 78          0002*M 		LD	A, val
042ED9 2F          0003*M 		CPL
042EDA 4F          0004*M 		LD	C, A
042EDB ED 38 9D    0005*M 		IN0	A, (reg)
042EDE A1          0006*M 		AND	C
042EDF ED 39 9D    0007*M 		OUT0	(reg), A
042EE2 C1          0008*M 		POP	BC
042EE3 C9          0047*  			RET
042EE4             0048*  
042EE4             0049*  ; Open Drain IO
042EE4             0050*  ;
042EE4             0051*  GPIOB_M2:		RES_GPIO PB_DDR,  B
042EE4 C5          0001*M 		PUSH	BC
042EE5 78          0002*M 		LD	A, val
042EE6 2F          0003*M 		CPL
042EE7 4F          0004*M 		LD	C, A
042EE8 ED 38 9B    0005*M 		IN0	A, (reg)
042EEB A1          0006*M 		AND	C
042EEC ED 39 9B    0007*M 		OUT0	(reg), A
042EEF C1          0008*M 		POP	BC
042EF0             0052*  			SET_GPIO PB_ALT1, B
042EF0 ED 38 9C    0001*M 		IN0	A, (reg)
042EF3 B0          0002*M 		OR	val
042EF4 ED 39 9C    0003*M 		OUT0	(reg), A
042EF7             0053*  			RES_GPIO PB_ALT2, B
042EF7 C5          0001*M 		PUSH	BC
042EF8 78          0002*M 		LD	A, val
042EF9 2F          0003*M 		CPL
042EFA 4F          0004*M 		LD	C, A
042EFB ED 38 9D    0005*M 		IN0	A, (reg)
042EFE A1          0006*M 		AND	C
042EFF ED 39 9D    0007*M 		OUT0	(reg), A
042F02 C1          0008*M 		POP	BC
042F03 C9          0054*  			RET
042F04             0055*  
042F04             0056*  ; Open Source IO
042F04             0057*  ;
042F04             0058*  GPIOB_M3:		SET_GPIO PB_DDR,  B
042F04 ED 38 9B    0001*M 		IN0	A, (reg)
042F07 B0          0002*M 		OR	val
042F08 ED 39 9B    0003*M 		OUT0	(reg), A
042F0B             0059*  			SET_GPIO PB_ALT1, B
042F0B ED 38 9C    0001*M 		IN0	A, (reg)
042F0E B0          0002*M 		OR	val
042F0F ED 39 9C    0003*M 		OUT0	(reg), A
042F12             0060*  			RES_GPIO PB_ALT2, B
042F12 C5          0001*M 		PUSH	BC
042F13 78          0002*M 		LD	A, val
042F14 2F          0003*M 		CPL
042F15 4F          0004*M 		LD	C, A
042F16 ED 38 9D    0005*M 		IN0	A, (reg)
042F19 A1          0006*M 		AND	C
042F1A ED 39 9D    0007*M 		OUT0	(reg), A
042F1D C1          0008*M 		POP	BC
042F1E C9          0061*  			RET
042F1F             0062*  
042F1F             0063*  ; Interrupt, Dual Edge
042F1F             0064*  ;
042F1F             0065*  GPIOB_M4:		SET_GPIO PB_DR,   B
042F1F ED 38 9A    0001*M 		IN0	A, (reg)
042F22 B0          0002*M 		OR	val
042F23 ED 39 9A    0003*M 		OUT0	(reg), A
042F26             0066*  			RES_GPIO PB_DDR,  B
042F26 C5          0001*M 		PUSH	BC
042F27 78          0002*M 		LD	A, val
042F28 2F          0003*M 		CPL
042F29 4F          0004*M 		LD	C, A
042F2A ED 38 9B    0005*M 		IN0	A, (reg)
042F2D A1          0006*M 		AND	C
042F2E ED 39 9B    0007*M 		OUT0	(reg), A
042F31 C1          0008*M 		POP	BC
042F32             0067*  			RES_GPIO PB_ALT1, B
042F32 C5          0001*M 		PUSH	BC
042F33 78          0002*M 		LD	A, val
042F34 2F          0003*M 		CPL
042F35 4F          0004*M 		LD	C, A
042F36 ED 38 9C    0005*M 		IN0	A, (reg)
042F39 A1          0006*M 		AND	C
042F3A ED 39 9C    0007*M 		OUT0	(reg), A
042F3D C1          0008*M 		POP	BC
042F3E             0068*  			RES_GPIO PB_ALT2, B
042F3E C5          0001*M 		PUSH	BC
042F3F 78          0002*M 		LD	A, val
042F40 2F          0003*M 		CPL
042F41 4F          0004*M 		LD	C, A
042F42 ED 38 9D    0005*M 		IN0	A, (reg)
042F45 A1          0006*M 		AND	C
042F46 ED 39 9D    0007*M 		OUT0	(reg), A
042F49 C1          0008*M 		POP	BC
042F4A C9          0069*  			RET
042F4B             0070*  
042F4B             0071*  ; Alt Function
042F4B             0072*  ;
042F4B             0073*  GPIOB_M5:		SET_GPIO PB_DDR,  B
042F4B ED 38 9B    0001*M 		IN0	A, (reg)
042F4E B0          0002*M 		OR	val
042F4F ED 39 9B    0003*M 		OUT0	(reg), A
042F52             0074*  			RES_GPIO PB_ALT1, B
042F52 C5          0001*M 		PUSH	BC
042F53 78          0002*M 		LD	A, val
042F54 2F          0003*M 		CPL
042F55 4F          0004*M 		LD	C, A
042F56 ED 38 9C    0005*M 		IN0	A, (reg)
042F59 A1          0006*M 		AND	C
042F5A ED 39 9C    0007*M 		OUT0	(reg), A
042F5D C1          0008*M 		POP	BC
042F5E             0075*  			SET_GPIO PB_ALT2, B
042F5E ED 38 9D    0001*M 		IN0	A, (reg)
042F61 B0          0002*M 		OR	val
042F62 ED 39 9D    0003*M 		OUT0	(reg), A
042F65 C9          0076*  			RET
042F66             0077*  
042F66             0078*  ; Interrupt, Active Low
042F66             0079*  ;
042F66             0080*  GPIOB_M6:		RES_GPIO PB_DR,   B
042F66 C5          0001*M 		PUSH	BC
042F67 78          0002*M 		LD	A, val
042F68 2F          0003*M 		CPL
042F69 4F          0004*M 		LD	C, A
042F6A ED 38 9A    0005*M 		IN0	A, (reg)
042F6D A1          0006*M 		AND	C
042F6E ED 39 9A    0007*M 		OUT0	(reg), A
042F71 C1          0008*M 		POP	BC
042F72             0081*  			RES_GPIO PB_DDR,  B
042F72 C5          0001*M 		PUSH	BC
042F73 78          0002*M 		LD	A, val
042F74 2F          0003*M 		CPL
042F75 4F          0004*M 		LD	C, A
042F76 ED 38 9B    0005*M 		IN0	A, (reg)
042F79 A1          0006*M 		AND	C
042F7A ED 39 9B    0007*M 		OUT0	(reg), A
042F7D C1          0008*M 		POP	BC
042F7E             0082*  			SET_GPIO PB_ALT1, B
042F7E ED 38 9C    0001*M 		IN0	A, (reg)
042F81 B0          0002*M 		OR	val
042F82 ED 39 9C    0003*M 		OUT0	(reg), A
042F85             0083*  			SET_GPIO PB_ALT2, B
042F85 ED 38 9D    0001*M 		IN0	A, (reg)
042F88 B0          0002*M 		OR	val
042F89 ED 39 9D    0003*M 		OUT0	(reg), A
042F8C C9          0084*  			RET
042F8D             0085*  
042F8D             0086*  
042F8D             0087*  ; Interrupt, Active High
042F8D             0088*  ;
042F8D             0089*  GPIOB_M7:		SET_GPIO PB_DR,   B
042F8D ED 38 9A    0001*M 		IN0	A, (reg)
042F90 B0          0002*M 		OR	val
042F91 ED 39 9A    0003*M 		OUT0	(reg), A
042F94             0090*  			RES_GPIO PB_DDR,  B
042F94 C5          0001*M 		PUSH	BC
042F95 78          0002*M 		LD	A, val
042F96 2F          0003*M 		CPL
042F97 4F          0004*M 		LD	C, A
042F98 ED 38 9B    0005*M 		IN0	A, (reg)
042F9B A1          0006*M 		AND	C
042F9C ED 39 9B    0007*M 		OUT0	(reg), A
042F9F C1          0008*M 		POP	BC
042FA0             0091*  			SET_GPIO PB_ALT1, B
042FA0 ED 38 9C    0001*M 		IN0	A, (reg)
042FA3 B0          0002*M 		OR	val
042FA4 ED 39 9C    0003*M 		OUT0	(reg), A
042FA7             0092*  			SET_GPIO PB_ALT2, B
042FA7 ED 38 9D    0001*M 		IN0	A, (reg)
042FAA B0          0002*M 		OR	val
042FAB ED 39 9D    0003*M 		OUT0	(reg), A
042FAE C9          0093*  			RET
042FAF             0094*  
042FAF             0095*  
042FAF             0096*  ; Interrupt, Falling Edge
042FAF             0097*  ;
042FAF             0098*  GPIOB_M8:		RES_GPIO PB_DR,   B
042FAF C5          0001*M 		PUSH	BC
042FB0 78          0002*M 		LD	A, val
042FB1 2F          0003*M 		CPL
042FB2 4F          0004*M 		LD	C, A
042FB3 ED 38 9A    0005*M 		IN0	A, (reg)
042FB6 A1          0006*M 		AND	C
042FB7 ED 39 9A    0007*M 		OUT0	(reg), A
042FBA C1          0008*M 		POP	BC
042FBB             0099*  			SET_GPIO PB_DDR,  B
042FBB ED 38 9B    0001*M 		IN0	A, (reg)
042FBE B0          0002*M 		OR	val
042FBF ED 39 9B    0003*M 		OUT0	(reg), A
042FC2             0100*  			SET_GPIO PB_ALT1, B
042FC2 ED 38 9C    0001*M 		IN0	A, (reg)
042FC5 B0          0002*M 		OR	val
042FC6 ED 39 9C    0003*M 		OUT0	(reg), A
042FC9             0101*  			SET_GPIO PB_ALT2, B
042FC9 ED 38 9D    0001*M 		IN0	A, (reg)
042FCC B0          0002*M 		OR	val
042FCD ED 39 9D    0003*M 		OUT0	(reg), A
042FD0 C9          0102*  			RET
042FD1             0103*  
042FD1             0104*  ; Interrupt, Rising Edge
042FD1             0105*  ;
042FD1             0106*  GPIOB_M9:		SET_GPIO PB_DR,   B
042FD1 ED 38 9A    0001*M 		IN0	A, (reg)
042FD4 B0          0002*M 		OR	val
042FD5 ED 39 9A    0003*M 		OUT0	(reg), A
042FD8             0107*  			SET_GPIO PB_DDR,  B
042FD8 ED 38 9B    0001*M 		IN0	A, (reg)
042FDB B0          0002*M 		OR	val
042FDC ED 39 9B    0003*M 		OUT0	(reg), A
042FDF             0108*  			SET_GPIO PB_ALT1, B
042FDF ED 38 9C    0001*M 		IN0	A, (reg)
042FE2 B0          0002*M 		OR	val
042FE3 ED 39 9C    0003*M 		OUT0	(reg), A
042FE6             0109*  			SET_GPIO PB_ALT2, B
042FE6 ED 38 9D    0001*M 		IN0	A, (reg)
042FE9 B0          0002*M 		OR	val
042FEA ED 39 9D    0003*M 		OUT0	(reg), A
042FED C9          0110*  			RET
042FEE             0010       include "main.asm"
042FEE             0001*  ;
042FEE             0002*  ; Title:	BBC Basic Interpreter - Z80 version
042FEE             0003*  ;		Command, Error and Lexical Analysis Module - "MAIN"
042FEE             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
042FEE             0005*  ; Modified By:	Dean Belfield
042FEE             0006*  ; Created:	12/05/2023
042FEE             0007*  ; Last Updated:	26/11/2023
042FEE             0008*  ;
042FEE             0009*  ; Modinfo:
042FEE             0010*  ; 07/05/1984:	Version 2.3
042FEE             0011*  ; 01/03/1987:	Version 3.0
042FEE             0012*  ; 03/05/2022:	Modified by Dean Belfield
042FEE             0013*  ; 06/06/2023:	Modified to run in ADL mode
042FEE             0014*  ; 26/06/2023:	Fixed binary and unary indirection
042FEE             0015*  ; 17/08/2023:	Added binary constants
042FEE             0016*  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
042FEE             0017*  ; 26/11/2023:	Fixed bug in AUTOLOAD
042FEE             0018*  
042FEE             0019*  			; .ASSUME	ADL = 1
042FEE             0020*  
042FEE             0021*  			; INCLUDE	"equs.inc"
042FEE             0022*  
042FEE             0023*  			; SEGMENT CODE
042FEE             0024*  
042FEE             0025*  			; XDEF	_main
042FEE             0026*  
042FEE             0027*  			; XDEF	COLD
042FEE             0028*  			; XDEF	WARM
042FEE             0029*  			; XDEF	CLOOP
042FEE             0030*  			; XDEF	DELETE
042FEE             0031*  			; XDEF	LIST_
042FEE             0032*  			; XDEF	RENUM
042FEE             0033*  			; XDEF	AUTO
042FEE             0034*  			; XDEF	NEW
042FEE             0035*  			; XDEF	OLD
042FEE             0036*  			; XDEF	LOAD
042FEE             0037*  			; XDEF	SAVE
042FEE             0038*  			; XDEF	ERROR_
042FEE             0039*  			; XDEF	EXTERR
042FEE             0040*  			; XDEF	LOAD0
042FEE             0041*  			; XDEF	CLEAR
042FEE             0042*  			; XDEF	CRLF
042FEE             0043*  			; XDEF	OUTCHR
042FEE             0044*  			; XDEF	OUT_
042FEE             0045*  			; XDEF	FINDL
042FEE             0046*  			; XDEF	SETLIN
042FEE             0047*  			; XDEF	PBCDL
042FEE             0048*  			; XDEF	SAYLN
042FEE             0049*  			; XDEF	PUTVAR
042FEE             0050*  			; XDEF	GETVAR
042FEE             0051*  			; XDEF	GETDEF
042FEE             0052*  			; XDEF	CREATE
042FEE             0053*  			; XDEF	RANGE
042FEE             0054*  			; XDEF	LEXAN2
042FEE             0055*  			; XDEF	REPORT
042FEE             0056*  			; XDEF	TELL
042FEE             0057*  			; XDEF	SPACE_
042FEE             0058*  			; XDEF	KEYWDS
042FEE             0059*  			; XDEF	KEYWDL
042FEE             0060*  			; XDEF	ONEDIT
042FEE             0061*  			; XDEF	ONEDIT1
042FEE             0062*  			; XDEF	LISTIT
042FEE             0063*  			; XDEF	CLEAN
042FEE             0064*  
042FEE             0065*  			; XREF	LISTON
042FEE             0066*  			; XREF	ERRTXT
042FEE             0067*  			; XREF	OSINIT
042FEE             0068*  			; XREF	HIMEM
042FEE             0069*  			; XREF	PAGE_
042FEE             0070*  			; XREF	CHAIN0
042FEE             0071*  			; XREF	PROMPT
042FEE             0072*  			; XREF	ERRTRP
042FEE             0073*  			; XREF	ERRLIN
042FEE             0074*  			; XREF	AUTONO
042FEE             0075*  			; XREF	LINENO
042FEE             0076*  			; XREF	INCREM
042FEE             0077*  			; XREF	OSLINE
042FEE             0078*  			; XREF	COUNT
042FEE             0079*  			; XREF	NXT
042FEE             0080*  			; XREF	BUFFER
042FEE             0081*  			; XREF	XEQ
042FEE             0082*  			; XREF	TOP
042FEE             0083*  			; XREF	EXPRI
042FEE             0084*  			; XREF	SEARCH
042FEE             0085*  			; XREF	LTRAP
042FEE             0086*  			; XREF	LOMEM
042FEE             0087*  			; XREF	DECODE
042FEE             0088*  			; XREF	EXPRS
042FEE             0089*  			; XREF	OSSAVE
042FEE             0090*  			; XREF	ERR
042FEE             0091*  			; XREF	ERL
042FEE             0092*  			; XREF	TRACEN
042FEE             0093*  			; XREF	RESET
042FEE             0094*  			; XREF	OSSHUT
042FEE             0095*  			; XREF	OSLOAD
042FEE             0096*  			; XREF	FREE
042FEE             0097*  			; XREF	DYNVAR
042FEE             0098*  			; XREF	FILL
042FEE             0099*  			; XREF	OSWRCH
042FEE             0100*  			; XREF	WIDTH
042FEE             0101*  			; XREF	COMMA
042FEE             0102*  			; XREF	MUL16
042FEE             0103*  			; XREF	BRAKET
042FEE             0104*  			; XREF	X4OR5
042FEE             0105*  			; XREF	LOADN
042FEE             0106*  			; XREF	SFIX
042FEE             0107*  			; XREF	ITEMI
042FEE             0108*  			; XREF	FNPTR
042FEE             0109*  			; XREF	PROPTR
042FEE             0110*  			; XREF	CHECK
042FEE             0111*  			; XREF	TERMQ
042FEE             0112*  			; XREF	OSWRCHCH
042FEE             0113*  			; XREF	NEWIT
042FEE             0114*  			; XREF	BAD
042FEE             0115*  			; XREF	RAM_START
042FEE             0116*  			; XREF	RAM_END
042FEE             0117*  			; XREF	R0
042FEE             0118*  			; XREF	STAR_VERSION
042FEE             0119*  
042FEE             0120*  			; XREF	_end			; In init.asm
042FEE             0121*  
042FEE             0122*  ;
042FEE             0123*  ; This defines the block of tokens that are pseudo-variables.
042FEE             0124*  ; There are two versions of each token, a GET and a SET
042FEE             0125*  
042FEE             0126*  ; Name  : GET : SET
042FEE             0127*  ; ------:-----:----
042FEE             0128*  ; PTR   : 8Fh : CFh
042FEE             0129*  ; PAGE  : 90h : D0h
042FEE             0130*  ; TIME  : 91h : D1h
042FEE             0131*  ; LOMEM : 92h : D2h
042FEE             0132*  ; HIMEM : 93h : D3h
042FEE             0133*  ;
042FEE             0134*  ; Examples:
042FEE             0135*  ;   LET A% = PAGE : REM This is the GET version
042FEE             0136*  ;   PAGE = 40000  : REM This is the SET version
042FEE             0137*  ;
042FEE             0138*  ; TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
042FEE             0139*  ; TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
042FEE             0140*  ; OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
042FEE             0141*  
042FEE             0142*  ; The main routine
042FEE             0143*  ; IXU: argv - pointer to array of parameters
042FEE             0144*  ;   C: argc - number of parameters
042FEE             0145*  ; Returns:
042FEE             0146*  ;  HL: Error code, or 0 if OK
042FEE             0147*  ;
042FEE 21 00 4A 04 0148*  _main:			LD	HL, ACCS		; Clear the ACCS
042FF2 36 00       0149*  			LD	(HL), 0
042FF4 79          0150*  			LD	A, C
042FF5 FE 02       0151*  			CP	2
042FF7 28 2D       0152*  			JR	Z, AUTOLOAD		; 2 parameters = autoload
042FF9 38 3F       0153*  			JR	C, COLD			; 1 parameter = normal start
042FFB CD 9F 40 04 0154*  			CALL	STAR_VERSION
042FFF CD E6 3D 04 0155*  			CALL	TELL
043003 55 73 61 67 0156*  			DB	"Usage:\n\r"
       65 3A 0A 0D 
04300B 52 55 4E 20 0157*  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
04301E 21 00 00 00 0158*  			LD	HL, 0			; The error code
043022 C3 68 00 04 0159*  			JP	_end
043026             0160*  ;
043026 DD 27 03    0161*  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043029 11 00 4A 04 0162*  			LD	DE, ACCS		;  DE: Destination address
04302D 7E          0163*  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
04302E 12          0164*  			LD	(DE), A			;
04302F 23          0165*  			INC	HL			; Increase the source pointer
043030 1C          0166*  			INC	E			; We only need to increase E as ACCS is on a page boundary
043031 28 03       0167*  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
043033 B7          0168*  			OR	A
043034 20 F7       0169*  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043036 1D          0170*  AUTOLOAD_2:		DEC	E
043037 3E 0D       0171*  			LD	A, CR
043039 12          0172*  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
04303A             0173*  ;
04303A E1          0174*  COLD:			POP	HL			; Pop the return address to init off SPS
04303B E5          0175*  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04303C 21 00 4C 04 0176*  			LD	HL, STAVAR		; Cold start
043040 F9          0177*  			LD	SP, HL
043041 36 0A       0178*  			LD	(HL), 10
043043 23          0179*  			INC	HL
043044 36 09       0180*  			LD	(HL),9
043046 CD D7 3F 04 0181*  			CALL    OSINIT			; Call the machine specific OS initialisation routines
04304A ED 53 20 4D 0182*  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
04304F 22 14 4D 04 0183*  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043053 3E B7       0184*  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043055 32 40 4D 04 0185*  			LD      (LISTON),A
043059 21 B2 30 04 0186*  			LD      HL,NOTICE
04305D 22 2F 4D 04 0187*  			LD      (ERRTXT),HL
043061 CD C2 38 04 0188*  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043065 3A 00 4A 04 0189*  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043069 B7          0190*  			OR	A
04306A C2 5B 0B 04 0191*  			JP	NZ,CHAIN0		; Yes, so load and run
04306E CD 9F 40 04 0192*  			CALL	STAR_VERSION		;
043072 CD E6 3D 04 0193*  			CALL    TELL			; Output the welcome message
043076 42 42 43 20 0194*  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
043094 45 5A 38 30 0195*  			db      "EZ80ASM ADL Version 0.01beta\n\r"
       41 53 4D 20 
       41 44 4C 20 
       56 65 72 73 
       69 6F 6E 20 
       30 2E 30 31 
       62 65 74 61 
       0A 0D       
0430B2 28 43 29 20 0196*  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0430D2 0A 0D 00    0197*  			DB	"\n\r", 0
0430D5             0198*  ;
0430D5 F6          0199*  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0430D6             0200*  ;
0430D6             0201*  ; This is the main entry point for BASIC
0430D6             0202*  ;
0430D6 37          0203*  CLOOP:			SCF				; See above - not sure why this is here!
0430D7 ED 7B 20 4D 0204*  			LD      SP,(HIMEM)
       04          
0430DC CD 50 3F 04 0205*  			CALL    PROMPT          	; Prompt user
0430E0 21 40 4D 04 0206*  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0430E4 7E          0207*  			LD      A,(HL)			; Fetch the value
0430E5 E6 0F       0208*  			AND     0FH             	; Bottom nibble: LISTO
0430E7 F6 B0       0209*  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0430E9 77          0210*  			LD      (HL),A			; Store back in
0430EA ED 62       0211*  			SBC     HL,HL           	; HL: 0
0430EC 22 2C 4D 04 0212*  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0430F0 22 35 4D 04 0213*  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0430F4             0214*  ;
0430F4 2A 29 4D 04 0215*  			LD      HL,(AUTONO)		; Get the auto line number
0430F8 22 23 4D 04 0216*  			LD      (LINENO),HL		; Store in line number
0430FC 7C          0217*  			LD      A,H			; If the auto line number is zero then
0430FD B5          0218*  			OR      L
0430FE 28 1E       0219*  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
043100             0220*  ;
043100             0221*  ; This section handles auto line numbering
043100             0222*  ;
043100 E5          0223*  			PUSH    HL			; Stack the line number
043101 CD 51 3A 04 0224*  			CALL    PBCD           	 	; Output the line number
043105 E1          0225*  			POP     HL			; Pop the line number back off the stack
043106             0226*  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
043106             0227*  ;			LD      B,0			; So clear B
043106 01 00 00 00 0228*  			LD	BC, 0			; Load BC with Increment
04310A 3A 41 4D 04 0229*  			LD	A,(INCREM)
04310E 4F          0230*  			LD	C, A
04310F 09          0231*  			ADD     HL,BC			; Add the increment to the line number
043110 DA 7B 3C 04 0232*  			JP      C,TOOBIG		; And error if we wrap
043114 22 29 4D 04 0233*  			LD      (AUTONO),HL		; Store the new auto line number
043118 3E 20       0234*  			LD      A,' '			; Print a space
04311A CD A5 39 04 0235*  			CALL    OUTCHR
04311E             0236*  ;
04311E             0237*  ; This section invokes the line editor
04311E             0238*  ;
04311E 21 00 4A 04 0239*  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
043122 CD B5 3E 04 0240*  			CALL    OSLINE          	; Call the line editor in MOS
043126 CD 32 31 04 0241*  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
04312A DC 95 38 04 0242*  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
04312E C3 D6 30 04 0243*  			JP      CLOOP			; Jump back to immediate mode
043132             0244*  ;
043132             0245*  ; This bit enters the line into memory
043132             0246*  ; Also called from OSLOAD_TXT
043132             0247*  ; Returns:
043132             0248*  ; F: C if a new line has been entered (CLEAN will need to be called)
043132             0249*  ;
043132 AF          0250*  ONEDIT1:		XOR     A			; Entry point after *EDIT
043133 32 3D 4D 04 0251*  			LD      (COUNT),A
043137 FD 21 00 4A 0252*  			LD      IY,ACCS
       04          
04313C CD 4F 3C 04 0253*  			CALL    LINNUM			; HL: The line number from the input buffer
043140 CD 78 0A 04 0254*  			CALL    NXT			; Skip spaces
043144 7C          0255*  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043145 B5          0256*  			OR      L
043146 28 04       0257*  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043148 22 23 4D 04 0258*  			LD      (LINENO),HL		; Otherwise store it
04314C             0259*  ;
04314C             0260*  ; This bit does the lexical analysis and tokenisation
04314C             0261*  ;
04314C 0E 01       0262*  LNZERO:			LD	C,1			; Left mode
04314E 11 00 4B 04 0263*  			LD      DE,BUFFER		; Buffer for tokenised BASIC
043152 CD F5 3C 04 0264*  			CALL    LEXAN2          	; Lexical analysis on the user input
043156 12          0265*  			LD      (DE),A          	; Terminator
043157 AF          0266*  			XOR     A
043158             0267*  ;			LD      B,A
043158             0268*  ;			LD      C,E             	; BC: Line length
043158 01 00 00 00 0269*  			LD	BC,0
04315C 4B          0270*  			LD	C,E			; BC: Line length
04315D 13          0271*  			INC     DE
04315E 12          0272*  			LD      (DE),A          	; Zero next
04315F 2A 23 4D 04 0273*  			LD      HL,(LINENO)		; Get the line number
043163 7C          0274*  			LD      A,H			; Is it zero, i.e. a command with no line number?
043164 B5          0275*  			OR      L
043165 FD 21 00 4B 0276*  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
04316A CA 9E 0B 04 0277*  			JP      Z,XEQ           	; Execute it
04316E             0278*  ;
04316E             0279*  ; This section stores the BASIC line in memory
04316E             0280*  ;
04316E C5          0281*  			PUSH    BC
04316F E5          0282*  			PUSH    HL
043170 CD A1 38 04 0283*  			CALL    SETTOP          	; Set TOP sysvar
043174 E1          0284*  			POP     HL
043175 CD E5 39 04 0285*  			CALL    FINDL			; Find the address of the line
043179 CC 58 38 04 0286*  			CALL    Z,DEL			; Delete the existing line if found
04317D C1          0287*  			POP     BC
04317E 79          0288*  			LD      A,C			; Check for the line length being zero, i.e.
04317F B7          0289*  			OR      A			; the user has just entered a line number in the command line
043180 C8          0290*  			RET	Z 	         	; If so, then don't do anything else
043181 C6 04       0291*  			ADD     A,4
043183 4F          0292*  			LD      C,A             	; Length inclusive
043184 D5          0293*  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043185 C5          0294*  			PUSH    BC              	; BC: Line length
043186 EB          0295*  			EX      DE,HL			; DE: Address of the line in memory
043187 2A 17 4D 04 0296*  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
04318B E5          0297*  			PUSH    HL			; Stack TOP (current TOP value)
04318C 09          0298*  			ADD     HL,BC			; Add the line length to HL, the new TOP value
04318D E5          0299*  			PUSH    HL			; Stack HL (new TOP value)
04318E 24          0300*  			INC     H			; Add 256 to HL
04318F AF          0301*  			XOR     A
043190 ED 72       0302*  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
043192 E1          0303*  			POP     HL			; Pop HL (new TOP value)
043193 D2 B6 37 04 0304*  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043197 22 17 4D 04 0305*  			LD      (TOP),HL		; Store new value of TOP
04319B E3          0306*  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
04319C E5          0307*  			PUSH    HL			; PUSH current TOP value
04319D 23          0308*  			INC     HL
04319E B7          0309*  			OR      A
04319F ED 52       0310*  			SBC     HL,DE			; DE: Address of the line in memory
0431A1 44          0311*  			LD      B,H             	; BC: Amount to move
0431A2 4D          0312*  			LD      C,L
0431A3 E1          0313*  			POP     HL			; HL: Destination (current TOP value)
0431A4 D1          0314*  			POP     DE			; DE: Source (new TOP value)
0431A5 28 02       0315*  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0431A7 ED B8       0316*  			LDDR                    	; Otherwise, make space for the new line in the program
0431A9 C1          0317*  ATEND:			POP     BC              	; BC: Line length
0431AA D1          0318*  			POP     DE              	; DE: Line number
0431AB 23          0319*  			INC     HL			; HL: Destination address
0431AC 71          0320*  			LD      (HL),C          	; Store length
0431AD 23          0321*  			INC     HL
0431AE 73          0322*  			LD      (HL),E          	; Store line number
0431AF 23          0323*  			INC     HL
0431B0 72          0324*  			LD      (HL),D
0431B1 23          0325*  			INC     HL
0431B2 11 00 4B 04 0326*  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0431B6 EB          0327*  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0431B7 0D          0328*  			DEC     C			; Subtract 3 from the number of bytes to copy to
0431B8 0D          0329*  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0431B9 0D          0330*  			DEC     C
0431BA ED B0       0331*  			LDIR                    	; Add the line to the BASIC program
0431BC 37          0332*  			SCF				; To flag we need to call CLEAN
0431BD C9          0333*  			RET
0431BE             0334*  ;
0431BE             0335*  ; List of tokens and keywords. If a keyword is followed by 0 then
0431BE             0336*  ; it will only match with the keyword followed immediately by
0431BE             0337*  ; a delimiter
0431BE             0338*  ;
0431BE 80 41 4E 44 0339*  KEYWDS:			DB    80H, "AND"
0431C2 94 41 42 53 0340*  			DB    94H, "ABS"
0431C6 95 41 43 53 0341*  			DB    95H, "ACS"
0431CA 96 41 44 56 0342*  			DB    96H, "ADVAL"
       41 4C       
0431D0 97 41 53 43 0343*  			DB    97H, "ASC"
0431D4 98 41 53 4E 0344*  			DB    98H, "ASN"
0431D8 99 41 54 4E 0345*  			DB    99H, "ATN"
0431DC C6 41 55 54 0346*  			DB    C6H, "AUTO"
       4F          
0431E1 9A 42 47 45 0347*  			DB    9AH, "BGET", 0
       54 00       
0431E7 D5 42 50 55 0348*  			DB    D5H, "BPUT", 0
       54 00       
0431ED FB 43 4F 4C 0349*  			DB    FBH, "COLOUR"
       4F 55 52    
0431F4 FB 43 4F 4C 0350*  			DB    FBH, "COLOR"
       4F 52       
0431FA D6 43 41 4C 0351*  			DB    D6H, "CALL"
       4C          
0431FF D7 43 48 41 0352*  			DB    D7H, "CHAIN"
       49 4E       
043205 BD 43 48 52 0353*  			DB    BDH, "CHR$"
       24          
04320A D8 43 4C 45 0354*  			DB    D8H, "CLEAR", 0
       41 52 00    
043211 D9 43 4C 4F 0355*  			DB    D9H, "CLOSE", 0
       53 45 00    
043218 DA 43 4C 47 0356*  			DB    DAH, "CLG", 0
       00          
04321D DB 43 4C 53 0357*  			DB    DBH, "CLS", 0
       00          
043222 9B 43 4F 53 0358*  			DB    9BH, "COS"
043226 9C 43 4F 55 0359*  			DB    9CH, "COUNT", 0
       4E 54 00    
04322D DC 44 41 54 0360*  			DB    DCH, "DATA"
       41          
043232 9D 44 45 47 0361*  			DB    9DH, "DEG"
043236 DD 44 45 46 0362*  			DB    DDH, "DEF"
04323A C7 44 45 4C 0363*  			DB    C7H, "DELETE"
       45 54 45    
043241 81 44 49 56 0364*  			DB    81H, "DIV"
043245 DE 44 49 4D 0365*  			DB    DEH, "DIM"
043249 DF 44 52 41 0366*  			DB    DFH, "DRAW"
       57          
04324E E1 45 4E 44 0367*  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043257 E0 45 4E 44 0368*  			DB    E0H, "END", 0
       00          
04325C E2 45 4E 56 0369*  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
043265 8B 45 4C 53 0370*  			DB    8BH, "ELSE"
       45          
04326A A0 45 56 41 0371*  			DB    A0H, "EVAL"
       4C          
04326F 9E 45 52 4C 0372*  			DB    9EH, "ERL", 0
       00          
043274 85 45 52 52 0373*  			DB    85H, "ERROR"
       4F 52       
04327A C5 45 4F 46 0374*  			DB    C5H, "EOF", 0
       00          
04327F 82 45 4F 52 0375*  			DB    82H, "EOR"
043283 9F 45 52 52 0376*  			DB    9FH, "ERR", 0
       00          
043288 A1 45 58 50 0377*  			DB    A1H, "EXP"
04328C A2 45 58 54 0378*  			DB    A2H, "EXT", 0
       00          
043291 E3 46 4F 52 0379*  			DB    E3H, "FOR"
043295 A3 46 41 4C 0380*  			DB    A3H, "FALSE", 0
       53 45 00    
04329C A4 46 4E    0381*  			DB    A4H, "FN"
04329F E5 47 4F 54 0382*  			DB    E5H, "GOTO"
       4F          
0432A4 BE 47 45 54 0383*  			DB    BEH, "GET$"
       24          
0432A9 A5 47 45 54 0384*  			DB    A5H, "GET"
0432AD E4 47 4F 53 0385*  			DB    E4H, "GOSUB"
       55 42       
0432B3 E6 47 43 4F 0386*  			DB    E6H, "GCOL"
       4C          
0432B8 93 48 49 4D 0387*  			DB    93H, "HIMEM", 0
       45 4D 00    
0432BF E8 49 4E 50 0388*  			DB    E8H, "INPUT"
       55 54       
0432C5 E7 49 46    0389*  			DB    E7H, "IF"
0432C8 BF 49 4E 4B 0390*  			DB    BFH, "INKEY$"
       45 59 24    
0432CF A6 49 4E 4B 0391*  			DB    A6H, "INKEY"
       45 59       
0432D5 A8 49 4E 54 0392*  			DB    A8H, "INT"
0432D9 A7 49 4E 53 0393*  			DB    A7H, "INSTR("
       54 52 28    
0432E0 C9 4C 49 53 0394*  			DB    C9H, "LIST"
       54          
0432E5 86 4C 49 4E 0395*  			DB    86H, "LINE"
       45          
0432EA C8 4C 4F 41 0396*  			DB    C8H, "LOAD"
       44          
0432EF 92 4C 4F 4D 0397*  			DB    92H, "LOMEM", 0
       45 4D 00    
0432F6 EA 4C 4F 43 0398*  			DB    EAH, "LOCAL"
       41 4C       
0432FC C0 4C 45 46 0399*  			DB    C0H, "LEFT$("
       54 24 28    
043303 A9 4C 45 4E 0400*  			DB    A9H, "LEN"
043307 E9 4C 45 54 0401*  			DB    E9H, "LET"
04330B AB 4C 4F 47 0402*  			DB    ABH, "LOG"
04330F AA 4C 4E    0403*  			DB    AAH, "LN"
043312 C1 4D 49 44 0404*  			DB    C1H, "MID$("
       24 28       
043318 EB 4D 4F 44 0405*  			DB    EBH, "MODE"
       45          
04331D 83 4D 4F 44 0406*  			DB    83H, "MOD"
043321 EC 4D 4F 56 0407*  			DB    ECH, "MOVE"
       45          
043326 ED 4E 45 58 0408*  			DB    EDH, "NEXT"
       54          
04332B CA 4E 45 57 0409*  			DB    CAH, "NEW", 0
       00          
043330 AC 4E 4F 54 0410*  			DB    ACH, "NOT"
043334 CB 4F 4C 44 0411*  			DB    CBH, "OLD", 0
       00          
043339 EE 4F 4E    0412*  			DB    EEH, "ON"
04333C 87 4F 46 46 0413*  			DB    87H, "OFF"
043340 84 4F 52    0414*  			DB    84H, "OR"
043343 8E 4F 50 45 0415*  			DB    8EH, "OPENIN"
       4E 49 4E    
04334A AE 4F 50 45 0416*  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
043352 AD 4F 50 45 0417*  			DB    ADH, "OPENUP"
       4E 55 50    
043359 FF 4F 53 43 0418*  			DB    FFH, "OSCLI"
       4C 49       
04335F F1 50 52 49 0419*  			DB    F1H, "PRINT"
       4E 54       
043365 90 50 41 47 0420*  			DB    90H, "PAGE", 0
       45 00       
04336B 8F 50 54 52 0421*  			DB    8FH, "PTR", 0
       00          
043370 AF 50 49 00 0422*  			DB    AFH, "PI", 0
043374 F0 50 4C 4F 0423*  			DB    F0H, "PLOT"
       54          
043379 B0 50 4F 49 0424*  			DB    B0H, "POINT("
       4E 54 28    
043380 F2 50 52 4F 0425*  			DB    F2H, "PROC"
       43          
043385 B1 50 4F 53 0426*  			DB    B1H, "POS", 0
       00          
04338A CE 50 55 54 0427*  			DB    CEH, "PUT"
04338E F8 52 45 54 0428*  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043396 F5 52 45 50 0429*  			DB    F5H, "REPEAT"
       45 41 54    
04339D F6 52 45 50 0430*  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0433A5 F3 52 45 41 0431*  			DB    F3H, "READ"
       44          
0433AA F4 52 45 4D 0432*  			DB    F4H, "REM"
0433AE F9 52 55 4E 0433*  			DB    F9H, "RUN", 0
       00          
0433B3 B2 52 41 44 0434*  			DB    B2H, "RAD"
0433B7 F7 52 45 53 0435*  			DB    F7H, "RESTORE"
       54 4F 52 45 
0433BF C2 52 49 47 0436*  			DB    C2H, "RIGHT$("
       48 54 24 28 
0433C7 B3 52 4E 44 0437*  			DB    B3H, "RND", 0
       00          
0433CC CC 52 45 4E 0438*  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0433D5 88 53 54 45 0439*  			DB    88H, "STEP"
       50          
0433DA CD 53 41 56 0440*  			DB    CDH, "SAVE"
       45          
0433DF B4 53 47 4E 0441*  			DB    B4H, "SGN"
0433E3 B5 53 49 4E 0442*  			DB    B5H, "SIN"
0433E7 B6 53 51 52 0443*  			DB    B6H, "SQR"
0433EB 89 53 50 43 0444*  			DB    89H, "SPC"
0433EF C3 53 54 52 0445*  			DB    C3H, "STR$"
       24          
0433F4 C4 53 54 52 0446*  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0433FD D4 53 4F 55 0447*  			DB    D4H, "SOUND"
       4E 44       
043403 FA 53 54 4F 0448*  			DB    FAH, "STOP", 0
       50 00       
043409 B7 54 41 4E 0449*  			DB    B7H, "TAN"
04340D 8C 54 48 45 0450*  			DB    8CH, "THEN"
       4E          
043412 B8 54 4F    0451*  			DB    B8H, "TO"
043415 8A 54 41 42 0452*  			DB    8AH, "TAB("
       28          
04341A FC 54 52 41 0453*  			DB    FCH, "TRACE"
       43 45       
043420 91 54 49 4D 0454*  			DB    91H, "TIME", 0
       45 00       
043426 B9 54 52 55 0455*  			DB    B9H, "TRUE", 0
       45 00       
04342C FD 55 4E 54 0456*  			DB    FDH, "UNTIL"
       49 4C       
043432 BA 55 53 52 0457*  			DB    BAH, "USR"
043436 EF 56 44 55 0458*  			DB    EFH, "VDU"
04343A BB 56 41 4C 0459*  			DB    BBH, "VAL"
04343E BC 56 50 4F 0460*  			DB    BCH, "VPOS", 0
       53 00       
043444 FE 57 49 44 0461*  			DB    FEH, "WIDTH"
       54 48       
04344A D3 48 49 4D 0462*  			DB    D3H, "HIMEM"
       45 4D       
043450 D2 4C 4F 4D 0463*  			DB    D2H, "LOMEM"
       45 4D       
043456 D0 50 41 47 0464*  			DB    D0H, "PAGE"
       45          
04345B CF 50 54 52 0465*  			DB    CFH, "PTR"
04345F D1 54 49 4D 0466*  			DB    D1H, "TIME"
       45          
043464             0467*  ;
043464             0468*  ; These are indexed from the ERRWDS table
043464             0469*  ;
043464 01 4D 69 73 0470*  			DB    01H, "Missing "
       73 69 6E 67 
       20          
04346D 02 4E 6F 20 0471*  			DB    02H, "No such "
       73 75 63 68 
       20          
043476 03 42 61 64 0472*  			DB    03H, "Bad "
       20          
04347B 04 20 72 61 0473*  			DB    04H, " range"
       6E 67 65    
043482 05 76 61 72 0474*  			DB    05H, "variable"
       69 61 62 6C 
       65          
04348B 06 4F 75 74 0475*  			DB    06H, "Out of"
       20 6F 66    
043492 07 4E 6F 20 0476*  			DB    07H, "No "
043496 08 20 73 70 0477*  			DB    08H, " space"
       61 63 65    
04349D             0478*  
04349D             0479*  KEYWDL:			EQU     $-KEYWDS
04349D FF FF       0480*  			DW    -1
04349F             0481*  ;
04349F             0482*  ; Error messages
04349F             0483*  ;
04349F 07 72 6F 6F 0484*  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0434A5 06 04 00    0485*  			DB    6, 4, 0			;  1: Out of range
0434A8 00          0486*  			DB    0				;  2: *
0434A9 00          0487*  			DB    0				;  3: *
0434AA 4D 69 73 74 0488*  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0434B2 01 2C 00    0489*  			DB    1, ",", 0			;  5: Missing ,
0434B5 54 79 70 65 0490*  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0434C3 07 A4 00    0491*  			DB    7, FN, 0			;  7: No FN
0434C6 00          0492*  			DB    0				;  8: *
0434C7 01 22 00    0493*  			DB    1, 34, 0			;  9: Missing "
0434CA 03 DE 00    0494*  			DB    3, DIM, 0			; 10: Bad DIM
0434CD DE 08 00    0495*  			DB    DIM, 8, 0			; 11: DIM space
0434D0 4E 6F 74 20 0496*  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0434D6 07 F2 00    0497*  			DB    7, PROC, 0		; 13: No PROC
0434D9 41 72 72 61 0498*  			DB    "Array", 0		; 14: Array
       79 00       
0434DF 53 75 62 73 0499*  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0434E9 53 79 6E 74 0500*  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0434F6 45 73 63 61 0501*  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0434FD 44 69 76 69 0502*  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
04350E 53 74 72 69 0503*  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
04351E 54 6F 6F 20 0504*  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
043526 2D 76 65 20 0505*  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
04352F 4C 6F 67 04 0506*  			DB    "Log", 4, 0		; 22: Log range
       00          
043534 41 63 63 75 0507*  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
043542 45 78 70 04 0508*  			DB    "Exp", 4, 0		; 24: Exp range
       00          
043547 00          0509*  			DB    0				; 25: *
043548 02 05 00    0510*  			DB    2, 5, 0			; 26: No such variable
04354B 01 29 00    0511*  			DB    1, ")", 0			; 27: Missing )
04354E 03 48 45 58 0512*  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
043553 02 A4 2F F2 0513*  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
043558 03 63 61 6C 0514*  			DB    3, "call", 0		; 30: Bad call
       6C 00       
04355E 41 72 67 75 0515*  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
043568 07 E3 00    0516*  			DB    7, FOR, 0			; 32: No FOR
04356B 43 61 6E 27 0517*  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
043579 E3 20 05 00 0518*  			DB    FOR, " ", 5, 0		; 34: FOR variable
04357D 00          0519*  			DB    0				; 35: *
04357E 07 B8 00    0520*  			DB    7, TO, 0			; 36: No TO
043581 00          0521*  			DB    0				; 37: *
043582 07 E4 00    0522*  			DB    7, GOSUB, 0		; 38: No GOSUB
043585 EE 20 73 79 0523*  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
04358E EE 04 00    0524*  			DB    ON_, 4, 0			; 40: ON range
043591 02 6C 69 6E 0525*  			DB    2, "line", 0		; 41: No such line
       65 00       
043597 06 20 DC 00 0526*  			DB    6, " ", DATA_, 0		; 42: Out of DATA
04359B 07 F5 00    0527*  			DB    7, REPEAT, 0		; 43: No REPEAT
04359E 00          0528*  			DB    0				; 44: *
04359F 01 23 00    0529*  			DB    1, "#", 0			; 45: Missing #
0435A2             0530*  ;
0435A2             0531*  ; COMMANDS:
0435A2             0532*  ;
0435A2             0533*  ; DELETE line,line
0435A2             0534*  ;
0435A2 CD A1 38 04 0535*  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0435A6 CD A9 3C 04 0536*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435AA 7E          0537*  DELET1:			LD      A,(HL)			; Check whether it's the last line
0435AB B7          0538*  			OR      A
0435AC CA 33 36 04 0539*  			JP      Z,WARMNC		; Yes, so do nothing
0435B0 23          0540*  			INC     HL			; Skip the line length byte
0435B1 11 00 00 00 0541*  			LD	DE, 0			; Clear DE
0435B5 5E          0542*  			LD      E,(HL)			; Fetch the line number in DE
0435B6 23          0543*  			INC     HL
0435B7 56          0544*  			LD      D,(HL)
0435B8 7A          0545*  			LD      A,D			; If the line number is zero then
0435B9 B3          0546*  			OR      E
0435BA 28 1D       0547*  			JR      Z,CLOOP1        	; Do nothing
0435BC 2B          0548*  			DEC     HL			; Decrement BASIC program pointer back to length
0435BD 2B          0549*  			DEC     HL
0435BE EB          0550*  			EX      DE,HL			; Check if we've gone past the terminating line
0435BF 37          0551*  			SCF
0435C0 ED 42       0552*  			SBC     HL,BC
0435C2 EB          0553*  			EX      DE,HL
0435C3 30 6E       0554*  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0435C5 C5          0555*  			PUSH    BC
0435C6 CD 58 38 04 0556*  			CALL    DEL			; Delete the line pointed to by HL
0435CA C1          0557*  			POP     BC
0435CB 18 DD       0558*  			JR      DELET1			; And loop round to the next line
0435CD             0559*  ;
0435CD             0560*  ; LISTO expr
0435CD             0561*  ;
0435CD FD 23       0562*  LISTO:			INC     IY              	; Skip "O" byte
0435CF CD 0F 03 04 0563*  			CALL    EXPRI			; Get expr
0435D3 D9          0564*  			EXX
0435D4 7D          0565*  			LD      A,L
0435D5 32 40 4D 04 0566*  			LD      (LISTON),A		; Store in LISTON sysvar
0435D9 C3 D6 30 04 0567*  CLOOP1:			JP      CLOOP
0435DD             0568*  ;
0435DD             0569*  ; LIST
0435DD             0570*  ; LIST line
0435DD             0571*  ; LIST line,line [IF string]
0435DD             0572*  ; LIST ,line
0435DD             0573*  ; LIST line,
0435DD             0574*  ;
0435DD FE 4F       0575*  LIST_:			CP      'O'			; Check for O (LISTO)
0435DF 28 EC       0576*  			JR      Z,LISTO			; and jump to LISTO if zero
0435E1 CD A9 3C 04 0577*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0435E5 CD 78 0A 04 0578*  			CALL    NXT			; Skip space
0435E9 FE E7       0579*  			CP      TIF             	; Check for IF clause (token IF)
0435EB 3E 00       0580*  			LD      A,0             	; Initialise the IF clause string length
0435ED 20 17       0581*  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0435EF             0582*  ;
0435EF FD 23       0583*  			INC     IY              	; Skip the IF token
0435F1 CD 78 0A 04 0584*  			CALL    NXT             	; And skip any spaces
0435F5 EB          0585*  			EX      DE,HL			; DE: Address in memory
0435F6 FD E5       0586*  			PUSH    IY			; LD IY, HL
0435F8 E1          0587*  			POP     HL              	; HL is now the address of the tokenised line
0435F9 3E 0D       0588*  			LD      A,CR
0435FB C5          0589*  			PUSH    BC			; Stack the second line number arg
0435FC 01 00 01 00 0590*  			LD      BC,256
043600 ED B1       0591*  			CPIR                    	; Locate CR byte
043602 79          0592*  			LD      A,C
043603 2F          0593*  			CPL                    	 	; A: Substring length (of IF clause)
043604 C1          0594*  			POP     BC			; Restore the second line number arg
043605 EB          0595*  			EX      DE,HL			; HL: Address in memory
043606             0596*  ;
043606 5F          0597*  LISTB:			LD      E,A             	; E: IF clause string length
043607 78          0598*  			LD      A,B			; Check whether a second line number was passed (BC!=0)
043608 B1          0599*  			OR      C
043609 20 01       0600*  			JR      NZ,LISTA		; If there isn't a second line number
04360B 0B          0601*  			DEC     BC			; then we set it to the maximum of 65535
04360C             0602*  ;
04360C D9          0603*  LISTA:			EXX
04360D DD 21 40 4D 0604*  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
043612 01 00 00 00 0605*  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
043616 D9          0606*  			EXX
043617 3E 14       0607*  			LD      A,20			; Number of lines to list
043619             0608*  ;
043619 C5          0609*  LISTC:			PUSH    BC              	; Save second line number
04361A D5          0610*  			PUSH    DE              	; Save IF clause length
04361B E5          0611*  			PUSH    HL              	; Save BASIC program counter
04361C 08          0612*  			EX      AF,AF'
04361D             0613*  ;
04361D             0614*  ; BBC BASIC for Z80 lines are stored as follows:
04361D             0615*  ;
04361D             0616*  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
04361D             0617*  ; - [&00] [&FF] [&FF]: End of program marker
04361D             0618*  ;
04361D             0619*  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
04361D             0620*  ;
04361D 7E          0621*  			LD      A,(HL)			; Check for end of program marker
04361E B7          0622*  			OR      A			; If found
04361F 28 12       0623*  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
043621             0624*  ;
043621             0625*  ; Check if past terminating line number
043621             0626*  ;
043621 7B          0627*  			LD      A,E             	; A: IF clause length
043622 23          0628*  			INC     HL			; Skip the length byte
043623 11 00 00 00 0629*  			LD	DE,0			; Clear DE
043627 5E          0630*  			LD      E,(HL)			; Fetch the line number in DE
043628 23          0631*  			INC     HL
043629 56          0632*  			LD      D,(HL)
04362A 2B          0633*  			DEC     HL			; Step HL back to the length byte
04362B 2B          0634*  			DEC     HL
04362C D5          0635*  			PUSH    DE             	 	; Push the line number on the stack
04362D EB          0636*  			EX      DE,HL			; HL: line number
04362E 37          0637*  			SCF				; Do a 16-bit compare of HL and DE
04362F ED 42       0638*  			SBC     HL,BC
043631 EB          0639*  			EX      DE,HL
043632 D1          0640*  			POP     DE              	; Restore the line number
043633 D2 D5 30 04 0641*  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
043637 4E          0642*  			LD      C,(HL)          	; C: Line length + 4
043638 47          0643*  			LD      B,A             	; B: IF clause length
043639             0644*  ;
043639             0645*  ; Check if "UNLISTABLE":
043639             0646*  ;
043639 7A          0647*  			LD      A,D			; TODO: What is "UNLISTABLE?"
04363A B3          0648*  			OR      E
04363B CA D6 30 04 0649*  			JP      Z,CLOOP
04363F             0650*  ;
04363F             0651*  ; Check for IF clause:
04363F             0652*  ;
04363F 23          0653*  			INC     HL			; Skip the length
043640 23          0654*  			INC     HL			; Skip the line number
043641 23          0655*  			INC     HL              	; HL: Address of the tokenised BASIC line
043642 0D          0656*  			DEC     C			;  C: Line length
043643 0D          0657*  			DEC     C
043644 0D          0658*  			DEC     C
043645 0D          0659*  			DEC     C
043646 D5          0660*  			PUSH    DE              	; Save the line number
043647 E5          0661*  			PUSH    HL              	; Save the BASIC program address
043648 AF          0662*  			XOR     A               	;
043649 B8          0663*  			CP      B              	 	; Check for an IF clause (B!=0)
04364A FD E5       0664*  			PUSH    IY			; LD IY, DE
04364C D1          0665*  			POP     DE              	; DE: Address of the IF clause string in the input buffer
04364D C4 8A 07 04 0666*  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
043651 E1          0667*  			POP     HL              	; Restore BASIC program address
043652 D1          0668*  			POP     DE              	; Restore line number
043653 FD E5       0669*  			PUSH    IY
043655 CC E8 38 04 0670*  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
043659 FD E1       0671*  			POP     IY
04365B             0672*  ;
04365B 08          0673*  			EX      AF,AF'
04365C 3D          0674*  			DEC     A			; Decrement line list counter
04365D CD C7 3F 04 0675*  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
043661 E1          0676*  			POP     HL             	 	; Restore BASIC program address to beginning of line
043662 11 00 00 00 0677*  			LD	DE,0
043666 5E          0678*  			LD      E,(HL)			; Fetch the length of line in DE
043667 19          0679*  			ADD     HL,DE           	; Go to the next line
043668 D1          0680*  			POP     DE              	; Restore IF clause length
043669 C1          0681*  			POP     BC              	; Restore second line number
04366A 18 AD       0682*  			JR      LISTC			; Loop back to do next line
04366C             0683*  ;
04366C             0684*  ; RENUMBER
04366C             0685*  ; RENUMBER start
04366C             0686*  ; RENUMBER start,increment
04366C             0687*  ; RENUMBER ,increment
04366C             0688*  ;
04366C CD CC 38 04 0689*  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
043670 CD 81 3C 04 0690*  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
043674 D9          0691*  			EXX
043675 2A 14 4D 04 0692*  			LD      HL,(PAGE_)		; HL: Top of program
043679 ED 5B 1A 4D 0693*  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
04367E             0694*  ;
04367E             0695*  ; Build the table
04367E             0696*  ;
04367E 7E          0697*  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
04367F B7          0698*  			OR      A			; Is it zero, i.e. the end of program marker?
043680 28 36       0699*  			JR      Z,RENUM2		; Yes, so skip to the next part
043682 23          0700*  			INC     HL
043683 4E          0701*  			LD      C,(HL)          	; BC: The OLD line number
043684 23          0702*  			INC     HL
043685 46          0703*  			LD      B,(HL)
043686 78          0704*  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
043687 B1          0705*  			OR      C
043688 CA D6 30 04 0706*  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
04368C EB          0707*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
04368D 71          0708*  			LD      (HL),C			; Store the OLD line number in the heap
04368E 23          0709*  			INC     HL
04368F 70          0710*  			LD      (HL),B
043690 23          0711*  			INC     HL
043691 D9          0712*  			EXX				; HL: line number, BC: increment (16-bit values)
043692 E5          0713*  			PUSH    HL			; HL: Stack the NEW line number value
043693 52 09       0714*  			ADD.S   HL,BC           	; Add the increment
043695 DA 7B 3C 04 0715*  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
043699 D9          0716*  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
04369A C1          0717*  			POP     BC			; BC: Pop the NEW line number value off the stack
04369B 71          0718*  			LD      (HL),C			; Store the NEW line number in the heap
04369C 23          0719*  			INC     HL
04369D 70          0720*  			LD      (HL),B
04369E 23          0721*  			INC     HL
04369F EB          0722*  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436A0 2B          0723*  			DEC     HL			; Back up to the line length byte
0436A1 2B          0724*  			DEC     HL
0436A2 01 00 00 00 0725*  			LD	BC, 0
0436A6 4E          0726*  			LD      C,(HL)			; BC: Line length
0436A7 09          0727*  			ADD	HL,BC           	; Advance HL to next line
0436A8 EB          0728*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0436A9 E5          0729*  			PUSH    HL
0436AA 24          0730*  			INC     H			; Increment to next page
0436AB ED 72       0731*  			SBC     HL,SP			; Subtract from SP
0436AD E1          0732*  			POP     HL
0436AE EB          0733*  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0436AF 38 CD       0734*  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0436B1 CD CD 37 04 0735*  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0436B5 CC          0736*  			DB    	REN
0436B6 08          0737*  			DB    	8
0436B7 00          0738*  			DB    	0
0436B8             0739*  ;
0436B8             0740*  ; At this point a list of BASIC line numbers have been written to the heap
0436B8             0741*  ; as word pairs:
0436B8             0742*  ; - DW: The OLD line number
0436B8             0743*  ; - DW: The NEW line number
0436B8             0744*  ;
0436B8 EB          0745*  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0436B9 36 FF       0746*  			LD      (HL),-1			; Mark the end with FFFFh
0436BB 23          0747*  			INC     HL
0436BC 36 FF       0748*  			LD      (HL),-1
0436BE ED 5B 1A 4D 0749*  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
0436C3 D9          0750*  			EXX
0436C4 2A 14 4D 04 0751*  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0436C8 4E          0752*  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0436C9 79          0753*  			LD      A,C			; If it is zero, then no program, so...
0436CA B7          0754*  			OR      A
0436CB CA D5 30 04 0755*  			JP      Z,WARM			; Jump to warm start
0436CF D9          0756*  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0436D0 EB          0757*  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0436D1 23          0758*  			INC     HL			; Skip to the NEW line number
0436D2 23          0759*  			INC     HL
0436D3 5E          0760*  			LD      E,(HL)			; DE: The NEW line number
0436D4 23          0761*  			INC     HL
0436D5 56          0762*  			LD      D,(HL)
0436D6 23          0763*  			INC     HL
0436D7 D5          0764*  			PUSH    DE			; Stack the NEW line number
0436D8 EB          0765*  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0436D9 22 23 4D 04 0766*  			LD      (LINENO),HL		; Store the line number in LINENO
0436DD D9          0767*  			EXX				; HL: Pointer to the BASIC program area
0436DE D1          0768*  			POP     DE			; DE: The NEW line number
0436DF 23          0769*  			INC     HL
0436E0 73          0770*  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0436E1 23          0771*  			INC     HL
0436E2 72          0772*  			LD      (HL),D
0436E3 23          0773*  			INC     HL
0436E4 0D          0774*  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0436E5 0D          0775*  			DEC     C
0436E6 0D          0776*  			DEC     C
0436E7 79          0777*  			LD	A,C
0436E8 01 00 00 00 0778*  			LD	BC,0
0436EC 4F          0779*  			LD	C,A			; BC: Line length
0436ED             0780*  ;
0436ED 3E 8D       0781*  RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0436EF ED B1       0782*  			CPIR                    	; Search for the token
0436F1 20 D5       0783*  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0436F3             0784*  ;
0436F3             0785*  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0436F3             0786*  ;
0436F3 C5          0787*  			PUSH    BC			; Stack everything
0436F4 E5          0788*  			PUSH    HL
0436F5 E5          0789*  			PUSH    HL			; HL: Pointer to encoded line number
0436F6 FD E1       0790*  			POP     IY			; IY: Pointer to encoded line number
0436F8 D9          0791*  			EXX
0436F9 CD EB 08 04 0792*  			CALL    DECODE			; Decode the encoded line number (in HL')
0436FD D9          0793*  			EXX				; HL: Decoded line number
0436FE 44          0794*  			LD      B,H			; BC: Decoded line number
0436FF 4D          0795*  			LD      C,L
043700 2A 1A 4D 04 0796*  			LD      HL,(LOMEM)		; HL: Pointer to heap
043704             0797*  ;
043704             0798*  ; This section of code cross-references the decoded (OLD) line number with the list
043704             0799*  ; created previously in the global heap
043704             0800*  ;
043704 5E          0801*  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
043705 23          0802*  			INC     HL
043706 56          0803*  			LD      D,(HL)
043707 23          0804*  			INC     HL
043708 EB          0805*  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
043709 B7          0806*  			OR      A               	; Clear the carry and...
04370A 52 ED 42    0807*  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
04370D EB          0808*  			EX      DE,HL			; HL: Pointer in the global heap
04370E 5E          0809*  			LD      E,(HL)          	; DE: The NEW line number
04370F 23          0810*  			INC     HL
043710 56          0811*  			LD      D,(HL)
043711 23          0812*  			INC     HL
043712 38 F0       0813*  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
043714 EB          0814*  			EX      DE,HL			; DE: Pointer in the global heap
043715 28 1D       0815*  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
043717             0816*  ;
043717 CD E6 3D 04 0817*  			CALL    TELL			; Display this error if the line number is not found
04371B 46 61 69 6C 0818*  			DB    	"Failed at "
       65 64 20 61 
       74 20       
043725 00          0819*  			DB    	0
043726 2A 23 4D 04 0820*  			LD      HL,(LINENO)
04372A CD 4D 3A 04 0821*  			CALL    PBCDL
04372E CD 9D 39 04 0822*  			CALL    CRLF
043732 18 07       0823*  			JR      RENUM6			; And carry on renumbering
043734             0824*  ;
043734             0825*  ; This snippet re-encodes the line number in the BASIC program
043734             0826*  ;
043734 D1          0827*  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
043735 D5          0828*  			PUSH    DE
043736 1B          0829*  			DEC     DE			; Back up a byte to the LINO token
043737 CD B2 3D 04 0830*  			CALL    ENCODE          	; Re-write the new line number out
04373B E1          0831*  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
04373C C1          0832*  			POP     BC			; BC: The remaining line length
04373D 18 AE       0833*  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
04373F             0834*  ;
04373F             0835*  ; AUTO
04373F             0836*  ; AUTO start,increment
04373F             0837*  ; AUTO start
04373F             0838*  ; AUTO ,increment
04373F             0839*  ;
04373F CD 81 3C 04 0840*  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
043743 22 29 4D 04 0841*  			LD      (AUTONO),HL		; Store the start in AUTONO
043747 79          0842*  			LD      A,C			; Increment is 8 bit (0-255)
043748 32 41 4D 04 0843*  			LD      (INCREM),A		; Store that in INCREM
04374C 18 2E       0844*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04374E             0845*  ;
04374E             0846*  ; BAD
04374E             0847*  ; NEW
04374E             0848*  ;
04374E CD E6 3D 04 0849*  BAD:			CALL    TELL            	; Output "Bad program" error
043752 03          0850*  			DB    3				; Token for "BAD"
043753 70 72 6F 67 0851*  			DB    "program"
       72 61 6D    
04375A 0D          0852*  			DB    CR
04375B 0A          0853*  			DB    LF
04375C 00          0854*  			DB    0				; Falls through to NEW
04375D             0855*  ;
04375D CD C2 38 04 0856*  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
043761 18 19       0857*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
043763             0858*  ;
043763             0859*  ; OLD
043763             0860*  ;
043763 2A 14 4D 04 0861*  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
043767 E5          0862*  			PUSH    HL			; Stack it
043768 23          0863*  			INC     HL			; Skip the potential length byte of first line of code
043769 23          0864*  			INC     HL			; And the line number word
04376A 23          0865*  			INC     HL
04376B 01 FC 00 00 0866*  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
04376F 3E 0D       0867*  			LD      A,CR
043771 ED B1       0868*  			CPIR
043773 20 D9       0869*  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
043775 7D          0870*  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
043776 E1          0871*  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
043777 77          0872*  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
043778 CD 95 38 04 0873*  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04377C C3 D6 30 04 0874*  CLOOP0:			JP      CLOOP			; Jump back to the command loop
043780             0875*  ;
043780             0876*  ; LOAD filename
043780             0877*  ;
043780 CD 1A 03 04 0878*  LOAD:			CALL    EXPRS           	; Get the filename
043784 3E 0D       0879*  			LD      A,CR			; DE points to the last byte of filename in ACCS
043786 12          0880*  			LD      (DE),A			; Terminate filename with a CR
043787 CD 75 38 04 0881*  			CALL    LOAD0			; Load the file in, then CLEAN
04378B CD CC 38 04 0882*  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
04378F 18 21       0883*  			JR      WARM0			; Jump back to the command loop
043791             0884*  ;
043791             0885*  ; SAVE filename
043791             0886*  ;
043791 CD A1 38 04 0887*  SAVE:			CALL    SETTOP          	; Set TOP sysvar
043795 CD 1A 03 04 0888*  			CALL    EXPRS           	; Get the filename
043799 3E 0D       0889*  			LD      A,CR			; Terminate the filename with a CR
04379B 12          0890*  			LD      (DE),A
04379C ED 5B 14 4D 0891*  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
0437A1 2A 17 4D 04 0892*  			LD      HL,(TOP)		; HL: Top of program memory
0437A5 B7          0893*  			OR      A			; Calculate program size (TOP-PAGE)
0437A6 ED 52       0894*  			SBC     HL,DE
0437A8 44          0895*  			LD      B,H             	; BC: Length of program in bytes
0437A9 4D          0896*  			LD      C,L
0437AA 21 00 4A 04 0897*  			LD      HL,ACCS			; HL: Address of the filename
0437AE CD 94 42 04 0898*  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0437B2 C3 D5 30 04 0899*  WARM0:			JP      WARM			; Jump back to the command loop
0437B6             0900*  
0437B6             0901*  ;
0437B6             0902*  ; ERROR
0437B6             0903*  ; Called whenever BASIC needs to halt with an error
0437B6             0904*  ; Error messages are indexed from 0
0437B6             0905*  ; Inputs:
0437B6             0906*  ;  A: Error number
0437B6             0907*  ;
0437B6 ED 7B 20 4D 0908*  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437BB 21 9F 34 04 0909*  			LD      HL,ERRWDS		; Index into the error string table
0437BF B7          0910*  			OR      A			; We don't need to search for the first error
0437C0 28 0A       0911*  			JR      Z,ERROR1		; So skip the search routine
0437C2             0912*  ;
0437C2             0913*  ; Search the error table for error #A
0437C2             0914*  ; HL will end up being the pointer into the correct error
0437C2             0915*  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0437C2             0916*  ;
0437C2 47          0917*  			LD      B,A             	; Store error number in B
0437C3 08          0918*  			EX      AF,AF'			; Store error number in AF'
0437C4 AF          0919*  			XOR     A
0437C5 BE          0920*  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0437C6 23          0921*  			INC     HL			; Increment the string pointer
0437C7 20 FC       0922*  			JR      NZ,ERROR0		; Loop until with hit a 0
0437C9 10 FA       0923*  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0437CB 08          0924*  			EX      AF,AF'			; Restore the error number from AF'
0437CC             0925*  ;
0437CC             0926*  ; At this point HL points to the tokenised error string
0437CC             0927*  ;
0437CC E5          0928*  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0437CD             0929*  
0437CD             0930*  ;
0437CD             0931*  ; EXTERR
0437CD             0932*  ; Inputs:
0437CD             0933*  ;  A: Error number
0437CD             0934*  ;
0437CD             0935*  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0437CD             0936*  ; The error text immediately follows the CALL to EXTERR, for example:
0437CD             0937*  ; > CALL  EXTERR
0437CD             0938*  ; > DB    "Silly", 0
0437CD             0939*  ; So we can get the address of the string by popping the return address off the stack
0437CD             0940*  ;
0437CD E1          0941*  EXTERR:			POP     HL			; Pop the error string pointer
0437CE 22 2F 4D 04 0942*  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0437D2 ED 7B 20 4D 0943*  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0437D7 32 3F 4D 04 0944*  			LD      (ERR),A			; Store error number in ERR sysvar
0437DB CD 04 3A 04 0945*  			CALL    SETLIN			; Get line number
0437DF 22 33 4D 04 0946*  			LD      (ERL),HL		; Store in ERL sysvar
0437E3 B7          0947*  			OR      A			; Is error number 0?
0437E4 28 0D       0948*  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0437E6             0949*  ;
0437E6 2A 2C 4D 04 0950*  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0437EA 7C          0951*  			LD      A,H
0437EB B5          0952*  			OR      L
0437EC E5          0953*  			PUSH    HL			; HL: Error line
0437ED FD E1       0954*  			POP     IY			; IY: HL
0437EF C2 9E 0B 04 0955*  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0437F3             0956*  ;
0437F3 21 00 00 00 0957*  ERROR2:			LD      HL,0
0437F7 22 29 4D 04 0958*  			LD      (AUTONO),HL		; Cancel AUTO
0437FB 22 26 4D 04 0959*  			LD      (TRACEN),HL     	; Cancel TRACE
0437FF CD 1D 44 04 0960*  			CALL    RESET           	; Reset OPSYS
043803 CD 9D 39 04 0961*  			CALL    CRLF			; Output newline
043807 CD D8 3D 04 0962*  			CALL    REPORT          	; Output the error message
04380B CD 38 3A 04 0963*  			CALL    SAYLN			; Output " at line nnnn" message.
04380F 1E 00       0964*  			LD      E,0			; Close all files
043811 DC 92 43 04 0965*  			CALL    C,OSSHUT
043815 CD 9D 39 04 0966*  			CALL    CRLF			; Output newline
043819 C3 D6 30 04 0967*  			JP      CLOOP			; Back to CLOOP
04381D             0968*  ;
04381D             0969*  ; SUBROUTINES:
04381D             0970*  ;
04381D             0971*  ; LEX - SEARCH FOR KEYWORDS
04381D             0972*  ;   Inputs: HL = start of keyword table
04381D             0973*  ;           IY = start of match text
04381D             0974*  ;  Outputs: If found, Z-flag set, A=token.
04381D             0975*  ;           If not found, Z-flag reset, A=(IY).
04381D             0976*  ;           IY updated (if NZ, IY unchanged).
04381D             0977*  ; Destroys: A,B,H,L,IY,F
04381D             0978*  ;
04381D 21 BE 31 04 0979*  LEX:			LD      HL,KEYWDS		; Address of the keywords table
043821             0980*  ;
043821 FD 7E 00    0981*  LEX0:			LD      A,(IY)			; Fetch the character to match
043824 46          0982*  			LD      B,(HL)			; B: The token from the keywords table
043825 23          0983*  			INC     HL			; Increment the pointer in the keywords table
043826 BE          0984*  			CP      (HL)			; Compare the first characters
043827 28 08       0985*  			JR      Z,LEX2			; If there is a match, then skip to LEX2
043829 D8          0986*  			RET     C               	; No match, so fail
04382A             0987*  ;
04382A             0988*  ; This snippet of code skips to the next token in the KEYWDS table
04382A             0989*  ;
04382A 23          0990*  LEX1:			INC     HL			; Increment the pointer
04382B CB 7E       0991*  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
04382D 28 FB       0992*  			JR      Z,LEX1			; No, so loop
04382F 18 F0       0993*  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
043831             0994*  ;
043831 FD E5       0995*  LEX2:			PUSH    IY              	; Save the input pointer
043833 23          0996*  LEX3:			INC     HL			; Increment the keyword pointer
043834 CB 7E       0997*  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
043836 20 1C       0998*  			JR      NZ,LEX6         	; Jump to here as we've found a token
043838 FD 23       0999*  			INC     IY			; Increment the text pointer
04383A FD 7E 00    1000*  			LD      A,(IY)			; Fetch the character
04383D FE 2E       1001*  			CP      '.'			; Is it an abbreviated keyword?
04383F 28 13       1002*  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
043841 BE          1003*  			CP      (HL)			; Compare with the keywords list
043842 28 EF       1004*  			JR      Z,LEX3			; It's a match, so continue checking this keyword
043844 CD D1 3C 04 1005*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043848 38 04       1006*  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
04384A             1007*  ;
04384A FD E1       1008*  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
04384C 18 DC       1009*  			JR      LEX1			; And loop back to start again
04384E             1010*  ;
04384E             1011*  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
04384E             1012*  ; immediately delimited
04384E             1013*  ;
04384E 7E          1014*  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
04384F B7          1015*  			OR      A			; If it is not zero, then...
043850 20 F8       1016*  			JR      NZ,LEX4			; Keep searching
043852 FD 2B       1017*  			DEC     IY			; If it is zero, then skip the input pointer back one byte
043854             1018*  ;
043854             1019*  ; We've found a token at this point
043854             1020*  ;
043854 F1          1021*  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
043855 AF          1022*  			XOR     A			; Set the Z flag
043856 78          1023*  			LD      A,B			; A: The token
043857 C9          1024*  			RET
043858             1025*  ;
043858             1026*  ; DEL - DELETE A PROGRAM LINE.
043858             1027*  ;   Inputs: HL addresses program line.
043858             1028*  ; Destroys: B,C,F
043858             1029*  ;
043858             1030*  ; This simply erases the line by moving all of the code after the line to be deleted back over
043858             1031*  ; it using an LDIR
043858             1032*  ;
043858 D5          1033*  DEL:			PUSH    DE
043859 E5          1034*  			PUSH    HL
04385A E5          1035*  			PUSH    HL			; HL: Address of the program line
04385B 06 00       1036*  			LD      B,0			; BC: Length of the line
04385D 4E          1037*  			LD      C,(HL)
04385E 09          1038*  			ADD     HL,BC			; HL: Advanced to the start of the next line
04385F E5          1039*  			PUSH    HL
043860 EB          1040*  			EX      DE,HL			; DE: Pointer to the next line
043861 2A 17 4D 04 1041*  			LD      HL,(TOP)		; HL: Pointer to the end of the program
043865 ED 52       1042*  			SBC     HL,DE
043867 44          1043*  			LD      B,H			; BC: Size of block to move
043868 4D          1044*  			LD      C,L
043869 E1          1045*  			POP     HL			; HL: Pointer to next line
04386A D1          1046*  			POP     DE			; DE: Pointer to this line
04386B ED B0       1047*  			LDIR                    	; Delete the line
04386D ED 53 17 4D 1048*  			LD      (TOP),DE		; Adjust TOP
       04          
043872 E1          1049*  			POP     HL
043873 D1          1050*  			POP     DE
043874 C9          1051*  			RET
043875             1052*  ;
043875             1053*  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
043875             1054*  ;   Inputs: Filename in ACCS (term CR)
043875             1055*  ; Destroys: A,B,C,D,E,H,L,F
043875             1056*  ;
043875             1057*  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
043875             1058*  ; AND WRITE FF FF, THEN LOAD (TOP).
043875             1059*  ; Destroys: A,B,C,H,L,F
043875             1060*  ;
043875 ED 5B 14 4D 1061*  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
04387A 21 00 FF FF 1062*  			LD      HL,-256
04387E 39          1063*  			ADD     HL,SP
04387F ED 52       1064*  			SBC     HL,DE           	; Find available space
043881 44          1065*  			LD      B,H
043882 4D          1066*  			LD      C,L
043883 21 00 4A 04 1067*  			LD      HL,ACCS
043887 CD FB 41 04 1068*  			CALL    OSLOAD          	; Call the OSLOAD function in patch
04388B D4 C2 38 04 1069*  			CALL    NC,NEWIT		; If NC then NEW
04388F 3E 00       1070*  			LD      A,0
043891 D2 B6 37 04 1071*  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
043895             1072*  ;
043895 CD A1 38 04 1073*  CLEAN:			CALL    SETTOP			; Set TOP sysvar
043899 2B          1074*  			DEC     HL			; Write out the end of program markers
04389A 36 FF       1075*  			LD      (HL),-1
04389C 2B          1076*  			DEC     HL
04389D 36 FF       1077*  			LD      (HL),-1
04389F 18 2B       1078*  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0438A1             1079*  ;
0438A1             1080*  ; Set the TOP sysvar; the first free location after the end of the current program
0438A1             1081*  ; Returns:
0438A1             1082*  ; - HL: TOP
0438A1             1083*  ;
0438A1 2A 14 4D 04 1084*  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0438A5 01 00 00 00 1085*  			LD	BC, 0			; BC: 0
0438A9 3E 0D       1086*  			LD      A,CR			; End of line marker
0438AB 4E          1087*  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0438AC 0C          1088*  			INC     C			; Check for zero
0438AD 0D          1089*  			DEC     C
0438AE 28 0A       1090*  			JR      Z,SETOP2		; If it is zero, we've reached the end
0438B0 09          1091*  			ADD     HL,BC			; Skip to next line
0438B1 2B          1092*  			DEC     HL			; Check end of previous line
0438B2 BE          1093*  			CP      (HL)
0438B3 23          1094*  			INC     HL
0438B4 28 F5       1095*  			JR      Z,SETOP1		; If CR then loop
0438B6 C3 4E 37 04 1096*  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0438BA             1097*  ;
0438BA 23          1098*  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0438BB 23          1099*  			INC     HL			; NB: Called from NEWIT
0438BC 23          1100*  			INC     HL
0438BD 22 17 4D 04 1101*  			LD      (TOP),HL		; Store in TOP sysvar
0438C1 C9          1102*  			RET
0438C2             1103*  ;
0438C2             1104*  ; NEWIT - NEW PROGRAM THEN CLEAR
0438C2             1105*  ;   Destroys: H,L
0438C2             1106*  ;
0438C2             1107*  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0438C2             1108*  ; FUNCTION AND PROCEDURE POINTERS.
0438C2             1109*  ;   Destroys: Nothing
0438C2             1110*  ;
0438C2 2A 14 4D 04 1111*  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0438C6 36 00       1112*  			LD      (HL),0			; Stick a 0 in there
0438C8 CD BA 38 04 1113*  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0438CC             1114*  ;
0438CC E5          1115*  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0438CD 2A 17 4D 04 1116*  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0438D1 22 1A 4D 04 1117*  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0438D5 22 1D 4D 04 1118*  			LD      (FREE),HL		; And the FREE sysvar with that value
0438D9 21 6C 4C 04 1119*  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0438DD C5          1120*  			PUSH    BC
0438DE             1121*  			; LD      B,3*(54+2)		; Loop counter
0438DE 06 A8       1122*  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0438E0 36 00       1123*  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0438E2 23          1124*  			INC     HL
0438E3 10 FB       1125*  			DJNZ    CLEAR1
0438E5 C1          1126*  			POP     BC
0438E6 E1          1127*  			POP     HL			; Restore the BASIC program pointer
0438E7 C9          1128*  			RET
0438E8             1129*  ;
0438E8             1130*  ;LISTIT - LIST A PROGRAM LINE.
0438E8             1131*  ;    Inputs: HL addresses line
0438E8             1132*  ;            DE = line number (binary)
0438E8             1133*  ;            IX = Pointer to LISTON
0438E8             1134*  ;             B = FOR/NEXT indent level
0438E8             1135*  ;             C = REPEAT/UNTIL indent level
0438E8             1136*  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0438E8             1137*  ;
0438E8 E5          1138*  LISTIT:			PUSH    HL			; Stack the address of the line
0438E9 EB          1139*  			EX      DE,HL			; HL: Line number
0438EA C5          1140*  			PUSH    BC
0438EB CD 51 3A 04 1141*  			CALL    PBCD			; Print the line number
0438EF C1          1142*  			POP     BC
0438F0 E1          1143*  			POP     HL			; HL: Address of the first token/character
0438F1 7E          1144*  			LD      A,(HL)			; Fetch the token
0438F2 FE ED       1145*  			CP      NEXT			; Is it NEXT...
0438F4 CC 7E 39 04 1146*  			CALL    Z,INDENT		; Yes, so indent in
0438F8 FE FD       1147*  			CP      UNTIL			; Or is it UNTIL...
0438FA CC 7E 39 04 1148*  			CALL    Z,INDENT		; Yes, so indent in
0438FE D9          1149*  			EXX
0438FF 3E 20       1150*  			LD      A,' '
043901 DD CB 00 46 1151*  			BIT     0,(IX)			; If BIT 0 of LISTON is set
043905 C4 A5 39 04 1152*  			CALL    NZ,OUTCHR		; Then print a space after the line number
043909 78          1153*  			LD      A,B			; Fetch the FOR/NEXT indent level
04390A 87          1154*  			ADD     A,A			; Multiply by 2
04390B DD CB 00 4E 1155*  			BIT     1,(IX)			; If BIT 1 of LISTON is set
04390F C4 21 18 04 1156*  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
043913 79          1157*  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
043914 87          1158*  			ADD     A,A			; Multiply by 2
043915 DD CB 00 56 1159*  			BIT     2,(IX)			; If BIT 2 of LISTON is set
043919 C4 21 18 04 1160*  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
04391D D9          1161*  			EXX
04391E 7E          1162*  			LD      A,(HL)			; Fetch the token
04391F FE E3       1163*  			CP      FOR			; Is it FOR?
043921 CC 7E 39 04 1164*  			CALL    Z,INDENT		; Yes, so indent
043925 FE F5       1165*  			CP      REPEAT			; Is it REPEAT?
043927 CC 7E 39 04 1166*  			CALL    Z,INDENT		; Yes, so indent
04392B 1E 00       1167*  			LD      E,0			; E: The quote counter - reset to 0
04392D 7E          1168*  LIST8:			LD      A,(HL)			; Fetch a character / token byte
04392E 23          1169*  			INC     HL
04392F FE 0D       1170*  			CP      CR			; Is it end of line?
043931 28 0B       1171*  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
043933 FE 22       1172*  			CP      34			; Is it a quote character?
043935 20 01       1173*  			JR      NZ,LIST7		; No, so skip to next bit
043937 1C          1174*  			INC     E			; Otherwise increment quote counter
043938 CD 6D 39 04 1175*  LIST7:			CALL    LOUT			; Output the character / token
04393C 18 EF       1176*  			JR      LIST8			; And repeat
04393E             1177*  ;
04393E             1178*  ; DB: Modification for *EDIT
04393E             1179*  ; Terminate the line with either a CRLF or a NUL character
04393E             1180*  ;
04393E DD CB 00 5E 1181*  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
043942 28 59       1182*  			JR	Z, CRLF			; Yes, so print a CRLF
043944 AF          1183*  			XOR	A			; Otherwise print a NUL (0)
043945 C3 56 3F 04 1184*  			JP	OSWRCH
043949             1185*  ;
043949             1186*  ; Decode the 3 byte GOTO type line number
043949             1187*  ;
043949 E5          1188*  PRLINO:			PUSH    HL			; Swap HL and IY
04394A FD E1       1189*  			POP     IY			; IY: Pointer to the line number
04394C C5          1190*  			PUSH    BC
04394D CD EB 08 04 1191*  			CALL    DECODE			; Decode
043951 C1          1192*  			POP     BC
043952 D9          1193*  			EXX
043953 C5          1194*  			PUSH    BC
043954 CD 4D 3A 04 1195*  			CALL    PBCDL			; Output the line number
043958 C1          1196*  			POP     BC
043959 D9          1197*  			EXX
04395A FD E5       1198*  			PUSH    IY			; Swap HL and IY
04395C E1          1199*  			POP     HL			; HL: Pointer to the next character in the line
04395D C9          1200*  			RET
04395E             1201*  ;
04395E             1202*  ; DB: Modification for internationalisation
04395E             1203*  ;
04395E CD C2 39 04 1204*  PRREM:			CALL	OUT_			; Output the REM token
043962 7E          1205*  @@:			LD	A, (HL)			; Fetch the character
043963 FE 0D       1206*  			CP	CR			; If it is end of line, then
043965 C8          1207*  			RET	Z			; we have finished
043966 CD A5 39 04 1208*  			CALL	OUTCHR			; Ouput the character
04396A 23          1209*  			INC	HL
04396B 18 F5       1210*  			JR	@B			; And loop
04396D             1211*  ;
04396D             1212*  ; DB: End of modification
04396D             1213*  ;
04396D CB 43       1214*  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
04396F 20 34       1215*  			JR      NZ,OUTCHR		; don't tokenise, just output the character
043971 FE F4       1216*  			CP	REM			; DB: Is it REM
043973 28 E9       1217*  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
043975 FE 8D       1218*  			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
043977 28 D0       1219*  			JR      Z,PRLINO		; Yes, so decode and print the line number
043979 CD C2 39 04 1220*  			CALL    OUT_			; Output a character / keyword
04397D 7E          1221*  			LD      A,(HL)			; Fetch the next character
04397E             1222*  ;
04397E             1223*  ; This block of code handles the indentation
04397E             1224*  ; B: Counter for FOR/NEXT indent
04397E             1225*  ; C: Counter for REPEAT/UNTIL indent
04397E             1226*  ;
04397E D9          1227*  INDENT:			EXX
04397F FE E3       1228*  			CP      FOR			; If the token is FOR
043981 28 09       1229*  			JR      Z,IND1			; Then INC B
043983 FE ED       1230*  			CP      NEXT			; If it is NEXT
043985 20 06       1231*  			JR      NZ,IND2_		; Then...
043987 05          1232*  			DEC     B			; DEC B
043988 F2 8D 39 04 1233*  			JP      P,IND2_			; If we have gone below 0 then
04398C 04          1234*  IND1:			INC     B			; Increment back to 0
04398D             1235*  ;
04398D FE F5       1236*  IND2_:			CP      REPEAT			; If the token is REPEAT
04398F 28 09       1237*  			JR      Z,IND3			; Then INC C
043991 FE FD       1238*  			CP      UNTIL			; If it is UNTIL
043993 20 06       1239*  			JR      NZ,IND4			; Then...
043995 0D          1240*  			DEC     C			; DEC C
043996 F2 9B 39 04 1241*  			JP      P,IND4			; If we have gone below 0 then
04399A 0C          1242*  IND3:			INC     C			; Incremet back to 0
04399B D9          1243*  IND4:			EXX
04399C C9          1244*  			RET
04399D             1245*  ;
04399D             1246*  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
04399D             1247*  ;  Destroys: A,F
04399D             1248*  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
04399D             1249*  ;    Inputs: A = character
04399D             1250*  ;  Destroys: A,F
04399D             1251*  ;
04399D 3E 0D       1252*  CRLF:			LD      A,CR			; Output CR
04399F CD A5 39 04 1253*  			CALL    OUTCHR
0439A3 3E 0A       1254*  			LD      A,LF			; Output LF
0439A5             1255*  ;
0439A5 CD 56 3F 04 1256*  OUTCHR:			CALL    OSWRCH			; Output the character in A
0439A9 D6 0D       1257*  			SUB     CR			; Check for CR
0439AB 28 06       1258*  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0439AD D8          1259*  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0439AE 3A 3D 4D 04 1260*  			LD      A,(COUNT)		; Increment the count
0439B2 3C          1261*  			INC     A
0439B3             1262*  ;
0439B3 32 3D 4D 04 1263*  CARRET:			LD      (COUNT),A		; Store the new count value
0439B7 C8          1264*  			RET     Z			; Return if the count has wrapped to 0
0439B8 E5          1265*  			PUSH    HL			; Now check if count = print width
0439B9 2A 3E 4D 04 1266*  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0439BD BD          1267*  			CP      L			; L is the width. Compare it with count.
0439BE E1          1268*  			POP     HL
0439BF C0          1269*  			RET     NZ			; If we've not hit print width, then just return
0439C0 18 DB       1270*  			JR      CRLF			; Otherwise output CRLF
0439C2             1271*  ;
0439C2             1272*  ; OUT - SEND CHARACTER OR KEYWORD
0439C2             1273*  ;   Inputs: A = character (>=10, <128)
0439C2             1274*  ;           A = Token (<10, >=128)
0439C2             1275*  ;  Destroys: A,F
0439C2             1276*  ;
0439C2 FE 8A       1277*  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0439C4 EA A5 39 04 1278*  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0439C8             1279*  ;
0439C8             1280*  ; This bit looks up the character in the KEYWDS token table and expands it
0439C8             1281*  ; Note the CP 138; this sets the overflow flag as follows:
0439C8             1282*  ;
0439C8             1283*  ; NB:
0439C8             1284*  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0439C8             1285*  ;  2. CP is effectively a SUB; sets the flags without affecting A
0439C8             1286*  ;  3. The operation n - -118 ~ n + 118
0439C8             1287*  ;
0439C8             1288*  ; So:
0439C8             1289*  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0439C8             1290*  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0439C8             1291*  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0439C8             1292*  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0439C8             1293*  ;
0439C8 C5          1294*  			PUSH    BC			; Preserve BC and HL
0439C9 E5          1295*  			PUSH    HL
0439CA 21 BE 31 04 1296*  			LD      HL,KEYWDS		; The list of tokens and keywords
0439CE 01 DF 02 00 1297*  			LD      BC,KEYWDL		; The length of the keyword list
0439D2 ED B1       1298*  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0439D4             1299*  ;							; At this point HL points to the next byte, the first character of the token
0439D4 7E          1300*  TOKEN1:			LD      A,(HL)			; Fetch the character
0439D5 23          1301*  			INC     HL			; Increment to the next byte in the token table
0439D6 FE 8A       1302*  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0439D8 F5          1303*  			PUSH    AF			; Then...
0439D9 EC A5 39 04 1304*  			CALL    PE,OUTCHR		; Output the character...
0439DD F1          1305*  			POP     AF			;
0439DE EA D4 39 04 1306*  			JP      PE,TOKEN1		; And loop to the next character
0439E2 E1          1307*  			POP     HL			; Done, so tidy up the stack and exit
0439E3 C1          1308*  			POP     BC
0439E4 C9          1309*  			RET
0439E5             1310*  ;
0439E5             1311*  ; FINDL - FIND PROGRAM LINE
0439E5             1312*  ;   Inputs: HL = line number (binary)
0439E5             1313*  ;  Outputs: HL addresses line (if found)
0439E5             1314*  ;           DE = line number
0439E5             1315*  ;           Z-flag set if found.
0439E5             1316*  ; Destroys: A,B,C,D,E,H,L,F
0439E5             1317*  ;
0439E5 EB          1318*  FINDL:			EX      DE,HL			; DE: Line number (binary)
0439E6 2A 14 4D 04 1319*  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0439EA AF          1320*  			XOR     A               	;  A: 0
0439EB BE          1321*  			CP      (HL)			; Check for end of program marker
0439EC 3C          1322*  			INC     A			;  A: 1
0439ED D0          1323*  			RET     NC			; Return with 1 if 0
0439EE AF          1324*  			XOR     A               	; Clear the carry flag
0439EF             1325*  ;			LD      B,A			;  B: 0
0439EF 01 00 00 00 1326*  			LD	BC, 0			; BC: 0
0439F3             1327*  ;
0439F3 4E          1328*  FINDL1:			LD      C,(HL)			;  C: The line length
0439F4 E5          1329*  			PUSH    HL			; Stack the current program counter
0439F5 23          1330*  			INC     HL			; Skip to the line number bytes
0439F6 7E          1331*  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0439F7 23          1332*  			INC     HL
0439F8 66          1333*  			LD      H,(HL)
0439F9 6F          1334*  			LD      L,A
0439FA 52 ED 52    1335*  			SBC.S   HL,DE			; Compare with the line number we're searching for
0439FD E1          1336*  			POP     HL			; Get the current program counter
0439FE D0          1337*  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0439FF 09          1338*  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
043A00 C3 F3 39 04 1339*  			JP      FINDL1			; And loop
043A04             1340*  ;
043A04             1341*  ; SETLIN - Search program for line containing address
043A04             1342*  ;          Update (LINENO)
043A04             1343*  ;   Inputs: Address in (ERRLIN)
043A04             1344*  ;  Outputs: Line number in HL and (LINENO)
043A04             1345*  ; Destroys: B,C,D,E,H,L,F
043A04             1346*  ;
043A04 01 00 00 00 1347*  SETLIN:			LD	BC, 0			; Zero BC for later
043A08             1348*  ;			LD      B, 0			; Zero B for later
043A08 ED 5B 35 4D 1349*  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
043A0D 2A 14 4D 04 1350*  			LD      HL, (PAGE_)		; HL: Start of user program area
043A11 B7          1351*  			OR      A			; Do a 24 bit compare without destroying HL
043A12 ED 52       1352*  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
043A14 19          1353*  			ADD     HL, DE			;  C: DE > HL
043A15 30 1B       1354*  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
043A17             1355*  ;
043A17 4E          1356*  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
043A18 0C          1357*  			INC     C			; This is a way to check for zero without using the accumulator
043A19 0D          1358*  			DEC     C			; If it is zero, then...
043A1A 28 16       1359*  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
043A1C 09          1360*  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
043A1D ED 52       1361*  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
043A1F 19          1362*  			ADD     HL, DE
043A20 38 F5       1363*  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
043A22 ED 42       1364*  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
043A24 23          1365*  			INC     HL			; Skip the length counter
043A25 11 00 00 00 1366*  			LD	DE, 0			; Zero DE
043A29 5E          1367*  			LD      E, (HL)          	; Fetch the line number
043A2A 23          1368*  			INC     HL
043A2B 56          1369*  			LD      D, (HL)
043A2C EB          1370*  			EX      DE, HL			; HL: The line number
043A2D 22 23 4D 04 1371*  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
043A31 C9          1372*  			RET
043A32             1373*  ;
043A32 21 00 00 00 1374*  SET3:			LD      HL, 0			; We've not found the line at this point so
043A36 18 F5       1375*  			JR      SET2			; Set LINENO to 0
043A38             1376*  ;
043A38             1377*  ;SAYLN - PRINT " at line nnnn" MESSAGE.
043A38             1378*  ;  Outputs: Carry=0 if line number is zero.
043A38             1379*  ;           Carry=1 if line number is non-zero.
043A38             1380*  ; Destroys: A,B,C,D,E,H,L,F
043A38             1381*  ;
043A38 2A 23 4D 04 1382*  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
043A3C 7C          1383*  			LD      A,H			; If it is zero then
043A3D B5          1384*  			OR      L
043A3E C8          1385*  			RET     Z			; Don't need to do anything; return with F:C set to 0
043A3F CD E6 3D 04 1386*  			CALL    TELL			; Output the error message
043A43 20 61 74 20 1387*  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
043A4D 0E 00       1388*  PBCDL:			LD      C,0			; C: Leading character (NUL)
043A4F 18 02       1389*  			JR      PBCD0			; Output the line number; return with F:C set to 1
043A51             1390*  ;
043A51             1391*  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
043A51             1392*  ;   Inputs: HL = number (binary).
043A51             1393*  ;  Outputs: Carry = 1
043A51             1394*  ; Destroys: A,B,C,D,E,H,L,F
043A51             1395*  ;
043A51 0E 20       1396*  PBCD:			LD      C,' '			; C: Leading character (" ")
043A53 06 05       1397*  PBCD0:			LD      B,5			; Number of digits in result
043A55 11 10 27 00 1398*  			LD      DE,10000		; Start off with the 10,000 column
043A59 AF          1399*  PBCD1:			XOR     A			; Counter
043A5A ED 52       1400*  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
043A5C 3C          1401*  			INC     A
043A5D 30 FB       1402*  			JR      NC,PBCD2
043A5F 19          1403*  			ADD     HL,DE			; The loop overruns by one, so adjust here
043A60 3D          1404*  			DEC     A			; A: Number of 10,000s
043A61 28 04       1405*  			JR      Z,PBCD3			; If it is 0, then skip the next bit
043A63 CB E1       1406*  			SET     4,C			; C: Set to '0' ASCII (30h)
043A65 CB E9       1407*  			SET     5,C
043A67 B1          1408*  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
043A68 C4 A5 39 04 1409*  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
043A6C 78          1410*  			LD      A,B			; If on first transition, skip this
043A6D FE 05       1411*  			CP      5			; TODO: Need to find out why
043A6F 28 06       1412*  			JR      Z,PBCD4
043A71 29          1413*  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
043A72 54          1414*  			LD      D,H			;         : rather than shifting DE right
043A73 5D          1415*  			LD      E,L			;         : This makes a lot of sense
043A74 29          1416*  			ADD     HL,HL			; HL x  4
043A75 29          1417*  			ADD     HL,HL			; HL x  8
043A76 19          1418*  			ADD     HL,DE			; HL x 10
043A77 11 E8 03 00 1419*  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
043A7B 10 DC       1420*  			DJNZ    PBCD1			; Loop until done
043A7D 37          1421*  			SCF				; SCF set for SAYLN in this module
043A7E C9          1422*  			RET
043A7F             1423*  ;
043A7F             1424*  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
043A7F             1425*  ;   Inputs: HL, IY as returned from GETVAR (NZ).
043A7F             1426*  ;  Outputs: As GETVAR.
043A7F             1427*  ; Destroys: everything
043A7F             1428*  ;
043A7F CD 04 3C 04 1429*  PUTVAR:			CALL    CREATE			; Create the variable
043A83 FD 7E 00    1430*  			LD      A,(IY)			; Fetch the next character
043A86 FE 28       1431*  			CP      '('			; Check for bad use of array
043A88 20 70       1432*  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
043A8A 3E 0E       1433*  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
043A8C C3 B6 37 04 1434*  ERROR3:			JP      ERROR_
043A90             1435*  ;
043A90             1436*  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
043A90             1437*  ;   Inputs: IY addresses first character.
043A90             1438*  ;  Outputs: Carry set and NZ if illegal character.
043A90             1439*  ;           Z-flag set if variable found, then:
043A90             1440*  ;            A = variable type (0,4,5,128 or 129)
043A90             1441*  ;            HL = IX = variable pointer.
043A90             1442*  ;            IY updated
043A90             1443*  ;           If Z-flag & carry reset, then:
043A90             1444*  ;            HL, IY set for subsequent PUTVAR call.
043A90             1445*  ; Destroys: everything
043A90             1446*  ;
043A90 FD 7E 00    1447*  GETVAR:			LD      A,(IY)			; Get the first character
043A93 FE 24       1448*  			CP      '$'			; Is it a string?
043A95 28 69       1449*  			JR      Z,GETV4			; Yes, so branch here
043A97 FE 21       1450*  			CP      '!'			; Is it indirection (32-bit)?
043A99 28 69       1451*  			JR      Z,GETV5			; Yes, so branch here
043A9B FE 3F       1452*  			CP      '?'			; Is it indirection (8-bit)?
043A9D 28 69       1453*  			JR      Z,GETV6			; Yes, so branch here
043A9F             1454*  ;
043A9F CD 6E 3B 04 1455*  			CALL    LOCATE			; Locate the variable
043AA3 C0          1456*  			RET     NZ			; And exit here if not found
043AA4             1457*  ;
043AA4             1458*  ; At this point:
043AA4             1459*  ;  HL: Address of variable in memory
043AA4             1460*  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
043AA4             1461*  ;
043AA4 FD 7E 00    1462*  			LD      A,(IY)			; Further checks
043AA7 FE 28       1463*  			CP      '('             	; Is it an array?
043AA9 20 47       1464*  			JR      NZ,GETVX        	; No, so exit
043AAB             1465*  ;
043AAB             1466*  ; We are processing an array at this point
043AAB             1467*  ;
043AAB D5          1468*  			PUSH    DE              	; Save the variable type (in D)
043AAC 7E          1469*  			LD      A,(HL)          	; Fetch the number of dimensions
043AAD B7          1470*  			OR      A
043AAE 28 DA       1471*  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
043AB0 23          1472*  			INC     HL			;
043AB1 11 00 00 00 1473*  			LD      DE,0            	; Accumulator
043AB5 F5          1474*  			PUSH    AF
043AB6 FD 23       1475*  			INC     IY              	; Skip "("
043AB8 18 05       1476*  			JR      GETV3
043ABA             1477*  ;
043ABA F5          1478*  GETV2:			PUSH    AF
043ABB CD 2A 0A 04 1479*  			CALL    COMMA
043ABF E5          1480*  GETV3:			PUSH    HL
043AC0 D5          1481*  			PUSH    DE
043AC1 CD 0F 03 04 1482*  			CALL    EXPRI			; Get the subscript
043AC5 D9          1483*  			EXX
043AC6 D1          1484*  			POP     DE
043AC7 E3          1485*  			EX      (SP),HL
043AC8 4E          1486*  			LD      C,(HL)
043AC9 23          1487*  			INC     HL
043ACA 46          1488*  			LD      B,(HL)
043ACB 23          1489*  			INC     HL
043ACC E3          1490*  			EX      (SP),HL
043ACD EB          1491*  			EX      DE,HL
043ACE D5          1492*  			PUSH    DE
043ACF CD A4 18 04 1493*  			CALL    MUL16			; HL=HL*BC
043AD3 D1          1494*  			POP     DE
043AD4 19          1495*  			ADD     HL,DE
043AD5 EB          1496*  			EX      DE,HL
043AD6 B7          1497*  			OR      A
043AD7 ED 42       1498*  			SBC     HL,BC
043AD9 3E 0F       1499*  			LD      A,15
043ADB 30 AF       1500*  			JR      NC,ERROR3		; Throw a "Subscript" error
043ADD E1          1501*  			POP     HL
043ADE F1          1502*  			POP     AF
043ADF 3D          1503*  			DEC     A               	; Dimension counter
043AE0 20 D8       1504*  			JR      NZ,GETV2
043AE2 CD 37 0A 04 1505*  			CALL    BRAKET          	; Check for closing bracket
043AE6 F1          1506*  			POP     AF              	; Restore the type
043AE7 E5          1507*  			PUSH    HL
043AE8 CD 97 18 04 1508*  			CALL    X4OR5           	; DE=DE*n
043AEC E1          1509*  			POP     HL
043AED 19          1510*  			ADD     HL,DE
043AEE 57          1511*  			LD      D,A             	; The type
043AEF FD 7E 00    1512*  			LD      A,(IY)
043AF2 FE 3F       1513*  GETVX:			CP      '?'
043AF4 28 1E       1514*  			JR      Z,GETV9
043AF6 FE 21       1515*  			CP      '!'
043AF8 28 16       1516*  			JR      Z,GETV8
043AFA E5          1517*  GETVZ:			PUSH    HL              	; Set exit conditions
043AFB DD E1       1518*  			POP     IX
043AFD 7A          1519*  			LD      A,D
043AFE BF          1520*  			CP      A
043AFF C9          1521*  			RET
043B00             1522*  ;
043B00             1523*  ; Process strings, unary & binary indirection:
043B00             1524*  ;
043B00 3E 80       1525*  GETV4:			LD      A,128           	; Static strings
043B02 18 05       1526*  			JR      GETV7
043B04             1527*  ;
043B04 3E 04       1528*  GETV5:			LD      A,4             	; Unary 32-bit indirection
043B06 18 01       1529*  			JR      GETV7
043B08             1530*  ;
043B08 AF          1531*  GETV6:			XOR     A               	; Unary 8-bit indirection
043B09             1532*  ;
043B09 21 00 00 00 1533*  GETV7:			LD      HL,0
043B0D F5          1534*  			PUSH    AF
043B0E 18 24       1535*  			JR      GETV0
043B10             1536*  ;
043B10 06 04       1537*  GETV8:			LD      B,4             	; Binary 32-bt indirection
043B12 18 02       1538*  			JR      GETVA
043B14             1539*  ;
043B14 06 00       1540*  GETV9:			LD      B,0             	; Binary 8-bit indirection
043B16             1541*  ;
043B16 E5          1542*  GETVA:			PUSH    HL
043B17 DD E1       1543*  			POP     IX
043B19 7A          1544*  			LD      A,D            		; Fetch the variable type
043B1A FE 81       1545*  			CP      129			; Is it a string?
043B1C C8          1546*  			RET     Z               	; Yes, so exit here
043B1D C5          1547*  			PUSH    BC
043B1E CD 1B 04 04 1548*  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
043B22 CD 67 06 04 1549*  			CALL    SFIX
043B26 7D          1550*  			LD	A,L
043B27 D9          1551*  			EXX
043B28 22 4A 4D 04 1552*  			LD	(R0+0),HL
043B2C 32 4C 4D 04 1553*  			LD	(R0+2),A
043B30 2A 4A 4D 04 1554*  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
043B34             1555*  ;
043B34 E5          1556*  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
043B35 FD 23       1557*  			INC     IY
043B37 CD 2A 03 04 1558*  			CALL    ITEMI
043B3B 7D          1559*  			LD	A,L			;  A: The MSB of the address
043B3C D9          1560*  			EXX
043B3D 22 4A 4D 04 1561*  			LD	(R0+0),HL		; HL: The LSW of the address
043B41 32 4C 4D 04 1562*  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
043B45 D1          1563*  			POP     DE
043B46 F1          1564*  			POP     AF
043B47 2A 4A 4D 04 1565*  			LD	HL,(R0)			; HL: L'HL
043B4B 19          1566*  			ADD     HL,DE
043B4C E5          1567*  			PUSH    HL
043B4D DD E1       1568*  			POP     IX
043B4F BF          1569*  			CP      A
043B50 C9          1570*  			RET
043B51             1571*  ;
043B51             1572*  ;GETDEF - Find entry for FN or PROC in dynamic area.
043B51             1573*  ;   Inputs: IY addresses byte following "DEF" token.
043B51             1574*  ;  Outputs: Z flag set if found
043B51             1575*  ;           Carry set if neither FN or PROC first.
043B51             1576*  ;           If Z: HL points to entry
043B51             1577*  ;                 IY addresses delimiter
043B51             1578*  ; Destroys: A,D,E,H,L,IY,F
043B51             1579*  ;
043B51 FD 7E 01    1580*  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
043B54 CD D1 3C 04 1581*  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
043B58 D8          1582*  			RET     C			; No so return with C set
043B59 FD 7E 00    1583*  			LD      A,(IY)			; Fetch the current character from the tokenised line
043B5C 21 0E 4D 04 1584*  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
043B60 FE A4       1585*  			CP      FN			; Is it the token FN?
043B62 28 4A       1586*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B64 21 11 4D 04 1587*  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
043B68 FE F2       1588*  			CP      PROC			; Is it the token PROC?
043B6A 28 42       1589*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
043B6C 37          1590*  			SCF				; No, so just return with C set
043B6D C9          1591*  			RET
043B6E             1592*  ;
043B6E             1593*  ; LOCATE - Try to locate variable name in static or dynamic variables.
043B6E             1594*  ; If illegal first character return carry, non-zero.
043B6E             1595*  ; If found, return no-carry, zero.
043B6E             1596*  ; If not found, return no-carry, non-zero.
043B6E             1597*  ;   Inputs: IY=Addresses first character of name.
043B6E             1598*  ;            A=(IY)
043B6E             1599*  ;  Outputs:  F=Z set if found, then:
043B6E             1600*  ;           IY=addresses terminator
043B6E             1601*  ;           HL=addresses location of variable
043B6E             1602*  ;            D=type of variable: 4 = integer
043B6E             1603*  ;                                5 = floating point
043B6E             1604*  ;                              129 = string
043B6E             1605*  ; Destroys: A,D,E,H,L,IY,F
043B6E             1606*  ;
043B6E             1607*  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
043B6E             1608*  ; They can contain any alphanumeric character and underscore (_)
043B6E             1609*  ; String variables are postfixed with the dollar ($) character
043B6E             1610*  ; Integer variables are postfixed with the percent (%) character
043B6E             1611*  ; Static integer variables are named @%, A% to Z%
043B6E             1612*  ; All other variables are dynamic
043B6E             1613*  ;
043B6E D6 40       1614*  LOCATE:			SUB     '@'			; Check for valid range
043B70 D8          1615*  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
043B71 21 00 00 00 1616*  			LD      HL, 0			; Clear HL
043B75 FE 1B       1617*  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
043B77 30 1E       1618*  			JR      NC,LOC0         	; Then branch here
043B79 6F          1619*  			LD	L, A			; HL = A
043B7A FD 7E 01    1620*  			LD      A,(IY+1)        	; Check the 2nd character
043B7D FE 25       1621*  			CP      '%'			; If not "%" then it is not static...
043B7F 20 21       1622*  			JR      NZ,LOC1         	; Branch here
043B81 FD 7E 02    1623*  			LD      A,(IY+2)		; Check the 3rd character
043B84 FE 28       1624*  			CP      '('			; If it is "(" (array) then it is not static...
043B86 28 1A       1625*  			JR      Z,LOC1          	; Branch here
043B88             1626*  ;
043B88             1627*  ; At this point we're dealing with a static variable
043B88             1628*  ;
043B88 29          1629*  			ADD     HL,HL			; HL: Variable index * 4
043B89 29          1630*  			ADD	HL,HL
043B8A 11 00 4C 04 1631*  			LD      DE,STAVAR       	; The static variable area in memory
043B8E 19          1632*  			ADD     HL,DE			; HL: The address of the static variable
043B8F FD 23       1633*  			INC     IY			; Skip the program pointer past the static variable name
043B91 FD 23       1634*  			INC     IY
043B93 16 04       1635*  			LD      D,4             	; Set the type to be integer
043B95 AF          1636*  			XOR     A			; Set the Z flag
043B96 C9          1637*  			RET
043B97             1638*  ;
043B97             1639*  ; At this point it's potentially a dynamic variable, just need to do a few more checks
043B97             1640*  ;
043B97 FE 1F       1641*  LOC0:			CP      '_'-'@'			; Check the first character is in
043B99 D8          1642*  			RET     C			; the range "_" to
043B9A FE 3B       1643*  			CP      'z'-'@'+1		; "z" (lowercase characters only)
043B9C 3F          1644*  			CCF				; If it is not in range then
043B9D 3D          1645*  			DEC     A               	; Set NZ flag and
043B9E D8          1646*  			RET     C			; Exit here
043B9F D6 03       1647*  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
043BA1 6F          1648*  			LD	L, A			; HL = A
043BA2             1649*  ;
043BA2             1650*  ; Yes, it's definitely a dynamic variable at this point...
043BA2             1651*  ;
043BA2 7D          1652*  LOC1:			LD	A, L			; Fetch variable index
043BA3 87          1653*  			ADD	A, A			; x 2
043BA4 85          1654*  			ADD	A, L			; x 3
043BA5 D6 03       1655*  			SUB	3			; Subtract 2 TODO: Should be 3
043BA7 6F          1656*  			LD	L, A
043BA8 11 6C 4C 04 1657*  			LD      DE, DYNVAR       	; The dynamic variable storage
043BAC D8          1658*  			RET	C			; Bounds check to trap for variable '@'
043BAD 19          1659*  			ADD     HL, DE			; HL: Address of first entry
043BAE             1660*  ;
043BAE             1661*  ; Loop through the linked list of variables to find a match
043BAE             1662*  ;
043BAE ED 17       1663*  LOC2:			LD	DE, (HL)		; Fetch the original pointer
043BB0 E5          1664*  			PUSH	HL			; Need to preserve HL for LOC6
043BB1 AF          1665*  			XOR	A			; Reset carry flag
043BB2 ED 62       1666*  			SBC	HL, HL			; Set HL to 0
043BB4 ED 52       1667*  			SBC	HL, DE			; Compare with 0
043BB6 E1          1668*  			POP	HL			; Restore the original pointer
043BB7 28 49       1669*  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
043BB9             1670*  			; LD	HL, DE			; Make a copy of this pointer in HL
043BB9 D5          1671*  			push de
043BBA E1          1672*  			pop hl ; how was that even possible?
043BBB 23          1673*  			INC     HL              	; Skip the link (24-bits)
043BBC 23          1674*  			INC     HL
043BBD 23          1675*  			INC	HL			; HL: Address of the variable name in DYNVARS
043BBE FD E5       1676*  			PUSH    IY			; IY: Address of the variable name in the program
043BC0             1677*  ;
043BC0 7E          1678*  LOC3:			LD      A,(HL)         		; Compare
043BC1 23          1679*  			INC     HL
043BC2 FD 23       1680*  			INC     IY
043BC4 FD BE 00    1681*  			CP      (IY)
043BC7 28 F7       1682*  			JR      Z, LOC3			; Keep looping whilst we've got a match...
043BC9 B7          1683*  			OR      A               	; Have we hit a terminator?
043BCA 28 07       1684*  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
043BCC             1685*  ;
043BCC FD E1       1686*  LOC4:			POP     IY			; Restore the pointer in the program
043BCE EB          1687*  			EX      DE, HL			; HL: New pointer in DYNVARS
043BCF C3 AE 3B 04 1688*  			JP      LOC2            	; Loop round and try again
043BD3             1689*  ;
043BD3             1690*  ; We might have located a variable at this point, just need to do a few more tests
043BD3             1691*  ;
043BD3 FD 2B       1692*  LOC5:			DEC     IY
043BD5 FD 7E 00    1693*  			LD      A,(IY)
043BD8 FE 28       1694*  			CP      '('
043BDA 28 15       1695*  			JR      Z,LOC5A         	; FOUND
043BDC FD 23       1696*  			INC     IY
043BDE CD C5 3C 04 1697*  			CALL    RANGE
043BE2 38 0D       1698*  			JR      C,LOC5A         	; FOUND
043BE4 FE 28       1699*  			CP      '('
043BE6 28 E4       1700*  			JR      Z,LOC4          	; KEEP LOOKING
043BE8 FD 7E FF    1701*  			LD      A,(IY-1)
043BEB CD D1 3C 04 1702*  			CALL    RANGE1
043BEF 30 DB       1703*  			JR      NC,LOC4         	; KEEP LOOKING
043BF1 D1          1704*  LOC5A:			POP     DE
043BF2 FD 7E FF    1705*  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
043BF5 FE 24       1706*  			CP      '$'			; Is it a string?
043BF7 16 81       1707*  			LD      D,129			; Yes, so return D = 129
043BF9 C8          1708*  			RET     Z
043BFA FE 25       1709*  			CP      '%'			; Is it an integer?
043BFC 16 04       1710*  			LD      D,4			; Yes, so return D = 4
043BFE C8          1711*  			RET     Z
043BFF 14          1712*  			INC     D			; At this point it must be a float
043C00 BF          1713*  			CP      A			; Set the flags
043C01 C9          1714*  			RET
043C02             1715*  ;
043C02             1716*  ; The variable is undefined at this point; HL will be zero
043C02             1717*  ;
043C02 3C          1718*  LOC6:			INC     A               	; Set NZ flag
043C03 C9          1719*  			RET
043C04             1720*  ;
043C04             1721*  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
043C04             1722*  ;   Inputs: HL, IY as returned from LOCATE (NZ).
043C04             1723*  ;  Outputs: As LOCATE, GETDEF.
043C04             1724*  ; Destroys: As LOCATE, GETDEF.
043C04             1725*  ;
043C04 AF          1726*  CREATE:			XOR     A
043C05 ED 5B 1D 4D 1727*  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
043C0A ED 1F       1728*  			LD	(HL), DE		; Store
043C0C EB          1729*  			EX      DE,HL
043C0D 77          1730*  			LD      (HL),A			; Clear the link of the new entity
043C0E 23          1731*  			INC     HL
043C0F 77          1732*  			LD      (HL),A
043C10 23          1733*  			INC     HL
043C11 77          1734*  			LD      (HL),A
043C12 23          1735*  			INC     HL
043C13 FD 23       1736*  LOC7:			INC     IY
043C15 CD C5 3C 04 1737*  			CALL    RANGE           	; END OF VARIABLE?
043C19 38 15       1738*  			JR      C,LOC8
043C1B 77          1739*  			LD      (HL),A
043C1C 23          1740*  			INC     HL
043C1D CD D1 3C 04 1741*  			CALL    RANGE1
043C21 30 F0       1742*  			JR      NC,LOC7
043C23 FE 28       1743*  			CP      '('
043C25 28 09       1744*  			JR      Z,LOC8
043C27 FD 7E 01    1745*  			LD      A,(IY+1)
043C2A FE 28       1746*  			CP      '('
043C2C 28 E5       1747*  			JR      Z,LOC7
043C2E FD 23       1748*  			INC     IY
043C30 36 00       1749*  LOC8:			LD      (HL),0          	; TERMINATOR
043C32 23          1750*  			INC     HL
043C33 E5          1751*  			PUSH    HL
043C34 CD F2 3B 04 1752*  			CALL    TYPE_			; Get the variable type in D
043C38 3E 04       1753*  			LD      A,4			; If it is an integer then it takes up 4 bytes
043C3A BA          1754*  			CP      D
043C3B 28 01       1755*  			JR      Z,LOC9			; So skip the next bit
043C3D 3C          1756*  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
043C3E 36 00       1757*  LOC9:			LD      (HL),0          	; Initialise the memory to zero
043C40 23          1758*  			INC     HL
043C41 3D          1759*  			DEC     A
043C42 20 FA       1760*  			JR      NZ,LOC9
043C44 22 1D 4D 04 1761*  			LD      (FREE),HL		; Adjust the stack
043C48 CD 81 16 04 1762*  			CALL    CHECK			; Check whether we are out of space
043C4C E1          1763*  			POP     HL
043C4D AF          1764*  			XOR     A
043C4E C9          1765*  			RET
043C4F             1766*  ;
043C4F             1767*  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
043C4F             1768*  ;   Inputs: IY = Text Pointer
043C4F             1769*  ;  Outputs: HL = Line number (zero if none)
043C4F             1770*  ;           IY updated
043C4F             1771*  ; Destroys: A,D,E,H,L,IY,F
043C4F             1772*  ;
043C4F             1773*  ; This bit of code performs a BASE 10 shift to build up the number
043C4F             1774*  ; So if the string passed is "345", the algorithm does this:
043C4F             1775*  ;
043C4F             1776*  ;    HL : Digit	: Operation
043C4F             1777*  ; ----- : ----- : ---------
043C4F             1778*  ; 00000 :	:
043C4F             1779*  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
043C4F             1780*  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
043C4F             1781*  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
043C4F             1782*  ;
043C4F             1783*  ; The multiply by 10 is done by an unrolled shift and add loop
043C4F             1784*  ;
043C4F CD 78 0A 04 1785*  LINNUM:			CALL    NXT			; Skip whitespace to the first character
043C53 40 21 00 00 1786*  			LD.SIS  HL,0			; The running total
043C57 FD 7E 00    1787*  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
043C5A D6 30       1788*  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
043C5C D8          1789*  			RET     C			; And return if less than 0
043C5D FE 0A       1790*  			CP      10			; Or greater than or equal to 10
043C5F D0          1791*  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
043C60 FD 23       1792*  			INC     IY			; Increment the string pointer
043C62 54          1793*  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
043C63 5D          1794*  			LD      E,L			; Store the original number in DE
043C64 52 29       1795*  			ADD.S   HL,HL           	; *2
043C66 38 13       1796*  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
043C68 52 29       1797*  			ADD.S   HL,HL           	; *4S
043C6A 38 0F       1798*  			JR      C,TOOBIG
043C6C 52 19       1799*  			ADD.S   HL,DE           	; *5
043C6E 38 0B       1800*  			JR      C,TOOBIG
043C70 52 29       1801*  			ADD.S   HL,HL           	; *10
043C72 38 07       1802*  			JR      C,TOOBIG
043C74 5F          1803*  			LD      E,A			; A->DE: the digit to add in
043C75 16 00       1804*  			LD      D,0
043C77 52 19       1805*  			ADD.S   HL,DE           	; Add in the digit to the running total
043C79 30 DC       1806*  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
043C7B             1807*  ;
043C7B 3E 14       1808*  TOOBIG:			LD      A,20
043C7D C3 B6 37 04 1809*  			JP      ERROR_           	; Error: "Too big"
043C81             1810*  ;
043C81             1811*  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
043C81             1812*  ;   Inputs: IY = text pointer
043C81             1813*  ;  Outputs: HL = first number (10 by default)
043C81             1814*  ;           BC = second number (10 by default)
043C81             1815*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
043C81             1816*  ;
043C81 CD 4F 3C 04 1817*  PAIR:			CALL    LINNUM          	; Parse the first line number
043C85 7C          1818*  			LD      A,H			; If it is not zero, then...
043C86 B5          1819*  			OR      L
043C87 20 02       1820*  			JR      NZ,PAIR1		; Skip...
043C89 2E 0A       1821*  			LD      L,10			; HL: the default value (10)
043C8B             1822*  ;
043C8B CD AC 17 04 1823*  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
043C8F FD 23       1824*  			INC     IY			; Skip to next character
043C91 E5          1825*  			PUSH    HL			; Stack the first line number
043C92 21 0A 00 00 1826*  			LD      HL,10			; HL: the second default (10)
043C96 C4 4F 3C 04 1827*  			CALL    NZ,LINNUM       	; Parse the second line number
043C9A E3          1828*  			EX      (SP),HL			; HL: The first line number (off the stack)
043C9B C1          1829*  			POP     BC			; BC: Second line number
043C9C 78          1830*  			LD      A,B			; If the second line number is not zero then...
043C9D B1          1831*  			OR      C			; We're good...
043C9E C0          1832*  			RET     NZ			; Exit, otherwise...
043C9F CD CD 37 04 1833*  			CALL    EXTERR			; Throw error: "Silly"
043CA3 53 69 6C 6C 1834*  			DB    	"Silly", 0
       79 00       
043CA9             1835*  ;
043CA9             1836*  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
043CA9             1837*  ;   Inputs: IY = text pointer
043CA9             1838*  ;  Outputs: HL = points to program text
043CA9             1839*  ;           BC = second number (0 by default)
043CA9             1840*  ; Destroys: A,B,C,D,E,H,L,IY,F
043CA9             1841*  ;
043CA9 CD 4F 3C 04 1842*  DLPAIR:			CALL    LINNUM			; Parse the first line number
043CAD E5          1843*  			PUSH    HL			; Stack it
043CAE CD AC 17 04 1844*  			CALL    TERMQ			; Check for ELSE, : or CR
043CB2 28 0A       1845*  			JR      Z,DLP1			; And exit if so
043CB4 FE E7       1846*  			CP      TIF			; Is the token IF?
043CB6 28 06       1847*  			JR      Z,DLP1			; Yes, so skip the next bit...
043CB8 FD 23       1848*  			INC     IY			; Otherwise...
043CBA CD 4F 3C 04 1849*  			CALL    LINNUM			; Fetch the second line number
043CBE E3          1850*  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
043CBF CD E5 39 04 1851*  			CALL    FINDL			; HL: Find the address of the line
043CC3 C1          1852*  			POP     BC			; BC: The second number
043CC4 C9          1853*  			RET
043CC5             1854*  ;
043CC5             1855*  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
043CC5             1856*  ;   Inputs: IY addresses character
043CC5             1857*  ;  Outputs: Carry set if out-of-range.
043CC5             1858*  ; Destroys: A,F
043CC5             1859*  ;
043CC5             1860*  ; It is called here to check the following
043CC5             1861*  ; In range: "$", "%" and "("
043CC5             1862*  ;   Plus all characters in RANGE1 and RANGE2
043CC5             1863*  ;
043CC5 FD 7E 00    1864*  RANGE:			LD      A,(IY)			; Fetch the character
043CC8 FE 24       1865*  			CP      '$'			; Postfix for string variable is valid
043CCA C8          1866*  			RET     Z
043CCB FE 25       1867*  			CP      '%'			; Postfix for integer variable is valid
043CCD C8          1868*  			RET     Z
043CCE FE 28       1869*  			CP      '('			; Postfix for array is valid
043CD0 C8          1870*  			RET     Z
043CD1             1871*  ;
043CD1             1872*  ; It is called here to check the following
043CD1             1873*  ; In range: "0" to "9" and "@"
043CD1             1874*  ;   Plus all characters in RANGE2
043CD1             1875*  ;
043CD1 FE 30       1876*  RANGE1:			CP      '0'			; If it is between '0'...
043CD3 D8          1877*  			RET     C
043CD4 FE 3A       1878*  			CP      '9'+1			; And '9'...
043CD6 3F          1879*  			CCF
043CD7 D0          1880*  			RET     NC			; Then it is valid
043CD8 FE 40       1881*  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
043CDA C8          1882*  			RET     Z
043CDB             1883*  ;
043CDB             1884*  ; It is called here to check the following
043CDB             1885*  ; In range: "A" to "Z", "a' to "z", "_" and "`"
043CDB             1886*  ;
043CDB FE 41       1887*  RANGE2:			CP      'A'			; If it is between 'A'...
043CDD D8          1888*  			RET     C
043CDE FE 5B       1889*  			CP      'Z'+1			; And 'Z'...
043CE0 3F          1890*  			CCF
043CE1 D0          1891*  			RET     NC			; Then it is valid
043CE2 FE 5F       1892*  			CP      '_'			; If it is underscore, grave, or between 'a'
043CE4 D8          1893*  			RET     C
043CE5 FE 7B       1894*  			CP      'z'+1			; And 'z'
043CE7 3F          1895*  			CCF				; Then it is valid
043CE8 C9          1896*  			RET
043CE9             1897*  ;
043CE9             1898*  ; Throw a 'LINE space' error (line too long)
043CE9             1899*  ; This is called from LEXAN
043CE9             1900*  ;
043CE9 AF          1901*  SPACE_: 		XOR     A
043CEA CD CD 37 04 1902*  			CALL    EXTERR          	; "LINE space"
043CEE 86 08 00    1903*  			DB    	LINE_, 8, 0
043CF1             1904*  ;
043CF1             1905*  ; LEXAN - LEXICAL ANALYSIS.
043CF1             1906*  ;  Bit 0,C: 1=left, 0=right
043CF1             1907*  ;  Bit 2,C: 1=in BINARY
043CF1             1908*  ;  Bit 3,C: 1=in HEX
043CF1             1909*  ;  Bit 4,C: 1=accept line number
043CF1             1910*  ;  Bit 5,C: 1=in variable, FN, PROC
043CF1             1911*  ;  Bit 6,C: 1=in REM, DATA, *
043CF1             1912*  ;  Bit 7,C: 1=in quotes
043CF1             1913*  ;   Inputs: IY addresses source string
043CF1             1914*  ;           DE addresses destination string (must be page boundary)
043CF1             1915*  ;            C sets initial mode
043CF1             1916*  ;  Outputs: DE, IY updated
043CF1             1917*  ;            A holds carriage return
043CF1             1918*  ;
043CF1 12          1919*  LEXAN1:			LD      (DE),A          	; Transfer to buffer
043CF2 13          1920*  			INC     DE              	; Increment the pointers
043CF3 FD 23       1921*  			INC     IY			; And fall through to the main function
043CF5             1922*  ;
043CF5             1923*  ; This is the main entry point
043CF5             1924*  ;
043CF5 7B          1925*  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
043CF6 FE FC       1926*  			CP      252             	; If it is >= 252 bytes, then...
043CF8 30 EF       1927*  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
043CFA FD 7E 00    1928*  			LD      A,(IY)			; Fetch character from source string
043CFD FE 0D       1929*  			CP      CR			; If it is a CR
043CFF C8          1930*  			RET     Z               	; Then it is end of line; we're done parsing
043D00 CD D1 3C 04 1931*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
043D04 30 06       1932*  			JR      NC,LEXAN3		; Yes, so skip
043D06 CB A9       1933*  			RES     5,C             	; FLAG: NOT IN VARIABLE
043D08 CB 99       1934*  			RES     3,C             	; FLAG: NOT IN HEX
043D0A CB 91       1935*  			RES	2,C			; FLAG: NOT IN BINARY
043D0C             1936*  ;
043D0C FE 20       1937*  LEXAN3:			CP      ' '			; Ignore spaces
043D0E 28 E1       1938*  			JR      Z,LEXAN1
043D10 FE 2C       1939*  			CP      ','			; Ignore commas
043D12 28 DD       1940*  			JR      Z,LEXAN1
043D14 FE 32       1941*  			CP	'2'			; If less than '2'
043D16 30 02       1942*  			JR	NC, @F			; No, so skip
043D18 CB 91       1943*  			RES	2,C			; FLAG: NOT IN BINARY
043D1A FE 47       1944*  @@:			CP      'G'			; If less then 'G'
043D1C 38 02       1945*  			JR      C,LEXAN4		; Yes, so skip
043D1E CB 99       1946*  			RES     3,C             	; FLAG: NOT IN HEX
043D20             1947*  ;
043D20 FE 22       1948*  LEXAN4:			CP      34			; Is it a quote character?
043D22 20 05       1949*  			JR      NZ,LEXAN5		; No, so skip
043D24 CB 11       1950*  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
043D26 3F          1951*  			CCF                     	; Toggle the carry
043D27 CB 19       1952*  			RR      C			; And then shifting it back into bit 7 of C
043D29             1953*  ;
043D29 CB 61       1954*  LEXAN5:			BIT     4,C			; Accept line number?
043D2B 28 12       1955*  			JR      Z,LEXAN6		; No, so skip
043D2D CB A1       1956*  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
043D2F C5          1957*  			PUSH    BC
043D30 D5          1958*  			PUSH    DE
043D31 CD 4F 3C 04 1959*  			CALL    LINNUM         		; Parse the line number to HL
043D35 D1          1960*  			POP     DE
043D36 C1          1961*  			POP     BC
043D37 7C          1962*  			LD      A,H			; If it is not zero
043D38 B5          1963*  			OR      L
043D39 C4 B2 3D 04 1964*  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
043D3D 18 B6       1965*  			JR      LEXAN2          	; And loop
043D3F             1966*  ;
043D3F 0D          1967*  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
043D40 28 0A       1968*  			JR      Z,LEXAN7        	; If so, skip
043D42 0C          1969*  			INC     C			; Otherwise restore C
043D43 20 AC       1970*  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
043D45 B7          1971*  			OR      A			; Set the flags based on the character
043D46 F4 1D 38 04 1972*  			CALL    P,LEX           	; Tokenise if A < 128
043D4A 18 13       1973*  			JR      LEXAN8			; And skip
043D4C             1974*  ;
043D4C             1975*  ; Processing the LEFT hand side here
043D4C             1976*  ;
043D4C FE 2A       1977*  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
043D4E 28 17       1978*  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
043D50 B7          1979*  			OR      A			; Set the flags based on the character
043D51 F4 1D 38 04 1980*  			CALL    P,LEX           	; Tokenise if A < 128
043D55             1981*  ;
043D55             1982*  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
043D55             1983*  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
043D55             1984*  ; Examples:
043D55             1985*  ;   LET A% = PAGE : REM This is the GET version
043D55             1986*  ;   PAGE = 40000  : REM This is the SET version
043D55             1987*  ;
043D55 FE 8F       1988*  			CP      TOKLO			; TOKLO is 8Fh
043D57 38 06       1989*  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
043D59 FE 94       1990*  			CP      TOKHI+1			; TOKHI is 93h
043D5B 30 02       1991*  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
043D5D C6 40       1992*  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
043D5F             1993*  ;
043D5F FE F4       1994*  LEXAN8:			CP      REM			; If the token is REM
043D61 28 04       1995*  			JR      Z,LEXAN9		; Then stop tokenising
043D63 FE DC       1996*  			CP      DATA_			; If it is not DATA then
043D65 20 02       1997*  			JR      NZ,LEXANA		; Skip
043D67 CB F1       1998*  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
043D69             1999*  ;
043D69 FE A4       2000*  LEXANA:			CP      FN			; If the token is FN
043D6B 28 0A       2001*  			JR      Z,LEXANB
043D6D FE F2       2002*  			CP      PROC			; Or the token is PROC
043D6F 28 06       2003*  			JR      Z,LEXANB		; Then jump to here
043D71 CD DB 3C 04 2004*  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
043D75 38 02       2005*  			JR      C,LEXANC		; Jump here if out of range
043D77             2006*  ;
043D77 CB E9       2007*  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
043D79 FE 26       2008*  LEXANC:			CP      '&'			; Check for hex prefix
043D7B 20 02       2009*  			JR      NZ,LEXAND		; If not, skip
043D7D CB D9       2010*  			SET     3,C             	; FLAG: IN HEX
043D7F             2011*  ;
043D7F FE 25       2012*  LEXAND:			CP	'%'			; Check for binary prefix
043D81 20 02       2013*  			JR	NZ,LEXANE		; If not, skip
043D83 CB D1       2014*  			SET	2,C			; FLAG: IN BINARY
043D85             2015*  ;
043D85 21 A9 3D 04 2016*  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
043D89 C5          2017*  			PUSH    BC
043D8A 01 06 00 00 2018*  			LD      BC,LIST1L		; The list length
043D8E ED B1       2019*  			CPIR				; Check if the token is in this list
043D90 C1          2020*  			POP     BC
043D91 20 02       2021*  			JR      NZ,LEXANF		; If not, then skip
043D93 CB E1       2022*  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
043D95             2023*  ;
043D95 21 AD 3D 04 2024*  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
043D99 C5          2025*  			PUSH    BC
043D9A 01 05 00 00 2026*  			LD      BC,LIST2L		; The list length
043D9E ED B1       2027*  			CPIR				; Check if the token is in this list
043DA0 C1          2028*  			POP     BC
043DA1 20 02       2029*  			JR      NZ,LEXANG		; If not, then skip
043DA3 CB C1       2030*  			SET     0,C             	; FLAG: ENTER LEFT MODE
043DA5 C3 F1 3C 04 2031*  LEXANG:			JP      LEXAN1			; And loop
043DA9             2032*  
043DA9             2033*  ;
043DA9             2034*  ; LIST1: List of tokens that must be followed by line numbers
043DA9             2035*  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
043DA9             2036*  ;
043DA9 E5          2037*  LIST1:			DB	GOTO
043DAA E4          2038*  			DB	GOSUB
043DAB F7          2039*  			DB	RESTOR
043DAC FC          2040*  			DB	TRACE
043DAD 8C          2041*  LIST2:			DB	THEN
043DAE 8B          2042*  			DB	ELSE_
043DAF             2043*  LIST1L:			EQU     $-LIST1
043DAF F5          2044*  			DB	REPEAT
043DB0 85          2045*  			DB	TERROR
043DB1 3A          2046*  			DB    	':'
043DB2             2047*  LIST2L:			EQU     $-LIST2
043DB2             2048*  ;
043DB2             2049*  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
043DB2             2050*  ;   Inputs: HL=line number, DE=string pointer
043DB2             2051*  ;  Outputs: DE updated, BIT 4,C set.
043DB2             2052*  ; Destroys: A,B,C,D,E,F
043DB2             2053*  ;
043DB2             2054*  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
043DB2             2055*  ;
043DB2             2056*  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
043DB2             2057*  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
043DB2             2058*  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
043DB2             2059*  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
043DB2             2060*  ; each byte are then stored, in LO/HI order, ORred with 0x40.
043DB2             2061*  ;
043DB2 CB E1       2062*  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
043DB4 EB          2063*  			EX      DE, HL			; HL: string pointer, DE: line number
043DB5 36 8D       2064*  			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
043DB7 23          2065*  			INC     HL
043DB8 7A          2066*  			LD      A,D			; Get the high byte
043DB9 E6 C0       2067*  			AND     0C0H			; Get the top two bits	DD000000
043DBB 0F          2068*  			RRCA				; Shift right		00DD0000
043DBC 0F          2069*  			RRCA
043DBD 47          2070*  			LD      B,A			; Store in B
043DBE 7B          2071*  			LD      A,E			; Get the low byte
043DBF E6 C0       2072*  			AND     0C0H			; Get the top two bits	EE000000
043DC1 B0          2073*  			OR      B			; Combine with D	EEDD0000
043DC2 0F          2074*  			RRCA				; Shift right		00EEDD00
043DC3 0F          2075*  			RRCA
043DC4 EE 54       2076*  			XOR     01010100B		; XOR with 54h
043DC6 77          2077*  			LD      (HL),A			; Store this as the second byte
043DC7 23          2078*  			INC     HL
043DC8 7B          2079*  			LD      A,E			; Get the low byte
043DC9 E6 3F       2080*  			AND     3FH			; Strip the top two bits off
043DCB F6 40       2081*  			OR      '@'			; OR with 40h
043DCD 77          2082*  			LD      (HL),A			; Store
043DCE 23          2083*  			INC     HL
043DCF 7A          2084*  			LD      A,D			; Get the high byte
043DD0 E6 3F       2085*  			AND     3FH			; Strip the top two bits off
043DD2 F6 40       2086*  			OR      '@'			; OR with 40h
043DD4 77          2087*  			LD      (HL),A			; Store
043DD5 23          2088*  			INC     HL
043DD6 EB          2089*  			EX      DE,HL			; DE: string pointer, HL: line number
043DD7 C9          2090*  			RET
043DD8             2091*  ;
043DD8             2092*  ; TEXT - OUTPUT MESSAGE.
043DD8             2093*  ;   Inputs: HL addresses text (terminated by nul)
043DD8             2094*  ;  Outputs: HL addresses character following nul.
043DD8             2095*  ; Destroys: A,H,L,F
043DD8             2096*  ;
043DD8 2A 2F 4D 04 2097*  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
043DDC             2098*  ;
043DDC 7E          2099*  TEXT_:			LD      A, (HL)			; Fetch the character
043DDD 23          2100*  			INC     HL			; Increment pointer to next character
043DDE B7          2101*  			OR      A			; Check for the nul (0) string terminator
043DDF C8          2102*  			RET     Z			; And return if so
043DE0 CD C2 39 04 2103*  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
043DE4 18 F6       2104*  			JR      TEXT_			; And loop
043DE6             2105*  ;
043DE6             2106*  ; TELL - OUTPUT MESSAGE.
043DE6             2107*  ;   Inputs: Text follows subroutine call (term=nul)
043DE6             2108*  ; Destroys: A,F
043DE6             2109*  ;
043DE6             2110*  ; Example usage:
043DE6             2111*  ;
043DE6             2112*  ;	CALL	TELL			Call the function
043DE6             2113*  ;	DB	"Hello World", 0	Followed by a zero terminated string
043DE6             2114*  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
043DE6             2115*  ;
043DE6 E3          2116*  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
043DE7 CD DC 3D 04 2117*  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
043DEB E3          2118*  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
043DEC C9          2119*  			RET				; at this point we'll return to the first instruction after the message
043DED             0011       include "misc.asm"
043DED             0001*  ;
043DED             0002*  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043DED             0003*  ; Author:	Dean Belfield
043DED             0004*  ; Created:	12/05/2023
043DED             0005*  ; Last Updated:	12/05/2023
043DED             0006*  ;
043DED             0007*  ; Modinfo:
043DED             0008*  
043DED             0009*  			; INCLUDE	"equs.inc"
043DED             0010*  			; INCLUDE	"macros.inc"
043DED             0011*  
043DED             0012*  			; .ASSUME	ADL = 1
043DED             0013*  
043DED             0014*  			; SEGMENT CODE
043DED             0015*  
043DED             0016*  			; XDEF	ASC_TO_NUMBER
043DED             0017*  			; XDEF	SWITCH_A
043DED             0018*  			; XDEF	NULLTOCR
043DED             0019*  			; XDEF	CRTONULL
043DED             0020*  			; XDEF	CSTR_FNAME
043DED             0021*  			; XDEF	CSTR_LINE
043DED             0022*  			; XDEF	CSTR_FINDCH
043DED             0023*  			; XDEF	CSTR_ENDSWITH
043DED             0024*  			; XDEF	CSTR_CAT
043DED             0025*  
043DED             0026*  			; XREF	OSWRCH
043DED             0027*  			; XREF	KEYWDS
043DED             0028*  			; XREF	KEYWDL
043DED             0029*  
043DED             0030*  ; Read a number and convert to binary
043DED             0031*  ; If prefixed with &, will read as hex, otherwise decimal
043DED             0032*  ;   Inputs: HL: Pointer in string buffer
043DED             0033*  ;  Outputs: HL: Updated text pointer
043DED             0034*  ;           DE: Value
043DED             0035*  ;            A: Terminator (spaces skipped)
043DED             0036*  ; Destroys: A,D,E,H,L,F
043DED             0037*  ;
043DED C5          0038*  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043DEE 11 00 00 00 0039*  			LD	DE, 0			; Initialise DE
043DF2 CD 34 3E 04 0040*  			CALL	SKIPSPC			; Skip whitespace
043DF6 7E          0041*  			LD	A, (HL)			; Read first character
043DF7 FE 26       0042*  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043DF9 20 1F       0043*  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043DFB 23          0044*  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043DFC             0045*  ;
043DFC 7E          0046*  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043DFD CD 42 3E 04 0047*  			CALL    UPPERC			; Convert to uppercase
043E01 D6 30       0048*  			SUB	'0'			; Normalise to 0
043E03 38 2E       0049*  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E05 FE 0A       0050*  			CP 	10			; Check if >= 10
043E07 38 06       0051*  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043E09 D6 07       0052*  			SUB 	7			; Adjust ASCII A-F to nibble
043E0B FE 10       0053*  			CP 	16			; Check for > F
043E0D 30 24       0054*  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043E0F EB          0055*  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
043E10 29          0056*  			ADD	HL, HL
043E11 29          0057*  			ADD	HL, HL
043E12 29          0058*  			ADD	HL, HL
043E13 29          0059*  			ADD	HL, HL
043E14 EB          0060*  			EX	DE, HL
043E15 B3          0061*  			OR      E			; OR the new digit in to the least significant nibble
043E16 5F          0062*  			LD      E, A
043E17 23          0063*  			INC     HL			; Onto the next character
043E18 18 E2       0064*  			JR      ASC_TO_NUMBER1		; And loop
043E1A             0065*  ;
043E1A 7E          0066*  ASC_TO_NUMBER3:		LD	A, (HL)
043E1B D6 30       0067*  			SUB	'0'			; Normalise to 0
043E1D 38 14       0068*  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043E1F FE 0A       0069*  			CP	10			; Check if >= 10
043E21 30 10       0070*  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
043E23 EB          0071*  			EX 	DE, HL 			; Stick DE in HL
043E24 44          0072*  			LD	B, H 			; And copy HL into BC
043E25 4D          0073*  			LD	C, L
043E26 29          0074*  			ADD	HL, HL 			; x 2
043E27 29          0075*  			ADD	HL, HL 			; x 4
043E28 09          0076*  			ADD	HL, BC 			; x 5
043E29 29          0077*  			ADD	HL, HL 			; x 10
043E2A EB          0078*  			EX	DE, HL
043E2B             0079*  			ADD8U_DE 			; Add A to DE (macro)
043E2B 83          0001*M 		ADD	A, E
043E2C 5F          0002*M 		LD	E, A
043E2D 8A          0003*M 		ADC	A, D
043E2E 93          0004*M 		SUB	E
043E2F 57          0005*M 		LD	D, A
043E30 23          0080*  			INC	HL
043E31 18 E7       0081*  			JR	ASC_TO_NUMBER3
043E33 C1          0082*  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
043E34             0083*  
043E34             0084*  ; Skip a space
043E34             0085*  ; HL: Pointer in string buffer
043E34             0086*  ;
043E34 7E          0087*  SKIPSPC:			LD      A, (HL)
043E35 FE 20       0088*  			CP      ' '
043E37 C0          0089*  			RET     NZ
043E38 23          0090*  			INC     HL
043E39 18 F9       0091*  			JR      SKIPSPC
043E3B             0092*  
043E3B             0093*  ; Skip a string
043E3B             0094*  ; HL: Pointer in string buffer
043E3B             0095*  ;
043E3B 7E          0096*  SKIPNOTSP:		LD	A, (HL)
043E3C FE 20       0097*  			CP	' '
043E3E C8          0098*  			RET	Z
043E3F 23          0099*  			INC	HL
043E40 18 F9       0100*  			JR	SKIPNOTSP
043E42             0101*  
043E42             0102*  ; Convert a character to upper case
043E42             0103*  ;  A: Character to convert
043E42             0104*  ;
043E42 E6 7F       0105*  UPPERC:  		AND     7FH
043E44 FE 60       0106*  			CP      '`'
043E46 D8          0107*  			RET     C
043E47 E6 5F       0108*  			AND     5FH			; Convert to upper case
043E49 C9          0109*  			RET
043E4A             0110*  
043E4A             0111*  ; Switch on A - lookup table immediately after call
043E4A             0112*  ;  A: Index into lookup table
043E4A             0113*  ;
043E4A E3          0114*  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
043E4B 87          0115*  			ADD	A, A			; Multiply A by two
043E4C             0116*  			ADD8U_HL 			; Add to HL (macro)
043E4C 85          0001*M 		ADD	A, L
043E4D 6F          0002*M 		LD	L, A
043E4E 8C          0003*M 		ADC	A, H
043E4F 95          0004*M 		SUB	L
043E50 67          0005*M 		LD	H, A
043E51 7E          0117*  			LD	A, (HL)			; follow the call. Fetch an address from the
043E52 23          0118*  			INC	HL 			; table.
043E53 66          0119*  			LD	H, (HL)
043E54 6F          0120*  			LD	L, A
043E55 E3          0121*  			EX	(SP), HL		; Swap this new address back, restores HL
043E56 C9          0122*  			RET				; Return program control to this new address
043E57             0123*  
043E57             0124*  ; Convert the buffer to a null terminated string and back
043E57             0125*  ; HL: Buffer address
043E57             0126*  ;
043E57 C5          0127*  NULLTOCR:		PUSH 	BC
043E58 06 00       0128*  			LD	B, 0
043E5A 0E 0D       0129*  			LD	C, CR
043E5C 18 05       0130*  			JR	CRTONULL0
043E5E             0131*  ;
043E5E C5          0132*  CRTONULL:		PUSH	BC
043E5F 06 0D       0133*  			LD	B, CR
043E61 0E 00       0134*  			LD	C, 0
043E63             0135*  ;
043E63 E5          0136*  CRTONULL0:		PUSH	HL
043E64 7E          0137*  CRTONULL1:		LD	A, (HL)
043E65 B8          0138*  			CP 	B
043E66 28 03       0139*  			JR	Z, CRTONULL2
043E68 23          0140*  			INC	HL
043E69 18 F9       0141*  			JR	CRTONULL1
043E6B 71          0142*  CRTONULL2:		LD	(HL), C
043E6C E1          0143*  			POP 	HL
043E6D C1          0144*  			POP	BC
043E6E C9          0145*  			RET
043E6F             0146*  
043E6F             0147*  ; Copy a filename to DE and zero terminate it
043E6F             0148*  ; HL: Source
043E6F             0149*  ; DE: Destination (ACCS)
043E6F             0150*  ;
043E6F 7E          0151*  CSTR_FNAME:		LD	A, (HL)			; Get source
043E70 FE 20       0152*  			CP	32			; Is it space
043E72 28 09       0153*  			JR	Z, @F
043E74 FE 0D       0154*  			CP	CR			; Or is it CR
043E76 28 05       0155*  			JR	Z, @F
043E78 12          0156*  			LD	(DE), A			; No, so store
043E79 23          0157*  			INC	HL			; Increment
043E7A 13          0158*  			INC	DE
043E7B 18 F2       0159*  			JR	CSTR_FNAME		; And loop
043E7D AF          0160*  @@:			XOR	A			; Zero terminate the target string
043E7E 12          0161*  			LD	(DE), A
043E7F 13          0162*  			INC	DE			; And point to next free address
043E80 C9          0163*  			RET
043E81             0164*  
043E81             0165*  ; Copy a CR terminated line to DE and zero terminate it
043E81             0166*  ; HL: Source
043E81             0167*  ; DE: Destination (ACCS)
043E81             0168*  ;
043E81 7E          0169*  CSTR_LINE:		LD	A, (HL)			; Get source
043E82 FE 0D       0170*  			CP	CR			; Is it CR
043E84 28 05       0171*  			JR	Z, @F
043E86 12          0172*  			LD	(DE), A			; No, so store
043E87 23          0173*  			INC	HL			; Increment
043E88 13          0174*  			INC	DE
043E89 18 F6       0175*  			JR	CSTR_LINE		; And loop
043E8B AF          0176*  @@:			XOR	A			; Zero terminate the target string
043E8C 12          0177*  			LD	(DE), A
043E8D 13          0178*  			INC	DE			; And point to next free address
043E8E C9          0179*  			RET
043E8F             0180*  
043E8F             0181*  ; Find the first occurrence of a character (case sensitive)
043E8F             0182*  ; HL: Source
043E8F             0183*  ;  C: Character to find
043E8F             0184*  ; Returns:
043E8F             0185*  ; HL: Pointer to character, or end of string marker
043E8F             0186*  ;
043E8F 7E          0187*  CSTR_FINDCH:		LD	A, (HL)			; Get source
043E90 B9          0188*  			CP	C			; Is it our character?
043E91 C8          0189*  			RET	Z			; Yes, so exit
043E92 B7          0190*  			OR	A			; Is it the end of string?
043E93 C8          0191*  			RET	Z			; Yes, so exit
043E94 23          0192*  			INC	HL
043E95 18 F8       0193*  			JR	CSTR_FINDCH
043E97             0194*  
043E97             0195*  ; Check whether a string ends with another string (case insensitive)
043E97             0196*  ; HL: Source
043E97             0197*  ; DE: The substring we want to test with
043E97             0198*  ; Returns:
043E97             0199*  ;  F: Z if HL ends with DE, otherwise NZ
043E97             0200*  ;
043E97 7E          0201*  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043E98 CD 42 3E 04 0202*  			CALL	UPPERC			; Convert to upper case
043E9C 4F          0203*  			LD	C, A
043E9D 1A          0204*  			LD	A, (DE)			; Get the substring byte
043E9E B9          0205*  			CP	C
043E9F C0          0206*  			RET	NZ			; Return NZ if at any point the strings don't match
043EA0 B1          0207*  			OR	C			; Check whether both bytes are zero
043EA1 C8          0208*  			RET	Z			; If so, return, as we have reached the end of both strings
043EA2 23          0209*  			INC	HL
043EA3 13          0210*  			INC	DE
043EA4 18 F1       0211*  			JR	CSTR_ENDSWITH		; And loop
043EA6             0212*  
043EA6             0213*  ; Concatenate a string onto the end of another string
043EA6             0214*  ; HL: Source
043EA6             0215*  ; DE: Second string
043EA6             0216*  ;
043EA6 7E          0217*  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043EA7 B7          0218*  			OR	A
043EA8 28 03       0219*  			JR	Z, CSTR_CAT_1
043EAA 23          0220*  			INC	HL
043EAB 18 F9       0221*  			JR	CSTR_CAT
043EAD             0222*  ;
043EAD 1A          0223*  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043EAE 77          0224*  			LD	(HL), A
043EAF B7          0225*  			OR	A			; Check for end of string
043EB0 C8          0226*  			RET	Z			; And return
043EB1 23          0227*  			INC	HL
043EB2 13          0228*  			INC	DE
043EB3 18 F8       0229*  			JR	CSTR_CAT_1		; Loop until finished
043EB5             0012       include "patch.asm"
043EB5             0001*  ;
043EB5             0002*  ; Title:	BBC Basic for AGON
043EB5             0003*  ; Author:	Dean Belfield
043EB5             0004*  ; Created:	12/05/2023
043EB5             0005*  ; Last Updated:	15/11/2023
043EB5             0006*  ;
043EB5             0007*  ; Modinfo:
043EB5             0008*  ; 11/07/2023:	Fixed *BYE for ADL mode
043EB5             0009*  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
043EB5             0010*  
043EB5             0011*  			; .ASSUME	ADL = 1
043EB5             0012*  
043EB5             0013*  			; INCLUDE	"equs.inc"
043EB5             0014*  			; INCLUDE "macros.inc"
043EB5             0015*  			; INCLUDE "mos_api.inc"	; In MOS/src
043EB5             0016*  
043EB5             0017*  			; SEGMENT CODE
043EB5             0018*  
043EB5             0019*  			; XDEF	OSWRCH
043EB5             0020*  			; XDEF	OSLINE
043EB5             0021*  			; XDEF	ESCSET
043EB5             0022*  			; XDEF	PUTIME
043EB5             0023*  			; XDEF	GETIME
043EB5             0024*  			; XDEF	PUTCSR
043EB5             0025*  			; XDEF 	GETCSR
043EB5             0026*  			; XDEF	OSRDCH
043EB5             0027*  			; XDEF	PROMPT
043EB5             0028*  			; XDEF	OSKEY
043EB5             0029*  			; XDEF	TRAP
043EB5             0030*  			; XDEF	LTRAP
043EB5             0031*  			; XDEF	OSINIT
043EB5             0032*  			; XDEF	OSCLI
043EB5             0033*  			; XDEF	OSBPUT
043EB5             0034*  			; XDEF	OSBGET
043EB5             0035*  			; XDEF	OSSTAT
043EB5             0036*  			; XDEF	OSSHUT
043EB5             0037*  			; XDEF	OSOPEN
043EB5             0038*  			; XDEF	OSCALL
043EB5             0039*  			; XDEF	GETPTR
043EB5             0040*  			; XDEF	PUTPTR
043EB5             0041*  			; XDEF	GETEXT
043EB5             0042*  			; XDEF	GETIMS
043EB5             0043*  			; XDEF	RESET
043EB5             0044*  			; XDEF	OSLOAD
043EB5             0045*  			; XDEF	OSSAVE
043EB5             0046*  			; XDEF	EXPR_W2
043EB5             0047*  			; XDEF	STAR_VERSION
043EB5             0048*  
043EB5             0049*  			; XREF	_end			; In init.asm
043EB5             0050*  
043EB5             0051*  			; XREF	ASC_TO_NUMBER
043EB5             0052*  			; XREF	RAM_START
043EB5             0053*  			; XREF	RAM_END
043EB5             0054*  			; XREF	FLAGS
043EB5             0055*  			; XREF	ESCAPE
043EB5             0056*  			; XREF	USER
043EB5             0057*  			; XREF	RAM_Top
043EB5             0058*  			; XREF	EXTERR
043EB5             0059*  			; XREF	COUNT0
043EB5             0060*  			; XREF	EXPRI
043EB5             0061*  			; XREF	COMMA
043EB5             0062*  			; XREF	XEQ
043EB5             0063*  			; XREF	NXT
043EB5             0064*  			; XREF	NULLTOCR
043EB5             0065*  			; XREF	CRLF
043EB5             0066*  			; XREF	CSTR_FNAME
043EB5             0067*  			; XREF	CSTR_LINE
043EB5             0068*  			; XREF	CSTR_FINDCH
043EB5             0069*  			; XREF	CSTR_ENDSWITH
043EB5             0070*  			; XREF	CSTR_CAT
043EB5             0071*  			; XREF	FINDL
043EB5             0072*  			; XREF	OUT_
043EB5             0073*  			; XREF	ERROR_
043EB5             0074*  			; XREF	ONEDIT
043EB5             0075*  			; XREF	TELL
043EB5             0076*  			; XREF	OSWRCHPT
043EB5             0077*  			; XREF	OSWRCHCH
043EB5             0078*  			; XREF	OSWRCHFH
043EB5             0079*  			; XREF	LISTON
043EB5             0080*  			; XREF	LISTIT
043EB5             0081*  			; XREF	PAGE_
043EB5             0082*  			; XREF	ONEDIT1
043EB5             0083*  			; XREF	CLEAN
043EB5             0084*  			; XREF	NEWIT
043EB5             0085*  			; XREF	BAD
043EB5             0086*  			; XREF	VBLANK_INIT
043EB5             0087*  			; XREF	VBLANK_STOP
043EB5             0088*  			; XREF	KEYDOWN
043EB5             0089*  			; XREF	KEYASCII
043EB5             0090*  			; XREF	WIDTH
043EB5             0091*  			; XREF	ASSEM
043EB5             0092*  
043EB5             0093*  ; OSLINE: Invoke the line editor
043EB5             0094*  ;
043EB5 1E 01       0095*  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043EB7             0096*  
043EB7             0097*  ; Entry point to line editor that does not clear the buffer
043EB7             0098*  ;
043EB7 FD E5       0099*  OSLINE1:		PUSH	IY
043EB9 E5          0100*  			PUSH	HL			; Buffer address
043EBA 01 00 01 00 0101*  			LD	BC, 256			; Buffer length
043EBE             0102*  			MOSCALL	mos_editline		; Call the MOS line editor
043EBE 3E 09       0001*M 			LD	A, function
043EC0 49 CF       0002*M 			RST.LIS	08h
043EC2 E1          0103*  			POP	HL			; Pop the address
043EC3 FD E1       0104*  			POP	IY
043EC5 F5          0105*  			PUSH	AF			; Stack the return value (key pressed)
043EC6 CD 57 3E 04 0106*  			CALL	NULLTOCR		; Turn the 0 character to a CR
043ECA CD 9D 39 04 0107*  			CALL	CRLF			; Display CRLF
043ECE F1          0108*  			POP	AF
043ECF FE 1B       0109*  			CP	1Bh 			; Check if ESC terminated the input
043ED1 CA CD 3F 04 0110*  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
043ED5 3A 42 4D 04 0111*  			LD	A, (FLAGS)		; Otherwise
043ED9 CB BF       0112*  			RES	7, A 			; Clear the escape flag
043EDB 32 42 4D 04 0113*  			LD	(FLAGS), A
043EDF CD A4 41 04 0114*  			CALL	WAIT_VBLANK 		; Wait a frame
043EE3 AF          0115*   			XOR	A			; Return A = 0
043EE4 32 47 4D 04 0116*  			LD	(KEYDOWN), A
043EE8 32 48 4D 04 0117*  			LD	(KEYASCII), A
043EEC C9          0118*  			RET
043EED             0119*  
043EED             0120*  ; PUTIME: set current time to DE:HL, in centiseconds.
043EED             0121*  ;
043EED DD E5       0122*  PUTIME:			PUSH 	IX
043EEF             0123*  			MOSCALL	mos_sysvars
043EEF 3E 08       0001*M 			LD	A, function
043EF1 49 CF       0002*M 			RST.LIS	08h
043EF3 DD 75 00    0124*  			LD	(IX + sysvar_time + 0), L
043EF6 DD 74 01    0125*  			LD	(IX + sysvar_time + 1), H
043EF9 DD 73 02    0126*  			LD	(IX + sysvar_time + 2), E
043EFC DD 72 03    0127*  			LD	(IX + sysvar_time + 3), D
043EFF DD E1       0128*  			POP	IX
043F01 C9          0129*  			RET
043F02             0130*  
043F02             0131*  ; GETIME: return current time in DE:HL, in centiseconds
043F02             0132*  ;
043F02 DD E5       0133*  GETIME:			PUSH 	IX
043F04             0134*  			MOSCALL	mos_sysvars
043F04 3E 08       0001*M 			LD	A, function
043F06 49 CF       0002*M 			RST.LIS	08h
043F08 DD 6E 00    0135*  			LD	L, (IX + sysvar_time + 0)
043F0B DD 66 01    0136*  			LD	H, (IX + sysvar_time + 1)
043F0E DD 5E 02    0137*  			LD	E, (IX + sysvar_time + 2)
043F11 DD 56 03    0138*  			LD	D, (IX + sysvar_time + 3)
043F14 DD E1       0139*  			POP	IX
043F16 C9          0140*  			RET
043F17             0141*  
043F17             0142*  ; PUTCSR: move to cursor to x=DE, y=HL
043F17             0143*  ;
043F17 3E 1F       0144*  PUTCSR:			LD	A, 1Fh			; TAB
043F19 5B D7       0145*  			RST.LIL	10h
043F1B 7B          0146*  			LD	A, E			; X
043F1C 5B D7       0147*  			RST.LIL 10h
043F1E 7D          0148*  			LD	A, L			; Y
043F1F 5B D7       0149*  			RST.LIL 10h
043F21 C9          0150*  			RET
043F22             0151*  
043F22             0152*  ; GETCSR: return cursor position in x=DE, y=HL
043F22             0153*  ;
043F22 DD E5       0154*  GETCSR:			PUSH	IX			; Get the system vars in IX
043F24             0155*  			MOSCALL	mos_sysvars		; Reset the semaphore
043F24 3E 08       0001*M 			LD	A, function
043F26 49 CF       0002*M 			RST.LIS	08h
043F28 DD CB 04 86 0156*  			RES	0, (IX+sysvar_vpd_pflags)
043F2C             0157*  			VDU	23
043F2C 3E 17       0001*M 		LD	A, val
043F2E CD 56 3F 04 0002*M 		CALL	OSWRCH
043F32             0158*  			VDU	0
043F32 3E 00       0001*M 		LD	A, val
043F34 CD 56 3F 04 0002*M 		CALL	OSWRCH
043F38             0159*  			VDU	vdp_cursor
043F38 3E 82       0001*M 		LD	A, val
043F3A CD 56 3F 04 0002*M 		CALL	OSWRCH
043F3E DD CB 04 46 0160*  @@:			BIT	0, (IX+sysvar_vpd_pflags)
043F42 28 FA       0161*  			JR	Z, @B			; Wait for the result
043F44 16 00       0162*  			LD 	D, 0
043F46 62          0163*  			LD	H, D
043F47 DD 5E 07    0164*  			LD	E, (IX + sysvar_cursorX)
043F4A DD 6E 08    0165*  			LD	L, (IX + sysvar_cursorY)
043F4D DD E1       0166*  			POP	IX
043F4F C9          0167*  			RET
043F50             0168*  
043F50             0169*  ; PROMPT: output the input prompt
043F50             0170*  ;
043F50 3E 3E       0171*  PROMPT: 		LD	A,'>'
043F52 C3 56 3F 04 0172*  			JP	OSWRCH
043F56             0173*  
043F56             0174*  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
043F56             0175*  ; A: Character to write
043F56             0176*  ;
043F56 E5          0177*  OSWRCH:			PUSH	HL
043F57 21 40 4D 04 0178*  			LD	HL, LISTON		; Fetch the LISTON variable
043F5B CB 5E       0179*  			BIT	3, (HL)			; Check whether we are in *EDIT mode
043F5D 20 0B       0180*  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
043F5F             0181*  ;
043F5F 2A 45 4D 04 0182*  			LD	HL, (OSWRCHCH)		; L: Channel #
043F63 2D          0183*  			DEC	L			; If it is 1
043F64 28 10       0184*  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
043F66             0185*  ;
043F66 E1          0186*  			POP	HL			; Otherwise
043F67 5B D7       0187*  			RST.LIL	10h			; Output the character to MOS
043F69 C9          0188*  			RET
043F6A             0189*  ;
043F6A 2A 43 4D 04 0190*  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
043F6E 77          0191*  			LD	(HL), A			; Echo the character into the buffer
043F6F 23          0192*  			INC	HL			; Increment pointer
043F70 22 43 4D 04 0193*  			LD	(OSWRCHPT), HL		; Write pointer back
043F74 E1          0194*  			POP	HL
043F75 C9          0195*  			RET
043F76             0196*  ;
043F76 D5          0197*  OSWRCH_FILE:		PUSH	DE
043F77 5C          0198*  			LD	E, H			; Filehandle to E
043F78 CD A2 43 04 0199*  			CALL	OSBPUT			; Write the byte out
043F7C D1          0200*  			POP	DE
043F7D E1          0201*  			POP	HL
043F7E C9          0202*  			RET
043F7F             0203*  
043F7F             0204*  ; OSRDCH: Read a character in from the ESP32 keyboard handler
043F7F             0205*  ; This is only called in GETS (eval.asm)
043F7F             0206*  ;
043F7F             0207*  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
043F7F 3E 00       0001*M 			LD	A, function
043F81 49 CF       0002*M 			RST.LIS	08h
043F83 FE 1B       0208*  			CP	1Bh
043F85 28 46       0209*  			JR	Z, LTRAP1
043F87 C9          0210*  			RET
043F88             0211*  
043F88             0212*  
043F88             0213*  ;OSKEY - Read key with time-limit, test for ESCape.
043F88             0214*  ;Main function is carried out in user patch.
043F88             0215*  ;   Inputs: HL = time limit (centiseconds)
043F88             0216*  ;  Outputs: Carry reset if time-out
043F88             0217*  ;           If carry set A = character
043F88             0218*  ; Destroys: A,H,L,F
043F88             0219*  ;
043F88 CD B9 3F 04 0220*  OSKEY:			CALL	READKEY			; Read the keyboard
043F8C 28 0A       0221*  			JR	Z, @F 			; Skip if we have a key
043F8E 7C          0222*  			LD	A, H 			; Check loop counter
043F8F B5          0223*  			OR 	L
043F90 C8          0224*  			RET 	Z 			; Return, we've not got a key at this point
043F91 CD A4 41 04 0225*  			CALL	WAIT_VBLANK 		; Wait a frame
043F95 2B          0226*  			DEC 	HL			; Decrement
043F96 18 F0       0227*  			JR	OSKEY 			; And loop
043F98             0228*  ;
043F98 21 47 4D 04 0229*  @@:			LD	HL, KEYDOWN		; We have a key, so
043F9C 36 00       0230*  			LD	(HL), 0			; clear the keydown flag
043F9E FE 1B       0231*  			CP	1BH			; If we are not pressing ESC,
043FA0 37          0232*  			SCF 				; then flag we've got a character
043FA1 C0          0233*  			RET	NZ
043FA2             0234*  ;
043FA2             0235*  ; ESCSET
043FA2             0236*  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
043FA2             0237*  ;
043FA2 E5          0238*  ESCSET: 		PUSH    HL
043FA3 21 42 4D 04 0239*          		LD      HL,FLAGS		; Pointer to FLAGS
043FA7 CB 76       0240*          		BIT     6,(HL)			; If bit 6 is set, then
043FA9 20 02       0241*          		JR      NZ,ESCDIS		; escape is disabled, so skip
043FAB CB FE       0242*          		SET     7,(HL)			; Set bit 7, the escape flag
043FAD E1          0243*  ESCDIS: 		POP     HL
043FAE C9          0244*          		RET
043FAF             0245*  ;
043FAF             0246*  ; ESCTEST
043FAF             0247*  ; Test for ESC key
043FAF             0248*  ;
043FAF CD B9 3F 04 0249*  ESCTEST:		CALL	READKEY			; Read the keyboard
043FB3 C0          0250*  			RET	NZ			; Skip if no key is pressed
043FB4 FE 1B       0251*  			CP	1BH			; If ESC pressed then
043FB6 28 EA       0252*  			JR	Z,ESCSET		; jump to the escape set routine
043FB8 C9          0253*  			RET
043FB9             0254*  
043FB9             0255*  ; Read the keyboard
043FB9             0256*  ; Returns:
043FB9             0257*  ; - A: ASCII of the pressed key
043FB9             0258*  ; - F: Z if the key is pressed, otherwise NZ
043FB9             0259*  ;
043FB9 3A 47 4D 04 0260*  READKEY:		LD	A, (KEYDOWN)		; Get key down
043FBD 3D          0261*  			DEC	A 			; Set Z flag if keydown is 1
043FBE 3A 48 4D 04 0262*  			LD	A, (KEYASCII)		; Get key ASCII value
043FC2 C9          0263*  			RET
043FC3             0264*  ;
043FC3             0265*  ; TRAP
043FC3             0266*  ; This is called whenever BASIC needs to check for ESC
043FC3             0267*  ;
043FC3 CD AF 3F 04 0268*  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043FC7             0269*  ;
043FC7 3A 42 4D 04 0270*  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043FCB B7          0271*  			OR	A			; This checks for bit 7; if it is not set then the result will
043FCC F0          0272*  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043FCD 21 42 4D 04 0273*  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
043FD1 CB BE       0274*  			RES	7,(HL)			; Clear the escape pressed flag and
043FD3 C3 A3 0C 04 0275*  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043FD7             0276*  
043FD7             0277*  ;OSINIT - Initialise RAM mapping etc.
043FD7             0278*  ;If BASIC is entered by BBCBASIC FILENAME then file
043FD7             0279*  ;FILENAME.BBC is automatically CHAINed.
043FD7             0280*  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043FD7             0281*  ;            HL = initial value of PAGE (user program)
043FD7             0282*  ;            Z-flag reset indicates AUTO-RUN.
043FD7             0283*  ;  Destroys: A,D,E,H,L,F
043FD7             0284*  ;
043FD7 CD 3C 49 04 0285*  OSINIT:			CALL	VBLANK_INIT
043FDB AF          0286*  			XOR	A
043FDC 21 00 4E 04 0287*  			LD 	HL, USER
043FE0 11 00 00 0B 0288*  			LD	DE, RAM_Top
043FE4 5F          0289*  			LD	E, A			; Page boundary
043FE5 C9          0290*  			RET
043FE6             0291*  
043FE6             0292*  ;
043FE6             0293*  ;OSCLI - Process a MOS command
043FE6             0294*  ;
043FE6 CD 5A 40 04 0295*  OSCLI: 			CALL    SKIPSP
043FEA FE 0D       0296*  			CP      CR
043FEC C8          0297*  			RET     Z
043FED FE 7C       0298*  			CP      '|'
043FEF C8          0299*  			RET     Z
043FF0 EB          0300*  			EX      DE,HL
043FF1 21 69 40 04 0301*  			LD      HL,COMDS
043FF5 1A          0302*  OSCLI0:			LD      A,(DE)
043FF6 CD 61 40 04 0303*  			CALL    UPPRC
043FFA BE          0304*  			CP      (HL)
043FFB 28 0B       0305*  			JR      Z,OSCLI2
043FFD 38 30       0306*  			JR      C,OSCLI6
043FFF CB 7E       0307*  OSCLI1:			BIT     7,(HL)
044001 23          0308*  			INC     HL
044002 28 FB       0309*  			JR      Z,OSCLI1
044004 23          0310*  			INC     HL
044005 23          0311*  			INC     HL
044006 18 ED       0312*  			JR      OSCLI0
044008             0313*  ;
044008 D5          0314*  OSCLI2:			PUSH    DE
044009 13          0315*  OSCLI3:			INC     DE
04400A 23          0316*  			INC     HL
04400B 1A          0317*  			LD      A,(DE)
04400C CD 61 40 04 0318*  			CALL    UPPRC
044010 FE 2E       0319*  			CP      '.'			; ABBREVIATED?
044012 28 0A       0320*  			JR      Z,OSCLI4
044014 AE          0321*  			XOR     (HL)
044015 28 F2       0322*  			JR      Z,OSCLI3
044017 FE 80       0323*  			CP      80H
044019 28 03       0324*  			JR      Z,OSCLI4
04401B D1          0325*  			POP     DE
04401C 18 E1       0326*  			JR      OSCLI1
04401E             0327*  ;
04401E F1          0328*  OSCLI4:			POP     AF
04401F 13          0329*  		        INC     DE
044020 CB 7E       0330*  OSCLI5:			BIT     7,(HL)
044022 23          0331*  			INC     HL
044023 28 FB       0332*  			JR      Z,OSCLI5
044025 7E          0333*  			LD      A,(HL)
044026 23          0334*  			INC     HL
044027 66          0335*  			LD      H,(HL)
044028 6F          0336*  			LD      L,A
044029 E5          0337*  			PUSH    HL
04402A EB          0338*  			EX      DE,HL
04402B C3 5A 40 04 0339*  			JP      SKIPSP
04402F             0340*  ;
04402F EB          0341*  OSCLI6:			EX	DE, HL			; HL: Buffer for command
044030 11 00 4A 04 0342*  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
044034 D5          0343*  			PUSH	DE			; Store buffer address
044035 CD 81 3E 04 0344*  			CALL	CSTR_LINE		; Fetch the line
044039 E1          0345*  			POP	HL			; HL: Pointer to command string in ACCS
04403A FD E5       0346*  			PUSH	IY
04403C             0347*  			MOSCALL	mos_oscli		; Returns OSCLI error in A
04403C 3E 10       0001*M 			LD	A, function
04403E 49 CF       0002*M 			RST.LIS	08h
044040 FD E1       0348*  			POP	IY
044042 B7          0349*  			OR	A			; 0 means MOS returned OK
044043 C8          0350*  			RET	Z			; So don't do anything
044044 C3 7E 42 04 0351*  			JP 	OSERROR			; Otherwise it's a MOS error
044048             0352*  
044048 3E FE       0353*  HUH:    		LD      A,254			; Bad command error
04404A CD CD 37 04 0354*          		CALL    EXTERR
04404E 42 61 64 20 0355*          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044059 00          0356*          		DEFB    0
04405A             0357*  
04405A 7E          0358*  SKIPSP:			LD      A,(HL)
04405B FE 20       0359*          		CP      ' '
04405D C0          0360*          		RET     NZ
04405E 23          0361*          		INC     HL
04405F 18 F9       0362*          		JR      SKIPSP
044061             0363*  
044061 E6 7F       0364*  UPPRC:  		AND     7FH
044063 FE 60       0365*  			CP      '`'
044065 D8          0366*  			RET     C
044066 E6 5F       0367*  			AND     5FH			; CONVERT TO UPPER CASE
044068 C9          0368*  			RET
044069             0369*  
044069             0370*  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044069             0371*  ; These must be in alphabetical order
044069             0372*  ;
044069 41 53 4D    0373*  COMDS:  		DB	"AS","M"+80h		; ASM
04406C 87 40       0374*  			DW	STAR_ASM
04406E 42 59 45    0375*  			DB	"BY","E"+80h		; BYE
044071 93 40       0376*  			DW	STAR_BYE
044073 45 44 49 54 0377*  			DB	"EDI","T"+80h		; EDIT
044077 C8 40       0378*  			DW	STAR_EDIT
044079 46 58       0379*  			DB	"F","X"+80h		; FX
04407B 08 41       0380*  			DW	STAR_FX
04407D 56 45 52 53 0381*  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
044084 9F 40       0382*  			DW	STAR_VERSION
044086 FF          0383*  			DB	FFh
044087             0384*  
044087             0385*  ; *ASM string
044087             0386*  ;
044087 FD E5       0387*  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044089 E5          0388*  			PUSH	HL			; HL = IY
04408A FD E1       0389*  			POP	IY
04408C CD CD 18 04 0390*  			CALL	ASSEM			; Invoke the assembler
044090 FD E1       0391*  			POP	IY
044092 C9          0392*  			RET
044093             0393*  
044093             0394*  ; *BYE
044093             0395*  ;
044093 CD 50 49 04 0396*  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044097 21 00 00 00 0397*  			LD	HL, 0			; The return value
04409B C3 68 00 04 0398*  			JP	_end 			; Jump back to the end routine in init.asm
04409F             0399*  
04409F             0400*  ; *VERSION
04409F             0401*  ;
04409F CD E6 3D 04 0402*  STAR_VERSION:		CALL    TELL			; Output the welcome message
0440A3 42 42 43 20 0403*  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0440C7 C9          0404*  			RET
0440C8             0405*  
0440C8             0406*  ; *EDIT linenum
0440C8             0407*  ;
0440C8 CD ED 3D 04 0408*  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0440CC EB          0409*  			EX	DE, HL			; HL: Line number
0440CD CD E5 39 04 0410*  			CALL	FINDL			; HL: Address in RAM of tokenised line
0440D1 3E 29       0411*  			LD	A, 41			; F:NZ If the line is not found
0440D3 C2 B6 37 04 0412*  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0440D7             0413*  ;
0440D7             0414*  ; Use LISTIT to output the line to the ACCS buffer
0440D7             0415*  ;
0440D7 23          0416*  			INC	HL			; Skip the length byte
0440D8 5E          0417*  			LD	E, (HL)			; Fetch the line number
0440D9 23          0418*  			INC	HL
0440DA 56          0419*  			LD	D, (HL)
0440DB 23          0420*  			INC	HL
0440DC DD 21 00 4A 0421*  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
0440E1 DD 22 43 4D 0422*  			LD	(OSWRCHPT), IX
       04          
0440E6 DD 21 40 4D 0423*  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
0440EB DD 7E 00    0424*  			LD	A, (IX)			; Store that variable
0440EE F5          0425*  			PUSH	AF
0440EF DD 36 00 09 0426*  			LD	(IX), 09h		; Set to echo to buffer
0440F3 CD E8 38 04 0427*  			CALL	LISTIT
0440F7 F1          0428*  			POP	AF
0440F8 DD 77 00    0429*  			LD	(IX), A			; Restore the original LISTON variable
0440FB 21 00 4A 04 0430*  			LD	HL, ACCS		; HL: ACCS
0440FF 5D          0431*  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044100 CD B7 3E 04 0432*  			CALL	OSLINE1			; Invoke the editor
044104 C3 26 31 04 0433*  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
044108             0434*  
044108             0435*  ; OSCLI FX n
044108             0436*  ;
044108 CD ED 3D 04 0437*  STAR_FX:		CALL	ASC_TO_NUMBER
04410C 4B          0438*  			LD	C, E			; C: Save FX #
04410D CD ED 3D 04 0439*  			CALL	ASC_TO_NUMBER
044111 7A          0440*  			LD	A, D  			; Is first parameter > 255?
044112 B7          0441*  			OR 	A
044113 28 03       0442*  			JR	Z, STAR_FX1		; Yes, so skip next bit
044115 EB          0443*  			EX	DE, HL 			; Parameter is 16-bit
044116 18 07       0444*  			JR	STAR_FX2
044118             0445*  ;
044118 43          0446*  STAR_FX1:		LD	B, E 			; B: Save First parameter
044119 CD ED 3D 04 0447*  			CALL	ASC_TO_NUMBER		; Fetch second parameter
04411D 68          0448*  			LD	L, B 			; L: First parameter
04411E 63          0449*  			LD	H, E 			; H: Second parameter
04411F             0450*  ;
04411F 79          0451*  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
044120             0452*  ;
044120             0453*  ; OSBYTE
044120             0454*  ;  A: FX #
044120             0455*  ;  L: First parameter
044120             0456*  ;  H: Second parameter
044120             0457*  ;
044120 FE 0B       0458*  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
044122 28 18       0459*  			JR	Z, OSBYTE_0B
044124 FE 0C       0460*  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044126 28 43       0461*  			JR	Z, OSBYTE_0C
044128 FE 13       0462*  			CP	13H			; *FX 19: Wait for vblank
04412A 28 6E       0463*  			JR	Z, OSBYTE_13
04412C FE 76       0464*  			CP	76H			; *FX 118, n: Set keyboard LED
04412E CA B5 41 04 0465*  			JP	Z, OSBYTE_76
044132 FE A0       0466*  			CP	A0H
044134 CA E5 41 04 0467*  			JP	Z, OSBYTE_A0
044138 C3 48 40 04 0468*  			JP	HUH			; Anything else trips an error
04413C             0469*  
04413C             0470*  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
04413C             0471*  ; Parameters:
04413C             0472*  ; - HL: Repeat delay
04413C             0473*  ;
04413C             0474*  OSBYTE_0B:		VDU	23
04413C 3E 17       0001*M 		LD	A, val
04413E CD 56 3F 04 0002*M 		CALL	OSWRCH
044142             0475*  			VDU	0
044142 3E 00       0001*M 		LD	A, val
044144 CD 56 3F 04 0002*M 		CALL	OSWRCH
044148             0476*  			VDU	vdp_keystate
044148 3E 88       0001*M 		LD	A, val
04414A CD 56 3F 04 0002*M 		CALL	OSWRCH
04414E             0477*  			VDU	L
04414E 7D          0001*M 		LD	A, val
04414F CD 56 3F 04 0002*M 		CALL	OSWRCH
044153             0478*  			VDU	H
044153 7C          0001*M 		LD	A, val
044154 CD 56 3F 04 0002*M 		CALL	OSWRCH
044158             0479*  			VDU	0
044158 3E 00       0001*M 		LD	A, val
04415A CD 56 3F 04 0002*M 		CALL	OSWRCH
04415E             0480*  			VDU 	0
04415E 3E 00       0001*M 		LD	A, val
044160 CD 56 3F 04 0002*M 		CALL	OSWRCH
044164             0481*  			VDU	255
044164 3E FF       0001*M 		LD	A, val
044166 CD 56 3F 04 0002*M 		CALL	OSWRCH
04416A C9          0482*  			RET
04416B             0483*  
04416B             0484*  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
04416B             0485*  ; Parameters:
04416B             0486*  ; - HL: Repeat rate
04416B             0487*  ;
04416B             0488*  OSBYTE_0C:		VDU	23
04416B 3E 17       0001*M 		LD	A, val
04416D CD 56 3F 04 0002*M 		CALL	OSWRCH
044171             0489*  			VDU	0
044171 3E 00       0001*M 		LD	A, val
044173 CD 56 3F 04 0002*M 		CALL	OSWRCH
044177             0490*  			VDU	vdp_keystate
044177 3E 88       0001*M 		LD	A, val
044179 CD 56 3F 04 0002*M 		CALL	OSWRCH
04417D             0491*  			VDU	0
04417D 3E 00       0001*M 		LD	A, val
04417F CD 56 3F 04 0002*M 		CALL	OSWRCH
044183             0492*  			VDU 	0
044183 3E 00       0001*M 		LD	A, val
044185 CD 56 3F 04 0002*M 		CALL	OSWRCH
044189             0493*  			VDU	L
044189 7D          0001*M 		LD	A, val
04418A CD 56 3F 04 0002*M 		CALL	OSWRCH
04418E             0494*  			VDU	H
04418E 7C          0001*M 		LD	A, val
04418F CD 56 3F 04 0002*M 		CALL	OSWRCH
044193             0495*  			VDU	255
044193 3E FF       0001*M 		LD	A, val
044195 CD 56 3F 04 0002*M 		CALL	OSWRCH
044199 C9          0496*  			RET
04419A             0497*  
04419A             0498*  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
04419A             0499*  ;
04419A CD A4 41 04 0500*  OSBYTE_13:		CALL	WAIT_VBLANK
04419E 2E 00       0501*  			LD	L, 0			; Returns 0
0441A0 C3 84 05 04 0502*  			JP	COUNT0
0441A4             0503*  ;
0441A4 DD E5       0504*  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0441A6             0505*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441A6 3E 08       0001*M 			LD	A, function
0441A8 49 CF       0002*M 			RST.LIS	08h
0441AA DD 7E 00    0506*  			LD	A, (IX + sysvar_time + 0)
0441AD DD BE 00    0507*  @@:			CP 	A, (IX + sysvar_time + 0)
0441B0 28 FB       0508*  			JR	Z, @B
0441B2 DD E1       0509*  			POP	IX
0441B4 C9          0510*  			RET
0441B5             0511*  
0441B5             0512*  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0441B5             0513*  ; Parameters:
0441B5             0514*  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0441B5             0515*  ;
0441B5             0516*  OSBYTE_76:		VDU	23
0441B5 3E 17       0001*M 		LD	A, val
0441B7 CD 56 3F 04 0002*M 		CALL	OSWRCH
0441BB             0517*  			VDU	0
0441BB 3E 00       0001*M 		LD	A, val
0441BD CD 56 3F 04 0002*M 		CALL	OSWRCH
0441C1             0518*  			VDU	vdp_keystate
0441C1 3E 88       0001*M 		LD	A, val
0441C3 CD 56 3F 04 0002*M 		CALL	OSWRCH
0441C7             0519*  			VDU	0
0441C7 3E 00       0001*M 		LD	A, val
0441C9 CD 56 3F 04 0002*M 		CALL	OSWRCH
0441CD             0520*  			VDU 	0
0441CD 3E 00       0001*M 		LD	A, val
0441CF CD 56 3F 04 0002*M 		CALL	OSWRCH
0441D3             0521*  			VDU	0
0441D3 3E 00       0001*M 		LD	A, val
0441D5 CD 56 3F 04 0002*M 		CALL	OSWRCH
0441D9             0522*  			VDU	0
0441D9 3E 00       0001*M 		LD	A, val
0441DB CD 56 3F 04 0002*M 		CALL	OSWRCH
0441DF             0523*  			VDU	L
0441DF 7D          0001*M 		LD	A, val
0441E0 CD 56 3F 04 0002*M 		CALL	OSWRCH
0441E4 C9          0524*  			RET
0441E5             0525*  
0441E5             0526*  ; OSBYTE 0xA0: Fetch system variable
0441E5             0527*  ; Parameters:
0441E5             0528*  ; - L: The system variable to fetch
0441E5             0529*  ;
0441E5 DD E5       0530*  OSBYTE_A0:		PUSH	IX
0441E7             0531*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0441E7 3E 08       0001*M 			LD	A, function
0441E9 49 CF       0002*M 			RST.LIS	08h
0441EB 01 00 00 00 0532*  			LD	BC, 0
0441EF 4D          0533*  			LD	C, L			; BCU = L
0441F0 DD 09       0534*  			ADD	IX, BC			; Add to IX
0441F2 DD 6E 00    0535*  			LD	L, (IX + 0)		; Fetch the return value
0441F5 DD E1       0536*  			POP	IX
0441F7 C3 84 05 04 0537*  			JP 	COUNT0
0441FB             0538*  
0441FB             0539*  ;OSLOAD - Load an area of memory from a file.
0441FB             0540*  ;   Inputs: HL addresses filename (CR terminated)
0441FB             0541*  ;           DE = address at which to load
0441FB             0542*  ;           BC = maximum allowed size (bytes)
0441FB             0543*  ;  Outputs: Carry reset indicates no room for file.
0441FB             0544*  ; Destroys: A,B,C,D,E,H,L,F
0441FB             0545*  ;
0441FB C5          0546*  OSLOAD:			PUSH	BC			; Stack the size
0441FC D5          0547*  			PUSH	DE			; Stack the load address
0441FD 11 00 4A 04 0548*  			LD	DE, ACCS		; Buffer address for filename
044201 CD 6F 3E 04 0549*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044205 21 00 4A 04 0550*  			LD	HL, ACCS		; HL: Filename
044209 CD FB 42 04 0551*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04420D CD 0F 43 04 0552*  			CALL	EXT_HANDLER		; Get the default handler
044211 D1          0553*  			POP	DE			; Restore the load address
044212 C1          0554*  			POP	BC			; Restore the size
044213 B7          0555*  			OR	A
044214 28 60       0556*  			JR 	Z, OSLOAD_BBC
044216             0557*  ;
044216             0558*  ; Load the file in as a text file
044216             0559*  ;
044216 AF          0560*  OSLOAD_TXT:		XOR	A			; Set file attributes to read
044217 CD 83 43 04 0561*  			CALL	OSOPEN			; Open the file
04421B 5F          0562*  			LD 	E, A 			; The filehandle
04421C B7          0563*  			OR	A
04421D 3E 04       0564*  			LD	A, 4			; File not found error
04421F 28 5D       0565*  			JR	Z, OSERROR		; Jump to error handler
044221 CD C2 38 04 0566*  			CALL	NEWIT			; Call NEW to clear the program space
044225             0567*  ;
044225 21 00 4A 04 0568*  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044229             0569*  ;
044229             0570*  ; First skip any whitespace (indents) at the beginning of the input
044229             0571*  ;
044229 CD 9A 43 04 0572*  @@:			CALL	OSBGET			; Read the byte into A
04422D 38 1E       0573*  			JR	C, OSLOAD_TXT3		; Is it EOF?
04422F FE 0A       0574*  			CP	LF 			; Is it LF?
044231 28 1A       0575*  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
044233 FE 21       0576*  			CP	21h			; Is it less than or equal to ASCII space?
044235 38 F2       0577*  			JR	C, @B 			; Yes, so keep looping
044237 77          0578*  			LD	(HL), A 		; Store the first character
044238 2C          0579*  			INC	L
044239             0580*  ;
044239             0581*  ; Now read the rest of the line in
044239             0582*  ;
044239 CD 9A 43 04 0583*  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
04423D 38 2B       0584*  			JR	C, OSLOAD_TXT4		; Is it EOF?
04423F FE 20       0585*  			CP	20h			; Skip if not an ASCII character
044241 38 06       0586*  			JR	C, @F
044243 77          0587*  			LD	(HL), A 		; Store in the input buffer
044244 2C          0588*  			INC	L			; Increment the buffer pointer
044245 CA 4E 37 04 0589*  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044249 FE 0A       0590*  @@:			CP	LF			; Check for LF
04424B 20 EC       0591*  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
04424D             0592*  ;
04424D             0593*  ; Finally, handle EOL/EOF
04424D             0594*  ;
04424D 36 0D       0595*  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
04424F 7D          0596*  			LD	A, L			; Check for minimum line length
044250 FE 02       0597*  			CP	2			; If it is 2 characters or less (including CR)
044252 38 0A       0598*  			JR	C, @F			; Then don't bother entering it
044254 D5          0599*  			PUSH	DE			; Preserve the filehandle
044255 CD 32 31 04 0600*  			CALL	ONEDIT1			; Enter the line in memory
044259 DC 95 38 04 0601*  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
04425D D1          0602*  			POP	DE
04425E CD AB 43 04 0603*  @@:			CALL	OSSTAT			; End of file?
044262 20 C1       0604*  			JR	NZ, OSLOAD_TXT1		; No, so loop
044264 CD 92 43 04 0605*  			CALL	OSSHUT			; Close the file
044268 37          0606*  			SCF				; Flag to BASIC that we're good
044269 C9          0607*  			RET
04426A             0608*  ;
04426A             0609*  ; Special case for BASIC programs with no blank line at the end
04426A             0610*  ;
04426A FE 20       0611*  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
04426C 38 06       0612*  			JR	C, @F
04426E 77          0613*  			LD	(HL), A			; Store the character
04426F 2C          0614*  			INC	L
044270 CA 4E 37 04 0615*  			JP	Z, BAD
044274 18 D7       0616*  @@:			JR	OSLOAD_TXT3
044276             0617*  
044276             0618*  ;
044276             0619*  ; Load the file in as a tokenised binary blob
044276             0620*  ;
044276             0621*  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044276 3E 01       0001*M 			LD	A, function
044278 49 CF       0002*M 			RST.LIS	08h
04427A D0          0622*  			RET	NC			; If load returns with carry reset - NO ROOM
04427B B7          0623*  			OR	A			; If there is no error (A=0)
04427C 37          0624*  			SCF				; Need to set carry indicating there was room
04427D C8          0625*  			RET	Z			; Return
04427E             0626*  ;
04427E F5          0627*  OSERROR:		PUSH	AF			; Handle the MOS error
04427F 21 00 4A 04 0628*  			LD	HL, ACCS		; Address of the buffer
044283 01 00 01 00 0629*  			LD	BC, 256			; Length of the buffer
044287 5F          0630*  			LD	E, A			; The error code
044288             0631*  			MOSCALL	mos_getError		; Copy the error message into the buffer
044288 3E 0F       0001*M 			LD	A, function
04428A 49 CF       0002*M 			RST.LIS	08h
04428C F1          0632*  			POP	AF
04428D E5          0633*  			PUSH	HL			; Stack the address of the error (now in ACCS)
04428E C6 7F       0634*  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044290 C3 CD 37 04 0635*  			JP	EXTERR			; Trigger an external error
044294             0636*  
044294             0637*  ;OSSAVE - Save an area of memory to a file.
044294             0638*  ;   Inputs: HL addresses filename (term CR)
044294             0639*  ;           DE = start address of data to save
044294             0640*  ;           BC = length of data to save (bytes)
044294             0641*  ; Destroys: A,B,C,D,E,H,L,F
044294             0642*  ;
044294 C5          0643*  OSSAVE:			PUSH	BC			; Stack the size
044295 D5          0644*  			PUSH	DE			; Stack the save address
044296 11 00 4A 04 0645*  			LD	DE, ACCS		; Buffer address for filename
04429A CD 6F 3E 04 0646*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04429E 21 00 4A 04 0647*  			LD	HL, ACCS		; HL: Filename
0442A2 CD FB 42 04 0648*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0442A6 CD 0F 43 04 0649*  			CALL	EXT_HANDLER		; Get the default handler
0442AA D1          0650*  			POP	DE			; Restore the save address
0442AB C1          0651*  			POP	BC			; Restore the size
0442AC B7          0652*  			OR	A			; Is the extension .BBC
0442AD 28 44       0653*  			JR	Z, OSSAVE_BBC		; Yes, so use that
0442AF             0654*  ;
0442AF             0655*  ; Save the file out as a text file
0442AF             0656*  ;
0442AF 3A 45 4D 04 0657*  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0442B3 F5          0658*  			PUSH	AF
0442B4 AF          0659*  			XOR	A
0442B5 3C          0660*  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0442B6 32 45 4D 04 0661*  			LD	(OSWRCHCH), A
0442BA CD 83 43 04 0662*  			CALL	OSOPEN			; Open the file
0442BE 32 46 4D 04 0663*  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0442C2 DD 21 40 4D 0664*  			LD	IX, LISTON		; Required for LISTIT
       04          
0442C7 2A 14 4D 04 0665*  			LD	HL, (PAGE_)		; Get start of program area
0442CB D9          0666*  			EXX
0442CC 01 00 00 00 0667*  			LD	BC, 0			; Set the initial indent counters
0442D0 D9          0668*  			EXX
0442D1 7E          0669*  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0442D2 B7          0670*  			OR	A
0442D3 28 0F       0671*  			JR	Z, OSSAVE_TXT2
0442D5 23          0672*  			INC	HL			; Skip the length byte
0442D6 11 00 00 00 0673*  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0442DA 5E          0674*  			LD	E, (HL)			; Get the line number
0442DB 23          0675*  			INC	HL
0442DC 56          0676*  			LD	D, (HL)
0442DD 23          0677*  			INC	HL
0442DE CD E8 38 04 0678*  			CALL	LISTIT			; List the line
0442E2 18 ED       0679*  			JR	OSSAVE_TXT1
0442E4 3A 46 4D 04 0680*  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0442E8 5F          0681*  			LD	E, A
0442E9 CD 92 43 04 0682*  			CALL	OSSHUT			; Close it
0442ED F1          0683*  			POP	AF			; Restore the channel
0442EE 32 45 4D 04 0684*  			LD	(OSWRCHCH), A
0442F2 C9          0685*  			RET
0442F3             0686*  ;
0442F3             0687*  ; Save the file out as a tokenised binary blob
0442F3             0688*  ;
0442F3             0689*  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0442F3 3E 02       0001*M 			LD	A, function
0442F5 49 CF       0002*M 			RST.LIS	08h
0442F7 B7          0690*  			OR	A			; If there is no error (A=0)
0442F8 C8          0691*  			RET	Z			; Just return
0442F9 18 83       0692*  			JR	OSERROR			; Trip an error
0442FB             0693*  
0442FB             0694*  ; Check if an extension is specified in the filename
0442FB             0695*  ; Add a default if not specified
0442FB             0696*  ; HL: Filename (CSTR format)
0442FB             0697*  ;
0442FB E5          0698*  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0442FC 0E 2E       0699*  			LD	C, '.'			; Search for dot (marks start of extension)
0442FE CD 8F 3E 04 0700*  			CALL	CSTR_FINDCH
044302 B7          0701*  			OR	A			; Check for end of string marker
044303 20 08       0702*  			JR	NZ, @F			; No, so skip as we have an extension at this point
044305 11 3F 43 04 0703*  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
044309 CD A6 3E 04 0704*  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
04430D E1          0705*  @@:			POP	HL			; Restore the filename pointer
04430E C9          0706*  			RET
04430F             0707*  
04430F             0708*  ; Check if an extension is valid and, if so, provide a pointer to a handler
04430F             0709*  ; HL: Filename (CSTR format)
04430F             0710*  ; Returns:
04430F             0711*  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
04430F             0712*  ;
04430F E5          0713*  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
044310 0E 2E       0714*  			LD	C, '.'			; Find the '.'
044312 CD 8F 3E 04 0715*  			CALL	CSTR_FINDCH
044316 11 3F 43 04 0716*  			LD	DE, EXT_LOOKUP		; The lookup table
04431A             0717*  ;
04431A E5          0718*  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
04431B CD 97 3E 04 0719*  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
04431F E1          0720*  			POP	HL			; Restore the pointer to the extension
044320 28 19       0721*  			JR	Z, EXT_HANDLER_2	; We have a match!
044322             0722*  ;
044322 1A          0723*  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
044323 13          0724*  			INC	DE
044324 B7          0725*  			OR	A
044325 20 FB       0726*  			JR	NZ, @B
044327 13          0727*  			INC	DE			; Skip the file extension # byte
044328             0728*  ;
044328 1A          0729*  			LD	A, (DE)			; Are we at the end of the table?
044329 B7          0730*  			OR	A
04432A 20 EE       0731*  			JR	NZ, EXT_HANDLER_1	; No, so loop
04432C             0732*  ;
04432C 3E CC       0733*  			LD      A,204			; Throw a "Bad name" error
04432E CD CD 37 04 0734*          		CALL    EXTERR
044332 42 61 64 20 0735*          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
04433B             0736*  ;
04433B 13          0737*  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
04433C 1A          0738*  			LD	A, (DE)
04433D E1          0739*  			POP	HL			; Restore the filename pointer
04433E C9          0740*  			RET
04433F             0741*  ;
04433F             0742*  
04433F             0743*  
04433F             0744*  ; Extension lookup table
04433F             0745*  ; CSTR, TYPE
04433F             0746*  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
04433F             0747*  ; 	- 1: Human readable plain text
04433F             0748*  ;
04433F 2E 42 42 43 0749*  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
044345 2E 54 58 54 0750*  			DB	".TXT", 0, 1
       00 01       
04434B 2E 41 53 43 0751*  			DB	".ASC", 0, 1
       00 01       
044351 2E 42 41 53 0752*  			DB	".BAS", 0, 1
       00 01       
044357 00          0753*  			DB	0			; End of table
044358             0754*  
044358             0755*  ;OSCALL - Intercept page &FF calls and provide an alternative address
044358             0756*  ;
044358             0757*  ;&FFF7:	OSCLI	Execute *command.
044358             0758*  ;&FFF4:	OSBYTE	Various byte-wide functions.
044358             0759*  ;&FFF1:	OSWORD	Various control block functions.
044358             0760*  ;&FFEE:	OSWRCH	Write character to output stream.
044358             0761*  ;&FFE7:	OSNEWL	Write NewLine to output stream.
044358             0762*  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
044358             0763*  ;&FFE0:	OSRDCH	Wait for character from input stream.
044358             0764*  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
044358             0765*  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
044358             0766*  ;&FFD7:	OSBGET	Read a byte from an a channel.
044358             0767*  ;&FFD4:	OSBPUT	Write a byte to a channel.
044358             0768*  ;&FFD1:	OSGBPB	Read and write blocks of data.
044358             0769*  ;&FFCE:	OSFIND	Open or close a file.
044358             0770*  ;
044358 21 6E 43 04 0771*  OSCALL:			LD	HL, OSCALL_TABLE
04435C 7E          0772*  OSCALL_1:		LD	A, (HL)
04435D 23          0773*  			INC	HL
04435E FE FF       0774*  			CP	FFh
044360 C8          0775*  			RET	Z
044361 FD BD       0776*  			CP	A, IYL
044363 28 06       0777*  			JR	Z, OSCALL_2
044365 D0          0778*  			RET	NC
044366 23          0779*  			INC	HL
044367 23          0780*  			INC	HL
044368 23          0781*  			INC	HL
044369 18 F1       0782*  			JR	OSCALL_1
04436B ED 31       0783*  OSCALL_2:		LD	IY,(HL)
04436D C9          0784*  			RET
04436E D4          0785*  OSCALL_TABLE:		DB 	D4h
04436F A2 43 04    0786*  			DW24 	OSBPUT
044372 D7          0787*  			DB 	D7h
044373 9A 43 04    0788*  			DW24 	OSBGET
044376 EE          0789*  			DB 	EEh
044377 56 3F 04    0790*  			DW24 	OSWRCH
04437A F4          0791*  			DB	F4h
04437B 20 41 04    0792*  			DW24 	OSBYTE
04437E F7          0793*  			DB	F7h
04437F E6 3F 04    0794*  			DW24	OSCLI
044382 FF          0795*  			DB	FFh
044383             0796*  
044383             0797*  ; OSOPEN
044383             0798*  ; HL: Pointer to path
044383             0799*  ;  F: C Z
044383             0800*  ;     x x OPENIN
044383             0801*  ; 	  OPENOUT
044383             0802*  ;     x	  OPENUP
044383             0803*  ; Returns:
044383             0804*  ;  A: Filehandle, 0 if cannot open
044383             0805*  ;
044383 0E 01       0806*  OSOPEN:			LD	C, fa_read
044385 28 06       0807*  			JR	Z, @F
044387 0E 32       0808*  			LD	C, fa_write | fa_open_append
044389 38 02       0809*  			JR	C, @F
04438B 0E 0A       0810*  			LD	C, fa_write | fa_create_always
04438D             0811*  @@:			MOSCALL	mos_fopen
04438D 3E 0A       0001*M 			LD	A, function
04438F 49 CF       0002*M 			RST.LIS	08h
044391 C9          0812*  			RET
044392             0813*  
044392             0814*  ;OSSHUT - Close disk file(s).
044392             0815*  ; E = file channel
044392             0816*  ;  If E=0 all files are closed (except SPOOL)
044392             0817*  ; Destroys: A,B,C,D,E,H,L,F
044392             0818*  ;
044392 C5          0819*  OSSHUT:			PUSH	BC
044393 4B          0820*  			LD	C, E
044394             0821*  			MOSCALL	mos_fclose
044394 3E 0B       0001*M 			LD	A, function
044396 49 CF       0002*M 			RST.LIS	08h
044398 C1          0822*  			POP	BC
044399 C9          0823*  			RET
04439A             0824*  
04439A             0825*  ; OSBGET - Read a byte from a random disk file.
04439A             0826*  ;  E = file channel
04439A             0827*  ; Returns
04439A             0828*  ;  A = byte read
04439A             0829*  ;  Carry set if LAST BYTE of file
04439A             0830*  ; Destroys: A,B,C,F
04439A             0831*  ;
04439A C5          0832*  OSBGET:			PUSH	BC
04439B 4B          0833*  			LD	C, E
04439C             0834*  			MOSCALL	mos_fgetc
04439C 3E 0C       0001*M 			LD	A, function
04439E 49 CF       0002*M 			RST.LIS	08h
0443A0 C1          0835*  			POP	BC
0443A1 C9          0836*  			RET
0443A2             0837*  
0443A2             0838*  ; OSBPUT - Write a byte to a random disk file.
0443A2             0839*  ;  E = file channel
0443A2             0840*  ;  A = byte to write
0443A2             0841*  ; Destroys: A,B,C,F
0443A2             0842*  ;
0443A2 C5          0843*  OSBPUT:			PUSH	BC
0443A3 4B          0844*  			LD	C, E
0443A4 47          0845*  			LD	B, A
0443A5             0846*  			MOSCALL	mos_fputc
0443A5 3E 0D       0001*M 			LD	A, function
0443A7 49 CF       0002*M 			RST.LIS	08h
0443A9 C1          0847*  			POP	BC
0443AA C9          0848*  			RET
0443AB             0849*  
0443AB             0850*  ; OSSTAT - Read file status
0443AB             0851*  ;  E = file channel
0443AB             0852*  ; Returns
0443AB             0853*  ;  F: Z flag set - EOF
0443AB             0854*  ;  A: If Z then A = 0
0443AB             0855*  ; Destroys: A,D,E,H,L,F
0443AB             0856*  ;
0443AB C5          0857*  OSSTAT:			PUSH	BC
0443AC 4B          0858*  			LD	C, E
0443AD             0859*  			MOSCALL	mos_feof
0443AD 3E 0E       0001*M 			LD	A, function
0443AF 49 CF       0002*M 			RST.LIS	08h
0443B1 C1          0860*  			POP	BC
0443B2 FE 01       0861*  			CP	1
0443B4 C9          0862*  			RET
0443B5             0863*  
0443B5             0864*  ; GETPTR - Return file pointer.
0443B5             0865*  ;    E = file channel
0443B5             0866*  ; Returns:
0443B5             0867*  ; DEHL = pointer (0-&7FFFFF)
0443B5             0868*  ; Destroys: A,B,C,D,E,H,L,F
0443B5             0869*  ;
0443B5 FD E5       0870*  GETPTR:			PUSH		IY
0443B7 4B          0871*  			LD		C, E
0443B8             0872*  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0443B8 3E 19       0001*M 			LD	A, function
0443BA 49 CF       0002*M 			RST.LIS	08h
0443BC E5          0873*  			PUSH		HL
0443BD FD E1       0874*  			POP		IY		; IYU: Pointer to FIL structure
0443BF FD 6E 11    0875*  			LD		L, (IY + FIL.fptr + 0)
0443C2 FD 66 12    0876*  			LD		H, (IY + FIL.fptr + 1)
0443C5 FD 5E 13    0877*  			LD		E, (IY + FIL.fptr + 2)
0443C8 FD 56 14    0878*  			LD		D, (IY + FIL.fptr + 3)
0443CB FD E1       0879*  			POP		IY
0443CD C9          0880*  			RET
0443CE             0881*  
0443CE             0882*  ; PUTPTR - Update file pointer.
0443CE             0883*  ;    A = file channel
0443CE             0884*  ; DEHL = new pointer (0-&7FFFFF)
0443CE             0885*  ; Destroys: A,B,C,D,E,H,L,F
0443CE             0886*  ;
0443CE FD E5       0887*  PUTPTR:			PUSH		IY
0443D0 4F          0888*  			LD		C, A  		; C: Filehandle
0443D1 E5          0889*  			PUSH		HL
0443D2 21 02 00 00 0890*  			LD		HL, 2
0443D6 39          0891*  			ADD		HL, SP
0443D7 73          0892*  			LD		(HL), E 	; 3rd byte of DWORD set to E
0443D8 E1          0893*  			POP		HL
0443D9 5A          0894*  			LD		E, D  		; 4th byte passed as E
0443DA             0895*  			MOSCALL		mos_flseek
0443DA 3E 1C       0001*M 			LD	A, function
0443DC 49 CF       0002*M 			RST.LIS	08h
0443DE FD E1       0896*  			POP		IY
0443E0 C9          0897*  			RET
0443E1             0898*  
0443E1             0899*  ; GETEXT - Find file size.
0443E1             0900*  ;    E = file channel
0443E1             0901*  ; Returns:
0443E1             0902*  ; DEHL = file size (0-&800000)
0443E1             0903*  ; Destroys: A,B,C,D,E,H,L,F
0443E1             0904*  ;
0443E1 FD E5       0905*  GETEXT:         PUSH    IY
0443E3 4B          0906*                  LD      C, E
0443E4             0907*                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0443E4 3E 19       0001*M 			LD	A, function
0443E6 49 CF       0002*M 			RST.LIS	08h
0443E8 E5          0908*                  PUSH    HL
0443E9 FD E1       0909*                  POP     IY          ; IYU: Pointer to FIL structure
0443EB             0910*                  ; Access the obj.objsize field using the offset values
0443EB FD 6E 0B    0911*                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0443EE FD 66 0C    0912*                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0443F1 FD 5E 0D    0913*                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0443F4 FD 56 0E    0914*                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0443F7             0915*  
0443F7 FD E1       0916*                  POP     IY
0443F9 C9          0917*  			RET
0443FA             0918*  
0443FA             0919*  ; GETIMS - Get time from RTC
0443FA             0920*  ;
0443FA FD E5       0921*  GETIMS:			PUSH	IY
0443FC 21 00 4A 04 0922*  			LD	HL, ACCS 		; Where to store the time string
044400             0923*  			MOSCALL	mos_getrtc
044400 3E 12       0001*M 			LD	A, function
044402 49 CF       0002*M 			RST.LIS	08h
044404 11 00 4A 04 0924*  			LD	DE, ACCS		; DE: pointer to start of string accumulator
044408 5F          0925*  			LD	E, A 			;  E: now points to the end of the string
044409 FD E1       0926*  			POP	IY
04440B C9          0927*  			RET
04440C             0928*  
04440C             0929*  ; Get two word values from EXPR in DE, HL
04440C             0930*  ; IY: Pointer to expression string
04440C             0931*  ; Returns:
04440C             0932*  ; DE: P1
04440C             0933*  ; HL: P2
04440C             0934*  ;
04440C CD 0F 03 04 0935*  EXPR_W2:		CALL	EXPRI			; Get first parameter
044410 D9          0936*  			EXX
044411 E5          0937*  			PUSH	HL
044412 CD 2A 0A 04 0938*  			CALL	COMMA
044416 CD 0F 03 04 0939*  			CALL	EXPRI			; Get second parameter
04441A D9          0940*  			EXX
04441B D1          0941*  			POP	DE
04441C C9          0942*  			RET
04441D             0943*  
04441D             0944*  ; Stuff not implemented yet
04441D             0945*  ;
04441D C9          0946*  RESET:			RET
04441E             0013       include "agon_graphics.asm"
04441E             0001*  ;
04441E             0002*  ; Title:	BBC Basic for AGON - Graphics stuff
04441E             0003*  ; Author:	Dean Belfield
04441E             0004*  ; Created:	12/05/2023
04441E             0005*  ; Last Updated:	07/06/2023
04441E             0006*  ;
04441E             0007*  ; Modinfo:
04441E             0008*  ; 07/06/2023:	Modified to run in ADL mode
04441E             0009*  
04441E             0010*  			; .ASSUME	ADL = 1
04441E             0011*  
04441E             0012*  			; INCLUDE	"equs.inc"
04441E             0013*  			; INCLUDE "macros.inc"
04441E             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
04441E             0015*  
04441E             0016*  			; SEGMENT CODE
04441E             0017*  
04441E             0018*  			; XDEF	CLG
04441E             0019*  			; XDEF	CLRSCN
04441E             0020*  			; XDEF	MODE
04441E             0021*  			; XDEF	COLOUR
04441E             0022*  			; XDEF	GCOL
04441E             0023*  			; XDEF	MOVE
04441E             0024*  			; XDEF	PLOT
04441E             0025*  			; XDEF	DRAW
04441E             0026*  			; XDEF	POINT
04441E             0027*  			; XDEF	GETSCHR
04441E             0028*  
04441E             0029*  			; XREF	OSWRCH
04441E             0030*  			; XREF	ASC_TO_NUMBER
04441E             0031*  			; XREF	EXTERR
04441E             0032*  			; XREF	EXPRI
04441E             0033*  			; XREF	COMMA
04441E             0034*  			; XREF	XEQ
04441E             0035*  			; XREF	NXT
04441E             0036*  			; XREF	BRAKET
04441E             0037*  			; XREF	COUNT0
04441E             0038*  			; XREF	CRTONULL
04441E             0039*  			; XREF	NULLTOCR
04441E             0040*  			; XREF	CRLF
04441E             0041*  			; XREF	EXPR_W2
04441E             0042*  			; XREF	INKEY1
04441E             0043*  
04441E             0044*  ; CLG: clears the graphics area
04441E             0045*  ;
04441E             0046*  CLG:			VDU	10h
04441E 3E 10       0001*M 		LD	A, val
044420 CD 56 3F 04 0002*M 		CALL	OSWRCH
044424 C3 9E 0B 04 0047*  			JP	XEQ
044428             0048*  
044428             0049*  ; CLS: clears the text area
044428             0050*  ;
044428 3E 0C       0051*  CLRSCN:			LD	A, 0Ch
04442A C3 56 3F 04 0052*  			JP	OSWRCH
04442E             0053*  
04442E             0054*  ; MODE n: Set video mode
04442E             0055*  ;
04442E DD E5       0056*  MODE:			PUSH	IX			; Get the system vars in IX
044430             0057*  			MOSCALL	mos_sysvars		; Reset the semaphore
044430 3E 08       0001*M 			LD	A, function
044432 49 CF       0002*M 			RST.LIS	08h
044434 DD CB 04 A6 0058*  			RES	4, (IX+sysvar_vpd_pflags)
044438 CD 0F 03 04 0059*  			CALL    EXPRI
04443C D9          0060*  			EXX
04443D             0061*  			VDU	16H			; Mode change
04443D 3E 16       0001*M 		LD	A, val
04443F CD 56 3F 04 0002*M 		CALL	OSWRCH
044443             0062*  			VDU	L
044443 7D          0001*M 		LD	A, val
044444 CD 56 3F 04 0002*M 		CALL	OSWRCH
044448             0063*  			MOSCALL	mos_sysvars
044448 3E 08       0001*M 			LD	A, function
04444A 49 CF       0002*M 			RST.LIS	08h
04444C DD CB 04 66 0064*  @@:			BIT	4, (IX+sysvar_vpd_pflags)
044450 28 FA       0065*  			JR	Z, @B			; Wait for the result
044452 DD E1       0066*  			POP	IX
044454 C3 9E 0B 04 0067*  			JP	XEQ
044458             0068*  
044458             0069*  ; GET(x,y): Get the ASCII code of a character on screen
044458             0070*  ;
044458 FD 23       0071*  GETSCHR:		INC	IY
04445A CD 0F 03 04 0072*  			CALL    EXPRI      		; Get X coordinate
04445E D9          0073*  			EXX
04445F 22 00 4A 04 0074*  			LD	(VDU_BUFFER+0), HL
044463 CD 2A 0A 04 0075*  			CALL	COMMA
044467 CD 0F 03 04 0076*  			CALL	EXPRI			; Get Y coordinate
04446B D9          0077*  			EXX
04446C 22 02 4A 04 0078*  			LD	(VDU_BUFFER+2), HL
044470 CD 37 0A 04 0079*  			CALL	BRAKET			; Closing bracket
044474             0080*  ;
044474 DD E5       0081*  			PUSH	IX			; Get the system vars in IX
044476             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
044476 3E 08       0001*M 			LD	A, function
044478 49 CF       0002*M 			RST.LIS	08h
04447A DD CB 04 8E 0083*  			RES	1, (IX+sysvar_vpd_pflags)
04447E             0084*  			VDU	23
04447E 3E 17       0001*M 		LD	A, val
044480 CD 56 3F 04 0002*M 		CALL	OSWRCH
044484             0085*  			VDU	0
044484 3E 00       0001*M 		LD	A, val
044486 CD 56 3F 04 0002*M 		CALL	OSWRCH
04448A             0086*  			VDU	vdp_scrchar
04448A 3E 83       0001*M 		LD	A, val
04448C CD 56 3F 04 0002*M 		CALL	OSWRCH
044490             0087*  			VDU	(VDU_BUFFER+0)
044490 3A 00 4A 04 0001*M 		LD	A, val
044494 CD 56 3F 04 0002*M 		CALL	OSWRCH
044498             0088*  			VDU	(VDU_BUFFER+1)
044498 3A 01 4A 04 0001*M 		LD	A, val
04449C CD 56 3F 04 0002*M 		CALL	OSWRCH
0444A0             0089*  			VDU	(VDU_BUFFER+2)
0444A0 3A 02 4A 04 0001*M 		LD	A, val
0444A4 CD 56 3F 04 0002*M 		CALL	OSWRCH
0444A8             0090*  			VDU	(VDU_BUFFER+3)
0444A8 3A 03 4A 04 0001*M 		LD	A, val
0444AC CD 56 3F 04 0002*M 		CALL	OSWRCH
0444B0 DD CB 04 4E 0091*  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0444B4 28 FA       0092*  			JR	Z, @B			; Wait for the result
0444B6 DD 7E 09    0093*  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0444B9 B7          0094*  			OR	A			; Check for 00h
0444BA 37          0095*  			SCF				; C = character map
0444BB 20 02       0096*  			JR	NZ, @F			; We have a character, so skip next bit
0444BD AF          0097*  			XOR	A			; Clear carry
0444BE 3D          0098*  			DEC	A			; Set A to FFh
0444BF DD E1       0099*  @@:			POP	IX
0444C1 C3 E6 07 04 0100*  			JP	INKEY1			; Jump back to the GET command
0444C5             0101*  
0444C5             0102*  ; POINT(x,y): Get the pixel colour of a point on screen
0444C5             0103*  ;
0444C5 CD 0F 03 04 0104*  POINT:			CALL    EXPRI      		; Get X coordinate
0444C9 D9          0105*  			EXX
0444CA 22 00 4A 04 0106*  			LD	(VDU_BUFFER+0), HL
0444CE CD 2A 0A 04 0107*  			CALL	COMMA
0444D2 CD 0F 03 04 0108*  			CALL	EXPRI			; Get Y coordinate
0444D6 D9          0109*  			EXX
0444D7 22 02 4A 04 0110*  			LD	(VDU_BUFFER+2), HL
0444DB CD 37 0A 04 0111*  			CALL	BRAKET			; Closing bracket
0444DF             0112*  ;
0444DF DD E5       0113*  			PUSH	IX			; Get the system vars in IX
0444E1             0114*  			MOSCALL	mos_sysvars		; Reset the semaphore
0444E1 3E 08       0001*M 			LD	A, function
0444E3 49 CF       0002*M 			RST.LIS	08h
0444E5 DD CB 04 96 0115*  			RES	2, (IX+sysvar_vpd_pflags)
0444E9             0116*  			VDU	23
0444E9 3E 17       0001*M 		LD	A, val
0444EB CD 56 3F 04 0002*M 		CALL	OSWRCH
0444EF             0117*  			VDU	0
0444EF 3E 00       0001*M 		LD	A, val
0444F1 CD 56 3F 04 0002*M 		CALL	OSWRCH
0444F5             0118*  			VDU	vdp_scrpixel
0444F5 3E 84       0001*M 		LD	A, val
0444F7 CD 56 3F 04 0002*M 		CALL	OSWRCH
0444FB             0119*  			VDU	(VDU_BUFFER+0)
0444FB 3A 00 4A 04 0001*M 		LD	A, val
0444FF CD 56 3F 04 0002*M 		CALL	OSWRCH
044503             0120*  			VDU	(VDU_BUFFER+1)
044503 3A 01 4A 04 0001*M 		LD	A, val
044507 CD 56 3F 04 0002*M 		CALL	OSWRCH
04450B             0121*  			VDU	(VDU_BUFFER+2)
04450B 3A 02 4A 04 0001*M 		LD	A, val
04450F CD 56 3F 04 0002*M 		CALL	OSWRCH
044513             0122*  			VDU	(VDU_BUFFER+3)
044513 3A 03 4A 04 0001*M 		LD	A, val
044517 CD 56 3F 04 0002*M 		CALL	OSWRCH
04451B DD CB 04 56 0123*  @@:			BIT	2, (IX+sysvar_vpd_pflags)
04451F 28 FA       0124*  			JR	Z, @B			; Wait for the result
044521             0125*  ;
044521             0126*  ; Return the data as a 1 byte index
044521             0127*  ;
044521 DD 6E 16    0128*  			LD	L, (IX+sysvar_scrpixelIndex)
044524 DD E1       0129*  			POP	IX
044526 C3 84 05 04 0130*  			JP	COUNT0
04452A             0131*  
04452A             0132*  
04452A             0133*  ; COLOUR colour
04452A             0134*  ; COLOUR L,P
04452A             0135*  ; COLOUR L,R,G,B
04452A             0136*  ;
04452A CD 0F 03 04 0137*  COLOUR:			CALL	EXPRI			; The colour / mode
04452E D9          0138*  			EXX
04452F 7D          0139*  			LD	A, L
044530 32 00 4A 04 0140*  			LD	(VDU_BUFFER+0), A	; Store first parameter
044534 CD 78 0A 04 0141*  			CALL	NXT			; Are there any more parameters?
044538 FE 2C       0142*  			CP	','
04453A 28 12       0143*  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
04453C             0144*  ;
04453C             0145*  			VDU	11h			; Just set the colour
04453C 3E 11       0001*M 		LD	A, val
04453E CD 56 3F 04 0002*M 		CALL	OSWRCH
044542             0146*  			VDU	(VDU_BUFFER+0)
044542 3A 00 4A 04 0001*M 		LD	A, val
044546 CD 56 3F 04 0002*M 		CALL	OSWRCH
04454A C3 9E 0B 04 0147*  			JP	XEQ
04454E             0148*  ;
04454E CD 2A 0A 04 0149*  COLOUR_1:		CALL	COMMA
044552 CD 0F 03 04 0150*  			CALL	EXPRI			; Parse R (OR P)
044556 D9          0151*  			EXX
044557 7D          0152*  			LD	A, L
044558 32 01 4A 04 0153*  			LD	(VDU_BUFFER+1), A
04455C CD 78 0A 04 0154*  			CALL	NXT			; Are there any more parameters?
044560 FE 2C       0155*  			CP	','
044562 28 2C       0156*  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
044564             0157*  ;
044564             0158*  			VDU	13h			; VDU:COLOUR
044564 3E 13       0001*M 		LD	A, val
044566 CD 56 3F 04 0002*M 		CALL	OSWRCH
04456A             0159*  			VDU	(VDU_BUFFER+0)		; Logical Colour
04456A 3A 00 4A 04 0001*M 		LD	A, val
04456E CD 56 3F 04 0002*M 		CALL	OSWRCH
044572             0160*  			VDU	(VDU_BUFFER+1)		; Palette Colour
044572 3A 01 4A 04 0001*M 		LD	A, val
044576 CD 56 3F 04 0002*M 		CALL	OSWRCH
04457A             0161*  			VDU	0			; RGB set to 0
04457A 3E 00       0001*M 		LD	A, val
04457C CD 56 3F 04 0002*M 		CALL	OSWRCH
044580             0162*  			VDU	0
044580 3E 00       0001*M 		LD	A, val
044582 CD 56 3F 04 0002*M 		CALL	OSWRCH
044586             0163*  			VDU	0
044586 3E 00       0001*M 		LD	A, val
044588 CD 56 3F 04 0002*M 		CALL	OSWRCH
04458C C3 9E 0B 04 0164*  			JP	XEQ
044590             0165*  ;
044590 CD 2A 0A 04 0166*  COLOUR_2:		CALL	COMMA
044594 CD 0F 03 04 0167*  			CALL	EXPRI			; Parse G
044598 D9          0168*  			EXX
044599 7D          0169*  			LD	A, L
04459A 32 02 4A 04 0170*  			LD	(VDU_BUFFER+2), A
04459E CD 2A 0A 04 0171*  			CALL	COMMA
0445A2 CD 0F 03 04 0172*  			CALL	EXPRI			; Parse B
0445A6 D9          0173*  			EXX
0445A7 7D          0174*  			LD	A, L
0445A8 32 03 4A 04 0175*  			LD	(VDU_BUFFER+3), A
0445AC             0176*  			VDU	13h			; VDU:COLOUR
0445AC 3E 13       0001*M 		LD	A, val
0445AE CD 56 3F 04 0002*M 		CALL	OSWRCH
0445B2             0177*  			VDU	(VDU_BUFFER+0)		; Logical Colour
0445B2 3A 00 4A 04 0001*M 		LD	A, val
0445B6 CD 56 3F 04 0002*M 		CALL	OSWRCH
0445BA             0178*  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0445BA 3E FF       0001*M 		LD	A, val
0445BC CD 56 3F 04 0002*M 		CALL	OSWRCH
0445C0             0179*  			VDU	(VDU_BUFFER+1)		; R
0445C0 3A 01 4A 04 0001*M 		LD	A, val
0445C4 CD 56 3F 04 0002*M 		CALL	OSWRCH
0445C8             0180*  			VDU	(VDU_BUFFER+2)		; G
0445C8 3A 02 4A 04 0001*M 		LD	A, val
0445CC CD 56 3F 04 0002*M 		CALL	OSWRCH
0445D0             0181*  			VDU	(VDU_BUFFER+3)		; B
0445D0 3A 03 4A 04 0001*M 		LD	A, val
0445D4 CD 56 3F 04 0002*M 		CALL	OSWRCH
0445D8 C3 9E 0B 04 0182*  			JP	XEQ
0445DC             0183*  
0445DC             0184*  ; GCOL mode,colour
0445DC             0185*  ;
0445DC CD 0F 03 04 0186*  GCOL:			CALL	EXPRI			; Parse MODE
0445E0 D9          0187*  			EXX
0445E1 7D          0188*  			LD	A, L
0445E2 32 00 4A 04 0189*  			LD	(VDU_BUFFER+0), A
0445E6 CD 2A 0A 04 0190*  			CALL	COMMA
0445EA             0191*  ;
0445EA CD 0F 03 04 0192*  			CALL	EXPRI			; Parse Colour
0445EE D9          0193*  			EXX
0445EF 7D          0194*  			LD	A, L
0445F0 32 01 4A 04 0195*  			LD	(VDU_BUFFER+1), A
0445F4             0196*  ;
0445F4             0197*  			VDU	12h			; VDU:GCOL
0445F4 3E 12       0001*M 		LD	A, val
0445F6 CD 56 3F 04 0002*M 		CALL	OSWRCH
0445FA             0198*  			VDU	(VDU_BUFFER+0)		; Mode
0445FA 3A 00 4A 04 0001*M 		LD	A, val
0445FE CD 56 3F 04 0002*M 		CALL	OSWRCH
044602             0199*  			VDU	(VDU_BUFFER+1)		; Colour
044602 3A 01 4A 04 0001*M 		LD	A, val
044606 CD 56 3F 04 0002*M 		CALL	OSWRCH
04460A C3 9E 0B 04 0200*  			JP	XEQ
04460E             0201*  
04460E             0202*  ; PLOT mode,x,y
04460E             0203*  ;
04460E CD 0F 03 04 0204*  PLOT:			CALL	EXPRI		; Parse mode
044612 D9          0205*  			EXX
044613 E5          0206*  			PUSH	HL		; Push mode (L) onto stack
044614 CD 2A 0A 04 0207*  			CALL	COMMA
044618 CD 0C 44 04 0208*  			CALL	EXPR_W2		; Parse X and Y
04461C C1          0209*  			POP	BC		; Pop mode (C) off stack
04461D             0210*  PLOT_1:			VDU	19H		; VDU code for PLOT
04461D 3E 19       0001*M 		LD	A, val
04461F CD 56 3F 04 0002*M 		CALL	OSWRCH
044623             0211*  			VDU	C		;  C: Mode
044623 79          0001*M 		LD	A, val
044624 CD 56 3F 04 0002*M 		CALL	OSWRCH
044628             0212*  			VDU	E		; DE: X
044628 7B          0001*M 		LD	A, val
044629 CD 56 3F 04 0002*M 		CALL	OSWRCH
04462D             0213*  			VDU	D
04462D 7A          0001*M 		LD	A, val
04462E CD 56 3F 04 0002*M 		CALL	OSWRCH
044632             0214*  			VDU	L		; HL: Y
044632 7D          0001*M 		LD	A, val
044633 CD 56 3F 04 0002*M 		CALL	OSWRCH
044637             0215*  			VDU	H
044637 7C          0001*M 		LD	A, val
044638 CD 56 3F 04 0002*M 		CALL	OSWRCH
04463C C3 9E 0B 04 0216*  			JP	XEQ
044640             0217*  
044640             0218*  ; MOVE x,y
044640             0219*  ;
044640 CD 0C 44 04 0220*  MOVE:			CALL	EXPR_W2		; Parse X and Y
044644 0E 04       0221*  			LD	C, 04H		; Plot mode 04H (Move)
044646 18 D5       0222*  			JR	PLOT_1		; Plot
044648             0223*  
044648             0224*  ; DRAW x1,y1
044648             0225*  ; DRAW x1,y1,x2,y2
044648             0226*  ;
044648 CD 0C 44 04 0227*  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
04464C CD 78 0A 04 0228*  			CALL	NXT		; Are there any more parameters?
044650 FE 2C       0229*  			CP	','
044652 0E 05       0230*  			LD	C, 05h		; Code for LINE
044654 20 C7       0231*  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
044656             0232*  			VDU	19h		; Move to the first coordinates
044656 3E 19       0001*M 		LD	A, val
044658 CD 56 3F 04 0002*M 		CALL	OSWRCH
04465C             0233*  			VDU	04h
04465C 3E 04       0001*M 		LD	A, val
04465E CD 56 3F 04 0002*M 		CALL	OSWRCH
044662             0234*  			VDU	E
044662 7B          0001*M 		LD	A, val
044663 CD 56 3F 04 0002*M 		CALL	OSWRCH
044667             0235*  			VDU	D
044667 7A          0001*M 		LD	A, val
044668 CD 56 3F 04 0002*M 		CALL	OSWRCH
04466C             0236*  			VDU	L
04466C 7D          0001*M 		LD	A, val
04466D CD 56 3F 04 0002*M 		CALL	OSWRCH
044671             0237*  			VDU	H
044671 7C          0001*M 		LD	A, val
044672 CD 56 3F 04 0002*M 		CALL	OSWRCH
044676 CD 2A 0A 04 0238*  			CALL	COMMA
04467A C5          0239*  			PUSH	BC
04467B CD 0C 44 04 0240*  			CALL	EXPR_W2		; Get X2 and Y2
04467F C1          0241*  			POP	BC
044680 18 9B       0242*  			JR	PLOT_1		; Now DRAW the line to those positions
044682             0243*  
044682             0244*  
044682             0245*  
044682             0014       include "agon_sound.asm"
044682             0001*  ;
044682             0002*  ; Title:	BBC Basic for AGON - Audio stuff
044682             0003*  ; Author:	Dean Belfield
044682             0004*  ; Created:	12/05/2023
044682             0005*  ; Last Updated:	12/05/2023
044682             0006*  ;
044682             0007*  ; Modinfo:
044682             0008*  
044682             0009*  			; .ASSUME	ADL = 1
044682             0010*  
044682             0011*  			; INCLUDE	"equs.inc"
044682             0012*  			; INCLUDE "macros.inc"
044682             0013*  			; INCLUDE "mos_api.inc"	; In MOS/src
044682             0014*  
044682             0015*  			; SEGMENT CODE
044682             0016*  
044682             0017*  			; XDEF	SOUND
044682             0018*  
044682             0019*  			; XREF	COMMA
044682             0020*  			; XREF	EXPR_W2
044682             0021*  			; XREF	XEQ
044682             0022*  			; XREF	LTRAP
044682             0023*  			; XREF	OSWRCH
044682             0024*  			; XREF	VDU_BUFFER
044682             0025*  
044682             0026*  
044682             0027*  ; SOUND channel,volume,pitch,duration
044682             0028*  ; volume: 0 (off) to -15 (full volume)
044682             0029*  ; pitch: 0 - 255
044682             0030*  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
044682             0031*  ;
044682 CD 0C 44 04 0032*  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044686 7D          0033*  			LD	A, L 			;  A: Volume
044687 F5          0034*  			PUSH	AF
044688 D5          0035*  			PUSH	DE
044689 CD 2A 0A 04 0036*  			CALL	COMMA
04468D CD 0C 44 04 0037*  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
044691 53          0038*  			LD	D, E			;  D: Pitch
044692 5D          0039*  			LD	E, L 			;  E: Duration
044693 E1          0040*  			POP	HL 			; HL: Channel/Control
044694 F1          0041*  			POP	AF
044695 ED 44       0042*  			NEG
044697 FE 10       0043*  			CP	16			; Check volume is in bounds
044699 D2 9E 0B 04 0044*  			JP	NC, XEQ			; Out of bounds, do nothing
04469D             0045*  ;
04469D             0046*  ; Store	in VDU vars
04469D             0047*  ;
04469D 4F          0048*  			LD	C, A			; Store Volume in C
04469E 7D          0049*  			LD	A, L
04469F 32 00 4A 04 0050*  			LD	(VDU_BUFFER+0), A	; Channel
0446A3 AF          0051*  			XOR	A
0446A4 32 01 4A 04 0052*  			LD	(VDU_BUFFER+1), A	; Waveform
0446A8             0053*  ;
0446A8             0054*  ; Calculate the volume
0446A8             0055*  ;
0446A8 06 06       0056*  			LD	B, 6			; C already contains the volume
0446AA ED 4C       0057*  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0446AC 79          0058*  			LD	A, C
0446AD 32 02 4A 04 0059*  			LD	(VDU_BUFFER+2), A
0446B1             0060*  ;
0446B1             0061*  ; And the frequency
0446B1             0062*  ;
0446B1 4B          0063*  			LD	C, E			; Store duration in C
0446B2 26 00       0064*  			LD	H, 0			; Lookup the frequency
0446B4 6A          0065*  			LD	L, D
0446B5 11 3C 47 04 0066*  			LD	DE, SOUND_FREQ_LOOKUP
0446B9 29          0067*  			ADD	HL, HL
0446BA 19          0068*  			ADD	HL, DE
0446BB 7E          0069*  			LD	A, (HL)
0446BC 32 03 4A 04 0070*  			LD	(VDU_BUFFER+3), A
0446C0 23          0071*  			INC	HL
0446C1 7E          0072*  			LD	A, (HL)
0446C2 32 04 4A 04 0073*  			LD	(VDU_BUFFER+4), A
0446C6             0074*  ;
0446C6             0075*  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0446C6             0076*  ;
0446C6 06 32       0077*  			LD	B, 50			; C contains the duration, so MLT by 50
0446C8 ED 4C       0078*  			MLT	BC
0446CA ED 43 05 4A 0079*  			LD	(VDU_BUFFER+5), BC
       04          
0446CF             0080*  ;
0446CF DD E5       0081*  			PUSH	IX			; Get the system vars in IX
0446D1             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
0446D1 3E 08       0001*M 			LD	A, function
0446D3 49 CF       0002*M 			RST.LIS	08h
0446D5 5B DD CB 04 0083*  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0446DA             0084*  ;
0446DA             0085*  			VDU	23			; Send the sound command
0446DA 3E 17       0001*M 		LD	A, val
0446DC CD 56 3F 04 0002*M 		CALL	OSWRCH
0446E0             0086*  			VDU	0
0446E0 3E 00       0001*M 		LD	A, val
0446E2 CD 56 3F 04 0002*M 		CALL	OSWRCH
0446E6             0087*  			VDU	vdp_audio
0446E6 3E 85       0001*M 		LD	A, val
0446E8 CD 56 3F 04 0002*M 		CALL	OSWRCH
0446EC             0088*  			VDU	(VDU_BUFFER+0)		; 0: Channel
0446EC 3A 00 4A 04 0001*M 		LD	A, val
0446F0 CD 56 3F 04 0002*M 		CALL	OSWRCH
0446F4             0089*  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0446F4 3A 01 4A 04 0001*M 		LD	A, val
0446F8 CD 56 3F 04 0002*M 		CALL	OSWRCH
0446FC             0090*  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0446FC 3A 02 4A 04 0001*M 		LD	A, val
044700 CD 56 3F 04 0002*M 		CALL	OSWRCH
044704             0091*  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
044704 3A 03 4A 04 0001*M 		LD	A, val
044708 CD 56 3F 04 0002*M 		CALL	OSWRCH
04470C             0092*  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
04470C 3A 04 4A 04 0001*M 		LD	A, val
044710 CD 56 3F 04 0002*M 		CALL	OSWRCH
044714             0093*  			VDU	(VDU_BUFFER+5)		; 5: Duration L
044714 3A 05 4A 04 0001*M 		LD	A, val
044718 CD 56 3F 04 0002*M 		CALL	OSWRCH
04471C             0094*  			VDU	(VDU_BUFFER+6)		; 6: Duration H
04471C 3A 06 4A 04 0001*M 		LD	A, val
044720 CD 56 3F 04 0002*M 		CALL	OSWRCH
044724             0095*  ;
044724             0096*  ; Wait for acknowledgement
044724             0097*  ;
044724 5B DD CB 04 0098*  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
044729 28 F9       0099*  			JR	Z, @B			; Wait for the result
04472B CD C7 3F 04 0100*  			CALL	LTRAP			; Check for ESC
04472F 5B DD 7E 0E 0101*  			LD.LIL	A, (IX+sysvar_audioSuccess)
044733 A7          0102*  			AND	A			; Check if VDP has queued the note
044734 28 9F       0103*  			JR	Z, SOUND0		; No, so loop back and send again
044736             0104*  ;
044736 DD E1       0105*  			POP	IX
044738 C3 9E 0B 04 0106*  			JP	XEQ
04473C             0107*  
04473C             0108*  ; Frequency Lookup Table
04473C             0109*  ; Set up to replicate the BBC Micro audio frequencies
04473C             0110*  ;
04473C             0111*  ; Split over 5 complete octaves, with 53 being middle C
04473C             0112*  ; * C4: 262hz
04473C             0113*  ; + A4: 440hz
04473C             0114*  ;
04473C             0115*  ;	2	3	4	5	6	7	8
04473C             0116*  ;
04473C             0117*  ; B	1	49	97	145	193	241
04473C             0118*  ; A#	0	45	93	141	189	237
04473C             0119*  ; A		41	89+	137	185	233
04473C             0120*  ; G#		37	85	133	181	229
04473C             0121*  ; G		33	81	129	177	225
04473C             0122*  ; F#		29	77	125	173	221
04473C             0123*  ; F		25	73	121	169	217
04473C             0124*  ; E		21	69	117	165	213
04473C             0125*  ; D#		17	65	113	161	209
04473C             0126*  ; D		13	61	109	157	205	253
04473C             0127*  ; C#		9	57	105	153	201	249
04473C             0128*  ; C		5	53*	101	149	197	245
04473C             0129*  ;
04473C 75 00 76 00 0130*  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
04474C 89 00 8B 00 0131*  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
04475C 99 00 9C 00 0132*  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
04476C AC 00 AF 00 0133*  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
04477C C1 00 C4 00 0134*  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
04478C D9 00 DC 00 0135*  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
04479C F3 00 F7 00 0136*  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0447AC 11 01 15 01 0137*  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0447BC 33 01 37 01 0138*  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0447CC 58 01 5D 01 0139*  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0447DC 82 01 88 01 0140*  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0447EC B2 01 B8 01 0141*  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0447FC E7 01 EE 01 0142*  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
04480C 22 02 2A 02 0143*  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
04481C 65 02 6E 02 0144*  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
04482C B1 02 BB 02 0145*  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
04483C 05 03 10 03 0146*  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
04484C 63 03 70 03 0147*  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
04485C CE 03 DC 03 0148*  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
04486C 45 04 55 04 0149*  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
04487C CB 04 DD 04 0150*  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
04488C 62 05 76 05 0151*  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
04489C 0A 06 21 06 0152*  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0448AC C8 06 E1 06 0153*  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0448BC 9C 07 B8 07 0154*  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0448CC 8A 08 A9 08 0155*  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0448DC 95 09 B9 09 0156*  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0448EC C2 0A EA 0A 0157*  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0448FC 13 0C 40 0C 0158*  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
04490C 8E 0D C0 0D 0159*  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
04491C 36 0F 6F 0F 0160*  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
04492C 13 11 53 11 0161*  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
04493C             0162*  
04493C             0163*  
04493C             0015       include "interrupts.asm"
04493C             0001*  ;
04493C             0002*  ; Title:	BBC Basic for AGON - Interrupts
04493C             0003*  ; Author:	Dean Belfield
04493C             0004*  ; Created:	12/05/2023
04493C             0005*  ; Last Updated:	07/06/2023
04493C             0006*  ;
04493C             0007*  ; Modinfo:
04493C             0008*  ; 07/06/2023:	Modified to run in ADL mode
04493C             0009*  
04493C             0010*  			; .ASSUME	ADL = 1
04493C             0011*  
04493C             0012*  			; INCLUDE	"macros.inc"
04493C             0013*  			; INCLUDE	"equs.inc"
04493C             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
04493C             0015*  
04493C             0016*  			; SEGMENT CODE
04493C             0017*  
04493C             0018*  			; XDEF	VBLANK_INIT
04493C             0019*  			; XDEF	VBLANK_STOP
04493C             0020*  			; XDEF	VBLANK_HANDLER
04493C             0021*  
04493C             0022*  			; XREF	ESCSET
04493C             0023*  			; XREF	KEYDOWN		; In ram.asm
04493C             0024*  			; XREF	KEYASCII 	; In ram.asm
04493C             0025*  			; XREF	KEYCOUNT	; In ram.asm
04493C             0026*  
04493C             0027*  ; Hook into the MOS VBLANK interrupt
04493C             0028*  ;
04493C F3          0029*  VBLANK_INIT:		DI
04493D 21 91 49 04 0030*  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044941 1E 32       0031*  			LD		E, 32h				; Set up the VBlank Interrupt Vector
044943             0032*  			MOSCALL		mos_setintvector
044943 3E 14       0001*M 			LD	A, function
044945 49 CF       0002*M 			RST.LIS	08h
044947             0033*  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
044947 EB          0034*  			ex de,hl
044948 21 9F 49 04 0035*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04494C ED 1F       0036*  			LD		(HL), DE			; Self-modify the code
04494E FB          0037*  			EI
04494F C9          0038*  			RET
044950             0039*  
044950             0040*  ; Unhook the custom VBLANK interrupt
044950             0041*  ;
044950 F3          0042*  VBLANK_STOP:		DI
044951 21 9F 49 04 0043*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044955 ED 17       0044*  			LD		DE, (HL)
044957 EB          0045*  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
044958 1E 32       0046*  			LD		E, 32h
04495A             0047*  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
04495A 3E 14       0001*M 			LD	A, function
04495C 49 CF       0002*M 			RST.LIS	08h
04495E FB          0048*  			EI
04495F C9          0049*  			RET
044960             0050*  
044960             0051*  ; A safe LIS call to ESCSET
044960             0052*  ;
044960             0053*  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044960 3E 08       0001*M 			LD	A, function
044962 49 CF       0002*M 			RST.LIS	08h
044964 21 49 4D 04 0054*  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
044968 DD 7E 19    0055*  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
04496B BE          0056*  			CP 		(HL)				; with our local copy
04496C 20 0A       0057*  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
04496E             0058*  ;
04496E AF          0059*  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
04496F 32 48 4D 04 0060*  			LD		(KEYASCII), A
044973 32 47 4D 04 0061*  			LD		(KEYDOWN), A
044977 C9          0062*  			RET	 					; And return
044978             0063*  ;
044978 77          0064*  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044979 DD 7E 18    0065*  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
04497C B7          0066*  			OR		A
04497D 28 EF       0067*  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
04497F             0068*  ;
04497F 32 47 4D 04 0069*  			LD		(KEYDOWN), A 			; Store the keydown value
044983 DD 7E 05    0070*  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
044986 32 48 4D 04 0071*  			LD		(KEYASCII), A 			; Store locally
04498A FE 1B       0072*  			CP		1Bh				; Is it escape?
04498C CC A2 3F 04 0073*  			CALL		Z, ESCSET			; Yes, so set the escape flags
044990 C9          0074*  			RET						; Return to the interrupt handler
044991             0075*  
044991 F3          0076*  VBLANK_HANDLER:		DI
044992 F5          0077*  			PUSH		AF
044993 E5          0078*  			PUSH		HL
044994 DD E5       0079*  			PUSH		IX
044996 CD 60 49 04 0080*  			CALL		DO_KEYBOARD
04499A DD E1       0081*  			POP		IX
04499C E1          0082*  			POP		HL
04499D F1          0083*  			POP		AF
04499E             0084*  ;
04499E             0085*  ; Finally jump to the MOS interrupt
04499E             0086*  ;
04499E C3 00 00 00 0087*  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0449A2             0016       include "sorry.asm"
0449A2             0001*  ;
0449A2             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0449A2             0003*  ;		Catch-all for unimplemented functionality
0449A2             0004*  ; Author:	Dean Belfield
0449A2             0005*  ; Created:	12/05/2023
0449A2             0006*  ; Last Updated:	12/05/2023
0449A2             0007*  ;
0449A2             0008*  ; Modinfo:
0449A2             0009*  
0449A2             0010*  			; .ASSUME	ADL = 1
0449A2             0011*  
0449A2             0012*  			; SEGMENT CODE
0449A2             0013*  
0449A2             0014*  			; XDEF	ENVEL
0449A2             0015*  			; XDEF	ADVAL
0449A2             0016*  			; XDEF	PUTIMS
0449A2             0017*  
0449A2             0018*  			; XREF	EXTERR
0449A2             0019*  
0449A2             0020*  ENVEL:
0449A2             0021*  ADVAL:
0449A2             0022*  PUTIMS:
0449A2 AF          0023*  			XOR     A
0449A3 CD CD 37 04 0024*  			CALL    EXTERR
0449A7 53 6F 72 72 0025*  			DEFB    "Sorry"
       79          
0449AC 00          0026*  			DEFB    0
0449AD             0017   
0449AD             0018       include "ram.asm"
0449AD             0001*  ;
0449AD             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0449AD             0003*  ;		RAM Module for BBC Basic Interpreter
0449AD             0004*  ;		For use with Version 2.0 of BBC BASIC
0449AD             0005*  ;		Standard CP/M Distribution Version
0449AD             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0449AD             0007*  ; Modified By:	Dean Belfield
0449AD             0008*  ; Created:	12/05/2023
0449AD             0009*  ; Last Updated:	26/06/2023
0449AD             0010*  ;
0449AD             0011*  ; Modinfo:
0449AD             0012*  ; 06/06/2023:	Modified to run in ADL mode
0449AD             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
0449AD             0014*  
0449AD             0015*  			; .ASSUME	ADL = 1
0449AD             0016*  
0449AD             0017*  			; DEFINE	LORAM, SPACE = ROM
0449AD             0018*  			; SEGMENT LORAM
0449AD             0019*  
0449AD             0020*  			; XDEF	ACCS
0449AD             0021*  			; XDEF	BUFFER
0449AD             0022*  			; XDEF	STAVAR
0449AD             0023*  			; XDEF	DYNVAR
0449AD             0024*  			; XDEF	FNPTR
0449AD             0025*  			; XDEF	PROPTR
0449AD             0026*  			; XDEF	PAGE_
0449AD             0027*  			; XDEF	TOP
0449AD             0028*  			; XDEF	LOMEM
0449AD             0029*  			; XDEF 	FREE
0449AD             0030*  			; XDEF	HIMEM
0449AD             0031*  			; XDEF	LINENO
0449AD             0032*  			; XDEF	TRACEN
0449AD             0033*  			; XDEF	AUTONO
0449AD             0034*  			; XDEF	ERRTRP
0449AD             0035*  			; XDEF	ERRTXT
0449AD             0036*  			; XDEF	DATPTR
0449AD             0037*  			; XDEF	ERL
0449AD             0038*  			; XDEF	ERRLIN
0449AD             0039*  			; XDEF	RANDOM
0449AD             0040*  			; XDEF	COUNT
0449AD             0041*  			; XDEF	WIDTH
0449AD             0042*  			; XDEF	ERR
0449AD             0043*  			; XDEF	LISTON
0449AD             0044*  			; XDEF	INCREM
0449AD             0045*  
0449AD             0046*  			; XDEF	FLAGS
0449AD             0047*  			; XDEF	OSWRCHPT
0449AD             0048*  			; XDEF	OSWRCHCH
0449AD             0049*  			; XDEF	OSWRCHFH
0449AD             0050*  			; XDEF	KEYDOWN
0449AD             0051*  			; XDEF	KEYASCII
0449AD             0052*  			; XDEF	KEYCOUNT
0449AD             0053*  
0449AD             0054*  			; XDEF	R0
0449AD             0055*  			; XDEF	R1
0449AD             0056*  
0449AD             0057*  			; XDEF	RAM_START
0449AD             0058*  			; XDEF	RAM_END
0449AD             0059*  			; XDEF	USER
0449AD             0060*  
0449AD 00 00 00 00 0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00    
044A00             0062*  RAM_START:
044A00             0063*  ;
044A00 00 00 00 00 0064*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 0065*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 0066*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 0067*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    0068*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    0069*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             0070*  ;
044D14 00 00 00    0071*  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    0072*  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    0073*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    0074*  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    0075*  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             0076*  ;
044D23 00 00 00    0077*  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    0078*  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    0079*  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    0080*  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       0081*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       0082*  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       0083*  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    0084*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 0085*  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          0086*  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          0087*  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          0088*  ERR:            BLKB    1,0               ; Error Number
044D40 00          0089*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             0090*                                  ; - BIT 0: If set, output a space after the line number
044D41             0091*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             0092*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             0093*                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             0094*                                  ; OPT FLAG (top nibble)
044D41             0095*                                  ; - BIT 4: If set, then list whilst assembling
044D41             0096*                                  ; - BIT 5: If set, then assembler errors are reported
044D41             0097*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             0098*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          0099*  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             0100*  ;
044D42             0101*  ; Extra Agon-implementation specific system variables
044D42             0102*  ;
044D42 00          0103*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             0104*                                  ; - BIT 7: Set if ESC pressed
044D43             0105*                                  ; - BIT 6: Set to disable ESC
044D43 00 00       0106*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          0107*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             0108*                                  ; - 0: Console
044D46             0109*                                  ; - 1: File
044D46 00          0110*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          0111*  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          0112*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          0113*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    0114*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    0115*  R1:             BLKB    3,0
044D50             0116*  
044D50             0117*  ;
044D50             0118*  ; This must be at the end
044D50             0119*  ;
044D50             0120*  RAM_END:
044D50             0121*  ; moved to user.asm
044D50             0122*  ; 			ALIGN	256
044D50             0123*  ; USER:							; Must be aligned on a page boundary
044D50             0124*  
044D50             0019       include "user.asm"
044D50             0001*  ; this must be the last include to allow unbounded user space for programs
044D50             0002*  
044D50             0003*  			; .ASSUME	ADL = 1
044D50             0004*  
044D50 00 00 00 00 0005*  			ALIGN	256
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044E00             0006*  USER:							; Must be aligned on a page boundary
044E00             0020       include "equs_bottom.inc"
044E00             0001*  ; --- Begin equs.inc ---
044E00             0002*  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
044E00             0003*  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
044E00             0004*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044E00             0005*  ; --- End equs.inc ---
044E00             0006*  
044E00             0007*  ; --- Begin eval.asm ---
044E00             0008*  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
044E00             0009*  ; 041DFA D6 C6       0258*  			SUB     TCMD
044E00             0010*  
044E00             0011*  ; --- End eval.asm ---
044E00             0012*  
044E00             0013*  ; --- Begin exec.asm ---
044E00             0014*  ; --- End exec.asm ---
044E00             0015*  
044E00             0016*  ; --- Begin fpp.asm ---
044E00             0017*  ; --- End fpp.asm ---
044E00             0018*  
044E00             0019*  ; --- Begin init.asm ---
044E00             0020*  ; --- End init.asm ---
044E00             0021*  
044E00             0022*  ; --- Begin main.asm ---
044E00             0023*  ; --- End main.asm ---
044E00             0024*  
044E00             0025*  ; --- Begin mos_api.inc ---
044E00             0026*  ; --- End mos_api.inc ---
044E00             0027*  
