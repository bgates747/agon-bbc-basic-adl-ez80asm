PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ; FFOBJID offsets
040000             0241*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0242*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0243*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0244*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0245*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0246*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0247*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0248*  
040000             0249*  ; FIL offsets (including FFOBJID fields)
040000             0250*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0251*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0252*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0253*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0254*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0255*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0256*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0257*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0258*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0259*  
040000             0260*  ; DIR offsets (including FFOBJID fields)
040000             0261*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0262*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0263*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0264*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0265*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0266*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0267*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0268*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0269*  
040000             0270*  ; FILINFO offsets
040000             0271*  FILINFO.fsize:    EQU 0    ; File size
040000             0272*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0273*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0274*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0275*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0276*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0277*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0278*  
040000             0279*  ;
040000             0280*  ; Macro for calling the API
040000             0281*  ; Parameters:
040000             0282*  ; - function: One of the function numbers listed above
040000             0283*  ;
040000             0284*  			MACRO MOSCALL	function
040000             0285*  			LD	A, function
040000             0286*  			RST.LIS	08h
040000             0287*  			ENDMACRO
040000             0002       include "macros.inc"
040000             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040000             0002*  	;		Useful macros
040000             0003*  	; Author:	Dean Belfield
040000             0004*  	; Created:	12/05/2023
040000             0005*  	; Last Updated:	11/06/2023
040000             0006*  	;
040000             0007*  	; Modinfo:
040000             0008*  	; 11/06/2023:	Modified to run in ADL mode
040000             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0010*  
040000             0011*  	MACRO EXREG	rp1, rp2
040000             0012*  		PUSH	rp1
040000             0013*  		POP	rp2
040000             0014*  	ENDMACRO
040000             0015*  
040000             0016*  	; MACRO ADD8U_DE	reg
040000             0017*  		MACRO ADD8U_DE
040000             0018*  		ADD	A, E
040000             0019*  		LD	E, A
040000             0020*  		ADC	A, D
040000             0021*  		SUB	E
040000             0022*  		LD	D, A
040000             0023*  	ENDMACRO
040000             0024*  
040000             0025*  	; MACRO ADD8U_HL	reg
040000             0026*  	MACRO ADD8U_HL
040000             0027*  		ADD	A, L
040000             0028*  		LD	L, A
040000             0029*  		ADC	A, H
040000             0030*  		SUB	L
040000             0031*  		LD	H, A
040000             0032*  	ENDMACRO
040000             0033*  
040000             0034*  	MACRO VDU	val
040000             0035*  		LD	A, val
040000             0036*  		CALL	OSWRCH
040000             0037*  	ENDMACRO
040000             0038*  
040000             0039*  	MACRO SET_GPIO	reg, val
040000             0040*  		IN0	A, (reg)
040000             0041*  		OR	val
040000             0042*  		OUT0	(reg), A
040000             0043*  	ENDMACRO
040000             0044*  
040000             0045*  	MACRO RES_GPIO	reg, val
040000             0046*  		PUSH	BC
040000             0047*  		LD	A, val
040000             0048*  		CPL
040000             0049*  		LD	C, A
040000             0050*  		IN0	A, (reg)
040000             0051*  		AND	C
040000             0052*  		OUT0	(reg), A
040000             0053*  		POP	BC
040000             0054*  	ENDMACRO
040000             0003       include "init.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0003*  ;		Initialisation Code
040000             0004*  ; Author:	Dean Belfield
040000             0005*  ; Created:	12/05/2023
040000             0006*  ; Last Updated:	26/11/2023
040000             0007*  ;
040000             0008*  ; Modinfo:
040000             0009*  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0010*  ; 26/11/2023:	Moved the ram clear routine into here
040000             0011*  
040000             0012*  			; SEGMENT CODE
040000             0013*  
040000             0014*  			; XDEF	_end
040000             0015*  
040000             0016*  			; XREF	_main				; In main.asm
040000             0017*  
040000             0018*  			; XREF	RAM_START			; In ram.asm
040000             0019*  			; XREF	RAM_END
040000             0020*  
040000             0021*  			.ASSUME	ADL = 1
040000             0022*  
040000             0023*  			; INCLUDE	"equs.inc"
040000             0024*  
040000             0025*  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0026*  
040000             0027*  ;
040000             0028*  ; Start in ADL mode
040000             0029*  ;
040000 C3 45 00 04 0030*  			JP	_start				; Jump to start
040004             0031*  ;
040004             0032*  ; The header stuff is from byte 64 onwards
040004             0033*  ;
040004 62 62 63 62 0034*  _exec_name:		DB	"bbcbasic24ez.bin", 0		; The executable name, only used in argv
       61 73 69 63 
       32 34 65 7A 
       2E 62 69 6E 
       00          
040015             0035*  
040015 FF FF FF FF 0036*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0037*  
040040 4D 4F 53    0038*  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0039*  			DB	00h				; MOS header version 0
040044 01          0040*  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0041*  ;
040045             0042*  ; And the code follows on immediately after the header
040045             0043*  ;
040045 F5          0044*  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0045*  			PUSH		BC
040047 D5          0046*  			PUSH		DE
040048 DD E5       0047*  			PUSH		IX
04004A FD E5       0048*  			PUSH		IY
04004C             0049*  
04004C ED 73 D7 00 0050*  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0051*  
040051 DD 21 DA 00 0052*  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0053*  			PUSH		IX
040058 CD 88 00 04 0054*  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0055*  			POP		IX			; IX: argv
04005E 06 00       0056*  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0057*  			CALL		_clear_ram
040064 C3 50 05 04 0058*  			JP		_main			; Start user code
040068             0059*  ;
040068             0060*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0061*  ;
040068 ED 7B D7 00 0062*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0063*  
04006D FD E1       0064*  			POP		IY			; Restore the registers
04006F DD E1       0065*  			POP		IX
040071 D1          0066*  			POP		DE
040072 C1          0067*  			POP		BC
040073 F1          0068*  			POP		AF
040074 C9          0069*  			RET					; Return to MOS
040075             0070*  
040075             0071*  ;Clear the application memory
040075             0072*  ;
040075 C5          0073*  _clear_ram:		PUSH		BC
040076 21 00 02 04 0074*  			LD		HL, RAM_START
04007A 11 01 02 04 0075*  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0076*  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0077*  			XOR		A
040083 77          0078*  			LD		(HL), A
040084 ED B0       0079*  			LDIR
040086 C1          0080*  			POP		BC
040087 C9          0081*  			RET
040088             0082*  
040088             0083*  ; Parse the parameter string into a C array
040088             0084*  ; Parameters
040088             0085*  ; - HL: Address of parameter string
040088             0086*  ; - IX: Address for array pointer storage
040088             0087*  ; Returns:
040088             0088*  ; -  C: Number of parameters parsed
040088             0089*  ;
040088 01 04 00 04 0090*  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0091*  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0092*  			INC	IX
040091 DD 23       0093*  			INC	IX
040093 DD 23       0094*  			INC	IX
040095 CD D0 00 04 0095*  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0096*  ;
040099 01 01 00 00 0097*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0098*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0099*  ;
04009F             0100*  _parse_params_1:
04009F C5          0101*  			PUSH	BC			; Stack ARGC
0400A0 E5          0102*  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0103*  			CALL	_get_token		; Get the next token
0400A5 79          0104*  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0105*  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0106*  			POP	BC			; ARGC
0400A8 B7          0107*  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0108*  			RET	Z
0400AA             0109*  ;
0400AA DD 1F 00    0110*  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0111*  			PUSH	HL			; DE=HL
0400AE D1          0112*  			POP	DE
0400AF CD D0 00 04 0113*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0114*  			XOR	A
0400B4 12          0115*  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0116*  			INC	IX
0400B7 DD 23       0117*  			INC	IX
0400B9 DD 23       0118*  			INC	IX			; Advance to next pointer position
0400BB 0C          0119*  			INC	C			; Increment ARGC
0400BC 79          0120*  			LD	A, C			; Check for C >= A
0400BD B8          0121*  			CP	B
0400BE 38 DF       0122*  			JR	C, _parse_params_1	; And loop
0400C0 C9          0123*  			RET
0400C1             0124*  
0400C1             0125*  ; Get the next token
0400C1             0126*  ; Parameters:
0400C1             0127*  ; - HL: Address of parameter string
0400C1             0128*  ; Returns:
0400C1             0129*  ; - HL: Address of first character after token
0400C1             0130*  ; -  C: Length of token (in characters)
0400C1             0131*  ;
0400C1 0E 00       0132*  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0133*  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0134*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0135*  			RET 	Z
0400C6 FE 0D       0136*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0137*  			RET	Z
0400C9 FE 20       0138*  			CP	' '			; Exit if space (end of token)
0400CB C8          0139*  			RET	Z
0400CC 23          0140*  			INC	HL			; Advance to next character
0400CD 0C          0141*  			INC 	C			; Increment length
0400CE 18 F3       0142*  			JR	@B
0400D0             0143*  
0400D0             0144*  ; Skip spaces in the parameter string
0400D0             0145*  ; Parameters:
0400D0             0146*  ; - HL: Address of parameter string
0400D0             0147*  ; Returns:
0400D0             0148*  ; - HL: Address of next none-space character
0400D0             0149*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0150*  ;
0400D0 7E          0151*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0152*  			CP	' '			; Exit if not space
0400D3 C0          0153*  			RET	NZ
0400D4 23          0154*  			INC	HL			; Advance to next character
0400D5 18 F9       0155*  			JR	_skip_spaces		; Increment length
0400D7             0156*  
0400D7             0157*  ; Storage
0400D7             0158*  ;
0400D7             0159*  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0160*  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0004       include "ram.asm"
04010A             0001*  ;
04010A             0002*  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0003*  ;		RAM Module for BBC Basic Interpreter
04010A             0004*  ;		For use with Version 2.0 of BBC BASIC
04010A             0005*  ;		Standard CP/M Distribution Version
04010A             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
04010A             0007*  ; Modified By:	Dean Belfield
04010A             0008*  ; Created:	12/05/2023
04010A             0009*  ; Last Updated:	26/06/2023
04010A             0010*  ;
04010A             0011*  ; Modinfo:
04010A             0012*  ; 06/06/2023:	Modified to run in ADL mode
04010A             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
04010A             0014*  
04010A             0015*  			; .ASSUME	ADL = 1
04010A             0016*  
04010A             0017*  			; DEFINE	LORAM, SPACE = ROM
04010A             0018*  			; SEGMENT LORAM
04010A             0019*  
04010A             0020*  			; XDEF	ACCS
04010A             0021*  			; XDEF	BUFFER
04010A             0022*  			; XDEF	STAVAR
04010A             0023*  			; XDEF	DYNVAR
04010A             0024*  			; XDEF	FNPTR
04010A             0025*  			; XDEF	PROPTR
04010A             0026*  			; XDEF	PAGE_
04010A             0027*  			; XDEF	TOP
04010A             0028*  			; XDEF	LOMEM
04010A             0029*  			; XDEF 	FREE
04010A             0030*  			; XDEF	HIMEM
04010A             0031*  			; XDEF	LINENO
04010A             0032*  			; XDEF	TRACEN
04010A             0033*  			; XDEF	AUTONO
04010A             0034*  			; XDEF	ERRTRP
04010A             0035*  			; XDEF	ERRTXT
04010A             0036*  			; XDEF	DATPTR
04010A             0037*  			; XDEF	ERL
04010A             0038*  			; XDEF	ERRLIN
04010A             0039*  			; XDEF	RANDOM
04010A             0040*  			; XDEF	COUNT
04010A             0041*  			; XDEF	WIDTH
04010A             0042*  			; XDEF	ERR
04010A             0043*  			; XDEF	LISTON
04010A             0044*  			; XDEF	INCREM
04010A             0045*  
04010A             0046*  			; XDEF	FLAGS
04010A             0047*  			; XDEF	OSWRCHPT
04010A             0048*  			; XDEF	OSWRCHCH
04010A             0049*  			; XDEF	OSWRCHFH
04010A             0050*  			; XDEF	KEYDOWN
04010A             0051*  			; XDEF	KEYASCII
04010A             0052*  			; XDEF	KEYCOUNT
04010A             0053*  
04010A             0054*  			; XDEF	R0
04010A             0055*  			; XDEF	R1
04010A             0056*  
04010A             0057*  			; XDEF	RAM_START
04010A             0058*  			; XDEF	RAM_END
04010A             0059*  			; XDEF	USER
04010A             0060*  
04010A FF FF FF FF 0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
040200             0062*  RAM_START:
040200             0063*  ;
040200 00 00 00 00 0064*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040300 00 00 00 00 0065*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040400 00 00 00 00 0066*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04046C 00 00 00 00 0067*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
04050E 00 00 00    0068*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
040511 00 00 00    0069*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
040514             0070*  ;
040514 00 00 00    0071*  PAGE_:          BLKB    3,0               ; Start of User Program
040517 00 00 00    0072*  TOP:            BLKB    3,0               ; First Location after User Program
04051A 00 00 00    0073*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
04051D 00 00 00    0074*  FREE:           BLKB    3,0               ; First Free Space Byte
040520 00 00 00    0075*  HIMEM:          BLKB    3,0               ; First Protected Byte
040523             0076*  ;
040523 00 00 00    0077*  LINENO:         BLKB    3,0               ; Line Number
040526 00 00 00    0078*  TRACEN:         BLKB    3,0               ; Trace Flag
040529 00 00 00    0079*  AUTONO:         BLKB    3,0               ; Auto Flag
04052C 00 00 00    0080*  ERRTRP:         BLKB    3,0               ; Error Trap
04052F 00 00       0081*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
040531 00 00       0082*  DATPTR:         BLKB    2,0               ; Data Pointer
040533 00 00       0083*  ERL:            BLKB    2,0               ; Error Line
040535 00 00 00    0084*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
040538 00 00 00 00 0085*  RANDOM:         BLKB    5,0               ; Random Number
       00          
04053D 00          0086*  COUNT:          BLKB    1,0               ; Print Position
04053E 00          0087*  WIDTH:          BLKB    1,0               ; Print Width
04053F 00          0088*  ERR:            BLKB    1,0               ; Error Number
040540 00          0089*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
040541             0090*                                  ; - BIT 0: If set, output a space after the line number
040541             0091*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
040541             0092*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
040541             0093*                                  ; - BIT 3: If set, then output to buffer for *EDIT
040541             0094*                                  ; OPT FLAG (top nibble)
040541             0095*                                  ; - BIT 4: If set, then list whilst assembling
040541             0096*                                  ; - BIT 5: If set, then assembler errors are reported
040541             0097*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
040541             0098*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040541 00          0099*  INCREM:         BLKB    1,0               ; Auto-Increment Value
040542             0100*  ;
040542             0101*  ; Extra Agon-implementation specific system variables
040542             0102*  ;
040542 00          0103*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
040543             0104*                                  ; - BIT 7: Set if ESC pressed
040543             0105*                                  ; - BIT 6: Set to disable ESC
040543 00 00       0106*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
040545 00          0107*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
040546             0108*                                  ; - 0: Console
040546             0109*                                  ; - 1: File
040546 00          0110*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
040547 00          0111*  KEYDOWN:        BLKB    1,0       ; Keydown flag
040548 00          0112*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
040549 00          0113*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
04054A 00 00 00    0114*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
04054D 00 00 00    0115*  R1:             BLKB    3,0
040550             0116*  
040550             0117*  ;
040550             0118*  ; This must be at the end
040550             0119*  ;
040550             0120*  RAM_END:
040550             0121*  ; moved to user.asm
040550             0122*  ; 			ALIGN	256
040550             0123*  ; USER:							; Must be aligned on a page boundary
040550             0124*  
040550             0005       include "equs_top.inc"
040550             0001*  ; --- Begin equs.inc ---
040550             0002*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040550             0003*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040550             0004*  PA_DR:			EQU		96h
040550             0005*  PA_DDR:			EQU		97h
040550             0006*  PA_ALT1:		EQU		98h
040550             0007*  PA_ALT2:		EQU		99h
040550             0008*  PB_DR:          	EQU		9Ah
040550             0009*  PB_DDR:        	 	EQU		9Bh
040550             0010*  PB_ALT1:        	EQU		9Ch
040550             0011*  PB_ALT2:        	EQU		9Dh
040550             0012*  PC_DR:          	EQU		9Eh
040550             0013*  PC_DDR:         	EQU		9Fh
040550             0014*  PC_ALT1:        	EQU		A0h
040550             0015*  PC_ALT2:        	EQU		A1h
040550             0016*  PD_DR:          	EQU		A2h
040550             0017*  PD_DDR:			EQU		A3h
040550             0018*  PD_ALT1:		EQU		A4h
040550             0019*  PD_ALT2:		EQU		A5h
040550             0020*  GPIOMODE_OUT:		EQU		0	; Output
040550             0021*  GPIOMODE_IN:		EQU		1	; Input
040550             0022*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040550             0023*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040550             0024*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040550             0025*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040550             0026*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040550             0027*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040550             0028*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040550             0029*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040550             0030*  CR:			EQU     0DH
040550             0031*  LF:			EQU     0AH
040550             0032*  ESC:			EQU     1BH
040550             0033*  ; --- End equs.inc ---
040550             0034*  
040550             0035*  ; --- Begin eval.asm ---
040550             0036*  FUNTOK:			EQU	8DH			; First token number
040550             0037*  ANDK:			EQU     80H
040550             0038*  DIVK:			EQU     81H
040550             0039*  EORK:			EQU     82H
040550             0040*  MODK:			EQU     83H
040550             0041*  ORK:			EQU     84H
040550             0042*  ; --- End eval.asm ---
040550             0043*  
040550             0044*  ; --- Begin exec.asm ---
040550             0045*  ; --- End exec.asm ---
040550             0046*  
040550             0047*  ; --- Begin fpp.asm ---
040550             0048*  BADOP:			EQU     1               ;Bad operation code
040550             0049*  DIVBY0:			EQU     18              ;Division by zero
040550             0050*  TOOBIG_FP:			EQU     20              ;Too big
040550             0051*  NGROOT:			EQU     21              ;Negative root
040550             0052*  LOGRNG:			EQU     22              ;Log range
040550             0053*  ACLOST:			EQU     23              ;Accuracy lost
040550             0054*  EXPRNG:			EQU     24              ;Exp range
040550             0055*  ; --- End fpp.asm ---
040550             0056*  
040550             0057*  ; --- Begin init.asm ---
040550             0058*  ; --- End init.asm ---
040550             0059*  
040550             0060*  ; --- Begin main.asm ---
040550             0061*  DATA_:	EQU     DCH
040550             0062*  DEF_:	EQU     DDH
040550             0063*  DIM:	EQU     DEH
040550             0064*  ELSE_:	EQU     8BH
040550             0065*  FN:	EQU     A4H
040550             0066*  FOR:	EQU     E3H
040550             0067*  GOSUB:	EQU     E4H
040550             0068*  GOTO:	EQU     E5H
040550             0069*  LINE_:	EQU     86H
040550             0070*  LINO:	EQU     8DH
040550             0071*  LOCAL_:	EQU     EAH
040550             0072*  NEXT:	EQU     EDH
040550             0073*  OFF_:	EQU     87H
040550             0074*  ON_:	EQU     EEH
040550             0075*  PROC:	EQU     F2H
040550             0076*  REM:	EQU     F4H
040550             0077*  REN:	EQU     CCH
040550             0078*  REPEAT:	EQU     F5H
040550             0079*  RESTOR:	EQU     F7H
040550             0080*  SPC:	EQU     89H
040550             0081*  STEP:	EQU     88H
040550             0082*  TAB:	EQU     8AH
040550             0083*  TAND:	EQU     80H
040550             0084*  TCALL:	EQU     D6H
040550             0085*  TERROR:	EQU     85H
040550             0086*  TGOSUB:	EQU     E4H
040550             0087*  TGOTO:	EQU     E5H
040550             0088*  THEN:	EQU     8CH
040550             0089*  TIF:	EQU     E7H
040550             0090*  TO:	EQU     B8H
040550             0091*  TON:	EQU     EEH
040550             0092*  TOR:	EQU     84H
040550             0093*  TPROC:	EQU     F2H
040550             0094*  TRACE:	EQU     FCH
040550             0095*  TSTOP:	EQU     FAH
040550             0096*  UNTIL:	EQU     FDH
040550             0097*  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040550             0098*  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040550             0099*  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040550             0100*  ; --- End main.asm ---
040550             0006       include "main.asm"
040550             0001*  ;
040550             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040550             0003*  ;		Command, Error and Lexical Analysis Module - "MAIN"
040550             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
040550             0005*  ; Modified By:	Dean Belfield
040550             0006*  ; Created:	12/05/2023
040550             0007*  ; Last Updated:	26/11/2023
040550             0008*  ;
040550             0009*  ; Modinfo:
040550             0010*  ; 07/05/1984:	Version 2.3
040550             0011*  ; 01/03/1987:	Version 3.0
040550             0012*  ; 03/05/2022:	Modified by Dean Belfield
040550             0013*  ; 06/06/2023:	Modified to run in ADL mode
040550             0014*  ; 26/06/2023:	Fixed binary and unary indirection
040550             0015*  ; 17/08/2023:	Added binary constants
040550             0016*  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
040550             0017*  ; 26/11/2023:	Fixed bug in AUTOLOAD
040550             0018*  
040550             0019*  			; .ASSUME	ADL = 1
040550             0020*  
040550             0021*  			; INCLUDE	"equs.inc"
040550             0022*  
040550             0023*  			; SEGMENT CODE
040550             0024*  
040550             0025*  			; XDEF	_main
040550             0026*  
040550             0027*  			; XDEF	COLD
040550             0028*  			; XDEF	WARM
040550             0029*  			; XDEF	CLOOP
040550             0030*  			; XDEF	DELETE
040550             0031*  			; XDEF	LIST_
040550             0032*  			; XDEF	RENUM
040550             0033*  			; XDEF	AUTO
040550             0034*  			; XDEF	NEW
040550             0035*  			; XDEF	OLD
040550             0036*  			; XDEF	LOAD
040550             0037*  			; XDEF	SAVE
040550             0038*  			; XDEF	ERROR_
040550             0039*  			; XDEF	EXTERR
040550             0040*  			; XDEF	LOAD0
040550             0041*  			; XDEF	CLEAR
040550             0042*  			; XDEF	CRLF
040550             0043*  			; XDEF	OUTCHR
040550             0044*  			; XDEF	OUT_
040550             0045*  			; XDEF	FINDL
040550             0046*  			; XDEF	SETLIN
040550             0047*  			; XDEF	PBCDL
040550             0048*  			; XDEF	SAYLN
040550             0049*  			; XDEF	PUTVAR
040550             0050*  			; XDEF	GETVAR
040550             0051*  			; XDEF	GETDEF
040550             0052*  			; XDEF	CREATE
040550             0053*  			; XDEF	RANGE
040550             0054*  			; XDEF	LEXAN2
040550             0055*  			; XDEF	REPORT
040550             0056*  			; XDEF	TELL
040550             0057*  			; XDEF	SPACE_
040550             0058*  			; XDEF	KEYWDS
040550             0059*  			; XDEF	KEYWDL
040550             0060*  			; XDEF	ONEDIT
040550             0061*  			; XDEF	ONEDIT1
040550             0062*  			; XDEF	LISTIT
040550             0063*  			; XDEF	CLEAN
040550             0064*  
040550             0065*  			; XREF	LISTON
040550             0066*  			; XREF	ERRTXT
040550             0067*  			; XREF	OSINIT
040550             0068*  			; XREF	HIMEM
040550             0069*  			; XREF	PAGE_
040550             0070*  			; XREF	CHAIN0
040550             0071*  			; XREF	PROMPT
040550             0072*  			; XREF	ERRTRP
040550             0073*  			; XREF	ERRLIN
040550             0074*  			; XREF	AUTONO
040550             0075*  			; XREF	LINENO
040550             0076*  			; XREF	INCREM
040550             0077*  			; XREF	OSLINE
040550             0078*  			; XREF	COUNT
040550             0079*  			; XREF	NXT
040550             0080*  			; XREF	BUFFER
040550             0081*  			; XREF	XEQ
040550             0082*  			; XREF	TOP
040550             0083*  			; XREF	EXPRI
040550             0084*  			; XREF	SEARCH
040550             0085*  			; XREF	LTRAP
040550             0086*  			; XREF	LOMEM
040550             0087*  			; XREF	DECODE
040550             0088*  			; XREF	EXPRS
040550             0089*  			; XREF	OSSAVE
040550             0090*  			; XREF	ERR
040550             0091*  			; XREF	ERL
040550             0092*  			; XREF	TRACEN
040550             0093*  			; XREF	RESET
040550             0094*  			; XREF	OSSHUT
040550             0095*  			; XREF	OSLOAD
040550             0096*  			; XREF	FREE
040550             0097*  			; XREF	DYNVAR
040550             0098*  			; XREF	FILL
040550             0099*  			; XREF	OSWRCH
040550             0100*  			; XREF	WIDTH
040550             0101*  			; XREF	COMMA
040550             0102*  			; XREF	MUL16
040550             0103*  			; XREF	BRAKET
040550             0104*  			; XREF	X4OR5
040550             0105*  			; XREF	LOADN
040550             0106*  			; XREF	SFIX
040550             0107*  			; XREF	ITEMI
040550             0108*  			; XREF	FNPTR
040550             0109*  			; XREF	PROPTR
040550             0110*  			; XREF	CHECK
040550             0111*  			; XREF	TERMQ
040550             0112*  			; XREF	OSWRCHCH
040550             0113*  			; XREF	NEWIT
040550             0114*  			; XREF	BAD
040550             0115*  			; XREF	RAM_START
040550             0116*  			; XREF	RAM_END
040550             0117*  			; XREF	R0
040550             0118*  			; XREF	STAR_VERSION
040550             0119*  
040550             0120*  			; XREF	_end			; In init.asm
040550             0121*  
040550             0122*  ;
040550             0123*  ; This defines the block of tokens that are pseudo-variables.
040550             0124*  ; There are two versions of each token, a GET and a SET
040550             0125*  
040550             0126*  ; Name  : GET : SET
040550             0127*  ; ------:-----:----
040550             0128*  ; PTR   : 8Fh : CFh
040550             0129*  ; PAGE  : 90h : D0h
040550             0130*  ; TIME  : 91h : D1h
040550             0131*  ; LOMEM : 92h : D2h
040550             0132*  ; HIMEM : 93h : D3h
040550             0133*  ;
040550             0134*  ; Examples:
040550             0135*  ;   LET A% = PAGE : REM This is the GET version
040550             0136*  ;   PAGE = 40000  : REM This is the SET version
040550             0137*  ;
040550             0138*  ; TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040550             0139*  ; TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040550             0140*  ; OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040550             0141*  
040550             0142*  ; The main routine
040550             0143*  ; IXU: argv - pointer to array of parameters
040550             0144*  ;   C: argc - number of parameters
040550             0145*  ; Returns:
040550             0146*  ;  HL: Error code, or 0 if OK
040550             0147*  ;
040550 21 00 02 04 0148*  _main:			LD	HL, ACCS		; Clear the ACCS
040554 36 00       0149*  			LD	(HL), 0
040556 79          0150*  			LD	A, C
040557 FE 02       0151*  			CP	2
040559 28 2D       0152*  			JR	Z, AUTOLOAD		; 2 parameters = autoload
04055B 38 3F       0153*  			JR	C, COLD			; 1 parameter = normal start
04055D CD 69 4A 04 0154*  			CALL	STAR_VERSION
040561 CD 48 13 04 0155*  			CALL	TELL
040565 55 73 61 67 0156*  			DB	"Usage:\n\r"
       65 3A 0A 0D 
04056D 52 55 4E 20 0157*  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
040580 21 00 00 00 0158*  			LD	HL, 0			; The error code
040584 C3 68 00 04 0159*  			JP	_end
040588             0160*  ;
040588 DD 27 03    0161*  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
04058B 11 00 02 04 0162*  			LD	DE, ACCS		;  DE: Destination address
04058F 7E          0163*  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
040590 12          0164*  			LD	(DE), A			;
040591 23          0165*  			INC	HL			; Increase the source pointer
040592 1C          0166*  			INC	E			; We only need to increase E as ACCS is on a page boundary
040593 28 03       0167*  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
040595 B7          0168*  			OR	A
040596 20 F7       0169*  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
040598 1D          0170*  AUTOLOAD_2:		DEC	E
040599 3E 0D       0171*  			LD	A, CR
04059B 12          0172*  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
04059C             0173*  ;
04059C E1          0174*  COLD:			POP	HL			; Pop the return address to init off SPS
04059D E5          0175*  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04059E 21 00 04 04 0176*  			LD	HL, STAVAR		; Cold start
0405A2 F9          0177*  			LD	SP, HL
0405A3 36 0A       0178*  			LD	(HL), 10
0405A5 23          0179*  			INC	HL
0405A6 36 09       0180*  			LD	(HL),9
0405A8 CD A1 49 04 0181*  			CALL    OSINIT			; Call the machine specific OS initialisation routines
0405AC ED 53 20 05 0182*  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
0405B1 22 14 05 04 0183*  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
0405B5 3E B7       0184*  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
0405B7 32 40 05 04 0185*  			LD      (LISTON),A
0405BB 21 14 06 04 0186*  			LD      HL,NOTICE
0405BF 22 2F 05 04 0187*  			LD      (ERRTXT),HL
0405C3 CD 24 0E 04 0188*  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
0405C7 3A 00 02 04 0189*  			LD	A,(ACCS)		; Check if there is a filename in ACCS
0405CB B7          0190*  			OR	A
0405CC C2 A0 1D 04 0191*  			JP	NZ,CHAIN0		; Yes, so load and run
0405D0 CD 69 4A 04 0192*  			CALL	STAR_VERSION		;
0405D4 CD 48 13 04 0193*  			CALL    TELL			; Output the welcome message
0405D8 42 42 43 20 0194*  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
0405F6 45 5A 38 30 0195*  			db      "EZ80ASM ADL Version 0.01beta\n\r"
       41 53 4D 20 
       41 44 4C 20 
       56 65 72 73 
       69 6F 6E 20 
       30 2E 30 31 
       62 65 74 61 
       0A 0D       
040614 28 43 29 20 0196*  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
040634 0A 0D 00    0197*  			DB	"\n\r", 0
040637             0198*  ;
040637 F6          0199*  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
040638             0200*  ;
040638             0201*  ; This is the main entry point for BASIC
040638             0202*  ;
040638 37          0203*  CLOOP:			SCF				; See above - not sure why this is here!
040639 ED 7B 20 05 0204*  			LD      SP,(HIMEM)
       04          
04063E CD 1A 49 04 0205*  			CALL    PROMPT          	; Prompt user
040642 21 40 05 04 0206*  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
040646 7E          0207*  			LD      A,(HL)			; Fetch the value
040647 E6 0F       0208*  			AND     0FH             	; Bottom nibble: LISTO
040649 F6 B0       0209*  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
04064B 77          0210*  			LD      (HL),A			; Store back in
04064C ED 62       0211*  			SBC     HL,HL           	; HL: 0
04064E 22 2C 05 04 0212*  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
040652 22 35 05 04 0213*  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
040656             0214*  ;
040656 2A 29 05 04 0215*  			LD      HL,(AUTONO)		; Get the auto line number
04065A 22 23 05 04 0216*  			LD      (LINENO),HL		; Store in line number
04065E 7C          0217*  			LD      A,H			; If the auto line number is zero then
04065F B5          0218*  			OR      L
040660 28 1E       0219*  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
040662             0220*  ;
040662             0221*  ; This section handles auto line numbering
040662             0222*  ;
040662 E5          0223*  			PUSH    HL			; Stack the line number
040663 CD B3 0F 04 0224*  			CALL    PBCD           	 	; Output the line number
040667 E1          0225*  			POP     HL			; Pop the line number back off the stack
040668             0226*  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
040668             0227*  ;			LD      B,0			; So clear B
040668 01 00 00 00 0228*  			LD	BC, 0			; Load BC with Increment
04066C 3A 41 05 04 0229*  			LD	A,(INCREM)
040670 4F          0230*  			LD	C, A
040671 09          0231*  			ADD     HL,BC			; Add the increment to the line number
040672 DA DD 11 04 0232*  			JP      C,TOOBIG		; And error if we wrap
040676 22 29 05 04 0233*  			LD      (AUTONO),HL		; Store the new auto line number
04067A 3E 20       0234*  			LD      A,' '			; Print a space
04067C CD 07 0F 04 0235*  			CALL    OUTCHR
040680             0236*  ;
040680             0237*  ; This section invokes the line editor
040680             0238*  ;
040680 21 00 02 04 0239*  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
040684 CD 7F 48 04 0240*  			CALL    OSLINE          	; Call the line editor in MOS
040688 CD 94 06 04 0241*  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
04068C DC F7 0D 04 0242*  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
040690 C3 38 06 04 0243*  			JP      CLOOP			; Jump back to immediate mode
040694             0244*  ;
040694             0245*  ; This bit enters the line into memory
040694             0246*  ; Also called from OSLOAD_TXT
040694             0247*  ; Returns:
040694             0248*  ; F: C if a new line has been entered (CLEAN will need to be called)
040694             0249*  ;
040694 AF          0250*  ONEDIT1:		XOR     A			; Entry point after *EDIT
040695 32 3D 05 04 0251*  			LD      (COUNT),A
040699 FD 21 00 02 0252*  			LD      IY,ACCS
       04          
04069E CD B1 11 04 0253*  			CALL    LINNUM			; HL: The line number from the input buffer
0406A2 CD BD 1C 04 0254*  			CALL    NXT			; Skip spaces
0406A6 7C          0255*  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0406A7 B5          0256*  			OR      L
0406A8 28 04       0257*  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0406AA 22 23 05 04 0258*  			LD      (LINENO),HL		; Otherwise store it
0406AE             0259*  ;
0406AE             0260*  ; This bit does the lexical analysis and tokenisation
0406AE             0261*  ;
0406AE 0E 01       0262*  LNZERO:			LD	C,1			; Left mode
0406B0 11 00 03 04 0263*  			LD      DE,BUFFER		; Buffer for tokenised BASIC
0406B4 CD 57 12 04 0264*  			CALL    LEXAN2          	; Lexical analysis on the user input
0406B8 12          0265*  			LD      (DE),A          	; Terminator
0406B9 AF          0266*  			XOR     A
0406BA             0267*  ;			LD      B,A
0406BA             0268*  ;			LD      C,E             	; BC: Line length
0406BA 01 00 00 00 0269*  			LD	BC,0
0406BE 4B          0270*  			LD	C,E			; BC: Line length
0406BF 13          0271*  			INC     DE
0406C0 12          0272*  			LD      (DE),A          	; Zero next
0406C1 2A 23 05 04 0273*  			LD      HL,(LINENO)		; Get the line number
0406C5 7C          0274*  			LD      A,H			; Is it zero, i.e. a command with no line number?
0406C6 B5          0275*  			OR      L
0406C7 FD 21 00 03 0276*  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
0406CC CA E3 1D 04 0277*  			JP      Z,XEQ           	; Execute it
0406D0             0278*  ;
0406D0             0279*  ; This section stores the BASIC line in memory
0406D0             0280*  ;
0406D0 C5          0281*  			PUSH    BC
0406D1 E5          0282*  			PUSH    HL
0406D2 CD 03 0E 04 0283*  			CALL    SETTOP          	; Set TOP sysvar
0406D6 E1          0284*  			POP     HL
0406D7 CD 47 0F 04 0285*  			CALL    FINDL			; Find the address of the line
0406DB CC BA 0D 04 0286*  			CALL    Z,DEL			; Delete the existing line if found
0406DF C1          0287*  			POP     BC
0406E0 79          0288*  			LD      A,C			; Check for the line length being zero, i.e.
0406E1 B7          0289*  			OR      A			; the user has just entered a line number in the command line
0406E2 C8          0290*  			RET	Z 	         	; If so, then don't do anything else
0406E3 C6 04       0291*  			ADD     A,4
0406E5 4F          0292*  			LD      C,A             	; Length inclusive
0406E6 D5          0293*  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0406E7 C5          0294*  			PUSH    BC              	; BC: Line length
0406E8 EB          0295*  			EX      DE,HL			; DE: Address of the line in memory
0406E9 2A 17 05 04 0296*  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0406ED E5          0297*  			PUSH    HL			; Stack TOP (current TOP value)
0406EE 09          0298*  			ADD     HL,BC			; Add the line length to HL, the new TOP value
0406EF E5          0299*  			PUSH    HL			; Stack HL (new TOP value)
0406F0 24          0300*  			INC     H			; Add 256 to HL
0406F1 AF          0301*  			XOR     A
0406F2 ED 72       0302*  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0406F4 E1          0303*  			POP     HL			; Pop HL (new TOP value)
0406F5 D2 18 0D 04 0304*  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0406F9 22 17 05 04 0305*  			LD      (TOP),HL		; Store new value of TOP
0406FD E3          0306*  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0406FE E5          0307*  			PUSH    HL			; PUSH current TOP value
0406FF 23          0308*  			INC     HL
040700 B7          0309*  			OR      A
040701 ED 52       0310*  			SBC     HL,DE			; DE: Address of the line in memory
040703 44          0311*  			LD      B,H             	; BC: Amount to move
040704 4D          0312*  			LD      C,L
040705 E1          0313*  			POP     HL			; HL: Destination (current TOP value)
040706 D1          0314*  			POP     DE			; DE: Source (new TOP value)
040707 28 02       0315*  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
040709 ED B8       0316*  			LDDR                    	; Otherwise, make space for the new line in the program
04070B C1          0317*  ATEND:			POP     BC              	; BC: Line length
04070C D1          0318*  			POP     DE              	; DE: Line number
04070D 23          0319*  			INC     HL			; HL: Destination address
04070E 71          0320*  			LD      (HL),C          	; Store length
04070F 23          0321*  			INC     HL
040710 73          0322*  			LD      (HL),E          	; Store line number
040711 23          0323*  			INC     HL
040712 72          0324*  			LD      (HL),D
040713 23          0325*  			INC     HL
040714 11 00 03 04 0326*  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
040718 EB          0327*  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
040719 0D          0328*  			DEC     C			; Subtract 3 from the number of bytes to copy to
04071A 0D          0329*  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
04071B 0D          0330*  			DEC     C
04071C ED B0       0331*  			LDIR                    	; Add the line to the BASIC program
04071E 37          0332*  			SCF				; To flag we need to call CLEAN
04071F C9          0333*  			RET
040720             0334*  ;
040720             0335*  ; List of tokens and keywords. If a keyword is followed by 0 then
040720             0336*  ; it will only match with the keyword followed immediately by
040720             0337*  ; a delimiter
040720             0338*  ;
040720 80 41 4E 44 0339*  KEYWDS:			DB    80H, "AND"
040724 94 41 42 53 0340*  			DB    94H, "ABS"
040728 95 41 43 53 0341*  			DB    95H, "ACS"
04072C 96 41 44 56 0342*  			DB    96H, "ADVAL"
       41 4C       
040732 97 41 53 43 0343*  			DB    97H, "ASC"
040736 98 41 53 4E 0344*  			DB    98H, "ASN"
04073A 99 41 54 4E 0345*  			DB    99H, "ATN"
04073E C6 41 55 54 0346*  			DB    C6H, "AUTO"
       4F          
040743 9A 42 47 45 0347*  			DB    9AH, "BGET", 0
       54 00       
040749 D5 42 50 55 0348*  			DB    D5H, "BPUT", 0
       54 00       
04074F FB 43 4F 4C 0349*  			DB    FBH, "COLOUR"
       4F 55 52    
040756 FB 43 4F 4C 0350*  			DB    FBH, "COLOR"
       4F 52       
04075C D6 43 41 4C 0351*  			DB    D6H, "CALL"
       4C          
040761 D7 43 48 41 0352*  			DB    D7H, "CHAIN"
       49 4E       
040767 BD 43 48 52 0353*  			DB    BDH, "CHR$"
       24          
04076C D8 43 4C 45 0354*  			DB    D8H, "CLEAR", 0
       41 52 00    
040773 D9 43 4C 4F 0355*  			DB    D9H, "CLOSE", 0
       53 45 00    
04077A DA 43 4C 47 0356*  			DB    DAH, "CLG", 0
       00          
04077F DB 43 4C 53 0357*  			DB    DBH, "CLS", 0
       00          
040784 9B 43 4F 53 0358*  			DB    9BH, "COS"
040788 9C 43 4F 55 0359*  			DB    9CH, "COUNT", 0
       4E 54 00    
04078F DC 44 41 54 0360*  			DB    DCH, "DATA"
       41          
040794 9D 44 45 47 0361*  			DB    9DH, "DEG"
040798 DD 44 45 46 0362*  			DB    DDH, "DEF"
04079C C7 44 45 4C 0363*  			DB    C7H, "DELETE"
       45 54 45    
0407A3 81 44 49 56 0364*  			DB    81H, "DIV"
0407A7 DE 44 49 4D 0365*  			DB    DEH, "DIM"
0407AB DF 44 52 41 0366*  			DB    DFH, "DRAW"
       57          
0407B0 E1 45 4E 44 0367*  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
0407B9 E0 45 4E 44 0368*  			DB    E0H, "END", 0
       00          
0407BE E2 45 4E 56 0369*  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
0407C7 8B 45 4C 53 0370*  			DB    8BH, "ELSE"
       45          
0407CC A0 45 56 41 0371*  			DB    A0H, "EVAL"
       4C          
0407D1 9E 45 52 4C 0372*  			DB    9EH, "ERL", 0
       00          
0407D6 85 45 52 52 0373*  			DB    85H, "ERROR"
       4F 52       
0407DC C5 45 4F 46 0374*  			DB    C5H, "EOF", 0
       00          
0407E1 82 45 4F 52 0375*  			DB    82H, "EOR"
0407E5 9F 45 52 52 0376*  			DB    9FH, "ERR", 0
       00          
0407EA A1 45 58 50 0377*  			DB    A1H, "EXP"
0407EE A2 45 58 54 0378*  			DB    A2H, "EXT", 0
       00          
0407F3 E3 46 4F 52 0379*  			DB    E3H, "FOR"
0407F7 A3 46 41 4C 0380*  			DB    A3H, "FALSE", 0
       53 45 00    
0407FE A4 46 4E    0381*  			DB    A4H, "FN"
040801 E5 47 4F 54 0382*  			DB    E5H, "GOTO"
       4F          
040806 BE 47 45 54 0383*  			DB    BEH, "GET$"
       24          
04080B A5 47 45 54 0384*  			DB    A5H, "GET"
04080F E4 47 4F 53 0385*  			DB    E4H, "GOSUB"
       55 42       
040815 E6 47 43 4F 0386*  			DB    E6H, "GCOL"
       4C          
04081A 93 48 49 4D 0387*  			DB    93H, "HIMEM", 0
       45 4D 00    
040821 E8 49 4E 50 0388*  			DB    E8H, "INPUT"
       55 54       
040827 E7 49 46    0389*  			DB    E7H, "IF"
04082A BF 49 4E 4B 0390*  			DB    BFH, "INKEY$"
       45 59 24    
040831 A6 49 4E 4B 0391*  			DB    A6H, "INKEY"
       45 59       
040837 A8 49 4E 54 0392*  			DB    A8H, "INT"
04083B A7 49 4E 53 0393*  			DB    A7H, "INSTR("
       54 52 28    
040842 C9 4C 49 53 0394*  			DB    C9H, "LIST"
       54          
040847 86 4C 49 4E 0395*  			DB    86H, "LINE"
       45          
04084C C8 4C 4F 41 0396*  			DB    C8H, "LOAD"
       44          
040851 92 4C 4F 4D 0397*  			DB    92H, "LOMEM", 0
       45 4D 00    
040858 EA 4C 4F 43 0398*  			DB    EAH, "LOCAL"
       41 4C       
04085E C0 4C 45 46 0399*  			DB    C0H, "LEFT$("
       54 24 28    
040865 A9 4C 45 4E 0400*  			DB    A9H, "LEN"
040869 E9 4C 45 54 0401*  			DB    E9H, "LET"
04086D AB 4C 4F 47 0402*  			DB    ABH, "LOG"
040871 AA 4C 4E    0403*  			DB    AAH, "LN"
040874 C1 4D 49 44 0404*  			DB    C1H, "MID$("
       24 28       
04087A EB 4D 4F 44 0405*  			DB    EBH, "MODE"
       45          
04087F 83 4D 4F 44 0406*  			DB    83H, "MOD"
040883 EC 4D 4F 56 0407*  			DB    ECH, "MOVE"
       45          
040888 ED 4E 45 58 0408*  			DB    EDH, "NEXT"
       54          
04088D CA 4E 45 57 0409*  			DB    CAH, "NEW", 0
       00          
040892 AC 4E 4F 54 0410*  			DB    ACH, "NOT"
040896 CB 4F 4C 44 0411*  			DB    CBH, "OLD", 0
       00          
04089B EE 4F 4E    0412*  			DB    EEH, "ON"
04089E 87 4F 46 46 0413*  			DB    87H, "OFF"
0408A2 84 4F 52    0414*  			DB    84H, "OR"
0408A5 8E 4F 50 45 0415*  			DB    8EH, "OPENIN"
       4E 49 4E    
0408AC AE 4F 50 45 0416*  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0408B4 AD 4F 50 45 0417*  			DB    ADH, "OPENUP"
       4E 55 50    
0408BB FF 4F 53 43 0418*  			DB    FFH, "OSCLI"
       4C 49       
0408C1 F1 50 52 49 0419*  			DB    F1H, "PRINT"
       4E 54       
0408C7 90 50 41 47 0420*  			DB    90H, "PAGE", 0
       45 00       
0408CD 8F 50 54 52 0421*  			DB    8FH, "PTR", 0
       00          
0408D2 AF 50 49 00 0422*  			DB    AFH, "PI", 0
0408D6 F0 50 4C 4F 0423*  			DB    F0H, "PLOT"
       54          
0408DB B0 50 4F 49 0424*  			DB    B0H, "POINT("
       4E 54 28    
0408E2 F2 50 52 4F 0425*  			DB    F2H, "PROC"
       43          
0408E7 B1 50 4F 53 0426*  			DB    B1H, "POS", 0
       00          
0408EC CE 50 55 54 0427*  			DB    CEH, "PUT"
0408F0 F8 52 45 54 0428*  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0408F8 F5 52 45 50 0429*  			DB    F5H, "REPEAT"
       45 41 54    
0408FF F6 52 45 50 0430*  			DB    F6H, "REPORT", 0
       4F 52 54 00 
040907 F3 52 45 41 0431*  			DB    F3H, "READ"
       44          
04090C F4 52 45 4D 0432*  			DB    F4H, "REM"
040910 F9 52 55 4E 0433*  			DB    F9H, "RUN", 0
       00          
040915 B2 52 41 44 0434*  			DB    B2H, "RAD"
040919 F7 52 45 53 0435*  			DB    F7H, "RESTORE"
       54 4F 52 45 
040921 C2 52 49 47 0436*  			DB    C2H, "RIGHT$("
       48 54 24 28 
040929 B3 52 4E 44 0437*  			DB    B3H, "RND", 0
       00          
04092E CC 52 45 4E 0438*  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
040937 88 53 54 45 0439*  			DB    88H, "STEP"
       50          
04093C CD 53 41 56 0440*  			DB    CDH, "SAVE"
       45          
040941 B4 53 47 4E 0441*  			DB    B4H, "SGN"
040945 B5 53 49 4E 0442*  			DB    B5H, "SIN"
040949 B6 53 51 52 0443*  			DB    B6H, "SQR"
04094D 89 53 50 43 0444*  			DB    89H, "SPC"
040951 C3 53 54 52 0445*  			DB    C3H, "STR$"
       24          
040956 C4 53 54 52 0446*  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
04095F D4 53 4F 55 0447*  			DB    D4H, "SOUND"
       4E 44       
040965 FA 53 54 4F 0448*  			DB    FAH, "STOP", 0
       50 00       
04096B B7 54 41 4E 0449*  			DB    B7H, "TAN"
04096F 8C 54 48 45 0450*  			DB    8CH, "THEN"
       4E          
040974 B8 54 4F    0451*  			DB    B8H, "TO"
040977 8A 54 41 42 0452*  			DB    8AH, "TAB("
       28          
04097C FC 54 52 41 0453*  			DB    FCH, "TRACE"
       43 45       
040982 91 54 49 4D 0454*  			DB    91H, "TIME", 0
       45 00       
040988 B9 54 52 55 0455*  			DB    B9H, "TRUE", 0
       45 00       
04098E FD 55 4E 54 0456*  			DB    FDH, "UNTIL"
       49 4C       
040994 BA 55 53 52 0457*  			DB    BAH, "USR"
040998 EF 56 44 55 0458*  			DB    EFH, "VDU"
04099C BB 56 41 4C 0459*  			DB    BBH, "VAL"
0409A0 BC 56 50 4F 0460*  			DB    BCH, "VPOS", 0
       53 00       
0409A6 FE 57 49 44 0461*  			DB    FEH, "WIDTH"
       54 48       
0409AC D3 48 49 4D 0462*  			DB    D3H, "HIMEM"
       45 4D       
0409B2 D2 4C 4F 4D 0463*  			DB    D2H, "LOMEM"
       45 4D       
0409B8 D0 50 41 47 0464*  			DB    D0H, "PAGE"
       45          
0409BD CF 50 54 52 0465*  			DB    CFH, "PTR"
0409C1 D1 54 49 4D 0466*  			DB    D1H, "TIME"
       45          
0409C6             0467*  ;
0409C6             0468*  ; These are indexed from the ERRWDS table
0409C6             0469*  ;
0409C6 01 4D 69 73 0470*  			DB    01H, "Missing "
       73 69 6E 67 
       20          
0409CF 02 4E 6F 20 0471*  			DB    02H, "No such "
       73 75 63 68 
       20          
0409D8 03 42 61 64 0472*  			DB    03H, "Bad "
       20          
0409DD 04 20 72 61 0473*  			DB    04H, " range"
       6E 67 65    
0409E4 05 76 61 72 0474*  			DB    05H, "variable"
       69 61 62 6C 
       65          
0409ED 06 4F 75 74 0475*  			DB    06H, "Out of"
       20 6F 66    
0409F4 07 4E 6F 20 0476*  			DB    07H, "No "
0409F8 08 20 73 70 0477*  			DB    08H, " space"
       61 63 65    
0409FF             0478*  
0409FF             0479*  KEYWDL:			EQU     $-KEYWDS
0409FF FF FF       0480*  			DW    -1
040A01             0481*  ;
040A01             0482*  ; Error messages
040A01             0483*  ;
040A01 07 72 6F 6F 0484*  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
040A07 06 04 00    0485*  			DB    6, 4, 0			;  1: Out of range
040A0A 00          0486*  			DB    0				;  2: *
040A0B 00          0487*  			DB    0				;  3: *
040A0C 4D 69 73 74 0488*  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
040A14 01 2C 00    0489*  			DB    1, ",", 0			;  5: Missing ,
040A17 54 79 70 65 0490*  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
040A25 07 A4 00    0491*  			DB    7, FN, 0			;  7: No FN
040A28 00          0492*  			DB    0				;  8: *
040A29 01 22 00    0493*  			DB    1, 34, 0			;  9: Missing "
040A2C 03 DE 00    0494*  			DB    3, DIM, 0			; 10: Bad DIM
040A2F DE 08 00    0495*  			DB    DIM, 8, 0			; 11: DIM space
040A32 4E 6F 74 20 0496*  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
040A38 07 F2 00    0497*  			DB    7, PROC, 0		; 13: No PROC
040A3B 41 72 72 61 0498*  			DB    "Array", 0		; 14: Array
       79 00       
040A41 53 75 62 73 0499*  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
040A4B 53 79 6E 74 0500*  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
040A58 45 73 63 61 0501*  			DB    "Escape", 0		; 17: Escape
       70 65 00    
040A5F 44 69 76 69 0502*  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
040A70 53 74 72 69 0503*  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
040A80 54 6F 6F 20 0504*  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
040A88 2D 76 65 20 0505*  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
040A91 4C 6F 67 04 0506*  			DB    "Log", 4, 0		; 22: Log range
       00          
040A96 41 63 63 75 0507*  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
040AA4 45 78 70 04 0508*  			DB    "Exp", 4, 0		; 24: Exp range
       00          
040AA9 00          0509*  			DB    0				; 25: *
040AAA 02 05 00    0510*  			DB    2, 5, 0			; 26: No such variable
040AAD 01 29 00    0511*  			DB    1, ")", 0			; 27: Missing )
040AB0 03 48 45 58 0512*  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
040AB5 02 A4 2F F2 0513*  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
040ABA 03 63 61 6C 0514*  			DB    3, "call", 0		; 30: Bad call
       6C 00       
040AC0 41 72 67 75 0515*  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
040ACA 07 E3 00    0516*  			DB    7, FOR, 0			; 32: No FOR
040ACD 43 61 6E 27 0517*  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
040ADB E3 20 05 00 0518*  			DB    FOR, " ", 5, 0		; 34: FOR variable
040ADF 00          0519*  			DB    0				; 35: *
040AE0 07 B8 00    0520*  			DB    7, TO, 0			; 36: No TO
040AE3 00          0521*  			DB    0				; 37: *
040AE4 07 E4 00    0522*  			DB    7, GOSUB, 0		; 38: No GOSUB
040AE7 EE 20 73 79 0523*  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
040AF0 EE 04 00    0524*  			DB    ON_, 4, 0			; 40: ON range
040AF3 02 6C 69 6E 0525*  			DB    2, "line", 0		; 41: No such line
       65 00       
040AF9 06 20 DC 00 0526*  			DB    6, " ", DATA_, 0		; 42: Out of DATA
040AFD 07 F5 00    0527*  			DB    7, REPEAT, 0		; 43: No REPEAT
040B00 00          0528*  			DB    0				; 44: *
040B01 01 23 00    0529*  			DB    1, "#", 0			; 45: Missing #
040B04             0530*  ;
040B04             0531*  ; COMMANDS:
040B04             0532*  ;
040B04             0533*  ; DELETE line,line
040B04             0534*  ;
040B04 CD 03 0E 04 0535*  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
040B08 CD 0B 12 04 0536*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
040B0C 7E          0537*  DELET1:			LD      A,(HL)			; Check whether it's the last line
040B0D B7          0538*  			OR      A
040B0E CA 95 0B 04 0539*  			JP      Z,WARMNC		; Yes, so do nothing
040B12 23          0540*  			INC     HL			; Skip the line length byte
040B13 11 00 00 00 0541*  			LD	DE, 0			; Clear DE
040B17 5E          0542*  			LD      E,(HL)			; Fetch the line number in DE
040B18 23          0543*  			INC     HL
040B19 56          0544*  			LD      D,(HL)
040B1A 7A          0545*  			LD      A,D			; If the line number is zero then
040B1B B3          0546*  			OR      E
040B1C 28 1D       0547*  			JR      Z,CLOOP1        	; Do nothing
040B1E 2B          0548*  			DEC     HL			; Decrement BASIC program pointer back to length
040B1F 2B          0549*  			DEC     HL
040B20 EB          0550*  			EX      DE,HL			; Check if we've gone past the terminating line
040B21 37          0551*  			SCF
040B22 ED 42       0552*  			SBC     HL,BC
040B24 EB          0553*  			EX      DE,HL
040B25 30 6E       0554*  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
040B27 C5          0555*  			PUSH    BC
040B28 CD BA 0D 04 0556*  			CALL    DEL			; Delete the line pointed to by HL
040B2C C1          0557*  			POP     BC
040B2D 18 DD       0558*  			JR      DELET1			; And loop round to the next line
040B2F             0559*  ;
040B2F             0560*  ; LISTO expr
040B2F             0561*  ;
040B2F FD 23       0562*  LISTO:			INC     IY              	; Skip "O" byte
040B31 CD 54 15 04 0563*  			CALL    EXPRI			; Get expr
040B35 D9          0564*  			EXX
040B36 7D          0565*  			LD      A,L
040B37 32 40 05 04 0566*  			LD      (LISTON),A		; Store in LISTON sysvar
040B3B C3 38 06 04 0567*  CLOOP1:			JP      CLOOP
040B3F             0568*  ;
040B3F             0569*  ; LIST
040B3F             0570*  ; LIST line
040B3F             0571*  ; LIST line,line [IF string]
040B3F             0572*  ; LIST ,line
040B3F             0573*  ; LIST line,
040B3F             0574*  ;
040B3F FE 4F       0575*  LIST_:			CP      'O'			; Check for O (LISTO)
040B41 28 EC       0576*  			JR      Z,LISTO			; and jump to LISTO if zero
040B43 CD 0B 12 04 0577*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
040B47 CD BD 1C 04 0578*  			CALL    NXT			; Skip space
040B4B FE E7       0579*  			CP      TIF             	; Check for IF clause (token IF)
040B4D 3E 00       0580*  			LD      A,0             	; Initialise the IF clause string length
040B4F 20 17       0581*  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
040B51             0582*  ;
040B51 FD 23       0583*  			INC     IY              	; Skip the IF token
040B53 CD BD 1C 04 0584*  			CALL    NXT             	; And skip any spaces
040B57 EB          0585*  			EX      DE,HL			; DE: Address in memory
040B58 FD E5       0586*  			PUSH    IY			; LD IY, HL
040B5A E1          0587*  			POP     HL              	; HL is now the address of the tokenised line
040B5B 3E 0D       0588*  			LD      A,CR
040B5D C5          0589*  			PUSH    BC			; Stack the second line number arg
040B5E 01 00 01 00 0590*  			LD      BC,256
040B62 ED B1       0591*  			CPIR                    	; Locate CR byte
040B64 79          0592*  			LD      A,C
040B65 2F          0593*  			CPL                    	 	; A: Substring length (of IF clause)
040B66 C1          0594*  			POP     BC			; Restore the second line number arg
040B67 EB          0595*  			EX      DE,HL			; HL: Address in memory
040B68             0596*  ;
040B68 5F          0597*  LISTB:			LD      E,A             	; E: IF clause string length
040B69 78          0598*  			LD      A,B			; Check whether a second line number was passed (BC!=0)
040B6A B1          0599*  			OR      C
040B6B 20 01       0600*  			JR      NZ,LISTA		; If there isn't a second line number
040B6D 0B          0601*  			DEC     BC			; then we set it to the maximum of 65535
040B6E             0602*  ;
040B6E D9          0603*  LISTA:			EXX
040B6F DD 21 40 05 0604*  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
040B74 01 00 00 00 0605*  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
040B78 D9          0606*  			EXX
040B79 3E 14       0607*  			LD      A,20			; Number of lines to list
040B7B             0608*  ;
040B7B C5          0609*  LISTC:			PUSH    BC              	; Save second line number
040B7C D5          0610*  			PUSH    DE              	; Save IF clause length
040B7D E5          0611*  			PUSH    HL              	; Save BASIC program counter
040B7E 08          0612*  			EX      AF,AF'
040B7F             0613*  ;
040B7F             0614*  ; BBC BASIC for Z80 lines are stored as follows:
040B7F             0615*  ;
040B7F             0616*  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
040B7F             0617*  ; - [&00] [&FF] [&FF]: End of program marker
040B7F             0618*  ;
040B7F             0619*  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
040B7F             0620*  ;
040B7F 7E          0621*  			LD      A,(HL)			; Check for end of program marker
040B80 B7          0622*  			OR      A			; If found
040B81 28 12       0623*  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
040B83             0624*  ;
040B83             0625*  ; Check if past terminating line number
040B83             0626*  ;
040B83 7B          0627*  			LD      A,E             	; A: IF clause length
040B84 23          0628*  			INC     HL			; Skip the length byte
040B85 11 00 00 00 0629*  			LD	DE,0			; Clear DE
040B89 5E          0630*  			LD      E,(HL)			; Fetch the line number in DE
040B8A 23          0631*  			INC     HL
040B8B 56          0632*  			LD      D,(HL)
040B8C 2B          0633*  			DEC     HL			; Step HL back to the length byte
040B8D 2B          0634*  			DEC     HL
040B8E D5          0635*  			PUSH    DE             	 	; Push the line number on the stack
040B8F EB          0636*  			EX      DE,HL			; HL: line number
040B90 37          0637*  			SCF				; Do a 16-bit compare of HL and DE
040B91 ED 42       0638*  			SBC     HL,BC
040B93 EB          0639*  			EX      DE,HL
040B94 D1          0640*  			POP     DE              	; Restore the line number
040B95 D2 37 06 04 0641*  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
040B99 4E          0642*  			LD      C,(HL)          	; C: Line length + 4
040B9A 47          0643*  			LD      B,A             	; B: IF clause length
040B9B             0644*  ;
040B9B             0645*  ; Check if "UNLISTABLE":
040B9B             0646*  ;
040B9B 7A          0647*  			LD      A,D			; TODO: What is "UNLISTABLE?"
040B9C B3          0648*  			OR      E
040B9D CA 38 06 04 0649*  			JP      Z,CLOOP
040BA1             0650*  ;
040BA1             0651*  ; Check for IF clause:
040BA1             0652*  ;
040BA1 23          0653*  			INC     HL			; Skip the length
040BA2 23          0654*  			INC     HL			; Skip the line number
040BA3 23          0655*  			INC     HL              	; HL: Address of the tokenised BASIC line
040BA4 0D          0656*  			DEC     C			;  C: Line length
040BA5 0D          0657*  			DEC     C
040BA6 0D          0658*  			DEC     C
040BA7 0D          0659*  			DEC     C
040BA8 D5          0660*  			PUSH    DE              	; Save the line number
040BA9 E5          0661*  			PUSH    HL              	; Save the BASIC program address
040BAA AF          0662*  			XOR     A               	;
040BAB B8          0663*  			CP      B              	 	; Check for an IF clause (B!=0)
040BAC FD E5       0664*  			PUSH    IY			; LD IY, DE
040BAE D1          0665*  			POP     DE              	; DE: Address of the IF clause string in the input buffer
040BAF C4 CF 19 04 0666*  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
040BB3 E1          0667*  			POP     HL              	; Restore BASIC program address
040BB4 D1          0668*  			POP     DE              	; Restore line number
040BB5 FD E5       0669*  			PUSH    IY
040BB7 CC 4A 0E 04 0670*  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
040BBB FD E1       0671*  			POP     IY
040BBD             0672*  ;
040BBD 08          0673*  			EX      AF,AF'
040BBE 3D          0674*  			DEC     A			; Decrement line list counter
040BBF CD 91 49 04 0675*  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
040BC3 E1          0676*  			POP     HL             	 	; Restore BASIC program address to beginning of line
040BC4 11 00 00 00 0677*  			LD	DE,0
040BC8 5E          0678*  			LD      E,(HL)			; Fetch the length of line in DE
040BC9 19          0679*  			ADD     HL,DE           	; Go to the next line
040BCA D1          0680*  			POP     DE              	; Restore IF clause length
040BCB C1          0681*  			POP     BC              	; Restore second line number
040BCC 18 AD       0682*  			JR      LISTC			; Loop back to do next line
040BCE             0683*  ;
040BCE             0684*  ; RENUMBER
040BCE             0685*  ; RENUMBER start
040BCE             0686*  ; RENUMBER start,increment
040BCE             0687*  ; RENUMBER ,increment
040BCE             0688*  ;
040BCE CD 2E 0E 04 0689*  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
040BD2 CD E3 11 04 0690*  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
040BD6 D9          0691*  			EXX
040BD7 2A 14 05 04 0692*  			LD      HL,(PAGE_)		; HL: Top of program
040BDB ED 5B 1A 05 0693*  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
040BE0             0694*  ;
040BE0             0695*  ; Build the table
040BE0             0696*  ;
040BE0 7E          0697*  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
040BE1 B7          0698*  			OR      A			; Is it zero, i.e. the end of program marker?
040BE2 28 36       0699*  			JR      Z,RENUM2		; Yes, so skip to the next part
040BE4 23          0700*  			INC     HL
040BE5 4E          0701*  			LD      C,(HL)          	; BC: The OLD line number
040BE6 23          0702*  			INC     HL
040BE7 46          0703*  			LD      B,(HL)
040BE8 78          0704*  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
040BE9 B1          0705*  			OR      C
040BEA CA 38 06 04 0706*  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
040BEE EB          0707*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
040BEF 71          0708*  			LD      (HL),C			; Store the OLD line number in the heap
040BF0 23          0709*  			INC     HL
040BF1 70          0710*  			LD      (HL),B
040BF2 23          0711*  			INC     HL
040BF3 D9          0712*  			EXX				; HL: line number, BC: increment (16-bit values)
040BF4 E5          0713*  			PUSH    HL			; HL: Stack the NEW line number value
040BF5 52 09       0714*  			ADD.S   HL,BC           	; Add the increment
040BF7 DA DD 11 04 0715*  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
040BFB D9          0716*  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
040BFC C1          0717*  			POP     BC			; BC: Pop the NEW line number value off the stack
040BFD 71          0718*  			LD      (HL),C			; Store the NEW line number in the heap
040BFE 23          0719*  			INC     HL
040BFF 70          0720*  			LD      (HL),B
040C00 23          0721*  			INC     HL
040C01 EB          0722*  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
040C02 2B          0723*  			DEC     HL			; Back up to the line length byte
040C03 2B          0724*  			DEC     HL
040C04 01 00 00 00 0725*  			LD	BC, 0
040C08 4E          0726*  			LD      C,(HL)			; BC: Line length
040C09 09          0727*  			ADD	HL,BC           	; Advance HL to next line
040C0A EB          0728*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
040C0B E5          0729*  			PUSH    HL
040C0C 24          0730*  			INC     H			; Increment to next page
040C0D ED 72       0731*  			SBC     HL,SP			; Subtract from SP
040C0F E1          0732*  			POP     HL
040C10 EB          0733*  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
040C11 38 CD       0734*  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
040C13 CD 2F 0D 04 0735*  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
040C17 CC          0736*  			DB    	REN
040C18 08          0737*  			DB    	8
040C19 00          0738*  			DB    	0
040C1A             0739*  ;
040C1A             0740*  ; At this point a list of BASIC line numbers have been written to the heap
040C1A             0741*  ; as word pairs:
040C1A             0742*  ; - DW: The OLD line number
040C1A             0743*  ; - DW: The NEW line number
040C1A             0744*  ;
040C1A EB          0745*  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
040C1B 36 FF       0746*  			LD      (HL),-1			; Mark the end with FFFFh
040C1D 23          0747*  			INC     HL
040C1E 36 FF       0748*  			LD      (HL),-1
040C20 ED 5B 1A 05 0749*  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
040C25 D9          0750*  			EXX
040C26 2A 14 05 04 0751*  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
040C2A 4E          0752*  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
040C2B 79          0753*  			LD      A,C			; If it is zero, then no program, so...
040C2C B7          0754*  			OR      A
040C2D CA 37 06 04 0755*  			JP      Z,WARM			; Jump to warm start
040C31 D9          0756*  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
040C32 EB          0757*  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
040C33 23          0758*  			INC     HL			; Skip to the NEW line number
040C34 23          0759*  			INC     HL
040C35 5E          0760*  			LD      E,(HL)			; DE: The NEW line number
040C36 23          0761*  			INC     HL
040C37 56          0762*  			LD      D,(HL)
040C38 23          0763*  			INC     HL
040C39 D5          0764*  			PUSH    DE			; Stack the NEW line number
040C3A EB          0765*  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
040C3B 22 23 05 04 0766*  			LD      (LINENO),HL		; Store the line number in LINENO
040C3F D9          0767*  			EXX				; HL: Pointer to the BASIC program area
040C40 D1          0768*  			POP     DE			; DE: The NEW line number
040C41 23          0769*  			INC     HL
040C42 73          0770*  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
040C43 23          0771*  			INC     HL
040C44 72          0772*  			LD      (HL),D
040C45 23          0773*  			INC     HL
040C46 0D          0774*  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
040C47 0D          0775*  			DEC     C
040C48 0D          0776*  			DEC     C
040C49 79          0777*  			LD	A,C
040C4A 01 00 00 00 0778*  			LD	BC,0
040C4E 4F          0779*  			LD	C,A			; BC: Line length
040C4F             0780*  ;
040C4F 3E 8D       0781*  RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
040C51 ED B1       0782*  			CPIR                    	; Search for the token
040C53 20 D5       0783*  			JR      NZ,RENUM3		; If not found, then loop to process the next line
040C55             0784*  ;
040C55             0785*  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
040C55             0786*  ;
040C55 C5          0787*  			PUSH    BC			; Stack everything
040C56 E5          0788*  			PUSH    HL
040C57 E5          0789*  			PUSH    HL			; HL: Pointer to encoded line number
040C58 FD E1       0790*  			POP     IY			; IY: Pointer to encoded line number
040C5A D9          0791*  			EXX
040C5B CD 30 1B 04 0792*  			CALL    DECODE			; Decode the encoded line number (in HL')
040C5F D9          0793*  			EXX				; HL: Decoded line number
040C60 44          0794*  			LD      B,H			; BC: Decoded line number
040C61 4D          0795*  			LD      C,L
040C62 2A 1A 05 04 0796*  			LD      HL,(LOMEM)		; HL: Pointer to heap
040C66             0797*  ;
040C66             0798*  ; This section of code cross-references the decoded (OLD) line number with the list
040C66             0799*  ; created previously in the global heap
040C66             0800*  ;
040C66 5E          0801*  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
040C67 23          0802*  			INC     HL
040C68 56          0803*  			LD      D,(HL)
040C69 23          0804*  			INC     HL
040C6A EB          0805*  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
040C6B B7          0806*  			OR      A               	; Clear the carry and...
040C6C 52 ED 42    0807*  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
040C6F EB          0808*  			EX      DE,HL			; HL: Pointer in the global heap
040C70 5E          0809*  			LD      E,(HL)          	; DE: The NEW line number
040C71 23          0810*  			INC     HL
040C72 56          0811*  			LD      D,(HL)
040C73 23          0812*  			INC     HL
040C74 38 F0       0813*  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
040C76 EB          0814*  			EX      DE,HL			; DE: Pointer in the global heap
040C77 28 1D       0815*  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
040C79             0816*  ;
040C79 CD 48 13 04 0817*  			CALL    TELL			; Display this error if the line number is not found
040C7D 46 61 69 6C 0818*  			DB    	"Failed at "
       65 64 20 61 
       74 20       
040C87 00          0819*  			DB    	0
040C88 2A 23 05 04 0820*  			LD      HL,(LINENO)
040C8C CD AF 0F 04 0821*  			CALL    PBCDL
040C90 CD FF 0E 04 0822*  			CALL    CRLF
040C94 18 07       0823*  			JR      RENUM6			; And carry on renumbering
040C96             0824*  ;
040C96             0825*  ; This snippet re-encodes the line number in the BASIC program
040C96             0826*  ;
040C96 D1          0827*  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
040C97 D5          0828*  			PUSH    DE
040C98 1B          0829*  			DEC     DE			; Back up a byte to the LINO token
040C99 CD 14 13 04 0830*  			CALL    ENCODE          	; Re-write the new line number out
040C9D E1          0831*  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
040C9E C1          0832*  			POP     BC			; BC: The remaining line length
040C9F 18 AE       0833*  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
040CA1             0834*  ;
040CA1             0835*  ; AUTO
040CA1             0836*  ; AUTO start,increment
040CA1             0837*  ; AUTO start
040CA1             0838*  ; AUTO ,increment
040CA1             0839*  ;
040CA1 CD E3 11 04 0840*  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
040CA5 22 29 05 04 0841*  			LD      (AUTONO),HL		; Store the start in AUTONO
040CA9 79          0842*  			LD      A,C			; Increment is 8 bit (0-255)
040CAA 32 41 05 04 0843*  			LD      (INCREM),A		; Store that in INCREM
040CAE 18 2E       0844*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
040CB0             0845*  ;
040CB0             0846*  ; BAD
040CB0             0847*  ; NEW
040CB0             0848*  ;
040CB0 CD 48 13 04 0849*  BAD:			CALL    TELL            	; Output "Bad program" error
040CB4 03          0850*  			DB    3				; Token for "BAD"
040CB5 70 72 6F 67 0851*  			DB    "program"
       72 61 6D    
040CBC 0D          0852*  			DB    CR
040CBD 0A          0853*  			DB    LF
040CBE 00          0854*  			DB    0				; Falls through to NEW
040CBF             0855*  ;
040CBF CD 24 0E 04 0856*  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
040CC3 18 19       0857*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
040CC5             0858*  ;
040CC5             0859*  ; OLD
040CC5             0860*  ;
040CC5 2A 14 05 04 0861*  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
040CC9 E5          0862*  			PUSH    HL			; Stack it
040CCA 23          0863*  			INC     HL			; Skip the potential length byte of first line of code
040CCB 23          0864*  			INC     HL			; And the line number word
040CCC 23          0865*  			INC     HL
040CCD 01 FC 00 00 0866*  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
040CD1 3E 0D       0867*  			LD      A,CR
040CD3 ED B1       0868*  			CPIR
040CD5 20 D9       0869*  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
040CD7 7D          0870*  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
040CD8 E1          0871*  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
040CD9 77          0872*  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
040CDA CD F7 0D 04 0873*  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
040CDE C3 38 06 04 0874*  CLOOP0:			JP      CLOOP			; Jump back to the command loop
040CE2             0875*  ;
040CE2             0876*  ; LOAD filename
040CE2             0877*  ;
040CE2 CD 5F 15 04 0878*  LOAD:			CALL    EXPRS           	; Get the filename
040CE6 3E 0D       0879*  			LD      A,CR			; DE points to the last byte of filename in ACCS
040CE8 12          0880*  			LD      (DE),A			; Terminate filename with a CR
040CE9 CD D7 0D 04 0881*  			CALL    LOAD0			; Load the file in, then CLEAN
040CED CD 2E 0E 04 0882*  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
040CF1 18 21       0883*  			JR      WARM0			; Jump back to the command loop
040CF3             0884*  ;
040CF3             0885*  ; SAVE filename
040CF3             0886*  ;
040CF3 CD 03 0E 04 0887*  SAVE:			CALL    SETTOP          	; Set TOP sysvar
040CF7 CD 5F 15 04 0888*  			CALL    EXPRS           	; Get the filename
040CFB 3E 0D       0889*  			LD      A,CR			; Terminate the filename with a CR
040CFD 12          0890*  			LD      (DE),A
040CFE ED 5B 14 05 0891*  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
040D03 2A 17 05 04 0892*  			LD      HL,(TOP)		; HL: Top of program memory
040D07 B7          0893*  			OR      A			; Calculate program size (TOP-PAGE)
040D08 ED 52       0894*  			SBC     HL,DE
040D0A 44          0895*  			LD      B,H             	; BC: Length of program in bytes
040D0B 4D          0896*  			LD      C,L
040D0C 21 00 02 04 0897*  			LD      HL,ACCS			; HL: Address of the filename
040D10 CD 5E 4C 04 0898*  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
040D14 C3 37 06 04 0899*  WARM0:			JP      WARM			; Jump back to the command loop
040D18             0900*  
040D18             0901*  ;
040D18             0902*  ; ERROR
040D18             0903*  ; Called whenever BASIC needs to halt with an error
040D18             0904*  ; Error messages are indexed from 0
040D18             0905*  ; Inputs:
040D18             0906*  ;  A: Error number
040D18             0907*  ;
040D18 ED 7B 20 05 0908*  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
040D1D 21 01 0A 04 0909*  			LD      HL,ERRWDS		; Index into the error string table
040D21 B7          0910*  			OR      A			; We don't need to search for the first error
040D22 28 0A       0911*  			JR      Z,ERROR1		; So skip the search routine
040D24             0912*  ;
040D24             0913*  ; Search the error table for error #A
040D24             0914*  ; HL will end up being the pointer into the correct error
040D24             0915*  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
040D24             0916*  ;
040D24 47          0917*  			LD      B,A             	; Store error number in B
040D25 08          0918*  			EX      AF,AF'			; Store error number in AF'
040D26 AF          0919*  			XOR     A
040D27 BE          0920*  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
040D28 23          0921*  			INC     HL			; Increment the string pointer
040D29 20 FC       0922*  			JR      NZ,ERROR0		; Loop until with hit a 0
040D2B 10 FA       0923*  			DJNZ    ERROR0			; Decrements the error number and loop until 0
040D2D 08          0924*  			EX      AF,AF'			; Restore the error number from AF'
040D2E             0925*  ;
040D2E             0926*  ; At this point HL points to the tokenised error string
040D2E             0927*  ;
040D2E E5          0928*  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
040D2F             0929*  
040D2F             0930*  ;
040D2F             0931*  ; EXTERR
040D2F             0932*  ; Inputs:
040D2F             0933*  ;  A: Error number
040D2F             0934*  ;
040D2F             0935*  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
040D2F             0936*  ; The error text immediately follows the CALL to EXTERR, for example:
040D2F             0937*  ; > CALL  EXTERR
040D2F             0938*  ; > DB    "Silly", 0
040D2F             0939*  ; So we can get the address of the string by popping the return address off the stack
040D2F             0940*  ;
040D2F E1          0941*  EXTERR:			POP     HL			; Pop the error string pointer
040D30 22 2F 05 04 0942*  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
040D34 ED 7B 20 05 0943*  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
040D39 32 3F 05 04 0944*  			LD      (ERR),A			; Store error number in ERR sysvar
040D3D CD 66 0F 04 0945*  			CALL    SETLIN			; Get line number
040D41 22 33 05 04 0946*  			LD      (ERL),HL		; Store in ERL sysvar
040D45 B7          0947*  			OR      A			; Is error number 0?
040D46 28 0D       0948*  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
040D48             0949*  ;
040D48 2A 2C 05 04 0950*  			LD      HL,(ERRTRP)		; Check whether the error is trapped
040D4C 7C          0951*  			LD      A,H
040D4D B5          0952*  			OR      L
040D4E E5          0953*  			PUSH    HL			; HL: Error line
040D4F FD E1       0954*  			POP     IY			; IY: HL
040D51 C2 E3 1D 04 0955*  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
040D55             0956*  ;
040D55 21 00 00 00 0957*  ERROR2:			LD      HL,0
040D59 22 29 05 04 0958*  			LD      (AUTONO),HL		; Cancel AUTO
040D5D 22 26 05 04 0959*  			LD      (TRACEN),HL     	; Cancel TRACE
040D61 CD E7 4D 04 0960*  			CALL    RESET           	; Reset OPSYS
040D65 CD FF 0E 04 0961*  			CALL    CRLF			; Output newline
040D69 CD 3A 13 04 0962*  			CALL    REPORT          	; Output the error message
040D6D CD 9A 0F 04 0963*  			CALL    SAYLN			; Output " at line nnnn" message.
040D71 1E 00       0964*  			LD      E,0			; Close all files
040D73 DC 5C 4D 04 0965*  			CALL    C,OSSHUT
040D77 CD FF 0E 04 0966*  			CALL    CRLF			; Output newline
040D7B C3 38 06 04 0967*  			JP      CLOOP			; Back to CLOOP
040D7F             0968*  ;
040D7F             0969*  ; SUBROUTINES:
040D7F             0970*  ;
040D7F             0971*  ; LEX - SEARCH FOR KEYWORDS
040D7F             0972*  ;   Inputs: HL = start of keyword table
040D7F             0973*  ;           IY = start of match text
040D7F             0974*  ;  Outputs: If found, Z-flag set, A=token.
040D7F             0975*  ;           If not found, Z-flag reset, A=(IY).
040D7F             0976*  ;           IY updated (if NZ, IY unchanged).
040D7F             0977*  ; Destroys: A,B,H,L,IY,F
040D7F             0978*  ;
040D7F 21 20 07 04 0979*  LEX:			LD      HL,KEYWDS		; Address of the keywords table
040D83             0980*  ;
040D83 FD 7E 00    0981*  LEX0:			LD      A,(IY)			; Fetch the character to match
040D86 46          0982*  			LD      B,(HL)			; B: The token from the keywords table
040D87 23          0983*  			INC     HL			; Increment the pointer in the keywords table
040D88 BE          0984*  			CP      (HL)			; Compare the first characters
040D89 28 08       0985*  			JR      Z,LEX2			; If there is a match, then skip to LEX2
040D8B D8          0986*  			RET     C               	; No match, so fail
040D8C             0987*  ;
040D8C             0988*  ; This snippet of code skips to the next token in the KEYWDS table
040D8C             0989*  ;
040D8C 23          0990*  LEX1:			INC     HL			; Increment the pointer
040D8D CB 7E       0991*  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
040D8F 28 FB       0992*  			JR      Z,LEX1			; No, so loop
040D91 18 F0       0993*  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
040D93             0994*  ;
040D93 FD E5       0995*  LEX2:			PUSH    IY              	; Save the input pointer
040D95 23          0996*  LEX3:			INC     HL			; Increment the keyword pointer
040D96 CB 7E       0997*  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
040D98 20 1C       0998*  			JR      NZ,LEX6         	; Jump to here as we've found a token
040D9A FD 23       0999*  			INC     IY			; Increment the text pointer
040D9C FD 7E 00    1000*  			LD      A,(IY)			; Fetch the character
040D9F FE 2E       1001*  			CP      '.'			; Is it an abbreviated keyword?
040DA1 28 13       1002*  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
040DA3 BE          1003*  			CP      (HL)			; Compare with the keywords list
040DA4 28 EF       1004*  			JR      Z,LEX3			; It's a match, so continue checking this keyword
040DA6 CD 33 12 04 1005*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
040DAA 38 04       1006*  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
040DAC             1007*  ;
040DAC FD E1       1008*  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
040DAE 18 DC       1009*  			JR      LEX1			; And loop back to start again
040DB0             1010*  ;
040DB0             1011*  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
040DB0             1012*  ; immediately delimited
040DB0             1013*  ;
040DB0 7E          1014*  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
040DB1 B7          1015*  			OR      A			; If it is not zero, then...
040DB2 20 F8       1016*  			JR      NZ,LEX4			; Keep searching
040DB4 FD 2B       1017*  			DEC     IY			; If it is zero, then skip the input pointer back one byte
040DB6             1018*  ;
040DB6             1019*  ; We've found a token at this point
040DB6             1020*  ;
040DB6 F1          1021*  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
040DB7 AF          1022*  			XOR     A			; Set the Z flag
040DB8 78          1023*  			LD      A,B			; A: The token
040DB9 C9          1024*  			RET
040DBA             1025*  ;
040DBA             1026*  ; DEL - DELETE A PROGRAM LINE.
040DBA             1027*  ;   Inputs: HL addresses program line.
040DBA             1028*  ; Destroys: B,C,F
040DBA             1029*  ;
040DBA             1030*  ; This simply erases the line by moving all of the code after the line to be deleted back over
040DBA             1031*  ; it using an LDIR
040DBA             1032*  ;
040DBA D5          1033*  DEL:			PUSH    DE
040DBB E5          1034*  			PUSH    HL
040DBC E5          1035*  			PUSH    HL			; HL: Address of the program line
040DBD 06 00       1036*  			LD      B,0			; BC: Length of the line
040DBF 4E          1037*  			LD      C,(HL)
040DC0 09          1038*  			ADD     HL,BC			; HL: Advanced to the start of the next line
040DC1 E5          1039*  			PUSH    HL
040DC2 EB          1040*  			EX      DE,HL			; DE: Pointer to the next line
040DC3 2A 17 05 04 1041*  			LD      HL,(TOP)		; HL: Pointer to the end of the program
040DC7 ED 52       1042*  			SBC     HL,DE
040DC9 44          1043*  			LD      B,H			; BC: Size of block to move
040DCA 4D          1044*  			LD      C,L
040DCB E1          1045*  			POP     HL			; HL: Pointer to next line
040DCC D1          1046*  			POP     DE			; DE: Pointer to this line
040DCD ED B0       1047*  			LDIR                    	; Delete the line
040DCF ED 53 17 05 1048*  			LD      (TOP),DE		; Adjust TOP
       04          
040DD4 E1          1049*  			POP     HL
040DD5 D1          1050*  			POP     DE
040DD6 C9          1051*  			RET
040DD7             1052*  ;
040DD7             1053*  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
040DD7             1054*  ;   Inputs: Filename in ACCS (term CR)
040DD7             1055*  ; Destroys: A,B,C,D,E,H,L,F
040DD7             1056*  ;
040DD7             1057*  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
040DD7             1058*  ; AND WRITE FF FF, THEN LOAD (TOP).
040DD7             1059*  ; Destroys: A,B,C,H,L,F
040DD7             1060*  ;
040DD7 ED 5B 14 05 1061*  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
040DDC 21 00 FF FF 1062*  			LD      HL,-256
040DE0 39          1063*  			ADD     HL,SP
040DE1 ED 52       1064*  			SBC     HL,DE           	; Find available space
040DE3 44          1065*  			LD      B,H
040DE4 4D          1066*  			LD      C,L
040DE5 21 00 02 04 1067*  			LD      HL,ACCS
040DE9 CD C5 4B 04 1068*  			CALL    OSLOAD          	; Call the OSLOAD function in patch
040DED D4 24 0E 04 1069*  			CALL    NC,NEWIT		; If NC then NEW
040DF1 3E 00       1070*  			LD      A,0
040DF3 D2 18 0D 04 1071*  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
040DF7             1072*  ;
040DF7 CD 03 0E 04 1073*  CLEAN:			CALL    SETTOP			; Set TOP sysvar
040DFB 2B          1074*  			DEC     HL			; Write out the end of program markers
040DFC 36 FF       1075*  			LD      (HL),-1
040DFE 2B          1076*  			DEC     HL
040DFF 36 FF       1077*  			LD      (HL),-1
040E01 18 2B       1078*  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
040E03             1079*  ;
040E03             1080*  ; Set the TOP sysvar; the first free location after the end of the current program
040E03             1081*  ; Returns:
040E03             1082*  ; - HL: TOP
040E03             1083*  ;
040E03 2A 14 05 04 1084*  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
040E07 01 00 00 00 1085*  			LD	BC, 0			; BC: 0
040E0B 3E 0D       1086*  			LD      A,CR			; End of line marker
040E0D 4E          1087*  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
040E0E 0C          1088*  			INC     C			; Check for zero
040E0F 0D          1089*  			DEC     C
040E10 28 0A       1090*  			JR      Z,SETOP2		; If it is zero, we've reached the end
040E12 09          1091*  			ADD     HL,BC			; Skip to next line
040E13 2B          1092*  			DEC     HL			; Check end of previous line
040E14 BE          1093*  			CP      (HL)
040E15 23          1094*  			INC     HL
040E16 28 F5       1095*  			JR      Z,SETOP1		; If CR then loop
040E18 C3 B0 0C 04 1096*  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
040E1C             1097*  ;
040E1C 23          1098*  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
040E1D 23          1099*  			INC     HL			; NB: Called from NEWIT
040E1E 23          1100*  			INC     HL
040E1F 22 17 05 04 1101*  			LD      (TOP),HL		; Store in TOP sysvar
040E23 C9          1102*  			RET
040E24             1103*  ;
040E24             1104*  ; NEWIT - NEW PROGRAM THEN CLEAR
040E24             1105*  ;   Destroys: H,L
040E24             1106*  ;
040E24             1107*  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
040E24             1108*  ; FUNCTION AND PROCEDURE POINTERS.
040E24             1109*  ;   Destroys: Nothing
040E24             1110*  ;
040E24 2A 14 05 04 1111*  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
040E28 36 00       1112*  			LD      (HL),0			; Stick a 0 in there
040E2A CD 1C 0E 04 1113*  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
040E2E             1114*  ;
040E2E E5          1115*  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
040E2F 2A 17 05 04 1116*  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
040E33 22 1A 05 04 1117*  			LD      (LOMEM),HL		; Set the LOMEM sysvar
040E37 22 1D 05 04 1118*  			LD      (FREE),HL		; And the FREE sysvar with that value
040E3B 21 6C 04 04 1119*  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
040E3F C5          1120*  			PUSH    BC
040E40             1121*  			; LD      B,3*(54+2)		; Loop counter
040E40 06 A8       1122*  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
040E42 36 00       1123*  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
040E44 23          1124*  			INC     HL
040E45 10 FB       1125*  			DJNZ    CLEAR1
040E47 C1          1126*  			POP     BC
040E48 E1          1127*  			POP     HL			; Restore the BASIC program pointer
040E49 C9          1128*  			RET
040E4A             1129*  ;
040E4A             1130*  ;LISTIT - LIST A PROGRAM LINE.
040E4A             1131*  ;    Inputs: HL addresses line
040E4A             1132*  ;            DE = line number (binary)
040E4A             1133*  ;            IX = Pointer to LISTON
040E4A             1134*  ;             B = FOR/NEXT indent level
040E4A             1135*  ;             C = REPEAT/UNTIL indent level
040E4A             1136*  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
040E4A             1137*  ;
040E4A E5          1138*  LISTIT:			PUSH    HL			; Stack the address of the line
040E4B EB          1139*  			EX      DE,HL			; HL: Line number
040E4C C5          1140*  			PUSH    BC
040E4D CD B3 0F 04 1141*  			CALL    PBCD			; Print the line number
040E51 C1          1142*  			POP     BC
040E52 E1          1143*  			POP     HL			; HL: Address of the first token/character
040E53 7E          1144*  			LD      A,(HL)			; Fetch the token
040E54 FE ED       1145*  			CP      NEXT			; Is it NEXT...
040E56 CC E0 0E 04 1146*  			CALL    Z,INDENT		; Yes, so indent in
040E5A FE FD       1147*  			CP      UNTIL			; Or is it UNTIL...
040E5C CC E0 0E 04 1148*  			CALL    Z,INDENT		; Yes, so indent in
040E60 D9          1149*  			EXX
040E61 3E 20       1150*  			LD      A,' '
040E63 DD CB 00 46 1151*  			BIT     0,(IX)			; If BIT 0 of LISTON is set
040E67 C4 07 0F 04 1152*  			CALL    NZ,OUTCHR		; Then print a space after the line number
040E6B 78          1153*  			LD      A,B			; Fetch the FOR/NEXT indent level
040E6C 87          1154*  			ADD     A,A			; Multiply by 2
040E6D DD CB 00 4E 1155*  			BIT     1,(IX)			; If BIT 1 of LISTON is set
040E71 C4 66 2A 04 1156*  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
040E75 79          1157*  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
040E76 87          1158*  			ADD     A,A			; Multiply by 2
040E77 DD CB 00 56 1159*  			BIT     2,(IX)			; If BIT 2 of LISTON is set
040E7B C4 66 2A 04 1160*  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
040E7F D9          1161*  			EXX
040E80 7E          1162*  			LD      A,(HL)			; Fetch the token
040E81 FE E3       1163*  			CP      FOR			; Is it FOR?
040E83 CC E0 0E 04 1164*  			CALL    Z,INDENT		; Yes, so indent
040E87 FE F5       1165*  			CP      REPEAT			; Is it REPEAT?
040E89 CC E0 0E 04 1166*  			CALL    Z,INDENT		; Yes, so indent
040E8D 1E 00       1167*  			LD      E,0			; E: The quote counter - reset to 0
040E8F 7E          1168*  LIST8:			LD      A,(HL)			; Fetch a character / token byte
040E90 23          1169*  			INC     HL
040E91 FE 0D       1170*  			CP      CR			; Is it end of line?
040E93 28 0B       1171*  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
040E95 FE 22       1172*  			CP      34			; Is it a quote character?
040E97 20 01       1173*  			JR      NZ,LIST7		; No, so skip to next bit
040E99 1C          1174*  			INC     E			; Otherwise increment quote counter
040E9A CD CF 0E 04 1175*  LIST7:			CALL    LOUT			; Output the character / token
040E9E 18 EF       1176*  			JR      LIST8			; And repeat
040EA0             1177*  ;
040EA0             1178*  ; DB: Modification for *EDIT
040EA0             1179*  ; Terminate the line with either a CRLF or a NUL character
040EA0             1180*  ;
040EA0 DD CB 00 5E 1181*  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
040EA4 28 59       1182*  			JR	Z, CRLF			; Yes, so print a CRLF
040EA6 AF          1183*  			XOR	A			; Otherwise print a NUL (0)
040EA7 C3 20 49 04 1184*  			JP	OSWRCH
040EAB             1185*  ;
040EAB             1186*  ; Decode the 3 byte GOTO type line number
040EAB             1187*  ;
040EAB E5          1188*  PRLINO:			PUSH    HL			; Swap HL and IY
040EAC FD E1       1189*  			POP     IY			; IY: Pointer to the line number
040EAE C5          1190*  			PUSH    BC
040EAF CD 30 1B 04 1191*  			CALL    DECODE			; Decode
040EB3 C1          1192*  			POP     BC
040EB4 D9          1193*  			EXX
040EB5 C5          1194*  			PUSH    BC
040EB6 CD AF 0F 04 1195*  			CALL    PBCDL			; Output the line number
040EBA C1          1196*  			POP     BC
040EBB D9          1197*  			EXX
040EBC FD E5       1198*  			PUSH    IY			; Swap HL and IY
040EBE E1          1199*  			POP     HL			; HL: Pointer to the next character in the line
040EBF C9          1200*  			RET
040EC0             1201*  ;
040EC0             1202*  ; DB: Modification for internationalisation
040EC0             1203*  ;
040EC0 CD 24 0F 04 1204*  PRREM:			CALL	OUT_			; Output the REM token
040EC4 7E          1205*  @@:			LD	A, (HL)			; Fetch the character
040EC5 FE 0D       1206*  			CP	CR			; If it is end of line, then
040EC7 C8          1207*  			RET	Z			; we have finished
040EC8 CD 07 0F 04 1208*  			CALL	OUTCHR			; Ouput the character
040ECC 23          1209*  			INC	HL
040ECD 18 F5       1210*  			JR	@B			; And loop
040ECF             1211*  ;
040ECF             1212*  ; DB: End of modification
040ECF             1213*  ;
040ECF CB 43       1214*  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
040ED1 20 34       1215*  			JR      NZ,OUTCHR		; don't tokenise, just output the character
040ED3 FE F4       1216*  			CP	REM			; DB: Is it REM
040ED5 28 E9       1217*  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
040ED7 FE 8D       1218*  			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
040ED9 28 D0       1219*  			JR      Z,PRLINO		; Yes, so decode and print the line number
040EDB CD 24 0F 04 1220*  			CALL    OUT_			; Output a character / keyword
040EDF 7E          1221*  			LD      A,(HL)			; Fetch the next character
040EE0             1222*  ;
040EE0             1223*  ; This block of code handles the indentation
040EE0             1224*  ; B: Counter for FOR/NEXT indent
040EE0             1225*  ; C: Counter for REPEAT/UNTIL indent
040EE0             1226*  ;
040EE0 D9          1227*  INDENT:			EXX
040EE1 FE E3       1228*  			CP      FOR			; If the token is FOR
040EE3 28 09       1229*  			JR      Z,IND1			; Then INC B
040EE5 FE ED       1230*  			CP      NEXT			; If it is NEXT
040EE7 20 06       1231*  			JR      NZ,IND2_		; Then...
040EE9 05          1232*  			DEC     B			; DEC B
040EEA F2 EF 0E 04 1233*  			JP      P,IND2_			; If we have gone below 0 then
040EEE 04          1234*  IND1:			INC     B			; Increment back to 0
040EEF             1235*  ;
040EEF FE F5       1236*  IND2_:			CP      REPEAT			; If the token is REPEAT
040EF1 28 09       1237*  			JR      Z,IND3			; Then INC C
040EF3 FE FD       1238*  			CP      UNTIL			; If it is UNTIL
040EF5 20 06       1239*  			JR      NZ,IND4			; Then...
040EF7 0D          1240*  			DEC     C			; DEC C
040EF8 F2 FD 0E 04 1241*  			JP      P,IND4			; If we have gone below 0 then
040EFC 0C          1242*  IND3:			INC     C			; Incremet back to 0
040EFD D9          1243*  IND4:			EXX
040EFE C9          1244*  			RET
040EFF             1245*  ;
040EFF             1246*  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
040EFF             1247*  ;  Destroys: A,F
040EFF             1248*  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
040EFF             1249*  ;    Inputs: A = character
040EFF             1250*  ;  Destroys: A,F
040EFF             1251*  ;
040EFF 3E 0D       1252*  CRLF:			LD      A,CR			; Output CR
040F01 CD 07 0F 04 1253*  			CALL    OUTCHR
040F05 3E 0A       1254*  			LD      A,LF			; Output LF
040F07             1255*  ;
040F07 CD 20 49 04 1256*  OUTCHR:			CALL    OSWRCH			; Output the character in A
040F0B D6 0D       1257*  			SUB     CR			; Check for CR
040F0D 28 06       1258*  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
040F0F D8          1259*  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
040F10 3A 3D 05 04 1260*  			LD      A,(COUNT)		; Increment the count
040F14 3C          1261*  			INC     A
040F15             1262*  ;
040F15 32 3D 05 04 1263*  CARRET:			LD      (COUNT),A		; Store the new count value
040F19 C8          1264*  			RET     Z			; Return if the count has wrapped to 0
040F1A E5          1265*  			PUSH    HL			; Now check if count = print width
040F1B 2A 3E 05 04 1266*  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
040F1F BD          1267*  			CP      L			; L is the width. Compare it with count.
040F20 E1          1268*  			POP     HL
040F21 C0          1269*  			RET     NZ			; If we've not hit print width, then just return
040F22 18 DB       1270*  			JR      CRLF			; Otherwise output CRLF
040F24             1271*  ;
040F24             1272*  ; OUT - SEND CHARACTER OR KEYWORD
040F24             1273*  ;   Inputs: A = character (>=10, <128)
040F24             1274*  ;           A = Token (<10, >=128)
040F24             1275*  ;  Destroys: A,F
040F24             1276*  ;
040F24 FE 8A       1277*  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
040F26 EA 07 0F 04 1278*  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
040F2A             1279*  ;
040F2A             1280*  ; This bit looks up the character in the KEYWDS token table and expands it
040F2A             1281*  ; Note the CP 138; this sets the overflow flag as follows:
040F2A             1282*  ;
040F2A             1283*  ; NB:
040F2A             1284*  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
040F2A             1285*  ;  2. CP is effectively a SUB; sets the flags without affecting A
040F2A             1286*  ;  3. The operation n - -118 ~ n + 118
040F2A             1287*  ;
040F2A             1288*  ; So:
040F2A             1289*  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
040F2A             1290*  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
040F2A             1291*  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
040F2A             1292*  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
040F2A             1293*  ;
040F2A C5          1294*  			PUSH    BC			; Preserve BC and HL
040F2B E5          1295*  			PUSH    HL
040F2C 21 20 07 04 1296*  			LD      HL,KEYWDS		; The list of tokens and keywords
040F30 01 DF 02 00 1297*  			LD      BC,KEYWDL		; The length of the keyword list
040F34 ED B1       1298*  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
040F36             1299*  ;							; At this point HL points to the next byte, the first character of the token
040F36 7E          1300*  TOKEN1:			LD      A,(HL)			; Fetch the character
040F37 23          1301*  			INC     HL			; Increment to the next byte in the token table
040F38 FE 8A       1302*  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
040F3A F5          1303*  			PUSH    AF			; Then...
040F3B EC 07 0F 04 1304*  			CALL    PE,OUTCHR		; Output the character...
040F3F F1          1305*  			POP     AF			;
040F40 EA 36 0F 04 1306*  			JP      PE,TOKEN1		; And loop to the next character
040F44 E1          1307*  			POP     HL			; Done, so tidy up the stack and exit
040F45 C1          1308*  			POP     BC
040F46 C9          1309*  			RET
040F47             1310*  ;
040F47             1311*  ; FINDL - FIND PROGRAM LINE
040F47             1312*  ;   Inputs: HL = line number (binary)
040F47             1313*  ;  Outputs: HL addresses line (if found)
040F47             1314*  ;           DE = line number
040F47             1315*  ;           Z-flag set if found.
040F47             1316*  ; Destroys: A,B,C,D,E,H,L,F
040F47             1317*  ;
040F47 EB          1318*  FINDL:			EX      DE,HL			; DE: Line number (binary)
040F48 2A 14 05 04 1319*  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
040F4C AF          1320*  			XOR     A               	;  A: 0
040F4D BE          1321*  			CP      (HL)			; Check for end of program marker
040F4E 3C          1322*  			INC     A			;  A: 1
040F4F D0          1323*  			RET     NC			; Return with 1 if 0
040F50 AF          1324*  			XOR     A               	; Clear the carry flag
040F51             1325*  ;			LD      B,A			;  B: 0
040F51 01 00 00 00 1326*  			LD	BC, 0			; BC: 0
040F55             1327*  ;
040F55 4E          1328*  FINDL1:			LD      C,(HL)			;  C: The line length
040F56 E5          1329*  			PUSH    HL			; Stack the current program counter
040F57 23          1330*  			INC     HL			; Skip to the line number bytes
040F58 7E          1331*  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
040F59 23          1332*  			INC     HL
040F5A 66          1333*  			LD      H,(HL)
040F5B 6F          1334*  			LD      L,A
040F5C 52 ED 52    1335*  			SBC.S   HL,DE			; Compare with the line number we're searching for
040F5F E1          1336*  			POP     HL			; Get the current program counter
040F60 D0          1337*  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
040F61 09          1338*  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
040F62 C3 55 0F 04 1339*  			JP      FINDL1			; And loop
040F66             1340*  ;
040F66             1341*  ; SETLIN - Search program for line containing address
040F66             1342*  ;          Update (LINENO)
040F66             1343*  ;   Inputs: Address in (ERRLIN)
040F66             1344*  ;  Outputs: Line number in HL and (LINENO)
040F66             1345*  ; Destroys: B,C,D,E,H,L,F
040F66             1346*  ;
040F66 01 00 00 00 1347*  SETLIN:			LD	BC, 0			; Zero BC for later
040F6A             1348*  ;			LD      B, 0			; Zero B for later
040F6A ED 5B 35 05 1349*  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
040F6F 2A 14 05 04 1350*  			LD      HL, (PAGE_)		; HL: Start of user program area
040F73 B7          1351*  			OR      A			; Do a 24 bit compare without destroying HL
040F74 ED 52       1352*  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
040F76 19          1353*  			ADD     HL, DE			;  C: DE > HL
040F77 30 1B       1354*  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
040F79             1355*  ;
040F79 4E          1356*  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
040F7A 0C          1357*  			INC     C			; This is a way to check for zero without using the accumulator
040F7B 0D          1358*  			DEC     C			; If it is zero, then...
040F7C 28 16       1359*  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
040F7E 09          1360*  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
040F7F ED 52       1361*  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
040F81 19          1362*  			ADD     HL, DE
040F82 38 F5       1363*  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
040F84 ED 42       1364*  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
040F86 23          1365*  			INC     HL			; Skip the length counter
040F87 11 00 00 00 1366*  			LD	DE, 0			; Zero DE
040F8B 5E          1367*  			LD      E, (HL)          	; Fetch the line number
040F8C 23          1368*  			INC     HL
040F8D 56          1369*  			LD      D, (HL)
040F8E EB          1370*  			EX      DE, HL			; HL: The line number
040F8F 22 23 05 04 1371*  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
040F93 C9          1372*  			RET
040F94             1373*  ;
040F94 21 00 00 00 1374*  SET3:			LD      HL, 0			; We've not found the line at this point so
040F98 18 F5       1375*  			JR      SET2			; Set LINENO to 0
040F9A             1376*  ;
040F9A             1377*  ;SAYLN - PRINT " at line nnnn" MESSAGE.
040F9A             1378*  ;  Outputs: Carry=0 if line number is zero.
040F9A             1379*  ;           Carry=1 if line number is non-zero.
040F9A             1380*  ; Destroys: A,B,C,D,E,H,L,F
040F9A             1381*  ;
040F9A 2A 23 05 04 1382*  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
040F9E 7C          1383*  			LD      A,H			; If it is zero then
040F9F B5          1384*  			OR      L
040FA0 C8          1385*  			RET     Z			; Don't need to do anything; return with F:C set to 0
040FA1 CD 48 13 04 1386*  			CALL    TELL			; Output the error message
040FA5 20 61 74 20 1387*  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
040FAF 0E 00       1388*  PBCDL:			LD      C,0			; C: Leading character (NUL)
040FB1 18 02       1389*  			JR      PBCD0			; Output the line number; return with F:C set to 1
040FB3             1390*  ;
040FB3             1391*  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
040FB3             1392*  ;   Inputs: HL = number (binary).
040FB3             1393*  ;  Outputs: Carry = 1
040FB3             1394*  ; Destroys: A,B,C,D,E,H,L,F
040FB3             1395*  ;
040FB3 0E 20       1396*  PBCD:			LD      C,' '			; C: Leading character (" ")
040FB5 06 05       1397*  PBCD0:			LD      B,5			; Number of digits in result
040FB7 11 10 27 00 1398*  			LD      DE,10000		; Start off with the 10,000 column
040FBB AF          1399*  PBCD1:			XOR     A			; Counter
040FBC ED 52       1400*  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
040FBE 3C          1401*  			INC     A
040FBF 30 FB       1402*  			JR      NC,PBCD2
040FC1 19          1403*  			ADD     HL,DE			; The loop overruns by one, so adjust here
040FC2 3D          1404*  			DEC     A			; A: Number of 10,000s
040FC3 28 04       1405*  			JR      Z,PBCD3			; If it is 0, then skip the next bit
040FC5 CB E1       1406*  			SET     4,C			; C: Set to '0' ASCII (30h)
040FC7 CB E9       1407*  			SET     5,C
040FC9 B1          1408*  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
040FCA C4 07 0F 04 1409*  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
040FCE 78          1410*  			LD      A,B			; If on first transition, skip this
040FCF FE 05       1411*  			CP      5			; TODO: Need to find out why
040FD1 28 06       1412*  			JR      Z,PBCD4
040FD3 29          1413*  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
040FD4 54          1414*  			LD      D,H			;         : rather than shifting DE right
040FD5 5D          1415*  			LD      E,L			;         : This makes a lot of sense
040FD6 29          1416*  			ADD     HL,HL			; HL x  4
040FD7 29          1417*  			ADD     HL,HL			; HL x  8
040FD8 19          1418*  			ADD     HL,DE			; HL x 10
040FD9 11 E8 03 00 1419*  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
040FDD 10 DC       1420*  			DJNZ    PBCD1			; Loop until done
040FDF 37          1421*  			SCF				; SCF set for SAYLN in this module
040FE0 C9          1422*  			RET
040FE1             1423*  ;
040FE1             1424*  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
040FE1             1425*  ;   Inputs: HL, IY as returned from GETVAR (NZ).
040FE1             1426*  ;  Outputs: As GETVAR.
040FE1             1427*  ; Destroys: everything
040FE1             1428*  ;
040FE1 CD 66 11 04 1429*  PUTVAR:			CALL    CREATE			; Create the variable
040FE5 FD 7E 00    1430*  			LD      A,(IY)			; Fetch the next character
040FE8 FE 28       1431*  			CP      '('			; Check for bad use of array
040FEA 20 70       1432*  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
040FEC 3E 0E       1433*  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
040FEE C3 18 0D 04 1434*  ERROR3:			JP      ERROR_
040FF2             1435*  ;
040FF2             1436*  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
040FF2             1437*  ;   Inputs: IY addresses first character.
040FF2             1438*  ;  Outputs: Carry set and NZ if illegal character.
040FF2             1439*  ;           Z-flag set if variable found, then:
040FF2             1440*  ;            A = variable type (0,4,5,128 or 129)
040FF2             1441*  ;            HL = IX = variable pointer.
040FF2             1442*  ;            IY updated
040FF2             1443*  ;           If Z-flag & carry reset, then:
040FF2             1444*  ;            HL, IY set for subsequent PUTVAR call.
040FF2             1445*  ; Destroys: everything
040FF2             1446*  ;
040FF2 FD 7E 00    1447*  GETVAR:			LD      A,(IY)			; Get the first character
040FF5 FE 24       1448*  			CP      '$'			; Is it a string?
040FF7 28 69       1449*  			JR      Z,GETV4			; Yes, so branch here
040FF9 FE 21       1450*  			CP      '!'			; Is it indirection (32-bit)?
040FFB 28 69       1451*  			JR      Z,GETV5			; Yes, so branch here
040FFD FE 3F       1452*  			CP      '?'			; Is it indirection (8-bit)?
040FFF 28 69       1453*  			JR      Z,GETV6			; Yes, so branch here
041001             1454*  ;
041001 CD D0 10 04 1455*  			CALL    LOCATE			; Locate the variable
041005 C0          1456*  			RET     NZ			; And exit here if not found
041006             1457*  ;
041006             1458*  ; At this point:
041006             1459*  ;  HL: Address of variable in memory
041006             1460*  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
041006             1461*  ;
041006 FD 7E 00    1462*  			LD      A,(IY)			; Further checks
041009 FE 28       1463*  			CP      '('             	; Is it an array?
04100B 20 47       1464*  			JR      NZ,GETVX        	; No, so exit
04100D             1465*  ;
04100D             1466*  ; We are processing an array at this point
04100D             1467*  ;
04100D D5          1468*  			PUSH    DE              	; Save the variable type (in D)
04100E 7E          1469*  			LD      A,(HL)          	; Fetch the number of dimensions
04100F B7          1470*  			OR      A
041010 28 DA       1471*  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
041012 23          1472*  			INC     HL			;
041013 11 00 00 00 1473*  			LD      DE,0            	; Accumulator
041017 F5          1474*  			PUSH    AF
041018 FD 23       1475*  			INC     IY              	; Skip "("
04101A 18 05       1476*  			JR      GETV3
04101C             1477*  ;
04101C F5          1478*  GETV2:			PUSH    AF
04101D CD 6F 1C 04 1479*  			CALL    COMMA
041021 E5          1480*  GETV3:			PUSH    HL
041022 D5          1481*  			PUSH    DE
041023 CD 54 15 04 1482*  			CALL    EXPRI			; Get the subscript
041027 D9          1483*  			EXX
041028 D1          1484*  			POP     DE
041029 E3          1485*  			EX      (SP),HL
04102A 4E          1486*  			LD      C,(HL)
04102B 23          1487*  			INC     HL
04102C 46          1488*  			LD      B,(HL)
04102D 23          1489*  			INC     HL
04102E E3          1490*  			EX      (SP),HL
04102F EB          1491*  			EX      DE,HL
041030 D5          1492*  			PUSH    DE
041031 CD E9 2A 04 1493*  			CALL    MUL16			; HL=HL*BC
041035 D1          1494*  			POP     DE
041036 19          1495*  			ADD     HL,DE
041037 EB          1496*  			EX      DE,HL
041038 B7          1497*  			OR      A
041039 ED 42       1498*  			SBC     HL,BC
04103B 3E 0F       1499*  			LD      A,15
04103D 30 AF       1500*  			JR      NC,ERROR3		; Throw a "Subscript" error
04103F E1          1501*  			POP     HL
041040 F1          1502*  			POP     AF
041041 3D          1503*  			DEC     A               	; Dimension counter
041042 20 D8       1504*  			JR      NZ,GETV2
041044 CD 7C 1C 04 1505*  			CALL    BRAKET          	; Check for closing bracket
041048 F1          1506*  			POP     AF              	; Restore the type
041049 E5          1507*  			PUSH    HL
04104A CD DC 2A 04 1508*  			CALL    X4OR5           	; DE=DE*n
04104E E1          1509*  			POP     HL
04104F 19          1510*  			ADD     HL,DE
041050 57          1511*  			LD      D,A             	; The type
041051 FD 7E 00    1512*  			LD      A,(IY)
041054 FE 3F       1513*  GETVX:			CP      '?'
041056 28 1E       1514*  			JR      Z,GETV9
041058 FE 21       1515*  			CP      '!'
04105A 28 16       1516*  			JR      Z,GETV8
04105C E5          1517*  GETVZ:			PUSH    HL              	; Set exit conditions
04105D DD E1       1518*  			POP     IX
04105F 7A          1519*  			LD      A,D
041060 BF          1520*  			CP      A
041061 C9          1521*  			RET
041062             1522*  ;
041062             1523*  ; Process strings, unary & binary indirection:
041062             1524*  ;
041062 3E 80       1525*  GETV4:			LD      A,128           	; Static strings
041064 18 05       1526*  			JR      GETV7
041066             1527*  ;
041066 3E 04       1528*  GETV5:			LD      A,4             	; Unary 32-bit indirection
041068 18 01       1529*  			JR      GETV7
04106A             1530*  ;
04106A AF          1531*  GETV6:			XOR     A               	; Unary 8-bit indirection
04106B             1532*  ;
04106B 21 00 00 00 1533*  GETV7:			LD      HL,0
04106F F5          1534*  			PUSH    AF
041070 18 24       1535*  			JR      GETV0
041072             1536*  ;
041072 06 04       1537*  GETV8:			LD      B,4             	; Binary 32-bt indirection
041074 18 02       1538*  			JR      GETVA
041076             1539*  ;
041076 06 00       1540*  GETV9:			LD      B,0             	; Binary 8-bit indirection
041078             1541*  ;
041078 E5          1542*  GETVA:			PUSH    HL
041079 DD E1       1543*  			POP     IX
04107B 7A          1544*  			LD      A,D            		; Fetch the variable type
04107C FE 81       1545*  			CP      129			; Is it a string?
04107E C8          1546*  			RET     Z               	; Yes, so exit here
04107F C5          1547*  			PUSH    BC
041080 CD 60 16 04 1548*  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
041084 CD AC 18 04 1549*  			CALL    SFIX
041088 7D          1550*  			LD	A,L
041089 D9          1551*  			EXX
04108A 22 4A 05 04 1552*  			LD	(R0+0),HL
04108E 32 4C 05 04 1553*  			LD	(R0+2),A
041092 2A 4A 05 04 1554*  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
041096             1555*  ;
041096 E5          1556*  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
041097 FD 23       1557*  			INC     IY
041099 CD 6F 15 04 1558*  			CALL    ITEMI
04109D 7D          1559*  			LD	A,L			;  A: The MSB of the address
04109E D9          1560*  			EXX
04109F 22 4A 05 04 1561*  			LD	(R0+0),HL		; HL: The LSW of the address
0410A3 32 4C 05 04 1562*  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
0410A7 D1          1563*  			POP     DE
0410A8 F1          1564*  			POP     AF
0410A9 2A 4A 05 04 1565*  			LD	HL,(R0)			; HL: L'HL
0410AD 19          1566*  			ADD     HL,DE
0410AE E5          1567*  			PUSH    HL
0410AF DD E1       1568*  			POP     IX
0410B1 BF          1569*  			CP      A
0410B2 C9          1570*  			RET
0410B3             1571*  ;
0410B3             1572*  ;GETDEF - Find entry for FN or PROC in dynamic area.
0410B3             1573*  ;   Inputs: IY addresses byte following "DEF" token.
0410B3             1574*  ;  Outputs: Z flag set if found
0410B3             1575*  ;           Carry set if neither FN or PROC first.
0410B3             1576*  ;           If Z: HL points to entry
0410B3             1577*  ;                 IY addresses delimiter
0410B3             1578*  ; Destroys: A,D,E,H,L,IY,F
0410B3             1579*  ;
0410B3 FD 7E 01    1580*  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0410B6 CD 33 12 04 1581*  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0410BA D8          1582*  			RET     C			; No so return with C set
0410BB FD 7E 00    1583*  			LD      A,(IY)			; Fetch the current character from the tokenised line
0410BE 21 0E 05 04 1584*  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
0410C2 FE A4       1585*  			CP      FN			; Is it the token FN?
0410C4 28 4A       1586*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0410C6 21 11 05 04 1587*  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
0410CA FE F2       1588*  			CP      PROC			; Is it the token PROC?
0410CC 28 42       1589*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0410CE 37          1590*  			SCF				; No, so just return with C set
0410CF C9          1591*  			RET
0410D0             1592*  ;
0410D0             1593*  ; LOCATE - Try to locate variable name in static or dynamic variables.
0410D0             1594*  ; If illegal first character return carry, non-zero.
0410D0             1595*  ; If found, return no-carry, zero.
0410D0             1596*  ; If not found, return no-carry, non-zero.
0410D0             1597*  ;   Inputs: IY=Addresses first character of name.
0410D0             1598*  ;            A=(IY)
0410D0             1599*  ;  Outputs:  F=Z set if found, then:
0410D0             1600*  ;           IY=addresses terminator
0410D0             1601*  ;           HL=addresses location of variable
0410D0             1602*  ;            D=type of variable: 4 = integer
0410D0             1603*  ;                                5 = floating point
0410D0             1604*  ;                              129 = string
0410D0             1605*  ; Destroys: A,D,E,H,L,IY,F
0410D0             1606*  ;
0410D0             1607*  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
0410D0             1608*  ; They can contain any alphanumeric character and underscore (_)
0410D0             1609*  ; String variables are postfixed with the dollar ($) character
0410D0             1610*  ; Integer variables are postfixed with the percent (%) character
0410D0             1611*  ; Static integer variables are named @%, A% to Z%
0410D0             1612*  ; All other variables are dynamic
0410D0             1613*  ;
0410D0 D6 40       1614*  LOCATE:			SUB     '@'			; Check for valid range
0410D2 D8          1615*  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0410D3 21 00 00 00 1616*  			LD      HL, 0			; Clear HL
0410D7 FE 1B       1617*  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0410D9 30 1E       1618*  			JR      NC,LOC0         	; Then branch here
0410DB 6F          1619*  			LD	L, A			; HL = A
0410DC FD 7E 01    1620*  			LD      A,(IY+1)        	; Check the 2nd character
0410DF FE 25       1621*  			CP      '%'			; If not "%" then it is not static...
0410E1 20 21       1622*  			JR      NZ,LOC1         	; Branch here
0410E3 FD 7E 02    1623*  			LD      A,(IY+2)		; Check the 3rd character
0410E6 FE 28       1624*  			CP      '('			; If it is "(" (array) then it is not static...
0410E8 28 1A       1625*  			JR      Z,LOC1          	; Branch here
0410EA             1626*  ;
0410EA             1627*  ; At this point we're dealing with a static variable
0410EA             1628*  ;
0410EA 29          1629*  			ADD     HL,HL			; HL: Variable index * 4
0410EB 29          1630*  			ADD	HL,HL
0410EC 11 00 04 04 1631*  			LD      DE,STAVAR       	; The static variable area in memory
0410F0 19          1632*  			ADD     HL,DE			; HL: The address of the static variable
0410F1 FD 23       1633*  			INC     IY			; Skip the program pointer past the static variable name
0410F3 FD 23       1634*  			INC     IY
0410F5 16 04       1635*  			LD      D,4             	; Set the type to be integer
0410F7 AF          1636*  			XOR     A			; Set the Z flag
0410F8 C9          1637*  			RET
0410F9             1638*  ;
0410F9             1639*  ; At this point it's potentially a dynamic variable, just need to do a few more checks
0410F9             1640*  ;
0410F9 FE 1F       1641*  LOC0:			CP      '_'-'@'			; Check the first character is in
0410FB D8          1642*  			RET     C			; the range "_" to
0410FC FE 3B       1643*  			CP      'z'-'@'+1		; "z" (lowercase characters only)
0410FE 3F          1644*  			CCF				; If it is not in range then
0410FF 3D          1645*  			DEC     A               	; Set NZ flag and
041100 D8          1646*  			RET     C			; Exit here
041101 D6 03       1647*  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
041103 6F          1648*  			LD	L, A			; HL = A
041104             1649*  ;
041104             1650*  ; Yes, it's definitely a dynamic variable at this point...
041104             1651*  ;
041104 7D          1652*  LOC1:			LD	A, L			; Fetch variable index
041105 87          1653*  			ADD	A, A			; x 2
041106 85          1654*  			ADD	A, L			; x 3
041107 D6 03       1655*  			SUB	3			; Subtract 2 TODO: Should be 3
041109 6F          1656*  			LD	L, A
04110A 11 6C 04 04 1657*  			LD      DE, DYNVAR       	; The dynamic variable storage
04110E D8          1658*  			RET	C			; Bounds check to trap for variable '@'
04110F 19          1659*  			ADD     HL, DE			; HL: Address of first entry
041110             1660*  ;
041110             1661*  ; Loop through the linked list of variables to find a match
041110             1662*  ;
041110 ED 17       1663*  LOC2:			LD	DE, (HL)		; Fetch the original pointer
041112 E5          1664*  			PUSH	HL			; Need to preserve HL for LOC6
041113 AF          1665*  			XOR	A			; Reset carry flag
041114 ED 62       1666*  			SBC	HL, HL			; Set HL to 0
041116 ED 52       1667*  			SBC	HL, DE			; Compare with 0
041118 E1          1668*  			POP	HL			; Restore the original pointer
041119 28 49       1669*  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
04111B             1670*  			; LD	HL, DE			; Make a copy of this pointer in HL
04111B D5          1671*  			push de
04111C E1          1672*  			pop hl ; how was that even possible?
04111D 23          1673*  			INC     HL              	; Skip the link (24-bits)
04111E 23          1674*  			INC     HL
04111F 23          1675*  			INC	HL			; HL: Address of the variable name in DYNVARS
041120 FD E5       1676*  			PUSH    IY			; IY: Address of the variable name in the program
041122             1677*  ;
041122 7E          1678*  LOC3:			LD      A,(HL)         		; Compare
041123 23          1679*  			INC     HL
041124 FD 23       1680*  			INC     IY
041126 FD BE 00    1681*  			CP      (IY)
041129 28 F7       1682*  			JR      Z, LOC3			; Keep looping whilst we've got a match...
04112B B7          1683*  			OR      A               	; Have we hit a terminator?
04112C 28 07       1684*  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
04112E             1685*  ;
04112E FD E1       1686*  LOC4:			POP     IY			; Restore the pointer in the program
041130 EB          1687*  			EX      DE, HL			; HL: New pointer in DYNVARS
041131 C3 10 11 04 1688*  			JP      LOC2            	; Loop round and try again
041135             1689*  ;
041135             1690*  ; We might have located a variable at this point, just need to do a few more tests
041135             1691*  ;
041135 FD 2B       1692*  LOC5:			DEC     IY
041137 FD 7E 00    1693*  			LD      A,(IY)
04113A FE 28       1694*  			CP      '('
04113C 28 15       1695*  			JR      Z,LOC5A         	; FOUND
04113E FD 23       1696*  			INC     IY
041140 CD 27 12 04 1697*  			CALL    RANGE
041144 38 0D       1698*  			JR      C,LOC5A         	; FOUND
041146 FE 28       1699*  			CP      '('
041148 28 E4       1700*  			JR      Z,LOC4          	; KEEP LOOKING
04114A FD 7E FF    1701*  			LD      A,(IY-1)
04114D CD 33 12 04 1702*  			CALL    RANGE1
041151 30 DB       1703*  			JR      NC,LOC4         	; KEEP LOOKING
041153 D1          1704*  LOC5A:			POP     DE
041154 FD 7E FF    1705*  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
041157 FE 24       1706*  			CP      '$'			; Is it a string?
041159 16 81       1707*  			LD      D,129			; Yes, so return D = 129
04115B C8          1708*  			RET     Z
04115C FE 25       1709*  			CP      '%'			; Is it an integer?
04115E 16 04       1710*  			LD      D,4			; Yes, so return D = 4
041160 C8          1711*  			RET     Z
041161 14          1712*  			INC     D			; At this point it must be a float
041162 BF          1713*  			CP      A			; Set the flags
041163 C9          1714*  			RET
041164             1715*  ;
041164             1716*  ; The variable is undefined at this point; HL will be zero
041164             1717*  ;
041164 3C          1718*  LOC6:			INC     A               	; Set NZ flag
041165 C9          1719*  			RET
041166             1720*  ;
041166             1721*  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
041166             1722*  ;   Inputs: HL, IY as returned from LOCATE (NZ).
041166             1723*  ;  Outputs: As LOCATE, GETDEF.
041166             1724*  ; Destroys: As LOCATE, GETDEF.
041166             1725*  ;
041166 AF          1726*  CREATE:			XOR     A
041167 ED 5B 1D 05 1727*  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
04116C ED 1F       1728*  			LD	(HL), DE		; Store
04116E EB          1729*  			EX      DE,HL
04116F 77          1730*  			LD      (HL),A			; Clear the link of the new entity
041170 23          1731*  			INC     HL
041171 77          1732*  			LD      (HL),A
041172 23          1733*  			INC     HL
041173 77          1734*  			LD      (HL),A
041174 23          1735*  			INC     HL
041175 FD 23       1736*  LOC7:			INC     IY
041177 CD 27 12 04 1737*  			CALL    RANGE           	; END OF VARIABLE?
04117B 38 15       1738*  			JR      C,LOC8
04117D 77          1739*  			LD      (HL),A
04117E 23          1740*  			INC     HL
04117F CD 33 12 04 1741*  			CALL    RANGE1
041183 30 F0       1742*  			JR      NC,LOC7
041185 FE 28       1743*  			CP      '('
041187 28 09       1744*  			JR      Z,LOC8
041189 FD 7E 01    1745*  			LD      A,(IY+1)
04118C FE 28       1746*  			CP      '('
04118E 28 E5       1747*  			JR      Z,LOC7
041190 FD 23       1748*  			INC     IY
041192 36 00       1749*  LOC8:			LD      (HL),0          	; TERMINATOR
041194 23          1750*  			INC     HL
041195 E5          1751*  			PUSH    HL
041196 CD 54 11 04 1752*  			CALL    TYPE_			; Get the variable type in D
04119A 3E 04       1753*  			LD      A,4			; If it is an integer then it takes up 4 bytes
04119C BA          1754*  			CP      D
04119D 28 01       1755*  			JR      Z,LOC9			; So skip the next bit
04119F 3C          1756*  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0411A0 36 00       1757*  LOC9:			LD      (HL),0          	; Initialise the memory to zero
0411A2 23          1758*  			INC     HL
0411A3 3D          1759*  			DEC     A
0411A4 20 FA       1760*  			JR      NZ,LOC9
0411A6 22 1D 05 04 1761*  			LD      (FREE),HL		; Adjust the stack
0411AA CD C6 28 04 1762*  			CALL    CHECK			; Check whether we are out of space
0411AE E1          1763*  			POP     HL
0411AF AF          1764*  			XOR     A
0411B0 C9          1765*  			RET
0411B1             1766*  ;
0411B1             1767*  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
0411B1             1768*  ;   Inputs: IY = Text Pointer
0411B1             1769*  ;  Outputs: HL = Line number (zero if none)
0411B1             1770*  ;           IY updated
0411B1             1771*  ; Destroys: A,D,E,H,L,IY,F
0411B1             1772*  ;
0411B1             1773*  ; This bit of code performs a BASE 10 shift to build up the number
0411B1             1774*  ; So if the string passed is "345", the algorithm does this:
0411B1             1775*  ;
0411B1             1776*  ;    HL : Digit	: Operation
0411B1             1777*  ; ----- : ----- : ---------
0411B1             1778*  ; 00000 :	:
0411B1             1779*  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
0411B1             1780*  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
0411B1             1781*  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
0411B1             1782*  ;
0411B1             1783*  ; The multiply by 10 is done by an unrolled shift and add loop
0411B1             1784*  ;
0411B1 CD BD 1C 04 1785*  LINNUM:			CALL    NXT			; Skip whitespace to the first character
0411B5 40 21 00 00 1786*  			LD.SIS  HL,0			; The running total
0411B9 FD 7E 00    1787*  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
0411BC D6 30       1788*  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
0411BE D8          1789*  			RET     C			; And return if less than 0
0411BF FE 0A       1790*  			CP      10			; Or greater than or equal to 10
0411C1 D0          1791*  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
0411C2 FD 23       1792*  			INC     IY			; Increment the string pointer
0411C4 54          1793*  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
0411C5 5D          1794*  			LD      E,L			; Store the original number in DE
0411C6 52 29       1795*  			ADD.S   HL,HL           	; *2
0411C8 38 13       1796*  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
0411CA 52 29       1797*  			ADD.S   HL,HL           	; *4S
0411CC 38 0F       1798*  			JR      C,TOOBIG
0411CE 52 19       1799*  			ADD.S   HL,DE           	; *5
0411D0 38 0B       1800*  			JR      C,TOOBIG
0411D2 52 29       1801*  			ADD.S   HL,HL           	; *10
0411D4 38 07       1802*  			JR      C,TOOBIG
0411D6 5F          1803*  			LD      E,A			; A->DE: the digit to add in
0411D7 16 00       1804*  			LD      D,0
0411D9 52 19       1805*  			ADD.S   HL,DE           	; Add in the digit to the running total
0411DB 30 DC       1806*  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
0411DD             1807*  ;
0411DD 3E 14       1808*  TOOBIG:			LD      A,20
0411DF C3 18 0D 04 1809*  			JP      ERROR_           	; Error: "Too big"
0411E3             1810*  ;
0411E3             1811*  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
0411E3             1812*  ;   Inputs: IY = text pointer
0411E3             1813*  ;  Outputs: HL = first number (10 by default)
0411E3             1814*  ;           BC = second number (10 by default)
0411E3             1815*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
0411E3             1816*  ;
0411E3 CD B1 11 04 1817*  PAIR:			CALL    LINNUM          	; Parse the first line number
0411E7 7C          1818*  			LD      A,H			; If it is not zero, then...
0411E8 B5          1819*  			OR      L
0411E9 20 02       1820*  			JR      NZ,PAIR1		; Skip...
0411EB 2E 0A       1821*  			LD      L,10			; HL: the default value (10)
0411ED             1822*  ;
0411ED CD F1 29 04 1823*  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
0411F1 FD 23       1824*  			INC     IY			; Skip to next character
0411F3 E5          1825*  			PUSH    HL			; Stack the first line number
0411F4 21 0A 00 00 1826*  			LD      HL,10			; HL: the second default (10)
0411F8 C4 B1 11 04 1827*  			CALL    NZ,LINNUM       	; Parse the second line number
0411FC E3          1828*  			EX      (SP),HL			; HL: The first line number (off the stack)
0411FD C1          1829*  			POP     BC			; BC: Second line number
0411FE 78          1830*  			LD      A,B			; If the second line number is not zero then...
0411FF B1          1831*  			OR      C			; We're good...
041200 C0          1832*  			RET     NZ			; Exit, otherwise...
041201 CD 2F 0D 04 1833*  			CALL    EXTERR			; Throw error: "Silly"
041205 53 69 6C 6C 1834*  			DB    	"Silly", 0
       79 00       
04120B             1835*  ;
04120B             1836*  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
04120B             1837*  ;   Inputs: IY = text pointer
04120B             1838*  ;  Outputs: HL = points to program text
04120B             1839*  ;           BC = second number (0 by default)
04120B             1840*  ; Destroys: A,B,C,D,E,H,L,IY,F
04120B             1841*  ;
04120B CD B1 11 04 1842*  DLPAIR:			CALL    LINNUM			; Parse the first line number
04120F E5          1843*  			PUSH    HL			; Stack it
041210 CD F1 29 04 1844*  			CALL    TERMQ			; Check for ELSE, : or CR
041214 28 0A       1845*  			JR      Z,DLP1			; And exit if so
041216 FE E7       1846*  			CP      TIF			; Is the token IF?
041218 28 06       1847*  			JR      Z,DLP1			; Yes, so skip the next bit...
04121A FD 23       1848*  			INC     IY			; Otherwise...
04121C CD B1 11 04 1849*  			CALL    LINNUM			; Fetch the second line number
041220 E3          1850*  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
041221 CD 47 0F 04 1851*  			CALL    FINDL			; HL: Find the address of the line
041225 C1          1852*  			POP     BC			; BC: The second number
041226 C9          1853*  			RET
041227             1854*  ;
041227             1855*  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
041227             1856*  ;   Inputs: IY addresses character
041227             1857*  ;  Outputs: Carry set if out-of-range.
041227             1858*  ; Destroys: A,F
041227             1859*  ;
041227             1860*  ; It is called here to check the following
041227             1861*  ; In range: "$", "%" and "("
041227             1862*  ;   Plus all characters in RANGE1 and RANGE2
041227             1863*  ;
041227 FD 7E 00    1864*  RANGE:			LD      A,(IY)			; Fetch the character
04122A FE 24       1865*  			CP      '$'			; Postfix for string variable is valid
04122C C8          1866*  			RET     Z
04122D FE 25       1867*  			CP      '%'			; Postfix for integer variable is valid
04122F C8          1868*  			RET     Z
041230 FE 28       1869*  			CP      '('			; Postfix for array is valid
041232 C8          1870*  			RET     Z
041233             1871*  ;
041233             1872*  ; It is called here to check the following
041233             1873*  ; In range: "0" to "9" and "@"
041233             1874*  ;   Plus all characters in RANGE2
041233             1875*  ;
041233 FE 30       1876*  RANGE1:			CP      '0'			; If it is between '0'...
041235 D8          1877*  			RET     C
041236 FE 3A       1878*  			CP      '9'+1			; And '9'...
041238 3F          1879*  			CCF
041239 D0          1880*  			RET     NC			; Then it is valid
04123A FE 40       1881*  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
04123C C8          1882*  			RET     Z
04123D             1883*  ;
04123D             1884*  ; It is called here to check the following
04123D             1885*  ; In range: "A" to "Z", "a' to "z", "_" and "`"
04123D             1886*  ;
04123D FE 41       1887*  RANGE2:			CP      'A'			; If it is between 'A'...
04123F D8          1888*  			RET     C
041240 FE 5B       1889*  			CP      'Z'+1			; And 'Z'...
041242 3F          1890*  			CCF
041243 D0          1891*  			RET     NC			; Then it is valid
041244 FE 5F       1892*  			CP      '_'			; If it is underscore, grave, or between 'a'
041246 D8          1893*  			RET     C
041247 FE 7B       1894*  			CP      'z'+1			; And 'z'
041249 3F          1895*  			CCF				; Then it is valid
04124A C9          1896*  			RET
04124B             1897*  ;
04124B             1898*  ; Throw a 'LINE space' error (line too long)
04124B             1899*  ; This is called from LEXAN
04124B             1900*  ;
04124B AF          1901*  SPACE_: 		XOR     A
04124C CD 2F 0D 04 1902*  			CALL    EXTERR          	; "LINE space"
041250 86 08 00    1903*  			DB    	LINE_, 8, 0
041253             1904*  ;
041253             1905*  ; LEXAN - LEXICAL ANALYSIS.
041253             1906*  ;  Bit 0,C: 1=left, 0=right
041253             1907*  ;  Bit 2,C: 1=in BINARY
041253             1908*  ;  Bit 3,C: 1=in HEX
041253             1909*  ;  Bit 4,C: 1=accept line number
041253             1910*  ;  Bit 5,C: 1=in variable, FN, PROC
041253             1911*  ;  Bit 6,C: 1=in REM, DATA, *
041253             1912*  ;  Bit 7,C: 1=in quotes
041253             1913*  ;   Inputs: IY addresses source string
041253             1914*  ;           DE addresses destination string (must be page boundary)
041253             1915*  ;            C sets initial mode
041253             1916*  ;  Outputs: DE, IY updated
041253             1917*  ;            A holds carriage return
041253             1918*  ;
041253 12          1919*  LEXAN1:			LD      (DE),A          	; Transfer to buffer
041254 13          1920*  			INC     DE              	; Increment the pointers
041255 FD 23       1921*  			INC     IY			; And fall through to the main function
041257             1922*  ;
041257             1923*  ; This is the main entry point
041257             1924*  ;
041257 7B          1925*  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
041258 FE FC       1926*  			CP      252             	; If it is >= 252 bytes, then...
04125A 30 EF       1927*  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
04125C FD 7E 00    1928*  			LD      A,(IY)			; Fetch character from source string
04125F FE 0D       1929*  			CP      CR			; If it is a CR
041261 C8          1930*  			RET     Z               	; Then it is end of line; we're done parsing
041262 CD 33 12 04 1931*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
041266 30 06       1932*  			JR      NC,LEXAN3		; Yes, so skip
041268 CB A9       1933*  			RES     5,C             	; FLAG: NOT IN VARIABLE
04126A CB 99       1934*  			RES     3,C             	; FLAG: NOT IN HEX
04126C CB 91       1935*  			RES	2,C			; FLAG: NOT IN BINARY
04126E             1936*  ;
04126E FE 20       1937*  LEXAN3:			CP      ' '			; Ignore spaces
041270 28 E1       1938*  			JR      Z,LEXAN1
041272 FE 2C       1939*  			CP      ','			; Ignore commas
041274 28 DD       1940*  			JR      Z,LEXAN1
041276 FE 32       1941*  			CP	'2'			; If less than '2'
041278 30 02       1942*  			JR	NC, @F			; No, so skip
04127A CB 91       1943*  			RES	2,C			; FLAG: NOT IN BINARY
04127C FE 47       1944*  @@:			CP      'G'			; If less then 'G'
04127E 38 02       1945*  			JR      C,LEXAN4		; Yes, so skip
041280 CB 99       1946*  			RES     3,C             	; FLAG: NOT IN HEX
041282             1947*  ;
041282 FE 22       1948*  LEXAN4:			CP      34			; Is it a quote character?
041284 20 05       1949*  			JR      NZ,LEXAN5		; No, so skip
041286 CB 11       1950*  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
041288 3F          1951*  			CCF                     	; Toggle the carry
041289 CB 19       1952*  			RR      C			; And then shifting it back into bit 7 of C
04128B             1953*  ;
04128B CB 61       1954*  LEXAN5:			BIT     4,C			; Accept line number?
04128D 28 12       1955*  			JR      Z,LEXAN6		; No, so skip
04128F CB A1       1956*  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
041291 C5          1957*  			PUSH    BC
041292 D5          1958*  			PUSH    DE
041293 CD B1 11 04 1959*  			CALL    LINNUM         		; Parse the line number to HL
041297 D1          1960*  			POP     DE
041298 C1          1961*  			POP     BC
041299 7C          1962*  			LD      A,H			; If it is not zero
04129A B5          1963*  			OR      L
04129B C4 14 13 04 1964*  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
04129F 18 B6       1965*  			JR      LEXAN2          	; And loop
0412A1             1966*  ;
0412A1 0D          1967*  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0412A2 28 0A       1968*  			JR      Z,LEXAN7        	; If so, skip
0412A4 0C          1969*  			INC     C			; Otherwise restore C
0412A5 20 AC       1970*  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0412A7 B7          1971*  			OR      A			; Set the flags based on the character
0412A8 F4 7F 0D 04 1972*  			CALL    P,LEX           	; Tokenise if A < 128
0412AC 18 13       1973*  			JR      LEXAN8			; And skip
0412AE             1974*  ;
0412AE             1975*  ; Processing the LEFT hand side here
0412AE             1976*  ;
0412AE FE 2A       1977*  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0412B0 28 17       1978*  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0412B2 B7          1979*  			OR      A			; Set the flags based on the character
0412B3 F4 7F 0D 04 1980*  			CALL    P,LEX           	; Tokenise if A < 128
0412B7             1981*  ;
0412B7             1982*  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
0412B7             1983*  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
0412B7             1984*  ; Examples:
0412B7             1985*  ;   LET A% = PAGE : REM This is the GET version
0412B7             1986*  ;   PAGE = 40000  : REM This is the SET version
0412B7             1987*  ;
0412B7 FE 8F       1988*  			CP      TOKLO			; TOKLO is 8Fh
0412B9 38 06       1989*  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0412BB FE 94       1990*  			CP      TOKHI+1			; TOKHI is 93h
0412BD 30 02       1991*  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0412BF C6 40       1992*  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0412C1             1993*  ;
0412C1 FE F4       1994*  LEXAN8:			CP      REM			; If the token is REM
0412C3 28 04       1995*  			JR      Z,LEXAN9		; Then stop tokenising
0412C5 FE DC       1996*  			CP      DATA_			; If it is not DATA then
0412C7 20 02       1997*  			JR      NZ,LEXANA		; Skip
0412C9 CB F1       1998*  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0412CB             1999*  ;
0412CB FE A4       2000*  LEXANA:			CP      FN			; If the token is FN
0412CD 28 0A       2001*  			JR      Z,LEXANB
0412CF FE F2       2002*  			CP      PROC			; Or the token is PROC
0412D1 28 06       2003*  			JR      Z,LEXANB		; Then jump to here
0412D3 CD 3D 12 04 2004*  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0412D7 38 02       2005*  			JR      C,LEXANC		; Jump here if out of range
0412D9             2006*  ;
0412D9 CB E9       2007*  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0412DB FE 26       2008*  LEXANC:			CP      '&'			; Check for hex prefix
0412DD 20 02       2009*  			JR      NZ,LEXAND		; If not, skip
0412DF CB D9       2010*  			SET     3,C             	; FLAG: IN HEX
0412E1             2011*  ;
0412E1 FE 25       2012*  LEXAND:			CP	'%'			; Check for binary prefix
0412E3 20 02       2013*  			JR	NZ,LEXANE		; If not, skip
0412E5 CB D1       2014*  			SET	2,C			; FLAG: IN BINARY
0412E7             2015*  ;
0412E7 21 0B 13 04 2016*  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
0412EB C5          2017*  			PUSH    BC
0412EC 01 06 00 00 2018*  			LD      BC,LIST1L		; The list length
0412F0 ED B1       2019*  			CPIR				; Check if the token is in this list
0412F2 C1          2020*  			POP     BC
0412F3 20 02       2021*  			JR      NZ,LEXANF		; If not, then skip
0412F5 CB E1       2022*  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0412F7             2023*  ;
0412F7 21 0F 13 04 2024*  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0412FB C5          2025*  			PUSH    BC
0412FC 01 05 00 00 2026*  			LD      BC,LIST2L		; The list length
041300 ED B1       2027*  			CPIR				; Check if the token is in this list
041302 C1          2028*  			POP     BC
041303 20 02       2029*  			JR      NZ,LEXANG		; If not, then skip
041305 CB C1       2030*  			SET     0,C             	; FLAG: ENTER LEFT MODE
041307 C3 53 12 04 2031*  LEXANG:			JP      LEXAN1			; And loop
04130B             2032*  
04130B             2033*  ;
04130B             2034*  ; LIST1: List of tokens that must be followed by line numbers
04130B             2035*  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
04130B             2036*  ;
04130B E5          2037*  LIST1:			DB	GOTO
04130C E4          2038*  			DB	GOSUB
04130D F7          2039*  			DB	RESTOR
04130E FC          2040*  			DB	TRACE
04130F 8C          2041*  LIST2:			DB	THEN
041310 8B          2042*  			DB	ELSE_
041311             2043*  LIST1L:			EQU     $-LIST1
041311 F5          2044*  			DB	REPEAT
041312 85          2045*  			DB	TERROR
041313 3A          2046*  			DB    	':'
041314             2047*  LIST2L:			EQU     $-LIST2
041314             2048*  ;
041314             2049*  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
041314             2050*  ;   Inputs: HL=line number, DE=string pointer
041314             2051*  ;  Outputs: DE updated, BIT 4,C set.
041314             2052*  ; Destroys: A,B,C,D,E,F
041314             2053*  ;
041314             2054*  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
041314             2055*  ;
041314             2056*  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
041314             2057*  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
041314             2058*  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
041314             2059*  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
041314             2060*  ; each byte are then stored, in LO/HI order, ORred with 0x40.
041314             2061*  ;
041314 CB E1       2062*  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
041316 EB          2063*  			EX      DE, HL			; HL: string pointer, DE: line number
041317 36 8D       2064*  			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
041319 23          2065*  			INC     HL
04131A 7A          2066*  			LD      A,D			; Get the high byte
04131B E6 C0       2067*  			AND     0C0H			; Get the top two bits	DD000000
04131D 0F          2068*  			RRCA				; Shift right		00DD0000
04131E 0F          2069*  			RRCA
04131F 47          2070*  			LD      B,A			; Store in B
041320 7B          2071*  			LD      A,E			; Get the low byte
041321 E6 C0       2072*  			AND     0C0H			; Get the top two bits	EE000000
041323 B0          2073*  			OR      B			; Combine with D	EEDD0000
041324 0F          2074*  			RRCA				; Shift right		00EEDD00
041325 0F          2075*  			RRCA
041326 EE 54       2076*  			XOR     01010100B		; XOR with 54h
041328 77          2077*  			LD      (HL),A			; Store this as the second byte
041329 23          2078*  			INC     HL
04132A 7B          2079*  			LD      A,E			; Get the low byte
04132B E6 3F       2080*  			AND     3FH			; Strip the top two bits off
04132D F6 40       2081*  			OR      '@'			; OR with 40h
04132F 77          2082*  			LD      (HL),A			; Store
041330 23          2083*  			INC     HL
041331 7A          2084*  			LD      A,D			; Get the high byte
041332 E6 3F       2085*  			AND     3FH			; Strip the top two bits off
041334 F6 40       2086*  			OR      '@'			; OR with 40h
041336 77          2087*  			LD      (HL),A			; Store
041337 23          2088*  			INC     HL
041338 EB          2089*  			EX      DE,HL			; DE: string pointer, HL: line number
041339 C9          2090*  			RET
04133A             2091*  ;
04133A             2092*  ; TEXT - OUTPUT MESSAGE.
04133A             2093*  ;   Inputs: HL addresses text (terminated by nul)
04133A             2094*  ;  Outputs: HL addresses character following nul.
04133A             2095*  ; Destroys: A,H,L,F
04133A             2096*  ;
04133A 2A 2F 05 04 2097*  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
04133E             2098*  ;
04133E 7E          2099*  TEXT_:			LD      A, (HL)			; Fetch the character
04133F 23          2100*  			INC     HL			; Increment pointer to next character
041340 B7          2101*  			OR      A			; Check for the nul (0) string terminator
041341 C8          2102*  			RET     Z			; And return if so
041342 CD 24 0F 04 2103*  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
041346 18 F6       2104*  			JR      TEXT_			; And loop
041348             2105*  ;
041348             2106*  ; TELL - OUTPUT MESSAGE.
041348             2107*  ;   Inputs: Text follows subroutine call (term=nul)
041348             2108*  ; Destroys: A,F
041348             2109*  ;
041348             2110*  ; Example usage:
041348             2111*  ;
041348             2112*  ;	CALL	TELL			Call the function
041348             2113*  ;	DB	"Hello World", 0	Followed by a zero terminated string
041348             2114*  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
041348             2115*  ;
041348 E3          2116*  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
041349 CD 3E 13 04 2117*  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
04134D E3          2118*  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
04134E C9          2119*  			RET				; at this point we'll return to the first instruction after the message
04134F             0007       include "eval.asm"
04134F             0001*  ;
04134F             0002*  ; Title:	BBC Basic Interpreter - Z80 version
04134F             0003*  ;		Expression Evaluation & Arithmetic Module - "EVAL"
04134F             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
04134F             0005*  ; Modified By:	Dean Belfield
04134F             0006*  ; Created:	12/05/2023
04134F             0007*  ; Last Updated:	17/08/2023
04134F             0008*  ;
04134F             0009*  ; Modinfo:
04134F             0010*  ; 07/06/2023:	Modified to run in ADL mode
04134F             0011*  ; 26/06/2023:	Fixed HEX and HEXSTR
04134F             0012*  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
04134F             0013*  ; 17/08/2023:	Added binary constants
04134F             0014*  
04134F             0015*  			; .ASSUME	ADL = 1
04134F             0016*  
04134F             0017*  			; INCLUDE	"equs.inc"
04134F             0018*  			; INCLUDE "macros.inc"
04134F             0019*  			; INCLUDE "mos_api.inc"	; In MOS/src
04134F             0020*  
04134F             0021*  			; SEGMENT CODE
04134F             0022*  
04134F             0023*  			; XDEF	EXPR
04134F             0024*  			; XDEF	EXPRN
04134F             0025*  			; XDEF	EXPRI
04134F             0026*  			; XDEF	EXPRS
04134F             0027*  			; XDEF	ITEMI
04134F             0028*  			; XDEF	LOADN
04134F             0029*  			; XDEF	LOAD4
04134F             0030*  			; XDEF	CONS
04134F             0031*  			; XDEF	LOADS
04134F             0032*  			; XDEF	SFIX
04134F             0033*  			; XDEF	VAL0
04134F             0034*  			; XDEF	SEARCH
04134F             0035*  			; XDEF	SWAP
04134F             0036*  			; XDEF	TEST
04134F             0037*  			; XDEF	DECODE
04134F             0038*  			; XDEF	HEXSTR
04134F             0039*  			; XDEF	STR
04134F             0040*  			; XDEF	ZERO
04134F             0041*  			; XDEF	PUSHS
04134F             0042*  			; XDEF	POPS
04134F             0043*  			; XDEF	COMMA
04134F             0044*  			; XDEF	BRAKET
04134F             0045*  			; XDEF	NXT
04134F             0046*  			; XDEF	COUNT0
04134F             0047*  
04134F             0048*  			; XREF	ADVAL
04134F             0049*  			; XREF	FN_EX
04134F             0050*  			; XREF	POINT
04134F             0051*  			; XREF	USR
04134F             0052*  			; XREF	SYNTAX
04134F             0053*  			; XREF	ERROR_
04134F             0054*  			; XREF	CHECK
04134F             0055*  			; XREF	GETVAR
04134F             0056*  			; XREF	LISTON
04134F             0057*  			; XREF	RANGE
04134F             0058*  			; XREF	FPP
04134F             0059*  			; XREF	GETCSR
04134F             0060*  			; XREF	CHANEL
04134F             0061*  			; XREF	OSSTAT
04134F             0062*  			; XREF	OSBGET
04134F             0063*  			; XREF	LOMEM
04134F             0064*  			; XREF	HIMEM
04134F             0065*  			; XREF	PAGE_
04134F             0066*  			; XREF	TOP
04134F             0067*  			; XREF	ERL
04134F             0068*  			; XREF	ERR
04134F             0069*  			; XREF	COUNT
04134F             0070*  			; XREF	OSOPEN
04134F             0071*  			; XREF	GETEXT
04134F             0072*  			; XREF	GETPTR
04134F             0073*  			; XREF	GETIME
04134F             0074*  			; XREF	GETIMS
04134F             0075*  			; XREF	LEXAN2
04134F             0076*  			; XREF	RANDOM
04134F             0077*  			; XREF	STORE5
04134F             0078*  			; XREF	GETSCHR
04134F             0079*  			; XREF	OSRDCH
04134F             0080*  			; XREF	OSKEY
04134F             0081*  			; XREF	INKEY1
04134F             0082*  			; XREF	EXTERR
04134F             0083*  ;
04134F             0084*  ; BINARY FLOATING POINT REPRESENTATION:
04134F             0085*  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04134F             0086*  ;     8 BIT EXCESS-128 SIGNED EXPONENT
04134F             0087*  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04134F             0088*  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04134F             0089*  ;
04134F             0090*  ; BINARY INTEGER REPRESENTATION:
04134F             0091*  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04134F             0092*  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
04134F             0093*  ;
04134F             0094*  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04134F             0095*  ;                             EXPONENT - C
04134F             0096*  ;
04134F             0097*  
04134F             0098*  ;
04134F             0099*  ; Table of addresses for functions
04134F             0100*  ;
04134F             0101*  ; FUNTOK:			EQU	8DH			; First token number
04134F             0102*  ;
04134F 30 1B 04    0103*  FUNTBL:			DW24	DECODE			; Line number
041352 DE 17 04    0104*  			DW24	OPENIN			; OPENIN
041355 00 18 04    0105*  			DW24	PTR_EV			; PTR
041358 9A 17 04    0106*  			DW24	PAGEV			; PAGE
04135B 0A 18 04    0107*  			DW24	TIMEV			; TIME
04135E 86 17 04    0108*  			DW24	LOMEMV			; LOMEM
041361 90 17 04    0109*  			DW24	HIMEMV			; HIMEM
041364 5E 18 04    0110*  			DW24	ABSV			; ABS
041367 9A 18 04    0111*  			DW24	ACS			; ACS
04136A E8 4D 04    0112*  			DW24	ADVAL			; ADVAL
04136D 6F 17 04    0113*  			DW24	ASC			; ASC
041370 92 18 04    0114*  			DW24	ASN			; ASN
041373 96 18 04    0115*  			DW24	ATN			; ATN
041376 38 17 04    0116*  			DW24	BGET			; BGET
041379 7E 18 04    0117*  			DW24	COS			; COS
04137C C5 17 04    0118*  			DW24	COUNTV			; COUNT
04137F 66 18 04    0119*  			DW24	DEG			; DEG
041382 B9 17 04    0120*  			DW24	ERLV			; ERL
041385 BF 17 04    0121*  			DW24	ERRV			; ERR
041388 C3 18 04    0122*  			DW24	EVAL_			; EVAL
04138B 86 18 04    0123*  			DW24	EXP			; EXP
04138E F6 17 04    0124*  			DW24	EXT			; EXT
041391 DD 1B 04    0125*  			DW24	ZERO			; FALSE
041394 CC 22 04    0126*  			DW24	FN_EX			; FN
041397 56 17 04    0127*  			DW24	GET			; GET
04139A 45 17 04    0128*  			DW24	INKEY			; INKEY
04139D 75 19 04    0129*  			DW24	INSTR			; INSTR(
0413A0 72 18 04    0130*  			DW24	INT_			; INT
0413A3 7F 17 04    0131*  			DW24	LEN			; LEN
0413A6 8A 18 04    0132*  			DW24	LN			; LN
0413A9 8E 18 04    0133*  			DW24	LOG			; LOG
0413AC 62 18 04    0134*  			DW24	NOTK			; NOT
0413AF DA 17 04    0135*  			DW24	OPENUP			; OPENUP
0413B2 D7 17 04    0136*  			DW24	OPENOT			; OPENOUT
0413B5 5A 18 04    0137*  			DW24	PI			; PI
0413B8 40 43 04    0138*  			DW24	POINT			; POINT(
0413BB 17 17 04    0139*  			DW24	POS			; POS
0413BE 6A 18 04    0140*  			DW24	RAD			; RAD
0413C1 F7 18 04    0141*  			DW24	RND			; RND
0413C4 6E 18 04    0142*  			DW24	SGN			; SGN
0413C7 82 18 04    0143*  			DW24	SIN			; SIN
0413CA 76 18 04    0144*  			DW24	SQR			; SQR
0413CD 7A 18 04    0145*  			DW24	TAN			; TAN
0413D0 A4 17 04    0146*  			DW24	TOPV			; TO(P)
0413D3 4F 18 04    0147*  			DW24	TRUE			; TRUE
0413D6 99 27 04    0148*  			DW24	USR			; USR
0413D9 B4 18 04    0149*  			DW24	VAL			; VAL
0413DC 20 17 04    0150*  			DW24	VPOS			; VPOS
0413DF 09 1A 04    0151*  			DW24	CHRS			; CHRS
0413E2 11 1A 04    0152*  			DW24	GETS			; GETS
0413E5 22 1A 04    0153*  			DW24	INKEYS			; INKEYS
0413E8 A7 1A 04    0154*  			DW24	LEFTS			; LEFTS(
0413EB 6F 1A 04    0155*  			DW24	MIDS			; MIDS(
0413EE C7 1A 04    0156*  			DW24	RIGHTS			; RIGHTS(
0413F1 94 1B 04    0157*  			DW24	STRS			; STR$
0413F4 E8 1A 04    0158*  			DW24	STRING_			; STRINGS(
0413F7 28 17 04    0159*  			DW24	EOF			; EOF
0413FA             0160*  ;
0413FA             0161*  FUNTBL_END:		EQU	$
0413FA             0162*  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0413FA             0163*  ; TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0413FA             0164*  ;
0413FA             0165*  ; ANDK:			EQU     80H
0413FA             0166*  ; DIVK:			EQU     81H
0413FA             0167*  ; EORK:			EQU     82H
0413FA             0168*  ; MODK:			EQU     83H
0413FA             0169*  ; ORK:			EQU     84H
0413FA             0170*  ;
0413FA 3A 18 04    0171*  SOPTBL:			DW24	SLE			; <= (STRING)
0413FD 43 18 04    0172*  			DW24	SNE			; <>
041400 33 18 04    0173*  			DW24	SGE			; >=
041403 24 18 04    0174*  			DW24	SLT			; <
041406 4A 18 04    0175*  			DW24	SEQ			; =
041409 2B 18 04    0176*  			DW24	SGT			; >
04140C             0177*  ;
04140C             0178*  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
04140C             0179*  ;     Expression type is returned in A'F':
04140C             0180*  ;        Numeric - A' bit 7=0, F' sign bit cleared.
04140C             0181*  ;         String - A' bit 7=1, F' sign bit set.
04140C             0182*  ; Floating-point or integer result returned in HLH'L'C
04140C             0183*  ; Integer result denoted by C=0 and HLH'L' non-zero.
04140C             0184*  ; String result returned in string accumulator, DE set.
04140C             0185*  ;
04140C             0186*  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
04140C             0187*  ;               (2) ^
04140C             0188*  ;               (3) * / MOD DIV
04140C             0189*  ;               (4) + -
04140C             0190*  ;               (5) = <> <= >= > <
04140C             0191*  ;               (6) AND
04140C             0192*  ;               (7) EOR OR
04140C             0193*  
04140C             0194*  ;
04140C             0195*  ; Level 7: EOR and OR
04140C             0196*  ;
04140C CD 25 14 04 0197*  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
041410 FE 82       0198*  EXPR0A:			CP      EORK            	; Is operator EOR?
041412 28 03       0199*  			JR      Z,EXPR0B		; Yes, so skip to next bit
041414 FE 84       0200*  			CP      ORK			; Is operator OR
041416 C0          0201*  			RET     NZ			; No, so return
041417             0202*  ;
041417 CD 8B 1C 04 0203*  EXPR0B:			CALL    SAVE_EV            	; Save first operand
04141B CD 25 14 04 0204*  			CALL    EXPR1           	; Get second operand
04141F CD 9A 1C 04 0205*  			CALL    DOIT            	; Do the operation
041423 18 EB       0206*  			JR      EXPR0A          	; And continue
041425             0207*  ;
041425             0208*  ; Level 6: AND
041425             0209*  ;
041425 CD 3A 14 04 0210*  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
041429 FE 80       0211*  EXPR1A:			CP      ANDK			; Is operator AND?
04142B C0          0212*  			RET     NZ			; No, so return
04142C CD 8B 1C 04 0213*  			CALL    SAVE_EV			; Save first operand
041430 CD 3A 14 04 0214*  			CALL    EXPR2			; Get second operand
041434 CD 9A 1C 04 0215*  			CALL    DOIT			; Do the operation
041438 18 EF       0216*  			JR      EXPR1A			; And continue
04143A             0217*  ;
04143A             0218*  ; Level 5: Comparisons
04143A             0219*  ;
04143A CD AC 14 04 0220*  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
04143E CD 62 1C 04 0221*  			CALL    RELOP?			; Is it ">", "=" or "<"?
041442 C0          0222*  			RET     NZ			; No, so return
041443 47          0223*  			LD      B,A			; Store the first operator in B
041444 FD 23       0224*  			INC     IY              	; Bump over operator
041446 CD BD 1C 04 0225*  			CALL    NXT			;
04144A CD 62 1C 04 0226*  			CALL    RELOP?          	; Is it a compound operator?
04144E 20 09       0227*  			JR      NZ,EXPR2B		; No, so skip next bit
041450 FD 23       0228*  			INC     IY			; Bump over operator
041452 B8          0229*  			CP      B			; Compare with first
041453 CA E4 1E 04 0230*  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
041457 80          0231*  			ADD     A,B
041458 47          0232*  			LD      B,A			; B: Unique code for the compound operator
041459 78          0233*  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
04145A 08          0234*  			EX      AF,AF'
04145B FA 75 14 04 0235*  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
04145F 08          0236*  			EX      AF,AF'
041460 D6 04       0237*  			SUB     4
041462 FE 3A       0238*  			CP      '>'-4
041464 20 02       0239*  			JR      NZ,EXPR2C
041466 C6 02       0240*  			ADD     A,2
041468 CD 8D 1C 04 0241*  EXPR2C:			CALL    SAVE1
04146C CD AC 14 04 0242*  			CALL    EXPR3
041470 CD 9A 1C 04 0243*  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
041474 C9          0244*  			RET
041475             0245*  ;
041475 08          0246*  EXPR2S:			EX      AF,AF'			; Handle string comparisons
041476 3D          0247*  			DEC     A
041477 E6 07       0248*  			AND     7
041479 CD FE 1B 04 0249*  			CALL    PUSHS           	; Save string on the stack
04147D F5          0250*  			PUSH    AF              	; Save the operator
04147E CD AC 14 04 0251*  			CALL    EXPR3           	; Get the second string
041482 08          0252*  			EX      AF,AF'
041483 F2 80 15 04 0253*  			JP      P,TYPE_EV_
041487 F1          0254*  			POP     AF
041488 4B          0255*  			LD      C,E             	; Length of string #2
041489 D1          0256*  			POP     DE
04148A 21 00 00 00 0257*  			LD      HL,0
04148E 39          0258*  			ADD     HL,SP
04148F 43          0259*  			LD      B,E             	; Length of string #1
041490 D5          0260*  			PUSH    DE
041491 11 00 02 04 0261*  			LD      DE,ACCS
041495 EB          0262*  			EX      DE,HL
041496 CD C9 1C 04 0263*  			CALL    DISPT2
04149A D1          0264*  			POP     DE
04149B EB          0265*  			EX      DE,HL
04149C 7D          0266*  			LD	A,L
04149D 21 00 00 00 0267*  			LD	HL,0
0414A1 6F          0268*  			LD	L,A
0414A2 39          0269*  			ADD     HL,SP
0414A3 F9          0270*  			LD      SP,HL
0414A4 EB          0271*  			EX      DE,HL
0414A5 AF          0272*  			XOR     A               	; Numeric marker
0414A6 4F          0273*  			LD      C,A             	; Integer marker
0414A7 08          0274*  			EX      AF,AF'
0414A8 FD 7E 00    0275*  			LD      A,(IY)
0414AB C9          0276*  			RET
0414AC             0277*  ;
0414AC             0278*  ; Level 4: + and -
0414AC             0279*  ;
0414AC CD 0E 15 04 0280*  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0414B0 FE 2D       0281*  EXPR3A:			CP      '-'			; Is it "-"?
0414B2 28 09       0282*  			JR      Z,EXPR3B		; Yes, so skip the next bit
0414B4 FE 2B       0283*  			CP      '+'			; Is it "+"?
0414B6 C0          0284*  			RET     NZ			; No, so return
0414B7 08          0285*  			EX      AF,AF'			; Get the type
0414B8 FA CB 14 04 0286*  			JP      M,EXPR3S		; Branch here if string
0414BC 08          0287*  			EX      AF,AF'
0414BD CD 8B 1C 04 0288*  EXPR3B:			CALL    SAVE_EV			; Save the first operator
0414C1 CD 0E 15 04 0289*  			CALL    EXPR4			; Fetch the second operator
0414C5 CD 9A 1C 04 0290*  			CALL    DOIT			; Do the operation
0414C9 18 E5       0291*  			JR      EXPR3A			; And continue
0414CB             0292*  ;
0414CB 08          0293*  EXPR3S:			EX      AF,AF'			; Handle string concatenation
0414CC FD 23       0294*  			INC     IY              	; Bump past the "+"
0414CE CD FE 1B 04 0295*  			CALL    PUSHS           	; Save the string on the stack
0414D2 CD 0E 15 04 0296*  			CALL    EXPR4           	; Fetch the second operator
0414D6 08          0297*  			EX      AF,AF'
0414D7 F2 80 15 04 0298*  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0414DB 01 00 00 00 0299*  			LD	BC, 0			; Clear BC
0414DF 4B          0300*  			LD      C,E             	; C: Length of the second string
0414E0 D1          0301*  			POP     DE
0414E1 D5          0302*  			PUSH    DE
0414E2 21 00 02 04 0303*  			LD      HL,ACCS
0414E6 7B          0304*  			LD	A,E			;  E: Length of the first string
0414E7 11 00 02 04 0305*  			LD      DE,ACCS
0414EB 5F          0306*  			LD	E,A 			; DE: Pointer to the end of the first string
0414EC 79          0307*  			LD      A,C
0414ED B7          0308*  			OR      A
0414EE 28 0F       0309*  			JR      Z,EXP3S3
0414F0 6F          0310*  			LD      L,A             	; Source
0414F1 83          0311*  			ADD     A,E
0414F2 5F          0312*  			LD      E,A             	; Destination
0414F3 3E 13       0313*  			LD      A,19
0414F5 DA 18 0D 04 0314*  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0414F9 D5          0315*  			PUSH    DE
0414FA 1D          0316*  			DEC     E
0414FB 2D          0317*  			DEC     L
0414FC ED B8       0318*  			LDDR                    	; Copy
0414FE D1          0319*  			POP     DE
0414FF D9          0320*  EXP3S3:			EXX
041500 C1          0321*  			POP     BC
041501 CD 2B 1C 04 0322*  			CALL    POPS            	; Restore from stack
041505 D9          0323*  			EXX
041506 F6 80       0324*  			OR      80H             	; Flag as a string
041508 08          0325*  			EX      AF,AF'
041509 FD 7E 00    0326*  			LD      A,(IY)			; Fetch the next character
04150C 18 A2       0327*  			JR      EXPR3A			; And continue
04150E             0328*  ;
04150E             0329*  ; Level 3: * / MOD DIV
04150E             0330*  ;
04150E CD 2F 15 04 0331*  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
041512 FE 2A       0332*  EXPR4A:			CP      '*'			; "*" is valid
041514 28 0B       0333*  			JR      Z,EXPR4B
041516 FE 2F       0334*  			CP      '/'			; "/" is valid
041518 28 07       0335*  			JR      Z,EXPR4B
04151A FE 83       0336*  			CP      MODK			; MOD token is valid
04151C 28 03       0337*  			JR      Z,EXPR4B
04151E FE 81       0338*  			CP      DIVK			; DIV token is valid
041520 C0          0339*  			RET     NZ			; And return if it is anything else
041521 CD 8B 1C 04 0340*  EXPR4B:			CALL    SAVE_EV
041525 CD 2F 15 04 0341*  			CALL    EXPR5
041529 CD 9A 1C 04 0342*  			CALL    DOIT
04152D 18 E3       0343*  			JR      EXPR4A
04152F             0344*  ;
04152F             0345*  ; Level 2: ^
04152F             0346*  ;
04152F CD 0F 16 04 0347*  EXPR5:			CALL    ITEM			; Get variable
041533 B7          0348*  			OR      A               	; Test type
041534 08          0349*  			EX      AF,AF'          	; Save type
041535 CD BD 1C 04 0350*  EXPR5A:			CALL    NXT			; Skip spaces
041539 FE 5E       0351*  			CP      '^'			; Is the operator "^"?
04153B C0          0352*  			RET     NZ			; No, so return
04153C CD 8B 1C 04 0353*  			CALL    SAVE_EV			; Save first operand
041540 CD 0F 16 04 0354*  			CALL    ITEM			; Get second operand
041544 B7          0355*  			OR      A			; Test type
041545 08          0356*  			EX      AF,AF'			; Save type
041546 CD 9A 1C 04 0357*  			CALL    DOIT			; Do the operation
04154A 18 E9       0358*  			JR      EXPR5A			; And continue
04154C             0359*  ;
04154C             0360*  ; Evaluate a numeric expression
04154C             0361*  ;
04154C CD 0C 14 04 0362*  EXPRN:			CALL    EXPR			; Evaluate expression
041550 08          0363*  			EX      AF,AF'			; Get the type
041551 F0          0364*  			RET     P			; And return if it is a number
041552 18 2C       0365*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041554             0366*  ;
041554             0367*  ; Evaluate a fixed-point expression
041554             0368*  ;
041554 CD 0C 14 04 0369*  EXPRI:			CALL    EXPR			; Evaluate the expression
041558 08          0370*  			EX      AF,AF'			; Get the type
041559 F2 AC 18 04 0371*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
04155D 18 21       0372*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04155F             0373*  ;
04155F             0374*  ; Evaluate a string expression
04155F             0375*  ;
04155F CD 0C 14 04 0376*  EXPRS:			CALL    EXPR			; Evaluate the expression
041563 08          0377*  			EX      AF,AF'			; Get the type
041564 F8          0378*  			RET     M			; And return if it is a string
041565 18 19       0379*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041567             0380*  ;
041567             0381*  ; Get a numeric variable
041567             0382*  ;
041567 CD 0F 16 04 0383*  ITEMN:			CALL    ITEM			; Get the variable
04156B B7          0384*  			OR      A			; Test the type
04156C F0          0385*  			RET     P			; And return if it is a number
04156D 18 11       0386*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04156F             0387*  ;
04156F             0388*  ; Get a fixed-point variable
04156F             0389*  ;
04156F CD 0F 16 04 0390*  ITEMI:			CALL    ITEM			; Get the variable
041573 B7          0391*  			OR      A			; Test the type
041574 F2 AC 18 04 0392*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
041578 18 06       0393*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04157A             0394*  ;
04157A             0395*  ; Get a string variable
04157A             0396*  ;
04157A CD 0F 16 04 0397*  ITEMS:			CALL    ITEM			; Get the variable
04157E B7          0398*  			OR      A			; Test the type
04157F F8          0399*  			RET     M			; If it is a string, then return
041580             0400*  ;							; Otherwise
041580 3E 06       0401*  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
041582 C3 18 0D 04 0402*  			JP      ERROR_
041586             0403*  ;
041586             0404*  ; Evaluate a bracketed expression
041586             0405*  ;
041586 CD 0C 14 04 0406*  ITEM1:			CALL    EXPR            	; Evaluate the expression
04158A CD 7C 1C 04 0407*  			CALL    BRAKET			; Check for closing bracket
04158E 08          0408*  			EX      AF,AF'
04158F C9          0409*  			RET
041590             0410*  ;
041590             0411*  ; HEX - Get hexadecimal constant.
041590             0412*  ;   Inputs: ASCII string at (IY)
041590             0413*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
041590             0414*  ;           IY updated (points to delimiter)
041590             0415*  ;
041590 CD DD 1B 04 0416*  HEX:			CALL    ZERO			; Set result to 0
041594 CD 45 1C 04 0417*  			CALL    HEXDIG			; Fetch the character from IY
041598 38 1B       0418*  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
04159A FD 23       0419*  HEX1:			INC     IY			; Move pointer to next character
04159C E6 0F       0420*  			AND     0FH			; Clear the top nibble
04159E 06 04       0421*  			LD      B,4			; Loop counter
0415A0             0422*  ;
0415A0 D9          0423*  HEX2:			EXX				; Shift the result left B (4) times. This makes
0415A1 52 29       0424*  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0415A3 D9          0425*  			EXX				; .
0415A4 52 ED 6A    0426*  			ADC.S   HL,HL			; .
0415A7 10 F7       0427*  			DJNZ    HEX2			; And loop
0415A9 D9          0428*  			EXX
0415AA B5          0429*  			OR      L			; OR in the digit
0415AB 6F          0430*  			LD      L,A
0415AC D9          0431*  			EXX
0415AD             0432*  ;
0415AD CD 45 1C 04 0433*  			CALL    HEXDIG			; Fetch the next character
0415B1 30 E7       0434*  			JR      NC,HEX1			; If it is a HEX digit then loop
0415B3 AF          0435*  			XOR     A			; Clear A
0415B4 C9          0436*  			RET
0415B5             0437*  ;
0415B5 3E 1C       0438*  BADHEX:			LD      A,28
0415B7 C3 18 0D 04 0439*  			JP      ERROR_          	; Error: "Bad HEX"
0415BB             0440*  ;
0415BB             0441*  ; BIN - Get binary constant.
0415BB             0442*  ;   Inputs: ASCII string at (IY)
0415BB             0443*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0415BB             0444*  ;           IY updated (points to delimiter)
0415BB             0445*  ;
0415BB CD DD 1B 04 0446*  BIN:			CALL    ZERO			; Set result to 0
0415BF CD 58 1C 04 0447*  			CALL	BINDIG			; Fetch the character from IY
0415C3 38 13       0448*  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0415C5 FD 23       0449*  BIN1:			INC	IY			; Move pointer to next character
0415C7 0F          0450*  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0415C8 D9          0451*  			EXX				;
0415C9 52 ED 6A    0452*  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0415CC D9          0453*  			EXX
0415CD 52 ED 6A    0454*  			ADC.S	HL,HL
0415D0 CD 58 1C 04 0455*  			CALL	BINDIG			; Fetch the next character
0415D4 30 EF       0456*  			JR	NC,BIN1
0415D6 AF          0457*  			XOR	A			; Clear A
0415D7 C9          0458*  			RET
0415D8             0459*  ;
0415D8 3E 1C       0460*  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0415DA CD 2F 0D 04 0461*  			CALL	EXTERR
0415DE 42 61 64 20 0462*  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0415E9             0463*  ;
0415E9             0464*  ; MINUS - Unary minus.
0415E9             0465*  ;   Inputs: IY = text pointer
0415E9             0466*  ;  Outputs: Numeric result, same type as argument.
0415E9             0467*  ;           Result in H'L'HLC
0415E9             0468*  ;
0415E9 CD 67 15 04 0469*  MINUS:			CALL    ITEMN			; Get the numeric argument
0415ED 0D          0470*  MINUS0:			DEC     C			; Check exponent (C)
0415EE 0C          0471*  			INC     C			; If it is zero, then it's either a FP zero or an integer
0415EF 28 06       0472*  			JR      Z,NEGATE_EV        	; So do an integer negation
0415F1             0473*  ;
0415F1 7C          0474*  			LD      A,H			; Do a FP negation by
0415F2 EE 80       0475*  			XOR     80H             	; Toggling the sign bit (H)
0415F4 67          0476*  			LD      H,A
0415F5 AF          0477*  			XOR     A               	; Numeric marker
0415F6 C9          0478*  			RET
0415F7             0479*  ;
0415F7 D9          0480*  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0415F8 7C          0481*  			LD      A,H			; First do a one's complement by negating all the bytes
0415F9 2F          0482*  			CPL
0415FA 67          0483*  			LD      H,A
0415FB 7D          0484*  			LD      A,L
0415FC 2F          0485*  			CPL
0415FD 6F          0486*  			LD      L,A
0415FE D9          0487*  			EXX
0415FF 7C          0488*  			LD      A,H
041600 2F          0489*  			CPL
041601 67          0490*  			LD      H,A
041602 7D          0491*  			LD      A,L
041603 2F          0492*  			CPL
041604 6F          0493*  			LD      L,A
041605 D9          0494*  ADD1:			EXX				; Then add 1
041606 23          0495*  			INC     HL
041607 7C          0496*  			LD      A,H
041608 B5          0497*  			OR      L
041609 D9          0498*  			EXX
04160A 3E 00       0499*  			LD      A,0             	; Numeric marker
04160C C0          0500*  			RET     NZ
04160D 23          0501*  			INC     HL
04160E C9          0502*  			RET
04160F             0503*  ;
04160F             0504*  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
04160F             0505*  ; Item type is returned in A:  Bit 7=0 numeric.
04160F             0506*  ;                              Bit 7=1 string.
04160F             0507*  ; Numeric item returned in HLH'L'C.
04160F             0508*  ; String item returned in string accumulator,
04160F             0509*  ;   DE addresses byte after last (E=length).
04160F             0510*  ;
04160F CD C6 28 04 0511*  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
041613 CD BD 1C 04 0512*  			CALL    NXT			; Skip spaces
041617 FD 23       0513*  			INC     IY			; Move to the prefix character
041619 FE 26       0514*  			CP      '&'			; If `&`
04161B CA 90 15 04 0515*  			JP      Z,HEX           	; Then get a HEX constant
04161F FE 25       0516*  			CP	'%'			; If '%'
041621 28 98       0517*  			JR	Z,BIN			; Then get a BINARY constant
041623 FE 2D       0518*  			CP      '-'			; If `-`
041625 28 C2       0519*  			JR      Z,MINUS         	; Then get a negative number
041627 FE 2B       0520*  			CP      '+'			; If `+`
041629 CA 67 15 04 0521*  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
04162D FE 28       0522*  			CP      '('			; If `(`
04162F CA 86 15 04 0523*  			JP      Z,ITEM1         	; Start of a bracketed expression
041633 FE 22       0524*  			CP      34			; If `"`
041635 28 7A       0525*  			JR      Z,CONS          	; Start of a string constant
041637 FE C6       0526*  			CP      TCMD			; Is it out of range of the function table?
041639 D2 E4 1E 04 0527*  			JP      NC,SYNTAX       	; Error: "Syntax Error"
04163D FE 8D       0528*  			CP      FUNTOK			; If it is in range, then
04163F D2 D0 1C 04 0529*  			JP      NC,DISPAT       	; It's a function
041643 FD 2B       0530*  			DEC     IY
041645 FE 3A       0531*  			CP      ':'
041647 30 0C       0532*  			JR      NC,ITEM2		; VARIABLE?
041649 FE 30       0533*  			CP      '0'
04164B D2 D8 16 04 0534*  			JP      NC,CON			; NUMERIC CONSTANT
04164F FE 2E       0535*  			CP      '.'
041651 CA D8 16 04 0536*  			JP      Z,CON			; NUMERIC CONSTANT
041655 CD F2 0F 04 0537*  ITEM2:			CALL    GETVAR			; VARIABLE
041659 20 37       0538*  			JR      NZ,NOSUCH
04165B B7          0539*  			OR      A
04165C FA EA 16 04 0540*  			JP      M,LOADS			; STRING VARIABLE
041660 B7          0541*  LOADN:			OR      A
041661 28 20       0542*  			JR      Z,LOAD1			; BYTE VARIABLE
041663 0E 00       0543*  			LD      C,0
041665 CB 47       0544*  			BIT     0,A
041667 28 03       0545*  			JR      Z,LOAD4			; INTEGER VARIABLE
041669 DD 4E 04    0546*  LOAD5:			LD      C,(IX+4)
04166C D9          0547*  LOAD4:			EXX
04166D 21 00 00 00 0548*  			LD	HL, 0			; TODO: Optimise
041671 DD 6E 00    0549*  			LD      L,(IX+0)
041674 DD 66 01    0550*  			LD      H,(IX+1)
041677 D9          0551*  			EXX
041678 21 00 00 00 0552*  			LD	HL, 0			; TODO: Optimise
04167C DD 6E 02    0553*  			LD      L,(IX+2)
04167F DD 66 03    0554*  			LD      H,(IX+3)
041682 C9          0555*  			RET
041683             0556*  ;
041683 21 00 00 00 0557*  LOAD1:			LD      HL,0
041687 D9          0558*  			EXX
041688 21 00 00 00 0559*  			LD      HL,0			; TODO: Optimise
04168C DD 6E 00    0560*  			LD      L,(IX+0)
04168F D9          0561*  			EXX
041690 4C          0562*  			LD      C,H
041691 C9          0563*  			RET
041692             0564*  ;
041692 DA E4 1E 04 0565*  NOSUCH:			JP      C,SYNTAX
041696 3A 40 05 04 0566*  			LD      A,(LISTON)
04169A CB 6F       0567*  			BIT     5,A
04169C 3E 1A       0568*  			LD      A,26
04169E 20 26       0569*  			JR      NZ,ERROR0_EV		; Throw "No such variable"
0416A0 FD 23       0570*  NOS1:			INC     IY
0416A2 CD 27 12 04 0571*  			CALL    RANGE
0416A6 30 F8       0572*  			JR      NC,NOS1
0416A8 DD 21 40 10 0573*  			LD      IX,PC
       10          
0416AD AF          0574*  			XOR     A
0416AE 4F          0575*  			LD      C,A
0416AF 18 BB       0576*  			JR      LOAD4
0416B1             0577*  ;
0416B1             0578*  ;CONS - Get string constant from ASCII string.
0416B1             0579*  ;   Inputs: ASCII string at (IY)
0416B1             0580*  ;  Outputs: Result in string accumulator.
0416B1             0581*  ;           D = MS byte of ACCS, E = string length
0416B1             0582*  ;           A7 = 1 (string marker)
0416B1             0583*  ;           IY updated
0416B1             0584*  ;
0416B1 11 00 02 04 0585*  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0416B5 FD 7E 00    0586*  CONS3:			LD      A,(IY)			; Fetch the first character and
0416B8 FD 23       0587*  			INC     IY			; Increment the pointer
0416BA FE 22       0588*  			CP      '"'			; Check for start quote
0416BC 28 0C       0589*  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0416BE             0590*  ;
0416BE 12          0591*  CONS1:			LD      (DE),A			; Store the character in the string accumulator
0416BF 1C          0592*  			INC     E			; Increment the string accumulator pointer
0416C0 FE 0D       0593*  			CP      CR			; Is it CR
0416C2 20 F1       0594*  			JR      NZ,CONS3		; No, so keep looping
0416C4             0595*  ;
0416C4 3E 09       0596*  			LD      A,9
0416C6 C3 18 0D 04 0597*  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
0416CA             0598*  ;
0416CA FD 7E 00    0599*  CONS2:			LD      A,(IY)			; Fetch the next character
0416CD FE 22       0600*  			CP      '"'			; Check for end quote?
0416CF FD 23       0601*  			INC     IY			; Increment the pointer
0416D1 28 EB       0602*  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0416D3 FD 2B       0603*  			DEC     IY			;
0416D5 3E 80       0604*  			LD      A,80H           	; String marker
0416D7 C9          0605*  			RET
0416D8             0606*  ;
0416D8             0607*  ;CON - Get unsigned numeric constant from ASCII string.
0416D8             0608*  ;   Inputs: ASCII string at (IY).
0416D8             0609*  ;  Outputs: Variable-type result in HLH'L'C
0416D8             0610*  ;           IY updated (points to delimiter)
0416D8             0611*  ;           A7 = 0 (numeric marker)
0416D8             0612*  ;
0416D8 FD E5       0613*  CON:			PUSH    IY
0416DA DD E1       0614*  			POP     IX
0416DC 3E 24       0615*  			LD      A,36
0416DE CD E7 32 04 0616*  			CALL    FPP
0416E2 38 E2       0617*  			JR      C,ERROR0_EV
0416E4 DD E5       0618*  			PUSH    IX
0416E6 FD E1       0619*  			POP     IY
0416E8 AF          0620*  			XOR     A
0416E9 C9          0621*  			RET
0416EA             0622*  ;
0416EA 11 00 02 04 0623*  LOADS:			LD      DE,ACCS			; Where to store the string
0416EE 1F          0624*  			RRA
0416EF 30 1A       0625*  			JR      NC,LOADS2       	; Skip if it is a fixed string
0416F1             0626*  ;
0416F1 D9          0627*  			EXX				; This block was a call to LOAD4
0416F2 DD 6E 00    0628*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0416F5 DD 66 01    0629*  			LD      H,(IX+1)		; The maximum original string length
0416F8 D9          0630*  			EXX
0416F9 DD 27 02    0631*  			LD	HL,(IX+2)		; Address of the string (24-bit)
0416FC             0632*  ;
0416FC D9          0633*  			EXX
0416FD 7D          0634*  			LD      A,L
0416FE D9          0635*  			EXX
0416FF B7          0636*  			OR      A
041700 01 00 00 00 0637*  			LD	BC,0			; BC: Number of bytes to copy
041704 4F          0638*  			LD      C,A
041705 3E 80       0639*  			LD      A,80H           	; String marker
041707 C8          0640*  			RET     Z
041708 ED B0       0641*  			LDIR
04170A C9          0642*  			RET
04170B 7E          0643*  LOADS2:			LD      A,(HL)
04170C 12          0644*  			LD      (DE),A
04170D 23          0645*  			INC     HL
04170E FE 0D       0646*  			CP      CR
041710 3E 80       0647*  			LD      A,80H           	; String marker
041712 C8          0648*  			RET     Z
041713 1C          0649*  			INC     E
041714 20 F5       0650*  			JR      NZ,LOADS2
041716 C9          0651*  			RET                     	; Return null string
041717             0652*  ;
041717             0653*  ;VARIABLE-TYPE FUNCTIONS:
041717             0654*  ;
041717             0655*  ;Result returned in HLH'L'C (floating point)
041717             0656*  ;Result returned in HLH'L' (C=0) (integer)
041717             0657*  ;Result returned in string accumulator & DE (string)
041717             0658*  ;All registers destroyed.
041717             0659*  ;IY (text pointer) updated.
041717             0660*  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
041717             0661*  ;
041717             0662*  ;POS - horizontal cursor position.
041717             0663*  ;VPOS - vertical cursor position.
041717             0664*  ;EOF - return status of file.
041717             0665*  ;BGET - read byte from file.
041717             0666*  ;INKEY - as GET but wait only n centiseconds.
041717             0667*  ;GET - wait for keypress and return ASCII value.
041717             0668*  ;GET(n) - input from Z80 port n.
041717             0669*  ;ASC - ASCII value of string.
041717             0670*  ;LEN - length of string.
041717             0671*  ;LOMEM - location of dynamic variables.
041717             0672*  ;HIMEM - top of available RAM.
041717             0673*  ;PAGE - start of current text page.
041717             0674*  ;TOP - address of first free byte after program.
041717             0675*  ;ERL - line number where last error occurred.
041717             0676*  ;ERR - number of last error.
041717             0677*  ;COUNT - number of printing characters since CR.
041717             0678*  ;Results are integer numeric.
041717             0679*  ;
041717 CD EC 48 04 0680*  POS:			CALL    GETCSR			; Return the horizontal cursor position
04171B EB          0681*  			EX      DE,HL			;  L: The X cursor position
04171C C3 CB 17 04 0682*  			JP      COUNT1			; Return an 8-bit value
041720             0683*  ;
041720 CD EC 48 04 0684*  VPOS:			CALL    GETCSR			; Return the vertical cursor position
041724 C3 CB 17 04 0685*  			JP      COUNT1			; Return an 8-bit value
041728             0686*  ;
041728 CD FD 2A 04 0687*  EOF:			CALL    CHANEL			; Check for EOF
04172C CD 75 4D 04 0688*  			CALL    OSSTAT
041730 CA 4F 18 04 0689*  			JP      Z,TRUE			; Yes, so return true
041734 C3 DD 1B 04 0690*  			JP      ZERO			; Otherwise return false (zero)
041738             0691*  ;
041738 CD FD 2A 04 0692*  BGET:			CALL    CHANEL          	; Channel number
04173C CD 64 4D 04 0693*  			CALL    OSBGET
041740 6F          0694*  			LD      L,A
041741 C3 C9 17 04 0695*  			JP      COUNT0			; Return an 8-bit value
041745             0696*  ;
041745 CD 6F 15 04 0697*  INKEY:			CALL    ITEMI			; Get the argument
041749 CB 7C       0698*  			BIT	7, H			; Check the sign
04174B D9          0699*  			EXX				; HL: The argument
04174C C2 35 1A 04 0700*  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
041750 CD 27 1A 04 0701*  			CALL	INKEY0 			; Do INKEY(n)
041754 18 1D       0702*  			JR      ASC0			; Return a numeric value
041756             0703*  ;
041756 CD BD 1C 04 0704*  GET:			CALL    NXT			; Skip whitespace
04175A FE 28       0705*  			CP      '('			; Is it GET(
04175C 20 0B       0706*  			JR      NZ,GET0			; No, so get a keyboard character
04175E CD 6F 15 04 0707*  			CALL    ITEMI           	; Yes, so fetch the port address
041762 D9          0708*  			EXX
041763 44          0709*  			LD      B,H			; BC: The port address
041764 4D          0710*  			LD      C,L
041765 ED 68       0711*  			IN      L,(C)           	;  L: Input from port BC
041767 18 60       0712*  			JR      COUNT0			; Return an 8-bit value
041769             0713*  ;
041769 CD 11 1A 04 0714*  GET0:			CALL    GETS			; Read the keyboard character
04176D 18 0A       0715*  			JR      ASC1			; And return the value
04176F             0716*  ;
04176F CD 7A 15 04 0717*  ASC:			CALL    ITEMS			; Get the string argument argument
041773 AF          0718*  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
041774 BB          0719*  			CP      E			; Is the pointer 0
041775 CA 4F 18 04 0720*  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
041779 2A 00 02 04 0721*  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
04177D 18 4A       0722*  			JR      COUNT0			; An 8-bit value
04177F             0723*  ;
04177F CD 7A 15 04 0724*  LEN:			CALL    ITEMS			; Get the string argument
041783 EB          0725*  			EX      DE,HL			; HL: Pointer into ACCS
041784 18 43       0726*  			JR      COUNT0			; Return L
041786             0727*  ;
041786 2A 1A 05 04 0728*  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
04178A 3A 1C 05 04 0729*  			LD	A, (LOMEM+2)
04178E 18 41       0730*  			JR      COUNT2			; A 24-bit value
041790             0731*  ;
041790 2A 20 05 04 0732*  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
041794 3A 22 05 04 0733*  			LD	A, (HIMEM+2)
041798 18 37       0734*  			JR      COUNT2			; A 24-bit value
04179A             0735*  ;
04179A 2A 14 05 04 0736*  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
04179E 3A 16 05 04 0737*  			LD	A, (PAGE_+2)		; A 24-bit value
0417A2 18 2D       0738*  			JR      COUNT2
0417A4             0739*  ;
0417A4 FD 7E 00    0740*  TOPV:			LD      A,(IY)			; Return the TOP system variable
0417A7 FD 23       0741*  			INC     IY              	; Skip "P"
0417A9 FE 50       0742*  			CP      'P'
0417AB C2 E4 1E 04 0743*  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
0417AF 2A 17 05 04 0744*  			LD      HL,(TOP)
0417B3 3A 19 05 04 0745*  			LD	A, (TOP+2)
0417B7 18 18       0746*  			JR      COUNT2
0417B9             0747*  ;
0417B9 2A 33 05 04 0748*  ERLV:			LD      HL,(ERL)		; Return the error line
0417BD 18 0C       0749*  			JR      COUNT1			; A 16-bit value
0417BF             0750*  ;
0417BF 2A 3F 05 04 0751*  ERRV:			LD      HL,(ERR)		; Return the error value
0417C3 18 04       0752*  			JR      COUNT0			; An 8-bit value
0417C5             0753*  ;
0417C5 2A 3D 05 04 0754*  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0417C9             0755*  
0417C9 26 00       0756*  COUNT0:			LD      H,0			; Return L
0417CB D9          0757*  COUNT1:			EXX				; Return HL
0417CC AF          0758*  			XOR     A
0417CD 4F          0759*  			LD      C,A             	; Integer marker
0417CE 67          0760*  			LD      H,A
0417CF 6F          0761*  			LD      L,A
0417D0 C9          0762*  			RET
0417D1 D9          0763*  COUNT2:			EXX
0417D2 6F          0764*  			LD	L,A
0417D3 AF          0765*  			XOR	A
0417D4 4F          0766*  			LD	C,A			; Integer marker
0417D5 67          0767*  			LD	H,A
0417D6 C9          0768*  			RET
0417D7             0769*  ;
0417D7             0770*  ;OPENIN - Open a file for reading.
0417D7             0771*  ;OPENOT - Open a file for writing.
0417D7             0772*  ;OPENUP - Open a file for reading or writing.
0417D7             0773*  ;Result is integer channel number (0 if error)
0417D7             0774*  ;
0417D7 AF          0775*  OPENOT:			XOR     A			; Open for writing
0417D8 18 06       0776*  			JR	OPENIN_1
0417DA             0777*  ;
0417DA 3E 02       0778*  OPENUP:			LD      A,2			; Open for reading / writing
0417DC 18 02       0779*  			JR	OPENIN_1
0417DE             0780*  ;
0417DE 3E 01       0781*  OPENIN:			LD      A,1			; Open for reading
0417E0             0782*  ;
0417E0 F5          0783*  OPENIN_1:		PUSH    AF              	; Save OPEN type
0417E1 CD 7A 15 04 0784*  			CALL    ITEMS           	; Fetch the filename
0417E5 3E 0D       0785*  			LD      A,CR
0417E7 12          0786*  			LD      (DE),A
0417E8 F1          0787*  			POP     AF              	; Restore the OPEN type
0417E9 C6 FF       0788*  			ADD     A,-1            	; Affect the flags
0417EB 21 00 02 04 0789*  			LD      HL,ACCS
0417EF CD 4D 4D 04 0790*  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0417F3 6F          0791*  			LD      L,A			; L: Channel number
0417F4 18 D3       0792*  			JR      COUNT0			; Return channel number to BASIC
0417F6             0793*  ;
0417F6             0794*  ;EXT - Return length of file.
0417F6             0795*  ;PTR_EV - Return current file pointer.
0417F6             0796*  ;Results are integer numeric.
0417F6             0797*  ;
0417F6 CD FD 2A 04 0798*  EXT:			CALL    CHANEL
0417FA CD AB 4D 04 0799*  			CALL    GETEXT
0417FE 18 15       0800*  			JR      TIME0
041800             0801*  ;
041800 CD FD 2A 04 0802*  PTR_EV:			CALL    CHANEL
041804 CD 7F 4D 04 0803*  			CALL    GETPTR
041808 18 0B       0804*  			JR      TIME0
04180A             0805*  ;
04180A             0806*  ;TIME - Return current value of elapsed time.
04180A             0807*  ;Result is integer numeric.
04180A             0808*  ;
04180A FD 7E 00    0809*  TIMEV:			LD      A,(IY)
04180D FE 24       0810*  			CP      '$'
04180F 28 0A       0811*  			JR      Z,TIMEVS
041811 CD CC 48 04 0812*  			CALL    GETIME
041815 D5          0813*  TIME0:			PUSH    DE
041816 D9          0814*  			EXX
041817 E1          0815*  			POP     HL
041818 AF          0816*  			XOR     A
041819 4F          0817*  			LD      C,A
04181A C9          0818*  			RET
04181B             0819*  ;
04181B             0820*  ;TIME$ - Return date/time string.
04181B             0821*  ;Result is string
04181B             0822*  ;
04181B FD 23       0823*  TIMEVS:			INC     IY              ;SKIP $
04181D CD C4 4D 04 0824*  			CALL    GETIMS
041821 3E 80       0825*  			LD      A,80H           ;MARK STRING
041823 C9          0826*  			RET
041824             0827*  ;
041824             0828*  ;String comparison:
041824             0829*  ;
041824 CD D9 1B 04 0830*  SLT:			CALL    SCP
041828 D0          0831*  			RET     NC
041829 18 24       0832*  			JR      TRUE
04182B             0833*  ;
04182B CD D9 1B 04 0834*  SGT:			CALL    SCP
04182F C8          0835*  			RET     Z
041830 D8          0836*  			RET     C
041831 18 1C       0837*  			JR      TRUE
041833             0838*  ;
041833 CD D9 1B 04 0839*  SGE:			CALL    SCP
041837 D8          0840*  			RET     C
041838 18 15       0841*  			JR      TRUE
04183A             0842*  ;
04183A CD D9 1B 04 0843*  SLE:			CALL    SCP
04183E 28 0F       0844*  			JR      Z,TRUE
041840 D0          0845*  			RET     NC
041841 18 0C       0846*  			JR      TRUE
041843             0847*  ;
041843 CD D9 1B 04 0848*  SNE:			CALL    SCP
041847 C8          0849*  			RET     Z
041848 18 05       0850*  			JR      TRUE
04184A             0851*  ;
04184A CD D9 1B 04 0852*  SEQ:			CALL    SCP
04184E C0          0853*  			RET     NZ
04184F 3E FF       0854*  TRUE:			LD      A,-1
041851 D9          0855*  			EXX
041852 67          0856*  			LD      H,A
041853 6F          0857*  			LD      L,A
041854 D9          0858*  			EXX
041855 67          0859*  			LD      H,A
041856 6F          0860*  			LD      L,A
041857 3C          0861*  			INC     A
041858 4F          0862*  			LD      C,A
041859 C9          0863*  			RET
04185A             0864*  ;
04185A             0865*  ;PI - Return PI (3.141592654)
04185A             0866*  ;Result is floating-point numeric.
04185A             0867*  ;
04185A 3E 23       0868*  PI:			LD      A,35
04185C 18 44       0869*  			JR      FPP1
04185E             0870*  ;
04185E             0871*  ;ABS - Absolute value
04185E             0872*  ;Result is numeric, variable type.
04185E             0873*  ;
04185E 3E 10       0874*  ABSV:			LD      A,16
041860 18 3A       0875*  			JR      FPPN
041862             0876*  ;
041862             0877*  ;NOT - Complement integer.
041862             0878*  ;Result is integer numeric.
041862             0879*  ;
041862 3E 1A       0880*  NOTK:			LD      A,26
041864 18 36       0881*  			JR      FPPN
041866             0882*  ;
041866             0883*  ;DEG - Convert radians to degrees
041866             0884*  ;Result is floating-point numeric.
041866             0885*  ;
041866 3E 15       0886*  DEG:			LD      A,21
041868 18 32       0887*  			JR      FPPN
04186A             0888*  ;
04186A             0889*  ;RAD - Convert degrees to radians
04186A             0890*  ;Result is floating-point numeric.
04186A             0891*  ;
04186A 3E 1B       0892*  RAD:			LD      A,27
04186C 18 2E       0893*  			JR      FPPN
04186E             0894*  ;
04186E             0895*  ;SGN - Return -1, 0 or +1
04186E             0896*  ;Result is integer numeric.
04186E             0897*  ;
04186E 3E 1C       0898*  SGN:			LD      A,28
041870 18 2A       0899*  			JR      FPPN
041872             0900*  ;
041872             0901*  ;INT - Floor function
041872             0902*  ;Result is integer numeric.
041872             0903*  ;
041872 3E 17       0904*  INT_:			LD      A,23
041874 18 26       0905*  			JR      FPPN
041876             0906*  ;
041876             0907*  ;SQR - square root
041876             0908*  ;Result is floating-point numeric.
041876             0909*  ;
041876 3E 1E       0910*  SQR:			LD      A,30
041878 18 22       0911*  			JR      FPPN
04187A             0912*  ;
04187A             0913*  ;TAN - Tangent function
04187A             0914*  ;Result is floating-point numeric.
04187A             0915*  ;
04187A 3E 1F       0916*  TAN:			LD      A,31
04187C 18 1E       0917*  			JR      FPPN
04187E             0918*  ;
04187E             0919*  ;COS - Cosine function
04187E             0920*  ;Result is floating-point numeric.
04187E             0921*  ;
04187E 3E 14       0922*  COS:			LD      A,20
041880 18 1A       0923*  			JR      FPPN
041882             0924*  ;
041882             0925*  ;SIN - Sine function
041882             0926*  ;Result is floating-point numeric.
041882             0927*  ;
041882 3E 1D       0928*  SIN:			LD      A,29
041884 18 16       0929*  			JR      FPPN
041886             0930*  ;
041886             0931*  ;EXP - Exponential function
041886             0932*  ;Result is floating-point numeric.
041886             0933*  ;
041886 3E 16       0934*  EXP:			LD      A,22
041888 18 12       0935*  			JR      FPPN
04188A             0936*  ;
04188A             0937*  ;LN - Natural log.
04188A             0938*  ;Result is floating-point numeric.
04188A             0939*  ;
04188A 3E 18       0940*  LN:			LD      A,24
04188C 18 0E       0941*  			JR      FPPN
04188E             0942*  ;
04188E             0943*  ;LOG - base-10 logarithm.
04188E             0944*  ;Result is floating-point numeric.
04188E             0945*  ;
04188E 3E 19       0946*  LOG:			LD      A,25
041890 18 0A       0947*  			JR      FPPN
041892             0948*  ;
041892             0949*  ;ASN - Arc-sine
041892             0950*  ;Result is floating-point numeric.
041892             0951*  ;
041892 3E 12       0952*  ASN:			LD      A,18
041894 18 06       0953*  			JR      FPPN
041896             0954*  ;
041896             0955*  ;ATN - arc-tangent
041896             0956*  ;Result is floating-point numeric.
041896             0957*  ;
041896 3E 13       0958*  ATN:			LD      A,19
041898 18 02       0959*  			JR      FPPN
04189A             0960*  ;
04189A             0961*  ;ACS - arc-cosine
04189A             0962*  ;Result is floating point numeric.
04189A             0963*  ;
04189A 3E 11       0964*  ACS:			LD      A,17
04189C F5          0965*  FPPN:			PUSH    AF
04189D CD 67 15 04 0966*  			CALL    ITEMN
0418A1 F1          0967*  			POP     AF
0418A2 CD E7 32 04 0968*  FPP1:			CALL    FPP
0418A6 DA 18 0D 04 0969*  			JP      C,ERROR_
0418AA AF          0970*  			XOR     A
0418AB C9          0971*  			RET
0418AC             0972*  ;
0418AC             0973*  ;SFIX - Convert to fixed-point notation
0418AC             0974*  ;
0418AC 3E 26       0975*  SFIX:			LD      A,38
0418AE 18 F2       0976*  			JR      FPP1
0418B0             0977*  ;
0418B0             0978*  ;SFLOAT - Convert to floating-point notation
0418B0             0979*  ;
0418B0 3E 27       0980*  SFLOAT:			LD      A,39
0418B2 18 EE       0981*  			JR      FPP1
0418B4             0982*  ;
0418B4             0983*  ;VAL - Return numeric value of string.
0418B4             0984*  ;Result is variable type numeric.
0418B4             0985*  ;
0418B4 CD 7A 15 04 0986*  VAL:			CALL    ITEMS
0418B8 AF          0987*  VAL0:			XOR     A
0418B9 12          0988*  			LD      (DE),A
0418BA DD 21 00 02 0989*  			LD      IX,ACCS
       04          
0418BF 3E 24       0990*  			LD      A,36
0418C1 18 DF       0991*  			JR      FPP1
0418C3             0992*  ;
0418C3             0993*  ;EVAL - Pass string to expression evaluator.
0418C3             0994*  ;Result is variable type (numeric or string).
0418C3             0995*  ;
0418C3 CD 7A 15 04 0996*  EVAL_:			CALL    ITEMS
0418C7 3E 0D       0997*  			LD      A,CR
0418C9 12          0998*  			LD      (DE),A
0418CA FD E5       0999*  			PUSH    IY
0418CC 11 00 02 04 1000*  			LD      DE,ACCS
0418D0 FD 21 00 02 1001*  			LD      IY,ACCS
       04          
0418D5 0E 00       1002*  			LD      C,0
0418D7 CD 57 12 04 1003*  			CALL    LEXAN2          ;TOKENISE
0418DB 12          1004*  			LD      (DE),A
0418DC 13          1005*  			INC     DE
0418DD AF          1006*  			XOR     A
0418DE CD FE 1B 04 1007*  			CALL    PUSHS           ;PUT ON STACK
0418E2 FD 21 03 00 1008*  			LD      IY,SIZEW	;WAS 2
       00          
0418E7 FD 39       1009*  			ADD     IY,SP
0418E9 CD 0C 14 04 1010*  			CALL    EXPR
0418ED FD E1       1011*  			POP     IY
0418EF FD 39       1012*  			ADD     IY,SP
0418F1 FD F9       1013*  			LD      SP,IY           ;ADJUST STACK POINTER
0418F3 FD E1       1014*  			POP     IY
0418F5 08          1015*  			EX      AF,AF'
0418F6 C9          1016*  			RET
0418F7             1017*  ;
0418F7             1018*  ;RND - Random number function.
0418F7             1019*  ; RND gives random integer 0-&FFFFFFFF
0418F7             1020*  ; RND(-n) seeds random number & returns -n.
0418F7             1021*  ; RND(0) returns last value in RND(1) form.
0418F7             1022*  ; RND(1) returns floating-point 0-0.99999999.
0418F7             1023*  ; RND(n) returns random integer 1-n.
0418F7             1024*  ;
0418F7 DD 21 38 05 1025*  RND:			LD      IX,RANDOM
       04          
0418FC CD BD 1C 04 1026*  			CALL    NXT
041900 FE 28       1027*  			CP      '('
041902 28 20       1028*  			JR      Z,RND5          ;ARGUMENT FOLLOWS
041904 CD 69 16 04 1029*  			CALL    LOAD5
041908 CB 19       1030*  RND1:			RR      C
04190A 06 20       1031*  			LD      B,32
04190C D9          1032*  RND2:			EXX                     ;CALCULATE NEXT
04190D 52 ED 6A    1033*  			ADC.S   HL,HL
041910 D9          1034*  			EXX
041911 52 ED 6A    1035*  			ADC.S   HL,HL
041914 CB 5D       1036*  			BIT     3,L
041916 28 01       1037*  			JR      Z,RND3
041918 3F          1038*  			CCF
041919 10 F1       1039*  RND3:			DJNZ    RND2
04191B CB 11       1040*  RND4:			RL      C               ;SAVE CARRY
04191D CD 52 28 04 1041*  			CALL    STORE5          ;STORE NEW NUMBER
041921 AF          1042*  			XOR     A
041922 4F          1043*  			LD      C,A
041923 C9          1044*  			RET
041924 CD 6F 15 04 1045*  RND5:			CALL    ITEMI
041928 DD 21 38 05 1046*  			LD      IX,RANDOM
       04          
04192D CB 7C       1047*  			BIT     7,H             ;NEGATIVE?
04192F 37          1048*  			SCF
041930 20 E9       1049*  			JR      NZ,RND4         ;SEED
041932 CD 29 1B 04 1050*  			CALL    TEST
041936 F5          1051*  			PUSH    AF
041937 CD 21 1B 04 1052*  			CALL    SWAP
04193B D9          1053*  			EXX
04193C CD 69 16 04 1054*  			CALL    LOAD5
041940 C4 08 19 04 1055*  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
041944 D9          1056*  			EXX                     ;SCRAMBLE (CARE!)
041945 0E 7F       1057*  			LD      C,7FH
041947 CB 7C       1058*  RND6:			BIT     7,H             ;FLOAT
041949 20 0A       1059*  			JR      NZ,RND7
04194B D9          1060*  			EXX
04194C 52 29       1061*  			ADD.S   HL,HL
04194E D9          1062*  			EXX
04194F 52 ED 6A    1063*  			ADC.S   HL,HL
041952 0D          1064*  			DEC     C
041953 20 F2       1065*  			JR      NZ,RND6
041955 CB BC       1066*  RND7:			RES     7,H             ;POSITIVE 0-0.999999
041957 F1          1067*  			POP     AF
041958 C8          1068*  			RET     Z               ;ZERO ARGUMENT
041959 D9          1069*  			EXX
04195A 7B          1070*  			LD      A,E
04195B 3D          1071*  			DEC     A
04195C B2          1072*  			OR      D
04195D D9          1073*  			EXX
04195E B3          1074*  			OR      E
04195F B2          1075*  			OR      D
041960 C8          1076*  			RET     Z               ;ARGUMENT=1
041961 06 00       1077*  			LD      B,0             ;INTEGER MARKER
041963 3E 0A       1078*  			LD      A,10
041965 CD E7 32 04 1079*  			CALL    FPP             ;MULTIPLY
041969 DA 18 0D 04 1080*  			JP      C,ERROR_
04196D CD AC 18 04 1081*  			CALL    SFIX
041971 C3 05 16 04 1082*  			JP      ADD1
041975             1083*  ;
041975             1084*  ; INSTR - String search.
041975             1085*  ; Result is integer numeric.
041975             1086*  ;
041975 CD 6B 1C 04 1087*  INSTR:			CALL    EXPRSC			; Get the first string expression
041979 CD FE 1B 04 1088*  			CALL    PUSHS           	; Push the string onto the stack
04197D CD 5F 15 04 1089*  			CALL    EXPRS           	; Get the second string expression
041981 C1          1090*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
041982 21 00 00 00 1091*  			LD      HL,0
041986 39          1092*  			ADD     HL,SP           	; HL: Pointer to main string
041987 C5          1093*  			PUSH    BC              	;  C: Main string length
041988 43          1094*  			LD      B,E             	;  B: Sub-string length
041989 CD BD 1C 04 1095*  			CALL    NXT			; Skip whitespace
04198D FE 2C       1096*  			CP      ','			; Check if there is a comma for the third parameter
04198F 3E 00       1097*  			LD      A,0			;  A: Default start position in string
041991 20 1A       1098*  			JR      NZ,INSTR1		; No, so skip the next bit
041993 FD 23       1099*  			INC     IY              	; Skip the comma
041995 C5          1100*  			PUSH    BC              	; Save the lengths
041996 E5          1101*  			PUSH    HL              	; Save the pointer to the main string
041997 CD FE 1B 04 1102*  			CALL    PUSHS			; Push the string onto the stack
04199B CD 54 15 04 1103*  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
04199F C1          1104*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0419A0 CD 2B 1C 04 1105*  			CALL    POPS			; Pop the string off the stack
0419A4 E1          1106*  			POP     HL              	; Restore the pointer to the main string
0419A5 C1          1107*  			POP     BC              	; Restore the lengths
0419A6 D9          1108*  			EXX
0419A7 7D          1109*  			LD      A,L			; A: The start position in the  string
0419A8 D9          1110*  			EXX
0419A9 B7          1111*  			OR      A			; Set the flags
0419AA 28 01       1112*  			JR      Z,INSTR1		; If it is zero, then skip
0419AC 3D          1113*  			DEC     A
0419AD 11 00 02 04 1114*  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0419B1 CD CF 19 04 1115*  			CALL    SEARCH			; Do the search
0419B5 D1          1116*  			POP     DE
0419B6 28 03       1117*  			JR      Z,INSTR2        	; NB: Carry cleared
0419B8 ED 62       1118*  			SBC     HL,HL
0419BA 39          1119*  			ADD     HL,SP
0419BB ED 72       1120*  INSTR2:			SBC     HL,SP
0419BD EB          1121*  			EX      DE,HL
0419BE 7D          1122*  			LD	A,L
0419BF 21 00 00 00 1123*  			LD      HL,0
0419C3 6F          1124*  			LD	L,A
0419C4 39          1125*  			ADD     HL,SP
0419C5 F9          1126*  			LD      SP,HL
0419C6 EB          1127*  			EX      DE,HL
0419C7 CD 7C 1C 04 1128*  			CALL    BRAKET			; Check for closing bracket
0419CB C3 CB 17 04 1129*  			JP      COUNT1			; Return a numeric integer
0419CF             1130*  ;
0419CF             1131*  ; SEARCH - Search string for sub-string
0419CF             1132*  ;    Inputs: Main string at HL length C
0419CF             1133*  ;            Sub-string  at DE length B
0419CF             1134*  ;            Starting offset A
0419CF             1135*  ;   Outputs: NZ - not found
0419CF             1136*  ;            Z - found at location HL-1
0419CF             1137*  ;            Carry always cleared
0419CF             1138*  ;
0419CF C5          1139*  SEARCH:			PUSH    BC			; Add the starting offset to HL
0419D0 01 00 00 00 1140*  			LD      BC,0
0419D4 4F          1141*  			LD      C,A
0419D5 09          1142*  			ADD     HL,BC           	; New start address
0419D6 C1          1143*  			POP     BC
0419D7 91          1144*  			SUB     C			; If the starting offset > main string length, then do nothing
0419D8 30 2C       1145*  			JR      NC,SRCH4
0419DA ED 44       1146*  			NEG
0419DC 4F          1147*  			LD      C,A             	; Remaining length
0419DD             1148*  ;
0419DD C5          1149*  SRCH1:			PUSH    BC
0419DE 79          1150*  			LD	A,C
0419DF 01 00 00 00 1151*  			LD	BC,0
0419E3 4F          1152*  			LD	C,A
0419E4 1A          1153*  			LD      A,(DE)
0419E5 ED B1       1154*  			CPIR                    	; Find the first character
0419E7 79          1155*  			LD      A,C
0419E8 C1          1156*  			POP     BC
0419E9 20 1B       1157*  			JR      NZ,SRCH4
0419EB 4F          1158*  			LD      C,A
0419EC             1159*  ;
0419EC             1160*  ; This block of four instructions was commented as a bug fix by R.T.Russell
0419EC             1161*  ;
0419EC 05          1162*  			DEC     B			; Bug fix
0419ED B8          1163*  			CP      B			; Bug fix
0419EE 04          1164*  			INC     B			; Bug fix
0419EF 38 15       1165*  			JR      C,SRCH4			; Bug fix
0419F1             1166*  ;
0419F1 C5          1167*  			PUSH    BC
0419F2 D5          1168*  			PUSH    DE
0419F3 E5          1169*  			PUSH    HL
0419F4 05          1170*  			DEC     B
0419F5 28 08       1171*  			JR      Z,SRCH3         	; Found!
0419F7 13          1172*  SRCH2:			INC     DE
0419F8 1A          1173*  			LD      A,(DE)
0419F9 BE          1174*  			CP      (HL)
0419FA 20 03       1175*  			JR      NZ,SRCH3
0419FC 23          1176*  			INC     HL
0419FD 10 F8       1177*  			DJNZ    SRCH2
0419FF E1          1178*  SRCH3:			POP     HL
041A00 D1          1179*  			POP     DE
041A01 C1          1180*  			POP     BC
041A02 20 D9       1181*  			JR      NZ,SRCH1
041A04 AF          1182*  			XOR     A               	; Flags: Z, NC
041A05 C9          1183*  			RET                     	; Found
041A06             1184*  ;
041A06 F6 FF       1185*  SRCH4:			OR      0FFH            	; Flags: NZ, NC
041A08 C9          1186*  			RET                     	; Not found
041A09             1187*  ;
041A09             1188*  ;CHRS - Return character with given ASCII value.
041A09             1189*  ;Result is string.
041A09             1190*  ;
041A09 CD 6F 15 04 1191*  CHRS:			CALL    ITEMI
041A0D D9          1192*  			EXX
041A0E 7D          1193*  			LD      A,L
041A0F 18 0E       1194*  			JR      GET1
041A11             1195*  ;
041A11             1196*  ;GETS - Return key pressed as stringor character at position (X,Y).
041A11             1197*  ;Result is string.
041A11             1198*  ;
041A11 CD BD 1C 04 1199*  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
041A15 FE 28       1200*  			CP	'('
041A17 CA D3 42 04 1201*  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
041A1B CD 49 49 04 1202*  			CALL    OSRDCH
041A1F 37          1203*  GET1:			SCF
041A20 18 09       1204*  			JR      INKEY1
041A22             1205*  ;
041A22             1206*  ; INKEYS - Wait up to n centiseconds for keypress.
041A22             1207*  ;          Return key pressed as string or null
041A22             1208*  ;          string if time elapsed.
041A22             1209*  ; Result is string.
041A22             1210*  ;
041A22 CD 6F 15 04 1211*  INKEYS:			CALL    ITEMI			; Fetch the argument
041A26 D9          1212*  			EXX
041A27 CD 52 49 04 1213*  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
041A2B 11 00 02 04 1214*  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
041A2F 12          1215*  			LD      (DE),A
041A30 3E 80       1216*  			LD      A,80H
041A32 D0          1217*  			RET     NC
041A33 1C          1218*  			INC     E
041A34 C9          1219*  			RET
041A35             1220*  ;
041A35             1221*  ; INKEYM - Check immediately whether a given key is being pressed
041A35             1222*  ; Result is integer numeric
041A35             1223*  ;
041A35             1224*  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
041A35 3E 1E       0001*M 			LD	A, function
041A37 49 CF       0002*M 			RST.LIS	08h
041A39 23          1225*  			INC	HL			; Index from 0
041A3A 7D          1226*  			LD	A, L			; Negate the LSB of the answer
041A3B ED 44       1227*  			NEG
041A3D 4F          1228*  			LD	C, A			;  E: The positive keycode value
041A3E 3E 01       1229*  			LD	A, 1			; Throw an "Out of range" error
041A40 FA 18 0D 04 1230*  			JP	M, ERROR_		; if the argument < - 128
041A44             1231*  ;
041A44 21 67 1A 04 1232*  			LD	HL, BITLOOKUP		; HL: The bit lookup table
041A48 11 00 00 00 1233*  			LD	DE, 0
041A4C 79          1234*  			LD	A, C
041A4D E6 07       1235*  			AND	00000111b		; Just need the first three bits
041A4F 5F          1236*  			LD	E, A			; DE: The bit number
041A50 19          1237*  			ADD	HL, DE
041A51 46          1238*  			LD	B, (HL)			;  B: The mask
041A52             1239*  ;
041A52 79          1240*  			LD	A, C			; Fetch the keycode again
041A53 E6 78       1241*  			AND	01111000b		; And divide by 8
041A55 0F          1242*  			RRCA
041A56 0F          1243*  			RRCA
041A57 0F          1244*  			RRCA
041A58 5F          1245*  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
041A59 DD 19       1246*  			ADD	IX, DE			; IX: The address
041A5B 78          1247*  			LD	A, B			;  B: The mask
041A5C DD A6 00    1248*  			AND	(IX+0)			; Check whether the bit is set
041A5F CA DD 1B 04 1249*  			JP	Z, ZERO			; No, so return 0
041A63 C3 4F 18 04 1250*  			JP	TRUE			; Otherwise return -1
041A67             1251*  ;
041A67             1252*  ; A bit lookup table
041A67             1253*  ;
041A67 01 02 04 08 1254*  BITLOOKUP:		DB	01h, 02h, 04h, 08h
041A6B 10 20 40 80 1255*  			DB	10h, 20h, 40h, 80h
041A6F             1256*  ;
041A6F             1257*  ; MID$ - Return sub-string.
041A6F             1258*  ; Result is string.
041A6F             1259*  ;
041A6F CD 6B 1C 04 1260*  MIDS:			CALL    EXPRSC			; Get the first string expression
041A73 CD FE 1B 04 1261*  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
041A77 CD 54 15 04 1262*  			CALL    EXPRI			; Get the second expression
041A7B C1          1263*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
041A7C CD 2B 1C 04 1264*  			CALL    POPS			; Pop the string back off the stack to the string accumulator
041A80 D9          1265*  			EXX
041A81 7D          1266*  			LD      A,L			; A: The start index
041A82 D9          1267*  			EXX
041A83 B7          1268*  			OR      A			; If the start index is 0, then we don't need to do the next bit
041A84 28 0E       1269*  			JR      Z,MIDS1
041A86 3D          1270*  			DEC     A
041A87 6F          1271*  			LD      L,A			; L: The start index - 1
041A88 93          1272*  			SUB     E			; Subtract from the string length
041A89 1E 00       1273*  			LD      E,0			; Preemptively set the string length to 0
041A8B 30 07       1274*  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
041A8D ED 44       1275*  			NEG				; Negate the answer and
041A8F 4F          1276*  			LD      C,A			; C: Number of bytes to copy
041A90 CD D3 1A 04 1277*  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
041A94 CD BD 1C 04 1278*  MIDS1:			CALL    NXT			; Skip whitespace
041A98 FE 2C       1279*  			CP      ','			; Check for a comma
041A9A FD 23       1280*  			INC     IY			; Advance to the next character in the BASIC line
041A9C 28 0D       1281*  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
041A9E FD 2B       1282*  			DEC     IY			; Restore the BASIC program pointer
041AA0 CD 7C 1C 04 1283*  			CALL    BRAKET			; Check for a bracket
041AA4 3E 80       1284*  			LD      A,80H			; String marker
041AA6 C9          1285*  			RET
041AA7             1286*  ;
041AA7             1287*  ; LEFT$ - Return left part of string.
041AA7             1288*  ; Carry cleared if entire string returned.
041AA7             1289*  ; Result is string.
041AA7             1290*  ;
041AA7 CD 6B 1C 04 1291*  LEFTS:			CALL    EXPRSC			; Get the first string expression
041AAB CD FE 1B 04 1292*  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
041AAF CD 54 15 04 1293*  			CALL    EXPRI			; Get the second expression
041AB3 C1          1294*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
041AB4 CD 2B 1C 04 1295*  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
041AB8 CD 7C 1C 04 1296*  			CALL    BRAKET			; Check for closing bracket
041ABC D9          1297*  			EXX
041ABD 7D          1298*  			LD      A,L			; L: The second parameter
041ABE D9          1299*  			EXX
041ABF BB          1300*  			CP      E			; Compare with the string length
041AC0 30 02       1301*  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
041AC2 6B          1302*  			LD      L,E             	; For RIGHTS, no effect in LEFTS
041AC3 5F          1303*  LEFT2:			LD      E,A			; E: The new length of string
041AC4 3E 80       1304*  LEFT3:			LD      A,80H           	; String marker
041AC6 C9          1305*  			RET
041AC7             1306*  ;
041AC7             1307*  ; RIGHT$ - Return right part of string.
041AC7             1308*  ; Result is string.
041AC7             1309*  ;
041AC7 CD A7 1A 04 1310*  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
041ACB D0          1311*  			RET     NC			; Do nothing if the second parameter is >= string length
041ACC 1C          1312*  			INC     E			; Check for a zero length string
041ACD 1D          1313*  			DEC     E
041ACE C8          1314*  			RET     Z			; Yes, so do nothing
041ACF 4B          1315*  			LD      C,E			;  C: Number of bytes to copy
041AD0 7D          1316*  			LD      A,L
041AD1 93          1317*  			SUB     E
041AD2 6F          1318*  			LD      L,A			;  L: Index into the string
041AD3 79          1319*  RIGHT1:			LD	A,C
041AD4 01 00 00 00 1320*  			LD	BC,0
041AD8 4F          1321*  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
041AD9 7D          1322*  			LD	A,L
041ADA 21 00 02 04 1323*  			LD	HL,ACCS
041ADE 6F          1324*  			LD	L,A			; HL: Source (in ACCS)
041ADF 11 00 02 04 1325*  			LD      DE,ACCS			; DE: Destination (start of ACCS)
041AE3 ED B0       1326*  			LDIR                    	; Copy
041AE5 3E 80       1327*  			LD      A,80H			; String marker
041AE7 C9          1328*  			RET
041AE8             1329*  ;
041AE8             1330*  ; STRINGS - Return n concatenations of a string.
041AE8             1331*  ; Result is string.
041AE8             1332*  ;
041AE8 CD 54 15 04 1333*  STRING_:		CALL    EXPRI			; Get number of times to replicate
041AEC CD 6F 1C 04 1334*  			CALL    COMMA			; Check for comma
041AF0 D9          1335*  			EXX
041AF1 7D          1336*  			LD      A,L			; L: Number of iterations of string
041AF2 D9          1337*  			EXX
041AF3 F5          1338*  			PUSH    AF
041AF4 CD 5F 15 04 1339*  			CALL    EXPRS			; Get the string
041AF8 CD 7C 1C 04 1340*  			CALL    BRAKET			; Check for closing bracket
041AFC F1          1341*  			POP     AF			; A: Number of iterations of string
041AFD B7          1342*  			OR      A			; Set flags
041AFE 28 C3       1343*  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
041B00 3D          1344*  			DEC     A
041B01 4F          1345*  			LD      C,A			; C: Loop counter
041B02 3E 80       1346*  			LD      A,80H			; String marker
041B04 C8          1347*  			RET     Z
041B05 1C          1348*  			INC     E			; Check for empty string
041B06 1D          1349*  			DEC     E
041B07 C8          1350*  			RET     Z              		; And return
041B08 43          1351*  			LD      B,E			; B: String length tally
041B09 21 00 02 04 1352*  			LD	HL,ACCS
041B0D C5          1353*  STRIN1:			PUSH    BC
041B0E 7E          1354*  STRIN2:			LD      A,(HL)
041B0F 23          1355*  			INC     HL
041B10 12          1356*  			LD      (DE),A
041B11 1C          1357*  			INC     E
041B12 3E 13       1358*  			LD      A,19
041B14 CA 18 0D 04 1359*  			JP      Z,ERROR_         	; Throw a "String too long" error
041B18 10 F4       1360*  			DJNZ    STRIN2
041B1A C1          1361*  			POP     BC
041B1B 0D          1362*  			DEC     C
041B1C 20 EF       1363*  			JR      NZ,STRIN1
041B1E 3E 80       1364*  			LD      A,80H
041B20 C9          1365*  			RET
041B21             1366*  ;
041B21             1367*  ;SUBROUTINES
041B21             1368*  ;
041B21             1369*  ;SWAP - Swap arguments
041B21             1370*  ;Exchanges DE,HL D'E',H'L' and B,C
041B21             1371*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
041B21             1372*  ;
041B21 79          1373*  SWAP:			LD      A,C
041B22 48          1374*  			LD      C,B
041B23 47          1375*  			LD      B,A
041B24 EB          1376*  			EX      DE,HL
041B25 D9          1377*  			EXX
041B26 EB          1378*  			EX      DE,HL
041B27 D9          1379*  			EXX
041B28 C9          1380*  			RET
041B29             1381*  ;
041B29             1382*  ;TEST - Test HLH'L' for zero
041B29             1383*  ;Outputs: Z-flag set & A=0 if zero
041B29             1384*  ;Destroys: A,F
041B29             1385*  ;
041B29 7C          1386*  TEST:			LD      A,H
041B2A B5          1387*  			OR      L
041B2B D9          1388*  			EXX
041B2C B4          1389*  			OR      H
041B2D B5          1390*  			OR      L
041B2E D9          1391*  			EXX
041B2F C9          1392*  			RET
041B30             1393*  ;
041B30             1394*  ;DECODE - Decode line number in pseudo-binary.
041B30             1395*  ;   Inputs: IY = Text pointer.
041B30             1396*  ;   Outputs: HL=0, H'L'=line number, C=0.
041B30             1397*  ;   Destroys: A,C,H,L,H',L',IY,F
041B30             1398*  ;
041B30 D9          1399*  DECODE:			EXX
041B31 21 00 00 00 1400*  			LD	HL, 0
041B35 FD 7E 00    1401*  			LD      A,(IY)
041B38 FD 23       1402*  			INC     IY
041B3A 17          1403*  			RLA
041B3B 17          1404*  			RLA
041B3C 67          1405*  			LD      H,A
041B3D E6 C0       1406*  			AND     0C0H
041B3F FD AE 00    1407*  			XOR     (IY)
041B42 FD 23       1408*  			INC     IY
041B44 6F          1409*  			LD      L,A
041B45 7C          1410*  			LD      A,H
041B46 17          1411*  			RLA
041B47 17          1412*  			RLA
041B48 E6 C0       1413*  			AND     0C0H
041B4A FD AE 00    1414*  			XOR     (IY)
041B4D FD 23       1415*  			INC     IY
041B4F 67          1416*  			LD      H,A
041B50 D9          1417*  			EXX
041B51             1418*  ;			XOR     A
041B51             1419*  ;			LD      C,A
041B51             1420*  ;			LD      H,A
041B51             1421*  ;			LD      L,A
041B51 21 00 00 00 1422*  			LD	HL, 0
041B55 4D          1423*  			LD	C, L
041B56 C9          1424*  			RET
041B57             1425*  ;
041B57             1426*  ;HEXSTR - convert numeric value to HEX string.
041B57             1427*  ;   Inputs: HLH'L'C = integer or floating-point number
041B57             1428*  ;  Outputs: String in string accumulator.
041B57             1429*  ;           E = string length.  D = ACCS/256
041B57             1430*  ;
041B57 FD 23       1431*  HEXSTS:			INC     IY              ;SKIP TILDE
041B59 CD 67 15 04 1432*  			CALL    ITEMN
041B5D CD 64 1B 04 1433*  			CALL    HEXSTR
041B61 3E 80       1434*  			LD      A,80H
041B63 C9          1435*  			RET
041B64             1436*  ;
041B64 CD AC 18 04 1437*  HEXSTR:			CALL    SFIX
041B68 01 08 00 00 1438*  			LD      BC,8
041B6C 11 00 02 04 1439*  			LD      DE,ACCS
041B70 C5          1440*  HEXST1:			PUSH    BC
041B71 06 04       1441*  			LD      B,4
041B73 AF          1442*  			XOR     A
041B74 D9          1443*  HEXST2:			EXX
041B75 52 29       1444*  			ADD.S	HL,HL
041B77 D9          1445*  			EXX
041B78 52 ED 6A    1446*  			ADC.S	HL,HL
041B7B 17          1447*  			RLA
041B7C 10 F6       1448*  			DJNZ    HEXST2
041B7E C1          1449*  			POP     BC
041B7F 0D          1450*  			DEC     C
041B80 F8          1451*  			RET     M
041B81 28 06       1452*  			JR      Z,HEXST3
041B83 B7          1453*  			OR      A
041B84 20 03       1454*  			JR      NZ,HEXST3
041B86 B8          1455*  			CP      B
041B87 28 E7       1456*  			JR      Z,HEXST1
041B89 C6 90       1457*  HEXST3:			ADD     A,90H
041B8B 27          1458*  			DAA
041B8C CE 40       1459*  			ADC     A,40H
041B8E 27          1460*  			DAA
041B8F 12          1461*  			LD      (DE),A
041B90 13          1462*  			INC     DE
041B91 47          1463*  			LD      B,A
041B92 18 DC       1464*  			JR      HEXST1
041B94             1465*  ;
041B94             1466*  ;Function STR - convert numeric value to ASCII string.
041B94             1467*  ;   Inputs: HLH'L'C = integer or floating-point number.
041B94             1468*  ;  Outputs: String in string accumulator.
041B94             1469*  ;           E = length, D = ACCS/256
041B94             1470*  ;           A = 80H (type=string)
041B94             1471*  ;
041B94             1472*  ;First normalise for decimal output:
041B94             1473*  ;
041B94 CD BD 1C 04 1474*  STRS:			CALL    NXT
041B98 FE 7E       1475*  			CP      '~'
041B9A 28 BB       1476*  			JR      Z,HEXSTS
041B9C CD 67 15 04 1477*  			CALL    ITEMN
041BA0 DD 21 00 04 1478*  			LD      IX,STAVAR
       04          
041BA5 DD 7E 03    1479*  			LD      A,(IX+3)
041BA8 B7          1480*  			OR      A
041BA9 DD 21 D6 1B 1481*  			LD      IX,G9-1         ;G9 FORMAT
       04          
041BAE 28 05       1482*  			JR      Z,STR0
041BB0 DD 21 00 04 1483*  STR:			LD      IX,STAVAR
       04          
041BB5 11 00 02 04 1484*  STR0:			LD      DE,ACCS
041BB9 3E 25       1485*  			LD      A,37
041BBB CD E7 32 04 1486*  			CALL    FPP
041BBF DA 18 0D 04 1487*  			JP      C,ERROR_
041BC3 DD CB 02 46 1488*  			BIT     0,(IX+2)
041BC7 3E 80       1489*  STR1:			LD      A,80H           ;STRING MARKER
041BC9 C8          1490*  			RET     Z
041BCA 79          1491*  			LD      A,C
041BCB C6 04       1492*  			ADD     A,4
041BCD BB          1493*  STR2:			CP      E
041BCE 28 F7       1494*  			JR      Z,STR1
041BD0 EB          1495*  			EX      DE,HL
041BD1 36 20       1496*  			LD      (HL),' '        ;TRAILING SPACE
041BD3 23          1497*  			INC     HL
041BD4 EB          1498*  			EX      DE,HL
041BD5 18 F6       1499*  			JR      STR2
041BD7             1500*  ;
041BD7 09 00       1501*  G9:			DW    9
041BD9             1502*  ;
041BD9             1503*  ;STRING COMPARE
041BD9             1504*  ;Compare string (DE) length B with string (HL) length C.
041BD9             1505*  ;Result preset to false.
041BD9             1506*  ;
041BD9 CD E7 1B 04 1507*  SCP:			CALL	SCP0
041BDD             1508*  ;
041BDD 3E 00       1509*  ZERO:			LD      A,0
041BDF D9          1510*  			EXX
041BE0 67          1511*  			LD      H,A
041BE1 6F          1512*  			LD      L,A
041BE2 D9          1513*  			EXX
041BE3 67          1514*  			LD      H,A
041BE4 6F          1515*  			LD      L,A
041BE5 4F          1516*  			LD      C,A
041BE6 C9          1517*  			RET
041BE7             1518*  ;
041BE7 04          1519*  SCP0:			INC     B
041BE8 0C          1520*  			INC     C
041BE9 05          1521*  SCP1:			DEC     B
041BEA 28 0A       1522*  			JR      Z,SCP2
041BEC 0D          1523*  			DEC     C
041BED 28 0C       1524*  			JR      Z,SCP3
041BEF 1A          1525*  			LD      A,(DE)
041BF0 BE          1526*  			CP      (HL)
041BF1 C0          1527*  			RET     NZ
041BF2 13          1528*  			INC     DE
041BF3 23          1529*  			INC     HL
041BF4 18 F3       1530*  			JR      SCP1
041BF6 B7          1531*  SCP2:			OR      A
041BF7 0D          1532*  			DEC     C
041BF8 C8          1533*  			RET     Z
041BF9 37          1534*  			SCF
041BFA C9          1535*  			RET
041BFB B7          1536*  SCP3:			OR      A
041BFC 0C          1537*  			INC     C
041BFD C9          1538*  			RET
041BFE             1539*  ;
041BFE             1540*  ; PUSHS - SAVE STRING ON STACK.
041BFE             1541*  ;     Inputs: String in string accumulator.
041BFE             1542*  ;             E = string length.
041BFE             1543*  ;             A - saved on stack.
041BFE             1544*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
041BFE             1545*  ;
041BFE CD C6 28 04 1546*  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
041C02 DD E1       1547*  			POP     IX              	; IX: Return address
041C04 B7          1548*  			OR      A               	; Clear the carry flag
041C05 01 00 00 00 1549*  			LD	BC,0			; BC: Length of the string
041C09 4B          1550*  			LD	C,E
041C0A 21 00 02 04 1551*  			LD      HL,ACCS			; HL: Pointer to the string accumulator
041C0E 11 00 02 04 1552*  			LD	DE,ACCS
041C12 59          1553*  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
041C13 ED 52       1554*  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
041C15 39          1555*  			ADD     HL,SP			; Grow the stack
041C16 F9          1556*  			LD      SP,HL
041C17 57          1557*  			LD      D,A			;  D: This needs to be set to A for some functions
041C18 47          1558*  			LD	B,A			; Stack A and C (the string length)
041C19 C5          1559*  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
041C1A 06 00       1560*  			LD	B,0			; Reset B to 0 for the LDIR in this function
041C1C 28 0B       1561*  			JR      Z,PUSHS1        	; Is it zero length?
041C1E 11 00 02 04 1562*  			LD      DE,ACCS			; DE: Destination
041C22 EB          1563*  			EX      DE,HL			; HL: Destination, DE: Address on stack
041C23 ED B0       1564*  			LDIR	                    	; Copy to stack
041C25 CD C6 28 04 1565*  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
041C29 DD E9       1566*  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
041C2B             1567*  ;
041C2B             1568*  ; POPS - RESTORE STRING FROM STACK.
041C2B             1569*  ;     Inputs: C = string length.
041C2B             1570*  ;    Outputs: String in string accumulator.
041C2B             1571*  ;             E = string length.
041C2B             1572*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
041C2B             1573*  ;
041C2B DD E1       1574*  POPS:			POP     IX              	; IX: Return address
041C2D 69          1575*  			LD	L,C			; Temporarily store string length in L
041C2E 01 00 00 00 1576*  			LD	BC,0
041C32 4D          1577*  			LD	C,L			; BC: Number of bytes to copy
041C33 21 00 00 00 1578*  			LD      HL,0			; HL: 0
041C37 39          1579*  			ADD     HL,SP			; HL: Stack address
041C38 11 00 02 04 1580*  			LD      DE,ACCS			; DE: Destination
041C3C 0C          1581*  			INC     C			; Quick check to see if this is a zero length string
041C3D 0D          1582*  			DEC     C
041C3E 28 02       1583*  			JR      Z,POPS1         	; Yes it is, so skip
041C40 ED B0       1584*  			LDIR                    	; No, so copy from the stack
041C42 F9          1585*  POPS1:			LD      SP,HL			; Shrink the stack
041C43 DD E9       1586*  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
041C45             1587*  ;
041C45 FD 7E 00    1588*  HEXDIG:			LD      A,(IY)
041C48 FE 30       1589*  			CP      '0'
041C4A D8          1590*  			RET     C
041C4B FE 3A       1591*  			CP      '9'+1
041C4D 3F          1592*  			CCF
041C4E D0          1593*  			RET     NC
041C4F FE 41       1594*  			CP      'A'
041C51 D8          1595*  			RET     C
041C52 D6 37       1596*  			SUB     'A'-10
041C54 FE 10       1597*  			CP      16
041C56 3F          1598*  			CCF
041C57 C9          1599*  			RET
041C58             1600*  ;
041C58 FD 7E 00    1601*  BINDIG:			LD	A,(IY)
041C5B FE 30       1602*  			CP	'0'
041C5D D8          1603*  			RET	C
041C5E FE 32       1604*  			CP	'1'+1
041C60 3F          1605*  			CCF
041C61 C9          1606*  			RET
041C62             1607*  ;
041C62 FE 3E       1608*  RELOP?:			CP      '>'
041C64 D0          1609*  			RET     NC
041C65 FE 3D       1610*  			CP      '='
041C67 D0          1611*  			RET     NC
041C68 FE 3C       1612*  			CP      '<'
041C6A C9          1613*  			RET
041C6B             1614*  ;
041C6B CD 5F 15 04 1615*  EXPRSC:			CALL    EXPRS
041C6F CD BD 1C 04 1616*  COMMA:			CALL    NXT
041C73 FD 23       1617*  			INC     IY
041C75 FE 2C       1618*  			CP      ','
041C77 C8          1619*  			RET     Z
041C78 3E 05       1620*  			LD      A,5
041C7A 18 0B       1621*  			JR      ERROR1_EV          ;"Missing ,"
041C7C             1622*  ;
041C7C CD BD 1C 04 1623*  BRAKET:			CALL    NXT
041C80 FD 23       1624*  			INC     IY
041C82 FE 29       1625*  			CP      ')'
041C84 C8          1626*  			RET     Z
041C85 3E 1B       1627*  			LD      A,27
041C87 C3 18 0D 04 1628*  ERROR1_EV:			JP      ERROR_           ;"Missing )"
041C8B             1629*  ;
041C8B FD 23       1630*  SAVE_EV:			INC     IY
041C8D 08          1631*  SAVE1:			EX      AF,AF'
041C8E FA 80 15 04 1632*  			JP      M,TYPE_EV_
041C92 08          1633*  			EX      AF,AF'
041C93 E3          1634*  			EX      (SP),HL
041C94 D9          1635*  			EXX
041C95 E5          1636*  			PUSH    HL
041C96 D9          1637*  			EXX
041C97 F5          1638*  			PUSH    AF
041C98 C5          1639*  			PUSH    BC
041C99 E9          1640*  			JP      (HL)
041C9A             1641*  ;
041C9A 08          1642*  DOIT:			EX      AF,AF'
041C9B FA 80 15 04 1643*  			JP      M,TYPE_EV_
041C9F D9          1644*  			EXX
041CA0 C1          1645*  			POP     BC              ;RETURN ADDRESS
041CA1 D9          1646*  			EXX
041CA2 79          1647*  			LD      A,C
041CA3 C1          1648*  			POP     BC
041CA4 47          1649*  			LD      B,A
041CA5 F1          1650*  			POP     AF              ;OPERATOR
041CA6 D9          1651*  			EXX
041CA7 EB          1652*  			EX      DE,HL
041CA8 E1          1653*  			POP     HL
041CA9 D9          1654*  			EXX
041CAA EB          1655*  			EX      DE,HL
041CAB E1          1656*  			POP     HL
041CAC D9          1657*  			EXX
041CAD C5          1658*  			PUSH    BC
041CAE D9          1659*  			EXX
041CAF E6 0F       1660*  			AND     0FH
041CB1 CD E7 32 04 1661*  			CALL    FPP
041CB5 38 D0       1662*  			JR      C,ERROR1_EV
041CB7 AF          1663*  			XOR     A
041CB8 08          1664*  			EX      AF,AF'          ;TYPE
041CB9 FD 7E 00    1665*  			LD      A,(IY)
041CBC C9          1666*  			RET
041CBD             1667*  ;
041CBD             1668*  ; Skip spaces
041CBD             1669*  ; - IY: String pointer
041CBD             1670*  ; Returns:
041CBD             1671*  ;  - A: The non-space character found
041CBD             1672*  ; - IY: Points to the character before that
041CBD             1673*  ;
041CBD FD 7E 00    1674*  NXT:			LD      A,(IY)			; Fetch the character
041CC0 FE 20       1675*  			CP      ' '			; If it is space, then return
041CC2 C0          1676*  			RET     NZ
041CC3 FD 23       1677*  			INC     IY			; Increment the pointer and
041CC5 C3 BD 1C 04 1678*  			JP      NXT			; Loop
041CC9             1679*  ;
041CC9 E5          1680*  DISPT2:			PUSH    HL
041CCA 21 FA 13 04 1681*  			LD      HL,SOPTBL
041CCE 18 07       1682*  			JR      DISPT0
041CD0             1683*  ;
041CD0 E5          1684*  DISPAT:			PUSH    HL
041CD1 D6 8D       1685*  			SUB     FUNTOK
041CD3 21 4F 13 04 1686*  			LD      HL,FUNTBL
041CD7 C5          1687*  DISPT0:			PUSH    BC
041CD8             1688*  
041CD8 01 03 00 00 1689*  			LD	BC, 3
041CDC 47          1690*  			LD	B, A
041CDD ED 4C       1691*  			MLT	BC
041CDF 09          1692*  			ADD	HL, BC
041CE0 ED 27       1693*  			LD	HL, (HL)
041CE2             1694*  
041CE2             1695*  ;			ADD     A,A
041CE2             1696*  ;			LD      C,A
041CE2             1697*  ;			LD      B,0
041CE2             1698*  ;			ADD     HL,BC
041CE2             1699*  ;			LD      A,(HL)
041CE2             1700*  ;			INC     HL
041CE2             1701*  ;			LD      H,(HL)
041CE2             1702*  ;			LD      L,A
041CE2             1703*  
041CE2 C1          1704*  			POP     BC
041CE3 E3          1705*  			EX      (SP),HL
041CE4 C9          1706*  			RET                     ;OFF TO ROUTINE
041CE5             1707*  
041CE5             0008       include "exec.asm"
041CE5             0001*  ;
041CE5             0002*  ; Title:	BBC Basic Interpreter - Z80 version
041CE5             0003*  ;		Statement Execution & Assembler Module - "EXEC"
041CE5             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
041CE5             0005*  ; Modified By:	Dean Belfield
041CE5             0006*  ; Created:	12/05/2023
041CE5             0007*  ; Last Updated:	26/06/2023
041CE5             0008*  ;
041CE5             0009*  ; Modinfo:
041CE5             0010*  ; 27/01/1984:	Version 2.1
041CE5             0011*  ; 02/03/1987:	Version 3.0
041CE5             0012*  ; 11/06/1987:	Version 3.1
041CE5             0013*  ; 12/05/2023:	Modified by Dean Belfield
041CE5             0014*  ; 07/06/2023:	Modified to run in ADL mode
041CE5             0015*  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
041CE5             0016*  
041CE5             0017*  			; .ASSUME	ADL = 1
041CE5             0018*  
041CE5             0019*  			; INCLUDE	"equs.inc"
041CE5             0020*  
041CE5             0021*  			; SEGMENT CODE
041CE5             0022*  
041CE5             0023*  			; XDEF	XEQ
041CE5             0024*  			; XDEF	CHAIN0
041CE5             0025*  			; XDEF	RUN
041CE5             0026*  			; XDEF	SYNTAX
041CE5             0027*  			; XDEF	ESCAPE
041CE5             0028*  			; XDEF	FN_EX
041CE5             0029*  			; XDEF	USR
041CE5             0030*  			; XDEF	STORE5
041CE5             0031*  			; XDEF	STORE4
041CE5             0032*  			; XDEF	CHECK
041CE5             0033*  			; XDEF	TERMQ
041CE5             0034*  			; XDEF	FILL
041CE5             0035*  			; XDEF	X4OR5
041CE5             0036*  			; XDEF	MUL16
041CE5             0037*  			; XDEF	CHANEL
041CE5             0038*  			; XDEF	ASSEM
041CE5             0039*  
041CE5             0040*  			; XREF	AUTO
041CE5             0041*  			; XREF	DELETE
041CE5             0042*  			; XREF	LOAD
041CE5             0043*  			; XREF	LIST_
041CE5             0044*  			; XREF	NEW
041CE5             0045*  			; XREF	OLD
041CE5             0046*  			; XREF	RENUM
041CE5             0047*  			; XREF	SAVE
041CE5             0048*  			; XREF	SOUND
041CE5             0049*  			; XREF	CLG
041CE5             0050*  			; XREF	DRAW
041CE5             0051*  			; XREF	ENVEL
041CE5             0052*  			; XREF	GCOL
041CE5             0053*  			; XREF	MODE
041CE5             0054*  			; XREF	MOVE
041CE5             0055*  			; XREF	PLOT
041CE5             0056*  			; XREF	COLOUR
041CE5             0057*  			; XREF	EXPRS
041CE5             0058*  			; XREF	HIMEM
041CE5             0059*  			; XREF	LOAD0
041CE5             0060*  			; XREF	RANDOM
041CE5             0061*  			; XREF	CLEAR
041CE5             0062*  			; XREF	ERRTRP
041CE5             0063*  			; XREF	PAGE_
041CE5             0064*  			; XREF	DATAPTR
041CE5             0065*  			; XREF	ERRLIN
041CE5             0066*  			; XREF	TRAP
041CE5             0067*  			; XREF	NXT
041CE5             0068*  			; XREF	SETLIN
041CE5             0069*  			; XREF	CLOOP
041CE5             0070*  			; XREF	OSSHUT
041CE5             0071*  			; XREF	WARM
041CE5             0072*  			; XREF	TRACEN
041CE5             0073*  			; XREF	OUTCHR
041CE5             0074*  			; XREF	PBCDL
041CE5             0075*  			; XREF	OSCLI
041CE5             0076*  			; XREF	LISTON
041CE5             0077*  			; XREF	GETVAR
041CE5             0078*  			; XREF	PUTVAR
041CE5             0079*  			; XREF	DATPTR
041CE5             0080*  			; XREF	ERROR_
041CE5             0081*  			; XREF	EXPR
041CE5             0082*  			; XREF	CREATE
041CE5             0083*  			; XREF	EXPRI
041CE5             0084*  			; XREF	BRAKET
041CE5             0085*  			; XREF	FREE
041CE5             0086*  			; XREF	OSBPUT
041CE5             0087*  			; XREF	COUNT
041CE5             0088*  			; XREF	STR
041CE5             0089*  			; XREF	HEXSTR
041CE5             0090*  			; XREF	CRLF
041CE5             0091*  			; XREF	ITEMI
041CE5             0092*  			; XREF	FINDL
041CE5             0093*  			; XREF	TEST
041CE5             0094*  			; XREF	EXPRN
041CE5             0095*  			; XREF	DLOAD5
041CE5             0096*  			; XREF	DLOAD5_SPL
041CE5             0097*  			; XREF	LOADN
041CE5             0098*  			; XREF	FPP
041CE5             0099*  			; XREF	SWAP
041CE5             0100*  			; XREF	GETDEF
041CE5             0101*  			; XREF	ZERO
041CE5             0102*  			; XREF	OSBGET
041CE5             0103*  			; XREF	BUFFER
041CE5             0104*  			; XREF	CONS
041CE5             0105*  			; XREF	VAL0
041CE5             0106*  			; XREF	OSLINE
041CE5             0107*  			; XREF	CLRSCN
041CE5             0108*  			; XREF	TELL
041CE5             0109*  			; XREF	SAYLN
041CE5             0110*  			; XREF	REPORT
041CE5             0111*  			; XREF	PUTPTR
041CE5             0112*  			; XREF	PUTIME
041CE5             0113*  			; XREF	PUTIMS
041CE5             0114*  			; XREF	LOMEM
041CE5             0115*  			; XREF	WIDTH
041CE5             0116*  			; XREF	OSWRCH
041CE5             0117*  			; XREF	COMMA
041CE5             0118*  			; XREF	OSCALL
041CE5             0119*  			; XREF	SFIX
041CE5             0120*  			; XREF	LOAD4
041CE5             0121*  			; XREF	PUSHS
041CE5             0122*  			; XREF	POPS
041CE5             0123*  			; XREF	LOADS
041CE5             0124*  			; XREF	PUTCSR
041CE5             0125*  			; XREF	OUT_
041CE5             0126*  			; XREF	R0
041CE5             0127*  ;
041CE5             0128*  ; List of token values used in this module
041CE5             0129*  ; consolidated with the token values in main.asm
041CE5             0130*  ; TAND:			EQU     80H
041CE5             0131*  ; TOR:			EQU     84H
041CE5             0132*  ; TERROR:			EQU     85H
041CE5             0133*  ; LINE_:			EQU     86H
041CE5             0134*  ; OFF_:			EQU     87H
041CE5             0135*  ; STEP:			EQU     88H
041CE5             0136*  ; SPC:			EQU     89H
041CE5             0137*  ; TAB:			EQU     8AH
041CE5             0138*  ; ELSE_:			EQU     8BH
041CE5             0139*  ; THEN:			EQU     8CH
041CE5             0140*  ; LINO:			EQU     8DH
041CE5             0141*  ; TO:				EQU     B8H
041CE5             0142*  ; TCALL:			EQU     D6H
041CE5             0143*  ; DATA_:			EQU     DCH
041CE5             0144*  ; DEF_:			EQU     DDH
041CE5             0145*  ; TGOSUB:			EQU     E4H
041CE5             0146*  ; TGOTO:			EQU     E5H
041CE5             0147*  ; TON:			EQU     EEH
041CE5             0148*  ; TPROC:			EQU     F2H
041CE5             0149*  ; TSTOP:			EQU     FAH
041CE5             0150*  
041CE5             0151*  ; TCMD:			EQU     C6H ; in eval.asm
041CE5             0152*  
041CE5             0153*  ; The command table
041CE5             0154*  ; Commands are tokens from C6H onwards; this lookup table is used to
041CE5             0155*  ; run the corresponding function; Note that DATA and DEF both use the same
041CE5             0156*  ; code as REM
041CE5             0157*  ;
041CE5 A1 0C 04    0158*  CMDTAB:			DW24  AUTO			; C6H
041CE8 04 0B 04    0159*  			DW24  DELETE			; C7H
041CEB E2 0C 04    0160*  			DW24  LOAD			; C8H
041CEE 3F 0B 04    0161*  			DW24  LIST_			; C9H
041CF1 BF 0C 04    0162*  			DW24  NEW			; CAH
041CF4 C5 0C 04    0163*  			DW24  OLD			; CBH
041CF7 CE 0B 04    0164*  			DW24  RENUM			; CCH
041CFA F3 0C 04    0165*  			DW24  SAVE			; CDH
041CFD 1F 28 04    0166*  			DW24  PUT			; CEH
041D00 15 26 04    0167*  			DW24  PTR_EX			; CFH
041D03 2F 26 04    0168*  			DW24  PAGEV_EX			; D0H
041D06 42 26 04    0169*  			DW24  TIMEV_EX			; D1H
041D09 6B 26 04    0170*  			DW24  LOMEMV_EX			; D2H
041D0C 84 26 04    0171*  			DW24  HIMEMV_EX			; D3H
041D0F FD 44 04    0172*  			DW24  SOUND			; D4H
041D12 39 27 04    0173*  			DW24  BPUT			; D5H
041D15 51 27 04    0174*  			DW24  CALL_			; D6H
041D18 99 1D 04    0175*  			DW24  CHAIN			; D7H
041D1B E4 25 04    0176*  			DW24  CLR			; D8H
041D1E 2D 27 04    0177*  			DW24  CLOSE			; D9H
041D21 99 42 04    0178*  			DW24  CLG			; DAH
041D24 B7 25 04    0179*  			DW24  CLS			; DBH
041D27 78 1E 04    0180*  			DW24  REM_EX             		; DCH: DATA
041D2A 78 1E 04    0181*  			DW24  REM_EX             		; DDH: DEF
041D2D 3E 1F 04    0182*  			DW24  DIM_EX			; DEH
041D30 C3 44 04    0183*  			DW24  DRAW			; DFH
041D33 13 1E 04    0184*  			DW24  END_			; E0H
041D36 CF 23 04    0185*  			DW24  ENDPRO			; E1H
041D39 E8 4D 04    0186*  			DW24  ENVEL			; E2H
041D3C E4 21 04    0187*  			DW24  FOR_EX			; E3H
041D3F 94 21 04    0188*  			DW24  GOSUB_EX			; E4H
041D42 78 21 04    0189*  			DW24  GOTO_EX			; E5H
041D45 57 44 04    0190*  			DW24  GCOL			; E6H
041D48 83 25 04    0191*  			DW24  IF_			; E7H
041D4B 71 24 04    0192*  			DW24  INPUT			; E8H
041D4E 99 1E 04    0193*  			DW24  LET			; E9H
041D51 74 23 04    0194*  			DW24  LOCAL_EX_			; EAH
041D54 A9 42 04    0195*  			DW24  MODE			; EBH
041D57 BB 44 04    0196*  			DW24  MOVE			; ECH
041D5A 32 22 04    0197*  			DW24  NEXT_EX			; EDH
041D5D 0B 21 04    0198*  			DW24  ON_EX_			; EEH
041D60 EE 26 04    0199*  			DW24  VDU			; EFH
041D63 89 44 04    0200*  			DW24  PLOT			; F0H
041D66 14 20 04    0201*  			DW24  PRINT_			; F1H
041D69 D1 22 04    0202*  			DW24  PROC_EX			; F2H
041D6C 23 25 04    0203*  			DW24  READ			; F3H
041D6F 78 1E 04    0204*  			DW24  REM_EX			; F4H
041D72 B4 21 04    0205*  			DW24  REPEAT_EX			; F5H
041D75 DC 25 04    0206*  			DW24  REPOR			; F6H
041D78 EE 25 04    0207*  			DW24  RESTOR_EX			; F7H
041D7B A2 21 04    0208*  			DW24  RETURN			; F8H
041D7E 93 1D 04    0209*  			DW24  RUN			; F9H
041D81 C4 25 04    0210*  			DW24  STOP			; FAH
041D84 A5 43 04    0211*  			DW24  COLOUR			; FBH
041D87 D0 26 04    0212*  			DW24  TRACE_EX			; FCH
041D8A BE 21 04    0213*  			DW24  UNTIL_EX			; FDH
041D8D C2 26 04    0214*  			DW24  WIDTHV			; FEH
041D90 5E 1E 04    0215*  			DW24  CLI             		; FFH: OSCLI
041D93             0216*  
041D93             0217*  ; RUN
041D93             0218*  ; RUN "filename"
041D93             0219*  ;
041D93 CD F1 29 04 0220*  RUN:			CALL    TERMQ			; Standalone RUN command?
041D97 28 10       0221*  			JR      Z,RUN0			; Yes, so just RUN the code
041D99             0222*  
041D99             0223*  ; CHAIN "filename"
041D99             0224*  ;
041D99 CD 5F 15 04 0225*  CHAIN:			CALL    EXPRS			; Get the filename
041D9D 3E 0D       0226*  			LD      A,CR			; Terminate it with a CR
041D9F 12          0227*  			LD      (DE),A
041DA0 ED 7B 20 05 0228*  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
041DA5 CD D7 0D 04 0229*  			CALL    LOAD0			; And load the file in
041DA9             0230*  ;
041DA9 ED 7B 20 05 0231*  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
041DAE DD 21 38 05 0232*  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
041DB3 ED 5F       0233*  @@:			LD      A, R			; Use the R register to seed the random number generator
041DB5 28 FC       0234*  			JR      Z, @B			; Loop unti we get a non-zero value in A
041DB7 07          0235*  			RLCA				; Rotate it
041DB8 07          0236*  			RLCA
041DB9 DD 77 03    0237*  			LD      (IX+3),A		; And store
041DBC 9F          0238*  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
041DBD DD 77 04    0239*  			LD      (IX+4),A		; And store
041DC0 CD 2E 0E 04 0240*  			CALL    CLEAR
041DC4 21 00 00 00 0241*  			LD      HL,0			; Clear the error trap sysvar
041DC8 22 2C 05 04 0242*  			LD      (ERRTRP),HL
041DCC 2A 14 05 04 0243*  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
041DD0 3E DC       0244*  			LD      A,DATA_			; The DATA token value
041DD2 CD C5 2A 04 0245*  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
041DD6 22 31 05 04 0246*  			LD      (DATPTR),HL     	; Set data pointer
041DDA FD 2A 14 05 0247*  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
041DDF             0248*  ;
041DDF CD 27 1E 04 0249*  XEQ0:			CALL    NEWLIN
041DE3 FD 22 35 05 0250*  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
041DE8 CD 8D 49 04 0251*  			CALL    TRAP           		; Check keyboard
041DEC CD BD 1C 04 0252*  XEQ1:			CALL    NXT
041DF0 FD 23       0253*  			INC     IY
041DF2 FE 3A       0254*  			CP      ':'             	; Seperator
041DF4 28 F6       0255*  			JR      Z,XEQ1
041DF6 FE 0D       0256*  			CP      CR
041DF8 28 E5       0257*  			JR      Z,XEQ0          	; New program line
041DFA D6 C6       0258*  			SUB     TCMD
041DFC DA 87 1E 04 0259*  			JP      C,LET0          	; Implied "LET"
041E00             0260*  
041E00 01 03 00 00 0261*  			LD	BC, 3
041E04 47          0262*  			LD	B, A
041E05 ED 4C       0263*  			MLT	BC
041E07 21 E5 1C 04 0264*  			LD	HL,CMDTAB
041E0B 09          0265*  			ADD	HL, BC
041E0C ED 27       0266*  			LD	HL, (HL)		; Table entry
041E0E             0267*  
041E0E             0268*  ;			ADD     A,A
041E0E             0269*  ;			LD      C,A
041E0E             0270*  ;			LD      B,0
041E0E             0271*  ;			LD      HL,CMDTAB
041E0E             0272*  ;			ADD     HL,BC
041E0E             0273*  ;			LD      A,(HL)          	; Table entry
041E0E             0274*  ;			INC     HL
041E0E             0275*  ;			LD      H,(HL)
041E0E             0276*  ;			LD      L,A
041E0E             0277*  
041E0E CD BD 1C 04 0278*  			CALL    NXT
041E12 E9          0279*  			JP      (HL)            	; Execute the statement
041E13             0280*  
041E13             0281*  ;END
041E13             0282*  ;
041E13 CD 66 0F 04 0283*  END_:			CALL    SETLIN          ;FIND CURRENT LINE
041E17 7C          0284*  			LD      A,H
041E18 B5          0285*  			OR      L               ;DIRECT?
041E19 CA 38 06 04 0286*  			JP      Z,CLOOP
041E1D 1E 00       0287*  			LD      E,0
041E1F CD 5C 4D 04 0288*  			CALL    OSSHUT          ;CLOSE ALL FILES
041E23 C3 37 06 04 0289*  			JP      WARM            ;"Ready"
041E27             0290*  ;
041E27 FD 7E 00    0291*  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
041E2A 01 03 00 00 0292*  			LD      BC,3
041E2E FD 09       0293*  			ADD     IY,BC
041E30 B7          0294*  			OR      A
041E31 28 E0       0295*  			JR      Z,END_           ;LENGTH=0, EXIT
041E33 2A 26 05 04 0296*  			LD      HL,(TRACEN)
041E37 7C          0297*  			LD      A,H
041E38 B5          0298*  			OR      L
041E39 C8          0299*  			RET     Z
041E3A 11 00 00 00 0300*  			LD	DE, 0		;Clear DE
041E3E FD 56 FF    0301*  			LD      D,(IY-1)        ;DE = LINE NUMBER
041E41 FD 5E FE    0302*  			LD      E,(IY-2)
041E44 ED 52       0303*  			SBC     HL,DE
041E46 D8          0304*  			RET     C
041E47 EB          0305*  			EX      DE,HL
041E48 3E 5B       0306*  			LD      A,'['           ;TRACE
041E4A CD 07 0F 04 0307*  			CALL    OUTCHR
041E4E CD AF 0F 04 0308*  			CALL    PBCDL
041E52 3E 5D       0309*  			LD      A,']'
041E54 CD 07 0F 04 0310*  			CALL    OUTCHR
041E58 3E 20       0311*  			LD      A,' '
041E5A C3 07 0F 04 0312*  			JP      OUTCHR
041E5E             0313*  
041E5E             0314*  ; Routines for each statement -------------------------------------------------
041E5E             0315*  
041E5E             0316*  ; OSCLI
041E5E             0317*  ;
041E5E CD 5F 15 04 0318*  CLI:			CALL    EXPRS
041E62 3E 0D       0319*  			LD      A,CR
041E64 12          0320*  			LD      (DE),A
041E65 21 00 02 04 0321*  			LD      HL,ACCS
041E69 CD B0 49 04 0322*  			CALL    OSCLI
041E6D C3 E3 1D 04 0323*  			JP      XEQ
041E71             0324*  
041E71             0325*  ; REM, *
041E71             0326*  ;
041E71 FD E5       0327*  EXT_EX:			PUSH    IY
041E73 E1          0328*  			POP     HL
041E74 CD B0 49 04 0329*  			CALL    OSCLI
041E78 FD E5       0330*  REM_EX:			PUSH    IY
041E7A E1          0331*  			POP     HL
041E7B 3E 0D       0332*  			LD      A,CR
041E7D 47          0333*  			LD      B,A
041E7E ED B1       0334*  			CPIR                    ;FIND LINE END
041E80 E5          0335*  			PUSH    HL
041E81 FD E1       0336*  			POP     IY
041E83 C3 DF 1D 04 0337*  			JP      XEQ0
041E87             0338*  
041E87             0339*  ; [LET] var = expr
041E87             0340*  ;
041E87 FE C5       0341*  LET0:			CP      ELSE_-TCMD
041E89 28 ED       0342*  			JR      Z,REM_EX
041E8B             0343*  			; CP      ('*'-TCMD) & 0FFH
041E8B             0344*  			; JR      Z,EXT_EX
041E8B             0345*  			; CP      ('='-TCMD) & 0FFH
041E8B             0346*  			; JR      Z,FNEND
041E8B             0347*  			; CP      ('['-TCMD) & 0FFH
041E8B             0348*  			; ez80asm doesn't like () in expressions
041E8B FE 64       0349*  			CP      '*'-TCMD & 0FFH
041E8D 28 E2       0350*  			JR      Z,EXT_EX
041E8F FE 77       0351*  			CP      '='-TCMD & 0FFH
041E91 28 5B       0352*  			JR      Z,FNEND
041E93 FE 95       0353*  			CP      '['-TCMD & 0FFH
041E95 28 25       0354*  			JR      Z,ASM
041E97 FD 2B       0355*  			DEC     IY
041E99 CD 35 28 04 0356*  LET:			CALL    ASSIGN			; Assign the variable
041E9D CA E3 1D 04 0357*  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
041EA1 38 41       0358*  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
041EA3             0359*  ;
041EA3 F5          0360*  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
041EA4 CD 07 2A 04 0361*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041EA8 E5          0362*  			PUSH    HL			; HL: Address of the variable
041EA9 CD 5F 15 04 0363*  			CALL    EXPRS
041EAD DD E1       0364*  			POP     IX			; IX: Address of the variable
041EAF F1          0365*  			POP     AF			; AF: The variable type
041EB0 CD 77 28 04 0366*  			CALL    STACCS			; Copy the string from ACCS to the variable area
041EB4 C3 E3 1D 04 0367*  XEQR:			JP      XEQ
041EB8             0368*  ;
041EB8 CD 27 1E 04 0369*  ASM0:			CALL    NEWLIN
041EBC FD 22 35 05 0370*  ASM:			LD      (ERRLIN),IY
       04          
041EC1 CD 8D 49 04 0371*  			CALL    TRAP
041EC5 CD 12 2B 04 0372*  			CALL    ASSEM
041EC9 38 19       0373*  			JR      C,SYNTAX
041ECB FE 0D       0374*  			CP      CR
041ECD 28 E9       0375*  			JR      Z,ASM0
041ECF 21 40 05 04 0376*  			LD      HL,LISTON
041ED3 7E          0377*  			LD      A,(HL)
041ED4 E6 0F       0378*  			AND     0FH
041ED6 F6 B0       0379*  			OR      B0H
041ED8 77          0380*  			LD      (HL),A
041ED9 18 D9       0381*  			JR      XEQR
041EDB             0382*  ;
041EDB CD F2 0F 04 0383*  VAR_:			CALL    GETVAR
041EDF C8          0384*  			RET     Z
041EE0 D2 E1 0F 04 0385*  			JP      NC,PUTVAR
041EE4 3E 10       0386*  SYNTAX:			LD      A,16            ;"Syntax error"
041EE6 18 02       0387*  			JR	ERROR0_EX
041EE8 3E 11       0388*  ESCAPE:			LD      A,17            ;"Escape"
041EEA C3 18 0D 04 0389*  ERROR0_EX:			JP      ERROR_
041EEE             0390*  
041EEE             0391*  ; =
041EEE             0392*  ;
041EEE CD 0C 14 04 0393*  FNEND:			CALL    EXPR            ;FUNCTION RESULT
041EF2 43          0394*  			LD      B,E
041EF3 EB          0395*  			EX      DE,HL
041EF4 D9          0396*  			EXX                     ;SAVE RESULT
041EF5 EB          0397*  			EX      DE,HL           ; IN DEB'C'D'E'
041EF6 C1          0398*  FNEND5:			POP     BC
041EF7 21 CF 29 04 0399*  			LD      HL,LOCCHK
041EFB B7          0400*  			OR      A
041EFC ED 42       0401*  			SBC     HL,BC
041EFE 28 1C       0402*  			JR      Z,FNEND0        ;LOCAL VARIABLE
041F00 21 D1 22 04 0403*  			LD      HL,FNCHK
041F04 B7          0404*  			OR      A
041F05 ED 42       0405*  			SBC     HL,BC
041F07 3E 07       0406*  			LD      A,7
041F09 20 DF       0407*  			JR      NZ,ERROR0_EX       ;"No FN"
041F0B FD E1       0408*  			POP     IY
041F0D FD 22 35 05 0409*  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
041F12 EB          0410*  			EX      DE,HL
041F13 D9          0411*  			EXX
041F14 EB          0412*  			EX      DE,HL
041F15 11 00 02 04 0413*  			LD      DE,ACCS
041F19 58          0414*  			LD      E,B
041F1A 08          0415*  			EX      AF,AF'
041F1B C9          0416*  			RET
041F1C             0417*  ;
041F1C DD E1       0418*  FNEND0:			POP     IX
041F1E C1          0419*  			POP     BC
041F1F 78          0420*  			LD      A,B
041F20 B7          0421*  			OR      A
041F21 FA 2F 1F 04 0422*  			JP      M,FNEND1        ;STRING
041F25 E1          0423*  			POP     HL
041F26 D9          0424*  			EXX
041F27 E1          0425*  			POP     HL
041F28 D9          0426*  			EXX
041F29 CD 4D 28 04 0427*  			CALL    STORE
041F2D 18 C7       0428*  			JR      FNEND5
041F2F 21 00 00 00 0429*  FNEND1:			LD      HL,0
041F33 39          0430*  			ADD     HL,SP
041F34 D5          0431*  			PUSH    DE
041F35 59          0432*  			LD      E,C
041F36 CD 7B 28 04 0433*  			CALL    STORES
041F3A D1          0434*  			POP     DE
041F3B F9          0435*  			LD      SP,HL
041F3C 18 B8       0436*  			JR      FNEND5
041F3E             0437*  
041F3E             0438*  ; DIM var(dim1[,dim2[,...]])[,var(...]
041F3E             0439*  ; DIM var expr[,var expr...]
041F3E             0440*  ;
041F3E CD F2 0F 04 0441*  DIM_EX:			CALL    GETVAR          	; Get the variable
041F42 DA CE 1F 04 0442*  			JP      C,BADDIM		; Throw a "Bad Dim" error
041F46 CA D8 1F 04 0443*  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
041F4A CD 66 11 04 0444*  			CALL    CREATE			; Create a new entity
041F4E E5          0445*  			PUSH    HL			; HL: Address of the entity
041F4F DD E1       0446*  			POP     IX			; IX: Address of the entity
041F51 FD 7E 00    0447*  			LD      A,(IY)			; Fetch the next character from the tokenised string
041F54 FE 28       0448*  			CP      '('			; Check for opening brackets
041F56 7A          0449*  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
041F57 20 7F       0450*  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
041F59             0451*  ;
041F59             0452*  ; At this point we're reserving a variable array
041F59             0453*  ;
041F59 E5          0454*  			PUSH    HL			; HL: Address of the entity
041F5A F5          0455*  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
041F5B 11 01 00 00 0456*  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
041F5F 42          0457*  			LD      B,D			;  B: The number of dimensions in the array
041F60             0458*  ;
041F60 FD 23       0459*  DIM1:			INC     IY			; Skip to the next token
041F62 C5          0460*  			PUSH    BC			; Stack the dimension counter
041F63 D5          0461*  			PUSH    DE			; Stack the total size of array accumulator
041F64 DD E5       0462*  			PUSH    IX			; Stack the entity address
041F66 CD 54 15 04 0463*  			CALL    EXPRI           	; Fetch the size of this dimension
041F6A CB 7C       0464*  			BIT     7,H			; If it is negative then
041F6C 20 60       0465*  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
041F6E D9          0466*  			EXX
041F6F 23          0467*  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
041F70 DD E1       0468*  			POP     IX			; IX: The entity address
041F72 DD 23       0469*  			INC     IX
041F74 DD 75 00    0470*  			LD      (IX),L          	; Save the size of this dimension in the entity
041F77 DD 23       0471*  			INC     IX
041F79 DD 74 00    0472*  			LD      (IX),H
041F7C C1          0473*  			POP     BC
041F7D CD E9 2A 04 0474*  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
041F81 38 4F       0475*  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
041F83 EB          0476*  			EX      DE,HL           	; DE: The new total size of array accumulator
041F84 C1          0477*  			POP     BC
041F85 04          0478*  			INC     B               	;  B: The dimension counter; increment
041F86 FD 7E 00    0479*  			LD      A,(IY)			; Fetch the nex token
041F89 FE 2C       0480*  			CP      ','             	; Check for another dimension in the array
041F8B 28 D3       0481*  			JR      Z,DIM1			; And loop
041F8D             0482*  ;
041F8D CD 7C 1C 04 0483*  			CALL    BRAKET          	; Check for closing bracket
041F91 F1          0484*  			POP     AF              	; Restore the type
041F92 DD 23       0485*  			INC     IX
041F94 DD E3       0486*  			EX      (SP),IX
041F96 DD 70 00    0487*  			LD      (IX),B          	; Number of dimensions
041F99 CD DC 2A 04 0488*  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
041F9D E1          0489*  			POP     HL			; Restore the entity address
041F9E 38 32       0490*  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
041FA0             0491*  ;
041FA0             0492*  ; We now allocate the memory for the array
041FA0             0493*  ;
041FA0 19          0494*  DIM3:			ADD     HL,DE
041FA1 38 2F       0495*  			JR      C,NOROOM
041FA3 E5          0496*  			PUSH    HL
041FA4 24          0497*  			INC     H
041FA5 28 2B       0498*  			JR      Z,NOROOM
041FA7 ED 72       0499*  			SBC     HL,SP
041FA9 30 27       0500*  			JR      NC,NOROOM       	; Throw an "Out of Space" error
041FAB E1          0501*  			POP     HL
041FAC 22 1D 05 04 0502*  			LD      (FREE),HL
041FB0 7A          0503*  DIM2:			LD      A,D
041FB1 B3          0504*  			OR      E
041FB2 28 06       0505*  			JR      Z,DIM5
041FB4 2B          0506*  			DEC     HL
041FB5 36 00       0507*  			LD      (HL),0         		; Initialise the array
041FB7 1B          0508*  			DEC     DE
041FB8 18 F6       0509*  			JR      DIM2
041FBA CD BD 1C 04 0510*  DIM5:			CALL    NXT
041FBE FE 2C       0511*  			CP      ','            		; Another variable?
041FC0 C2 E3 1D 04 0512*  			JP      NZ,XEQ
041FC4 FD 23       0513*  			INC     IY
041FC6 CD BD 1C 04 0514*  			CALL    NXT
041FCA C3 3E 1F 04 0515*  			JP      DIM_EX
041FCE             0516*  ;
041FCE             0517*  ; DIM errors
041FCE             0518*  ;
041FCE 3E 0A       0519*  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
041FD0 18 02       0520*  			JR	ERROR1_EX
041FD2 3E 0B       0521*  NOROOM:			LD      A,11            	; Throw a "DIM space" error
041FD4 C3 18 0D 04 0522*  ERROR1_EX:			JP      ERROR_
041FD8             0523*  ;
041FD8             0524*  ; At this point we're reserving a block of memory, i.e.
041FD8             0525*  ; DIM var expr[,var expr...]
041FD8             0526*  ;
041FD8 B7          0527*  DIM4:			OR      A			;  A: The dimension variable type
041FD9 28 F3       0528*  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
041FDB FA CE 1F 04 0529*  			JP      M,BADDIM        	; or a string
041FDF 47          0530*  			LD      B,A			; Temporarily store the dimension variable type in B
041FE0 FD 7E FF    0531*  			LD      A,(IY-1)		; Get the last character but one
041FE3 FE 29       0532*  			CP      ')'			; Check if it is a trailing bracket
041FE5 28 E7       0533*  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
041FE7             0534*  ;
041FE7 21 00 00 00 0535*  			LD	HL,0			; Clear HL
041FEB 3A 1D 05 04 0536*  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
041FEF 6F          0537*  			LD	L,A
041FF0 3A 1E 05 04 0538*  			LD	A,(FREE+1)
041FF4 67          0539*  			LD	H,A
041FF5 78          0540*  			LD	A,B			; Restore the dimension variable type
041FF6 D9          0541*  			EXX
041FF7 21 00 00 00 0542*  			LD	HL,0			; Clear HL
041FFB 47          0543*  			LD	B,A			; Temporarily store the dimension variable type in B
041FFC 3A 1F 05 04 0544*  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
042000 6F          0545*  			LD	L,A
042001 78          0546*  			LD	A,B			; Restore the dimension variable type
042002 4C          0547*  			LD	C,H
042003 CD 4D 28 04 0548*  			CALL    STORE           	; Store the address
042007 CD 54 15 04 0549*  			CALL    EXPRI			; Get the number of bytes to store
04200B D9          0550*  			EXX
04200C 23          0551*  			INC     HL			; Add one to it
04200D EB          0552*  			EX      DE,HL
04200E 2A 1D 05 04 0553*  			LD      HL,(FREE)
042012 18 8C       0554*  			JR      DIM3			; Continue with the DIM
042014             0555*  
042014             0556*  ; PRINT list...
042014             0557*  ; PRINT #channel,list...
042014             0558*  ;
042014 FE 23       0559*  PRINT_:			CP      '#'
042016 20 7C       0560*  			JR      NZ,PRINT0
042018 CD 09 2B 04 0561*  			CALL    CHNL            ;CHANNEL NO. = E
04201C CD BD 1C 04 0562*  PRNTN1:			CALL    NXT
042020 FE 2C       0563*  			CP      ','
042022 C2 E3 1D 04 0564*  			JP      NZ,XEQ
042026 FD 23       0565*  			INC     IY
042028 D5          0566*  			PUSH    DE
042029 CD 0C 14 04 0567*  			CALL    EXPR            ;ITEM TO PRINT
04202D 08          0568*  			EX      AF,AF'
04202E FA 54 20 04 0569*  			JP      M,PRNTN2        ;STRING
042032 D1          0570*  			POP     DE
042033 C5          0571*  			PUSH    BC
042034 D9          0572*  			EXX
042035 7D          0573*  			LD      A,L
042036 D9          0574*  			EXX
042037 CD 6C 4D 04 0575*  			CALL    OSBPUT
04203B D9          0576*  			EXX
04203C 7C          0577*  			LD      A,H
04203D D9          0578*  			EXX
04203E CD 6C 4D 04 0579*  			CALL    OSBPUT
042042 7D          0580*  			LD      A,L
042043 CD 6C 4D 04 0581*  			CALL    OSBPUT
042047 7C          0582*  			LD      A,H
042048 CD 6C 4D 04 0583*  			CALL    OSBPUT
04204C C1          0584*  			POP     BC
04204D 79          0585*  			LD      A,C
04204E CD 6C 4D 04 0586*  			CALL    OSBPUT
042052 18 C8       0587*  			JR      PRNTN1
042054 4B          0588*  PRNTN2:			LD      C,E
042055 D1          0589*  			POP     DE
042056 21 00 02 04 0590*  			LD      HL,ACCS
04205A 0C          0591*  			INC     C
04205B 0D          0592*  PRNTN3:			DEC     C
04205C 28 0A       0593*  			JR      Z,PRNTN4
04205E 7E          0594*  			LD      A,(HL)
04205F 23          0595*  			INC     HL
042060 C5          0596*  			PUSH    BC
042061 CD 6C 4D 04 0597*  			CALL    OSBPUT
042065 C1          0598*  			POP     BC
042066 18 F3       0599*  			JR      PRNTN3
042068 3E 0D       0600*  PRNTN4:			LD      A,CR
04206A CD 6C 4D 04 0601*  			CALL    OSBPUT
04206E 18 AC       0602*  			JR      PRNTN1
042070             0603*  ;
042070 06 02       0604*  PRINT6:			LD      B,2
042072 18 27       0605*  			JR      PRINTC
042074 01 00 01 00 0606*  PRINT8:			LD      BC,100H
042078 18 21       0607*  			JR      PRINTC
04207A 21 00 04 04 0608*  PRINT9:			LD      HL,STAVAR
04207E AF          0609*  			XOR     A
04207F BE          0610*  			CP      (HL)
042080 28 12       0611*  			JR      Z,PRINT0
042082 3A 3D 05 04 0612*  			LD      A,(COUNT)
042086 B7          0613*  			OR      A
042087 28 0B       0614*  			JR      Z,PRINT0
042089 96          0615*  PRINTA:			SUB     (HL)
04208A 28 08       0616*  			JR      Z,PRINT0
04208C 30 FB       0617*  			JR      NC,PRINTA
04208E ED 44       0618*  			NEG
042090 CD 66 2A 04 0619*  			CALL    FILL
042094 3A 00 04 04 0620*  PRINT0:			LD      A,(STAVAR)
042098 4F          0621*  			LD      C,A             ;PRINTS
042099 06 00       0622*  			LD      B,0             ;PRINTF
04209B CD F1 29 04 0623*  PRINTC:			CALL    TERMQ
04209F 28 3F       0624*  			JR      Z,PRINT4
0420A1 CB 80       0625*  			RES     0,B
0420A3 FD 23       0626*  			INC     IY
0420A5 FE 7E       0627*  			CP      '~'
0420A7 28 C7       0628*  			JR      Z,PRINT6
0420A9 FE 3B       0629*  			CP      ';'
0420AB 28 C7       0630*  			JR      Z,PRINT8
0420AD FE 2C       0631*  			CP      ','
0420AF 28 C9       0632*  			JR      Z,PRINT9
0420B1 CD 16 2A 04 0633*  			CALL    FORMAT          ;SPC, TAB, '
0420B5 28 E4       0634*  			JR      Z,PRINTC
0420B7 FD 2B       0635*  			DEC     IY
0420B9 C5          0636*  			PUSH    BC
0420BA CD 0C 14 04 0637*  			CALL    EXPR            ;VARIABLE TYPE
0420BE 08          0638*  			EX      AF,AF'
0420BF FA D9 20 04 0639*  			JP      M,PRINT3        ;STRING
0420C3 D1          0640*  			POP     DE
0420C4 D5          0641*  			PUSH    DE
0420C5 CB 4A       0642*  			BIT     1,D
0420C7 F5          0643*  			PUSH    AF
0420C8 CC B0 1B 04 0644*  			CALL    Z,STR           ;DECIMAL
0420CC F1          0645*  			POP     AF
0420CD C4 64 1B 04 0646*  			CALL    NZ,HEXSTR       ;HEX
0420D1 C1          0647*  			POP     BC
0420D2 C5          0648*  			PUSH    BC
0420D3 79          0649*  			LD      A,C
0420D4 93          0650*  			SUB     E
0420D5 D4 66 2A 04 0651*  			CALL    NC,FILL         ;RIGHT JUSTIFY
0420D9 C1          0652*  PRINT3:			POP     BC
0420DA CD 75 2A 04 0653*  			CALL    PTEXT           ;PRINT
0420DE 18 BB       0654*  			JR      PRINTC
0420E0 CB 40       0655*  PRINT4:			BIT     0,B
0420E2 CC FF 0E 04 0656*  			CALL    Z,CRLF
0420E6 C3 E3 1D 04 0657*  			JP      XEQ
0420EA             0658*  
0420EA             0659*  ; ON ERROR statement [:statement...]
0420EA             0660*  ; ON ERROR OFF
0420EA             0661*  ;
0420EA FD 23       0662*  ONERR:			INC     IY              ;SKIP "ERROR"
0420EC 21 00 00 00 0663*  			LD      HL,0
0420F0 22 2C 05 04 0664*  			LD      (ERRTRP),HL
0420F4 CD BD 1C 04 0665*  			CALL    NXT
0420F8 FE 87       0666*  			CP      OFF_
0420FA FD 23       0667*  			INC     IY
0420FC CA E3 1D 04 0668*  			JP      Z,XEQ
042100 FD 2B       0669*  			DEC     IY
042102 FD 22 2C 05 0670*  			LD      (ERRTRP),IY
       04          
042107 C3 78 1E 04 0671*  			JP      REM_EX
04210B             0672*  
04210B             0673*  ; ON expr GOTO line[,line...] [ELSE statement]
04210B             0674*  ; ON expr GOTO line[,line...] [ELSE line]
04210B             0675*  ; ON expr GOSUB line[,line...] [ELSE statement]
04210B             0676*  ; ON expr GOSUB line[,line...] [ELSE line]
04210B             0677*  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
04210B             0678*  ;
04210B FE 85       0679*  ON_EX_:			CP      TERROR
04210D 28 DB       0680*  			JR      Z,ONERR         ;"ON ERROR"
04210F CD 54 15 04 0681*  			CALL    EXPRI
042113 FD 7E 00    0682*  			LD      A,(IY)
042116 FD 23       0683*  			INC     IY
042118 1E 2C       0684*  			LD      E,','           ;SEPARATOR
04211A FE E5       0685*  			CP      TGOTO
04211C 28 0B       0686*  			JR      Z,ON1
04211E FE E4       0687*  			CP      TGOSUB
042120 28 07       0688*  			JR      Z,ON1
042122 1E F2       0689*  			LD      E,TPROC
042124 BB          0690*  			CP      E
042125 3E 27       0691*  			LD      A,39
042127 20 45       0692*  			JR      NZ,ERROR2_EX       ;"ON syntax"
042129 57          0693*  ON1:			LD      D,A
04212A D9          0694*  			EXX
04212B E5          0695*  			PUSH    HL
04212C D9          0696*  			EXX
04212D C1          0697*  			POP     BC              ;ON INDEX
04212E 78          0698*  			LD      A,B
04212F B4          0699*  			OR      H
042130 B5          0700*  			OR      L
042131 20 2A       0701*  			JR      NZ,ON4          ;OUT OF RANGE
042133 B1          0702*  			OR      C
042134 28 27       0703*  			JR      Z,ON4
042136 0D          0704*  			DEC     C
042137 28 0E       0705*  			JR      Z,ON3           ;INDEX=1
042139 CD F1 29 04 0706*  ON2:			CALL    TERMQ
04213D 28 1E       0707*  			JR      Z,ON4           ;OUT OF RANGE
04213F FD 23       0708*  			INC     IY              ;SKIP DELIMITER
042141 BB          0709*  			CP      E
042142 20 F5       0710*  			JR      NZ,ON2
042144 0D          0711*  			DEC     C
042145 20 F2       0712*  			JR      NZ,ON2
042147 7B          0713*  ON3:			LD      A,E
042148 FE F2       0714*  			CP      TPROC
04214A 28 26       0715*  			JR      Z,ONPROC
04214C D5          0716*  			PUSH    DE
04214D CD 6F 15 04 0717*  			CALL    ITEMI           ;LINE NUMBER
042151 D1          0718*  			POP     DE
042152 7A          0719*  			LD      A,D
042153 FE E5       0720*  			CP      TGOTO
042155 28 2D       0721*  			JR      Z,GOTO2
042157 CD FE 29 04 0722*  			CALL    SPAN            ;SKIP REST OF LIST
04215B 18 3B       0723*  			JR      GOSUB1
04215D             0724*  ;
04215D FD 7E 00    0725*  ON4:			LD      A,(IY)
042160 FD 23       0726*  			INC     IY
042162 FE 8B       0727*  			CP      ELSE_
042164 CA 98 25 04 0728*  			JP      Z,IF1           ;ELSE CLAUSE
042168 FE 0D       0729*  			CP      CR
04216A 20 F1       0730*  			JR      NZ,ON4
04216C 3E 28       0731*  			LD      A,40
04216E C3 18 0D 04 0732*  ERROR2_EX:			JP      ERROR_           ;"ON range"
042172             0733*  ;
042172 3E EE       0734*  ONPROC:			LD      A,TON
042174 C3 D1 22 04 0735*  			JP      PROC_EX
042178             0736*  
042178             0737*  ; GOTO line
042178             0738*  ;
042178 CD 6F 15 04 0739*  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
04217C CD F1 29 04 0740*  GOTO1:			CALL    TERMQ			; Check for terminator
042180 C2 E4 1E 04 0741*  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
042184 D9          0742*  GOTO2:			EXX
042185 CD 47 0F 04 0743*  			CALL    FINDL			; HL: Line number - Find the line
042189 E5          0744*  			PUSH    HL			; HL: Address of the line
04218A FD E1       0745*  			POP     IY			; IY = HL
04218C CA DF 1D 04 0746*  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
042190 3E 29       0747*  			LD      A,41			; Otherwise throw a "No such line" error
042192 18 DA       0748*  			JR      ERROR2_EX
042194             0749*  
042194             0750*  ; GOSUB line
042194             0751*  ; This pushes the following data onto the execution stack
042194             0752*  ; - 3 bytes: Current execution address
042194             0753*  ; - 3 bytes: Marker (the address of label GOSCHK)
042194             0754*  ;
042194 CD 6F 15 04 0755*  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
042198 FD E5       0756*  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
04219A CD C6 28 04 0757*  			CALL    CHECK           	; Check there is enough room
04219E CD 7C 21 04 0758*  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0421A2             0759*  GOSCHK:			EQU     $
0421A2             0760*  
0421A2             0761*  ; RETURN
0421A2             0762*  ; This pops the following data off the execution stack as pushed by GOSUB
0421A2             0763*  ; - 3 bytes: Marker (should be the address of label GOSCHK)
0421A2             0764*  ; - 3 bytes: The return execution address
0421A2             0765*  ;
0421A2 D1          0766*  RETURN:			POP     DE			; Pop the marker off the execution stack
0421A3 21 A2 21 04 0767*  			LD      HL,GOSCHK		; Compare with GOSCHK
0421A7 B7          0768*  			OR      A
0421A8 ED 52       0769*  			SBC     HL,DE
0421AA FD E1       0770*  			POP     IY			; Pop the return address off the execution stack
0421AC CA E3 1D 04 0771*  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0421B0 3E 26       0772*  			LD      A,38			; Otherwise throw a "No GOSUB" error
0421B2 18 BA       0773*  			JR      ERROR2_EX
0421B4             0774*  
0421B4             0775*  ; REPEAT
0421B4             0776*  ; This pushes the following data onto the execution stack
0421B4             0777*  ; - 3 bytes: Current execution address
0421B4             0778*  ; - 3 bytes: Marker (the address of label REPCHK)
0421B4             0779*  ;
0421B4 FD E5       0780*  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
0421B6 CD C6 28 04 0781*  			CALL    CHECK			; Check if there is enough room
0421BA CD E3 1D 04 0782*  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0421BE             0783*  REPCHK:			EQU     $
0421BE             0784*  
0421BE             0785*  ; UNTIL expr
0421BE             0786*  ; This pops the following data off the execution stack
0421BE             0787*  ; - 3 bytes: Marker (should be the address of label REPCHK)
0421BE             0788*  ; - 3 bytes: The address of the REPEAT instruction
0421BE             0789*  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
0421BE             0790*  ;
0421BE C1          0791*  UNTIL_EX:			POP     BC			; Fetch the marker
0421BF C5          0792*  			PUSH    BC			; And push it back onto the execution stack
0421C0 21 BE 21 04 0793*  			LD      HL,REPCHK		; Compare with REPCHK
0421C4 B7          0794*  			OR      A
0421C5 ED 42       0795*  			SBC     HL,BC
0421C7 3E 2B       0796*  			LD      A,43
0421C9 20 A3       0797*  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
0421CB CD 54 15 04 0798*  			CALL    EXPRI			; Fetch the expression
0421CF CD 29 1B 04 0799*  			CALL    TEST			; Test if the expression evaluates to zero
0421D3 C1          0800*  			POP     BC			; Pop the marker
0421D4 D1          0801*  			POP     DE			; Pop the address of the REPEAT instruction
0421D5 20 05       0802*  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0421D7 D5          0803*  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0421D8 C5          0804*  			PUSH    BC			; Push the marker back on the stack
0421D9 D5          0805*  			PUSH    DE			; IY = DE
0421DA FD E1       0806*  			POP     IY			; This sets the execution address back to the REPEAT instruction
0421DC C3 E3 1D 04 0807*  XEQ2:			JP      XEQ			; Continue execution
0421E0             0808*  
0421E0             0809*  ; FOR var = expr TO expr [STEP expr]
0421E0             0810*  ; This pushes the following data onto the execution stack
0421E0             0811*  ; - 3 bytes: The limit value
0421E0             0812*  ; - 3 bytes: The step value
0421E0             0813*  ; - 3 bytes: The current execution address
0421E0             0814*  ; - 3 bytes: The address of the loop variable
0421E0             0815*  ; - 3 bytes: Marker (the address of FORCHK)
0421E0             0816*  ;
0421E0 3E 22       0817*  FORVAR:			LD      A,34
0421E2 18 8A       0818*  			JR      ERROR2_EX          	; Throw "FOR variable" error
0421E4             0819*  ;
0421E4 CD 35 28 04 0820*  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
0421E8 20 F6       0821*  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
0421EA F5          0822*  			PUSH    AF              	; Save the variable type
0421EB FD 7E 00    0823*  			LD      A,(IY)			; Check the next token
0421EE FE B8       0824*  			CP      TO			; Compare with the token value for "TO"
0421F0 3E 24       0825*  			LD      A,36			; Set the error code to 36 ("No TO")
0421F2 C2 6E 21 04 0826*  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
0421F6 FD 23       0827*  			INC     IY			; Skip to the next token
0421F8             0828*  ;
0421F8 DD E5       0829*  			PUSH    IX
0421FA CD 4C 15 04 0830*  			CALL    EXPRN           	; Fetch the LIMIT expression value
0421FE DD E1       0831*  			POP     IX
042200 F1          0832*  			POP     AF
042201 47          0833*  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
042202 C5          0834*  			PUSH    BC              	; Stack the LIMIT value
042203 E5          0835*  			PUSH    HL
042204 21 00 00 00 0836*  			LD      HL,0
042208 4C          0837*  			LD      C,H
042209 D9          0838*  			EXX
04220A E5          0839*  			PUSH    HL
04220B             0840*  ;
04220B 21 01 00 00 0841*  			LD      HL,1            	; The preset STEP value is 1
04220F D9          0842*  			EXX
042210 FD 7E 00    0843*  			LD      A,(IY)			; Fetch the next token
042213 FE 88       0844*  			CP      STEP			; Compare with the token value for "STEP"
042215 20 0A       0845*  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
042217             0846*  ;
042217 FD 23       0847*  			INC     IY			; Skip past the STEP token
042219 DD E5       0848*  			PUSH    IX
04221B CD 4C 15 04 0849*  			CALL    EXPRN          		; Fetch the STEP expression value
04221F DD E1       0850*  			POP     IX
042221             0851*  ;
042221 C5          0852*  FOR1:			PUSH    BC			; Stack the STEP value
042222 E5          0853*  			PUSH    HL
042223 D9          0854*  			EXX
042224 E5          0855*  			PUSH    HL
042225 D9          0856*  			EXX
042226             0857*  ;
042226 FD E5       0858*  			PUSH    IY              	; Stack the current execution address
042228 DD E5       0859*  			PUSH    IX              	; Stack the loop variable
04222A CD C6 28 04 0860*  			CALL    CHECK
04222E CD E3 1D 04 0861*  			CALL    XEQ
042232             0862*  FORCHK:			EQU     $
042232             0863*  
042232             0864*  ; NEXT [var[,var...]]
042232             0865*  ; This pops the following data off the execution stack
042232             0866*  ; - 3 bytes: Marker (the address of FORCHK)
042232             0867*  ; - 3 bytes: The address of the loop variable
042232             0868*  ; - 3 bytes: The current execution address
042232             0869*  ; - 3 bytes: The step value
042232             0870*  ; - 3 bytes: The limit value
042232             0871*  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
042232             0872*  ;
042232 C1          0873*  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
042233 21 32 22 04 0874*  			LD      HL,FORCHK		; Compare with FORCHK
042237 B7          0875*  			OR      A
042238 ED 42       0876*  			SBC     HL,BC
04223A 3E 20       0877*  			LD      A,32
04223C C2 C8 22 04 0878*  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
042240 CD F1 29 04 0879*  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
042244 E1          0880*  			POP     HL			; Pop the address of the loop variable off the execution stack
042245 E5          0881*  			PUSH    HL			; Push it back onto the execution stack
042246 C5          0882*  			PUSH    BC			; Push the marker back onto the execution stack
042247 E5          0883*  			PUSH    HL			; HL: Address of the loop variable off the stack
042248 C4 F2 0F 04 0884*  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
04224C D1          0885*  			POP     DE			; DE: Address of the loop variable off the stack
04224D EB          0886*  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
04224E B7          0887*  			OR      A
04224F ED 52       0888*  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
042251 20 61       0889*  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
042253 D5          0890*  			PUSH    DE
042254 DD 21 0C 00 0891*  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
042259 DD 39       0892*  			ADD     IX,SP
04225B CD 5E 3C 04 0893*  			CALL    DLOAD5_SPL      	; Load the STEP value
04225F DD 7E 10    0894*  			LD      A,(IX+16)       	; Get the STEP type
042262 DD E1       0895*  			POP     IX
042264 CD 60 16 04 0896*  			CALL    LOADN           	; Load the LOOP variable
042268 CB 7A       0897*  			BIT     7,D             	; Check the sign
04226A F5          0898*  			PUSH    AF
04226B 3E 0B       0899*  			LD      A,'+' & 0FH
04226D CD E7 32 04 0900*  			CALL    FPP             	; Add the STEP
042271 38 55       0901*  			JR      C,ERROR3_EX
042273 F1          0902*  			POP     AF              	; Restore TYPE
042274 F5          0903*  			PUSH    AF
042275 CD 4D 28 04 0904*  			CALL    STORE           	; Update the variable
042279 DD 21 15 00 0905*  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
04227E DD 39       0906*  			ADD     IX,SP
042280 CD 5E 3C 04 0907*  			CALL    DLOAD5_SPL      	; Load the LIMIT value
042284 F1          0908*  			POP     AF
042285 CC 21 1B 04 0909*  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
042289             0910*  			; LD      A,0+('<'-4) & 0FH
042289 3E 08       0911*  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04228B CD E7 32 04 0912*  			CALL    FPP             	; Test against the limit
04228F 38 37       0913*  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
042291 24          0914*  			INC     H
042292 20 14       0915*  			JR      NZ,LOOP_        	; Keep looping
042294 21 1B 00 00 0916*  			LD      HL,27			; Adjust the stack
042298 39          0917*  			ADD     HL,SP
042299 F9          0918*  			LD      SP,HL
04229A CD BD 1C 04 0919*  			CALL    NXT
04229E FE 2C       0920*  			CP      ','			; Check for multiple variables
0422A0 C2 E3 1D 04 0921*  			JP      NZ,XEQ			; No, so we are done at ths point
0422A4 FD 23       0922*  			INC     IY			; Increment to the next variable
0422A6 18 8A       0923*  			JR      NEXT_EX			; And continue
0422A8             0924*  ;
0422A8 C1          0925*  LOOP_:			POP     BC
0422A9 D1          0926*  			POP     DE
0422AA FD E1       0927*  			POP     IY
0422AC FD E5       0928*  			PUSH    IY
0422AE D5          0929*  			PUSH    DE
0422AF C5          0930*  			PUSH    BC
0422B0 C3 E3 1D 04 0931*  			JP      XEQ
0422B4             0932*  ;
0422B4 21 1B 00 00 0933*  NEXT1:			LD      HL,27			; TODO: What does this do?
0422B8 39          0934*  			ADD     HL,SP
0422B9 F9          0935*  			LD      SP,HL			; Adjust the stack
0422BA C1          0936*  			POP     BC
0422BB 21 32 22 04 0937*  			LD      HL,FORCHK
0422BF ED 42       0938*  			SBC     HL,BC
0422C1 E1          0939*  			POP     HL              	; Variable pointer
0422C2 E5          0940*  			PUSH    HL
0422C3 C5          0941*  			PUSH    BC
0422C4 28 89       0942*  			JR      Z,NEXT0
0422C6             0943*  ;
0422C6 3E 21       0944*  			LD      A,33
0422C8 C3 18 0D 04 0945*  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
0422CC             0946*  
0422CC             0947*  ; FNname
0422CC             0948*  ; N.B. ENTERED WITH A <> TON
0422CC             0949*  ;
0422CC F5          0950*  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0422CD CD D6 22 04 0951*  			CALL    PROC1
0422D1             0952*  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0422D1             0953*  
0422D1             0954*  ; PROCname
0422D1             0955*  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
0422D1             0956*  ; This pushes the following data onto the execution stack
0422D1             0957*  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
0422D1             0958*  ; - 3 bytes: Marker (the address of PROCHK)
0422D1             0959*  ;
0422D1 F5          0960*  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0422D2 CD D6 22 04 0961*  			CALL    PROC1			; and is also space reserved on the stack for the return address
0422D6             0962*  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0422D6             0963*  ;
0422D6 CD C6 28 04 0964*  PROC1:			CALL    CHECK			; Check there is space for this
0422DA FD 2B       0965*  			DEC     IY			; Decrement IY to the PROC token
0422DC FD E5       0966*  			PUSH    IY			; Stack the pointer
0422DE CD B3 10 04 0967*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0422E2 C1          0968*  			POP     BC			; BC = IY
0422E3 28 41       0969*  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0422E5 3E 1E       0970*  			LD      A,30
0422E7 38 DF       0971*  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0422E9             0972*  ;
0422E9             0973*  ; At this point the PROC/FN has not yet been registered in the dynamic area
0422E9             0974*  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0422E9             0975*  ;
0422E9 C5          0976*  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0422EA 2A 14 05 04 0977*  			LD      HL,(PAGE_)		; HL: Start of program memory
0422EE             0978*  ;
0422EE 3E DD       0979*  PROC2:			LD      A,DEF_			;  A: The token to search for
0422F0 CD C5 2A 04 0980*  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0422F4 38 26       0981*  			JR      C,PROC3			; Not found, so jump to PROC3
0422F6 E5          0982*  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0422F7 FD E1       0983*  			POP     IY			; IY = HL
0422F9 FD 23       0984*  			INC     IY              	; Skip the DEF token
0422FB CD BD 1C 04 0985*  			CALL    NXT			; And any whitespace
0422FF CD B3 10 04 0986*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
042303 FD E5       0987*  			PUSH    IY
042305 D1          0988*  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
042306 38 09       0989*  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
042308 C4 66 11 04 0990*  			CALL    NZ,CREATE		; Create an entity in the dynamic area
04230C FD E5       0991*  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
04230E D1          0992*  			POP     DE			; DE = IY
04230F ED 1F       0993*  			LD	(HL),DE			; Save address
042311             0994*  ;
042311 EB          0995*  PROC6:			EX      DE,HL			; HL: Address of the procedure
042312 3E 0D       0996*  			LD      A,CR			; The character to search for
042314 01 00 01 00 0997*  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
042318 ED B1       0998*  			CPIR                    	; Skip to next line
04231A 18 D2       0999*  			JR      PROC2			; Rinse, lather and repeat
04231C             1000*  ;
04231C             1001*  ; At this point a DEF has not been found for the PROC/FN
04231C             1002*  ;
04231C FD E1       1003*  PROC3:			POP     IY              	; Restore the execution address
04231E CD B3 10 04 1004*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
042322 3E 1D       1005*  			LD      A,29
042324 20 A2       1006*  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
042326             1007*  ;
042326             1008*  ; At this point we have a PROC/FN entry in the dynamic area
042326             1009*  ;
042326 ED 17       1010*  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
042328 21 03 00 00 1011*  			LD	HL,3
04232C 39          1012*  			ADD     HL,SP
04232D CD BD 1C 04 1013*  			CALL    NXT             	; Allow space before "("
042331 D5          1014*  			PUSH    DE              	; Exchange DE and IY
042332 FD E3       1015*  			EX      (SP),IY
042334 FE 28       1016*  			CP      '('             	; Arguments?
042336 D1          1017*  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
042337 20 20       1018*  			JR      NZ,PROC5
042339 CD BD 1C 04 1019*  			CALL    NXT             	; Allow space before "("
04233D FE 28       1020*  			CP      '('
04233F C2 E4 1E 04 1021*  			JP      NZ,SYNTAX       	; Throw "Syntax error"
042343 FD E5       1022*  			PUSH    IY
042345 C1          1023*  			POP     BC              	; Save IY in BC
042346 D9          1024*  			EXX
042347 CD 71 29 04 1025*  			CALL    SAVLOC          	; Save local parameters
04234B CD 7C 1C 04 1026*  			CALL    BRAKET          	; Closing bracket
04234F D9          1027*  			EXX
042350 C5          1028*  			PUSH    BC
042351 FD E1       1029*  			POP     IY              	; Restore IY
042353 E5          1030*  			PUSH    HL
042354 CD ED 28 04 1031*  			CALL    ARGUE           	; Transfer arguments
042358 E1          1032*  			POP     HL
042359             1033*  ;
042359 23          1034*  PROC5:			INC	HL			; Increment to the ON PROC flag address
04235A 7E          1035*  			LD	A, (HL)			; And fetch the value
04235B 2B          1036*  			DEC 	HL
04235C ED 1F       1037*  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
04235E FE EE       1038*  			CP	TON			; Was it "ON PROC"?
042360 C2 E3 1D 04 1039*  			JP	NZ, XEQ			; No, so back to XEQ
042364 D5          1040*  			PUSH    DE			; Exchange DE and IY
042365 FD E3       1041*  			EX      (SP),IY
042367 CD FE 29 04 1042*  			CALL    SPAN            	; Skip rest of ON list
04236B FD E3       1043*  			EX      (SP),IY			; Exchange DE and IY
04236D D1          1044*  			POP     DE
04236E ED 1F       1045*  			LD	(HL), DE		; Save the return address
042370 C3 E3 1D 04 1046*  			JP      XEQ
042374             1047*  
042374             1048*  ; LOCAL var[,var...]
042374             1049*  ;
042374 C1          1050*  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
042375 C5          1051*  			PUSH    BC
042376 21 D1 22 04 1052*  			LD      HL,FNCHK		; Check if we are in a FN
04237A B7          1053*  			OR      A
04237B ED 42       1054*  			SBC     HL,BC
04237D 28 16       1055*  			JR      Z,LOCAL1		; Yes, so all good, we can use local
04237F 21 D6 22 04 1056*  			LD      HL,PROCHK		; Now check if we are in a PROC
042383 B7          1057*  			OR      A
042384 ED 42       1058*  			SBC     HL,BC
042386 28 0D       1059*  			JR      Z,LOCAL1		; Again, all good, we can use local
042388 21 CF 29 04 1060*  			LD      HL,LOCCHK		; Finally check for the local parameters marker
04238C B7          1061*  			OR      A
04238D ED 42       1062*  			SBC     HL,BC			; If it is not present, then
04238F 3E 0C       1063*  			LD      A,12
042391 C2 18 0D 04 1064*  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
042395             1065*  ;
042395             1066*  ; At this point we are adding a local variable into a PROC or FN
042395             1067*  ;
042395 FD E5       1068*  LOCAL1:			PUSH    IY			; IY: BASIC pointer
042397 C1          1069*  			POP     BC			; BC: Copy of the BASIC pointer
042398 D9          1070*  			EXX
042399 FD 2B       1071*  			DEC     IY
04239B CD 71 29 04 1072*  			CALL    SAVLOC
04239F D9          1073*  			EXX
0423A0 C5          1074*  			PUSH    BC
0423A1 FD E1       1075*  			POP     IY
0423A3             1076*  ;
0423A3 CD F2 0F 04 1077*  LOCAL2:			CALL    GETVAR			; Get the variable location
0423A7 C2 E4 1E 04 1078*  			JP      NZ,SYNTAX
0423AB B7          1079*  			OR      A               	; Check the variable type (80h = string)
0423AC 08          1080*  			EX      AF,AF'
0423AD CD DD 1B 04 1081*  			CALL    ZERO			; Zero the variable anyway
0423B1 08          1082*  			EX      AF,AF'
0423B2 F5          1083*  			PUSH    AF
0423B3 F4 4D 28 04 1084*  			CALL    P,STORE         	; Call STORE if it is not a string
0423B7 F1          1085*  			POP     AF
0423B8 59          1086*  			LD      E,C
0423B9 FC 7B 28 04 1087*  			CALL    M,STORES		; Call STORES if it is a string
0423BD CD BD 1C 04 1088*  			CALL    NXT			; Skip to the next character in the expression
0423C1 FE 2C       1089*  			CP      ','			; Is it a comma?
0423C3 C2 E3 1D 04 1090*  			JP      NZ,XEQ			; No, so we're done, carry on executing
0423C7 FD 23       1091*  			INC     IY			; Yes, so skip the comma
0423C9 CD BD 1C 04 1092*  			CALL    NXT			; And any whitespace
0423CD 18 D4       1093*  			JR      LOCAL2			; Then loop back and handle any further local variables
0423CF             1094*  
0423CF             1095*  ; ENDPROC
0423CF             1096*  ;
0423CF C1          1097*  ENDPRO:			POP     BC			; Pop the check value off the stack
0423D0 21 CF 29 04 1098*  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
0423D4 B7          1099*  			OR      A
0423D5 ED 42       1100*  			SBC     HL,BC
0423D7 28 13       1101*  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
0423D9             1102*  ;
0423D9 21 D6 22 04 1103*  			LD      HL,PROCHK       	; Check if it is the PROC marker
0423DD B7          1104*  			OR      A
0423DE ED 42       1105*  			SBC     HL,BC
0423E0 FD E1       1106*  			POP     IY
0423E2 CA E3 1D 04 1107*  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0423E6 3E 0D       1108*  			LD      A,13			; Otherwise throw the "No PROC" error
0423E8 C3 18 0D 04 1109*  			JP      ERROR_
0423EC             1110*  ;
0423EC DD E1       1111*  UNSTK:			POP     IX			; Unstack a single local variable
0423EE C1          1112*  			POP     BC
0423EF 78          1113*  			LD      A,B
0423F0 B7          1114*  			OR      A
0423F1 FA FF 23 04 1115*  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0423F5 E1          1116*  			POP     HL			; Unstack a normal variable
0423F6 D9          1117*  			EXX
0423F7 E1          1118*  			POP     HL
0423F8 D9          1119*  			EXX
0423F9 CD 4D 28 04 1120*  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0423FD 18 D0       1121*  			JR      ENDPRO			; And loop back to ENDPRO
0423FF             1122*  ;
0423FF 21 00 00 00 1123*  UNSTK1:			LD      HL,0			; Unstack a string
042403 39          1124*  			ADD     HL,SP
042404 59          1125*  			LD      E,C
042405 CD 7B 28 04 1126*  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
042409 F9          1127*  			LD      SP,HL
04240A 18 C3       1128*  			JR      ENDPRO
04240C             1129*  
04240C             1130*  ; INPUT #channel,var,var...
04240C             1131*  ;
04240C CD 09 2B 04 1132*  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
042410 CD BD 1C 04 1133*  INPN1:			CALL    NXT
042414 FE 2C       1134*  			CP      ','
042416 C2 E3 1D 04 1135*  			JP      NZ,XEQ
04241A FD 23       1136*  			INC     IY
04241C CD BD 1C 04 1137*  			CALL    NXT
042420 D5          1138*  			PUSH    DE
042421 CD DB 1E 04 1139*  			CALL    VAR_
042425 D1          1140*  			POP     DE
042426 F5          1141*  			PUSH    AF              ;SAVE TYPE
042427 E5          1142*  			PUSH    HL              ;VARPTR
042428 B7          1143*  			OR      A
042429 FA 55 24 04 1144*  			JP      M,INPN2         ;STRING
04242D CD 64 4D 04 1145*  			CALL    OSBGET
042431 D9          1146*  			EXX
042432 6F          1147*  			LD      L,A
042433 D9          1148*  			EXX
042434 CD 64 4D 04 1149*  			CALL    OSBGET
042438 D9          1150*  			EXX
042439 67          1151*  			LD      H,A
04243A D9          1152*  			EXX
04243B CD 64 4D 04 1153*  			CALL    OSBGET
04243F 6F          1154*  			LD      L,A
042440 CD 64 4D 04 1155*  			CALL    OSBGET
042444 67          1156*  			LD      H,A
042445 CD 64 4D 04 1157*  			CALL    OSBGET
042449 4F          1158*  			LD      C,A
04244A DD E1       1159*  			POP     IX
04244C F1          1160*  			POP     AF              ;RESTORE TYPE
04244D D5          1161*  			PUSH    DE              ;SAVE CHANNEL
04244E CD 4D 28 04 1162*  			CALL    STORE
042452 D1          1163*  			POP     DE
042453 18 BB       1164*  			JR      INPN1
042455 21 00 02 04 1165*  INPN2:			LD      HL,ACCS
042459 CD 64 4D 04 1166*  INPN3:			CALL    OSBGET
04245D FE 0D       1167*  			CP      CR
04245F 28 04       1168*  			JR      Z,INPN4
042461 77          1169*  			LD      (HL),A
042462 2C          1170*  			INC     L
042463 20 F4       1171*  			JR      NZ,INPN3
042465 DD E1       1172*  INPN4:			POP     IX
042467 F1          1173*  			POP     AF
042468 D5          1174*  			PUSH    DE
042469 EB          1175*  			EX      DE,HL
04246A CD 77 28 04 1176*  			CALL    STACCS
04246E D1          1177*  			POP     DE
04246F 18 9F       1178*  			JR      INPN1
042471             1179*  
042471             1180*  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
042471             1181*  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
042471             1182*  ;
042471 FE 23       1183*  INPUT:			CP      '#'
042473 28 97       1184*  			JR      Z,INPUTN
042475 0E 00       1185*  			LD      C,0             ;FLAG PROMPT
042477 FE 86       1186*  			CP      LINE_
042479 20 04       1187*  			JR      NZ,INPUT0
04247B FD 23       1188*  			INC     IY              ;SKIP "LINE"
04247D 0E 80       1189*  			LD      C,80H
04247F 21 00 03 04 1190*  INPUT0:			LD      HL,BUFFER
042483 36 0D       1191*  			LD      (HL),CR         ;INITIALISE EMPTY
042485 CD F1 29 04 1192*  INPUT1:			CALL    TERMQ
042489 CA E3 1D 04 1193*  			JP      Z,XEQ           ;DONE
04248D FD 23       1194*  			INC     IY
04248F FE 2C       1195*  			CP      ','
042491 28 5C       1196*  			JR      Z,INPUT3        ;SKIP COMMA
042493 FE 3B       1197*  			CP      ';'
042495 28 58       1198*  			JR      Z,INPUT3
042497 E5          1199*  			PUSH    HL              ;SAVE BUFFER POINTER
042498 FE 22       1200*  			CP      34		;ASCII ""
04249A 20 0C       1201*  			JR      NZ,INPUT6
04249C C5          1202*  			PUSH    BC
04249D CD B1 16 04 1203*  			CALL    CONS
0424A1 C1          1204*  			POP     BC
0424A2 CD 75 2A 04 1205*  			CALL    PTEXT           ;PRINT PROMPT
0424A6 18 06       1206*  			JR      INPUT9
0424A8 CD 16 2A 04 1207*  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
0424AC 20 05       1208*  			JR      NZ,INPUT2
0424AE E1          1209*  INPUT9:			POP     HL
0424AF CB C1       1210*  			SET     0,C             ;FLAG NO PROMPT
0424B1 18 CC       1211*  			JR      INPUT0
0424B3 FD 2B       1212*  INPUT2:			DEC     IY
0424B5 C5          1213*  			PUSH    BC
0424B6 CD DB 1E 04 1214*  			CALL    VAR_
0424BA C1          1215*  			POP     BC
0424BB E1          1216*  			POP     HL
0424BC F5          1217*  			PUSH    AF              ;SAVE TYPE
0424BD 7E          1218*  			LD      A,(HL)
0424BE 23          1219*  			INC     HL
0424BF FE 0D       1220*  			CP      CR              ;BUFFER EMPTY?
0424C1 CC F3 24 04 1221*  			CALL    Z,REFILL
0424C5 CB 79       1222*  			BIT     7,C
0424C7 F5          1223*  			PUSH    AF
0424C8 C4 97 2A 04 1224*  			CALL    NZ,LINES
0424CC F1          1225*  			POP     AF
0424CD CC 84 2A 04 1226*  			CALL    Z,FETCHS
0424D1 F1          1227*  			POP     AF              ;RESTORE TYPE
0424D2 C5          1228*  			PUSH    BC
0424D3 E5          1229*  			PUSH    HL
0424D4 B7          1230*  			OR      A
0424D5 FA E9 24 04 1231*  			JP      M,INPUT4        ;STRING
0424D9 F5          1232*  			PUSH    AF
0424DA DD E5       1233*  			PUSH    IX
0424DC CD B8 18 04 1234*  			CALL    VAL0
0424E0 DD E1       1235*  			POP     IX
0424E2 F1          1236*  			POP     AF
0424E3 CD 4D 28 04 1237*  			CALL    STORE
0424E7 18 04       1238*  			JR      INPUT5
0424E9 CD 77 28 04 1239*  INPUT4:			CALL    STACCS
0424ED E1          1240*  INPUT5:			POP     HL
0424EE C1          1241*  			POP     BC
0424EF CB 81       1242*  INPUT3:			RES     0,C
0424F1 18 92       1243*  			JR      INPUT1
0424F3             1244*  ;
0424F3 CB 41       1245*  REFILL:			BIT     0,C
0424F5 20 0C       1246*  			JR      NZ,REFIL0       ;NO PROMPT
0424F7 3E 3F       1247*  			LD      A,'?'
0424F9 CD 07 0F 04 1248*  			CALL    OUTCHR          ;PROMPT
0424FD 3E 20       1249*  			LD      A,' '
0424FF CD 07 0F 04 1250*  			CALL    OUTCHR
042503 21 00 03 04 1251*  REFIL0:			LD      HL,BUFFER
042507 C5          1252*  			PUSH    BC
042508 E5          1253*  			PUSH    HL
042509 DD E5       1254*  			PUSH    IX
04250B CD 7F 48 04 1255*  			CALL    OSLINE
04250F DD E1       1256*  			POP     IX
042511 E1          1257*  			POP     HL
042512 C1          1258*  			POP     BC
042513 47          1259*  			LD      B,A             ;POS AT ENTRY
042514 AF          1260*  			XOR     A
042515 32 3D 05 04 1261*  			LD      (COUNT),A
042519 B8          1262*  			CP      B
04251A C8          1263*  			RET     Z
04251B 7E          1264*  REFIL1:			LD      A,(HL)
04251C FE 0D       1265*  			CP      CR
04251E C8          1266*  			RET     Z
04251F 23          1267*  			INC     HL
042520 10 F9       1268*  			DJNZ    REFIL1
042522 C9          1269*  			RET
042523             1270*  
042523             1271*  ; READ var[,var...]
042523             1272*  ;
042523 FE 23       1273*  READ:			CP      '#'
042525 CA 0C 24 04 1274*  			JP      Z,INPUTN
042529 2A 31 05 04 1275*  			LD      HL,(DATPTR)
04252D 7E          1276*  READ0:			LD      A,(HL)
04252E 23          1277*  			INC     HL              ;SKIP COMMA OR "DATA"
04252F FE 0D       1278*  			CP      CR              ;END OF DATA STMT?
042531 CC 75 25 04 1279*  			CALL    Z,GETDAT
042535 E5          1280*  			PUSH    HL
042536 CD DB 1E 04 1281*  			CALL    VAR_
04253A E1          1282*  			POP     HL
04253B B7          1283*  			OR      A
04253C FA 55 25 04 1284*  			JP      M,READ1         ;STRING
042540 E5          1285*  			PUSH    HL
042541 FD E3       1286*  			EX      (SP),IY
042543 F5          1287*  			PUSH    AF              ;SAVE TYPE
042544 DD E5       1288*  			PUSH    IX
042546 CD 4C 15 04 1289*  			CALL    EXPRN
04254A DD E1       1290*  			POP     IX
04254C F1          1291*  			POP     AF
04254D CD 4D 28 04 1292*  			CALL    STORE
042551 FD E3       1293*  			EX      (SP),IY
042553 18 09       1294*  			JR      READ2
042555 CD 84 2A 04 1295*  READ1:			CALL    FETCHS
042559 E5          1296*  			PUSH    HL
04255A CD 77 28 04 1297*  			CALL    STACCS
04255E E1          1298*  READ2:			POP     HL
04255F 22 31 05 04 1299*  			LD      (DATPTR),HL
042563 CD BD 1C 04 1300*  			CALL    NXT
042567 FE 2C       1301*  			CP      ','
042569 C2 E3 1D 04 1302*  			JP      NZ,XEQ
04256D FD 23       1303*  			INC     IY
04256F CD BD 1C 04 1304*  			CALL    NXT
042573 18 B8       1305*  			JR      READ0
042575             1306*  ;
042575 3E DC       1307*  GETDAT:			LD      A,DATA_
042577 CD C5 2A 04 1308*  			CALL    SEARCH_EX
04257B 23          1309*  			INC     HL
04257C D0          1310*  			RET     NC
04257D 3E 2A       1311*  			LD      A,42
04257F C3 18 0D 04 1312*  ERROR4:			JP      ERROR_           ;"Out of DATA"
042583             1313*  
042583             1314*  ; IF expr statement
042583             1315*  ; IF expr THEN statement [ELSE statement]
042583             1316*  ; IF expr THEN line [ELSE line]
042583             1317*  ;
042583 CD 54 15 04 1318*  IF_:			CALL    EXPRI
042587 CD 29 1B 04 1319*  			CALL    TEST
04258B 28 19       1320*  			JR      Z,IFNOT         ;FALSE
04258D FD 7E 00    1321*  			LD      A,(IY)
042590 FE 8C       1322*  			CP      THEN
042592 C2 E3 1D 04 1323*  			JP      NZ,XEQ
042596 FD 23       1324*  			INC     IY              ;SKIP "THEN"
042598 CD BD 1C 04 1325*  IF1:			CALL    NXT
04259C FE 8D       1326*  			CP      LINO
04259E C2 E3 1D 04 1327*  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
0425A2 C3 78 21 04 1328*  			JP      GOTO_EX            ;LINE NO. FOLLOWS
0425A6 FD 7E 00    1329*  IFNOT:			LD      A,(IY)
0425A9 FE 0D       1330*  			CP      CR
0425AB FD 23       1331*  			INC     IY
0425AD CA DF 1D 04 1332*  			JP      Z,XEQ0          ;END OF LINE
0425B1 FE 8B       1333*  			CP      ELSE_
0425B3 20 F1       1334*  			JR      NZ,IFNOT
0425B5 18 E1       1335*  			JR      IF1
0425B7             1336*  
0425B7             1337*  ; CLS
0425B7             1338*  ;
0425B7 CD A3 42 04 1339*  CLS:		CALL    CLRSCN
0425BB AF          1340*  			XOR     A
0425BC 32 3D 05 04 1341*  			LD      (COUNT),A
0425C0 C3 E3 1D 04 1342*  			JP      XEQ
0425C4             1343*  
0425C4             1344*  ; STOP
0425C4             1345*  ;
0425C4 CD 48 13 04 1346*  STOP:			CALL    TELL
0425C8 0D          1347*  			DB	CR
0425C9 0A          1348*  			DB	LF
0425CA FA          1349*  			DB	TSTOP
0425CB 00          1350*  			DB	0
0425CC CD 66 0F 04 1351*  			CALL    SETLIN          ;FIND CURRENT LINE
0425D0 CD 9A 0F 04 1352*  			CALL    SAYLN
0425D4 CD FF 0E 04 1353*  			CALL    CRLF
0425D8 C3 38 06 04 1354*  			JP      CLOOP
0425DC             1355*  
0425DC             1356*  ; REPORT
0425DC             1357*  ;
0425DC CD 3A 13 04 1358*  REPOR:			CALL    REPORT
0425E0 C3 E3 1D 04 1359*  			JP      XEQ
0425E4             1360*  
0425E4             1361*  ; CLEAR
0425E4             1362*  ;
0425E4 CD 2E 0E 04 1363*  CLR:			CALL    CLEAR
0425E8 2A 14 05 04 1364*  			LD      HL,(PAGE_)
0425EC 18 19       1365*  			JR      RESTR1
0425EE             1366*  
0425EE             1367*  ; RESTORE [line]
0425EE             1368*  ;
0425EE 2A 14 05 04 1369*  RESTOR_EX:			LD      HL,(PAGE_)
0425F2 CD F1 29 04 1370*  			CALL    TERMQ
0425F6 28 0F       1371*  			JR      Z,RESTR1
0425F8 CD 6F 15 04 1372*  			CALL    ITEMI
0425FC D9          1373*  			EXX
0425FD CD 47 0F 04 1374*  			CALL    FINDL           ;SEARCH FOR LINE
042601 3E 29       1375*  			LD      A,41
042603 C2 7F 25 04 1376*  			JP      NZ,ERROR4       ;"No such line"
042607 3E DC       1377*  RESTR1:			LD      A,DATA_
042609 CD C5 2A 04 1378*  			CALL    SEARCH_EX
04260D 22 31 05 04 1379*  			LD      (DATPTR),HL
042611 C3 E3 1D 04 1380*  			JP      XEQ
042615             1381*  
042615             1382*  ; PTR#channel=expr
042615             1383*  ; PAGE=expr
042615             1384*  ; TIME=expr
042615             1385*  ; LOMEM=expr
042615             1386*  ; HIMEM=expr
042615             1387*  ;
042615 CD FD 2A 04 1388*  PTR_EX:			CALL    CHANEL
042619 CD 07 2A 04 1389*  			CALL    EQUALS
04261D 7B          1390*  			LD      A,E
04261E F5          1391*  			PUSH    AF
04261F CD 54 15 04 1392*  			CALL    EXPRI
042623 E5          1393*  			PUSH    HL
042624 D9          1394*  			EXX
042625 D1          1395*  			POP     DE
042626 F1          1396*  			POP     AF
042627 CD 98 4D 04 1397*  			CALL    PUTPTR
04262B C3 E3 1D 04 1398*  			JP      XEQ
04262F             1399*  ;
04262F CD 07 2A 04 1400*  PAGEV_EX:			CALL    EQUALS
042633 CD 54 15 04 1401*  			CALL    EXPRI
042637 D9          1402*  			EXX
042638 2E 00       1403*  			LD      L,0
04263A 22 14 05 04 1404*  			LD      (PAGE_),HL
04263E C3 E3 1D 04 1405*  			JP      XEQ
042642             1406*  ;
042642 FE 24       1407*  TIMEV_EX:			CP      '$'
042644 28 13       1408*  			JR      Z,TIMEVS_EX
042646 CD 07 2A 04 1409*  			CALL    EQUALS
04264A CD 54 15 04 1410*  			CALL    EXPRI
04264E E5          1411*  			PUSH    HL
04264F D9          1412*  			EXX
042650 D1          1413*  			POP     DE
042651 CD B7 48 04 1414*  			CALL    PUTIME
042655 C3 E3 1D 04 1415*  			JP      XEQ
042659             1416*  ;
042659 FD 23       1417*  TIMEVS_EX:			INC     IY              ;SKIP '$'
04265B CD 07 2A 04 1418*  			CALL    EQUALS
04265F CD 5F 15 04 1419*  			CALL    EXPRS
042663 CD E8 4D 04 1420*  			CALL    PUTIMS
042667 C3 E3 1D 04 1421*  			JP      XEQ
04266B             1422*  ;
04266B CD 07 2A 04 1423*  LOMEMV_EX:			CALL    EQUALS
04266F CD 54 15 04 1424*  			CALL    EXPRI
042673 CD 2E 0E 04 1425*  			CALL    CLEAR
042677 D9          1426*  			EXX
042678 22 1A 05 04 1427*  			LD      (LOMEM),HL
04267C 22 1D 05 04 1428*  			LD      (FREE),HL
042680 C3 E3 1D 04 1429*  			JP      XEQ
042684             1430*  ;
042684 CD 07 2A 04 1431*  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
042688 CD 54 15 04 1432*  			CALL    EXPRI			; Load the expression into registers
04268C 7D          1433*  			LD	A,L			;  A: The MSB of the 24-bit value
04268D D9          1434*  			EXX				; HL: The LSW of the 24-bit value
04268E 22 4A 05 04 1435*  			LD	(R0),HL
042692 32 4C 05 04 1436*  			LD	(R0+2),A
042696 2A 1D 05 04 1437*  			LD	HL,(FREE)
04269A 11 00 01 00 1438*  			LD      DE,256
04269E 19          1439*  			ADD	HL,DE
04269F EB          1440*  			EX	DE,HL			; DE: FREE + 256
0426A0 2A 4A 05 04 1441*  			LD	HL,(R0)			; HL: The passed expression
0426A4 AF          1442*  			XOR     A
0426A5 ED 52       1443*  			SBC     HL,DE
0426A7 19          1444*  			ADD     HL,DE			; Do a bounds check
0426A8 DA 18 0D 04 1445*  			JP      C,ERROR_         	; Throw the error: "No room"
0426AC ED 5B 20 05 1446*  			LD      DE,(HIMEM)
       04          
0426B1 22 20 05 04 1447*  			LD      (HIMEM),HL
0426B5 EB          1448*  			EX      DE,HL
0426B6 ED 72       1449*  			SBC     HL,SP			; Adjust the stack
0426B8 C2 E3 1D 04 1450*  			JP      NZ,XEQ
0426BC EB          1451*  			EX      DE,HL
0426BD F9          1452*  			LD      SP,HL           	; Load the SP
0426BE C3 E3 1D 04 1453*  			JP      XEQ
0426C2             1454*  
0426C2             1455*  ; WIDTH expr
0426C2             1456*  ;
0426C2 CD 54 15 04 1457*  WIDTHV:			CALL    EXPRI
0426C6 D9          1458*  			EXX
0426C7 7D          1459*  			LD      A,L
0426C8 32 3E 05 04 1460*  			LD      (WIDTH),A
0426CC C3 E3 1D 04 1461*  			JP      XEQ
0426D0             1462*  
0426D0             1463*  ; TRACE ON
0426D0             1464*  ; TRACE OFF
0426D0             1465*  ; TRACE line
0426D0             1466*  ;
0426D0 FD 23       1467*  TRACE_EX:			INC     IY
0426D2 21 00 00 00 1468*  			LD      HL,0
0426D6 FE EE       1469*  			CP      TON
0426D8 28 0B       1470*  			JR      Z,TRACE0
0426DA FE 87       1471*  			CP      OFF_
0426DC 28 08       1472*  			JR      Z,TRACE1
0426DE FD 2B       1473*  			DEC     IY
0426E0 CD 54 15 04 1474*  			CALL    EXPRI
0426E4 D9          1475*  			EXX
0426E5 2B          1476*  TRACE0:			DEC     HL
0426E6 22 26 05 04 1477*  TRACE1:			LD      (TRACEN),HL
0426EA C3 E3 1D 04 1478*  			JP      XEQ
0426EE             1479*  
0426EE             1480*  ; VDU expr,expr;....
0426EE             1481*  ;
0426EE DD 21 00 03 1482*  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0426F3 DD E5       1483*  VDU1:			PUSH	IX
0426F5 CD 54 15 04 1484*  			CALL    EXPRI			; Fetch the VDU character
0426F9 DD E1       1485*  			POP	IX
0426FB D9          1486*  			EXX
0426FC DD 75 00    1487*  			LD	(IX+0),L		; Write out the character to the buffer
0426FF DD 23       1488*  			INC	IX
042701 FD 7E 00    1489*  			LD      A,(IY)			;  A: The separator character
042704 FE 2C       1490*  			CP      ','			; Is it a comma?
042706 28 09       1491*  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
042708 FE 3B       1492*  			CP      ';'			; Is it a semicolon?
04270A 20 07       1493*  			JR      NZ,VDU3			; No, so skip to the next expression
04270C DD 74 00    1494*  			LD	(IX+0),H		; Write out the high byte to the buffer
04270F DD 23       1495*  			INC	IX
042711 FD 23       1496*  VDU2:			INC     IY			; Skip to the next character
042713 CD F1 29 04 1497*  VDU3:			CALL    TERMQ			; Skip past white space
042717 20 DA       1498*  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
042719 DD 7D       1499*  			LD	A,IXL			;  A: Number of bytes to write out
04271B B7          1500*  			OR	A
04271C 28 0B       1501*  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
04271E 21 00 03 04 1502*  			LD	HL,BUFFER		; HL: Start of stream
042722 01 00 00 00 1503*  			LD	BC,0
042726 4F          1504*  			LD	C,A			; BC: Number of bytes to write out
042727 5B DF       1505*  			RST.LIL	18h			; Output the buffer to MOS
042729 C3 E3 1D 04 1506*  VDU4:			JP      XEQ
04272D             1507*  
04272D             1508*  ; CLOSE channel number
04272D             1509*  ;
04272D CD FD 2A 04 1510*  CLOSE:			CALL    CHANEL			; Fetch the channel number
042731 CD 5C 4D 04 1511*  			CALL    OSSHUT			; Close the channel
042735 C3 E3 1D 04 1512*  			JP      XEQ
042739             1513*  
042739             1514*  ; BPUT channel,byte
042739             1515*  ;
042739 CD FD 2A 04 1516*  BPUT:			CALL    CHANEL          	; Fetch the channel number
04273D D5          1517*  			PUSH    DE			; DE: Channel number
04273E CD 6F 1C 04 1518*  			CALL    COMMA			; Skip to the next expression
042742 CD 54 15 04 1519*  			CALL    EXPRI           	; Feth the data
042746 D9          1520*  			EXX
042747 7D          1521*  			LD      A,L			; A: The byte to write
042748 D1          1522*  			POP     DE
042749 CD 6C 4D 04 1523*  			CALL    OSBPUT			; Write the byte out
04274D C3 E3 1D 04 1524*  			JP      XEQ
042751             1525*  
042751             1526*  ; CALL address[,var[,var...]]
042751             1527*  ;
042751             1528*  ; Note that the parameter table differs from the Z80 version
042751             1529*  ; Each entry now takes up 4 bytes, not 3, so the table is now:
042751             1530*  ;  -1 byte:  Number of parameters
042751             1531*  ; Then, for each parameter:
042751             1532*  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
042751             1533*  ;  -3 bytes: Parameter address
042751             1534*  ;
042751             1535*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
042751             1536*  ;
042751 CD 54 15 04 1537*  CALL_:			CALL    EXPRI           	; Fetch the address
042755 7D          1538*  			LD	A,L			;  A: MSB of address
042756 D9          1539*  			EXX
042757 22 4A 05 04 1540*  			LD	(R0+0),HL		; HL: LSW of address
04275B 32 4C 05 04 1541*  			LD	(R0+2),A
04275F 06 00       1542*  			LD      B,0             	;  B: The parameter counter
042761 11 00 03 04 1543*  			LD      DE,BUFFER       	; DE: Vector
042765             1544*  ;
042765 CD BD 1C 04 1545*  CALL1:			CALL    NXT			; Skip whitespace
042769 FE 2C       1546*  			CP      ','			; Check for comma
04276B 20 1B       1547*  			JR      NZ,CALL2		; If no more parameters, then jump here
04276D FD 23       1548*  			INC     IY			; Skip to the next character
04276F 04          1549*  			INC     B			; Increment the parameter count
042770 CD BD 1C 04 1550*  			CALL    NXT			; Skip whitespace
042774 C5          1551*  			PUSH    BC
042775 D5          1552*  			PUSH    DE
042776 CD DB 1E 04 1553*  			CALL    VAR_
04277A D1          1554*  			POP     DE
04277B C1          1555*  			POP     BC
04277C 13          1556*  			INC     DE
04277D 12          1557*  			LD      (DE),A			; Save the parameter type
04277E 13          1558*  			INC     DE
04277F EB          1559*  			EX      DE,HL
042780 ED 1F       1560*  			LD	(HL),DE			; Save the parameter address (3 bytes)
042782 23          1561*  			INC	HL
042783 23          1562*  			INC	HL
042784 23          1563*  			INC	HL
042785 EB          1564*  			EX      DE,HL
042786 18 DD       1565*  			JR      CALL1
042788             1566*  ;
042788 78          1567*  CALL2:			LD      A,B
042789 32 00 03 04 1568*  			LD      (BUFFER),A      	; Save the parameter count
04278D 2A 4A 05 04 1569*  			LD	HL,(R0)			; HL: Address of the code
042791 CD AB 27 04 1570*  			CALL    USR1			; And call it
042795 C3 E3 1D 04 1571*  			JP      XEQ
042799             1572*  
042799             1573*  ; USR(address)
042799             1574*  ;
042799 CD 6F 15 04 1575*  USR:			CALL    ITEMI			; Evaluate the expression
04279D 7D          1576*  			LD	A,L			;  A: MSB of address
04279E D9          1577*  			EXX
04279F 22 4A 05 04 1578*  			LD	(R0+0),HL		; HL: LSW of address
0427A3 32 4C 05 04 1579*  			LD	(R0+2),A
0427A7 2A 4A 05 04 1580*  			LD	HL,(R0)			; Get the 24-bit address in HL
0427AB             1581*  ;
0427AB E5          1582*  USR1:			PUSH    HL              	; Address on stack
0427AC FD E3       1583*  			EX      (SP),IY
0427AE 24          1584*  			INC     H               	; Check for PAGE &00FFxx
0427AF B4          1585*  			OR	H
0427B0 21 1A 28 04 1586*  			LD      HL,USR2         	; Return address
0427B4 E5          1587*  			PUSH    HL
0427B5 DD 21 00 04 1588*  			LD      IX,STAVAR
       04          
0427BA CC 22 4D 04 1589*  			CALL    Z,OSCALL        	; Intercept &00FFxx
0427BE             1590*  ;
0427BE DD 4E 18    1591*  			LD      C, (IX+24)		; F%
0427C1 C5          1592*  			PUSH    BC
0427C2             1593*  ;
0427C2 DD 7E 08    1594*  			LD	A, (IX+8)		; B% -> MSW
0427C5 32 4B 05 04 1595*  			LD	(R0+1), A
0427C9 DD 7E 09    1596*  			LD	A, (IX+9)
0427CC 32 4C 05 04 1597*  			LD	(R0+2), A
0427D0 DD 7E 0C    1598*  			LD	A, (IX+12)		; C% -> LSB
0427D3 32 4A 05 04 1599*  			LD	(R0+0), A
0427D7 ED 4B 4A 05 1600*  			LD	BC, (R0)
       04          
0427DC             1601*  ;
0427DC DD 7E 10    1602*  			LD	A, (IX+16)		; D% -> MSW
0427DF 32 4B 05 04 1603*  			LD	(R0+1), A
0427E3 DD 7E 11    1604*  			LD	A, (IX+17)
0427E6 32 4C 05 04 1605*  			LD	(R0+2), A
0427EA DD 7E 14    1606*  			LD	A, (IX+20)		; E% -> LSB
0427ED 32 4A 05 04 1607*  			LD	(R0+0), A
0427F1 ED 5B 4A 05 1608*  			LD	DE, (R0)
       04          
0427F6             1609*  ;
0427F6 DD 7E 20    1610*  			LD	A, (IX+32)		; H% -> MSW
0427F9 32 4B 05 04 1611*  			LD	(R0+1), A
0427FD DD 7E 21    1612*  			LD	A, (IX+33)
042800 32 4C 05 04 1613*  			LD	(R0+2), A
042804 DD 7E 30    1614*  			LD	A, (IX+48)		; L% -> LSB
042807 32 4A 05 04 1615*  			LD	(R0+0), A
04280B 2A 4A 05 04 1616*  			LD	HL, (R0)
04280F             1617*  ;
04280F F1          1618*  			POP     AF			; F%
042810 DD 7E 04    1619*  			LD      A, (IX+4)        	; A%
042813             1620*  
042813 DD 21 00 03 1621*  			LD      IX,BUFFER
       04          
042818 FD E9       1622*  			JP      (IY)            	; Off to user routine
04281A             1623*  ;
04281A FD E1       1624*  USR2:			POP     IY
04281C AF          1625*  			XOR     A
04281D 4F          1626*  			LD      C,A
04281E C9          1627*  			RET
04281F             1628*  
04281F             1629*  ; PUT port,data
04281F             1630*  ;
04281F CD 54 15 04 1631*  PUT:			CALL    EXPRI           ;PORT ADDRESS
042823 D9          1632*  			EXX
042824 E5          1633*  			PUSH    HL
042825 CD 6F 1C 04 1634*  			CALL    COMMA
042829 CD 54 15 04 1635*  			CALL    EXPRI           ;DATA
04282D D9          1636*  			EXX
04282E C1          1637*  			POP     BC
04282F ED 69       1638*  			OUT     (C),L           ;OUTPUT TO PORT BC
042831 C3 E3 1D 04 1639*  			JP      XEQ
042835             1640*  
042835             1641*  ; SUBROUTINES -----------------------------------------------------------------
042835             1642*  
042835             1643*  ; ASSIGN - Assign a numeric value to a variable.
042835             1644*  ; Outputs: NC,  Z - OK, numeric.
042835             1645*  ;          NC, NZ - OK, string.
042835             1646*  ;           C, NZ - illegal
042835             1647*  ;
042835 CD F2 0F 04 1648*  ASSIGN:			CALL    GETVAR          	; Try to get the variable
042839 D8          1649*  			RET     C               	; Return with C if it is an illegal variable
04283A C4 E1 0F 04 1650*  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
04283E B7          1651*  			OR      A
04283F F8          1652*  			RET     M               	; Return if type is string (81h)
042840 F5          1653*  			PUSH    AF              	; It's a numeric type from this point on
042841 CD 07 2A 04 1654*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
042845 E5          1655*  			PUSH    HL
042846 CD 4C 15 04 1656*  			CALL    EXPRN
04284A DD E1       1657*  			POP     IX
04284C F1          1658*  			POP     AF
04284D CB 47       1659*  STORE:			BIT     0,A
04284F 28 13       1660*  			JR      Z,STOREI
042851 BF          1661*  			CP      A               	; Set the variable to 0
042852 DD 71 04    1662*  STORE5:			LD      (IX+4),C
042855 D9          1663*  STORE4:			EXX
042856 DD 75 00    1664*  			LD      (IX+0),L
042859 DD 74 01    1665*  			LD      (IX+1),H
04285C D9          1666*  			EXX
04285D DD 75 02    1667*  			LD      (IX+2),L
042860 DD 74 03    1668*  			LD      (IX+3),H
042863 C9          1669*  			RET
042864 F5          1670*  STOREI:			PUSH    AF
042865 0C          1671*  			INC     C               ;SPEED - & PRESERVE F'
042866 0D          1672*  			DEC     C               ; WHEN CALLED BY FNEND0
042867 C4 AC 18 04 1673*  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
04286B F1          1674*  			POP     AF
04286C FE 04       1675*  			CP      4
04286E 28 E5       1676*  			JR      Z,STORE4
042870 BF          1677*  			CP      A               ;SET ZERO
042871 D9          1678*  STORE1:			EXX
042872 DD 75 00    1679*  			LD      (IX+0),L
042875 D9          1680*  			EXX
042876 C9          1681*  			RET
042877             1682*  ;
042877             1683*  ; Copy a string from the string accumulator to variable storage on the stack
042877             1684*  ; Parameters:
042877             1685*  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
042877             1686*  ; - IX: Address of the variable storage on the stack
042877             1687*  ;
042877 21 00 02 04 1688*  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
04287B             1689*  ;
04287B             1690*  ; Parameters:
04287B             1691*  ; As above, but:
04287B             1692*  ; - HL: Address of the string to be stored
04287B             1693*  ; -  E: The string length
04287B             1694*  ; NB:
04287B             1695*  ; Strings are mutable
04287B             1696*  ; Strings are stored in the following format in the variable:
04287B             1697*  ; - Address of the next variable (3 bytes)
04287B             1698*  ; - The rest of the variable name - this is zero terminated
04287B             1699*  ; - Current string length (byte)
04287B             1700*  ; - Maximum (original) string length (byte)
04287B             1701*  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
04287B             1702*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
04287B             1703*  ;
04287B 1F          1704*  STORES:			RRA				; Rotate right to shift bit 0 into carry
04287C 30 5D       1705*  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
04287E E5          1706*  			PUSH    HL			; Stack ACCS
04287F             1707*  ;
04287F             1708*  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
04287F             1709*  ;
04287F D9          1710*  			EXX				; This block was a call to LOAD4
042880 DD 6E 00    1711*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
042883 DD 66 01    1712*  			LD      H,(IX+1)		; The maximum original string length
042886 D9          1713*  			EXX
042887 DD 27 02    1714*  			LD	HL,(IX+2)		; Address of the string (24-bit)
04288A             1715*  ;
04288A 7B          1716*  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
04288B D9          1717*  			EXX
04288C 6F          1718*  			LD      L,A			; L': Length of string currently stored on the stack
04288D 7C          1719*  			LD      A,H             	; H': The maximum (original) string length
04288E D9          1720*  			EXX
04288F BB          1721*  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
042890 30 17       1722*  			JR      NC,STORS1       	; Yes there is, so skip the next bit
042892             1723*  ;
042892             1724*  ; At this point we're either initialising a new string or assigning more memory to an existing string
042892             1725*  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
042892             1726*  ; then the existing and new strings may both exist in memory.
042892             1727*  ;
042892 D9          1728*  			EXX
042893 65          1729*  			LD      H,L			; H: Set the maximum string length to the string length
042894 D9          1730*  			EXX
042895 E5          1731*  			PUSH    HL
042896 01 00 00 00 1732*  			LD	BC, 0
04289A 4F          1733*  			LD      C,A			; BC: The maximum (original) string length
04289B 09          1734*  			ADD     HL,BC			; Work out whether this is the last string in memory
04289C ED 4B 1D 05 1735*  			LD      BC,(FREE)
       04          
0428A1 ED 42       1736*  			SBC     HL,BC			; Is string last?
0428A3 E1          1737*  			POP     HL
0428A4 37          1738*  			SCF
0428A5 28 02       1739*  			JR      Z,STORS1
0428A7             1740*  			; LD	HL, BC			; HL=BC
0428A7 C5          1741*  			push bc
0428A8 E1          1742*  			pop hl
0428A9             1743*  ;
0428A9             1744*  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
0428A9             1745*  ; - H': The maximum (original) string length
0428A9             1746*  ; - L': The actual string length (must be less than H')
0428A9             1747*  ; - HL: Address of the string in memory
0428A9             1748*  ;
0428A9 D9          1749*  STORS1:			EXX				; This block was a call to STORE4
0428AA DD 75 00    1750*  			LD      (IX+0),L		; The actual string length (must be less then H')
0428AD DD 74 01    1751*  			LD      (IX+1),H		; The maximum (original) string length
0428B0 D9          1752*  			EXX
0428B1 DD 2F 02    1753*  			LD	(IX+2),HL		; The pointer to the original string
0428B4             1754*  ;
0428B4 01 00 00 00 1755*  			LD	BC, 0
0428B8 4B          1756*  			LD      C,E			; BC: The new string length
0428B9 EB          1757*  			EX      DE,HL
0428BA E1          1758*  			POP     HL
0428BB 0D          1759*  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
0428BC 0C          1760*  			INC     C			; check whether BC is 0 without affecting the carry flag
0428BD C8          1761*  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
0428BE ED B0       1762*  			LDIR				; Replace the string in memory
0428C0 D0          1763*  			RET     NC
0428C1 ED 53 1D 05 1764*  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
0428C6             1765*  ;
0428C6             1766*  ; Check whether the stack is full
0428C6             1767*  ;
0428C6 E5          1768*  CHECK:			PUSH    HL
0428C7 C5          1769*  			PUSH	BC
0428C8 2A 1D 05 04 1770*  			LD      HL,(FREE)		; HL: Address of first free space byte
0428CC 01 00 01 00 1771*  			LD	BC,100h			; BC: One page of memory
0428D0 09          1772*  			ADD	HL,BC			; Add a page to FREE
0428D1 ED 72       1773*  			SBC     HL,SP			; And subtract the current SP
0428D3 C1          1774*  			POP	BC
0428D4 E1          1775*  			POP     HL
0428D5 D8          1776*  			RET     C			; The SP is not in the same page, so just return
0428D6 AF          1777*  			XOR     A			; Otherwise
0428D7 C3 18 0D 04 1778*  			JP      ERROR_			; Throw error "No room"
0428DB             1779*  ;
0428DB 01 00 00 00 1780*  STORS3:			LD	BC,0
0428DF 4B          1781*  			LD      C,E			; BC: String length
0428E0 DD E5       1782*  			PUSH    IX
0428E2 D1          1783*  			POP     DE			; DE: Destination
0428E3 AF          1784*  			XOR     A			; Check if string length is 0
0428E4 B9          1785*  			CP      C
0428E5 28 02       1786*  			JR      Z,STORS5		; Yes, so don't copy
0428E7 ED B0       1787*  			LDIR
0428E9 3E 0D       1788*  STORS5:			LD      A,CR			; Finally add the terminator
0428EB 12          1789*  			LD      (DE),A
0428EC C9          1790*  			RET
0428ED             1791*  
0428ED             1792*  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0428ED             1793*  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0428ED             1794*  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0428ED             1795*  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0428ED             1796*  ;    Inputs: DE addresses parameter list
0428ED             1797*  ;            IY addresses dummy variable list
0428ED             1798*  ;   Outputs: DE,IY updated
0428ED             1799*  ;  Destroys: Everything
0428ED             1800*  ;
0428ED 3E FF       1801*  ARGUE:			LD      A,-1
0428EF F5          1802*  			PUSH    AF              	; Put marker on the stack
0428F0 FD 23       1803*  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0428F2 13          1804*  			INC     DE
0428F3 D5          1805*  			PUSH    DE
0428F4 CD BD 1C 04 1806*  			CALL    NXT			; Skip any whitespace
0428F8 CD F2 0F 04 1807*  			CALL    GETVAR			; Get the location of the variable in HL/IX
0428FC 38 3F       1808*  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0428FE C4 E1 0F 04 1809*  			CALL    NZ,PUTVAR
042902 D1          1810*  			POP     DE
042903 E5          1811*  			PUSH    HL              	; VARPTR
042904 B7          1812*  			OR      A               	; Check the variable type
042905 F5          1813*  			PUSH    AF
042906 D5          1814*  			PUSH    DE
042907 FD E3       1815*  			EX      (SP),IY
042909 FA 21 29 04 1816*  			JP      M,ARGUE2        	; Jump here if it is a string
04290D             1817*  ;
04290D CD 4C 15 04 1818*  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
042911 FD E3       1819*  			EX      (SP),IY
042913 D1          1820*  			POP     DE
042914 F1          1821*  			POP     AF
042915 D9          1822*  			EXX
042916 E5          1823*  			PUSH    HL
042917 D9          1824*  			EXX
042918 E5          1825*  			PUSH    HL
042919 47          1826*  			LD      B,A
04291A C5          1827*  			PUSH    BC
04291B CD C6 28 04 1828*  			CALL    CHECK           	; Check room
04291F 18 0F       1829*  			JR      ARGUE4
042921             1830*  ;
042921 CD 5F 15 04 1831*  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
042925 FD E3       1832*  			EX      (SP),IY
042927 D9          1833*  			EXX
042928 D1          1834*  			POP     DE
042929 D9          1835*  			EXX
04292A F1          1836*  			POP     AF
04292B CD FE 1B 04 1837*  			CALL    PUSHS
04292F D9          1838*  			EXX
042930             1839*  ;
042930 CD BD 1C 04 1840*  ARGUE4:			CALL    NXT			; Skip whitespace
042934 FE 2C       1841*  			CP      ','			; Check to see if the next value is a comma
042936 20 0B       1842*  			JR      NZ,ARGUE5		; No, so jump here
042938 1A          1843*  			LD      A,(DE)
042939 FE 2C       1844*  			CP      ','			; Are there any more arguments?
04293B 28 B3       1845*  			JR      Z,ARGUE1        	; Yes, so loop
04293D             1846*  ;
04293D 3E 1F       1847*  ARGERR:			LD      A,31
04293F C3 18 0D 04 1848*  			JP      ERROR_           	; Throw error "Arguments"
042943             1849*  ;
042943 CD 7C 1C 04 1850*  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
042947 1A          1851*  			LD      A,(DE)
042948 FE 29       1852*  			CP      ')'
04294A 20 F1       1853*  			JR      NZ,ARGERR
04294C 13          1854*  			INC     DE
04294D D9          1855*  			EXX
04294E C1          1856*  ARGUE6:			POP     BC
04294F 78          1857*  			LD      A,B
042950 3C          1858*  			INC     A
042951 D9          1859*  			EXX
042952 C8          1860*  			RET     Z               	; Marker popped
042953 D9          1861*  			EXX
042954 3D          1862*  			DEC     A
042955 FA 65 29 04 1863*  			JP      M,ARGUE7        	; If it is a string, then jump here
042959 E1          1864*  			POP     HL
04295A D9          1865*  			EXX
04295B E1          1866*  			POP     HL
04295C D9          1867*  			EXX
04295D DD E1       1868*  			POP     IX
04295F CD 4D 28 04 1869*  			CALL    STORE	           	; Write to dummy variable
042963 18 E9       1870*  			JR      ARGUE6
042965             1871*  ;
042965 CD 2B 1C 04 1872*  ARGUE7:			CALL    POPS
042969 DD E1       1873*  			POP     IX
04296B CD 77 28 04 1874*  			CALL    STACCS
04296F 18 DD       1875*  			JR      ARGUE6
042971             1876*  
042971             1877*  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
042971             1878*  ;   OF A FUNCTION OR PROCEDURE.
042971             1879*  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
042971             1880*  ;    Inputs: IY is parameters pointer
042971             1881*  ;   Outputs: IY updated
042971             1882*  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
042971             1883*  ;
042971 D1          1884*  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
042972             1885*  ;
042972 FD 23       1886*  SAVLO1:			INC     IY              	; Bump past '(' or ','
042974 CD BD 1C 04 1887*  			CALL    NXT			; And also any whitespace
042978 D5          1888*  			PUSH    DE			; Push the return address back onto the stack
042979 D9          1889*  			EXX
04297A C5          1890*  			PUSH    BC
04297B D5          1891*  			PUSH    DE
04297C E5          1892*  			PUSH    HL
04297D D9          1893*  			EXX
04297E CD DB 1E 04 1894*  			CALL    VAR_             	; Dummy variable
042982 D9          1895*  			EXX
042983 E1          1896*  			POP     HL
042984 D1          1897*  			POP     DE
042985 C1          1898*  			POP     BC
042986 D9          1899*  			EXX
042987 D1          1900*  			POP     DE
042988 B7          1901*  			OR      A               	; Check the variable type
042989 FA 9C 29 04 1902*  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
04298D D9          1903*  			EXX
04298E E5          1904*  			PUSH    HL              	; Save H'L'
04298F D9          1905*  			EXX
042990 47          1906*  			LD      B,A             	;  B: Variable type
042991 CD 60 16 04 1907*  			CALL    LOADN
042995 D9          1908*  			EXX
042996 E3          1909*  			EX      (SP),HL
042997 D9          1910*  			EXX
042998 E5          1911*  			PUSH    HL
042999 C5          1912*  			PUSH    BC
04299A 18 2D       1913*  			JR      SAVLO4
04299C             1914*  ;
04299C F5          1915*  SAVLO2:			PUSH    AF              	; Save the type (string)
04299D D5          1916*  			PUSH    DE
04299E D9          1917*  			EXX
04299F E5          1918*  			PUSH    HL
0429A0 D9          1919*  			EXX
0429A1 CD EA 16 04 1920*  			CALL    LOADS
0429A5 D9          1921*  			EXX
0429A6 E1          1922*  			POP     HL
0429A7 D9          1923*  			EXX
0429A8 01 00 00 00 1924*  			LD	BC,0
0429AC 4B          1925*  			LD      C,E			; BC: String length
0429AD D1          1926*  			POP     DE
0429AE CD C6 28 04 1927*  			CALL    CHECK			; Check if there is space on the stack
0429B2 F1          1928*  			POP     AF              	; Level stack
0429B3 21 00 00 00 1929*  			LD      HL,0
0429B7 ED 42       1930*  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0429B9 39          1931*  			ADD     HL,SP			; Make space for the string on the stack
0429BA F9          1932*  			LD      SP,HL
0429BB 47          1933*  			LD      B,A             	;  B: Variable type
0429BC C5          1934*  			PUSH    BC
0429BD 28 0A       1935*  			JR      Z,SAVLO4
0429BF D5          1936*  			PUSH    DE
0429C0 11 00 02 04 1937*  			LD      DE,ACCS
0429C4 EB          1938*  			EX      DE,HL
0429C5 45          1939*  			LD      B,L
0429C6 ED B0       1940*  			LDIR                    	; Save the string onto the stack
0429C8 D1          1941*  			POP     DE
0429C9             1942*  ;
0429C9 DD E5       1943*  SAVLO4:			PUSH    IX			; VARPTR
0429CB CD CF 29 04 1944*  			CALL    SAVLO5
0429CF             1945*  LOCCHK:			EQU     $
0429CF CD C6 28 04 1946*  SAVLO5:			CALL    CHECK
0429D3 CD BD 1C 04 1947*  			CALL    NXT
0429D7 FE 2C       1948*  			CP      ','             	; Are there any more local variables?
0429D9 28 97       1949*  			JR      Z,SAVLO1		; Yes, so loop
0429DB EB          1950*  			EX      DE,HL			; DE -> HL: The return address
0429DC E9          1951*  			JP      (HL)            	; And effectvely return
0429DD             1952*  ;
0429DD FD 7E 00    1953*  DELIM:			LD      A,(IY)          	; Assembler delimiter
0429E0 FE 20       1954*  			CP      ' '
0429E2 C8          1955*  			RET     Z
0429E3 FE 2C       1956*  			CP      ','
0429E5 C8          1957*  			RET     Z
0429E6 FE 29       1958*  			CP      ')'
0429E8 C8          1959*  			RET     Z
0429E9 FE 3B       1960*  TERM:			CP      ';'             	; Assembler terminator
0429EB C8          1961*  			RET     Z
0429EC FE 5C       1962*  			CP      '\'
0429EE C8          1963*  			RET     Z
0429EF 18 07       1964*  			JR      TERM0
0429F1             1965*  ;
0429F1 CD BD 1C 04 1966*  TERMQ:			CALL    NXT
0429F5 FE 8B       1967*  			CP      ELSE_
0429F7 D0          1968*  			RET     NC
0429F8 FE 3A       1969*  TERM0:			CP      ':'             	; Assembler seperator
0429FA D0          1970*  			RET     NC
0429FB FE 0D       1971*  			CP      CR
0429FD C9          1972*  			RET
0429FE             1973*  ;
0429FE CD F1 29 04 1974*  SPAN:			CALL    TERMQ
042A02 C8          1975*  			RET     Z
042A03 FD 23       1976*  			INC     IY
042A05 18 F7       1977*  			JR      SPAN
042A07             1978*  ;
042A07             1979*  ; This snippet is used to check whether an expression is followed by an '=' symbol
042A07             1980*  ;
042A07 CD BD 1C 04 1981*  EQUALS:			CALL    NXT			; Skip whitespace
042A0B FD 23       1982*  			INC     IY			; Skip past the character in question
042A0D FE 3D       1983*  			CP      '='			; Is it '='
042A0F C8          1984*  			RET     Z			; Yes, so return
042A10 3E 04       1985*  			LD      A,4			; Otherwise
042A12 C3 18 0D 04 1986*  			JP      ERROR_           	; Throw error "Mistake"
042A16             1987*  ;
042A16 FE 8A       1988*  FORMAT:			CP      TAB
042A18 28 0D       1989*  			JR      Z,DOTAB
042A1A FE 89       1990*  			CP      SPC
042A1C 28 40       1991*  			JR      Z,DOSPC
042A1E FE 27       1992*  			CP      '''
042A20 C0          1993*  			RET     NZ
042A21 CD FF 0E 04 1994*  			CALL    CRLF
042A25 AF          1995*  			XOR     A
042A26 C9          1996*  			RET
042A27             1997*  ;
042A27 C5          1998*  DOTAB:			PUSH    BC
042A28 CD 54 15 04 1999*  			CALL    EXPRI
042A2C D9          2000*  			EXX
042A2D C1          2001*  			POP     BC
042A2E FD 7E 00    2002*  			LD      A,(IY)
042A31 FE 2C       2003*  			CP      ','
042A33 28 14       2004*  			JR      Z,DOTAB1
042A35 CD 7C 1C 04 2005*  			CALL    BRAKET
042A39 7D          2006*  			LD      A,L
042A3A 21 3D 05 04 2007*  TABIT:			LD      HL,COUNT
042A3E BE          2008*  			CP      (HL)
042A3F C8          2009*  			RET     Z
042A40 F5          2010*  			PUSH    AF
042A41 DC FF 0E 04 2011*  			CALL    C,CRLF
042A45 F1          2012*  			POP     AF
042A46 96          2013*  			SUB     (HL)
042A47 18 1D       2014*  			JR      FILL
042A49 FD 23       2015*  DOTAB1:			INC     IY
042A4B C5          2016*  			PUSH    BC
042A4C E5          2017*  			PUSH    HL
042A4D CD 54 15 04 2018*  			CALL    EXPRI
042A51 D9          2019*  			EXX
042A52 D1          2020*  			POP     DE
042A53 C1          2021*  			POP     BC
042A54 CD 7C 1C 04 2022*  			CALL    BRAKET
042A58 CD E1 48 04 2023*  			CALL    PUTCSR
042A5C AF          2024*  			XOR     A
042A5D C9          2025*  			RET
042A5E             2026*  ;
042A5E C5          2027*  DOSPC:			PUSH    BC
042A5F CD 6F 15 04 2028*  			CALL    ITEMI
042A63 D9          2029*  			EXX
042A64 7D          2030*  			LD      A,L
042A65 C1          2031*  			POP     BC
042A66 B7          2032*  FILL:			OR      A
042A67 C8          2033*  			RET     Z
042A68 C5          2034*  			PUSH    BC
042A69 47          2035*  			LD      B,A
042A6A 3E 20       2036*  FILL1:			LD      A,' '
042A6C CD 07 0F 04 2037*  			CALL    OUTCHR
042A70 10 F8       2038*  			DJNZ    FILL1
042A72 C1          2039*  			POP     BC
042A73 AF          2040*  			XOR     A
042A74 C9          2041*  			RET
042A75             2042*  ;
042A75 21 00 02 04 2043*  PTEXT:			LD      HL,ACCS
042A79 1C          2044*  			INC     E
042A7A 1D          2045*  PTEXT1:			DEC     E
042A7B C8          2046*  			RET     Z
042A7C 7E          2047*  			LD      A,(HL)
042A7D 23          2048*  			INC     HL
042A7E CD 07 0F 04 2049*  			CALL    OUTCHR
042A82 18 F6       2050*  			JR      PTEXT1
042A84             2051*  ;
042A84 F5          2052*  FETCHS:			PUSH    AF
042A85 C5          2053*  			PUSH    BC
042A86 E5          2054*  			PUSH    HL
042A87 FD E3       2055*  			EX      (SP),IY
042A89 CD A4 2A 04 2056*  			CALL    XTRACT
042A8D CD BD 1C 04 2057*  			CALL    NXT
042A91 FD E3       2058*  			EX      (SP),IY
042A93 E1          2059*  			POP     HL
042A94 C1          2060*  			POP     BC
042A95 F1          2061*  			POP     AF
042A96 C9          2062*  			RET
042A97             2063*  ;
042A97 11 00 02 04 2064*  LINES:			LD      DE,ACCS
042A9B 7E          2065*  LINE1S:			LD      A,(HL)
042A9C 12          2066*  			LD      (DE),A
042A9D FE 0D       2067*  			CP      CR
042A9F C8          2068*  			RET     Z
042AA0 23          2069*  			INC     HL
042AA1 1C          2070*  			INC     E
042AA2 18 F7       2071*  			JR      LINE1S
042AA4             2072*  ;
042AA4 CD BD 1C 04 2073*  XTRACT:			CALL    NXT
042AA8 FE 22       2074*  			CP      '"'
042AAA FD 23       2075*  			INC     IY
042AAC CA B1 16 04 2076*  			JP      Z,CONS
042AB0 FD 2B       2077*  			DEC     IY
042AB2 11 00 02 04 2078*  			LD      DE,ACCS
042AB6 FD 7E 00    2079*  XTRAC1:			LD      A,(IY)
042AB9 12          2080*  			LD      (DE),A
042ABA FE 2C       2081*  			CP      ','
042ABC C8          2082*  			RET     Z
042ABD FE 0D       2083*  			CP      CR
042ABF C8          2084*  			RET     Z
042AC0 FD 23       2085*  			INC     IY
042AC2 1C          2086*  			INC     E
042AC3 18 F1       2087*  			JR      XTRAC1
042AC5             2088*  
042AC5             2089*  ; Search for a token at the start of a program line
042AC5             2090*  ; - HL: Pointer to the start of a tokenised line in the program area
042AC5             2091*  ; Returns:
042AC5             2092*  ; - HL: Pointer to the
042AC5             2093*  ; -  F: Carry set if not found
042AC5             2094*  ; Corrupts:
042AC5             2095*  ; - BC
042AC5             2096*  ;
042AC5 01 00 00 00 2097*  SEARCH_EX:			LD      BC,0			; Clear BC
042AC9             2098*  ;
042AC9 4E          2099*  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
042ACA 0C          2100*  			INC     C			; Check for 0, i.e. end of program marker
042ACB 0D          2101*  			DEC     C
042ACC 28 0B       2102*  			JR      Z,SRCH2_EX         	; Not found the token, so end
042ACE 23          2103*  			INC     HL			; Skip the line length and line number
042ACF 23          2104*  			INC     HL
042AD0 23          2105*  			INC     HL
042AD1 BE          2106*  			CP      (HL)			; Compare with the token
042AD2 C8          2107*  			RET     Z			; Found it, so return with carry not set
042AD3 0D          2108*  			DEC     C			; Skip to the next line
042AD4 0D          2109*  			DEC     C
042AD5 0D          2110*  			DEC     C
042AD6 09          2111*  			ADD     HL,BC
042AD7 18 F0       2112*  			JR      SRCH1_EX			; Rinse, lather and repeat
042AD9             2113*  ;
042AD9 2B          2114*  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
042ADA 37          2115*  			SCF				; And set the carry flag
042ADB C9          2116*  			RET
042ADC             2117*  
042ADC             2118*  ; Multiply by 4 or 5
042ADC             2119*  ; This function is used to allocate space for dimensioned variables
042ADC             2120*  ; This is a 24-bit operation
042ADC             2121*  ; - DE: Number to multiple
042ADC             2122*  ; -  A: 04h (Integer) - takes up 4 bytes
042ADC             2123*  ;       05h (Float)   - takes up 5 bytes
042ADC             2124*  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
042ADC             2125*  ; Returns:
042ADC             2126*  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
042ADC             2127*  ; -  F: Carry if overflow
042ADC             2128*  ; Corrupts:
042ADC             2129*  ; - HL
042ADC FE 04       2130*  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
042ADE             2131*  			; LD	HL,DE
042ADE D5          2132*  			push de
042ADF E1          2133*  			pop hl
042AE0 29          2134*  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
042AE1 D8          2135*  			RET     C			; Exit if overflow
042AE2 29          2136*  			ADD     HL,HL			; Multiply by 2 again
042AE3 D8          2137*  			RET     C			; Exit if overflow
042AE4 EB          2138*  			EX      DE,HL			; DE: Product
042AE5 C8          2139*  			RET     Z			; Exit if A = 4
042AE6 19          2140*  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
042AE7 EB          2141*  			EX      DE,HL			; DE: Product
042AE8 C9          2142*  			RET
042AE9             2143*  
042AE9             2144*  ; 16-bit unsigned multiply
042AE9             2145*  ; - HL: Operand 1
042AE9             2146*  ; - BC: Operand 2
042AE9             2147*  ; Returns:
042AE9             2148*  ; - HL: Result
042AE9             2149*  ; -  F: C if overflow
042AE9             2150*  ;
042AE9 C5          2151*  MUL16:			PUSH	BC
042AEA 51          2152*  			LD	D, C			; Set up the registers for the multiplies
042AEB 5D          2153*  			LD	E, L
042AEC 69          2154*  			LD	L, C
042AED 4B          2155*  			LD	C, E
042AEE ED 6C       2156*  			MLT	HL			; HL = H * C (*256)
042AF0 ED 5C       2157*  			MLT	DE			; DE = L * C
042AF2 ED 4C       2158*  			MLT	BC			; BC = B * L (*256)
042AF4 09          2159*  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
042AF5 C1          2160*  			POP	BC
042AF6 AF          2161*  			XOR	A
042AF7 9C          2162*  			SBC	H			; If H is not zero then it's an overflow
042AF8 D8          2163*  			RET	C
042AF9 65          2164*  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
042AFA 6F          2165*  			LD	L, A
042AFB 19          2166*  			ADD	HL, DE
042AFC C9          2167*  			RET
042AFD             2168*  ;
042AFD CD BD 1C 04 2169*  CHANEL:			CALL    NXT			; Skip whitespace
042B01 FE 23       2170*  			CP      '#'			; Check for the '#' symbol
042B03 3E 2D       2171*  			LD      A,45
042B05 C2 18 0D 04 2172*  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
042B09 FD 23       2173*  CHNL:			INC     IY             		; Bump past the '#'
042B0B CD 6F 15 04 2174*  			CALL    ITEMI			; Get the channel number
042B0F D9          2175*  			EXX
042B10 EB          2176*  			EX      DE,HL			; DE: The channel number
042B11 C9          2177*  			RET
042B12             2178*  
042B12             2179*  ; ASSEMBLER -------------------------------------------------------------------
042B12             2180*  
042B12             2181*  ; Language independant control section:
042B12             2182*  ;  Outputs: A=delimiter, carry set if syntax error.
042B12             2183*  ;
042B12 CD 32 30 04 2184*  ASSEM:			CALL    SKIP
042B16 FD 23       2185*  			INC     IY
042B18 FE 3A       2186*  			CP      ':'
042B1A 28 F6       2187*  			JR      Z,ASSEM
042B1C FE 5D       2188*  			CP      ']'
042B1E C8          2189*  			RET     Z
042B1F FE 0D       2190*  			CP      CR
042B21 C8          2191*  			RET     Z
042B22 FD 2B       2192*  			DEC     IY
042B24 DD 2A 40 10 2193*  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       10          
042B29 21 40 05 04 2194*  			LD      HL,LISTON
042B2D CB 76       2195*  			BIT     6,(HL)
042B2F 28 05       2196*  			JR      Z,ASSEM0
042B31 DD 2A 3C 10 2197*  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       10          
042B36 DD E5       2198*  ASSEM0:			PUSH    IX
042B38 FD E5       2199*  			PUSH    IY
042B3A CD EA 2B 04 2200*  			CALL    ASMB
042B3E C1          2201*  			POP     BC
042B3F D1          2202*  			POP     DE
042B40 D8          2203*  			RET     C
042B41 CD 32 30 04 2204*  			CALL    SKIP
042B45 37          2205*  			SCF
042B46 C0          2206*  			RET     NZ
042B47 FD 2B       2207*  			DEC     IY
042B49 FD 23       2208*  ASSEM3:			INC     IY
042B4B FD 7E 00    2209*  			LD      A,(IY)
042B4E CD F8 29 04 2210*  			CALL    TERM0
042B52 20 F5       2211*  			JR      NZ,ASSEM3
042B54 3A 40 05 04 2212*  			LD      A,(LISTON)
042B58 DD E5       2213*  			PUSH    IX
042B5A E1          2214*  			POP     HL
042B5B B7          2215*  			OR      A
042B5C ED 52       2216*  			SBC     HL,DE
042B5E EB          2217*  			EX      DE,HL           	; DE: Number of bytes
042B5F E5          2218*  			PUSH    HL
042B60 2A 40 10 10 2219*  			LD      HL,(PC)
042B64 E5          2220*  			PUSH    HL
042B65 19          2221*  			ADD     HL,DE
042B66 22 40 10 10 2222*  			LD      (PC),HL         	; Update PC
042B6A CB 77       2223*  			BIT     6,A
042B6C 28 09       2224*  			JR      Z,ASSEM5
042B6E 2A 3C 10 10 2225*  			LD      HL,(OC)
042B72 19          2226*  			ADD     HL,DE
042B73 22 3C 10 10 2227*  			LD      (OC),HL         	; Update OC
042B77 E1          2228*  ASSEM5:			POP     HL              	; Old PC
042B78 DD E1       2229*  			POP     IX              	; Code here
042B7A CB 67       2230*  			BIT     4,A
042B7C 28 94       2231*  			JR      Z,ASSEM
042B7E 22 4A 05 04 2232*  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
042B82 3A 4C 05 04 2233*  			LD	A,(R0+2)		; Print out the address
042B86 CD D4 2B 04 2234*  			CALL	HEX_EX
042B8A 7C          2235*  			LD      A,H
042B8B CD D4 2B 04 2236*  			CALL    HEX_EX
042B8F 7D          2237*  			LD      A,L
042B90 CD CC 2B 04 2238*  			CALL    HEXSP
042B94 AF          2239*  			XOR     A
042B95 BB          2240*  			CP      E
042B96 28 18       2241*  			JR      Z,ASSEM2
042B98             2242*  ;
042B98 3A 3D 05 04 2243*  ASSEM1:			LD      A,(COUNT)
042B9C FE 14       2244*  			CP      20
042B9E 3E 07       2245*  			LD      A,7
042BA0 D4 3A 2A 04 2246*  			CALL    NC,TABIT        	; Next line
042BA4 DD 7E 00    2247*  			LD      A,(IX)
042BA7 CD CC 2B 04 2248*  			CALL    HEXSP
042BAB DD 23       2249*  			INC     IX
042BAD 1D          2250*  			DEC     E
042BAE 20 E8       2251*  			JR      NZ,ASSEM1
042BB0             2252*  ;
042BB0 3E 16       2253*  ASSEM2:			LD      A,22			; Tab to the disassembly field
042BB2 CD 3A 2A 04 2254*  			CALL    TABIT
042BB6 FD E5       2255*  			PUSH    IY
042BB8 E1          2256*  			POP     HL
042BB9 ED 42       2257*  			SBC     HL,BC
042BBB 0A          2258*  ASSEM4:			LD      A,(BC)
042BBC CD 24 0F 04 2259*  			CALL    OUT_
042BC0 03          2260*  			INC     BC
042BC1 2D          2261*  			DEC     L
042BC2 20 F7       2262*  			JR      NZ,ASSEM4
042BC4 CD FF 0E 04 2263*  			CALL    CRLF
042BC8 C3 12 2B 04 2264*  			JP      ASSEM
042BCC             2265*  ;
042BCC CD D4 2B 04 2266*  HEXSP:			CALL    HEX_EX
042BD0 3E 20       2267*  			LD      A,' '
042BD2 18 12       2268*  			JR      OUTCH1
042BD4 F5          2269*  HEX_EX:			PUSH    AF
042BD5 0F          2270*  			RRCA
042BD6 0F          2271*  			RRCA
042BD7 0F          2272*  			RRCA
042BD8 0F          2273*  			RRCA
042BD9 CD DE 2B 04 2274*  			CALL    HEXOUT
042BDD F1          2275*  			POP     AF
042BDE E6 0F       2276*  HEXOUT:			AND     0FH
042BE0 C6 90       2277*  			ADD     A,90H
042BE2 27          2278*  			DAA
042BE3 CE 40       2279*  			ADC     A,40H
042BE5 27          2280*  			DAA
042BE6 C3 24 0F 04 2281*  OUTCH1:			JP      OUT_
042BEA             2282*  
042BEA             2283*  ; Processor Specific Translation Section:
042BEA             2284*  ;
042BEA             2285*  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
042BEA             2286*  ;                 C: Opcode beig built
042BEA             2287*  ;                 D: Flags
042BEA             2288*  ;			Bit 7: Set to 1 if the instruction uses long addressing
042BEA             2289*  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
042BEA             2290*  ;                 E: Offset from IX or IY
042BEA             2291*  ;                HL: Numeric operand value
042BEA             2292*  ;                IX: Code destination pointer
042BEA             2293*  ;                IY: Source text pointer
042BEA             2294*  ;    Inputs: A = initial character
042BEA             2295*  ;   Outputs: Carry set if syntax error.
042BEA             2296*  ;
042BEA FE 2E       2297*  ASMB:			CP      '.'			; Check for a dot; this indicates a label
042BEC 20 1F       2298*  			JR      NZ,ASMB1		; No, so just process the instruction
042BEE FD 23       2299*  			INC     IY			; Skip past the dot to the label name
042BF0 DD E5       2300*  			PUSH    IX			; Store the code destination pointer
042BF2 CD DB 1E 04 2301*  			CALL    VAR_			; Create a variable
042BF6 F5          2302*  			PUSH    AF
042BF7 CD DD 1B 04 2303*  			CALL    ZERO			; Zero it
042BFB 3A 42 10 10 2304*  			LD	A,(PC+2)
042BFF 6F          2305*  			LD	L,A			; The MSB of the 24-bit address
042C00 D9          2306*  			EXX
042C01 2A 40 10 10 2307*  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
042C05 D9          2308*  			EXX
042C06 F1          2309*  			POP     AF
042C07 CD 4D 28 04 2310*  			CALL    STORE			; Store the program counter
042C0B DD E1       2311*  			POP     IX			; Restore the code destination pointer
042C0D             2312*  ;
042C0D 3A 40 05 04 2313*  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
042C11 E6 80       2314*  			AND	80H
042C13 57          2315*  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
042C14 CD 32 30 04 2316*  			CALL    SKIP			; Skip any whitespace
042C18 C8          2317*  			RET     Z			; And return if there is nothing further to process
042C19 FE D6       2318*  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
042C1B 0E C4       2319*  			LD      C,0C4H			;  A: The base operand
042C1D FD 23       2320*  			INC     IY			; Skip past the token
042C1F CA 67 2D 04 2321*  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
042C23 FD 2B       2322*  			DEC     IY			; Skip back, as we're not doing the above at this point
042C25 21 49 30 04 2323*  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
042C29 CD E1 2F 04 2324*  			CALL    FIND			; Find the opcode
042C2D D8          2325*  			RET     C			; If not found, then return; carry indicates an error condition
042C2E 48          2326*  			LD      C,B     		;  C: A copy of the opcode
042C2F             2327*  ;
042C2F             2328*  ; GROUP 0: Trivial cases requiring no computation
042C2F             2329*  ; GROUP 1: As Group 0, but with "ED" prefix
042C2F             2330*  ;
042C2F D6 44       2331*  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
042C31 30 08       2332*  			JR      NC,GROUP02		; If not in that range, then check GROUP2
042C33 FE CB       2333*  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
042C35 D4 3A 2F 04 2334*  			CALL    NC,ED			; Needs to be prefixed with ED
042C39 18 76       2335*  			JR      BYTE0			; Then write the opcode byte
042C3B             2336*  ;
042C3B             2337*  ; GROUP 2: BIT, RES, SET
042C3B             2338*  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
042C3B             2339*  ;
042C3B D6 0A       2340*  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
042C3D 30 12       2341*  			JR      NC,GROUP04		; If not in that range, then check GROUP4
042C3F FE F9       2342*  			CP      3-10			;
042C41 DC CF 2F 04 2343*  			CALL    C,BIT_
042C45 D8          2344*  			RET     C
042C46 CD A0 2F 04 2345*  			CALL    REGLO
042C4A D8          2346*  			RET     C
042C4B CD 3E 2F 04 2347*  			CALL    CB
042C4F 18 60       2348*  			JR      BYTE0
042C51             2349*  ;
042C51             2350*  ; GROUP 4 - PUSH, POP, EX (SP)
042C51             2351*  ;
042C51 D6 03       2352*  GROUP04:		SUB     3			; The number of opcodes in GROUP4
042C53 30 07       2353*  			JR      NC,GROUP05		; If not in that range, then check GROUP5
042C55 CD C2 2F 04 2354*  GROUP04_1:		CALL    PAIR_EX
042C59 D8          2355*  			RET     C
042C5A 18 55       2356*  			JR      BYTE0
042C5C             2357*  ;
042C5C             2358*  ; GROUP 5 - SUB, AND, XOR, OR, CP
042C5C             2359*  ; GROUP 6 - ADD, ADC, SBC
042C5C             2360*  ;
042C5C D6 0A       2361*  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
042C5E 30 39       2362*  			JR      NC,GROUP07
042C60 FE FD       2363*  			CP      5-8
042C62 06 07       2364*  			LD      B,7
042C64 D4 4E 2F 04 2365*  			CALL    NC,OPND			; Get the first operand
042C68 78          2366*  			LD      A,B
042C69 FE 07       2367*  			CP      7			; Is the operand 'A'?
042C6B 20 15       2368*  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
042C6D             2369*  ;
042C6D CD A0 2F 04 2370*  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
042C71 79          2371*  			LD      A,C
042C72 30 2E       2372*  			JR      NC,BIND1		; If it is a register, then write that out
042C74 EE 46       2373*  			XOR     46H			; Handle ADD A,n
042C76 CD 40 2F 04 2374*  			CALL    BIND
042C7A CD 80 2F 04 2375*  DB_:			CALL    NUMBER
042C7E C3 39 2D 04 2376*  			JP      VAL8
042C82             2377*  ;
042C82 E6 3F       2378*  GROUP05_HL:		AND     3FH
042C84 FE 0C       2379*  			CP      12
042C86 37          2380*  			SCF
042C87 C0          2381*  			RET     NZ
042C88 79          2382*  			LD      A,C
042C89 FE 80       2383*  			CP      80H
042C8B 0E 09       2384*  			LD      C,9
042C8D 28 C6       2385*  			JR      Z,GROUP04_1
042C8F EE 1C       2386*  			XOR     1CH
042C91 0F          2387*  			RRCA
042C92 4F          2388*  			LD      C,A
042C93 CD 3A 2F 04 2389*  			CALL    ED
042C97 18 BC       2390*  			JR      GROUP04_1
042C99             2391*  ;
042C99             2392*  ; GROUP 7 - INC, DEC
042C99             2393*  ;
042C99 D6 02       2394*  GROUP07:		SUB     2			; The number of opcodes in GROUP7
042C9B 30 19       2395*  			JR      NC,GROUP08
042C9D CD A7 2F 04 2396*  			CALL    REGHI
042CA1 79          2397*  			LD      A,C
042CA2 D2 40 2F 04 2398*  BIND1:			JP      NC,BIND
042CA6 EE 64       2399*  			XOR     64H
042CA8 07          2400*  			RLCA
042CA9 07          2401*  			RLCA
042CAA 07          2402*  			RLCA
042CAB 4F          2403*  			LD      C,A
042CAC CD C7 2F 04 2404*  			CALL    PAIR1_EX
042CB0 D8          2405*  			RET     C
042CB1 79          2406*  BYTE0:			LD      A,C
042CB2 C3 6F 2F 04 2407*  			JP      BYTE_
042CB6             2408*  ;
042CB6             2409*  ; Group 8: IN0, OUT0
042CB6             2410*  ;
042CB6 D6 02       2411*  GROUP08:		SUB	2			; The number of opcodes in GROUP8
042CB8 30 2C       2412*  			JR	NC,GROUP09
042CBA FE FF       2413*  			CP	1-2
042CBC CC 80 2F 04 2414*  			CALL    Z,NUMBER		; Fetch number first if OUT
042CC0 08          2415*  			EX      AF,AF'			; Save flags
042CC1 CD 94 2F 04 2416*  			CALL    REG			; Get the register value regardless
042CC5 D8          2417*  			RET     C			; Return if not a register
042CC6 08          2418*  			EX      AF,AF'			; Restore the flags
042CC7 DC 80 2F 04 2419*  			CALL    C,NUMBER		; Fetch number last if IN
042CCB 78          2420*  			LD	A,B			; Get the register number
042CCC FE 06       2421*  			CP	6			; Fail on (HL)
042CCE 37          2422*  			SCF
042CCF C8          2423*  			RET	Z
042CD0 FE 08       2424*  			CP	8			; Check it is just single pairs only
042CD2 3F          2425*  			CCF
042CD3 D8          2426*  			RET	C			; And return if it is an invalid register
042CD4 07          2427*  			RLCA				; Bind with the operand
042CD5 07          2428*  			RLCA
042CD6 07          2429*  			RLCA
042CD7 81          2430*  			ADD	A,C
042CD8 4F          2431*  			LD	C,A
042CD9 CD 3A 2F 04 2432*  			CALL	ED			; Prefix with ED
042CDD 79          2433*  			LD	A,C
042CDE CD 6F 2F 04 2434*  			CALL	BYTE_			; Write out the operand
042CE2 C3 39 2D 04 2435*  			JP	VAL8			; Write out the value
042CE6             2436*  ;
042CE6             2437*  ; GROUP 9 - IN
042CE6             2438*  ; GROUP 10 - OUT
042CE6             2439*  ;
042CE6 D6 02       2440*  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
042CE8 30 25       2441*  			JR      NC,GROUP11
042CEA FE FF       2442*  			CP      1-2			; Check if Group 9 or Group 1
042CEC CC 2E 2F 04 2443*  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
042CF0 08          2444*  			EX      AF,AF'			; Save flags
042CF1 CD A7 2F 04 2445*  			CALL    REGHI			; Get the register value regardless
042CF5 D8          2446*  			RET     C			; Return if not a register
042CF6 08          2447*  			EX      AF,AF'			; Restore the flags
042CF7 DC 2E 2F 04 2448*  			CALL    C,CORN			; Call CORN if Group 9 (IN)
042CFB 24          2449*  			INC     H			; If it is IN r,(C) or OUT (C),r then
042CFC 28 B3       2450*  			JR      Z,BYTE0			; Just write the operand out
042CFE             2451*  ;
042CFE 78          2452*  			LD      A,B			; Check the register
042CFF FE 07       2453*  			CP      7
042D01 37          2454*  			SCF
042D02 C0          2455*  			RET     NZ			; If it is not A, then return
042D03             2456*  ;
042D03 79          2457*  			LD      A,C			; Bind the register with the operand
042D04 EE 03       2458*  			XOR     3
042D06 07          2459*  			RLCA
042D07 07          2460*  			RLCA
042D08 07          2461*  			RLCA
042D09 CD 6F 2F 04 2462*  			CALL    BYTE_			; Write out the operand
042D0D 18 2A       2463*  			JR      VAL8			; And the value
042D0F             2464*  ;
042D0F             2465*  ; GROUP 11 - JR, DJNZ
042D0F             2466*  ;
042D0F D6 02       2467*  GROUP11:		SUB     2			; The number of opcodes in GROUP11
042D11 30 2B       2468*  			JR      NC,GROUP12
042D13 FE FF       2469*  			CP      1-2
042D15 C4 AE 2F 04 2470*  			CALL    NZ,COND_
042D19 79          2471*  			LD      A,C
042D1A 30 02       2472*  			JR      NC,@F
042D1C 3E 18       2473*  			LD      A,18H
042D1E CD 6F 2F 04 2474*  @@:			CALL    BYTE_
042D22 CD 80 2F 04 2475*  			CALL    NUMBER
042D26 ED 5B 40 10 2476*  			LD      DE,(PC)
       10          
042D2B 13          2477*  			INC     DE
042D2C 37          2478*  			SCF
042D2D ED 52       2479*  			SBC     HL,DE
042D2F 7D          2480*  			LD      A,L
042D30 17          2481*  			RLA
042D31 9F          2482*  			SBC     A,A
042D32 BC          2483*  			CP      H
042D33 3E 01       2484*  TOOFAR:			LD      A,1
042D35 C2 18 0D 04 2485*  			JP      NZ,ERROR_		; Throw an "Out of range" error
042D39 7D          2486*  VAL8:			LD      A,L
042D3A C3 6F 2F 04 2487*  			JP      BYTE_
042D3E             2488*  ;
042D3E             2489*  ; GROUP 12 - JP
042D3E             2490*  ;
042D3E D6 01       2491*  GROUP12:		SUB	1			; The number of opcodes in GROUP12
042D40 30 21       2492*  			JR	NC,GROUP13
042D42 CD 94 2E 04 2493*  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
042D46 D8          2494*  			RET	C			; Exit if an invalid suffix is provided
042D47 CD AE 2F 04 2495*  			CALL    COND_			; Evaluate the conditions
042D4B 79          2496*  			LD      A,C
042D4C 30 0D       2497*  			JR      NC,GROUP12_1
042D4E 78          2498*  			LD      A,B
042D4F E6 3F       2499*  			AND     3FH
042D51 FE 06       2500*  			CP      6
042D53 3E E9       2501*  			LD      A,0E9H
042D55 CA 6F 2F 04 2502*  			JP      Z,BYTE_
042D59 3E C3       2503*  			LD      A,0C3H
042D5B CD 6F 2F 04 2504*  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
042D5F C3 E9 2E 04 2505*  			JP	ADDR_			; Output the address
042D63             2506*  ;
042D63             2507*  ; GROUP 13 - CALL
042D63             2508*  ;
042D63 D6 01       2509*  GROUP13:		SUB	1			; The number of opcodes in GROUP13
042D65 30 0C       2510*  			JR	NC,GROUP14
042D67 CD AC 2E 04 2511*  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
042D6B CD 8E 2D 04 2512*  			CALL    GROUP15_1		; Output the opcode (with conditions)
042D6F C3 E9 2E 04 2513*  			JP	ADDR_			; Output the address
042D73             2514*  ;
042D73             2515*  ; GROUP 14 - RST
042D73             2516*  ;
042D73 D6 01       2517*  GROUP14:		SUB	1			; The number of opcodes in GROUP14
042D75 30 13       2518*  			JR	NC,GROUP15
042D77 CD AC 2E 04 2519*  			CALL	EZ80SF_FULL		; Evaluate the suffix
042D7B D8          2520*  			RET	C			; Exit if an invalid suffix provided
042D7C CD 80 2F 04 2521*  			CALL    NUMBER
042D80 A1          2522*  			AND     C
042D81 B4          2523*  			OR      H
042D82 20 AF       2524*  			JR      NZ,TOOFAR
042D84 7D          2525*  			LD      A,L
042D85 B1          2526*  			OR      C
042D86 C3 6F 2F 04 2527*  	  		JP      BYTE_
042D8A             2528*  ;
042D8A             2529*  ; GROUP 15 - RET
042D8A             2530*  ;
042D8A D6 01       2531*  GROUP15:		SUB	1			; The number of opcodes in GROUP15
042D8C 30 0F       2532*  			JR	NC,GROUP16
042D8E CD AE 2F 04 2533*  GROUP15_1:		CALL    COND_
042D92 79          2534*  			LD      A,C
042D93 D2 6F 2F 04 2535*  			JP      NC,BYTE_
042D97 F6 09       2536*  			OR      9
042D99 C3 6F 2F 04 2537*  			JP      BYTE_
042D9D             2538*  ;
042D9D             2539*  ; GROUP 16 - LD
042D9D             2540*  ;
042D9D D6 01       2541*  GROUP16:		SUB	1			; The number of opcodes in GROUP16
042D9F 30 74       2542*  			JR	NC,GROUP17
042DA1 CD AC 2E 04 2543*  			CALL	EZ80SF_FULL		; Evaluate the suffix
042DA5 CD DD 2F 04 2544*  			CALL    LDOP			; Check for accumulator loads
042DA9 D2 09 2F 04 2545*  			JP      NC,LDA			; Yes, so jump here
042DAD CD A7 2F 04 2546*  			CALL    REGHI
042DB1 08          2547*  			EX      AF,AF'
042DB2 CD 32 30 04 2548*  			CALL    SKIP
042DB6 FE 28       2549*  			CP      '('			; Check for bracket
042DB8 28 24       2550*  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
042DBA 08          2551*  			EX      AF,AF'
042DBB D2 6D 2C 04 2552*  			JP      NC,GROUP05_1		; Load single register direct; go here
042DBF 0E 01       2553*  			LD      C,1
042DC1 CD C7 2F 04 2554*  			CALL    PAIR1_EX
042DC5 D8          2555*  			RET     C
042DC6 3E 0E       2556*  			LD      A,14
042DC8 B8          2557*  			CP      B
042DC9 47          2558*  			LD      B,A
042DCA CC C2 2F 04 2559*  			CALL    Z,PAIR_EX
042DCE 78          2560*  			LD      A,B
042DCF E6 3F       2561*  			AND     3FH
042DD1 FE 0C       2562*  			CP      12
042DD3 79          2563*  			LD      A,C
042DD4 C2 5B 2D 04 2564*  			JP      NZ,GROUP12_1		; Load register pair direct; go here
042DD8 3E F9       2565*  			LD      A,0F9H
042DDA C3 6F 2F 04 2566*  			JP      BYTE_
042DDE             2567*  ;
042DDE 08          2568*  LDIN:			EX      AF,AF'
042DDF C5          2569*  			PUSH    BC
042DE0 D4 A0 2F 04 2570*  			CALL    NC,REGLO
042DE4 79          2571*  			LD      A,C
042DE5 C1          2572*  			POP     BC
042DE6 D2 40 2F 04 2573*  			JP      NC,BIND
042DEA 0E 0A       2574*  			LD      C,0AH
042DEC CD C7 2F 04 2575*  			CALL    PAIR1_EX
042DF0 CD 14 2F 04 2576*  			CALL    LD16
042DF4 D2 5B 2D 04 2577*  			JP      NC,GROUP12_1
042DF8 CD 80 2F 04 2578*  			CALL    NUMBER
042DFC 0E 02       2579*  			LD      C,2
042DFE CD C2 2F 04 2580*  			CALL    PAIR_EX
042E02 CD 14 2F 04 2581*  			CALL    LD16
042E06 D8          2582*  			RET     C
042E07 CD 6F 2F 04 2583*  			CALL    BYTE_
042E0B CB 7A       2584*  			BIT	7,D			; Check the ADL flag
042E0D C2 FE 2E 04 2585*  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
042E11 C3 F1 2E 04 2586*  			JP      VAL16			; Otherwise use 16-bit addresses
042E15             2587*  ;
042E15             2588*  ; Group 17 - TST
042E15             2589*  ;
042E15 D6 01       2590*  GROUP17:		SUB	1			; The number of opcodes in GROUP17
042E17 30 25       2591*  			JR	NC,OPTS
042E19 CD 3A 2F 04 2592*  			CALL	ED			; Needs to be prefixed with ED
042E1D CD 94 2F 04 2593*  			CALL	REG			; Fetch the register
042E21 30 0E       2594*  			JR	NC,GROUP17_1		; It's just a register
042E23             2595*  ;
042E23 3E 64       2596*  			LD	A,64H			; Opcode for TST n
042E25 CD 6F 2F 04 2597*  			CALL	BYTE_			; Write out the opcode
042E29 CD 80 2F 04 2598*  			CALL	NUMBER			; Get the number
042E2D C3 39 2D 04 2599*  			JP	VAL8			; And write that out
042E31             2600*  ;
042E31 78          2601*  GROUP17_1:		LD	A,B			; Check the register rangs
042E32 FE 08       2602*  			CP	8
042E34 3F          2603*  			CCF
042E35 D8          2604*  			RET	C			; Ret with carry flag set for error if out of range
042E36 07          2605*  			RLCA				; Get the opcode value
042E37 07          2606*  			RLCA
042E38 07          2607*  			RLCA
042E39 81          2608*  			ADD	A,C			; Add the opcode base in
042E3A C3 6F 2F 04 2609*  			JP	BYTE_
042E3E             2610*  
042E3E             2611*  ;
042E3E             2612*  ; Assembler directives - OPT, ADL
042E3E             2613*  ;
042E3E D6 02       2614*  OPTS:			SUB	2
042E40 30 2B       2615*  			JR	NC, DEFS
042E42 FE FF       2616*  			CP	1-2			; Check for ADL opcode
042E44 28 13       2617*  			JR	Z, ADL_
042E46             2618*  ;
042E46 CD 80 2F 04 2619*  OPT:			CALL    NUMBER			; Fetch the OPT value
042E4A 21 40 05 04 2620*  			LD      HL,LISTON		; Address of the LISTON/OPT flag
042E4E E6 07       2621*  			AND	7			; Only interested in the first three bits
042E50 4F          2622*  			LD      C,A			; Store the new OPT value in C
042E51 ED 6F       2623*  			RLD				; Shift the top nibble of LISTON (OPT) into A
042E53 E6 08       2624*  			AND	8			; Clear the bottom three bits, preserving the ADL bit
042E55 B1          2625*  			OR	C			; OR in the new value
042E56 ED 67       2626*  			RRD				; And shift the nibble back in
042E58 C9          2627*  			RET
042E59             2628*  ;
042E59 CD 80 2F 04 2629*  ADL_:			CALL	NUMBER			; Fetch the ADL value
042E5D E6 01       2630*  			AND	1			; Only interested if it is 0 or 1
042E5F 0F          2631*  			RRCA				; Rotate to bit 7
042E60 4F          2632*  			LD	C,A			; Store in C
042E61 3A 40 05 04 2633*  			LD	A,(LISTON)		; Get the LISTON system variable
042E65 E6 7F       2634*  			AND	7Fh			; Clear bit 7
042E67 B1          2635*  			OR	C			; OR in the ADL value
042E68 32 40 05 04 2636*  			LD	(LISTON),A		; Store
042E6C C9          2637*  			RET
042E6D             2638*  ;
042E6D             2639*  ; DEFB, DEFW, DEFL, DEFM
042E6D             2640*  ;
042E6D B7          2641*  DEFS:			OR	A			; Handle DEFB
042E6E CA 7A 2C 04 2642*  			JP	Z, DB_
042E72 3D          2643*  			DEC	A			; Handle DEFW
042E73 CA ED 2E 04 2644*  			JP	Z, ADDR16
042E77 3D          2645*  			DEC	A			; Handle DEFL
042E78 CA FA 2E 04 2646*  			JP	Z, ADDR24
042E7C             2647*  ;
042E7C DD E5       2648*  			PUSH    IX			; Handle DEFM
042E7E CD 5F 15 04 2649*  			CALL    EXPRS
042E82 DD E1       2650*  			POP     IX
042E84 21 00 02 04 2651*  			LD      HL,ACCS
042E88 AF          2652*  @@:			XOR     A
042E89 BB          2653*  			CP      E
042E8A C8          2654*  			RET     Z
042E8B 7E          2655*  			LD      A,(HL)
042E8C 23          2656*  			INC     HL
042E8D CD 6F 2F 04 2657*  			CALL    BYTE_
042E91 1D          2658*  			DEC     E
042E92 18 F4       2659*  			JR      @B
042E94             2660*  
042E94             2661*  ;
042E94             2662*  ;SUBROUTINES:
042E94             2663*  ;
042E94 FD 7E 00    2664*  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
042E97 FE 2E       2665*  			CP	'.'
042E99 28 02       2666*  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
042E9B B7          2667*  			OR	A			; Reset the carry flag (no error)
042E9C C9          2668*  			RET				; And return
042E9D FD 23       2669*  @@:			INC	IY			; Skip the dot
042E9F C5          2670*  			PUSH	BC			; Push the operand
042EA0 21 C8 32 04 2671*  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
042EA4 CD E1 2F 04 2672*  			CALL	FIND			; Look up the operand
042EA8 30 24       2673*  			JR	NC,EZ80SF_OK
042EAA C1          2674*  			POP	BC			; Not found at this point, so will return with a C (error)
042EAB C9          2675*  			RET
042EAC             2676*  ;
042EAC FD 7E 00    2677*  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
042EAF FE 2E       2678*  			CP	'.'
042EB1 28 02       2679*  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
042EB3 B7          2680*  			OR	A			; Reset the carry flag (no error)
042EB4 C9          2681*  			RET				; And return
042EB5 FD 23       2682*  @@:			INC	IY 			; Skip the dot
042EB7 C5          2683*  			PUSH	BC			; Push the operand
042EB8 21 C0 32 04 2684*  			LD	HL,EZ80SFS_1		; First check the fully qualified table
042EBC CD E1 2F 04 2685*  			CALL	FIND 			; Look up the operand
042EC0 30 0C       2686*  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
042EC2 CD DD 2E 04 2687*  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
042EC6 CD E1 2F 04 2688*  			CALL	FIND
042ECA 30 02       2689*  			JR	NC,EZ80SF_OK
042ECC C1          2690*  			POP	BC			; Not found at this point, so will return with a C (error)
042ECD C9          2691*  			RET
042ECE             2692*  ;
042ECE 78          2693*  EZ80SF_OK:		LD	A,B			; The operand value
042ECF D4 6F 2F 04 2694*  			CALL	NC,BYTE_ 		; Write it out if found
042ED3 CB BA       2695*  			RES	7,D			; Clear the default ADL mode from the flags
042ED5 E6 02       2696*  			AND	2			; Check the second half of the suffix (.xxL)
042ED7 0F          2697*  			RRCA				; Shift into bit 7
042ED8 0F          2698*  			RRCA
042ED9 B2          2699*  			OR	D			; Or into bit 7 of D
042EDA 57          2700*  			LD	D,A
042EDB C1          2701*  			POP	BC 			; Restore the operand
042EDC C9          2702*  			RET
042EDD             2703*  ;
042EDD 21 D1 32 04 2704*  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
042EE1 CB 7A       2705*  			BIT 	7,D			; if bit 7 of D is 0
042EE3 C8          2706*  			RET	Z
042EE4 21 DC 32 04 2707*  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
042EE8 C9          2708*  			RET
042EE9             2709*  ;
042EE9 CB 7A       2710*  ADDR_:			BIT	7,D			; Check the ADL flag
042EEB 20 0D       2711*  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
042EED             2712*  ;
042EED CD 80 2F 04 2713*  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
042EF1 CD 39 2D 04 2714*  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
042EF5 7C          2715*  			LD      A,H
042EF6 C3 6F 2F 04 2716*  			JP      BYTE_
042EFA             2717*  ;
042EFA CD 80 2F 04 2718*  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
042EFE CD F1 2E 04 2719*  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
042F02 D9          2720*  			EXX
042F03 7D          2721*  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
042F04 D9          2722*  			EXX
042F05 C3 6F 2F 04 2723*  			JP	BYTE_
042F09             2724*  ;
042F09 FE 04       2725*  LDA:			CP      4
042F0B DC 3A 2F 04 2726*  			CALL    C,ED
042F0F 78          2727*  			LD      A,B
042F10 C3 6F 2F 04 2728*  			JP      BYTE_
042F14             2729*  ;
042F14 78          2730*  LD16:			LD      A,B
042F15 38 0F       2731*  			JR      C,LD8
042F17 78          2732*  			LD      A,B
042F18 E6 3F       2733*  			AND     3FH
042F1A FE 0C       2734*  			CP      12
042F1C 79          2735*  			LD      A,C
042F1D C8          2736*  			RET     Z
042F1E CD 3A 2F 04 2737*  			CALL    ED
042F22 79          2738*  			LD      A,C
042F23 F6 43       2739*  			OR      43H
042F25 C9          2740*  			RET
042F26             2741*  ;
042F26 FE 07       2742*  LD8:			CP      7
042F28 37          2743*  			SCF
042F29 C0          2744*  			RET     NZ
042F2A 79          2745*  			LD      A,C
042F2B F6 30       2746*  			OR      30H
042F2D C9          2747*  			RET
042F2E             2748*  ;
042F2E             2749*  ; Used in IN and OUT to handle whether the operand is C or a number
042F2E             2750*  ;
042F2E C5          2751*  CORN:			PUSH    BC
042F2F CD 4E 2F 04 2752*  			CALL    OPND			; Get the operand
042F33 CB 68       2753*  			BIT     5,B
042F35 C1          2754*  			POP     BC
042F36 28 48       2755*  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
042F38 26 FF       2756*  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
042F3A             2757*  ;
042F3A 3E ED       2758*  ED:			LD      A,0EDH			; Write an ED prefix out
042F3C 18 31       2759*  			JR      BYTE_
042F3E             2760*  ;
042F3E 3E CB       2761*  CB:			LD      A,0CBH
042F40 FE 76       2762*  BIND:			CP      76H
042F42 37          2763*  			SCF
042F43 C8          2764*  			RET     Z               	; Reject LD (HL),(HL)
042F44 CD 6F 2F 04 2765*  			CALL    BYTE_
042F48 CB 72       2766*  			BIT	6,D			; Check the index bit in flags
042F4A C8          2767*  			RET     Z
042F4B 7B          2768*  			LD      A,E			; If there is an index, output the offset
042F4C 18 21       2769*  			JR      BYTE_
042F4E             2770*  ;
042F4E             2771*  ; Search through the operand table
042F4E             2772*  ; Returns:
042F4E             2773*  ; - B: The operand type
042F4E             2774*  ; - D: Bit 7: 0 = no prefix, 1 = prefix
042F4E             2775*  ; - E: The IX/IY offset
042F4E             2776*  ; - F: Carry if not found
042F4E             2777*  ;
042F4E E5          2778*  OPND:			PUSH    HL			; Preserve HL
042F4F 21 52 32 04 2779*  			LD      HL,OPRNDS		; The operands table
042F53 CD E1 2F 04 2780*  			CALL    FIND			; Find the operand
042F57 E1          2781*  			POP     HL
042F58 D8          2782*  			RET     C			; Return if not found
042F59 CB 78       2783*  			BIT     7,B			; Check if it is an index register (IX, IY)
042F5B C8          2784*  			RET     Z			; Return if it isn't
042F5C CB F2       2785*  			SET	6,D			; Set flag to indicate we've got an index
042F5E CB 58       2786*  			BIT     3,B			; Check if an offset is required
042F60 E5          2787*  			PUSH    HL
042F61 CC 76 2F 04 2788*  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
042F65 5D          2789*  			LD      E,L			; E: The offset
042F66 E1          2790*  			POP     HL
042F67 3E DD       2791*  			LD	A,DDH			; IX prefix
042F69 CB 70       2792*  			BIT     6,B			; If bit 6 is reset then
042F6B 28 02       2793*  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
042F6D 3E FD       2794*  			LD	A,FDH			; IY prefix
042F6F             2795*  ;
042F6F DD 77 00    2796*  BYTE_:			LD      (IX),A			; Write a byte out
042F72 DD 23       2797*  			INC     IX
042F74 B7          2798*  			OR      A
042F75 C9          2799*  			RET
042F76             2800*  ;
042F76 FD 7E 00    2801*  OFFSET_EX:			LD      A,(IY)
042F79 FE 29       2802*  			CP      ')'
042F7B 21 00 00 00 2803*  			LD      HL,0
042F7F C8          2804*  			RET     Z
042F80 CD 32 30 04 2805*  NUMBER:			CALL    SKIP
042F84 C5          2806*  			PUSH    BC
042F85 D5          2807*  			PUSH    DE
042F86 DD E5       2808*  			PUSH    IX
042F88 CD 54 15 04 2809*  			CALL    EXPRI
042F8C DD E1       2810*  			POP     IX
042F8E D9          2811*  			EXX
042F8F D1          2812*  			POP     DE
042F90 C1          2813*  			POP     BC
042F91 7D          2814*  			LD      A,L
042F92 B7          2815*  			OR      A
042F93 C9          2816*  			RET
042F94             2817*  ;
042F94 CD 4E 2F 04 2818*  REG:			CALL    OPND
042F98 D8          2819*  			RET     C
042F99 78          2820*  			LD      A,B
042F9A E6 3F       2821*  			AND     3FH
042F9C FE 08       2822*  			CP      8
042F9E 3F          2823*  			CCF
042F9F C9          2824*  			RET
042FA0             2825*  ;
042FA0 CD 94 2F 04 2826*  REGLO:			CALL    REG
042FA4 D8          2827*  			RET     C
042FA5 18 33       2828*  			JR      ORC
042FA7             2829*  ;
042FA7 CD 94 2F 04 2830*  REGHI:			CALL    REG
042FAB D8          2831*  			RET     C
042FAC 18 29       2832*  			JR      SHL3
042FAE             2833*  ;
042FAE CD 4E 2F 04 2834*  COND_:			CALL    OPND
042FB2 D8          2835*  			RET     C
042FB3 78          2836*  			LD      A,B
042FB4 E6 1F       2837*  			AND     1FH
042FB6 D6 10       2838*  			SUB     16
042FB8 30 1D       2839*  			JR      NC,SHL3
042FBA FE F1       2840*  			CP      -15
042FBC 37          2841*  			SCF
042FBD C0          2842*  			RET     NZ
042FBE 3E 03       2843*  			LD      A,3
042FC0 18 15       2844*  			JR      SHL3
042FC2             2845*  ;
042FC2 CD 4E 2F 04 2846*  PAIR_EX:			CALL    OPND
042FC6 D8          2847*  			RET     C
042FC7 78          2848*  PAIR1_EX:			LD      A,B
042FC8 E6 0F       2849*  			AND     0FH
042FCA D6 08       2850*  			SUB     8
042FCC D8          2851*  			RET     C
042FCD 18 08       2852*  			JR      SHL3
042FCF             2853*  ;
042FCF CD 80 2F 04 2854*  BIT_:			CALL    NUMBER
042FD3 FE 08       2855*  			CP      8
042FD5 3F          2856*  			CCF
042FD6 D8          2857*  			RET     C
042FD7 07          2858*  SHL3:			RLCA
042FD8 07          2859*  			RLCA
042FD9 07          2860*  			RLCA
042FDA B1          2861*  ORC:			OR      C
042FDB 4F          2862*  			LD      C,A
042FDC C9          2863*  			RET
042FDD             2864*  ;
042FDD 21 97 32 04 2865*  LDOP:			LD      HL,LDOPS
042FE1             2866*  
042FE1             2867*  ;
042FE1             2868*  ; Look up a value in a table
042FE1             2869*  ; Parameters:
042FE1             2870*  ; - IY: Address of the assembly language line in the BASIC program area
042FE1             2871*  ; - HL: Address of the table
042FE1             2872*  ; Returns:
042FE1             2873*  ; - B: The operand code
042FE1             2874*  ; - F: Carry set if not found
042FE1             2875*  ;
042FE1 CD 32 30 04 2876*  FIND:			CALL    SKIP			; Skip delimiters
042FE5             2877*  ;
042FE5 06 00       2878*  EXIT_:			LD      B,0			; Set B to 0
042FE7 37          2879*  			SCF				; Set the carry flag
042FE8 C8          2880*  			RET     Z			; Returns if Z
042FE9             2881*  ;
042FE9 FE DD       2882*  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
042FEB 28 04       2883*  			JR      Z,FIND0
042FED FE 85       2884*  			CP      TOR+1			; Special case for tokens AND and OR
042FEF 3F          2885*  			CCF
042FF0 D8          2886*  			RET     C
042FF1 7E          2887*  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
042FF2 B7          2888*  			OR      A
042FF3 28 F0       2889*  			JR      Z,EXIT_			; Exit
042FF5 FD AE 00    2890*  			XOR     (IY)
042FF8 E6 5F       2891*  			AND     01011111B
042FFA 28 09       2892*  			JR      Z,FIND2
042FFC CB 7E       2893*  FIND1:			BIT     7,(HL)
042FFE 23          2894*  			INC     HL
042FFF 28 FB       2895*  			JR      Z,FIND1
043001 23          2896*  			INC     HL
043002 04          2897*  			INC     B
043003 18 EC       2898*  			JR      FIND0
043005             2899*  ;
043005 FD E5       2900*  FIND2:			PUSH    IY
043007 CB 7E       2901*  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
043009 FD 23       2902*  			INC     IY
04300B 23          2903*  			INC     HL
04300C 20 11       2904*  			JR      NZ,FIND5		; Yes
04300E BE          2905*  			CP      (HL)
04300F CC 31 30 04 2906*  			CALL    Z,SKIP0
043013 7E          2907*  			LD      A,(HL)
043014 FD AE 00    2908*  			XOR     (IY)
043017 E6 5F       2909*  			AND     01011111B
043019 28 EC       2910*  			JR      Z,FIND3
04301B FD E1       2911*  FIND4:			POP     IY
04301D 18 DD       2912*  			JR      FIND1
04301F             2913*  ;
04301F CD DD 29 04 2914*  FIND5:			CALL    DELIM			; Is it a delimiter?
043023 C4 46 30 04 2915*  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
043027 C4 40 30 04 2916*  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
04302B 20 EE       2917*  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
04302D             2918*  ;
04302D 78          2919*  FIND6:			LD      A,B			; At this point we have a token
04302E 46          2920*  			LD      B,(HL)			; Fetch the token type code
04302F E1          2921*  			POP     HL			; Restore the stack
043030 C9          2922*  			RET
043031             2923*  ;
043031 23          2924*  SKIP0:			INC     HL
043032 CD DD 29 04 2925*  SKIP:			CALL    DELIM			; Is it a delimiter?
043036 C0          2926*  			RET     NZ			; No, so return
043037 CD E9 29 04 2927*  			CALL    TERM			; Is it a terminator?
04303B C8          2928*  			RET     Z			; Yes, so return
04303C FD 23       2929*  			INC     IY			; Increment the basic program counter
04303E 18 F2       2930*  			JR      SKIP			; And loop
043040             2931*  ;
043040 FE 2B       2932*  SIGN:			CP      '+'			; Check whether the character is a sign symbol
043042 C8          2933*  			RET     Z
043043 FE 2D       2934*  			CP      '-'
043045 C9          2935*  			RET
043046             2936*  ;
043046 FE 2E       2937*  DOT:			CP	'.'			; Check if it is a dot character
043048 C9          2938*  			RET
043049             2939*  ; Z80 opcode list
043049             2940*  ;
043049             2941*  ; Group 0: (15 opcodes)
043049             2942*  ; Trivial cases requiring no computation
043049             2943*  ;
043049 4E 4F 50 00 2944*  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
04304D 52 4C 43 41 2945*  			DB	"RLC","A"+80H,07h
       07          
043052 45 58 00 41 2946*  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
04305C 52 52 43 41 2947*  			DB	"RRC","A"+80H,0FH
       0F          
043061 52 4C 41 17 2948*  			DB	"RL","A"+80H,17H
043065 52 52 41 1F 2949*  			DB	"RR","A"+80H,1FH
043069 44 41 41 27 2950*  			DB	"DA","A"+80H,27H
04306D 43 50 4C 2F 2951*  			DB	"CP","L"+80H,2FH
043071 53 43 46 37 2952*  			DB	"SC","F"+80H,37H
043075 43 43 46 3F 2953*  			DB	"CC","F"+80H,3FH
043079 48 41 4C 54 2954*  			DB	"HAL","T"+80H,76H
       76          
04307E 45 58 58 D9 2955*  			DB	"EX","X"+80H,D9H
043082 45 58 00 44 2956*  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
04308B 44 49 F3    2957*  			DB	"D","I"+80H,F3H
04308E 45 49 FB    2958*  			DB	"E","I"+80H,FBH
043091             2959*  ;
043091             2960*  ; Group 1: (53 opcodes)
043091             2961*  ; As Group 0, but with an ED prefix
043091             2962*  ;
043091 4E 45 47 44 2963*  			DB	"NE","G"+80H,44H	; 0Fh
043095 49 4D 00 30 2964*  			DB	"IM",0,"0"+80H,46H
       46          
04309A 52 45 54 4E 2965*  			DB	"RET","N"+80H,45H
       45          
04309F 4D 4C 54 00 2966*  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
0430A6 52 45 54 49 2967*  			DB	"RET","I"+80H,4DH
       4D          
0430AB 49 4D 00 31 2968*  			DB	"IM",0,"1"+80H,56H
       56          
0430B0 4D 4C 54 00 2969*  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
0430B7 49 4D 00 32 2970*  			DB	"IM",0,"2"+80H,5EH
       5E          
0430BC 52 52 44 67 2971*  			DB	"RR","D"+80H,67H
0430C0 4D 4C 54 00 2972*  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
0430C7 4C 44 00 4D 2973*  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
0430CF 4C 44 00 41 2974*  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
0430D7 52 4C 44 6F 2975*  			DB	"RL","D"+80H,6FH
0430DB 53 4C 50 76 2976*  			DB	"SL","P"+80H,76H
0430DF 4D 4C 54 00 2977*  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
0430E6 53 54 4D 49 2978*  			DB	"STMI","X"+80H,7DH
       58 7D       
0430EC 52 53 4D 49 2979*  			DB	"RSMI","X"+80H,7EH
       58 7E       
0430F2 49 4E 49 4D 2980*  			DB	"INI","M"+80H,82H
       82          
0430F7 4F 54 49 4D 2981*  			DB	"OTI","M"+80H,83H
       83          
0430FC 49 4E 49 32 2982*  			DB	"INI","2"+80H,84H
       84          
043101 49 4E 44 4D 2983*  			DB	"IND","M"+80H,8AH
       8A          
043106 4F 54 44 4D 2984*  			DB	"OTD","M"+80H,8BH
       8B          
04310B 49 4E 44 32 2985*  			DB	"IND","2"+80H,8CH
       8C          
043110 49 4E 49 4D 2986*  			DB	"INIM","R"+80H,92H
       52 92       
043116 4F 54 49 4D 2987*  			DB	"OTIM","R"+80H,93H
       52 93       
04311C 49 4E 49 32 2988*  			DB	"INI2","R"+80H,94H
       52 94       
043122 49 4E 44 4D 2989*  			DB	"INDM","R"+80H,9AH
       52 9A       
043128 4F 54 44 4D 2990*  			DB	"OTDM","R"+80H,9BH
       52 9B       
04312E 49 4E 44 32 2991*  			DB	"IND2","R"+80H,9CH
       52 9C       
043134 4C 44 49 A0 2992*  			DB	"LD","I"+80H,A0H
043138 43 50 49 A1 2993*  			DB	"CP","I"+80H,A1H
04313C 49 4E 49 A2 2994*  			DB	"IN","I"+80H,A2H
043140 4F 55 54 49 2995*  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
043146 4F 55 54 49 2996*  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
04314B 4C 44 44 A8 2997*  			DB	"LD","D"+80H,A8H
04314F 43 50 44 A9 2998*  			DB	"CP","D"+80H,A9H
043153 49 4E 44 AA 2999*  			DB	"IN","D"+80H,AAH
043157 4F 55 54 44 3000*  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
04315D 4F 55 54 44 3001*  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
043162 4C 44 49 52 3002*  			DB	"LDI","R"+80H,B0H
       B0          
043167 43 50 49 52 3003*  			DB	"CPI","R"+80H,B1H
       B1          
04316C 49 4E 49 52 3004*  			DB	"INI","R"+80H,B2H
       B2          
043171 4F 54 49 52 3005*  			DB	"OTI","R"+80H,B3H
       B3          
043176 4F 54 49 32 3006*  			DB	"OTI2","R"+80H,B4H
       52 B4       
04317C 4C 44 44 52 3007*  			DB	"LDD","R"+80H,B8H
       B8          
043181 43 50 44 52 3008*  			DB	"CPD","R"+80H,B9H
       B9          
043186 49 4E 44 52 3009*  			DB	"IND","R"+80H,BAH
       BA          
04318B 4F 54 44 52 3010*  			DB	"OTD","R"+80H,BBH
       BB          
043190 4F 54 44 32 3011*  			DB	"OTD2","R"+80H,BCH
       52 BC       
043196 49 4E 49 52 3012*  			DB	"INIR","X"+80H,C2H
       58 C2       
04319C 4F 54 49 52 3013*  			DB	"OTIR","X"+80H,C3H
       58 C3       
0431A2 49 4E 44 52 3014*  			DB	"INDR","X"+80H,CAH
       58 CA       
0431A8 4F 54 44 52 3015*  			DB	"OTDR","X"+80H,CBH
       58 CB       
0431AE             3016*  ;
0431AE             3017*  ; Group 2: (3 opcodes)
0431AE             3018*  ;
0431AE 42 49 54 40 3019*  			DB	"BI","T"+80H,40H	; 44h
0431B2 52 45 53 80 3020*  			DB	"RE","S"+80H,80H
0431B6 53 45 54 C0 3021*  			DB	"SE","T"+80H,C0H
0431BA             3022*  ;
0431BA             3023*  ; Group 3: (7 opcodes)
0431BA             3024*  ;
0431BA 52 4C 43 00 3025*  			DB	"RL","C"+80H,00H	; 47h
0431BE 52 52 43 08 3026*  			DB	"RR","C"+80H,08H
0431C2 52 4C 10    3027*  			DB	"R","L"+80H,10H
0431C5 52 52 18    3028*  			DB	"R","R"+80H,18H
0431C8 53 4C 41 20 3029*  			DB	"SL","A"+80H,20H
0431CC 53 52 41 28 3030*  			DB	"SR","A"+80H,28H
0431D0 53 52 4C 38 3031*  			DB	"SR","L"+80H,38H
0431D4             3032*  ;
0431D4             3033*  ; Group 4: (3 opcodes)
0431D4             3034*  ;
0431D4 50 4F 50 C1 3035*  			DB	"PO","P"+80H,C1H	; 4Eh
0431D8 50 55 53 48 3036*  			DB	"PUS","H"+80H,C5H
       C5          
0431DD 45 58 00 28 3037*  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
0431E4             3038*  ;
0431E4             3039*  ; Group 5: (7 opcodes)
0431E4             3040*  ;
0431E4 53 55 42 90 3041*  			DB	"SU","B"+80H,90H	; 51h
0431E8 41 4E 44 A0 3042*  			DB	"AN","D"+80H,A0H
0431EC 58 4F 52 A8 3043*  			DB	"XO","R"+80H,A8H
0431F0 4F 52 B0    3044*  			DB	"O","R"+80H,B0H
0431F3 43 50 B8    3045*  			DB	"C","P"+80H,B8H
0431F6 80 A0       3046*  			DB	TAND,A0H		; 56h TAND: Tokenised AND
0431F8 84 B0       3047*  			DB	TOR,B0H			; 57h TOR: Tokenised OR
0431FA             3048*  ;
0431FA             3049*  ; Group 6 (3 opcodes)
0431FA             3050*  ;
0431FA 41 44 44 80 3051*  			DB	"AD","D"+80H,80H	; 58h
0431FE 41 44 43 88 3052*  			DB	"AD","C"+80H,88H
043202 53 42 43 98 3053*  			DB	"SB","C"+80H,98H
043206             3054*  ;
043206             3055*  ; Group 7: (2 opcodes)
043206             3056*  ;
043206 49 4E 43 04 3057*  			DB	"IN","C"+80H,04H	; 5Bh
04320A 44 45 43 05 3058*  			DB	"DE","C"+80H,05H
04320E             3059*  ;
04320E             3060*  ; Group 8: (2 opcodes)
04320E             3061*  ;
04320E 49 4E 30 00 3062*  			DB	"IN","0"+80H,00H	; 5Dh
043212 4F 55 54 30 3063*  			DB	"OUT","0"+80H,01H
       01          
043217             3064*  ;
043217             3065*  ; Group 9: (1 opcode)
043217             3066*  ;
043217 49 4E 40    3067*  			DB	"I","N"+80H,40H		; 5Fh
04321A             3068*  ;
04321A             3069*  ; Group 10: (1 opcode)
04321A             3070*  ;
04321A 4F 55 54 41 3071*  			DB	"OU","T"+80H,41H	; 60h
04321E             3072*  ;
04321E             3073*  ; Group 11: (2 opcodes)
04321E             3074*  ;
04321E 4A 52 20    3075*  			DB	"J","R"+80H,20H		; 61h
043221 44 4A 4E 5A 3076*  			DB	"DJN","Z"+80H,10H
       10          
043226             3077*  ;
043226             3078*  ; Group 12: (1 opcode)
043226             3079*  ;
043226 4A 50 C2    3080*  			DB	"J","P"+80H,C2H		; 63h
043229             3081*  ;
043229             3082*  ; Group 13: (1 opcode)
043229             3083*  ;
043229 43 41 4C 4C 3084*  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
04322E             3085*  ;
04322E             3086*  ; Group 14: (1 opcode)
04322E             3087*  ;
04322E 52 53 54 C7 3088*  			DB	"RS","T"+80H,C7H	; 65h
043232             3089*  ;
043232             3090*  ; Group 15: (1 opcode)
043232             3091*  ;
043232 52 45 54 C0 3092*  			DB	"RE","T"+80H,C0H	; 66h
043236             3093*  ;
043236             3094*  ; Group 16: (1 opcode)
043236             3095*  ;
043236 4C 44 40    3096*  			DB	"L","D"+80H,40H		; 67h
043239             3097*  ;
043239             3098*  ; Group 17: (1 opcode)
043239             3099*  ;
043239 54 53 54 04 3100*  			DB	"TS","T"+80H,04H	; 68h
04323D             3101*  
04323D             3102*  ;
04323D             3103*  ; Assembler Directives
04323D             3104*  ;
04323D 4F 50 54 00 3105*  			DB	"OP","T"+80H,00H	; 69h OPT
043241 41 44 4C 00 3106*  			DB	"AD","L"+80H,00H	; 6Ah ADL
043245             3107*  ;
043245 5D 42 00    3108*  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
043248 5D 57 00    3109*  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
04324B 5D 4C 00    3110*  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
04324E 5D 4D 00    3111*  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
043251             3112*  ;
043251 00          3113*  			DB	0
043252             3114*  ;
043252             3115*  ; Operands
043252             3116*  ;
043252 42 00       3117*  OPRNDS:			DB	"B"+80H, 00H
043254 43 01       3118*  			DB	"C"+80H, 01H
043256 44 02       3119*  			DB	"D"+80H, 02H
043258 45 03       3120*  			DB	"E"+80H, 03H
04325A 48 04       3121*  			DB	"H"+80H, 04H
04325C 4C 05       3122*  			DB	"L"+80H, 05H
04325E 28 48 4C 06 3123*  			DB	"(H","L"+80H,06H
043262 41 07       3124*  			DB	"A"+80H, 07H
043264 28 49 58 86 3125*  			DB	"(I","X"+80H,86H
043268 28 49 59 C6 3126*  			DB	"(I","Y"+80H,C6H
04326C             3127*  ;
04326C 42 43 08    3128*  			DB	"B","C"+80H,08H
04326F 44 45 0A    3129*  			DB	"D","E"+80H,0AH
043272 48 4C 0C    3130*  			DB	"H","L"+80H,0CH
043275 49 58 8C    3131*  			DB	"I","X"+80H,8CH
043278 49 59 CC    3132*  			DB	"I","Y"+80H,CCH
04327B 41 46 0E    3133*  			DB	"A","F"+80H,0EH
04327E 53 50 0E    3134*  			DB	"S","P"+80H,0EH
043281             3135*  ;
043281 4E 5A 10    3136*  			DB	"N","Z"+80H,10H
043284 5A 11       3137*  			DB	"Z"+80H,11H
043286 4E 43 12    3138*  			DB	"N","C"+80H,12H
043289 50 4F 14    3139*  			DB	"P","O"+80H,14H
04328C 50 45 15    3140*  			DB	"P","E"+80H,15H
04328F 50 16       3141*  			DB	"P"+80H,16H
043291 4D 17       3142*  			DB	"M"+80H,17H
043293             3143*  ;
043293 28 43 20    3144*  			DB	"(","C"+80H,20H
043296             3145*  ;
043296 00          3146*  			DB	0
043297             3147*  ;
043297             3148*  ; Load operations
043297             3149*  ;
043297 49 00 41 47 3150*  LDOPS:			DB	"I",0,"A"+80H,47H
04329B 52 00 41 4F 3151*  			DB	"R",0,"A"+80H,4FH
04329F 41 00 49 57 3152*  			DB	"A",0,"I"+80H,57H
0432A3 41 00 52 5F 3153*  			DB	"A",0,"R"+80H,5FH
0432A7 28 42 43 00 3154*  			DB	"(BC",0,"A"+80H,02h
       41 02       
0432AD 28 44 45 00 3155*  			DB	"(DE",0,"A"+80H,12H
       41 12       
0432B3 41 00 28 42 3156*  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
0432B9 41 00 28 44 3157*  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
0432BF             3158*  ;
0432BF 00          3159*  			DB	0
0432C0             3160*  ;
0432C0             3161*  ; eZ80 addressing mode suffixes
0432C0             3162*  ;
0432C0             3163*  ; Fully qualified suffixes
0432C0             3164*  ;
0432C0 4C 49 53 49 3165*  EZ80SFS_1:		DB	"LI","S"+80H,49H
0432C4 53 49 4C 52 3166*  			DB	"SI","L"+80H,52H
0432C8 53 49 53 40 3167*  EZ80SFS_2:		DB	"SI","S"+80H,40H
0432CC 4C 49 4C 5B 3168*  			DB	"LI","L"+80H,5BH
0432D0             3169*  ;
0432D0 00          3170*  			DB	0
0432D1             3171*  ;
0432D1             3172*  ; Shortcuts when ADL mode is 0
0432D1             3173*  ;
0432D1 53 40       3174*  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0432D3 4C 49       3175*  			DB	"L"+80H,49H		; Equivalent to .LIS
0432D5 49 53 40    3176*  			DB	"I","S"+80H,40H		; Equivalent to .SIS
0432D8 49 4C 52    3177*  			DB	"I","L"+80H,52H		; Equivalent to .SIL
0432DB             3178*  ;
0432DB 00          3179*  			DB	0
0432DC             3180*  ;
0432DC             3181*  ; Shortcuts when ADL mode is 1
0432DC             3182*  ;
0432DC 53 52       3183*  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0432DE 4C 5B       3184*  			DB	"L"+80H,5BH		; Equivalent to .LIL
0432E0 49 53 49    3185*  			DB	"I","S"+80H,49H		; Equivalent to .LIS
0432E3 49 4C 5B    3186*  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0432E6             3187*  ;
0432E6 00          3188*  			DB	0
0432E7             3189*  ;
0432E7             3190*  ; .LIST
0432E7             3191*  ;
0432E7             3192*  ; already defined in equs.inc
0432E7             3193*  ; LF:			EQU     0AH
0432E7             3194*  ; CR:			EQU     0DH
0432E7             0009       include "fpp.asm"
0432E7             0001*  ;
0432E7             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0432E7             0003*  ;		Z80 Floating Point Package
0432E7             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
0432E7             0005*  ; Modified By:	Dean Belfield
0432E7             0006*  ; Created:	03/05/2022
0432E7             0007*  ; Last Updated:	07/06/2023
0432E7             0008*  ;
0432E7             0009*  ; Modinfo:
0432E7             0010*  ; 26/10/1986:	Version 0.0
0432E7             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0432E7             0012*  ; 12/05/2023:	Modified by Dean Belfield
0432E7             0013*  ; 07/06/2023:	Modified to run in ADL mode
0432E7             0014*  
0432E7             0015*  			; .ASSUME	ADL = 1
0432E7             0016*  
0432E7             0017*  			; SEGMENT CODE
0432E7             0018*  
0432E7             0019*  			; XDEF	FPP
0432E7             0020*  			; XDEF	DLOAD5
0432E7             0021*  			; XDEF	DLOAD5_SPL
0432E7             0022*  ;
0432E7             0023*  ;BINARY FLOATING POINT REPRESENTATION:
0432E7             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0432E7             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0432E7             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0432E7             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0432E7             0028*  ;
0432E7             0029*  ;BINARY INTEGER REPRESENTATION:
0432E7             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0432E7             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0432E7             0032*  ;
0432E7             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0432E7             0034*  ;                            EXPONENT - C
0432E7             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0432E7             0036*  ;                               EXPONENT - B
0432E7             0037*  
0432E7             0038*  ;
0432E7             0039*  ;Error codes:
0432E7             0040*  ;
0432E7             0041*  
0432E7             0042*  ; BADOP:			EQU     1               ;Bad operation code
0432E7             0043*  ; DIVBY0:			EQU     18              ;Division by zero
0432E7             0044*  ; TOOBIG_FP:			EQU     20              ;Too big
0432E7             0045*  ; NGROOT:			EQU     21              ;Negative root
0432E7             0046*  ; LOGRNG:			EQU     22              ;Log range
0432E7             0047*  ; ACLOST:			EQU     23              ;Accuracy lost
0432E7             0048*  ; EXPRNG:			EQU     24              ;Exp range
0432E7             0049*  ;
0432E7             0050*  ;Call entry and despatch code:
0432E7             0051*  ;
0432E7 FD E5       0052*  FPP:			PUSH    IY              ;Save IY
0432E9 FD 21 00 00 0053*          		LD      IY,0
       00          
0432EE FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
0432F0 CD 00 33 04 0055*          		CALL    OP              ;Perform operation
0432F4 BF          0056*          		CP      A               ;Good return (Z, NC)
0432F5 FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
0432F7 C9          0058*          		RET                     ;Return to caller
0432F8             0059*  ;
0432F8             0060*  ;Error exit:
0432F8             0061*  ;
0432F8 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0432FA FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0432FC B7          0064*          		OR      A               ;Set NZ
0432FD 37          0065*          		SCF                     ;Set C
0432FE 18 F5       0066*          		JR      EXIT_FP_
043300             0067*  ;
043300             0068*  ;Perform operation or function:
043300             0069*  ;
043300             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
043300 FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
043302             0072*  
043302 30 F4       0073*          		JR      NC,BAD_FP
043304             0074*          		; CP      (FTABLE-DTABLE)/3
043304 FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
043306 30 08       0076*          		JR      NC,DISPAT_FP
043308 08          0077*          		EX      AF,AF'
043309 78          0078*          		LD      A,B
04330A B1          0079*          		OR      C               ;Both integer?
04330B C4 13 3E 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
04330F 08          0081*          		EX      AF,AF'
043310 E5          0082*  DISPAT_FP:			PUSH    HL
043311 21 23 33 04 0083*          		LD      HL,DTABLE
043315 C5          0084*          		PUSH    BC
043316 01 03 00 00 0085*  			LD	BC, 3		; C = 3
04331A 47          0086*  			LD	B, A 		; B = op-code
04331B ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
04331D 09          0088*  			ADD	HL, BC 		;Add to table base
04331E ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
043320             0090*  
043320             0091*  ;        		ADD     A, A            ;A = op-code * 2
043320             0092*  ;        		LD      C,A
043320             0093*  ;        		LD      B,0             ;BC = op-code * 2
043320             0094*  ;        		ADD     HL,BC
043320             0095*  ;        		LD      A,(HL)          ;Get low byte
043320             0096*  ;        		INC     HL
043320             0097*  ;        		LD      H,(HL)          ;Get high byte
043320             0098*  ;        		LD      L,A
043320             0099*  
043320 C1          0100*          		POP     BC
043321 E3          0101*          		EX      (SP),HL
043322 C9          0102*          		RET                     ;Off to routine
043323             0103*  ;
043323             0104*  ;Despatch table:
043323             0105*  ;
043323 D5 33 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
043326 43 34 04    0107*          		DW24  IBDIV           ;DIV
043329 E8 33 04    0108*          		DW24  IEOR            ;EOR
04332C 0E 34 04    0109*          		DW24  IMOD            ;MOD
04332F FB 33 04    0110*          		DW24  IOR             ;OR
043332 C9 36 04    0111*          		DW24  ILE             ;<=
043335 D8 36 04    0112*          		DW24  INE             ;<>
043338 BC 36 04    0113*          		DW24  IGE             ;>=
04333B A1 36 04    0114*          		DW24  ILT             ;<
04333E E5 36 04    0115*          		DW24  IEQ             ;=
043341 31 35 04    0116*          		DW24  IMUL            ;*
043344 6C 34 04    0117*          		DW24  IADD            ;+
043347 AE 36 04    0118*          		DW24  IGT             ;>
04334A 53 34 04    0119*          		DW24  ISUB            ;-
04334D E8 35 04    0120*          		DW24  IPOW            ;^
043350 DE 34 04    0121*          		DW24  IDIV            ;/
043353             0122*  ;
043353             0123*  FTABLE:
043353 F7 36 04    0124*  				DW24  ABSV_FP            ;ABS
043356 DD 3A 04    0125*          		DW24  ACS_FP             ;ACS
043359 1B 3A 04    0126*          		DW24  ASN_FP             ;ASN
04335C 4B 3A 04    0127*          		DW24  ATN_FP             ;ATN
04335F 16 38 04    0128*          		DW24  COS_FP             ;COS
043362 25 37 04    0129*          		DW24  DEG_FP             ;DEG
043365 D2 38 04    0130*          		DW24  EXP_FP             ;EXP
043368 79 37 04    0131*          		DW24  INT_FP_            ;INT
04336B 70 39 04    0132*          		DW24  LN_FP              ;LN
04336E 05 3A 04    0133*          		DW24  LOG_FP             ;LOG
043371 03 37 04    0134*          		DW24  NOTK_FP            ;NOT
043374 2F 37 04    0135*          		DW24  RAD_FP             ;RAD
043377 4A 37 04    0136*          		DW24  SGN_FP             ;SGN
04337A 23 38 04    0137*          		DW24  SIN_FP             ;SIN
04337D 92 37 04    0138*          		DW24  SQR_FP             ;SQR
043380 F0 37 04    0139*          		DW24  TAN_FP             ;TAN
043383             0140*  ;
043383 A0 3E 04    0141*  		        DW24  ZERO_FP            ;ZERO
043386 AB 38 04    0142*          		DW24  FONE_FP            ;FONE
043389 EA 36 04    0143*          		DW24  TRUE_FP            ;TRUE
04338C 17 37 04    0144*          		DW24  PI_FP              ;PI
04338F             0145*  ;
04338F 5E 37 04    0146*  		        DW24  VAL_FP             ;VAL
043392 E6 3A 04    0147*          		DW24  STR_FP             ;STR$
043395             0148*  ;
043395 47 3D 04    0149*          		DW24  SFIX_FP            ;FIX
043398 23 3E 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
04339B             0151*  ;
04339B 71 3E 04    0152*  		        DW24  FTEST_FP           ;TEST
04339E 83 3E 04    0153*          		DW24  FCOMP_FP           ;COMPARE
0433A1             0154*  ;
0433A1 D1 33 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0433A4 3F 34 04    0156*          		DW24  FBDIV           ;DIV
0433A7 E4 33 04    0157*          		DW24  FEOR            ;EOR
0433AA 0A 34 04    0158*          		DW24  FMOD            ;MOD
0433AD F7 33 04    0159*          		DW24  FFOR             ;OR
0433B0 C3 36 04    0160*          		DW24  FLE             ;<=
0433B3 D2 36 04    0161*          		DW24  FNE             ;<>
0433B6 B6 36 04    0162*          		DW24  FGE             ;>=
0433B9 9B 36 04    0163*          		DW24  FLT             ;<
0433BC DF 36 04    0164*          		DW24  FEQ             ;=
0433BF 8B 35 04    0165*          		DW24  FMUL            ;*
0433C2 79 34 04    0166*          		DW24  FADD            ;+
0433C5 A8 36 04    0167*          		DW24  FGT             ;>
0433C8 60 34 04    0168*          		DW24  FSUB            ;-
0433CB 68 36 04    0169*          		DW24  FPOW            ;^
0433CE E2 34 04    0170*          		DW24  FDIV            ;/
0433D1             0171*  ;
0433D1             0172*  ;       PAGE
0433D1             0173*  ;
0433D1             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
0433D1             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
0433D1             0176*  ;Output in HLH'L'C
0433D1             0177*  ;All registers except IX, IY destroyed.
0433D1             0178*  ; (N.B. FPOW destroys IX).
0433D1             0179*  ;
0433D1             0180*  ;FAND - Floating-point AND.
0433D1             0181*  ;IAND - Integer AND.
0433D1             0182*  ;
0433D1 CD 3B 3D 04 0183*  FAND:			CALL    FIX2
0433D5 7C          0184*  IAND:			LD      A,H
0433D6 A2          0185*          		AND     D
0433D7 67          0186*          		LD      H,A
0433D8 7D          0187*          		LD      A,L
0433D9 A3          0188*          		AND     E
0433DA 6F          0189*          		LD      L,A
0433DB D9          0190*          		EXX
0433DC 7C          0191*          		LD      A,H
0433DD A2          0192*          		AND     D
0433DE 67          0193*          		LD      H,A
0433DF 7D          0194*          		LD      A,L
0433E0 A3          0195*          		AND     E
0433E1 6F          0196*          		LD      L,A
0433E2 D9          0197*          		EXX
0433E3 C9          0198*          		RET
0433E4             0199*  ;
0433E4             0200*  ;FEOR - Floating-point exclusive-OR.
0433E4             0201*  ;IEOR - Integer exclusive-OR.
0433E4             0202*  ;
0433E4 CD 3B 3D 04 0203*  FEOR:			CALL    FIX2
0433E8 7C          0204*  IEOR:			LD      A,H
0433E9 AA          0205*          		XOR     D
0433EA 67          0206*          		LD      H,A
0433EB 7D          0207*          		LD      A,L
0433EC AB          0208*          		XOR     E
0433ED 6F          0209*          		LD      L,A
0433EE D9          0210*          		EXX
0433EF 7C          0211*          		LD      A,H
0433F0 AA          0212*          		XOR     D
0433F1 67          0213*          		LD      H,A
0433F2 7D          0214*          		LD      A,L
0433F3 AB          0215*          		XOR     E
0433F4 6F          0216*          		LD      L,A
0433F5 D9          0217*          		EXX
0433F6 C9          0218*          		RET
0433F7             0219*  ;
0433F7             0220*  ;FFOR - Floating-point OR.
0433F7             0221*  ;IOR - Integer OR.
0433F7             0222*  ;
0433F7 CD 3B 3D 04 0223*  FFOR:			CALL    FIX2
0433FB 7C          0224*  IOR:			LD      A,H
0433FC B2          0225*          		OR      D
0433FD 67          0226*          		LD      H,A
0433FE 7D          0227*          		LD      A,L
0433FF B3          0228*          		OR      E
043400 6F          0229*          		LD      L,A
043401 D9          0230*          		EXX
043402 7C          0231*          		LD      A,H
043403 B2          0232*          		OR      D
043404 67          0233*          		LD      H,A
043405 7D          0234*          		LD      A,L
043406 B3          0235*          		OR      E
043407 6F          0236*          		LD      L,A
043408 D9          0237*          		EXX
043409 C9          0238*          		RET
04340A             0239*  ;
04340A             0240*  ;FMOD - Floating-point remainder.
04340A             0241*  ;IMOD - Integer remainder.
04340A             0242*  ;
04340A CD 3B 3D 04 0243*  FMOD:			CALL    FIX2
04340E 7C          0244*  IMOD:			LD      A,H
04340F AA          0245*          		XOR     D               ;DIV RESULT SIGN
043410 CB 7C       0246*          		BIT     7,H
043412 08          0247*          		EX      AF,AF'
043413 CB 7C       0248*          		BIT     7,H
043415 C4 57 3D 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
043419 CD 54 3E 04 0250*          		CALL    SWAP_FP
04341D CB 7C       0251*          		BIT     7,H
04341F C4 57 3D 04 0252*          		CALL    NZ,NEGATE
043423 44          0253*          		LD      B,H
043424 4D          0254*          		LD      C,L
043425 21 00 00 00 0255*          		LD      HL,0
043429 D9          0256*          		EXX
04342A 44          0257*          		LD      B,H
04342B 4D          0258*          		LD      C,L
04342C 21 00 00 00 0259*          		LD      HL,0
043430 3E DF       0260*          		LD      A,-33
043432 CD E1 3F 04 0261*          		CALL    DIVA            ;DIVIDE
043436 D9          0262*          		EXX
043437 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
043439 08          0264*          		EX      AF,AF'
04343A C8          0265*          		RET     Z
04343B C3 57 3D 04 0266*          		JP      NEGATE
04343F             0267*  ;
04343F             0268*  ;BDIV - Integer division.
04343F             0269*  ;
04343F CD 3B 3D 04 0270*  FBDIV:			CALL    FIX2
043443 CD 0E 34 04 0271*  IBDIV:			CALL    IMOD
043447 B7          0272*          		OR      A
043448 CD 54 3E 04 0273*          		CALL    SWAP_FP
04344C 0E 00       0274*          		LD      C,0
04344E F0          0275*          		RET     P
04344F C3 57 3D 04 0276*          		JP      NEGATE
043453             0277*  ;
043453             0278*  ;ISUB - Integer subtraction.
043453             0279*  ;FSUB - Floating point subtraction with rounding.
043453             0280*  ;
043453 CD EF 3E 04 0281*  ISUB:			CALL    SUB_
043457 E0          0282*          		RET     PO
043458 CD E7 3E 04 0283*          		CALL    ADD_
04345C CD 17 3E 04 0284*          		CALL    FLOAT2
043460 7A          0285*  FSUB:			LD      A,D
043461 EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
043463 57          0287*          		LD      D,A
043464 18 13       0288*          		JR      FADD
043466             0289*  ;
043466             0290*  ;Reverse subtract.
043466             0291*  ;
043466 7C          0292*  RSUB:			LD      A,H
043467 EE 80       0293*          		XOR     80H
043469 67          0294*          		LD      H,A
04346A 18 0D       0295*          		JR      FADD
04346C             0296*  ;
04346C             0297*  ;IADD - Integer addition.
04346C             0298*  ;FADD - Floating point addition with rounding.
04346C             0299*  ;
04346C CD E7 3E 04 0300*  IADD:			CALL    ADD_
043470 E0          0301*          		RET     PO
043471 CD EF 3E 04 0302*          		CALL    SUB_
043475 CD 17 3E 04 0303*          		CALL    FLOAT2
043479 05          0304*  FADD:			DEC     B
04347A 04          0305*          		INC     B
04347B C8          0306*          		RET     Z               ;ARG 2 ZERO
04347C 0D          0307*          		DEC     C
04347D 0C          0308*          		INC     C
04347E CA 54 3E 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
043482 D9          0310*          		EXX
043483 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
043487 D9          0312*          		EXX
043488 7C          0313*          		LD      A,H
043489 AA          0314*          		XOR     D               ;XOR SIGNS
04348A F5          0315*          		PUSH    AF
04348B 78          0316*          		LD      A,B
04348C B9          0317*          		CP      C               ;COMPARE EXPONENTS
04348D DC 54 3E 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
043491 78          0319*          		LD      A,B
043492 CB FC       0320*          		SET     7,H             ;IMPLIED 1
043494 C4 28 3D 04 0321*          		CALL    NZ,FIX          ;ALIGN
043498 F1          0322*          		POP     AF
043499 7A          0323*          		LD      A,D             ;SIGN OF LARGER
04349A CB FA       0324*          		SET     7,D             ;IMPLIED 1
04349C FA AC 34 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
0434A0 CD E7 3E 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0434A4 DC 5C 3E 04 0327*          		CALL    C,DIV2          ;NORMALISE
0434A8 CB FC       0328*          		SET     7,H
0434AA 18 0D       0329*          		JR      FADD4
0434AC             0330*  ;
0434AC CD EF 3E 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0434B0 DC 6F 3D 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0434B4 CD EE 3D 04 0333*          		CALL    FLO48
0434B8 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
0434B9 D9          0335*  FADD4:			EXX
0434BA EB          0336*          		EX      DE,HL
0434BB 21 00 80 00 0337*          		LD      HL,8000H
0434BF B7          0338*          		OR      A               ;CLEAR CARRY
0434C0 52 ED 42    0339*          		SBC.S   HL,BC
0434C3 EB          0340*          		EX      DE,HL
0434C4 D9          0341*          		EXX
0434C5 CC 4E 3E 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
0434C9 DC 3C 3E 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
0434CD DC 69 3E 04 0344*          		CALL    C,INCC
0434D1 CB BC       0345*          		RES     7,H
0434D3 0D          0346*          		DEC     C
0434D4 0C          0347*          		INC     C
0434D5 CA A0 3E 04 0348*          		JP      Z,ZERO_FP
0434D9 B7          0349*          		OR      A               ;RESULT SIGNQ
0434DA F0          0350*          		RET     P               ;POSITIVE
0434DB CB FC       0351*          		SET     7,H             ;NEGATIVE
0434DD C9          0352*          		RET
0434DE             0353*  ;
0434DE             0354*  ;IDIV - Integer division.
0434DE             0355*  ;FDIV - Floating point division with rounding.
0434DE             0356*  ;
0434DE CD 17 3E 04 0357*  IDIV:			CALL    FLOAT2
0434E2 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
0434E3 04          0359*          		INC     B
0434E4 3E 12       0360*          		LD      A,DIVBY0
0434E6 CA FA 32 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
0434EA 0D          0362*          		DEC     C               ;TEST FOR ZERO
0434EB 0C          0363*          		INC     C
0434EC C8          0364*          		RET     Z
0434ED 7C          0365*          		LD      A,H
0434EE AA          0366*          		XOR     D               ;CALC. RESULT SIGN
0434EF 08          0367*          		EX      AF,AF'          ;SAVE SIGN
0434F0 CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
0434F2 CB FC       0369*          		SET     7,H
0434F4 C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
0434F5 42          0371*          		LD      B,D             ;LOAD REGISTERS
0434F6 4B          0372*          		LD      C,E
0434F7 11 00 00 00 0373*          		LD      DE,0
0434FB D9          0374*          		EXX
0434FC 42          0375*          		LD      B,D
0434FD 4B          0376*          		LD      C,E
0434FE 11 00 00 00 0377*          		LD      DE,0
043502 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
043504 CD E1 3F 04 0379*          		CALL    DIVA            ;DIVIDE
043508 D9          0380*          		EXX
043509 CB 7A       0381*          		BIT     7,D
04350B D9          0382*          		EXX
04350C CC 00 40 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
043510 EB          0384*          		EX      DE,HL
043511 D9          0385*          		EXX
043512 CB 38       0386*          		SRL     B               ;DIVISOR/2
043514 CB 19       0387*          		RR      C
043516 B7          0388*          		OR      A               ;CLEAR CARRY
043517 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
04351A 3F          0390*          		CCF
04351B EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
04351C CC 4E 3E 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
043520 DC 3C 3E 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
043524 C1          0394*          		POP     BC              ;RESTORE EXPONENTS
043525 DC 69 3E 04 0395*          		CALL    C,INCC
043529 1F          0396*          		RRA                     ;LSB OF A TO CARRY
04352A 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
04352B 98          0398*          		SBC     A,B
04352C 3F          0399*          		CCF
04352D C3 CE 35 04 0400*          		JP      CHKOVF
043531             0401*  ;
043531             0402*  ;IMUL - Integer multiplication.
043531             0403*  ;
043531 7C          0404*  IMUL:			LD      A,H
043532 AA          0405*          		XOR     D
043533 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
043534 CB 7C       0407*          		BIT     7,H
043536 C4 57 3D 04 0408*          		CALL    NZ,NEGATE
04353A CD 54 3E 04 0409*          		CALL    SWAP_FP
04353E CB 7C       0410*          		BIT     7,H
043540 C4 57 3D 04 0411*          		CALL    NZ,NEGATE
043544 44          0412*          		LD      B,H
043545 4D          0413*          		LD      C,L
043546 21 00 00 00 0414*          		LD      HL,0
04354A D9          0415*          		EXX
04354B 44          0416*          		LD      B,H
04354C 4D          0417*          		LD      C,L
04354D 21 00 00 00 0418*          		LD      HL,0
043551 3E DF       0419*          		LD      A,-33
043553 CD 18 40 04 0420*          		CALL    MULA            ;MULTIPLY
043557 D9          0421*          		EXX
043558 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
04355A CD 7C 3E 04 0423*          		CALL    TEST_FP            ;TEST RANGE
04355E 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
043560 CB 7A       0425*          		BIT     7,D
043562 20 0B       0426*          		JR      NZ,IMUL1
043564 CD 54 3E 04 0427*          		CALL    SWAP_FP
043568 4A          0428*          		LD      C,D             ;INTEGER MARKER
043569 08          0429*          		EX      AF,AF'
04356A F0          0430*          		RET     P
04356B C3 57 3D 04 0431*          		JP      NEGATE
04356F             0432*  ;
04356F 0D          0433*  IMUL1:			DEC     C
043570 D9          0434*          		EXX
043571 CB 23       0435*          		SLA     E
043573 CB 12       0436*          		RL      D
043575 D9          0437*          		EXX
043576 CB 13       0438*          		RL      E
043578 CB 12       0439*          		RL      D
04357A D9          0440*          		EXX
04357B 52 ED 6A    0441*          		ADC.S   HL,HL
04357E D9          0442*          		EXX
04357F 52 ED 6A    0443*          		ADC.S   HL,HL
043582 F2 6F 35 04 0444*          		JP      P,IMUL1         ;NORMALISE
043586 08          0445*          		EX      AF,AF'
043587 F8          0446*          		RET     M
043588 CB BC       0447*          		RES     7,H             ;POSITIVE
04358A C9          0448*          		RET
04358B             0449*  ;
04358B             0450*  ;FMUL - Floating point multiplication with rounding.
04358B             0451*  ;
04358B 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
04358C 04          0453*          		INC     B
04358D CA A0 3E 04 0454*          		JP      Z,ZERO_FP
043591 0D          0455*          		DEC     C               ;TEST FOR ZERO
043592 0C          0456*          		INC     C
043593 C8          0457*          		RET     Z
043594 7C          0458*          		LD      A,H
043595 AA          0459*          		XOR     D               ;CALC. RESULT SIGN
043596 08          0460*          		EX      AF,AF'
043597 CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
043599 CB FC       0462*          		SET     7,H
04359B C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
04359C 44          0464*          		LD      B,H             ;LOAD REGISTERS
04359D 4D          0465*          		LD      C,L
04359E 21 00 00 00 0466*          		LD      HL,0
0435A2 D9          0467*          		EXX
0435A3 44          0468*          		LD      B,H
0435A4 4D          0469*          		LD      C,L
0435A5 21 00 00 00 0470*          		LD      HL,0
0435A9 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
0435AB CD 18 40 04 0472*          		CALL    MULA            ;MULTIPLY
0435AF DC 2E 40 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
0435B3 D9          0474*          		EXX
0435B4 E5          0475*          		PUSH    HL
0435B5 21 00 80 00 0476*          		LD      HL,8000H
0435B9 B7          0477*          		OR      A               ;CLEAR CARRY
0435BA 52 ED 52    0478*          		SBC.S   HL,DE
0435BD E1          0479*          		POP     HL
0435BE CC 4E 3E 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
0435C2 DC 3C 3E 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
0435C6 C1          0482*          		POP     BC              ;RESTORE EXPONENTS
0435C7 DC 69 3E 04 0483*          		CALL    C,INCC
0435CB 1F          0484*          		RRA                     ;LSB OF A TO CARRY
0435CC 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
0435CD 88          0486*          		ADC     A,B
0435CE 38 06       0487*  CHKOVF:			JR      C,CHKO1
0435D0 F2 A0 3E 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
0435D4 18 04       0489*          		JR      CHKO2
0435D6 FA 6B 3E 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0435DA C6 80       0491*  CHKO2:			ADD     A,80H
0435DC 4F          0492*          		LD      C,A
0435DD CA A0 3E 04 0493*          		JP      Z,ZERO_FP
0435E1 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
0435E2 CB BC       0495*          		RES     7,H
0435E4 F0          0496*          		RET     P
0435E5 CB FC       0497*          		SET     7,H
0435E7 C9          0498*          		RET
0435E8             0499*  ;
0435E8             0500*  ;IPOW - Integer involution.
0435E8             0501*  ;
0435E8 CD 54 3E 04 0502*  IPOW:			CALL    SWAP_FP
0435EC CB 7C       0503*          		BIT     7,H
0435EE F5          0504*          		PUSH    AF              ;SAVE SIGN
0435EF C4 57 3D 04 0505*          		CALL    NZ,NEGATE
0435F3 48          0506*  IPOW0:			LD      C,B
0435F4 06 20       0507*          		LD      B,32            ;LOOP COUNTER
0435F6 CD 0C 3F 04 0508*  IPOW1:			CALL    X2
0435FA 38 08       0509*          		JR      C,IPOW2
0435FC 10 F8       0510*          		DJNZ    IPOW1
0435FE F1          0511*          		POP     AF
0435FF D9          0512*          		EXX
043600 2C          0513*          		INC     L               ;RESULT=1
043601 D9          0514*          		EXX
043602 4C          0515*          		LD      C,H
043603 C9          0516*          		RET
043604             0517*  ;
043604 F1          0518*  IPOW2:			POP     AF
043605 C5          0519*          		PUSH    BC
043606 EB          0520*          		EX      DE,HL
043607 E5          0521*          		PUSH    HL
043608 D9          0522*          		EXX
043609 EB          0523*          		EX      DE,HL
04360A E5          0524*          		PUSH    HL
04360B D9          0525*          		EXX
04360C DD 21 00 00 0526*          		LD      IX,0
       00          
043611 DD 39       0527*          		ADD     IX,SP
043613 28 48       0528*          		JR      Z,IPOW4
043615 C5          0529*          		PUSH    BC
043616 D9          0530*          		EXX
043617 D5          0531*          		PUSH    DE
043618 D9          0532*          		EXX
043619 D5          0533*          		PUSH    DE
04361A CD 23 3E 04 0534*          		CALL    SFLOAT_FP
04361E CD 57 39 04 0535*          		CALL    RECIP
043622 DD 71 04    0536*          		LD      (IX+4),C
043625 D9          0537*          		EXX
043626 DD 75 00    0538*          		LD      (IX+0),L
043629 DD 74 01    0539*          		LD      (IX+1),H
04362C D9          0540*          		EXX
04362D DD 75 02    0541*          		LD      (IX+2),L
043630 DD 74 03    0542*          		LD      (IX+3),H
043633 18 21       0543*          		JR      IPOW5
043635             0544*  ;
043635 C5          0545*  IPOW3:			PUSH    BC
043636 D9          0546*          		EXX
043637 CB 23       0547*          		SLA     E
043639 CB 12       0548*          		RL      D
04363B D5          0549*          		PUSH    DE
04363C D9          0550*          		EXX
04363D CB 13       0551*          		RL      E
04363F CB 12       0552*          		RL      D
043641 D5          0553*          		PUSH    DE
043642 3E 0A       0554*          		LD      A,'*' & 0FH
043644 F5          0555*          		PUSH    AF
043645 CD 20 3F 04 0556*          		CALL    COPY_
043649 CD 00 33 04 0557*          		CALL    OP              ;SQUARE
04364D F1          0558*          		POP     AF
04364E CD 4C 3C 04 0559*          		CALL    DLOAD5
043652 DC 00 33 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
043656 D1          0561*  IPOW5:			POP     DE
043657 D9          0562*          		EXX
043658 D1          0563*          		POP     DE
043659 D9          0564*          		EXX
04365A 79          0565*          		LD      A,C
04365B C1          0566*          		POP     BC
04365C 4F          0567*          		LD      C,A
04365D 10 D6       0568*  IPOW4:			DJNZ    IPOW3
04365F F1          0569*          		POP     AF
043660 F1          0570*          		POP     AF
043661 F1          0571*          		POP     AF
043662 C9          0572*          		RET
043663             0573*  ;
043663 F1          0574*  FPOW0:			POP     AF
043664 F1          0575*          		POP     AF
043665 F1          0576*          		POP     AF
043666 18 8B       0577*          		JR      IPOW0
043668             0578*  ;
043668             0579*  ;FPOW - Floating-point involution.
043668             0580*  ;
043668 CB 7A       0581*  FPOW:			BIT     7,D
04366A F5          0582*          		PUSH    AF
04366B CD 54 3E 04 0583*          		CALL    SWAP_FP
04366F CD 30 3F 04 0584*          		CALL    PUSH5
043673 0D          0585*          		DEC     C
043674 0C          0586*          		INC     C
043675 28 EC       0587*          		JR      Z,FPOW0
043677 3E 9E       0588*          		LD      A,158
043679 B9          0589*          		CP      C
04367A 38 0A       0590*          		JR      C,FPOW1
04367C 3C          0591*          		INC     A
04367D CD 28 3D 04 0592*          		CALL    FIX
043681 08          0593*          		EX      AF,AF'
043682 F2 63 36 04 0594*          		JP      P,FPOW0
043686 CD 54 3E 04 0595*  FPOW1:			CALL    SWAP_FP
04368A CD 74 39 04 0596*          		CALL    LN0
04368E CD 39 3F 04 0597*          		CALL    POP5
043692 F1          0598*          		POP     AF
043693 CD 8B 35 04 0599*          		CALL    FMUL
043697 C3 D6 38 04 0600*          		JP      EXP0
04369B             0601*  ;
04369B             0602*  ;Integer and floating-point compare.
04369B             0603*  ;Result is TRUE (-1) or FALSE (0).
04369B             0604*  ;
04369B CD AA 3E 04 0605*  FLT:			CALL    FCP
04369F 18 04       0606*          		JR      ILT1
0436A1 CD 9C 3E 04 0607*  ILT:			CALL    ICP
0436A5 D0          0608*  ILT1:			RET     NC
0436A6 18 42       0609*          		JR      TRUE_FP
0436A8             0610*  ;
0436A8 CD AA 3E 04 0611*  FGT:			CALL    FCP
0436AC 18 04       0612*          		JR      IGT1
0436AE CD 9C 3E 04 0613*  IGT:			CALL    ICP
0436B2 C8          0614*  IGT1:			RET     Z
0436B3 D8          0615*          		RET     C
0436B4 18 34       0616*          		JR      TRUE_FP
0436B6             0617*  ;
0436B6 CD AA 3E 04 0618*  FGE:			CALL    FCP
0436BA 18 04       0619*          		JR      IGE1
0436BC CD 9C 3E 04 0620*  IGE:			CALL    ICP
0436C0 D8          0621*  IGE1:			RET     C
0436C1 18 27       0622*          		JR      TRUE_FP
0436C3             0623*  ;
0436C3 CD AA 3E 04 0624*  FLE:			CALL    FCP
0436C7 18 04       0625*          		JR      ILE1
0436C9 CD 9C 3E 04 0626*  ILE:			CALL    ICP
0436CD 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
0436CF D0          0628*          		RET     NC
0436D0 18 18       0629*          		JR      TRUE_FP
0436D2             0630*  ;
0436D2 CD AA 3E 04 0631*  FNE:			CALL    FCP
0436D6 18 04       0632*          		JR      INE1
0436D8 CD 9C 3E 04 0633*  INE:			CALL    ICP
0436DC C8          0634*  INE1:			RET     Z
0436DD 18 0B       0635*          		JR      TRUE_FP
0436DF             0636*  ;
0436DF CD AA 3E 04 0637*  FEQ:			CALL    FCP
0436E3 18 04       0638*          		JR      IEQ1
0436E5 CD 9C 3E 04 0639*  IEQ:			CALL    ICP
0436E9 C0          0640*  IEQ1:			RET     NZ
0436EA 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
0436EE D9          0642*          		EXX
0436EF 21 FF FF FF 0643*          		LD      HL,-1
0436F3 D9          0644*          		EXX
0436F4 AF          0645*          		XOR     A
0436F5 4F          0646*          		LD      C,A
0436F6 C9          0647*          		RET
0436F7             0648*  ;
0436F7             0649*  ;FUNCTIONS:
0436F7             0650*  ;
0436F7             0651*  ;Result returned in HLH'L'C (floating point)
0436F7             0652*  ;Result returned in HLH'L' (C=0) (integer)
0436F7             0653*  ;All registers except IY destroyed.
0436F7             0654*  ;
0436F7             0655*  ;ABS - Absolute value
0436F7             0656*  ;Result is numeric, variable type.
0436F7             0657*  ;
0436F7 CB 7C       0658*  ABSV_FP:			BIT     7,H
0436F9 C8          0659*          		RET     Z               ;POSITIVE/ZERO
0436FA 0D          0660*          		DEC     C
0436FB 0C          0661*          		INC     C
0436FC CA 57 3D 04 0662*          		JP      Z,NEGATE        ;INTEGER
043700 CB BC       0663*          		RES     7,H
043702 C9          0664*          		RET
043703             0665*  ;
043703             0666*  ;NOT - Complement integer.
043703             0667*  ;Result is integer numeric.
043703             0668*  ;
043703 CD 47 3D 04 0669*  NOTK_FP:			CALL    SFIX_FP
043707 7C          0670*          		LD      A,H
043708 2F          0671*          		CPL
043709 67          0672*          		LD      H,A
04370A 7D          0673*          		LD      A,L
04370B 2F          0674*          		CPL
04370C 6F          0675*          		LD      L,A
04370D D9          0676*          		EXX
04370E 7C          0677*          		LD      A,H
04370F 2F          0678*          		CPL
043710 67          0679*          		LD      H,A
043711 7D          0680*          		LD      A,L
043712 2F          0681*          		CPL
043713 6F          0682*          		LD      L,A
043714 D9          0683*          		EXX
043715 AF          0684*          		XOR     A               ;NUMERIC MARKER
043716 C9          0685*          		RET
043717             0686*  ;
043717             0687*  ;PI - Return PI (3.141592654)
043717             0688*  ;Result is floating-point numeric.
043717             0689*  ;
043717 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
04371B D9          0691*          		EXX
04371C 21 A2 DA 00 0692*          		LD      HL,0DAA2H
043720 D9          0693*          		EXX
043721 0E 81       0694*          		LD      C,81H
043723 AF          0695*          		XOR     A               ;NUMERIC MARKER
043724 C9          0696*          		RET
043725             0697*  ;
043725             0698*  ;DEG - Convert radians to degrees
043725             0699*  ;Result is floating-point numeric.
043725             0700*  ;
043725 CD 39 37 04 0701*  DEG_FP:			CALL    FPI180
043729 CD 8B 35 04 0702*          		CALL    FMUL
04372D AF          0703*          		XOR     A
04372E C9          0704*          		RET
04372F             0705*  ;
04372F             0706*  ;RAD - Convert degrees to radians
04372F             0707*  ;Result is floating-point numeric.
04372F             0708*  ;
04372F CD 39 37 04 0709*  RAD_FP:			CALL    FPI180
043733 CD E2 34 04 0710*          		CALL    FDIV
043737 AF          0711*          		XOR     A
043738 C9          0712*          		RET
043739             0713*  ;
043739             0714*  ;180/PI
043739             0715*  ;
043739 CD 23 3E 04 0716*  FPI180:			CALL    SFLOAT_FP
04373D 11 2E 65 00 0717*          		LD      DE,652EH
043741 D9          0718*          		EXX
043742 11 D3 E0 00 0719*          		LD      DE,0E0D3H
043746 D9          0720*          		EXX
043747 06 85       0721*          		LD      B,85H
043749 C9          0722*          		RET
04374A             0723*  ;
04374A             0724*  ;SGN - Return -1, 0 or +1
04374A             0725*  ;Result is integer numeric.
04374A             0726*  ;
04374A CD 7C 3E 04 0727*  SGN_FP:			CALL    TEST_FP
04374E B1          0728*          		OR      C
04374F C8          0729*          		RET     Z               ;ZERO
043750 CB 7C       0730*          		BIT     7,H
043752 C2 EA 36 04 0731*          		JP      NZ,TRUE_FP         ;-1
043756 CD A0 3E 04 0732*          		CALL    ZERO_FP
04375A C3 3C 3E 04 0733*          		JP      ADD1_FP            ;1
04375E             0734*  ;
04375E             0735*  ;VAL - Return numeric value of string.
04375E             0736*  ;Input: ASCII string at IX
04375E             0737*  ;Result is variable type numeric.
04375E             0738*  ;
04375E CD BA 40 04 0739*  VAL_FP:			CALL    SIGNQ
043762 F5          0740*          		PUSH    AF
043763 CD 6A 3C 04 0741*          		CALL    CON_FP
043767 F1          0742*          		POP     AF
043768 FE 2D       0743*          		CP      '-'
04376A 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
04376C C0          0745*          		RET     NZ
04376D 0D          0746*          		DEC     C
04376E 0C          0747*          		INC     C
04376F CA 57 3D 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
043773 7C          0749*          		LD      A,H
043774 EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
043776 67          0751*          		LD      H,A
043777 AF          0752*          		XOR     A
043778 C9          0753*          		RET
043779             0754*  ;
043779             0755*  ;INT - Floor function
043779             0756*  ;Result is integer numeric.
043779             0757*  ;
043779 0D          0758*  INT_FP_:			DEC     C
04377A 0C          0759*          		INC     C
04377B C8          0760*          		RET     Z               ;ZERO/INTEGER
04377C 3E 9F       0761*          		LD      A,159
04377E 44          0762*          		LD      B,H             ;B7=SIGN BIT
04377F CD 28 3D 04 0763*          		CALL    FIX
043783 08          0764*          		EX      AF,AF'
043784 A0          0765*          		AND     B
043785 FC 3C 3E 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
043789 78          0767*          		LD      A,B
04378A B7          0768*          		OR      A
04378B FC 57 3D 04 0769*          		CALL    M,NEGATE
04378F AF          0770*          		XOR     A
043790 4F          0771*          		LD      C,A
043791 C9          0772*          		RET
043792             0773*  ;
043792             0774*  ;SQR - square root
043792             0775*  ;Result is floating-point numeric.
043792             0776*  ;
043792 CD 23 3E 04 0777*  SQR_FP:			CALL    SFLOAT_FP
043796 CB 7C       0778*  SQR0:			BIT     7,H
043798 3E 15       0779*          		LD      A,NGROOT
04379A C2 FA 32 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
04379E 0D          0781*          		DEC     C
04379F 0C          0782*          		INC     C
0437A0 C8          0783*          		RET     Z               ;ZERO
0437A1 CB FC       0784*          		SET     7,H             ;IMPLIED 1
0437A3 CB 41       0785*          		BIT     0,C
0437A5 CC 5C 3E 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0437A9 79          0787*          		LD      A,C
0437AA D6 80       0788*          		SUB     80H
0437AC CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
0437AE C6 80       0790*          		ADD     A,80H
0437B0 4F          0791*          		LD      C,A
0437B1 C5          0792*          		PUSH    BC              ;SAVE EXPONENT
0437B2 EB          0793*          		EX      DE,HL
0437B3 21 00 00 00 0794*          		LD      HL,0
0437B7 44          0795*          		LD      B,H
0437B8 4D          0796*          		LD      C,L
0437B9 D9          0797*          		EXX
0437BA EB          0798*          		EX      DE,HL
0437BB 21 00 00 00 0799*          		LD      HL,0
0437BF 44          0800*          		LD      B,H
0437C0 4D          0801*          		LD      C,L
0437C1 3E E1       0802*          		LD      A,-31
0437C3 CD 52 40 04 0803*          		CALL    SQRA            ;ROOT
0437C7 D9          0804*          		EXX
0437C8 CB 78       0805*          		BIT     7,B
0437CA D9          0806*          		EXX
0437CB CC 52 40 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
0437CF CD 93 40 04 0808*          		CALL    SQRB
0437D3 B7          0809*          		OR      A               ;CLEAR CARRY
0437D4 CD 00 40 04 0810*          		CALL    DIVB
0437D8 CB 1B       0811*          		RR      E               ;LSB TO CARRY
0437DA 60          0812*          		LD      H,B
0437DB 69          0813*          		LD      L,C
0437DC D9          0814*          		EXX
0437DD 60          0815*          		LD      H,B
0437DE 69          0816*          		LD      L,C
0437DF DC 3C 3E 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
0437E3 C1          0818*          		POP     BC              ;RESTORE EXPONENT
0437E4 DC 69 3E 04 0819*          		CALL    C,INCC
0437E8 1F          0820*          		RRA
0437E9 9F          0821*          		SBC     A,A
0437EA 81          0822*          		ADD     A,C
0437EB 4F          0823*          		LD      C,A
0437EC CB BC       0824*          		RES     7,H             ;POSITIVE
0437EE AF          0825*          		XOR     A
0437EF C9          0826*          		RET
0437F0             0827*  ;
0437F0             0828*  ;TAN - Tangent function
0437F0             0829*  ;Result is floating-point numeric.
0437F0             0830*  ;
0437F0 CD 23 3E 04 0831*  TAN_FP:			CALL    SFLOAT_FP
0437F4 CD 30 3F 04 0832*          		CALL    PUSH5
0437F8 CD 1A 38 04 0833*          		CALL    COS0
0437FC CD 39 3F 04 0834*          		CALL    POP5
043800 CD 30 3F 04 0835*          		CALL    PUSH5
043804 CD 54 3E 04 0836*          		CALL    SWAP_FP
043808 CD 27 38 04 0837*          		CALL    SIN0
04380C CD 39 3F 04 0838*          		CALL    POP5
043810 CD E2 34 04 0839*          		CALL    FDIV
043814 AF          0840*          		XOR     A               ;NUMERIC MARKER
043815 C9          0841*          		RET
043816             0842*  ;
043816             0843*  ;COS - Cosine function
043816             0844*  ;Result is floating-point numeric.
043816             0845*  ;
043816 CD 23 3E 04 0846*  COS_FP:			CALL    SFLOAT_FP
04381A CD 7F 3D 04 0847*  COS0:			CALL    SCALE
04381E 1C          0848*          		INC     E
04381F 1C          0849*          		INC     E
043820 7B          0850*          		LD      A,E
043821 18 10       0851*          		JR      SIN1
043823             0852*  ;
043823             0853*  ;SIN - Sine function
043823             0854*  ;Result is floating-point numeric.
043823             0855*  ;
043823 CD 23 3E 04 0856*  SIN_FP:			CALL    SFLOAT_FP
043827 E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
043828 CD 7F 3D 04 0858*          		CALL    SCALE
04382C F1          0859*          		POP     AF
04382D 07          0860*          		RLCA
04382E 07          0861*          		RLCA
04382F 07          0862*          		RLCA
043830 E6 04       0863*          		AND     4
043832 AB          0864*          		XOR     E
043833 F5          0865*  SIN1:			PUSH    AF              ;OCTANT
043834 CB BC       0866*          		RES     7,H
043836 1F          0867*          		RRA
043837 CD C5 38 04 0868*          		CALL    PIBY4
04383B DC 66 34 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
04383F F1          0870*          		POP     AF
043840 F5          0871*          		PUSH    AF
043841 E6 03       0872*          		AND     3
043843 E2 7C 38 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
043847 CD 30 3F 04 0874*          		CALL    PUSH5           ;SAVE X
04384B CD 28 3F 04 0875*          		CALL    SQUARE          ;PUSH X*X
04384F CD 6D 3F 04 0876*          		CALL    POLY
043853 B7 A8       0877*          		DW	0A8B7H          ;a(8)
043855 11 36       0878*          		DW	3611H
043857 6D          0879*          		DB	6DH
043858 26 DE       0880*          		DW	0DE26H          ;a(6)
04385A 05 D0       0881*          		DW	0D005H
04385C 73          0882*          		DB	73H
04385D C0 80       0883*          		DW	80C0H           ;a(4)
04385F 88 08       0884*          		DW	888H
043861 79          0885*          		DB	79H
043862 9D AA       0886*          		DW	0AA9DH          ;a(2)
043864 AA AA       0887*          		DW	0AAAAH
043866 7D          0888*          		DB	7DH
043867 00 00       0889*          		DW	0               ;a(0)
043869 00 00       0890*          		DW	0
04386B 80          0891*          		DB	80H
04386C CD 39 3F 04 0892*          		CALL    POP5
043870 CD 39 3F 04 0893*          		CALL    POP5
043874 CD 8B 35 04 0894*          		CALL    FMUL
043878 C3 A1 38 04 0895*          		JP      SIN3
04387C             0896*  ;
04387C CD 28 3F 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
043880 CD 6D 3F 04 0898*          		CALL    POLY
043884 71 D5       0899*          		DW	0D571H          ;b(8)
043886 78 4C       0900*          		DW	4C78H
043888 70          0901*          		DB	70H
043889 AF 94       0902*          		DW	94AFH           ;b(6)
04388B 03 B6       0903*          		DW	0B603H
04388D 76          0904*          		DB	76H
04388E C8 9C       0905*          		DW	9CC8H           ;b(4)
043890 AA 2A       0906*          		DW	2AAAH
043892 7B          0907*          		DB	7BH
043893 DD FF       0908*          		DW	0FFDDH          ;b(2)
043895 FF FF       0909*          		DW	0FFFFH
043897 7E          0910*          		DB	7EH
043898 00 00       0911*          		DW	0               ;b(0)
04389A 00 00       0912*          		DW	0
04389C 80          0913*          		DB	80H
04389D CD 39 3F 04 0914*          		CALL    POP5
0438A1 F1          0915*  SIN3:			POP     AF
0438A2 E6 04       0916*          		AND     4
0438A4 C8          0917*          		RET     Z
0438A5 0D          0918*          		DEC     C
0438A6 0C          0919*          		INC     C
0438A7 C8          0920*          		RET     Z               ;ZERO
0438A8 CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
0438AA C9          0922*          		RET
0438AB             0923*  ;
0438AB             0924*  ;Floating-point one:
0438AB             0925*  ;
0438AB 21 00 00 00 0926*  FONE_FP:			LD      HL,0
0438AF D9          0927*          		EXX
0438B0 21 00 00 00 0928*          		LD      HL,0
0438B4 D9          0929*          		EXX
0438B5 0E 80       0930*          		LD      C,80H
0438B7 C9          0931*          		RET
0438B8             0932*  ;
0438B8 11 00 00 00 0933*  DONE:			LD      DE,0
0438BC D9          0934*          		EXX
0438BD 11 00 00 00 0935*          		LD      DE,0
0438C1 D9          0936*          		EXX
0438C2 06 80       0937*          		LD      B,80H
0438C4 C9          0938*          		RET
0438C5             0939*  ;
0438C5 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
0438C9 D9          0941*          		EXX
0438CA 11 A2 DA 00 0942*          		LD      DE,0DAA2H
0438CE D9          0943*          		EXX
0438CF 06 7F       0944*          		LD      B,7FH
0438D1 C9          0945*          		RET
0438D2             0946*  ;
0438D2             0947*  ;EXP - Exponential function
0438D2             0948*  ;Result is floating-point numeric.
0438D2             0949*  ;
0438D2 CD 23 3E 04 0950*  EXP_FP:			CALL    SFLOAT_FP
0438D6 CD 63 39 04 0951*  EXP0:			CALL    LN2             ;LN(2)
0438DA D9          0952*          		EXX
0438DB 1D          0953*  	        	DEC     E
0438DC 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
0438E0 D9          0955*          		EXX
0438E1 E5          0956*          		PUSH    HL              ;H7=SIGN
0438E2 CD 92 3D 04 0957*          		CALL    MOD48           ;"MODULUS"
0438E6 F1          0958*          		POP     AF
0438E7 CB 7B       0959*          		BIT     7,E
0438E9 28 0B       0960*          		JR      Z,EXP1
0438EB 17          0961*          		RLA
0438EC DA A0 3E 04 0962*          		JP      C,ZERO_FP
0438F0 3E 18       0963*          		LD      A,EXPRNG
0438F2 C3 FA 32 04 0964*          		JP      ERROR_FP_           ;"Exp range"
0438F6             0965*  ;
0438F6 E6 80       0966*  EXP1:			AND     80H
0438F8 B3          0967*          		OR      E
0438F9 F5          0968*          		PUSH    AF              ;INTEGER PART
0438FA CB BC       0969*          		RES     7,H
0438FC CD 30 3F 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
043900 CD 6D 3F 04 0971*          		CALL    POLY
043904 72 40       0972*          		DW	4072H           ;a(7)
043906 2E 94       0973*          		DW	942EH
043908 73          0974*          		DB	73H
043909 65 6F       0975*          		DW	6F65H           ;a(6)
04390B 4F 2E       0976*          		DW	2E4FH
04390D 76          0977*          		DB	76H
04390E 37 6D       0978*          		DW	6D37H           ;a(5)
043910 02 88       0979*          		DW	8802H
043912 79          0980*          		DB	79H
043913 12 E5       0981*          		DW	0E512H          ;a(4)
043915 A0 2A       0982*          		DW	2AA0H
043917 7B          0983*          		DB	7BH
043918 14 4F       0984*          		DW	4F14H           ;a(3)
04391A AA AA       0985*          		DW	0AAAAH
04391C 7D          0986*          		DB	7DH
04391D 56 FD       0987*          		DW	0FD56H          ;a(2)
04391F FF 7F       0988*          		DW	7FFFH
043921 7E          0989*          		DB	7EH
043922 FE FF       0990*          		DW	0FFFEH          ;a(1)
043924 FF FF       0991*          		DW	0FFFFH
043926 7F          0992*          		DB	7FH
043927 00 00       0993*          		DW	0               ;a(0)
043929 00 00       0994*          		DW	0
04392B 80          0995*          		DB	80H
04392C CD 39 3F 04 0996*          		CALL    POP5
043930 F1          0997*          		POP     AF
043931 F5          0998*          		PUSH    AF
043932 F4 57 39 04 0999*          		CALL    P,RECIP         ;X=1/X
043936 F1          1000*          		POP     AF
043937 F2 3F 39 04 1001*          		JP      P,EXP4
04393B E6 7F       1002*          		AND     7FH
04393D ED 44       1003*          		NEG
04393F C6 80       1004*  EXP4:			ADD     A,80H
043941 81          1005*          		ADD     A,C
043942 38 06       1006*          		JR      C,EXP2
043944 F2 A0 3E 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
043948 18 04       1008*          		JR      EXP3
04394A FA 6B 3E 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
04394E C6 80       1010*  EXP3:			ADD     A,80H
043950 CA A0 3E 04 1011*          		JP      Z,ZERO_FP
043954 4F          1012*          		LD      C,A
043955 AF          1013*          		XOR     A               ;NUMERIC MARKER
043956 C9          1014*          		RET
043957             1015*  ;
043957 CD B8 38 04 1016*  RECIP:			CALL    DONE
04395B CD 54 3E 04 1017*  RDIV:			CALL    SWAP_FP
04395F C3 E2 34 04 1018*          		JP      FDIV            ;RECIPROCAL
043963             1019*  ;
043963 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
043967 D9          1021*          		EXX
043968 11 F8 17 00 1022*          		LD      DE,17F8H
04396C D9          1023*          		EXX
04396D 06 7F       1024*          		LD      B,7FH
04396F C9          1025*          		RET
043970             1026*  ;
043970             1027*  ;LN - Natural log.
043970             1028*  ;Result is floating-point numeric.
043970             1029*  ;
043970 CD 23 3E 04 1030*  LN_FP:			CALL    SFLOAT_FP
043974 3E 16       1031*  LN0:			LD      A,LOGRNG
043976 CB 7C       1032*          		BIT     7,H
043978 C2 FA 32 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
04397C 0C          1034*          		INC     C
04397D 0D          1035*          		DEC     C
04397E CA FA 32 04 1036*          		JP      Z,ERROR_FP_
043982 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
043986 D9          1038*          		EXX
043987 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
04398B D9          1040*          		EXX
04398C CD B3 3E 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
043990 79          1042*          		LD      A,C             ;EXPONENT
043991 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
043993 38 02       1044*          		JR      C,LN4
043995 0D          1045*          		DEC     C
043996 3C          1046*          		INC     A
043997 F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
043998 CD 45 3F 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
04399C CD 30 3F 04 1049*          		CALL    PUSH5
0439A0 CD 28 3F 04 1050*  		        CALL    SQUARE          ;PUSH X*X
0439A4 CD 6D 3F 04 1051*          		CALL    POLY
0439A8 48 CC       1052*          		DW	0CC48H          ;a(9)
0439AA FB 74       1053*          		DW	74FBH
0439AC 7D          1054*          		DB	7DH
0439AD AF AE       1055*          		DW	0AEAFH          ;a(7)
0439AF FF 11       1056*          		DW	11FFH
0439B1 7E          1057*          		DB	7EH
0439B2 8C D9       1058*          		DW	0D98CH          ;a(5)
0439B4 CD 4C       1059*          		DW	4CCDH
0439B6 7E          1060*          		DB	7EH
0439B7 E3 A9       1061*          		DW	0A9E3H          ;a(3)
0439B9 AA 2A       1062*          		DW	2AAAH
0439BB 7F          1063*          		DB	7FH
0439BC 00 00       1064*          		DW	0               ;a(1)
0439BE 00 00       1065*          		DW	0
0439C0 81          1066*          		DB	81H
0439C1 CD 39 3F 04 1067*          		CALL    POP5
0439C5 CD 39 3F 04 1068*          		CALL    POP5
0439C9 CD 8B 35 04 1069*          		CALL    FMUL
0439CD F1          1070*          		POP     AF              ;EXPONENT
0439CE CD 30 3F 04 1071*          		CALL    PUSH5
0439D2 08          1072*          		EX      AF,AF'
0439D3 CD A0 3E 04 1073*          		CALL    ZERO_FP
0439D7 08          1074*          		EX      AF,AF'
0439D8 D6 80       1075*          		SUB     80H
0439DA 28 1F       1076*          		JR      Z,LN3
0439DC 30 02       1077*          		JR      NC,LN1
0439DE 2F          1078*          		CPL
0439DF 3C          1079*          		INC     A
0439E0 67          1080*  LN1:			LD      H,A
0439E1 0E 87       1081*          		LD      C,87H
0439E3 F5          1082*          		PUSH    AF
0439E4 CD 03 3E 04 1083*          		CALL    FLOAT_
0439E8 CB BC       1084*          		RES     7,H
0439EA CD 63 39 04 1085*          		CALL    LN2
0439EE CD 8B 35 04 1086*          		CALL    FMUL
0439F2 F1          1087*          		POP     AF
0439F3 30 06       1088*          		JR      NC,LN3
0439F5 FA FB 39 04 1089*          		JP      M,LN3
0439F9 CB FC       1090*          		SET     7,H
0439FB CD 39 3F 04 1091*  LN3:			CALL    POP5
0439FF CD 79 34 04 1092*          		CALL    FADD
043A03 AF          1093*          		XOR     A
043A04 C9          1094*          		RET
043A05             1095*  ;
043A05             1096*  ;LOG - base-10 logarithm.
043A05             1097*  ;Result is floating-point numeric.
043A05             1098*  ;
043A05 CD 70 39 04 1099*  LOG_FP:			CALL    LN_FP
043A09 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
043A0D D9          1101*          		EXX
043A0E 11 A9 D8 00 1102*          		LD      DE,0D8A9H
043A12 D9          1103*          		EXX
043A13 06 7E       1104*          		LD      B,7EH
043A15 CD 8B 35 04 1105*          		CALL    FMUL
043A19 AF          1106*          		XOR     A
043A1A C9          1107*          		RET
043A1B             1108*  ;
043A1B             1109*  ;ASN - Arc-sine
043A1B             1110*  ;Result is floating-point numeric.
043A1B             1111*  ;
043A1B CD 23 3E 04 1112*  ASN_FP:			CALL    SFLOAT_FP
043A1F CD 30 3F 04 1113*          		CALL    PUSH5
043A23 CD 20 3F 04 1114*          		CALL    COPY_
043A27 CD 8B 35 04 1115*          		CALL    FMUL
043A2B CD B8 38 04 1116*          		CALL    DONE
043A2F CD 66 34 04 1117*          		CALL    RSUB
043A33 CD 96 37 04 1118*          		CALL    SQR0
043A37 CD 39 3F 04 1119*          		CALL    POP5
043A3B 0C          1120*          		INC     C
043A3C 0D          1121*          		DEC     C
043A3D 3E 02       1122*          		LD      A,2
043A3F D5          1123*          		PUSH    DE
043A40 CA C5 3A 04 1124*          		JP      Z,ACS1
043A44 D1          1125*          		POP     DE
043A45 CD 5B 39 04 1126*          		CALL    RDIV
043A49 18 04       1127*          		JR      ATN0
043A4B             1128*  ;
043A4B             1129*  ;ATN - arc-tangent
043A4B             1130*  ;Result is floating-point numeric.
043A4B             1131*  ;
043A4B CD 23 3E 04 1132*  ATN_FP:			CALL    SFLOAT_FP
043A4F E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
043A50 CB BC       1134*          		RES     7,H
043A52 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
043A56 D9          1136*          		EXX
043A57 11 D0 CC 00 1137*          		LD      DE,0CCD0H
043A5B D9          1138*          		EXX
043A5C 06 7E       1139*          		LD      B,7EH
043A5E CD B0 3E 04 1140*          		CALL    FCP0            ;COMPARE
043A62 06 00       1141*          		LD      B,0
043A64 38 22       1142*          		JR      C,ATN2
043A66 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
043A6A D9          1144*          		EXX
043A6B 11 9A 79 00 1145*          		LD      DE,799AH
043A6F D9          1146*          		EXX
043A70 06 81       1147*          		LD      B,81H
043A72 CD B0 3E 04 1148*          		CALL    FCP0            ;COMPARE
043A76 38 0A       1149*          		JR      C,ATN1
043A78 CD 57 39 04 1150*          		CALL    RECIP           ;X=1/X
043A7C 06 02       1151*          		LD      B,2
043A7E C3 88 3A 04 1152*          		JP      ATN2
043A82 CD 45 3F 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
043A86 06 01       1154*          		LD      B,1
043A88 C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
043A89 CD 30 3F 04 1156*          		CALL    PUSH5
043A8D CD 28 3F 04 1157*          		CALL    SQUARE          ;PUSH X*X
043A91 CD 6D 3F 04 1158*          		CALL    POLY
043A95 35 F3       1159*          		DW	0F335H          ;a(13)
043A97 D8 37       1160*          		DW	37D8H
043A99 7B          1161*          		DB	7BH
043A9A 91 6B       1162*          		DW	6B91H           ;a(11)
043A9C B9 AA       1163*          		DW	0AAB9H
043A9E 7C          1164*          		DB	7CH
043A9F DE 41       1165*          		DW	41DEH           ;a(9)
043AA1 97 61       1166*          		DW	6197H
043AA3 7C          1167*          		DB	7CH
043AA4 7B 9D       1168*          		DW	9D7BH           ;a(7)
043AA6 37 92       1169*          		DW	9237H
043AA8 7D          1170*          		DB	7DH
043AA9 5A 2A       1171*          		DW	2A5AH           ;a(5)
043AAB CC 4C       1172*          		DW	4CCCH
043AAD 7D          1173*          		DB	7DH
043AAE 5C A9       1174*          		DW	0A95CH          ;a(3)
043AB0 AA AA       1175*          		DW	0AAAAH
043AB2 7E          1176*          		DB	7EH
043AB3 00 00       1177*          		DW	0               ;a(1)
043AB5 00 00       1178*          		DW	0
043AB7 80          1179*          		DB	80H
043AB8 CD 39 3F 04 1180*          		CALL    POP5
043ABC CD 39 3F 04 1181*          		CALL    POP5
043AC0 CD 8B 35 04 1182*          		CALL    FMUL
043AC4 F1          1183*          		POP     AF
043AC5 CD C5 38 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
043AC9 1F          1185*          		RRA
043ACA F5          1186*          		PUSH    AF
043ACB DC 79 34 04 1187*          		CALL    C,FADD
043ACF F1          1188*          		POP     AF
043AD0 04          1189*          		INC     B
043AD1 1F          1190*          		RRA
043AD2 DC 66 34 04 1191*          		CALL    C,RSUB
043AD6 F1          1192*          		POP     AF
043AD7 B7          1193*          		OR      A
043AD8 F0          1194*          		RET     P
043AD9 CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
043ADB AF          1196*          		XOR     A
043ADC C9          1197*          		RET
043ADD             1198*  ;
043ADD             1199*  ;ACS - Arc cosine=PI/2-ASN.
043ADD             1200*  ;Result is floating point numeric.
043ADD             1201*  ;
043ADD CD 1B 3A 04 1202*  ACS_FP:			CALL    ASN_FP
043AE1 3E 02       1203*          		LD      A,2
043AE3 F5          1204*          		PUSH    AF
043AE4 18 DF       1205*          		JR      ACS1
043AE6             1206*  ;
043AE6             1207*  ;Function STR - convert numeric value to ASCII string.
043AE6             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
043AE6             1209*  ;           DE = address at which to store string
043AE6             1210*  ;           IX = address of @% format control
043AE6             1211*  ;  Outputs: String stored, with NUL terminator
043AE6             1212*  ;
043AE6             1213*  ;First normalise for decimal output:
043AE6             1214*  ;
043AE6 CD 23 3E 04 1215*  STR_FP:			CALL    SFLOAT_FP
043AEA 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
043AEC CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
043AEE 28 06       1218*          		JR      Z,STR10
043AF0 CB BC       1219*          		RES     7,H
043AF2 3E 2D       1220*          		LD      A,'-'
043AF4 12          1221*          		LD      (DE),A          ;STORE SIGN
043AF5 13          1222*          		INC     DE
043AF6 AF          1223*  STR10:			XOR     A               ;CLEAR A
043AF7 B9          1224*          		CP      C
043AF8 28 4E       1225*          		JR      Z,STR02          ;ZERO
043AFA D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
043AFB 78          1227*          		LD      A,B
043AFC F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
043AFD 79          1229*          		LD      A,C             ;BINARY EXPONENT
043AFE FE A1       1230*          		CP      161
043B00 30 1C       1231*          		JR      NC,STR14
043B02 FE 9B       1232*          		CP      155
043B04 30 29       1233*          		JR      NC,STR15
043B06 2F          1234*          		CPL
043B07 FE E1       1235*          		CP      225
043B09 38 02       1236*          		JR      C,STR13
043B0B 3E F8       1237*          		LD      A,-8
043B0D C6 1C       1238*  STR13:			ADD     A,28
043B0F CD 9C 3F 04 1239*          		CALL    POWR10
043B13 F5          1240*          		PUSH    AF
043B14 CD 8B 35 04 1241*          		CALL    FMUL
043B18 F1          1242*          		POP     AF
043B19 47          1243*          		LD      B,A
043B1A F1          1244*          		POP     AF
043B1B 90          1245*          		SUB     B
043B1C 18 DE       1246*          		JR      STR11
043B1E D6 20       1247*  STR14:			SUB     32
043B20 CD 9C 3F 04 1248*          		CALL    POWR10
043B24 F5          1249*          		PUSH    AF
043B25 CD E2 34 04 1250*          		CALL    FDIV
043B29 F1          1251*          		POP     AF
043B2A 47          1252*          		LD      B,A
043B2B F1          1253*          		POP     AF
043B2C 80          1254*          		ADD     A,B
043B2D 18 CD       1255*          		JR      STR11
043B2F 3E 09       1256*  STR15:			LD      A,9
043B31 CD 9C 3F 04 1257*          		CALL    POWR10          ;10^9
043B35 CD B0 3E 04 1258*          		CALL    FCP0
043B39 79          1259*          		LD      A,C
043B3A C1          1260*          		POP     BC
043B3B 4F          1261*          		LD      C,A
043B3C CB FC       1262*          		SET     7,H             ;IMPLIED 1
043B3E DC D8 3E 04 1263*          		CALL    C,X10B          ;X10, DEC B
043B42 D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
043B43 CB B9       1265*          		RES     7,C
043B45 3E 00       1266*          		LD      A,0
043B47 17          1267*          		RLA                     ;PUT CARRY IN LSB
043B48             1268*  ;
043B48             1269*  ;At this point decimal normalisation has been done,
043B48             1270*  ;now convert to decimal digits:
043B48             1271*  ;      AHLH'L' = number in normalised integer form
043B48             1272*  ;            B = decimal place adjustment
043B48             1273*  ;            C = binary place adjustment (29-33)
043B48             1274*  ;
043B48 0C          1275*  STR02:			INC     C
043B49 08          1276*          		EX      AF,AF'          ;SAVE A
043B4A 78          1277*          		LD      A,B
043B4B DD CB 02 4E 1278*          		BIT     1,(IX+2)
043B4F 20 08       1279*          		JR      NZ,STR20
043B51 AF          1280*          		XOR     A
043B52 DD BE 01    1281*          		CP      (IX+1)
043B55 28 0B       1282*          		JR      Z,STR21
043B57 3E F6       1283*          		LD      A,-10
043B59 DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
043B5C B7          1285*          		OR      A               ;CLEAR CARRY
043B5D FA 62 3B 04 1286*          		JP      M,STR21
043B61 AF          1287*          		XOR     A
043B62 F5          1288*  STR21:			PUSH    AF
043B63 08          1289*          		EX      AF,AF'          ;RESTORE A
043B64 CD 0C 3F 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
043B68 8F          1291*          		ADC     A,A
043B69 FE 0A       1292*          		CP      10
043B6B 38 05       1293*          		JR      C,STR23
043B6D D6 0A       1294*          		SUB     10
043B6F D9          1295*          		EXX
043B70 2C          1296*          		INC     L               ;SET RESULT BIT
043B71 D9          1297*          		EXX
043B72 0D          1298*  STR23:			DEC     C
043B73 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
043B75 4F          1300*          		LD      C,A             ;REMAINDER
043B76 7C          1301*          		LD      A,H
043B77 E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
043B79 67          1303*          		LD      H,A
043B7A F1          1304*          		POP     AF
043B7B F2 89 3B 04 1305*          		JP      P,STR24
043B7F 3C          1306*          		INC     A
043B80 20 1C       1307*          		JR      NZ,STR26
043B82 3E 04       1308*          		LD      A,4
043B84 B9          1309*          		CP      C               ;ROUND UP?
043B85 3E 00       1310*          		LD      A,0
043B87 18 15       1311*          		JR      STR26
043B89 F5          1312*  STR24:			PUSH    AF
043B8A 79          1313*          		LD      A,C
043B8B CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
043B8D FE 30       1315*          		CP      '0'
043B8F 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
043B91 FE 3A       1317*          		CP      '9'+1
043B93 3F          1318*          		CCF
043B94 30 08       1319*          		JR      NC,STR26
043B96 E3          1320*  STR25:			EX      (SP),HL
043B97 CB 75       1321*          		BIT     6,L             ;ZERO FLAG
043B99 E3          1322*  		        EX      (SP),HL
043B9A 20 05       1323*          		JR      NZ,STR27
043B9C 3E 30       1324*          		LD      A,'0'
043B9E 3C          1325*  STR26:			INC     A               ;SET +VE
043B9F 3D          1326*          		DEC     A
043BA0 F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
043BA1 04          1328*  STR27:			INC     B
043BA2 CD 7C 3E 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
043BA6 0E 20       1330*          		LD      C,32
043BA8 3E 00       1331*          		LD      A,0
043BAA 20 B8       1332*          		JR      NZ,STR22
043BAC F1          1333*          		POP     AF
043BAD F5          1334*          		PUSH    AF
043BAE 3E 00       1335*          		LD      A,0
043BB0 38 B2       1336*          		JR      C,STR22
043BB2             1337*  ;
043BB2             1338*  ;At this point, the decimal character string is stored
043BB2             1339*  ; on the stack. Trailing zeroes are suppressed and may
043BB2             1340*  ; need to be replaced.
043BB2             1341*  ;B register holds decimal point position.
043BB2             1342*  ;Now format number and store as ASCII string:
043BB2             1343*  ;
043BB2 EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
043BB3 0E FF       1345*          		LD      C,-1            ;FLAG "E"
043BB5 16 01       1346*          		LD      D,1
043BB7 DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
043BBA DD CB 02 46 1348*          		BIT     0,(IX+2)
043BBE 20 35       1349*          		JR      NZ,STR34        ;E MODE
043BC0 DD CB 02 4E 1350*          		BIT     1,(IX+2)
043BC4 28 12       1351*          		JR      Z,STR31
043BC6 78          1352*          		LD      A,B             ;F MODE
043BC7 B7          1353*          		OR      A
043BC8 28 05       1354*          		JR      Z,STR30
043BCA FA CF 3B 04 1355*          		JP      M,STR30
043BCE 50          1356*          		LD      D,B
043BCF 7A          1357*  STR30:			LD      A,D
043BD0 DD 86 01    1358*          		ADD     A,(IX+1)
043BD3 5F          1359*          		LD      E,A
043BD4 FE 0B       1360*          		CP      11
043BD6 38 19       1361*          		JR      C,STR32
043BD8 78          1362*  STR31:			LD      A,B             ;G MODE
043BD9 11 01 01 00 1363*          		LD      DE,101H
043BDD B7          1364*          		OR      A
043BDE FA F5 3B 04 1365*          		JP      M,STR34
043BE2 28 0D       1366*          		JR      Z,STR32
043BE4 DD 7E 01    1367*          		LD      A,(IX+1)
043BE7 B7          1368*          		OR      A
043BE8 20 02       1369*          		JR      NZ,STR3A
043BEA 3E 0A       1370*          		LD      A,10
043BEC B8          1371*  STR3A:			CP      B
043BED 38 06       1372*          		JR      C,STR34
043BEF 50          1373*          		LD      D,B
043BF0 58          1374*          		LD      E,B
043BF1 78          1375*  STR32:			LD      A,B
043BF2 C6 81       1376*          		ADD     A,129
043BF4 4F          1377*          		LD      C,A
043BF5 CB FA       1378*  STR34:			SET     7,D
043BF7 1D          1379*          		DEC     E
043BF8 7A          1380*  STR35:			LD      A,D
043BF9 B9          1381*          		CP      C
043BFA 30 0E       1382*          		JR      NC,STR33
043BFC F1          1383*  STR36:			POP     AF
043BFD 28 04       1384*          		JR      Z,STR37
043BFF F2 0C 3C 04 1385*          		JP      P,STR38
043C03 F5          1386*  STR37:			PUSH    AF
043C04 1C          1387*          		INC     E
043C05 1D          1388*          		DEC     E
043C06 FA 1D 3C 04 1389*          		JP      M,STR4
043C0A 3E 30       1390*  STR33:			LD      A,'0'
043C0C 15          1391*  STR38:			DEC     D
043C0D E2 14 3C 04 1392*          		JP      PO,STR39
043C11 36 2E       1393*          		LD      (HL),'.'
043C13 23          1394*          		INC     HL
043C14 77          1395*  STR39:			LD      (HL),A
043C15 23          1396*          		INC     HL
043C16 1D          1397*          		DEC     E
043C17 F2 F8 3B 04 1398*          		JP      P,STR35
043C1B 18 DF       1399*          		JR      STR36
043C1D             1400*  ;
043C1D F1          1401*  STR4:			POP     AF
043C1E 0C          1402*  STR40:			INC     C
043C1F 4D          1403*          		LD      C,L
043C20 20 28       1404*          		JR      NZ,STR44
043C22 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
043C24 23          1406*          		INC     HL
043C25 78          1407*          		LD      A,B
043C26 3D          1408*          		DEC     A
043C27 F2 30 3C 04 1409*          		JP      P,STR41
043C2B 36 2D       1410*          		LD      (HL),'-'
043C2D 23          1411*          		INC     HL
043C2E ED 44       1412*          		NEG
043C30 36 30       1413*  STR41:			LD      (HL),'0'
043C32 28 15       1414*          		JR      Z,STR47
043C34 FE 0A       1415*          		CP      10
043C36 47          1416*          		LD      B,A
043C37 3E 3A       1417*          		LD      A,':'
043C39 38 03       1418*          		JR      C,STR42
043C3B 23          1419*          		INC     HL
043C3C 36 30       1420*          		LD      (HL),'0'
043C3E 34          1421*  STR42:			INC     (HL)
043C3F BE          1422*          		CP      (HL)
043C40 20 05       1423*          		JR      NZ,STR43
043C42 36 30       1424*          		LD      (HL),'0'
043C44 2B          1425*          		DEC     HL
043C45 34          1426*          		INC     (HL)
043C46 23          1427*          		INC     HL
043C47 10 F5       1428*  STR43:			DJNZ    STR42
043C49 23          1429*  STR47:			INC     HL
043C4A EB          1430*  STR44:			EX      DE,HL
043C4B C9          1431*        			RET
043C4C             1432*  ;
043C4C             1433*  ;Support subroutines:
043C4C             1434*  ;
043C4C DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
043C4F D9          1436*          		EXX
043C50 DD 5E 00    1437*          		LD      E,(IX+0)
043C53 DD 56 01    1438*          		LD      D,(IX+1)
043C56 D9          1439*          		EXX
043C57 DD 5E 02    1440*          		LD      E,(IX+2)
043C5A DD 56 03    1441*          		LD      D,(IX+3)
043C5D C9          1442*          		RET
043C5E             1443*  ;
043C5E DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
043C61 D9          1445*  			EXX
043C62 DD 17 00    1446*  			LD	DE, (IX+0)
043C65 D9          1447*  			EXX
043C66 DD 17 03    1448*  			LD	DE, (IX+3)
043C69 C9          1449*  			RET
043C6A             1450*  ;
043C6A             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
043C6A             1452*  ;   Inputs: ASCII string at (IX).
043C6A             1453*  ;  Outputs: Variable-type result in HLH'L'C
043C6A             1454*  ;           IX updated (points to delimiter)
043C6A             1455*  ;           A7 = 0 (numeric marker)
043C6A             1456*  ;
043C6A CD A0 3E 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
043C6E 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
043C70 CD FE 3C 04 1459*          		CALL    UINT          ;GET INTEGER PART
043C74 FE 2E       1460*          		CP      '.'
043C76 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
043C78 CC FC 3C 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
043C7C FE 45       1463*          		CP      'E'
043C7E 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
043C80 CC CA 3C 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
043C84 CB 7C       1466*          		BIT     7,H
043C86 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
043C88 B7          1468*          		OR      A
043C89 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
043C8B B8          1470*          		CP      B
043C8C 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
043C8E B9          1472*          		CP      C
043C8F C8          1473*          		RET     Z               ;INTEGER
043C90 90          1474*  CON0:			SUB     B
043C91 81          1475*          		ADD     A,C
043C92 0E 9F       1476*          		LD      C,159
043C94 CD 03 3E 04 1477*          		CALL    FLOAT_
043C98 CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
043C9A B7          1479*          		OR      A
043C9B C8          1480*          		RET     Z               ;DONE
043C9C FA AA 3C 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
043CA0 CD 9C 3F 04 1482*          		CALL    POWR10
043CA4 CD 8B 35 04 1483*          		CALL    FMUL            ;SCALE
043CA8 AF          1484*          		XOR     A
043CA9 C9          1485*          		RET
043CAA FE DA       1486*  CON2:			CP      -38
043CAC 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
043CAE ED 44       1488*          		NEG
043CB0 CD 9C 3F 04 1489*          		CALL    POWR10
043CB4 CD E2 34 04 1490*          		CALL    FDIV            ;SCALE
043CB8 AF          1491*          		XOR     A
043CB9 C9          1492*          		RET
043CBA F5          1493*  CON3:			PUSH    AF
043CBB 3E 26       1494*          		LD      A,38
043CBD CD 9C 3F 04 1495*          		CALL    POWR10
043CC1 CD E2 34 04 1496*          		CALL    FDIV
043CC5 F1          1497*          		POP     AF
043CC6 C6 26       1498*          		ADD     A,38
043CC8 18 E0       1499*          		JR      CON2
043CCA             1500*  ;
043CCA             1501*  ;GETEXP - Get decimal exponent from string
043CCA             1502*  ;     Inputs: ASCII string at (IX)
043CCA             1503*  ;             (IX points at 'E')
043CCA             1504*  ;             A = initial value
043CCA             1505*  ;    Outputs: A = new exponent
043CCA             1506*  ;             IX updated.
043CCA             1507*  ;   Destroys: A,A',IX,F,F'
043CCA             1508*  ;
043CCA C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
043CCB 47          1510*          		LD      B,A             ;INITIAL VALUE
043CCC 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
043CCE DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
043CD0 CD BA 40 04 1513*          		CALL    SIGNQ
043CD4 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
043CD5 CD B0 40 04 1515*  GETEX1:			CALL    DIGITQ
043CD9 38 18       1516*          		JR      C,GETEX2
043CDB 78          1517*          		LD      A,B             ;B=B*10
043CDC 87          1518*          		ADD     A,A
043CDD 87          1519*          		ADD     A,A
043CDE 80          1520*          		ADD     A,B
043CDF 87          1521*          		ADD     A,A
043CE0 47          1522*          		LD      B,A
043CE1 DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
043CE4 DD 23       1524*          		INC     IX
043CE6 E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
043CE8 80          1526*          		ADD     A,B             ;ADD IN DIGIT
043CE9 47          1527*          		LD      B,A
043CEA 0D          1528*          		DEC     C
043CEB F2 D5 3C 04 1529*          		JP      P,GETEX1
043CEF 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
043CF1 18 E2       1531*          		JR      GETEX1
043CF3 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
043CF4 FE 2D       1533*          		CP      '-'
043CF6 78          1534*          		LD      A,B
043CF7 C1          1535*          		POP     BC              ;RESTORE
043CF8 C0          1536*          		RET     NZ
043CF9 ED 44       1537*          		NEG                     ;NEGATE EXPONENT
043CFB C9          1538*          		RET
043CFC             1539*  ;
043CFC             1540*  ;UINT: Get unsigned integer from string.
043CFC             1541*  ;    Inputs: string at (IX)
043CFC             1542*  ;            C = truncated digit count
043CFC             1543*  ;                (initially zero)
043CFC             1544*  ;            B = total digit count
043CFC             1545*  ;            HLH'L' = initial value
043CFC             1546*  ;   Outputs: HLH'L' = number (binary integer)
043CFC             1547*  ;            A = delimiter.
043CFC             1548*  ;            B, C & IX updated
043CFC             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
043CFC             1550*  ;
043CFC DD 23       1551*  NUMBIX:			INC     IX
043CFE CD B0 40 04 1552*  UINT:			CALL    DIGITQ
043D02 D8          1553*          		RET     C
043D03 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
043D04 DD 23       1555*          		INC     IX
043D06 CD F9 3E 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
043D0A 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
043D0C 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
043D0D 0C          1559*          		INC     C
043D0E 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
043D10 E6 0F       1561*          		AND     0FH
043D12 D9          1562*          		EXX
043D13 06 00       1563*          		LD      B,0
043D15 4F          1564*          		LD      C,A
043D16 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
043D18 D9          1566*          		EXX
043D19 30 E3       1567*          		JR      NC,UINT
043D1B 52 23       1568*          		INC.S   HL              ;CARRY
043D1D 7C          1569*          		LD      A,H
043D1E B5          1570*          		OR      L
043D1F 20 DD       1571*          		JR      NZ,UINT
043D21 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
043D22 CD 57 3E 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
043D26 18 D6       1574*          		JR      UINT
043D28             1575*  ;
043D28             1576*  ;FIX - Fix number to specified exponent value.
043D28             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
043D28             1578*  ;            A = desired exponent (A>C)
043D28             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
043D28             1580*  ;            fraction shifted into B'C'
043D28             1581*  ;            A'F' positive if integer input
043D28             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
043D28             1583*  ;
043D28 08          1584*  FIX:			EX      AF,AF'
043D29 AF          1585*          		XOR     A
043D2A 08          1586*          		EX      AF,AF'
043D2B CB FC       1587*          		SET     7,H             ;IMPLIED 1
043D2D CD 5C 3E 04 1588*  FIX1:			CALL    DIV2
043D31 B9          1589*          		CP      C
043D32 C8          1590*          		RET     Z
043D33 D2 2D 3D 04 1591*          		JP      NC,FIX1
043D37 C3 6B 3E 04 1592*          		JP      OFLOW
043D3B             1593*  ;
043D3B             1594*  ;SFIX - Convert to integer if necessary.
043D3B             1595*  ;    Input: Variable-type number in HLH'L'C
043D3B             1596*  ;   Output: Integer in HLH'L', C=0
043D3B             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
043D3B             1598*  ;
043D3B             1599*  ;NEGATE - Negate HLH'L'
043D3B             1600*  ;    Destroys: H,L,H',L',F
043D3B             1601*  ;
043D3B CD 54 3E 04 1602*  FIX2:			CALL    SWAP_FP
043D3F CD 47 3D 04 1603*          		CALL    SFIX_FP
043D43 CD 54 3E 04 1604*          		CALL    SWAP_FP
043D47 0D          1605*  SFIX_FP:			DEC     C
043D48 0C          1606*          		INC     C
043D49 C8          1607*          		RET     Z               ;INTEGER/ZERO
043D4A CB 7C       1608*          		BIT     7,H             ;SIGN
043D4C F5          1609*          		PUSH    AF
043D4D 3E 9F       1610*          		LD      A,159
043D4F CD 28 3D 04 1611*          		CALL    FIX
043D53 F1          1612*          		POP     AF
043D54 0E 00       1613*          		LD      C,0
043D56 C8          1614*          		RET     Z
043D57 B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
043D58 D9          1616*          		EXX
043D59 D5          1617*  NEG0:			PUSH    DE
043D5A EB          1618*          		EX      DE,HL
043D5B 21 00 00 00 1619*          		LD      HL,0
043D5F 52 ED 52    1620*          		SBC.S   HL,DE
043D62 D1          1621*          		POP     DE
043D63 D9          1622*          		EXX
043D64 D5          1623*          		PUSH    DE
043D65 EB          1624*          		EX      DE,HL
043D66 21 00 00 00 1625*          		LD      HL,0
043D6A 52 ED 52    1626*          		SBC.S   HL,DE
043D6D D1          1627*          		POP     DE
043D6E C9          1628*          		RET
043D6F             1629*  ;
043D6F             1630*  ;NEG - Negate HLH'L'B'C'
043D6F             1631*  ;    Also complements A (used in FADD)
043D6F             1632*  ;    Destroys: A,H,L,B',C',H',L',F
043D6F             1633*  ;
043D6F D9          1634*  NEG_:			EXX
043D70 2F          1635*          		CPL
043D71 E5          1636*          		PUSH    HL
043D72 B7          1637*          		OR      A               ;CLEAR CARRY
043D73 21 00 00 00 1638*          		LD      HL,0
043D77 52 ED 42    1639*          		SBC.S   HL,BC
043D7A 44          1640*          		LD      B,H
043D7B 4D          1641*          		LD      C,L
043D7C E1          1642*          		POP     HL
043D7D 18 DA       1643*          		JR      NEG0
043D7F             1644*  ;
043D7F             1645*  ;SCALE - Trig scaling.
043D7F             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
043D7F             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
043D7F             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
043D7F             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
043D7F             1650*  ;           E = quotient (bit 7 is sticky)
043D7F             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
043D7F             1652*  ;FLO48 - Float unsigned number (48 bits)
043D7F             1653*  ;    Input/output in HLH'L'B'C'C
043D7F             1654*  ;   Destroys: C,H,L,B',C',H',L',F
043D7F             1655*  ;
043D7F 3E 96       1656*  SCALE:			LD      A,150
043D81 B9          1657*          		CP      C
043D82 3E 17       1658*          		LD      A,ACLOST
043D84 DA FA 32 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
043D88 CD C5 38 04 1660*          		CALL    PIBY4
043D8C D9          1661*          		EXX
043D8D 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
043D91 D9          1663*          		EXX
043D92 CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
043D94 CB FC       1665*          		SET     7,H
043D96 79          1666*          		LD      A,C
043D97 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
043D99 DD 21 00 00 1668*          		LD      IX,0
       00          
043D9E DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
043DA0 B8          1670*          		CP      B
043DA1 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
043DA3 D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
043DA4 E3          1673*          		EX      (SP),HL
043DA5 52 ED 42    1674*          		SBC.S   HL,BC
043DA8 E3          1675*          		EX      (SP),HL
043DA9 52 ED 52    1676*          		SBC.S   HL,DE
043DAC D9          1677*          		EXX
043DAD 52 ED 52    1678*          		SBC.S   HL,DE
043DB0 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
043DB2 D9          1680*          		EXX
043DB3 E3          1681*          		EX      (SP),HL
043DB4 52 09       1682*          		ADD.S   HL,BC
043DB6 E3          1683*          		EX      (SP),HL
043DB7 52 ED 5A    1684*          		ADC.S   HL,DE
043DBA D9          1685*          		EXX
043DBB 52 ED 5A    1686*          		ADC.S   HL,DE
043DBE 3F          1687*  MOD482:			CCF
043DBF CB 11       1688*          		RL      C               ;QUOTIENT
043DC1 30 02       1689*          		JR      NC,MOD483
043DC3 CB F9       1690*          		SET     7,C             ;STICKY BIT
043DC5 3D          1691*  MOD483:			DEC     A
043DC6 B8          1692*          		CP      B
043DC7 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
043DC9 E3          1694*          		EX      (SP),HL
043DCA 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
043DCC E3          1696*          		EX      (SP),HL
043DCD D9          1697*          		EXX
043DCE 52 ED 6A    1698*          		ADC.S   HL,HL
043DD1 D9          1699*          		EXX
043DD2 52 ED 6A    1700*          		ADC.S   HL,HL
043DD5 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
043DD7 B7          1702*          		OR      A
043DD8 D9          1703*          		EXX
043DD9 E3          1704*          		EX      (SP),HL
043DDA 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
043DDD E3          1706*          		EX      (SP),HL
043DDE 52 ED 52    1707*          		SBC.S   HL,DE
043DE1 D9          1708*          		EXX
043DE2 52 ED 52    1709*          		SBC.S   HL,DE
043DE5 B7          1710*          		OR      A
043DE6 18 D6       1711*          		JR      MOD482
043DE8             1712*  ;
043DE8 3C          1713*  MOD484:			INC     A
043DE9 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
043DEA 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
043DEB D9          1716*          		EXX
043DEC C1          1717*          		POP     BC
043DED D9          1718*          		EXX
043DEE CB 7C       1719*  FLO48:			BIT     7,H
043DF0 C0          1720*          		RET     NZ
043DF1 D9          1721*          		EXX
043DF2 CB 21       1722*          		SLA     C
043DF4 CB 10       1723*          		RL      B
043DF6 52 ED 6A    1724*          		ADC.S   HL,HL
043DF9 D9          1725*          		EXX
043DFA 52 ED 6A    1726*          		ADC.S   HL,HL
043DFD 0D          1727*          		DEC     C
043DFE C2 EE 3D 04 1728*          		JP      NZ,FLO48
043E02 C9          1729*          		RET
043E03             1730*  ;
043E03             1731*  ;Float unsigned number
043E03             1732*  ;    Input/output in HLH'L'C
043E03             1733*  ;   Destroys: C,H,L,H',L',F
043E03             1734*  ;
043E03 CB 7C       1735*  FLOAT_:			BIT     7,H
043E05 C0          1736*          		RET     NZ
043E06 D9          1737*          		EXX                     ;SAME AS "X2"
043E07 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
043E09 D9          1739*          		EXX                     ;REGION
043E0A 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
043E0D 0D          1741*          		DEC     C
043E0E C2 03 3E 04 1742*          		JP      NZ,FLOAT_
043E12 C9          1743*          		RET
043E13             1744*  ;
043E13             1745*  ;SFLOAT - Convert to floating-point if necessary.
043E13             1746*  ;    Input: Variable-type number in HLH'L'C
043E13             1747*  ;    Output: Floating-point in HLH'L'C
043E13             1748*  ;    Destroys: A,C,H,L,H',L',F
043E13             1749*  ;
043E13 08          1750*  FLOATA:			EX      AF,AF'
043E14             1751*          		; ADD     A,(RTABLE-DTABLE)/3
043E14 C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
043E16 08          1753*          		EX      AF,AF'
043E17 CD 54 3E 04 1754*  FLOAT2:			CALL    SWAP_FP
043E1B CD 23 3E 04 1755*          		CALL    SFLOAT_FP
043E1F CD 54 3E 04 1756*          		CALL    SWAP_FP
043E23 0D          1757*  SFLOAT_FP:			DEC     C
043E24 0C          1758*          		INC     C
043E25 C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
043E26 CD 7C 3E 04 1760*          		CALL    TEST_FP
043E2A C8          1761*          		RET     Z               ;ZERO
043E2B 7C          1762*          		LD      A,H
043E2C B7          1763*          		OR      A
043E2D FC 57 3D 04 1764*          		CALL    M,NEGATE
043E31 0E 9F       1765*          		LD      C,159
043E33 CD 03 3E 04 1766*          		CALL    FLOAT_
043E37 B7          1767*          		OR      A
043E38 F8          1768*          		RET     M               ;NEGATIVE
043E39 CB BC       1769*          		RES     7,H
043E3B C9          1770*          		RET
043E3C             1771*  ;
043E3C             1772*  ;ROUND UP
043E3C             1773*  ;Return with carry set if 32-bit overflow
043E3C             1774*  ;   Destroys: H,L,B',C',H',L',F
043E3C             1775*  ;
043E3C D9          1776*  ADD1_FP:			EXX
043E3D 01 01 00 00 1777*          		LD      BC,1
043E41 52 09       1778*          		ADD.S   HL,BC
043E43 D9          1779*          		EXX
043E44 D0          1780*          		RET     NC
043E45 C5          1781*          		PUSH    BC
043E46 01 01 00 00 1782*          		LD      BC,1
043E4A 52 09       1783*          		ADD.S   HL,BC
043E4C C1          1784*          		POP     BC
043E4D C9          1785*          		RET
043E4E             1786*  ;
043E4E             1787*  ;ODD - Add one if even, leave alone if odd.
043E4E             1788*  ; (Used to perform unbiassed rounding, i.e.
043E4E             1789*  ;  number is rounded up half the time)
043E4E             1790*  ;    Destroys: L',F (carry cleared)
043E4E             1791*  ;
043E4E B7          1792*  ODD:			OR      A               ;CLEAR CARRY
043E4F D9          1793*          		EXX
043E50 CB C5       1794*          		SET     0,L             ;MAKE ODD
043E52 D9          1795*          		EXX
043E53 C9          1796*          		RET
043E54             1797*  ;
043E54             1798*  ;SWAP_FP - Swap arguments.
043E54             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
043E54             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
043E54             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
043E54             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
043E54             1803*  ;
043E54 79          1804*  SWAP_FP:			LD      A,C
043E55 48          1805*          		LD      C,B
043E56 47          1806*          		LD      B,A
043E57 EB          1807*  SWAP1:			EX      DE,HL
043E58 D9          1808*          		EXX
043E59 EB          1809*          		EX      DE,HL
043E5A D9          1810*          		EXX
043E5B C9          1811*          		RET
043E5C             1812*  ;
043E5C             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
043E5C             1814*  ; INCC - destroys C,F
043E5C             1815*  ; OFLOW
043E5C             1816*  ;
043E5C CD 15 3F 04 1817*  DIV2:			CALL    D2
043E60 D9          1818*          		EXX
043E61 CB 18       1819*          		RR      B
043E63 CB 19       1820*          		RR      C
043E65 08          1821*          		EX      AF,AF'
043E66 B0          1822*          		OR      B
043E67 08          1823*          		EX      AF,AF'
043E68 D9          1824*          		EXX
043E69 0C          1825*  INCC:			INC     C
043E6A C0          1826*          		RET     NZ
043E6B 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
043E6D C3 FA 32 04 1828*          		JP      ERROR_FP_           ;"Too big"
043E71             1829*  ;
043E71             1830*  ; FTEST - Test for zero & sign
043E71             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
043E71             1832*  ;
043E71 CD 7C 3E 04 1833*  FTEST_FP:			CALL    TEST_FP
043E75 C8          1834*          		RET     Z
043E76 7C          1835*          		LD      A,H
043E77 E6 80       1836*          		AND     10000000B
043E79 F6 40       1837*          		OR      01000000B
043E7B C9          1838*          		RET
043E7C             1839*  ;
043E7C             1840*  ; TEST_FP - Test HLH'L' for zero.
043E7C             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
043E7C             1842*  ;     Destroys: A,F
043E7C             1843*  ;
043E7C 7C          1844*  TEST_FP:			LD      A,H
043E7D B5          1845*          		OR      L
043E7E D9          1846*          		EXX
043E7F B4          1847*          		OR      H
043E80 B5          1848*          		OR      L
043E81 D9          1849*          		EXX
043E82 C9          1850*          		RET
043E83             1851*  ;
043E83             1852*  ; FCOMP - Compare two numbers
043E83             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
043E83             1854*  ;
043E83 78          1855*  FCOMP_FP:			LD      A,B
043E84 B1          1856*          		OR      C               ;Both integer?
043E85 20 0B       1857*          		JR      NZ,FCOMP1
043E87 CD 9C 3E 04 1858*          		CALL    ICP
043E8B 3E 00       1859*  FCOMP0:			LD      A,0
043E8D C8          1860*          		RET     Z               ;Equal
043E8E 3E 80       1861*          		LD      A,80H
043E90 1F          1862*          		RRA
043E91 C9          1863*          		RET
043E92             1864*  ;
043E92 CD 17 3E 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
043E96 CD AA 3E 04 1866*          		CALL    FCP
043E9A 18 EF       1867*          		JR      FCOMP0
043E9C             1868*  ;
043E9C             1869*  ; Integer and floating point compare.
043E9C             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
043E9C             1871*  ; Result pre-set to FALSE
043E9C             1872*  ; ICP1, FCP1 destroy A,F
043E9C             1873*  ;
043E9C             1874*  ; ZERO - Return zero.
043E9C             1875*  ;  Destroys: A,C,H,L,H',L'
043E9C             1876*  ;
043E9C CD CF 3E 04 1877*  ICP:			CALL    ICP1
043EA0 3E 00       1878*  ZERO_FP:			LD      A,0
043EA2 D9          1879*          		EXX
043EA3 67          1880*          		LD      H,A
043EA4 6F          1881*  	       		LD      L,A
043EA5 D9          1882*          		EXX
043EA6 67          1883*        			LD      H,A
043EA7 6F          1884*       			LD      L,A
043EA8 4F          1885*  	    		LD      C,A
043EA9 C9          1886*          		RET
043EAA             1887*  ;
043EAA CD C1 3E 04 1888*  FCP:			CALL    FCP1
043EAE 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
043EB0             1890*  ;
043EB0 79          1891*  FCP0:			LD      A,C
043EB1 B8          1892*          		CP      B               ;COMPARE EXPONENTS
043EB2 C0          1893*          		RET     NZ
043EB3             1894*  ICP0:
043EB3 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
043EB6 52 19       1896*          		ADD.S   HL,DE
043EB8 C0          1897*          		RET     NZ
043EB9 D9          1898*          		EXX
043EBA 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
043EBD 52 19       1900*          		ADD.S   HL,DE
043EBF D9          1901*          		EXX
043EC0 C9          1902*          		RET
043EC1             1903*  ;
043EC1 7C          1904*  FCP1:			LD      A,H
043EC2 AA          1905*          		XOR     D
043EC3 7C          1906*          		LD      A,H
043EC4 17          1907*          		RLA
043EC5 F8          1908*          		RET     M
043EC6 30 E8       1909*          		JR      NC,FCP0
043EC8 CD B0 3E 04 1910*          		CALL    FCP0
043ECC C8          1911*          		RET     Z               ;** V0.1 BUG FIX
043ECD 3F          1912*          		CCF
043ECE C9          1913*          		RET
043ECF             1914*  ;
043ECF 7C          1915*  ICP1:			LD      A,H
043ED0 AA          1916*          		XOR     D
043ED1 F2 B3 3E 04 1917*          		JP      P,ICP0
043ED5 7C          1918*          		LD      A,H
043ED6 17          1919*          		RLA
043ED7 C9          1920*          		RET
043ED8             1921*  ;
043ED8             1922*  ; ADD - Integer add.
043ED8             1923*  ; Carry, sign & zero flags valid on exit
043ED8             1924*  ;     Destroys: H,L,H',L',F
043ED8             1925*  ;
043ED8 05          1926*  X10B:			DEC     B
043ED9 0C          1927*          		INC     C
043EDA CD 21 3F 04 1928*  X5:			CALL    COPY0
043EDE CD 14 3F 04 1929*          		CALL    D2C
043EE2 CD 14 3F 04 1930*          		CALL    D2C
043EE6 08          1931*          		EX      AF,AF'          ;SAVE CARRY
043EE7 D9          1932*  ADD_:			EXX
043EE8 52 19       1933*          		ADD.S   HL,DE
043EEA D9          1934*          		EXX
043EEB 52 ED 5A    1935*          		ADC.S   HL,DE
043EEE C9          1936*          		RET
043EEF             1937*  ;
043EEF             1938*  ; SUB - Integer subtract.
043EEF             1939*  ; Carry, sign & zero flags valid on exit
043EEF             1940*  ;     Destroys: H,L,H',L',F
043EEF             1941*  ;
043EEF D9          1942*  SUB_:			EXX
043EF0 B7          1943*          		OR      A
043EF1 52 ED 52    1944*          		SBC.S   HL,DE
043EF4 D9          1945*          		EXX
043EF5 52 ED 52    1946*          		SBC.S   HL,DE
043EF8 C9          1947*          		RET
043EF9             1948*  ;
043EF9             1949*  ; X10 - unsigned integer * 10
043EF9             1950*  ;    Inputs: HLH'L' initial value
043EF9             1951*  ;   Outputs: DED'E' = initial HLH'L'
043EF9             1952*  ;            Carry bit set if overflow
043EF9             1953*  ;            If carry not set HLH'L'=result
043EF9             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
043EF9             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
043EF9             1956*  ;     Carry set if MSB=1 before shift.
043EF9             1957*  ;     Sign set if MSB=1 after shift.
043EF9             1958*  ;     Destroys: H,L,H',L',F
043EF9             1959*  ;
043EF9 CD 21 3F 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
043EFD CD 0C 3F 04 1961*          		CALL    X2
043F01 D8          1962*          		RET     C               ;TOO BIG
043F02 CD 0C 3F 04 1963*          		CALL    X2
043F06 D8          1964*          		RET     C
043F07 CD E7 3E 04 1965*          		CALL    ADD_
043F0B D8          1966*          		RET     C
043F0C D9          1967*  X2:			EXX
043F0D 52 29       1968*          		ADD.S   HL,HL
043F0F D9          1969*          		EXX
043F10 52 ED 6A    1970*          		ADC.S   HL,HL
043F13 C9          1971*          		RET
043F14             1972*  ;
043F14             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
043F14             1974*  ;     Carry set if LSB=1 before shift.
043F14             1975*  ;     Destroys: H,L,H',L',F
043F14             1976*  ;
043F14 0C          1977*  D2C:			INC     C
043F15 CB 3C       1978*  D2:			SRL     H
043F17 CB 1D       1979*          		RR      L
043F19 D9          1980*          		EXX
043F1A CB 1C       1981*          		RR      H
043F1C CB 1D       1982*          		RR      L
043F1E D9          1983*          		EXX
043F1F C9          1984*          		RET
043F20             1985*  ;
043F20             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
043F20             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
043F20             1988*  ;
043F20 41          1989*  COPY_:			LD      B,C
043F21 54          1990*  COPY0:			LD      D,H
043F22 5D          1991*          		LD      E,L
043F23 D9          1992*          		EXX
043F24 54          1993*          		LD      D,H
043F25 5D          1994*          		LD      E,L
043F26 D9          1995*          		EXX
043F27 C9          1996*          		RET
043F28             1997*  ;
043F28             1998*  ; SQUARE - PUSH X*X
043F28             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
043F28             2000*  ;   Destroys: SP,IX
043F28             2001*  ;
043F28 CD 20 3F 04 2002*  SQUARE:			CALL    COPY_
043F2C CD 8B 35 04 2003*          		CALL    FMUL
043F30 DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
043F32 C5          2005*          		PUSH    BC
043F33 E5          2006*          		PUSH    HL
043F34 D9          2007*          		EXX
043F35 E5          2008*          		PUSH    HL
043F36 D9          2009*          		EXX
043F37 DD E9       2010*          		JP      (IX)            ;"RETURN"
043F39             2011*  ;
043F39             2012*  ; POP5 - POP DED'E'B OFF STACK.
043F39             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
043F39             2014*  ;
043F39 DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
043F3B D9          2016*          		EXX
043F3C D1          2017*          		POP     DE
043F3D D9          2018*          		EXX
043F3E D1          2019*          		POP     DE
043F3F 79          2020*          		LD      A,C
043F40 C1          2021*          		POP     BC
043F41 41          2022*          		LD      B,C
043F42 4F          2023*          		LD      C,A
043F43 DD E9       2024*          		JP      (IX)            ;"RETURN"
043F45             2025*  ;
043F45             2026*  ; RATIO - Calculate (X-1)/(X+1)
043F45             2027*  ;     Inputs: X in HLH'L'C
043F45             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
043F45             2029*  ;   Destroys: Everything except IY,SP,I
043F45             2030*  ;
043F45 CD 30 3F 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
043F49 CD B8 38 04 2032*          		CALL    DONE
043F4D CD 79 34 04 2033*          		CALL    FADD
043F51 CD 39 3F 04 2034*          		CALL    POP5            ;RESTORE X
043F55 CD 30 3F 04 2035*          		CALL    PUSH5           ;SAVE X+1
043F59 CD 54 3E 04 2036*          		CALL    SWAP_FP
043F5D CD B8 38 04 2037*          		CALL    DONE
043F61 CD 60 34 04 2038*          		CALL    FSUB
043F65 CD 39 3F 04 2039*          		CALL    POP5            ;RESTORE X+1
043F69 C3 E2 34 04 2040*          		JP      FDIV
043F6D             2041*  ;
043F6D             2042*  ; POLY - Evaluate a polynomial.
043F6D             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
043F6D             2044*  ;             Polynomial coefficients follow call.
043F6D             2045*  ;    Outputs: Result in HLH'L'C
043F6D             2046*  ;   Destroys: Everything except IY,SP,I
043F6D             2047*  ; Routine terminates on finding a coefficient >=1.
043F6D             2048*  ; Note: The last coefficient is EXECUTED on return
043F6D             2049*  ;       so must contain only innocuous bytes!
043F6D             2050*  ;
043F6D DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
043F72 DD 39       2052*          		ADD     IX, SP
043F74 DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
043F76             2054*  ;
043F76 CD 4C 3C 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
043F7A CD 8B 35 04 2056*  POLY1:			CALL    FMUL
043F7E 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
043F82 DD 19       2058*          		ADD     IX, DE
043F84 CD 4C 3C 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
043F88 DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
043F8A 04          2061*          		INC     B
043F8B 05          2062*          		DEC     B               		; Test B for end byte (80h)
043F8C FA 79 34 04 2063*          		JP      M,FADD				; Yes, so add and return
043F90 CD 79 34 04 2064*          		CALL    FADD				; No, so add
043F94 CD 5E 3C 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
043F98 DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
043F9A 18 DE       2067*          		JR      POLY1				; And loop
043F9C             2068*  ;
043F9C             2069*  ; POWR10 - Calculate power of ten.
043F9C             2070*  ;     Inputs: A=power of 10 required (A<128)
043F9C             2071*  ;             A=binary exponent to be exceeded (A>=128)
043F9C             2072*  ;    Outputs: DED'E'B = result
043F9C             2073*  ;             A = actual power of ten returned
043F9C             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
043F9C             2075*  ;
043F9C 3C          2076*  POWR10:			INC     A
043F9D 08          2077*          		EX      AF,AF'
043F9E E5          2078*          		PUSH    HL
043F9F D9          2079*          		EXX
043FA0 E5          2080*          		PUSH    HL
043FA1 D9          2081*          		EXX
043FA2 CD B8 38 04 2082*          		CALL    DONE
043FA6 CD 54 3E 04 2083*          		CALL    SWAP_FP
043FAA AF          2084*          		XOR     A
043FAB 08          2085*  POWR11:			EX      AF,AF'
043FAC 3D          2086*          		DEC     A
043FAD 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
043FAF F2 B7 3F 04 2088*          		JP      P,POWR13
043FB3 B9          2089*          		CP      C
043FB4 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
043FB6 3C          2091*          		INC     A
043FB7 08          2092*  POWR13:			EX      AF,AF'
043FB8 3C          2093*          		INC     A
043FB9 CB FC       2094*          		SET     7,H
043FBB CD DA 3E 04 2095*          		CALL    X5
043FBF 30 06       2096*          		JR      NC,POWR12
043FC1 08          2097*          		EX      AF,AF'
043FC2 CD 14 3F 04 2098*          		CALL    D2C
043FC6 08          2099*          		EX      AF,AF'
043FC7 08          2100*  POWR12:			EX      AF,AF'
043FC8 DC 3C 3E 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
043FCC 0C          2102*          		INC     C
043FCD FA AB 3F 04 2103*          		JP      M,POWR11
043FD1 C3 6B 3E 04 2104*          		JP      OFLOW
043FD5 CD 54 3E 04 2105*  POWR14:			CALL    SWAP_FP
043FD9 CB BA       2106*          		RES     7,D
043FDB D9          2107*          		EXX
043FDC E1          2108*          		POP     HL
043FDD D9          2109*          		EXX
043FDE E1          2110*          		POP     HL
043FDF 08          2111*          		EX      AF,AF'
043FE0 C9          2112*          		RET
043FE1             2113*  ;
043FE1             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
043FE1             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
043FE1             2116*  ;               Remainder in H'L'HL
043FE1             2117*  ;     Inputs: A = loop counter (normally -32)
043FE1             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
043FE1             2119*  ;
043FE1 B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
043FE2             2121*  DIV0:
043FE2 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
043FE5 D9          2123*          		EXX
043FE6 52 ED 42    2124*          		SBC.S   HL,BC
043FE9 D9          2125*          		EXX
043FEA 30 07       2126*          		JR      NC,DIV1
043FEC 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
043FEE D9          2128*          		EXX
043FEF 52 ED 4A    2129*          		ADC.S   HL,BC
043FF2 D9          2130*          		EXX
043FF3 3F          2131*  DIV1:			CCF
043FF4 CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
043FF6 CB 12       2133*          		RL      D
043FF8 D9          2134*          		EXX
043FF9 CB 13       2135*          		RL      E
043FFB CB 12       2136*          		RL      D
043FFD D9          2137*          		EXX
043FFE 3C          2138*          		INC     A
043FFF F0          2139*          		RET     P
044000             2140*  DIVB:
044000 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
044003 D9          2142*          		EXX
044004 52 ED 6A    2143*          		ADC.S   HL,HL
044007 D9          2144*          		EXX
044008 30 D8       2145*          		JR      NC,DIV0
04400A B7          2146*          		OR      A
04400B 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
04400E D9          2148*          		EXX
04400F 52 ED 42    2149*          		SBC.S   HL,BC
044012 D9          2150*          		EXX
044013 37          2151*          		SCF
044014 C3 F4 3F 04 2152*          		JP      DIVC
044018             2153*  ;
044018             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
044018             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
044018             2156*  ;    Inputs: A = loop counter (usually -32)
044018             2157*  ;            H'L'HL = 0
044018             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
044018             2159*  ;
044018 B7          2160*  MULA:			OR      A               ;CLEAR CARRY
044019 D9          2161*  MUL0:			EXX
04401A CB 1A       2162*          		RR      D               ;MULTIPLIER/2
04401C CB 1B       2163*          		RR      E
04401E D9          2164*          		EXX
04401F CB 1A       2165*          		RR      D
044021 CB 1B       2166*          		RR      E
044023 30 07       2167*          		JR      NC,MUL1
044025 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
044027 D9          2169*          		EXX
044028 52 ED 4A    2170*          		ADC.S   HL,BC
04402B D9          2171*          		EXX
04402C 3C          2172*  MUL1:			INC     A
04402D F0          2173*          		RET     P
04402E D9          2174*  MULB:			EXX
04402F CB 1C       2175*          		RR      H               ;PRODUCT/2
044031 CB 1D       2176*          		RR      L
044033 D9          2177*          		EXX
044034 CB 1C       2178*          		RR      H
044036 CB 1D       2179*          		RR      L
044038 C3 19 40 04 2180*          		JP      MUL0
04403C             2181*  ;
04403C             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
04403C             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
04403C             2184*  ;     Inputs: A = loop counter (normally -31)
04403C             2185*  ;             B'C'BCH'L'HL initialised to 0
04403C             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
04403C             2187*  ;
04403C             2188*  SQR1:
04403C 52 ED 42    2189*  			SBC.S   HL,BC
04403F D9          2190*          		EXX
044040 52 ED 42    2191*          		SBC.S   HL,BC
044043 D9          2192*          		EXX
044044 0C          2193*          		INC     C
044045 30 09       2194*          		JR      NC,SQR2
044047 0D          2195*          		DEC     C
044048 52 09       2196*          		ADD.S   HL,BC
04404A D9          2197*          		EXX
04404B 52 ED 4A    2198*          		ADC.S   HL,BC
04404E D9          2199*          		EXX
04404F 0D          2200*          		DEC     C
044050 3C          2201*  SQR2:			INC     A
044051 F0          2202*          		RET     P
044052 CB 21       2203*  SQRA:			SLA     C
044054 CB 10       2204*          		RL      B
044056 D9          2205*          		EXX
044057 CB 11       2206*          		RL      C
044059 CB 10       2207*          		RL      B
04405B D9          2208*          		EXX
04405C 0C          2209*          		INC     C
04405D CB 23       2210*          		SLA     E
04405F CB 12       2211*          		RL      D
044061 D9          2212*          		EXX
044062 CB 13       2213*          		RL      E
044064 CB 12       2214*          		RL      D
044066 D9          2215*          		EXX
044067 52 ED 6A    2216*          		ADC.S   HL,HL
04406A D9          2217*          		EXX
04406B 52 ED 6A    2218*          		ADC.S   HL,HL
04406E D9          2219*          		EXX
04406F CB 23       2220*          		SLA     E
044071 CB 12       2221*          		RL      D
044073 D9          2222*          		EXX
044074 CB 13       2223*          		RL      E
044076 CB 12       2224*          		RL      D
044078 D9          2225*          		EXX
044079 52 ED 6A    2226*          		ADC.S   HL,HL
04407C D9          2227*          		EXX
04407D 52 ED 6A    2228*          		ADC.S   HL,HL
044080 D9          2229*          		EXX
044081 D2 3C 40 04 2230*          		JP      NC,SQR1
044085 B7          2231*  SQR3:			OR      A
044086 52 ED 42    2232*          		SBC.S   HL,BC
044089 D9          2233*          		EXX
04408A 52 ED 42    2234*          		SBC.S   HL,BC
04408D D9          2235*          		EXX
04408E 0C          2236*          		INC     C
04408F C3 50 40 04 2237*          		JP      SQR2
044093             2238*  ;
044093             2239*  SQRB:
044093 52 29       2240*  			ADD.S   HL,HL
044095 D9          2241*          		EXX
044096 52 ED 6A    2242*          		ADC.S   HL,HL
044099 D9          2243*          		EXX
04409A 38 E9       2244*          		JR      C,SQR3
04409C 3C          2245*          		INC     A
04409D 0C          2246*          		INC     C
04409E 52 ED 42    2247*          		SBC.S   HL,BC
0440A1 D9          2248*          		EXX
0440A2 52 ED 42    2249*          		SBC.S   HL,BC
0440A5 D9          2250*          		EXX
0440A6 D0          2251*          		RET     NC
0440A7 52 09       2252*          		ADD.S   HL,BC
0440A9 D9          2253*          		EXX
0440AA 52 ED 4A    2254*          		ADC.S   HL,BC
0440AD D9          2255*          		EXX
0440AE 0D          2256*          		DEC     C
0440AF C9          2257*          		RET
0440B0             2258*  ;
0440B0 DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
0440B3 FE 3A       2260*          		CP      '9'+1
0440B5 3F          2261*          		CCF
0440B6 D8          2262*          		RET     C
0440B7 FE 30       2263*          		CP      '0'
0440B9 C9          2264*          		RET
0440BA             2265*  ;
0440BA DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
0440BD DD 23       2267*          		INC     IX
0440BF FE 20       2268*          		CP      ' '
0440C1 28 F7       2269*          		JR      Z,SIGNQ
0440C3 FE 2B       2270*          		CP      '+'
0440C5 C8          2271*          		RET     Z
0440C6 FE 2D       2272*          		CP      '-'
0440C8 C8          2273*          		RET     Z
0440C9 DD 2B       2274*          		DEC     IX
0440CB C9          2275*          		RET
0440CC             0010       include "gpio.asm"
0440CC             0001*  ;
0440CC             0002*  ; Title:	BBC Basic for AGON - GPIO functions
0440CC             0003*  ; Author:	Dean Belfield
0440CC             0004*  ; Created:	12/05/2023
0440CC             0005*  ; Last Updated:	12/05/2023
0440CC             0006*  ;
0440CC             0007*  ; Modinfo:
0440CC             0008*  
0440CC             0009*  			; INCLUDE	"macros.inc"
0440CC             0010*  			; INCLUDE	"equs.inc"
0440CC             0011*  
0440CC             0012*  			; .ASSUME	ADL = 1
0440CC             0013*  
0440CC             0014*  			; SEGMENT CODE
0440CC             0015*  
0440CC             0016*  			; XDEF	GPIOB_SETMODE
0440CC             0017*  
0440CC             0018*  			; XREF	SWITCH_A
0440CC             0019*  
0440CC             0020*  ;  A: Mode
0440CC             0021*  ;  B: Pins
0440CC             0022*  ;
0440CC CD 14 48 04 0023*  GPIOB_SETMODE:		CALL	SWITCH_A
0440D0 E4 40       0024*  			DW	GPIOB_M0	; Output
0440D2 09 41       0025*  			DW	GPIOB_M1	; Input
0440D4 29 41       0026*  			DW	GPIOB_M2	; Open Drain IO
0440D6 49 41       0027*  			DW	GPIOB_M3	; Open Source IO
0440D8 64 41       0028*  			DW	GPIOB_M4	; Interrupt, Dual Edge
0440DA 90 41       0029*  			DW	GPIOB_M5	; Alt Function
0440DC AB 41       0030*  			DW	GPIOB_M6	; Interrupt, Active Low
0440DE D2 41       0031*  			DW	GPIOB_M7	; Interrupt, Active High
0440E0 F4 41       0032*  			DW	GPIOB_M8	; Interrupt, Falling Edge
0440E2 16 42       0033*  			DW	GPIOB_M9	; Interrupt, Rising Edge
0440E4             0034*  
0440E4             0035*  ; Output
0440E4             0036*  ;
0440E4             0037*  GPIOB_M0:		RES_GPIO PB_DDR,  B
0440E4 C5          0001*M 		PUSH	BC
0440E5 78          0002*M 		LD	A, val
0440E6 2F          0003*M 		CPL
0440E7 4F          0004*M 		LD	C, A
0440E8 ED 38 9B    0005*M 		IN0	A, (reg)
0440EB A1          0006*M 		AND	C
0440EC ED 39 9B    0007*M 		OUT0	(reg), A
0440EF C1          0008*M 		POP	BC
0440F0             0038*  			RES_GPIO PB_ALT1, B
0440F0 C5          0001*M 		PUSH	BC
0440F1 78          0002*M 		LD	A, val
0440F2 2F          0003*M 		CPL
0440F3 4F          0004*M 		LD	C, A
0440F4 ED 38 9C    0005*M 		IN0	A, (reg)
0440F7 A1          0006*M 		AND	C
0440F8 ED 39 9C    0007*M 		OUT0	(reg), A
0440FB C1          0008*M 		POP	BC
0440FC             0039*  			RES_GPIO PB_ALT2, B
0440FC C5          0001*M 		PUSH	BC
0440FD 78          0002*M 		LD	A, val
0440FE 2F          0003*M 		CPL
0440FF 4F          0004*M 		LD	C, A
044100 ED 38 9D    0005*M 		IN0	A, (reg)
044103 A1          0006*M 		AND	C
044104 ED 39 9D    0007*M 		OUT0	(reg), A
044107 C1          0008*M 		POP	BC
044108 C9          0040*  			RET
044109             0041*  
044109             0042*  ; Input
044109             0043*  ;
044109             0044*  GPIOB_M1:		SET_GPIO PB_DDR,  B
044109 ED 38 9B    0001*M 		IN0	A, (reg)
04410C B0          0002*M 		OR	val
04410D ED 39 9B    0003*M 		OUT0	(reg), A
044110             0045*  			RES_GPIO PB_ALT1, B
044110 C5          0001*M 		PUSH	BC
044111 78          0002*M 		LD	A, val
044112 2F          0003*M 		CPL
044113 4F          0004*M 		LD	C, A
044114 ED 38 9C    0005*M 		IN0	A, (reg)
044117 A1          0006*M 		AND	C
044118 ED 39 9C    0007*M 		OUT0	(reg), A
04411B C1          0008*M 		POP	BC
04411C             0046*  			RES_GPIO PB_ALT2, B
04411C C5          0001*M 		PUSH	BC
04411D 78          0002*M 		LD	A, val
04411E 2F          0003*M 		CPL
04411F 4F          0004*M 		LD	C, A
044120 ED 38 9D    0005*M 		IN0	A, (reg)
044123 A1          0006*M 		AND	C
044124 ED 39 9D    0007*M 		OUT0	(reg), A
044127 C1          0008*M 		POP	BC
044128 C9          0047*  			RET
044129             0048*  
044129             0049*  ; Open Drain IO
044129             0050*  ;
044129             0051*  GPIOB_M2:		RES_GPIO PB_DDR,  B
044129 C5          0001*M 		PUSH	BC
04412A 78          0002*M 		LD	A, val
04412B 2F          0003*M 		CPL
04412C 4F          0004*M 		LD	C, A
04412D ED 38 9B    0005*M 		IN0	A, (reg)
044130 A1          0006*M 		AND	C
044131 ED 39 9B    0007*M 		OUT0	(reg), A
044134 C1          0008*M 		POP	BC
044135             0052*  			SET_GPIO PB_ALT1, B
044135 ED 38 9C    0001*M 		IN0	A, (reg)
044138 B0          0002*M 		OR	val
044139 ED 39 9C    0003*M 		OUT0	(reg), A
04413C             0053*  			RES_GPIO PB_ALT2, B
04413C C5          0001*M 		PUSH	BC
04413D 78          0002*M 		LD	A, val
04413E 2F          0003*M 		CPL
04413F 4F          0004*M 		LD	C, A
044140 ED 38 9D    0005*M 		IN0	A, (reg)
044143 A1          0006*M 		AND	C
044144 ED 39 9D    0007*M 		OUT0	(reg), A
044147 C1          0008*M 		POP	BC
044148 C9          0054*  			RET
044149             0055*  
044149             0056*  ; Open Source IO
044149             0057*  ;
044149             0058*  GPIOB_M3:		SET_GPIO PB_DDR,  B
044149 ED 38 9B    0001*M 		IN0	A, (reg)
04414C B0          0002*M 		OR	val
04414D ED 39 9B    0003*M 		OUT0	(reg), A
044150             0059*  			SET_GPIO PB_ALT1, B
044150 ED 38 9C    0001*M 		IN0	A, (reg)
044153 B0          0002*M 		OR	val
044154 ED 39 9C    0003*M 		OUT0	(reg), A
044157             0060*  			RES_GPIO PB_ALT2, B
044157 C5          0001*M 		PUSH	BC
044158 78          0002*M 		LD	A, val
044159 2F          0003*M 		CPL
04415A 4F          0004*M 		LD	C, A
04415B ED 38 9D    0005*M 		IN0	A, (reg)
04415E A1          0006*M 		AND	C
04415F ED 39 9D    0007*M 		OUT0	(reg), A
044162 C1          0008*M 		POP	BC
044163 C9          0061*  			RET
044164             0062*  
044164             0063*  ; Interrupt, Dual Edge
044164             0064*  ;
044164             0065*  GPIOB_M4:		SET_GPIO PB_DR,   B
044164 ED 38 9A    0001*M 		IN0	A, (reg)
044167 B0          0002*M 		OR	val
044168 ED 39 9A    0003*M 		OUT0	(reg), A
04416B             0066*  			RES_GPIO PB_DDR,  B
04416B C5          0001*M 		PUSH	BC
04416C 78          0002*M 		LD	A, val
04416D 2F          0003*M 		CPL
04416E 4F          0004*M 		LD	C, A
04416F ED 38 9B    0005*M 		IN0	A, (reg)
044172 A1          0006*M 		AND	C
044173 ED 39 9B    0007*M 		OUT0	(reg), A
044176 C1          0008*M 		POP	BC
044177             0067*  			RES_GPIO PB_ALT1, B
044177 C5          0001*M 		PUSH	BC
044178 78          0002*M 		LD	A, val
044179 2F          0003*M 		CPL
04417A 4F          0004*M 		LD	C, A
04417B ED 38 9C    0005*M 		IN0	A, (reg)
04417E A1          0006*M 		AND	C
04417F ED 39 9C    0007*M 		OUT0	(reg), A
044182 C1          0008*M 		POP	BC
044183             0068*  			RES_GPIO PB_ALT2, B
044183 C5          0001*M 		PUSH	BC
044184 78          0002*M 		LD	A, val
044185 2F          0003*M 		CPL
044186 4F          0004*M 		LD	C, A
044187 ED 38 9D    0005*M 		IN0	A, (reg)
04418A A1          0006*M 		AND	C
04418B ED 39 9D    0007*M 		OUT0	(reg), A
04418E C1          0008*M 		POP	BC
04418F C9          0069*  			RET
044190             0070*  
044190             0071*  ; Alt Function
044190             0072*  ;
044190             0073*  GPIOB_M5:		SET_GPIO PB_DDR,  B
044190 ED 38 9B    0001*M 		IN0	A, (reg)
044193 B0          0002*M 		OR	val
044194 ED 39 9B    0003*M 		OUT0	(reg), A
044197             0074*  			RES_GPIO PB_ALT1, B
044197 C5          0001*M 		PUSH	BC
044198 78          0002*M 		LD	A, val
044199 2F          0003*M 		CPL
04419A 4F          0004*M 		LD	C, A
04419B ED 38 9C    0005*M 		IN0	A, (reg)
04419E A1          0006*M 		AND	C
04419F ED 39 9C    0007*M 		OUT0	(reg), A
0441A2 C1          0008*M 		POP	BC
0441A3             0075*  			SET_GPIO PB_ALT2, B
0441A3 ED 38 9D    0001*M 		IN0	A, (reg)
0441A6 B0          0002*M 		OR	val
0441A7 ED 39 9D    0003*M 		OUT0	(reg), A
0441AA C9          0076*  			RET
0441AB             0077*  
0441AB             0078*  ; Interrupt, Active Low
0441AB             0079*  ;
0441AB             0080*  GPIOB_M6:		RES_GPIO PB_DR,   B
0441AB C5          0001*M 		PUSH	BC
0441AC 78          0002*M 		LD	A, val
0441AD 2F          0003*M 		CPL
0441AE 4F          0004*M 		LD	C, A
0441AF ED 38 9A    0005*M 		IN0	A, (reg)
0441B2 A1          0006*M 		AND	C
0441B3 ED 39 9A    0007*M 		OUT0	(reg), A
0441B6 C1          0008*M 		POP	BC
0441B7             0081*  			RES_GPIO PB_DDR,  B
0441B7 C5          0001*M 		PUSH	BC
0441B8 78          0002*M 		LD	A, val
0441B9 2F          0003*M 		CPL
0441BA 4F          0004*M 		LD	C, A
0441BB ED 38 9B    0005*M 		IN0	A, (reg)
0441BE A1          0006*M 		AND	C
0441BF ED 39 9B    0007*M 		OUT0	(reg), A
0441C2 C1          0008*M 		POP	BC
0441C3             0082*  			SET_GPIO PB_ALT1, B
0441C3 ED 38 9C    0001*M 		IN0	A, (reg)
0441C6 B0          0002*M 		OR	val
0441C7 ED 39 9C    0003*M 		OUT0	(reg), A
0441CA             0083*  			SET_GPIO PB_ALT2, B
0441CA ED 38 9D    0001*M 		IN0	A, (reg)
0441CD B0          0002*M 		OR	val
0441CE ED 39 9D    0003*M 		OUT0	(reg), A
0441D1 C9          0084*  			RET
0441D2             0085*  
0441D2             0086*  
0441D2             0087*  ; Interrupt, Active High
0441D2             0088*  ;
0441D2             0089*  GPIOB_M7:		SET_GPIO PB_DR,   B
0441D2 ED 38 9A    0001*M 		IN0	A, (reg)
0441D5 B0          0002*M 		OR	val
0441D6 ED 39 9A    0003*M 		OUT0	(reg), A
0441D9             0090*  			RES_GPIO PB_DDR,  B
0441D9 C5          0001*M 		PUSH	BC
0441DA 78          0002*M 		LD	A, val
0441DB 2F          0003*M 		CPL
0441DC 4F          0004*M 		LD	C, A
0441DD ED 38 9B    0005*M 		IN0	A, (reg)
0441E0 A1          0006*M 		AND	C
0441E1 ED 39 9B    0007*M 		OUT0	(reg), A
0441E4 C1          0008*M 		POP	BC
0441E5             0091*  			SET_GPIO PB_ALT1, B
0441E5 ED 38 9C    0001*M 		IN0	A, (reg)
0441E8 B0          0002*M 		OR	val
0441E9 ED 39 9C    0003*M 		OUT0	(reg), A
0441EC             0092*  			SET_GPIO PB_ALT2, B
0441EC ED 38 9D    0001*M 		IN0	A, (reg)
0441EF B0          0002*M 		OR	val
0441F0 ED 39 9D    0003*M 		OUT0	(reg), A
0441F3 C9          0093*  			RET
0441F4             0094*  
0441F4             0095*  
0441F4             0096*  ; Interrupt, Falling Edge
0441F4             0097*  ;
0441F4             0098*  GPIOB_M8:		RES_GPIO PB_DR,   B
0441F4 C5          0001*M 		PUSH	BC
0441F5 78          0002*M 		LD	A, val
0441F6 2F          0003*M 		CPL
0441F7 4F          0004*M 		LD	C, A
0441F8 ED 38 9A    0005*M 		IN0	A, (reg)
0441FB A1          0006*M 		AND	C
0441FC ED 39 9A    0007*M 		OUT0	(reg), A
0441FF C1          0008*M 		POP	BC
044200             0099*  			SET_GPIO PB_DDR,  B
044200 ED 38 9B    0001*M 		IN0	A, (reg)
044203 B0          0002*M 		OR	val
044204 ED 39 9B    0003*M 		OUT0	(reg), A
044207             0100*  			SET_GPIO PB_ALT1, B
044207 ED 38 9C    0001*M 		IN0	A, (reg)
04420A B0          0002*M 		OR	val
04420B ED 39 9C    0003*M 		OUT0	(reg), A
04420E             0101*  			SET_GPIO PB_ALT2, B
04420E ED 38 9D    0001*M 		IN0	A, (reg)
044211 B0          0002*M 		OR	val
044212 ED 39 9D    0003*M 		OUT0	(reg), A
044215 C9          0102*  			RET
044216             0103*  
044216             0104*  ; Interrupt, Rising Edge
044216             0105*  ;
044216             0106*  GPIOB_M9:		SET_GPIO PB_DR,   B
044216 ED 38 9A    0001*M 		IN0	A, (reg)
044219 B0          0002*M 		OR	val
04421A ED 39 9A    0003*M 		OUT0	(reg), A
04421D             0107*  			SET_GPIO PB_DDR,  B
04421D ED 38 9B    0001*M 		IN0	A, (reg)
044220 B0          0002*M 		OR	val
044221 ED 39 9B    0003*M 		OUT0	(reg), A
044224             0108*  			SET_GPIO PB_ALT1, B
044224 ED 38 9C    0001*M 		IN0	A, (reg)
044227 B0          0002*M 		OR	val
044228 ED 39 9C    0003*M 		OUT0	(reg), A
04422B             0109*  			SET_GPIO PB_ALT2, B
04422B ED 38 9D    0001*M 		IN0	A, (reg)
04422E B0          0002*M 		OR	val
04422F ED 39 9D    0003*M 		OUT0	(reg), A
044232 C9          0110*  			RET
044233             0011       include "interrupts.asm"
044233             0001*  ;
044233             0002*  ; Title:	BBC Basic for AGON - Interrupts
044233             0003*  ; Author:	Dean Belfield
044233             0004*  ; Created:	12/05/2023
044233             0005*  ; Last Updated:	07/06/2023
044233             0006*  ;
044233             0007*  ; Modinfo:
044233             0008*  ; 07/06/2023:	Modified to run in ADL mode
044233             0009*  
044233             0010*  			; .ASSUME	ADL = 1
044233             0011*  
044233             0012*  			; INCLUDE	"macros.inc"
044233             0013*  			; INCLUDE	"equs.inc"
044233             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
044233             0015*  
044233             0016*  			; SEGMENT CODE
044233             0017*  
044233             0018*  			; XDEF	VBLANK_INIT
044233             0019*  			; XDEF	VBLANK_STOP
044233             0020*  			; XDEF	VBLANK_HANDLER
044233             0021*  
044233             0022*  			; XREF	ESCSET
044233             0023*  			; XREF	KEYDOWN		; In ram.asm
044233             0024*  			; XREF	KEYASCII 	; In ram.asm
044233             0025*  			; XREF	KEYCOUNT	; In ram.asm
044233             0026*  
044233             0027*  ; Hook into the MOS VBLANK interrupt
044233             0028*  ;
044233 F3          0029*  VBLANK_INIT:		DI
044234 21 88 42 04 0030*  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
044238 1E 32       0031*  			LD		E, 32h				; Set up the VBlank Interrupt Vector
04423A             0032*  			MOSCALL		mos_setintvector
04423A 3E 14       0001*M 			LD	A, function
04423C 49 CF       0002*M 			RST.LIS	08h
04423E             0033*  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
04423E EB          0034*  			ex de,hl
04423F 21 96 42 04 0035*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
044243 ED 1F       0036*  			LD		(HL), DE			; Self-modify the code
044245 FB          0037*  			EI
044246 C9          0038*  			RET
044247             0039*  
044247             0040*  ; Unhook the custom VBLANK interrupt
044247             0041*  ;
044247 F3          0042*  VBLANK_STOP:		DI
044248 21 96 42 04 0043*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04424C ED 17       0044*  			LD		DE, (HL)
04424E EB          0045*  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
04424F 1E 32       0046*  			LD		E, 32h
044251             0047*  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
044251 3E 14       0001*M 			LD	A, function
044253 49 CF       0002*M 			RST.LIS	08h
044255 FB          0048*  			EI
044256 C9          0049*  			RET
044257             0050*  
044257             0051*  ; A safe LIS call to ESCSET
044257             0052*  ;
044257             0053*  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
044257 3E 08       0001*M 			LD	A, function
044259 49 CF       0002*M 			RST.LIS	08h
04425B 21 49 05 04 0054*  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04425F DD 7E 19    0055*  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
044262 BE          0056*  			CP 		(HL)				; with our local copy
044263 20 0A       0057*  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
044265             0058*  ;
044265 AF          0059*  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
044266 32 48 05 04 0060*  			LD		(KEYASCII), A
04426A 32 47 05 04 0061*  			LD		(KEYDOWN), A
04426E C9          0062*  			RET	 					; And return
04426F             0063*  ;
04426F 77          0064*  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
044270 DD 7E 18    0065*  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
044273 B7          0066*  			OR		A
044274 28 EF       0067*  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
044276             0068*  ;
044276 32 47 05 04 0069*  			LD		(KEYDOWN), A 			; Store the keydown value
04427A DD 7E 05    0070*  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
04427D 32 48 05 04 0071*  			LD		(KEYASCII), A 			; Store locally
044281 FE 1B       0072*  			CP		1Bh				; Is it escape?
044283 CC 6C 49 04 0073*  			CALL		Z, ESCSET			; Yes, so set the escape flags
044287 C9          0074*  			RET						; Return to the interrupt handler
044288             0075*  
044288 F3          0076*  VBLANK_HANDLER:		DI
044289 F5          0077*  			PUSH		AF
04428A E5          0078*  			PUSH		HL
04428B DD E5       0079*  			PUSH		IX
04428D CD 57 42 04 0080*  			CALL		DO_KEYBOARD
044291 DD E1       0081*  			POP		IX
044293 E1          0082*  			POP		HL
044294 F1          0083*  			POP		AF
044295             0084*  ;
044295             0085*  ; Finally jump to the MOS interrupt
044295             0086*  ;
044295 C3 00 00 00 0087*  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
044299             0012       include "agon_graphics.asm"
044299             0001*  ;
044299             0002*  ; Title:	BBC Basic for AGON - Graphics stuff
044299             0003*  ; Author:	Dean Belfield
044299             0004*  ; Created:	12/05/2023
044299             0005*  ; Last Updated:	07/06/2023
044299             0006*  ;
044299             0007*  ; Modinfo:
044299             0008*  ; 07/06/2023:	Modified to run in ADL mode
044299             0009*  
044299             0010*  			; .ASSUME	ADL = 1
044299             0011*  
044299             0012*  			; INCLUDE	"equs.inc"
044299             0013*  			; INCLUDE "macros.inc"
044299             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
044299             0015*  
044299             0016*  			; SEGMENT CODE
044299             0017*  
044299             0018*  			; XDEF	CLG
044299             0019*  			; XDEF	CLRSCN
044299             0020*  			; XDEF	MODE
044299             0021*  			; XDEF	COLOUR
044299             0022*  			; XDEF	GCOL
044299             0023*  			; XDEF	MOVE
044299             0024*  			; XDEF	PLOT
044299             0025*  			; XDEF	DRAW
044299             0026*  			; XDEF	POINT
044299             0027*  			; XDEF	GETSCHR
044299             0028*  
044299             0029*  			; XREF	OSWRCH
044299             0030*  			; XREF	ASC_TO_NUMBER
044299             0031*  			; XREF	EXTERR
044299             0032*  			; XREF	EXPRI
044299             0033*  			; XREF	COMMA
044299             0034*  			; XREF	XEQ
044299             0035*  			; XREF	NXT
044299             0036*  			; XREF	BRAKET
044299             0037*  			; XREF	COUNT0
044299             0038*  			; XREF	CRTONULL
044299             0039*  			; XREF	NULLTOCR
044299             0040*  			; XREF	CRLF
044299             0041*  			; XREF	EXPR_W2
044299             0042*  			; XREF	INKEY1
044299             0043*  
044299             0044*  ; CLG: clears the graphics area
044299             0045*  ;
044299             0046*  CLG:			VDU	10h
044299 3E 10       0001*M 		LD	A, val
04429B CD 20 49 04 0002*M 		CALL	OSWRCH
04429F C3 E3 1D 04 0047*  			JP	XEQ
0442A3             0048*  
0442A3             0049*  ; CLS: clears the text area
0442A3             0050*  ;
0442A3 3E 0C       0051*  CLRSCN:			LD	A, 0Ch
0442A5 C3 20 49 04 0052*  			JP	OSWRCH
0442A9             0053*  
0442A9             0054*  ; MODE n: Set video mode
0442A9             0055*  ;
0442A9 DD E5       0056*  MODE:			PUSH	IX			; Get the system vars in IX
0442AB             0057*  			MOSCALL	mos_sysvars		; Reset the semaphore
0442AB 3E 08       0001*M 			LD	A, function
0442AD 49 CF       0002*M 			RST.LIS	08h
0442AF DD CB 04 A6 0058*  			RES	4, (IX+sysvar_vpd_pflags)
0442B3 CD 54 15 04 0059*  			CALL    EXPRI
0442B7 D9          0060*  			EXX
0442B8             0061*  			VDU	16H			; Mode change
0442B8 3E 16       0001*M 		LD	A, val
0442BA CD 20 49 04 0002*M 		CALL	OSWRCH
0442BE             0062*  			VDU	L
0442BE 7D          0001*M 		LD	A, val
0442BF CD 20 49 04 0002*M 		CALL	OSWRCH
0442C3             0063*  			MOSCALL	mos_sysvars
0442C3 3E 08       0001*M 			LD	A, function
0442C5 49 CF       0002*M 			RST.LIS	08h
0442C7 DD CB 04 66 0064*  @@:			BIT	4, (IX+sysvar_vpd_pflags)
0442CB 28 FA       0065*  			JR	Z, @B			; Wait for the result
0442CD DD E1       0066*  			POP	IX
0442CF C3 E3 1D 04 0067*  			JP	XEQ
0442D3             0068*  
0442D3             0069*  ; GET(x,y): Get the ASCII code of a character on screen
0442D3             0070*  ;
0442D3 FD 23       0071*  GETSCHR:		INC	IY
0442D5 CD 54 15 04 0072*  			CALL    EXPRI      		; Get X coordinate
0442D9 D9          0073*  			EXX
0442DA 22 00 02 04 0074*  			LD	(VDU_BUFFER+0), HL
0442DE CD 6F 1C 04 0075*  			CALL	COMMA
0442E2 CD 54 15 04 0076*  			CALL	EXPRI			; Get Y coordinate
0442E6 D9          0077*  			EXX
0442E7 22 02 02 04 0078*  			LD	(VDU_BUFFER+2), HL
0442EB CD 7C 1C 04 0079*  			CALL	BRAKET			; Closing bracket
0442EF             0080*  ;
0442EF DD E5       0081*  			PUSH	IX			; Get the system vars in IX
0442F1             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
0442F1 3E 08       0001*M 			LD	A, function
0442F3 49 CF       0002*M 			RST.LIS	08h
0442F5 DD CB 04 8E 0083*  			RES	1, (IX+sysvar_vpd_pflags)
0442F9             0084*  			VDU	23
0442F9 3E 17       0001*M 		LD	A, val
0442FB CD 20 49 04 0002*M 		CALL	OSWRCH
0442FF             0085*  			VDU	0
0442FF 3E 00       0001*M 		LD	A, val
044301 CD 20 49 04 0002*M 		CALL	OSWRCH
044305             0086*  			VDU	vdp_scrchar
044305 3E 83       0001*M 		LD	A, val
044307 CD 20 49 04 0002*M 		CALL	OSWRCH
04430B             0087*  			VDU	(VDU_BUFFER+0)
04430B 3A 00 02 04 0001*M 		LD	A, val
04430F CD 20 49 04 0002*M 		CALL	OSWRCH
044313             0088*  			VDU	(VDU_BUFFER+1)
044313 3A 01 02 04 0001*M 		LD	A, val
044317 CD 20 49 04 0002*M 		CALL	OSWRCH
04431B             0089*  			VDU	(VDU_BUFFER+2)
04431B 3A 02 02 04 0001*M 		LD	A, val
04431F CD 20 49 04 0002*M 		CALL	OSWRCH
044323             0090*  			VDU	(VDU_BUFFER+3)
044323 3A 03 02 04 0001*M 		LD	A, val
044327 CD 20 49 04 0002*M 		CALL	OSWRCH
04432B DD CB 04 4E 0091*  @@:			BIT	1, (IX+sysvar_vpd_pflags)
04432F 28 FA       0092*  			JR	Z, @B			; Wait for the result
044331 DD 7E 09    0093*  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
044334 B7          0094*  			OR	A			; Check for 00h
044335 37          0095*  			SCF				; C = character map
044336 20 02       0096*  			JR	NZ, @F			; We have a character, so skip next bit
044338 AF          0097*  			XOR	A			; Clear carry
044339 3D          0098*  			DEC	A			; Set A to FFh
04433A DD E1       0099*  @@:			POP	IX
04433C C3 2B 1A 04 0100*  			JP	INKEY1			; Jump back to the GET command
044340             0101*  
044340             0102*  ; POINT(x,y): Get the pixel colour of a point on screen
044340             0103*  ;
044340 CD 54 15 04 0104*  POINT:			CALL    EXPRI      		; Get X coordinate
044344 D9          0105*  			EXX
044345 22 00 02 04 0106*  			LD	(VDU_BUFFER+0), HL
044349 CD 6F 1C 04 0107*  			CALL	COMMA
04434D CD 54 15 04 0108*  			CALL	EXPRI			; Get Y coordinate
044351 D9          0109*  			EXX
044352 22 02 02 04 0110*  			LD	(VDU_BUFFER+2), HL
044356 CD 7C 1C 04 0111*  			CALL	BRAKET			; Closing bracket
04435A             0112*  ;
04435A DD E5       0113*  			PUSH	IX			; Get the system vars in IX
04435C             0114*  			MOSCALL	mos_sysvars		; Reset the semaphore
04435C 3E 08       0001*M 			LD	A, function
04435E 49 CF       0002*M 			RST.LIS	08h
044360 DD CB 04 96 0115*  			RES	2, (IX+sysvar_vpd_pflags)
044364             0116*  			VDU	23
044364 3E 17       0001*M 		LD	A, val
044366 CD 20 49 04 0002*M 		CALL	OSWRCH
04436A             0117*  			VDU	0
04436A 3E 00       0001*M 		LD	A, val
04436C CD 20 49 04 0002*M 		CALL	OSWRCH
044370             0118*  			VDU	vdp_scrpixel
044370 3E 84       0001*M 		LD	A, val
044372 CD 20 49 04 0002*M 		CALL	OSWRCH
044376             0119*  			VDU	(VDU_BUFFER+0)
044376 3A 00 02 04 0001*M 		LD	A, val
04437A CD 20 49 04 0002*M 		CALL	OSWRCH
04437E             0120*  			VDU	(VDU_BUFFER+1)
04437E 3A 01 02 04 0001*M 		LD	A, val
044382 CD 20 49 04 0002*M 		CALL	OSWRCH
044386             0121*  			VDU	(VDU_BUFFER+2)
044386 3A 02 02 04 0001*M 		LD	A, val
04438A CD 20 49 04 0002*M 		CALL	OSWRCH
04438E             0122*  			VDU	(VDU_BUFFER+3)
04438E 3A 03 02 04 0001*M 		LD	A, val
044392 CD 20 49 04 0002*M 		CALL	OSWRCH
044396 DD CB 04 56 0123*  @@:			BIT	2, (IX+sysvar_vpd_pflags)
04439A 28 FA       0124*  			JR	Z, @B			; Wait for the result
04439C             0125*  ;
04439C             0126*  ; Return the data as a 1 byte index
04439C             0127*  ;
04439C DD 6E 16    0128*  			LD	L, (IX+sysvar_scrpixelIndex)
04439F DD E1       0129*  			POP	IX
0443A1 C3 C9 17 04 0130*  			JP	COUNT0
0443A5             0131*  
0443A5             0132*  
0443A5             0133*  ; COLOUR colour
0443A5             0134*  ; COLOUR L,P
0443A5             0135*  ; COLOUR L,R,G,B
0443A5             0136*  ;
0443A5 CD 54 15 04 0137*  COLOUR:			CALL	EXPRI			; The colour / mode
0443A9 D9          0138*  			EXX
0443AA 7D          0139*  			LD	A, L
0443AB 32 00 02 04 0140*  			LD	(VDU_BUFFER+0), A	; Store first parameter
0443AF CD BD 1C 04 0141*  			CALL	NXT			; Are there any more parameters?
0443B3 FE 2C       0142*  			CP	','
0443B5 28 12       0143*  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0443B7             0144*  ;
0443B7             0145*  			VDU	11h			; Just set the colour
0443B7 3E 11       0001*M 		LD	A, val
0443B9 CD 20 49 04 0002*M 		CALL	OSWRCH
0443BD             0146*  			VDU	(VDU_BUFFER+0)
0443BD 3A 00 02 04 0001*M 		LD	A, val
0443C1 CD 20 49 04 0002*M 		CALL	OSWRCH
0443C5 C3 E3 1D 04 0147*  			JP	XEQ
0443C9             0148*  ;
0443C9 CD 6F 1C 04 0149*  COLOUR_1:		CALL	COMMA
0443CD CD 54 15 04 0150*  			CALL	EXPRI			; Parse R (OR P)
0443D1 D9          0151*  			EXX
0443D2 7D          0152*  			LD	A, L
0443D3 32 01 02 04 0153*  			LD	(VDU_BUFFER+1), A
0443D7 CD BD 1C 04 0154*  			CALL	NXT			; Are there any more parameters?
0443DB FE 2C       0155*  			CP	','
0443DD 28 2C       0156*  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
0443DF             0157*  ;
0443DF             0158*  			VDU	13h			; VDU:COLOUR
0443DF 3E 13       0001*M 		LD	A, val
0443E1 CD 20 49 04 0002*M 		CALL	OSWRCH
0443E5             0159*  			VDU	(VDU_BUFFER+0)		; Logical Colour
0443E5 3A 00 02 04 0001*M 		LD	A, val
0443E9 CD 20 49 04 0002*M 		CALL	OSWRCH
0443ED             0160*  			VDU	(VDU_BUFFER+1)		; Palette Colour
0443ED 3A 01 02 04 0001*M 		LD	A, val
0443F1 CD 20 49 04 0002*M 		CALL	OSWRCH
0443F5             0161*  			VDU	0			; RGB set to 0
0443F5 3E 00       0001*M 		LD	A, val
0443F7 CD 20 49 04 0002*M 		CALL	OSWRCH
0443FB             0162*  			VDU	0
0443FB 3E 00       0001*M 		LD	A, val
0443FD CD 20 49 04 0002*M 		CALL	OSWRCH
044401             0163*  			VDU	0
044401 3E 00       0001*M 		LD	A, val
044403 CD 20 49 04 0002*M 		CALL	OSWRCH
044407 C3 E3 1D 04 0164*  			JP	XEQ
04440B             0165*  ;
04440B CD 6F 1C 04 0166*  COLOUR_2:		CALL	COMMA
04440F CD 54 15 04 0167*  			CALL	EXPRI			; Parse G
044413 D9          0168*  			EXX
044414 7D          0169*  			LD	A, L
044415 32 02 02 04 0170*  			LD	(VDU_BUFFER+2), A
044419 CD 6F 1C 04 0171*  			CALL	COMMA
04441D CD 54 15 04 0172*  			CALL	EXPRI			; Parse B
044421 D9          0173*  			EXX
044422 7D          0174*  			LD	A, L
044423 32 03 02 04 0175*  			LD	(VDU_BUFFER+3), A
044427             0176*  			VDU	13h			; VDU:COLOUR
044427 3E 13       0001*M 		LD	A, val
044429 CD 20 49 04 0002*M 		CALL	OSWRCH
04442D             0177*  			VDU	(VDU_BUFFER+0)		; Logical Colour
04442D 3A 00 02 04 0001*M 		LD	A, val
044431 CD 20 49 04 0002*M 		CALL	OSWRCH
044435             0178*  			VDU	FFh			; Physical Colour (-1 for RGB mode)
044435 3E FF       0001*M 		LD	A, val
044437 CD 20 49 04 0002*M 		CALL	OSWRCH
04443B             0179*  			VDU	(VDU_BUFFER+1)		; R
04443B 3A 01 02 04 0001*M 		LD	A, val
04443F CD 20 49 04 0002*M 		CALL	OSWRCH
044443             0180*  			VDU	(VDU_BUFFER+2)		; G
044443 3A 02 02 04 0001*M 		LD	A, val
044447 CD 20 49 04 0002*M 		CALL	OSWRCH
04444B             0181*  			VDU	(VDU_BUFFER+3)		; B
04444B 3A 03 02 04 0001*M 		LD	A, val
04444F CD 20 49 04 0002*M 		CALL	OSWRCH
044453 C3 E3 1D 04 0182*  			JP	XEQ
044457             0183*  
044457             0184*  ; GCOL mode,colour
044457             0185*  ;
044457 CD 54 15 04 0186*  GCOL:			CALL	EXPRI			; Parse MODE
04445B D9          0187*  			EXX
04445C 7D          0188*  			LD	A, L
04445D 32 00 02 04 0189*  			LD	(VDU_BUFFER+0), A
044461 CD 6F 1C 04 0190*  			CALL	COMMA
044465             0191*  ;
044465 CD 54 15 04 0192*  			CALL	EXPRI			; Parse Colour
044469 D9          0193*  			EXX
04446A 7D          0194*  			LD	A, L
04446B 32 01 02 04 0195*  			LD	(VDU_BUFFER+1), A
04446F             0196*  ;
04446F             0197*  			VDU	12h			; VDU:GCOL
04446F 3E 12       0001*M 		LD	A, val
044471 CD 20 49 04 0002*M 		CALL	OSWRCH
044475             0198*  			VDU	(VDU_BUFFER+0)		; Mode
044475 3A 00 02 04 0001*M 		LD	A, val
044479 CD 20 49 04 0002*M 		CALL	OSWRCH
04447D             0199*  			VDU	(VDU_BUFFER+1)		; Colour
04447D 3A 01 02 04 0001*M 		LD	A, val
044481 CD 20 49 04 0002*M 		CALL	OSWRCH
044485 C3 E3 1D 04 0200*  			JP	XEQ
044489             0201*  
044489             0202*  ; PLOT mode,x,y
044489             0203*  ;
044489 CD 54 15 04 0204*  PLOT:			CALL	EXPRI		; Parse mode
04448D D9          0205*  			EXX
04448E E5          0206*  			PUSH	HL		; Push mode (L) onto stack
04448F CD 6F 1C 04 0207*  			CALL	COMMA
044493 CD D6 4D 04 0208*  			CALL	EXPR_W2		; Parse X and Y
044497 C1          0209*  			POP	BC		; Pop mode (C) off stack
044498             0210*  PLOT_1:			VDU	19H		; VDU code for PLOT
044498 3E 19       0001*M 		LD	A, val
04449A CD 20 49 04 0002*M 		CALL	OSWRCH
04449E             0211*  			VDU	C		;  C: Mode
04449E 79          0001*M 		LD	A, val
04449F CD 20 49 04 0002*M 		CALL	OSWRCH
0444A3             0212*  			VDU	E		; DE: X
0444A3 7B          0001*M 		LD	A, val
0444A4 CD 20 49 04 0002*M 		CALL	OSWRCH
0444A8             0213*  			VDU	D
0444A8 7A          0001*M 		LD	A, val
0444A9 CD 20 49 04 0002*M 		CALL	OSWRCH
0444AD             0214*  			VDU	L		; HL: Y
0444AD 7D          0001*M 		LD	A, val
0444AE CD 20 49 04 0002*M 		CALL	OSWRCH
0444B2             0215*  			VDU	H
0444B2 7C          0001*M 		LD	A, val
0444B3 CD 20 49 04 0002*M 		CALL	OSWRCH
0444B7 C3 E3 1D 04 0216*  			JP	XEQ
0444BB             0217*  
0444BB             0218*  ; MOVE x,y
0444BB             0219*  ;
0444BB CD D6 4D 04 0220*  MOVE:			CALL	EXPR_W2		; Parse X and Y
0444BF 0E 04       0221*  			LD	C, 04H		; Plot mode 04H (Move)
0444C1 18 D5       0222*  			JR	PLOT_1		; Plot
0444C3             0223*  
0444C3             0224*  ; DRAW x1,y1
0444C3             0225*  ; DRAW x1,y1,x2,y2
0444C3             0226*  ;
0444C3 CD D6 4D 04 0227*  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0444C7 CD BD 1C 04 0228*  			CALL	NXT		; Are there any more parameters?
0444CB FE 2C       0229*  			CP	','
0444CD 0E 05       0230*  			LD	C, 05h		; Code for LINE
0444CF 20 C7       0231*  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0444D1             0232*  			VDU	19h		; Move to the first coordinates
0444D1 3E 19       0001*M 		LD	A, val
0444D3 CD 20 49 04 0002*M 		CALL	OSWRCH
0444D7             0233*  			VDU	04h
0444D7 3E 04       0001*M 		LD	A, val
0444D9 CD 20 49 04 0002*M 		CALL	OSWRCH
0444DD             0234*  			VDU	E
0444DD 7B          0001*M 		LD	A, val
0444DE CD 20 49 04 0002*M 		CALL	OSWRCH
0444E2             0235*  			VDU	D
0444E2 7A          0001*M 		LD	A, val
0444E3 CD 20 49 04 0002*M 		CALL	OSWRCH
0444E7             0236*  			VDU	L
0444E7 7D          0001*M 		LD	A, val
0444E8 CD 20 49 04 0002*M 		CALL	OSWRCH
0444EC             0237*  			VDU	H
0444EC 7C          0001*M 		LD	A, val
0444ED CD 20 49 04 0002*M 		CALL	OSWRCH
0444F1 CD 6F 1C 04 0238*  			CALL	COMMA
0444F5 C5          0239*  			PUSH	BC
0444F6 CD D6 4D 04 0240*  			CALL	EXPR_W2		; Get X2 and Y2
0444FA C1          0241*  			POP	BC
0444FB 18 9B       0242*  			JR	PLOT_1		; Now DRAW the line to those positions
0444FD             0243*  
0444FD             0244*  
0444FD             0245*  
0444FD             0013       include "agon_sound.asm"
0444FD             0001*  ;
0444FD             0002*  ; Title:	BBC Basic for AGON - Audio stuff
0444FD             0003*  ; Author:	Dean Belfield
0444FD             0004*  ; Created:	12/05/2023
0444FD             0005*  ; Last Updated:	12/05/2023
0444FD             0006*  ;
0444FD             0007*  ; Modinfo:
0444FD             0008*  
0444FD             0009*  			; .ASSUME	ADL = 1
0444FD             0010*  
0444FD             0011*  			; INCLUDE	"equs.inc"
0444FD             0012*  			; INCLUDE "macros.inc"
0444FD             0013*  			; INCLUDE "mos_api.inc"	; In MOS/src
0444FD             0014*  
0444FD             0015*  			; SEGMENT CODE
0444FD             0016*  
0444FD             0017*  			; XDEF	SOUND
0444FD             0018*  
0444FD             0019*  			; XREF	COMMA
0444FD             0020*  			; XREF	EXPR_W2
0444FD             0021*  			; XREF	XEQ
0444FD             0022*  			; XREF	LTRAP
0444FD             0023*  			; XREF	OSWRCH
0444FD             0024*  			; XREF	VDU_BUFFER
0444FD             0025*  
0444FD             0026*  
0444FD             0027*  ; SOUND channel,volume,pitch,duration
0444FD             0028*  ; volume: 0 (off) to -15 (full volume)
0444FD             0029*  ; pitch: 0 - 255
0444FD             0030*  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
0444FD             0031*  ;
0444FD CD D6 4D 04 0032*  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
044501 7D          0033*  			LD	A, L 			;  A: Volume
044502 F5          0034*  			PUSH	AF
044503 D5          0035*  			PUSH	DE
044504 CD 6F 1C 04 0036*  			CALL	COMMA
044508 CD D6 4D 04 0037*  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
04450C 53          0038*  			LD	D, E			;  D: Pitch
04450D 5D          0039*  			LD	E, L 			;  E: Duration
04450E E1          0040*  			POP	HL 			; HL: Channel/Control
04450F F1          0041*  			POP	AF
044510 ED 44       0042*  			NEG
044512 FE 10       0043*  			CP	16			; Check volume is in bounds
044514 D2 E3 1D 04 0044*  			JP	NC, XEQ			; Out of bounds, do nothing
044518             0045*  ;
044518             0046*  ; Store	in VDU vars
044518             0047*  ;
044518 4F          0048*  			LD	C, A			; Store Volume in C
044519 7D          0049*  			LD	A, L
04451A 32 00 02 04 0050*  			LD	(VDU_BUFFER+0), A	; Channel
04451E AF          0051*  			XOR	A
04451F 32 01 02 04 0052*  			LD	(VDU_BUFFER+1), A	; Waveform
044523             0053*  ;
044523             0054*  ; Calculate the volume
044523             0055*  ;
044523 06 06       0056*  			LD	B, 6			; C already contains the volume
044525 ED 4C       0057*  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
044527 79          0058*  			LD	A, C
044528 32 02 02 04 0059*  			LD	(VDU_BUFFER+2), A
04452C             0060*  ;
04452C             0061*  ; And the frequency
04452C             0062*  ;
04452C 4B          0063*  			LD	C, E			; Store duration in C
04452D 26 00       0064*  			LD	H, 0			; Lookup the frequency
04452F 6A          0065*  			LD	L, D
044530 11 B7 45 04 0066*  			LD	DE, SOUND_FREQ_LOOKUP
044534 29          0067*  			ADD	HL, HL
044535 19          0068*  			ADD	HL, DE
044536 7E          0069*  			LD	A, (HL)
044537 32 03 02 04 0070*  			LD	(VDU_BUFFER+3), A
04453B 23          0071*  			INC	HL
04453C 7E          0072*  			LD	A, (HL)
04453D 32 04 02 04 0073*  			LD	(VDU_BUFFER+4), A
044541             0074*  ;
044541             0075*  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
044541             0076*  ;
044541 06 32       0077*  			LD	B, 50			; C contains the duration, so MLT by 50
044543 ED 4C       0078*  			MLT	BC
044545 ED 43 05 02 0079*  			LD	(VDU_BUFFER+5), BC
       04          
04454A             0080*  ;
04454A DD E5       0081*  			PUSH	IX			; Get the system vars in IX
04454C             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
04454C 3E 08       0001*M 			LD	A, function
04454E 49 CF       0002*M 			RST.LIS	08h
044550 5B DD CB 04 0083*  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
044555             0084*  ;
044555             0085*  			VDU	23			; Send the sound command
044555 3E 17       0001*M 		LD	A, val
044557 CD 20 49 04 0002*M 		CALL	OSWRCH
04455B             0086*  			VDU	0
04455B 3E 00       0001*M 		LD	A, val
04455D CD 20 49 04 0002*M 		CALL	OSWRCH
044561             0087*  			VDU	vdp_audio
044561 3E 85       0001*M 		LD	A, val
044563 CD 20 49 04 0002*M 		CALL	OSWRCH
044567             0088*  			VDU	(VDU_BUFFER+0)		; 0: Channel
044567 3A 00 02 04 0001*M 		LD	A, val
04456B CD 20 49 04 0002*M 		CALL	OSWRCH
04456F             0089*  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
04456F 3A 01 02 04 0001*M 		LD	A, val
044573 CD 20 49 04 0002*M 		CALL	OSWRCH
044577             0090*  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
044577 3A 02 02 04 0001*M 		LD	A, val
04457B CD 20 49 04 0002*M 		CALL	OSWRCH
04457F             0091*  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
04457F 3A 03 02 04 0001*M 		LD	A, val
044583 CD 20 49 04 0002*M 		CALL	OSWRCH
044587             0092*  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
044587 3A 04 02 04 0001*M 		LD	A, val
04458B CD 20 49 04 0002*M 		CALL	OSWRCH
04458F             0093*  			VDU	(VDU_BUFFER+5)		; 5: Duration L
04458F 3A 05 02 04 0001*M 		LD	A, val
044593 CD 20 49 04 0002*M 		CALL	OSWRCH
044597             0094*  			VDU	(VDU_BUFFER+6)		; 6: Duration H
044597 3A 06 02 04 0001*M 		LD	A, val
04459B CD 20 49 04 0002*M 		CALL	OSWRCH
04459F             0095*  ;
04459F             0096*  ; Wait for acknowledgement
04459F             0097*  ;
04459F 5B DD CB 04 0098*  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
0445A4 28 F9       0099*  			JR	Z, @B			; Wait for the result
0445A6 CD 91 49 04 0100*  			CALL	LTRAP			; Check for ESC
0445AA 5B DD 7E 0E 0101*  			LD.LIL	A, (IX+sysvar_audioSuccess)
0445AE A7          0102*  			AND	A			; Check if VDP has queued the note
0445AF 28 9F       0103*  			JR	Z, SOUND0		; No, so loop back and send again
0445B1             0104*  ;
0445B1 DD E1       0105*  			POP	IX
0445B3 C3 E3 1D 04 0106*  			JP	XEQ
0445B7             0107*  
0445B7             0108*  ; Frequency Lookup Table
0445B7             0109*  ; Set up to replicate the BBC Micro audio frequencies
0445B7             0110*  ;
0445B7             0111*  ; Split over 5 complete octaves, with 53 being middle C
0445B7             0112*  ; * C4: 262hz
0445B7             0113*  ; + A4: 440hz
0445B7             0114*  ;
0445B7             0115*  ;	2	3	4	5	6	7	8
0445B7             0116*  ;
0445B7             0117*  ; B	1	49	97	145	193	241
0445B7             0118*  ; A#	0	45	93	141	189	237
0445B7             0119*  ; A		41	89+	137	185	233
0445B7             0120*  ; G#		37	85	133	181	229
0445B7             0121*  ; G		33	81	129	177	225
0445B7             0122*  ; F#		29	77	125	173	221
0445B7             0123*  ; F		25	73	121	169	217
0445B7             0124*  ; E		21	69	117	165	213
0445B7             0125*  ; D#		17	65	113	161	209
0445B7             0126*  ; D		13	61	109	157	205	253
0445B7             0127*  ; C#		9	57	105	153	201	249
0445B7             0128*  ; C		5	53*	101	149	197	245
0445B7             0129*  ;
0445B7 75 00 76 00 0130*  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
0445C7 89 00 8B 00 0131*  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
0445D7 99 00 9C 00 0132*  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
0445E7 AC 00 AF 00 0133*  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
0445F7 C1 00 C4 00 0134*  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
044607 D9 00 DC 00 0135*  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
044617 F3 00 F7 00 0136*  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
044627 11 01 15 01 0137*  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
044637 33 01 37 01 0138*  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
044647 58 01 5D 01 0139*  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
044657 82 01 88 01 0140*  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
044667 B2 01 B8 01 0141*  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
044677 E7 01 EE 01 0142*  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
044687 22 02 2A 02 0143*  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
044697 65 02 6E 02 0144*  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
0446A7 B1 02 BB 02 0145*  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
0446B7 05 03 10 03 0146*  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
0446C7 63 03 70 03 0147*  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
0446D7 CE 03 DC 03 0148*  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
0446E7 45 04 55 04 0149*  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
0446F7 CB 04 DD 04 0150*  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
044707 62 05 76 05 0151*  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
044717 0A 06 21 06 0152*  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
044727 C8 06 E1 06 0153*  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
044737 9C 07 B8 07 0154*  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
044747 8A 08 A9 08 0155*  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
044757 95 09 B9 09 0156*  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
044767 C2 0A EA 0A 0157*  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
044777 13 0C 40 0C 0158*  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
044787 8E 0D C0 0D 0159*  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
044797 36 0F 6F 0F 0160*  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
0447A7 13 11 53 11 0161*  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
0447B7             0162*  
0447B7             0163*  
0447B7             0014       include "misc.asm"
0447B7             0001*  ;
0447B7             0002*  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0447B7             0003*  ; Author:	Dean Belfield
0447B7             0004*  ; Created:	12/05/2023
0447B7             0005*  ; Last Updated:	12/05/2023
0447B7             0006*  ;
0447B7             0007*  ; Modinfo:
0447B7             0008*  
0447B7             0009*  			; INCLUDE	"equs.inc"
0447B7             0010*  			; INCLUDE	"macros.inc"
0447B7             0011*  
0447B7             0012*  			; .ASSUME	ADL = 1
0447B7             0013*  
0447B7             0014*  			; SEGMENT CODE
0447B7             0015*  
0447B7             0016*  			; XDEF	ASC_TO_NUMBER
0447B7             0017*  			; XDEF	SWITCH_A
0447B7             0018*  			; XDEF	NULLTOCR
0447B7             0019*  			; XDEF	CRTONULL
0447B7             0020*  			; XDEF	CSTR_FNAME
0447B7             0021*  			; XDEF	CSTR_LINE
0447B7             0022*  			; XDEF	CSTR_FINDCH
0447B7             0023*  			; XDEF	CSTR_ENDSWITH
0447B7             0024*  			; XDEF	CSTR_CAT
0447B7             0025*  
0447B7             0026*  			; XREF	OSWRCH
0447B7             0027*  			; XREF	KEYWDS
0447B7             0028*  			; XREF	KEYWDL
0447B7             0029*  
0447B7             0030*  ; Read a number and convert to binary
0447B7             0031*  ; If prefixed with &, will read as hex, otherwise decimal
0447B7             0032*  ;   Inputs: HL: Pointer in string buffer
0447B7             0033*  ;  Outputs: HL: Updated text pointer
0447B7             0034*  ;           DE: Value
0447B7             0035*  ;            A: Terminator (spaces skipped)
0447B7             0036*  ; Destroys: A,D,E,H,L,F
0447B7             0037*  ;
0447B7 C5          0038*  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0447B8 11 00 00 00 0039*  			LD	DE, 0			; Initialise DE
0447BC CD FE 47 04 0040*  			CALL	SKIPSPC			; Skip whitespace
0447C0 7E          0041*  			LD	A, (HL)			; Read first character
0447C1 FE 26       0042*  			CP	'&'			; Is it prefixed with '&' (HEX number)?
0447C3 20 1F       0043*  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0447C5 23          0044*  			INC	HL			; Otherwise fall through to ASC_TO_HEX
0447C6             0045*  ;
0447C6 7E          0046*  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0447C7 CD 0C 48 04 0047*  			CALL    UPPERC			; Convert to uppercase
0447CB D6 30       0048*  			SUB	'0'			; Normalise to 0
0447CD 38 2E       0049*  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0447CF FE 0A       0050*  			CP 	10			; Check if >= 10
0447D1 38 06       0051*  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0447D3 D6 07       0052*  			SUB 	7			; Adjust ASCII A-F to nibble
0447D5 FE 10       0053*  			CP 	16			; Check for > F
0447D7 30 24       0054*  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0447D9 EB          0055*  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0447DA 29          0056*  			ADD	HL, HL
0447DB 29          0057*  			ADD	HL, HL
0447DC 29          0058*  			ADD	HL, HL
0447DD 29          0059*  			ADD	HL, HL
0447DE EB          0060*  			EX	DE, HL
0447DF B3          0061*  			OR      E			; OR the new digit in to the least significant nibble
0447E0 5F          0062*  			LD      E, A
0447E1 23          0063*  			INC     HL			; Onto the next character
0447E2 18 E2       0064*  			JR      ASC_TO_NUMBER1		; And loop
0447E4             0065*  ;
0447E4 7E          0066*  ASC_TO_NUMBER3:		LD	A, (HL)
0447E5 D6 30       0067*  			SUB	'0'			; Normalise to 0
0447E7 38 14       0068*  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0447E9 FE 0A       0069*  			CP	10			; Check if >= 10
0447EB 30 10       0070*  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0447ED EB          0071*  			EX 	DE, HL 			; Stick DE in HL
0447EE 44          0072*  			LD	B, H 			; And copy HL into BC
0447EF 4D          0073*  			LD	C, L
0447F0 29          0074*  			ADD	HL, HL 			; x 2
0447F1 29          0075*  			ADD	HL, HL 			; x 4
0447F2 09          0076*  			ADD	HL, BC 			; x 5
0447F3 29          0077*  			ADD	HL, HL 			; x 10
0447F4 EB          0078*  			EX	DE, HL
0447F5             0079*  			ADD8U_DE 			; Add A to DE (macro)
0447F5 83          0001*M 		ADD	A, E
0447F6 5F          0002*M 		LD	E, A
0447F7 8A          0003*M 		ADC	A, D
0447F8 93          0004*M 		SUB	E
0447F9 57          0005*M 		LD	D, A
0447FA 23          0080*  			INC	HL
0447FB 18 E7       0081*  			JR	ASC_TO_NUMBER3
0447FD C1          0082*  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
0447FE             0083*  
0447FE             0084*  ; Skip a space
0447FE             0085*  ; HL: Pointer in string buffer
0447FE             0086*  ;
0447FE 7E          0087*  SKIPSPC:			LD      A, (HL)
0447FF FE 20       0088*  			CP      ' '
044801 C0          0089*  			RET     NZ
044802 23          0090*  			INC     HL
044803 18 F9       0091*  			JR      SKIPSPC
044805             0092*  
044805             0093*  ; Skip a string
044805             0094*  ; HL: Pointer in string buffer
044805             0095*  ;
044805 7E          0096*  SKIPNOTSP:		LD	A, (HL)
044806 FE 20       0097*  			CP	' '
044808 C8          0098*  			RET	Z
044809 23          0099*  			INC	HL
04480A 18 F9       0100*  			JR	SKIPNOTSP
04480C             0101*  
04480C             0102*  ; Convert a character to upper case
04480C             0103*  ;  A: Character to convert
04480C             0104*  ;
04480C E6 7F       0105*  UPPERC:  		AND     7FH
04480E FE 60       0106*  			CP      '`'
044810 D8          0107*  			RET     C
044811 E6 5F       0108*  			AND     5FH			; Convert to upper case
044813 C9          0109*  			RET
044814             0110*  
044814             0111*  ; Switch on A - lookup table immediately after call
044814             0112*  ;  A: Index into lookup table
044814             0113*  ;
044814 E3          0114*  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
044815 87          0115*  			ADD	A, A			; Multiply A by two
044816             0116*  			ADD8U_HL 			; Add to HL (macro)
044816 85          0001*M 		ADD	A, L
044817 6F          0002*M 		LD	L, A
044818 8C          0003*M 		ADC	A, H
044819 95          0004*M 		SUB	L
04481A 67          0005*M 		LD	H, A
04481B 7E          0117*  			LD	A, (HL)			; follow the call. Fetch an address from the
04481C 23          0118*  			INC	HL 			; table.
04481D 66          0119*  			LD	H, (HL)
04481E 6F          0120*  			LD	L, A
04481F E3          0121*  			EX	(SP), HL		; Swap this new address back, restores HL
044820 C9          0122*  			RET				; Return program control to this new address
044821             0123*  
044821             0124*  ; Convert the buffer to a null terminated string and back
044821             0125*  ; HL: Buffer address
044821             0126*  ;
044821 C5          0127*  NULLTOCR:		PUSH 	BC
044822 06 00       0128*  			LD	B, 0
044824 0E 0D       0129*  			LD	C, CR
044826 18 05       0130*  			JR	CRTONULL0
044828             0131*  ;
044828 C5          0132*  CRTONULL:		PUSH	BC
044829 06 0D       0133*  			LD	B, CR
04482B 0E 00       0134*  			LD	C, 0
04482D             0135*  ;
04482D E5          0136*  CRTONULL0:		PUSH	HL
04482E 7E          0137*  CRTONULL1:		LD	A, (HL)
04482F B8          0138*  			CP 	B
044830 28 03       0139*  			JR	Z, CRTONULL2
044832 23          0140*  			INC	HL
044833 18 F9       0141*  			JR	CRTONULL1
044835 71          0142*  CRTONULL2:		LD	(HL), C
044836 E1          0143*  			POP 	HL
044837 C1          0144*  			POP	BC
044838 C9          0145*  			RET
044839             0146*  
044839             0147*  ; Copy a filename to DE and zero terminate it
044839             0148*  ; HL: Source
044839             0149*  ; DE: Destination (ACCS)
044839             0150*  ;
044839 7E          0151*  CSTR_FNAME:		LD	A, (HL)			; Get source
04483A FE 20       0152*  			CP	32			; Is it space
04483C 28 09       0153*  			JR	Z, @F
04483E FE 0D       0154*  			CP	CR			; Or is it CR
044840 28 05       0155*  			JR	Z, @F
044842 12          0156*  			LD	(DE), A			; No, so store
044843 23          0157*  			INC	HL			; Increment
044844 13          0158*  			INC	DE
044845 18 F2       0159*  			JR	CSTR_FNAME		; And loop
044847 AF          0160*  @@:			XOR	A			; Zero terminate the target string
044848 12          0161*  			LD	(DE), A
044849 13          0162*  			INC	DE			; And point to next free address
04484A C9          0163*  			RET
04484B             0164*  
04484B             0165*  ; Copy a CR terminated line to DE and zero terminate it
04484B             0166*  ; HL: Source
04484B             0167*  ; DE: Destination (ACCS)
04484B             0168*  ;
04484B 7E          0169*  CSTR_LINE:		LD	A, (HL)			; Get source
04484C FE 0D       0170*  			CP	CR			; Is it CR
04484E 28 05       0171*  			JR	Z, @F
044850 12          0172*  			LD	(DE), A			; No, so store
044851 23          0173*  			INC	HL			; Increment
044852 13          0174*  			INC	DE
044853 18 F6       0175*  			JR	CSTR_LINE		; And loop
044855 AF          0176*  @@:			XOR	A			; Zero terminate the target string
044856 12          0177*  			LD	(DE), A
044857 13          0178*  			INC	DE			; And point to next free address
044858 C9          0179*  			RET
044859             0180*  
044859             0181*  ; Find the first occurrence of a character (case sensitive)
044859             0182*  ; HL: Source
044859             0183*  ;  C: Character to find
044859             0184*  ; Returns:
044859             0185*  ; HL: Pointer to character, or end of string marker
044859             0186*  ;
044859 7E          0187*  CSTR_FINDCH:		LD	A, (HL)			; Get source
04485A B9          0188*  			CP	C			; Is it our character?
04485B C8          0189*  			RET	Z			; Yes, so exit
04485C B7          0190*  			OR	A			; Is it the end of string?
04485D C8          0191*  			RET	Z			; Yes, so exit
04485E 23          0192*  			INC	HL
04485F 18 F8       0193*  			JR	CSTR_FINDCH
044861             0194*  
044861             0195*  ; Check whether a string ends with another string (case insensitive)
044861             0196*  ; HL: Source
044861             0197*  ; DE: The substring we want to test with
044861             0198*  ; Returns:
044861             0199*  ;  F: Z if HL ends with DE, otherwise NZ
044861             0200*  ;
044861 7E          0201*  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
044862 CD 0C 48 04 0202*  			CALL	UPPERC			; Convert to upper case
044866 4F          0203*  			LD	C, A
044867 1A          0204*  			LD	A, (DE)			; Get the substring byte
044868 B9          0205*  			CP	C
044869 C0          0206*  			RET	NZ			; Return NZ if at any point the strings don't match
04486A B1          0207*  			OR	C			; Check whether both bytes are zero
04486B C8          0208*  			RET	Z			; If so, return, as we have reached the end of both strings
04486C 23          0209*  			INC	HL
04486D 13          0210*  			INC	DE
04486E 18 F1       0211*  			JR	CSTR_ENDSWITH		; And loop
044870             0212*  
044870             0213*  ; Concatenate a string onto the end of another string
044870             0214*  ; HL: Source
044870             0215*  ; DE: Second string
044870             0216*  ;
044870 7E          0217*  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
044871 B7          0218*  			OR	A
044872 28 03       0219*  			JR	Z, CSTR_CAT_1
044874 23          0220*  			INC	HL
044875 18 F9       0221*  			JR	CSTR_CAT
044877             0222*  ;
044877 1A          0223*  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
044878 77          0224*  			LD	(HL), A
044879 B7          0225*  			OR	A			; Check for end of string
04487A C8          0226*  			RET	Z			; And return
04487B 23          0227*  			INC	HL
04487C 13          0228*  			INC	DE
04487D 18 F8       0229*  			JR	CSTR_CAT_1		; Loop until finished
04487F             0015       include "patch.asm"
04487F             0001*  ;
04487F             0002*  ; Title:	BBC Basic for AGON
04487F             0003*  ; Author:	Dean Belfield
04487F             0004*  ; Created:	12/05/2023
04487F             0005*  ; Last Updated:	15/11/2023
04487F             0006*  ;
04487F             0007*  ; Modinfo:
04487F             0008*  ; 11/07/2023:	Fixed *BYE for ADL mode
04487F             0009*  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
04487F             0010*  
04487F             0011*  			; .ASSUME	ADL = 1
04487F             0012*  
04487F             0013*  			; INCLUDE	"equs.inc"
04487F             0014*  			; INCLUDE "macros.inc"
04487F             0015*  			; INCLUDE "mos_api.inc"	; In MOS/src
04487F             0016*  
04487F             0017*  			; SEGMENT CODE
04487F             0018*  
04487F             0019*  			; XDEF	OSWRCH
04487F             0020*  			; XDEF	OSLINE
04487F             0021*  			; XDEF	ESCSET
04487F             0022*  			; XDEF	PUTIME
04487F             0023*  			; XDEF	GETIME
04487F             0024*  			; XDEF	PUTCSR
04487F             0025*  			; XDEF 	GETCSR
04487F             0026*  			; XDEF	OSRDCH
04487F             0027*  			; XDEF	PROMPT
04487F             0028*  			; XDEF	OSKEY
04487F             0029*  			; XDEF	TRAP
04487F             0030*  			; XDEF	LTRAP
04487F             0031*  			; XDEF	OSINIT
04487F             0032*  			; XDEF	OSCLI
04487F             0033*  			; XDEF	OSBPUT
04487F             0034*  			; XDEF	OSBGET
04487F             0035*  			; XDEF	OSSTAT
04487F             0036*  			; XDEF	OSSHUT
04487F             0037*  			; XDEF	OSOPEN
04487F             0038*  			; XDEF	OSCALL
04487F             0039*  			; XDEF	GETPTR
04487F             0040*  			; XDEF	PUTPTR
04487F             0041*  			; XDEF	GETEXT
04487F             0042*  			; XDEF	GETIMS
04487F             0043*  			; XDEF	RESET
04487F             0044*  			; XDEF	OSLOAD
04487F             0045*  			; XDEF	OSSAVE
04487F             0046*  			; XDEF	EXPR_W2
04487F             0047*  			; XDEF	STAR_VERSION
04487F             0048*  
04487F             0049*  			; XREF	_end			; In init.asm
04487F             0050*  
04487F             0051*  			; XREF	ASC_TO_NUMBER
04487F             0052*  			; XREF	RAM_START
04487F             0053*  			; XREF	RAM_END
04487F             0054*  			; XREF	FLAGS
04487F             0055*  			; XREF	ESCAPE
04487F             0056*  			; XREF	USER
04487F             0057*  			; XREF	RAM_Top
04487F             0058*  			; XREF	EXTERR
04487F             0059*  			; XREF	COUNT0
04487F             0060*  			; XREF	EXPRI
04487F             0061*  			; XREF	COMMA
04487F             0062*  			; XREF	XEQ
04487F             0063*  			; XREF	NXT
04487F             0064*  			; XREF	NULLTOCR
04487F             0065*  			; XREF	CRLF
04487F             0066*  			; XREF	CSTR_FNAME
04487F             0067*  			; XREF	CSTR_LINE
04487F             0068*  			; XREF	CSTR_FINDCH
04487F             0069*  			; XREF	CSTR_ENDSWITH
04487F             0070*  			; XREF	CSTR_CAT
04487F             0071*  			; XREF	FINDL
04487F             0072*  			; XREF	OUT_
04487F             0073*  			; XREF	ERROR_
04487F             0074*  			; XREF	ONEDIT
04487F             0075*  			; XREF	TELL
04487F             0076*  			; XREF	OSWRCHPT
04487F             0077*  			; XREF	OSWRCHCH
04487F             0078*  			; XREF	OSWRCHFH
04487F             0079*  			; XREF	LISTON
04487F             0080*  			; XREF	LISTIT
04487F             0081*  			; XREF	PAGE_
04487F             0082*  			; XREF	ONEDIT1
04487F             0083*  			; XREF	CLEAN
04487F             0084*  			; XREF	NEWIT
04487F             0085*  			; XREF	BAD
04487F             0086*  			; XREF	VBLANK_INIT
04487F             0087*  			; XREF	VBLANK_STOP
04487F             0088*  			; XREF	KEYDOWN
04487F             0089*  			; XREF	KEYASCII
04487F             0090*  			; XREF	WIDTH
04487F             0091*  			; XREF	ASSEM
04487F             0092*  
04487F             0093*  ; OSLINE: Invoke the line editor
04487F             0094*  ;
04487F 1E 01       0095*  OSLINE:			LD 	E, 1			; Default is to clear the buffer
044881             0096*  
044881             0097*  ; Entry point to line editor that does not clear the buffer
044881             0098*  ;
044881 FD E5       0099*  OSLINE1:		PUSH	IY
044883 E5          0100*  			PUSH	HL			; Buffer address
044884 01 00 01 00 0101*  			LD	BC, 256			; Buffer length
044888             0102*  			MOSCALL	mos_editline		; Call the MOS line editor
044888 3E 09       0001*M 			LD	A, function
04488A 49 CF       0002*M 			RST.LIS	08h
04488C E1          0103*  			POP	HL			; Pop the address
04488D FD E1       0104*  			POP	IY
04488F F5          0105*  			PUSH	AF			; Stack the return value (key pressed)
044890 CD 21 48 04 0106*  			CALL	NULLTOCR		; Turn the 0 character to a CR
044894 CD FF 0E 04 0107*  			CALL	CRLF			; Display CRLF
044898 F1          0108*  			POP	AF
044899 FE 1B       0109*  			CP	1Bh 			; Check if ESC terminated the input
04489B CA 97 49 04 0110*  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
04489F 3A 42 05 04 0111*  			LD	A, (FLAGS)		; Otherwise
0448A3 CB BF       0112*  			RES	7, A 			; Clear the escape flag
0448A5 32 42 05 04 0113*  			LD	(FLAGS), A
0448A9 CD 6E 4B 04 0114*  			CALL	WAIT_VBLANK 		; Wait a frame
0448AD AF          0115*   			XOR	A			; Return A = 0
0448AE 32 47 05 04 0116*  			LD	(KEYDOWN), A
0448B2 32 48 05 04 0117*  			LD	(KEYASCII), A
0448B6 C9          0118*  			RET
0448B7             0119*  
0448B7             0120*  ; PUTIME: set current time to DE:HL, in centiseconds.
0448B7             0121*  ;
0448B7 DD E5       0122*  PUTIME:			PUSH 	IX
0448B9             0123*  			MOSCALL	mos_sysvars
0448B9 3E 08       0001*M 			LD	A, function
0448BB 49 CF       0002*M 			RST.LIS	08h
0448BD DD 75 00    0124*  			LD	(IX + sysvar_time + 0), L
0448C0 DD 74 01    0125*  			LD	(IX + sysvar_time + 1), H
0448C3 DD 73 02    0126*  			LD	(IX + sysvar_time + 2), E
0448C6 DD 72 03    0127*  			LD	(IX + sysvar_time + 3), D
0448C9 DD E1       0128*  			POP	IX
0448CB C9          0129*  			RET
0448CC             0130*  
0448CC             0131*  ; GETIME: return current time in DE:HL, in centiseconds
0448CC             0132*  ;
0448CC DD E5       0133*  GETIME:			PUSH 	IX
0448CE             0134*  			MOSCALL	mos_sysvars
0448CE 3E 08       0001*M 			LD	A, function
0448D0 49 CF       0002*M 			RST.LIS	08h
0448D2 DD 6E 00    0135*  			LD	L, (IX + sysvar_time + 0)
0448D5 DD 66 01    0136*  			LD	H, (IX + sysvar_time + 1)
0448D8 DD 5E 02    0137*  			LD	E, (IX + sysvar_time + 2)
0448DB DD 56 03    0138*  			LD	D, (IX + sysvar_time + 3)
0448DE DD E1       0139*  			POP	IX
0448E0 C9          0140*  			RET
0448E1             0141*  
0448E1             0142*  ; PUTCSR: move to cursor to x=DE, y=HL
0448E1             0143*  ;
0448E1 3E 1F       0144*  PUTCSR:			LD	A, 1Fh			; TAB
0448E3 5B D7       0145*  			RST.LIL	10h
0448E5 7B          0146*  			LD	A, E			; X
0448E6 5B D7       0147*  			RST.LIL 10h
0448E8 7D          0148*  			LD	A, L			; Y
0448E9 5B D7       0149*  			RST.LIL 10h
0448EB C9          0150*  			RET
0448EC             0151*  
0448EC             0152*  ; GETCSR: return cursor position in x=DE, y=HL
0448EC             0153*  ;
0448EC DD E5       0154*  GETCSR:			PUSH	IX			; Get the system vars in IX
0448EE             0155*  			MOSCALL	mos_sysvars		; Reset the semaphore
0448EE 3E 08       0001*M 			LD	A, function
0448F0 49 CF       0002*M 			RST.LIS	08h
0448F2 DD CB 04 86 0156*  			RES	0, (IX+sysvar_vpd_pflags)
0448F6             0157*  			VDU	23
0448F6 3E 17       0001*M 		LD	A, val
0448F8 CD 20 49 04 0002*M 		CALL	OSWRCH
0448FC             0158*  			VDU	0
0448FC 3E 00       0001*M 		LD	A, val
0448FE CD 20 49 04 0002*M 		CALL	OSWRCH
044902             0159*  			VDU	vdp_cursor
044902 3E 82       0001*M 		LD	A, val
044904 CD 20 49 04 0002*M 		CALL	OSWRCH
044908 DD CB 04 46 0160*  @@:			BIT	0, (IX+sysvar_vpd_pflags)
04490C 28 FA       0161*  			JR	Z, @B			; Wait for the result
04490E 16 00       0162*  			LD 	D, 0
044910 62          0163*  			LD	H, D
044911 DD 5E 07    0164*  			LD	E, (IX + sysvar_cursorX)
044914 DD 6E 08    0165*  			LD	L, (IX + sysvar_cursorY)
044917 DD E1       0166*  			POP	IX
044919 C9          0167*  			RET
04491A             0168*  
04491A             0169*  ; PROMPT: output the input prompt
04491A             0170*  ;
04491A 3E 3E       0171*  PROMPT: 		LD	A,'>'
04491C C3 20 49 04 0172*  			JP	OSWRCH
044920             0173*  
044920             0174*  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
044920             0175*  ; A: Character to write
044920             0176*  ;
044920 E5          0177*  OSWRCH:			PUSH	HL
044921 21 40 05 04 0178*  			LD	HL, LISTON		; Fetch the LISTON variable
044925 CB 5E       0179*  			BIT	3, (HL)			; Check whether we are in *EDIT mode
044927 20 0B       0180*  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
044929             0181*  ;
044929 2A 45 05 04 0182*  			LD	HL, (OSWRCHCH)		; L: Channel #
04492D 2D          0183*  			DEC	L			; If it is 1
04492E 28 10       0184*  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
044930             0185*  ;
044930 E1          0186*  			POP	HL			; Otherwise
044931 5B D7       0187*  			RST.LIL	10h			; Output the character to MOS
044933 C9          0188*  			RET
044934             0189*  ;
044934 2A 43 05 04 0190*  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
044938 77          0191*  			LD	(HL), A			; Echo the character into the buffer
044939 23          0192*  			INC	HL			; Increment pointer
04493A 22 43 05 04 0193*  			LD	(OSWRCHPT), HL		; Write pointer back
04493E E1          0194*  			POP	HL
04493F C9          0195*  			RET
044940             0196*  ;
044940 D5          0197*  OSWRCH_FILE:		PUSH	DE
044941 5C          0198*  			LD	E, H			; Filehandle to E
044942 CD 6C 4D 04 0199*  			CALL	OSBPUT			; Write the byte out
044946 D1          0200*  			POP	DE
044947 E1          0201*  			POP	HL
044948 C9          0202*  			RET
044949             0203*  
044949             0204*  ; OSRDCH: Read a character in from the ESP32 keyboard handler
044949             0205*  ; This is only called in GETS (eval.asm)
044949             0206*  ;
044949             0207*  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
044949 3E 00       0001*M 			LD	A, function
04494B 49 CF       0002*M 			RST.LIS	08h
04494D FE 1B       0208*  			CP	1Bh
04494F 28 46       0209*  			JR	Z, LTRAP1
044951 C9          0210*  			RET
044952             0211*  
044952             0212*  
044952             0213*  ;OSKEY - Read key with time-limit, test for ESCape.
044952             0214*  ;Main function is carried out in user patch.
044952             0215*  ;   Inputs: HL = time limit (centiseconds)
044952             0216*  ;  Outputs: Carry reset if time-out
044952             0217*  ;           If carry set A = character
044952             0218*  ; Destroys: A,H,L,F
044952             0219*  ;
044952 CD 83 49 04 0220*  OSKEY:			CALL	READKEY			; Read the keyboard
044956 28 0A       0221*  			JR	Z, @F 			; Skip if we have a key
044958 7C          0222*  			LD	A, H 			; Check loop counter
044959 B5          0223*  			OR 	L
04495A C8          0224*  			RET 	Z 			; Return, we've not got a key at this point
04495B CD 6E 4B 04 0225*  			CALL	WAIT_VBLANK 		; Wait a frame
04495F 2B          0226*  			DEC 	HL			; Decrement
044960 18 F0       0227*  			JR	OSKEY 			; And loop
044962             0228*  ;
044962 21 47 05 04 0229*  @@:			LD	HL, KEYDOWN		; We have a key, so
044966 36 00       0230*  			LD	(HL), 0			; clear the keydown flag
044968 FE 1B       0231*  			CP	1BH			; If we are not pressing ESC,
04496A 37          0232*  			SCF 				; then flag we've got a character
04496B C0          0233*  			RET	NZ
04496C             0234*  ;
04496C             0235*  ; ESCSET
04496C             0236*  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
04496C             0237*  ;
04496C E5          0238*  ESCSET: 		PUSH    HL
04496D 21 42 05 04 0239*          		LD      HL,FLAGS		; Pointer to FLAGS
044971 CB 76       0240*          		BIT     6,(HL)			; If bit 6 is set, then
044973 20 02       0241*          		JR      NZ,ESCDIS		; escape is disabled, so skip
044975 CB FE       0242*          		SET     7,(HL)			; Set bit 7, the escape flag
044977 E1          0243*  ESCDIS: 		POP     HL
044978 C9          0244*          		RET
044979             0245*  ;
044979             0246*  ; ESCTEST
044979             0247*  ; Test for ESC key
044979             0248*  ;
044979 CD 83 49 04 0249*  ESCTEST:		CALL	READKEY			; Read the keyboard
04497D C0          0250*  			RET	NZ			; Skip if no key is pressed
04497E FE 1B       0251*  			CP	1BH			; If ESC pressed then
044980 28 EA       0252*  			JR	Z,ESCSET		; jump to the escape set routine
044982 C9          0253*  			RET
044983             0254*  
044983             0255*  ; Read the keyboard
044983             0256*  ; Returns:
044983             0257*  ; - A: ASCII of the pressed key
044983             0258*  ; - F: Z if the key is pressed, otherwise NZ
044983             0259*  ;
044983 3A 47 05 04 0260*  READKEY:		LD	A, (KEYDOWN)		; Get key down
044987 3D          0261*  			DEC	A 			; Set Z flag if keydown is 1
044988 3A 48 05 04 0262*  			LD	A, (KEYASCII)		; Get key ASCII value
04498C C9          0263*  			RET
04498D             0264*  ;
04498D             0265*  ; TRAP
04498D             0266*  ; This is called whenever BASIC needs to check for ESC
04498D             0267*  ;
04498D CD 79 49 04 0268*  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
044991             0269*  ;
044991 3A 42 05 04 0270*  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
044995 B7          0271*  			OR	A			; This checks for bit 7; if it is not set then the result will
044996 F0          0272*  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
044997 21 42 05 04 0273*  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
04499B CB BE       0274*  			RES	7,(HL)			; Clear the escape pressed flag and
04499D C3 E8 1E 04 0275*  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0449A1             0276*  
0449A1             0277*  ;OSINIT - Initialise RAM mapping etc.
0449A1             0278*  ;If BASIC is entered by BBCBASIC FILENAME then file
0449A1             0279*  ;FILENAME.BBC is automatically CHAINed.
0449A1             0280*  ;   Outputs: DE = initial value of HIMEM (top of RAM)
0449A1             0281*  ;            HL = initial value of PAGE (user program)
0449A1             0282*  ;            Z-flag reset indicates AUTO-RUN.
0449A1             0283*  ;  Destroys: A,D,E,H,L,F
0449A1             0284*  ;
0449A1 CD 33 42 04 0285*  OSINIT:			CALL	VBLANK_INIT
0449A5 AF          0286*  			XOR	A
0449A6 21 00 4E 04 0287*  			LD 	HL, USER
0449AA 11 00 00 0B 0288*  			LD	DE, RAM_Top
0449AE 5F          0289*  			LD	E, A			; Page boundary
0449AF C9          0290*  			RET
0449B0             0291*  
0449B0             0292*  ;
0449B0             0293*  ;OSCLI - Process a MOS command
0449B0             0294*  ;
0449B0 CD 24 4A 04 0295*  OSCLI: 			CALL    SKIPSP
0449B4 FE 0D       0296*  			CP      CR
0449B6 C8          0297*  			RET     Z
0449B7 FE 7C       0298*  			CP      '|'
0449B9 C8          0299*  			RET     Z
0449BA EB          0300*  			EX      DE,HL
0449BB 21 33 4A 04 0301*  			LD      HL,COMDS
0449BF 1A          0302*  OSCLI0:			LD      A,(DE)
0449C0 CD 2B 4A 04 0303*  			CALL    UPPRC
0449C4 BE          0304*  			CP      (HL)
0449C5 28 0B       0305*  			JR      Z,OSCLI2
0449C7 38 30       0306*  			JR      C,OSCLI6
0449C9 CB 7E       0307*  OSCLI1:			BIT     7,(HL)
0449CB 23          0308*  			INC     HL
0449CC 28 FB       0309*  			JR      Z,OSCLI1
0449CE 23          0310*  			INC     HL
0449CF 23          0311*  			INC     HL
0449D0 18 ED       0312*  			JR      OSCLI0
0449D2             0313*  ;
0449D2 D5          0314*  OSCLI2:			PUSH    DE
0449D3 13          0315*  OSCLI3:			INC     DE
0449D4 23          0316*  			INC     HL
0449D5 1A          0317*  			LD      A,(DE)
0449D6 CD 2B 4A 04 0318*  			CALL    UPPRC
0449DA FE 2E       0319*  			CP      '.'			; ABBREVIATED?
0449DC 28 0A       0320*  			JR      Z,OSCLI4
0449DE AE          0321*  			XOR     (HL)
0449DF 28 F2       0322*  			JR      Z,OSCLI3
0449E1 FE 80       0323*  			CP      80H
0449E3 28 03       0324*  			JR      Z,OSCLI4
0449E5 D1          0325*  			POP     DE
0449E6 18 E1       0326*  			JR      OSCLI1
0449E8             0327*  ;
0449E8 F1          0328*  OSCLI4:			POP     AF
0449E9 13          0329*  		        INC     DE
0449EA CB 7E       0330*  OSCLI5:			BIT     7,(HL)
0449EC 23          0331*  			INC     HL
0449ED 28 FB       0332*  			JR      Z,OSCLI5
0449EF 7E          0333*  			LD      A,(HL)
0449F0 23          0334*  			INC     HL
0449F1 66          0335*  			LD      H,(HL)
0449F2 6F          0336*  			LD      L,A
0449F3 E5          0337*  			PUSH    HL
0449F4 EB          0338*  			EX      DE,HL
0449F5 C3 24 4A 04 0339*  			JP      SKIPSP
0449F9             0340*  ;
0449F9 EB          0341*  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0449FA 11 00 02 04 0342*  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0449FE D5          0343*  			PUSH	DE			; Store buffer address
0449FF CD 4B 48 04 0344*  			CALL	CSTR_LINE		; Fetch the line
044A03 E1          0345*  			POP	HL			; HL: Pointer to command string in ACCS
044A04 FD E5       0346*  			PUSH	IY
044A06             0347*  			MOSCALL	mos_oscli		; Returns OSCLI error in A
044A06 3E 10       0001*M 			LD	A, function
044A08 49 CF       0002*M 			RST.LIS	08h
044A0A FD E1       0348*  			POP	IY
044A0C B7          0349*  			OR	A			; 0 means MOS returned OK
044A0D C8          0350*  			RET	Z			; So don't do anything
044A0E C3 48 4C 04 0351*  			JP 	OSERROR			; Otherwise it's a MOS error
044A12             0352*  
044A12 3E FE       0353*  HUH:    		LD      A,254			; Bad command error
044A14 CD 2F 0D 04 0354*          		CALL    EXTERR
044A18 42 61 64 20 0355*          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
044A23 00          0356*          		DEFB    0
044A24             0357*  
044A24 7E          0358*  SKIPSP:			LD      A,(HL)
044A25 FE 20       0359*          		CP      ' '
044A27 C0          0360*          		RET     NZ
044A28 23          0361*          		INC     HL
044A29 18 F9       0362*          		JR      SKIPSP
044A2B             0363*  
044A2B E6 7F       0364*  UPPRC:  		AND     7FH
044A2D FE 60       0365*  			CP      '`'
044A2F D8          0366*  			RET     C
044A30 E6 5F       0367*  			AND     5FH			; CONVERT TO UPPER CASE
044A32 C9          0368*  			RET
044A33             0369*  
044A33             0370*  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
044A33             0371*  ; These must be in alphabetical order
044A33             0372*  ;
044A33 41 53 4D    0373*  COMDS:  		DB	"AS","M"+80h		; ASM
044A36 51 4A       0374*  			DW	STAR_ASM
044A38 42 59 45    0375*  			DB	"BY","E"+80h		; BYE
044A3B 5D 4A       0376*  			DW	STAR_BYE
044A3D 45 44 49 54 0377*  			DB	"EDI","T"+80h		; EDIT
044A41 92 4A       0378*  			DW	STAR_EDIT
044A43 46 58       0379*  			DB	"F","X"+80h		; FX
044A45 D2 4A       0380*  			DW	STAR_FX
044A47 56 45 52 53 0381*  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
044A4E 69 4A       0382*  			DW	STAR_VERSION
044A50 FF          0383*  			DB	FFh
044A51             0384*  
044A51             0385*  ; *ASM string
044A51             0386*  ;
044A51 FD E5       0387*  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
044A53 E5          0388*  			PUSH	HL			; HL = IY
044A54 FD E1       0389*  			POP	IY
044A56 CD 12 2B 04 0390*  			CALL	ASSEM			; Invoke the assembler
044A5A FD E1       0391*  			POP	IY
044A5C C9          0392*  			RET
044A5D             0393*  
044A5D             0394*  ; *BYE
044A5D             0395*  ;
044A5D CD 47 42 04 0396*  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
044A61 21 00 00 00 0397*  			LD	HL, 0			; The return value
044A65 C3 68 00 04 0398*  			JP	_end 			; Jump back to the end routine in init.asm
044A69             0399*  
044A69             0400*  ; *VERSION
044A69             0401*  ;
044A69 CD 48 13 04 0402*  STAR_VERSION:		CALL    TELL			; Output the welcome message
044A6D 42 42 43 20 0403*  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
044A91 C9          0404*  			RET
044A92             0405*  
044A92             0406*  ; *EDIT linenum
044A92             0407*  ;
044A92 CD B7 47 04 0408*  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
044A96 EB          0409*  			EX	DE, HL			; HL: Line number
044A97 CD 47 0F 04 0410*  			CALL	FINDL			; HL: Address in RAM of tokenised line
044A9B 3E 29       0411*  			LD	A, 41			; F:NZ If the line is not found
044A9D C2 18 0D 04 0412*  			JP	NZ, ERROR_		; Do error 41: No such line in that case
044AA1             0413*  ;
044AA1             0414*  ; Use LISTIT to output the line to the ACCS buffer
044AA1             0415*  ;
044AA1 23          0416*  			INC	HL			; Skip the length byte
044AA2 5E          0417*  			LD	E, (HL)			; Fetch the line number
044AA3 23          0418*  			INC	HL
044AA4 56          0419*  			LD	D, (HL)
044AA5 23          0420*  			INC	HL
044AA6 DD 21 00 02 0421*  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
044AAB DD 22 43 05 0422*  			LD	(OSWRCHPT), IX
       04          
044AB0 DD 21 40 05 0423*  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
044AB5 DD 7E 00    0424*  			LD	A, (IX)			; Store that variable
044AB8 F5          0425*  			PUSH	AF
044AB9 DD 36 00 09 0426*  			LD	(IX), 09h		; Set to echo to buffer
044ABD CD 4A 0E 04 0427*  			CALL	LISTIT
044AC1 F1          0428*  			POP	AF
044AC2 DD 77 00    0429*  			LD	(IX), A			; Restore the original LISTON variable
044AC5 21 00 02 04 0430*  			LD	HL, ACCS		; HL: ACCS
044AC9 5D          0431*  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044ACA CD 81 48 04 0432*  			CALL	OSLINE1			; Invoke the editor
044ACE C3 88 06 04 0433*  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
044AD2             0434*  
044AD2             0435*  ; OSCLI FX n
044AD2             0436*  ;
044AD2 CD B7 47 04 0437*  STAR_FX:		CALL	ASC_TO_NUMBER
044AD6 4B          0438*  			LD	C, E			; C: Save FX #
044AD7 CD B7 47 04 0439*  			CALL	ASC_TO_NUMBER
044ADB 7A          0440*  			LD	A, D  			; Is first parameter > 255?
044ADC B7          0441*  			OR 	A
044ADD 28 03       0442*  			JR	Z, STAR_FX1		; Yes, so skip next bit
044ADF EB          0443*  			EX	DE, HL 			; Parameter is 16-bit
044AE0 18 07       0444*  			JR	STAR_FX2
044AE2             0445*  ;
044AE2 43          0446*  STAR_FX1:		LD	B, E 			; B: Save First parameter
044AE3 CD B7 47 04 0447*  			CALL	ASC_TO_NUMBER		; Fetch second parameter
044AE7 68          0448*  			LD	L, B 			; L: First parameter
044AE8 63          0449*  			LD	H, E 			; H: Second parameter
044AE9             0450*  ;
044AE9 79          0451*  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
044AEA             0452*  ;
044AEA             0453*  ; OSBYTE
044AEA             0454*  ;  A: FX #
044AEA             0455*  ;  L: First parameter
044AEA             0456*  ;  H: Second parameter
044AEA             0457*  ;
044AEA FE 0B       0458*  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
044AEC 28 18       0459*  			JR	Z, OSBYTE_0B
044AEE FE 0C       0460*  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
044AF0 28 43       0461*  			JR	Z, OSBYTE_0C
044AF2 FE 13       0462*  			CP	13H			; *FX 19: Wait for vblank
044AF4 28 6E       0463*  			JR	Z, OSBYTE_13
044AF6 FE 76       0464*  			CP	76H			; *FX 118, n: Set keyboard LED
044AF8 CA 7F 4B 04 0465*  			JP	Z, OSBYTE_76
044AFC FE A0       0466*  			CP	A0H
044AFE CA AF 4B 04 0467*  			JP	Z, OSBYTE_A0
044B02 C3 12 4A 04 0468*  			JP	HUH			; Anything else trips an error
044B06             0469*  
044B06             0470*  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
044B06             0471*  ; Parameters:
044B06             0472*  ; - HL: Repeat delay
044B06             0473*  ;
044B06             0474*  OSBYTE_0B:		VDU	23
044B06 3E 17       0001*M 		LD	A, val
044B08 CD 20 49 04 0002*M 		CALL	OSWRCH
044B0C             0475*  			VDU	0
044B0C 3E 00       0001*M 		LD	A, val
044B0E CD 20 49 04 0002*M 		CALL	OSWRCH
044B12             0476*  			VDU	vdp_keystate
044B12 3E 88       0001*M 		LD	A, val
044B14 CD 20 49 04 0002*M 		CALL	OSWRCH
044B18             0477*  			VDU	L
044B18 7D          0001*M 		LD	A, val
044B19 CD 20 49 04 0002*M 		CALL	OSWRCH
044B1D             0478*  			VDU	H
044B1D 7C          0001*M 		LD	A, val
044B1E CD 20 49 04 0002*M 		CALL	OSWRCH
044B22             0479*  			VDU	0
044B22 3E 00       0001*M 		LD	A, val
044B24 CD 20 49 04 0002*M 		CALL	OSWRCH
044B28             0480*  			VDU 	0
044B28 3E 00       0001*M 		LD	A, val
044B2A CD 20 49 04 0002*M 		CALL	OSWRCH
044B2E             0481*  			VDU	255
044B2E 3E FF       0001*M 		LD	A, val
044B30 CD 20 49 04 0002*M 		CALL	OSWRCH
044B34 C9          0482*  			RET
044B35             0483*  
044B35             0484*  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
044B35             0485*  ; Parameters:
044B35             0486*  ; - HL: Repeat rate
044B35             0487*  ;
044B35             0488*  OSBYTE_0C:		VDU	23
044B35 3E 17       0001*M 		LD	A, val
044B37 CD 20 49 04 0002*M 		CALL	OSWRCH
044B3B             0489*  			VDU	0
044B3B 3E 00       0001*M 		LD	A, val
044B3D CD 20 49 04 0002*M 		CALL	OSWRCH
044B41             0490*  			VDU	vdp_keystate
044B41 3E 88       0001*M 		LD	A, val
044B43 CD 20 49 04 0002*M 		CALL	OSWRCH
044B47             0491*  			VDU	0
044B47 3E 00       0001*M 		LD	A, val
044B49 CD 20 49 04 0002*M 		CALL	OSWRCH
044B4D             0492*  			VDU 	0
044B4D 3E 00       0001*M 		LD	A, val
044B4F CD 20 49 04 0002*M 		CALL	OSWRCH
044B53             0493*  			VDU	L
044B53 7D          0001*M 		LD	A, val
044B54 CD 20 49 04 0002*M 		CALL	OSWRCH
044B58             0494*  			VDU	H
044B58 7C          0001*M 		LD	A, val
044B59 CD 20 49 04 0002*M 		CALL	OSWRCH
044B5D             0495*  			VDU	255
044B5D 3E FF       0001*M 		LD	A, val
044B5F CD 20 49 04 0002*M 		CALL	OSWRCH
044B63 C9          0496*  			RET
044B64             0497*  
044B64             0498*  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
044B64             0499*  ;
044B64 CD 6E 4B 04 0500*  OSBYTE_13:		CALL	WAIT_VBLANK
044B68 2E 00       0501*  			LD	L, 0			; Returns 0
044B6A C3 C9 17 04 0502*  			JP	COUNT0
044B6E             0503*  ;
044B6E DD E5       0504*  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
044B70             0505*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044B70 3E 08       0001*M 			LD	A, function
044B72 49 CF       0002*M 			RST.LIS	08h
044B74 DD 7E 00    0506*  			LD	A, (IX + sysvar_time + 0)
044B77 DD BE 00    0507*  @@:			CP 	A, (IX + sysvar_time + 0)
044B7A 28 FB       0508*  			JR	Z, @B
044B7C DD E1       0509*  			POP	IX
044B7E C9          0510*  			RET
044B7F             0511*  
044B7F             0512*  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
044B7F             0513*  ; Parameters:
044B7F             0514*  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
044B7F             0515*  ;
044B7F             0516*  OSBYTE_76:		VDU	23
044B7F 3E 17       0001*M 		LD	A, val
044B81 CD 20 49 04 0002*M 		CALL	OSWRCH
044B85             0517*  			VDU	0
044B85 3E 00       0001*M 		LD	A, val
044B87 CD 20 49 04 0002*M 		CALL	OSWRCH
044B8B             0518*  			VDU	vdp_keystate
044B8B 3E 88       0001*M 		LD	A, val
044B8D CD 20 49 04 0002*M 		CALL	OSWRCH
044B91             0519*  			VDU	0
044B91 3E 00       0001*M 		LD	A, val
044B93 CD 20 49 04 0002*M 		CALL	OSWRCH
044B97             0520*  			VDU 	0
044B97 3E 00       0001*M 		LD	A, val
044B99 CD 20 49 04 0002*M 		CALL	OSWRCH
044B9D             0521*  			VDU	0
044B9D 3E 00       0001*M 		LD	A, val
044B9F CD 20 49 04 0002*M 		CALL	OSWRCH
044BA3             0522*  			VDU	0
044BA3 3E 00       0001*M 		LD	A, val
044BA5 CD 20 49 04 0002*M 		CALL	OSWRCH
044BA9             0523*  			VDU	L
044BA9 7D          0001*M 		LD	A, val
044BAA CD 20 49 04 0002*M 		CALL	OSWRCH
044BAE C9          0524*  			RET
044BAF             0525*  
044BAF             0526*  ; OSBYTE 0xA0: Fetch system variable
044BAF             0527*  ; Parameters:
044BAF             0528*  ; - L: The system variable to fetch
044BAF             0529*  ;
044BAF DD E5       0530*  OSBYTE_A0:		PUSH	IX
044BB1             0531*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
044BB1 3E 08       0001*M 			LD	A, function
044BB3 49 CF       0002*M 			RST.LIS	08h
044BB5 01 00 00 00 0532*  			LD	BC, 0
044BB9 4D          0533*  			LD	C, L			; BCU = L
044BBA DD 09       0534*  			ADD	IX, BC			; Add to IX
044BBC DD 6E 00    0535*  			LD	L, (IX + 0)		; Fetch the return value
044BBF DD E1       0536*  			POP	IX
044BC1 C3 C9 17 04 0537*  			JP 	COUNT0
044BC5             0538*  
044BC5             0539*  ;OSLOAD - Load an area of memory from a file.
044BC5             0540*  ;   Inputs: HL addresses filename (CR terminated)
044BC5             0541*  ;           DE = address at which to load
044BC5             0542*  ;           BC = maximum allowed size (bytes)
044BC5             0543*  ;  Outputs: Carry reset indicates no room for file.
044BC5             0544*  ; Destroys: A,B,C,D,E,H,L,F
044BC5             0545*  ;
044BC5 C5          0546*  OSLOAD:			PUSH	BC			; Stack the size
044BC6 D5          0547*  			PUSH	DE			; Stack the load address
044BC7 11 00 02 04 0548*  			LD	DE, ACCS		; Buffer address for filename
044BCB CD 39 48 04 0549*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044BCF 21 00 02 04 0550*  			LD	HL, ACCS		; HL: Filename
044BD3 CD C5 4C 04 0551*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044BD7 CD D9 4C 04 0552*  			CALL	EXT_HANDLER		; Get the default handler
044BDB D1          0553*  			POP	DE			; Restore the load address
044BDC C1          0554*  			POP	BC			; Restore the size
044BDD B7          0555*  			OR	A
044BDE 28 60       0556*  			JR 	Z, OSLOAD_BBC
044BE0             0557*  ;
044BE0             0558*  ; Load the file in as a text file
044BE0             0559*  ;
044BE0 AF          0560*  OSLOAD_TXT:		XOR	A			; Set file attributes to read
044BE1 CD 4D 4D 04 0561*  			CALL	OSOPEN			; Open the file
044BE5 5F          0562*  			LD 	E, A 			; The filehandle
044BE6 B7          0563*  			OR	A
044BE7 3E 04       0564*  			LD	A, 4			; File not found error
044BE9 28 5D       0565*  			JR	Z, OSERROR		; Jump to error handler
044BEB CD 24 0E 04 0566*  			CALL	NEWIT			; Call NEW to clear the program space
044BEF             0567*  ;
044BEF 21 00 02 04 0568*  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
044BF3             0569*  ;
044BF3             0570*  ; First skip any whitespace (indents) at the beginning of the input
044BF3             0571*  ;
044BF3 CD 64 4D 04 0572*  @@:			CALL	OSBGET			; Read the byte into A
044BF7 38 1E       0573*  			JR	C, OSLOAD_TXT3		; Is it EOF?
044BF9 FE 0A       0574*  			CP	LF 			; Is it LF?
044BFB 28 1A       0575*  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
044BFD FE 21       0576*  			CP	21h			; Is it less than or equal to ASCII space?
044BFF 38 F2       0577*  			JR	C, @B 			; Yes, so keep looping
044C01 77          0578*  			LD	(HL), A 		; Store the first character
044C02 2C          0579*  			INC	L
044C03             0580*  ;
044C03             0581*  ; Now read the rest of the line in
044C03             0582*  ;
044C03 CD 64 4D 04 0583*  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
044C07 38 2B       0584*  			JR	C, OSLOAD_TXT4		; Is it EOF?
044C09 FE 20       0585*  			CP	20h			; Skip if not an ASCII character
044C0B 38 06       0586*  			JR	C, @F
044C0D 77          0587*  			LD	(HL), A 		; Store in the input buffer
044C0E 2C          0588*  			INC	L			; Increment the buffer pointer
044C0F CA B0 0C 04 0589*  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
044C13 FE 0A       0590*  @@:			CP	LF			; Check for LF
044C15 20 EC       0591*  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
044C17             0592*  ;
044C17             0593*  ; Finally, handle EOL/EOF
044C17             0594*  ;
044C17 36 0D       0595*  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
044C19 7D          0596*  			LD	A, L			; Check for minimum line length
044C1A FE 02       0597*  			CP	2			; If it is 2 characters or less (including CR)
044C1C 38 0A       0598*  			JR	C, @F			; Then don't bother entering it
044C1E D5          0599*  			PUSH	DE			; Preserve the filehandle
044C1F CD 94 06 04 0600*  			CALL	ONEDIT1			; Enter the line in memory
044C23 DC F7 0D 04 0601*  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
044C27 D1          0602*  			POP	DE
044C28 CD 75 4D 04 0603*  @@:			CALL	OSSTAT			; End of file?
044C2C 20 C1       0604*  			JR	NZ, OSLOAD_TXT1		; No, so loop
044C2E CD 5C 4D 04 0605*  			CALL	OSSHUT			; Close the file
044C32 37          0606*  			SCF				; Flag to BASIC that we're good
044C33 C9          0607*  			RET
044C34             0608*  ;
044C34             0609*  ; Special case for BASIC programs with no blank line at the end
044C34             0610*  ;
044C34 FE 20       0611*  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
044C36 38 06       0612*  			JR	C, @F
044C38 77          0613*  			LD	(HL), A			; Store the character
044C39 2C          0614*  			INC	L
044C3A CA B0 0C 04 0615*  			JP	Z, BAD
044C3E 18 D7       0616*  @@:			JR	OSLOAD_TXT3
044C40             0617*  
044C40             0618*  ;
044C40             0619*  ; Load the file in as a tokenised binary blob
044C40             0620*  ;
044C40             0621*  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
044C40 3E 01       0001*M 			LD	A, function
044C42 49 CF       0002*M 			RST.LIS	08h
044C44 D0          0622*  			RET	NC			; If load returns with carry reset - NO ROOM
044C45 B7          0623*  			OR	A			; If there is no error (A=0)
044C46 37          0624*  			SCF				; Need to set carry indicating there was room
044C47 C8          0625*  			RET	Z			; Return
044C48             0626*  ;
044C48 F5          0627*  OSERROR:		PUSH	AF			; Handle the MOS error
044C49 21 00 02 04 0628*  			LD	HL, ACCS		; Address of the buffer
044C4D 01 00 01 00 0629*  			LD	BC, 256			; Length of the buffer
044C51 5F          0630*  			LD	E, A			; The error code
044C52             0631*  			MOSCALL	mos_getError		; Copy the error message into the buffer
044C52 3E 0F       0001*M 			LD	A, function
044C54 49 CF       0002*M 			RST.LIS	08h
044C56 F1          0632*  			POP	AF
044C57 E5          0633*  			PUSH	HL			; Stack the address of the error (now in ACCS)
044C58 C6 7F       0634*  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044C5A C3 2F 0D 04 0635*  			JP	EXTERR			; Trigger an external error
044C5E             0636*  
044C5E             0637*  ;OSSAVE - Save an area of memory to a file.
044C5E             0638*  ;   Inputs: HL addresses filename (term CR)
044C5E             0639*  ;           DE = start address of data to save
044C5E             0640*  ;           BC = length of data to save (bytes)
044C5E             0641*  ; Destroys: A,B,C,D,E,H,L,F
044C5E             0642*  ;
044C5E C5          0643*  OSSAVE:			PUSH	BC			; Stack the size
044C5F D5          0644*  			PUSH	DE			; Stack the save address
044C60 11 00 02 04 0645*  			LD	DE, ACCS		; Buffer address for filename
044C64 CD 39 48 04 0646*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044C68 21 00 02 04 0647*  			LD	HL, ACCS		; HL: Filename
044C6C CD C5 4C 04 0648*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044C70 CD D9 4C 04 0649*  			CALL	EXT_HANDLER		; Get the default handler
044C74 D1          0650*  			POP	DE			; Restore the save address
044C75 C1          0651*  			POP	BC			; Restore the size
044C76 B7          0652*  			OR	A			; Is the extension .BBC
044C77 28 44       0653*  			JR	Z, OSSAVE_BBC		; Yes, so use that
044C79             0654*  ;
044C79             0655*  ; Save the file out as a text file
044C79             0656*  ;
044C79 3A 45 05 04 0657*  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
044C7D F5          0658*  			PUSH	AF
044C7E AF          0659*  			XOR	A
044C7F 3C          0660*  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
044C80 32 45 05 04 0661*  			LD	(OSWRCHCH), A
044C84 CD 4D 4D 04 0662*  			CALL	OSOPEN			; Open the file
044C88 32 46 05 04 0663*  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
044C8C DD 21 40 05 0664*  			LD	IX, LISTON		; Required for LISTIT
       04          
044C91 2A 14 05 04 0665*  			LD	HL, (PAGE_)		; Get start of program area
044C95 D9          0666*  			EXX
044C96 01 00 00 00 0667*  			LD	BC, 0			; Set the initial indent counters
044C9A D9          0668*  			EXX
044C9B 7E          0669*  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
044C9C B7          0670*  			OR	A
044C9D 28 0F       0671*  			JR	Z, OSSAVE_TXT2
044C9F 23          0672*  			INC	HL			; Skip the length byte
044CA0 11 00 00 00 0673*  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
044CA4 5E          0674*  			LD	E, (HL)			; Get the line number
044CA5 23          0675*  			INC	HL
044CA6 56          0676*  			LD	D, (HL)
044CA7 23          0677*  			INC	HL
044CA8 CD 4A 0E 04 0678*  			CALL	LISTIT			; List the line
044CAC 18 ED       0679*  			JR	OSSAVE_TXT1
044CAE 3A 46 05 04 0680*  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
044CB2 5F          0681*  			LD	E, A
044CB3 CD 5C 4D 04 0682*  			CALL	OSSHUT			; Close it
044CB7 F1          0683*  			POP	AF			; Restore the channel
044CB8 32 45 05 04 0684*  			LD	(OSWRCHCH), A
044CBC C9          0685*  			RET
044CBD             0686*  ;
044CBD             0687*  ; Save the file out as a tokenised binary blob
044CBD             0688*  ;
044CBD             0689*  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
044CBD 3E 02       0001*M 			LD	A, function
044CBF 49 CF       0002*M 			RST.LIS	08h
044CC1 B7          0690*  			OR	A			; If there is no error (A=0)
044CC2 C8          0691*  			RET	Z			; Just return
044CC3 18 83       0692*  			JR	OSERROR			; Trip an error
044CC5             0693*  
044CC5             0694*  ; Check if an extension is specified in the filename
044CC5             0695*  ; Add a default if not specified
044CC5             0696*  ; HL: Filename (CSTR format)
044CC5             0697*  ;
044CC5 E5          0698*  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044CC6 0E 2E       0699*  			LD	C, '.'			; Search for dot (marks start of extension)
044CC8 CD 59 48 04 0700*  			CALL	CSTR_FINDCH
044CCC B7          0701*  			OR	A			; Check for end of string marker
044CCD 20 08       0702*  			JR	NZ, @F			; No, so skip as we have an extension at this point
044CCF 11 09 4D 04 0703*  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
044CD3 CD 70 48 04 0704*  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
044CD7 E1          0705*  @@:			POP	HL			; Restore the filename pointer
044CD8 C9          0706*  			RET
044CD9             0707*  
044CD9             0708*  ; Check if an extension is valid and, if so, provide a pointer to a handler
044CD9             0709*  ; HL: Filename (CSTR format)
044CD9             0710*  ; Returns:
044CD9             0711*  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
044CD9             0712*  ;
044CD9 E5          0713*  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
044CDA 0E 2E       0714*  			LD	C, '.'			; Find the '.'
044CDC CD 59 48 04 0715*  			CALL	CSTR_FINDCH
044CE0 11 09 4D 04 0716*  			LD	DE, EXT_LOOKUP		; The lookup table
044CE4             0717*  ;
044CE4 E5          0718*  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
044CE5 CD 61 48 04 0719*  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
044CE9 E1          0720*  			POP	HL			; Restore the pointer to the extension
044CEA 28 19       0721*  			JR	Z, EXT_HANDLER_2	; We have a match!
044CEC             0722*  ;
044CEC 1A          0723*  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
044CED 13          0724*  			INC	DE
044CEE B7          0725*  			OR	A
044CEF 20 FB       0726*  			JR	NZ, @B
044CF1 13          0727*  			INC	DE			; Skip the file extension # byte
044CF2             0728*  ;
044CF2 1A          0729*  			LD	A, (DE)			; Are we at the end of the table?
044CF3 B7          0730*  			OR	A
044CF4 20 EE       0731*  			JR	NZ, EXT_HANDLER_1	; No, so loop
044CF6             0732*  ;
044CF6 3E CC       0733*  			LD      A,204			; Throw a "Bad name" error
044CF8 CD 2F 0D 04 0734*          		CALL    EXTERR
044CFC 42 61 64 20 0735*          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
044D05             0736*  ;
044D05 13          0737*  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
044D06 1A          0738*  			LD	A, (DE)
044D07 E1          0739*  			POP	HL			; Restore the filename pointer
044D08 C9          0740*  			RET
044D09             0741*  ;
044D09             0742*  
044D09             0743*  
044D09             0744*  ; Extension lookup table
044D09             0745*  ; CSTR, TYPE
044D09             0746*  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
044D09             0747*  ; 	- 1: Human readable plain text
044D09             0748*  ;
044D09 2E 42 42 43 0749*  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
044D0F 2E 54 58 54 0750*  			DB	".TXT", 0, 1
       00 01       
044D15 2E 41 53 43 0751*  			DB	".ASC", 0, 1
       00 01       
044D1B 2E 42 41 53 0752*  			DB	".BAS", 0, 1
       00 01       
044D21 00          0753*  			DB	0			; End of table
044D22             0754*  
044D22             0755*  ;OSCALL - Intercept page &FF calls and provide an alternative address
044D22             0756*  ;
044D22             0757*  ;&FFF7:	OSCLI	Execute *command.
044D22             0758*  ;&FFF4:	OSBYTE	Various byte-wide functions.
044D22             0759*  ;&FFF1:	OSWORD	Various control block functions.
044D22             0760*  ;&FFEE:	OSWRCH	Write character to output stream.
044D22             0761*  ;&FFE7:	OSNEWL	Write NewLine to output stream.
044D22             0762*  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
044D22             0763*  ;&FFE0:	OSRDCH	Wait for character from input stream.
044D22             0764*  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
044D22             0765*  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
044D22             0766*  ;&FFD7:	OSBGET	Read a byte from an a channel.
044D22             0767*  ;&FFD4:	OSBPUT	Write a byte to a channel.
044D22             0768*  ;&FFD1:	OSGBPB	Read and write blocks of data.
044D22             0769*  ;&FFCE:	OSFIND	Open or close a file.
044D22             0770*  ;
044D22 21 38 4D 04 0771*  OSCALL:			LD	HL, OSCALL_TABLE
044D26 7E          0772*  OSCALL_1:		LD	A, (HL)
044D27 23          0773*  			INC	HL
044D28 FE FF       0774*  			CP	FFh
044D2A C8          0775*  			RET	Z
044D2B FD BD       0776*  			CP	A, IYL
044D2D 28 06       0777*  			JR	Z, OSCALL_2
044D2F D0          0778*  			RET	NC
044D30 23          0779*  			INC	HL
044D31 23          0780*  			INC	HL
044D32 23          0781*  			INC	HL
044D33 18 F1       0782*  			JR	OSCALL_1
044D35 ED 31       0783*  OSCALL_2:		LD	IY,(HL)
044D37 C9          0784*  			RET
044D38 D4          0785*  OSCALL_TABLE:		DB 	D4h
044D39 6C 4D 04    0786*  			DW24 	OSBPUT
044D3C D7          0787*  			DB 	D7h
044D3D 64 4D 04    0788*  			DW24 	OSBGET
044D40 EE          0789*  			DB 	EEh
044D41 20 49 04    0790*  			DW24 	OSWRCH
044D44 F4          0791*  			DB	F4h
044D45 EA 4A 04    0792*  			DW24 	OSBYTE
044D48 F7          0793*  			DB	F7h
044D49 B0 49 04    0794*  			DW24	OSCLI
044D4C FF          0795*  			DB	FFh
044D4D             0796*  
044D4D             0797*  ; OSOPEN
044D4D             0798*  ; HL: Pointer to path
044D4D             0799*  ;  F: C Z
044D4D             0800*  ;     x x OPENIN
044D4D             0801*  ; 	  OPENOUT
044D4D             0802*  ;     x	  OPENUP
044D4D             0803*  ; Returns:
044D4D             0804*  ;  A: Filehandle, 0 if cannot open
044D4D             0805*  ;
044D4D 0E 01       0806*  OSOPEN:			LD	C, fa_read
044D4F 28 06       0807*  			JR	Z, @F
044D51 0E 32       0808*  			LD	C, fa_write | fa_open_append
044D53 38 02       0809*  			JR	C, @F
044D55 0E 0A       0810*  			LD	C, fa_write | fa_create_always
044D57             0811*  @@:			MOSCALL	mos_fopen
044D57 3E 0A       0001*M 			LD	A, function
044D59 49 CF       0002*M 			RST.LIS	08h
044D5B C9          0812*  			RET
044D5C             0813*  
044D5C             0814*  ;OSSHUT - Close disk file(s).
044D5C             0815*  ; E = file channel
044D5C             0816*  ;  If E=0 all files are closed (except SPOOL)
044D5C             0817*  ; Destroys: A,B,C,D,E,H,L,F
044D5C             0818*  ;
044D5C C5          0819*  OSSHUT:			PUSH	BC
044D5D 4B          0820*  			LD	C, E
044D5E             0821*  			MOSCALL	mos_fclose
044D5E 3E 0B       0001*M 			LD	A, function
044D60 49 CF       0002*M 			RST.LIS	08h
044D62 C1          0822*  			POP	BC
044D63 C9          0823*  			RET
044D64             0824*  
044D64             0825*  ; OSBGET - Read a byte from a random disk file.
044D64             0826*  ;  E = file channel
044D64             0827*  ; Returns
044D64             0828*  ;  A = byte read
044D64             0829*  ;  Carry set if LAST BYTE of file
044D64             0830*  ; Destroys: A,B,C,F
044D64             0831*  ;
044D64 C5          0832*  OSBGET:			PUSH	BC
044D65 4B          0833*  			LD	C, E
044D66             0834*  			MOSCALL	mos_fgetc
044D66 3E 0C       0001*M 			LD	A, function
044D68 49 CF       0002*M 			RST.LIS	08h
044D6A C1          0835*  			POP	BC
044D6B C9          0836*  			RET
044D6C             0837*  
044D6C             0838*  ; OSBPUT - Write a byte to a random disk file.
044D6C             0839*  ;  E = file channel
044D6C             0840*  ;  A = byte to write
044D6C             0841*  ; Destroys: A,B,C,F
044D6C             0842*  ;
044D6C C5          0843*  OSBPUT:			PUSH	BC
044D6D 4B          0844*  			LD	C, E
044D6E 47          0845*  			LD	B, A
044D6F             0846*  			MOSCALL	mos_fputc
044D6F 3E 0D       0001*M 			LD	A, function
044D71 49 CF       0002*M 			RST.LIS	08h
044D73 C1          0847*  			POP	BC
044D74 C9          0848*  			RET
044D75             0849*  
044D75             0850*  ; OSSTAT - Read file status
044D75             0851*  ;  E = file channel
044D75             0852*  ; Returns
044D75             0853*  ;  F: Z flag set - EOF
044D75             0854*  ;  A: If Z then A = 0
044D75             0855*  ; Destroys: A,D,E,H,L,F
044D75             0856*  ;
044D75 C5          0857*  OSSTAT:			PUSH	BC
044D76 4B          0858*  			LD	C, E
044D77             0859*  			MOSCALL	mos_feof
044D77 3E 0E       0001*M 			LD	A, function
044D79 49 CF       0002*M 			RST.LIS	08h
044D7B C1          0860*  			POP	BC
044D7C FE 01       0861*  			CP	1
044D7E C9          0862*  			RET
044D7F             0863*  
044D7F             0864*  ; GETPTR - Return file pointer.
044D7F             0865*  ;    E = file channel
044D7F             0866*  ; Returns:
044D7F             0867*  ; DEHL = pointer (0-&7FFFFF)
044D7F             0868*  ; Destroys: A,B,C,D,E,H,L,F
044D7F             0869*  ;
044D7F FD E5       0870*  GETPTR:			PUSH		IY
044D81 4B          0871*  			LD		C, E
044D82             0872*  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
044D82 3E 19       0001*M 			LD	A, function
044D84 49 CF       0002*M 			RST.LIS	08h
044D86 E5          0873*  			PUSH		HL
044D87 FD E1       0874*  			POP		IY		; IYU: Pointer to FIL structure
044D89 FD 6E 11    0875*  			LD		L, (IY + FIL.fptr + 0)
044D8C FD 66 12    0876*  			LD		H, (IY + FIL.fptr + 1)
044D8F FD 5E 13    0877*  			LD		E, (IY + FIL.fptr + 2)
044D92 FD 56 14    0878*  			LD		D, (IY + FIL.fptr + 3)
044D95 FD E1       0879*  			POP		IY
044D97 C9          0880*  			RET
044D98             0881*  
044D98             0882*  ; PUTPTR - Update file pointer.
044D98             0883*  ;    A = file channel
044D98             0884*  ; DEHL = new pointer (0-&7FFFFF)
044D98             0885*  ; Destroys: A,B,C,D,E,H,L,F
044D98             0886*  ;
044D98 FD E5       0887*  PUTPTR:			PUSH		IY
044D9A 4F          0888*  			LD		C, A  		; C: Filehandle
044D9B E5          0889*  			PUSH		HL
044D9C 21 02 00 00 0890*  			LD		HL, 2
044DA0 39          0891*  			ADD		HL, SP
044DA1 73          0892*  			LD		(HL), E 	; 3rd byte of DWORD set to E
044DA2 E1          0893*  			POP		HL
044DA3 5A          0894*  			LD		E, D  		; 4th byte passed as E
044DA4             0895*  			MOSCALL		mos_flseek
044DA4 3E 1C       0001*M 			LD	A, function
044DA6 49 CF       0002*M 			RST.LIS	08h
044DA8 FD E1       0896*  			POP		IY
044DAA C9          0897*  			RET
044DAB             0898*  
044DAB             0899*  ; GETEXT - Find file size.
044DAB             0900*  ;    E = file channel
044DAB             0901*  ; Returns:
044DAB             0902*  ; DEHL = file size (0-&800000)
044DAB             0903*  ; Destroys: A,B,C,D,E,H,L,F
044DAB             0904*  ;
044DAB FD E5       0905*  GETEXT:         PUSH    IY
044DAD 4B          0906*                  LD      C, E
044DAE             0907*                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
044DAE 3E 19       0001*M 			LD	A, function
044DB0 49 CF       0002*M 			RST.LIS	08h
044DB2 E5          0908*                  PUSH    HL
044DB3 FD E1       0909*                  POP     IY          ; IYU: Pointer to FIL structure
044DB5             0910*                  ; Access the obj.objsize field using the offset values
044DB5 FD 6E 0B    0911*                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
044DB8 FD 66 0C    0912*                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
044DBB FD 5E 0D    0913*                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
044DBE FD 56 0E    0914*                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
044DC1             0915*  
044DC1 FD E1       0916*                  POP     IY
044DC3 C9          0917*  			RET
044DC4             0918*  
044DC4             0919*  ; GETIMS - Get time from RTC
044DC4             0920*  ;
044DC4 FD E5       0921*  GETIMS:			PUSH	IY
044DC6 21 00 02 04 0922*  			LD	HL, ACCS 		; Where to store the time string
044DCA             0923*  			MOSCALL	mos_getrtc
044DCA 3E 12       0001*M 			LD	A, function
044DCC 49 CF       0002*M 			RST.LIS	08h
044DCE 11 00 02 04 0924*  			LD	DE, ACCS		; DE: pointer to start of string accumulator
044DD2 5F          0925*  			LD	E, A 			;  E: now points to the end of the string
044DD3 FD E1       0926*  			POP	IY
044DD5 C9          0927*  			RET
044DD6             0928*  
044DD6             0929*  ; Get two word values from EXPR in DE, HL
044DD6             0930*  ; IY: Pointer to expression string
044DD6             0931*  ; Returns:
044DD6             0932*  ; DE: P1
044DD6             0933*  ; HL: P2
044DD6             0934*  ;
044DD6 CD 54 15 04 0935*  EXPR_W2:		CALL	EXPRI			; Get first parameter
044DDA D9          0936*  			EXX
044DDB E5          0937*  			PUSH	HL
044DDC CD 6F 1C 04 0938*  			CALL	COMMA
044DE0 CD 54 15 04 0939*  			CALL	EXPRI			; Get second parameter
044DE4 D9          0940*  			EXX
044DE5 D1          0941*  			POP	DE
044DE6 C9          0942*  			RET
044DE7             0943*  
044DE7             0944*  ; Stuff not implemented yet
044DE7             0945*  ;
044DE7 C9          0946*  RESET:			RET
044DE8             0016       include "sorry.asm"
044DE8             0001*  ;
044DE8             0002*  ; Title:	BBC Basic Interpreter - Z80 version
044DE8             0003*  ;		Catch-all for unimplemented functionality
044DE8             0004*  ; Author:	Dean Belfield
044DE8             0005*  ; Created:	12/05/2023
044DE8             0006*  ; Last Updated:	12/05/2023
044DE8             0007*  ;
044DE8             0008*  ; Modinfo:
044DE8             0009*  
044DE8             0010*  			; .ASSUME	ADL = 1
044DE8             0011*  
044DE8             0012*  			; SEGMENT CODE
044DE8             0013*  
044DE8             0014*  			; XDEF	ENVEL
044DE8             0015*  			; XDEF	ADVAL
044DE8             0016*  			; XDEF	PUTIMS
044DE8             0017*  
044DE8             0018*  			; XREF	EXTERR
044DE8             0019*  
044DE8             0020*  ENVEL:
044DE8             0021*  ADVAL:
044DE8             0022*  PUTIMS:
044DE8 AF          0023*  			XOR     A
044DE9 CD 2F 0D 04 0024*  			CALL    EXTERR
044DED 53 6F 72 72 0025*  			DEFB    "Sorry"
       79          
044DF2 00          0026*  			DEFB    0
044DF3             0017       include "user.asm"
044DF3             0001*  ; this must be the last include to allow unbounded user space for programs
044DF3             0002*  
044DF3             0003*  			; .ASSUME	ADL = 1
044DF3             0004*  
044DF3 FF FF FF FF 0005*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF          
044E00             0006*  USER:							; Must be aligned on a page boundary
044E00             0018       include "equs_bottom.inc"
044E00             0001*  ; --- Begin equs.inc ---
044E00             0002*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
044E00             0003*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
044E00             0004*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044E00             0005*  ; --- End equs.inc ---
044E00             0006*  
044E00             0007*  ; --- Begin eval.asm ---
044E00             0008*  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
044E00             0009*  ; 041DFA D6 C6       0258*  			SUB     TCMD
044E00             0010*  
044E00             0011*  ; --- End eval.asm ---
044E00             0012*  
044E00             0013*  ; --- Begin exec.asm ---
044E00             0014*  ; --- End exec.asm ---
044E00             0015*  
044E00             0016*  ; --- Begin fpp.asm ---
044E00             0017*  ; --- End fpp.asm ---
044E00             0018*  
044E00             0019*  ; --- Begin init.asm ---
044E00             0020*  ; --- End init.asm ---
044E00             0021*  
044E00             0022*  ; --- Begin main.asm ---
044E00             0023*  ; --- End main.asm ---
044E00             0024*  
044E00             0025*  ; --- Begin mos_api.inc ---
044E00             0026*  ; --- End mos_api.inc ---
044E00             0027*  
