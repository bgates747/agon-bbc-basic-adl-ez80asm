PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ; FFOBJID offsets
040000             0241*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0242*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0243*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0244*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0245*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0246*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0247*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0248*  
040000             0249*  ; FIL offsets (including FFOBJID fields)
040000             0250*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0251*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0252*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0253*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0254*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0255*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0256*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0257*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0258*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0259*  
040000             0260*  ; DIR offsets (including FFOBJID fields)
040000             0261*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0262*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0263*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0264*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0265*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0266*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0267*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0268*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0269*  
040000             0270*  ; FILINFO offsets
040000             0271*  FILINFO.fsize:    EQU 0    ; File size
040000             0272*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0273*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0274*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0275*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0276*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0277*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0278*  
040000             0279*  ;
040000             0280*  ; Macro for calling the API
040000             0281*  ; Parameters:
040000             0282*  ; - function: One of the function numbers listed above
040000             0283*  ;
040000             0284*  			MACRO MOSCALL	function
040000             0285*  			LD	A, function
040000             0286*  			RST.LIS	08h
040000             0287*  			ENDMACRO
040000             0002       include "macros.inc"
040000             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040000             0002*  	;		Useful macros
040000             0003*  	; Author:	Dean Belfield
040000             0004*  	; Created:	12/05/2023
040000             0005*  	; Last Updated:	11/06/2023
040000             0006*  	;
040000             0007*  	; Modinfo:
040000             0008*  	; 11/06/2023:	Modified to run in ADL mode
040000             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0010*  
040000             0011*  	MACRO EXREG	rp1, rp2
040000             0012*  		PUSH	rp1
040000             0013*  		POP	rp2
040000             0014*  	ENDMACRO
040000             0015*  
040000             0016*  	; MACRO ADD8U_DE	reg
040000             0017*  		MACRO ADD8U_DE
040000             0018*  		ADD	A, E
040000             0019*  		LD	E, A
040000             0020*  		ADC	A, D
040000             0021*  		SUB	E
040000             0022*  		LD	D, A
040000             0023*  	ENDMACRO
040000             0024*  
040000             0025*  	; MACRO ADD8U_HL	reg
040000             0026*  	MACRO ADD8U_HL
040000             0027*  		ADD	A, L
040000             0028*  		LD	L, A
040000             0029*  		ADC	A, H
040000             0030*  		SUB	L
040000             0031*  		LD	H, A
040000             0032*  	ENDMACRO
040000             0033*  
040000             0034*  	MACRO VDU	val
040000             0035*  		LD	A, val
040000             0036*  		CALL	OSWRCH
040000             0037*  	ENDMACRO
040000             0038*  
040000             0039*  	MACRO SET_GPIO	reg, val
040000             0040*  		IN0	A, (reg)
040000             0041*  		OR	val
040000             0042*  		OUT0	(reg), A
040000             0043*  	ENDMACRO
040000             0044*  
040000             0045*  	MACRO RES_GPIO	reg, val
040000             0046*  		PUSH	BC
040000             0047*  		LD	A, val
040000             0048*  		CPL
040000             0049*  		LD	C, A
040000             0050*  		IN0	A, (reg)
040000             0051*  		AND	C
040000             0052*  		OUT0	(reg), A
040000             0053*  		POP	BC
040000             0054*  	ENDMACRO
040000             0003       include "init.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040000             0003*  ;		Initialisation Code
040000             0004*  ; Author:	Dean Belfield
040000             0005*  ; Created:	12/05/2023
040000             0006*  ; Last Updated:	26/11/2023
040000             0007*  ;
040000             0008*  ; Modinfo:
040000             0009*  ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0010*  ; 26/11/2023:	Moved the ram clear routine into here
040000             0011*  
040000             0012*  			; SEGMENT CODE
040000             0013*  
040000             0014*  			; XDEF	_end
040000             0015*  
040000             0016*  			; XREF	_main				; In main.asm
040000             0017*  
040000             0018*  			; XREF	RAM_START			; In ram.asm
040000             0019*  			; XREF	RAM_END
040000             0020*  
040000             0021*  			.ASSUME	ADL = 1
040000             0022*  
040000             0023*  			; INCLUDE	"equs.inc"
040000             0024*  
040000             0025*  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040000             0026*  
040000             0027*  ;
040000             0028*  ; Start in ADL mode
040000             0029*  ;
040000 C3 45 00 04 0030*  			JP	_start				; Jump to start
040004             0031*  ;
040004             0032*  ; The header stuff is from byte 64 onwards
040004             0033*  ;
040004 62 62 63 62 0034*  _exec_name:		DB	"bbcbasic24ez.bin", 0		; The executable name, only used in argv
       61 73 69 63 
       32 34 65 7A 
       2E 62 69 6E 
       00          
040015             0035*  
040015 FF FF FF FF 0036*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040             0037*  
040040 4D 4F 53    0038*  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040043 00          0039*  			DB	00h				; MOS header version 0
040044 01          0040*  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040045             0041*  ;
040045             0042*  ; And the code follows on immediately after the header
040045             0043*  ;
040045 F5          0044*  _start:			PUSH		AF			; Preserve the rest of the registers
040046 C5          0045*  			PUSH		BC
040047 D5          0046*  			PUSH		DE
040048 DD E5       0047*  			PUSH		IX
04004A FD E5       0048*  			PUSH		IY
04004C             0049*  
04004C ED 73 D7 00 0050*  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040051             0051*  
040051 DD 21 DA 00 0052*  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040056 DD E5       0053*  			PUSH		IX
040058 CD 88 00 04 0054*  			CALL		_parse_params		; Parse the parameters
04005C DD E1       0055*  			POP		IX			; IX: argv
04005E 06 00       0056*  			LD		B, 0			;  C: argc
040060 CD 75 00 04 0057*  			CALL		_clear_ram
040064 C3 0A 01 04 0058*  			JP		_main			; Start user code
040068             0059*  ;
040068             0060*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040068             0061*  ;
040068 ED 7B D7 00 0062*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04006D             0063*  
04006D FD E1       0064*  			POP		IY			; Restore the registers
04006F DD E1       0065*  			POP		IX
040071 D1          0066*  			POP		DE
040072 C1          0067*  			POP		BC
040073 F1          0068*  			POP		AF
040074 C9          0069*  			RET					; Return to MOS
040075             0070*  
040075             0071*  ;Clear the application memory
040075             0072*  ;
040075 C5          0073*  _clear_ram:		PUSH		BC
040076 21 00 4A 04 0074*  			LD		HL, RAM_START
04007A 11 01 4A 04 0075*  			LD		DE, RAM_START + 1
04007E 01 4F 03 00 0076*  			LD		BC, RAM_END - RAM_START - 1
040082 AF          0077*  			XOR		A
040083 77          0078*  			LD		(HL), A
040084 ED B0       0079*  			LDIR
040086 C1          0080*  			POP		BC
040087 C9          0081*  			RET
040088             0082*  
040088             0083*  ; Parse the parameter string into a C array
040088             0084*  ; Parameters
040088             0085*  ; - HL: Address of parameter string
040088             0086*  ; - IX: Address for array pointer storage
040088             0087*  ; Returns:
040088             0088*  ; -  C: Number of parameters parsed
040088             0089*  ;
040088 01 04 00 04 0090*  _parse_params:		LD	BC, _exec_name
04008C DD 0F 00    0091*  			LD	(IX+0), BC		; ARGV[0] = the executable name
04008F DD 23       0092*  			INC	IX
040091 DD 23       0093*  			INC	IX
040093 DD 23       0094*  			INC	IX
040095 CD D0 00 04 0095*  			CALL	_skip_spaces		; Skip HL past any leading spaces
040099             0096*  ;
040099 01 01 00 00 0097*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04009D 06 0F       0098*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04009F             0099*  ;
04009F             0100*  _parse_params_1:
04009F C5          0101*  			PUSH	BC			; Stack ARGC
0400A0 E5          0102*  			PUSH	HL			; Stack start address of token
0400A1 CD C1 00 04 0103*  			CALL	_get_token		; Get the next token
0400A5 79          0104*  			LD	A, C			; A: Length of the token in characters
0400A6 D1          0105*  			POP	DE			; Start address of token (was in HL)
0400A7 C1          0106*  			POP	BC			; ARGC
0400A8 B7          0107*  			OR	A			; Check for A=0 (no token found) OR at end of string
0400A9 C8          0108*  			RET	Z
0400AA             0109*  ;
0400AA DD 1F 00    0110*  			LD	(IX+0), DE		; Store the pointer to the token
0400AD E5          0111*  			PUSH	HL			; DE=HL
0400AE D1          0112*  			POP	DE
0400AF CD D0 00 04 0113*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0400B3 AF          0114*  			XOR	A
0400B4 12          0115*  			LD	(DE), A			; Zero-terminate the token
0400B5 DD 23       0116*  			INC	IX
0400B7 DD 23       0117*  			INC	IX
0400B9 DD 23       0118*  			INC	IX			; Advance to next pointer position
0400BB 0C          0119*  			INC	C			; Increment ARGC
0400BC 79          0120*  			LD	A, C			; Check for C >= A
0400BD B8          0121*  			CP	B
0400BE 38 DF       0122*  			JR	C, _parse_params_1	; And loop
0400C0 C9          0123*  			RET
0400C1             0124*  
0400C1             0125*  ; Get the next token
0400C1             0126*  ; Parameters:
0400C1             0127*  ; - HL: Address of parameter string
0400C1             0128*  ; Returns:
0400C1             0129*  ; - HL: Address of first character after token
0400C1             0130*  ; -  C: Length of token (in characters)
0400C1             0131*  ;
0400C1 0E 00       0132*  _get_token:		LD	C, 0			; Initialise length
0400C3 7E          0133*  @@:			LD	A, (HL)			; Get the character from the parameter string
0400C4 B7          0134*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0400C5 C8          0135*  			RET 	Z
0400C6 FE 0D       0136*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0400C8 C8          0137*  			RET	Z
0400C9 FE 20       0138*  			CP	' '			; Exit if space (end of token)
0400CB C8          0139*  			RET	Z
0400CC 23          0140*  			INC	HL			; Advance to next character
0400CD 0C          0141*  			INC 	C			; Increment length
0400CE 18 F3       0142*  			JR	@B
0400D0             0143*  
0400D0             0144*  ; Skip spaces in the parameter string
0400D0             0145*  ; Parameters:
0400D0             0146*  ; - HL: Address of parameter string
0400D0             0147*  ; Returns:
0400D0             0148*  ; - HL: Address of next none-space character
0400D0             0149*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0400D0             0150*  ;
0400D0 7E          0151*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0400D1 FE 20       0152*  			CP	' '			; Exit if not space
0400D3 C0          0153*  			RET	NZ
0400D4 23          0154*  			INC	HL			; Advance to next character
0400D5 18 F9       0155*  			JR	_skip_spaces		; Increment length
0400D7             0156*  
0400D7             0157*  ; Storage
0400D7             0158*  ;
0400D7             0159*  _sps:			DS	3			; Storage for the stack pointer
0400DA 00 00 00 00 0160*  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04010A             0004       ; include "ram.asm"
04010A             0005       include "equs_top.inc"
04010A             0001*  ; --- Begin equs.inc ---
04010A             0002*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
04010A             0003*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
04010A             0004*  PA_DR:			EQU		96h
04010A             0005*  PA_DDR:			EQU		97h
04010A             0006*  PA_ALT1:		EQU		98h
04010A             0007*  PA_ALT2:		EQU		99h
04010A             0008*  PB_DR:          	EQU		9Ah
04010A             0009*  PB_DDR:        	 	EQU		9Bh
04010A             0010*  PB_ALT1:        	EQU		9Ch
04010A             0011*  PB_ALT2:        	EQU		9Dh
04010A             0012*  PC_DR:          	EQU		9Eh
04010A             0013*  PC_DDR:         	EQU		9Fh
04010A             0014*  PC_ALT1:        	EQU		A0h
04010A             0015*  PC_ALT2:        	EQU		A1h
04010A             0016*  PD_DR:          	EQU		A2h
04010A             0017*  PD_DDR:			EQU		A3h
04010A             0018*  PD_ALT1:		EQU		A4h
04010A             0019*  PD_ALT2:		EQU		A5h
04010A             0020*  GPIOMODE_OUT:		EQU		0	; Output
04010A             0021*  GPIOMODE_IN:		EQU		1	; Input
04010A             0022*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
04010A             0023*  GPIOMODE_SIO:		EQU		3	; Open Source IO
04010A             0024*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
04010A             0025*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
04010A             0026*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
04010A             0027*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
04010A             0028*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
04010A             0029*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
04010A             0030*  CR:			EQU     0DH
04010A             0031*  LF:			EQU     0AH
04010A             0032*  ESC:			EQU     1BH
04010A             0033*  ; --- End equs.inc ---
04010A             0034*  
04010A             0035*  ; --- Begin eval.asm ---
04010A             0036*  FUNTOK:			EQU	8DH			; First token number
04010A             0037*  ANDK:			EQU     80H
04010A             0038*  DIVK:			EQU     81H
04010A             0039*  EORK:			EQU     82H
04010A             0040*  MODK:			EQU     83H
04010A             0041*  ORK:			EQU     84H
04010A             0042*  ; --- End eval.asm ---
04010A             0043*  
04010A             0044*  ; --- Begin exec.asm ---
04010A             0045*  ; --- End exec.asm ---
04010A             0046*  
04010A             0047*  ; --- Begin fpp.asm ---
04010A             0048*  BADOP:			EQU     1               ;Bad operation code
04010A             0049*  DIVBY0:			EQU     18              ;Division by zero
04010A             0050*  TOOBIG_FP:			EQU     20              ;Too big
04010A             0051*  NGROOT:			EQU     21              ;Negative root
04010A             0052*  LOGRNG:			EQU     22              ;Log range
04010A             0053*  ACLOST:			EQU     23              ;Accuracy lost
04010A             0054*  EXPRNG:			EQU     24              ;Exp range
04010A             0055*  ; --- End fpp.asm ---
04010A             0056*  
04010A             0057*  ; --- Begin init.asm ---
04010A             0058*  ; --- End init.asm ---
04010A             0059*  
04010A             0060*  ; --- Begin main.asm ---
04010A             0061*  DATA_:	EQU     DCH
04010A             0062*  DEF_:	EQU     DDH
04010A             0063*  DIM:	EQU     DEH
04010A             0064*  ELSE_:	EQU     8BH
04010A             0065*  FN:	EQU     A4H
04010A             0066*  FOR:	EQU     E3H
04010A             0067*  GOSUB:	EQU     E4H
04010A             0068*  GOTO:	EQU     E5H
04010A             0069*  LINE_:	EQU     86H
04010A             0070*  LINO:	EQU     8DH
04010A             0071*  LOCAL_:	EQU     EAH
04010A             0072*  NEXT:	EQU     EDH
04010A             0073*  OFF_:	EQU     87H
04010A             0074*  ON_:	EQU     EEH
04010A             0075*  PROC:	EQU     F2H
04010A             0076*  REM:	EQU     F4H
04010A             0077*  REN:	EQU     CCH
04010A             0078*  REPEAT:	EQU     F5H
04010A             0079*  RESTOR:	EQU     F7H
04010A             0080*  SPC:	EQU     89H
04010A             0081*  STEP:	EQU     88H
04010A             0082*  TAB:	EQU     8AH
04010A             0083*  TAND:	EQU     80H
04010A             0084*  TCALL:	EQU     D6H
04010A             0085*  TERROR:	EQU     85H
04010A             0086*  TGOSUB:	EQU     E4H
04010A             0087*  TGOTO:	EQU     E5H
04010A             0088*  THEN:	EQU     8CH
04010A             0089*  TIF:	EQU     E7H
04010A             0090*  TO:	EQU     B8H
04010A             0091*  TON:	EQU     EEH
04010A             0092*  TOR:	EQU     84H
04010A             0093*  TPROC:	EQU     F2H
04010A             0094*  TRACE:	EQU     FCH
04010A             0095*  TSTOP:	EQU     FAH
04010A             0096*  UNTIL:	EQU     FDH
04010A             0097*  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
04010A             0098*  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
04010A             0099*  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
04010A             0100*  ; --- End main.asm ---
04010A             0006       include "main.asm"
04010A             0001*  ;
04010A             0002*  ; Title:	BBC Basic Interpreter - Z80 version
04010A             0003*  ;		Command, Error and Lexical Analysis Module - "MAIN"
04010A             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
04010A             0005*  ; Modified By:	Dean Belfield
04010A             0006*  ; Created:	12/05/2023
04010A             0007*  ; Last Updated:	26/11/2023
04010A             0008*  ;
04010A             0009*  ; Modinfo:
04010A             0010*  ; 07/05/1984:	Version 2.3
04010A             0011*  ; 01/03/1987:	Version 3.0
04010A             0012*  ; 03/05/2022:	Modified by Dean Belfield
04010A             0013*  ; 06/06/2023:	Modified to run in ADL mode
04010A             0014*  ; 26/06/2023:	Fixed binary and unary indirection
04010A             0015*  ; 17/08/2023:	Added binary constants
04010A             0016*  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
04010A             0017*  ; 26/11/2023:	Fixed bug in AUTOLOAD
04010A             0018*  
04010A             0019*  			; .ASSUME	ADL = 1
04010A             0020*  
04010A             0021*  			; INCLUDE	"equs.inc"
04010A             0022*  
04010A             0023*  			; SEGMENT CODE
04010A             0024*  
04010A             0025*  			; XDEF	_main
04010A             0026*  
04010A             0027*  			; XDEF	COLD
04010A             0028*  			; XDEF	WARM
04010A             0029*  			; XDEF	CLOOP
04010A             0030*  			; XDEF	DELETE
04010A             0031*  			; XDEF	LIST_
04010A             0032*  			; XDEF	RENUM
04010A             0033*  			; XDEF	AUTO
04010A             0034*  			; XDEF	NEW
04010A             0035*  			; XDEF	OLD
04010A             0036*  			; XDEF	LOAD
04010A             0037*  			; XDEF	SAVE
04010A             0038*  			; XDEF	ERROR_
04010A             0039*  			; XDEF	EXTERR
04010A             0040*  			; XDEF	LOAD0
04010A             0041*  			; XDEF	CLEAR
04010A             0042*  			; XDEF	CRLF
04010A             0043*  			; XDEF	OUTCHR
04010A             0044*  			; XDEF	OUT_
04010A             0045*  			; XDEF	FINDL
04010A             0046*  			; XDEF	SETLIN
04010A             0047*  			; XDEF	PBCDL
04010A             0048*  			; XDEF	SAYLN
04010A             0049*  			; XDEF	PUTVAR
04010A             0050*  			; XDEF	GETVAR
04010A             0051*  			; XDEF	GETDEF
04010A             0052*  			; XDEF	CREATE
04010A             0053*  			; XDEF	RANGE
04010A             0054*  			; XDEF	LEXAN2
04010A             0055*  			; XDEF	REPORT
04010A             0056*  			; XDEF	TELL
04010A             0057*  			; XDEF	SPACE_
04010A             0058*  			; XDEF	KEYWDS
04010A             0059*  			; XDEF	KEYWDL
04010A             0060*  			; XDEF	ONEDIT
04010A             0061*  			; XDEF	ONEDIT1
04010A             0062*  			; XDEF	LISTIT
04010A             0063*  			; XDEF	CLEAN
04010A             0064*  
04010A             0065*  			; XREF	LISTON
04010A             0066*  			; XREF	ERRTXT
04010A             0067*  			; XREF	OSINIT
04010A             0068*  			; XREF	HIMEM
04010A             0069*  			; XREF	PAGE_
04010A             0070*  			; XREF	CHAIN0
04010A             0071*  			; XREF	PROMPT
04010A             0072*  			; XREF	ERRTRP
04010A             0073*  			; XREF	ERRLIN
04010A             0074*  			; XREF	AUTONO
04010A             0075*  			; XREF	LINENO
04010A             0076*  			; XREF	INCREM
04010A             0077*  			; XREF	OSLINE
04010A             0078*  			; XREF	COUNT
04010A             0079*  			; XREF	NXT
04010A             0080*  			; XREF	BUFFER
04010A             0081*  			; XREF	XEQ
04010A             0082*  			; XREF	TOP
04010A             0083*  			; XREF	EXPRI
04010A             0084*  			; XREF	SEARCH
04010A             0085*  			; XREF	LTRAP
04010A             0086*  			; XREF	LOMEM
04010A             0087*  			; XREF	DECODE
04010A             0088*  			; XREF	EXPRS
04010A             0089*  			; XREF	OSSAVE
04010A             0090*  			; XREF	ERR
04010A             0091*  			; XREF	ERL
04010A             0092*  			; XREF	TRACEN
04010A             0093*  			; XREF	RESET
04010A             0094*  			; XREF	OSSHUT
04010A             0095*  			; XREF	OSLOAD
04010A             0096*  			; XREF	FREE
04010A             0097*  			; XREF	DYNVAR
04010A             0098*  			; XREF	FILL
04010A             0099*  			; XREF	OSWRCH
04010A             0100*  			; XREF	WIDTH
04010A             0101*  			; XREF	COMMA
04010A             0102*  			; XREF	MUL16
04010A             0103*  			; XREF	BRAKET
04010A             0104*  			; XREF	X4OR5
04010A             0105*  			; XREF	LOADN
04010A             0106*  			; XREF	SFIX
04010A             0107*  			; XREF	ITEMI
04010A             0108*  			; XREF	FNPTR
04010A             0109*  			; XREF	PROPTR
04010A             0110*  			; XREF	CHECK
04010A             0111*  			; XREF	TERMQ
04010A             0112*  			; XREF	OSWRCHCH
04010A             0113*  			; XREF	NEWIT
04010A             0114*  			; XREF	BAD
04010A             0115*  			; XREF	RAM_START
04010A             0116*  			; XREF	RAM_END
04010A             0117*  			; XREF	R0
04010A             0118*  			; XREF	STAR_VERSION
04010A             0119*  
04010A             0120*  			; XREF	_end			; In init.asm
04010A             0121*  
04010A             0122*  ;
04010A             0123*  ; This defines the block of tokens that are pseudo-variables.
04010A             0124*  ; There are two versions of each token, a GET and a SET
04010A             0125*  
04010A             0126*  ; Name  : GET : SET
04010A             0127*  ; ------:-----:----
04010A             0128*  ; PTR   : 8Fh : CFh
04010A             0129*  ; PAGE  : 90h : D0h
04010A             0130*  ; TIME  : 91h : D1h
04010A             0131*  ; LOMEM : 92h : D2h
04010A             0132*  ; HIMEM : 93h : D3h
04010A             0133*  ;
04010A             0134*  ; Examples:
04010A             0135*  ;   LET A% = PAGE : REM This is the GET version
04010A             0136*  ;   PAGE = 40000  : REM This is the SET version
04010A             0137*  ;
04010A             0138*  ; TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
04010A             0139*  ; TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
04010A             0140*  ; OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
04010A             0141*  
04010A             0142*  ; The main routine
04010A             0143*  ; IXU: argv - pointer to array of parameters
04010A             0144*  ;   C: argc - number of parameters
04010A             0145*  ; Returns:
04010A             0146*  ;  HL: Error code, or 0 if OK
04010A             0147*  ;
04010A 21 00 4A 04 0148*  _main:			LD	HL, ACCS		; Clear the ACCS
04010E 36 00       0149*  			LD	(HL), 0
040110 79          0150*  			LD	A, C
040111 FE 02       0151*  			CP	2
040113 28 2D       0152*  			JR	Z, AUTOLOAD		; 2 parameters = autoload
040115 38 3F       0153*  			JR	C, COLD			; 1 parameter = normal start
040117 CD 23 46 04 0154*  			CALL	STAR_VERSION
04011B CD 02 0F 04 0155*  			CALL	TELL
04011F 55 73 61 67 0156*  			DB	"Usage:\n\r"
       65 3A 0A 0D 
040127 52 55 4E 20 0157*  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
04013A 21 00 00 00 0158*  			LD	HL, 0			; The error code
04013E C3 68 00 04 0159*  			JP	_end
040142             0160*  ;
040142 DD 27 03    0161*  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
040145 11 00 4A 04 0162*  			LD	DE, ACCS		;  DE: Destination address
040149 7E          0163*  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
04014A 12          0164*  			LD	(DE), A			;
04014B 23          0165*  			INC	HL			; Increase the source pointer
04014C 1C          0166*  			INC	E			; We only need to increase E as ACCS is on a page boundary
04014D 28 03       0167*  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
04014F B7          0168*  			OR	A
040150 20 F7       0169*  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
040152 1D          0170*  AUTOLOAD_2:		DEC	E
040153 3E 0D       0171*  			LD	A, CR
040155 12          0172*  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
040156             0173*  ;
040156 E1          0174*  COLD:			POP	HL			; Pop the return address to init off SPS
040157 E5          0175*  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
040158 21 00 4C 04 0176*  			LD	HL, STAVAR		; Cold start
04015C F9          0177*  			LD	SP, HL
04015D 36 0A       0178*  			LD	(HL), 10
04015F 23          0179*  			INC	HL
040160 36 09       0180*  			LD	(HL),9
040162 CD 5B 45 04 0181*  			CALL    OSINIT			; Call the machine specific OS initialisation routines
040166 ED 53 20 4D 0182*  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
04016B 22 14 4D 04 0183*  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
04016F 3E B7       0184*  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
040171 32 40 4D 04 0185*  			LD      (LISTON),A
040175 21 CE 01 04 0186*  			LD      HL,NOTICE
040179 22 2F 4D 04 0187*  			LD      (ERRTXT),HL
04017D CD DE 09 04 0188*  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
040181 3A 00 4A 04 0189*  			LD	A,(ACCS)		; Check if there is a filename in ACCS
040185 B7          0190*  			OR	A
040186 C2 5A 19 04 0191*  			JP	NZ,CHAIN0		; Yes, so load and run
04018A CD 23 46 04 0192*  			CALL	STAR_VERSION		;
04018E CD 02 0F 04 0193*  			CALL    TELL			; Output the welcome message
040192 42 42 43 20 0194*  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
0401B0 45 5A 38 30 0195*  			db      "EZ80ASM ADL Version 0.01beta\n\r"
       41 53 4D 20 
       41 44 4C 20 
       56 65 72 73 
       69 6F 6E 20 
       30 2E 30 31 
       62 65 74 61 
       0A 0D       
0401CE 28 43 29 20 0196*  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0401EE 0A 0D 00    0197*  			DB	"\n\r", 0
0401F1             0198*  ;
0401F1 F6          0199*  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0401F2             0200*  ;
0401F2             0201*  ; This is the main entry point for BASIC
0401F2             0202*  ;
0401F2 37          0203*  CLOOP:			SCF				; See above - not sure why this is here!
0401F3 ED 7B 20 4D 0204*  			LD      SP,(HIMEM)
       04          
0401F8 CD D4 44 04 0205*  			CALL    PROMPT          	; Prompt user
0401FC 21 40 4D 04 0206*  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
040200 7E          0207*  			LD      A,(HL)			; Fetch the value
040201 E6 0F       0208*  			AND     0FH             	; Bottom nibble: LISTO
040203 F6 B0       0209*  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
040205 77          0210*  			LD      (HL),A			; Store back in
040206 ED 62       0211*  			SBC     HL,HL           	; HL: 0
040208 22 2C 4D 04 0212*  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
04020C 22 35 4D 04 0213*  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
040210             0214*  ;
040210 2A 29 4D 04 0215*  			LD      HL,(AUTONO)		; Get the auto line number
040214 22 23 4D 04 0216*  			LD      (LINENO),HL		; Store in line number
040218 7C          0217*  			LD      A,H			; If the auto line number is zero then
040219 B5          0218*  			OR      L
04021A 28 1E       0219*  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
04021C             0220*  ;
04021C             0221*  ; This section handles auto line numbering
04021C             0222*  ;
04021C E5          0223*  			PUSH    HL			; Stack the line number
04021D CD 6D 0B 04 0224*  			CALL    PBCD           	 	; Output the line number
040221 E1          0225*  			POP     HL			; Pop the line number back off the stack
040222             0226*  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
040222             0227*  ;			LD      B,0			; So clear B
040222 01 00 00 00 0228*  			LD	BC, 0			; Load BC with Increment
040226 3A 41 4D 04 0229*  			LD	A,(INCREM)
04022A 4F          0230*  			LD	C, A
04022B 09          0231*  			ADD     HL,BC			; Add the increment to the line number
04022C DA 97 0D 04 0232*  			JP      C,TOOBIG		; And error if we wrap
040230 22 29 4D 04 0233*  			LD      (AUTONO),HL		; Store the new auto line number
040234 3E 20       0234*  			LD      A,' '			; Print a space
040236 CD C1 0A 04 0235*  			CALL    OUTCHR
04023A             0236*  ;
04023A             0237*  ; This section invokes the line editor
04023A             0238*  ;
04023A 21 00 4A 04 0239*  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
04023E CD 39 44 04 0240*  			CALL    OSLINE          	; Call the line editor in MOS
040242 CD 4E 02 04 0241*  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
040246 DC B1 09 04 0242*  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
04024A C3 F2 01 04 0243*  			JP      CLOOP			; Jump back to immediate mode
04024E             0244*  ;
04024E             0245*  ; This bit enters the line into memory
04024E             0246*  ; Also called from OSLOAD_TXT
04024E             0247*  ; Returns:
04024E             0248*  ; F: C if a new line has been entered (CLEAN will need to be called)
04024E             0249*  ;
04024E AF          0250*  ONEDIT1:		XOR     A			; Entry point after *EDIT
04024F 32 3D 4D 04 0251*  			LD      (COUNT),A
040253 FD 21 00 4A 0252*  			LD      IY,ACCS
       04          
040258 CD 6B 0D 04 0253*  			CALL    LINNUM			; HL: The line number from the input buffer
04025C CD 77 18 04 0254*  			CALL    NXT			; Skip spaces
040260 7C          0255*  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
040261 B5          0256*  			OR      L
040262 28 04       0257*  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
040264 22 23 4D 04 0258*  			LD      (LINENO),HL		; Otherwise store it
040268             0259*  ;
040268             0260*  ; This bit does the lexical analysis and tokenisation
040268             0261*  ;
040268 0E 01       0262*  LNZERO:			LD	C,1			; Left mode
04026A 11 00 4B 04 0263*  			LD      DE,BUFFER		; Buffer for tokenised BASIC
04026E CD 11 0E 04 0264*  			CALL    LEXAN2          	; Lexical analysis on the user input
040272 12          0265*  			LD      (DE),A          	; Terminator
040273 AF          0266*  			XOR     A
040274             0267*  ;			LD      B,A
040274             0268*  ;			LD      C,E             	; BC: Line length
040274 01 00 00 00 0269*  			LD	BC,0
040278 4B          0270*  			LD	C,E			; BC: Line length
040279 13          0271*  			INC     DE
04027A 12          0272*  			LD      (DE),A          	; Zero next
04027B 2A 23 4D 04 0273*  			LD      HL,(LINENO)		; Get the line number
04027F 7C          0274*  			LD      A,H			; Is it zero, i.e. a command with no line number?
040280 B5          0275*  			OR      L
040281 FD 21 00 4B 0276*  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
040286 CA 9D 19 04 0277*  			JP      Z,XEQ           	; Execute it
04028A             0278*  ;
04028A             0279*  ; This section stores the BASIC line in memory
04028A             0280*  ;
04028A C5          0281*  			PUSH    BC
04028B E5          0282*  			PUSH    HL
04028C CD BD 09 04 0283*  			CALL    SETTOP          	; Set TOP sysvar
040290 E1          0284*  			POP     HL
040291 CD 01 0B 04 0285*  			CALL    FINDL			; Find the address of the line
040295 CC 74 09 04 0286*  			CALL    Z,DEL			; Delete the existing line if found
040299 C1          0287*  			POP     BC
04029A 79          0288*  			LD      A,C			; Check for the line length being zero, i.e.
04029B B7          0289*  			OR      A			; the user has just entered a line number in the command line
04029C C8          0290*  			RET	Z 	         	; If so, then don't do anything else
04029D C6 04       0291*  			ADD     A,4
04029F 4F          0292*  			LD      C,A             	; Length inclusive
0402A0 D5          0293*  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0402A1 C5          0294*  			PUSH    BC              	; BC: Line length
0402A2 EB          0295*  			EX      DE,HL			; DE: Address of the line in memory
0402A3 2A 17 4D 04 0296*  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0402A7 E5          0297*  			PUSH    HL			; Stack TOP (current TOP value)
0402A8 09          0298*  			ADD     HL,BC			; Add the line length to HL, the new TOP value
0402A9 E5          0299*  			PUSH    HL			; Stack HL (new TOP value)
0402AA 24          0300*  			INC     H			; Add 256 to HL
0402AB AF          0301*  			XOR     A
0402AC ED 72       0302*  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0402AE E1          0303*  			POP     HL			; Pop HL (new TOP value)
0402AF D2 D2 08 04 0304*  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0402B3 22 17 4D 04 0305*  			LD      (TOP),HL		; Store new value of TOP
0402B7 E3          0306*  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0402B8 E5          0307*  			PUSH    HL			; PUSH current TOP value
0402B9 23          0308*  			INC     HL
0402BA B7          0309*  			OR      A
0402BB ED 52       0310*  			SBC     HL,DE			; DE: Address of the line in memory
0402BD 44          0311*  			LD      B,H             	; BC: Amount to move
0402BE 4D          0312*  			LD      C,L
0402BF E1          0313*  			POP     HL			; HL: Destination (current TOP value)
0402C0 D1          0314*  			POP     DE			; DE: Source (new TOP value)
0402C1 28 02       0315*  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0402C3 ED B8       0316*  			LDDR                    	; Otherwise, make space for the new line in the program
0402C5 C1          0317*  ATEND:			POP     BC              	; BC: Line length
0402C6 D1          0318*  			POP     DE              	; DE: Line number
0402C7 23          0319*  			INC     HL			; HL: Destination address
0402C8 71          0320*  			LD      (HL),C          	; Store length
0402C9 23          0321*  			INC     HL
0402CA 73          0322*  			LD      (HL),E          	; Store line number
0402CB 23          0323*  			INC     HL
0402CC 72          0324*  			LD      (HL),D
0402CD 23          0325*  			INC     HL
0402CE 11 00 4B 04 0326*  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0402D2 EB          0327*  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0402D3 0D          0328*  			DEC     C			; Subtract 3 from the number of bytes to copy to
0402D4 0D          0329*  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0402D5 0D          0330*  			DEC     C
0402D6 ED B0       0331*  			LDIR                    	; Add the line to the BASIC program
0402D8 37          0332*  			SCF				; To flag we need to call CLEAN
0402D9 C9          0333*  			RET
0402DA             0334*  ;
0402DA             0335*  ; List of tokens and keywords. If a keyword is followed by 0 then
0402DA             0336*  ; it will only match with the keyword followed immediately by
0402DA             0337*  ; a delimiter
0402DA             0338*  ;
0402DA 80 41 4E 44 0339*  KEYWDS:			DB    80H, "AND"
0402DE 94 41 42 53 0340*  			DB    94H, "ABS"
0402E2 95 41 43 53 0341*  			DB    95H, "ACS"
0402E6 96 41 44 56 0342*  			DB    96H, "ADVAL"
       41 4C       
0402EC 97 41 53 43 0343*  			DB    97H, "ASC"
0402F0 98 41 53 4E 0344*  			DB    98H, "ASN"
0402F4 99 41 54 4E 0345*  			DB    99H, "ATN"
0402F8 C6 41 55 54 0346*  			DB    C6H, "AUTO"
       4F          
0402FD 9A 42 47 45 0347*  			DB    9AH, "BGET", 0
       54 00       
040303 D5 42 50 55 0348*  			DB    D5H, "BPUT", 0
       54 00       
040309 FB 43 4F 4C 0349*  			DB    FBH, "COLOUR"
       4F 55 52    
040310 FB 43 4F 4C 0350*  			DB    FBH, "COLOR"
       4F 52       
040316 D6 43 41 4C 0351*  			DB    D6H, "CALL"
       4C          
04031B D7 43 48 41 0352*  			DB    D7H, "CHAIN"
       49 4E       
040321 BD 43 48 52 0353*  			DB    BDH, "CHR$"
       24          
040326 D8 43 4C 45 0354*  			DB    D8H, "CLEAR", 0
       41 52 00    
04032D D9 43 4C 4F 0355*  			DB    D9H, "CLOSE", 0
       53 45 00    
040334 DA 43 4C 47 0356*  			DB    DAH, "CLG", 0
       00          
040339 DB 43 4C 53 0357*  			DB    DBH, "CLS", 0
       00          
04033E 9B 43 4F 53 0358*  			DB    9BH, "COS"
040342 9C 43 4F 55 0359*  			DB    9CH, "COUNT", 0
       4E 54 00    
040349 DC 44 41 54 0360*  			DB    DCH, "DATA"
       41          
04034E 9D 44 45 47 0361*  			DB    9DH, "DEG"
040352 DD 44 45 46 0362*  			DB    DDH, "DEF"
040356 C7 44 45 4C 0363*  			DB    C7H, "DELETE"
       45 54 45    
04035D 81 44 49 56 0364*  			DB    81H, "DIV"
040361 DE 44 49 4D 0365*  			DB    DEH, "DIM"
040365 DF 44 52 41 0366*  			DB    DFH, "DRAW"
       57          
04036A E1 45 4E 44 0367*  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
040373 E0 45 4E 44 0368*  			DB    E0H, "END", 0
       00          
040378 E2 45 4E 56 0369*  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
040381 8B 45 4C 53 0370*  			DB    8BH, "ELSE"
       45          
040386 A0 45 56 41 0371*  			DB    A0H, "EVAL"
       4C          
04038B 9E 45 52 4C 0372*  			DB    9EH, "ERL", 0
       00          
040390 85 45 52 52 0373*  			DB    85H, "ERROR"
       4F 52       
040396 C5 45 4F 46 0374*  			DB    C5H, "EOF", 0
       00          
04039B 82 45 4F 52 0375*  			DB    82H, "EOR"
04039F 9F 45 52 52 0376*  			DB    9FH, "ERR", 0
       00          
0403A4 A1 45 58 50 0377*  			DB    A1H, "EXP"
0403A8 A2 45 58 54 0378*  			DB    A2H, "EXT", 0
       00          
0403AD E3 46 4F 52 0379*  			DB    E3H, "FOR"
0403B1 A3 46 41 4C 0380*  			DB    A3H, "FALSE", 0
       53 45 00    
0403B8 A4 46 4E    0381*  			DB    A4H, "FN"
0403BB E5 47 4F 54 0382*  			DB    E5H, "GOTO"
       4F          
0403C0 BE 47 45 54 0383*  			DB    BEH, "GET$"
       24          
0403C5 A5 47 45 54 0384*  			DB    A5H, "GET"
0403C9 E4 47 4F 53 0385*  			DB    E4H, "GOSUB"
       55 42       
0403CF E6 47 43 4F 0386*  			DB    E6H, "GCOL"
       4C          
0403D4 93 48 49 4D 0387*  			DB    93H, "HIMEM", 0
       45 4D 00    
0403DB E8 49 4E 50 0388*  			DB    E8H, "INPUT"
       55 54       
0403E1 E7 49 46    0389*  			DB    E7H, "IF"
0403E4 BF 49 4E 4B 0390*  			DB    BFH, "INKEY$"
       45 59 24    
0403EB A6 49 4E 4B 0391*  			DB    A6H, "INKEY"
       45 59       
0403F1 A8 49 4E 54 0392*  			DB    A8H, "INT"
0403F5 A7 49 4E 53 0393*  			DB    A7H, "INSTR("
       54 52 28    
0403FC C9 4C 49 53 0394*  			DB    C9H, "LIST"
       54          
040401 86 4C 49 4E 0395*  			DB    86H, "LINE"
       45          
040406 C8 4C 4F 41 0396*  			DB    C8H, "LOAD"
       44          
04040B 92 4C 4F 4D 0397*  			DB    92H, "LOMEM", 0
       45 4D 00    
040412 EA 4C 4F 43 0398*  			DB    EAH, "LOCAL"
       41 4C       
040418 C0 4C 45 46 0399*  			DB    C0H, "LEFT$("
       54 24 28    
04041F A9 4C 45 4E 0400*  			DB    A9H, "LEN"
040423 E9 4C 45 54 0401*  			DB    E9H, "LET"
040427 AB 4C 4F 47 0402*  			DB    ABH, "LOG"
04042B AA 4C 4E    0403*  			DB    AAH, "LN"
04042E C1 4D 49 44 0404*  			DB    C1H, "MID$("
       24 28       
040434 EB 4D 4F 44 0405*  			DB    EBH, "MODE"
       45          
040439 83 4D 4F 44 0406*  			DB    83H, "MOD"
04043D EC 4D 4F 56 0407*  			DB    ECH, "MOVE"
       45          
040442 ED 4E 45 58 0408*  			DB    EDH, "NEXT"
       54          
040447 CA 4E 45 57 0409*  			DB    CAH, "NEW", 0
       00          
04044C AC 4E 4F 54 0410*  			DB    ACH, "NOT"
040450 CB 4F 4C 44 0411*  			DB    CBH, "OLD", 0
       00          
040455 EE 4F 4E    0412*  			DB    EEH, "ON"
040458 87 4F 46 46 0413*  			DB    87H, "OFF"
04045C 84 4F 52    0414*  			DB    84H, "OR"
04045F 8E 4F 50 45 0415*  			DB    8EH, "OPENIN"
       4E 49 4E    
040466 AE 4F 50 45 0416*  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
04046E AD 4F 50 45 0417*  			DB    ADH, "OPENUP"
       4E 55 50    
040475 FF 4F 53 43 0418*  			DB    FFH, "OSCLI"
       4C 49       
04047B F1 50 52 49 0419*  			DB    F1H, "PRINT"
       4E 54       
040481 90 50 41 47 0420*  			DB    90H, "PAGE", 0
       45 00       
040487 8F 50 54 52 0421*  			DB    8FH, "PTR", 0
       00          
04048C AF 50 49 00 0422*  			DB    AFH, "PI", 0
040490 F0 50 4C 4F 0423*  			DB    F0H, "PLOT"
       54          
040495 B0 50 4F 49 0424*  			DB    B0H, "POINT("
       4E 54 28    
04049C F2 50 52 4F 0425*  			DB    F2H, "PROC"
       43          
0404A1 B1 50 4F 53 0426*  			DB    B1H, "POS", 0
       00          
0404A6 CE 50 55 54 0427*  			DB    CEH, "PUT"
0404AA F8 52 45 54 0428*  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0404B2 F5 52 45 50 0429*  			DB    F5H, "REPEAT"
       45 41 54    
0404B9 F6 52 45 50 0430*  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0404C1 F3 52 45 41 0431*  			DB    F3H, "READ"
       44          
0404C6 F4 52 45 4D 0432*  			DB    F4H, "REM"
0404CA F9 52 55 4E 0433*  			DB    F9H, "RUN", 0
       00          
0404CF B2 52 41 44 0434*  			DB    B2H, "RAD"
0404D3 F7 52 45 53 0435*  			DB    F7H, "RESTORE"
       54 4F 52 45 
0404DB C2 52 49 47 0436*  			DB    C2H, "RIGHT$("
       48 54 24 28 
0404E3 B3 52 4E 44 0437*  			DB    B3H, "RND", 0
       00          
0404E8 CC 52 45 4E 0438*  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0404F1 88 53 54 45 0439*  			DB    88H, "STEP"
       50          
0404F6 CD 53 41 56 0440*  			DB    CDH, "SAVE"
       45          
0404FB B4 53 47 4E 0441*  			DB    B4H, "SGN"
0404FF B5 53 49 4E 0442*  			DB    B5H, "SIN"
040503 B6 53 51 52 0443*  			DB    B6H, "SQR"
040507 89 53 50 43 0444*  			DB    89H, "SPC"
04050B C3 53 54 52 0445*  			DB    C3H, "STR$"
       24          
040510 C4 53 54 52 0446*  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
040519 D4 53 4F 55 0447*  			DB    D4H, "SOUND"
       4E 44       
04051F FA 53 54 4F 0448*  			DB    FAH, "STOP", 0
       50 00       
040525 B7 54 41 4E 0449*  			DB    B7H, "TAN"
040529 8C 54 48 45 0450*  			DB    8CH, "THEN"
       4E          
04052E B8 54 4F    0451*  			DB    B8H, "TO"
040531 8A 54 41 42 0452*  			DB    8AH, "TAB("
       28          
040536 FC 54 52 41 0453*  			DB    FCH, "TRACE"
       43 45       
04053C 91 54 49 4D 0454*  			DB    91H, "TIME", 0
       45 00       
040542 B9 54 52 55 0455*  			DB    B9H, "TRUE", 0
       45 00       
040548 FD 55 4E 54 0456*  			DB    FDH, "UNTIL"
       49 4C       
04054E BA 55 53 52 0457*  			DB    BAH, "USR"
040552 EF 56 44 55 0458*  			DB    EFH, "VDU"
040556 BB 56 41 4C 0459*  			DB    BBH, "VAL"
04055A BC 56 50 4F 0460*  			DB    BCH, "VPOS", 0
       53 00       
040560 FE 57 49 44 0461*  			DB    FEH, "WIDTH"
       54 48       
040566 D3 48 49 4D 0462*  			DB    D3H, "HIMEM"
       45 4D       
04056C D2 4C 4F 4D 0463*  			DB    D2H, "LOMEM"
       45 4D       
040572 D0 50 41 47 0464*  			DB    D0H, "PAGE"
       45          
040577 CF 50 54 52 0465*  			DB    CFH, "PTR"
04057B D1 54 49 4D 0466*  			DB    D1H, "TIME"
       45          
040580             0467*  ;
040580             0468*  ; These are indexed from the ERRWDS table
040580             0469*  ;
040580 01 4D 69 73 0470*  			DB    01H, "Missing "
       73 69 6E 67 
       20          
040589 02 4E 6F 20 0471*  			DB    02H, "No such "
       73 75 63 68 
       20          
040592 03 42 61 64 0472*  			DB    03H, "Bad "
       20          
040597 04 20 72 61 0473*  			DB    04H, " range"
       6E 67 65    
04059E 05 76 61 72 0474*  			DB    05H, "variable"
       69 61 62 6C 
       65          
0405A7 06 4F 75 74 0475*  			DB    06H, "Out of"
       20 6F 66    
0405AE 07 4E 6F 20 0476*  			DB    07H, "No "
0405B2 08 20 73 70 0477*  			DB    08H, " space"
       61 63 65    
0405B9             0478*  
0405B9             0479*  KEYWDL:			EQU     $-KEYWDS
0405B9 FF FF       0480*  			DW    -1
0405BB             0481*  ;
0405BB             0482*  ; Error messages
0405BB             0483*  ;
0405BB 07 72 6F 6F 0484*  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0405C1 06 04 00    0485*  			DB    6, 4, 0			;  1: Out of range
0405C4 00          0486*  			DB    0				;  2: *
0405C5 00          0487*  			DB    0				;  3: *
0405C6 4D 69 73 74 0488*  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0405CE 01 2C 00    0489*  			DB    1, ",", 0			;  5: Missing ,
0405D1 54 79 70 65 0490*  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0405DF 07 A4 00    0491*  			DB    7, FN, 0			;  7: No FN
0405E2 00          0492*  			DB    0				;  8: *
0405E3 01 22 00    0493*  			DB    1, 34, 0			;  9: Missing "
0405E6 03 DE 00    0494*  			DB    3, DIM, 0			; 10: Bad DIM
0405E9 DE 08 00    0495*  			DB    DIM, 8, 0			; 11: DIM space
0405EC 4E 6F 74 20 0496*  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0405F2 07 F2 00    0497*  			DB    7, PROC, 0		; 13: No PROC
0405F5 41 72 72 61 0498*  			DB    "Array", 0		; 14: Array
       79 00       
0405FB 53 75 62 73 0499*  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
040605 53 79 6E 74 0500*  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
040612 45 73 63 61 0501*  			DB    "Escape", 0		; 17: Escape
       70 65 00    
040619 44 69 76 69 0502*  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
04062A 53 74 72 69 0503*  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
04063A 54 6F 6F 20 0504*  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
040642 2D 76 65 20 0505*  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
04064B 4C 6F 67 04 0506*  			DB    "Log", 4, 0		; 22: Log range
       00          
040650 41 63 63 75 0507*  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
04065E 45 78 70 04 0508*  			DB    "Exp", 4, 0		; 24: Exp range
       00          
040663 00          0509*  			DB    0				; 25: *
040664 02 05 00    0510*  			DB    2, 5, 0			; 26: No such variable
040667 01 29 00    0511*  			DB    1, ")", 0			; 27: Missing )
04066A 03 48 45 58 0512*  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
04066F 02 A4 2F F2 0513*  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
040674 03 63 61 6C 0514*  			DB    3, "call", 0		; 30: Bad call
       6C 00       
04067A 41 72 67 75 0515*  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
040684 07 E3 00    0516*  			DB    7, FOR, 0			; 32: No FOR
040687 43 61 6E 27 0517*  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
040695 E3 20 05 00 0518*  			DB    FOR, " ", 5, 0		; 34: FOR variable
040699 00          0519*  			DB    0				; 35: *
04069A 07 B8 00    0520*  			DB    7, TO, 0			; 36: No TO
04069D 00          0521*  			DB    0				; 37: *
04069E 07 E4 00    0522*  			DB    7, GOSUB, 0		; 38: No GOSUB
0406A1 EE 20 73 79 0523*  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
0406AA EE 04 00    0524*  			DB    ON_, 4, 0			; 40: ON range
0406AD 02 6C 69 6E 0525*  			DB    2, "line", 0		; 41: No such line
       65 00       
0406B3 06 20 DC 00 0526*  			DB    6, " ", DATA_, 0		; 42: Out of DATA
0406B7 07 F5 00    0527*  			DB    7, REPEAT, 0		; 43: No REPEAT
0406BA 00          0528*  			DB    0				; 44: *
0406BB 01 23 00    0529*  			DB    1, "#", 0			; 45: Missing #
0406BE             0530*  ;
0406BE             0531*  ; COMMANDS:
0406BE             0532*  ;
0406BE             0533*  ; DELETE line,line
0406BE             0534*  ;
0406BE CD BD 09 04 0535*  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0406C2 CD C5 0D 04 0536*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0406C6 7E          0537*  DELET1:			LD      A,(HL)			; Check whether it's the last line
0406C7 B7          0538*  			OR      A
0406C8 CA 4F 07 04 0539*  			JP      Z,WARMNC		; Yes, so do nothing
0406CC 23          0540*  			INC     HL			; Skip the line length byte
0406CD 11 00 00 00 0541*  			LD	DE, 0			; Clear DE
0406D1 5E          0542*  			LD      E,(HL)			; Fetch the line number in DE
0406D2 23          0543*  			INC     HL
0406D3 56          0544*  			LD      D,(HL)
0406D4 7A          0545*  			LD      A,D			; If the line number is zero then
0406D5 B3          0546*  			OR      E
0406D6 28 1D       0547*  			JR      Z,CLOOP1        	; Do nothing
0406D8 2B          0548*  			DEC     HL			; Decrement BASIC program pointer back to length
0406D9 2B          0549*  			DEC     HL
0406DA EB          0550*  			EX      DE,HL			; Check if we've gone past the terminating line
0406DB 37          0551*  			SCF
0406DC ED 42       0552*  			SBC     HL,BC
0406DE EB          0553*  			EX      DE,HL
0406DF 30 6E       0554*  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0406E1 C5          0555*  			PUSH    BC
0406E2 CD 74 09 04 0556*  			CALL    DEL			; Delete the line pointed to by HL
0406E6 C1          0557*  			POP     BC
0406E7 18 DD       0558*  			JR      DELET1			; And loop round to the next line
0406E9             0559*  ;
0406E9             0560*  ; LISTO expr
0406E9             0561*  ;
0406E9 FD 23       0562*  LISTO:			INC     IY              	; Skip "O" byte
0406EB CD 0E 11 04 0563*  			CALL    EXPRI			; Get expr
0406EF D9          0564*  			EXX
0406F0 7D          0565*  			LD      A,L
0406F1 32 40 4D 04 0566*  			LD      (LISTON),A		; Store in LISTON sysvar
0406F5 C3 F2 01 04 0567*  CLOOP1:			JP      CLOOP
0406F9             0568*  ;
0406F9             0569*  ; LIST
0406F9             0570*  ; LIST line
0406F9             0571*  ; LIST line,line [IF string]
0406F9             0572*  ; LIST ,line
0406F9             0573*  ; LIST line,
0406F9             0574*  ;
0406F9 FE 4F       0575*  LIST_:			CP      'O'			; Check for O (LISTO)
0406FB 28 EC       0576*  			JR      Z,LISTO			; and jump to LISTO if zero
0406FD CD C5 0D 04 0577*  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
040701 CD 77 18 04 0578*  			CALL    NXT			; Skip space
040705 FE E7       0579*  			CP      TIF             	; Check for IF clause (token IF)
040707 3E 00       0580*  			LD      A,0             	; Initialise the IF clause string length
040709 20 17       0581*  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
04070B             0582*  ;
04070B FD 23       0583*  			INC     IY              	; Skip the IF token
04070D CD 77 18 04 0584*  			CALL    NXT             	; And skip any spaces
040711 EB          0585*  			EX      DE,HL			; DE: Address in memory
040712 FD E5       0586*  			PUSH    IY			; LD IY, HL
040714 E1          0587*  			POP     HL              	; HL is now the address of the tokenised line
040715 3E 0D       0588*  			LD      A,CR
040717 C5          0589*  			PUSH    BC			; Stack the second line number arg
040718 01 00 01 00 0590*  			LD      BC,256
04071C ED B1       0591*  			CPIR                    	; Locate CR byte
04071E 79          0592*  			LD      A,C
04071F 2F          0593*  			CPL                    	 	; A: Substring length (of IF clause)
040720 C1          0594*  			POP     BC			; Restore the second line number arg
040721 EB          0595*  			EX      DE,HL			; HL: Address in memory
040722             0596*  ;
040722 5F          0597*  LISTB:			LD      E,A             	; E: IF clause string length
040723 78          0598*  			LD      A,B			; Check whether a second line number was passed (BC!=0)
040724 B1          0599*  			OR      C
040725 20 01       0600*  			JR      NZ,LISTA		; If there isn't a second line number
040727 0B          0601*  			DEC     BC			; then we set it to the maximum of 65535
040728             0602*  ;
040728 D9          0603*  LISTA:			EXX
040729 DD 21 40 4D 0604*  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
04072E 01 00 00 00 0605*  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
040732 D9          0606*  			EXX
040733 3E 14       0607*  			LD      A,20			; Number of lines to list
040735             0608*  ;
040735 C5          0609*  LISTC:			PUSH    BC              	; Save second line number
040736 D5          0610*  			PUSH    DE              	; Save IF clause length
040737 E5          0611*  			PUSH    HL              	; Save BASIC program counter
040738 08          0612*  			EX      AF,AF'
040739             0613*  ;
040739             0614*  ; BBC BASIC for Z80 lines are stored as follows:
040739             0615*  ;
040739             0616*  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
040739             0617*  ; - [&00] [&FF] [&FF]: End of program marker
040739             0618*  ;
040739             0619*  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
040739             0620*  ;
040739 7E          0621*  			LD      A,(HL)			; Check for end of program marker
04073A B7          0622*  			OR      A			; If found
04073B 28 12       0623*  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
04073D             0624*  ;
04073D             0625*  ; Check if past terminating line number
04073D             0626*  ;
04073D 7B          0627*  			LD      A,E             	; A: IF clause length
04073E 23          0628*  			INC     HL			; Skip the length byte
04073F 11 00 00 00 0629*  			LD	DE,0			; Clear DE
040743 5E          0630*  			LD      E,(HL)			; Fetch the line number in DE
040744 23          0631*  			INC     HL
040745 56          0632*  			LD      D,(HL)
040746 2B          0633*  			DEC     HL			; Step HL back to the length byte
040747 2B          0634*  			DEC     HL
040748 D5          0635*  			PUSH    DE             	 	; Push the line number on the stack
040749 EB          0636*  			EX      DE,HL			; HL: line number
04074A 37          0637*  			SCF				; Do a 16-bit compare of HL and DE
04074B ED 42       0638*  			SBC     HL,BC
04074D EB          0639*  			EX      DE,HL
04074E D1          0640*  			POP     DE              	; Restore the line number
04074F D2 F1 01 04 0641*  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
040753 4E          0642*  			LD      C,(HL)          	; C: Line length + 4
040754 47          0643*  			LD      B,A             	; B: IF clause length
040755             0644*  ;
040755             0645*  ; Check if "UNLISTABLE":
040755             0646*  ;
040755 7A          0647*  			LD      A,D			; TODO: What is "UNLISTABLE?"
040756 B3          0648*  			OR      E
040757 CA F2 01 04 0649*  			JP      Z,CLOOP
04075B             0650*  ;
04075B             0651*  ; Check for IF clause:
04075B             0652*  ;
04075B 23          0653*  			INC     HL			; Skip the length
04075C 23          0654*  			INC     HL			; Skip the line number
04075D 23          0655*  			INC     HL              	; HL: Address of the tokenised BASIC line
04075E 0D          0656*  			DEC     C			;  C: Line length
04075F 0D          0657*  			DEC     C
040760 0D          0658*  			DEC     C
040761 0D          0659*  			DEC     C
040762 D5          0660*  			PUSH    DE              	; Save the line number
040763 E5          0661*  			PUSH    HL              	; Save the BASIC program address
040764 AF          0662*  			XOR     A               	;
040765 B8          0663*  			CP      B              	 	; Check for an IF clause (B!=0)
040766 FD E5       0664*  			PUSH    IY			; LD IY, DE
040768 D1          0665*  			POP     DE              	; DE: Address of the IF clause string in the input buffer
040769 C4 89 15 04 0666*  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
04076D E1          0667*  			POP     HL              	; Restore BASIC program address
04076E D1          0668*  			POP     DE              	; Restore line number
04076F FD E5       0669*  			PUSH    IY
040771 CC 04 0A 04 0670*  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
040775 FD E1       0671*  			POP     IY
040777             0672*  ;
040777 08          0673*  			EX      AF,AF'
040778 3D          0674*  			DEC     A			; Decrement line list counter
040779 CD 4B 45 04 0675*  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
04077D E1          0676*  			POP     HL             	 	; Restore BASIC program address to beginning of line
04077E 11 00 00 00 0677*  			LD	DE,0
040782 5E          0678*  			LD      E,(HL)			; Fetch the length of line in DE
040783 19          0679*  			ADD     HL,DE           	; Go to the next line
040784 D1          0680*  			POP     DE              	; Restore IF clause length
040785 C1          0681*  			POP     BC              	; Restore second line number
040786 18 AD       0682*  			JR      LISTC			; Loop back to do next line
040788             0683*  ;
040788             0684*  ; RENUMBER
040788             0685*  ; RENUMBER start
040788             0686*  ; RENUMBER start,increment
040788             0687*  ; RENUMBER ,increment
040788             0688*  ;
040788 CD E8 09 04 0689*  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
04078C CD 9D 0D 04 0690*  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
040790 D9          0691*  			EXX
040791 2A 14 4D 04 0692*  			LD      HL,(PAGE_)		; HL: Top of program
040795 ED 5B 1A 4D 0693*  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
04079A             0694*  ;
04079A             0695*  ; Build the table
04079A             0696*  ;
04079A 7E          0697*  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
04079B B7          0698*  			OR      A			; Is it zero, i.e. the end of program marker?
04079C 28 36       0699*  			JR      Z,RENUM2		; Yes, so skip to the next part
04079E 23          0700*  			INC     HL
04079F 4E          0701*  			LD      C,(HL)          	; BC: The OLD line number
0407A0 23          0702*  			INC     HL
0407A1 46          0703*  			LD      B,(HL)
0407A2 78          0704*  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
0407A3 B1          0705*  			OR      C
0407A4 CA F2 01 04 0706*  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
0407A8 EB          0707*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0407A9 71          0708*  			LD      (HL),C			; Store the OLD line number in the heap
0407AA 23          0709*  			INC     HL
0407AB 70          0710*  			LD      (HL),B
0407AC 23          0711*  			INC     HL
0407AD D9          0712*  			EXX				; HL: line number, BC: increment (16-bit values)
0407AE E5          0713*  			PUSH    HL			; HL: Stack the NEW line number value
0407AF 52 09       0714*  			ADD.S   HL,BC           	; Add the increment
0407B1 DA 97 0D 04 0715*  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0407B5 D9          0716*  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0407B6 C1          0717*  			POP     BC			; BC: Pop the NEW line number value off the stack
0407B7 71          0718*  			LD      (HL),C			; Store the NEW line number in the heap
0407B8 23          0719*  			INC     HL
0407B9 70          0720*  			LD      (HL),B
0407BA 23          0721*  			INC     HL
0407BB EB          0722*  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0407BC 2B          0723*  			DEC     HL			; Back up to the line length byte
0407BD 2B          0724*  			DEC     HL
0407BE 01 00 00 00 0725*  			LD	BC, 0
0407C2 4E          0726*  			LD      C,(HL)			; BC: Line length
0407C3 09          0727*  			ADD	HL,BC           	; Advance HL to next line
0407C4 EB          0728*  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0407C5 E5          0729*  			PUSH    HL
0407C6 24          0730*  			INC     H			; Increment to next page
0407C7 ED 72       0731*  			SBC     HL,SP			; Subtract from SP
0407C9 E1          0732*  			POP     HL
0407CA EB          0733*  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0407CB 38 CD       0734*  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0407CD CD E9 08 04 0735*  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0407D1 CC          0736*  			DB    	REN
0407D2 08          0737*  			DB    	8
0407D3 00          0738*  			DB    	0
0407D4             0739*  ;
0407D4             0740*  ; At this point a list of BASIC line numbers have been written to the heap
0407D4             0741*  ; as word pairs:
0407D4             0742*  ; - DW: The OLD line number
0407D4             0743*  ; - DW: The NEW line number
0407D4             0744*  ;
0407D4 EB          0745*  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0407D5 36 FF       0746*  			LD      (HL),-1			; Mark the end with FFFFh
0407D7 23          0747*  			INC     HL
0407D8 36 FF       0748*  			LD      (HL),-1
0407DA ED 5B 1A 4D 0749*  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
0407DF D9          0750*  			EXX
0407E0 2A 14 4D 04 0751*  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0407E4 4E          0752*  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0407E5 79          0753*  			LD      A,C			; If it is zero, then no program, so...
0407E6 B7          0754*  			OR      A
0407E7 CA F1 01 04 0755*  			JP      Z,WARM			; Jump to warm start
0407EB D9          0756*  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0407EC EB          0757*  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0407ED 23          0758*  			INC     HL			; Skip to the NEW line number
0407EE 23          0759*  			INC     HL
0407EF 5E          0760*  			LD      E,(HL)			; DE: The NEW line number
0407F0 23          0761*  			INC     HL
0407F1 56          0762*  			LD      D,(HL)
0407F2 23          0763*  			INC     HL
0407F3 D5          0764*  			PUSH    DE			; Stack the NEW line number
0407F4 EB          0765*  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0407F5 22 23 4D 04 0766*  			LD      (LINENO),HL		; Store the line number in LINENO
0407F9 D9          0767*  			EXX				; HL: Pointer to the BASIC program area
0407FA D1          0768*  			POP     DE			; DE: The NEW line number
0407FB 23          0769*  			INC     HL
0407FC 73          0770*  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0407FD 23          0771*  			INC     HL
0407FE 72          0772*  			LD      (HL),D
0407FF 23          0773*  			INC     HL
040800 0D          0774*  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
040801 0D          0775*  			DEC     C
040802 0D          0776*  			DEC     C
040803 79          0777*  			LD	A,C
040804 01 00 00 00 0778*  			LD	BC,0
040808 4F          0779*  			LD	C,A			; BC: Line length
040809             0780*  ;
040809 3E 8D       0781*  RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
04080B ED B1       0782*  			CPIR                    	; Search for the token
04080D 20 D5       0783*  			JR      NZ,RENUM3		; If not found, then loop to process the next line
04080F             0784*  ;
04080F             0785*  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
04080F             0786*  ;
04080F C5          0787*  			PUSH    BC			; Stack everything
040810 E5          0788*  			PUSH    HL
040811 E5          0789*  			PUSH    HL			; HL: Pointer to encoded line number
040812 FD E1       0790*  			POP     IY			; IY: Pointer to encoded line number
040814 D9          0791*  			EXX
040815 CD EA 16 04 0792*  			CALL    DECODE			; Decode the encoded line number (in HL')
040819 D9          0793*  			EXX				; HL: Decoded line number
04081A 44          0794*  			LD      B,H			; BC: Decoded line number
04081B 4D          0795*  			LD      C,L
04081C 2A 1A 4D 04 0796*  			LD      HL,(LOMEM)		; HL: Pointer to heap
040820             0797*  ;
040820             0798*  ; This section of code cross-references the decoded (OLD) line number with the list
040820             0799*  ; created previously in the global heap
040820             0800*  ;
040820 5E          0801*  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
040821 23          0802*  			INC     HL
040822 56          0803*  			LD      D,(HL)
040823 23          0804*  			INC     HL
040824 EB          0805*  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
040825 B7          0806*  			OR      A               	; Clear the carry and...
040826 52 ED 42    0807*  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
040829 EB          0808*  			EX      DE,HL			; HL: Pointer in the global heap
04082A 5E          0809*  			LD      E,(HL)          	; DE: The NEW line number
04082B 23          0810*  			INC     HL
04082C 56          0811*  			LD      D,(HL)
04082D 23          0812*  			INC     HL
04082E 38 F0       0813*  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
040830 EB          0814*  			EX      DE,HL			; DE: Pointer in the global heap
040831 28 1D       0815*  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
040833             0816*  ;
040833 CD 02 0F 04 0817*  			CALL    TELL			; Display this error if the line number is not found
040837 46 61 69 6C 0818*  			DB    	"Failed at "
       65 64 20 61 
       74 20       
040841 00          0819*  			DB    	0
040842 2A 23 4D 04 0820*  			LD      HL,(LINENO)
040846 CD 69 0B 04 0821*  			CALL    PBCDL
04084A CD B9 0A 04 0822*  			CALL    CRLF
04084E 18 07       0823*  			JR      RENUM6			; And carry on renumbering
040850             0824*  ;
040850             0825*  ; This snippet re-encodes the line number in the BASIC program
040850             0826*  ;
040850 D1          0827*  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
040851 D5          0828*  			PUSH    DE
040852 1B          0829*  			DEC     DE			; Back up a byte to the LINO token
040853 CD CE 0E 04 0830*  			CALL    ENCODE          	; Re-write the new line number out
040857 E1          0831*  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
040858 C1          0832*  			POP     BC			; BC: The remaining line length
040859 18 AE       0833*  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
04085B             0834*  ;
04085B             0835*  ; AUTO
04085B             0836*  ; AUTO start,increment
04085B             0837*  ; AUTO start
04085B             0838*  ; AUTO ,increment
04085B             0839*  ;
04085B CD 9D 0D 04 0840*  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
04085F 22 29 4D 04 0841*  			LD      (AUTONO),HL		; Store the start in AUTONO
040863 79          0842*  			LD      A,C			; Increment is 8 bit (0-255)
040864 32 41 4D 04 0843*  			LD      (INCREM),A		; Store that in INCREM
040868 18 2E       0844*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04086A             0845*  ;
04086A             0846*  ; BAD
04086A             0847*  ; NEW
04086A             0848*  ;
04086A CD 02 0F 04 0849*  BAD:			CALL    TELL            	; Output "Bad program" error
04086E 03          0850*  			DB    3				; Token for "BAD"
04086F 70 72 6F 67 0851*  			DB    "program"
       72 61 6D    
040876 0D          0852*  			DB    CR
040877 0A          0853*  			DB    LF
040878 00          0854*  			DB    0				; Falls through to NEW
040879             0855*  ;
040879 CD DE 09 04 0856*  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
04087D 18 19       0857*  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04087F             0858*  ;
04087F             0859*  ; OLD
04087F             0860*  ;
04087F 2A 14 4D 04 0861*  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
040883 E5          0862*  			PUSH    HL			; Stack it
040884 23          0863*  			INC     HL			; Skip the potential length byte of first line of code
040885 23          0864*  			INC     HL			; And the line number word
040886 23          0865*  			INC     HL
040887 01 FC 00 00 0866*  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
04088B 3E 0D       0867*  			LD      A,CR
04088D ED B1       0868*  			CPIR
04088F 20 D9       0869*  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
040891 7D          0870*  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
040892 E1          0871*  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
040893 77          0872*  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
040894 CD B1 09 04 0873*  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
040898 C3 F2 01 04 0874*  CLOOP0:			JP      CLOOP			; Jump back to the command loop
04089C             0875*  ;
04089C             0876*  ; LOAD filename
04089C             0877*  ;
04089C CD 19 11 04 0878*  LOAD:			CALL    EXPRS           	; Get the filename
0408A0 3E 0D       0879*  			LD      A,CR			; DE points to the last byte of filename in ACCS
0408A2 12          0880*  			LD      (DE),A			; Terminate filename with a CR
0408A3 CD 91 09 04 0881*  			CALL    LOAD0			; Load the file in, then CLEAN
0408A7 CD E8 09 04 0882*  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0408AB 18 21       0883*  			JR      WARM0			; Jump back to the command loop
0408AD             0884*  ;
0408AD             0885*  ; SAVE filename
0408AD             0886*  ;
0408AD CD BD 09 04 0887*  SAVE:			CALL    SETTOP          	; Set TOP sysvar
0408B1 CD 19 11 04 0888*  			CALL    EXPRS           	; Get the filename
0408B5 3E 0D       0889*  			LD      A,CR			; Terminate the filename with a CR
0408B7 12          0890*  			LD      (DE),A
0408B8 ED 5B 14 4D 0891*  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
0408BD 2A 17 4D 04 0892*  			LD      HL,(TOP)		; HL: Top of program memory
0408C1 B7          0893*  			OR      A			; Calculate program size (TOP-PAGE)
0408C2 ED 52       0894*  			SBC     HL,DE
0408C4 44          0895*  			LD      B,H             	; BC: Length of program in bytes
0408C5 4D          0896*  			LD      C,L
0408C6 21 00 4A 04 0897*  			LD      HL,ACCS			; HL: Address of the filename
0408CA CD 18 48 04 0898*  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0408CE C3 F1 01 04 0899*  WARM0:			JP      WARM			; Jump back to the command loop
0408D2             0900*  
0408D2             0901*  ;
0408D2             0902*  ; ERROR
0408D2             0903*  ; Called whenever BASIC needs to halt with an error
0408D2             0904*  ; Error messages are indexed from 0
0408D2             0905*  ; Inputs:
0408D2             0906*  ;  A: Error number
0408D2             0907*  ;
0408D2 ED 7B 20 4D 0908*  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0408D7 21 BB 05 04 0909*  			LD      HL,ERRWDS		; Index into the error string table
0408DB B7          0910*  			OR      A			; We don't need to search for the first error
0408DC 28 0A       0911*  			JR      Z,ERROR1		; So skip the search routine
0408DE             0912*  ;
0408DE             0913*  ; Search the error table for error #A
0408DE             0914*  ; HL will end up being the pointer into the correct error
0408DE             0915*  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0408DE             0916*  ;
0408DE 47          0917*  			LD      B,A             	; Store error number in B
0408DF 08          0918*  			EX      AF,AF'			; Store error number in AF'
0408E0 AF          0919*  			XOR     A
0408E1 BE          0920*  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0408E2 23          0921*  			INC     HL			; Increment the string pointer
0408E3 20 FC       0922*  			JR      NZ,ERROR0		; Loop until with hit a 0
0408E5 10 FA       0923*  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0408E7 08          0924*  			EX      AF,AF'			; Restore the error number from AF'
0408E8             0925*  ;
0408E8             0926*  ; At this point HL points to the tokenised error string
0408E8             0927*  ;
0408E8 E5          0928*  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0408E9             0929*  
0408E9             0930*  ;
0408E9             0931*  ; EXTERR
0408E9             0932*  ; Inputs:
0408E9             0933*  ;  A: Error number
0408E9             0934*  ;
0408E9             0935*  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0408E9             0936*  ; The error text immediately follows the CALL to EXTERR, for example:
0408E9             0937*  ; > CALL  EXTERR
0408E9             0938*  ; > DB    "Silly", 0
0408E9             0939*  ; So we can get the address of the string by popping the return address off the stack
0408E9             0940*  ;
0408E9 E1          0941*  EXTERR:			POP     HL			; Pop the error string pointer
0408EA 22 2F 4D 04 0942*  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0408EE ED 7B 20 4D 0943*  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
0408F3 32 3F 4D 04 0944*  			LD      (ERR),A			; Store error number in ERR sysvar
0408F7 CD 20 0B 04 0945*  			CALL    SETLIN			; Get line number
0408FB 22 33 4D 04 0946*  			LD      (ERL),HL		; Store in ERL sysvar
0408FF B7          0947*  			OR      A			; Is error number 0?
040900 28 0D       0948*  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
040902             0949*  ;
040902 2A 2C 4D 04 0950*  			LD      HL,(ERRTRP)		; Check whether the error is trapped
040906 7C          0951*  			LD      A,H
040907 B5          0952*  			OR      L
040908 E5          0953*  			PUSH    HL			; HL: Error line
040909 FD E1       0954*  			POP     IY			; IY: HL
04090B C2 9D 19 04 0955*  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
04090F             0956*  ;
04090F 21 00 00 00 0957*  ERROR2:			LD      HL,0
040913 22 29 4D 04 0958*  			LD      (AUTONO),HL		; Cancel AUTO
040917 22 26 4D 04 0959*  			LD      (TRACEN),HL     	; Cancel TRACE
04091B CD A1 49 04 0960*  			CALL    RESET           	; Reset OPSYS
04091F CD B9 0A 04 0961*  			CALL    CRLF			; Output newline
040923 CD F4 0E 04 0962*  			CALL    REPORT          	; Output the error message
040927 CD 54 0B 04 0963*  			CALL    SAYLN			; Output " at line nnnn" message.
04092B 1E 00       0964*  			LD      E,0			; Close all files
04092D DC 16 49 04 0965*  			CALL    C,OSSHUT
040931 CD B9 0A 04 0966*  			CALL    CRLF			; Output newline
040935 C3 F2 01 04 0967*  			JP      CLOOP			; Back to CLOOP
040939             0968*  ;
040939             0969*  ; SUBROUTINES:
040939             0970*  ;
040939             0971*  ; LEX - SEARCH FOR KEYWORDS
040939             0972*  ;   Inputs: HL = start of keyword table
040939             0973*  ;           IY = start of match text
040939             0974*  ;  Outputs: If found, Z-flag set, A=token.
040939             0975*  ;           If not found, Z-flag reset, A=(IY).
040939             0976*  ;           IY updated (if NZ, IY unchanged).
040939             0977*  ; Destroys: A,B,H,L,IY,F
040939             0978*  ;
040939 21 DA 02 04 0979*  LEX:			LD      HL,KEYWDS		; Address of the keywords table
04093D             0980*  ;
04093D FD 7E 00    0981*  LEX0:			LD      A,(IY)			; Fetch the character to match
040940 46          0982*  			LD      B,(HL)			; B: The token from the keywords table
040941 23          0983*  			INC     HL			; Increment the pointer in the keywords table
040942 BE          0984*  			CP      (HL)			; Compare the first characters
040943 28 08       0985*  			JR      Z,LEX2			; If there is a match, then skip to LEX2
040945 D8          0986*  			RET     C               	; No match, so fail
040946             0987*  ;
040946             0988*  ; This snippet of code skips to the next token in the KEYWDS table
040946             0989*  ;
040946 23          0990*  LEX1:			INC     HL			; Increment the pointer
040947 CB 7E       0991*  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
040949 28 FB       0992*  			JR      Z,LEX1			; No, so loop
04094B 18 F0       0993*  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
04094D             0994*  ;
04094D FD E5       0995*  LEX2:			PUSH    IY              	; Save the input pointer
04094F 23          0996*  LEX3:			INC     HL			; Increment the keyword pointer
040950 CB 7E       0997*  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
040952 20 1C       0998*  			JR      NZ,LEX6         	; Jump to here as we've found a token
040954 FD 23       0999*  			INC     IY			; Increment the text pointer
040956 FD 7E 00    1000*  			LD      A,(IY)			; Fetch the character
040959 FE 2E       1001*  			CP      '.'			; Is it an abbreviated keyword?
04095B 28 13       1002*  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
04095D BE          1003*  			CP      (HL)			; Compare with the keywords list
04095E 28 EF       1004*  			JR      Z,LEX3			; It's a match, so continue checking this keyword
040960 CD ED 0D 04 1005*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
040964 38 04       1006*  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
040966             1007*  ;
040966 FD E1       1008*  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
040968 18 DC       1009*  			JR      LEX1			; And loop back to start again
04096A             1010*  ;
04096A             1011*  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
04096A             1012*  ; immediately delimited
04096A             1013*  ;
04096A 7E          1014*  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
04096B B7          1015*  			OR      A			; If it is not zero, then...
04096C 20 F8       1016*  			JR      NZ,LEX4			; Keep searching
04096E FD 2B       1017*  			DEC     IY			; If it is zero, then skip the input pointer back one byte
040970             1018*  ;
040970             1019*  ; We've found a token at this point
040970             1020*  ;
040970 F1          1021*  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
040971 AF          1022*  			XOR     A			; Set the Z flag
040972 78          1023*  			LD      A,B			; A: The token
040973 C9          1024*  			RET
040974             1025*  ;
040974             1026*  ; DEL - DELETE A PROGRAM LINE.
040974             1027*  ;   Inputs: HL addresses program line.
040974             1028*  ; Destroys: B,C,F
040974             1029*  ;
040974             1030*  ; This simply erases the line by moving all of the code after the line to be deleted back over
040974             1031*  ; it using an LDIR
040974             1032*  ;
040974 D5          1033*  DEL:			PUSH    DE
040975 E5          1034*  			PUSH    HL
040976 E5          1035*  			PUSH    HL			; HL: Address of the program line
040977 06 00       1036*  			LD      B,0			; BC: Length of the line
040979 4E          1037*  			LD      C,(HL)
04097A 09          1038*  			ADD     HL,BC			; HL: Advanced to the start of the next line
04097B E5          1039*  			PUSH    HL
04097C EB          1040*  			EX      DE,HL			; DE: Pointer to the next line
04097D 2A 17 4D 04 1041*  			LD      HL,(TOP)		; HL: Pointer to the end of the program
040981 ED 52       1042*  			SBC     HL,DE
040983 44          1043*  			LD      B,H			; BC: Size of block to move
040984 4D          1044*  			LD      C,L
040985 E1          1045*  			POP     HL			; HL: Pointer to next line
040986 D1          1046*  			POP     DE			; DE: Pointer to this line
040987 ED B0       1047*  			LDIR                    	; Delete the line
040989 ED 53 17 4D 1048*  			LD      (TOP),DE		; Adjust TOP
       04          
04098E E1          1049*  			POP     HL
04098F D1          1050*  			POP     DE
040990 C9          1051*  			RET
040991             1052*  ;
040991             1053*  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
040991             1054*  ;   Inputs: Filename in ACCS (term CR)
040991             1055*  ; Destroys: A,B,C,D,E,H,L,F
040991             1056*  ;
040991             1057*  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
040991             1058*  ; AND WRITE FF FF, THEN LOAD (TOP).
040991             1059*  ; Destroys: A,B,C,H,L,F
040991             1060*  ;
040991 ED 5B 14 4D 1061*  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
040996 21 00 FF FF 1062*  			LD      HL,-256
04099A 39          1063*  			ADD     HL,SP
04099B ED 52       1064*  			SBC     HL,DE           	; Find available space
04099D 44          1065*  			LD      B,H
04099E 4D          1066*  			LD      C,L
04099F 21 00 4A 04 1067*  			LD      HL,ACCS
0409A3 CD 7F 47 04 1068*  			CALL    OSLOAD          	; Call the OSLOAD function in patch
0409A7 D4 DE 09 04 1069*  			CALL    NC,NEWIT		; If NC then NEW
0409AB 3E 00       1070*  			LD      A,0
0409AD D2 D2 08 04 1071*  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0409B1             1072*  ;
0409B1 CD BD 09 04 1073*  CLEAN:			CALL    SETTOP			; Set TOP sysvar
0409B5 2B          1074*  			DEC     HL			; Write out the end of program markers
0409B6 36 FF       1075*  			LD      (HL),-1
0409B8 2B          1076*  			DEC     HL
0409B9 36 FF       1077*  			LD      (HL),-1
0409BB 18 2B       1078*  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0409BD             1079*  ;
0409BD             1080*  ; Set the TOP sysvar; the first free location after the end of the current program
0409BD             1081*  ; Returns:
0409BD             1082*  ; - HL: TOP
0409BD             1083*  ;
0409BD 2A 14 4D 04 1084*  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0409C1 01 00 00 00 1085*  			LD	BC, 0			; BC: 0
0409C5 3E 0D       1086*  			LD      A,CR			; End of line marker
0409C7 4E          1087*  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0409C8 0C          1088*  			INC     C			; Check for zero
0409C9 0D          1089*  			DEC     C
0409CA 28 0A       1090*  			JR      Z,SETOP2		; If it is zero, we've reached the end
0409CC 09          1091*  			ADD     HL,BC			; Skip to next line
0409CD 2B          1092*  			DEC     HL			; Check end of previous line
0409CE BE          1093*  			CP      (HL)
0409CF 23          1094*  			INC     HL
0409D0 28 F5       1095*  			JR      Z,SETOP1		; If CR then loop
0409D2 C3 6A 08 04 1096*  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0409D6             1097*  ;
0409D6 23          1098*  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0409D7 23          1099*  			INC     HL			; NB: Called from NEWIT
0409D8 23          1100*  			INC     HL
0409D9 22 17 4D 04 1101*  			LD      (TOP),HL		; Store in TOP sysvar
0409DD C9          1102*  			RET
0409DE             1103*  ;
0409DE             1104*  ; NEWIT - NEW PROGRAM THEN CLEAR
0409DE             1105*  ;   Destroys: H,L
0409DE             1106*  ;
0409DE             1107*  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0409DE             1108*  ; FUNCTION AND PROCEDURE POINTERS.
0409DE             1109*  ;   Destroys: Nothing
0409DE             1110*  ;
0409DE 2A 14 4D 04 1111*  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0409E2 36 00       1112*  			LD      (HL),0			; Stick a 0 in there
0409E4 CD D6 09 04 1113*  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0409E8             1114*  ;
0409E8 E5          1115*  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0409E9 2A 17 4D 04 1116*  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0409ED 22 1A 4D 04 1117*  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0409F1 22 1D 4D 04 1118*  			LD      (FREE),HL		; And the FREE sysvar with that value
0409F5 21 6C 4C 04 1119*  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0409F9 C5          1120*  			PUSH    BC
0409FA             1121*  			; LD      B,3*(54+2)		; Loop counter
0409FA 06 A8       1122*  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0409FC 36 00       1123*  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0409FE 23          1124*  			INC     HL
0409FF 10 FB       1125*  			DJNZ    CLEAR1
040A01 C1          1126*  			POP     BC
040A02 E1          1127*  			POP     HL			; Restore the BASIC program pointer
040A03 C9          1128*  			RET
040A04             1129*  ;
040A04             1130*  ;LISTIT - LIST A PROGRAM LINE.
040A04             1131*  ;    Inputs: HL addresses line
040A04             1132*  ;            DE = line number (binary)
040A04             1133*  ;            IX = Pointer to LISTON
040A04             1134*  ;             B = FOR/NEXT indent level
040A04             1135*  ;             C = REPEAT/UNTIL indent level
040A04             1136*  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
040A04             1137*  ;
040A04 E5          1138*  LISTIT:			PUSH    HL			; Stack the address of the line
040A05 EB          1139*  			EX      DE,HL			; HL: Line number
040A06 C5          1140*  			PUSH    BC
040A07 CD 6D 0B 04 1141*  			CALL    PBCD			; Print the line number
040A0B C1          1142*  			POP     BC
040A0C E1          1143*  			POP     HL			; HL: Address of the first token/character
040A0D 7E          1144*  			LD      A,(HL)			; Fetch the token
040A0E FE ED       1145*  			CP      NEXT			; Is it NEXT...
040A10 CC 9A 0A 04 1146*  			CALL    Z,INDENT		; Yes, so indent in
040A14 FE FD       1147*  			CP      UNTIL			; Or is it UNTIL...
040A16 CC 9A 0A 04 1148*  			CALL    Z,INDENT		; Yes, so indent in
040A1A D9          1149*  			EXX
040A1B 3E 20       1150*  			LD      A,' '
040A1D DD CB 00 46 1151*  			BIT     0,(IX)			; If BIT 0 of LISTON is set
040A21 C4 C1 0A 04 1152*  			CALL    NZ,OUTCHR		; Then print a space after the line number
040A25 78          1153*  			LD      A,B			; Fetch the FOR/NEXT indent level
040A26 87          1154*  			ADD     A,A			; Multiply by 2
040A27 DD CB 00 4E 1155*  			BIT     1,(IX)			; If BIT 1 of LISTON is set
040A2B C4 20 26 04 1156*  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
040A2F 79          1157*  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
040A30 87          1158*  			ADD     A,A			; Multiply by 2
040A31 DD CB 00 56 1159*  			BIT     2,(IX)			; If BIT 2 of LISTON is set
040A35 C4 20 26 04 1160*  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
040A39 D9          1161*  			EXX
040A3A 7E          1162*  			LD      A,(HL)			; Fetch the token
040A3B FE E3       1163*  			CP      FOR			; Is it FOR?
040A3D CC 9A 0A 04 1164*  			CALL    Z,INDENT		; Yes, so indent
040A41 FE F5       1165*  			CP      REPEAT			; Is it REPEAT?
040A43 CC 9A 0A 04 1166*  			CALL    Z,INDENT		; Yes, so indent
040A47 1E 00       1167*  			LD      E,0			; E: The quote counter - reset to 0
040A49 7E          1168*  LIST8:			LD      A,(HL)			; Fetch a character / token byte
040A4A 23          1169*  			INC     HL
040A4B FE 0D       1170*  			CP      CR			; Is it end of line?
040A4D 28 0B       1171*  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
040A4F FE 22       1172*  			CP      34			; Is it a quote character?
040A51 20 01       1173*  			JR      NZ,LIST7		; No, so skip to next bit
040A53 1C          1174*  			INC     E			; Otherwise increment quote counter
040A54 CD 89 0A 04 1175*  LIST7:			CALL    LOUT			; Output the character / token
040A58 18 EF       1176*  			JR      LIST8			; And repeat
040A5A             1177*  ;
040A5A             1178*  ; DB: Modification for *EDIT
040A5A             1179*  ; Terminate the line with either a CRLF or a NUL character
040A5A             1180*  ;
040A5A DD CB 00 5E 1181*  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
040A5E 28 59       1182*  			JR	Z, CRLF			; Yes, so print a CRLF
040A60 AF          1183*  			XOR	A			; Otherwise print a NUL (0)
040A61 C3 DA 44 04 1184*  			JP	OSWRCH
040A65             1185*  ;
040A65             1186*  ; Decode the 3 byte GOTO type line number
040A65             1187*  ;
040A65 E5          1188*  PRLINO:			PUSH    HL			; Swap HL and IY
040A66 FD E1       1189*  			POP     IY			; IY: Pointer to the line number
040A68 C5          1190*  			PUSH    BC
040A69 CD EA 16 04 1191*  			CALL    DECODE			; Decode
040A6D C1          1192*  			POP     BC
040A6E D9          1193*  			EXX
040A6F C5          1194*  			PUSH    BC
040A70 CD 69 0B 04 1195*  			CALL    PBCDL			; Output the line number
040A74 C1          1196*  			POP     BC
040A75 D9          1197*  			EXX
040A76 FD E5       1198*  			PUSH    IY			; Swap HL and IY
040A78 E1          1199*  			POP     HL			; HL: Pointer to the next character in the line
040A79 C9          1200*  			RET
040A7A             1201*  ;
040A7A             1202*  ; DB: Modification for internationalisation
040A7A             1203*  ;
040A7A CD DE 0A 04 1204*  PRREM:			CALL	OUT_			; Output the REM token
040A7E 7E          1205*  @@:			LD	A, (HL)			; Fetch the character
040A7F FE 0D       1206*  			CP	CR			; If it is end of line, then
040A81 C8          1207*  			RET	Z			; we have finished
040A82 CD C1 0A 04 1208*  			CALL	OUTCHR			; Ouput the character
040A86 23          1209*  			INC	HL
040A87 18 F5       1210*  			JR	@B			; And loop
040A89             1211*  ;
040A89             1212*  ; DB: End of modification
040A89             1213*  ;
040A89 CB 43       1214*  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
040A8B 20 34       1215*  			JR      NZ,OUTCHR		; don't tokenise, just output the character
040A8D FE F4       1216*  			CP	REM			; DB: Is it REM
040A8F 28 E9       1217*  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
040A91 FE 8D       1218*  			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
040A93 28 D0       1219*  			JR      Z,PRLINO		; Yes, so decode and print the line number
040A95 CD DE 0A 04 1220*  			CALL    OUT_			; Output a character / keyword
040A99 7E          1221*  			LD      A,(HL)			; Fetch the next character
040A9A             1222*  ;
040A9A             1223*  ; This block of code handles the indentation
040A9A             1224*  ; B: Counter for FOR/NEXT indent
040A9A             1225*  ; C: Counter for REPEAT/UNTIL indent
040A9A             1226*  ;
040A9A D9          1227*  INDENT:			EXX
040A9B FE E3       1228*  			CP      FOR			; If the token is FOR
040A9D 28 09       1229*  			JR      Z,IND1			; Then INC B
040A9F FE ED       1230*  			CP      NEXT			; If it is NEXT
040AA1 20 06       1231*  			JR      NZ,IND2_		; Then...
040AA3 05          1232*  			DEC     B			; DEC B
040AA4 F2 A9 0A 04 1233*  			JP      P,IND2_			; If we have gone below 0 then
040AA8 04          1234*  IND1:			INC     B			; Increment back to 0
040AA9             1235*  ;
040AA9 FE F5       1236*  IND2_:			CP      REPEAT			; If the token is REPEAT
040AAB 28 09       1237*  			JR      Z,IND3			; Then INC C
040AAD FE FD       1238*  			CP      UNTIL			; If it is UNTIL
040AAF 20 06       1239*  			JR      NZ,IND4			; Then...
040AB1 0D          1240*  			DEC     C			; DEC C
040AB2 F2 B7 0A 04 1241*  			JP      P,IND4			; If we have gone below 0 then
040AB6 0C          1242*  IND3:			INC     C			; Incremet back to 0
040AB7 D9          1243*  IND4:			EXX
040AB8 C9          1244*  			RET
040AB9             1245*  ;
040AB9             1246*  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
040AB9             1247*  ;  Destroys: A,F
040AB9             1248*  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
040AB9             1249*  ;    Inputs: A = character
040AB9             1250*  ;  Destroys: A,F
040AB9             1251*  ;
040AB9 3E 0D       1252*  CRLF:			LD      A,CR			; Output CR
040ABB CD C1 0A 04 1253*  			CALL    OUTCHR
040ABF 3E 0A       1254*  			LD      A,LF			; Output LF
040AC1             1255*  ;
040AC1 CD DA 44 04 1256*  OUTCHR:			CALL    OSWRCH			; Output the character in A
040AC5 D6 0D       1257*  			SUB     CR			; Check for CR
040AC7 28 06       1258*  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
040AC9 D8          1259*  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
040ACA 3A 3D 4D 04 1260*  			LD      A,(COUNT)		; Increment the count
040ACE 3C          1261*  			INC     A
040ACF             1262*  ;
040ACF 32 3D 4D 04 1263*  CARRET:			LD      (COUNT),A		; Store the new count value
040AD3 C8          1264*  			RET     Z			; Return if the count has wrapped to 0
040AD4 E5          1265*  			PUSH    HL			; Now check if count = print width
040AD5 2A 3E 4D 04 1266*  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
040AD9 BD          1267*  			CP      L			; L is the width. Compare it with count.
040ADA E1          1268*  			POP     HL
040ADB C0          1269*  			RET     NZ			; If we've not hit print width, then just return
040ADC 18 DB       1270*  			JR      CRLF			; Otherwise output CRLF
040ADE             1271*  ;
040ADE             1272*  ; OUT - SEND CHARACTER OR KEYWORD
040ADE             1273*  ;   Inputs: A = character (>=10, <128)
040ADE             1274*  ;           A = Token (<10, >=128)
040ADE             1275*  ;  Destroys: A,F
040ADE             1276*  ;
040ADE FE 8A       1277*  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
040AE0 EA C1 0A 04 1278*  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
040AE4             1279*  ;
040AE4             1280*  ; This bit looks up the character in the KEYWDS token table and expands it
040AE4             1281*  ; Note the CP 138; this sets the overflow flag as follows:
040AE4             1282*  ;
040AE4             1283*  ; NB:
040AE4             1284*  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
040AE4             1285*  ;  2. CP is effectively a SUB; sets the flags without affecting A
040AE4             1286*  ;  3. The operation n - -118 ~ n + 118
040AE4             1287*  ;
040AE4             1288*  ; So:
040AE4             1289*  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
040AE4             1290*  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
040AE4             1291*  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
040AE4             1292*  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
040AE4             1293*  ;
040AE4 C5          1294*  			PUSH    BC			; Preserve BC and HL
040AE5 E5          1295*  			PUSH    HL
040AE6 21 DA 02 04 1296*  			LD      HL,KEYWDS		; The list of tokens and keywords
040AEA 01 DF 02 00 1297*  			LD      BC,KEYWDL		; The length of the keyword list
040AEE ED B1       1298*  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
040AF0             1299*  ;							; At this point HL points to the next byte, the first character of the token
040AF0 7E          1300*  TOKEN1:			LD      A,(HL)			; Fetch the character
040AF1 23          1301*  			INC     HL			; Increment to the next byte in the token table
040AF2 FE 8A       1302*  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
040AF4 F5          1303*  			PUSH    AF			; Then...
040AF5 EC C1 0A 04 1304*  			CALL    PE,OUTCHR		; Output the character...
040AF9 F1          1305*  			POP     AF			;
040AFA EA F0 0A 04 1306*  			JP      PE,TOKEN1		; And loop to the next character
040AFE E1          1307*  			POP     HL			; Done, so tidy up the stack and exit
040AFF C1          1308*  			POP     BC
040B00 C9          1309*  			RET
040B01             1310*  ;
040B01             1311*  ; FINDL - FIND PROGRAM LINE
040B01             1312*  ;   Inputs: HL = line number (binary)
040B01             1313*  ;  Outputs: HL addresses line (if found)
040B01             1314*  ;           DE = line number
040B01             1315*  ;           Z-flag set if found.
040B01             1316*  ; Destroys: A,B,C,D,E,H,L,F
040B01             1317*  ;
040B01 EB          1318*  FINDL:			EX      DE,HL			; DE: Line number (binary)
040B02 2A 14 4D 04 1319*  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
040B06 AF          1320*  			XOR     A               	;  A: 0
040B07 BE          1321*  			CP      (HL)			; Check for end of program marker
040B08 3C          1322*  			INC     A			;  A: 1
040B09 D0          1323*  			RET     NC			; Return with 1 if 0
040B0A AF          1324*  			XOR     A               	; Clear the carry flag
040B0B             1325*  ;			LD      B,A			;  B: 0
040B0B 01 00 00 00 1326*  			LD	BC, 0			; BC: 0
040B0F             1327*  ;
040B0F 4E          1328*  FINDL1:			LD      C,(HL)			;  C: The line length
040B10 E5          1329*  			PUSH    HL			; Stack the current program counter
040B11 23          1330*  			INC     HL			; Skip to the line number bytes
040B12 7E          1331*  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
040B13 23          1332*  			INC     HL
040B14 66          1333*  			LD      H,(HL)
040B15 6F          1334*  			LD      L,A
040B16 52 ED 52    1335*  			SBC.S   HL,DE			; Compare with the line number we're searching for
040B19 E1          1336*  			POP     HL			; Get the current program counter
040B1A D0          1337*  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
040B1B 09          1338*  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
040B1C C3 0F 0B 04 1339*  			JP      FINDL1			; And loop
040B20             1340*  ;
040B20             1341*  ; SETLIN - Search program for line containing address
040B20             1342*  ;          Update (LINENO)
040B20             1343*  ;   Inputs: Address in (ERRLIN)
040B20             1344*  ;  Outputs: Line number in HL and (LINENO)
040B20             1345*  ; Destroys: B,C,D,E,H,L,F
040B20             1346*  ;
040B20 01 00 00 00 1347*  SETLIN:			LD	BC, 0			; Zero BC for later
040B24             1348*  ;			LD      B, 0			; Zero B for later
040B24 ED 5B 35 4D 1349*  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
040B29 2A 14 4D 04 1350*  			LD      HL, (PAGE_)		; HL: Start of user program area
040B2D B7          1351*  			OR      A			; Do a 24 bit compare without destroying HL
040B2E ED 52       1352*  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
040B30 19          1353*  			ADD     HL, DE			;  C: DE > HL
040B31 30 1B       1354*  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
040B33             1355*  ;
040B33 4E          1356*  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
040B34 0C          1357*  			INC     C			; This is a way to check for zero without using the accumulator
040B35 0D          1358*  			DEC     C			; If it is zero, then...
040B36 28 16       1359*  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
040B38 09          1360*  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
040B39 ED 52       1361*  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
040B3B 19          1362*  			ADD     HL, DE
040B3C 38 F5       1363*  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
040B3E ED 42       1364*  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
040B40 23          1365*  			INC     HL			; Skip the length counter
040B41 11 00 00 00 1366*  			LD	DE, 0			; Zero DE
040B45 5E          1367*  			LD      E, (HL)          	; Fetch the line number
040B46 23          1368*  			INC     HL
040B47 56          1369*  			LD      D, (HL)
040B48 EB          1370*  			EX      DE, HL			; HL: The line number
040B49 22 23 4D 04 1371*  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
040B4D C9          1372*  			RET
040B4E             1373*  ;
040B4E 21 00 00 00 1374*  SET3:			LD      HL, 0			; We've not found the line at this point so
040B52 18 F5       1375*  			JR      SET2			; Set LINENO to 0
040B54             1376*  ;
040B54             1377*  ;SAYLN - PRINT " at line nnnn" MESSAGE.
040B54             1378*  ;  Outputs: Carry=0 if line number is zero.
040B54             1379*  ;           Carry=1 if line number is non-zero.
040B54             1380*  ; Destroys: A,B,C,D,E,H,L,F
040B54             1381*  ;
040B54 2A 23 4D 04 1382*  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
040B58 7C          1383*  			LD      A,H			; If it is zero then
040B59 B5          1384*  			OR      L
040B5A C8          1385*  			RET     Z			; Don't need to do anything; return with F:C set to 0
040B5B CD 02 0F 04 1386*  			CALL    TELL			; Output the error message
040B5F 20 61 74 20 1387*  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
040B69 0E 00       1388*  PBCDL:			LD      C,0			; C: Leading character (NUL)
040B6B 18 02       1389*  			JR      PBCD0			; Output the line number; return with F:C set to 1
040B6D             1390*  ;
040B6D             1391*  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
040B6D             1392*  ;   Inputs: HL = number (binary).
040B6D             1393*  ;  Outputs: Carry = 1
040B6D             1394*  ; Destroys: A,B,C,D,E,H,L,F
040B6D             1395*  ;
040B6D 0E 20       1396*  PBCD:			LD      C,' '			; C: Leading character (" ")
040B6F 06 05       1397*  PBCD0:			LD      B,5			; Number of digits in result
040B71 11 10 27 00 1398*  			LD      DE,10000		; Start off with the 10,000 column
040B75 AF          1399*  PBCD1:			XOR     A			; Counter
040B76 ED 52       1400*  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
040B78 3C          1401*  			INC     A
040B79 30 FB       1402*  			JR      NC,PBCD2
040B7B 19          1403*  			ADD     HL,DE			; The loop overruns by one, so adjust here
040B7C 3D          1404*  			DEC     A			; A: Number of 10,000s
040B7D 28 04       1405*  			JR      Z,PBCD3			; If it is 0, then skip the next bit
040B7F CB E1       1406*  			SET     4,C			; C: Set to '0' ASCII (30h)
040B81 CB E9       1407*  			SET     5,C
040B83 B1          1408*  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
040B84 C4 C1 0A 04 1409*  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
040B88 78          1410*  			LD      A,B			; If on first transition, skip this
040B89 FE 05       1411*  			CP      5			; TODO: Need to find out why
040B8B 28 06       1412*  			JR      Z,PBCD4
040B8D 29          1413*  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
040B8E 54          1414*  			LD      D,H			;         : rather than shifting DE right
040B8F 5D          1415*  			LD      E,L			;         : This makes a lot of sense
040B90 29          1416*  			ADD     HL,HL			; HL x  4
040B91 29          1417*  			ADD     HL,HL			; HL x  8
040B92 19          1418*  			ADD     HL,DE			; HL x 10
040B93 11 E8 03 00 1419*  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
040B97 10 DC       1420*  			DJNZ    PBCD1			; Loop until done
040B99 37          1421*  			SCF				; SCF set for SAYLN in this module
040B9A C9          1422*  			RET
040B9B             1423*  ;
040B9B             1424*  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
040B9B             1425*  ;   Inputs: HL, IY as returned from GETVAR (NZ).
040B9B             1426*  ;  Outputs: As GETVAR.
040B9B             1427*  ; Destroys: everything
040B9B             1428*  ;
040B9B CD 20 0D 04 1429*  PUTVAR:			CALL    CREATE			; Create the variable
040B9F FD 7E 00    1430*  			LD      A,(IY)			; Fetch the next character
040BA2 FE 28       1431*  			CP      '('			; Check for bad use of array
040BA4 20 70       1432*  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
040BA6 3E 0E       1433*  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
040BA8 C3 D2 08 04 1434*  ERROR3:			JP      ERROR_
040BAC             1435*  ;
040BAC             1436*  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
040BAC             1437*  ;   Inputs: IY addresses first character.
040BAC             1438*  ;  Outputs: Carry set and NZ if illegal character.
040BAC             1439*  ;           Z-flag set if variable found, then:
040BAC             1440*  ;            A = variable type (0,4,5,128 or 129)
040BAC             1441*  ;            HL = IX = variable pointer.
040BAC             1442*  ;            IY updated
040BAC             1443*  ;           If Z-flag & carry reset, then:
040BAC             1444*  ;            HL, IY set for subsequent PUTVAR call.
040BAC             1445*  ; Destroys: everything
040BAC             1446*  ;
040BAC FD 7E 00    1447*  GETVAR:			LD      A,(IY)			; Get the first character
040BAF FE 24       1448*  			CP      '$'			; Is it a string?
040BB1 28 69       1449*  			JR      Z,GETV4			; Yes, so branch here
040BB3 FE 21       1450*  			CP      '!'			; Is it indirection (32-bit)?
040BB5 28 69       1451*  			JR      Z,GETV5			; Yes, so branch here
040BB7 FE 3F       1452*  			CP      '?'			; Is it indirection (8-bit)?
040BB9 28 69       1453*  			JR      Z,GETV6			; Yes, so branch here
040BBB             1454*  ;
040BBB CD 8A 0C 04 1455*  			CALL    LOCATE			; Locate the variable
040BBF C0          1456*  			RET     NZ			; And exit here if not found
040BC0             1457*  ;
040BC0             1458*  ; At this point:
040BC0             1459*  ;  HL: Address of variable in memory
040BC0             1460*  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
040BC0             1461*  ;
040BC0 FD 7E 00    1462*  			LD      A,(IY)			; Further checks
040BC3 FE 28       1463*  			CP      '('             	; Is it an array?
040BC5 20 47       1464*  			JR      NZ,GETVX        	; No, so exit
040BC7             1465*  ;
040BC7             1466*  ; We are processing an array at this point
040BC7             1467*  ;
040BC7 D5          1468*  			PUSH    DE              	; Save the variable type (in D)
040BC8 7E          1469*  			LD      A,(HL)          	; Fetch the number of dimensions
040BC9 B7          1470*  			OR      A
040BCA 28 DA       1471*  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
040BCC 23          1472*  			INC     HL			;
040BCD 11 00 00 00 1473*  			LD      DE,0            	; Accumulator
040BD1 F5          1474*  			PUSH    AF
040BD2 FD 23       1475*  			INC     IY              	; Skip "("
040BD4 18 05       1476*  			JR      GETV3
040BD6             1477*  ;
040BD6 F5          1478*  GETV2:			PUSH    AF
040BD7 CD 29 18 04 1479*  			CALL    COMMA
040BDB E5          1480*  GETV3:			PUSH    HL
040BDC D5          1481*  			PUSH    DE
040BDD CD 0E 11 04 1482*  			CALL    EXPRI			; Get the subscript
040BE1 D9          1483*  			EXX
040BE2 D1          1484*  			POP     DE
040BE3 E3          1485*  			EX      (SP),HL
040BE4 4E          1486*  			LD      C,(HL)
040BE5 23          1487*  			INC     HL
040BE6 46          1488*  			LD      B,(HL)
040BE7 23          1489*  			INC     HL
040BE8 E3          1490*  			EX      (SP),HL
040BE9 EB          1491*  			EX      DE,HL
040BEA D5          1492*  			PUSH    DE
040BEB CD A3 26 04 1493*  			CALL    MUL16			; HL=HL*BC
040BEF D1          1494*  			POP     DE
040BF0 19          1495*  			ADD     HL,DE
040BF1 EB          1496*  			EX      DE,HL
040BF2 B7          1497*  			OR      A
040BF3 ED 42       1498*  			SBC     HL,BC
040BF5 3E 0F       1499*  			LD      A,15
040BF7 30 AF       1500*  			JR      NC,ERROR3		; Throw a "Subscript" error
040BF9 E1          1501*  			POP     HL
040BFA F1          1502*  			POP     AF
040BFB 3D          1503*  			DEC     A               	; Dimension counter
040BFC 20 D8       1504*  			JR      NZ,GETV2
040BFE CD 36 18 04 1505*  			CALL    BRAKET          	; Check for closing bracket
040C02 F1          1506*  			POP     AF              	; Restore the type
040C03 E5          1507*  			PUSH    HL
040C04 CD 96 26 04 1508*  			CALL    X4OR5           	; DE=DE*n
040C08 E1          1509*  			POP     HL
040C09 19          1510*  			ADD     HL,DE
040C0A 57          1511*  			LD      D,A             	; The type
040C0B FD 7E 00    1512*  			LD      A,(IY)
040C0E FE 3F       1513*  GETVX:			CP      '?'
040C10 28 1E       1514*  			JR      Z,GETV9
040C12 FE 21       1515*  			CP      '!'
040C14 28 16       1516*  			JR      Z,GETV8
040C16 E5          1517*  GETVZ:			PUSH    HL              	; Set exit conditions
040C17 DD E1       1518*  			POP     IX
040C19 7A          1519*  			LD      A,D
040C1A BF          1520*  			CP      A
040C1B C9          1521*  			RET
040C1C             1522*  ;
040C1C             1523*  ; Process strings, unary & binary indirection:
040C1C             1524*  ;
040C1C 3E 80       1525*  GETV4:			LD      A,128           	; Static strings
040C1E 18 05       1526*  			JR      GETV7
040C20             1527*  ;
040C20 3E 04       1528*  GETV5:			LD      A,4             	; Unary 32-bit indirection
040C22 18 01       1529*  			JR      GETV7
040C24             1530*  ;
040C24 AF          1531*  GETV6:			XOR     A               	; Unary 8-bit indirection
040C25             1532*  ;
040C25 21 00 00 00 1533*  GETV7:			LD      HL,0
040C29 F5          1534*  			PUSH    AF
040C2A 18 24       1535*  			JR      GETV0
040C2C             1536*  ;
040C2C 06 04       1537*  GETV8:			LD      B,4             	; Binary 32-bt indirection
040C2E 18 02       1538*  			JR      GETVA
040C30             1539*  ;
040C30 06 00       1540*  GETV9:			LD      B,0             	; Binary 8-bit indirection
040C32             1541*  ;
040C32 E5          1542*  GETVA:			PUSH    HL
040C33 DD E1       1543*  			POP     IX
040C35 7A          1544*  			LD      A,D            		; Fetch the variable type
040C36 FE 81       1545*  			CP      129			; Is it a string?
040C38 C8          1546*  			RET     Z               	; Yes, so exit here
040C39 C5          1547*  			PUSH    BC
040C3A CD 1A 12 04 1548*  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
040C3E CD 66 14 04 1549*  			CALL    SFIX
040C42 7D          1550*  			LD	A,L
040C43 D9          1551*  			EXX
040C44 22 4A 4D 04 1552*  			LD	(R0+0),HL
040C48 32 4C 4D 04 1553*  			LD	(R0+2),A
040C4C 2A 4A 4D 04 1554*  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
040C50             1555*  ;
040C50 E5          1556*  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
040C51 FD 23       1557*  			INC     IY
040C53 CD 29 11 04 1558*  			CALL    ITEMI
040C57 7D          1559*  			LD	A,L			;  A: The MSB of the address
040C58 D9          1560*  			EXX
040C59 22 4A 4D 04 1561*  			LD	(R0+0),HL		; HL: The LSW of the address
040C5D 32 4C 4D 04 1562*  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
040C61 D1          1563*  			POP     DE
040C62 F1          1564*  			POP     AF
040C63 2A 4A 4D 04 1565*  			LD	HL,(R0)			; HL: L'HL
040C67 19          1566*  			ADD     HL,DE
040C68 E5          1567*  			PUSH    HL
040C69 DD E1       1568*  			POP     IX
040C6B BF          1569*  			CP      A
040C6C C9          1570*  			RET
040C6D             1571*  ;
040C6D             1572*  ;GETDEF - Find entry for FN or PROC in dynamic area.
040C6D             1573*  ;   Inputs: IY addresses byte following "DEF" token.
040C6D             1574*  ;  Outputs: Z flag set if found
040C6D             1575*  ;           Carry set if neither FN or PROC first.
040C6D             1576*  ;           If Z: HL points to entry
040C6D             1577*  ;                 IY addresses delimiter
040C6D             1578*  ; Destroys: A,D,E,H,L,IY,F
040C6D             1579*  ;
040C6D FD 7E 01    1580*  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
040C70 CD ED 0D 04 1581*  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
040C74 D8          1582*  			RET     C			; No so return with C set
040C75 FD 7E 00    1583*  			LD      A,(IY)			; Fetch the current character from the tokenised line
040C78 21 0E 4D 04 1584*  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
040C7C FE A4       1585*  			CP      FN			; Is it the token FN?
040C7E 28 4A       1586*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
040C80 21 11 4D 04 1587*  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
040C84 FE F2       1588*  			CP      PROC			; Is it the token PROC?
040C86 28 42       1589*  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
040C88 37          1590*  			SCF				; No, so just return with C set
040C89 C9          1591*  			RET
040C8A             1592*  ;
040C8A             1593*  ; LOCATE - Try to locate variable name in static or dynamic variables.
040C8A             1594*  ; If illegal first character return carry, non-zero.
040C8A             1595*  ; If found, return no-carry, zero.
040C8A             1596*  ; If not found, return no-carry, non-zero.
040C8A             1597*  ;   Inputs: IY=Addresses first character of name.
040C8A             1598*  ;            A=(IY)
040C8A             1599*  ;  Outputs:  F=Z set if found, then:
040C8A             1600*  ;           IY=addresses terminator
040C8A             1601*  ;           HL=addresses location of variable
040C8A             1602*  ;            D=type of variable: 4 = integer
040C8A             1603*  ;                                5 = floating point
040C8A             1604*  ;                              129 = string
040C8A             1605*  ; Destroys: A,D,E,H,L,IY,F
040C8A             1606*  ;
040C8A             1607*  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
040C8A             1608*  ; They can contain any alphanumeric character and underscore (_)
040C8A             1609*  ; String variables are postfixed with the dollar ($) character
040C8A             1610*  ; Integer variables are postfixed with the percent (%) character
040C8A             1611*  ; Static integer variables are named @%, A% to Z%
040C8A             1612*  ; All other variables are dynamic
040C8A             1613*  ;
040C8A D6 40       1614*  LOCATE:			SUB     '@'			; Check for valid range
040C8C D8          1615*  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
040C8D 21 00 00 00 1616*  			LD      HL, 0			; Clear HL
040C91 FE 1B       1617*  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
040C93 30 1E       1618*  			JR      NC,LOC0         	; Then branch here
040C95 6F          1619*  			LD	L, A			; HL = A
040C96 FD 7E 01    1620*  			LD      A,(IY+1)        	; Check the 2nd character
040C99 FE 25       1621*  			CP      '%'			; If not "%" then it is not static...
040C9B 20 21       1622*  			JR      NZ,LOC1         	; Branch here
040C9D FD 7E 02    1623*  			LD      A,(IY+2)		; Check the 3rd character
040CA0 FE 28       1624*  			CP      '('			; If it is "(" (array) then it is not static...
040CA2 28 1A       1625*  			JR      Z,LOC1          	; Branch here
040CA4             1626*  ;
040CA4             1627*  ; At this point we're dealing with a static variable
040CA4             1628*  ;
040CA4 29          1629*  			ADD     HL,HL			; HL: Variable index * 4
040CA5 29          1630*  			ADD	HL,HL
040CA6 11 00 4C 04 1631*  			LD      DE,STAVAR       	; The static variable area in memory
040CAA 19          1632*  			ADD     HL,DE			; HL: The address of the static variable
040CAB FD 23       1633*  			INC     IY			; Skip the program pointer past the static variable name
040CAD FD 23       1634*  			INC     IY
040CAF 16 04       1635*  			LD      D,4             	; Set the type to be integer
040CB1 AF          1636*  			XOR     A			; Set the Z flag
040CB2 C9          1637*  			RET
040CB3             1638*  ;
040CB3             1639*  ; At this point it's potentially a dynamic variable, just need to do a few more checks
040CB3             1640*  ;
040CB3 FE 1F       1641*  LOC0:			CP      '_'-'@'			; Check the first character is in
040CB5 D8          1642*  			RET     C			; the range "_" to
040CB6 FE 3B       1643*  			CP      'z'-'@'+1		; "z" (lowercase characters only)
040CB8 3F          1644*  			CCF				; If it is not in range then
040CB9 3D          1645*  			DEC     A               	; Set NZ flag and
040CBA D8          1646*  			RET     C			; Exit here
040CBB D6 03       1647*  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
040CBD 6F          1648*  			LD	L, A			; HL = A
040CBE             1649*  ;
040CBE             1650*  ; Yes, it's definitely a dynamic variable at this point...
040CBE             1651*  ;
040CBE 7D          1652*  LOC1:			LD	A, L			; Fetch variable index
040CBF 87          1653*  			ADD	A, A			; x 2
040CC0 85          1654*  			ADD	A, L			; x 3
040CC1 D6 03       1655*  			SUB	3			; Subtract 2 TODO: Should be 3
040CC3 6F          1656*  			LD	L, A
040CC4 11 6C 4C 04 1657*  			LD      DE, DYNVAR       	; The dynamic variable storage
040CC8 D8          1658*  			RET	C			; Bounds check to trap for variable '@'
040CC9 19          1659*  			ADD     HL, DE			; HL: Address of first entry
040CCA             1660*  ;
040CCA             1661*  ; Loop through the linked list of variables to find a match
040CCA             1662*  ;
040CCA ED 17       1663*  LOC2:			LD	DE, (HL)		; Fetch the original pointer
040CCC E5          1664*  			PUSH	HL			; Need to preserve HL for LOC6
040CCD AF          1665*  			XOR	A			; Reset carry flag
040CCE ED 62       1666*  			SBC	HL, HL			; Set HL to 0
040CD0 ED 52       1667*  			SBC	HL, DE			; Compare with 0
040CD2 E1          1668*  			POP	HL			; Restore the original pointer
040CD3 28 49       1669*  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
040CD5             1670*  			; LD	HL, DE			; Make a copy of this pointer in HL
040CD5 D5          1671*  			push de
040CD6 E1          1672*  			pop hl ; how was that even possible?
040CD7 23          1673*  			INC     HL              	; Skip the link (24-bits)
040CD8 23          1674*  			INC     HL
040CD9 23          1675*  			INC	HL			; HL: Address of the variable name in DYNVARS
040CDA FD E5       1676*  			PUSH    IY			; IY: Address of the variable name in the program
040CDC             1677*  ;
040CDC 7E          1678*  LOC3:			LD      A,(HL)         		; Compare
040CDD 23          1679*  			INC     HL
040CDE FD 23       1680*  			INC     IY
040CE0 FD BE 00    1681*  			CP      (IY)
040CE3 28 F7       1682*  			JR      Z, LOC3			; Keep looping whilst we've got a match...
040CE5 B7          1683*  			OR      A               	; Have we hit a terminator?
040CE6 28 07       1684*  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
040CE8             1685*  ;
040CE8 FD E1       1686*  LOC4:			POP     IY			; Restore the pointer in the program
040CEA EB          1687*  			EX      DE, HL			; HL: New pointer in DYNVARS
040CEB C3 CA 0C 04 1688*  			JP      LOC2            	; Loop round and try again
040CEF             1689*  ;
040CEF             1690*  ; We might have located a variable at this point, just need to do a few more tests
040CEF             1691*  ;
040CEF FD 2B       1692*  LOC5:			DEC     IY
040CF1 FD 7E 00    1693*  			LD      A,(IY)
040CF4 FE 28       1694*  			CP      '('
040CF6 28 15       1695*  			JR      Z,LOC5A         	; FOUND
040CF8 FD 23       1696*  			INC     IY
040CFA CD E1 0D 04 1697*  			CALL    RANGE
040CFE 38 0D       1698*  			JR      C,LOC5A         	; FOUND
040D00 FE 28       1699*  			CP      '('
040D02 28 E4       1700*  			JR      Z,LOC4          	; KEEP LOOKING
040D04 FD 7E FF    1701*  			LD      A,(IY-1)
040D07 CD ED 0D 04 1702*  			CALL    RANGE1
040D0B 30 DB       1703*  			JR      NC,LOC4         	; KEEP LOOKING
040D0D D1          1704*  LOC5A:			POP     DE
040D0E FD 7E FF    1705*  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
040D11 FE 24       1706*  			CP      '$'			; Is it a string?
040D13 16 81       1707*  			LD      D,129			; Yes, so return D = 129
040D15 C8          1708*  			RET     Z
040D16 FE 25       1709*  			CP      '%'			; Is it an integer?
040D18 16 04       1710*  			LD      D,4			; Yes, so return D = 4
040D1A C8          1711*  			RET     Z
040D1B 14          1712*  			INC     D			; At this point it must be a float
040D1C BF          1713*  			CP      A			; Set the flags
040D1D C9          1714*  			RET
040D1E             1715*  ;
040D1E             1716*  ; The variable is undefined at this point; HL will be zero
040D1E             1717*  ;
040D1E 3C          1718*  LOC6:			INC     A               	; Set NZ flag
040D1F C9          1719*  			RET
040D20             1720*  ;
040D20             1721*  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
040D20             1722*  ;   Inputs: HL, IY as returned from LOCATE (NZ).
040D20             1723*  ;  Outputs: As LOCATE, GETDEF.
040D20             1724*  ; Destroys: As LOCATE, GETDEF.
040D20             1725*  ;
040D20 AF          1726*  CREATE:			XOR     A
040D21 ED 5B 1D 4D 1727*  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
040D26 ED 1F       1728*  			LD	(HL), DE		; Store
040D28 EB          1729*  			EX      DE,HL
040D29 77          1730*  			LD      (HL),A			; Clear the link of the new entity
040D2A 23          1731*  			INC     HL
040D2B 77          1732*  			LD      (HL),A
040D2C 23          1733*  			INC     HL
040D2D 77          1734*  			LD      (HL),A
040D2E 23          1735*  			INC     HL
040D2F FD 23       1736*  LOC7:			INC     IY
040D31 CD E1 0D 04 1737*  			CALL    RANGE           	; END OF VARIABLE?
040D35 38 15       1738*  			JR      C,LOC8
040D37 77          1739*  			LD      (HL),A
040D38 23          1740*  			INC     HL
040D39 CD ED 0D 04 1741*  			CALL    RANGE1
040D3D 30 F0       1742*  			JR      NC,LOC7
040D3F FE 28       1743*  			CP      '('
040D41 28 09       1744*  			JR      Z,LOC8
040D43 FD 7E 01    1745*  			LD      A,(IY+1)
040D46 FE 28       1746*  			CP      '('
040D48 28 E5       1747*  			JR      Z,LOC7
040D4A FD 23       1748*  			INC     IY
040D4C 36 00       1749*  LOC8:			LD      (HL),0          	; TERMINATOR
040D4E 23          1750*  			INC     HL
040D4F E5          1751*  			PUSH    HL
040D50 CD 0E 0D 04 1752*  			CALL    TYPE_			; Get the variable type in D
040D54 3E 04       1753*  			LD      A,4			; If it is an integer then it takes up 4 bytes
040D56 BA          1754*  			CP      D
040D57 28 01       1755*  			JR      Z,LOC9			; So skip the next bit
040D59 3C          1756*  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
040D5A 36 00       1757*  LOC9:			LD      (HL),0          	; Initialise the memory to zero
040D5C 23          1758*  			INC     HL
040D5D 3D          1759*  			DEC     A
040D5E 20 FA       1760*  			JR      NZ,LOC9
040D60 22 1D 4D 04 1761*  			LD      (FREE),HL		; Adjust the stack
040D64 CD 80 24 04 1762*  			CALL    CHECK			; Check whether we are out of space
040D68 E1          1763*  			POP     HL
040D69 AF          1764*  			XOR     A
040D6A C9          1765*  			RET
040D6B             1766*  ;
040D6B             1767*  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
040D6B             1768*  ;   Inputs: IY = Text Pointer
040D6B             1769*  ;  Outputs: HL = Line number (zero if none)
040D6B             1770*  ;           IY updated
040D6B             1771*  ; Destroys: A,D,E,H,L,IY,F
040D6B             1772*  ;
040D6B             1773*  ; This bit of code performs a BASE 10 shift to build up the number
040D6B             1774*  ; So if the string passed is "345", the algorithm does this:
040D6B             1775*  ;
040D6B             1776*  ;    HL : Digit	: Operation
040D6B             1777*  ; ----- : ----- : ---------
040D6B             1778*  ; 00000 :	:
040D6B             1779*  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
040D6B             1780*  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
040D6B             1781*  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
040D6B             1782*  ;
040D6B             1783*  ; The multiply by 10 is done by an unrolled shift and add loop
040D6B             1784*  ;
040D6B CD 77 18 04 1785*  LINNUM:			CALL    NXT			; Skip whitespace to the first character
040D6F 40 21 00 00 1786*  			LD.SIS  HL,0			; The running total
040D73 FD 7E 00    1787*  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
040D76 D6 30       1788*  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
040D78 D8          1789*  			RET     C			; And return if less than 0
040D79 FE 0A       1790*  			CP      10			; Or greater than or equal to 10
040D7B D0          1791*  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
040D7C FD 23       1792*  			INC     IY			; Increment the string pointer
040D7E 54          1793*  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
040D7F 5D          1794*  			LD      E,L			; Store the original number in DE
040D80 52 29       1795*  			ADD.S   HL,HL           	; *2
040D82 38 13       1796*  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
040D84 52 29       1797*  			ADD.S   HL,HL           	; *4S
040D86 38 0F       1798*  			JR      C,TOOBIG
040D88 52 19       1799*  			ADD.S   HL,DE           	; *5
040D8A 38 0B       1800*  			JR      C,TOOBIG
040D8C 52 29       1801*  			ADD.S   HL,HL           	; *10
040D8E 38 07       1802*  			JR      C,TOOBIG
040D90 5F          1803*  			LD      E,A			; A->DE: the digit to add in
040D91 16 00       1804*  			LD      D,0
040D93 52 19       1805*  			ADD.S   HL,DE           	; Add in the digit to the running total
040D95 30 DC       1806*  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
040D97             1807*  ;
040D97 3E 14       1808*  TOOBIG:			LD      A,20
040D99 C3 D2 08 04 1809*  			JP      ERROR_           	; Error: "Too big"
040D9D             1810*  ;
040D9D             1811*  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
040D9D             1812*  ;   Inputs: IY = text pointer
040D9D             1813*  ;  Outputs: HL = first number (10 by default)
040D9D             1814*  ;           BC = second number (10 by default)
040D9D             1815*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
040D9D             1816*  ;
040D9D CD 6B 0D 04 1817*  PAIR:			CALL    LINNUM          	; Parse the first line number
040DA1 7C          1818*  			LD      A,H			; If it is not zero, then...
040DA2 B5          1819*  			OR      L
040DA3 20 02       1820*  			JR      NZ,PAIR1		; Skip...
040DA5 2E 0A       1821*  			LD      L,10			; HL: the default value (10)
040DA7             1822*  ;
040DA7 CD AB 25 04 1823*  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
040DAB FD 23       1824*  			INC     IY			; Skip to next character
040DAD E5          1825*  			PUSH    HL			; Stack the first line number
040DAE 21 0A 00 00 1826*  			LD      HL,10			; HL: the second default (10)
040DB2 C4 6B 0D 04 1827*  			CALL    NZ,LINNUM       	; Parse the second line number
040DB6 E3          1828*  			EX      (SP),HL			; HL: The first line number (off the stack)
040DB7 C1          1829*  			POP     BC			; BC: Second line number
040DB8 78          1830*  			LD      A,B			; If the second line number is not zero then...
040DB9 B1          1831*  			OR      C			; We're good...
040DBA C0          1832*  			RET     NZ			; Exit, otherwise...
040DBB CD E9 08 04 1833*  			CALL    EXTERR			; Throw error: "Silly"
040DBF 53 69 6C 6C 1834*  			DB    	"Silly", 0
       79 00       
040DC5             1835*  ;
040DC5             1836*  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
040DC5             1837*  ;   Inputs: IY = text pointer
040DC5             1838*  ;  Outputs: HL = points to program text
040DC5             1839*  ;           BC = second number (0 by default)
040DC5             1840*  ; Destroys: A,B,C,D,E,H,L,IY,F
040DC5             1841*  ;
040DC5 CD 6B 0D 04 1842*  DLPAIR:			CALL    LINNUM			; Parse the first line number
040DC9 E5          1843*  			PUSH    HL			; Stack it
040DCA CD AB 25 04 1844*  			CALL    TERMQ			; Check for ELSE, : or CR
040DCE 28 0A       1845*  			JR      Z,DLP1			; And exit if so
040DD0 FE E7       1846*  			CP      TIF			; Is the token IF?
040DD2 28 06       1847*  			JR      Z,DLP1			; Yes, so skip the next bit...
040DD4 FD 23       1848*  			INC     IY			; Otherwise...
040DD6 CD 6B 0D 04 1849*  			CALL    LINNUM			; Fetch the second line number
040DDA E3          1850*  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
040DDB CD 01 0B 04 1851*  			CALL    FINDL			; HL: Find the address of the line
040DDF C1          1852*  			POP     BC			; BC: The second number
040DE0 C9          1853*  			RET
040DE1             1854*  ;
040DE1             1855*  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
040DE1             1856*  ;   Inputs: IY addresses character
040DE1             1857*  ;  Outputs: Carry set if out-of-range.
040DE1             1858*  ; Destroys: A,F
040DE1             1859*  ;
040DE1             1860*  ; It is called here to check the following
040DE1             1861*  ; In range: "$", "%" and "("
040DE1             1862*  ;   Plus all characters in RANGE1 and RANGE2
040DE1             1863*  ;
040DE1 FD 7E 00    1864*  RANGE:			LD      A,(IY)			; Fetch the character
040DE4 FE 24       1865*  			CP      '$'			; Postfix for string variable is valid
040DE6 C8          1866*  			RET     Z
040DE7 FE 25       1867*  			CP      '%'			; Postfix for integer variable is valid
040DE9 C8          1868*  			RET     Z
040DEA FE 28       1869*  			CP      '('			; Postfix for array is valid
040DEC C8          1870*  			RET     Z
040DED             1871*  ;
040DED             1872*  ; It is called here to check the following
040DED             1873*  ; In range: "0" to "9" and "@"
040DED             1874*  ;   Plus all characters in RANGE2
040DED             1875*  ;
040DED FE 30       1876*  RANGE1:			CP      '0'			; If it is between '0'...
040DEF D8          1877*  			RET     C
040DF0 FE 3A       1878*  			CP      '9'+1			; And '9'...
040DF2 3F          1879*  			CCF
040DF3 D0          1880*  			RET     NC			; Then it is valid
040DF4 FE 40       1881*  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
040DF6 C8          1882*  			RET     Z
040DF7             1883*  ;
040DF7             1884*  ; It is called here to check the following
040DF7             1885*  ; In range: "A" to "Z", "a' to "z", "_" and "`"
040DF7             1886*  ;
040DF7 FE 41       1887*  RANGE2:			CP      'A'			; If it is between 'A'...
040DF9 D8          1888*  			RET     C
040DFA FE 5B       1889*  			CP      'Z'+1			; And 'Z'...
040DFC 3F          1890*  			CCF
040DFD D0          1891*  			RET     NC			; Then it is valid
040DFE FE 5F       1892*  			CP      '_'			; If it is underscore, grave, or between 'a'
040E00 D8          1893*  			RET     C
040E01 FE 7B       1894*  			CP      'z'+1			; And 'z'
040E03 3F          1895*  			CCF				; Then it is valid
040E04 C9          1896*  			RET
040E05             1897*  ;
040E05             1898*  ; Throw a 'LINE space' error (line too long)
040E05             1899*  ; This is called from LEXAN
040E05             1900*  ;
040E05 AF          1901*  SPACE_: 		XOR     A
040E06 CD E9 08 04 1902*  			CALL    EXTERR          	; "LINE space"
040E0A 86 08 00    1903*  			DB    	LINE_, 8, 0
040E0D             1904*  ;
040E0D             1905*  ; LEXAN - LEXICAL ANALYSIS.
040E0D             1906*  ;  Bit 0,C: 1=left, 0=right
040E0D             1907*  ;  Bit 2,C: 1=in BINARY
040E0D             1908*  ;  Bit 3,C: 1=in HEX
040E0D             1909*  ;  Bit 4,C: 1=accept line number
040E0D             1910*  ;  Bit 5,C: 1=in variable, FN, PROC
040E0D             1911*  ;  Bit 6,C: 1=in REM, DATA, *
040E0D             1912*  ;  Bit 7,C: 1=in quotes
040E0D             1913*  ;   Inputs: IY addresses source string
040E0D             1914*  ;           DE addresses destination string (must be page boundary)
040E0D             1915*  ;            C sets initial mode
040E0D             1916*  ;  Outputs: DE, IY updated
040E0D             1917*  ;            A holds carriage return
040E0D             1918*  ;
040E0D 12          1919*  LEXAN1:			LD      (DE),A          	; Transfer to buffer
040E0E 13          1920*  			INC     DE              	; Increment the pointers
040E0F FD 23       1921*  			INC     IY			; And fall through to the main function
040E11             1922*  ;
040E11             1923*  ; This is the main entry point
040E11             1924*  ;
040E11 7B          1925*  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
040E12 FE FC       1926*  			CP      252             	; If it is >= 252 bytes, then...
040E14 30 EF       1927*  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
040E16 FD 7E 00    1928*  			LD      A,(IY)			; Fetch character from source string
040E19 FE 0D       1929*  			CP      CR			; If it is a CR
040E1B C8          1930*  			RET     Z               	; Then it is end of line; we're done parsing
040E1C CD ED 0D 04 1931*  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
040E20 30 06       1932*  			JR      NC,LEXAN3		; Yes, so skip
040E22 CB A9       1933*  			RES     5,C             	; FLAG: NOT IN VARIABLE
040E24 CB 99       1934*  			RES     3,C             	; FLAG: NOT IN HEX
040E26 CB 91       1935*  			RES	2,C			; FLAG: NOT IN BINARY
040E28             1936*  ;
040E28 FE 20       1937*  LEXAN3:			CP      ' '			; Ignore spaces
040E2A 28 E1       1938*  			JR      Z,LEXAN1
040E2C FE 2C       1939*  			CP      ','			; Ignore commas
040E2E 28 DD       1940*  			JR      Z,LEXAN1
040E30 FE 32       1941*  			CP	'2'			; If less than '2'
040E32 30 02       1942*  			JR	NC, @F			; No, so skip
040E34 CB 91       1943*  			RES	2,C			; FLAG: NOT IN BINARY
040E36 FE 47       1944*  @@:			CP      'G'			; If less then 'G'
040E38 38 02       1945*  			JR      C,LEXAN4		; Yes, so skip
040E3A CB 99       1946*  			RES     3,C             	; FLAG: NOT IN HEX
040E3C             1947*  ;
040E3C FE 22       1948*  LEXAN4:			CP      34			; Is it a quote character?
040E3E 20 05       1949*  			JR      NZ,LEXAN5		; No, so skip
040E40 CB 11       1950*  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
040E42 3F          1951*  			CCF                     	; Toggle the carry
040E43 CB 19       1952*  			RR      C			; And then shifting it back into bit 7 of C
040E45             1953*  ;
040E45 CB 61       1954*  LEXAN5:			BIT     4,C			; Accept line number?
040E47 28 12       1955*  			JR      Z,LEXAN6		; No, so skip
040E49 CB A1       1956*  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
040E4B C5          1957*  			PUSH    BC
040E4C D5          1958*  			PUSH    DE
040E4D CD 6B 0D 04 1959*  			CALL    LINNUM         		; Parse the line number to HL
040E51 D1          1960*  			POP     DE
040E52 C1          1961*  			POP     BC
040E53 7C          1962*  			LD      A,H			; If it is not zero
040E54 B5          1963*  			OR      L
040E55 C4 CE 0E 04 1964*  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
040E59 18 B6       1965*  			JR      LEXAN2          	; And loop
040E5B             1966*  ;
040E5B 0D          1967*  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
040E5C 28 0A       1968*  			JR      Z,LEXAN7        	; If so, skip
040E5E 0C          1969*  			INC     C			; Otherwise restore C
040E5F 20 AC       1970*  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
040E61 B7          1971*  			OR      A			; Set the flags based on the character
040E62 F4 39 09 04 1972*  			CALL    P,LEX           	; Tokenise if A < 128
040E66 18 13       1973*  			JR      LEXAN8			; And skip
040E68             1974*  ;
040E68             1975*  ; Processing the LEFT hand side here
040E68             1976*  ;
040E68 FE 2A       1977*  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
040E6A 28 17       1978*  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
040E6C B7          1979*  			OR      A			; Set the flags based on the character
040E6D F4 39 09 04 1980*  			CALL    P,LEX           	; Tokenise if A < 128
040E71             1981*  ;
040E71             1982*  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
040E71             1983*  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
040E71             1984*  ; Examples:
040E71             1985*  ;   LET A% = PAGE : REM This is the GET version
040E71             1986*  ;   PAGE = 40000  : REM This is the SET version
040E71             1987*  ;
040E71 FE 8F       1988*  			CP      TOKLO			; TOKLO is 8Fh
040E73 38 06       1989*  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
040E75 FE 94       1990*  			CP      TOKHI+1			; TOKHI is 93h
040E77 30 02       1991*  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
040E79 C6 40       1992*  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
040E7B             1993*  ;
040E7B FE F4       1994*  LEXAN8:			CP      REM			; If the token is REM
040E7D 28 04       1995*  			JR      Z,LEXAN9		; Then stop tokenising
040E7F FE DC       1996*  			CP      DATA_			; If it is not DATA then
040E81 20 02       1997*  			JR      NZ,LEXANA		; Skip
040E83 CB F1       1998*  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
040E85             1999*  ;
040E85 FE A4       2000*  LEXANA:			CP      FN			; If the token is FN
040E87 28 0A       2001*  			JR      Z,LEXANB
040E89 FE F2       2002*  			CP      PROC			; Or the token is PROC
040E8B 28 06       2003*  			JR      Z,LEXANB		; Then jump to here
040E8D CD F7 0D 04 2004*  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
040E91 38 02       2005*  			JR      C,LEXANC		; Jump here if out of range
040E93             2006*  ;
040E93 CB E9       2007*  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
040E95 FE 26       2008*  LEXANC:			CP      '&'			; Check for hex prefix
040E97 20 02       2009*  			JR      NZ,LEXAND		; If not, skip
040E99 CB D9       2010*  			SET     3,C             	; FLAG: IN HEX
040E9B             2011*  ;
040E9B FE 25       2012*  LEXAND:			CP	'%'			; Check for binary prefix
040E9D 20 02       2013*  			JR	NZ,LEXANE		; If not, skip
040E9F CB D1       2014*  			SET	2,C			; FLAG: IN BINARY
040EA1             2015*  ;
040EA1 21 C5 0E 04 2016*  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
040EA5 C5          2017*  			PUSH    BC
040EA6 01 06 00 00 2018*  			LD      BC,LIST1L		; The list length
040EAA ED B1       2019*  			CPIR				; Check if the token is in this list
040EAC C1          2020*  			POP     BC
040EAD 20 02       2021*  			JR      NZ,LEXANF		; If not, then skip
040EAF CB E1       2022*  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
040EB1             2023*  ;
040EB1 21 C9 0E 04 2024*  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
040EB5 C5          2025*  			PUSH    BC
040EB6 01 05 00 00 2026*  			LD      BC,LIST2L		; The list length
040EBA ED B1       2027*  			CPIR				; Check if the token is in this list
040EBC C1          2028*  			POP     BC
040EBD 20 02       2029*  			JR      NZ,LEXANG		; If not, then skip
040EBF CB C1       2030*  			SET     0,C             	; FLAG: ENTER LEFT MODE
040EC1 C3 0D 0E 04 2031*  LEXANG:			JP      LEXAN1			; And loop
040EC5             2032*  
040EC5             2033*  ;
040EC5             2034*  ; LIST1: List of tokens that must be followed by line numbers
040EC5             2035*  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
040EC5             2036*  ;
040EC5 E5          2037*  LIST1:			DB	GOTO
040EC6 E4          2038*  			DB	GOSUB
040EC7 F7          2039*  			DB	RESTOR
040EC8 FC          2040*  			DB	TRACE
040EC9 8C          2041*  LIST2:			DB	THEN
040ECA 8B          2042*  			DB	ELSE_
040ECB             2043*  LIST1L:			EQU     $-LIST1
040ECB F5          2044*  			DB	REPEAT
040ECC 85          2045*  			DB	TERROR
040ECD 3A          2046*  			DB    	':'
040ECE             2047*  LIST2L:			EQU     $-LIST2
040ECE             2048*  ;
040ECE             2049*  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
040ECE             2050*  ;   Inputs: HL=line number, DE=string pointer
040ECE             2051*  ;  Outputs: DE updated, BIT 4,C set.
040ECE             2052*  ; Destroys: A,B,C,D,E,F
040ECE             2053*  ;
040ECE             2054*  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
040ECE             2055*  ;
040ECE             2056*  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
040ECE             2057*  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
040ECE             2058*  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
040ECE             2059*  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
040ECE             2060*  ; each byte are then stored, in LO/HI order, ORred with 0x40.
040ECE             2061*  ;
040ECE CB E1       2062*  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
040ED0 EB          2063*  			EX      DE, HL			; HL: string pointer, DE: line number
040ED1 36 8D       2064*  			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
040ED3 23          2065*  			INC     HL
040ED4 7A          2066*  			LD      A,D			; Get the high byte
040ED5 E6 C0       2067*  			AND     0C0H			; Get the top two bits	DD000000
040ED7 0F          2068*  			RRCA				; Shift right		00DD0000
040ED8 0F          2069*  			RRCA
040ED9 47          2070*  			LD      B,A			; Store in B
040EDA 7B          2071*  			LD      A,E			; Get the low byte
040EDB E6 C0       2072*  			AND     0C0H			; Get the top two bits	EE000000
040EDD B0          2073*  			OR      B			; Combine with D	EEDD0000
040EDE 0F          2074*  			RRCA				; Shift right		00EEDD00
040EDF 0F          2075*  			RRCA
040EE0 EE 54       2076*  			XOR     01010100B		; XOR with 54h
040EE2 77          2077*  			LD      (HL),A			; Store this as the second byte
040EE3 23          2078*  			INC     HL
040EE4 7B          2079*  			LD      A,E			; Get the low byte
040EE5 E6 3F       2080*  			AND     3FH			; Strip the top two bits off
040EE7 F6 40       2081*  			OR      '@'			; OR with 40h
040EE9 77          2082*  			LD      (HL),A			; Store
040EEA 23          2083*  			INC     HL
040EEB 7A          2084*  			LD      A,D			; Get the high byte
040EEC E6 3F       2085*  			AND     3FH			; Strip the top two bits off
040EEE F6 40       2086*  			OR      '@'			; OR with 40h
040EF0 77          2087*  			LD      (HL),A			; Store
040EF1 23          2088*  			INC     HL
040EF2 EB          2089*  			EX      DE,HL			; DE: string pointer, HL: line number
040EF3 C9          2090*  			RET
040EF4             2091*  ;
040EF4             2092*  ; TEXT - OUTPUT MESSAGE.
040EF4             2093*  ;   Inputs: HL addresses text (terminated by nul)
040EF4             2094*  ;  Outputs: HL addresses character following nul.
040EF4             2095*  ; Destroys: A,H,L,F
040EF4             2096*  ;
040EF4 2A 2F 4D 04 2097*  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
040EF8             2098*  ;
040EF8 7E          2099*  TEXT_:			LD      A, (HL)			; Fetch the character
040EF9 23          2100*  			INC     HL			; Increment pointer to next character
040EFA B7          2101*  			OR      A			; Check for the nul (0) string terminator
040EFB C8          2102*  			RET     Z			; And return if so
040EFC CD DE 0A 04 2103*  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
040F00 18 F6       2104*  			JR      TEXT_			; And loop
040F02             2105*  ;
040F02             2106*  ; TELL - OUTPUT MESSAGE.
040F02             2107*  ;   Inputs: Text follows subroutine call (term=nul)
040F02             2108*  ; Destroys: A,F
040F02             2109*  ;
040F02             2110*  ; Example usage:
040F02             2111*  ;
040F02             2112*  ;	CALL	TELL			Call the function
040F02             2113*  ;	DB	"Hello World", 0	Followed by a zero terminated string
040F02             2114*  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
040F02             2115*  ;
040F02 E3          2116*  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
040F03 CD F8 0E 04 2117*  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
040F07 E3          2118*  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
040F08 C9          2119*  			RET				; at this point we'll return to the first instruction after the message
040F09             0007       include "eval.asm"
040F09             0001*  ;
040F09             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040F09             0003*  ;		Expression Evaluation & Arithmetic Module - "EVAL"
040F09             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
040F09             0005*  ; Modified By:	Dean Belfield
040F09             0006*  ; Created:	12/05/2023
040F09             0007*  ; Last Updated:	17/08/2023
040F09             0008*  ;
040F09             0009*  ; Modinfo:
040F09             0010*  ; 07/06/2023:	Modified to run in ADL mode
040F09             0011*  ; 26/06/2023:	Fixed HEX and HEXSTR
040F09             0012*  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
040F09             0013*  ; 17/08/2023:	Added binary constants
040F09             0014*  
040F09             0015*  			; .ASSUME	ADL = 1
040F09             0016*  
040F09             0017*  			; INCLUDE	"equs.inc"
040F09             0018*  			; INCLUDE "macros.inc"
040F09             0019*  			; INCLUDE "mos_api.inc"	; In MOS/src
040F09             0020*  
040F09             0021*  			; SEGMENT CODE
040F09             0022*  
040F09             0023*  			; XDEF	EXPR
040F09             0024*  			; XDEF	EXPRN
040F09             0025*  			; XDEF	EXPRI
040F09             0026*  			; XDEF	EXPRS
040F09             0027*  			; XDEF	ITEMI
040F09             0028*  			; XDEF	LOADN
040F09             0029*  			; XDEF	LOAD4
040F09             0030*  			; XDEF	CONS
040F09             0031*  			; XDEF	LOADS
040F09             0032*  			; XDEF	SFIX
040F09             0033*  			; XDEF	VAL0
040F09             0034*  			; XDEF	SEARCH
040F09             0035*  			; XDEF	SWAP
040F09             0036*  			; XDEF	TEST
040F09             0037*  			; XDEF	DECODE
040F09             0038*  			; XDEF	HEXSTR
040F09             0039*  			; XDEF	STR
040F09             0040*  			; XDEF	ZERO
040F09             0041*  			; XDEF	PUSHS
040F09             0042*  			; XDEF	POPS
040F09             0043*  			; XDEF	COMMA
040F09             0044*  			; XDEF	BRAKET
040F09             0045*  			; XDEF	NXT
040F09             0046*  			; XDEF	COUNT0
040F09             0047*  
040F09             0048*  			; XREF	ADVAL
040F09             0049*  			; XREF	FN_EX
040F09             0050*  			; XREF	POINT
040F09             0051*  			; XREF	USR
040F09             0052*  			; XREF	SYNTAX
040F09             0053*  			; XREF	ERROR_
040F09             0054*  			; XREF	CHECK
040F09             0055*  			; XREF	GETVAR
040F09             0056*  			; XREF	LISTON
040F09             0057*  			; XREF	RANGE
040F09             0058*  			; XREF	FPP
040F09             0059*  			; XREF	GETCSR
040F09             0060*  			; XREF	CHANEL
040F09             0061*  			; XREF	OSSTAT
040F09             0062*  			; XREF	OSBGET
040F09             0063*  			; XREF	LOMEM
040F09             0064*  			; XREF	HIMEM
040F09             0065*  			; XREF	PAGE_
040F09             0066*  			; XREF	TOP
040F09             0067*  			; XREF	ERL
040F09             0068*  			; XREF	ERR
040F09             0069*  			; XREF	COUNT
040F09             0070*  			; XREF	OSOPEN
040F09             0071*  			; XREF	GETEXT
040F09             0072*  			; XREF	GETPTR
040F09             0073*  			; XREF	GETIME
040F09             0074*  			; XREF	GETIMS
040F09             0075*  			; XREF	LEXAN2
040F09             0076*  			; XREF	RANDOM
040F09             0077*  			; XREF	STORE5
040F09             0078*  			; XREF	GETSCHR
040F09             0079*  			; XREF	OSRDCH
040F09             0080*  			; XREF	OSKEY
040F09             0081*  			; XREF	INKEY1
040F09             0082*  			; XREF	EXTERR
040F09             0083*  ;
040F09             0084*  ; BINARY FLOATING POINT REPRESENTATION:
040F09             0085*  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
040F09             0086*  ;     8 BIT EXCESS-128 SIGNED EXPONENT
040F09             0087*  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
040F09             0088*  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
040F09             0089*  ;
040F09             0090*  ; BINARY INTEGER REPRESENTATION:
040F09             0091*  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
040F09             0092*  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
040F09             0093*  ;
040F09             0094*  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
040F09             0095*  ;                             EXPONENT - C
040F09             0096*  ;
040F09             0097*  
040F09             0098*  ;
040F09             0099*  ; Table of addresses for functions
040F09             0100*  ;
040F09             0101*  ; FUNTOK:			EQU	8DH			; First token number
040F09             0102*  ;
040F09 EA 16 04    0103*  FUNTBL:			DW24	DECODE			; Line number
040F0C 98 13 04    0104*  			DW24	OPENIN			; OPENIN
040F0F BA 13 04    0105*  			DW24	PTR_EV			; PTR
040F12 54 13 04    0106*  			DW24	PAGEV			; PAGE
040F15 C4 13 04    0107*  			DW24	TIMEV			; TIME
040F18 40 13 04    0108*  			DW24	LOMEMV			; LOMEM
040F1B 4A 13 04    0109*  			DW24	HIMEMV			; HIMEM
040F1E 18 14 04    0110*  			DW24	ABSV			; ABS
040F21 54 14 04    0111*  			DW24	ACS			; ACS
040F24 A2 49 04    0112*  			DW24	ADVAL			; ADVAL
040F27 29 13 04    0113*  			DW24	ASC			; ASC
040F2A 4C 14 04    0114*  			DW24	ASN			; ASN
040F2D 50 14 04    0115*  			DW24	ATN			; ATN
040F30 F2 12 04    0116*  			DW24	BGET			; BGET
040F33 38 14 04    0117*  			DW24	COS			; COS
040F36 7F 13 04    0118*  			DW24	COUNTV			; COUNT
040F39 20 14 04    0119*  			DW24	DEG			; DEG
040F3C 73 13 04    0120*  			DW24	ERLV			; ERL
040F3F 79 13 04    0121*  			DW24	ERRV			; ERR
040F42 7D 14 04    0122*  			DW24	EVAL_			; EVAL
040F45 40 14 04    0123*  			DW24	EXP			; EXP
040F48 B0 13 04    0124*  			DW24	EXT			; EXT
040F4B 97 17 04    0125*  			DW24	ZERO			; FALSE
040F4E 86 1E 04    0126*  			DW24	FN_EX			; FN
040F51 10 13 04    0127*  			DW24	GET			; GET
040F54 FF 12 04    0128*  			DW24	INKEY			; INKEY
040F57 2F 15 04    0129*  			DW24	INSTR			; INSTR(
040F5A 2C 14 04    0130*  			DW24	INT_			; INT
040F5D 39 13 04    0131*  			DW24	LEN			; LEN
040F60 44 14 04    0132*  			DW24	LN			; LN
040F63 48 14 04    0133*  			DW24	LOG			; LOG
040F66 1C 14 04    0134*  			DW24	NOTK			; NOT
040F69 94 13 04    0135*  			DW24	OPENUP			; OPENUP
040F6C 91 13 04    0136*  			DW24	OPENOT			; OPENOUT
040F6F 14 14 04    0137*  			DW24	PI			; PI
040F72 FA 3E 04    0138*  			DW24	POINT			; POINT(
040F75 D1 12 04    0139*  			DW24	POS			; POS
040F78 24 14 04    0140*  			DW24	RAD			; RAD
040F7B B1 14 04    0141*  			DW24	RND			; RND
040F7E 28 14 04    0142*  			DW24	SGN			; SGN
040F81 3C 14 04    0143*  			DW24	SIN			; SIN
040F84 30 14 04    0144*  			DW24	SQR			; SQR
040F87 34 14 04    0145*  			DW24	TAN			; TAN
040F8A 5E 13 04    0146*  			DW24	TOPV			; TO(P)
040F8D 09 14 04    0147*  			DW24	TRUE			; TRUE
040F90 53 23 04    0148*  			DW24	USR			; USR
040F93 6E 14 04    0149*  			DW24	VAL			; VAL
040F96 DA 12 04    0150*  			DW24	VPOS			; VPOS
040F99 C3 15 04    0151*  			DW24	CHRS			; CHRS
040F9C CB 15 04    0152*  			DW24	GETS			; GETS
040F9F DC 15 04    0153*  			DW24	INKEYS			; INKEYS
040FA2 61 16 04    0154*  			DW24	LEFTS			; LEFTS(
040FA5 29 16 04    0155*  			DW24	MIDS			; MIDS(
040FA8 81 16 04    0156*  			DW24	RIGHTS			; RIGHTS(
040FAB 4E 17 04    0157*  			DW24	STRS			; STR$
040FAE A2 16 04    0158*  			DW24	STRING_			; STRINGS(
040FB1 E2 12 04    0159*  			DW24	EOF			; EOF
040FB4             0160*  ;
040FB4             0161*  FUNTBL_END:		EQU	$
040FB4             0162*  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
040FB4             0163*  ; TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
040FB4             0164*  ;
040FB4             0165*  ; ANDK:			EQU     80H
040FB4             0166*  ; DIVK:			EQU     81H
040FB4             0167*  ; EORK:			EQU     82H
040FB4             0168*  ; MODK:			EQU     83H
040FB4             0169*  ; ORK:			EQU     84H
040FB4             0170*  ;
040FB4 F4 13 04    0171*  SOPTBL:			DW24	SLE			; <= (STRING)
040FB7 FD 13 04    0172*  			DW24	SNE			; <>
040FBA ED 13 04    0173*  			DW24	SGE			; >=
040FBD DE 13 04    0174*  			DW24	SLT			; <
040FC0 04 14 04    0175*  			DW24	SEQ			; =
040FC3 E5 13 04    0176*  			DW24	SGT			; >
040FC6             0177*  ;
040FC6             0178*  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
040FC6             0179*  ;     Expression type is returned in A'F':
040FC6             0180*  ;        Numeric - A' bit 7=0, F' sign bit cleared.
040FC6             0181*  ;         String - A' bit 7=1, F' sign bit set.
040FC6             0182*  ; Floating-point or integer result returned in HLH'L'C
040FC6             0183*  ; Integer result denoted by C=0 and HLH'L' non-zero.
040FC6             0184*  ; String result returned in string accumulator, DE set.
040FC6             0185*  ;
040FC6             0186*  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
040FC6             0187*  ;               (2) ^
040FC6             0188*  ;               (3) * / MOD DIV
040FC6             0189*  ;               (4) + -
040FC6             0190*  ;               (5) = <> <= >= > <
040FC6             0191*  ;               (6) AND
040FC6             0192*  ;               (7) EOR OR
040FC6             0193*  
040FC6             0194*  ;
040FC6             0195*  ; Level 7: EOR and OR
040FC6             0196*  ;
040FC6 CD DF 0F 04 0197*  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
040FCA FE 82       0198*  EXPR0A:			CP      EORK            	; Is operator EOR?
040FCC 28 03       0199*  			JR      Z,EXPR0B		; Yes, so skip to next bit
040FCE FE 84       0200*  			CP      ORK			; Is operator OR
040FD0 C0          0201*  			RET     NZ			; No, so return
040FD1             0202*  ;
040FD1 CD 45 18 04 0203*  EXPR0B:			CALL    SAVE_EV            	; Save first operand
040FD5 CD DF 0F 04 0204*  			CALL    EXPR1           	; Get second operand
040FD9 CD 54 18 04 0205*  			CALL    DOIT            	; Do the operation
040FDD 18 EB       0206*  			JR      EXPR0A          	; And continue
040FDF             0207*  ;
040FDF             0208*  ; Level 6: AND
040FDF             0209*  ;
040FDF CD F4 0F 04 0210*  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
040FE3 FE 80       0211*  EXPR1A:			CP      ANDK			; Is operator AND?
040FE5 C0          0212*  			RET     NZ			; No, so return
040FE6 CD 45 18 04 0213*  			CALL    SAVE_EV			; Save first operand
040FEA CD F4 0F 04 0214*  			CALL    EXPR2			; Get second operand
040FEE CD 54 18 04 0215*  			CALL    DOIT			; Do the operation
040FF2 18 EF       0216*  			JR      EXPR1A			; And continue
040FF4             0217*  ;
040FF4             0218*  ; Level 5: Comparisons
040FF4             0219*  ;
040FF4 CD 66 10 04 0220*  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
040FF8 CD 1C 18 04 0221*  			CALL    RELOP?			; Is it ">", "=" or "<"?
040FFC C0          0222*  			RET     NZ			; No, so return
040FFD 47          0223*  			LD      B,A			; Store the first operator in B
040FFE FD 23       0224*  			INC     IY              	; Bump over operator
041000 CD 77 18 04 0225*  			CALL    NXT			;
041004 CD 1C 18 04 0226*  			CALL    RELOP?          	; Is it a compound operator?
041008 20 09       0227*  			JR      NZ,EXPR2B		; No, so skip next bit
04100A FD 23       0228*  			INC     IY			; Bump over operator
04100C B8          0229*  			CP      B			; Compare with first
04100D CA 9E 1A 04 0230*  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
041011 80          0231*  			ADD     A,B
041012 47          0232*  			LD      B,A			; B: Unique code for the compound operator
041013 78          0233*  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
041014 08          0234*  			EX      AF,AF'
041015 FA 2F 10 04 0235*  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
041019 08          0236*  			EX      AF,AF'
04101A D6 04       0237*  			SUB     4
04101C FE 3A       0238*  			CP      '>'-4
04101E 20 02       0239*  			JR      NZ,EXPR2C
041020 C6 02       0240*  			ADD     A,2
041022 CD 47 18 04 0241*  EXPR2C:			CALL    SAVE1
041026 CD 66 10 04 0242*  			CALL    EXPR3
04102A CD 54 18 04 0243*  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
04102E C9          0244*  			RET
04102F             0245*  ;
04102F 08          0246*  EXPR2S:			EX      AF,AF'			; Handle string comparisons
041030 3D          0247*  			DEC     A
041031 E6 07       0248*  			AND     7
041033 CD B8 17 04 0249*  			CALL    PUSHS           	; Save string on the stack
041037 F5          0250*  			PUSH    AF              	; Save the operator
041038 CD 66 10 04 0251*  			CALL    EXPR3           	; Get the second string
04103C 08          0252*  			EX      AF,AF'
04103D F2 3A 11 04 0253*  			JP      P,TYPE_EV_
041041 F1          0254*  			POP     AF
041042 4B          0255*  			LD      C,E             	; Length of string #2
041043 D1          0256*  			POP     DE
041044 21 00 00 00 0257*  			LD      HL,0
041048 39          0258*  			ADD     HL,SP
041049 43          0259*  			LD      B,E             	; Length of string #1
04104A D5          0260*  			PUSH    DE
04104B 11 00 4A 04 0261*  			LD      DE,ACCS
04104F EB          0262*  			EX      DE,HL
041050 CD 83 18 04 0263*  			CALL    DISPT2
041054 D1          0264*  			POP     DE
041055 EB          0265*  			EX      DE,HL
041056 7D          0266*  			LD	A,L
041057 21 00 00 00 0267*  			LD	HL,0
04105B 6F          0268*  			LD	L,A
04105C 39          0269*  			ADD     HL,SP
04105D F9          0270*  			LD      SP,HL
04105E EB          0271*  			EX      DE,HL
04105F AF          0272*  			XOR     A               	; Numeric marker
041060 4F          0273*  			LD      C,A             	; Integer marker
041061 08          0274*  			EX      AF,AF'
041062 FD 7E 00    0275*  			LD      A,(IY)
041065 C9          0276*  			RET
041066             0277*  ;
041066             0278*  ; Level 4: + and -
041066             0279*  ;
041066 CD C8 10 04 0280*  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
04106A FE 2D       0281*  EXPR3A:			CP      '-'			; Is it "-"?
04106C 28 09       0282*  			JR      Z,EXPR3B		; Yes, so skip the next bit
04106E FE 2B       0283*  			CP      '+'			; Is it "+"?
041070 C0          0284*  			RET     NZ			; No, so return
041071 08          0285*  			EX      AF,AF'			; Get the type
041072 FA 85 10 04 0286*  			JP      M,EXPR3S		; Branch here if string
041076 08          0287*  			EX      AF,AF'
041077 CD 45 18 04 0288*  EXPR3B:			CALL    SAVE_EV			; Save the first operator
04107B CD C8 10 04 0289*  			CALL    EXPR4			; Fetch the second operator
04107F CD 54 18 04 0290*  			CALL    DOIT			; Do the operation
041083 18 E5       0291*  			JR      EXPR3A			; And continue
041085             0292*  ;
041085 08          0293*  EXPR3S:			EX      AF,AF'			; Handle string concatenation
041086 FD 23       0294*  			INC     IY              	; Bump past the "+"
041088 CD B8 17 04 0295*  			CALL    PUSHS           	; Save the string on the stack
04108C CD C8 10 04 0296*  			CALL    EXPR4           	; Fetch the second operator
041090 08          0297*  			EX      AF,AF'
041091 F2 3A 11 04 0298*  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
041095 01 00 00 00 0299*  			LD	BC, 0			; Clear BC
041099 4B          0300*  			LD      C,E             	; C: Length of the second string
04109A D1          0301*  			POP     DE
04109B D5          0302*  			PUSH    DE
04109C 21 00 4A 04 0303*  			LD      HL,ACCS
0410A0 7B          0304*  			LD	A,E			;  E: Length of the first string
0410A1 11 00 4A 04 0305*  			LD      DE,ACCS
0410A5 5F          0306*  			LD	E,A 			; DE: Pointer to the end of the first string
0410A6 79          0307*  			LD      A,C
0410A7 B7          0308*  			OR      A
0410A8 28 0F       0309*  			JR      Z,EXP3S3
0410AA 6F          0310*  			LD      L,A             	; Source
0410AB 83          0311*  			ADD     A,E
0410AC 5F          0312*  			LD      E,A             	; Destination
0410AD 3E 13       0313*  			LD      A,19
0410AF DA D2 08 04 0314*  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0410B3 D5          0315*  			PUSH    DE
0410B4 1D          0316*  			DEC     E
0410B5 2D          0317*  			DEC     L
0410B6 ED B8       0318*  			LDDR                    	; Copy
0410B8 D1          0319*  			POP     DE
0410B9 D9          0320*  EXP3S3:			EXX
0410BA C1          0321*  			POP     BC
0410BB CD E5 17 04 0322*  			CALL    POPS            	; Restore from stack
0410BF D9          0323*  			EXX
0410C0 F6 80       0324*  			OR      80H             	; Flag as a string
0410C2 08          0325*  			EX      AF,AF'
0410C3 FD 7E 00    0326*  			LD      A,(IY)			; Fetch the next character
0410C6 18 A2       0327*  			JR      EXPR3A			; And continue
0410C8             0328*  ;
0410C8             0329*  ; Level 3: * / MOD DIV
0410C8             0330*  ;
0410C8 CD E9 10 04 0331*  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0410CC FE 2A       0332*  EXPR4A:			CP      '*'			; "*" is valid
0410CE 28 0B       0333*  			JR      Z,EXPR4B
0410D0 FE 2F       0334*  			CP      '/'			; "/" is valid
0410D2 28 07       0335*  			JR      Z,EXPR4B
0410D4 FE 83       0336*  			CP      MODK			; MOD token is valid
0410D6 28 03       0337*  			JR      Z,EXPR4B
0410D8 FE 81       0338*  			CP      DIVK			; DIV token is valid
0410DA C0          0339*  			RET     NZ			; And return if it is anything else
0410DB CD 45 18 04 0340*  EXPR4B:			CALL    SAVE_EV
0410DF CD E9 10 04 0341*  			CALL    EXPR5
0410E3 CD 54 18 04 0342*  			CALL    DOIT
0410E7 18 E3       0343*  			JR      EXPR4A
0410E9             0344*  ;
0410E9             0345*  ; Level 2: ^
0410E9             0346*  ;
0410E9 CD C9 11 04 0347*  EXPR5:			CALL    ITEM			; Get variable
0410ED B7          0348*  			OR      A               	; Test type
0410EE 08          0349*  			EX      AF,AF'          	; Save type
0410EF CD 77 18 04 0350*  EXPR5A:			CALL    NXT			; Skip spaces
0410F3 FE 5E       0351*  			CP      '^'			; Is the operator "^"?
0410F5 C0          0352*  			RET     NZ			; No, so return
0410F6 CD 45 18 04 0353*  			CALL    SAVE_EV			; Save first operand
0410FA CD C9 11 04 0354*  			CALL    ITEM			; Get second operand
0410FE B7          0355*  			OR      A			; Test type
0410FF 08          0356*  			EX      AF,AF'			; Save type
041100 CD 54 18 04 0357*  			CALL    DOIT			; Do the operation
041104 18 E9       0358*  			JR      EXPR5A			; And continue
041106             0359*  ;
041106             0360*  ; Evaluate a numeric expression
041106             0361*  ;
041106 CD C6 0F 04 0362*  EXPRN:			CALL    EXPR			; Evaluate expression
04110A 08          0363*  			EX      AF,AF'			; Get the type
04110B F0          0364*  			RET     P			; And return if it is a number
04110C 18 2C       0365*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
04110E             0366*  ;
04110E             0367*  ; Evaluate a fixed-point expression
04110E             0368*  ;
04110E CD C6 0F 04 0369*  EXPRI:			CALL    EXPR			; Evaluate the expression
041112 08          0370*  			EX      AF,AF'			; Get the type
041113 F2 66 14 04 0371*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
041117 18 21       0372*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041119             0373*  ;
041119             0374*  ; Evaluate a string expression
041119             0375*  ;
041119 CD C6 0F 04 0376*  EXPRS:			CALL    EXPR			; Evaluate the expression
04111D 08          0377*  			EX      AF,AF'			; Get the type
04111E F8          0378*  			RET     M			; And return if it is a string
04111F 18 19       0379*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041121             0380*  ;
041121             0381*  ; Get a numeric variable
041121             0382*  ;
041121 CD C9 11 04 0383*  ITEMN:			CALL    ITEM			; Get the variable
041125 B7          0384*  			OR      A			; Test the type
041126 F0          0385*  			RET     P			; And return if it is a number
041127 18 11       0386*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041129             0387*  ;
041129             0388*  ; Get a fixed-point variable
041129             0389*  ;
041129 CD C9 11 04 0390*  ITEMI:			CALL    ITEM			; Get the variable
04112D B7          0391*  			OR      A			; Test the type
04112E F2 66 14 04 0392*  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
041132 18 06       0393*  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
041134             0394*  ;
041134             0395*  ; Get a string variable
041134             0396*  ;
041134 CD C9 11 04 0397*  ITEMS:			CALL    ITEM			; Get the variable
041138 B7          0398*  			OR      A			; Test the type
041139 F8          0399*  			RET     M			; If it is a string, then return
04113A             0400*  ;							; Otherwise
04113A 3E 06       0401*  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
04113C C3 D2 08 04 0402*  			JP      ERROR_
041140             0403*  ;
041140             0404*  ; Evaluate a bracketed expression
041140             0405*  ;
041140 CD C6 0F 04 0406*  ITEM1:			CALL    EXPR            	; Evaluate the expression
041144 CD 36 18 04 0407*  			CALL    BRAKET			; Check for closing bracket
041148 08          0408*  			EX      AF,AF'
041149 C9          0409*  			RET
04114A             0410*  ;
04114A             0411*  ; HEX - Get hexadecimal constant.
04114A             0412*  ;   Inputs: ASCII string at (IY)
04114A             0413*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
04114A             0414*  ;           IY updated (points to delimiter)
04114A             0415*  ;
04114A CD 97 17 04 0416*  HEX:			CALL    ZERO			; Set result to 0
04114E CD FF 17 04 0417*  			CALL    HEXDIG			; Fetch the character from IY
041152 38 1B       0418*  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
041154 FD 23       0419*  HEX1:			INC     IY			; Move pointer to next character
041156 E6 0F       0420*  			AND     0FH			; Clear the top nibble
041158 06 04       0421*  			LD      B,4			; Loop counter
04115A             0422*  ;
04115A D9          0423*  HEX2:			EXX				; Shift the result left B (4) times. This makes
04115B 52 29       0424*  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
04115D D9          0425*  			EXX				; .
04115E 52 ED 6A    0426*  			ADC.S   HL,HL			; .
041161 10 F7       0427*  			DJNZ    HEX2			; And loop
041163 D9          0428*  			EXX
041164 B5          0429*  			OR      L			; OR in the digit
041165 6F          0430*  			LD      L,A
041166 D9          0431*  			EXX
041167             0432*  ;
041167 CD FF 17 04 0433*  			CALL    HEXDIG			; Fetch the next character
04116B 30 E7       0434*  			JR      NC,HEX1			; If it is a HEX digit then loop
04116D AF          0435*  			XOR     A			; Clear A
04116E C9          0436*  			RET
04116F             0437*  ;
04116F 3E 1C       0438*  BADHEX:			LD      A,28
041171 C3 D2 08 04 0439*  			JP      ERROR_          	; Error: "Bad HEX"
041175             0440*  ;
041175             0441*  ; BIN - Get binary constant.
041175             0442*  ;   Inputs: ASCII string at (IY)
041175             0443*  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
041175             0444*  ;           IY updated (points to delimiter)
041175             0445*  ;
041175 CD 97 17 04 0446*  BIN:			CALL    ZERO			; Set result to 0
041179 CD 12 18 04 0447*  			CALL	BINDIG			; Fetch the character from IY
04117D 38 13       0448*  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
04117F FD 23       0449*  BIN1:			INC	IY			; Move pointer to next character
041181 0F          0450*  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
041182 D9          0451*  			EXX				;
041183 52 ED 6A    0452*  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
041186 D9          0453*  			EXX
041187 52 ED 6A    0454*  			ADC.S	HL,HL
04118A CD 12 18 04 0455*  			CALL	BINDIG			; Fetch the next character
04118E 30 EF       0456*  			JR	NC,BIN1
041190 AF          0457*  			XOR	A			; Clear A
041191 C9          0458*  			RET
041192             0459*  ;
041192 3E 1C       0460*  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
041194 CD E9 08 04 0461*  			CALL	EXTERR
041198 42 61 64 20 0462*  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0411A3             0463*  ;
0411A3             0464*  ; MINUS - Unary minus.
0411A3             0465*  ;   Inputs: IY = text pointer
0411A3             0466*  ;  Outputs: Numeric result, same type as argument.
0411A3             0467*  ;           Result in H'L'HLC
0411A3             0468*  ;
0411A3 CD 21 11 04 0469*  MINUS:			CALL    ITEMN			; Get the numeric argument
0411A7 0D          0470*  MINUS0:			DEC     C			; Check exponent (C)
0411A8 0C          0471*  			INC     C			; If it is zero, then it's either a FP zero or an integer
0411A9 28 06       0472*  			JR      Z,NEGATE_EV        	; So do an integer negation
0411AB             0473*  ;
0411AB 7C          0474*  			LD      A,H			; Do a FP negation by
0411AC EE 80       0475*  			XOR     80H             	; Toggling the sign bit (H)
0411AE 67          0476*  			LD      H,A
0411AF AF          0477*  			XOR     A               	; Numeric marker
0411B0 C9          0478*  			RET
0411B1             0479*  ;
0411B1 D9          0480*  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0411B2 7C          0481*  			LD      A,H			; First do a one's complement by negating all the bytes
0411B3 2F          0482*  			CPL
0411B4 67          0483*  			LD      H,A
0411B5 7D          0484*  			LD      A,L
0411B6 2F          0485*  			CPL
0411B7 6F          0486*  			LD      L,A
0411B8 D9          0487*  			EXX
0411B9 7C          0488*  			LD      A,H
0411BA 2F          0489*  			CPL
0411BB 67          0490*  			LD      H,A
0411BC 7D          0491*  			LD      A,L
0411BD 2F          0492*  			CPL
0411BE 6F          0493*  			LD      L,A
0411BF D9          0494*  ADD1:			EXX				; Then add 1
0411C0 23          0495*  			INC     HL
0411C1 7C          0496*  			LD      A,H
0411C2 B5          0497*  			OR      L
0411C3 D9          0498*  			EXX
0411C4 3E 00       0499*  			LD      A,0             	; Numeric marker
0411C6 C0          0500*  			RET     NZ
0411C7 23          0501*  			INC     HL
0411C8 C9          0502*  			RET
0411C9             0503*  ;
0411C9             0504*  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0411C9             0505*  ; Item type is returned in A:  Bit 7=0 numeric.
0411C9             0506*  ;                              Bit 7=1 string.
0411C9             0507*  ; Numeric item returned in HLH'L'C.
0411C9             0508*  ; String item returned in string accumulator,
0411C9             0509*  ;   DE addresses byte after last (E=length).
0411C9             0510*  ;
0411C9 CD 80 24 04 0511*  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0411CD CD 77 18 04 0512*  			CALL    NXT			; Skip spaces
0411D1 FD 23       0513*  			INC     IY			; Move to the prefix character
0411D3 FE 26       0514*  			CP      '&'			; If `&`
0411D5 CA 4A 11 04 0515*  			JP      Z,HEX           	; Then get a HEX constant
0411D9 FE 25       0516*  			CP	'%'			; If '%'
0411DB 28 98       0517*  			JR	Z,BIN			; Then get a BINARY constant
0411DD FE 2D       0518*  			CP      '-'			; If `-`
0411DF 28 C2       0519*  			JR      Z,MINUS         	; Then get a negative number
0411E1 FE 2B       0520*  			CP      '+'			; If `+`
0411E3 CA 21 11 04 0521*  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0411E7 FE 28       0522*  			CP      '('			; If `(`
0411E9 CA 40 11 04 0523*  			JP      Z,ITEM1         	; Start of a bracketed expression
0411ED FE 22       0524*  			CP      34			; If `"`
0411EF 28 7A       0525*  			JR      Z,CONS          	; Start of a string constant
0411F1 FE C6       0526*  			CP      TCMD			; Is it out of range of the function table?
0411F3 D2 9E 1A 04 0527*  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0411F7 FE 8D       0528*  			CP      FUNTOK			; If it is in range, then
0411F9 D2 8A 18 04 0529*  			JP      NC,DISPAT       	; It's a function
0411FD FD 2B       0530*  			DEC     IY
0411FF FE 3A       0531*  			CP      ':'
041201 30 0C       0532*  			JR      NC,ITEM2		; VARIABLE?
041203 FE 30       0533*  			CP      '0'
041205 D2 92 12 04 0534*  			JP      NC,CON			; NUMERIC CONSTANT
041209 FE 2E       0535*  			CP      '.'
04120B CA 92 12 04 0536*  			JP      Z,CON			; NUMERIC CONSTANT
04120F CD AC 0B 04 0537*  ITEM2:			CALL    GETVAR			; VARIABLE
041213 20 37       0538*  			JR      NZ,NOSUCH
041215 B7          0539*  			OR      A
041216 FA A4 12 04 0540*  			JP      M,LOADS			; STRING VARIABLE
04121A B7          0541*  LOADN:			OR      A
04121B 28 20       0542*  			JR      Z,LOAD1			; BYTE VARIABLE
04121D 0E 00       0543*  			LD      C,0
04121F CB 47       0544*  			BIT     0,A
041221 28 03       0545*  			JR      Z,LOAD4			; INTEGER VARIABLE
041223 DD 4E 04    0546*  LOAD5:			LD      C,(IX+4)
041226 D9          0547*  LOAD4:			EXX
041227 21 00 00 00 0548*  			LD	HL, 0			; TODO: Optimise
04122B DD 6E 00    0549*  			LD      L,(IX+0)
04122E DD 66 01    0550*  			LD      H,(IX+1)
041231 D9          0551*  			EXX
041232 21 00 00 00 0552*  			LD	HL, 0			; TODO: Optimise
041236 DD 6E 02    0553*  			LD      L,(IX+2)
041239 DD 66 03    0554*  			LD      H,(IX+3)
04123C C9          0555*  			RET
04123D             0556*  ;
04123D 21 00 00 00 0557*  LOAD1:			LD      HL,0
041241 D9          0558*  			EXX
041242 21 00 00 00 0559*  			LD      HL,0			; TODO: Optimise
041246 DD 6E 00    0560*  			LD      L,(IX+0)
041249 D9          0561*  			EXX
04124A 4C          0562*  			LD      C,H
04124B C9          0563*  			RET
04124C             0564*  ;
04124C DA 9E 1A 04 0565*  NOSUCH:			JP      C,SYNTAX
041250 3A 40 4D 04 0566*  			LD      A,(LISTON)
041254 CB 6F       0567*  			BIT     5,A
041256 3E 1A       0568*  			LD      A,26
041258 20 26       0569*  			JR      NZ,ERROR0_EV		; Throw "No such variable"
04125A FD 23       0570*  NOS1:			INC     IY
04125C CD E1 0D 04 0571*  			CALL    RANGE
041260 30 F8       0572*  			JR      NC,NOS1
041262 DD 21 40 30 0573*  			LD      IX,PC
       11          
041267 AF          0574*  			XOR     A
041268 4F          0575*  			LD      C,A
041269 18 BB       0576*  			JR      LOAD4
04126B             0577*  ;
04126B             0578*  ;CONS - Get string constant from ASCII string.
04126B             0579*  ;   Inputs: ASCII string at (IY)
04126B             0580*  ;  Outputs: Result in string accumulator.
04126B             0581*  ;           D = MS byte of ACCS, E = string length
04126B             0582*  ;           A7 = 1 (string marker)
04126B             0583*  ;           IY updated
04126B             0584*  ;
04126B 11 00 4A 04 0585*  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
04126F FD 7E 00    0586*  CONS3:			LD      A,(IY)			; Fetch the first character and
041272 FD 23       0587*  			INC     IY			; Increment the pointer
041274 FE 22       0588*  			CP      '"'			; Check for start quote
041276 28 0C       0589*  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
041278             0590*  ;
041278 12          0591*  CONS1:			LD      (DE),A			; Store the character in the string accumulator
041279 1C          0592*  			INC     E			; Increment the string accumulator pointer
04127A FE 0D       0593*  			CP      CR			; Is it CR
04127C 20 F1       0594*  			JR      NZ,CONS3		; No, so keep looping
04127E             0595*  ;
04127E 3E 09       0596*  			LD      A,9
041280 C3 D2 08 04 0597*  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
041284             0598*  ;
041284 FD 7E 00    0599*  CONS2:			LD      A,(IY)			; Fetch the next character
041287 FE 22       0600*  			CP      '"'			; Check for end quote?
041289 FD 23       0601*  			INC     IY			; Increment the pointer
04128B 28 EB       0602*  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
04128D FD 2B       0603*  			DEC     IY			;
04128F 3E 80       0604*  			LD      A,80H           	; String marker
041291 C9          0605*  			RET
041292             0606*  ;
041292             0607*  ;CON - Get unsigned numeric constant from ASCII string.
041292             0608*  ;   Inputs: ASCII string at (IY).
041292             0609*  ;  Outputs: Variable-type result in HLH'L'C
041292             0610*  ;           IY updated (points to delimiter)
041292             0611*  ;           A7 = 0 (numeric marker)
041292             0612*  ;
041292 FD E5       0613*  CON:			PUSH    IY
041294 DD E1       0614*  			POP     IX
041296 3E 24       0615*  			LD      A,36
041298 CD A1 2E 04 0616*  			CALL    FPP
04129C 38 E2       0617*  			JR      C,ERROR0_EV
04129E DD E5       0618*  			PUSH    IX
0412A0 FD E1       0619*  			POP     IY
0412A2 AF          0620*  			XOR     A
0412A3 C9          0621*  			RET
0412A4             0622*  ;
0412A4 11 00 4A 04 0623*  LOADS:			LD      DE,ACCS			; Where to store the string
0412A8 1F          0624*  			RRA
0412A9 30 1A       0625*  			JR      NC,LOADS2       	; Skip if it is a fixed string
0412AB             0626*  ;
0412AB D9          0627*  			EXX				; This block was a call to LOAD4
0412AC DD 6E 00    0628*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0412AF DD 66 01    0629*  			LD      H,(IX+1)		; The maximum original string length
0412B2 D9          0630*  			EXX
0412B3 DD 27 02    0631*  			LD	HL,(IX+2)		; Address of the string (24-bit)
0412B6             0632*  ;
0412B6 D9          0633*  			EXX
0412B7 7D          0634*  			LD      A,L
0412B8 D9          0635*  			EXX
0412B9 B7          0636*  			OR      A
0412BA 01 00 00 00 0637*  			LD	BC,0			; BC: Number of bytes to copy
0412BE 4F          0638*  			LD      C,A
0412BF 3E 80       0639*  			LD      A,80H           	; String marker
0412C1 C8          0640*  			RET     Z
0412C2 ED B0       0641*  			LDIR
0412C4 C9          0642*  			RET
0412C5 7E          0643*  LOADS2:			LD      A,(HL)
0412C6 12          0644*  			LD      (DE),A
0412C7 23          0645*  			INC     HL
0412C8 FE 0D       0646*  			CP      CR
0412CA 3E 80       0647*  			LD      A,80H           	; String marker
0412CC C8          0648*  			RET     Z
0412CD 1C          0649*  			INC     E
0412CE 20 F5       0650*  			JR      NZ,LOADS2
0412D0 C9          0651*  			RET                     	; Return null string
0412D1             0652*  ;
0412D1             0653*  ;VARIABLE-TYPE FUNCTIONS:
0412D1             0654*  ;
0412D1             0655*  ;Result returned in HLH'L'C (floating point)
0412D1             0656*  ;Result returned in HLH'L' (C=0) (integer)
0412D1             0657*  ;Result returned in string accumulator & DE (string)
0412D1             0658*  ;All registers destroyed.
0412D1             0659*  ;IY (text pointer) updated.
0412D1             0660*  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0412D1             0661*  ;
0412D1             0662*  ;POS - horizontal cursor position.
0412D1             0663*  ;VPOS - vertical cursor position.
0412D1             0664*  ;EOF - return status of file.
0412D1             0665*  ;BGET - read byte from file.
0412D1             0666*  ;INKEY - as GET but wait only n centiseconds.
0412D1             0667*  ;GET - wait for keypress and return ASCII value.
0412D1             0668*  ;GET(n) - input from Z80 port n.
0412D1             0669*  ;ASC - ASCII value of string.
0412D1             0670*  ;LEN - length of string.
0412D1             0671*  ;LOMEM - location of dynamic variables.
0412D1             0672*  ;HIMEM - top of available RAM.
0412D1             0673*  ;PAGE - start of current text page.
0412D1             0674*  ;TOP - address of first free byte after program.
0412D1             0675*  ;ERL - line number where last error occurred.
0412D1             0676*  ;ERR - number of last error.
0412D1             0677*  ;COUNT - number of printing characters since CR.
0412D1             0678*  ;Results are integer numeric.
0412D1             0679*  ;
0412D1 CD A6 44 04 0680*  POS:			CALL    GETCSR			; Return the horizontal cursor position
0412D5 EB          0681*  			EX      DE,HL			;  L: The X cursor position
0412D6 C3 85 13 04 0682*  			JP      COUNT1			; Return an 8-bit value
0412DA             0683*  ;
0412DA CD A6 44 04 0684*  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0412DE C3 85 13 04 0685*  			JP      COUNT1			; Return an 8-bit value
0412E2             0686*  ;
0412E2 CD B7 26 04 0687*  EOF:			CALL    CHANEL			; Check for EOF
0412E6 CD 2F 49 04 0688*  			CALL    OSSTAT
0412EA CA 09 14 04 0689*  			JP      Z,TRUE			; Yes, so return true
0412EE C3 97 17 04 0690*  			JP      ZERO			; Otherwise return false (zero)
0412F2             0691*  ;
0412F2 CD B7 26 04 0692*  BGET:			CALL    CHANEL          	; Channel number
0412F6 CD 1E 49 04 0693*  			CALL    OSBGET
0412FA 6F          0694*  			LD      L,A
0412FB C3 83 13 04 0695*  			JP      COUNT0			; Return an 8-bit value
0412FF             0696*  ;
0412FF CD 29 11 04 0697*  INKEY:			CALL    ITEMI			; Get the argument
041303 CB 7C       0698*  			BIT	7, H			; Check the sign
041305 D9          0699*  			EXX				; HL: The argument
041306 C2 EF 15 04 0700*  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
04130A CD E1 15 04 0701*  			CALL	INKEY0 			; Do INKEY(n)
04130E 18 1D       0702*  			JR      ASC0			; Return a numeric value
041310             0703*  ;
041310 CD 77 18 04 0704*  GET:			CALL    NXT			; Skip whitespace
041314 FE 28       0705*  			CP      '('			; Is it GET(
041316 20 0B       0706*  			JR      NZ,GET0			; No, so get a keyboard character
041318 CD 29 11 04 0707*  			CALL    ITEMI           	; Yes, so fetch the port address
04131C D9          0708*  			EXX
04131D 44          0709*  			LD      B,H			; BC: The port address
04131E 4D          0710*  			LD      C,L
04131F ED 68       0711*  			IN      L,(C)           	;  L: Input from port BC
041321 18 60       0712*  			JR      COUNT0			; Return an 8-bit value
041323             0713*  ;
041323 CD CB 15 04 0714*  GET0:			CALL    GETS			; Read the keyboard character
041327 18 0A       0715*  			JR      ASC1			; And return the value
041329             0716*  ;
041329 CD 34 11 04 0717*  ASC:			CALL    ITEMS			; Get the string argument argument
04132D AF          0718*  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
04132E BB          0719*  			CP      E			; Is the pointer 0
04132F CA 09 14 04 0720*  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
041333 2A 00 4A 04 0721*  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
041337 18 4A       0722*  			JR      COUNT0			; An 8-bit value
041339             0723*  ;
041339 CD 34 11 04 0724*  LEN:			CALL    ITEMS			; Get the string argument
04133D EB          0725*  			EX      DE,HL			; HL: Pointer into ACCS
04133E 18 43       0726*  			JR      COUNT0			; Return L
041340             0727*  ;
041340 2A 1A 4D 04 0728*  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
041344 3A 1C 4D 04 0729*  			LD	A, (LOMEM+2)
041348 18 41       0730*  			JR      COUNT2			; A 24-bit value
04134A             0731*  ;
04134A 2A 20 4D 04 0732*  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
04134E 3A 22 4D 04 0733*  			LD	A, (HIMEM+2)
041352 18 37       0734*  			JR      COUNT2			; A 24-bit value
041354             0735*  ;
041354 2A 14 4D 04 0736*  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
041358 3A 16 4D 04 0737*  			LD	A, (PAGE_+2)		; A 24-bit value
04135C 18 2D       0738*  			JR      COUNT2
04135E             0739*  ;
04135E FD 7E 00    0740*  TOPV:			LD      A,(IY)			; Return the TOP system variable
041361 FD 23       0741*  			INC     IY              	; Skip "P"
041363 FE 50       0742*  			CP      'P'
041365 C2 9E 1A 04 0743*  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
041369 2A 17 4D 04 0744*  			LD      HL,(TOP)
04136D 3A 19 4D 04 0745*  			LD	A, (TOP+2)
041371 18 18       0746*  			JR      COUNT2
041373             0747*  ;
041373 2A 33 4D 04 0748*  ERLV:			LD      HL,(ERL)		; Return the error line
041377 18 0C       0749*  			JR      COUNT1			; A 16-bit value
041379             0750*  ;
041379 2A 3F 4D 04 0751*  ERRV:			LD      HL,(ERR)		; Return the error value
04137D 18 04       0752*  			JR      COUNT0			; An 8-bit value
04137F             0753*  ;
04137F 2A 3D 4D 04 0754*  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
041383             0755*  
041383 26 00       0756*  COUNT0:			LD      H,0			; Return L
041385 D9          0757*  COUNT1:			EXX				; Return HL
041386 AF          0758*  			XOR     A
041387 4F          0759*  			LD      C,A             	; Integer marker
041388 67          0760*  			LD      H,A
041389 6F          0761*  			LD      L,A
04138A C9          0762*  			RET
04138B D9          0763*  COUNT2:			EXX
04138C 6F          0764*  			LD	L,A
04138D AF          0765*  			XOR	A
04138E 4F          0766*  			LD	C,A			; Integer marker
04138F 67          0767*  			LD	H,A
041390 C9          0768*  			RET
041391             0769*  ;
041391             0770*  ;OPENIN - Open a file for reading.
041391             0771*  ;OPENOT - Open a file for writing.
041391             0772*  ;OPENUP - Open a file for reading or writing.
041391             0773*  ;Result is integer channel number (0 if error)
041391             0774*  ;
041391 AF          0775*  OPENOT:			XOR     A			; Open for writing
041392 18 06       0776*  			JR	OPENIN_1
041394             0777*  ;
041394 3E 02       0778*  OPENUP:			LD      A,2			; Open for reading / writing
041396 18 02       0779*  			JR	OPENIN_1
041398             0780*  ;
041398 3E 01       0781*  OPENIN:			LD      A,1			; Open for reading
04139A             0782*  ;
04139A F5          0783*  OPENIN_1:		PUSH    AF              	; Save OPEN type
04139B CD 34 11 04 0784*  			CALL    ITEMS           	; Fetch the filename
04139F 3E 0D       0785*  			LD      A,CR
0413A1 12          0786*  			LD      (DE),A
0413A2 F1          0787*  			POP     AF              	; Restore the OPEN type
0413A3 C6 FF       0788*  			ADD     A,-1            	; Affect the flags
0413A5 21 00 4A 04 0789*  			LD      HL,ACCS
0413A9 CD 07 49 04 0790*  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0413AD 6F          0791*  			LD      L,A			; L: Channel number
0413AE 18 D3       0792*  			JR      COUNT0			; Return channel number to BASIC
0413B0             0793*  ;
0413B0             0794*  ;EXT - Return length of file.
0413B0             0795*  ;PTR_EV - Return current file pointer.
0413B0             0796*  ;Results are integer numeric.
0413B0             0797*  ;
0413B0 CD B7 26 04 0798*  EXT:			CALL    CHANEL
0413B4 CD 65 49 04 0799*  			CALL    GETEXT
0413B8 18 15       0800*  			JR      TIME0
0413BA             0801*  ;
0413BA CD B7 26 04 0802*  PTR_EV:			CALL    CHANEL
0413BE CD 39 49 04 0803*  			CALL    GETPTR
0413C2 18 0B       0804*  			JR      TIME0
0413C4             0805*  ;
0413C4             0806*  ;TIME - Return current value of elapsed time.
0413C4             0807*  ;Result is integer numeric.
0413C4             0808*  ;
0413C4 FD 7E 00    0809*  TIMEV:			LD      A,(IY)
0413C7 FE 24       0810*  			CP      '$'
0413C9 28 0A       0811*  			JR      Z,TIMEVS
0413CB CD 86 44 04 0812*  			CALL    GETIME
0413CF D5          0813*  TIME0:			PUSH    DE
0413D0 D9          0814*  			EXX
0413D1 E1          0815*  			POP     HL
0413D2 AF          0816*  			XOR     A
0413D3 4F          0817*  			LD      C,A
0413D4 C9          0818*  			RET
0413D5             0819*  ;
0413D5             0820*  ;TIME$ - Return date/time string.
0413D5             0821*  ;Result is string
0413D5             0822*  ;
0413D5 FD 23       0823*  TIMEVS:			INC     IY              ;SKIP $
0413D7 CD 7E 49 04 0824*  			CALL    GETIMS
0413DB 3E 80       0825*  			LD      A,80H           ;MARK STRING
0413DD C9          0826*  			RET
0413DE             0827*  ;
0413DE             0828*  ;String comparison:
0413DE             0829*  ;
0413DE CD 93 17 04 0830*  SLT:			CALL    SCP
0413E2 D0          0831*  			RET     NC
0413E3 18 24       0832*  			JR      TRUE
0413E5             0833*  ;
0413E5 CD 93 17 04 0834*  SGT:			CALL    SCP
0413E9 C8          0835*  			RET     Z
0413EA D8          0836*  			RET     C
0413EB 18 1C       0837*  			JR      TRUE
0413ED             0838*  ;
0413ED CD 93 17 04 0839*  SGE:			CALL    SCP
0413F1 D8          0840*  			RET     C
0413F2 18 15       0841*  			JR      TRUE
0413F4             0842*  ;
0413F4 CD 93 17 04 0843*  SLE:			CALL    SCP
0413F8 28 0F       0844*  			JR      Z,TRUE
0413FA D0          0845*  			RET     NC
0413FB 18 0C       0846*  			JR      TRUE
0413FD             0847*  ;
0413FD CD 93 17 04 0848*  SNE:			CALL    SCP
041401 C8          0849*  			RET     Z
041402 18 05       0850*  			JR      TRUE
041404             0851*  ;
041404 CD 93 17 04 0852*  SEQ:			CALL    SCP
041408 C0          0853*  			RET     NZ
041409 3E FF       0854*  TRUE:			LD      A,-1
04140B D9          0855*  			EXX
04140C 67          0856*  			LD      H,A
04140D 6F          0857*  			LD      L,A
04140E D9          0858*  			EXX
04140F 67          0859*  			LD      H,A
041410 6F          0860*  			LD      L,A
041411 3C          0861*  			INC     A
041412 4F          0862*  			LD      C,A
041413 C9          0863*  			RET
041414             0864*  ;
041414             0865*  ;PI - Return PI (3.141592654)
041414             0866*  ;Result is floating-point numeric.
041414             0867*  ;
041414 3E 23       0868*  PI:			LD      A,35
041416 18 44       0869*  			JR      FPP1
041418             0870*  ;
041418             0871*  ;ABS - Absolute value
041418             0872*  ;Result is numeric, variable type.
041418             0873*  ;
041418 3E 10       0874*  ABSV:			LD      A,16
04141A 18 3A       0875*  			JR      FPPN
04141C             0876*  ;
04141C             0877*  ;NOT - Complement integer.
04141C             0878*  ;Result is integer numeric.
04141C             0879*  ;
04141C 3E 1A       0880*  NOTK:			LD      A,26
04141E 18 36       0881*  			JR      FPPN
041420             0882*  ;
041420             0883*  ;DEG - Convert radians to degrees
041420             0884*  ;Result is floating-point numeric.
041420             0885*  ;
041420 3E 15       0886*  DEG:			LD      A,21
041422 18 32       0887*  			JR      FPPN
041424             0888*  ;
041424             0889*  ;RAD - Convert degrees to radians
041424             0890*  ;Result is floating-point numeric.
041424             0891*  ;
041424 3E 1B       0892*  RAD:			LD      A,27
041426 18 2E       0893*  			JR      FPPN
041428             0894*  ;
041428             0895*  ;SGN - Return -1, 0 or +1
041428             0896*  ;Result is integer numeric.
041428             0897*  ;
041428 3E 1C       0898*  SGN:			LD      A,28
04142A 18 2A       0899*  			JR      FPPN
04142C             0900*  ;
04142C             0901*  ;INT - Floor function
04142C             0902*  ;Result is integer numeric.
04142C             0903*  ;
04142C 3E 17       0904*  INT_:			LD      A,23
04142E 18 26       0905*  			JR      FPPN
041430             0906*  ;
041430             0907*  ;SQR - square root
041430             0908*  ;Result is floating-point numeric.
041430             0909*  ;
041430 3E 1E       0910*  SQR:			LD      A,30
041432 18 22       0911*  			JR      FPPN
041434             0912*  ;
041434             0913*  ;TAN - Tangent function
041434             0914*  ;Result is floating-point numeric.
041434             0915*  ;
041434 3E 1F       0916*  TAN:			LD      A,31
041436 18 1E       0917*  			JR      FPPN
041438             0918*  ;
041438             0919*  ;COS - Cosine function
041438             0920*  ;Result is floating-point numeric.
041438             0921*  ;
041438 3E 14       0922*  COS:			LD      A,20
04143A 18 1A       0923*  			JR      FPPN
04143C             0924*  ;
04143C             0925*  ;SIN - Sine function
04143C             0926*  ;Result is floating-point numeric.
04143C             0927*  ;
04143C 3E 1D       0928*  SIN:			LD      A,29
04143E 18 16       0929*  			JR      FPPN
041440             0930*  ;
041440             0931*  ;EXP - Exponential function
041440             0932*  ;Result is floating-point numeric.
041440             0933*  ;
041440 3E 16       0934*  EXP:			LD      A,22
041442 18 12       0935*  			JR      FPPN
041444             0936*  ;
041444             0937*  ;LN - Natural log.
041444             0938*  ;Result is floating-point numeric.
041444             0939*  ;
041444 3E 18       0940*  LN:			LD      A,24
041446 18 0E       0941*  			JR      FPPN
041448             0942*  ;
041448             0943*  ;LOG - base-10 logarithm.
041448             0944*  ;Result is floating-point numeric.
041448             0945*  ;
041448 3E 19       0946*  LOG:			LD      A,25
04144A 18 0A       0947*  			JR      FPPN
04144C             0948*  ;
04144C             0949*  ;ASN - Arc-sine
04144C             0950*  ;Result is floating-point numeric.
04144C             0951*  ;
04144C 3E 12       0952*  ASN:			LD      A,18
04144E 18 06       0953*  			JR      FPPN
041450             0954*  ;
041450             0955*  ;ATN - arc-tangent
041450             0956*  ;Result is floating-point numeric.
041450             0957*  ;
041450 3E 13       0958*  ATN:			LD      A,19
041452 18 02       0959*  			JR      FPPN
041454             0960*  ;
041454             0961*  ;ACS - arc-cosine
041454             0962*  ;Result is floating point numeric.
041454             0963*  ;
041454 3E 11       0964*  ACS:			LD      A,17
041456 F5          0965*  FPPN:			PUSH    AF
041457 CD 21 11 04 0966*  			CALL    ITEMN
04145B F1          0967*  			POP     AF
04145C CD A1 2E 04 0968*  FPP1:			CALL    FPP
041460 DA D2 08 04 0969*  			JP      C,ERROR_
041464 AF          0970*  			XOR     A
041465 C9          0971*  			RET
041466             0972*  ;
041466             0973*  ;SFIX - Convert to fixed-point notation
041466             0974*  ;
041466 3E 26       0975*  SFIX:			LD      A,38
041468 18 F2       0976*  			JR      FPP1
04146A             0977*  ;
04146A             0978*  ;SFLOAT - Convert to floating-point notation
04146A             0979*  ;
04146A 3E 27       0980*  SFLOAT:			LD      A,39
04146C 18 EE       0981*  			JR      FPP1
04146E             0982*  ;
04146E             0983*  ;VAL - Return numeric value of string.
04146E             0984*  ;Result is variable type numeric.
04146E             0985*  ;
04146E CD 34 11 04 0986*  VAL:			CALL    ITEMS
041472 AF          0987*  VAL0:			XOR     A
041473 12          0988*  			LD      (DE),A
041474 DD 21 00 4A 0989*  			LD      IX,ACCS
       04          
041479 3E 24       0990*  			LD      A,36
04147B 18 DF       0991*  			JR      FPP1
04147D             0992*  ;
04147D             0993*  ;EVAL - Pass string to expression evaluator.
04147D             0994*  ;Result is variable type (numeric or string).
04147D             0995*  ;
04147D CD 34 11 04 0996*  EVAL_:			CALL    ITEMS
041481 3E 0D       0997*  			LD      A,CR
041483 12          0998*  			LD      (DE),A
041484 FD E5       0999*  			PUSH    IY
041486 11 00 4A 04 1000*  			LD      DE,ACCS
04148A FD 21 00 4A 1001*  			LD      IY,ACCS
       04          
04148F 0E 00       1002*  			LD      C,0
041491 CD 11 0E 04 1003*  			CALL    LEXAN2          ;TOKENISE
041495 12          1004*  			LD      (DE),A
041496 13          1005*  			INC     DE
041497 AF          1006*  			XOR     A
041498 CD B8 17 04 1007*  			CALL    PUSHS           ;PUT ON STACK
04149C FD 21 03 00 1008*  			LD      IY,SIZEW	;WAS 2
       00          
0414A1 FD 39       1009*  			ADD     IY,SP
0414A3 CD C6 0F 04 1010*  			CALL    EXPR
0414A7 FD E1       1011*  			POP     IY
0414A9 FD 39       1012*  			ADD     IY,SP
0414AB FD F9       1013*  			LD      SP,IY           ;ADJUST STACK POINTER
0414AD FD E1       1014*  			POP     IY
0414AF 08          1015*  			EX      AF,AF'
0414B0 C9          1016*  			RET
0414B1             1017*  ;
0414B1             1018*  ;RND - Random number function.
0414B1             1019*  ; RND gives random integer 0-&FFFFFFFF
0414B1             1020*  ; RND(-n) seeds random number & returns -n.
0414B1             1021*  ; RND(0) returns last value in RND(1) form.
0414B1             1022*  ; RND(1) returns floating-point 0-0.99999999.
0414B1             1023*  ; RND(n) returns random integer 1-n.
0414B1             1024*  ;
0414B1 DD 21 38 4D 1025*  RND:			LD      IX,RANDOM
       04          
0414B6 CD 77 18 04 1026*  			CALL    NXT
0414BA FE 28       1027*  			CP      '('
0414BC 28 20       1028*  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0414BE CD 23 12 04 1029*  			CALL    LOAD5
0414C2 CB 19       1030*  RND1:			RR      C
0414C4 06 20       1031*  			LD      B,32
0414C6 D9          1032*  RND2:			EXX                     ;CALCULATE NEXT
0414C7 52 ED 6A    1033*  			ADC.S   HL,HL
0414CA D9          1034*  			EXX
0414CB 52 ED 6A    1035*  			ADC.S   HL,HL
0414CE CB 5D       1036*  			BIT     3,L
0414D0 28 01       1037*  			JR      Z,RND3
0414D2 3F          1038*  			CCF
0414D3 10 F1       1039*  RND3:			DJNZ    RND2
0414D5 CB 11       1040*  RND4:			RL      C               ;SAVE CARRY
0414D7 CD 0C 24 04 1041*  			CALL    STORE5          ;STORE NEW NUMBER
0414DB AF          1042*  			XOR     A
0414DC 4F          1043*  			LD      C,A
0414DD C9          1044*  			RET
0414DE CD 29 11 04 1045*  RND5:			CALL    ITEMI
0414E2 DD 21 38 4D 1046*  			LD      IX,RANDOM
       04          
0414E7 CB 7C       1047*  			BIT     7,H             ;NEGATIVE?
0414E9 37          1048*  			SCF
0414EA 20 E9       1049*  			JR      NZ,RND4         ;SEED
0414EC CD E3 16 04 1050*  			CALL    TEST
0414F0 F5          1051*  			PUSH    AF
0414F1 CD DB 16 04 1052*  			CALL    SWAP
0414F5 D9          1053*  			EXX
0414F6 CD 23 12 04 1054*  			CALL    LOAD5
0414FA C4 C2 14 04 1055*  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0414FE D9          1056*  			EXX                     ;SCRAMBLE (CARE!)
0414FF 0E 7F       1057*  			LD      C,7FH
041501 CB 7C       1058*  RND6:			BIT     7,H             ;FLOAT
041503 20 0A       1059*  			JR      NZ,RND7
041505 D9          1060*  			EXX
041506 52 29       1061*  			ADD.S   HL,HL
041508 D9          1062*  			EXX
041509 52 ED 6A    1063*  			ADC.S   HL,HL
04150C 0D          1064*  			DEC     C
04150D 20 F2       1065*  			JR      NZ,RND6
04150F CB BC       1066*  RND7:			RES     7,H             ;POSITIVE 0-0.999999
041511 F1          1067*  			POP     AF
041512 C8          1068*  			RET     Z               ;ZERO ARGUMENT
041513 D9          1069*  			EXX
041514 7B          1070*  			LD      A,E
041515 3D          1071*  			DEC     A
041516 B2          1072*  			OR      D
041517 D9          1073*  			EXX
041518 B3          1074*  			OR      E
041519 B2          1075*  			OR      D
04151A C8          1076*  			RET     Z               ;ARGUMENT=1
04151B 06 00       1077*  			LD      B,0             ;INTEGER MARKER
04151D 3E 0A       1078*  			LD      A,10
04151F CD A1 2E 04 1079*  			CALL    FPP             ;MULTIPLY
041523 DA D2 08 04 1080*  			JP      C,ERROR_
041527 CD 66 14 04 1081*  			CALL    SFIX
04152B C3 BF 11 04 1082*  			JP      ADD1
04152F             1083*  ;
04152F             1084*  ; INSTR - String search.
04152F             1085*  ; Result is integer numeric.
04152F             1086*  ;
04152F CD 25 18 04 1087*  INSTR:			CALL    EXPRSC			; Get the first string expression
041533 CD B8 17 04 1088*  			CALL    PUSHS           	; Push the string onto the stack
041537 CD 19 11 04 1089*  			CALL    EXPRS           	; Get the second string expression
04153B C1          1090*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
04153C 21 00 00 00 1091*  			LD      HL,0
041540 39          1092*  			ADD     HL,SP           	; HL: Pointer to main string
041541 C5          1093*  			PUSH    BC              	;  C: Main string length
041542 43          1094*  			LD      B,E             	;  B: Sub-string length
041543 CD 77 18 04 1095*  			CALL    NXT			; Skip whitespace
041547 FE 2C       1096*  			CP      ','			; Check if there is a comma for the third parameter
041549 3E 00       1097*  			LD      A,0			;  A: Default start position in string
04154B 20 1A       1098*  			JR      NZ,INSTR1		; No, so skip the next bit
04154D FD 23       1099*  			INC     IY              	; Skip the comma
04154F C5          1100*  			PUSH    BC              	; Save the lengths
041550 E5          1101*  			PUSH    HL              	; Save the pointer to the main string
041551 CD B8 17 04 1102*  			CALL    PUSHS			; Push the string onto the stack
041555 CD 0E 11 04 1103*  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
041559 C1          1104*  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
04155A CD E5 17 04 1105*  			CALL    POPS			; Pop the string off the stack
04155E E1          1106*  			POP     HL              	; Restore the pointer to the main string
04155F C1          1107*  			POP     BC              	; Restore the lengths
041560 D9          1108*  			EXX
041561 7D          1109*  			LD      A,L			; A: The start position in the  string
041562 D9          1110*  			EXX
041563 B7          1111*  			OR      A			; Set the flags
041564 28 01       1112*  			JR      Z,INSTR1		; If it is zero, then skip
041566 3D          1113*  			DEC     A
041567 11 00 4A 04 1114*  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
04156B CD 89 15 04 1115*  			CALL    SEARCH			; Do the search
04156F D1          1116*  			POP     DE
041570 28 03       1117*  			JR      Z,INSTR2        	; NB: Carry cleared
041572 ED 62       1118*  			SBC     HL,HL
041574 39          1119*  			ADD     HL,SP
041575 ED 72       1120*  INSTR2:			SBC     HL,SP
041577 EB          1121*  			EX      DE,HL
041578 7D          1122*  			LD	A,L
041579 21 00 00 00 1123*  			LD      HL,0
04157D 6F          1124*  			LD	L,A
04157E 39          1125*  			ADD     HL,SP
04157F F9          1126*  			LD      SP,HL
041580 EB          1127*  			EX      DE,HL
041581 CD 36 18 04 1128*  			CALL    BRAKET			; Check for closing bracket
041585 C3 85 13 04 1129*  			JP      COUNT1			; Return a numeric integer
041589             1130*  ;
041589             1131*  ; SEARCH - Search string for sub-string
041589             1132*  ;    Inputs: Main string at HL length C
041589             1133*  ;            Sub-string  at DE length B
041589             1134*  ;            Starting offset A
041589             1135*  ;   Outputs: NZ - not found
041589             1136*  ;            Z - found at location HL-1
041589             1137*  ;            Carry always cleared
041589             1138*  ;
041589 C5          1139*  SEARCH:			PUSH    BC			; Add the starting offset to HL
04158A 01 00 00 00 1140*  			LD      BC,0
04158E 4F          1141*  			LD      C,A
04158F 09          1142*  			ADD     HL,BC           	; New start address
041590 C1          1143*  			POP     BC
041591 91          1144*  			SUB     C			; If the starting offset > main string length, then do nothing
041592 30 2C       1145*  			JR      NC,SRCH4
041594 ED 44       1146*  			NEG
041596 4F          1147*  			LD      C,A             	; Remaining length
041597             1148*  ;
041597 C5          1149*  SRCH1:			PUSH    BC
041598 79          1150*  			LD	A,C
041599 01 00 00 00 1151*  			LD	BC,0
04159D 4F          1152*  			LD	C,A
04159E 1A          1153*  			LD      A,(DE)
04159F ED B1       1154*  			CPIR                    	; Find the first character
0415A1 79          1155*  			LD      A,C
0415A2 C1          1156*  			POP     BC
0415A3 20 1B       1157*  			JR      NZ,SRCH4
0415A5 4F          1158*  			LD      C,A
0415A6             1159*  ;
0415A6             1160*  ; This block of four instructions was commented as a bug fix by R.T.Russell
0415A6             1161*  ;
0415A6 05          1162*  			DEC     B			; Bug fix
0415A7 B8          1163*  			CP      B			; Bug fix
0415A8 04          1164*  			INC     B			; Bug fix
0415A9 38 15       1165*  			JR      C,SRCH4			; Bug fix
0415AB             1166*  ;
0415AB C5          1167*  			PUSH    BC
0415AC D5          1168*  			PUSH    DE
0415AD E5          1169*  			PUSH    HL
0415AE 05          1170*  			DEC     B
0415AF 28 08       1171*  			JR      Z,SRCH3         	; Found!
0415B1 13          1172*  SRCH2:			INC     DE
0415B2 1A          1173*  			LD      A,(DE)
0415B3 BE          1174*  			CP      (HL)
0415B4 20 03       1175*  			JR      NZ,SRCH3
0415B6 23          1176*  			INC     HL
0415B7 10 F8       1177*  			DJNZ    SRCH2
0415B9 E1          1178*  SRCH3:			POP     HL
0415BA D1          1179*  			POP     DE
0415BB C1          1180*  			POP     BC
0415BC 20 D9       1181*  			JR      NZ,SRCH1
0415BE AF          1182*  			XOR     A               	; Flags: Z, NC
0415BF C9          1183*  			RET                     	; Found
0415C0             1184*  ;
0415C0 F6 FF       1185*  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0415C2 C9          1186*  			RET                     	; Not found
0415C3             1187*  ;
0415C3             1188*  ;CHRS - Return character with given ASCII value.
0415C3             1189*  ;Result is string.
0415C3             1190*  ;
0415C3 CD 29 11 04 1191*  CHRS:			CALL    ITEMI
0415C7 D9          1192*  			EXX
0415C8 7D          1193*  			LD      A,L
0415C9 18 0E       1194*  			JR      GET1
0415CB             1195*  ;
0415CB             1196*  ;GETS - Return key pressed as stringor character at position (X,Y).
0415CB             1197*  ;Result is string.
0415CB             1198*  ;
0415CB CD 77 18 04 1199*  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0415CF FE 28       1200*  			CP	'('
0415D1 CA 8D 3E 04 1201*  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0415D5 CD 03 45 04 1202*  			CALL    OSRDCH
0415D9 37          1203*  GET1:			SCF
0415DA 18 09       1204*  			JR      INKEY1
0415DC             1205*  ;
0415DC             1206*  ; INKEYS - Wait up to n centiseconds for keypress.
0415DC             1207*  ;          Return key pressed as string or null
0415DC             1208*  ;          string if time elapsed.
0415DC             1209*  ; Result is string.
0415DC             1210*  ;
0415DC CD 29 11 04 1211*  INKEYS:			CALL    ITEMI			; Fetch the argument
0415E0 D9          1212*  			EXX
0415E1 CD 0C 45 04 1213*  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0415E5 11 00 4A 04 1214*  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0415E9 12          1215*  			LD      (DE),A
0415EA 3E 80       1216*  			LD      A,80H
0415EC D0          1217*  			RET     NC
0415ED 1C          1218*  			INC     E
0415EE C9          1219*  			RET
0415EF             1220*  ;
0415EF             1221*  ; INKEYM - Check immediately whether a given key is being pressed
0415EF             1222*  ; Result is integer numeric
0415EF             1223*  ;
0415EF             1224*  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0415EF 3E 1E       0001*M 			LD	A, function
0415F1 49 CF       0002*M 			RST.LIS	08h
0415F3 23          1225*  			INC	HL			; Index from 0
0415F4 7D          1226*  			LD	A, L			; Negate the LSB of the answer
0415F5 ED 44       1227*  			NEG
0415F7 4F          1228*  			LD	C, A			;  E: The positive keycode value
0415F8 3E 01       1229*  			LD	A, 1			; Throw an "Out of range" error
0415FA FA D2 08 04 1230*  			JP	M, ERROR_		; if the argument < - 128
0415FE             1231*  ;
0415FE 21 21 16 04 1232*  			LD	HL, BITLOOKUP		; HL: The bit lookup table
041602 11 00 00 00 1233*  			LD	DE, 0
041606 79          1234*  			LD	A, C
041607 E6 07       1235*  			AND	00000111b		; Just need the first three bits
041609 5F          1236*  			LD	E, A			; DE: The bit number
04160A 19          1237*  			ADD	HL, DE
04160B 46          1238*  			LD	B, (HL)			;  B: The mask
04160C             1239*  ;
04160C 79          1240*  			LD	A, C			; Fetch the keycode again
04160D E6 78       1241*  			AND	01111000b		; And divide by 8
04160F 0F          1242*  			RRCA
041610 0F          1243*  			RRCA
041611 0F          1244*  			RRCA
041612 5F          1245*  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
041613 DD 19       1246*  			ADD	IX, DE			; IX: The address
041615 78          1247*  			LD	A, B			;  B: The mask
041616 DD A6 00    1248*  			AND	(IX+0)			; Check whether the bit is set
041619 CA 97 17 04 1249*  			JP	Z, ZERO			; No, so return 0
04161D C3 09 14 04 1250*  			JP	TRUE			; Otherwise return -1
041621             1251*  ;
041621             1252*  ; A bit lookup table
041621             1253*  ;
041621 01 02 04 08 1254*  BITLOOKUP:		DB	01h, 02h, 04h, 08h
041625 10 20 40 80 1255*  			DB	10h, 20h, 40h, 80h
041629             1256*  ;
041629             1257*  ; MID$ - Return sub-string.
041629             1258*  ; Result is string.
041629             1259*  ;
041629 CD 25 18 04 1260*  MIDS:			CALL    EXPRSC			; Get the first string expression
04162D CD B8 17 04 1261*  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
041631 CD 0E 11 04 1262*  			CALL    EXPRI			; Get the second expression
041635 C1          1263*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
041636 CD E5 17 04 1264*  			CALL    POPS			; Pop the string back off the stack to the string accumulator
04163A D9          1265*  			EXX
04163B 7D          1266*  			LD      A,L			; A: The start index
04163C D9          1267*  			EXX
04163D B7          1268*  			OR      A			; If the start index is 0, then we don't need to do the next bit
04163E 28 0E       1269*  			JR      Z,MIDS1
041640 3D          1270*  			DEC     A
041641 6F          1271*  			LD      L,A			; L: The start index - 1
041642 93          1272*  			SUB     E			; Subtract from the string length
041643 1E 00       1273*  			LD      E,0			; Preemptively set the string length to 0
041645 30 07       1274*  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
041647 ED 44       1275*  			NEG				; Negate the answer and
041649 4F          1276*  			LD      C,A			; C: Number of bytes to copy
04164A CD 8D 16 04 1277*  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
04164E CD 77 18 04 1278*  MIDS1:			CALL    NXT			; Skip whitespace
041652 FE 2C       1279*  			CP      ','			; Check for a comma
041654 FD 23       1280*  			INC     IY			; Advance to the next character in the BASIC line
041656 28 0D       1281*  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
041658 FD 2B       1282*  			DEC     IY			; Restore the BASIC program pointer
04165A CD 36 18 04 1283*  			CALL    BRAKET			; Check for a bracket
04165E 3E 80       1284*  			LD      A,80H			; String marker
041660 C9          1285*  			RET
041661             1286*  ;
041661             1287*  ; LEFT$ - Return left part of string.
041661             1288*  ; Carry cleared if entire string returned.
041661             1289*  ; Result is string.
041661             1290*  ;
041661 CD 25 18 04 1291*  LEFTS:			CALL    EXPRSC			; Get the first string expression
041665 CD B8 17 04 1292*  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
041669 CD 0E 11 04 1293*  			CALL    EXPRI			; Get the second expression
04166D C1          1294*  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04166E CD E5 17 04 1295*  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
041672 CD 36 18 04 1296*  			CALL    BRAKET			; Check for closing bracket
041676 D9          1297*  			EXX
041677 7D          1298*  			LD      A,L			; L: The second parameter
041678 D9          1299*  			EXX
041679 BB          1300*  			CP      E			; Compare with the string length
04167A 30 02       1301*  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
04167C 6B          1302*  			LD      L,E             	; For RIGHTS, no effect in LEFTS
04167D 5F          1303*  LEFT2:			LD      E,A			; E: The new length of string
04167E 3E 80       1304*  LEFT3:			LD      A,80H           	; String marker
041680 C9          1305*  			RET
041681             1306*  ;
041681             1307*  ; RIGHT$ - Return right part of string.
041681             1308*  ; Result is string.
041681             1309*  ;
041681 CD 61 16 04 1310*  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
041685 D0          1311*  			RET     NC			; Do nothing if the second parameter is >= string length
041686 1C          1312*  			INC     E			; Check for a zero length string
041687 1D          1313*  			DEC     E
041688 C8          1314*  			RET     Z			; Yes, so do nothing
041689 4B          1315*  			LD      C,E			;  C: Number of bytes to copy
04168A 7D          1316*  			LD      A,L
04168B 93          1317*  			SUB     E
04168C 6F          1318*  			LD      L,A			;  L: Index into the string
04168D 79          1319*  RIGHT1:			LD	A,C
04168E 01 00 00 00 1320*  			LD	BC,0
041692 4F          1321*  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
041693 7D          1322*  			LD	A,L
041694 21 00 4A 04 1323*  			LD	HL,ACCS
041698 6F          1324*  			LD	L,A			; HL: Source (in ACCS)
041699 11 00 4A 04 1325*  			LD      DE,ACCS			; DE: Destination (start of ACCS)
04169D ED B0       1326*  			LDIR                    	; Copy
04169F 3E 80       1327*  			LD      A,80H			; String marker
0416A1 C9          1328*  			RET
0416A2             1329*  ;
0416A2             1330*  ; STRINGS - Return n concatenations of a string.
0416A2             1331*  ; Result is string.
0416A2             1332*  ;
0416A2 CD 0E 11 04 1333*  STRING_:		CALL    EXPRI			; Get number of times to replicate
0416A6 CD 29 18 04 1334*  			CALL    COMMA			; Check for comma
0416AA D9          1335*  			EXX
0416AB 7D          1336*  			LD      A,L			; L: Number of iterations of string
0416AC D9          1337*  			EXX
0416AD F5          1338*  			PUSH    AF
0416AE CD 19 11 04 1339*  			CALL    EXPRS			; Get the string
0416B2 CD 36 18 04 1340*  			CALL    BRAKET			; Check for closing bracket
0416B6 F1          1341*  			POP     AF			; A: Number of iterations of string
0416B7 B7          1342*  			OR      A			; Set flags
0416B8 28 C3       1343*  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0416BA 3D          1344*  			DEC     A
0416BB 4F          1345*  			LD      C,A			; C: Loop counter
0416BC 3E 80       1346*  			LD      A,80H			; String marker
0416BE C8          1347*  			RET     Z
0416BF 1C          1348*  			INC     E			; Check for empty string
0416C0 1D          1349*  			DEC     E
0416C1 C8          1350*  			RET     Z              		; And return
0416C2 43          1351*  			LD      B,E			; B: String length tally
0416C3 21 00 4A 04 1352*  			LD	HL,ACCS
0416C7 C5          1353*  STRIN1:			PUSH    BC
0416C8 7E          1354*  STRIN2:			LD      A,(HL)
0416C9 23          1355*  			INC     HL
0416CA 12          1356*  			LD      (DE),A
0416CB 1C          1357*  			INC     E
0416CC 3E 13       1358*  			LD      A,19
0416CE CA D2 08 04 1359*  			JP      Z,ERROR_         	; Throw a "String too long" error
0416D2 10 F4       1360*  			DJNZ    STRIN2
0416D4 C1          1361*  			POP     BC
0416D5 0D          1362*  			DEC     C
0416D6 20 EF       1363*  			JR      NZ,STRIN1
0416D8 3E 80       1364*  			LD      A,80H
0416DA C9          1365*  			RET
0416DB             1366*  ;
0416DB             1367*  ;SUBROUTINES
0416DB             1368*  ;
0416DB             1369*  ;SWAP - Swap arguments
0416DB             1370*  ;Exchanges DE,HL D'E',H'L' and B,C
0416DB             1371*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0416DB             1372*  ;
0416DB 79          1373*  SWAP:			LD      A,C
0416DC 48          1374*  			LD      C,B
0416DD 47          1375*  			LD      B,A
0416DE EB          1376*  			EX      DE,HL
0416DF D9          1377*  			EXX
0416E0 EB          1378*  			EX      DE,HL
0416E1 D9          1379*  			EXX
0416E2 C9          1380*  			RET
0416E3             1381*  ;
0416E3             1382*  ;TEST - Test HLH'L' for zero
0416E3             1383*  ;Outputs: Z-flag set & A=0 if zero
0416E3             1384*  ;Destroys: A,F
0416E3             1385*  ;
0416E3 7C          1386*  TEST:			LD      A,H
0416E4 B5          1387*  			OR      L
0416E5 D9          1388*  			EXX
0416E6 B4          1389*  			OR      H
0416E7 B5          1390*  			OR      L
0416E8 D9          1391*  			EXX
0416E9 C9          1392*  			RET
0416EA             1393*  ;
0416EA             1394*  ;DECODE - Decode line number in pseudo-binary.
0416EA             1395*  ;   Inputs: IY = Text pointer.
0416EA             1396*  ;   Outputs: HL=0, H'L'=line number, C=0.
0416EA             1397*  ;   Destroys: A,C,H,L,H',L',IY,F
0416EA             1398*  ;
0416EA D9          1399*  DECODE:			EXX
0416EB 21 00 00 00 1400*  			LD	HL, 0
0416EF FD 7E 00    1401*  			LD      A,(IY)
0416F2 FD 23       1402*  			INC     IY
0416F4 17          1403*  			RLA
0416F5 17          1404*  			RLA
0416F6 67          1405*  			LD      H,A
0416F7 E6 C0       1406*  			AND     0C0H
0416F9 FD AE 00    1407*  			XOR     (IY)
0416FC FD 23       1408*  			INC     IY
0416FE 6F          1409*  			LD      L,A
0416FF 7C          1410*  			LD      A,H
041700 17          1411*  			RLA
041701 17          1412*  			RLA
041702 E6 C0       1413*  			AND     0C0H
041704 FD AE 00    1414*  			XOR     (IY)
041707 FD 23       1415*  			INC     IY
041709 67          1416*  			LD      H,A
04170A D9          1417*  			EXX
04170B             1418*  ;			XOR     A
04170B             1419*  ;			LD      C,A
04170B             1420*  ;			LD      H,A
04170B             1421*  ;			LD      L,A
04170B 21 00 00 00 1422*  			LD	HL, 0
04170F 4D          1423*  			LD	C, L
041710 C9          1424*  			RET
041711             1425*  ;
041711             1426*  ;HEXSTR - convert numeric value to HEX string.
041711             1427*  ;   Inputs: HLH'L'C = integer or floating-point number
041711             1428*  ;  Outputs: String in string accumulator.
041711             1429*  ;           E = string length.  D = ACCS/256
041711             1430*  ;
041711 FD 23       1431*  HEXSTS:			INC     IY              ;SKIP TILDE
041713 CD 21 11 04 1432*  			CALL    ITEMN
041717 CD 1E 17 04 1433*  			CALL    HEXSTR
04171B 3E 80       1434*  			LD      A,80H
04171D C9          1435*  			RET
04171E             1436*  ;
04171E CD 66 14 04 1437*  HEXSTR:			CALL    SFIX
041722 01 08 00 00 1438*  			LD      BC,8
041726 11 00 4A 04 1439*  			LD      DE,ACCS
04172A C5          1440*  HEXST1:			PUSH    BC
04172B 06 04       1441*  			LD      B,4
04172D AF          1442*  			XOR     A
04172E D9          1443*  HEXST2:			EXX
04172F 52 29       1444*  			ADD.S	HL,HL
041731 D9          1445*  			EXX
041732 52 ED 6A    1446*  			ADC.S	HL,HL
041735 17          1447*  			RLA
041736 10 F6       1448*  			DJNZ    HEXST2
041738 C1          1449*  			POP     BC
041739 0D          1450*  			DEC     C
04173A F8          1451*  			RET     M
04173B 28 06       1452*  			JR      Z,HEXST3
04173D B7          1453*  			OR      A
04173E 20 03       1454*  			JR      NZ,HEXST3
041740 B8          1455*  			CP      B
041741 28 E7       1456*  			JR      Z,HEXST1
041743 C6 90       1457*  HEXST3:			ADD     A,90H
041745 27          1458*  			DAA
041746 CE 40       1459*  			ADC     A,40H
041748 27          1460*  			DAA
041749 12          1461*  			LD      (DE),A
04174A 13          1462*  			INC     DE
04174B 47          1463*  			LD      B,A
04174C 18 DC       1464*  			JR      HEXST1
04174E             1465*  ;
04174E             1466*  ;Function STR - convert numeric value to ASCII string.
04174E             1467*  ;   Inputs: HLH'L'C = integer or floating-point number.
04174E             1468*  ;  Outputs: String in string accumulator.
04174E             1469*  ;           E = length, D = ACCS/256
04174E             1470*  ;           A = 80H (type=string)
04174E             1471*  ;
04174E             1472*  ;First normalise for decimal output:
04174E             1473*  ;
04174E CD 77 18 04 1474*  STRS:			CALL    NXT
041752 FE 7E       1475*  			CP      '~'
041754 28 BB       1476*  			JR      Z,HEXSTS
041756 CD 21 11 04 1477*  			CALL    ITEMN
04175A DD 21 00 4C 1478*  			LD      IX,STAVAR
       04          
04175F DD 7E 03    1479*  			LD      A,(IX+3)
041762 B7          1480*  			OR      A
041763 DD 21 90 17 1481*  			LD      IX,G9-1         ;G9 FORMAT
       04          
041768 28 05       1482*  			JR      Z,STR0
04176A DD 21 00 4C 1483*  STR:			LD      IX,STAVAR
       04          
04176F 11 00 4A 04 1484*  STR0:			LD      DE,ACCS
041773 3E 25       1485*  			LD      A,37
041775 CD A1 2E 04 1486*  			CALL    FPP
041779 DA D2 08 04 1487*  			JP      C,ERROR_
04177D DD CB 02 46 1488*  			BIT     0,(IX+2)
041781 3E 80       1489*  STR1:			LD      A,80H           ;STRING MARKER
041783 C8          1490*  			RET     Z
041784 79          1491*  			LD      A,C
041785 C6 04       1492*  			ADD     A,4
041787 BB          1493*  STR2:			CP      E
041788 28 F7       1494*  			JR      Z,STR1
04178A EB          1495*  			EX      DE,HL
04178B 36 20       1496*  			LD      (HL),' '        ;TRAILING SPACE
04178D 23          1497*  			INC     HL
04178E EB          1498*  			EX      DE,HL
04178F 18 F6       1499*  			JR      STR2
041791             1500*  ;
041791 09 00       1501*  G9:			DW    9
041793             1502*  ;
041793             1503*  ;STRING COMPARE
041793             1504*  ;Compare string (DE) length B with string (HL) length C.
041793             1505*  ;Result preset to false.
041793             1506*  ;
041793 CD A1 17 04 1507*  SCP:			CALL	SCP0
041797             1508*  ;
041797 3E 00       1509*  ZERO:			LD      A,0
041799 D9          1510*  			EXX
04179A 67          1511*  			LD      H,A
04179B 6F          1512*  			LD      L,A
04179C D9          1513*  			EXX
04179D 67          1514*  			LD      H,A
04179E 6F          1515*  			LD      L,A
04179F 4F          1516*  			LD      C,A
0417A0 C9          1517*  			RET
0417A1             1518*  ;
0417A1 04          1519*  SCP0:			INC     B
0417A2 0C          1520*  			INC     C
0417A3 05          1521*  SCP1:			DEC     B
0417A4 28 0A       1522*  			JR      Z,SCP2
0417A6 0D          1523*  			DEC     C
0417A7 28 0C       1524*  			JR      Z,SCP3
0417A9 1A          1525*  			LD      A,(DE)
0417AA BE          1526*  			CP      (HL)
0417AB C0          1527*  			RET     NZ
0417AC 13          1528*  			INC     DE
0417AD 23          1529*  			INC     HL
0417AE 18 F3       1530*  			JR      SCP1
0417B0 B7          1531*  SCP2:			OR      A
0417B1 0D          1532*  			DEC     C
0417B2 C8          1533*  			RET     Z
0417B3 37          1534*  			SCF
0417B4 C9          1535*  			RET
0417B5 B7          1536*  SCP3:			OR      A
0417B6 0C          1537*  			INC     C
0417B7 C9          1538*  			RET
0417B8             1539*  ;
0417B8             1540*  ; PUSHS - SAVE STRING ON STACK.
0417B8             1541*  ;     Inputs: String in string accumulator.
0417B8             1542*  ;             E = string length.
0417B8             1543*  ;             A - saved on stack.
0417B8             1544*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0417B8             1545*  ;
0417B8 CD 80 24 04 1546*  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0417BC DD E1       1547*  			POP     IX              	; IX: Return address
0417BE B7          1548*  			OR      A               	; Clear the carry flag
0417BF 01 00 00 00 1549*  			LD	BC,0			; BC: Length of the string
0417C3 4B          1550*  			LD	C,E
0417C4 21 00 4A 04 1551*  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0417C8 11 00 4A 04 1552*  			LD	DE,ACCS
0417CC 59          1553*  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0417CD ED 52       1554*  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0417CF 39          1555*  			ADD     HL,SP			; Grow the stack
0417D0 F9          1556*  			LD      SP,HL
0417D1 57          1557*  			LD      D,A			;  D: This needs to be set to A for some functions
0417D2 47          1558*  			LD	B,A			; Stack A and C (the string length)
0417D3 C5          1559*  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0417D4 06 00       1560*  			LD	B,0			; Reset B to 0 for the LDIR in this function
0417D6 28 0B       1561*  			JR      Z,PUSHS1        	; Is it zero length?
0417D8 11 00 4A 04 1562*  			LD      DE,ACCS			; DE: Destination
0417DC EB          1563*  			EX      DE,HL			; HL: Destination, DE: Address on stack
0417DD ED B0       1564*  			LDIR	                    	; Copy to stack
0417DF CD 80 24 04 1565*  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0417E3 DD E9       1566*  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0417E5             1567*  ;
0417E5             1568*  ; POPS - RESTORE STRING FROM STACK.
0417E5             1569*  ;     Inputs: C = string length.
0417E5             1570*  ;    Outputs: String in string accumulator.
0417E5             1571*  ;             E = string length.
0417E5             1572*  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0417E5             1573*  ;
0417E5 DD E1       1574*  POPS:			POP     IX              	; IX: Return address
0417E7 69          1575*  			LD	L,C			; Temporarily store string length in L
0417E8 01 00 00 00 1576*  			LD	BC,0
0417EC 4D          1577*  			LD	C,L			; BC: Number of bytes to copy
0417ED 21 00 00 00 1578*  			LD      HL,0			; HL: 0
0417F1 39          1579*  			ADD     HL,SP			; HL: Stack address
0417F2 11 00 4A 04 1580*  			LD      DE,ACCS			; DE: Destination
0417F6 0C          1581*  			INC     C			; Quick check to see if this is a zero length string
0417F7 0D          1582*  			DEC     C
0417F8 28 02       1583*  			JR      Z,POPS1         	; Yes it is, so skip
0417FA ED B0       1584*  			LDIR                    	; No, so copy from the stack
0417FC F9          1585*  POPS1:			LD      SP,HL			; Shrink the stack
0417FD DD E9       1586*  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0417FF             1587*  ;
0417FF FD 7E 00    1588*  HEXDIG:			LD      A,(IY)
041802 FE 30       1589*  			CP      '0'
041804 D8          1590*  			RET     C
041805 FE 3A       1591*  			CP      '9'+1
041807 3F          1592*  			CCF
041808 D0          1593*  			RET     NC
041809 FE 41       1594*  			CP      'A'
04180B D8          1595*  			RET     C
04180C D6 37       1596*  			SUB     'A'-10
04180E FE 10       1597*  			CP      16
041810 3F          1598*  			CCF
041811 C9          1599*  			RET
041812             1600*  ;
041812 FD 7E 00    1601*  BINDIG:			LD	A,(IY)
041815 FE 30       1602*  			CP	'0'
041817 D8          1603*  			RET	C
041818 FE 32       1604*  			CP	'1'+1
04181A 3F          1605*  			CCF
04181B C9          1606*  			RET
04181C             1607*  ;
04181C FE 3E       1608*  RELOP?:			CP      '>'
04181E D0          1609*  			RET     NC
04181F FE 3D       1610*  			CP      '='
041821 D0          1611*  			RET     NC
041822 FE 3C       1612*  			CP      '<'
041824 C9          1613*  			RET
041825             1614*  ;
041825 CD 19 11 04 1615*  EXPRSC:			CALL    EXPRS
041829 CD 77 18 04 1616*  COMMA:			CALL    NXT
04182D FD 23       1617*  			INC     IY
04182F FE 2C       1618*  			CP      ','
041831 C8          1619*  			RET     Z
041832 3E 05       1620*  			LD      A,5
041834 18 0B       1621*  			JR      ERROR1_EV          ;"Missing ,"
041836             1622*  ;
041836 CD 77 18 04 1623*  BRAKET:			CALL    NXT
04183A FD 23       1624*  			INC     IY
04183C FE 29       1625*  			CP      ')'
04183E C8          1626*  			RET     Z
04183F 3E 1B       1627*  			LD      A,27
041841 C3 D2 08 04 1628*  ERROR1_EV:			JP      ERROR_           ;"Missing )"
041845             1629*  ;
041845 FD 23       1630*  SAVE_EV:			INC     IY
041847 08          1631*  SAVE1:			EX      AF,AF'
041848 FA 3A 11 04 1632*  			JP      M,TYPE_EV_
04184C 08          1633*  			EX      AF,AF'
04184D E3          1634*  			EX      (SP),HL
04184E D9          1635*  			EXX
04184F E5          1636*  			PUSH    HL
041850 D9          1637*  			EXX
041851 F5          1638*  			PUSH    AF
041852 C5          1639*  			PUSH    BC
041853 E9          1640*  			JP      (HL)
041854             1641*  ;
041854 08          1642*  DOIT:			EX      AF,AF'
041855 FA 3A 11 04 1643*  			JP      M,TYPE_EV_
041859 D9          1644*  			EXX
04185A C1          1645*  			POP     BC              ;RETURN ADDRESS
04185B D9          1646*  			EXX
04185C 79          1647*  			LD      A,C
04185D C1          1648*  			POP     BC
04185E 47          1649*  			LD      B,A
04185F F1          1650*  			POP     AF              ;OPERATOR
041860 D9          1651*  			EXX
041861 EB          1652*  			EX      DE,HL
041862 E1          1653*  			POP     HL
041863 D9          1654*  			EXX
041864 EB          1655*  			EX      DE,HL
041865 E1          1656*  			POP     HL
041866 D9          1657*  			EXX
041867 C5          1658*  			PUSH    BC
041868 D9          1659*  			EXX
041869 E6 0F       1660*  			AND     0FH
04186B CD A1 2E 04 1661*  			CALL    FPP
04186F 38 D0       1662*  			JR      C,ERROR1_EV
041871 AF          1663*  			XOR     A
041872 08          1664*  			EX      AF,AF'          ;TYPE
041873 FD 7E 00    1665*  			LD      A,(IY)
041876 C9          1666*  			RET
041877             1667*  ;
041877             1668*  ; Skip spaces
041877             1669*  ; - IY: String pointer
041877             1670*  ; Returns:
041877             1671*  ;  - A: The non-space character found
041877             1672*  ; - IY: Points to the character before that
041877             1673*  ;
041877 FD 7E 00    1674*  NXT:			LD      A,(IY)			; Fetch the character
04187A FE 20       1675*  			CP      ' '			; If it is space, then return
04187C C0          1676*  			RET     NZ
04187D FD 23       1677*  			INC     IY			; Increment the pointer and
04187F C3 77 18 04 1678*  			JP      NXT			; Loop
041883             1679*  ;
041883 E5          1680*  DISPT2:			PUSH    HL
041884 21 B4 0F 04 1681*  			LD      HL,SOPTBL
041888 18 07       1682*  			JR      DISPT0
04188A             1683*  ;
04188A E5          1684*  DISPAT:			PUSH    HL
04188B D6 8D       1685*  			SUB     FUNTOK
04188D 21 09 0F 04 1686*  			LD      HL,FUNTBL
041891 C5          1687*  DISPT0:			PUSH    BC
041892             1688*  
041892 01 03 00 00 1689*  			LD	BC, 3
041896 47          1690*  			LD	B, A
041897 ED 4C       1691*  			MLT	BC
041899 09          1692*  			ADD	HL, BC
04189A ED 27       1693*  			LD	HL, (HL)
04189C             1694*  
04189C             1695*  ;			ADD     A,A
04189C             1696*  ;			LD      C,A
04189C             1697*  ;			LD      B,0
04189C             1698*  ;			ADD     HL,BC
04189C             1699*  ;			LD      A,(HL)
04189C             1700*  ;			INC     HL
04189C             1701*  ;			LD      H,(HL)
04189C             1702*  ;			LD      L,A
04189C             1703*  
04189C C1          1704*  			POP     BC
04189D E3          1705*  			EX      (SP),HL
04189E C9          1706*  			RET                     ;OFF TO ROUTINE
04189F             1707*  
04189F             0008       include "exec.asm"
04189F             0001*  ;
04189F             0002*  ; Title:	BBC Basic Interpreter - Z80 version
04189F             0003*  ;		Statement Execution & Assembler Module - "EXEC"
04189F             0004*  ; Author:	(C) Copyright  R.T.Russell  1984
04189F             0005*  ; Modified By:	Dean Belfield
04189F             0006*  ; Created:	12/05/2023
04189F             0007*  ; Last Updated:	26/06/2023
04189F             0008*  ;
04189F             0009*  ; Modinfo:
04189F             0010*  ; 27/01/1984:	Version 2.1
04189F             0011*  ; 02/03/1987:	Version 3.0
04189F             0012*  ; 11/06/1987:	Version 3.1
04189F             0013*  ; 12/05/2023:	Modified by Dean Belfield
04189F             0014*  ; 07/06/2023:	Modified to run in ADL mode
04189F             0015*  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
04189F             0016*  
04189F             0017*  			; .ASSUME	ADL = 1
04189F             0018*  
04189F             0019*  			; INCLUDE	"equs.inc"
04189F             0020*  
04189F             0021*  			; SEGMENT CODE
04189F             0022*  
04189F             0023*  			; XDEF	XEQ
04189F             0024*  			; XDEF	CHAIN0
04189F             0025*  			; XDEF	RUN
04189F             0026*  			; XDEF	SYNTAX
04189F             0027*  			; XDEF	ESCAPE
04189F             0028*  			; XDEF	FN_EX
04189F             0029*  			; XDEF	USR
04189F             0030*  			; XDEF	STORE5
04189F             0031*  			; XDEF	STORE4
04189F             0032*  			; XDEF	CHECK
04189F             0033*  			; XDEF	TERMQ
04189F             0034*  			; XDEF	FILL
04189F             0035*  			; XDEF	X4OR5
04189F             0036*  			; XDEF	MUL16
04189F             0037*  			; XDEF	CHANEL
04189F             0038*  			; XDEF	ASSEM
04189F             0039*  
04189F             0040*  			; XREF	AUTO
04189F             0041*  			; XREF	DELETE
04189F             0042*  			; XREF	LOAD
04189F             0043*  			; XREF	LIST_
04189F             0044*  			; XREF	NEW
04189F             0045*  			; XREF	OLD
04189F             0046*  			; XREF	RENUM
04189F             0047*  			; XREF	SAVE
04189F             0048*  			; XREF	SOUND
04189F             0049*  			; XREF	CLG
04189F             0050*  			; XREF	DRAW
04189F             0051*  			; XREF	ENVEL
04189F             0052*  			; XREF	GCOL
04189F             0053*  			; XREF	MODE
04189F             0054*  			; XREF	MOVE
04189F             0055*  			; XREF	PLOT
04189F             0056*  			; XREF	COLOUR
04189F             0057*  			; XREF	EXPRS
04189F             0058*  			; XREF	HIMEM
04189F             0059*  			; XREF	LOAD0
04189F             0060*  			; XREF	RANDOM
04189F             0061*  			; XREF	CLEAR
04189F             0062*  			; XREF	ERRTRP
04189F             0063*  			; XREF	PAGE_
04189F             0064*  			; XREF	DATAPTR
04189F             0065*  			; XREF	ERRLIN
04189F             0066*  			; XREF	TRAP
04189F             0067*  			; XREF	NXT
04189F             0068*  			; XREF	SETLIN
04189F             0069*  			; XREF	CLOOP
04189F             0070*  			; XREF	OSSHUT
04189F             0071*  			; XREF	WARM
04189F             0072*  			; XREF	TRACEN
04189F             0073*  			; XREF	OUTCHR
04189F             0074*  			; XREF	PBCDL
04189F             0075*  			; XREF	OSCLI
04189F             0076*  			; XREF	LISTON
04189F             0077*  			; XREF	GETVAR
04189F             0078*  			; XREF	PUTVAR
04189F             0079*  			; XREF	DATPTR
04189F             0080*  			; XREF	ERROR_
04189F             0081*  			; XREF	EXPR
04189F             0082*  			; XREF	CREATE
04189F             0083*  			; XREF	EXPRI
04189F             0084*  			; XREF	BRAKET
04189F             0085*  			; XREF	FREE
04189F             0086*  			; XREF	OSBPUT
04189F             0087*  			; XREF	COUNT
04189F             0088*  			; XREF	STR
04189F             0089*  			; XREF	HEXSTR
04189F             0090*  			; XREF	CRLF
04189F             0091*  			; XREF	ITEMI
04189F             0092*  			; XREF	FINDL
04189F             0093*  			; XREF	TEST
04189F             0094*  			; XREF	EXPRN
04189F             0095*  			; XREF	DLOAD5
04189F             0096*  			; XREF	DLOAD5_SPL
04189F             0097*  			; XREF	LOADN
04189F             0098*  			; XREF	FPP
04189F             0099*  			; XREF	SWAP
04189F             0100*  			; XREF	GETDEF
04189F             0101*  			; XREF	ZERO
04189F             0102*  			; XREF	OSBGET
04189F             0103*  			; XREF	BUFFER
04189F             0104*  			; XREF	CONS
04189F             0105*  			; XREF	VAL0
04189F             0106*  			; XREF	OSLINE
04189F             0107*  			; XREF	CLRSCN
04189F             0108*  			; XREF	TELL
04189F             0109*  			; XREF	SAYLN
04189F             0110*  			; XREF	REPORT
04189F             0111*  			; XREF	PUTPTR
04189F             0112*  			; XREF	PUTIME
04189F             0113*  			; XREF	PUTIMS
04189F             0114*  			; XREF	LOMEM
04189F             0115*  			; XREF	WIDTH
04189F             0116*  			; XREF	OSWRCH
04189F             0117*  			; XREF	COMMA
04189F             0118*  			; XREF	OSCALL
04189F             0119*  			; XREF	SFIX
04189F             0120*  			; XREF	LOAD4
04189F             0121*  			; XREF	PUSHS
04189F             0122*  			; XREF	POPS
04189F             0123*  			; XREF	LOADS
04189F             0124*  			; XREF	PUTCSR
04189F             0125*  			; XREF	OUT_
04189F             0126*  			; XREF	R0
04189F             0127*  ;
04189F             0128*  ; List of token values used in this module
04189F             0129*  ; consolidated with the token values in main.asm
04189F             0130*  ; TAND:			EQU     80H
04189F             0131*  ; TOR:			EQU     84H
04189F             0132*  ; TERROR:			EQU     85H
04189F             0133*  ; LINE_:			EQU     86H
04189F             0134*  ; OFF_:			EQU     87H
04189F             0135*  ; STEP:			EQU     88H
04189F             0136*  ; SPC:			EQU     89H
04189F             0137*  ; TAB:			EQU     8AH
04189F             0138*  ; ELSE_:			EQU     8BH
04189F             0139*  ; THEN:			EQU     8CH
04189F             0140*  ; LINO:			EQU     8DH
04189F             0141*  ; TO:				EQU     B8H
04189F             0142*  ; TCALL:			EQU     D6H
04189F             0143*  ; DATA_:			EQU     DCH
04189F             0144*  ; DEF_:			EQU     DDH
04189F             0145*  ; TGOSUB:			EQU     E4H
04189F             0146*  ; TGOTO:			EQU     E5H
04189F             0147*  ; TON:			EQU     EEH
04189F             0148*  ; TPROC:			EQU     F2H
04189F             0149*  ; TSTOP:			EQU     FAH
04189F             0150*  
04189F             0151*  ; TCMD:			EQU     C6H ; in eval.asm
04189F             0152*  
04189F             0153*  ; The command table
04189F             0154*  ; Commands are tokens from C6H onwards; this lookup table is used to
04189F             0155*  ; run the corresponding function; Note that DATA and DEF both use the same
04189F             0156*  ; code as REM
04189F             0157*  ;
04189F 5B 08 04    0158*  CMDTAB:			DW24  AUTO			; C6H
0418A2 BE 06 04    0159*  			DW24  DELETE			; C7H
0418A5 9C 08 04    0160*  			DW24  LOAD			; C8H
0418A8 F9 06 04    0161*  			DW24  LIST_			; C9H
0418AB 79 08 04    0162*  			DW24  NEW			; CAH
0418AE 7F 08 04    0163*  			DW24  OLD			; CBH
0418B1 88 07 04    0164*  			DW24  RENUM			; CCH
0418B4 AD 08 04    0165*  			DW24  SAVE			; CDH
0418B7 D9 23 04    0166*  			DW24  PUT			; CEH
0418BA CF 21 04    0167*  			DW24  PTR_EX			; CFH
0418BD E9 21 04    0168*  			DW24  PAGEV_EX			; D0H
0418C0 FC 21 04    0169*  			DW24  TIMEV_EX			; D1H
0418C3 25 22 04    0170*  			DW24  LOMEMV_EX			; D2H
0418C6 3E 22 04    0171*  			DW24  HIMEMV_EX			; D3H
0418C9 B7 40 04    0172*  			DW24  SOUND			; D4H
0418CC F3 22 04    0173*  			DW24  BPUT			; D5H
0418CF 0B 23 04    0174*  			DW24  CALL_			; D6H
0418D2 53 19 04    0175*  			DW24  CHAIN			; D7H
0418D5 9E 21 04    0176*  			DW24  CLR			; D8H
0418D8 E7 22 04    0177*  			DW24  CLOSE			; D9H
0418DB 53 3E 04    0178*  			DW24  CLG			; DAH
0418DE 71 21 04    0179*  			DW24  CLS			; DBH
0418E1 32 1A 04    0180*  			DW24  REM_EX             		; DCH: DATA
0418E4 32 1A 04    0181*  			DW24  REM_EX             		; DDH: DEF
0418E7 F8 1A 04    0182*  			DW24  DIM_EX			; DEH
0418EA 7D 40 04    0183*  			DW24  DRAW			; DFH
0418ED CD 19 04    0184*  			DW24  END_			; E0H
0418F0 89 1F 04    0185*  			DW24  ENDPRO			; E1H
0418F3 A2 49 04    0186*  			DW24  ENVEL			; E2H
0418F6 9E 1D 04    0187*  			DW24  FOR_EX			; E3H
0418F9 4E 1D 04    0188*  			DW24  GOSUB_EX			; E4H
0418FC 32 1D 04    0189*  			DW24  GOTO_EX			; E5H
0418FF 11 40 04    0190*  			DW24  GCOL			; E6H
041902 3D 21 04    0191*  			DW24  IF_			; E7H
041905 2B 20 04    0192*  			DW24  INPUT			; E8H
041908 53 1A 04    0193*  			DW24  LET			; E9H
04190B 2E 1F 04    0194*  			DW24  LOCAL_EX_			; EAH
04190E 63 3E 04    0195*  			DW24  MODE			; EBH
041911 75 40 04    0196*  			DW24  MOVE			; ECH
041914 EC 1D 04    0197*  			DW24  NEXT_EX			; EDH
041917 C5 1C 04    0198*  			DW24  ON_EX_			; EEH
04191A A8 22 04    0199*  			DW24  VDU			; EFH
04191D 43 40 04    0200*  			DW24  PLOT			; F0H
041920 CE 1B 04    0201*  			DW24  PRINT_			; F1H
041923 8B 1E 04    0202*  			DW24  PROC_EX			; F2H
041926 DD 20 04    0203*  			DW24  READ			; F3H
041929 32 1A 04    0204*  			DW24  REM_EX			; F4H
04192C 6E 1D 04    0205*  			DW24  REPEAT_EX			; F5H
04192F 96 21 04    0206*  			DW24  REPOR			; F6H
041932 A8 21 04    0207*  			DW24  RESTOR_EX			; F7H
041935 5C 1D 04    0208*  			DW24  RETURN			; F8H
041938 4D 19 04    0209*  			DW24  RUN			; F9H
04193B 7E 21 04    0210*  			DW24  STOP			; FAH
04193E 5F 3F 04    0211*  			DW24  COLOUR			; FBH
041941 8A 22 04    0212*  			DW24  TRACE_EX			; FCH
041944 78 1D 04    0213*  			DW24  UNTIL_EX			; FDH
041947 7C 22 04    0214*  			DW24  WIDTHV			; FEH
04194A 18 1A 04    0215*  			DW24  CLI             		; FFH: OSCLI
04194D             0216*  
04194D             0217*  ; RUN
04194D             0218*  ; RUN "filename"
04194D             0219*  ;
04194D CD AB 25 04 0220*  RUN:			CALL    TERMQ			; Standalone RUN command?
041951 28 10       0221*  			JR      Z,RUN0			; Yes, so just RUN the code
041953             0222*  
041953             0223*  ; CHAIN "filename"
041953             0224*  ;
041953 CD 19 11 04 0225*  CHAIN:			CALL    EXPRS			; Get the filename
041957 3E 0D       0226*  			LD      A,CR			; Terminate it with a CR
041959 12          0227*  			LD      (DE),A
04195A ED 7B 20 4D 0228*  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
04195F CD 91 09 04 0229*  			CALL    LOAD0			; And load the file in
041963             0230*  ;
041963 ED 7B 20 4D 0231*  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
041968 DD 21 38 4D 0232*  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
04196D ED 5F       0233*  @@:			LD      A, R			; Use the R register to seed the random number generator
04196F 28 FC       0234*  			JR      Z, @B			; Loop unti we get a non-zero value in A
041971 07          0235*  			RLCA				; Rotate it
041972 07          0236*  			RLCA
041973 DD 77 03    0237*  			LD      (IX+3),A		; And store
041976 9F          0238*  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
041977 DD 77 04    0239*  			LD      (IX+4),A		; And store
04197A CD E8 09 04 0240*  			CALL    CLEAR
04197E 21 00 00 00 0241*  			LD      HL,0			; Clear the error trap sysvar
041982 22 2C 4D 04 0242*  			LD      (ERRTRP),HL
041986 2A 14 4D 04 0243*  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
04198A 3E DC       0244*  			LD      A,DATA_			; The DATA token value
04198C CD 7F 26 04 0245*  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
041990 22 31 4D 04 0246*  			LD      (DATPTR),HL     	; Set data pointer
041994 FD 2A 14 4D 0247*  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
041999             0248*  ;
041999 CD E1 19 04 0249*  XEQ0:			CALL    NEWLIN
04199D FD 22 35 4D 0250*  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
0419A2 CD 47 45 04 0251*  			CALL    TRAP           		; Check keyboard
0419A6 CD 77 18 04 0252*  XEQ1:			CALL    NXT
0419AA FD 23       0253*  			INC     IY
0419AC FE 3A       0254*  			CP      ':'             	; Seperator
0419AE 28 F6       0255*  			JR      Z,XEQ1
0419B0 FE 0D       0256*  			CP      CR
0419B2 28 E5       0257*  			JR      Z,XEQ0          	; New program line
0419B4 D6 C6       0258*  			SUB     TCMD
0419B6 DA 41 1A 04 0259*  			JP      C,LET0          	; Implied "LET"
0419BA             0260*  
0419BA 01 03 00 00 0261*  			LD	BC, 3
0419BE 47          0262*  			LD	B, A
0419BF ED 4C       0263*  			MLT	BC
0419C1 21 9F 18 04 0264*  			LD	HL,CMDTAB
0419C5 09          0265*  			ADD	HL, BC
0419C6 ED 27       0266*  			LD	HL, (HL)		; Table entry
0419C8             0267*  
0419C8             0268*  ;			ADD     A,A
0419C8             0269*  ;			LD      C,A
0419C8             0270*  ;			LD      B,0
0419C8             0271*  ;			LD      HL,CMDTAB
0419C8             0272*  ;			ADD     HL,BC
0419C8             0273*  ;			LD      A,(HL)          	; Table entry
0419C8             0274*  ;			INC     HL
0419C8             0275*  ;			LD      H,(HL)
0419C8             0276*  ;			LD      L,A
0419C8             0277*  
0419C8 CD 77 18 04 0278*  			CALL    NXT
0419CC E9          0279*  			JP      (HL)            	; Execute the statement
0419CD             0280*  
0419CD             0281*  ;END
0419CD             0282*  ;
0419CD CD 20 0B 04 0283*  END_:			CALL    SETLIN          ;FIND CURRENT LINE
0419D1 7C          0284*  			LD      A,H
0419D2 B5          0285*  			OR      L               ;DIRECT?
0419D3 CA F2 01 04 0286*  			JP      Z,CLOOP
0419D7 1E 00       0287*  			LD      E,0
0419D9 CD 16 49 04 0288*  			CALL    OSSHUT          ;CLOSE ALL FILES
0419DD C3 F1 01 04 0289*  			JP      WARM            ;"Ready"
0419E1             0290*  ;
0419E1 FD 7E 00    0291*  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0419E4 01 03 00 00 0292*  			LD      BC,3
0419E8 FD 09       0293*  			ADD     IY,BC
0419EA B7          0294*  			OR      A
0419EB 28 E0       0295*  			JR      Z,END_           ;LENGTH=0, EXIT
0419ED 2A 26 4D 04 0296*  			LD      HL,(TRACEN)
0419F1 7C          0297*  			LD      A,H
0419F2 B5          0298*  			OR      L
0419F3 C8          0299*  			RET     Z
0419F4 11 00 00 00 0300*  			LD	DE, 0		;Clear DE
0419F8 FD 56 FF    0301*  			LD      D,(IY-1)        ;DE = LINE NUMBER
0419FB FD 5E FE    0302*  			LD      E,(IY-2)
0419FE ED 52       0303*  			SBC     HL,DE
041A00 D8          0304*  			RET     C
041A01 EB          0305*  			EX      DE,HL
041A02 3E 5B       0306*  			LD      A,'['           ;TRACE
041A04 CD C1 0A 04 0307*  			CALL    OUTCHR
041A08 CD 69 0B 04 0308*  			CALL    PBCDL
041A0C 3E 5D       0309*  			LD      A,']'
041A0E CD C1 0A 04 0310*  			CALL    OUTCHR
041A12 3E 20       0311*  			LD      A,' '
041A14 C3 C1 0A 04 0312*  			JP      OUTCHR
041A18             0313*  
041A18             0314*  ; Routines for each statement -------------------------------------------------
041A18             0315*  
041A18             0316*  ; OSCLI
041A18             0317*  ;
041A18 CD 19 11 04 0318*  CLI:			CALL    EXPRS
041A1C 3E 0D       0319*  			LD      A,CR
041A1E 12          0320*  			LD      (DE),A
041A1F 21 00 4A 04 0321*  			LD      HL,ACCS
041A23 CD 6A 45 04 0322*  			CALL    OSCLI
041A27 C3 9D 19 04 0323*  			JP      XEQ
041A2B             0324*  
041A2B             0325*  ; REM, *
041A2B             0326*  ;
041A2B FD E5       0327*  EXT_EX:			PUSH    IY
041A2D E1          0328*  			POP     HL
041A2E CD 6A 45 04 0329*  			CALL    OSCLI
041A32 FD E5       0330*  REM_EX:			PUSH    IY
041A34 E1          0331*  			POP     HL
041A35 3E 0D       0332*  			LD      A,CR
041A37 47          0333*  			LD      B,A
041A38 ED B1       0334*  			CPIR                    ;FIND LINE END
041A3A E5          0335*  			PUSH    HL
041A3B FD E1       0336*  			POP     IY
041A3D C3 99 19 04 0337*  			JP      XEQ0
041A41             0338*  
041A41             0339*  ; [LET] var = expr
041A41             0340*  ;
041A41 FE C5       0341*  LET0:			CP      ELSE_-TCMD
041A43 28 ED       0342*  			JR      Z,REM_EX
041A45             0343*  			; CP      ('*'-TCMD) & 0FFH
041A45             0344*  			; JR      Z,EXT_EX
041A45             0345*  			; CP      ('='-TCMD) & 0FFH
041A45             0346*  			; JR      Z,FNEND
041A45             0347*  			; CP      ('['-TCMD) & 0FFH
041A45             0348*  			; ez80asm doesn't like () in expressions
041A45 FE 64       0349*  			CP      '*'-TCMD & 0FFH
041A47 28 E2       0350*  			JR      Z,EXT_EX
041A49 FE 77       0351*  			CP      '='-TCMD & 0FFH
041A4B 28 5B       0352*  			JR      Z,FNEND
041A4D FE 95       0353*  			CP      '['-TCMD & 0FFH
041A4F 28 25       0354*  			JR      Z,ASM
041A51 FD 2B       0355*  			DEC     IY
041A53 CD EF 23 04 0356*  LET:			CALL    ASSIGN			; Assign the variable
041A57 CA 9D 19 04 0357*  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
041A5B 38 41       0358*  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
041A5D             0359*  ;
041A5D F5          0360*  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
041A5E CD C1 25 04 0361*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041A62 E5          0362*  			PUSH    HL			; HL: Address of the variable
041A63 CD 19 11 04 0363*  			CALL    EXPRS
041A67 DD E1       0364*  			POP     IX			; IX: Address of the variable
041A69 F1          0365*  			POP     AF			; AF: The variable type
041A6A CD 31 24 04 0366*  			CALL    STACCS			; Copy the string from ACCS to the variable area
041A6E C3 9D 19 04 0367*  XEQR:			JP      XEQ
041A72             0368*  ;
041A72 CD E1 19 04 0369*  ASM0:			CALL    NEWLIN
041A76 FD 22 35 4D 0370*  ASM:			LD      (ERRLIN),IY
       04          
041A7B CD 47 45 04 0371*  			CALL    TRAP
041A7F CD CC 26 04 0372*  			CALL    ASSEM
041A83 38 19       0373*  			JR      C,SYNTAX
041A85 FE 0D       0374*  			CP      CR
041A87 28 E9       0375*  			JR      Z,ASM0
041A89 21 40 4D 04 0376*  			LD      HL,LISTON
041A8D 7E          0377*  			LD      A,(HL)
041A8E E6 0F       0378*  			AND     0FH
041A90 F6 B0       0379*  			OR      B0H
041A92 77          0380*  			LD      (HL),A
041A93 18 D9       0381*  			JR      XEQR
041A95             0382*  ;
041A95 CD AC 0B 04 0383*  VAR_:			CALL    GETVAR
041A99 C8          0384*  			RET     Z
041A9A D2 9B 0B 04 0385*  			JP      NC,PUTVAR
041A9E 3E 10       0386*  SYNTAX:			LD      A,16            ;"Syntax error"
041AA0 18 02       0387*  			JR	ERROR0_EX
041AA2 3E 11       0388*  ESCAPE:			LD      A,17            ;"Escape"
041AA4 C3 D2 08 04 0389*  ERROR0_EX:			JP      ERROR_
041AA8             0390*  
041AA8             0391*  ; =
041AA8             0392*  ;
041AA8 CD C6 0F 04 0393*  FNEND:			CALL    EXPR            ;FUNCTION RESULT
041AAC 43          0394*  			LD      B,E
041AAD EB          0395*  			EX      DE,HL
041AAE D9          0396*  			EXX                     ;SAVE RESULT
041AAF EB          0397*  			EX      DE,HL           ; IN DEB'C'D'E'
041AB0 C1          0398*  FNEND5:			POP     BC
041AB1 21 89 25 04 0399*  			LD      HL,LOCCHK
041AB5 B7          0400*  			OR      A
041AB6 ED 42       0401*  			SBC     HL,BC
041AB8 28 1C       0402*  			JR      Z,FNEND0        ;LOCAL VARIABLE
041ABA 21 8B 1E 04 0403*  			LD      HL,FNCHK
041ABE B7          0404*  			OR      A
041ABF ED 42       0405*  			SBC     HL,BC
041AC1 3E 07       0406*  			LD      A,7
041AC3 20 DF       0407*  			JR      NZ,ERROR0_EX       ;"No FN"
041AC5 FD E1       0408*  			POP     IY
041AC7 FD 22 35 4D 0409*  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
041ACC EB          0410*  			EX      DE,HL
041ACD D9          0411*  			EXX
041ACE EB          0412*  			EX      DE,HL
041ACF 11 00 4A 04 0413*  			LD      DE,ACCS
041AD3 58          0414*  			LD      E,B
041AD4 08          0415*  			EX      AF,AF'
041AD5 C9          0416*  			RET
041AD6             0417*  ;
041AD6 DD E1       0418*  FNEND0:			POP     IX
041AD8 C1          0419*  			POP     BC
041AD9 78          0420*  			LD      A,B
041ADA B7          0421*  			OR      A
041ADB FA E9 1A 04 0422*  			JP      M,FNEND1        ;STRING
041ADF E1          0423*  			POP     HL
041AE0 D9          0424*  			EXX
041AE1 E1          0425*  			POP     HL
041AE2 D9          0426*  			EXX
041AE3 CD 07 24 04 0427*  			CALL    STORE
041AE7 18 C7       0428*  			JR      FNEND5
041AE9 21 00 00 00 0429*  FNEND1:			LD      HL,0
041AED 39          0430*  			ADD     HL,SP
041AEE D5          0431*  			PUSH    DE
041AEF 59          0432*  			LD      E,C
041AF0 CD 35 24 04 0433*  			CALL    STORES
041AF4 D1          0434*  			POP     DE
041AF5 F9          0435*  			LD      SP,HL
041AF6 18 B8       0436*  			JR      FNEND5
041AF8             0437*  
041AF8             0438*  ; DIM var(dim1[,dim2[,...]])[,var(...]
041AF8             0439*  ; DIM var expr[,var expr...]
041AF8             0440*  ;
041AF8 CD AC 0B 04 0441*  DIM_EX:			CALL    GETVAR          	; Get the variable
041AFC DA 88 1B 04 0442*  			JP      C,BADDIM		; Throw a "Bad Dim" error
041B00 CA 92 1B 04 0443*  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
041B04 CD 20 0D 04 0444*  			CALL    CREATE			; Create a new entity
041B08 E5          0445*  			PUSH    HL			; HL: Address of the entity
041B09 DD E1       0446*  			POP     IX			; IX: Address of the entity
041B0B FD 7E 00    0447*  			LD      A,(IY)			; Fetch the next character from the tokenised string
041B0E FE 28       0448*  			CP      '('			; Check for opening brackets
041B10 7A          0449*  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
041B11 20 7F       0450*  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
041B13             0451*  ;
041B13             0452*  ; At this point we're reserving a variable array
041B13             0453*  ;
041B13 E5          0454*  			PUSH    HL			; HL: Address of the entity
041B14 F5          0455*  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
041B15 11 01 00 00 0456*  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
041B19 42          0457*  			LD      B,D			;  B: The number of dimensions in the array
041B1A             0458*  ;
041B1A FD 23       0459*  DIM1:			INC     IY			; Skip to the next token
041B1C C5          0460*  			PUSH    BC			; Stack the dimension counter
041B1D D5          0461*  			PUSH    DE			; Stack the total size of array accumulator
041B1E DD E5       0462*  			PUSH    IX			; Stack the entity address
041B20 CD 0E 11 04 0463*  			CALL    EXPRI           	; Fetch the size of this dimension
041B24 CB 7C       0464*  			BIT     7,H			; If it is negative then
041B26 20 60       0465*  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
041B28 D9          0466*  			EXX
041B29 23          0467*  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
041B2A DD E1       0468*  			POP     IX			; IX: The entity address
041B2C DD 23       0469*  			INC     IX
041B2E DD 75 00    0470*  			LD      (IX),L          	; Save the size of this dimension in the entity
041B31 DD 23       0471*  			INC     IX
041B33 DD 74 00    0472*  			LD      (IX),H
041B36 C1          0473*  			POP     BC
041B37 CD A3 26 04 0474*  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
041B3B 38 4F       0475*  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
041B3D EB          0476*  			EX      DE,HL           	; DE: The new total size of array accumulator
041B3E C1          0477*  			POP     BC
041B3F 04          0478*  			INC     B               	;  B: The dimension counter; increment
041B40 FD 7E 00    0479*  			LD      A,(IY)			; Fetch the nex token
041B43 FE 2C       0480*  			CP      ','             	; Check for another dimension in the array
041B45 28 D3       0481*  			JR      Z,DIM1			; And loop
041B47             0482*  ;
041B47 CD 36 18 04 0483*  			CALL    BRAKET          	; Check for closing bracket
041B4B F1          0484*  			POP     AF              	; Restore the type
041B4C DD 23       0485*  			INC     IX
041B4E DD E3       0486*  			EX      (SP),IX
041B50 DD 70 00    0487*  			LD      (IX),B          	; Number of dimensions
041B53 CD 96 26 04 0488*  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
041B57 E1          0489*  			POP     HL			; Restore the entity address
041B58 38 32       0490*  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
041B5A             0491*  ;
041B5A             0492*  ; We now allocate the memory for the array
041B5A             0493*  ;
041B5A 19          0494*  DIM3:			ADD     HL,DE
041B5B 38 2F       0495*  			JR      C,NOROOM
041B5D E5          0496*  			PUSH    HL
041B5E 24          0497*  			INC     H
041B5F 28 2B       0498*  			JR      Z,NOROOM
041B61 ED 72       0499*  			SBC     HL,SP
041B63 30 27       0500*  			JR      NC,NOROOM       	; Throw an "Out of Space" error
041B65 E1          0501*  			POP     HL
041B66 22 1D 4D 04 0502*  			LD      (FREE),HL
041B6A 7A          0503*  DIM2:			LD      A,D
041B6B B3          0504*  			OR      E
041B6C 28 06       0505*  			JR      Z,DIM5
041B6E 2B          0506*  			DEC     HL
041B6F 36 00       0507*  			LD      (HL),0         		; Initialise the array
041B71 1B          0508*  			DEC     DE
041B72 18 F6       0509*  			JR      DIM2
041B74 CD 77 18 04 0510*  DIM5:			CALL    NXT
041B78 FE 2C       0511*  			CP      ','            		; Another variable?
041B7A C2 9D 19 04 0512*  			JP      NZ,XEQ
041B7E FD 23       0513*  			INC     IY
041B80 CD 77 18 04 0514*  			CALL    NXT
041B84 C3 F8 1A 04 0515*  			JP      DIM_EX
041B88             0516*  ;
041B88             0517*  ; DIM errors
041B88             0518*  ;
041B88 3E 0A       0519*  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
041B8A 18 02       0520*  			JR	ERROR1_EX
041B8C 3E 0B       0521*  NOROOM:			LD      A,11            	; Throw a "DIM space" error
041B8E C3 D2 08 04 0522*  ERROR1_EX:			JP      ERROR_
041B92             0523*  ;
041B92             0524*  ; At this point we're reserving a block of memory, i.e.
041B92             0525*  ; DIM var expr[,var expr...]
041B92             0526*  ;
041B92 B7          0527*  DIM4:			OR      A			;  A: The dimension variable type
041B93 28 F3       0528*  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
041B95 FA 88 1B 04 0529*  			JP      M,BADDIM        	; or a string
041B99 47          0530*  			LD      B,A			; Temporarily store the dimension variable type in B
041B9A FD 7E FF    0531*  			LD      A,(IY-1)		; Get the last character but one
041B9D FE 29       0532*  			CP      ')'			; Check if it is a trailing bracket
041B9F 28 E7       0533*  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
041BA1             0534*  ;
041BA1 21 00 00 00 0535*  			LD	HL,0			; Clear HL
041BA5 3A 1D 4D 04 0536*  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
041BA9 6F          0537*  			LD	L,A
041BAA 3A 1E 4D 04 0538*  			LD	A,(FREE+1)
041BAE 67          0539*  			LD	H,A
041BAF 78          0540*  			LD	A,B			; Restore the dimension variable type
041BB0 D9          0541*  			EXX
041BB1 21 00 00 00 0542*  			LD	HL,0			; Clear HL
041BB5 47          0543*  			LD	B,A			; Temporarily store the dimension variable type in B
041BB6 3A 1F 4D 04 0544*  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
041BBA 6F          0545*  			LD	L,A
041BBB 78          0546*  			LD	A,B			; Restore the dimension variable type
041BBC 4C          0547*  			LD	C,H
041BBD CD 07 24 04 0548*  			CALL    STORE           	; Store the address
041BC1 CD 0E 11 04 0549*  			CALL    EXPRI			; Get the number of bytes to store
041BC5 D9          0550*  			EXX
041BC6 23          0551*  			INC     HL			; Add one to it
041BC7 EB          0552*  			EX      DE,HL
041BC8 2A 1D 4D 04 0553*  			LD      HL,(FREE)
041BCC 18 8C       0554*  			JR      DIM3			; Continue with the DIM
041BCE             0555*  
041BCE             0556*  ; PRINT list...
041BCE             0557*  ; PRINT #channel,list...
041BCE             0558*  ;
041BCE FE 23       0559*  PRINT_:			CP      '#'
041BD0 20 7C       0560*  			JR      NZ,PRINT0
041BD2 CD C3 26 04 0561*  			CALL    CHNL            ;CHANNEL NO. = E
041BD6 CD 77 18 04 0562*  PRNTN1:			CALL    NXT
041BDA FE 2C       0563*  			CP      ','
041BDC C2 9D 19 04 0564*  			JP      NZ,XEQ
041BE0 FD 23       0565*  			INC     IY
041BE2 D5          0566*  			PUSH    DE
041BE3 CD C6 0F 04 0567*  			CALL    EXPR            ;ITEM TO PRINT
041BE7 08          0568*  			EX      AF,AF'
041BE8 FA 0E 1C 04 0569*  			JP      M,PRNTN2        ;STRING
041BEC D1          0570*  			POP     DE
041BED C5          0571*  			PUSH    BC
041BEE D9          0572*  			EXX
041BEF 7D          0573*  			LD      A,L
041BF0 D9          0574*  			EXX
041BF1 CD 26 49 04 0575*  			CALL    OSBPUT
041BF5 D9          0576*  			EXX
041BF6 7C          0577*  			LD      A,H
041BF7 D9          0578*  			EXX
041BF8 CD 26 49 04 0579*  			CALL    OSBPUT
041BFC 7D          0580*  			LD      A,L
041BFD CD 26 49 04 0581*  			CALL    OSBPUT
041C01 7C          0582*  			LD      A,H
041C02 CD 26 49 04 0583*  			CALL    OSBPUT
041C06 C1          0584*  			POP     BC
041C07 79          0585*  			LD      A,C
041C08 CD 26 49 04 0586*  			CALL    OSBPUT
041C0C 18 C8       0587*  			JR      PRNTN1
041C0E 4B          0588*  PRNTN2:			LD      C,E
041C0F D1          0589*  			POP     DE
041C10 21 00 4A 04 0590*  			LD      HL,ACCS
041C14 0C          0591*  			INC     C
041C15 0D          0592*  PRNTN3:			DEC     C
041C16 28 0A       0593*  			JR      Z,PRNTN4
041C18 7E          0594*  			LD      A,(HL)
041C19 23          0595*  			INC     HL
041C1A C5          0596*  			PUSH    BC
041C1B CD 26 49 04 0597*  			CALL    OSBPUT
041C1F C1          0598*  			POP     BC
041C20 18 F3       0599*  			JR      PRNTN3
041C22 3E 0D       0600*  PRNTN4:			LD      A,CR
041C24 CD 26 49 04 0601*  			CALL    OSBPUT
041C28 18 AC       0602*  			JR      PRNTN1
041C2A             0603*  ;
041C2A 06 02       0604*  PRINT6:			LD      B,2
041C2C 18 27       0605*  			JR      PRINTC
041C2E 01 00 01 00 0606*  PRINT8:			LD      BC,100H
041C32 18 21       0607*  			JR      PRINTC
041C34 21 00 4C 04 0608*  PRINT9:			LD      HL,STAVAR
041C38 AF          0609*  			XOR     A
041C39 BE          0610*  			CP      (HL)
041C3A 28 12       0611*  			JR      Z,PRINT0
041C3C 3A 3D 4D 04 0612*  			LD      A,(COUNT)
041C40 B7          0613*  			OR      A
041C41 28 0B       0614*  			JR      Z,PRINT0
041C43 96          0615*  PRINTA:			SUB     (HL)
041C44 28 08       0616*  			JR      Z,PRINT0
041C46 30 FB       0617*  			JR      NC,PRINTA
041C48 ED 44       0618*  			NEG
041C4A CD 20 26 04 0619*  			CALL    FILL
041C4E 3A 00 4C 04 0620*  PRINT0:			LD      A,(STAVAR)
041C52 4F          0621*  			LD      C,A             ;PRINTS
041C53 06 00       0622*  			LD      B,0             ;PRINTF
041C55 CD AB 25 04 0623*  PRINTC:			CALL    TERMQ
041C59 28 3F       0624*  			JR      Z,PRINT4
041C5B CB 80       0625*  			RES     0,B
041C5D FD 23       0626*  			INC     IY
041C5F FE 7E       0627*  			CP      '~'
041C61 28 C7       0628*  			JR      Z,PRINT6
041C63 FE 3B       0629*  			CP      ';'
041C65 28 C7       0630*  			JR      Z,PRINT8
041C67 FE 2C       0631*  			CP      ','
041C69 28 C9       0632*  			JR      Z,PRINT9
041C6B CD D0 25 04 0633*  			CALL    FORMAT          ;SPC, TAB, '
041C6F 28 E4       0634*  			JR      Z,PRINTC
041C71 FD 2B       0635*  			DEC     IY
041C73 C5          0636*  			PUSH    BC
041C74 CD C6 0F 04 0637*  			CALL    EXPR            ;VARIABLE TYPE
041C78 08          0638*  			EX      AF,AF'
041C79 FA 93 1C 04 0639*  			JP      M,PRINT3        ;STRING
041C7D D1          0640*  			POP     DE
041C7E D5          0641*  			PUSH    DE
041C7F CB 4A       0642*  			BIT     1,D
041C81 F5          0643*  			PUSH    AF
041C82 CC 6A 17 04 0644*  			CALL    Z,STR           ;DECIMAL
041C86 F1          0645*  			POP     AF
041C87 C4 1E 17 04 0646*  			CALL    NZ,HEXSTR       ;HEX
041C8B C1          0647*  			POP     BC
041C8C C5          0648*  			PUSH    BC
041C8D 79          0649*  			LD      A,C
041C8E 93          0650*  			SUB     E
041C8F D4 20 26 04 0651*  			CALL    NC,FILL         ;RIGHT JUSTIFY
041C93 C1          0652*  PRINT3:			POP     BC
041C94 CD 2F 26 04 0653*  			CALL    PTEXT           ;PRINT
041C98 18 BB       0654*  			JR      PRINTC
041C9A CB 40       0655*  PRINT4:			BIT     0,B
041C9C CC B9 0A 04 0656*  			CALL    Z,CRLF
041CA0 C3 9D 19 04 0657*  			JP      XEQ
041CA4             0658*  
041CA4             0659*  ; ON ERROR statement [:statement...]
041CA4             0660*  ; ON ERROR OFF
041CA4             0661*  ;
041CA4 FD 23       0662*  ONERR:			INC     IY              ;SKIP "ERROR"
041CA6 21 00 00 00 0663*  			LD      HL,0
041CAA 22 2C 4D 04 0664*  			LD      (ERRTRP),HL
041CAE CD 77 18 04 0665*  			CALL    NXT
041CB2 FE 87       0666*  			CP      OFF_
041CB4 FD 23       0667*  			INC     IY
041CB6 CA 9D 19 04 0668*  			JP      Z,XEQ
041CBA FD 2B       0669*  			DEC     IY
041CBC FD 22 2C 4D 0670*  			LD      (ERRTRP),IY
       04          
041CC1 C3 32 1A 04 0671*  			JP      REM_EX
041CC5             0672*  
041CC5             0673*  ; ON expr GOTO line[,line...] [ELSE statement]
041CC5             0674*  ; ON expr GOTO line[,line...] [ELSE line]
041CC5             0675*  ; ON expr GOSUB line[,line...] [ELSE statement]
041CC5             0676*  ; ON expr GOSUB line[,line...] [ELSE line]
041CC5             0677*  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
041CC5             0678*  ;
041CC5 FE 85       0679*  ON_EX_:			CP      TERROR
041CC7 28 DB       0680*  			JR      Z,ONERR         ;"ON ERROR"
041CC9 CD 0E 11 04 0681*  			CALL    EXPRI
041CCD FD 7E 00    0682*  			LD      A,(IY)
041CD0 FD 23       0683*  			INC     IY
041CD2 1E 2C       0684*  			LD      E,','           ;SEPARATOR
041CD4 FE E5       0685*  			CP      TGOTO
041CD6 28 0B       0686*  			JR      Z,ON1
041CD8 FE E4       0687*  			CP      TGOSUB
041CDA 28 07       0688*  			JR      Z,ON1
041CDC 1E F2       0689*  			LD      E,TPROC
041CDE BB          0690*  			CP      E
041CDF 3E 27       0691*  			LD      A,39
041CE1 20 45       0692*  			JR      NZ,ERROR2_EX       ;"ON syntax"
041CE3 57          0693*  ON1:			LD      D,A
041CE4 D9          0694*  			EXX
041CE5 E5          0695*  			PUSH    HL
041CE6 D9          0696*  			EXX
041CE7 C1          0697*  			POP     BC              ;ON INDEX
041CE8 78          0698*  			LD      A,B
041CE9 B4          0699*  			OR      H
041CEA B5          0700*  			OR      L
041CEB 20 2A       0701*  			JR      NZ,ON4          ;OUT OF RANGE
041CED B1          0702*  			OR      C
041CEE 28 27       0703*  			JR      Z,ON4
041CF0 0D          0704*  			DEC     C
041CF1 28 0E       0705*  			JR      Z,ON3           ;INDEX=1
041CF3 CD AB 25 04 0706*  ON2:			CALL    TERMQ
041CF7 28 1E       0707*  			JR      Z,ON4           ;OUT OF RANGE
041CF9 FD 23       0708*  			INC     IY              ;SKIP DELIMITER
041CFB BB          0709*  			CP      E
041CFC 20 F5       0710*  			JR      NZ,ON2
041CFE 0D          0711*  			DEC     C
041CFF 20 F2       0712*  			JR      NZ,ON2
041D01 7B          0713*  ON3:			LD      A,E
041D02 FE F2       0714*  			CP      TPROC
041D04 28 26       0715*  			JR      Z,ONPROC
041D06 D5          0716*  			PUSH    DE
041D07 CD 29 11 04 0717*  			CALL    ITEMI           ;LINE NUMBER
041D0B D1          0718*  			POP     DE
041D0C 7A          0719*  			LD      A,D
041D0D FE E5       0720*  			CP      TGOTO
041D0F 28 2D       0721*  			JR      Z,GOTO2
041D11 CD B8 25 04 0722*  			CALL    SPAN            ;SKIP REST OF LIST
041D15 18 3B       0723*  			JR      GOSUB1
041D17             0724*  ;
041D17 FD 7E 00    0725*  ON4:			LD      A,(IY)
041D1A FD 23       0726*  			INC     IY
041D1C FE 8B       0727*  			CP      ELSE_
041D1E CA 52 21 04 0728*  			JP      Z,IF1           ;ELSE CLAUSE
041D22 FE 0D       0729*  			CP      CR
041D24 20 F1       0730*  			JR      NZ,ON4
041D26 3E 28       0731*  			LD      A,40
041D28 C3 D2 08 04 0732*  ERROR2_EX:			JP      ERROR_           ;"ON range"
041D2C             0733*  ;
041D2C 3E EE       0734*  ONPROC:			LD      A,TON
041D2E C3 8B 1E 04 0735*  			JP      PROC_EX
041D32             0736*  
041D32             0737*  ; GOTO line
041D32             0738*  ;
041D32 CD 29 11 04 0739*  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
041D36 CD AB 25 04 0740*  GOTO1:			CALL    TERMQ			; Check for terminator
041D3A C2 9E 1A 04 0741*  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
041D3E D9          0742*  GOTO2:			EXX
041D3F CD 01 0B 04 0743*  			CALL    FINDL			; HL: Line number - Find the line
041D43 E5          0744*  			PUSH    HL			; HL: Address of the line
041D44 FD E1       0745*  			POP     IY			; IY = HL
041D46 CA 99 19 04 0746*  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
041D4A 3E 29       0747*  			LD      A,41			; Otherwise throw a "No such line" error
041D4C 18 DA       0748*  			JR      ERROR2_EX
041D4E             0749*  
041D4E             0750*  ; GOSUB line
041D4E             0751*  ; This pushes the following data onto the execution stack
041D4E             0752*  ; - 3 bytes: Current execution address
041D4E             0753*  ; - 3 bytes: Marker (the address of label GOSCHK)
041D4E             0754*  ;
041D4E CD 29 11 04 0755*  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
041D52 FD E5       0756*  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
041D54 CD 80 24 04 0757*  			CALL    CHECK           	; Check there is enough room
041D58 CD 36 1D 04 0758*  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
041D5C             0759*  GOSCHK:			EQU     $
041D5C             0760*  
041D5C             0761*  ; RETURN
041D5C             0762*  ; This pops the following data off the execution stack as pushed by GOSUB
041D5C             0763*  ; - 3 bytes: Marker (should be the address of label GOSCHK)
041D5C             0764*  ; - 3 bytes: The return execution address
041D5C             0765*  ;
041D5C D1          0766*  RETURN:			POP     DE			; Pop the marker off the execution stack
041D5D 21 5C 1D 04 0767*  			LD      HL,GOSCHK		; Compare with GOSCHK
041D61 B7          0768*  			OR      A
041D62 ED 52       0769*  			SBC     HL,DE
041D64 FD E1       0770*  			POP     IY			; Pop the return address off the execution stack
041D66 CA 9D 19 04 0771*  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
041D6A 3E 26       0772*  			LD      A,38			; Otherwise throw a "No GOSUB" error
041D6C 18 BA       0773*  			JR      ERROR2_EX
041D6E             0774*  
041D6E             0775*  ; REPEAT
041D6E             0776*  ; This pushes the following data onto the execution stack
041D6E             0777*  ; - 3 bytes: Current execution address
041D6E             0778*  ; - 3 bytes: Marker (the address of label REPCHK)
041D6E             0779*  ;
041D6E FD E5       0780*  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
041D70 CD 80 24 04 0781*  			CALL    CHECK			; Check if there is enough room
041D74 CD 9D 19 04 0782*  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
041D78             0783*  REPCHK:			EQU     $
041D78             0784*  
041D78             0785*  ; UNTIL expr
041D78             0786*  ; This pops the following data off the execution stack
041D78             0787*  ; - 3 bytes: Marker (should be the address of label REPCHK)
041D78             0788*  ; - 3 bytes: The address of the REPEAT instruction
041D78             0789*  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
041D78             0790*  ;
041D78 C1          0791*  UNTIL_EX:			POP     BC			; Fetch the marker
041D79 C5          0792*  			PUSH    BC			; And push it back onto the execution stack
041D7A 21 78 1D 04 0793*  			LD      HL,REPCHK		; Compare with REPCHK
041D7E B7          0794*  			OR      A
041D7F ED 42       0795*  			SBC     HL,BC
041D81 3E 2B       0796*  			LD      A,43
041D83 20 A3       0797*  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
041D85 CD 0E 11 04 0798*  			CALL    EXPRI			; Fetch the expression
041D89 CD E3 16 04 0799*  			CALL    TEST			; Test if the expression evaluates to zero
041D8D C1          0800*  			POP     BC			; Pop the marker
041D8E D1          0801*  			POP     DE			; Pop the address of the REPEAT instruction
041D8F 20 05       0802*  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
041D91 D5          0803*  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
041D92 C5          0804*  			PUSH    BC			; Push the marker back on the stack
041D93 D5          0805*  			PUSH    DE			; IY = DE
041D94 FD E1       0806*  			POP     IY			; This sets the execution address back to the REPEAT instruction
041D96 C3 9D 19 04 0807*  XEQ2:			JP      XEQ			; Continue execution
041D9A             0808*  
041D9A             0809*  ; FOR var = expr TO expr [STEP expr]
041D9A             0810*  ; This pushes the following data onto the execution stack
041D9A             0811*  ; - 3 bytes: The limit value
041D9A             0812*  ; - 3 bytes: The step value
041D9A             0813*  ; - 3 bytes: The current execution address
041D9A             0814*  ; - 3 bytes: The address of the loop variable
041D9A             0815*  ; - 3 bytes: Marker (the address of FORCHK)
041D9A             0816*  ;
041D9A 3E 22       0817*  FORVAR:			LD      A,34
041D9C 18 8A       0818*  			JR      ERROR2_EX          	; Throw "FOR variable" error
041D9E             0819*  ;
041D9E CD EF 23 04 0820*  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
041DA2 20 F6       0821*  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
041DA4 F5          0822*  			PUSH    AF              	; Save the variable type
041DA5 FD 7E 00    0823*  			LD      A,(IY)			; Check the next token
041DA8 FE B8       0824*  			CP      TO			; Compare with the token value for "TO"
041DAA 3E 24       0825*  			LD      A,36			; Set the error code to 36 ("No TO")
041DAC C2 28 1D 04 0826*  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
041DB0 FD 23       0827*  			INC     IY			; Skip to the next token
041DB2             0828*  ;
041DB2 DD E5       0829*  			PUSH    IX
041DB4 CD 06 11 04 0830*  			CALL    EXPRN           	; Fetch the LIMIT expression value
041DB8 DD E1       0831*  			POP     IX
041DBA F1          0832*  			POP     AF
041DBB 47          0833*  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
041DBC C5          0834*  			PUSH    BC              	; Stack the LIMIT value
041DBD E5          0835*  			PUSH    HL
041DBE 21 00 00 00 0836*  			LD      HL,0
041DC2 4C          0837*  			LD      C,H
041DC3 D9          0838*  			EXX
041DC4 E5          0839*  			PUSH    HL
041DC5             0840*  ;
041DC5 21 01 00 00 0841*  			LD      HL,1            	; The preset STEP value is 1
041DC9 D9          0842*  			EXX
041DCA FD 7E 00    0843*  			LD      A,(IY)			; Fetch the next token
041DCD FE 88       0844*  			CP      STEP			; Compare with the token value for "STEP"
041DCF 20 0A       0845*  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
041DD1             0846*  ;
041DD1 FD 23       0847*  			INC     IY			; Skip past the STEP token
041DD3 DD E5       0848*  			PUSH    IX
041DD5 CD 06 11 04 0849*  			CALL    EXPRN          		; Fetch the STEP expression value
041DD9 DD E1       0850*  			POP     IX
041DDB             0851*  ;
041DDB C5          0852*  FOR1:			PUSH    BC			; Stack the STEP value
041DDC E5          0853*  			PUSH    HL
041DDD D9          0854*  			EXX
041DDE E5          0855*  			PUSH    HL
041DDF D9          0856*  			EXX
041DE0             0857*  ;
041DE0 FD E5       0858*  			PUSH    IY              	; Stack the current execution address
041DE2 DD E5       0859*  			PUSH    IX              	; Stack the loop variable
041DE4 CD 80 24 04 0860*  			CALL    CHECK
041DE8 CD 9D 19 04 0861*  			CALL    XEQ
041DEC             0862*  FORCHK:			EQU     $
041DEC             0863*  
041DEC             0864*  ; NEXT [var[,var...]]
041DEC             0865*  ; This pops the following data off the execution stack
041DEC             0866*  ; - 3 bytes: Marker (the address of FORCHK)
041DEC             0867*  ; - 3 bytes: The address of the loop variable
041DEC             0868*  ; - 3 bytes: The current execution address
041DEC             0869*  ; - 3 bytes: The step value
041DEC             0870*  ; - 3 bytes: The limit value
041DEC             0871*  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
041DEC             0872*  ;
041DEC C1          0873*  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
041DED 21 EC 1D 04 0874*  			LD      HL,FORCHK		; Compare with FORCHK
041DF1 B7          0875*  			OR      A
041DF2 ED 42       0876*  			SBC     HL,BC
041DF4 3E 20       0877*  			LD      A,32
041DF6 C2 82 1E 04 0878*  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
041DFA CD AB 25 04 0879*  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
041DFE E1          0880*  			POP     HL			; Pop the address of the loop variable off the execution stack
041DFF E5          0881*  			PUSH    HL			; Push it back onto the execution stack
041E00 C5          0882*  			PUSH    BC			; Push the marker back onto the execution stack
041E01 E5          0883*  			PUSH    HL			; HL: Address of the loop variable off the stack
041E02 C4 AC 0B 04 0884*  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
041E06 D1          0885*  			POP     DE			; DE: Address of the loop variable off the stack
041E07 EB          0886*  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041E08 B7          0887*  			OR      A
041E09 ED 52       0888*  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041E0B 20 61       0889*  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041E0D D5          0890*  			PUSH    DE
041E0E DD 21 0C 00 0891*  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
041E13 DD 39       0892*  			ADD     IX,SP
041E15 CD 18 38 04 0893*  			CALL    DLOAD5_SPL      	; Load the STEP value
041E19 DD 7E 10    0894*  			LD      A,(IX+16)       	; Get the STEP type
041E1C DD E1       0895*  			POP     IX
041E1E CD 1A 12 04 0896*  			CALL    LOADN           	; Load the LOOP variable
041E22 CB 7A       0897*  			BIT     7,D             	; Check the sign
041E24 F5          0898*  			PUSH    AF
041E25 3E 0B       0899*  			LD      A,'+' & 0FH
041E27 CD A1 2E 04 0900*  			CALL    FPP             	; Add the STEP
041E2B 38 55       0901*  			JR      C,ERROR3_EX
041E2D F1          0902*  			POP     AF              	; Restore TYPE
041E2E F5          0903*  			PUSH    AF
041E2F CD 07 24 04 0904*  			CALL    STORE           	; Update the variable
041E33 DD 21 15 00 0905*  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041E38 DD 39       0906*  			ADD     IX,SP
041E3A CD 18 38 04 0907*  			CALL    DLOAD5_SPL      	; Load the LIMIT value
041E3E F1          0908*  			POP     AF
041E3F CC DB 16 04 0909*  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
041E43             0910*  			; LD      A,0+('<'-4) & 0FH
041E43 3E 08       0911*  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
041E45 CD A1 2E 04 0912*  			CALL    FPP             	; Test against the limit
041E49 38 37       0913*  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
041E4B 24          0914*  			INC     H
041E4C 20 14       0915*  			JR      NZ,LOOP_        	; Keep looping
041E4E 21 1B 00 00 0916*  			LD      HL,27			; Adjust the stack
041E52 39          0917*  			ADD     HL,SP
041E53 F9          0918*  			LD      SP,HL
041E54 CD 77 18 04 0919*  			CALL    NXT
041E58 FE 2C       0920*  			CP      ','			; Check for multiple variables
041E5A C2 9D 19 04 0921*  			JP      NZ,XEQ			; No, so we are done at ths point
041E5E FD 23       0922*  			INC     IY			; Increment to the next variable
041E60 18 8A       0923*  			JR      NEXT_EX			; And continue
041E62             0924*  ;
041E62 C1          0925*  LOOP_:			POP     BC
041E63 D1          0926*  			POP     DE
041E64 FD E1       0927*  			POP     IY
041E66 FD E5       0928*  			PUSH    IY
041E68 D5          0929*  			PUSH    DE
041E69 C5          0930*  			PUSH    BC
041E6A C3 9D 19 04 0931*  			JP      XEQ
041E6E             0932*  ;
041E6E 21 1B 00 00 0933*  NEXT1:			LD      HL,27			; TODO: What does this do?
041E72 39          0934*  			ADD     HL,SP
041E73 F9          0935*  			LD      SP,HL			; Adjust the stack
041E74 C1          0936*  			POP     BC
041E75 21 EC 1D 04 0937*  			LD      HL,FORCHK
041E79 ED 42       0938*  			SBC     HL,BC
041E7B E1          0939*  			POP     HL              	; Variable pointer
041E7C E5          0940*  			PUSH    HL
041E7D C5          0941*  			PUSH    BC
041E7E 28 89       0942*  			JR      Z,NEXT0
041E80             0943*  ;
041E80 3E 21       0944*  			LD      A,33
041E82 C3 D2 08 04 0945*  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
041E86             0946*  
041E86             0947*  ; FNname
041E86             0948*  ; N.B. ENTERED WITH A <> TON
041E86             0949*  ;
041E86 F5          0950*  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
041E87 CD 90 1E 04 0951*  			CALL    PROC1
041E8B             0952*  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041E8B             0953*  
041E8B             0954*  ; PROCname
041E8B             0955*  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
041E8B             0956*  ; This pushes the following data onto the execution stack
041E8B             0957*  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
041E8B             0958*  ; - 3 bytes: Marker (the address of PROCHK)
041E8B             0959*  ;
041E8B F5          0960*  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
041E8C CD 90 1E 04 0961*  			CALL    PROC1			; and is also space reserved on the stack for the return address
041E90             0962*  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
041E90             0963*  ;
041E90 CD 80 24 04 0964*  PROC1:			CALL    CHECK			; Check there is space for this
041E94 FD 2B       0965*  			DEC     IY			; Decrement IY to the PROC token
041E96 FD E5       0966*  			PUSH    IY			; Stack the pointer
041E98 CD 6D 0C 04 0967*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041E9C C1          0968*  			POP     BC			; BC = IY
041E9D 28 41       0969*  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
041E9F 3E 1E       0970*  			LD      A,30
041EA1 38 DF       0971*  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
041EA3             0972*  ;
041EA3             0973*  ; At this point the PROC/FN has not yet been registered in the dynamic area
041EA3             0974*  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
041EA3             0975*  ;
041EA3 C5          0976*  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
041EA4 2A 14 4D 04 0977*  			LD      HL,(PAGE_)		; HL: Start of program memory
041EA8             0978*  ;
041EA8 3E DD       0979*  PROC2:			LD      A,DEF_			;  A: The token to search for
041EAA CD 7F 26 04 0980*  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
041EAE 38 26       0981*  			JR      C,PROC3			; Not found, so jump to PROC3
041EB0 E5          0982*  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
041EB1 FD E1       0983*  			POP     IY			; IY = HL
041EB3 FD 23       0984*  			INC     IY              	; Skip the DEF token
041EB5 CD 77 18 04 0985*  			CALL    NXT			; And any whitespace
041EB9 CD 6D 0C 04 0986*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041EBD FD E5       0987*  			PUSH    IY
041EBF D1          0988*  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
041EC0 38 09       0989*  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
041EC2 C4 20 0D 04 0990*  			CALL    NZ,CREATE		; Create an entity in the dynamic area
041EC6 FD E5       0991*  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
041EC8 D1          0992*  			POP     DE			; DE = IY
041EC9 ED 1F       0993*  			LD	(HL),DE			; Save address
041ECB             0994*  ;
041ECB EB          0995*  PROC6:			EX      DE,HL			; HL: Address of the procedure
041ECC 3E 0D       0996*  			LD      A,CR			; The character to search for
041ECE 01 00 01 00 0997*  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
041ED2 ED B1       0998*  			CPIR                    	; Skip to next line
041ED4 18 D2       0999*  			JR      PROC2			; Rinse, lather and repeat
041ED6             1000*  ;
041ED6             1001*  ; At this point a DEF has not been found for the PROC/FN
041ED6             1002*  ;
041ED6 FD E1       1003*  PROC3:			POP     IY              	; Restore the execution address
041ED8 CD 6D 0C 04 1004*  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
041EDC 3E 1D       1005*  			LD      A,29
041EDE 20 A2       1006*  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
041EE0             1007*  ;
041EE0             1008*  ; At this point we have a PROC/FN entry in the dynamic area
041EE0             1009*  ;
041EE0 ED 17       1010*  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
041EE2 21 03 00 00 1011*  			LD	HL,3
041EE6 39          1012*  			ADD     HL,SP
041EE7 CD 77 18 04 1013*  			CALL    NXT             	; Allow space before "("
041EEB D5          1014*  			PUSH    DE              	; Exchange DE and IY
041EEC FD E3       1015*  			EX      (SP),IY
041EEE FE 28       1016*  			CP      '('             	; Arguments?
041EF0 D1          1017*  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
041EF1 20 20       1018*  			JR      NZ,PROC5
041EF3 CD 77 18 04 1019*  			CALL    NXT             	; Allow space before "("
041EF7 FE 28       1020*  			CP      '('
041EF9 C2 9E 1A 04 1021*  			JP      NZ,SYNTAX       	; Throw "Syntax error"
041EFD FD E5       1022*  			PUSH    IY
041EFF C1          1023*  			POP     BC              	; Save IY in BC
041F00 D9          1024*  			EXX
041F01 CD 2B 25 04 1025*  			CALL    SAVLOC          	; Save local parameters
041F05 CD 36 18 04 1026*  			CALL    BRAKET          	; Closing bracket
041F09 D9          1027*  			EXX
041F0A C5          1028*  			PUSH    BC
041F0B FD E1       1029*  			POP     IY              	; Restore IY
041F0D E5          1030*  			PUSH    HL
041F0E CD A7 24 04 1031*  			CALL    ARGUE           	; Transfer arguments
041F12 E1          1032*  			POP     HL
041F13             1033*  ;
041F13 23          1034*  PROC5:			INC	HL			; Increment to the ON PROC flag address
041F14 7E          1035*  			LD	A, (HL)			; And fetch the value
041F15 2B          1036*  			DEC 	HL
041F16 ED 1F       1037*  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041F18 FE EE       1038*  			CP	TON			; Was it "ON PROC"?
041F1A C2 9D 19 04 1039*  			JP	NZ, XEQ			; No, so back to XEQ
041F1E D5          1040*  			PUSH    DE			; Exchange DE and IY
041F1F FD E3       1041*  			EX      (SP),IY
041F21 CD B8 25 04 1042*  			CALL    SPAN            	; Skip rest of ON list
041F25 FD E3       1043*  			EX      (SP),IY			; Exchange DE and IY
041F27 D1          1044*  			POP     DE
041F28 ED 1F       1045*  			LD	(HL), DE		; Save the return address
041F2A C3 9D 19 04 1046*  			JP      XEQ
041F2E             1047*  
041F2E             1048*  ; LOCAL var[,var...]
041F2E             1049*  ;
041F2E C1          1050*  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
041F2F C5          1051*  			PUSH    BC
041F30 21 8B 1E 04 1052*  			LD      HL,FNCHK		; Check if we are in a FN
041F34 B7          1053*  			OR      A
041F35 ED 42       1054*  			SBC     HL,BC
041F37 28 16       1055*  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041F39 21 90 1E 04 1056*  			LD      HL,PROCHK		; Now check if we are in a PROC
041F3D B7          1057*  			OR      A
041F3E ED 42       1058*  			SBC     HL,BC
041F40 28 0D       1059*  			JR      Z,LOCAL1		; Again, all good, we can use local
041F42 21 89 25 04 1060*  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041F46 B7          1061*  			OR      A
041F47 ED 42       1062*  			SBC     HL,BC			; If it is not present, then
041F49 3E 0C       1063*  			LD      A,12
041F4B C2 D2 08 04 1064*  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041F4F             1065*  ;
041F4F             1066*  ; At this point we are adding a local variable into a PROC or FN
041F4F             1067*  ;
041F4F FD E5       1068*  LOCAL1:			PUSH    IY			; IY: BASIC pointer
041F51 C1          1069*  			POP     BC			; BC: Copy of the BASIC pointer
041F52 D9          1070*  			EXX
041F53 FD 2B       1071*  			DEC     IY
041F55 CD 2B 25 04 1072*  			CALL    SAVLOC
041F59 D9          1073*  			EXX
041F5A C5          1074*  			PUSH    BC
041F5B FD E1       1075*  			POP     IY
041F5D             1076*  ;
041F5D CD AC 0B 04 1077*  LOCAL2:			CALL    GETVAR			; Get the variable location
041F61 C2 9E 1A 04 1078*  			JP      NZ,SYNTAX
041F65 B7          1079*  			OR      A               	; Check the variable type (80h = string)
041F66 08          1080*  			EX      AF,AF'
041F67 CD 97 17 04 1081*  			CALL    ZERO			; Zero the variable anyway
041F6B 08          1082*  			EX      AF,AF'
041F6C F5          1083*  			PUSH    AF
041F6D F4 07 24 04 1084*  			CALL    P,STORE         	; Call STORE if it is not a string
041F71 F1          1085*  			POP     AF
041F72 59          1086*  			LD      E,C
041F73 FC 35 24 04 1087*  			CALL    M,STORES		; Call STORES if it is a string
041F77 CD 77 18 04 1088*  			CALL    NXT			; Skip to the next character in the expression
041F7B FE 2C       1089*  			CP      ','			; Is it a comma?
041F7D C2 9D 19 04 1090*  			JP      NZ,XEQ			; No, so we're done, carry on executing
041F81 FD 23       1091*  			INC     IY			; Yes, so skip the comma
041F83 CD 77 18 04 1092*  			CALL    NXT			; And any whitespace
041F87 18 D4       1093*  			JR      LOCAL2			; Then loop back and handle any further local variables
041F89             1094*  
041F89             1095*  ; ENDPROC
041F89             1096*  ;
041F89 C1          1097*  ENDPRO:			POP     BC			; Pop the check value off the stack
041F8A 21 89 25 04 1098*  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041F8E B7          1099*  			OR      A
041F8F ED 42       1100*  			SBC     HL,BC
041F91 28 13       1101*  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041F93             1102*  ;
041F93 21 90 1E 04 1103*  			LD      HL,PROCHK       	; Check if it is the PROC marker
041F97 B7          1104*  			OR      A
041F98 ED 42       1105*  			SBC     HL,BC
041F9A FD E1       1106*  			POP     IY
041F9C CA 9D 19 04 1107*  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
041FA0 3E 0D       1108*  			LD      A,13			; Otherwise throw the "No PROC" error
041FA2 C3 D2 08 04 1109*  			JP      ERROR_
041FA6             1110*  ;
041FA6 DD E1       1111*  UNSTK:			POP     IX			; Unstack a single local variable
041FA8 C1          1112*  			POP     BC
041FA9 78          1113*  			LD      A,B
041FAA B7          1114*  			OR      A
041FAB FA B9 1F 04 1115*  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
041FAF E1          1116*  			POP     HL			; Unstack a normal variable
041FB0 D9          1117*  			EXX
041FB1 E1          1118*  			POP     HL
041FB2 D9          1119*  			EXX
041FB3 CD 07 24 04 1120*  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
041FB7 18 D0       1121*  			JR      ENDPRO			; And loop back to ENDPRO
041FB9             1122*  ;
041FB9 21 00 00 00 1123*  UNSTK1:			LD      HL,0			; Unstack a string
041FBD 39          1124*  			ADD     HL,SP
041FBE 59          1125*  			LD      E,C
041FBF CD 35 24 04 1126*  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
041FC3 F9          1127*  			LD      SP,HL
041FC4 18 C3       1128*  			JR      ENDPRO
041FC6             1129*  
041FC6             1130*  ; INPUT #channel,var,var...
041FC6             1131*  ;
041FC6 CD C3 26 04 1132*  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
041FCA CD 77 18 04 1133*  INPN1:			CALL    NXT
041FCE FE 2C       1134*  			CP      ','
041FD0 C2 9D 19 04 1135*  			JP      NZ,XEQ
041FD4 FD 23       1136*  			INC     IY
041FD6 CD 77 18 04 1137*  			CALL    NXT
041FDA D5          1138*  			PUSH    DE
041FDB CD 95 1A 04 1139*  			CALL    VAR_
041FDF D1          1140*  			POP     DE
041FE0 F5          1141*  			PUSH    AF              ;SAVE TYPE
041FE1 E5          1142*  			PUSH    HL              ;VARPTR
041FE2 B7          1143*  			OR      A
041FE3 FA 0F 20 04 1144*  			JP      M,INPN2         ;STRING
041FE7 CD 1E 49 04 1145*  			CALL    OSBGET
041FEB D9          1146*  			EXX
041FEC 6F          1147*  			LD      L,A
041FED D9          1148*  			EXX
041FEE CD 1E 49 04 1149*  			CALL    OSBGET
041FF2 D9          1150*  			EXX
041FF3 67          1151*  			LD      H,A
041FF4 D9          1152*  			EXX
041FF5 CD 1E 49 04 1153*  			CALL    OSBGET
041FF9 6F          1154*  			LD      L,A
041FFA CD 1E 49 04 1155*  			CALL    OSBGET
041FFE 67          1156*  			LD      H,A
041FFF CD 1E 49 04 1157*  			CALL    OSBGET
042003 4F          1158*  			LD      C,A
042004 DD E1       1159*  			POP     IX
042006 F1          1160*  			POP     AF              ;RESTORE TYPE
042007 D5          1161*  			PUSH    DE              ;SAVE CHANNEL
042008 CD 07 24 04 1162*  			CALL    STORE
04200C D1          1163*  			POP     DE
04200D 18 BB       1164*  			JR      INPN1
04200F 21 00 4A 04 1165*  INPN2:			LD      HL,ACCS
042013 CD 1E 49 04 1166*  INPN3:			CALL    OSBGET
042017 FE 0D       1167*  			CP      CR
042019 28 04       1168*  			JR      Z,INPN4
04201B 77          1169*  			LD      (HL),A
04201C 2C          1170*  			INC     L
04201D 20 F4       1171*  			JR      NZ,INPN3
04201F DD E1       1172*  INPN4:			POP     IX
042021 F1          1173*  			POP     AF
042022 D5          1174*  			PUSH    DE
042023 EB          1175*  			EX      DE,HL
042024 CD 31 24 04 1176*  			CALL    STACCS
042028 D1          1177*  			POP     DE
042029 18 9F       1178*  			JR      INPN1
04202B             1179*  
04202B             1180*  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04202B             1181*  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
04202B             1182*  ;
04202B FE 23       1183*  INPUT:			CP      '#'
04202D 28 97       1184*  			JR      Z,INPUTN
04202F 0E 00       1185*  			LD      C,0             ;FLAG PROMPT
042031 FE 86       1186*  			CP      LINE_
042033 20 04       1187*  			JR      NZ,INPUT0
042035 FD 23       1188*  			INC     IY              ;SKIP "LINE"
042037 0E 80       1189*  			LD      C,80H
042039 21 00 4B 04 1190*  INPUT0:			LD      HL,BUFFER
04203D 36 0D       1191*  			LD      (HL),CR         ;INITIALISE EMPTY
04203F CD AB 25 04 1192*  INPUT1:			CALL    TERMQ
042043 CA 9D 19 04 1193*  			JP      Z,XEQ           ;DONE
042047 FD 23       1194*  			INC     IY
042049 FE 2C       1195*  			CP      ','
04204B 28 5C       1196*  			JR      Z,INPUT3        ;SKIP COMMA
04204D FE 3B       1197*  			CP      ';'
04204F 28 58       1198*  			JR      Z,INPUT3
042051 E5          1199*  			PUSH    HL              ;SAVE BUFFER POINTER
042052 FE 22       1200*  			CP      34		;ASCII ""
042054 20 0C       1201*  			JR      NZ,INPUT6
042056 C5          1202*  			PUSH    BC
042057 CD 6B 12 04 1203*  			CALL    CONS
04205B C1          1204*  			POP     BC
04205C CD 2F 26 04 1205*  			CALL    PTEXT           ;PRINT PROMPT
042060 18 06       1206*  			JR      INPUT9
042062 CD D0 25 04 1207*  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
042066 20 05       1208*  			JR      NZ,INPUT2
042068 E1          1209*  INPUT9:			POP     HL
042069 CB C1       1210*  			SET     0,C             ;FLAG NO PROMPT
04206B 18 CC       1211*  			JR      INPUT0
04206D FD 2B       1212*  INPUT2:			DEC     IY
04206F C5          1213*  			PUSH    BC
042070 CD 95 1A 04 1214*  			CALL    VAR_
042074 C1          1215*  			POP     BC
042075 E1          1216*  			POP     HL
042076 F5          1217*  			PUSH    AF              ;SAVE TYPE
042077 7E          1218*  			LD      A,(HL)
042078 23          1219*  			INC     HL
042079 FE 0D       1220*  			CP      CR              ;BUFFER EMPTY?
04207B CC AD 20 04 1221*  			CALL    Z,REFILL
04207F CB 79       1222*  			BIT     7,C
042081 F5          1223*  			PUSH    AF
042082 C4 51 26 04 1224*  			CALL    NZ,LINES
042086 F1          1225*  			POP     AF
042087 CC 3E 26 04 1226*  			CALL    Z,FETCHS
04208B F1          1227*  			POP     AF              ;RESTORE TYPE
04208C C5          1228*  			PUSH    BC
04208D E5          1229*  			PUSH    HL
04208E B7          1230*  			OR      A
04208F FA A3 20 04 1231*  			JP      M,INPUT4        ;STRING
042093 F5          1232*  			PUSH    AF
042094 DD E5       1233*  			PUSH    IX
042096 CD 72 14 04 1234*  			CALL    VAL0
04209A DD E1       1235*  			POP     IX
04209C F1          1236*  			POP     AF
04209D CD 07 24 04 1237*  			CALL    STORE
0420A1 18 04       1238*  			JR      INPUT5
0420A3 CD 31 24 04 1239*  INPUT4:			CALL    STACCS
0420A7 E1          1240*  INPUT5:			POP     HL
0420A8 C1          1241*  			POP     BC
0420A9 CB 81       1242*  INPUT3:			RES     0,C
0420AB 18 92       1243*  			JR      INPUT1
0420AD             1244*  ;
0420AD CB 41       1245*  REFILL:			BIT     0,C
0420AF 20 0C       1246*  			JR      NZ,REFIL0       ;NO PROMPT
0420B1 3E 3F       1247*  			LD      A,'?'
0420B3 CD C1 0A 04 1248*  			CALL    OUTCHR          ;PROMPT
0420B7 3E 20       1249*  			LD      A,' '
0420B9 CD C1 0A 04 1250*  			CALL    OUTCHR
0420BD 21 00 4B 04 1251*  REFIL0:			LD      HL,BUFFER
0420C1 C5          1252*  			PUSH    BC
0420C2 E5          1253*  			PUSH    HL
0420C3 DD E5       1254*  			PUSH    IX
0420C5 CD 39 44 04 1255*  			CALL    OSLINE
0420C9 DD E1       1256*  			POP     IX
0420CB E1          1257*  			POP     HL
0420CC C1          1258*  			POP     BC
0420CD 47          1259*  			LD      B,A             ;POS AT ENTRY
0420CE AF          1260*  			XOR     A
0420CF 32 3D 4D 04 1261*  			LD      (COUNT),A
0420D3 B8          1262*  			CP      B
0420D4 C8          1263*  			RET     Z
0420D5 7E          1264*  REFIL1:			LD      A,(HL)
0420D6 FE 0D       1265*  			CP      CR
0420D8 C8          1266*  			RET     Z
0420D9 23          1267*  			INC     HL
0420DA 10 F9       1268*  			DJNZ    REFIL1
0420DC C9          1269*  			RET
0420DD             1270*  
0420DD             1271*  ; READ var[,var...]
0420DD             1272*  ;
0420DD FE 23       1273*  READ:			CP      '#'
0420DF CA C6 1F 04 1274*  			JP      Z,INPUTN
0420E3 2A 31 4D 04 1275*  			LD      HL,(DATPTR)
0420E7 7E          1276*  READ0:			LD      A,(HL)
0420E8 23          1277*  			INC     HL              ;SKIP COMMA OR "DATA"
0420E9 FE 0D       1278*  			CP      CR              ;END OF DATA STMT?
0420EB CC 2F 21 04 1279*  			CALL    Z,GETDAT
0420EF E5          1280*  			PUSH    HL
0420F0 CD 95 1A 04 1281*  			CALL    VAR_
0420F4 E1          1282*  			POP     HL
0420F5 B7          1283*  			OR      A
0420F6 FA 0F 21 04 1284*  			JP      M,READ1         ;STRING
0420FA E5          1285*  			PUSH    HL
0420FB FD E3       1286*  			EX      (SP),IY
0420FD F5          1287*  			PUSH    AF              ;SAVE TYPE
0420FE DD E5       1288*  			PUSH    IX
042100 CD 06 11 04 1289*  			CALL    EXPRN
042104 DD E1       1290*  			POP     IX
042106 F1          1291*  			POP     AF
042107 CD 07 24 04 1292*  			CALL    STORE
04210B FD E3       1293*  			EX      (SP),IY
04210D 18 09       1294*  			JR      READ2
04210F CD 3E 26 04 1295*  READ1:			CALL    FETCHS
042113 E5          1296*  			PUSH    HL
042114 CD 31 24 04 1297*  			CALL    STACCS
042118 E1          1298*  READ2:			POP     HL
042119 22 31 4D 04 1299*  			LD      (DATPTR),HL
04211D CD 77 18 04 1300*  			CALL    NXT
042121 FE 2C       1301*  			CP      ','
042123 C2 9D 19 04 1302*  			JP      NZ,XEQ
042127 FD 23       1303*  			INC     IY
042129 CD 77 18 04 1304*  			CALL    NXT
04212D 18 B8       1305*  			JR      READ0
04212F             1306*  ;
04212F 3E DC       1307*  GETDAT:			LD      A,DATA_
042131 CD 7F 26 04 1308*  			CALL    SEARCH_EX
042135 23          1309*  			INC     HL
042136 D0          1310*  			RET     NC
042137 3E 2A       1311*  			LD      A,42
042139 C3 D2 08 04 1312*  ERROR4:			JP      ERROR_           ;"Out of DATA"
04213D             1313*  
04213D             1314*  ; IF expr statement
04213D             1315*  ; IF expr THEN statement [ELSE statement]
04213D             1316*  ; IF expr THEN line [ELSE line]
04213D             1317*  ;
04213D CD 0E 11 04 1318*  IF_:			CALL    EXPRI
042141 CD E3 16 04 1319*  			CALL    TEST
042145 28 19       1320*  			JR      Z,IFNOT         ;FALSE
042147 FD 7E 00    1321*  			LD      A,(IY)
04214A FE 8C       1322*  			CP      THEN
04214C C2 9D 19 04 1323*  			JP      NZ,XEQ
042150 FD 23       1324*  			INC     IY              ;SKIP "THEN"
042152 CD 77 18 04 1325*  IF1:			CALL    NXT
042156 FE 8D       1326*  			CP      LINO
042158 C2 9D 19 04 1327*  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
04215C C3 32 1D 04 1328*  			JP      GOTO_EX            ;LINE NO. FOLLOWS
042160 FD 7E 00    1329*  IFNOT:			LD      A,(IY)
042163 FE 0D       1330*  			CP      CR
042165 FD 23       1331*  			INC     IY
042167 CA 99 19 04 1332*  			JP      Z,XEQ0          ;END OF LINE
04216B FE 8B       1333*  			CP      ELSE_
04216D 20 F1       1334*  			JR      NZ,IFNOT
04216F 18 E1       1335*  			JR      IF1
042171             1336*  
042171             1337*  ; CLS
042171             1338*  ;
042171 CD 5D 3E 04 1339*  CLS:		CALL    CLRSCN
042175 AF          1340*  			XOR     A
042176 32 3D 4D 04 1341*  			LD      (COUNT),A
04217A C3 9D 19 04 1342*  			JP      XEQ
04217E             1343*  
04217E             1344*  ; STOP
04217E             1345*  ;
04217E CD 02 0F 04 1346*  STOP:			CALL    TELL
042182 0D          1347*  			DB	CR
042183 0A          1348*  			DB	LF
042184 FA          1349*  			DB	TSTOP
042185 00          1350*  			DB	0
042186 CD 20 0B 04 1351*  			CALL    SETLIN          ;FIND CURRENT LINE
04218A CD 54 0B 04 1352*  			CALL    SAYLN
04218E CD B9 0A 04 1353*  			CALL    CRLF
042192 C3 F2 01 04 1354*  			JP      CLOOP
042196             1355*  
042196             1356*  ; REPORT
042196             1357*  ;
042196 CD F4 0E 04 1358*  REPOR:			CALL    REPORT
04219A C3 9D 19 04 1359*  			JP      XEQ
04219E             1360*  
04219E             1361*  ; CLEAR
04219E             1362*  ;
04219E CD E8 09 04 1363*  CLR:			CALL    CLEAR
0421A2 2A 14 4D 04 1364*  			LD      HL,(PAGE_)
0421A6 18 19       1365*  			JR      RESTR1
0421A8             1366*  
0421A8             1367*  ; RESTORE [line]
0421A8             1368*  ;
0421A8 2A 14 4D 04 1369*  RESTOR_EX:			LD      HL,(PAGE_)
0421AC CD AB 25 04 1370*  			CALL    TERMQ
0421B0 28 0F       1371*  			JR      Z,RESTR1
0421B2 CD 29 11 04 1372*  			CALL    ITEMI
0421B6 D9          1373*  			EXX
0421B7 CD 01 0B 04 1374*  			CALL    FINDL           ;SEARCH FOR LINE
0421BB 3E 29       1375*  			LD      A,41
0421BD C2 39 21 04 1376*  			JP      NZ,ERROR4       ;"No such line"
0421C1 3E DC       1377*  RESTR1:			LD      A,DATA_
0421C3 CD 7F 26 04 1378*  			CALL    SEARCH_EX
0421C7 22 31 4D 04 1379*  			LD      (DATPTR),HL
0421CB C3 9D 19 04 1380*  			JP      XEQ
0421CF             1381*  
0421CF             1382*  ; PTR#channel=expr
0421CF             1383*  ; PAGE=expr
0421CF             1384*  ; TIME=expr
0421CF             1385*  ; LOMEM=expr
0421CF             1386*  ; HIMEM=expr
0421CF             1387*  ;
0421CF CD B7 26 04 1388*  PTR_EX:			CALL    CHANEL
0421D3 CD C1 25 04 1389*  			CALL    EQUALS
0421D7 7B          1390*  			LD      A,E
0421D8 F5          1391*  			PUSH    AF
0421D9 CD 0E 11 04 1392*  			CALL    EXPRI
0421DD E5          1393*  			PUSH    HL
0421DE D9          1394*  			EXX
0421DF D1          1395*  			POP     DE
0421E0 F1          1396*  			POP     AF
0421E1 CD 52 49 04 1397*  			CALL    PUTPTR
0421E5 C3 9D 19 04 1398*  			JP      XEQ
0421E9             1399*  ;
0421E9 CD C1 25 04 1400*  PAGEV_EX:			CALL    EQUALS
0421ED CD 0E 11 04 1401*  			CALL    EXPRI
0421F1 D9          1402*  			EXX
0421F2 2E 00       1403*  			LD      L,0
0421F4 22 14 4D 04 1404*  			LD      (PAGE_),HL
0421F8 C3 9D 19 04 1405*  			JP      XEQ
0421FC             1406*  ;
0421FC FE 24       1407*  TIMEV_EX:			CP      '$'
0421FE 28 13       1408*  			JR      Z,TIMEVS_EX
042200 CD C1 25 04 1409*  			CALL    EQUALS
042204 CD 0E 11 04 1410*  			CALL    EXPRI
042208 E5          1411*  			PUSH    HL
042209 D9          1412*  			EXX
04220A D1          1413*  			POP     DE
04220B CD 71 44 04 1414*  			CALL    PUTIME
04220F C3 9D 19 04 1415*  			JP      XEQ
042213             1416*  ;
042213 FD 23       1417*  TIMEVS_EX:			INC     IY              ;SKIP '$'
042215 CD C1 25 04 1418*  			CALL    EQUALS
042219 CD 19 11 04 1419*  			CALL    EXPRS
04221D CD A2 49 04 1420*  			CALL    PUTIMS
042221 C3 9D 19 04 1421*  			JP      XEQ
042225             1422*  ;
042225 CD C1 25 04 1423*  LOMEMV_EX:			CALL    EQUALS
042229 CD 0E 11 04 1424*  			CALL    EXPRI
04222D CD E8 09 04 1425*  			CALL    CLEAR
042231 D9          1426*  			EXX
042232 22 1A 4D 04 1427*  			LD      (LOMEM),HL
042236 22 1D 4D 04 1428*  			LD      (FREE),HL
04223A C3 9D 19 04 1429*  			JP      XEQ
04223E             1430*  ;
04223E CD C1 25 04 1431*  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
042242 CD 0E 11 04 1432*  			CALL    EXPRI			; Load the expression into registers
042246 7D          1433*  			LD	A,L			;  A: The MSB of the 24-bit value
042247 D9          1434*  			EXX				; HL: The LSW of the 24-bit value
042248 22 4A 4D 04 1435*  			LD	(R0),HL
04224C 32 4C 4D 04 1436*  			LD	(R0+2),A
042250 2A 1D 4D 04 1437*  			LD	HL,(FREE)
042254 11 00 01 00 1438*  			LD      DE,256
042258 19          1439*  			ADD	HL,DE
042259 EB          1440*  			EX	DE,HL			; DE: FREE + 256
04225A 2A 4A 4D 04 1441*  			LD	HL,(R0)			; HL: The passed expression
04225E AF          1442*  			XOR     A
04225F ED 52       1443*  			SBC     HL,DE
042261 19          1444*  			ADD     HL,DE			; Do a bounds check
042262 DA D2 08 04 1445*  			JP      C,ERROR_         	; Throw the error: "No room"
042266 ED 5B 20 4D 1446*  			LD      DE,(HIMEM)
       04          
04226B 22 20 4D 04 1447*  			LD      (HIMEM),HL
04226F EB          1448*  			EX      DE,HL
042270 ED 72       1449*  			SBC     HL,SP			; Adjust the stack
042272 C2 9D 19 04 1450*  			JP      NZ,XEQ
042276 EB          1451*  			EX      DE,HL
042277 F9          1452*  			LD      SP,HL           	; Load the SP
042278 C3 9D 19 04 1453*  			JP      XEQ
04227C             1454*  
04227C             1455*  ; WIDTH expr
04227C             1456*  ;
04227C CD 0E 11 04 1457*  WIDTHV:			CALL    EXPRI
042280 D9          1458*  			EXX
042281 7D          1459*  			LD      A,L
042282 32 3E 4D 04 1460*  			LD      (WIDTH),A
042286 C3 9D 19 04 1461*  			JP      XEQ
04228A             1462*  
04228A             1463*  ; TRACE ON
04228A             1464*  ; TRACE OFF
04228A             1465*  ; TRACE line
04228A             1466*  ;
04228A FD 23       1467*  TRACE_EX:			INC     IY
04228C 21 00 00 00 1468*  			LD      HL,0
042290 FE EE       1469*  			CP      TON
042292 28 0B       1470*  			JR      Z,TRACE0
042294 FE 87       1471*  			CP      OFF_
042296 28 08       1472*  			JR      Z,TRACE1
042298 FD 2B       1473*  			DEC     IY
04229A CD 0E 11 04 1474*  			CALL    EXPRI
04229E D9          1475*  			EXX
04229F 2B          1476*  TRACE0:			DEC     HL
0422A0 22 26 4D 04 1477*  TRACE1:			LD      (TRACEN),HL
0422A4 C3 9D 19 04 1478*  			JP      XEQ
0422A8             1479*  
0422A8             1480*  ; VDU expr,expr;....
0422A8             1481*  ;
0422A8 DD 21 00 4B 1482*  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
0422AD DD E5       1483*  VDU1:			PUSH	IX
0422AF CD 0E 11 04 1484*  			CALL    EXPRI			; Fetch the VDU character
0422B3 DD E1       1485*  			POP	IX
0422B5 D9          1486*  			EXX
0422B6 DD 75 00    1487*  			LD	(IX+0),L		; Write out the character to the buffer
0422B9 DD 23       1488*  			INC	IX
0422BB FD 7E 00    1489*  			LD      A,(IY)			;  A: The separator character
0422BE FE 2C       1490*  			CP      ','			; Is it a comma?
0422C0 28 09       1491*  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0422C2 FE 3B       1492*  			CP      ';'			; Is it a semicolon?
0422C4 20 07       1493*  			JR      NZ,VDU3			; No, so skip to the next expression
0422C6 DD 74 00    1494*  			LD	(IX+0),H		; Write out the high byte to the buffer
0422C9 DD 23       1495*  			INC	IX
0422CB FD 23       1496*  VDU2:			INC     IY			; Skip to the next character
0422CD CD AB 25 04 1497*  VDU3:			CALL    TERMQ			; Skip past white space
0422D1 20 DA       1498*  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0422D3 DD 7D       1499*  			LD	A,IXL			;  A: Number of bytes to write out
0422D5 B7          1500*  			OR	A
0422D6 28 0B       1501*  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0422D8 21 00 4B 04 1502*  			LD	HL,BUFFER		; HL: Start of stream
0422DC 01 00 00 00 1503*  			LD	BC,0
0422E0 4F          1504*  			LD	C,A			; BC: Number of bytes to write out
0422E1 5B DF       1505*  			RST.LIL	18h			; Output the buffer to MOS
0422E3 C3 9D 19 04 1506*  VDU4:			JP      XEQ
0422E7             1507*  
0422E7             1508*  ; CLOSE channel number
0422E7             1509*  ;
0422E7 CD B7 26 04 1510*  CLOSE:			CALL    CHANEL			; Fetch the channel number
0422EB CD 16 49 04 1511*  			CALL    OSSHUT			; Close the channel
0422EF C3 9D 19 04 1512*  			JP      XEQ
0422F3             1513*  
0422F3             1514*  ; BPUT channel,byte
0422F3             1515*  ;
0422F3 CD B7 26 04 1516*  BPUT:			CALL    CHANEL          	; Fetch the channel number
0422F7 D5          1517*  			PUSH    DE			; DE: Channel number
0422F8 CD 29 18 04 1518*  			CALL    COMMA			; Skip to the next expression
0422FC CD 0E 11 04 1519*  			CALL    EXPRI           	; Feth the data
042300 D9          1520*  			EXX
042301 7D          1521*  			LD      A,L			; A: The byte to write
042302 D1          1522*  			POP     DE
042303 CD 26 49 04 1523*  			CALL    OSBPUT			; Write the byte out
042307 C3 9D 19 04 1524*  			JP      XEQ
04230B             1525*  
04230B             1526*  ; CALL address[,var[,var...]]
04230B             1527*  ;
04230B             1528*  ; Note that the parameter table differs from the Z80 version
04230B             1529*  ; Each entry now takes up 4 bytes, not 3, so the table is now:
04230B             1530*  ;  -1 byte:  Number of parameters
04230B             1531*  ; Then, for each parameter:
04230B             1532*  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
04230B             1533*  ;  -3 bytes: Parameter address
04230B             1534*  ;
04230B             1535*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
04230B             1536*  ;
04230B CD 0E 11 04 1537*  CALL_:			CALL    EXPRI           	; Fetch the address
04230F 7D          1538*  			LD	A,L			;  A: MSB of address
042310 D9          1539*  			EXX
042311 22 4A 4D 04 1540*  			LD	(R0+0),HL		; HL: LSW of address
042315 32 4C 4D 04 1541*  			LD	(R0+2),A
042319 06 00       1542*  			LD      B,0             	;  B: The parameter counter
04231B 11 00 4B 04 1543*  			LD      DE,BUFFER       	; DE: Vector
04231F             1544*  ;
04231F CD 77 18 04 1545*  CALL1:			CALL    NXT			; Skip whitespace
042323 FE 2C       1546*  			CP      ','			; Check for comma
042325 20 1B       1547*  			JR      NZ,CALL2		; If no more parameters, then jump here
042327 FD 23       1548*  			INC     IY			; Skip to the next character
042329 04          1549*  			INC     B			; Increment the parameter count
04232A CD 77 18 04 1550*  			CALL    NXT			; Skip whitespace
04232E C5          1551*  			PUSH    BC
04232F D5          1552*  			PUSH    DE
042330 CD 95 1A 04 1553*  			CALL    VAR_
042334 D1          1554*  			POP     DE
042335 C1          1555*  			POP     BC
042336 13          1556*  			INC     DE
042337 12          1557*  			LD      (DE),A			; Save the parameter type
042338 13          1558*  			INC     DE
042339 EB          1559*  			EX      DE,HL
04233A ED 1F       1560*  			LD	(HL),DE			; Save the parameter address (3 bytes)
04233C 23          1561*  			INC	HL
04233D 23          1562*  			INC	HL
04233E 23          1563*  			INC	HL
04233F EB          1564*  			EX      DE,HL
042340 18 DD       1565*  			JR      CALL1
042342             1566*  ;
042342 78          1567*  CALL2:			LD      A,B
042343 32 00 4B 04 1568*  			LD      (BUFFER),A      	; Save the parameter count
042347 2A 4A 4D 04 1569*  			LD	HL,(R0)			; HL: Address of the code
04234B CD 65 23 04 1570*  			CALL    USR1			; And call it
04234F C3 9D 19 04 1571*  			JP      XEQ
042353             1572*  
042353             1573*  ; USR(address)
042353             1574*  ;
042353 CD 29 11 04 1575*  USR:			CALL    ITEMI			; Evaluate the expression
042357 7D          1576*  			LD	A,L			;  A: MSB of address
042358 D9          1577*  			EXX
042359 22 4A 4D 04 1578*  			LD	(R0+0),HL		; HL: LSW of address
04235D 32 4C 4D 04 1579*  			LD	(R0+2),A
042361 2A 4A 4D 04 1580*  			LD	HL,(R0)			; Get the 24-bit address in HL
042365             1581*  ;
042365 E5          1582*  USR1:			PUSH    HL              	; Address on stack
042366 FD E3       1583*  			EX      (SP),IY
042368 24          1584*  			INC     H               	; Check for PAGE &00FFxx
042369 B4          1585*  			OR	H
04236A 21 D4 23 04 1586*  			LD      HL,USR2         	; Return address
04236E E5          1587*  			PUSH    HL
04236F DD 21 00 4C 1588*  			LD      IX,STAVAR
       04          
042374 CC DC 48 04 1589*  			CALL    Z,OSCALL        	; Intercept &00FFxx
042378             1590*  ;
042378 DD 4E 18    1591*  			LD      C, (IX+24)		; F%
04237B C5          1592*  			PUSH    BC
04237C             1593*  ;
04237C DD 7E 08    1594*  			LD	A, (IX+8)		; B% -> MSW
04237F 32 4B 4D 04 1595*  			LD	(R0+1), A
042383 DD 7E 09    1596*  			LD	A, (IX+9)
042386 32 4C 4D 04 1597*  			LD	(R0+2), A
04238A DD 7E 0C    1598*  			LD	A, (IX+12)		; C% -> LSB
04238D 32 4A 4D 04 1599*  			LD	(R0+0), A
042391 ED 4B 4A 4D 1600*  			LD	BC, (R0)
       04          
042396             1601*  ;
042396 DD 7E 10    1602*  			LD	A, (IX+16)		; D% -> MSW
042399 32 4B 4D 04 1603*  			LD	(R0+1), A
04239D DD 7E 11    1604*  			LD	A, (IX+17)
0423A0 32 4C 4D 04 1605*  			LD	(R0+2), A
0423A4 DD 7E 14    1606*  			LD	A, (IX+20)		; E% -> LSB
0423A7 32 4A 4D 04 1607*  			LD	(R0+0), A
0423AB ED 5B 4A 4D 1608*  			LD	DE, (R0)
       04          
0423B0             1609*  ;
0423B0 DD 7E 20    1610*  			LD	A, (IX+32)		; H% -> MSW
0423B3 32 4B 4D 04 1611*  			LD	(R0+1), A
0423B7 DD 7E 21    1612*  			LD	A, (IX+33)
0423BA 32 4C 4D 04 1613*  			LD	(R0+2), A
0423BE DD 7E 30    1614*  			LD	A, (IX+48)		; L% -> LSB
0423C1 32 4A 4D 04 1615*  			LD	(R0+0), A
0423C5 2A 4A 4D 04 1616*  			LD	HL, (R0)
0423C9             1617*  ;
0423C9 F1          1618*  			POP     AF			; F%
0423CA DD 7E 04    1619*  			LD      A, (IX+4)        	; A%
0423CD             1620*  
0423CD DD 21 00 4B 1621*  			LD      IX,BUFFER
       04          
0423D2 FD E9       1622*  			JP      (IY)            	; Off to user routine
0423D4             1623*  ;
0423D4 FD E1       1624*  USR2:			POP     IY
0423D6 AF          1625*  			XOR     A
0423D7 4F          1626*  			LD      C,A
0423D8 C9          1627*  			RET
0423D9             1628*  
0423D9             1629*  ; PUT port,data
0423D9             1630*  ;
0423D9 CD 0E 11 04 1631*  PUT:			CALL    EXPRI           ;PORT ADDRESS
0423DD D9          1632*  			EXX
0423DE E5          1633*  			PUSH    HL
0423DF CD 29 18 04 1634*  			CALL    COMMA
0423E3 CD 0E 11 04 1635*  			CALL    EXPRI           ;DATA
0423E7 D9          1636*  			EXX
0423E8 C1          1637*  			POP     BC
0423E9 ED 69       1638*  			OUT     (C),L           ;OUTPUT TO PORT BC
0423EB C3 9D 19 04 1639*  			JP      XEQ
0423EF             1640*  
0423EF             1641*  ; SUBROUTINES -----------------------------------------------------------------
0423EF             1642*  
0423EF             1643*  ; ASSIGN - Assign a numeric value to a variable.
0423EF             1644*  ; Outputs: NC,  Z - OK, numeric.
0423EF             1645*  ;          NC, NZ - OK, string.
0423EF             1646*  ;           C, NZ - illegal
0423EF             1647*  ;
0423EF CD AC 0B 04 1648*  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0423F3 D8          1649*  			RET     C               	; Return with C if it is an illegal variable
0423F4 C4 9B 0B 04 1650*  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0423F8 B7          1651*  			OR      A
0423F9 F8          1652*  			RET     M               	; Return if type is string (81h)
0423FA F5          1653*  			PUSH    AF              	; It's a numeric type from this point on
0423FB CD C1 25 04 1654*  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0423FF E5          1655*  			PUSH    HL
042400 CD 06 11 04 1656*  			CALL    EXPRN
042404 DD E1       1657*  			POP     IX
042406 F1          1658*  			POP     AF
042407 CB 47       1659*  STORE:			BIT     0,A
042409 28 13       1660*  			JR      Z,STOREI
04240B BF          1661*  			CP      A               	; Set the variable to 0
04240C DD 71 04    1662*  STORE5:			LD      (IX+4),C
04240F D9          1663*  STORE4:			EXX
042410 DD 75 00    1664*  			LD      (IX+0),L
042413 DD 74 01    1665*  			LD      (IX+1),H
042416 D9          1666*  			EXX
042417 DD 75 02    1667*  			LD      (IX+2),L
04241A DD 74 03    1668*  			LD      (IX+3),H
04241D C9          1669*  			RET
04241E F5          1670*  STOREI:			PUSH    AF
04241F 0C          1671*  			INC     C               ;SPEED - & PRESERVE F'
042420 0D          1672*  			DEC     C               ; WHEN CALLED BY FNEND0
042421 C4 66 14 04 1673*  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
042425 F1          1674*  			POP     AF
042426 FE 04       1675*  			CP      4
042428 28 E5       1676*  			JR      Z,STORE4
04242A BF          1677*  			CP      A               ;SET ZERO
04242B D9          1678*  STORE1:			EXX
04242C DD 75 00    1679*  			LD      (IX+0),L
04242F D9          1680*  			EXX
042430 C9          1681*  			RET
042431             1682*  ;
042431             1683*  ; Copy a string from the string accumulator to variable storage on the stack
042431             1684*  ; Parameters:
042431             1685*  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
042431             1686*  ; - IX: Address of the variable storage on the stack
042431             1687*  ;
042431 21 00 4A 04 1688*  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
042435             1689*  ;
042435             1690*  ; Parameters:
042435             1691*  ; As above, but:
042435             1692*  ; - HL: Address of the string to be stored
042435             1693*  ; -  E: The string length
042435             1694*  ; NB:
042435             1695*  ; Strings are mutable
042435             1696*  ; Strings are stored in the following format in the variable:
042435             1697*  ; - Address of the next variable (3 bytes)
042435             1698*  ; - The rest of the variable name - this is zero terminated
042435             1699*  ; - Current string length (byte)
042435             1700*  ; - Maximum (original) string length (byte)
042435             1701*  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
042435             1702*  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
042435             1703*  ;
042435 1F          1704*  STORES:			RRA				; Rotate right to shift bit 0 into carry
042436 30 5D       1705*  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
042438 E5          1706*  			PUSH    HL			; Stack ACCS
042439             1707*  ;
042439             1708*  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
042439             1709*  ;
042439 D9          1710*  			EXX				; This block was a call to LOAD4
04243A DD 6E 00    1711*  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
04243D DD 66 01    1712*  			LD      H,(IX+1)		; The maximum original string length
042440 D9          1713*  			EXX
042441 DD 27 02    1714*  			LD	HL,(IX+2)		; Address of the string (24-bit)
042444             1715*  ;
042444 7B          1716*  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
042445 D9          1717*  			EXX
042446 6F          1718*  			LD      L,A			; L': Length of string currently stored on the stack
042447 7C          1719*  			LD      A,H             	; H': The maximum (original) string length
042448 D9          1720*  			EXX
042449 BB          1721*  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
04244A 30 17       1722*  			JR      NC,STORS1       	; Yes there is, so skip the next bit
04244C             1723*  ;
04244C             1724*  ; At this point we're either initialising a new string or assigning more memory to an existing string
04244C             1725*  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
04244C             1726*  ; then the existing and new strings may both exist in memory.
04244C             1727*  ;
04244C D9          1728*  			EXX
04244D 65          1729*  			LD      H,L			; H: Set the maximum string length to the string length
04244E D9          1730*  			EXX
04244F E5          1731*  			PUSH    HL
042450 01 00 00 00 1732*  			LD	BC, 0
042454 4F          1733*  			LD      C,A			; BC: The maximum (original) string length
042455 09          1734*  			ADD     HL,BC			; Work out whether this is the last string in memory
042456 ED 4B 1D 4D 1735*  			LD      BC,(FREE)
       04          
04245B ED 42       1736*  			SBC     HL,BC			; Is string last?
04245D E1          1737*  			POP     HL
04245E 37          1738*  			SCF
04245F 28 02       1739*  			JR      Z,STORS1
042461             1740*  			; LD	HL, BC			; HL=BC
042461 C5          1741*  			push bc
042462 E1          1742*  			pop hl
042463             1743*  ;
042463             1744*  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
042463             1745*  ; - H': The maximum (original) string length
042463             1746*  ; - L': The actual string length (must be less than H')
042463             1747*  ; - HL: Address of the string in memory
042463             1748*  ;
042463 D9          1749*  STORS1:			EXX				; This block was a call to STORE4
042464 DD 75 00    1750*  			LD      (IX+0),L		; The actual string length (must be less then H')
042467 DD 74 01    1751*  			LD      (IX+1),H		; The maximum (original) string length
04246A D9          1752*  			EXX
04246B DD 2F 02    1753*  			LD	(IX+2),HL		; The pointer to the original string
04246E             1754*  ;
04246E 01 00 00 00 1755*  			LD	BC, 0
042472 4B          1756*  			LD      C,E			; BC: The new string length
042473 EB          1757*  			EX      DE,HL
042474 E1          1758*  			POP     HL
042475 0D          1759*  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
042476 0C          1760*  			INC     C			; check whether BC is 0 without affecting the carry flag
042477 C8          1761*  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
042478 ED B0       1762*  			LDIR				; Replace the string in memory
04247A D0          1763*  			RET     NC
04247B ED 53 1D 4D 1764*  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
042480             1765*  ;
042480             1766*  ; Check whether the stack is full
042480             1767*  ;
042480 E5          1768*  CHECK:			PUSH    HL
042481 C5          1769*  			PUSH	BC
042482 2A 1D 4D 04 1770*  			LD      HL,(FREE)		; HL: Address of first free space byte
042486 01 00 01 00 1771*  			LD	BC,100h			; BC: One page of memory
04248A 09          1772*  			ADD	HL,BC			; Add a page to FREE
04248B ED 72       1773*  			SBC     HL,SP			; And subtract the current SP
04248D C1          1774*  			POP	BC
04248E E1          1775*  			POP     HL
04248F D8          1776*  			RET     C			; The SP is not in the same page, so just return
042490 AF          1777*  			XOR     A			; Otherwise
042491 C3 D2 08 04 1778*  			JP      ERROR_			; Throw error "No room"
042495             1779*  ;
042495 01 00 00 00 1780*  STORS3:			LD	BC,0
042499 4B          1781*  			LD      C,E			; BC: String length
04249A DD E5       1782*  			PUSH    IX
04249C D1          1783*  			POP     DE			; DE: Destination
04249D AF          1784*  			XOR     A			; Check if string length is 0
04249E B9          1785*  			CP      C
04249F 28 02       1786*  			JR      Z,STORS5		; Yes, so don't copy
0424A1 ED B0       1787*  			LDIR
0424A3 3E 0D       1788*  STORS5:			LD      A,CR			; Finally add the terminator
0424A5 12          1789*  			LD      (DE),A
0424A6 C9          1790*  			RET
0424A7             1791*  
0424A7             1792*  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0424A7             1793*  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0424A7             1794*  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0424A7             1795*  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0424A7             1796*  ;    Inputs: DE addresses parameter list
0424A7             1797*  ;            IY addresses dummy variable list
0424A7             1798*  ;   Outputs: DE,IY updated
0424A7             1799*  ;  Destroys: Everything
0424A7             1800*  ;
0424A7 3E FF       1801*  ARGUE:			LD      A,-1
0424A9 F5          1802*  			PUSH    AF              	; Put marker on the stack
0424AA FD 23       1803*  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0424AC 13          1804*  			INC     DE
0424AD D5          1805*  			PUSH    DE
0424AE CD 77 18 04 1806*  			CALL    NXT			; Skip any whitespace
0424B2 CD AC 0B 04 1807*  			CALL    GETVAR			; Get the location of the variable in HL/IX
0424B6 38 3F       1808*  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0424B8 C4 9B 0B 04 1809*  			CALL    NZ,PUTVAR
0424BC D1          1810*  			POP     DE
0424BD E5          1811*  			PUSH    HL              	; VARPTR
0424BE B7          1812*  			OR      A               	; Check the variable type
0424BF F5          1813*  			PUSH    AF
0424C0 D5          1814*  			PUSH    DE
0424C1 FD E3       1815*  			EX      (SP),IY
0424C3 FA DB 24 04 1816*  			JP      M,ARGUE2        	; Jump here if it is a string
0424C7             1817*  ;
0424C7 CD 06 11 04 1818*  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0424CB FD E3       1819*  			EX      (SP),IY
0424CD D1          1820*  			POP     DE
0424CE F1          1821*  			POP     AF
0424CF D9          1822*  			EXX
0424D0 E5          1823*  			PUSH    HL
0424D1 D9          1824*  			EXX
0424D2 E5          1825*  			PUSH    HL
0424D3 47          1826*  			LD      B,A
0424D4 C5          1827*  			PUSH    BC
0424D5 CD 80 24 04 1828*  			CALL    CHECK           	; Check room
0424D9 18 0F       1829*  			JR      ARGUE4
0424DB             1830*  ;
0424DB CD 19 11 04 1831*  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0424DF FD E3       1832*  			EX      (SP),IY
0424E1 D9          1833*  			EXX
0424E2 D1          1834*  			POP     DE
0424E3 D9          1835*  			EXX
0424E4 F1          1836*  			POP     AF
0424E5 CD B8 17 04 1837*  			CALL    PUSHS
0424E9 D9          1838*  			EXX
0424EA             1839*  ;
0424EA CD 77 18 04 1840*  ARGUE4:			CALL    NXT			; Skip whitespace
0424EE FE 2C       1841*  			CP      ','			; Check to see if the next value is a comma
0424F0 20 0B       1842*  			JR      NZ,ARGUE5		; No, so jump here
0424F2 1A          1843*  			LD      A,(DE)
0424F3 FE 2C       1844*  			CP      ','			; Are there any more arguments?
0424F5 28 B3       1845*  			JR      Z,ARGUE1        	; Yes, so loop
0424F7             1846*  ;
0424F7 3E 1F       1847*  ARGERR:			LD      A,31
0424F9 C3 D2 08 04 1848*  			JP      ERROR_           	; Throw error "Arguments"
0424FD             1849*  ;
0424FD CD 36 18 04 1850*  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
042501 1A          1851*  			LD      A,(DE)
042502 FE 29       1852*  			CP      ')'
042504 20 F1       1853*  			JR      NZ,ARGERR
042506 13          1854*  			INC     DE
042507 D9          1855*  			EXX
042508 C1          1856*  ARGUE6:			POP     BC
042509 78          1857*  			LD      A,B
04250A 3C          1858*  			INC     A
04250B D9          1859*  			EXX
04250C C8          1860*  			RET     Z               	; Marker popped
04250D D9          1861*  			EXX
04250E 3D          1862*  			DEC     A
04250F FA 1F 25 04 1863*  			JP      M,ARGUE7        	; If it is a string, then jump here
042513 E1          1864*  			POP     HL
042514 D9          1865*  			EXX
042515 E1          1866*  			POP     HL
042516 D9          1867*  			EXX
042517 DD E1       1868*  			POP     IX
042519 CD 07 24 04 1869*  			CALL    STORE	           	; Write to dummy variable
04251D 18 E9       1870*  			JR      ARGUE6
04251F             1871*  ;
04251F CD E5 17 04 1872*  ARGUE7:			CALL    POPS
042523 DD E1       1873*  			POP     IX
042525 CD 31 24 04 1874*  			CALL    STACCS
042529 18 DD       1875*  			JR      ARGUE6
04252B             1876*  
04252B             1877*  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
04252B             1878*  ;   OF A FUNCTION OR PROCEDURE.
04252B             1879*  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
04252B             1880*  ;    Inputs: IY is parameters pointer
04252B             1881*  ;   Outputs: IY updated
04252B             1882*  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
04252B             1883*  ;
04252B D1          1884*  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
04252C             1885*  ;
04252C FD 23       1886*  SAVLO1:			INC     IY              	; Bump past '(' or ','
04252E CD 77 18 04 1887*  			CALL    NXT			; And also any whitespace
042532 D5          1888*  			PUSH    DE			; Push the return address back onto the stack
042533 D9          1889*  			EXX
042534 C5          1890*  			PUSH    BC
042535 D5          1891*  			PUSH    DE
042536 E5          1892*  			PUSH    HL
042537 D9          1893*  			EXX
042538 CD 95 1A 04 1894*  			CALL    VAR_             	; Dummy variable
04253C D9          1895*  			EXX
04253D E1          1896*  			POP     HL
04253E D1          1897*  			POP     DE
04253F C1          1898*  			POP     BC
042540 D9          1899*  			EXX
042541 D1          1900*  			POP     DE
042542 B7          1901*  			OR      A               	; Check the variable type
042543 FA 56 25 04 1902*  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
042547 D9          1903*  			EXX
042548 E5          1904*  			PUSH    HL              	; Save H'L'
042549 D9          1905*  			EXX
04254A 47          1906*  			LD      B,A             	;  B: Variable type
04254B CD 1A 12 04 1907*  			CALL    LOADN
04254F D9          1908*  			EXX
042550 E3          1909*  			EX      (SP),HL
042551 D9          1910*  			EXX
042552 E5          1911*  			PUSH    HL
042553 C5          1912*  			PUSH    BC
042554 18 2D       1913*  			JR      SAVLO4
042556             1914*  ;
042556 F5          1915*  SAVLO2:			PUSH    AF              	; Save the type (string)
042557 D5          1916*  			PUSH    DE
042558 D9          1917*  			EXX
042559 E5          1918*  			PUSH    HL
04255A D9          1919*  			EXX
04255B CD A4 12 04 1920*  			CALL    LOADS
04255F D9          1921*  			EXX
042560 E1          1922*  			POP     HL
042561 D9          1923*  			EXX
042562 01 00 00 00 1924*  			LD	BC,0
042566 4B          1925*  			LD      C,E			; BC: String length
042567 D1          1926*  			POP     DE
042568 CD 80 24 04 1927*  			CALL    CHECK			; Check if there is space on the stack
04256C F1          1928*  			POP     AF              	; Level stack
04256D 21 00 00 00 1929*  			LD      HL,0
042571 ED 42       1930*  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
042573 39          1931*  			ADD     HL,SP			; Make space for the string on the stack
042574 F9          1932*  			LD      SP,HL
042575 47          1933*  			LD      B,A             	;  B: Variable type
042576 C5          1934*  			PUSH    BC
042577 28 0A       1935*  			JR      Z,SAVLO4
042579 D5          1936*  			PUSH    DE
04257A 11 00 4A 04 1937*  			LD      DE,ACCS
04257E EB          1938*  			EX      DE,HL
04257F 45          1939*  			LD      B,L
042580 ED B0       1940*  			LDIR                    	; Save the string onto the stack
042582 D1          1941*  			POP     DE
042583             1942*  ;
042583 DD E5       1943*  SAVLO4:			PUSH    IX			; VARPTR
042585 CD 89 25 04 1944*  			CALL    SAVLO5
042589             1945*  LOCCHK:			EQU     $
042589 CD 80 24 04 1946*  SAVLO5:			CALL    CHECK
04258D CD 77 18 04 1947*  			CALL    NXT
042591 FE 2C       1948*  			CP      ','             	; Are there any more local variables?
042593 28 97       1949*  			JR      Z,SAVLO1		; Yes, so loop
042595 EB          1950*  			EX      DE,HL			; DE -> HL: The return address
042596 E9          1951*  			JP      (HL)            	; And effectvely return
042597             1952*  ;
042597 FD 7E 00    1953*  DELIM:			LD      A,(IY)          	; Assembler delimiter
04259A FE 20       1954*  			CP      ' '
04259C C8          1955*  			RET     Z
04259D FE 2C       1956*  			CP      ','
04259F C8          1957*  			RET     Z
0425A0 FE 29       1958*  			CP      ')'
0425A2 C8          1959*  			RET     Z
0425A3 FE 3B       1960*  TERM:			CP      ';'             	; Assembler terminator
0425A5 C8          1961*  			RET     Z
0425A6 FE 5C       1962*  			CP      '\'
0425A8 C8          1963*  			RET     Z
0425A9 18 07       1964*  			JR      TERM0
0425AB             1965*  ;
0425AB CD 77 18 04 1966*  TERMQ:			CALL    NXT
0425AF FE 8B       1967*  			CP      ELSE_
0425B1 D0          1968*  			RET     NC
0425B2 FE 3A       1969*  TERM0:			CP      ':'             	; Assembler seperator
0425B4 D0          1970*  			RET     NC
0425B5 FE 0D       1971*  			CP      CR
0425B7 C9          1972*  			RET
0425B8             1973*  ;
0425B8 CD AB 25 04 1974*  SPAN:			CALL    TERMQ
0425BC C8          1975*  			RET     Z
0425BD FD 23       1976*  			INC     IY
0425BF 18 F7       1977*  			JR      SPAN
0425C1             1978*  ;
0425C1             1979*  ; This snippet is used to check whether an expression is followed by an '=' symbol
0425C1             1980*  ;
0425C1 CD 77 18 04 1981*  EQUALS:			CALL    NXT			; Skip whitespace
0425C5 FD 23       1982*  			INC     IY			; Skip past the character in question
0425C7 FE 3D       1983*  			CP      '='			; Is it '='
0425C9 C8          1984*  			RET     Z			; Yes, so return
0425CA 3E 04       1985*  			LD      A,4			; Otherwise
0425CC C3 D2 08 04 1986*  			JP      ERROR_           	; Throw error "Mistake"
0425D0             1987*  ;
0425D0 FE 8A       1988*  FORMAT:			CP      TAB
0425D2 28 0D       1989*  			JR      Z,DOTAB
0425D4 FE 89       1990*  			CP      SPC
0425D6 28 40       1991*  			JR      Z,DOSPC
0425D8 FE 27       1992*  			CP      '''
0425DA C0          1993*  			RET     NZ
0425DB CD B9 0A 04 1994*  			CALL    CRLF
0425DF AF          1995*  			XOR     A
0425E0 C9          1996*  			RET
0425E1             1997*  ;
0425E1 C5          1998*  DOTAB:			PUSH    BC
0425E2 CD 0E 11 04 1999*  			CALL    EXPRI
0425E6 D9          2000*  			EXX
0425E7 C1          2001*  			POP     BC
0425E8 FD 7E 00    2002*  			LD      A,(IY)
0425EB FE 2C       2003*  			CP      ','
0425ED 28 14       2004*  			JR      Z,DOTAB1
0425EF CD 36 18 04 2005*  			CALL    BRAKET
0425F3 7D          2006*  			LD      A,L
0425F4 21 3D 4D 04 2007*  TABIT:			LD      HL,COUNT
0425F8 BE          2008*  			CP      (HL)
0425F9 C8          2009*  			RET     Z
0425FA F5          2010*  			PUSH    AF
0425FB DC B9 0A 04 2011*  			CALL    C,CRLF
0425FF F1          2012*  			POP     AF
042600 96          2013*  			SUB     (HL)
042601 18 1D       2014*  			JR      FILL
042603 FD 23       2015*  DOTAB1:			INC     IY
042605 C5          2016*  			PUSH    BC
042606 E5          2017*  			PUSH    HL
042607 CD 0E 11 04 2018*  			CALL    EXPRI
04260B D9          2019*  			EXX
04260C D1          2020*  			POP     DE
04260D C1          2021*  			POP     BC
04260E CD 36 18 04 2022*  			CALL    BRAKET
042612 CD 9B 44 04 2023*  			CALL    PUTCSR
042616 AF          2024*  			XOR     A
042617 C9          2025*  			RET
042618             2026*  ;
042618 C5          2027*  DOSPC:			PUSH    BC
042619 CD 29 11 04 2028*  			CALL    ITEMI
04261D D9          2029*  			EXX
04261E 7D          2030*  			LD      A,L
04261F C1          2031*  			POP     BC
042620 B7          2032*  FILL:			OR      A
042621 C8          2033*  			RET     Z
042622 C5          2034*  			PUSH    BC
042623 47          2035*  			LD      B,A
042624 3E 20       2036*  FILL1:			LD      A,' '
042626 CD C1 0A 04 2037*  			CALL    OUTCHR
04262A 10 F8       2038*  			DJNZ    FILL1
04262C C1          2039*  			POP     BC
04262D AF          2040*  			XOR     A
04262E C9          2041*  			RET
04262F             2042*  ;
04262F 21 00 4A 04 2043*  PTEXT:			LD      HL,ACCS
042633 1C          2044*  			INC     E
042634 1D          2045*  PTEXT1:			DEC     E
042635 C8          2046*  			RET     Z
042636 7E          2047*  			LD      A,(HL)
042637 23          2048*  			INC     HL
042638 CD C1 0A 04 2049*  			CALL    OUTCHR
04263C 18 F6       2050*  			JR      PTEXT1
04263E             2051*  ;
04263E F5          2052*  FETCHS:			PUSH    AF
04263F C5          2053*  			PUSH    BC
042640 E5          2054*  			PUSH    HL
042641 FD E3       2055*  			EX      (SP),IY
042643 CD 5E 26 04 2056*  			CALL    XTRACT
042647 CD 77 18 04 2057*  			CALL    NXT
04264B FD E3       2058*  			EX      (SP),IY
04264D E1          2059*  			POP     HL
04264E C1          2060*  			POP     BC
04264F F1          2061*  			POP     AF
042650 C9          2062*  			RET
042651             2063*  ;
042651 11 00 4A 04 2064*  LINES:			LD      DE,ACCS
042655 7E          2065*  LINE1S:			LD      A,(HL)
042656 12          2066*  			LD      (DE),A
042657 FE 0D       2067*  			CP      CR
042659 C8          2068*  			RET     Z
04265A 23          2069*  			INC     HL
04265B 1C          2070*  			INC     E
04265C 18 F7       2071*  			JR      LINE1S
04265E             2072*  ;
04265E CD 77 18 04 2073*  XTRACT:			CALL    NXT
042662 FE 22       2074*  			CP      '"'
042664 FD 23       2075*  			INC     IY
042666 CA 6B 12 04 2076*  			JP      Z,CONS
04266A FD 2B       2077*  			DEC     IY
04266C 11 00 4A 04 2078*  			LD      DE,ACCS
042670 FD 7E 00    2079*  XTRAC1:			LD      A,(IY)
042673 12          2080*  			LD      (DE),A
042674 FE 2C       2081*  			CP      ','
042676 C8          2082*  			RET     Z
042677 FE 0D       2083*  			CP      CR
042679 C8          2084*  			RET     Z
04267A FD 23       2085*  			INC     IY
04267C 1C          2086*  			INC     E
04267D 18 F1       2087*  			JR      XTRAC1
04267F             2088*  
04267F             2089*  ; Search for a token at the start of a program line
04267F             2090*  ; - HL: Pointer to the start of a tokenised line in the program area
04267F             2091*  ; Returns:
04267F             2092*  ; - HL: Pointer to the
04267F             2093*  ; -  F: Carry set if not found
04267F             2094*  ; Corrupts:
04267F             2095*  ; - BC
04267F             2096*  ;
04267F 01 00 00 00 2097*  SEARCH_EX:			LD      BC,0			; Clear BC
042683             2098*  ;
042683 4E          2099*  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
042684 0C          2100*  			INC     C			; Check for 0, i.e. end of program marker
042685 0D          2101*  			DEC     C
042686 28 0B       2102*  			JR      Z,SRCH2_EX         	; Not found the token, so end
042688 23          2103*  			INC     HL			; Skip the line length and line number
042689 23          2104*  			INC     HL
04268A 23          2105*  			INC     HL
04268B BE          2106*  			CP      (HL)			; Compare with the token
04268C C8          2107*  			RET     Z			; Found it, so return with carry not set
04268D 0D          2108*  			DEC     C			; Skip to the next line
04268E 0D          2109*  			DEC     C
04268F 0D          2110*  			DEC     C
042690 09          2111*  			ADD     HL,BC
042691 18 F0       2112*  			JR      SRCH1_EX			; Rinse, lather and repeat
042693             2113*  ;
042693 2B          2114*  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
042694 37          2115*  			SCF				; And set the carry flag
042695 C9          2116*  			RET
042696             2117*  
042696             2118*  ; Multiply by 4 or 5
042696             2119*  ; This function is used to allocate space for dimensioned variables
042696             2120*  ; This is a 24-bit operation
042696             2121*  ; - DE: Number to multiple
042696             2122*  ; -  A: 04h (Integer) - takes up 4 bytes
042696             2123*  ;       05h (Float)   - takes up 5 bytes
042696             2124*  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
042696             2125*  ; Returns:
042696             2126*  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
042696             2127*  ; -  F: Carry if overflow
042696             2128*  ; Corrupts:
042696             2129*  ; - HL
042696 FE 04       2130*  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
042698             2131*  			; LD	HL,DE
042698 D5          2132*  			push de
042699 E1          2133*  			pop hl
04269A 29          2134*  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
04269B D8          2135*  			RET     C			; Exit if overflow
04269C 29          2136*  			ADD     HL,HL			; Multiply by 2 again
04269D D8          2137*  			RET     C			; Exit if overflow
04269E EB          2138*  			EX      DE,HL			; DE: Product
04269F C8          2139*  			RET     Z			; Exit if A = 4
0426A0 19          2140*  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0426A1 EB          2141*  			EX      DE,HL			; DE: Product
0426A2 C9          2142*  			RET
0426A3             2143*  
0426A3             2144*  ; 16-bit unsigned multiply
0426A3             2145*  ; - HL: Operand 1
0426A3             2146*  ; - BC: Operand 2
0426A3             2147*  ; Returns:
0426A3             2148*  ; - HL: Result
0426A3             2149*  ; -  F: C if overflow
0426A3             2150*  ;
0426A3 C5          2151*  MUL16:			PUSH	BC
0426A4 51          2152*  			LD	D, C			; Set up the registers for the multiplies
0426A5 5D          2153*  			LD	E, L
0426A6 69          2154*  			LD	L, C
0426A7 4B          2155*  			LD	C, E
0426A8 ED 6C       2156*  			MLT	HL			; HL = H * C (*256)
0426AA ED 5C       2157*  			MLT	DE			; DE = L * C
0426AC ED 4C       2158*  			MLT	BC			; BC = B * L (*256)
0426AE 09          2159*  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0426AF C1          2160*  			POP	BC
0426B0 AF          2161*  			XOR	A
0426B1 9C          2162*  			SBC	H			; If H is not zero then it's an overflow
0426B2 D8          2163*  			RET	C
0426B3 65          2164*  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0426B4 6F          2165*  			LD	L, A
0426B5 19          2166*  			ADD	HL, DE
0426B6 C9          2167*  			RET
0426B7             2168*  ;
0426B7 CD 77 18 04 2169*  CHANEL:			CALL    NXT			; Skip whitespace
0426BB FE 23       2170*  			CP      '#'			; Check for the '#' symbol
0426BD 3E 2D       2171*  			LD      A,45
0426BF C2 D2 08 04 2172*  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0426C3 FD 23       2173*  CHNL:			INC     IY             		; Bump past the '#'
0426C5 CD 29 11 04 2174*  			CALL    ITEMI			; Get the channel number
0426C9 D9          2175*  			EXX
0426CA EB          2176*  			EX      DE,HL			; DE: The channel number
0426CB C9          2177*  			RET
0426CC             2178*  
0426CC             2179*  ; ASSEMBLER -------------------------------------------------------------------
0426CC             2180*  
0426CC             2181*  ; Language independant control section:
0426CC             2182*  ;  Outputs: A=delimiter, carry set if syntax error.
0426CC             2183*  ;
0426CC CD EC 2B 04 2184*  ASSEM:			CALL    SKIP
0426D0 FD 23       2185*  			INC     IY
0426D2 FE 3A       2186*  			CP      ':'
0426D4 28 F6       2187*  			JR      Z,ASSEM
0426D6 FE 5D       2188*  			CP      ']'
0426D8 C8          2189*  			RET     Z
0426D9 FE 0D       2190*  			CP      CR
0426DB C8          2191*  			RET     Z
0426DC FD 2B       2192*  			DEC     IY
0426DE DD 2A 40 30 2193*  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       11          
0426E3 21 40 4D 04 2194*  			LD      HL,LISTON
0426E7 CB 76       2195*  			BIT     6,(HL)
0426E9 28 05       2196*  			JR      Z,ASSEM0
0426EB DD 2A 3C 30 2197*  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       11          
0426F0 DD E5       2198*  ASSEM0:			PUSH    IX
0426F2 FD E5       2199*  			PUSH    IY
0426F4 CD A4 27 04 2200*  			CALL    ASMB
0426F8 C1          2201*  			POP     BC
0426F9 D1          2202*  			POP     DE
0426FA D8          2203*  			RET     C
0426FB CD EC 2B 04 2204*  			CALL    SKIP
0426FF 37          2205*  			SCF
042700 C0          2206*  			RET     NZ
042701 FD 2B       2207*  			DEC     IY
042703 FD 23       2208*  ASSEM3:			INC     IY
042705 FD 7E 00    2209*  			LD      A,(IY)
042708 CD B2 25 04 2210*  			CALL    TERM0
04270C 20 F5       2211*  			JR      NZ,ASSEM3
04270E 3A 40 4D 04 2212*  			LD      A,(LISTON)
042712 DD E5       2213*  			PUSH    IX
042714 E1          2214*  			POP     HL
042715 B7          2215*  			OR      A
042716 ED 52       2216*  			SBC     HL,DE
042718 EB          2217*  			EX      DE,HL           	; DE: Number of bytes
042719 E5          2218*  			PUSH    HL
04271A 2A 40 30 11 2219*  			LD      HL,(PC)
04271E E5          2220*  			PUSH    HL
04271F 19          2221*  			ADD     HL,DE
042720 22 40 30 11 2222*  			LD      (PC),HL         	; Update PC
042724 CB 77       2223*  			BIT     6,A
042726 28 09       2224*  			JR      Z,ASSEM5
042728 2A 3C 30 11 2225*  			LD      HL,(OC)
04272C 19          2226*  			ADD     HL,DE
04272D 22 3C 30 11 2227*  			LD      (OC),HL         	; Update OC
042731 E1          2228*  ASSEM5:			POP     HL              	; Old PC
042732 DD E1       2229*  			POP     IX              	; Code here
042734 CB 67       2230*  			BIT     4,A
042736 28 94       2231*  			JR      Z,ASSEM
042738 22 4A 4D 04 2232*  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04273C 3A 4C 4D 04 2233*  			LD	A,(R0+2)		; Print out the address
042740 CD 8E 27 04 2234*  			CALL	HEX_EX
042744 7C          2235*  			LD      A,H
042745 CD 8E 27 04 2236*  			CALL    HEX_EX
042749 7D          2237*  			LD      A,L
04274A CD 86 27 04 2238*  			CALL    HEXSP
04274E AF          2239*  			XOR     A
04274F BB          2240*  			CP      E
042750 28 18       2241*  			JR      Z,ASSEM2
042752             2242*  ;
042752 3A 3D 4D 04 2243*  ASSEM1:			LD      A,(COUNT)
042756 FE 14       2244*  			CP      20
042758 3E 07       2245*  			LD      A,7
04275A D4 F4 25 04 2246*  			CALL    NC,TABIT        	; Next line
04275E DD 7E 00    2247*  			LD      A,(IX)
042761 CD 86 27 04 2248*  			CALL    HEXSP
042765 DD 23       2249*  			INC     IX
042767 1D          2250*  			DEC     E
042768 20 E8       2251*  			JR      NZ,ASSEM1
04276A             2252*  ;
04276A 3E 16       2253*  ASSEM2:			LD      A,22			; Tab to the disassembly field
04276C CD F4 25 04 2254*  			CALL    TABIT
042770 FD E5       2255*  			PUSH    IY
042772 E1          2256*  			POP     HL
042773 ED 42       2257*  			SBC     HL,BC
042775 0A          2258*  ASSEM4:			LD      A,(BC)
042776 CD DE 0A 04 2259*  			CALL    OUT_
04277A 03          2260*  			INC     BC
04277B 2D          2261*  			DEC     L
04277C 20 F7       2262*  			JR      NZ,ASSEM4
04277E CD B9 0A 04 2263*  			CALL    CRLF
042782 C3 CC 26 04 2264*  			JP      ASSEM
042786             2265*  ;
042786 CD 8E 27 04 2266*  HEXSP:			CALL    HEX_EX
04278A 3E 20       2267*  			LD      A,' '
04278C 18 12       2268*  			JR      OUTCH1
04278E F5          2269*  HEX_EX:			PUSH    AF
04278F 0F          2270*  			RRCA
042790 0F          2271*  			RRCA
042791 0F          2272*  			RRCA
042792 0F          2273*  			RRCA
042793 CD 98 27 04 2274*  			CALL    HEXOUT
042797 F1          2275*  			POP     AF
042798 E6 0F       2276*  HEXOUT:			AND     0FH
04279A C6 90       2277*  			ADD     A,90H
04279C 27          2278*  			DAA
04279D CE 40       2279*  			ADC     A,40H
04279F 27          2280*  			DAA
0427A0 C3 DE 0A 04 2281*  OUTCH1:			JP      OUT_
0427A4             2282*  
0427A4             2283*  ; Processor Specific Translation Section:
0427A4             2284*  ;
0427A4             2285*  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0427A4             2286*  ;                 C: Opcode beig built
0427A4             2287*  ;                 D: Flags
0427A4             2288*  ;			Bit 7: Set to 1 if the instruction uses long addressing
0427A4             2289*  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0427A4             2290*  ;                 E: Offset from IX or IY
0427A4             2291*  ;                HL: Numeric operand value
0427A4             2292*  ;                IX: Code destination pointer
0427A4             2293*  ;                IY: Source text pointer
0427A4             2294*  ;    Inputs: A = initial character
0427A4             2295*  ;   Outputs: Carry set if syntax error.
0427A4             2296*  ;
0427A4 FE 2E       2297*  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0427A6 20 1F       2298*  			JR      NZ,ASMB1		; No, so just process the instruction
0427A8 FD 23       2299*  			INC     IY			; Skip past the dot to the label name
0427AA DD E5       2300*  			PUSH    IX			; Store the code destination pointer
0427AC CD 95 1A 04 2301*  			CALL    VAR_			; Create a variable
0427B0 F5          2302*  			PUSH    AF
0427B1 CD 97 17 04 2303*  			CALL    ZERO			; Zero it
0427B5 3A 42 30 11 2304*  			LD	A,(PC+2)
0427B9 6F          2305*  			LD	L,A			; The MSB of the 24-bit address
0427BA D9          2306*  			EXX
0427BB 2A 40 30 11 2307*  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0427BF D9          2308*  			EXX
0427C0 F1          2309*  			POP     AF
0427C1 CD 07 24 04 2310*  			CALL    STORE			; Store the program counter
0427C5 DD E1       2311*  			POP     IX			; Restore the code destination pointer
0427C7             2312*  ;
0427C7 3A 40 4D 04 2313*  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0427CB E6 80       2314*  			AND	80H
0427CD 57          2315*  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0427CE CD EC 2B 04 2316*  			CALL    SKIP			; Skip any whitespace
0427D2 C8          2317*  			RET     Z			; And return if there is nothing further to process
0427D3 FE D6       2318*  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0427D5 0E C4       2319*  			LD      C,0C4H			;  A: The base operand
0427D7 FD 23       2320*  			INC     IY			; Skip past the token
0427D9 CA 21 29 04 2321*  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0427DD FD 2B       2322*  			DEC     IY			; Skip back, as we're not doing the above at this point
0427DF 21 03 2C 04 2323*  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0427E3 CD 9B 2B 04 2324*  			CALL    FIND			; Find the opcode
0427E7 D8          2325*  			RET     C			; If not found, then return; carry indicates an error condition
0427E8 48          2326*  			LD      C,B     		;  C: A copy of the opcode
0427E9             2327*  ;
0427E9             2328*  ; GROUP 0: Trivial cases requiring no computation
0427E9             2329*  ; GROUP 1: As Group 0, but with "ED" prefix
0427E9             2330*  ;
0427E9 D6 44       2331*  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0427EB 30 08       2332*  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0427ED FE CB       2333*  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0427EF D4 F4 2A 04 2334*  			CALL    NC,ED			; Needs to be prefixed with ED
0427F3 18 76       2335*  			JR      BYTE0			; Then write the opcode byte
0427F5             2336*  ;
0427F5             2337*  ; GROUP 2: BIT, RES, SET
0427F5             2338*  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0427F5             2339*  ;
0427F5 D6 0A       2340*  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0427F7 30 12       2341*  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0427F9 FE F9       2342*  			CP      3-10			;
0427FB DC 89 2B 04 2343*  			CALL    C,BIT_
0427FF D8          2344*  			RET     C
042800 CD 5A 2B 04 2345*  			CALL    REGLO
042804 D8          2346*  			RET     C
042805 CD F8 2A 04 2347*  			CALL    CB
042809 18 60       2348*  			JR      BYTE0
04280B             2349*  ;
04280B             2350*  ; GROUP 4 - PUSH, POP, EX (SP)
04280B             2351*  ;
04280B D6 03       2352*  GROUP04:		SUB     3			; The number of opcodes in GROUP4
04280D 30 07       2353*  			JR      NC,GROUP05		; If not in that range, then check GROUP5
04280F CD 7C 2B 04 2354*  GROUP04_1:		CALL    PAIR_EX
042813 D8          2355*  			RET     C
042814 18 55       2356*  			JR      BYTE0
042816             2357*  ;
042816             2358*  ; GROUP 5 - SUB, AND, XOR, OR, CP
042816             2359*  ; GROUP 6 - ADD, ADC, SBC
042816             2360*  ;
042816 D6 0A       2361*  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
042818 30 39       2362*  			JR      NC,GROUP07
04281A FE FD       2363*  			CP      5-8
04281C 06 07       2364*  			LD      B,7
04281E D4 08 2B 04 2365*  			CALL    NC,OPND			; Get the first operand
042822 78          2366*  			LD      A,B
042823 FE 07       2367*  			CP      7			; Is the operand 'A'?
042825 20 15       2368*  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
042827             2369*  ;
042827 CD 5A 2B 04 2370*  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
04282B 79          2371*  			LD      A,C
04282C 30 2E       2372*  			JR      NC,BIND1		; If it is a register, then write that out
04282E EE 46       2373*  			XOR     46H			; Handle ADD A,n
042830 CD FA 2A 04 2374*  			CALL    BIND
042834 CD 3A 2B 04 2375*  DB_:			CALL    NUMBER
042838 C3 F3 28 04 2376*  			JP      VAL8
04283C             2377*  ;
04283C E6 3F       2378*  GROUP05_HL:		AND     3FH
04283E FE 0C       2379*  			CP      12
042840 37          2380*  			SCF
042841 C0          2381*  			RET     NZ
042842 79          2382*  			LD      A,C
042843 FE 80       2383*  			CP      80H
042845 0E 09       2384*  			LD      C,9
042847 28 C6       2385*  			JR      Z,GROUP04_1
042849 EE 1C       2386*  			XOR     1CH
04284B 0F          2387*  			RRCA
04284C 4F          2388*  			LD      C,A
04284D CD F4 2A 04 2389*  			CALL    ED
042851 18 BC       2390*  			JR      GROUP04_1
042853             2391*  ;
042853             2392*  ; GROUP 7 - INC, DEC
042853             2393*  ;
042853 D6 02       2394*  GROUP07:		SUB     2			; The number of opcodes in GROUP7
042855 30 19       2395*  			JR      NC,GROUP08
042857 CD 61 2B 04 2396*  			CALL    REGHI
04285B 79          2397*  			LD      A,C
04285C D2 FA 2A 04 2398*  BIND1:			JP      NC,BIND
042860 EE 64       2399*  			XOR     64H
042862 07          2400*  			RLCA
042863 07          2401*  			RLCA
042864 07          2402*  			RLCA
042865 4F          2403*  			LD      C,A
042866 CD 81 2B 04 2404*  			CALL    PAIR1_EX
04286A D8          2405*  			RET     C
04286B 79          2406*  BYTE0:			LD      A,C
04286C C3 29 2B 04 2407*  			JP      BYTE_
042870             2408*  ;
042870             2409*  ; Group 8: IN0, OUT0
042870             2410*  ;
042870 D6 02       2411*  GROUP08:		SUB	2			; The number of opcodes in GROUP8
042872 30 2C       2412*  			JR	NC,GROUP09
042874 FE FF       2413*  			CP	1-2
042876 CC 3A 2B 04 2414*  			CALL    Z,NUMBER		; Fetch number first if OUT
04287A 08          2415*  			EX      AF,AF'			; Save flags
04287B CD 4E 2B 04 2416*  			CALL    REG			; Get the register value regardless
04287F D8          2417*  			RET     C			; Return if not a register
042880 08          2418*  			EX      AF,AF'			; Restore the flags
042881 DC 3A 2B 04 2419*  			CALL    C,NUMBER		; Fetch number last if IN
042885 78          2420*  			LD	A,B			; Get the register number
042886 FE 06       2421*  			CP	6			; Fail on (HL)
042888 37          2422*  			SCF
042889 C8          2423*  			RET	Z
04288A FE 08       2424*  			CP	8			; Check it is just single pairs only
04288C 3F          2425*  			CCF
04288D D8          2426*  			RET	C			; And return if it is an invalid register
04288E 07          2427*  			RLCA				; Bind with the operand
04288F 07          2428*  			RLCA
042890 07          2429*  			RLCA
042891 81          2430*  			ADD	A,C
042892 4F          2431*  			LD	C,A
042893 CD F4 2A 04 2432*  			CALL	ED			; Prefix with ED
042897 79          2433*  			LD	A,C
042898 CD 29 2B 04 2434*  			CALL	BYTE_			; Write out the operand
04289C C3 F3 28 04 2435*  			JP	VAL8			; Write out the value
0428A0             2436*  ;
0428A0             2437*  ; GROUP 9 - IN
0428A0             2438*  ; GROUP 10 - OUT
0428A0             2439*  ;
0428A0 D6 02       2440*  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0428A2 30 25       2441*  			JR      NC,GROUP11
0428A4 FE FF       2442*  			CP      1-2			; Check if Group 9 or Group 1
0428A6 CC E8 2A 04 2443*  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0428AA 08          2444*  			EX      AF,AF'			; Save flags
0428AB CD 61 2B 04 2445*  			CALL    REGHI			; Get the register value regardless
0428AF D8          2446*  			RET     C			; Return if not a register
0428B0 08          2447*  			EX      AF,AF'			; Restore the flags
0428B1 DC E8 2A 04 2448*  			CALL    C,CORN			; Call CORN if Group 9 (IN)
0428B5 24          2449*  			INC     H			; If it is IN r,(C) or OUT (C),r then
0428B6 28 B3       2450*  			JR      Z,BYTE0			; Just write the operand out
0428B8             2451*  ;
0428B8 78          2452*  			LD      A,B			; Check the register
0428B9 FE 07       2453*  			CP      7
0428BB 37          2454*  			SCF
0428BC C0          2455*  			RET     NZ			; If it is not A, then return
0428BD             2456*  ;
0428BD 79          2457*  			LD      A,C			; Bind the register with the operand
0428BE EE 03       2458*  			XOR     3
0428C0 07          2459*  			RLCA
0428C1 07          2460*  			RLCA
0428C2 07          2461*  			RLCA
0428C3 CD 29 2B 04 2462*  			CALL    BYTE_			; Write out the operand
0428C7 18 2A       2463*  			JR      VAL8			; And the value
0428C9             2464*  ;
0428C9             2465*  ; GROUP 11 - JR, DJNZ
0428C9             2466*  ;
0428C9 D6 02       2467*  GROUP11:		SUB     2			; The number of opcodes in GROUP11
0428CB 30 2B       2468*  			JR      NC,GROUP12
0428CD FE FF       2469*  			CP      1-2
0428CF C4 68 2B 04 2470*  			CALL    NZ,COND_
0428D3 79          2471*  			LD      A,C
0428D4 30 02       2472*  			JR      NC,@F
0428D6 3E 18       2473*  			LD      A,18H
0428D8 CD 29 2B 04 2474*  @@:			CALL    BYTE_
0428DC CD 3A 2B 04 2475*  			CALL    NUMBER
0428E0 ED 5B 40 30 2476*  			LD      DE,(PC)
       11          
0428E5 13          2477*  			INC     DE
0428E6 37          2478*  			SCF
0428E7 ED 52       2479*  			SBC     HL,DE
0428E9 7D          2480*  			LD      A,L
0428EA 17          2481*  			RLA
0428EB 9F          2482*  			SBC     A,A
0428EC BC          2483*  			CP      H
0428ED 3E 01       2484*  TOOFAR:			LD      A,1
0428EF C2 D2 08 04 2485*  			JP      NZ,ERROR_		; Throw an "Out of range" error
0428F3 7D          2486*  VAL8:			LD      A,L
0428F4 C3 29 2B 04 2487*  			JP      BYTE_
0428F8             2488*  ;
0428F8             2489*  ; GROUP 12 - JP
0428F8             2490*  ;
0428F8 D6 01       2491*  GROUP12:		SUB	1			; The number of opcodes in GROUP12
0428FA 30 21       2492*  			JR	NC,GROUP13
0428FC CD 4E 2A 04 2493*  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
042900 D8          2494*  			RET	C			; Exit if an invalid suffix is provided
042901 CD 68 2B 04 2495*  			CALL    COND_			; Evaluate the conditions
042905 79          2496*  			LD      A,C
042906 30 0D       2497*  			JR      NC,GROUP12_1
042908 78          2498*  			LD      A,B
042909 E6 3F       2499*  			AND     3FH
04290B FE 06       2500*  			CP      6
04290D 3E E9       2501*  			LD      A,0E9H
04290F CA 29 2B 04 2502*  			JP      Z,BYTE_
042913 3E C3       2503*  			LD      A,0C3H
042915 CD 29 2B 04 2504*  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
042919 C3 A3 2A 04 2505*  			JP	ADDR_			; Output the address
04291D             2506*  ;
04291D             2507*  ; GROUP 13 - CALL
04291D             2508*  ;
04291D D6 01       2509*  GROUP13:		SUB	1			; The number of opcodes in GROUP13
04291F 30 0C       2510*  			JR	NC,GROUP14
042921 CD 66 2A 04 2511*  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
042925 CD 48 29 04 2512*  			CALL    GROUP15_1		; Output the opcode (with conditions)
042929 C3 A3 2A 04 2513*  			JP	ADDR_			; Output the address
04292D             2514*  ;
04292D             2515*  ; GROUP 14 - RST
04292D             2516*  ;
04292D D6 01       2517*  GROUP14:		SUB	1			; The number of opcodes in GROUP14
04292F 30 13       2518*  			JR	NC,GROUP15
042931 CD 66 2A 04 2519*  			CALL	EZ80SF_FULL		; Evaluate the suffix
042935 D8          2520*  			RET	C			; Exit if an invalid suffix provided
042936 CD 3A 2B 04 2521*  			CALL    NUMBER
04293A A1          2522*  			AND     C
04293B B4          2523*  			OR      H
04293C 20 AF       2524*  			JR      NZ,TOOFAR
04293E 7D          2525*  			LD      A,L
04293F B1          2526*  			OR      C
042940 C3 29 2B 04 2527*  	  		JP      BYTE_
042944             2528*  ;
042944             2529*  ; GROUP 15 - RET
042944             2530*  ;
042944 D6 01       2531*  GROUP15:		SUB	1			; The number of opcodes in GROUP15
042946 30 0F       2532*  			JR	NC,GROUP16
042948 CD 68 2B 04 2533*  GROUP15_1:		CALL    COND_
04294C 79          2534*  			LD      A,C
04294D D2 29 2B 04 2535*  			JP      NC,BYTE_
042951 F6 09       2536*  			OR      9
042953 C3 29 2B 04 2537*  			JP      BYTE_
042957             2538*  ;
042957             2539*  ; GROUP 16 - LD
042957             2540*  ;
042957 D6 01       2541*  GROUP16:		SUB	1			; The number of opcodes in GROUP16
042959 30 74       2542*  			JR	NC,GROUP17
04295B CD 66 2A 04 2543*  			CALL	EZ80SF_FULL		; Evaluate the suffix
04295F CD 97 2B 04 2544*  			CALL    LDOP			; Check for accumulator loads
042963 D2 C3 2A 04 2545*  			JP      NC,LDA			; Yes, so jump here
042967 CD 61 2B 04 2546*  			CALL    REGHI
04296B 08          2547*  			EX      AF,AF'
04296C CD EC 2B 04 2548*  			CALL    SKIP
042970 FE 28       2549*  			CP      '('			; Check for bracket
042972 28 24       2550*  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
042974 08          2551*  			EX      AF,AF'
042975 D2 27 28 04 2552*  			JP      NC,GROUP05_1		; Load single register direct; go here
042979 0E 01       2553*  			LD      C,1
04297B CD 81 2B 04 2554*  			CALL    PAIR1_EX
04297F D8          2555*  			RET     C
042980 3E 0E       2556*  			LD      A,14
042982 B8          2557*  			CP      B
042983 47          2558*  			LD      B,A
042984 CC 7C 2B 04 2559*  			CALL    Z,PAIR_EX
042988 78          2560*  			LD      A,B
042989 E6 3F       2561*  			AND     3FH
04298B FE 0C       2562*  			CP      12
04298D 79          2563*  			LD      A,C
04298E C2 15 29 04 2564*  			JP      NZ,GROUP12_1		; Load register pair direct; go here
042992 3E F9       2565*  			LD      A,0F9H
042994 C3 29 2B 04 2566*  			JP      BYTE_
042998             2567*  ;
042998 08          2568*  LDIN:			EX      AF,AF'
042999 C5          2569*  			PUSH    BC
04299A D4 5A 2B 04 2570*  			CALL    NC,REGLO
04299E 79          2571*  			LD      A,C
04299F C1          2572*  			POP     BC
0429A0 D2 FA 2A 04 2573*  			JP      NC,BIND
0429A4 0E 0A       2574*  			LD      C,0AH
0429A6 CD 81 2B 04 2575*  			CALL    PAIR1_EX
0429AA CD CE 2A 04 2576*  			CALL    LD16
0429AE D2 15 29 04 2577*  			JP      NC,GROUP12_1
0429B2 CD 3A 2B 04 2578*  			CALL    NUMBER
0429B6 0E 02       2579*  			LD      C,2
0429B8 CD 7C 2B 04 2580*  			CALL    PAIR_EX
0429BC CD CE 2A 04 2581*  			CALL    LD16
0429C0 D8          2582*  			RET     C
0429C1 CD 29 2B 04 2583*  			CALL    BYTE_
0429C5 CB 7A       2584*  			BIT	7,D			; Check the ADL flag
0429C7 C2 B8 2A 04 2585*  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0429CB C3 AB 2A 04 2586*  			JP      VAL16			; Otherwise use 16-bit addresses
0429CF             2587*  ;
0429CF             2588*  ; Group 17 - TST
0429CF             2589*  ;
0429CF D6 01       2590*  GROUP17:		SUB	1			; The number of opcodes in GROUP17
0429D1 30 25       2591*  			JR	NC,OPTS
0429D3 CD F4 2A 04 2592*  			CALL	ED			; Needs to be prefixed with ED
0429D7 CD 4E 2B 04 2593*  			CALL	REG			; Fetch the register
0429DB 30 0E       2594*  			JR	NC,GROUP17_1		; It's just a register
0429DD             2595*  ;
0429DD 3E 64       2596*  			LD	A,64H			; Opcode for TST n
0429DF CD 29 2B 04 2597*  			CALL	BYTE_			; Write out the opcode
0429E3 CD 3A 2B 04 2598*  			CALL	NUMBER			; Get the number
0429E7 C3 F3 28 04 2599*  			JP	VAL8			; And write that out
0429EB             2600*  ;
0429EB 78          2601*  GROUP17_1:		LD	A,B			; Check the register rangs
0429EC FE 08       2602*  			CP	8
0429EE 3F          2603*  			CCF
0429EF D8          2604*  			RET	C			; Ret with carry flag set for error if out of range
0429F0 07          2605*  			RLCA				; Get the opcode value
0429F1 07          2606*  			RLCA
0429F2 07          2607*  			RLCA
0429F3 81          2608*  			ADD	A,C			; Add the opcode base in
0429F4 C3 29 2B 04 2609*  			JP	BYTE_
0429F8             2610*  
0429F8             2611*  ;
0429F8             2612*  ; Assembler directives - OPT, ADL
0429F8             2613*  ;
0429F8 D6 02       2614*  OPTS:			SUB	2
0429FA 30 2B       2615*  			JR	NC, DEFS
0429FC FE FF       2616*  			CP	1-2			; Check for ADL opcode
0429FE 28 13       2617*  			JR	Z, ADL_
042A00             2618*  ;
042A00 CD 3A 2B 04 2619*  OPT:			CALL    NUMBER			; Fetch the OPT value
042A04 21 40 4D 04 2620*  			LD      HL,LISTON		; Address of the LISTON/OPT flag
042A08 E6 07       2621*  			AND	7			; Only interested in the first three bits
042A0A 4F          2622*  			LD      C,A			; Store the new OPT value in C
042A0B ED 6F       2623*  			RLD				; Shift the top nibble of LISTON (OPT) into A
042A0D E6 08       2624*  			AND	8			; Clear the bottom three bits, preserving the ADL bit
042A0F B1          2625*  			OR	C			; OR in the new value
042A10 ED 67       2626*  			RRD				; And shift the nibble back in
042A12 C9          2627*  			RET
042A13             2628*  ;
042A13 CD 3A 2B 04 2629*  ADL_:			CALL	NUMBER			; Fetch the ADL value
042A17 E6 01       2630*  			AND	1			; Only interested if it is 0 or 1
042A19 0F          2631*  			RRCA				; Rotate to bit 7
042A1A 4F          2632*  			LD	C,A			; Store in C
042A1B 3A 40 4D 04 2633*  			LD	A,(LISTON)		; Get the LISTON system variable
042A1F E6 7F       2634*  			AND	7Fh			; Clear bit 7
042A21 B1          2635*  			OR	C			; OR in the ADL value
042A22 32 40 4D 04 2636*  			LD	(LISTON),A		; Store
042A26 C9          2637*  			RET
042A27             2638*  ;
042A27             2639*  ; DEFB, DEFW, DEFL, DEFM
042A27             2640*  ;
042A27 B7          2641*  DEFS:			OR	A			; Handle DEFB
042A28 CA 34 28 04 2642*  			JP	Z, DB_
042A2C 3D          2643*  			DEC	A			; Handle DEFW
042A2D CA A7 2A 04 2644*  			JP	Z, ADDR16
042A31 3D          2645*  			DEC	A			; Handle DEFL
042A32 CA B4 2A 04 2646*  			JP	Z, ADDR24
042A36             2647*  ;
042A36 DD E5       2648*  			PUSH    IX			; Handle DEFM
042A38 CD 19 11 04 2649*  			CALL    EXPRS
042A3C DD E1       2650*  			POP     IX
042A3E 21 00 4A 04 2651*  			LD      HL,ACCS
042A42 AF          2652*  @@:			XOR     A
042A43 BB          2653*  			CP      E
042A44 C8          2654*  			RET     Z
042A45 7E          2655*  			LD      A,(HL)
042A46 23          2656*  			INC     HL
042A47 CD 29 2B 04 2657*  			CALL    BYTE_
042A4B 1D          2658*  			DEC     E
042A4C 18 F4       2659*  			JR      @B
042A4E             2660*  
042A4E             2661*  ;
042A4E             2662*  ;SUBROUTINES:
042A4E             2663*  ;
042A4E FD 7E 00    2664*  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
042A51 FE 2E       2665*  			CP	'.'
042A53 28 02       2666*  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
042A55 B7          2667*  			OR	A			; Reset the carry flag (no error)
042A56 C9          2668*  			RET				; And return
042A57 FD 23       2669*  @@:			INC	IY			; Skip the dot
042A59 C5          2670*  			PUSH	BC			; Push the operand
042A5A 21 82 2E 04 2671*  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
042A5E CD 9B 2B 04 2672*  			CALL	FIND			; Look up the operand
042A62 30 24       2673*  			JR	NC,EZ80SF_OK
042A64 C1          2674*  			POP	BC			; Not found at this point, so will return with a C (error)
042A65 C9          2675*  			RET
042A66             2676*  ;
042A66 FD 7E 00    2677*  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
042A69 FE 2E       2678*  			CP	'.'
042A6B 28 02       2679*  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
042A6D B7          2680*  			OR	A			; Reset the carry flag (no error)
042A6E C9          2681*  			RET				; And return
042A6F FD 23       2682*  @@:			INC	IY 			; Skip the dot
042A71 C5          2683*  			PUSH	BC			; Push the operand
042A72 21 7A 2E 04 2684*  			LD	HL,EZ80SFS_1		; First check the fully qualified table
042A76 CD 9B 2B 04 2685*  			CALL	FIND 			; Look up the operand
042A7A 30 0C       2686*  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
042A7C CD 97 2A 04 2687*  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
042A80 CD 9B 2B 04 2688*  			CALL	FIND
042A84 30 02       2689*  			JR	NC,EZ80SF_OK
042A86 C1          2690*  			POP	BC			; Not found at this point, so will return with a C (error)
042A87 C9          2691*  			RET
042A88             2692*  ;
042A88 78          2693*  EZ80SF_OK:		LD	A,B			; The operand value
042A89 D4 29 2B 04 2694*  			CALL	NC,BYTE_ 		; Write it out if found
042A8D CB BA       2695*  			RES	7,D			; Clear the default ADL mode from the flags
042A8F E6 02       2696*  			AND	2			; Check the second half of the suffix (.xxL)
042A91 0F          2697*  			RRCA				; Shift into bit 7
042A92 0F          2698*  			RRCA
042A93 B2          2699*  			OR	D			; Or into bit 7 of D
042A94 57          2700*  			LD	D,A
042A95 C1          2701*  			POP	BC 			; Restore the operand
042A96 C9          2702*  			RET
042A97             2703*  ;
042A97 21 8B 2E 04 2704*  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
042A9B CB 7A       2705*  			BIT 	7,D			; if bit 7 of D is 0
042A9D C8          2706*  			RET	Z
042A9E 21 96 2E 04 2707*  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
042AA2 C9          2708*  			RET
042AA3             2709*  ;
042AA3 CB 7A       2710*  ADDR_:			BIT	7,D			; Check the ADL flag
042AA5 20 0D       2711*  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
042AA7             2712*  ;
042AA7 CD 3A 2B 04 2713*  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
042AAB CD F3 28 04 2714*  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
042AAF 7C          2715*  			LD      A,H
042AB0 C3 29 2B 04 2716*  			JP      BYTE_
042AB4             2717*  ;
042AB4 CD 3A 2B 04 2718*  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
042AB8 CD AB 2A 04 2719*  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
042ABC D9          2720*  			EXX
042ABD 7D          2721*  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
042ABE D9          2722*  			EXX
042ABF C3 29 2B 04 2723*  			JP	BYTE_
042AC3             2724*  ;
042AC3 FE 04       2725*  LDA:			CP      4
042AC5 DC F4 2A 04 2726*  			CALL    C,ED
042AC9 78          2727*  			LD      A,B
042ACA C3 29 2B 04 2728*  			JP      BYTE_
042ACE             2729*  ;
042ACE 78          2730*  LD16:			LD      A,B
042ACF 38 0F       2731*  			JR      C,LD8
042AD1 78          2732*  			LD      A,B
042AD2 E6 3F       2733*  			AND     3FH
042AD4 FE 0C       2734*  			CP      12
042AD6 79          2735*  			LD      A,C
042AD7 C8          2736*  			RET     Z
042AD8 CD F4 2A 04 2737*  			CALL    ED
042ADC 79          2738*  			LD      A,C
042ADD F6 43       2739*  			OR      43H
042ADF C9          2740*  			RET
042AE0             2741*  ;
042AE0 FE 07       2742*  LD8:			CP      7
042AE2 37          2743*  			SCF
042AE3 C0          2744*  			RET     NZ
042AE4 79          2745*  			LD      A,C
042AE5 F6 30       2746*  			OR      30H
042AE7 C9          2747*  			RET
042AE8             2748*  ;
042AE8             2749*  ; Used in IN and OUT to handle whether the operand is C or a number
042AE8             2750*  ;
042AE8 C5          2751*  CORN:			PUSH    BC
042AE9 CD 08 2B 04 2752*  			CALL    OPND			; Get the operand
042AED CB 68       2753*  			BIT     5,B
042AEF C1          2754*  			POP     BC
042AF0 28 48       2755*  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
042AF2 26 FF       2756*  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
042AF4             2757*  ;
042AF4 3E ED       2758*  ED:			LD      A,0EDH			; Write an ED prefix out
042AF6 18 31       2759*  			JR      BYTE_
042AF8             2760*  ;
042AF8 3E CB       2761*  CB:			LD      A,0CBH
042AFA FE 76       2762*  BIND:			CP      76H
042AFC 37          2763*  			SCF
042AFD C8          2764*  			RET     Z               	; Reject LD (HL),(HL)
042AFE CD 29 2B 04 2765*  			CALL    BYTE_
042B02 CB 72       2766*  			BIT	6,D			; Check the index bit in flags
042B04 C8          2767*  			RET     Z
042B05 7B          2768*  			LD      A,E			; If there is an index, output the offset
042B06 18 21       2769*  			JR      BYTE_
042B08             2770*  ;
042B08             2771*  ; Search through the operand table
042B08             2772*  ; Returns:
042B08             2773*  ; - B: The operand type
042B08             2774*  ; - D: Bit 7: 0 = no prefix, 1 = prefix
042B08             2775*  ; - E: The IX/IY offset
042B08             2776*  ; - F: Carry if not found
042B08             2777*  ;
042B08 E5          2778*  OPND:			PUSH    HL			; Preserve HL
042B09 21 0C 2E 04 2779*  			LD      HL,OPRNDS		; The operands table
042B0D CD 9B 2B 04 2780*  			CALL    FIND			; Find the operand
042B11 E1          2781*  			POP     HL
042B12 D8          2782*  			RET     C			; Return if not found
042B13 CB 78       2783*  			BIT     7,B			; Check if it is an index register (IX, IY)
042B15 C8          2784*  			RET     Z			; Return if it isn't
042B16 CB F2       2785*  			SET	6,D			; Set flag to indicate we've got an index
042B18 CB 58       2786*  			BIT     3,B			; Check if an offset is required
042B1A E5          2787*  			PUSH    HL
042B1B CC 30 2B 04 2788*  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
042B1F 5D          2789*  			LD      E,L			; E: The offset
042B20 E1          2790*  			POP     HL
042B21 3E DD       2791*  			LD	A,DDH			; IX prefix
042B23 CB 70       2792*  			BIT     6,B			; If bit 6 is reset then
042B25 28 02       2793*  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
042B27 3E FD       2794*  			LD	A,FDH			; IY prefix
042B29             2795*  ;
042B29 DD 77 00    2796*  BYTE_:			LD      (IX),A			; Write a byte out
042B2C DD 23       2797*  			INC     IX
042B2E B7          2798*  			OR      A
042B2F C9          2799*  			RET
042B30             2800*  ;
042B30 FD 7E 00    2801*  OFFSET_EX:			LD      A,(IY)
042B33 FE 29       2802*  			CP      ')'
042B35 21 00 00 00 2803*  			LD      HL,0
042B39 C8          2804*  			RET     Z
042B3A CD EC 2B 04 2805*  NUMBER:			CALL    SKIP
042B3E C5          2806*  			PUSH    BC
042B3F D5          2807*  			PUSH    DE
042B40 DD E5       2808*  			PUSH    IX
042B42 CD 0E 11 04 2809*  			CALL    EXPRI
042B46 DD E1       2810*  			POP     IX
042B48 D9          2811*  			EXX
042B49 D1          2812*  			POP     DE
042B4A C1          2813*  			POP     BC
042B4B 7D          2814*  			LD      A,L
042B4C B7          2815*  			OR      A
042B4D C9          2816*  			RET
042B4E             2817*  ;
042B4E CD 08 2B 04 2818*  REG:			CALL    OPND
042B52 D8          2819*  			RET     C
042B53 78          2820*  			LD      A,B
042B54 E6 3F       2821*  			AND     3FH
042B56 FE 08       2822*  			CP      8
042B58 3F          2823*  			CCF
042B59 C9          2824*  			RET
042B5A             2825*  ;
042B5A CD 4E 2B 04 2826*  REGLO:			CALL    REG
042B5E D8          2827*  			RET     C
042B5F 18 33       2828*  			JR      ORC
042B61             2829*  ;
042B61 CD 4E 2B 04 2830*  REGHI:			CALL    REG
042B65 D8          2831*  			RET     C
042B66 18 29       2832*  			JR      SHL3
042B68             2833*  ;
042B68 CD 08 2B 04 2834*  COND_:			CALL    OPND
042B6C D8          2835*  			RET     C
042B6D 78          2836*  			LD      A,B
042B6E E6 1F       2837*  			AND     1FH
042B70 D6 10       2838*  			SUB     16
042B72 30 1D       2839*  			JR      NC,SHL3
042B74 FE F1       2840*  			CP      -15
042B76 37          2841*  			SCF
042B77 C0          2842*  			RET     NZ
042B78 3E 03       2843*  			LD      A,3
042B7A 18 15       2844*  			JR      SHL3
042B7C             2845*  ;
042B7C CD 08 2B 04 2846*  PAIR_EX:			CALL    OPND
042B80 D8          2847*  			RET     C
042B81 78          2848*  PAIR1_EX:			LD      A,B
042B82 E6 0F       2849*  			AND     0FH
042B84 D6 08       2850*  			SUB     8
042B86 D8          2851*  			RET     C
042B87 18 08       2852*  			JR      SHL3
042B89             2853*  ;
042B89 CD 3A 2B 04 2854*  BIT_:			CALL    NUMBER
042B8D FE 08       2855*  			CP      8
042B8F 3F          2856*  			CCF
042B90 D8          2857*  			RET     C
042B91 07          2858*  SHL3:			RLCA
042B92 07          2859*  			RLCA
042B93 07          2860*  			RLCA
042B94 B1          2861*  ORC:			OR      C
042B95 4F          2862*  			LD      C,A
042B96 C9          2863*  			RET
042B97             2864*  ;
042B97 21 51 2E 04 2865*  LDOP:			LD      HL,LDOPS
042B9B             2866*  
042B9B             2867*  ;
042B9B             2868*  ; Look up a value in a table
042B9B             2869*  ; Parameters:
042B9B             2870*  ; - IY: Address of the assembly language line in the BASIC program area
042B9B             2871*  ; - HL: Address of the table
042B9B             2872*  ; Returns:
042B9B             2873*  ; - B: The operand code
042B9B             2874*  ; - F: Carry set if not found
042B9B             2875*  ;
042B9B CD EC 2B 04 2876*  FIND:			CALL    SKIP			; Skip delimiters
042B9F             2877*  ;
042B9F 06 00       2878*  EXIT_:			LD      B,0			; Set B to 0
042BA1 37          2879*  			SCF				; Set the carry flag
042BA2 C8          2880*  			RET     Z			; Returns if Z
042BA3             2881*  ;
042BA3 FE DD       2882*  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
042BA5 28 04       2883*  			JR      Z,FIND0
042BA7 FE 85       2884*  			CP      TOR+1			; Special case for tokens AND and OR
042BA9 3F          2885*  			CCF
042BAA D8          2886*  			RET     C
042BAB 7E          2887*  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
042BAC B7          2888*  			OR      A
042BAD 28 F0       2889*  			JR      Z,EXIT_			; Exit
042BAF FD AE 00    2890*  			XOR     (IY)
042BB2 E6 5F       2891*  			AND     01011111B
042BB4 28 09       2892*  			JR      Z,FIND2
042BB6 CB 7E       2893*  FIND1:			BIT     7,(HL)
042BB8 23          2894*  			INC     HL
042BB9 28 FB       2895*  			JR      Z,FIND1
042BBB 23          2896*  			INC     HL
042BBC 04          2897*  			INC     B
042BBD 18 EC       2898*  			JR      FIND0
042BBF             2899*  ;
042BBF FD E5       2900*  FIND2:			PUSH    IY
042BC1 CB 7E       2901*  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
042BC3 FD 23       2902*  			INC     IY
042BC5 23          2903*  			INC     HL
042BC6 20 11       2904*  			JR      NZ,FIND5		; Yes
042BC8 BE          2905*  			CP      (HL)
042BC9 CC EB 2B 04 2906*  			CALL    Z,SKIP0
042BCD 7E          2907*  			LD      A,(HL)
042BCE FD AE 00    2908*  			XOR     (IY)
042BD1 E6 5F       2909*  			AND     01011111B
042BD3 28 EC       2910*  			JR      Z,FIND3
042BD5 FD E1       2911*  FIND4:			POP     IY
042BD7 18 DD       2912*  			JR      FIND1
042BD9             2913*  ;
042BD9 CD 97 25 04 2914*  FIND5:			CALL    DELIM			; Is it a delimiter?
042BDD C4 00 2C 04 2915*  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
042BE1 C4 FA 2B 04 2916*  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
042BE5 20 EE       2917*  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
042BE7             2918*  ;
042BE7 78          2919*  FIND6:			LD      A,B			; At this point we have a token
042BE8 46          2920*  			LD      B,(HL)			; Fetch the token type code
042BE9 E1          2921*  			POP     HL			; Restore the stack
042BEA C9          2922*  			RET
042BEB             2923*  ;
042BEB 23          2924*  SKIP0:			INC     HL
042BEC CD 97 25 04 2925*  SKIP:			CALL    DELIM			; Is it a delimiter?
042BF0 C0          2926*  			RET     NZ			; No, so return
042BF1 CD A3 25 04 2927*  			CALL    TERM			; Is it a terminator?
042BF5 C8          2928*  			RET     Z			; Yes, so return
042BF6 FD 23       2929*  			INC     IY			; Increment the basic program counter
042BF8 18 F2       2930*  			JR      SKIP			; And loop
042BFA             2931*  ;
042BFA FE 2B       2932*  SIGN:			CP      '+'			; Check whether the character is a sign symbol
042BFC C8          2933*  			RET     Z
042BFD FE 2D       2934*  			CP      '-'
042BFF C9          2935*  			RET
042C00             2936*  ;
042C00 FE 2E       2937*  DOT:			CP	'.'			; Check if it is a dot character
042C02 C9          2938*  			RET
042C03             2939*  ; Z80 opcode list
042C03             2940*  ;
042C03             2941*  ; Group 0: (15 opcodes)
042C03             2942*  ; Trivial cases requiring no computation
042C03             2943*  ;
042C03 4E 4F 50 00 2944*  OPCODS:			DB	"NO","P"+80H,00h	; # 00h
042C07 52 4C 43 41 2945*  			DB	"RLC","A"+80H,07h
       07          
042C0C 45 58 00 41 2946*  			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
042C16 52 52 43 41 2947*  			DB	"RRC","A"+80H,0FH
       0F          
042C1B 52 4C 41 17 2948*  			DB	"RL","A"+80H,17H
042C1F 52 52 41 1F 2949*  			DB	"RR","A"+80H,1FH
042C23 44 41 41 27 2950*  			DB	"DA","A"+80H,27H
042C27 43 50 4C 2F 2951*  			DB	"CP","L"+80H,2FH
042C2B 53 43 46 37 2952*  			DB	"SC","F"+80H,37H
042C2F 43 43 46 3F 2953*  			DB	"CC","F"+80H,3FH
042C33 48 41 4C 54 2954*  			DB	"HAL","T"+80H,76H
       76          
042C38 45 58 58 D9 2955*  			DB	"EX","X"+80H,D9H
042C3C 45 58 00 44 2956*  			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
042C45 44 49 F3    2957*  			DB	"D","I"+80H,F3H
042C48 45 49 FB    2958*  			DB	"E","I"+80H,FBH
042C4B             2959*  ;
042C4B             2960*  ; Group 1: (53 opcodes)
042C4B             2961*  ; As Group 0, but with an ED prefix
042C4B             2962*  ;
042C4B 4E 45 47 44 2963*  			DB	"NE","G"+80H,44H	; 0Fh
042C4F 49 4D 00 30 2964*  			DB	"IM",0,"0"+80H,46H
       46          
042C54 52 45 54 4E 2965*  			DB	"RET","N"+80H,45H
       45          
042C59 4D 4C 54 00 2966*  			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
042C60 52 45 54 49 2967*  			DB	"RET","I"+80H,4DH
       4D          
042C65 49 4D 00 31 2968*  			DB	"IM",0,"1"+80H,56H
       56          
042C6A 4D 4C 54 00 2969*  			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
042C71 49 4D 00 32 2970*  			DB	"IM",0,"2"+80H,5EH
       5E          
042C76 52 52 44 67 2971*  			DB	"RR","D"+80H,67H
042C7A 4D 4C 54 00 2972*  			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
042C81 4C 44 00 4D 2973*  			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
042C89 4C 44 00 41 2974*  			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
042C91 52 4C 44 6F 2975*  			DB	"RL","D"+80H,6FH
042C95 53 4C 50 76 2976*  			DB	"SL","P"+80H,76H
042C99 4D 4C 54 00 2977*  			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
042CA0 53 54 4D 49 2978*  			DB	"STMI","X"+80H,7DH
       58 7D       
042CA6 52 53 4D 49 2979*  			DB	"RSMI","X"+80H,7EH
       58 7E       
042CAC 49 4E 49 4D 2980*  			DB	"INI","M"+80H,82H
       82          
042CB1 4F 54 49 4D 2981*  			DB	"OTI","M"+80H,83H
       83          
042CB6 49 4E 49 32 2982*  			DB	"INI","2"+80H,84H
       84          
042CBB 49 4E 44 4D 2983*  			DB	"IND","M"+80H,8AH
       8A          
042CC0 4F 54 44 4D 2984*  			DB	"OTD","M"+80H,8BH
       8B          
042CC5 49 4E 44 32 2985*  			DB	"IND","2"+80H,8CH
       8C          
042CCA 49 4E 49 4D 2986*  			DB	"INIM","R"+80H,92H
       52 92       
042CD0 4F 54 49 4D 2987*  			DB	"OTIM","R"+80H,93H
       52 93       
042CD6 49 4E 49 32 2988*  			DB	"INI2","R"+80H,94H
       52 94       
042CDC 49 4E 44 4D 2989*  			DB	"INDM","R"+80H,9AH
       52 9A       
042CE2 4F 54 44 4D 2990*  			DB	"OTDM","R"+80H,9BH
       52 9B       
042CE8 49 4E 44 32 2991*  			DB	"IND2","R"+80H,9CH
       52 9C       
042CEE 4C 44 49 A0 2992*  			DB	"LD","I"+80H,A0H
042CF2 43 50 49 A1 2993*  			DB	"CP","I"+80H,A1H
042CF6 49 4E 49 A2 2994*  			DB	"IN","I"+80H,A2H
042CFA 4F 55 54 49 2995*  			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
042D00 4F 55 54 49 2996*  			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
042D05 4C 44 44 A8 2997*  			DB	"LD","D"+80H,A8H
042D09 43 50 44 A9 2998*  			DB	"CP","D"+80H,A9H
042D0D 49 4E 44 AA 2999*  			DB	"IN","D"+80H,AAH
042D11 4F 55 54 44 3000*  			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
042D17 4F 55 54 44 3001*  			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
042D1C 4C 44 49 52 3002*  			DB	"LDI","R"+80H,B0H
       B0          
042D21 43 50 49 52 3003*  			DB	"CPI","R"+80H,B1H
       B1          
042D26 49 4E 49 52 3004*  			DB	"INI","R"+80H,B2H
       B2          
042D2B 4F 54 49 52 3005*  			DB	"OTI","R"+80H,B3H
       B3          
042D30 4F 54 49 32 3006*  			DB	"OTI2","R"+80H,B4H
       52 B4       
042D36 4C 44 44 52 3007*  			DB	"LDD","R"+80H,B8H
       B8          
042D3B 43 50 44 52 3008*  			DB	"CPD","R"+80H,B9H
       B9          
042D40 49 4E 44 52 3009*  			DB	"IND","R"+80H,BAH
       BA          
042D45 4F 54 44 52 3010*  			DB	"OTD","R"+80H,BBH
       BB          
042D4A 4F 54 44 32 3011*  			DB	"OTD2","R"+80H,BCH
       52 BC       
042D50 49 4E 49 52 3012*  			DB	"INIR","X"+80H,C2H
       58 C2       
042D56 4F 54 49 52 3013*  			DB	"OTIR","X"+80H,C3H
       58 C3       
042D5C 49 4E 44 52 3014*  			DB	"INDR","X"+80H,CAH
       58 CA       
042D62 4F 54 44 52 3015*  			DB	"OTDR","X"+80H,CBH
       58 CB       
042D68             3016*  ;
042D68             3017*  ; Group 2: (3 opcodes)
042D68             3018*  ;
042D68 42 49 54 40 3019*  			DB	"BI","T"+80H,40H	; 44h
042D6C 52 45 53 80 3020*  			DB	"RE","S"+80H,80H
042D70 53 45 54 C0 3021*  			DB	"SE","T"+80H,C0H
042D74             3022*  ;
042D74             3023*  ; Group 3: (7 opcodes)
042D74             3024*  ;
042D74 52 4C 43 00 3025*  			DB	"RL","C"+80H,00H	; 47h
042D78 52 52 43 08 3026*  			DB	"RR","C"+80H,08H
042D7C 52 4C 10    3027*  			DB	"R","L"+80H,10H
042D7F 52 52 18    3028*  			DB	"R","R"+80H,18H
042D82 53 4C 41 20 3029*  			DB	"SL","A"+80H,20H
042D86 53 52 41 28 3030*  			DB	"SR","A"+80H,28H
042D8A 53 52 4C 38 3031*  			DB	"SR","L"+80H,38H
042D8E             3032*  ;
042D8E             3033*  ; Group 4: (3 opcodes)
042D8E             3034*  ;
042D8E 50 4F 50 C1 3035*  			DB	"PO","P"+80H,C1H	; 4Eh
042D92 50 55 53 48 3036*  			DB	"PUS","H"+80H,C5H
       C5          
042D97 45 58 00 28 3037*  			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
042D9E             3038*  ;
042D9E             3039*  ; Group 5: (7 opcodes)
042D9E             3040*  ;
042D9E 53 55 42 90 3041*  			DB	"SU","B"+80H,90H	; 51h
042DA2 41 4E 44 A0 3042*  			DB	"AN","D"+80H,A0H
042DA6 58 4F 52 A8 3043*  			DB	"XO","R"+80H,A8H
042DAA 4F 52 B0    3044*  			DB	"O","R"+80H,B0H
042DAD 43 50 B8    3045*  			DB	"C","P"+80H,B8H
042DB0 80 A0       3046*  			DB	TAND,A0H		; 56h TAND: Tokenised AND
042DB2 84 B0       3047*  			DB	TOR,B0H			; 57h TOR: Tokenised OR
042DB4             3048*  ;
042DB4             3049*  ; Group 6 (3 opcodes)
042DB4             3050*  ;
042DB4 41 44 44 80 3051*  			DB	"AD","D"+80H,80H	; 58h
042DB8 41 44 43 88 3052*  			DB	"AD","C"+80H,88H
042DBC 53 42 43 98 3053*  			DB	"SB","C"+80H,98H
042DC0             3054*  ;
042DC0             3055*  ; Group 7: (2 opcodes)
042DC0             3056*  ;
042DC0 49 4E 43 04 3057*  			DB	"IN","C"+80H,04H	; 5Bh
042DC4 44 45 43 05 3058*  			DB	"DE","C"+80H,05H
042DC8             3059*  ;
042DC8             3060*  ; Group 8: (2 opcodes)
042DC8             3061*  ;
042DC8 49 4E 30 00 3062*  			DB	"IN","0"+80H,00H	; 5Dh
042DCC 4F 55 54 30 3063*  			DB	"OUT","0"+80H,01H
       01          
042DD1             3064*  ;
042DD1             3065*  ; Group 9: (1 opcode)
042DD1             3066*  ;
042DD1 49 4E 40    3067*  			DB	"I","N"+80H,40H		; 5Fh
042DD4             3068*  ;
042DD4             3069*  ; Group 10: (1 opcode)
042DD4             3070*  ;
042DD4 4F 55 54 41 3071*  			DB	"OU","T"+80H,41H	; 60h
042DD8             3072*  ;
042DD8             3073*  ; Group 11: (2 opcodes)
042DD8             3074*  ;
042DD8 4A 52 20    3075*  			DB	"J","R"+80H,20H		; 61h
042DDB 44 4A 4E 5A 3076*  			DB	"DJN","Z"+80H,10H
       10          
042DE0             3077*  ;
042DE0             3078*  ; Group 12: (1 opcode)
042DE0             3079*  ;
042DE0 4A 50 C2    3080*  			DB	"J","P"+80H,C2H		; 63h
042DE3             3081*  ;
042DE3             3082*  ; Group 13: (1 opcode)
042DE3             3083*  ;
042DE3 43 41 4C 4C 3084*  			DB	"CAL","L"+80H,C4H	; 64h
       C4          
042DE8             3085*  ;
042DE8             3086*  ; Group 14: (1 opcode)
042DE8             3087*  ;
042DE8 52 53 54 C7 3088*  			DB	"RS","T"+80H,C7H	; 65h
042DEC             3089*  ;
042DEC             3090*  ; Group 15: (1 opcode)
042DEC             3091*  ;
042DEC 52 45 54 C0 3092*  			DB	"RE","T"+80H,C0H	; 66h
042DF0             3093*  ;
042DF0             3094*  ; Group 16: (1 opcode)
042DF0             3095*  ;
042DF0 4C 44 40    3096*  			DB	"L","D"+80H,40H		; 67h
042DF3             3097*  ;
042DF3             3098*  ; Group 17: (1 opcode)
042DF3             3099*  ;
042DF3 54 53 54 04 3100*  			DB	"TS","T"+80H,04H	; 68h
042DF7             3101*  
042DF7             3102*  ;
042DF7             3103*  ; Assembler Directives
042DF7             3104*  ;
042DF7 4F 50 54 00 3105*  			DB	"OP","T"+80H,00H	; 69h OPT
042DFB 41 44 4C 00 3106*  			DB	"AD","L"+80H,00H	; 6Ah ADL
042DFF             3107*  ;
042DFF 5D 42 00    3108*  			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
042E02 5D 57 00    3109*  			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
042E05 5D 4C 00    3110*  			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
042E08 5D 4D 00    3111*  			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
042E0B             3112*  ;
042E0B 00          3113*  			DB	0
042E0C             3114*  ;
042E0C             3115*  ; Operands
042E0C             3116*  ;
042E0C 42 00       3117*  OPRNDS:			DB	"B"+80H, 00H
042E0E 43 01       3118*  			DB	"C"+80H, 01H
042E10 44 02       3119*  			DB	"D"+80H, 02H
042E12 45 03       3120*  			DB	"E"+80H, 03H
042E14 48 04       3121*  			DB	"H"+80H, 04H
042E16 4C 05       3122*  			DB	"L"+80H, 05H
042E18 28 48 4C 06 3123*  			DB	"(H","L"+80H,06H
042E1C 41 07       3124*  			DB	"A"+80H, 07H
042E1E 28 49 58 86 3125*  			DB	"(I","X"+80H,86H
042E22 28 49 59 C6 3126*  			DB	"(I","Y"+80H,C6H
042E26             3127*  ;
042E26 42 43 08    3128*  			DB	"B","C"+80H,08H
042E29 44 45 0A    3129*  			DB	"D","E"+80H,0AH
042E2C 48 4C 0C    3130*  			DB	"H","L"+80H,0CH
042E2F 49 58 8C    3131*  			DB	"I","X"+80H,8CH
042E32 49 59 CC    3132*  			DB	"I","Y"+80H,CCH
042E35 41 46 0E    3133*  			DB	"A","F"+80H,0EH
042E38 53 50 0E    3134*  			DB	"S","P"+80H,0EH
042E3B             3135*  ;
042E3B 4E 5A 10    3136*  			DB	"N","Z"+80H,10H
042E3E 5A 11       3137*  			DB	"Z"+80H,11H
042E40 4E 43 12    3138*  			DB	"N","C"+80H,12H
042E43 50 4F 14    3139*  			DB	"P","O"+80H,14H
042E46 50 45 15    3140*  			DB	"P","E"+80H,15H
042E49 50 16       3141*  			DB	"P"+80H,16H
042E4B 4D 17       3142*  			DB	"M"+80H,17H
042E4D             3143*  ;
042E4D 28 43 20    3144*  			DB	"(","C"+80H,20H
042E50             3145*  ;
042E50 00          3146*  			DB	0
042E51             3147*  ;
042E51             3148*  ; Load operations
042E51             3149*  ;
042E51 49 00 41 47 3150*  LDOPS:			DB	"I",0,"A"+80H,47H
042E55 52 00 41 4F 3151*  			DB	"R",0,"A"+80H,4FH
042E59 41 00 49 57 3152*  			DB	"A",0,"I"+80H,57H
042E5D 41 00 52 5F 3153*  			DB	"A",0,"R"+80H,5FH
042E61 28 42 43 00 3154*  			DB	"(BC",0,"A"+80H,02h
       41 02       
042E67 28 44 45 00 3155*  			DB	"(DE",0,"A"+80H,12H
       41 12       
042E6D 41 00 28 42 3156*  			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
042E73 41 00 28 44 3157*  			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
042E79             3158*  ;
042E79 00          3159*  			DB	0
042E7A             3160*  ;
042E7A             3161*  ; eZ80 addressing mode suffixes
042E7A             3162*  ;
042E7A             3163*  ; Fully qualified suffixes
042E7A             3164*  ;
042E7A 4C 49 53 49 3165*  EZ80SFS_1:		DB	"LI","S"+80H,49H
042E7E 53 49 4C 52 3166*  			DB	"SI","L"+80H,52H
042E82 53 49 53 40 3167*  EZ80SFS_2:		DB	"SI","S"+80H,40H
042E86 4C 49 4C 5B 3168*  			DB	"LI","L"+80H,5BH
042E8A             3169*  ;
042E8A 00          3170*  			DB	0
042E8B             3171*  ;
042E8B             3172*  ; Shortcuts when ADL mode is 0
042E8B             3173*  ;
042E8B 53 40       3174*  EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
042E8D 4C 49       3175*  			DB	"L"+80H,49H		; Equivalent to .LIS
042E8F 49 53 40    3176*  			DB	"I","S"+80H,40H		; Equivalent to .SIS
042E92 49 4C 52    3177*  			DB	"I","L"+80H,52H		; Equivalent to .SIL
042E95             3178*  ;
042E95 00          3179*  			DB	0
042E96             3180*  ;
042E96             3181*  ; Shortcuts when ADL mode is 1
042E96             3182*  ;
042E96 53 52       3183*  EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
042E98 4C 5B       3184*  			DB	"L"+80H,5BH		; Equivalent to .LIL
042E9A 49 53 49    3185*  			DB	"I","S"+80H,49H		; Equivalent to .LIS
042E9D 49 4C 5B    3186*  			DB	"I","L"+80H,5BH		; Equivalent to .LIL
042EA0             3187*  ;
042EA0 00          3188*  			DB	0
042EA1             3189*  ;
042EA1             3190*  ; .LIST
042EA1             3191*  ;
042EA1             3192*  ; already defined in equs.inc
042EA1             3193*  ; LF:			EQU     0AH
042EA1             3194*  ; CR:			EQU     0DH
042EA1             0009       include "fpp.asm"
042EA1             0001*  ;
042EA1             0002*  ; Title:	BBC Basic Interpreter - Z80 version
042EA1             0003*  ;		Z80 Floating Point Package
042EA1             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
042EA1             0005*  ; Modified By:	Dean Belfield
042EA1             0006*  ; Created:	03/05/2022
042EA1             0007*  ; Last Updated:	07/06/2023
042EA1             0008*  ;
042EA1             0009*  ; Modinfo:
042EA1             0010*  ; 26/10/1986:	Version 0.0
042EA1             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
042EA1             0012*  ; 12/05/2023:	Modified by Dean Belfield
042EA1             0013*  ; 07/06/2023:	Modified to run in ADL mode
042EA1             0014*  
042EA1             0015*  			; .ASSUME	ADL = 1
042EA1             0016*  
042EA1             0017*  			; SEGMENT CODE
042EA1             0018*  
042EA1             0019*  			; XDEF	FPP
042EA1             0020*  			; XDEF	DLOAD5
042EA1             0021*  			; XDEF	DLOAD5_SPL
042EA1             0022*  ;
042EA1             0023*  ;BINARY FLOATING POINT REPRESENTATION:
042EA1             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
042EA1             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
042EA1             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
042EA1             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
042EA1             0028*  ;
042EA1             0029*  ;BINARY INTEGER REPRESENTATION:
042EA1             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
042EA1             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
042EA1             0032*  ;
042EA1             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
042EA1             0034*  ;                            EXPONENT - C
042EA1             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
042EA1             0036*  ;                               EXPONENT - B
042EA1             0037*  
042EA1             0038*  ;
042EA1             0039*  ;Error codes:
042EA1             0040*  ;
042EA1             0041*  
042EA1             0042*  ; BADOP:			EQU     1               ;Bad operation code
042EA1             0043*  ; DIVBY0:			EQU     18              ;Division by zero
042EA1             0044*  ; TOOBIG_FP:			EQU     20              ;Too big
042EA1             0045*  ; NGROOT:			EQU     21              ;Negative root
042EA1             0046*  ; LOGRNG:			EQU     22              ;Log range
042EA1             0047*  ; ACLOST:			EQU     23              ;Accuracy lost
042EA1             0048*  ; EXPRNG:			EQU     24              ;Exp range
042EA1             0049*  ;
042EA1             0050*  ;Call entry and despatch code:
042EA1             0051*  ;
042EA1 FD E5       0052*  FPP:			PUSH    IY              ;Save IY
042EA3 FD 21 00 00 0053*          		LD      IY,0
       00          
042EA8 FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
042EAA CD BA 2E 04 0055*          		CALL    OP              ;Perform operation
042EAE BF          0056*          		CP      A               ;Good return (Z, NC)
042EAF FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
042EB1 C9          0058*          		RET                     ;Return to caller
042EB2             0059*  ;
042EB2             0060*  ;Error exit:
042EB2             0061*  ;
042EB2 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
042EB4 FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
042EB6 B7          0064*          		OR      A               ;Set NZ
042EB7 37          0065*          		SCF                     ;Set C
042EB8 18 F5       0066*          		JR      EXIT_FP_
042EBA             0067*  ;
042EBA             0068*  ;Perform operation or function:
042EBA             0069*  ;
042EBA             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
042EBA FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
042EBC             0072*  
042EBC 30 F4       0073*          		JR      NC,BAD_FP
042EBE             0074*          		; CP      (FTABLE-DTABLE)/3
042EBE FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
042EC0 30 08       0076*          		JR      NC,DISPAT_FP
042EC2 08          0077*          		EX      AF,AF'
042EC3 78          0078*          		LD      A,B
042EC4 B1          0079*          		OR      C               ;Both integer?
042EC5 C4 CD 39 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
042EC9 08          0081*          		EX      AF,AF'
042ECA E5          0082*  DISPAT_FP:			PUSH    HL
042ECB 21 DD 2E 04 0083*          		LD      HL,DTABLE
042ECF C5          0084*          		PUSH    BC
042ED0 01 03 00 00 0085*  			LD	BC, 3		; C = 3
042ED4 47          0086*  			LD	B, A 		; B = op-code
042ED5 ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
042ED7 09          0088*  			ADD	HL, BC 		;Add to table base
042ED8 ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
042EDA             0090*  
042EDA             0091*  ;        		ADD     A, A            ;A = op-code * 2
042EDA             0092*  ;        		LD      C,A
042EDA             0093*  ;        		LD      B,0             ;BC = op-code * 2
042EDA             0094*  ;        		ADD     HL,BC
042EDA             0095*  ;        		LD      A,(HL)          ;Get low byte
042EDA             0096*  ;        		INC     HL
042EDA             0097*  ;        		LD      H,(HL)          ;Get high byte
042EDA             0098*  ;        		LD      L,A
042EDA             0099*  
042EDA C1          0100*          		POP     BC
042EDB E3          0101*          		EX      (SP),HL
042EDC C9          0102*          		RET                     ;Off to routine
042EDD             0103*  ;
042EDD             0104*  ;Despatch table:
042EDD             0105*  ;
042EDD 8F 2F 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
042EE0 FD 2F 04    0107*          		DW24  IBDIV           ;DIV
042EE3 A2 2F 04    0108*          		DW24  IEOR            ;EOR
042EE6 C8 2F 04    0109*          		DW24  IMOD            ;MOD
042EE9 B5 2F 04    0110*          		DW24  IOR             ;OR
042EEC 83 32 04    0111*          		DW24  ILE             ;<=
042EEF 92 32 04    0112*          		DW24  INE             ;<>
042EF2 76 32 04    0113*          		DW24  IGE             ;>=
042EF5 5B 32 04    0114*          		DW24  ILT             ;<
042EF8 9F 32 04    0115*          		DW24  IEQ             ;=
042EFB EB 30 04    0116*          		DW24  IMUL            ;*
042EFE 26 30 04    0117*          		DW24  IADD            ;+
042F01 68 32 04    0118*          		DW24  IGT             ;>
042F04 0D 30 04    0119*          		DW24  ISUB            ;-
042F07 A2 31 04    0120*          		DW24  IPOW            ;^
042F0A 98 30 04    0121*          		DW24  IDIV            ;/
042F0D             0122*  ;
042F0D             0123*  FTABLE:
042F0D B1 32 04    0124*  				DW24  ABSV_FP            ;ABS
042F10 97 36 04    0125*          		DW24  ACS_FP             ;ACS
042F13 D5 35 04    0126*          		DW24  ASN_FP             ;ASN
042F16 05 36 04    0127*          		DW24  ATN_FP             ;ATN
042F19 D0 33 04    0128*          		DW24  COS_FP             ;COS
042F1C DF 32 04    0129*          		DW24  DEG_FP             ;DEG
042F1F 8C 34 04    0130*          		DW24  EXP_FP             ;EXP
042F22 33 33 04    0131*          		DW24  INT_FP_            ;INT
042F25 2A 35 04    0132*          		DW24  LN_FP              ;LN
042F28 BF 35 04    0133*          		DW24  LOG_FP             ;LOG
042F2B BD 32 04    0134*          		DW24  NOTK_FP            ;NOT
042F2E E9 32 04    0135*          		DW24  RAD_FP             ;RAD
042F31 04 33 04    0136*          		DW24  SGN_FP             ;SGN
042F34 DD 33 04    0137*          		DW24  SIN_FP             ;SIN
042F37 4C 33 04    0138*          		DW24  SQR_FP             ;SQR
042F3A AA 33 04    0139*          		DW24  TAN_FP             ;TAN
042F3D             0140*  ;
042F3D 5A 3A 04    0141*  		        DW24  ZERO_FP            ;ZERO
042F40 65 34 04    0142*          		DW24  FONE_FP            ;FONE
042F43 A4 32 04    0143*          		DW24  TRUE_FP            ;TRUE
042F46 D1 32 04    0144*          		DW24  PI_FP              ;PI
042F49             0145*  ;
042F49 18 33 04    0146*  		        DW24  VAL_FP             ;VAL
042F4C A0 36 04    0147*          		DW24  STR_FP             ;STR$
042F4F             0148*  ;
042F4F 01 39 04    0149*          		DW24  SFIX_FP            ;FIX
042F52 DD 39 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
042F55             0151*  ;
042F55 2B 3A 04    0152*  		        DW24  FTEST_FP           ;TEST
042F58 3D 3A 04    0153*          		DW24  FCOMP_FP           ;COMPARE
042F5B             0154*  ;
042F5B 8B 2F 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
042F5E F9 2F 04    0156*          		DW24  FBDIV           ;DIV
042F61 9E 2F 04    0157*          		DW24  FEOR            ;EOR
042F64 C4 2F 04    0158*          		DW24  FMOD            ;MOD
042F67 B1 2F 04    0159*          		DW24  FFOR             ;OR
042F6A 7D 32 04    0160*          		DW24  FLE             ;<=
042F6D 8C 32 04    0161*          		DW24  FNE             ;<>
042F70 70 32 04    0162*          		DW24  FGE             ;>=
042F73 55 32 04    0163*          		DW24  FLT             ;<
042F76 99 32 04    0164*          		DW24  FEQ             ;=
042F79 45 31 04    0165*          		DW24  FMUL            ;*
042F7C 33 30 04    0166*          		DW24  FADD            ;+
042F7F 62 32 04    0167*          		DW24  FGT             ;>
042F82 1A 30 04    0168*          		DW24  FSUB            ;-
042F85 22 32 04    0169*          		DW24  FPOW            ;^
042F88 9C 30 04    0170*          		DW24  FDIV            ;/
042F8B             0171*  ;
042F8B             0172*  ;       PAGE
042F8B             0173*  ;
042F8B             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
042F8B             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
042F8B             0176*  ;Output in HLH'L'C
042F8B             0177*  ;All registers except IX, IY destroyed.
042F8B             0178*  ; (N.B. FPOW destroys IX).
042F8B             0179*  ;
042F8B             0180*  ;FAND - Floating-point AND.
042F8B             0181*  ;IAND - Integer AND.
042F8B             0182*  ;
042F8B CD F5 38 04 0183*  FAND:			CALL    FIX2
042F8F 7C          0184*  IAND:			LD      A,H
042F90 A2          0185*          		AND     D
042F91 67          0186*          		LD      H,A
042F92 7D          0187*          		LD      A,L
042F93 A3          0188*          		AND     E
042F94 6F          0189*          		LD      L,A
042F95 D9          0190*          		EXX
042F96 7C          0191*          		LD      A,H
042F97 A2          0192*          		AND     D
042F98 67          0193*          		LD      H,A
042F99 7D          0194*          		LD      A,L
042F9A A3          0195*          		AND     E
042F9B 6F          0196*          		LD      L,A
042F9C D9          0197*          		EXX
042F9D C9          0198*          		RET
042F9E             0199*  ;
042F9E             0200*  ;FEOR - Floating-point exclusive-OR.
042F9E             0201*  ;IEOR - Integer exclusive-OR.
042F9E             0202*  ;
042F9E CD F5 38 04 0203*  FEOR:			CALL    FIX2
042FA2 7C          0204*  IEOR:			LD      A,H
042FA3 AA          0205*          		XOR     D
042FA4 67          0206*          		LD      H,A
042FA5 7D          0207*          		LD      A,L
042FA6 AB          0208*          		XOR     E
042FA7 6F          0209*          		LD      L,A
042FA8 D9          0210*          		EXX
042FA9 7C          0211*          		LD      A,H
042FAA AA          0212*          		XOR     D
042FAB 67          0213*          		LD      H,A
042FAC 7D          0214*          		LD      A,L
042FAD AB          0215*          		XOR     E
042FAE 6F          0216*          		LD      L,A
042FAF D9          0217*          		EXX
042FB0 C9          0218*          		RET
042FB1             0219*  ;
042FB1             0220*  ;FFOR - Floating-point OR.
042FB1             0221*  ;IOR - Integer OR.
042FB1             0222*  ;
042FB1 CD F5 38 04 0223*  FFOR:			CALL    FIX2
042FB5 7C          0224*  IOR:			LD      A,H
042FB6 B2          0225*          		OR      D
042FB7 67          0226*          		LD      H,A
042FB8 7D          0227*          		LD      A,L
042FB9 B3          0228*          		OR      E
042FBA 6F          0229*          		LD      L,A
042FBB D9          0230*          		EXX
042FBC 7C          0231*          		LD      A,H
042FBD B2          0232*          		OR      D
042FBE 67          0233*          		LD      H,A
042FBF 7D          0234*          		LD      A,L
042FC0 B3          0235*          		OR      E
042FC1 6F          0236*          		LD      L,A
042FC2 D9          0237*          		EXX
042FC3 C9          0238*          		RET
042FC4             0239*  ;
042FC4             0240*  ;FMOD - Floating-point remainder.
042FC4             0241*  ;IMOD - Integer remainder.
042FC4             0242*  ;
042FC4 CD F5 38 04 0243*  FMOD:			CALL    FIX2
042FC8 7C          0244*  IMOD:			LD      A,H
042FC9 AA          0245*          		XOR     D               ;DIV RESULT SIGN
042FCA CB 7C       0246*          		BIT     7,H
042FCC 08          0247*          		EX      AF,AF'
042FCD CB 7C       0248*          		BIT     7,H
042FCF C4 11 39 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
042FD3 CD 0E 3A 04 0250*          		CALL    SWAP_FP
042FD7 CB 7C       0251*          		BIT     7,H
042FD9 C4 11 39 04 0252*          		CALL    NZ,NEGATE
042FDD 44          0253*          		LD      B,H
042FDE 4D          0254*          		LD      C,L
042FDF 21 00 00 00 0255*          		LD      HL,0
042FE3 D9          0256*          		EXX
042FE4 44          0257*          		LD      B,H
042FE5 4D          0258*          		LD      C,L
042FE6 21 00 00 00 0259*          		LD      HL,0
042FEA 3E DF       0260*          		LD      A,-33
042FEC CD 9B 3B 04 0261*          		CALL    DIVA            ;DIVIDE
042FF0 D9          0262*          		EXX
042FF1 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
042FF3 08          0264*          		EX      AF,AF'
042FF4 C8          0265*          		RET     Z
042FF5 C3 11 39 04 0266*          		JP      NEGATE
042FF9             0267*  ;
042FF9             0268*  ;BDIV - Integer division.
042FF9             0269*  ;
042FF9 CD F5 38 04 0270*  FBDIV:			CALL    FIX2
042FFD CD C8 2F 04 0271*  IBDIV:			CALL    IMOD
043001 B7          0272*          		OR      A
043002 CD 0E 3A 04 0273*          		CALL    SWAP_FP
043006 0E 00       0274*          		LD      C,0
043008 F0          0275*          		RET     P
043009 C3 11 39 04 0276*          		JP      NEGATE
04300D             0277*  ;
04300D             0278*  ;ISUB - Integer subtraction.
04300D             0279*  ;FSUB - Floating point subtraction with rounding.
04300D             0280*  ;
04300D CD A9 3A 04 0281*  ISUB:			CALL    SUB_
043011 E0          0282*          		RET     PO
043012 CD A1 3A 04 0283*          		CALL    ADD_
043016 CD D1 39 04 0284*          		CALL    FLOAT2
04301A 7A          0285*  FSUB:			LD      A,D
04301B EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
04301D 57          0287*          		LD      D,A
04301E 18 13       0288*          		JR      FADD
043020             0289*  ;
043020             0290*  ;Reverse subtract.
043020             0291*  ;
043020 7C          0292*  RSUB:			LD      A,H
043021 EE 80       0293*          		XOR     80H
043023 67          0294*          		LD      H,A
043024 18 0D       0295*          		JR      FADD
043026             0296*  ;
043026             0297*  ;IADD - Integer addition.
043026             0298*  ;FADD - Floating point addition with rounding.
043026             0299*  ;
043026 CD A1 3A 04 0300*  IADD:			CALL    ADD_
04302A E0          0301*          		RET     PO
04302B CD A9 3A 04 0302*          		CALL    SUB_
04302F CD D1 39 04 0303*          		CALL    FLOAT2
043033 05          0304*  FADD:			DEC     B
043034 04          0305*          		INC     B
043035 C8          0306*          		RET     Z               ;ARG 2 ZERO
043036 0D          0307*          		DEC     C
043037 0C          0308*          		INC     C
043038 CA 0E 3A 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
04303C D9          0310*          		EXX
04303D 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
043041 D9          0312*          		EXX
043042 7C          0313*          		LD      A,H
043043 AA          0314*          		XOR     D               ;XOR SIGNS
043044 F5          0315*          		PUSH    AF
043045 78          0316*          		LD      A,B
043046 B9          0317*          		CP      C               ;COMPARE EXPONENTS
043047 DC 0E 3A 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
04304B 78          0319*          		LD      A,B
04304C CB FC       0320*          		SET     7,H             ;IMPLIED 1
04304E C4 E2 38 04 0321*          		CALL    NZ,FIX          ;ALIGN
043052 F1          0322*          		POP     AF
043053 7A          0323*          		LD      A,D             ;SIGN OF LARGER
043054 CB FA       0324*          		SET     7,D             ;IMPLIED 1
043056 FA 66 30 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
04305A CD A1 3A 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04305E DC 16 3A 04 0327*          		CALL    C,DIV2          ;NORMALISE
043062 CB FC       0328*          		SET     7,H
043064 18 0D       0329*          		JR      FADD4
043066             0330*  ;
043066 CD A9 3A 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
04306A DC 29 39 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04306E CD A8 39 04 0333*          		CALL    FLO48
043072 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
043073 D9          0335*  FADD4:			EXX
043074 EB          0336*          		EX      DE,HL
043075 21 00 80 00 0337*          		LD      HL,8000H
043079 B7          0338*          		OR      A               ;CLEAR CARRY
04307A 52 ED 42    0339*          		SBC.S   HL,BC
04307D EB          0340*          		EX      DE,HL
04307E D9          0341*          		EXX
04307F CC 08 3A 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
043083 DC F6 39 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
043087 DC 23 3A 04 0344*          		CALL    C,INCC
04308B CB BC       0345*          		RES     7,H
04308D 0D          0346*          		DEC     C
04308E 0C          0347*          		INC     C
04308F CA 5A 3A 04 0348*          		JP      Z,ZERO_FP
043093 B7          0349*          		OR      A               ;RESULT SIGNQ
043094 F0          0350*          		RET     P               ;POSITIVE
043095 CB FC       0351*          		SET     7,H             ;NEGATIVE
043097 C9          0352*          		RET
043098             0353*  ;
043098             0354*  ;IDIV - Integer division.
043098             0355*  ;FDIV - Floating point division with rounding.
043098             0356*  ;
043098 CD D1 39 04 0357*  IDIV:			CALL    FLOAT2
04309C 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
04309D 04          0359*          		INC     B
04309E 3E 12       0360*          		LD      A,DIVBY0
0430A0 CA B4 2E 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
0430A4 0D          0362*          		DEC     C               ;TEST FOR ZERO
0430A5 0C          0363*          		INC     C
0430A6 C8          0364*          		RET     Z
0430A7 7C          0365*          		LD      A,H
0430A8 AA          0366*          		XOR     D               ;CALC. RESULT SIGN
0430A9 08          0367*          		EX      AF,AF'          ;SAVE SIGN
0430AA CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
0430AC CB FC       0369*          		SET     7,H
0430AE C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
0430AF 42          0371*          		LD      B,D             ;LOAD REGISTERS
0430B0 4B          0372*          		LD      C,E
0430B1 11 00 00 00 0373*          		LD      DE,0
0430B5 D9          0374*          		EXX
0430B6 42          0375*          		LD      B,D
0430B7 4B          0376*          		LD      C,E
0430B8 11 00 00 00 0377*          		LD      DE,0
0430BC 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
0430BE CD 9B 3B 04 0379*          		CALL    DIVA            ;DIVIDE
0430C2 D9          0380*          		EXX
0430C3 CB 7A       0381*          		BIT     7,D
0430C5 D9          0382*          		EXX
0430C6 CC BA 3B 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
0430CA EB          0384*          		EX      DE,HL
0430CB D9          0385*          		EXX
0430CC CB 38       0386*          		SRL     B               ;DIVISOR/2
0430CE CB 19       0387*          		RR      C
0430D0 B7          0388*          		OR      A               ;CLEAR CARRY
0430D1 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0430D4 3F          0390*          		CCF
0430D5 EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
0430D6 CC 08 3A 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
0430DA DC F6 39 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
0430DE C1          0394*          		POP     BC              ;RESTORE EXPONENTS
0430DF DC 23 3A 04 0395*          		CALL    C,INCC
0430E3 1F          0396*          		RRA                     ;LSB OF A TO CARRY
0430E4 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
0430E5 98          0398*          		SBC     A,B
0430E6 3F          0399*          		CCF
0430E7 C3 88 31 04 0400*          		JP      CHKOVF
0430EB             0401*  ;
0430EB             0402*  ;IMUL - Integer multiplication.
0430EB             0403*  ;
0430EB 7C          0404*  IMUL:			LD      A,H
0430EC AA          0405*          		XOR     D
0430ED 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
0430EE CB 7C       0407*          		BIT     7,H
0430F0 C4 11 39 04 0408*          		CALL    NZ,NEGATE
0430F4 CD 0E 3A 04 0409*          		CALL    SWAP_FP
0430F8 CB 7C       0410*          		BIT     7,H
0430FA C4 11 39 04 0411*          		CALL    NZ,NEGATE
0430FE 44          0412*          		LD      B,H
0430FF 4D          0413*          		LD      C,L
043100 21 00 00 00 0414*          		LD      HL,0
043104 D9          0415*          		EXX
043105 44          0416*          		LD      B,H
043106 4D          0417*          		LD      C,L
043107 21 00 00 00 0418*          		LD      HL,0
04310B 3E DF       0419*          		LD      A,-33
04310D CD D2 3B 04 0420*          		CALL    MULA            ;MULTIPLY
043111 D9          0421*          		EXX
043112 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
043114 CD 36 3A 04 0423*          		CALL    TEST_FP            ;TEST RANGE
043118 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
04311A CB 7A       0425*          		BIT     7,D
04311C 20 0B       0426*          		JR      NZ,IMUL1
04311E CD 0E 3A 04 0427*          		CALL    SWAP_FP
043122 4A          0428*          		LD      C,D             ;INTEGER MARKER
043123 08          0429*          		EX      AF,AF'
043124 F0          0430*          		RET     P
043125 C3 11 39 04 0431*          		JP      NEGATE
043129             0432*  ;
043129 0D          0433*  IMUL1:			DEC     C
04312A D9          0434*          		EXX
04312B CB 23       0435*          		SLA     E
04312D CB 12       0436*          		RL      D
04312F D9          0437*          		EXX
043130 CB 13       0438*          		RL      E
043132 CB 12       0439*          		RL      D
043134 D9          0440*          		EXX
043135 52 ED 6A    0441*          		ADC.S   HL,HL
043138 D9          0442*          		EXX
043139 52 ED 6A    0443*          		ADC.S   HL,HL
04313C F2 29 31 04 0444*          		JP      P,IMUL1         ;NORMALISE
043140 08          0445*          		EX      AF,AF'
043141 F8          0446*          		RET     M
043142 CB BC       0447*          		RES     7,H             ;POSITIVE
043144 C9          0448*          		RET
043145             0449*  ;
043145             0450*  ;FMUL - Floating point multiplication with rounding.
043145             0451*  ;
043145 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
043146 04          0453*          		INC     B
043147 CA 5A 3A 04 0454*          		JP      Z,ZERO_FP
04314B 0D          0455*          		DEC     C               ;TEST FOR ZERO
04314C 0C          0456*          		INC     C
04314D C8          0457*          		RET     Z
04314E 7C          0458*          		LD      A,H
04314F AA          0459*          		XOR     D               ;CALC. RESULT SIGN
043150 08          0460*          		EX      AF,AF'
043151 CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
043153 CB FC       0462*          		SET     7,H
043155 C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
043156 44          0464*          		LD      B,H             ;LOAD REGISTERS
043157 4D          0465*          		LD      C,L
043158 21 00 00 00 0466*          		LD      HL,0
04315C D9          0467*          		EXX
04315D 44          0468*          		LD      B,H
04315E 4D          0469*          		LD      C,L
04315F 21 00 00 00 0470*          		LD      HL,0
043163 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
043165 CD D2 3B 04 0472*          		CALL    MULA            ;MULTIPLY
043169 DC E8 3B 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
04316D D9          0474*          		EXX
04316E E5          0475*          		PUSH    HL
04316F 21 00 80 00 0476*          		LD      HL,8000H
043173 B7          0477*          		OR      A               ;CLEAR CARRY
043174 52 ED 52    0478*          		SBC.S   HL,DE
043177 E1          0479*          		POP     HL
043178 CC 08 3A 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
04317C DC F6 39 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
043180 C1          0482*          		POP     BC              ;RESTORE EXPONENTS
043181 DC 23 3A 04 0483*          		CALL    C,INCC
043185 1F          0484*          		RRA                     ;LSB OF A TO CARRY
043186 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
043187 88          0486*          		ADC     A,B
043188 38 06       0487*  CHKOVF:			JR      C,CHKO1
04318A F2 5A 3A 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
04318E 18 04       0489*          		JR      CHKO2
043190 FA 25 3A 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
043194 C6 80       0491*  CHKO2:			ADD     A,80H
043196 4F          0492*          		LD      C,A
043197 CA 5A 3A 04 0493*          		JP      Z,ZERO_FP
04319B 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
04319C CB BC       0495*          		RES     7,H
04319E F0          0496*          		RET     P
04319F CB FC       0497*          		SET     7,H
0431A1 C9          0498*          		RET
0431A2             0499*  ;
0431A2             0500*  ;IPOW - Integer involution.
0431A2             0501*  ;
0431A2 CD 0E 3A 04 0502*  IPOW:			CALL    SWAP_FP
0431A6 CB 7C       0503*          		BIT     7,H
0431A8 F5          0504*          		PUSH    AF              ;SAVE SIGN
0431A9 C4 11 39 04 0505*          		CALL    NZ,NEGATE
0431AD 48          0506*  IPOW0:			LD      C,B
0431AE 06 20       0507*          		LD      B,32            ;LOOP COUNTER
0431B0 CD C6 3A 04 0508*  IPOW1:			CALL    X2
0431B4 38 08       0509*          		JR      C,IPOW2
0431B6 10 F8       0510*          		DJNZ    IPOW1
0431B8 F1          0511*          		POP     AF
0431B9 D9          0512*          		EXX
0431BA 2C          0513*          		INC     L               ;RESULT=1
0431BB D9          0514*          		EXX
0431BC 4C          0515*          		LD      C,H
0431BD C9          0516*          		RET
0431BE             0517*  ;
0431BE F1          0518*  IPOW2:			POP     AF
0431BF C5          0519*          		PUSH    BC
0431C0 EB          0520*          		EX      DE,HL
0431C1 E5          0521*          		PUSH    HL
0431C2 D9          0522*          		EXX
0431C3 EB          0523*          		EX      DE,HL
0431C4 E5          0524*          		PUSH    HL
0431C5 D9          0525*          		EXX
0431C6 DD 21 00 00 0526*          		LD      IX,0
       00          
0431CB DD 39       0527*          		ADD     IX,SP
0431CD 28 48       0528*          		JR      Z,IPOW4
0431CF C5          0529*          		PUSH    BC
0431D0 D9          0530*          		EXX
0431D1 D5          0531*          		PUSH    DE
0431D2 D9          0532*          		EXX
0431D3 D5          0533*          		PUSH    DE
0431D4 CD DD 39 04 0534*          		CALL    SFLOAT_FP
0431D8 CD 11 35 04 0535*          		CALL    RECIP
0431DC DD 71 04    0536*          		LD      (IX+4),C
0431DF D9          0537*          		EXX
0431E0 DD 75 00    0538*          		LD      (IX+0),L
0431E3 DD 74 01    0539*          		LD      (IX+1),H
0431E6 D9          0540*          		EXX
0431E7 DD 75 02    0541*          		LD      (IX+2),L
0431EA DD 74 03    0542*          		LD      (IX+3),H
0431ED 18 21       0543*          		JR      IPOW5
0431EF             0544*  ;
0431EF C5          0545*  IPOW3:			PUSH    BC
0431F0 D9          0546*          		EXX
0431F1 CB 23       0547*          		SLA     E
0431F3 CB 12       0548*          		RL      D
0431F5 D5          0549*          		PUSH    DE
0431F6 D9          0550*          		EXX
0431F7 CB 13       0551*          		RL      E
0431F9 CB 12       0552*          		RL      D
0431FB D5          0553*          		PUSH    DE
0431FC 3E 0A       0554*          		LD      A,'*' & 0FH
0431FE F5          0555*          		PUSH    AF
0431FF CD DA 3A 04 0556*          		CALL    COPY_
043203 CD BA 2E 04 0557*          		CALL    OP              ;SQUARE
043207 F1          0558*          		POP     AF
043208 CD 06 38 04 0559*          		CALL    DLOAD5
04320C DC BA 2E 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
043210 D1          0561*  IPOW5:			POP     DE
043211 D9          0562*          		EXX
043212 D1          0563*          		POP     DE
043213 D9          0564*          		EXX
043214 79          0565*          		LD      A,C
043215 C1          0566*          		POP     BC
043216 4F          0567*          		LD      C,A
043217 10 D6       0568*  IPOW4:			DJNZ    IPOW3
043219 F1          0569*          		POP     AF
04321A F1          0570*          		POP     AF
04321B F1          0571*          		POP     AF
04321C C9          0572*          		RET
04321D             0573*  ;
04321D F1          0574*  FPOW0:			POP     AF
04321E F1          0575*          		POP     AF
04321F F1          0576*          		POP     AF
043220 18 8B       0577*          		JR      IPOW0
043222             0578*  ;
043222             0579*  ;FPOW - Floating-point involution.
043222             0580*  ;
043222 CB 7A       0581*  FPOW:			BIT     7,D
043224 F5          0582*          		PUSH    AF
043225 CD 0E 3A 04 0583*          		CALL    SWAP_FP
043229 CD EA 3A 04 0584*          		CALL    PUSH5
04322D 0D          0585*          		DEC     C
04322E 0C          0586*          		INC     C
04322F 28 EC       0587*          		JR      Z,FPOW0
043231 3E 9E       0588*          		LD      A,158
043233 B9          0589*          		CP      C
043234 38 0A       0590*          		JR      C,FPOW1
043236 3C          0591*          		INC     A
043237 CD E2 38 04 0592*          		CALL    FIX
04323B 08          0593*          		EX      AF,AF'
04323C F2 1D 32 04 0594*          		JP      P,FPOW0
043240 CD 0E 3A 04 0595*  FPOW1:			CALL    SWAP_FP
043244 CD 2E 35 04 0596*          		CALL    LN0
043248 CD F3 3A 04 0597*          		CALL    POP5
04324C F1          0598*          		POP     AF
04324D CD 45 31 04 0599*          		CALL    FMUL
043251 C3 90 34 04 0600*          		JP      EXP0
043255             0601*  ;
043255             0602*  ;Integer and floating-point compare.
043255             0603*  ;Result is TRUE (-1) or FALSE (0).
043255             0604*  ;
043255 CD 64 3A 04 0605*  FLT:			CALL    FCP
043259 18 04       0606*          		JR      ILT1
04325B CD 56 3A 04 0607*  ILT:			CALL    ICP
04325F D0          0608*  ILT1:			RET     NC
043260 18 42       0609*          		JR      TRUE_FP
043262             0610*  ;
043262 CD 64 3A 04 0611*  FGT:			CALL    FCP
043266 18 04       0612*          		JR      IGT1
043268 CD 56 3A 04 0613*  IGT:			CALL    ICP
04326C C8          0614*  IGT1:			RET     Z
04326D D8          0615*          		RET     C
04326E 18 34       0616*          		JR      TRUE_FP
043270             0617*  ;
043270 CD 64 3A 04 0618*  FGE:			CALL    FCP
043274 18 04       0619*          		JR      IGE1
043276 CD 56 3A 04 0620*  IGE:			CALL    ICP
04327A D8          0621*  IGE1:			RET     C
04327B 18 27       0622*          		JR      TRUE_FP
04327D             0623*  ;
04327D CD 64 3A 04 0624*  FLE:			CALL    FCP
043281 18 04       0625*          		JR      ILE1
043283 CD 56 3A 04 0626*  ILE:			CALL    ICP
043287 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
043289 D0          0628*          		RET     NC
04328A 18 18       0629*          		JR      TRUE_FP
04328C             0630*  ;
04328C CD 64 3A 04 0631*  FNE:			CALL    FCP
043290 18 04       0632*          		JR      INE1
043292 CD 56 3A 04 0633*  INE:			CALL    ICP
043296 C8          0634*  INE1:			RET     Z
043297 18 0B       0635*          		JR      TRUE_FP
043299             0636*  ;
043299 CD 64 3A 04 0637*  FEQ:			CALL    FCP
04329D 18 04       0638*          		JR      IEQ1
04329F CD 56 3A 04 0639*  IEQ:			CALL    ICP
0432A3 C0          0640*  IEQ1:			RET     NZ
0432A4 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
0432A8 D9          0642*          		EXX
0432A9 21 FF FF FF 0643*          		LD      HL,-1
0432AD D9          0644*          		EXX
0432AE AF          0645*          		XOR     A
0432AF 4F          0646*          		LD      C,A
0432B0 C9          0647*          		RET
0432B1             0648*  ;
0432B1             0649*  ;FUNCTIONS:
0432B1             0650*  ;
0432B1             0651*  ;Result returned in HLH'L'C (floating point)
0432B1             0652*  ;Result returned in HLH'L' (C=0) (integer)
0432B1             0653*  ;All registers except IY destroyed.
0432B1             0654*  ;
0432B1             0655*  ;ABS - Absolute value
0432B1             0656*  ;Result is numeric, variable type.
0432B1             0657*  ;
0432B1 CB 7C       0658*  ABSV_FP:			BIT     7,H
0432B3 C8          0659*          		RET     Z               ;POSITIVE/ZERO
0432B4 0D          0660*          		DEC     C
0432B5 0C          0661*          		INC     C
0432B6 CA 11 39 04 0662*          		JP      Z,NEGATE        ;INTEGER
0432BA CB BC       0663*          		RES     7,H
0432BC C9          0664*          		RET
0432BD             0665*  ;
0432BD             0666*  ;NOT - Complement integer.
0432BD             0667*  ;Result is integer numeric.
0432BD             0668*  ;
0432BD CD 01 39 04 0669*  NOTK_FP:			CALL    SFIX_FP
0432C1 7C          0670*          		LD      A,H
0432C2 2F          0671*          		CPL
0432C3 67          0672*          		LD      H,A
0432C4 7D          0673*          		LD      A,L
0432C5 2F          0674*          		CPL
0432C6 6F          0675*          		LD      L,A
0432C7 D9          0676*          		EXX
0432C8 7C          0677*          		LD      A,H
0432C9 2F          0678*          		CPL
0432CA 67          0679*          		LD      H,A
0432CB 7D          0680*          		LD      A,L
0432CC 2F          0681*          		CPL
0432CD 6F          0682*          		LD      L,A
0432CE D9          0683*          		EXX
0432CF AF          0684*          		XOR     A               ;NUMERIC MARKER
0432D0 C9          0685*          		RET
0432D1             0686*  ;
0432D1             0687*  ;PI - Return PI (3.141592654)
0432D1             0688*  ;Result is floating-point numeric.
0432D1             0689*  ;
0432D1 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
0432D5 D9          0691*          		EXX
0432D6 21 A2 DA 00 0692*          		LD      HL,0DAA2H
0432DA D9          0693*          		EXX
0432DB 0E 81       0694*          		LD      C,81H
0432DD AF          0695*          		XOR     A               ;NUMERIC MARKER
0432DE C9          0696*          		RET
0432DF             0697*  ;
0432DF             0698*  ;DEG - Convert radians to degrees
0432DF             0699*  ;Result is floating-point numeric.
0432DF             0700*  ;
0432DF CD F3 32 04 0701*  DEG_FP:			CALL    FPI180
0432E3 CD 45 31 04 0702*          		CALL    FMUL
0432E7 AF          0703*          		XOR     A
0432E8 C9          0704*          		RET
0432E9             0705*  ;
0432E9             0706*  ;RAD - Convert degrees to radians
0432E9             0707*  ;Result is floating-point numeric.
0432E9             0708*  ;
0432E9 CD F3 32 04 0709*  RAD_FP:			CALL    FPI180
0432ED CD 9C 30 04 0710*          		CALL    FDIV
0432F1 AF          0711*          		XOR     A
0432F2 C9          0712*          		RET
0432F3             0713*  ;
0432F3             0714*  ;180/PI
0432F3             0715*  ;
0432F3 CD DD 39 04 0716*  FPI180:			CALL    SFLOAT_FP
0432F7 11 2E 65 00 0717*          		LD      DE,652EH
0432FB D9          0718*          		EXX
0432FC 11 D3 E0 00 0719*          		LD      DE,0E0D3H
043300 D9          0720*          		EXX
043301 06 85       0721*          		LD      B,85H
043303 C9          0722*          		RET
043304             0723*  ;
043304             0724*  ;SGN - Return -1, 0 or +1
043304             0725*  ;Result is integer numeric.
043304             0726*  ;
043304 CD 36 3A 04 0727*  SGN_FP:			CALL    TEST_FP
043308 B1          0728*          		OR      C
043309 C8          0729*          		RET     Z               ;ZERO
04330A CB 7C       0730*          		BIT     7,H
04330C C2 A4 32 04 0731*          		JP      NZ,TRUE_FP         ;-1
043310 CD 5A 3A 04 0732*          		CALL    ZERO_FP
043314 C3 F6 39 04 0733*          		JP      ADD1_FP            ;1
043318             0734*  ;
043318             0735*  ;VAL - Return numeric value of string.
043318             0736*  ;Input: ASCII string at IX
043318             0737*  ;Result is variable type numeric.
043318             0738*  ;
043318 CD 74 3C 04 0739*  VAL_FP:			CALL    SIGNQ
04331C F5          0740*          		PUSH    AF
04331D CD 24 38 04 0741*          		CALL    CON_FP
043321 F1          0742*          		POP     AF
043322 FE 2D       0743*          		CP      '-'
043324 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
043326 C0          0745*          		RET     NZ
043327 0D          0746*          		DEC     C
043328 0C          0747*          		INC     C
043329 CA 11 39 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
04332D 7C          0749*          		LD      A,H
04332E EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
043330 67          0751*          		LD      H,A
043331 AF          0752*          		XOR     A
043332 C9          0753*          		RET
043333             0754*  ;
043333             0755*  ;INT - Floor function
043333             0756*  ;Result is integer numeric.
043333             0757*  ;
043333 0D          0758*  INT_FP_:			DEC     C
043334 0C          0759*          		INC     C
043335 C8          0760*          		RET     Z               ;ZERO/INTEGER
043336 3E 9F       0761*          		LD      A,159
043338 44          0762*          		LD      B,H             ;B7=SIGN BIT
043339 CD E2 38 04 0763*          		CALL    FIX
04333D 08          0764*          		EX      AF,AF'
04333E A0          0765*          		AND     B
04333F FC F6 39 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
043343 78          0767*          		LD      A,B
043344 B7          0768*          		OR      A
043345 FC 11 39 04 0769*          		CALL    M,NEGATE
043349 AF          0770*          		XOR     A
04334A 4F          0771*          		LD      C,A
04334B C9          0772*          		RET
04334C             0773*  ;
04334C             0774*  ;SQR - square root
04334C             0775*  ;Result is floating-point numeric.
04334C             0776*  ;
04334C CD DD 39 04 0777*  SQR_FP:			CALL    SFLOAT_FP
043350 CB 7C       0778*  SQR0:			BIT     7,H
043352 3E 15       0779*          		LD      A,NGROOT
043354 C2 B4 2E 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
043358 0D          0781*          		DEC     C
043359 0C          0782*          		INC     C
04335A C8          0783*          		RET     Z               ;ZERO
04335B CB FC       0784*          		SET     7,H             ;IMPLIED 1
04335D CB 41       0785*          		BIT     0,C
04335F CC 16 3A 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
043363 79          0787*          		LD      A,C
043364 D6 80       0788*          		SUB     80H
043366 CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
043368 C6 80       0790*          		ADD     A,80H
04336A 4F          0791*          		LD      C,A
04336B C5          0792*          		PUSH    BC              ;SAVE EXPONENT
04336C EB          0793*          		EX      DE,HL
04336D 21 00 00 00 0794*          		LD      HL,0
043371 44          0795*          		LD      B,H
043372 4D          0796*          		LD      C,L
043373 D9          0797*          		EXX
043374 EB          0798*          		EX      DE,HL
043375 21 00 00 00 0799*          		LD      HL,0
043379 44          0800*          		LD      B,H
04337A 4D          0801*          		LD      C,L
04337B 3E E1       0802*          		LD      A,-31
04337D CD 0C 3C 04 0803*          		CALL    SQRA            ;ROOT
043381 D9          0804*          		EXX
043382 CB 78       0805*          		BIT     7,B
043384 D9          0806*          		EXX
043385 CC 0C 3C 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
043389 CD 4D 3C 04 0808*          		CALL    SQRB
04338D B7          0809*          		OR      A               ;CLEAR CARRY
04338E CD BA 3B 04 0810*          		CALL    DIVB
043392 CB 1B       0811*          		RR      E               ;LSB TO CARRY
043394 60          0812*          		LD      H,B
043395 69          0813*          		LD      L,C
043396 D9          0814*          		EXX
043397 60          0815*          		LD      H,B
043398 69          0816*          		LD      L,C
043399 DC F6 39 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
04339D C1          0818*          		POP     BC              ;RESTORE EXPONENT
04339E DC 23 3A 04 0819*          		CALL    C,INCC
0433A2 1F          0820*          		RRA
0433A3 9F          0821*          		SBC     A,A
0433A4 81          0822*          		ADD     A,C
0433A5 4F          0823*          		LD      C,A
0433A6 CB BC       0824*          		RES     7,H             ;POSITIVE
0433A8 AF          0825*          		XOR     A
0433A9 C9          0826*          		RET
0433AA             0827*  ;
0433AA             0828*  ;TAN - Tangent function
0433AA             0829*  ;Result is floating-point numeric.
0433AA             0830*  ;
0433AA CD DD 39 04 0831*  TAN_FP:			CALL    SFLOAT_FP
0433AE CD EA 3A 04 0832*          		CALL    PUSH5
0433B2 CD D4 33 04 0833*          		CALL    COS0
0433B6 CD F3 3A 04 0834*          		CALL    POP5
0433BA CD EA 3A 04 0835*          		CALL    PUSH5
0433BE CD 0E 3A 04 0836*          		CALL    SWAP_FP
0433C2 CD E1 33 04 0837*          		CALL    SIN0
0433C6 CD F3 3A 04 0838*          		CALL    POP5
0433CA CD 9C 30 04 0839*          		CALL    FDIV
0433CE AF          0840*          		XOR     A               ;NUMERIC MARKER
0433CF C9          0841*          		RET
0433D0             0842*  ;
0433D0             0843*  ;COS - Cosine function
0433D0             0844*  ;Result is floating-point numeric.
0433D0             0845*  ;
0433D0 CD DD 39 04 0846*  COS_FP:			CALL    SFLOAT_FP
0433D4 CD 39 39 04 0847*  COS0:			CALL    SCALE
0433D8 1C          0848*          		INC     E
0433D9 1C          0849*          		INC     E
0433DA 7B          0850*          		LD      A,E
0433DB 18 10       0851*          		JR      SIN1
0433DD             0852*  ;
0433DD             0853*  ;SIN - Sine function
0433DD             0854*  ;Result is floating-point numeric.
0433DD             0855*  ;
0433DD CD DD 39 04 0856*  SIN_FP:			CALL    SFLOAT_FP
0433E1 E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
0433E2 CD 39 39 04 0858*          		CALL    SCALE
0433E6 F1          0859*          		POP     AF
0433E7 07          0860*          		RLCA
0433E8 07          0861*          		RLCA
0433E9 07          0862*          		RLCA
0433EA E6 04       0863*          		AND     4
0433EC AB          0864*          		XOR     E
0433ED F5          0865*  SIN1:			PUSH    AF              ;OCTANT
0433EE CB BC       0866*          		RES     7,H
0433F0 1F          0867*          		RRA
0433F1 CD 7F 34 04 0868*          		CALL    PIBY4
0433F5 DC 20 30 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
0433F9 F1          0870*          		POP     AF
0433FA F5          0871*          		PUSH    AF
0433FB E6 03       0872*          		AND     3
0433FD E2 36 34 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
043401 CD EA 3A 04 0874*          		CALL    PUSH5           ;SAVE X
043405 CD E2 3A 04 0875*          		CALL    SQUARE          ;PUSH X*X
043409 CD 27 3B 04 0876*          		CALL    POLY
04340D B7 A8       0877*          		DW	0A8B7H          ;a(8)
04340F 11 36       0878*          		DW	3611H
043411 6D          0879*          		DB	6DH
043412 26 DE       0880*          		DW	0DE26H          ;a(6)
043414 05 D0       0881*          		DW	0D005H
043416 73          0882*          		DB	73H
043417 C0 80       0883*          		DW	80C0H           ;a(4)
043419 88 08       0884*          		DW	888H
04341B 79          0885*          		DB	79H
04341C 9D AA       0886*          		DW	0AA9DH          ;a(2)
04341E AA AA       0887*          		DW	0AAAAH
043420 7D          0888*          		DB	7DH
043421 00 00       0889*          		DW	0               ;a(0)
043423 00 00       0890*          		DW	0
043425 80          0891*          		DB	80H
043426 CD F3 3A 04 0892*          		CALL    POP5
04342A CD F3 3A 04 0893*          		CALL    POP5
04342E CD 45 31 04 0894*          		CALL    FMUL
043432 C3 5B 34 04 0895*          		JP      SIN3
043436             0896*  ;
043436 CD E2 3A 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
04343A CD 27 3B 04 0898*          		CALL    POLY
04343E 71 D5       0899*          		DW	0D571H          ;b(8)
043440 78 4C       0900*          		DW	4C78H
043442 70          0901*          		DB	70H
043443 AF 94       0902*          		DW	94AFH           ;b(6)
043445 03 B6       0903*          		DW	0B603H
043447 76          0904*          		DB	76H
043448 C8 9C       0905*          		DW	9CC8H           ;b(4)
04344A AA 2A       0906*          		DW	2AAAH
04344C 7B          0907*          		DB	7BH
04344D DD FF       0908*          		DW	0FFDDH          ;b(2)
04344F FF FF       0909*          		DW	0FFFFH
043451 7E          0910*          		DB	7EH
043452 00 00       0911*          		DW	0               ;b(0)
043454 00 00       0912*          		DW	0
043456 80          0913*          		DB	80H
043457 CD F3 3A 04 0914*          		CALL    POP5
04345B F1          0915*  SIN3:			POP     AF
04345C E6 04       0916*          		AND     4
04345E C8          0917*          		RET     Z
04345F 0D          0918*          		DEC     C
043460 0C          0919*          		INC     C
043461 C8          0920*          		RET     Z               ;ZERO
043462 CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
043464 C9          0922*          		RET
043465             0923*  ;
043465             0924*  ;Floating-point one:
043465             0925*  ;
043465 21 00 00 00 0926*  FONE_FP:			LD      HL,0
043469 D9          0927*          		EXX
04346A 21 00 00 00 0928*          		LD      HL,0
04346E D9          0929*          		EXX
04346F 0E 80       0930*          		LD      C,80H
043471 C9          0931*          		RET
043472             0932*  ;
043472 11 00 00 00 0933*  DONE:			LD      DE,0
043476 D9          0934*          		EXX
043477 11 00 00 00 0935*          		LD      DE,0
04347B D9          0936*          		EXX
04347C 06 80       0937*          		LD      B,80H
04347E C9          0938*          		RET
04347F             0939*  ;
04347F 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
043483 D9          0941*          		EXX
043484 11 A2 DA 00 0942*          		LD      DE,0DAA2H
043488 D9          0943*          		EXX
043489 06 7F       0944*          		LD      B,7FH
04348B C9          0945*          		RET
04348C             0946*  ;
04348C             0947*  ;EXP - Exponential function
04348C             0948*  ;Result is floating-point numeric.
04348C             0949*  ;
04348C CD DD 39 04 0950*  EXP_FP:			CALL    SFLOAT_FP
043490 CD 1D 35 04 0951*  EXP0:			CALL    LN2             ;LN(2)
043494 D9          0952*          		EXX
043495 1D          0953*  	        	DEC     E
043496 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
04349A D9          0955*          		EXX
04349B E5          0956*          		PUSH    HL              ;H7=SIGN
04349C CD 4C 39 04 0957*          		CALL    MOD48           ;"MODULUS"
0434A0 F1          0958*          		POP     AF
0434A1 CB 7B       0959*          		BIT     7,E
0434A3 28 0B       0960*          		JR      Z,EXP1
0434A5 17          0961*          		RLA
0434A6 DA 5A 3A 04 0962*          		JP      C,ZERO_FP
0434AA 3E 18       0963*          		LD      A,EXPRNG
0434AC C3 B4 2E 04 0964*          		JP      ERROR_FP_           ;"Exp range"
0434B0             0965*  ;
0434B0 E6 80       0966*  EXP1:			AND     80H
0434B2 B3          0967*          		OR      E
0434B3 F5          0968*          		PUSH    AF              ;INTEGER PART
0434B4 CB BC       0969*          		RES     7,H
0434B6 CD EA 3A 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
0434BA CD 27 3B 04 0971*          		CALL    POLY
0434BE 72 40       0972*          		DW	4072H           ;a(7)
0434C0 2E 94       0973*          		DW	942EH
0434C2 73          0974*          		DB	73H
0434C3 65 6F       0975*          		DW	6F65H           ;a(6)
0434C5 4F 2E       0976*          		DW	2E4FH
0434C7 76          0977*          		DB	76H
0434C8 37 6D       0978*          		DW	6D37H           ;a(5)
0434CA 02 88       0979*          		DW	8802H
0434CC 79          0980*          		DB	79H
0434CD 12 E5       0981*          		DW	0E512H          ;a(4)
0434CF A0 2A       0982*          		DW	2AA0H
0434D1 7B          0983*          		DB	7BH
0434D2 14 4F       0984*          		DW	4F14H           ;a(3)
0434D4 AA AA       0985*          		DW	0AAAAH
0434D6 7D          0986*          		DB	7DH
0434D7 56 FD       0987*          		DW	0FD56H          ;a(2)
0434D9 FF 7F       0988*          		DW	7FFFH
0434DB 7E          0989*          		DB	7EH
0434DC FE FF       0990*          		DW	0FFFEH          ;a(1)
0434DE FF FF       0991*          		DW	0FFFFH
0434E0 7F          0992*          		DB	7FH
0434E1 00 00       0993*          		DW	0               ;a(0)
0434E3 00 00       0994*          		DW	0
0434E5 80          0995*          		DB	80H
0434E6 CD F3 3A 04 0996*          		CALL    POP5
0434EA F1          0997*          		POP     AF
0434EB F5          0998*          		PUSH    AF
0434EC F4 11 35 04 0999*          		CALL    P,RECIP         ;X=1/X
0434F0 F1          1000*          		POP     AF
0434F1 F2 F9 34 04 1001*          		JP      P,EXP4
0434F5 E6 7F       1002*          		AND     7FH
0434F7 ED 44       1003*          		NEG
0434F9 C6 80       1004*  EXP4:			ADD     A,80H
0434FB 81          1005*          		ADD     A,C
0434FC 38 06       1006*          		JR      C,EXP2
0434FE F2 5A 3A 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
043502 18 04       1008*          		JR      EXP3
043504 FA 25 3A 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
043508 C6 80       1010*  EXP3:			ADD     A,80H
04350A CA 5A 3A 04 1011*          		JP      Z,ZERO_FP
04350E 4F          1012*          		LD      C,A
04350F AF          1013*          		XOR     A               ;NUMERIC MARKER
043510 C9          1014*          		RET
043511             1015*  ;
043511 CD 72 34 04 1016*  RECIP:			CALL    DONE
043515 CD 0E 3A 04 1017*  RDIV:			CALL    SWAP_FP
043519 C3 9C 30 04 1018*          		JP      FDIV            ;RECIPROCAL
04351D             1019*  ;
04351D 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
043521 D9          1021*          		EXX
043522 11 F8 17 00 1022*          		LD      DE,17F8H
043526 D9          1023*          		EXX
043527 06 7F       1024*          		LD      B,7FH
043529 C9          1025*          		RET
04352A             1026*  ;
04352A             1027*  ;LN - Natural log.
04352A             1028*  ;Result is floating-point numeric.
04352A             1029*  ;
04352A CD DD 39 04 1030*  LN_FP:			CALL    SFLOAT_FP
04352E 3E 16       1031*  LN0:			LD      A,LOGRNG
043530 CB 7C       1032*          		BIT     7,H
043532 C2 B4 2E 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
043536 0C          1034*          		INC     C
043537 0D          1035*          		DEC     C
043538 CA B4 2E 04 1036*          		JP      Z,ERROR_FP_
04353C 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
043540 D9          1038*          		EXX
043541 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
043545 D9          1040*          		EXX
043546 CD 6D 3A 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
04354A 79          1042*          		LD      A,C             ;EXPONENT
04354B 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
04354D 38 02       1044*          		JR      C,LN4
04354F 0D          1045*          		DEC     C
043550 3C          1046*          		INC     A
043551 F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
043552 CD FF 3A 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
043556 CD EA 3A 04 1049*          		CALL    PUSH5
04355A CD E2 3A 04 1050*  		        CALL    SQUARE          ;PUSH X*X
04355E CD 27 3B 04 1051*          		CALL    POLY
043562 48 CC       1052*          		DW	0CC48H          ;a(9)
043564 FB 74       1053*          		DW	74FBH
043566 7D          1054*          		DB	7DH
043567 AF AE       1055*          		DW	0AEAFH          ;a(7)
043569 FF 11       1056*          		DW	11FFH
04356B 7E          1057*          		DB	7EH
04356C 8C D9       1058*          		DW	0D98CH          ;a(5)
04356E CD 4C       1059*          		DW	4CCDH
043570 7E          1060*          		DB	7EH
043571 E3 A9       1061*          		DW	0A9E3H          ;a(3)
043573 AA 2A       1062*          		DW	2AAAH
043575 7F          1063*          		DB	7FH
043576 00 00       1064*          		DW	0               ;a(1)
043578 00 00       1065*          		DW	0
04357A 81          1066*          		DB	81H
04357B CD F3 3A 04 1067*          		CALL    POP5
04357F CD F3 3A 04 1068*          		CALL    POP5
043583 CD 45 31 04 1069*          		CALL    FMUL
043587 F1          1070*          		POP     AF              ;EXPONENT
043588 CD EA 3A 04 1071*          		CALL    PUSH5
04358C 08          1072*          		EX      AF,AF'
04358D CD 5A 3A 04 1073*          		CALL    ZERO_FP
043591 08          1074*          		EX      AF,AF'
043592 D6 80       1075*          		SUB     80H
043594 28 1F       1076*          		JR      Z,LN3
043596 30 02       1077*          		JR      NC,LN1
043598 2F          1078*          		CPL
043599 3C          1079*          		INC     A
04359A 67          1080*  LN1:			LD      H,A
04359B 0E 87       1081*          		LD      C,87H
04359D F5          1082*          		PUSH    AF
04359E CD BD 39 04 1083*          		CALL    FLOAT_
0435A2 CB BC       1084*          		RES     7,H
0435A4 CD 1D 35 04 1085*          		CALL    LN2
0435A8 CD 45 31 04 1086*          		CALL    FMUL
0435AC F1          1087*          		POP     AF
0435AD 30 06       1088*          		JR      NC,LN3
0435AF FA B5 35 04 1089*          		JP      M,LN3
0435B3 CB FC       1090*          		SET     7,H
0435B5 CD F3 3A 04 1091*  LN3:			CALL    POP5
0435B9 CD 33 30 04 1092*          		CALL    FADD
0435BD AF          1093*          		XOR     A
0435BE C9          1094*          		RET
0435BF             1095*  ;
0435BF             1096*  ;LOG - base-10 logarithm.
0435BF             1097*  ;Result is floating-point numeric.
0435BF             1098*  ;
0435BF CD 2A 35 04 1099*  LOG_FP:			CALL    LN_FP
0435C3 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
0435C7 D9          1101*          		EXX
0435C8 11 A9 D8 00 1102*          		LD      DE,0D8A9H
0435CC D9          1103*          		EXX
0435CD 06 7E       1104*          		LD      B,7EH
0435CF CD 45 31 04 1105*          		CALL    FMUL
0435D3 AF          1106*          		XOR     A
0435D4 C9          1107*          		RET
0435D5             1108*  ;
0435D5             1109*  ;ASN - Arc-sine
0435D5             1110*  ;Result is floating-point numeric.
0435D5             1111*  ;
0435D5 CD DD 39 04 1112*  ASN_FP:			CALL    SFLOAT_FP
0435D9 CD EA 3A 04 1113*          		CALL    PUSH5
0435DD CD DA 3A 04 1114*          		CALL    COPY_
0435E1 CD 45 31 04 1115*          		CALL    FMUL
0435E5 CD 72 34 04 1116*          		CALL    DONE
0435E9 CD 20 30 04 1117*          		CALL    RSUB
0435ED CD 50 33 04 1118*          		CALL    SQR0
0435F1 CD F3 3A 04 1119*          		CALL    POP5
0435F5 0C          1120*          		INC     C
0435F6 0D          1121*          		DEC     C
0435F7 3E 02       1122*          		LD      A,2
0435F9 D5          1123*          		PUSH    DE
0435FA CA 7F 36 04 1124*          		JP      Z,ACS1
0435FE D1          1125*          		POP     DE
0435FF CD 15 35 04 1126*          		CALL    RDIV
043603 18 04       1127*          		JR      ATN0
043605             1128*  ;
043605             1129*  ;ATN - arc-tangent
043605             1130*  ;Result is floating-point numeric.
043605             1131*  ;
043605 CD DD 39 04 1132*  ATN_FP:			CALL    SFLOAT_FP
043609 E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
04360A CB BC       1134*          		RES     7,H
04360C 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
043610 D9          1136*          		EXX
043611 11 D0 CC 00 1137*          		LD      DE,0CCD0H
043615 D9          1138*          		EXX
043616 06 7E       1139*          		LD      B,7EH
043618 CD 6A 3A 04 1140*          		CALL    FCP0            ;COMPARE
04361C 06 00       1141*          		LD      B,0
04361E 38 22       1142*          		JR      C,ATN2
043620 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
043624 D9          1144*          		EXX
043625 11 9A 79 00 1145*          		LD      DE,799AH
043629 D9          1146*          		EXX
04362A 06 81       1147*          		LD      B,81H
04362C CD 6A 3A 04 1148*          		CALL    FCP0            ;COMPARE
043630 38 0A       1149*          		JR      C,ATN1
043632 CD 11 35 04 1150*          		CALL    RECIP           ;X=1/X
043636 06 02       1151*          		LD      B,2
043638 C3 42 36 04 1152*          		JP      ATN2
04363C CD FF 3A 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
043640 06 01       1154*          		LD      B,1
043642 C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
043643 CD EA 3A 04 1156*          		CALL    PUSH5
043647 CD E2 3A 04 1157*          		CALL    SQUARE          ;PUSH X*X
04364B CD 27 3B 04 1158*          		CALL    POLY
04364F 35 F3       1159*          		DW	0F335H          ;a(13)
043651 D8 37       1160*          		DW	37D8H
043653 7B          1161*          		DB	7BH
043654 91 6B       1162*          		DW	6B91H           ;a(11)
043656 B9 AA       1163*          		DW	0AAB9H
043658 7C          1164*          		DB	7CH
043659 DE 41       1165*          		DW	41DEH           ;a(9)
04365B 97 61       1166*          		DW	6197H
04365D 7C          1167*          		DB	7CH
04365E 7B 9D       1168*          		DW	9D7BH           ;a(7)
043660 37 92       1169*          		DW	9237H
043662 7D          1170*          		DB	7DH
043663 5A 2A       1171*          		DW	2A5AH           ;a(5)
043665 CC 4C       1172*          		DW	4CCCH
043667 7D          1173*          		DB	7DH
043668 5C A9       1174*          		DW	0A95CH          ;a(3)
04366A AA AA       1175*          		DW	0AAAAH
04366C 7E          1176*          		DB	7EH
04366D 00 00       1177*          		DW	0               ;a(1)
04366F 00 00       1178*          		DW	0
043671 80          1179*          		DB	80H
043672 CD F3 3A 04 1180*          		CALL    POP5
043676 CD F3 3A 04 1181*          		CALL    POP5
04367A CD 45 31 04 1182*          		CALL    FMUL
04367E F1          1183*          		POP     AF
04367F CD 7F 34 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
043683 1F          1185*          		RRA
043684 F5          1186*          		PUSH    AF
043685 DC 33 30 04 1187*          		CALL    C,FADD
043689 F1          1188*          		POP     AF
04368A 04          1189*          		INC     B
04368B 1F          1190*          		RRA
04368C DC 20 30 04 1191*          		CALL    C,RSUB
043690 F1          1192*          		POP     AF
043691 B7          1193*          		OR      A
043692 F0          1194*          		RET     P
043693 CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
043695 AF          1196*          		XOR     A
043696 C9          1197*          		RET
043697             1198*  ;
043697             1199*  ;ACS - Arc cosine=PI/2-ASN.
043697             1200*  ;Result is floating point numeric.
043697             1201*  ;
043697 CD D5 35 04 1202*  ACS_FP:			CALL    ASN_FP
04369B 3E 02       1203*          		LD      A,2
04369D F5          1204*          		PUSH    AF
04369E 18 DF       1205*          		JR      ACS1
0436A0             1206*  ;
0436A0             1207*  ;Function STR - convert numeric value to ASCII string.
0436A0             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
0436A0             1209*  ;           DE = address at which to store string
0436A0             1210*  ;           IX = address of @% format control
0436A0             1211*  ;  Outputs: String stored, with NUL terminator
0436A0             1212*  ;
0436A0             1213*  ;First normalise for decimal output:
0436A0             1214*  ;
0436A0 CD DD 39 04 1215*  STR_FP:			CALL    SFLOAT_FP
0436A4 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
0436A6 CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
0436A8 28 06       1218*          		JR      Z,STR10
0436AA CB BC       1219*          		RES     7,H
0436AC 3E 2D       1220*          		LD      A,'-'
0436AE 12          1221*          		LD      (DE),A          ;STORE SIGN
0436AF 13          1222*          		INC     DE
0436B0 AF          1223*  STR10:			XOR     A               ;CLEAR A
0436B1 B9          1224*          		CP      C
0436B2 28 4E       1225*          		JR      Z,STR02          ;ZERO
0436B4 D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
0436B5 78          1227*          		LD      A,B
0436B6 F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0436B7 79          1229*          		LD      A,C             ;BINARY EXPONENT
0436B8 FE A1       1230*          		CP      161
0436BA 30 1C       1231*          		JR      NC,STR14
0436BC FE 9B       1232*          		CP      155
0436BE 30 29       1233*          		JR      NC,STR15
0436C0 2F          1234*          		CPL
0436C1 FE E1       1235*          		CP      225
0436C3 38 02       1236*          		JR      C,STR13
0436C5 3E F8       1237*          		LD      A,-8
0436C7 C6 1C       1238*  STR13:			ADD     A,28
0436C9 CD 56 3B 04 1239*          		CALL    POWR10
0436CD F5          1240*          		PUSH    AF
0436CE CD 45 31 04 1241*          		CALL    FMUL
0436D2 F1          1242*          		POP     AF
0436D3 47          1243*          		LD      B,A
0436D4 F1          1244*          		POP     AF
0436D5 90          1245*          		SUB     B
0436D6 18 DE       1246*          		JR      STR11
0436D8 D6 20       1247*  STR14:			SUB     32
0436DA CD 56 3B 04 1248*          		CALL    POWR10
0436DE F5          1249*          		PUSH    AF
0436DF CD 9C 30 04 1250*          		CALL    FDIV
0436E3 F1          1251*          		POP     AF
0436E4 47          1252*          		LD      B,A
0436E5 F1          1253*          		POP     AF
0436E6 80          1254*          		ADD     A,B
0436E7 18 CD       1255*          		JR      STR11
0436E9 3E 09       1256*  STR15:			LD      A,9
0436EB CD 56 3B 04 1257*          		CALL    POWR10          ;10^9
0436EF CD 6A 3A 04 1258*          		CALL    FCP0
0436F3 79          1259*          		LD      A,C
0436F4 C1          1260*          		POP     BC
0436F5 4F          1261*          		LD      C,A
0436F6 CB FC       1262*          		SET     7,H             ;IMPLIED 1
0436F8 DC 92 3A 04 1263*          		CALL    C,X10B          ;X10, DEC B
0436FC D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
0436FD CB B9       1265*          		RES     7,C
0436FF 3E 00       1266*          		LD      A,0
043701 17          1267*          		RLA                     ;PUT CARRY IN LSB
043702             1268*  ;
043702             1269*  ;At this point decimal normalisation has been done,
043702             1270*  ;now convert to decimal digits:
043702             1271*  ;      AHLH'L' = number in normalised integer form
043702             1272*  ;            B = decimal place adjustment
043702             1273*  ;            C = binary place adjustment (29-33)
043702             1274*  ;
043702 0C          1275*  STR02:			INC     C
043703 08          1276*          		EX      AF,AF'          ;SAVE A
043704 78          1277*          		LD      A,B
043705 DD CB 02 4E 1278*          		BIT     1,(IX+2)
043709 20 08       1279*          		JR      NZ,STR20
04370B AF          1280*          		XOR     A
04370C DD BE 01    1281*          		CP      (IX+1)
04370F 28 0B       1282*          		JR      Z,STR21
043711 3E F6       1283*          		LD      A,-10
043713 DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
043716 B7          1285*          		OR      A               ;CLEAR CARRY
043717 FA 1C 37 04 1286*          		JP      M,STR21
04371B AF          1287*          		XOR     A
04371C F5          1288*  STR21:			PUSH    AF
04371D 08          1289*          		EX      AF,AF'          ;RESTORE A
04371E CD C6 3A 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
043722 8F          1291*          		ADC     A,A
043723 FE 0A       1292*          		CP      10
043725 38 05       1293*          		JR      C,STR23
043727 D6 0A       1294*          		SUB     10
043729 D9          1295*          		EXX
04372A 2C          1296*          		INC     L               ;SET RESULT BIT
04372B D9          1297*          		EXX
04372C 0D          1298*  STR23:			DEC     C
04372D 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
04372F 4F          1300*          		LD      C,A             ;REMAINDER
043730 7C          1301*          		LD      A,H
043731 E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
043733 67          1303*          		LD      H,A
043734 F1          1304*          		POP     AF
043735 F2 43 37 04 1305*          		JP      P,STR24
043739 3C          1306*          		INC     A
04373A 20 1C       1307*          		JR      NZ,STR26
04373C 3E 04       1308*          		LD      A,4
04373E B9          1309*          		CP      C               ;ROUND UP?
04373F 3E 00       1310*          		LD      A,0
043741 18 15       1311*          		JR      STR26
043743 F5          1312*  STR24:			PUSH    AF
043744 79          1313*          		LD      A,C
043745 CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
043747 FE 30       1315*          		CP      '0'
043749 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
04374B FE 3A       1317*          		CP      '9'+1
04374D 3F          1318*          		CCF
04374E 30 08       1319*          		JR      NC,STR26
043750 E3          1320*  STR25:			EX      (SP),HL
043751 CB 75       1321*          		BIT     6,L             ;ZERO FLAG
043753 E3          1322*  		        EX      (SP),HL
043754 20 05       1323*          		JR      NZ,STR27
043756 3E 30       1324*          		LD      A,'0'
043758 3C          1325*  STR26:			INC     A               ;SET +VE
043759 3D          1326*          		DEC     A
04375A F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
04375B 04          1328*  STR27:			INC     B
04375C CD 36 3A 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
043760 0E 20       1330*          		LD      C,32
043762 3E 00       1331*          		LD      A,0
043764 20 B8       1332*          		JR      NZ,STR22
043766 F1          1333*          		POP     AF
043767 F5          1334*          		PUSH    AF
043768 3E 00       1335*          		LD      A,0
04376A 38 B2       1336*          		JR      C,STR22
04376C             1337*  ;
04376C             1338*  ;At this point, the decimal character string is stored
04376C             1339*  ; on the stack. Trailing zeroes are suppressed and may
04376C             1340*  ; need to be replaced.
04376C             1341*  ;B register holds decimal point position.
04376C             1342*  ;Now format number and store as ASCII string:
04376C             1343*  ;
04376C EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
04376D 0E FF       1345*          		LD      C,-1            ;FLAG "E"
04376F 16 01       1346*          		LD      D,1
043771 DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
043774 DD CB 02 46 1348*          		BIT     0,(IX+2)
043778 20 35       1349*          		JR      NZ,STR34        ;E MODE
04377A DD CB 02 4E 1350*          		BIT     1,(IX+2)
04377E 28 12       1351*          		JR      Z,STR31
043780 78          1352*          		LD      A,B             ;F MODE
043781 B7          1353*          		OR      A
043782 28 05       1354*          		JR      Z,STR30
043784 FA 89 37 04 1355*          		JP      M,STR30
043788 50          1356*          		LD      D,B
043789 7A          1357*  STR30:			LD      A,D
04378A DD 86 01    1358*          		ADD     A,(IX+1)
04378D 5F          1359*          		LD      E,A
04378E FE 0B       1360*          		CP      11
043790 38 19       1361*          		JR      C,STR32
043792 78          1362*  STR31:			LD      A,B             ;G MODE
043793 11 01 01 00 1363*          		LD      DE,101H
043797 B7          1364*          		OR      A
043798 FA AF 37 04 1365*          		JP      M,STR34
04379C 28 0D       1366*          		JR      Z,STR32
04379E DD 7E 01    1367*          		LD      A,(IX+1)
0437A1 B7          1368*          		OR      A
0437A2 20 02       1369*          		JR      NZ,STR3A
0437A4 3E 0A       1370*          		LD      A,10
0437A6 B8          1371*  STR3A:			CP      B
0437A7 38 06       1372*          		JR      C,STR34
0437A9 50          1373*          		LD      D,B
0437AA 58          1374*          		LD      E,B
0437AB 78          1375*  STR32:			LD      A,B
0437AC C6 81       1376*          		ADD     A,129
0437AE 4F          1377*          		LD      C,A
0437AF CB FA       1378*  STR34:			SET     7,D
0437B1 1D          1379*          		DEC     E
0437B2 7A          1380*  STR35:			LD      A,D
0437B3 B9          1381*          		CP      C
0437B4 30 0E       1382*          		JR      NC,STR33
0437B6 F1          1383*  STR36:			POP     AF
0437B7 28 04       1384*          		JR      Z,STR37
0437B9 F2 C6 37 04 1385*          		JP      P,STR38
0437BD F5          1386*  STR37:			PUSH    AF
0437BE 1C          1387*          		INC     E
0437BF 1D          1388*          		DEC     E
0437C0 FA D7 37 04 1389*          		JP      M,STR4
0437C4 3E 30       1390*  STR33:			LD      A,'0'
0437C6 15          1391*  STR38:			DEC     D
0437C7 E2 CE 37 04 1392*          		JP      PO,STR39
0437CB 36 2E       1393*          		LD      (HL),'.'
0437CD 23          1394*          		INC     HL
0437CE 77          1395*  STR39:			LD      (HL),A
0437CF 23          1396*          		INC     HL
0437D0 1D          1397*          		DEC     E
0437D1 F2 B2 37 04 1398*          		JP      P,STR35
0437D5 18 DF       1399*          		JR      STR36
0437D7             1400*  ;
0437D7 F1          1401*  STR4:			POP     AF
0437D8 0C          1402*  STR40:			INC     C
0437D9 4D          1403*          		LD      C,L
0437DA 20 28       1404*          		JR      NZ,STR44
0437DC 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
0437DE 23          1406*          		INC     HL
0437DF 78          1407*          		LD      A,B
0437E0 3D          1408*          		DEC     A
0437E1 F2 EA 37 04 1409*          		JP      P,STR41
0437E5 36 2D       1410*          		LD      (HL),'-'
0437E7 23          1411*          		INC     HL
0437E8 ED 44       1412*          		NEG
0437EA 36 30       1413*  STR41:			LD      (HL),'0'
0437EC 28 15       1414*          		JR      Z,STR47
0437EE FE 0A       1415*          		CP      10
0437F0 47          1416*          		LD      B,A
0437F1 3E 3A       1417*          		LD      A,':'
0437F3 38 03       1418*          		JR      C,STR42
0437F5 23          1419*          		INC     HL
0437F6 36 30       1420*          		LD      (HL),'0'
0437F8 34          1421*  STR42:			INC     (HL)
0437F9 BE          1422*          		CP      (HL)
0437FA 20 05       1423*          		JR      NZ,STR43
0437FC 36 30       1424*          		LD      (HL),'0'
0437FE 2B          1425*          		DEC     HL
0437FF 34          1426*          		INC     (HL)
043800 23          1427*          		INC     HL
043801 10 F5       1428*  STR43:			DJNZ    STR42
043803 23          1429*  STR47:			INC     HL
043804 EB          1430*  STR44:			EX      DE,HL
043805 C9          1431*        			RET
043806             1432*  ;
043806             1433*  ;Support subroutines:
043806             1434*  ;
043806 DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
043809 D9          1436*          		EXX
04380A DD 5E 00    1437*          		LD      E,(IX+0)
04380D DD 56 01    1438*          		LD      D,(IX+1)
043810 D9          1439*          		EXX
043811 DD 5E 02    1440*          		LD      E,(IX+2)
043814 DD 56 03    1441*          		LD      D,(IX+3)
043817 C9          1442*          		RET
043818             1443*  ;
043818 DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
04381B D9          1445*  			EXX
04381C DD 17 00    1446*  			LD	DE, (IX+0)
04381F D9          1447*  			EXX
043820 DD 17 03    1448*  			LD	DE, (IX+3)
043823 C9          1449*  			RET
043824             1450*  ;
043824             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
043824             1452*  ;   Inputs: ASCII string at (IX).
043824             1453*  ;  Outputs: Variable-type result in HLH'L'C
043824             1454*  ;           IX updated (points to delimiter)
043824             1455*  ;           A7 = 0 (numeric marker)
043824             1456*  ;
043824 CD 5A 3A 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
043828 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
04382A CD B8 38 04 1459*          		CALL    UINT          ;GET INTEGER PART
04382E FE 2E       1460*          		CP      '.'
043830 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
043832 CC B6 38 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
043836 FE 45       1463*          		CP      'E'
043838 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
04383A CC 84 38 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
04383E CB 7C       1466*          		BIT     7,H
043840 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
043842 B7          1468*          		OR      A
043843 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
043845 B8          1470*          		CP      B
043846 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
043848 B9          1472*          		CP      C
043849 C8          1473*          		RET     Z               ;INTEGER
04384A 90          1474*  CON0:			SUB     B
04384B 81          1475*          		ADD     A,C
04384C 0E 9F       1476*          		LD      C,159
04384E CD BD 39 04 1477*          		CALL    FLOAT_
043852 CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
043854 B7          1479*          		OR      A
043855 C8          1480*          		RET     Z               ;DONE
043856 FA 64 38 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
04385A CD 56 3B 04 1482*          		CALL    POWR10
04385E CD 45 31 04 1483*          		CALL    FMUL            ;SCALE
043862 AF          1484*          		XOR     A
043863 C9          1485*          		RET
043864 FE DA       1486*  CON2:			CP      -38
043866 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
043868 ED 44       1488*          		NEG
04386A CD 56 3B 04 1489*          		CALL    POWR10
04386E CD 9C 30 04 1490*          		CALL    FDIV            ;SCALE
043872 AF          1491*          		XOR     A
043873 C9          1492*          		RET
043874 F5          1493*  CON3:			PUSH    AF
043875 3E 26       1494*          		LD      A,38
043877 CD 56 3B 04 1495*          		CALL    POWR10
04387B CD 9C 30 04 1496*          		CALL    FDIV
04387F F1          1497*          		POP     AF
043880 C6 26       1498*          		ADD     A,38
043882 18 E0       1499*          		JR      CON2
043884             1500*  ;
043884             1501*  ;GETEXP - Get decimal exponent from string
043884             1502*  ;     Inputs: ASCII string at (IX)
043884             1503*  ;             (IX points at 'E')
043884             1504*  ;             A = initial value
043884             1505*  ;    Outputs: A = new exponent
043884             1506*  ;             IX updated.
043884             1507*  ;   Destroys: A,A',IX,F,F'
043884             1508*  ;
043884 C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
043885 47          1510*          		LD      B,A             ;INITIAL VALUE
043886 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
043888 DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
04388A CD 74 3C 04 1513*          		CALL    SIGNQ
04388E 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
04388F CD 6A 3C 04 1515*  GETEX1:			CALL    DIGITQ
043893 38 18       1516*          		JR      C,GETEX2
043895 78          1517*          		LD      A,B             ;B=B*10
043896 87          1518*          		ADD     A,A
043897 87          1519*          		ADD     A,A
043898 80          1520*          		ADD     A,B
043899 87          1521*          		ADD     A,A
04389A 47          1522*          		LD      B,A
04389B DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
04389E DD 23       1524*          		INC     IX
0438A0 E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
0438A2 80          1526*          		ADD     A,B             ;ADD IN DIGIT
0438A3 47          1527*          		LD      B,A
0438A4 0D          1528*          		DEC     C
0438A5 F2 8F 38 04 1529*          		JP      P,GETEX1
0438A9 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
0438AB 18 E2       1531*          		JR      GETEX1
0438AD 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0438AE FE 2D       1533*          		CP      '-'
0438B0 78          1534*          		LD      A,B
0438B1 C1          1535*          		POP     BC              ;RESTORE
0438B2 C0          1536*          		RET     NZ
0438B3 ED 44       1537*          		NEG                     ;NEGATE EXPONENT
0438B5 C9          1538*          		RET
0438B6             1539*  ;
0438B6             1540*  ;UINT: Get unsigned integer from string.
0438B6             1541*  ;    Inputs: string at (IX)
0438B6             1542*  ;            C = truncated digit count
0438B6             1543*  ;                (initially zero)
0438B6             1544*  ;            B = total digit count
0438B6             1545*  ;            HLH'L' = initial value
0438B6             1546*  ;   Outputs: HLH'L' = number (binary integer)
0438B6             1547*  ;            A = delimiter.
0438B6             1548*  ;            B, C & IX updated
0438B6             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0438B6             1550*  ;
0438B6 DD 23       1551*  NUMBIX:			INC     IX
0438B8 CD 6A 3C 04 1552*  UINT:			CALL    DIGITQ
0438BC D8          1553*          		RET     C
0438BD 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
0438BE DD 23       1555*          		INC     IX
0438C0 CD B3 3A 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
0438C4 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
0438C6 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
0438C7 0C          1559*          		INC     C
0438C8 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
0438CA E6 0F       1561*          		AND     0FH
0438CC D9          1562*          		EXX
0438CD 06 00       1563*          		LD      B,0
0438CF 4F          1564*          		LD      C,A
0438D0 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
0438D2 D9          1566*          		EXX
0438D3 30 E3       1567*          		JR      NC,UINT
0438D5 52 23       1568*          		INC.S   HL              ;CARRY
0438D7 7C          1569*          		LD      A,H
0438D8 B5          1570*          		OR      L
0438D9 20 DD       1571*          		JR      NZ,UINT
0438DB 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
0438DC CD 11 3A 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0438E0 18 D6       1574*          		JR      UINT
0438E2             1575*  ;
0438E2             1576*  ;FIX - Fix number to specified exponent value.
0438E2             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
0438E2             1578*  ;            A = desired exponent (A>C)
0438E2             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
0438E2             1580*  ;            fraction shifted into B'C'
0438E2             1581*  ;            A'F' positive if integer input
0438E2             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
0438E2             1583*  ;
0438E2 08          1584*  FIX:			EX      AF,AF'
0438E3 AF          1585*          		XOR     A
0438E4 08          1586*          		EX      AF,AF'
0438E5 CB FC       1587*          		SET     7,H             ;IMPLIED 1
0438E7 CD 16 3A 04 1588*  FIX1:			CALL    DIV2
0438EB B9          1589*          		CP      C
0438EC C8          1590*          		RET     Z
0438ED D2 E7 38 04 1591*          		JP      NC,FIX1
0438F1 C3 25 3A 04 1592*          		JP      OFLOW
0438F5             1593*  ;
0438F5             1594*  ;SFIX - Convert to integer if necessary.
0438F5             1595*  ;    Input: Variable-type number in HLH'L'C
0438F5             1596*  ;   Output: Integer in HLH'L', C=0
0438F5             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
0438F5             1598*  ;
0438F5             1599*  ;NEGATE - Negate HLH'L'
0438F5             1600*  ;    Destroys: H,L,H',L',F
0438F5             1601*  ;
0438F5 CD 0E 3A 04 1602*  FIX2:			CALL    SWAP_FP
0438F9 CD 01 39 04 1603*          		CALL    SFIX_FP
0438FD CD 0E 3A 04 1604*          		CALL    SWAP_FP
043901 0D          1605*  SFIX_FP:			DEC     C
043902 0C          1606*          		INC     C
043903 C8          1607*          		RET     Z               ;INTEGER/ZERO
043904 CB 7C       1608*          		BIT     7,H             ;SIGN
043906 F5          1609*          		PUSH    AF
043907 3E 9F       1610*          		LD      A,159
043909 CD E2 38 04 1611*          		CALL    FIX
04390D F1          1612*          		POP     AF
04390E 0E 00       1613*          		LD      C,0
043910 C8          1614*          		RET     Z
043911 B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
043912 D9          1616*          		EXX
043913 D5          1617*  NEG0:			PUSH    DE
043914 EB          1618*          		EX      DE,HL
043915 21 00 00 00 1619*          		LD      HL,0
043919 52 ED 52    1620*          		SBC.S   HL,DE
04391C D1          1621*          		POP     DE
04391D D9          1622*          		EXX
04391E D5          1623*          		PUSH    DE
04391F EB          1624*          		EX      DE,HL
043920 21 00 00 00 1625*          		LD      HL,0
043924 52 ED 52    1626*          		SBC.S   HL,DE
043927 D1          1627*          		POP     DE
043928 C9          1628*          		RET
043929             1629*  ;
043929             1630*  ;NEG - Negate HLH'L'B'C'
043929             1631*  ;    Also complements A (used in FADD)
043929             1632*  ;    Destroys: A,H,L,B',C',H',L',F
043929             1633*  ;
043929 D9          1634*  NEG_:			EXX
04392A 2F          1635*          		CPL
04392B E5          1636*          		PUSH    HL
04392C B7          1637*          		OR      A               ;CLEAR CARRY
04392D 21 00 00 00 1638*          		LD      HL,0
043931 52 ED 42    1639*          		SBC.S   HL,BC
043934 44          1640*          		LD      B,H
043935 4D          1641*          		LD      C,L
043936 E1          1642*          		POP     HL
043937 18 DA       1643*          		JR      NEG0
043939             1644*  ;
043939             1645*  ;SCALE - Trig scaling.
043939             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
043939             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
043939             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
043939             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
043939             1650*  ;           E = quotient (bit 7 is sticky)
043939             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
043939             1652*  ;FLO48 - Float unsigned number (48 bits)
043939             1653*  ;    Input/output in HLH'L'B'C'C
043939             1654*  ;   Destroys: C,H,L,B',C',H',L',F
043939             1655*  ;
043939 3E 96       1656*  SCALE:			LD      A,150
04393B B9          1657*          		CP      C
04393C 3E 17       1658*          		LD      A,ACLOST
04393E DA B4 2E 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
043942 CD 7F 34 04 1660*          		CALL    PIBY4
043946 D9          1661*          		EXX
043947 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
04394B D9          1663*          		EXX
04394C CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
04394E CB FC       1665*          		SET     7,H
043950 79          1666*          		LD      A,C
043951 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
043953 DD 21 00 00 1668*          		LD      IX,0
       00          
043958 DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
04395A B8          1670*          		CP      B
04395B 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
04395D D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
04395E E3          1673*          		EX      (SP),HL
04395F 52 ED 42    1674*          		SBC.S   HL,BC
043962 E3          1675*          		EX      (SP),HL
043963 52 ED 52    1676*          		SBC.S   HL,DE
043966 D9          1677*          		EXX
043967 52 ED 52    1678*          		SBC.S   HL,DE
04396A 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
04396C D9          1680*          		EXX
04396D E3          1681*          		EX      (SP),HL
04396E 52 09       1682*          		ADD.S   HL,BC
043970 E3          1683*          		EX      (SP),HL
043971 52 ED 5A    1684*          		ADC.S   HL,DE
043974 D9          1685*          		EXX
043975 52 ED 5A    1686*          		ADC.S   HL,DE
043978 3F          1687*  MOD482:			CCF
043979 CB 11       1688*          		RL      C               ;QUOTIENT
04397B 30 02       1689*          		JR      NC,MOD483
04397D CB F9       1690*          		SET     7,C             ;STICKY BIT
04397F 3D          1691*  MOD483:			DEC     A
043980 B8          1692*          		CP      B
043981 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
043983 E3          1694*          		EX      (SP),HL
043984 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
043986 E3          1696*          		EX      (SP),HL
043987 D9          1697*          		EXX
043988 52 ED 6A    1698*          		ADC.S   HL,HL
04398B D9          1699*          		EXX
04398C 52 ED 6A    1700*          		ADC.S   HL,HL
04398F 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
043991 B7          1702*          		OR      A
043992 D9          1703*          		EXX
043993 E3          1704*          		EX      (SP),HL
043994 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
043997 E3          1706*          		EX      (SP),HL
043998 52 ED 52    1707*          		SBC.S   HL,DE
04399B D9          1708*          		EXX
04399C 52 ED 52    1709*          		SBC.S   HL,DE
04399F B7          1710*          		OR      A
0439A0 18 D6       1711*          		JR      MOD482
0439A2             1712*  ;
0439A2 3C          1713*  MOD484:			INC     A
0439A3 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
0439A4 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
0439A5 D9          1716*          		EXX
0439A6 C1          1717*          		POP     BC
0439A7 D9          1718*          		EXX
0439A8 CB 7C       1719*  FLO48:			BIT     7,H
0439AA C0          1720*          		RET     NZ
0439AB D9          1721*          		EXX
0439AC CB 21       1722*          		SLA     C
0439AE CB 10       1723*          		RL      B
0439B0 52 ED 6A    1724*          		ADC.S   HL,HL
0439B3 D9          1725*          		EXX
0439B4 52 ED 6A    1726*          		ADC.S   HL,HL
0439B7 0D          1727*          		DEC     C
0439B8 C2 A8 39 04 1728*          		JP      NZ,FLO48
0439BC C9          1729*          		RET
0439BD             1730*  ;
0439BD             1731*  ;Float unsigned number
0439BD             1732*  ;    Input/output in HLH'L'C
0439BD             1733*  ;   Destroys: C,H,L,H',L',F
0439BD             1734*  ;
0439BD CB 7C       1735*  FLOAT_:			BIT     7,H
0439BF C0          1736*          		RET     NZ
0439C0 D9          1737*          		EXX                     ;SAME AS "X2"
0439C1 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
0439C3 D9          1739*          		EXX                     ;REGION
0439C4 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
0439C7 0D          1741*          		DEC     C
0439C8 C2 BD 39 04 1742*          		JP      NZ,FLOAT_
0439CC C9          1743*          		RET
0439CD             1744*  ;
0439CD             1745*  ;SFLOAT - Convert to floating-point if necessary.
0439CD             1746*  ;    Input: Variable-type number in HLH'L'C
0439CD             1747*  ;    Output: Floating-point in HLH'L'C
0439CD             1748*  ;    Destroys: A,C,H,L,H',L',F
0439CD             1749*  ;
0439CD 08          1750*  FLOATA:			EX      AF,AF'
0439CE             1751*          		; ADD     A,(RTABLE-DTABLE)/3
0439CE C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0439D0 08          1753*          		EX      AF,AF'
0439D1 CD 0E 3A 04 1754*  FLOAT2:			CALL    SWAP_FP
0439D5 CD DD 39 04 1755*          		CALL    SFLOAT_FP
0439D9 CD 0E 3A 04 1756*          		CALL    SWAP_FP
0439DD 0D          1757*  SFLOAT_FP:			DEC     C
0439DE 0C          1758*          		INC     C
0439DF C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
0439E0 CD 36 3A 04 1760*          		CALL    TEST_FP
0439E4 C8          1761*          		RET     Z               ;ZERO
0439E5 7C          1762*          		LD      A,H
0439E6 B7          1763*          		OR      A
0439E7 FC 11 39 04 1764*          		CALL    M,NEGATE
0439EB 0E 9F       1765*          		LD      C,159
0439ED CD BD 39 04 1766*          		CALL    FLOAT_
0439F1 B7          1767*          		OR      A
0439F2 F8          1768*          		RET     M               ;NEGATIVE
0439F3 CB BC       1769*          		RES     7,H
0439F5 C9          1770*          		RET
0439F6             1771*  ;
0439F6             1772*  ;ROUND UP
0439F6             1773*  ;Return with carry set if 32-bit overflow
0439F6             1774*  ;   Destroys: H,L,B',C',H',L',F
0439F6             1775*  ;
0439F6 D9          1776*  ADD1_FP:			EXX
0439F7 01 01 00 00 1777*          		LD      BC,1
0439FB 52 09       1778*          		ADD.S   HL,BC
0439FD D9          1779*          		EXX
0439FE D0          1780*          		RET     NC
0439FF C5          1781*          		PUSH    BC
043A00 01 01 00 00 1782*          		LD      BC,1
043A04 52 09       1783*          		ADD.S   HL,BC
043A06 C1          1784*          		POP     BC
043A07 C9          1785*          		RET
043A08             1786*  ;
043A08             1787*  ;ODD - Add one if even, leave alone if odd.
043A08             1788*  ; (Used to perform unbiassed rounding, i.e.
043A08             1789*  ;  number is rounded up half the time)
043A08             1790*  ;    Destroys: L',F (carry cleared)
043A08             1791*  ;
043A08 B7          1792*  ODD:			OR      A               ;CLEAR CARRY
043A09 D9          1793*          		EXX
043A0A CB C5       1794*          		SET     0,L             ;MAKE ODD
043A0C D9          1795*          		EXX
043A0D C9          1796*          		RET
043A0E             1797*  ;
043A0E             1798*  ;SWAP_FP - Swap arguments.
043A0E             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
043A0E             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
043A0E             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
043A0E             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
043A0E             1803*  ;
043A0E 79          1804*  SWAP_FP:			LD      A,C
043A0F 48          1805*          		LD      C,B
043A10 47          1806*          		LD      B,A
043A11 EB          1807*  SWAP1:			EX      DE,HL
043A12 D9          1808*          		EXX
043A13 EB          1809*          		EX      DE,HL
043A14 D9          1810*          		EXX
043A15 C9          1811*          		RET
043A16             1812*  ;
043A16             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
043A16             1814*  ; INCC - destroys C,F
043A16             1815*  ; OFLOW
043A16             1816*  ;
043A16 CD CF 3A 04 1817*  DIV2:			CALL    D2
043A1A D9          1818*          		EXX
043A1B CB 18       1819*          		RR      B
043A1D CB 19       1820*          		RR      C
043A1F 08          1821*          		EX      AF,AF'
043A20 B0          1822*          		OR      B
043A21 08          1823*          		EX      AF,AF'
043A22 D9          1824*          		EXX
043A23 0C          1825*  INCC:			INC     C
043A24 C0          1826*          		RET     NZ
043A25 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
043A27 C3 B4 2E 04 1828*          		JP      ERROR_FP_           ;"Too big"
043A2B             1829*  ;
043A2B             1830*  ; FTEST - Test for zero & sign
043A2B             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
043A2B             1832*  ;
043A2B CD 36 3A 04 1833*  FTEST_FP:			CALL    TEST_FP
043A2F C8          1834*          		RET     Z
043A30 7C          1835*          		LD      A,H
043A31 E6 80       1836*          		AND     10000000B
043A33 F6 40       1837*          		OR      01000000B
043A35 C9          1838*          		RET
043A36             1839*  ;
043A36             1840*  ; TEST_FP - Test HLH'L' for zero.
043A36             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
043A36             1842*  ;     Destroys: A,F
043A36             1843*  ;
043A36 7C          1844*  TEST_FP:			LD      A,H
043A37 B5          1845*          		OR      L
043A38 D9          1846*          		EXX
043A39 B4          1847*          		OR      H
043A3A B5          1848*          		OR      L
043A3B D9          1849*          		EXX
043A3C C9          1850*          		RET
043A3D             1851*  ;
043A3D             1852*  ; FCOMP - Compare two numbers
043A3D             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
043A3D             1854*  ;
043A3D 78          1855*  FCOMP_FP:			LD      A,B
043A3E B1          1856*          		OR      C               ;Both integer?
043A3F 20 0B       1857*          		JR      NZ,FCOMP1
043A41 CD 56 3A 04 1858*          		CALL    ICP
043A45 3E 00       1859*  FCOMP0:			LD      A,0
043A47 C8          1860*          		RET     Z               ;Equal
043A48 3E 80       1861*          		LD      A,80H
043A4A 1F          1862*          		RRA
043A4B C9          1863*          		RET
043A4C             1864*  ;
043A4C CD D1 39 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
043A50 CD 64 3A 04 1866*          		CALL    FCP
043A54 18 EF       1867*          		JR      FCOMP0
043A56             1868*  ;
043A56             1869*  ; Integer and floating point compare.
043A56             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
043A56             1871*  ; Result pre-set to FALSE
043A56             1872*  ; ICP1, FCP1 destroy A,F
043A56             1873*  ;
043A56             1874*  ; ZERO - Return zero.
043A56             1875*  ;  Destroys: A,C,H,L,H',L'
043A56             1876*  ;
043A56 CD 89 3A 04 1877*  ICP:			CALL    ICP1
043A5A 3E 00       1878*  ZERO_FP:			LD      A,0
043A5C D9          1879*          		EXX
043A5D 67          1880*          		LD      H,A
043A5E 6F          1881*  	       		LD      L,A
043A5F D9          1882*          		EXX
043A60 67          1883*        			LD      H,A
043A61 6F          1884*       			LD      L,A
043A62 4F          1885*  	    		LD      C,A
043A63 C9          1886*          		RET
043A64             1887*  ;
043A64 CD 7B 3A 04 1888*  FCP:			CALL    FCP1
043A68 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
043A6A             1890*  ;
043A6A 79          1891*  FCP0:			LD      A,C
043A6B B8          1892*          		CP      B               ;COMPARE EXPONENTS
043A6C C0          1893*          		RET     NZ
043A6D             1894*  ICP0:
043A6D 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
043A70 52 19       1896*          		ADD.S   HL,DE
043A72 C0          1897*          		RET     NZ
043A73 D9          1898*          		EXX
043A74 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
043A77 52 19       1900*          		ADD.S   HL,DE
043A79 D9          1901*          		EXX
043A7A C9          1902*          		RET
043A7B             1903*  ;
043A7B 7C          1904*  FCP1:			LD      A,H
043A7C AA          1905*          		XOR     D
043A7D 7C          1906*          		LD      A,H
043A7E 17          1907*          		RLA
043A7F F8          1908*          		RET     M
043A80 30 E8       1909*          		JR      NC,FCP0
043A82 CD 6A 3A 04 1910*          		CALL    FCP0
043A86 C8          1911*          		RET     Z               ;** V0.1 BUG FIX
043A87 3F          1912*          		CCF
043A88 C9          1913*          		RET
043A89             1914*  ;
043A89 7C          1915*  ICP1:			LD      A,H
043A8A AA          1916*          		XOR     D
043A8B F2 6D 3A 04 1917*          		JP      P,ICP0
043A8F 7C          1918*          		LD      A,H
043A90 17          1919*          		RLA
043A91 C9          1920*          		RET
043A92             1921*  ;
043A92             1922*  ; ADD - Integer add.
043A92             1923*  ; Carry, sign & zero flags valid on exit
043A92             1924*  ;     Destroys: H,L,H',L',F
043A92             1925*  ;
043A92 05          1926*  X10B:			DEC     B
043A93 0C          1927*          		INC     C
043A94 CD DB 3A 04 1928*  X5:			CALL    COPY0
043A98 CD CE 3A 04 1929*          		CALL    D2C
043A9C CD CE 3A 04 1930*          		CALL    D2C
043AA0 08          1931*          		EX      AF,AF'          ;SAVE CARRY
043AA1 D9          1932*  ADD_:			EXX
043AA2 52 19       1933*          		ADD.S   HL,DE
043AA4 D9          1934*          		EXX
043AA5 52 ED 5A    1935*          		ADC.S   HL,DE
043AA8 C9          1936*          		RET
043AA9             1937*  ;
043AA9             1938*  ; SUB - Integer subtract.
043AA9             1939*  ; Carry, sign & zero flags valid on exit
043AA9             1940*  ;     Destroys: H,L,H',L',F
043AA9             1941*  ;
043AA9 D9          1942*  SUB_:			EXX
043AAA B7          1943*          		OR      A
043AAB 52 ED 52    1944*          		SBC.S   HL,DE
043AAE D9          1945*          		EXX
043AAF 52 ED 52    1946*          		SBC.S   HL,DE
043AB2 C9          1947*          		RET
043AB3             1948*  ;
043AB3             1949*  ; X10 - unsigned integer * 10
043AB3             1950*  ;    Inputs: HLH'L' initial value
043AB3             1951*  ;   Outputs: DED'E' = initial HLH'L'
043AB3             1952*  ;            Carry bit set if overflow
043AB3             1953*  ;            If carry not set HLH'L'=result
043AB3             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
043AB3             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
043AB3             1956*  ;     Carry set if MSB=1 before shift.
043AB3             1957*  ;     Sign set if MSB=1 after shift.
043AB3             1958*  ;     Destroys: H,L,H',L',F
043AB3             1959*  ;
043AB3 CD DB 3A 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
043AB7 CD C6 3A 04 1961*          		CALL    X2
043ABB D8          1962*          		RET     C               ;TOO BIG
043ABC CD C6 3A 04 1963*          		CALL    X2
043AC0 D8          1964*          		RET     C
043AC1 CD A1 3A 04 1965*          		CALL    ADD_
043AC5 D8          1966*          		RET     C
043AC6 D9          1967*  X2:			EXX
043AC7 52 29       1968*          		ADD.S   HL,HL
043AC9 D9          1969*          		EXX
043ACA 52 ED 6A    1970*          		ADC.S   HL,HL
043ACD C9          1971*          		RET
043ACE             1972*  ;
043ACE             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
043ACE             1974*  ;     Carry set if LSB=1 before shift.
043ACE             1975*  ;     Destroys: H,L,H',L',F
043ACE             1976*  ;
043ACE 0C          1977*  D2C:			INC     C
043ACF CB 3C       1978*  D2:			SRL     H
043AD1 CB 1D       1979*          		RR      L
043AD3 D9          1980*          		EXX
043AD4 CB 1C       1981*          		RR      H
043AD6 CB 1D       1982*          		RR      L
043AD8 D9          1983*          		EXX
043AD9 C9          1984*          		RET
043ADA             1985*  ;
043ADA             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
043ADA             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
043ADA             1988*  ;
043ADA 41          1989*  COPY_:			LD      B,C
043ADB 54          1990*  COPY0:			LD      D,H
043ADC 5D          1991*          		LD      E,L
043ADD D9          1992*          		EXX
043ADE 54          1993*          		LD      D,H
043ADF 5D          1994*          		LD      E,L
043AE0 D9          1995*          		EXX
043AE1 C9          1996*          		RET
043AE2             1997*  ;
043AE2             1998*  ; SQUARE - PUSH X*X
043AE2             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
043AE2             2000*  ;   Destroys: SP,IX
043AE2             2001*  ;
043AE2 CD DA 3A 04 2002*  SQUARE:			CALL    COPY_
043AE6 CD 45 31 04 2003*          		CALL    FMUL
043AEA DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
043AEC C5          2005*          		PUSH    BC
043AED E5          2006*          		PUSH    HL
043AEE D9          2007*          		EXX
043AEF E5          2008*          		PUSH    HL
043AF0 D9          2009*          		EXX
043AF1 DD E9       2010*          		JP      (IX)            ;"RETURN"
043AF3             2011*  ;
043AF3             2012*  ; POP5 - POP DED'E'B OFF STACK.
043AF3             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
043AF3             2014*  ;
043AF3 DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
043AF5 D9          2016*          		EXX
043AF6 D1          2017*          		POP     DE
043AF7 D9          2018*          		EXX
043AF8 D1          2019*          		POP     DE
043AF9 79          2020*          		LD      A,C
043AFA C1          2021*          		POP     BC
043AFB 41          2022*          		LD      B,C
043AFC 4F          2023*          		LD      C,A
043AFD DD E9       2024*          		JP      (IX)            ;"RETURN"
043AFF             2025*  ;
043AFF             2026*  ; RATIO - Calculate (X-1)/(X+1)
043AFF             2027*  ;     Inputs: X in HLH'L'C
043AFF             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
043AFF             2029*  ;   Destroys: Everything except IY,SP,I
043AFF             2030*  ;
043AFF CD EA 3A 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
043B03 CD 72 34 04 2032*          		CALL    DONE
043B07 CD 33 30 04 2033*          		CALL    FADD
043B0B CD F3 3A 04 2034*          		CALL    POP5            ;RESTORE X
043B0F CD EA 3A 04 2035*          		CALL    PUSH5           ;SAVE X+1
043B13 CD 0E 3A 04 2036*          		CALL    SWAP_FP
043B17 CD 72 34 04 2037*          		CALL    DONE
043B1B CD 1A 30 04 2038*          		CALL    FSUB
043B1F CD F3 3A 04 2039*          		CALL    POP5            ;RESTORE X+1
043B23 C3 9C 30 04 2040*          		JP      FDIV
043B27             2041*  ;
043B27             2042*  ; POLY - Evaluate a polynomial.
043B27             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
043B27             2044*  ;             Polynomial coefficients follow call.
043B27             2045*  ;    Outputs: Result in HLH'L'C
043B27             2046*  ;   Destroys: Everything except IY,SP,I
043B27             2047*  ; Routine terminates on finding a coefficient >=1.
043B27             2048*  ; Note: The last coefficient is EXECUTED on return
043B27             2049*  ;       so must contain only innocuous bytes!
043B27             2050*  ;
043B27 DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
043B2C DD 39       2052*          		ADD     IX, SP
043B2E DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
043B30             2054*  ;
043B30 CD 06 38 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
043B34 CD 45 31 04 2056*  POLY1:			CALL    FMUL
043B38 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
043B3C DD 19       2058*          		ADD     IX, DE
043B3E CD 06 38 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
043B42 DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
043B44 04          2061*          		INC     B
043B45 05          2062*          		DEC     B               		; Test B for end byte (80h)
043B46 FA 33 30 04 2063*          		JP      M,FADD				; Yes, so add and return
043B4A CD 33 30 04 2064*          		CALL    FADD				; No, so add
043B4E CD 18 38 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
043B52 DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
043B54 18 DE       2067*          		JR      POLY1				; And loop
043B56             2068*  ;
043B56             2069*  ; POWR10 - Calculate power of ten.
043B56             2070*  ;     Inputs: A=power of 10 required (A<128)
043B56             2071*  ;             A=binary exponent to be exceeded (A>=128)
043B56             2072*  ;    Outputs: DED'E'B = result
043B56             2073*  ;             A = actual power of ten returned
043B56             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
043B56             2075*  ;
043B56 3C          2076*  POWR10:			INC     A
043B57 08          2077*          		EX      AF,AF'
043B58 E5          2078*          		PUSH    HL
043B59 D9          2079*          		EXX
043B5A E5          2080*          		PUSH    HL
043B5B D9          2081*          		EXX
043B5C CD 72 34 04 2082*          		CALL    DONE
043B60 CD 0E 3A 04 2083*          		CALL    SWAP_FP
043B64 AF          2084*          		XOR     A
043B65 08          2085*  POWR11:			EX      AF,AF'
043B66 3D          2086*          		DEC     A
043B67 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
043B69 F2 71 3B 04 2088*          		JP      P,POWR13
043B6D B9          2089*          		CP      C
043B6E 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
043B70 3C          2091*          		INC     A
043B71 08          2092*  POWR13:			EX      AF,AF'
043B72 3C          2093*          		INC     A
043B73 CB FC       2094*          		SET     7,H
043B75 CD 94 3A 04 2095*          		CALL    X5
043B79 30 06       2096*          		JR      NC,POWR12
043B7B 08          2097*          		EX      AF,AF'
043B7C CD CE 3A 04 2098*          		CALL    D2C
043B80 08          2099*          		EX      AF,AF'
043B81 08          2100*  POWR12:			EX      AF,AF'
043B82 DC F6 39 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
043B86 0C          2102*          		INC     C
043B87 FA 65 3B 04 2103*          		JP      M,POWR11
043B8B C3 25 3A 04 2104*          		JP      OFLOW
043B8F CD 0E 3A 04 2105*  POWR14:			CALL    SWAP_FP
043B93 CB BA       2106*          		RES     7,D
043B95 D9          2107*          		EXX
043B96 E1          2108*          		POP     HL
043B97 D9          2109*          		EXX
043B98 E1          2110*          		POP     HL
043B99 08          2111*          		EX      AF,AF'
043B9A C9          2112*          		RET
043B9B             2113*  ;
043B9B             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
043B9B             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
043B9B             2116*  ;               Remainder in H'L'HL
043B9B             2117*  ;     Inputs: A = loop counter (normally -32)
043B9B             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
043B9B             2119*  ;
043B9B B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
043B9C             2121*  DIV0:
043B9C 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
043B9F D9          2123*          		EXX
043BA0 52 ED 42    2124*          		SBC.S   HL,BC
043BA3 D9          2125*          		EXX
043BA4 30 07       2126*          		JR      NC,DIV1
043BA6 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
043BA8 D9          2128*          		EXX
043BA9 52 ED 4A    2129*          		ADC.S   HL,BC
043BAC D9          2130*          		EXX
043BAD 3F          2131*  DIV1:			CCF
043BAE CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
043BB0 CB 12       2133*          		RL      D
043BB2 D9          2134*          		EXX
043BB3 CB 13       2135*          		RL      E
043BB5 CB 12       2136*          		RL      D
043BB7 D9          2137*          		EXX
043BB8 3C          2138*          		INC     A
043BB9 F0          2139*          		RET     P
043BBA             2140*  DIVB:
043BBA 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
043BBD D9          2142*          		EXX
043BBE 52 ED 6A    2143*          		ADC.S   HL,HL
043BC1 D9          2144*          		EXX
043BC2 30 D8       2145*          		JR      NC,DIV0
043BC4 B7          2146*          		OR      A
043BC5 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
043BC8 D9          2148*          		EXX
043BC9 52 ED 42    2149*          		SBC.S   HL,BC
043BCC D9          2150*          		EXX
043BCD 37          2151*          		SCF
043BCE C3 AE 3B 04 2152*          		JP      DIVC
043BD2             2153*  ;
043BD2             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
043BD2             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
043BD2             2156*  ;    Inputs: A = loop counter (usually -32)
043BD2             2157*  ;            H'L'HL = 0
043BD2             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
043BD2             2159*  ;
043BD2 B7          2160*  MULA:			OR      A               ;CLEAR CARRY
043BD3 D9          2161*  MUL0:			EXX
043BD4 CB 1A       2162*          		RR      D               ;MULTIPLIER/2
043BD6 CB 1B       2163*          		RR      E
043BD8 D9          2164*          		EXX
043BD9 CB 1A       2165*          		RR      D
043BDB CB 1B       2166*          		RR      E
043BDD 30 07       2167*          		JR      NC,MUL1
043BDF 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
043BE1 D9          2169*          		EXX
043BE2 52 ED 4A    2170*          		ADC.S   HL,BC
043BE5 D9          2171*          		EXX
043BE6 3C          2172*  MUL1:			INC     A
043BE7 F0          2173*          		RET     P
043BE8 D9          2174*  MULB:			EXX
043BE9 CB 1C       2175*          		RR      H               ;PRODUCT/2
043BEB CB 1D       2176*          		RR      L
043BED D9          2177*          		EXX
043BEE CB 1C       2178*          		RR      H
043BF0 CB 1D       2179*          		RR      L
043BF2 C3 D3 3B 04 2180*          		JP      MUL0
043BF6             2181*  ;
043BF6             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
043BF6             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
043BF6             2184*  ;     Inputs: A = loop counter (normally -31)
043BF6             2185*  ;             B'C'BCH'L'HL initialised to 0
043BF6             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
043BF6             2187*  ;
043BF6             2188*  SQR1:
043BF6 52 ED 42    2189*  			SBC.S   HL,BC
043BF9 D9          2190*          		EXX
043BFA 52 ED 42    2191*          		SBC.S   HL,BC
043BFD D9          2192*          		EXX
043BFE 0C          2193*          		INC     C
043BFF 30 09       2194*          		JR      NC,SQR2
043C01 0D          2195*          		DEC     C
043C02 52 09       2196*          		ADD.S   HL,BC
043C04 D9          2197*          		EXX
043C05 52 ED 4A    2198*          		ADC.S   HL,BC
043C08 D9          2199*          		EXX
043C09 0D          2200*          		DEC     C
043C0A 3C          2201*  SQR2:			INC     A
043C0B F0          2202*          		RET     P
043C0C CB 21       2203*  SQRA:			SLA     C
043C0E CB 10       2204*          		RL      B
043C10 D9          2205*          		EXX
043C11 CB 11       2206*          		RL      C
043C13 CB 10       2207*          		RL      B
043C15 D9          2208*          		EXX
043C16 0C          2209*          		INC     C
043C17 CB 23       2210*          		SLA     E
043C19 CB 12       2211*          		RL      D
043C1B D9          2212*          		EXX
043C1C CB 13       2213*          		RL      E
043C1E CB 12       2214*          		RL      D
043C20 D9          2215*          		EXX
043C21 52 ED 6A    2216*          		ADC.S   HL,HL
043C24 D9          2217*          		EXX
043C25 52 ED 6A    2218*          		ADC.S   HL,HL
043C28 D9          2219*          		EXX
043C29 CB 23       2220*          		SLA     E
043C2B CB 12       2221*          		RL      D
043C2D D9          2222*          		EXX
043C2E CB 13       2223*          		RL      E
043C30 CB 12       2224*          		RL      D
043C32 D9          2225*          		EXX
043C33 52 ED 6A    2226*          		ADC.S   HL,HL
043C36 D9          2227*          		EXX
043C37 52 ED 6A    2228*          		ADC.S   HL,HL
043C3A D9          2229*          		EXX
043C3B D2 F6 3B 04 2230*          		JP      NC,SQR1
043C3F B7          2231*  SQR3:			OR      A
043C40 52 ED 42    2232*          		SBC.S   HL,BC
043C43 D9          2233*          		EXX
043C44 52 ED 42    2234*          		SBC.S   HL,BC
043C47 D9          2235*          		EXX
043C48 0C          2236*          		INC     C
043C49 C3 0A 3C 04 2237*          		JP      SQR2
043C4D             2238*  ;
043C4D             2239*  SQRB:
043C4D 52 29       2240*  			ADD.S   HL,HL
043C4F D9          2241*          		EXX
043C50 52 ED 6A    2242*          		ADC.S   HL,HL
043C53 D9          2243*          		EXX
043C54 38 E9       2244*          		JR      C,SQR3
043C56 3C          2245*          		INC     A
043C57 0C          2246*          		INC     C
043C58 52 ED 42    2247*          		SBC.S   HL,BC
043C5B D9          2248*          		EXX
043C5C 52 ED 42    2249*          		SBC.S   HL,BC
043C5F D9          2250*          		EXX
043C60 D0          2251*          		RET     NC
043C61 52 09       2252*          		ADD.S   HL,BC
043C63 D9          2253*          		EXX
043C64 52 ED 4A    2254*          		ADC.S   HL,BC
043C67 D9          2255*          		EXX
043C68 0D          2256*          		DEC     C
043C69 C9          2257*          		RET
043C6A             2258*  ;
043C6A DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
043C6D FE 3A       2260*          		CP      '9'+1
043C6F 3F          2261*          		CCF
043C70 D8          2262*          		RET     C
043C71 FE 30       2263*          		CP      '0'
043C73 C9          2264*          		RET
043C74             2265*  ;
043C74 DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
043C77 DD 23       2267*          		INC     IX
043C79 FE 20       2268*          		CP      ' '
043C7B 28 F7       2269*          		JR      Z,SIGNQ
043C7D FE 2B       2270*          		CP      '+'
043C7F C8          2271*          		RET     Z
043C80 FE 2D       2272*          		CP      '-'
043C82 C8          2273*          		RET     Z
043C83 DD 2B       2274*          		DEC     IX
043C85 C9          2275*          		RET
043C86             0010       include "gpio.asm"
043C86             0001*  ;
043C86             0002*  ; Title:	BBC Basic for AGON - GPIO functions
043C86             0003*  ; Author:	Dean Belfield
043C86             0004*  ; Created:	12/05/2023
043C86             0005*  ; Last Updated:	12/05/2023
043C86             0006*  ;
043C86             0007*  ; Modinfo:
043C86             0008*  
043C86             0009*  			; INCLUDE	"macros.inc"
043C86             0010*  			; INCLUDE	"equs.inc"
043C86             0011*  
043C86             0012*  			; .ASSUME	ADL = 1
043C86             0013*  
043C86             0014*  			; SEGMENT CODE
043C86             0015*  
043C86             0016*  			; XDEF	GPIOB_SETMODE
043C86             0017*  
043C86             0018*  			; XREF	SWITCH_A
043C86             0019*  
043C86             0020*  ;  A: Mode
043C86             0021*  ;  B: Pins
043C86             0022*  ;
043C86 CD CE 43 04 0023*  GPIOB_SETMODE:		CALL	SWITCH_A
043C8A 9E 3C       0024*  			DW	GPIOB_M0	; Output
043C8C C3 3C       0025*  			DW	GPIOB_M1	; Input
043C8E E3 3C       0026*  			DW	GPIOB_M2	; Open Drain IO
043C90 03 3D       0027*  			DW	GPIOB_M3	; Open Source IO
043C92 1E 3D       0028*  			DW	GPIOB_M4	; Interrupt, Dual Edge
043C94 4A 3D       0029*  			DW	GPIOB_M5	; Alt Function
043C96 65 3D       0030*  			DW	GPIOB_M6	; Interrupt, Active Low
043C98 8C 3D       0031*  			DW	GPIOB_M7	; Interrupt, Active High
043C9A AE 3D       0032*  			DW	GPIOB_M8	; Interrupt, Falling Edge
043C9C D0 3D       0033*  			DW	GPIOB_M9	; Interrupt, Rising Edge
043C9E             0034*  
043C9E             0035*  ; Output
043C9E             0036*  ;
043C9E             0037*  GPIOB_M0:		RES_GPIO PB_DDR,  B
043C9E C5          0001*M 		PUSH	BC
043C9F 78          0002*M 		LD	A, val
043CA0 2F          0003*M 		CPL
043CA1 4F          0004*M 		LD	C, A
043CA2 ED 38 9B    0005*M 		IN0	A, (reg)
043CA5 A1          0006*M 		AND	C
043CA6 ED 39 9B    0007*M 		OUT0	(reg), A
043CA9 C1          0008*M 		POP	BC
043CAA             0038*  			RES_GPIO PB_ALT1, B
043CAA C5          0001*M 		PUSH	BC
043CAB 78          0002*M 		LD	A, val
043CAC 2F          0003*M 		CPL
043CAD 4F          0004*M 		LD	C, A
043CAE ED 38 9C    0005*M 		IN0	A, (reg)
043CB1 A1          0006*M 		AND	C
043CB2 ED 39 9C    0007*M 		OUT0	(reg), A
043CB5 C1          0008*M 		POP	BC
043CB6             0039*  			RES_GPIO PB_ALT2, B
043CB6 C5          0001*M 		PUSH	BC
043CB7 78          0002*M 		LD	A, val
043CB8 2F          0003*M 		CPL
043CB9 4F          0004*M 		LD	C, A
043CBA ED 38 9D    0005*M 		IN0	A, (reg)
043CBD A1          0006*M 		AND	C
043CBE ED 39 9D    0007*M 		OUT0	(reg), A
043CC1 C1          0008*M 		POP	BC
043CC2 C9          0040*  			RET
043CC3             0041*  
043CC3             0042*  ; Input
043CC3             0043*  ;
043CC3             0044*  GPIOB_M1:		SET_GPIO PB_DDR,  B
043CC3 ED 38 9B    0001*M 		IN0	A, (reg)
043CC6 B0          0002*M 		OR	val
043CC7 ED 39 9B    0003*M 		OUT0	(reg), A
043CCA             0045*  			RES_GPIO PB_ALT1, B
043CCA C5          0001*M 		PUSH	BC
043CCB 78          0002*M 		LD	A, val
043CCC 2F          0003*M 		CPL
043CCD 4F          0004*M 		LD	C, A
043CCE ED 38 9C    0005*M 		IN0	A, (reg)
043CD1 A1          0006*M 		AND	C
043CD2 ED 39 9C    0007*M 		OUT0	(reg), A
043CD5 C1          0008*M 		POP	BC
043CD6             0046*  			RES_GPIO PB_ALT2, B
043CD6 C5          0001*M 		PUSH	BC
043CD7 78          0002*M 		LD	A, val
043CD8 2F          0003*M 		CPL
043CD9 4F          0004*M 		LD	C, A
043CDA ED 38 9D    0005*M 		IN0	A, (reg)
043CDD A1          0006*M 		AND	C
043CDE ED 39 9D    0007*M 		OUT0	(reg), A
043CE1 C1          0008*M 		POP	BC
043CE2 C9          0047*  			RET
043CE3             0048*  
043CE3             0049*  ; Open Drain IO
043CE3             0050*  ;
043CE3             0051*  GPIOB_M2:		RES_GPIO PB_DDR,  B
043CE3 C5          0001*M 		PUSH	BC
043CE4 78          0002*M 		LD	A, val
043CE5 2F          0003*M 		CPL
043CE6 4F          0004*M 		LD	C, A
043CE7 ED 38 9B    0005*M 		IN0	A, (reg)
043CEA A1          0006*M 		AND	C
043CEB ED 39 9B    0007*M 		OUT0	(reg), A
043CEE C1          0008*M 		POP	BC
043CEF             0052*  			SET_GPIO PB_ALT1, B
043CEF ED 38 9C    0001*M 		IN0	A, (reg)
043CF2 B0          0002*M 		OR	val
043CF3 ED 39 9C    0003*M 		OUT0	(reg), A
043CF6             0053*  			RES_GPIO PB_ALT2, B
043CF6 C5          0001*M 		PUSH	BC
043CF7 78          0002*M 		LD	A, val
043CF8 2F          0003*M 		CPL
043CF9 4F          0004*M 		LD	C, A
043CFA ED 38 9D    0005*M 		IN0	A, (reg)
043CFD A1          0006*M 		AND	C
043CFE ED 39 9D    0007*M 		OUT0	(reg), A
043D01 C1          0008*M 		POP	BC
043D02 C9          0054*  			RET
043D03             0055*  
043D03             0056*  ; Open Source IO
043D03             0057*  ;
043D03             0058*  GPIOB_M3:		SET_GPIO PB_DDR,  B
043D03 ED 38 9B    0001*M 		IN0	A, (reg)
043D06 B0          0002*M 		OR	val
043D07 ED 39 9B    0003*M 		OUT0	(reg), A
043D0A             0059*  			SET_GPIO PB_ALT1, B
043D0A ED 38 9C    0001*M 		IN0	A, (reg)
043D0D B0          0002*M 		OR	val
043D0E ED 39 9C    0003*M 		OUT0	(reg), A
043D11             0060*  			RES_GPIO PB_ALT2, B
043D11 C5          0001*M 		PUSH	BC
043D12 78          0002*M 		LD	A, val
043D13 2F          0003*M 		CPL
043D14 4F          0004*M 		LD	C, A
043D15 ED 38 9D    0005*M 		IN0	A, (reg)
043D18 A1          0006*M 		AND	C
043D19 ED 39 9D    0007*M 		OUT0	(reg), A
043D1C C1          0008*M 		POP	BC
043D1D C9          0061*  			RET
043D1E             0062*  
043D1E             0063*  ; Interrupt, Dual Edge
043D1E             0064*  ;
043D1E             0065*  GPIOB_M4:		SET_GPIO PB_DR,   B
043D1E ED 38 9A    0001*M 		IN0	A, (reg)
043D21 B0          0002*M 		OR	val
043D22 ED 39 9A    0003*M 		OUT0	(reg), A
043D25             0066*  			RES_GPIO PB_DDR,  B
043D25 C5          0001*M 		PUSH	BC
043D26 78          0002*M 		LD	A, val
043D27 2F          0003*M 		CPL
043D28 4F          0004*M 		LD	C, A
043D29 ED 38 9B    0005*M 		IN0	A, (reg)
043D2C A1          0006*M 		AND	C
043D2D ED 39 9B    0007*M 		OUT0	(reg), A
043D30 C1          0008*M 		POP	BC
043D31             0067*  			RES_GPIO PB_ALT1, B
043D31 C5          0001*M 		PUSH	BC
043D32 78          0002*M 		LD	A, val
043D33 2F          0003*M 		CPL
043D34 4F          0004*M 		LD	C, A
043D35 ED 38 9C    0005*M 		IN0	A, (reg)
043D38 A1          0006*M 		AND	C
043D39 ED 39 9C    0007*M 		OUT0	(reg), A
043D3C C1          0008*M 		POP	BC
043D3D             0068*  			RES_GPIO PB_ALT2, B
043D3D C5          0001*M 		PUSH	BC
043D3E 78          0002*M 		LD	A, val
043D3F 2F          0003*M 		CPL
043D40 4F          0004*M 		LD	C, A
043D41 ED 38 9D    0005*M 		IN0	A, (reg)
043D44 A1          0006*M 		AND	C
043D45 ED 39 9D    0007*M 		OUT0	(reg), A
043D48 C1          0008*M 		POP	BC
043D49 C9          0069*  			RET
043D4A             0070*  
043D4A             0071*  ; Alt Function
043D4A             0072*  ;
043D4A             0073*  GPIOB_M5:		SET_GPIO PB_DDR,  B
043D4A ED 38 9B    0001*M 		IN0	A, (reg)
043D4D B0          0002*M 		OR	val
043D4E ED 39 9B    0003*M 		OUT0	(reg), A
043D51             0074*  			RES_GPIO PB_ALT1, B
043D51 C5          0001*M 		PUSH	BC
043D52 78          0002*M 		LD	A, val
043D53 2F          0003*M 		CPL
043D54 4F          0004*M 		LD	C, A
043D55 ED 38 9C    0005*M 		IN0	A, (reg)
043D58 A1          0006*M 		AND	C
043D59 ED 39 9C    0007*M 		OUT0	(reg), A
043D5C C1          0008*M 		POP	BC
043D5D             0075*  			SET_GPIO PB_ALT2, B
043D5D ED 38 9D    0001*M 		IN0	A, (reg)
043D60 B0          0002*M 		OR	val
043D61 ED 39 9D    0003*M 		OUT0	(reg), A
043D64 C9          0076*  			RET
043D65             0077*  
043D65             0078*  ; Interrupt, Active Low
043D65             0079*  ;
043D65             0080*  GPIOB_M6:		RES_GPIO PB_DR,   B
043D65 C5          0001*M 		PUSH	BC
043D66 78          0002*M 		LD	A, val
043D67 2F          0003*M 		CPL
043D68 4F          0004*M 		LD	C, A
043D69 ED 38 9A    0005*M 		IN0	A, (reg)
043D6C A1          0006*M 		AND	C
043D6D ED 39 9A    0007*M 		OUT0	(reg), A
043D70 C1          0008*M 		POP	BC
043D71             0081*  			RES_GPIO PB_DDR,  B
043D71 C5          0001*M 		PUSH	BC
043D72 78          0002*M 		LD	A, val
043D73 2F          0003*M 		CPL
043D74 4F          0004*M 		LD	C, A
043D75 ED 38 9B    0005*M 		IN0	A, (reg)
043D78 A1          0006*M 		AND	C
043D79 ED 39 9B    0007*M 		OUT0	(reg), A
043D7C C1          0008*M 		POP	BC
043D7D             0082*  			SET_GPIO PB_ALT1, B
043D7D ED 38 9C    0001*M 		IN0	A, (reg)
043D80 B0          0002*M 		OR	val
043D81 ED 39 9C    0003*M 		OUT0	(reg), A
043D84             0083*  			SET_GPIO PB_ALT2, B
043D84 ED 38 9D    0001*M 		IN0	A, (reg)
043D87 B0          0002*M 		OR	val
043D88 ED 39 9D    0003*M 		OUT0	(reg), A
043D8B C9          0084*  			RET
043D8C             0085*  
043D8C             0086*  
043D8C             0087*  ; Interrupt, Active High
043D8C             0088*  ;
043D8C             0089*  GPIOB_M7:		SET_GPIO PB_DR,   B
043D8C ED 38 9A    0001*M 		IN0	A, (reg)
043D8F B0          0002*M 		OR	val
043D90 ED 39 9A    0003*M 		OUT0	(reg), A
043D93             0090*  			RES_GPIO PB_DDR,  B
043D93 C5          0001*M 		PUSH	BC
043D94 78          0002*M 		LD	A, val
043D95 2F          0003*M 		CPL
043D96 4F          0004*M 		LD	C, A
043D97 ED 38 9B    0005*M 		IN0	A, (reg)
043D9A A1          0006*M 		AND	C
043D9B ED 39 9B    0007*M 		OUT0	(reg), A
043D9E C1          0008*M 		POP	BC
043D9F             0091*  			SET_GPIO PB_ALT1, B
043D9F ED 38 9C    0001*M 		IN0	A, (reg)
043DA2 B0          0002*M 		OR	val
043DA3 ED 39 9C    0003*M 		OUT0	(reg), A
043DA6             0092*  			SET_GPIO PB_ALT2, B
043DA6 ED 38 9D    0001*M 		IN0	A, (reg)
043DA9 B0          0002*M 		OR	val
043DAA ED 39 9D    0003*M 		OUT0	(reg), A
043DAD C9          0093*  			RET
043DAE             0094*  
043DAE             0095*  
043DAE             0096*  ; Interrupt, Falling Edge
043DAE             0097*  ;
043DAE             0098*  GPIOB_M8:		RES_GPIO PB_DR,   B
043DAE C5          0001*M 		PUSH	BC
043DAF 78          0002*M 		LD	A, val
043DB0 2F          0003*M 		CPL
043DB1 4F          0004*M 		LD	C, A
043DB2 ED 38 9A    0005*M 		IN0	A, (reg)
043DB5 A1          0006*M 		AND	C
043DB6 ED 39 9A    0007*M 		OUT0	(reg), A
043DB9 C1          0008*M 		POP	BC
043DBA             0099*  			SET_GPIO PB_DDR,  B
043DBA ED 38 9B    0001*M 		IN0	A, (reg)
043DBD B0          0002*M 		OR	val
043DBE ED 39 9B    0003*M 		OUT0	(reg), A
043DC1             0100*  			SET_GPIO PB_ALT1, B
043DC1 ED 38 9C    0001*M 		IN0	A, (reg)
043DC4 B0          0002*M 		OR	val
043DC5 ED 39 9C    0003*M 		OUT0	(reg), A
043DC8             0101*  			SET_GPIO PB_ALT2, B
043DC8 ED 38 9D    0001*M 		IN0	A, (reg)
043DCB B0          0002*M 		OR	val
043DCC ED 39 9D    0003*M 		OUT0	(reg), A
043DCF C9          0102*  			RET
043DD0             0103*  
043DD0             0104*  ; Interrupt, Rising Edge
043DD0             0105*  ;
043DD0             0106*  GPIOB_M9:		SET_GPIO PB_DR,   B
043DD0 ED 38 9A    0001*M 		IN0	A, (reg)
043DD3 B0          0002*M 		OR	val
043DD4 ED 39 9A    0003*M 		OUT0	(reg), A
043DD7             0107*  			SET_GPIO PB_DDR,  B
043DD7 ED 38 9B    0001*M 		IN0	A, (reg)
043DDA B0          0002*M 		OR	val
043DDB ED 39 9B    0003*M 		OUT0	(reg), A
043DDE             0108*  			SET_GPIO PB_ALT1, B
043DDE ED 38 9C    0001*M 		IN0	A, (reg)
043DE1 B0          0002*M 		OR	val
043DE2 ED 39 9C    0003*M 		OUT0	(reg), A
043DE5             0109*  			SET_GPIO PB_ALT2, B
043DE5 ED 38 9D    0001*M 		IN0	A, (reg)
043DE8 B0          0002*M 		OR	val
043DE9 ED 39 9D    0003*M 		OUT0	(reg), A
043DEC C9          0110*  			RET
043DED             0011       include "interrupts.asm"
043DED             0001*  ;
043DED             0002*  ; Title:	BBC Basic for AGON - Interrupts
043DED             0003*  ; Author:	Dean Belfield
043DED             0004*  ; Created:	12/05/2023
043DED             0005*  ; Last Updated:	07/06/2023
043DED             0006*  ;
043DED             0007*  ; Modinfo:
043DED             0008*  ; 07/06/2023:	Modified to run in ADL mode
043DED             0009*  
043DED             0010*  			; .ASSUME	ADL = 1
043DED             0011*  
043DED             0012*  			; INCLUDE	"macros.inc"
043DED             0013*  			; INCLUDE	"equs.inc"
043DED             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
043DED             0015*  
043DED             0016*  			; SEGMENT CODE
043DED             0017*  
043DED             0018*  			; XDEF	VBLANK_INIT
043DED             0019*  			; XDEF	VBLANK_STOP
043DED             0020*  			; XDEF	VBLANK_HANDLER
043DED             0021*  
043DED             0022*  			; XREF	ESCSET
043DED             0023*  			; XREF	KEYDOWN		; In ram.asm
043DED             0024*  			; XREF	KEYASCII 	; In ram.asm
043DED             0025*  			; XREF	KEYCOUNT	; In ram.asm
043DED             0026*  
043DED             0027*  ; Hook into the MOS VBLANK interrupt
043DED             0028*  ;
043DED F3          0029*  VBLANK_INIT:		DI
043DEE 21 42 3E 04 0030*  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
043DF2 1E 32       0031*  			LD		E, 32h				; Set up the VBlank Interrupt Vector
043DF4             0032*  			MOSCALL		mos_setintvector
043DF4 3E 14       0001*M 			LD	A, function
043DF6 49 CF       0002*M 			RST.LIS	08h
043DF8             0033*  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
043DF8 EB          0034*  			ex de,hl
043DF9 21 50 3E 04 0035*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
043DFD ED 1F       0036*  			LD		(HL), DE			; Self-modify the code
043DFF FB          0037*  			EI
043E00 C9          0038*  			RET
043E01             0039*  
043E01             0040*  ; Unhook the custom VBLANK interrupt
043E01             0041*  ;
043E01 F3          0042*  VBLANK_STOP:		DI
043E02 21 50 3E 04 0043*  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
043E06 ED 17       0044*  			LD		DE, (HL)
043E08 EB          0045*  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
043E09 1E 32       0046*  			LD		E, 32h
043E0B             0047*  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
043E0B 3E 14       0001*M 			LD	A, function
043E0D 49 CF       0002*M 			RST.LIS	08h
043E0F FB          0048*  			EI
043E10 C9          0049*  			RET
043E11             0050*  
043E11             0051*  ; A safe LIS call to ESCSET
043E11             0052*  ;
043E11             0053*  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
043E11 3E 08       0001*M 			LD	A, function
043E13 49 CF       0002*M 			RST.LIS	08h
043E15 21 49 4D 04 0054*  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
043E19 DD 7E 19    0055*  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
043E1C BE          0056*  			CP 		(HL)				; with our local copy
043E1D 20 0A       0057*  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
043E1F             0058*  ;
043E1F AF          0059*  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
043E20 32 48 4D 04 0060*  			LD		(KEYASCII), A
043E24 32 47 4D 04 0061*  			LD		(KEYDOWN), A
043E28 C9          0062*  			RET	 					; And return
043E29             0063*  ;
043E29 77          0064*  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
043E2A DD 7E 18    0065*  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
043E2D B7          0066*  			OR		A
043E2E 28 EF       0067*  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
043E30             0068*  ;
043E30 32 47 4D 04 0069*  			LD		(KEYDOWN), A 			; Store the keydown value
043E34 DD 7E 05    0070*  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
043E37 32 48 4D 04 0071*  			LD		(KEYASCII), A 			; Store locally
043E3B FE 1B       0072*  			CP		1Bh				; Is it escape?
043E3D CC 26 45 04 0073*  			CALL		Z, ESCSET			; Yes, so set the escape flags
043E41 C9          0074*  			RET						; Return to the interrupt handler
043E42             0075*  
043E42 F3          0076*  VBLANK_HANDLER:		DI
043E43 F5          0077*  			PUSH		AF
043E44 E5          0078*  			PUSH		HL
043E45 DD E5       0079*  			PUSH		IX
043E47 CD 11 3E 04 0080*  			CALL		DO_KEYBOARD
043E4B DD E1       0081*  			POP		IX
043E4D E1          0082*  			POP		HL
043E4E F1          0083*  			POP		AF
043E4F             0084*  ;
043E4F             0085*  ; Finally jump to the MOS interrupt
043E4F             0086*  ;
043E4F C3 00 00 00 0087*  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
043E53             0012       include "agon_graphics.asm"
043E53             0001*  ;
043E53             0002*  ; Title:	BBC Basic for AGON - Graphics stuff
043E53             0003*  ; Author:	Dean Belfield
043E53             0004*  ; Created:	12/05/2023
043E53             0005*  ; Last Updated:	07/06/2023
043E53             0006*  ;
043E53             0007*  ; Modinfo:
043E53             0008*  ; 07/06/2023:	Modified to run in ADL mode
043E53             0009*  
043E53             0010*  			; .ASSUME	ADL = 1
043E53             0011*  
043E53             0012*  			; INCLUDE	"equs.inc"
043E53             0013*  			; INCLUDE "macros.inc"
043E53             0014*  			; INCLUDE "mos_api.inc"	; In MOS/src
043E53             0015*  
043E53             0016*  			; SEGMENT CODE
043E53             0017*  
043E53             0018*  			; XDEF	CLG
043E53             0019*  			; XDEF	CLRSCN
043E53             0020*  			; XDEF	MODE
043E53             0021*  			; XDEF	COLOUR
043E53             0022*  			; XDEF	GCOL
043E53             0023*  			; XDEF	MOVE
043E53             0024*  			; XDEF	PLOT
043E53             0025*  			; XDEF	DRAW
043E53             0026*  			; XDEF	POINT
043E53             0027*  			; XDEF	GETSCHR
043E53             0028*  
043E53             0029*  			; XREF	OSWRCH
043E53             0030*  			; XREF	ASC_TO_NUMBER
043E53             0031*  			; XREF	EXTERR
043E53             0032*  			; XREF	EXPRI
043E53             0033*  			; XREF	COMMA
043E53             0034*  			; XREF	XEQ
043E53             0035*  			; XREF	NXT
043E53             0036*  			; XREF	BRAKET
043E53             0037*  			; XREF	COUNT0
043E53             0038*  			; XREF	CRTONULL
043E53             0039*  			; XREF	NULLTOCR
043E53             0040*  			; XREF	CRLF
043E53             0041*  			; XREF	EXPR_W2
043E53             0042*  			; XREF	INKEY1
043E53             0043*  
043E53             0044*  ; CLG: clears the graphics area
043E53             0045*  ;
043E53             0046*  CLG:			VDU	10h
043E53 3E 10       0001*M 		LD	A, val
043E55 CD DA 44 04 0002*M 		CALL	OSWRCH
043E59 C3 9D 19 04 0047*  			JP	XEQ
043E5D             0048*  
043E5D             0049*  ; CLS: clears the text area
043E5D             0050*  ;
043E5D 3E 0C       0051*  CLRSCN:			LD	A, 0Ch
043E5F C3 DA 44 04 0052*  			JP	OSWRCH
043E63             0053*  
043E63             0054*  ; MODE n: Set video mode
043E63             0055*  ;
043E63 DD E5       0056*  MODE:			PUSH	IX			; Get the system vars in IX
043E65             0057*  			MOSCALL	mos_sysvars		; Reset the semaphore
043E65 3E 08       0001*M 			LD	A, function
043E67 49 CF       0002*M 			RST.LIS	08h
043E69 DD CB 04 A6 0058*  			RES	4, (IX+sysvar_vpd_pflags)
043E6D CD 0E 11 04 0059*  			CALL    EXPRI
043E71 D9          0060*  			EXX
043E72             0061*  			VDU	16H			; Mode change
043E72 3E 16       0001*M 		LD	A, val
043E74 CD DA 44 04 0002*M 		CALL	OSWRCH
043E78             0062*  			VDU	L
043E78 7D          0001*M 		LD	A, val
043E79 CD DA 44 04 0002*M 		CALL	OSWRCH
043E7D             0063*  			MOSCALL	mos_sysvars
043E7D 3E 08       0001*M 			LD	A, function
043E7F 49 CF       0002*M 			RST.LIS	08h
043E81 DD CB 04 66 0064*  @@:			BIT	4, (IX+sysvar_vpd_pflags)
043E85 28 FA       0065*  			JR	Z, @B			; Wait for the result
043E87 DD E1       0066*  			POP	IX
043E89 C3 9D 19 04 0067*  			JP	XEQ
043E8D             0068*  
043E8D             0069*  ; GET(x,y): Get the ASCII code of a character on screen
043E8D             0070*  ;
043E8D FD 23       0071*  GETSCHR:		INC	IY
043E8F CD 0E 11 04 0072*  			CALL    EXPRI      		; Get X coordinate
043E93 D9          0073*  			EXX
043E94 22 00 4A 04 0074*  			LD	(VDU_BUFFER+0), HL
043E98 CD 29 18 04 0075*  			CALL	COMMA
043E9C CD 0E 11 04 0076*  			CALL	EXPRI			; Get Y coordinate
043EA0 D9          0077*  			EXX
043EA1 22 02 4A 04 0078*  			LD	(VDU_BUFFER+2), HL
043EA5 CD 36 18 04 0079*  			CALL	BRAKET			; Closing bracket
043EA9             0080*  ;
043EA9 DD E5       0081*  			PUSH	IX			; Get the system vars in IX
043EAB             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
043EAB 3E 08       0001*M 			LD	A, function
043EAD 49 CF       0002*M 			RST.LIS	08h
043EAF DD CB 04 8E 0083*  			RES	1, (IX+sysvar_vpd_pflags)
043EB3             0084*  			VDU	23
043EB3 3E 17       0001*M 		LD	A, val
043EB5 CD DA 44 04 0002*M 		CALL	OSWRCH
043EB9             0085*  			VDU	0
043EB9 3E 00       0001*M 		LD	A, val
043EBB CD DA 44 04 0002*M 		CALL	OSWRCH
043EBF             0086*  			VDU	vdp_scrchar
043EBF 3E 83       0001*M 		LD	A, val
043EC1 CD DA 44 04 0002*M 		CALL	OSWRCH
043EC5             0087*  			VDU	(VDU_BUFFER+0)
043EC5 3A 00 4A 04 0001*M 		LD	A, val
043EC9 CD DA 44 04 0002*M 		CALL	OSWRCH
043ECD             0088*  			VDU	(VDU_BUFFER+1)
043ECD 3A 01 4A 04 0001*M 		LD	A, val
043ED1 CD DA 44 04 0002*M 		CALL	OSWRCH
043ED5             0089*  			VDU	(VDU_BUFFER+2)
043ED5 3A 02 4A 04 0001*M 		LD	A, val
043ED9 CD DA 44 04 0002*M 		CALL	OSWRCH
043EDD             0090*  			VDU	(VDU_BUFFER+3)
043EDD 3A 03 4A 04 0001*M 		LD	A, val
043EE1 CD DA 44 04 0002*M 		CALL	OSWRCH
043EE5 DD CB 04 4E 0091*  @@:			BIT	1, (IX+sysvar_vpd_pflags)
043EE9 28 FA       0092*  			JR	Z, @B			; Wait for the result
043EEB DD 7E 09    0093*  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
043EEE B7          0094*  			OR	A			; Check for 00h
043EEF 37          0095*  			SCF				; C = character map
043EF0 20 02       0096*  			JR	NZ, @F			; We have a character, so skip next bit
043EF2 AF          0097*  			XOR	A			; Clear carry
043EF3 3D          0098*  			DEC	A			; Set A to FFh
043EF4 DD E1       0099*  @@:			POP	IX
043EF6 C3 E5 15 04 0100*  			JP	INKEY1			; Jump back to the GET command
043EFA             0101*  
043EFA             0102*  ; POINT(x,y): Get the pixel colour of a point on screen
043EFA             0103*  ;
043EFA CD 0E 11 04 0104*  POINT:			CALL    EXPRI      		; Get X coordinate
043EFE D9          0105*  			EXX
043EFF 22 00 4A 04 0106*  			LD	(VDU_BUFFER+0), HL
043F03 CD 29 18 04 0107*  			CALL	COMMA
043F07 CD 0E 11 04 0108*  			CALL	EXPRI			; Get Y coordinate
043F0B D9          0109*  			EXX
043F0C 22 02 4A 04 0110*  			LD	(VDU_BUFFER+2), HL
043F10 CD 36 18 04 0111*  			CALL	BRAKET			; Closing bracket
043F14             0112*  ;
043F14 DD E5       0113*  			PUSH	IX			; Get the system vars in IX
043F16             0114*  			MOSCALL	mos_sysvars		; Reset the semaphore
043F16 3E 08       0001*M 			LD	A, function
043F18 49 CF       0002*M 			RST.LIS	08h
043F1A DD CB 04 96 0115*  			RES	2, (IX+sysvar_vpd_pflags)
043F1E             0116*  			VDU	23
043F1E 3E 17       0001*M 		LD	A, val
043F20 CD DA 44 04 0002*M 		CALL	OSWRCH
043F24             0117*  			VDU	0
043F24 3E 00       0001*M 		LD	A, val
043F26 CD DA 44 04 0002*M 		CALL	OSWRCH
043F2A             0118*  			VDU	vdp_scrpixel
043F2A 3E 84       0001*M 		LD	A, val
043F2C CD DA 44 04 0002*M 		CALL	OSWRCH
043F30             0119*  			VDU	(VDU_BUFFER+0)
043F30 3A 00 4A 04 0001*M 		LD	A, val
043F34 CD DA 44 04 0002*M 		CALL	OSWRCH
043F38             0120*  			VDU	(VDU_BUFFER+1)
043F38 3A 01 4A 04 0001*M 		LD	A, val
043F3C CD DA 44 04 0002*M 		CALL	OSWRCH
043F40             0121*  			VDU	(VDU_BUFFER+2)
043F40 3A 02 4A 04 0001*M 		LD	A, val
043F44 CD DA 44 04 0002*M 		CALL	OSWRCH
043F48             0122*  			VDU	(VDU_BUFFER+3)
043F48 3A 03 4A 04 0001*M 		LD	A, val
043F4C CD DA 44 04 0002*M 		CALL	OSWRCH
043F50 DD CB 04 56 0123*  @@:			BIT	2, (IX+sysvar_vpd_pflags)
043F54 28 FA       0124*  			JR	Z, @B			; Wait for the result
043F56             0125*  ;
043F56             0126*  ; Return the data as a 1 byte index
043F56             0127*  ;
043F56 DD 6E 16    0128*  			LD	L, (IX+sysvar_scrpixelIndex)
043F59 DD E1       0129*  			POP	IX
043F5B C3 83 13 04 0130*  			JP	COUNT0
043F5F             0131*  
043F5F             0132*  
043F5F             0133*  ; COLOUR colour
043F5F             0134*  ; COLOUR L,P
043F5F             0135*  ; COLOUR L,R,G,B
043F5F             0136*  ;
043F5F CD 0E 11 04 0137*  COLOUR:			CALL	EXPRI			; The colour / mode
043F63 D9          0138*  			EXX
043F64 7D          0139*  			LD	A, L
043F65 32 00 4A 04 0140*  			LD	(VDU_BUFFER+0), A	; Store first parameter
043F69 CD 77 18 04 0141*  			CALL	NXT			; Are there any more parameters?
043F6D FE 2C       0142*  			CP	','
043F6F 28 12       0143*  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
043F71             0144*  ;
043F71             0145*  			VDU	11h			; Just set the colour
043F71 3E 11       0001*M 		LD	A, val
043F73 CD DA 44 04 0002*M 		CALL	OSWRCH
043F77             0146*  			VDU	(VDU_BUFFER+0)
043F77 3A 00 4A 04 0001*M 		LD	A, val
043F7B CD DA 44 04 0002*M 		CALL	OSWRCH
043F7F C3 9D 19 04 0147*  			JP	XEQ
043F83             0148*  ;
043F83 CD 29 18 04 0149*  COLOUR_1:		CALL	COMMA
043F87 CD 0E 11 04 0150*  			CALL	EXPRI			; Parse R (OR P)
043F8B D9          0151*  			EXX
043F8C 7D          0152*  			LD	A, L
043F8D 32 01 4A 04 0153*  			LD	(VDU_BUFFER+1), A
043F91 CD 77 18 04 0154*  			CALL	NXT			; Are there any more parameters?
043F95 FE 2C       0155*  			CP	','
043F97 28 2C       0156*  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
043F99             0157*  ;
043F99             0158*  			VDU	13h			; VDU:COLOUR
043F99 3E 13       0001*M 		LD	A, val
043F9B CD DA 44 04 0002*M 		CALL	OSWRCH
043F9F             0159*  			VDU	(VDU_BUFFER+0)		; Logical Colour
043F9F 3A 00 4A 04 0001*M 		LD	A, val
043FA3 CD DA 44 04 0002*M 		CALL	OSWRCH
043FA7             0160*  			VDU	(VDU_BUFFER+1)		; Palette Colour
043FA7 3A 01 4A 04 0001*M 		LD	A, val
043FAB CD DA 44 04 0002*M 		CALL	OSWRCH
043FAF             0161*  			VDU	0			; RGB set to 0
043FAF 3E 00       0001*M 		LD	A, val
043FB1 CD DA 44 04 0002*M 		CALL	OSWRCH
043FB5             0162*  			VDU	0
043FB5 3E 00       0001*M 		LD	A, val
043FB7 CD DA 44 04 0002*M 		CALL	OSWRCH
043FBB             0163*  			VDU	0
043FBB 3E 00       0001*M 		LD	A, val
043FBD CD DA 44 04 0002*M 		CALL	OSWRCH
043FC1 C3 9D 19 04 0164*  			JP	XEQ
043FC5             0165*  ;
043FC5 CD 29 18 04 0166*  COLOUR_2:		CALL	COMMA
043FC9 CD 0E 11 04 0167*  			CALL	EXPRI			; Parse G
043FCD D9          0168*  			EXX
043FCE 7D          0169*  			LD	A, L
043FCF 32 02 4A 04 0170*  			LD	(VDU_BUFFER+2), A
043FD3 CD 29 18 04 0171*  			CALL	COMMA
043FD7 CD 0E 11 04 0172*  			CALL	EXPRI			; Parse B
043FDB D9          0173*  			EXX
043FDC 7D          0174*  			LD	A, L
043FDD 32 03 4A 04 0175*  			LD	(VDU_BUFFER+3), A
043FE1             0176*  			VDU	13h			; VDU:COLOUR
043FE1 3E 13       0001*M 		LD	A, val
043FE3 CD DA 44 04 0002*M 		CALL	OSWRCH
043FE7             0177*  			VDU	(VDU_BUFFER+0)		; Logical Colour
043FE7 3A 00 4A 04 0001*M 		LD	A, val
043FEB CD DA 44 04 0002*M 		CALL	OSWRCH
043FEF             0178*  			VDU	FFh			; Physical Colour (-1 for RGB mode)
043FEF 3E FF       0001*M 		LD	A, val
043FF1 CD DA 44 04 0002*M 		CALL	OSWRCH
043FF5             0179*  			VDU	(VDU_BUFFER+1)		; R
043FF5 3A 01 4A 04 0001*M 		LD	A, val
043FF9 CD DA 44 04 0002*M 		CALL	OSWRCH
043FFD             0180*  			VDU	(VDU_BUFFER+2)		; G
043FFD 3A 02 4A 04 0001*M 		LD	A, val
044001 CD DA 44 04 0002*M 		CALL	OSWRCH
044005             0181*  			VDU	(VDU_BUFFER+3)		; B
044005 3A 03 4A 04 0001*M 		LD	A, val
044009 CD DA 44 04 0002*M 		CALL	OSWRCH
04400D C3 9D 19 04 0182*  			JP	XEQ
044011             0183*  
044011             0184*  ; GCOL mode,colour
044011             0185*  ;
044011 CD 0E 11 04 0186*  GCOL:			CALL	EXPRI			; Parse MODE
044015 D9          0187*  			EXX
044016 7D          0188*  			LD	A, L
044017 32 00 4A 04 0189*  			LD	(VDU_BUFFER+0), A
04401B CD 29 18 04 0190*  			CALL	COMMA
04401F             0191*  ;
04401F CD 0E 11 04 0192*  			CALL	EXPRI			; Parse Colour
044023 D9          0193*  			EXX
044024 7D          0194*  			LD	A, L
044025 32 01 4A 04 0195*  			LD	(VDU_BUFFER+1), A
044029             0196*  ;
044029             0197*  			VDU	12h			; VDU:GCOL
044029 3E 12       0001*M 		LD	A, val
04402B CD DA 44 04 0002*M 		CALL	OSWRCH
04402F             0198*  			VDU	(VDU_BUFFER+0)		; Mode
04402F 3A 00 4A 04 0001*M 		LD	A, val
044033 CD DA 44 04 0002*M 		CALL	OSWRCH
044037             0199*  			VDU	(VDU_BUFFER+1)		; Colour
044037 3A 01 4A 04 0001*M 		LD	A, val
04403B CD DA 44 04 0002*M 		CALL	OSWRCH
04403F C3 9D 19 04 0200*  			JP	XEQ
044043             0201*  
044043             0202*  ; PLOT mode,x,y
044043             0203*  ;
044043 CD 0E 11 04 0204*  PLOT:			CALL	EXPRI		; Parse mode
044047 D9          0205*  			EXX
044048 E5          0206*  			PUSH	HL		; Push mode (L) onto stack
044049 CD 29 18 04 0207*  			CALL	COMMA
04404D CD 90 49 04 0208*  			CALL	EXPR_W2		; Parse X and Y
044051 C1          0209*  			POP	BC		; Pop mode (C) off stack
044052             0210*  PLOT_1:			VDU	19H		; VDU code for PLOT
044052 3E 19       0001*M 		LD	A, val
044054 CD DA 44 04 0002*M 		CALL	OSWRCH
044058             0211*  			VDU	C		;  C: Mode
044058 79          0001*M 		LD	A, val
044059 CD DA 44 04 0002*M 		CALL	OSWRCH
04405D             0212*  			VDU	E		; DE: X
04405D 7B          0001*M 		LD	A, val
04405E CD DA 44 04 0002*M 		CALL	OSWRCH
044062             0213*  			VDU	D
044062 7A          0001*M 		LD	A, val
044063 CD DA 44 04 0002*M 		CALL	OSWRCH
044067             0214*  			VDU	L		; HL: Y
044067 7D          0001*M 		LD	A, val
044068 CD DA 44 04 0002*M 		CALL	OSWRCH
04406C             0215*  			VDU	H
04406C 7C          0001*M 		LD	A, val
04406D CD DA 44 04 0002*M 		CALL	OSWRCH
044071 C3 9D 19 04 0216*  			JP	XEQ
044075             0217*  
044075             0218*  ; MOVE x,y
044075             0219*  ;
044075 CD 90 49 04 0220*  MOVE:			CALL	EXPR_W2		; Parse X and Y
044079 0E 04       0221*  			LD	C, 04H		; Plot mode 04H (Move)
04407B 18 D5       0222*  			JR	PLOT_1		; Plot
04407D             0223*  
04407D             0224*  ; DRAW x1,y1
04407D             0225*  ; DRAW x1,y1,x2,y2
04407D             0226*  ;
04407D CD 90 49 04 0227*  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
044081 CD 77 18 04 0228*  			CALL	NXT		; Are there any more parameters?
044085 FE 2C       0229*  			CP	','
044087 0E 05       0230*  			LD	C, 05h		; Code for LINE
044089 20 C7       0231*  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
04408B             0232*  			VDU	19h		; Move to the first coordinates
04408B 3E 19       0001*M 		LD	A, val
04408D CD DA 44 04 0002*M 		CALL	OSWRCH
044091             0233*  			VDU	04h
044091 3E 04       0001*M 		LD	A, val
044093 CD DA 44 04 0002*M 		CALL	OSWRCH
044097             0234*  			VDU	E
044097 7B          0001*M 		LD	A, val
044098 CD DA 44 04 0002*M 		CALL	OSWRCH
04409C             0235*  			VDU	D
04409C 7A          0001*M 		LD	A, val
04409D CD DA 44 04 0002*M 		CALL	OSWRCH
0440A1             0236*  			VDU	L
0440A1 7D          0001*M 		LD	A, val
0440A2 CD DA 44 04 0002*M 		CALL	OSWRCH
0440A6             0237*  			VDU	H
0440A6 7C          0001*M 		LD	A, val
0440A7 CD DA 44 04 0002*M 		CALL	OSWRCH
0440AB CD 29 18 04 0238*  			CALL	COMMA
0440AF C5          0239*  			PUSH	BC
0440B0 CD 90 49 04 0240*  			CALL	EXPR_W2		; Get X2 and Y2
0440B4 C1          0241*  			POP	BC
0440B5 18 9B       0242*  			JR	PLOT_1		; Now DRAW the line to those positions
0440B7             0243*  
0440B7             0244*  
0440B7             0245*  
0440B7             0013       include "agon_sound.asm"
0440B7             0001*  ;
0440B7             0002*  ; Title:	BBC Basic for AGON - Audio stuff
0440B7             0003*  ; Author:	Dean Belfield
0440B7             0004*  ; Created:	12/05/2023
0440B7             0005*  ; Last Updated:	12/05/2023
0440B7             0006*  ;
0440B7             0007*  ; Modinfo:
0440B7             0008*  
0440B7             0009*  			; .ASSUME	ADL = 1
0440B7             0010*  
0440B7             0011*  			; INCLUDE	"equs.inc"
0440B7             0012*  			; INCLUDE "macros.inc"
0440B7             0013*  			; INCLUDE "mos_api.inc"	; In MOS/src
0440B7             0014*  
0440B7             0015*  			; SEGMENT CODE
0440B7             0016*  
0440B7             0017*  			; XDEF	SOUND
0440B7             0018*  
0440B7             0019*  			; XREF	COMMA
0440B7             0020*  			; XREF	EXPR_W2
0440B7             0021*  			; XREF	XEQ
0440B7             0022*  			; XREF	LTRAP
0440B7             0023*  			; XREF	OSWRCH
0440B7             0024*  			; XREF	VDU_BUFFER
0440B7             0025*  
0440B7             0026*  
0440B7             0027*  ; SOUND channel,volume,pitch,duration
0440B7             0028*  ; volume: 0 (off) to -15 (full volume)
0440B7             0029*  ; pitch: 0 - 255
0440B7             0030*  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
0440B7             0031*  ;
0440B7 CD 90 49 04 0032*  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
0440BB 7D          0033*  			LD	A, L 			;  A: Volume
0440BC F5          0034*  			PUSH	AF
0440BD D5          0035*  			PUSH	DE
0440BE CD 29 18 04 0036*  			CALL	COMMA
0440C2 CD 90 49 04 0037*  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
0440C6 53          0038*  			LD	D, E			;  D: Pitch
0440C7 5D          0039*  			LD	E, L 			;  E: Duration
0440C8 E1          0040*  			POP	HL 			; HL: Channel/Control
0440C9 F1          0041*  			POP	AF
0440CA ED 44       0042*  			NEG
0440CC FE 10       0043*  			CP	16			; Check volume is in bounds
0440CE D2 9D 19 04 0044*  			JP	NC, XEQ			; Out of bounds, do nothing
0440D2             0045*  ;
0440D2             0046*  ; Store	in VDU vars
0440D2             0047*  ;
0440D2 4F          0048*  			LD	C, A			; Store Volume in C
0440D3 7D          0049*  			LD	A, L
0440D4 32 00 4A 04 0050*  			LD	(VDU_BUFFER+0), A	; Channel
0440D8 AF          0051*  			XOR	A
0440D9 32 01 4A 04 0052*  			LD	(VDU_BUFFER+1), A	; Waveform
0440DD             0053*  ;
0440DD             0054*  ; Calculate the volume
0440DD             0055*  ;
0440DD 06 06       0056*  			LD	B, 6			; C already contains the volume
0440DF ED 4C       0057*  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0440E1 79          0058*  			LD	A, C
0440E2 32 02 4A 04 0059*  			LD	(VDU_BUFFER+2), A
0440E6             0060*  ;
0440E6             0061*  ; And the frequency
0440E6             0062*  ;
0440E6 4B          0063*  			LD	C, E			; Store duration in C
0440E7 26 00       0064*  			LD	H, 0			; Lookup the frequency
0440E9 6A          0065*  			LD	L, D
0440EA 11 71 41 04 0066*  			LD	DE, SOUND_FREQ_LOOKUP
0440EE 29          0067*  			ADD	HL, HL
0440EF 19          0068*  			ADD	HL, DE
0440F0 7E          0069*  			LD	A, (HL)
0440F1 32 03 4A 04 0070*  			LD	(VDU_BUFFER+3), A
0440F5 23          0071*  			INC	HL
0440F6 7E          0072*  			LD	A, (HL)
0440F7 32 04 4A 04 0073*  			LD	(VDU_BUFFER+4), A
0440FB             0074*  ;
0440FB             0075*  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0440FB             0076*  ;
0440FB 06 32       0077*  			LD	B, 50			; C contains the duration, so MLT by 50
0440FD ED 4C       0078*  			MLT	BC
0440FF ED 43 05 4A 0079*  			LD	(VDU_BUFFER+5), BC
       04          
044104             0080*  ;
044104 DD E5       0081*  			PUSH	IX			; Get the system vars in IX
044106             0082*  			MOSCALL	mos_sysvars		; Reset the semaphore
044106 3E 08       0001*M 			LD	A, function
044108 49 CF       0002*M 			RST.LIS	08h
04410A 5B DD CB 04 0083*  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
04410F             0084*  ;
04410F             0085*  			VDU	23			; Send the sound command
04410F 3E 17       0001*M 		LD	A, val
044111 CD DA 44 04 0002*M 		CALL	OSWRCH
044115             0086*  			VDU	0
044115 3E 00       0001*M 		LD	A, val
044117 CD DA 44 04 0002*M 		CALL	OSWRCH
04411B             0087*  			VDU	vdp_audio
04411B 3E 85       0001*M 		LD	A, val
04411D CD DA 44 04 0002*M 		CALL	OSWRCH
044121             0088*  			VDU	(VDU_BUFFER+0)		; 0: Channel
044121 3A 00 4A 04 0001*M 		LD	A, val
044125 CD DA 44 04 0002*M 		CALL	OSWRCH
044129             0089*  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
044129 3A 01 4A 04 0001*M 		LD	A, val
04412D CD DA 44 04 0002*M 		CALL	OSWRCH
044131             0090*  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
044131 3A 02 4A 04 0001*M 		LD	A, val
044135 CD DA 44 04 0002*M 		CALL	OSWRCH
044139             0091*  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
044139 3A 03 4A 04 0001*M 		LD	A, val
04413D CD DA 44 04 0002*M 		CALL	OSWRCH
044141             0092*  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
044141 3A 04 4A 04 0001*M 		LD	A, val
044145 CD DA 44 04 0002*M 		CALL	OSWRCH
044149             0093*  			VDU	(VDU_BUFFER+5)		; 5: Duration L
044149 3A 05 4A 04 0001*M 		LD	A, val
04414D CD DA 44 04 0002*M 		CALL	OSWRCH
044151             0094*  			VDU	(VDU_BUFFER+6)		; 6: Duration H
044151 3A 06 4A 04 0001*M 		LD	A, val
044155 CD DA 44 04 0002*M 		CALL	OSWRCH
044159             0095*  ;
044159             0096*  ; Wait for acknowledgement
044159             0097*  ;
044159 5B DD CB 04 0098*  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
04415E 28 F9       0099*  			JR	Z, @B			; Wait for the result
044160 CD 4B 45 04 0100*  			CALL	LTRAP			; Check for ESC
044164 5B DD 7E 0E 0101*  			LD.LIL	A, (IX+sysvar_audioSuccess)
044168 A7          0102*  			AND	A			; Check if VDP has queued the note
044169 28 9F       0103*  			JR	Z, SOUND0		; No, so loop back and send again
04416B             0104*  ;
04416B DD E1       0105*  			POP	IX
04416D C3 9D 19 04 0106*  			JP	XEQ
044171             0107*  
044171             0108*  ; Frequency Lookup Table
044171             0109*  ; Set up to replicate the BBC Micro audio frequencies
044171             0110*  ;
044171             0111*  ; Split over 5 complete octaves, with 53 being middle C
044171             0112*  ; * C4: 262hz
044171             0113*  ; + A4: 440hz
044171             0114*  ;
044171             0115*  ;	2	3	4	5	6	7	8
044171             0116*  ;
044171             0117*  ; B	1	49	97	145	193	241
044171             0118*  ; A#	0	45	93	141	189	237
044171             0119*  ; A		41	89+	137	185	233
044171             0120*  ; G#		37	85	133	181	229
044171             0121*  ; G		33	81	129	177	225
044171             0122*  ; F#		29	77	125	173	221
044171             0123*  ; F		25	73	121	169	217
044171             0124*  ; E		21	69	117	165	213
044171             0125*  ; D#		17	65	113	161	209
044171             0126*  ; D		13	61	109	157	205	253
044171             0127*  ; C#		9	57	105	153	201	249
044171             0128*  ; C		5	53*	101	149	197	245
044171             0129*  ;
044171 75 00 76 00 0130*  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
044181 89 00 8B 00 0131*  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
044191 99 00 9C 00 0132*  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
0441A1 AC 00 AF 00 0133*  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
0441B1 C1 00 C4 00 0134*  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
0441C1 D9 00 DC 00 0135*  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
0441D1 F3 00 F7 00 0136*  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0441E1 11 01 15 01 0137*  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0441F1 33 01 37 01 0138*  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
044201 58 01 5D 01 0139*  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
044211 82 01 88 01 0140*  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
044221 B2 01 B8 01 0141*  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
044231 E7 01 EE 01 0142*  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
044241 22 02 2A 02 0143*  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
044251 65 02 6E 02 0144*  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
044261 B1 02 BB 02 0145*  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
044271 05 03 10 03 0146*  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
044281 63 03 70 03 0147*  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
044291 CE 03 DC 03 0148*  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
0442A1 45 04 55 04 0149*  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
0442B1 CB 04 DD 04 0150*  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
0442C1 62 05 76 05 0151*  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
0442D1 0A 06 21 06 0152*  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0442E1 C8 06 E1 06 0153*  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0442F1 9C 07 B8 07 0154*  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
044301 8A 08 A9 08 0155*  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
044311 95 09 B9 09 0156*  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
044321 C2 0A EA 0A 0157*  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
044331 13 0C 40 0C 0158*  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
044341 8E 0D C0 0D 0159*  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
044351 36 0F 6F 0F 0160*  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
044361 13 11 53 11 0161*  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
044371             0162*  
044371             0163*  
044371             0014       include "misc.asm"
044371             0001*  ;
044371             0002*  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
044371             0003*  ; Author:	Dean Belfield
044371             0004*  ; Created:	12/05/2023
044371             0005*  ; Last Updated:	12/05/2023
044371             0006*  ;
044371             0007*  ; Modinfo:
044371             0008*  
044371             0009*  			; INCLUDE	"equs.inc"
044371             0010*  			; INCLUDE	"macros.inc"
044371             0011*  
044371             0012*  			; .ASSUME	ADL = 1
044371             0013*  
044371             0014*  			; SEGMENT CODE
044371             0015*  
044371             0016*  			; XDEF	ASC_TO_NUMBER
044371             0017*  			; XDEF	SWITCH_A
044371             0018*  			; XDEF	NULLTOCR
044371             0019*  			; XDEF	CRTONULL
044371             0020*  			; XDEF	CSTR_FNAME
044371             0021*  			; XDEF	CSTR_LINE
044371             0022*  			; XDEF	CSTR_FINDCH
044371             0023*  			; XDEF	CSTR_ENDSWITH
044371             0024*  			; XDEF	CSTR_CAT
044371             0025*  
044371             0026*  			; XREF	OSWRCH
044371             0027*  			; XREF	KEYWDS
044371             0028*  			; XREF	KEYWDL
044371             0029*  
044371             0030*  ; Read a number and convert to binary
044371             0031*  ; If prefixed with &, will read as hex, otherwise decimal
044371             0032*  ;   Inputs: HL: Pointer in string buffer
044371             0033*  ;  Outputs: HL: Updated text pointer
044371             0034*  ;           DE: Value
044371             0035*  ;            A: Terminator (spaces skipped)
044371             0036*  ; Destroys: A,D,E,H,L,F
044371             0037*  ;
044371 C5          0038*  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
044372 11 00 00 00 0039*  			LD	DE, 0			; Initialise DE
044376 CD B8 43 04 0040*  			CALL	SKIPSPC			; Skip whitespace
04437A 7E          0041*  			LD	A, (HL)			; Read first character
04437B FE 26       0042*  			CP	'&'			; Is it prefixed with '&' (HEX number)?
04437D 20 1F       0043*  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
04437F 23          0044*  			INC	HL			; Otherwise fall through to ASC_TO_HEX
044380             0045*  ;
044380 7E          0046*  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
044381 CD C6 43 04 0047*  			CALL    UPPERC			; Convert to uppercase
044385 D6 30       0048*  			SUB	'0'			; Normalise to 0
044387 38 2E       0049*  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
044389 FE 0A       0050*  			CP 	10			; Check if >= 10
04438B 38 06       0051*  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
04438D D6 07       0052*  			SUB 	7			; Adjust ASCII A-F to nibble
04438F FE 10       0053*  			CP 	16			; Check for > F
044391 30 24       0054*  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
044393 EB          0055*  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
044394 29          0056*  			ADD	HL, HL
044395 29          0057*  			ADD	HL, HL
044396 29          0058*  			ADD	HL, HL
044397 29          0059*  			ADD	HL, HL
044398 EB          0060*  			EX	DE, HL
044399 B3          0061*  			OR      E			; OR the new digit in to the least significant nibble
04439A 5F          0062*  			LD      E, A
04439B 23          0063*  			INC     HL			; Onto the next character
04439C 18 E2       0064*  			JR      ASC_TO_NUMBER1		; And loop
04439E             0065*  ;
04439E 7E          0066*  ASC_TO_NUMBER3:		LD	A, (HL)
04439F D6 30       0067*  			SUB	'0'			; Normalise to 0
0443A1 38 14       0068*  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0443A3 FE 0A       0069*  			CP	10			; Check if >= 10
0443A5 30 10       0070*  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0443A7 EB          0071*  			EX 	DE, HL 			; Stick DE in HL
0443A8 44          0072*  			LD	B, H 			; And copy HL into BC
0443A9 4D          0073*  			LD	C, L
0443AA 29          0074*  			ADD	HL, HL 			; x 2
0443AB 29          0075*  			ADD	HL, HL 			; x 4
0443AC 09          0076*  			ADD	HL, BC 			; x 5
0443AD 29          0077*  			ADD	HL, HL 			; x 10
0443AE EB          0078*  			EX	DE, HL
0443AF             0079*  			ADD8U_DE 			; Add A to DE (macro)
0443AF 83          0001*M 		ADD	A, E
0443B0 5F          0002*M 		LD	E, A
0443B1 8A          0003*M 		ADC	A, D
0443B2 93          0004*M 		SUB	E
0443B3 57          0005*M 		LD	D, A
0443B4 23          0080*  			INC	HL
0443B5 18 E7       0081*  			JR	ASC_TO_NUMBER3
0443B7 C1          0082*  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
0443B8             0083*  
0443B8             0084*  ; Skip a space
0443B8             0085*  ; HL: Pointer in string buffer
0443B8             0086*  ;
0443B8 7E          0087*  SKIPSPC:			LD      A, (HL)
0443B9 FE 20       0088*  			CP      ' '
0443BB C0          0089*  			RET     NZ
0443BC 23          0090*  			INC     HL
0443BD 18 F9       0091*  			JR      SKIPSPC
0443BF             0092*  
0443BF             0093*  ; Skip a string
0443BF             0094*  ; HL: Pointer in string buffer
0443BF             0095*  ;
0443BF 7E          0096*  SKIPNOTSP:		LD	A, (HL)
0443C0 FE 20       0097*  			CP	' '
0443C2 C8          0098*  			RET	Z
0443C3 23          0099*  			INC	HL
0443C4 18 F9       0100*  			JR	SKIPNOTSP
0443C6             0101*  
0443C6             0102*  ; Convert a character to upper case
0443C6             0103*  ;  A: Character to convert
0443C6             0104*  ;
0443C6 E6 7F       0105*  UPPERC:  		AND     7FH
0443C8 FE 60       0106*  			CP      '`'
0443CA D8          0107*  			RET     C
0443CB E6 5F       0108*  			AND     5FH			; Convert to upper case
0443CD C9          0109*  			RET
0443CE             0110*  
0443CE             0111*  ; Switch on A - lookup table immediately after call
0443CE             0112*  ;  A: Index into lookup table
0443CE             0113*  ;
0443CE E3          0114*  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0443CF 87          0115*  			ADD	A, A			; Multiply A by two
0443D0             0116*  			ADD8U_HL 			; Add to HL (macro)
0443D0 85          0001*M 		ADD	A, L
0443D1 6F          0002*M 		LD	L, A
0443D2 8C          0003*M 		ADC	A, H
0443D3 95          0004*M 		SUB	L
0443D4 67          0005*M 		LD	H, A
0443D5 7E          0117*  			LD	A, (HL)			; follow the call. Fetch an address from the
0443D6 23          0118*  			INC	HL 			; table.
0443D7 66          0119*  			LD	H, (HL)
0443D8 6F          0120*  			LD	L, A
0443D9 E3          0121*  			EX	(SP), HL		; Swap this new address back, restores HL
0443DA C9          0122*  			RET				; Return program control to this new address
0443DB             0123*  
0443DB             0124*  ; Convert the buffer to a null terminated string and back
0443DB             0125*  ; HL: Buffer address
0443DB             0126*  ;
0443DB C5          0127*  NULLTOCR:		PUSH 	BC
0443DC 06 00       0128*  			LD	B, 0
0443DE 0E 0D       0129*  			LD	C, CR
0443E0 18 05       0130*  			JR	CRTONULL0
0443E2             0131*  ;
0443E2 C5          0132*  CRTONULL:		PUSH	BC
0443E3 06 0D       0133*  			LD	B, CR
0443E5 0E 00       0134*  			LD	C, 0
0443E7             0135*  ;
0443E7 E5          0136*  CRTONULL0:		PUSH	HL
0443E8 7E          0137*  CRTONULL1:		LD	A, (HL)
0443E9 B8          0138*  			CP 	B
0443EA 28 03       0139*  			JR	Z, CRTONULL2
0443EC 23          0140*  			INC	HL
0443ED 18 F9       0141*  			JR	CRTONULL1
0443EF 71          0142*  CRTONULL2:		LD	(HL), C
0443F0 E1          0143*  			POP 	HL
0443F1 C1          0144*  			POP	BC
0443F2 C9          0145*  			RET
0443F3             0146*  
0443F3             0147*  ; Copy a filename to DE and zero terminate it
0443F3             0148*  ; HL: Source
0443F3             0149*  ; DE: Destination (ACCS)
0443F3             0150*  ;
0443F3 7E          0151*  CSTR_FNAME:		LD	A, (HL)			; Get source
0443F4 FE 20       0152*  			CP	32			; Is it space
0443F6 28 09       0153*  			JR	Z, @F
0443F8 FE 0D       0154*  			CP	CR			; Or is it CR
0443FA 28 05       0155*  			JR	Z, @F
0443FC 12          0156*  			LD	(DE), A			; No, so store
0443FD 23          0157*  			INC	HL			; Increment
0443FE 13          0158*  			INC	DE
0443FF 18 F2       0159*  			JR	CSTR_FNAME		; And loop
044401 AF          0160*  @@:			XOR	A			; Zero terminate the target string
044402 12          0161*  			LD	(DE), A
044403 13          0162*  			INC	DE			; And point to next free address
044404 C9          0163*  			RET
044405             0164*  
044405             0165*  ; Copy a CR terminated line to DE and zero terminate it
044405             0166*  ; HL: Source
044405             0167*  ; DE: Destination (ACCS)
044405             0168*  ;
044405 7E          0169*  CSTR_LINE:		LD	A, (HL)			; Get source
044406 FE 0D       0170*  			CP	CR			; Is it CR
044408 28 05       0171*  			JR	Z, @F
04440A 12          0172*  			LD	(DE), A			; No, so store
04440B 23          0173*  			INC	HL			; Increment
04440C 13          0174*  			INC	DE
04440D 18 F6       0175*  			JR	CSTR_LINE		; And loop
04440F AF          0176*  @@:			XOR	A			; Zero terminate the target string
044410 12          0177*  			LD	(DE), A
044411 13          0178*  			INC	DE			; And point to next free address
044412 C9          0179*  			RET
044413             0180*  
044413             0181*  ; Find the first occurrence of a character (case sensitive)
044413             0182*  ; HL: Source
044413             0183*  ;  C: Character to find
044413             0184*  ; Returns:
044413             0185*  ; HL: Pointer to character, or end of string marker
044413             0186*  ;
044413 7E          0187*  CSTR_FINDCH:		LD	A, (HL)			; Get source
044414 B9          0188*  			CP	C			; Is it our character?
044415 C8          0189*  			RET	Z			; Yes, so exit
044416 B7          0190*  			OR	A			; Is it the end of string?
044417 C8          0191*  			RET	Z			; Yes, so exit
044418 23          0192*  			INC	HL
044419 18 F8       0193*  			JR	CSTR_FINDCH
04441B             0194*  
04441B             0195*  ; Check whether a string ends with another string (case insensitive)
04441B             0196*  ; HL: Source
04441B             0197*  ; DE: The substring we want to test with
04441B             0198*  ; Returns:
04441B             0199*  ;  F: Z if HL ends with DE, otherwise NZ
04441B             0200*  ;
04441B 7E          0201*  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
04441C CD C6 43 04 0202*  			CALL	UPPERC			; Convert to upper case
044420 4F          0203*  			LD	C, A
044421 1A          0204*  			LD	A, (DE)			; Get the substring byte
044422 B9          0205*  			CP	C
044423 C0          0206*  			RET	NZ			; Return NZ if at any point the strings don't match
044424 B1          0207*  			OR	C			; Check whether both bytes are zero
044425 C8          0208*  			RET	Z			; If so, return, as we have reached the end of both strings
044426 23          0209*  			INC	HL
044427 13          0210*  			INC	DE
044428 18 F1       0211*  			JR	CSTR_ENDSWITH		; And loop
04442A             0212*  
04442A             0213*  ; Concatenate a string onto the end of another string
04442A             0214*  ; HL: Source
04442A             0215*  ; DE: Second string
04442A             0216*  ;
04442A 7E          0217*  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
04442B B7          0218*  			OR	A
04442C 28 03       0219*  			JR	Z, CSTR_CAT_1
04442E 23          0220*  			INC	HL
04442F 18 F9       0221*  			JR	CSTR_CAT
044431             0222*  ;
044431 1A          0223*  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
044432 77          0224*  			LD	(HL), A
044433 B7          0225*  			OR	A			; Check for end of string
044434 C8          0226*  			RET	Z			; And return
044435 23          0227*  			INC	HL
044436 13          0228*  			INC	DE
044437 18 F8       0229*  			JR	CSTR_CAT_1		; Loop until finished
044439             0015       include "patch.asm"
044439             0001*  ;
044439             0002*  ; Title:	BBC Basic for AGON
044439             0003*  ; Author:	Dean Belfield
044439             0004*  ; Created:	12/05/2023
044439             0005*  ; Last Updated:	15/11/2023
044439             0006*  ;
044439             0007*  ; Modinfo:
044439             0008*  ; 11/07/2023:	Fixed *BYE for ADL mode
044439             0009*  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
044439             0010*  
044439             0011*  			; .ASSUME	ADL = 1
044439             0012*  
044439             0013*  			; INCLUDE	"equs.inc"
044439             0014*  			; INCLUDE "macros.inc"
044439             0015*  			; INCLUDE "mos_api.inc"	; In MOS/src
044439             0016*  
044439             0017*  			; SEGMENT CODE
044439             0018*  
044439             0019*  			; XDEF	OSWRCH
044439             0020*  			; XDEF	OSLINE
044439             0021*  			; XDEF	ESCSET
044439             0022*  			; XDEF	PUTIME
044439             0023*  			; XDEF	GETIME
044439             0024*  			; XDEF	PUTCSR
044439             0025*  			; XDEF 	GETCSR
044439             0026*  			; XDEF	OSRDCH
044439             0027*  			; XDEF	PROMPT
044439             0028*  			; XDEF	OSKEY
044439             0029*  			; XDEF	TRAP
044439             0030*  			; XDEF	LTRAP
044439             0031*  			; XDEF	OSINIT
044439             0032*  			; XDEF	OSCLI
044439             0033*  			; XDEF	OSBPUT
044439             0034*  			; XDEF	OSBGET
044439             0035*  			; XDEF	OSSTAT
044439             0036*  			; XDEF	OSSHUT
044439             0037*  			; XDEF	OSOPEN
044439             0038*  			; XDEF	OSCALL
044439             0039*  			; XDEF	GETPTR
044439             0040*  			; XDEF	PUTPTR
044439             0041*  			; XDEF	GETEXT
044439             0042*  			; XDEF	GETIMS
044439             0043*  			; XDEF	RESET
044439             0044*  			; XDEF	OSLOAD
044439             0045*  			; XDEF	OSSAVE
044439             0046*  			; XDEF	EXPR_W2
044439             0047*  			; XDEF	STAR_VERSION
044439             0048*  
044439             0049*  			; XREF	_end			; In init.asm
044439             0050*  
044439             0051*  			; XREF	ASC_TO_NUMBER
044439             0052*  			; XREF	RAM_START
044439             0053*  			; XREF	RAM_END
044439             0054*  			; XREF	FLAGS
044439             0055*  			; XREF	ESCAPE
044439             0056*  			; XREF	USER
044439             0057*  			; XREF	RAM_Top
044439             0058*  			; XREF	EXTERR
044439             0059*  			; XREF	COUNT0
044439             0060*  			; XREF	EXPRI
044439             0061*  			; XREF	COMMA
044439             0062*  			; XREF	XEQ
044439             0063*  			; XREF	NXT
044439             0064*  			; XREF	NULLTOCR
044439             0065*  			; XREF	CRLF
044439             0066*  			; XREF	CSTR_FNAME
044439             0067*  			; XREF	CSTR_LINE
044439             0068*  			; XREF	CSTR_FINDCH
044439             0069*  			; XREF	CSTR_ENDSWITH
044439             0070*  			; XREF	CSTR_CAT
044439             0071*  			; XREF	FINDL
044439             0072*  			; XREF	OUT_
044439             0073*  			; XREF	ERROR_
044439             0074*  			; XREF	ONEDIT
044439             0075*  			; XREF	TELL
044439             0076*  			; XREF	OSWRCHPT
044439             0077*  			; XREF	OSWRCHCH
044439             0078*  			; XREF	OSWRCHFH
044439             0079*  			; XREF	LISTON
044439             0080*  			; XREF	LISTIT
044439             0081*  			; XREF	PAGE_
044439             0082*  			; XREF	ONEDIT1
044439             0083*  			; XREF	CLEAN
044439             0084*  			; XREF	NEWIT
044439             0085*  			; XREF	BAD
044439             0086*  			; XREF	VBLANK_INIT
044439             0087*  			; XREF	VBLANK_STOP
044439             0088*  			; XREF	KEYDOWN
044439             0089*  			; XREF	KEYASCII
044439             0090*  			; XREF	WIDTH
044439             0091*  			; XREF	ASSEM
044439             0092*  
044439             0093*  ; OSLINE: Invoke the line editor
044439             0094*  ;
044439 1E 01       0095*  OSLINE:			LD 	E, 1			; Default is to clear the buffer
04443B             0096*  
04443B             0097*  ; Entry point to line editor that does not clear the buffer
04443B             0098*  ;
04443B FD E5       0099*  OSLINE1:		PUSH	IY
04443D E5          0100*  			PUSH	HL			; Buffer address
04443E 01 00 01 00 0101*  			LD	BC, 256			; Buffer length
044442             0102*  			MOSCALL	mos_editline		; Call the MOS line editor
044442 3E 09       0001*M 			LD	A, function
044444 49 CF       0002*M 			RST.LIS	08h
044446 E1          0103*  			POP	HL			; Pop the address
044447 FD E1       0104*  			POP	IY
044449 F5          0105*  			PUSH	AF			; Stack the return value (key pressed)
04444A CD DB 43 04 0106*  			CALL	NULLTOCR		; Turn the 0 character to a CR
04444E CD B9 0A 04 0107*  			CALL	CRLF			; Display CRLF
044452 F1          0108*  			POP	AF
044453 FE 1B       0109*  			CP	1Bh 			; Check if ESC terminated the input
044455 CA 51 45 04 0110*  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
044459 3A 42 4D 04 0111*  			LD	A, (FLAGS)		; Otherwise
04445D CB BF       0112*  			RES	7, A 			; Clear the escape flag
04445F 32 42 4D 04 0113*  			LD	(FLAGS), A
044463 CD 28 47 04 0114*  			CALL	WAIT_VBLANK 		; Wait a frame
044467 AF          0115*   			XOR	A			; Return A = 0
044468 32 47 4D 04 0116*  			LD	(KEYDOWN), A
04446C 32 48 4D 04 0117*  			LD	(KEYASCII), A
044470 C9          0118*  			RET
044471             0119*  
044471             0120*  ; PUTIME: set current time to DE:HL, in centiseconds.
044471             0121*  ;
044471 DD E5       0122*  PUTIME:			PUSH 	IX
044473             0123*  			MOSCALL	mos_sysvars
044473 3E 08       0001*M 			LD	A, function
044475 49 CF       0002*M 			RST.LIS	08h
044477 DD 75 00    0124*  			LD	(IX + sysvar_time + 0), L
04447A DD 74 01    0125*  			LD	(IX + sysvar_time + 1), H
04447D DD 73 02    0126*  			LD	(IX + sysvar_time + 2), E
044480 DD 72 03    0127*  			LD	(IX + sysvar_time + 3), D
044483 DD E1       0128*  			POP	IX
044485 C9          0129*  			RET
044486             0130*  
044486             0131*  ; GETIME: return current time in DE:HL, in centiseconds
044486             0132*  ;
044486 DD E5       0133*  GETIME:			PUSH 	IX
044488             0134*  			MOSCALL	mos_sysvars
044488 3E 08       0001*M 			LD	A, function
04448A 49 CF       0002*M 			RST.LIS	08h
04448C DD 6E 00    0135*  			LD	L, (IX + sysvar_time + 0)
04448F DD 66 01    0136*  			LD	H, (IX + sysvar_time + 1)
044492 DD 5E 02    0137*  			LD	E, (IX + sysvar_time + 2)
044495 DD 56 03    0138*  			LD	D, (IX + sysvar_time + 3)
044498 DD E1       0139*  			POP	IX
04449A C9          0140*  			RET
04449B             0141*  
04449B             0142*  ; PUTCSR: move to cursor to x=DE, y=HL
04449B             0143*  ;
04449B 3E 1F       0144*  PUTCSR:			LD	A, 1Fh			; TAB
04449D 5B D7       0145*  			RST.LIL	10h
04449F 7B          0146*  			LD	A, E			; X
0444A0 5B D7       0147*  			RST.LIL 10h
0444A2 7D          0148*  			LD	A, L			; Y
0444A3 5B D7       0149*  			RST.LIL 10h
0444A5 C9          0150*  			RET
0444A6             0151*  
0444A6             0152*  ; GETCSR: return cursor position in x=DE, y=HL
0444A6             0153*  ;
0444A6 DD E5       0154*  GETCSR:			PUSH	IX			; Get the system vars in IX
0444A8             0155*  			MOSCALL	mos_sysvars		; Reset the semaphore
0444A8 3E 08       0001*M 			LD	A, function
0444AA 49 CF       0002*M 			RST.LIS	08h
0444AC DD CB 04 86 0156*  			RES	0, (IX+sysvar_vpd_pflags)
0444B0             0157*  			VDU	23
0444B0 3E 17       0001*M 		LD	A, val
0444B2 CD DA 44 04 0002*M 		CALL	OSWRCH
0444B6             0158*  			VDU	0
0444B6 3E 00       0001*M 		LD	A, val
0444B8 CD DA 44 04 0002*M 		CALL	OSWRCH
0444BC             0159*  			VDU	vdp_cursor
0444BC 3E 82       0001*M 		LD	A, val
0444BE CD DA 44 04 0002*M 		CALL	OSWRCH
0444C2 DD CB 04 46 0160*  @@:			BIT	0, (IX+sysvar_vpd_pflags)
0444C6 28 FA       0161*  			JR	Z, @B			; Wait for the result
0444C8 16 00       0162*  			LD 	D, 0
0444CA 62          0163*  			LD	H, D
0444CB DD 5E 07    0164*  			LD	E, (IX + sysvar_cursorX)
0444CE DD 6E 08    0165*  			LD	L, (IX + sysvar_cursorY)
0444D1 DD E1       0166*  			POP	IX
0444D3 C9          0167*  			RET
0444D4             0168*  
0444D4             0169*  ; PROMPT: output the input prompt
0444D4             0170*  ;
0444D4 3E 3E       0171*  PROMPT: 		LD	A,'>'
0444D6 C3 DA 44 04 0172*  			JP	OSWRCH
0444DA             0173*  
0444DA             0174*  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0444DA             0175*  ; A: Character to write
0444DA             0176*  ;
0444DA E5          0177*  OSWRCH:			PUSH	HL
0444DB 21 40 4D 04 0178*  			LD	HL, LISTON		; Fetch the LISTON variable
0444DF CB 5E       0179*  			BIT	3, (HL)			; Check whether we are in *EDIT mode
0444E1 20 0B       0180*  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0444E3             0181*  ;
0444E3 2A 45 4D 04 0182*  			LD	HL, (OSWRCHCH)		; L: Channel #
0444E7 2D          0183*  			DEC	L			; If it is 1
0444E8 28 10       0184*  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0444EA             0185*  ;
0444EA E1          0186*  			POP	HL			; Otherwise
0444EB 5B D7       0187*  			RST.LIL	10h			; Output the character to MOS
0444ED C9          0188*  			RET
0444EE             0189*  ;
0444EE 2A 43 4D 04 0190*  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0444F2 77          0191*  			LD	(HL), A			; Echo the character into the buffer
0444F3 23          0192*  			INC	HL			; Increment pointer
0444F4 22 43 4D 04 0193*  			LD	(OSWRCHPT), HL		; Write pointer back
0444F8 E1          0194*  			POP	HL
0444F9 C9          0195*  			RET
0444FA             0196*  ;
0444FA D5          0197*  OSWRCH_FILE:		PUSH	DE
0444FB 5C          0198*  			LD	E, H			; Filehandle to E
0444FC CD 26 49 04 0199*  			CALL	OSBPUT			; Write the byte out
044500 D1          0200*  			POP	DE
044501 E1          0201*  			POP	HL
044502 C9          0202*  			RET
044503             0203*  
044503             0204*  ; OSRDCH: Read a character in from the ESP32 keyboard handler
044503             0205*  ; This is only called in GETS (eval.asm)
044503             0206*  ;
044503             0207*  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
044503 3E 00       0001*M 			LD	A, function
044505 49 CF       0002*M 			RST.LIS	08h
044507 FE 1B       0208*  			CP	1Bh
044509 28 46       0209*  			JR	Z, LTRAP1
04450B C9          0210*  			RET
04450C             0211*  
04450C             0212*  
04450C             0213*  ;OSKEY - Read key with time-limit, test for ESCape.
04450C             0214*  ;Main function is carried out in user patch.
04450C             0215*  ;   Inputs: HL = time limit (centiseconds)
04450C             0216*  ;  Outputs: Carry reset if time-out
04450C             0217*  ;           If carry set A = character
04450C             0218*  ; Destroys: A,H,L,F
04450C             0219*  ;
04450C CD 3D 45 04 0220*  OSKEY:			CALL	READKEY			; Read the keyboard
044510 28 0A       0221*  			JR	Z, @F 			; Skip if we have a key
044512 7C          0222*  			LD	A, H 			; Check loop counter
044513 B5          0223*  			OR 	L
044514 C8          0224*  			RET 	Z 			; Return, we've not got a key at this point
044515 CD 28 47 04 0225*  			CALL	WAIT_VBLANK 		; Wait a frame
044519 2B          0226*  			DEC 	HL			; Decrement
04451A 18 F0       0227*  			JR	OSKEY 			; And loop
04451C             0228*  ;
04451C 21 47 4D 04 0229*  @@:			LD	HL, KEYDOWN		; We have a key, so
044520 36 00       0230*  			LD	(HL), 0			; clear the keydown flag
044522 FE 1B       0231*  			CP	1BH			; If we are not pressing ESC,
044524 37          0232*  			SCF 				; then flag we've got a character
044525 C0          0233*  			RET	NZ
044526             0234*  ;
044526             0235*  ; ESCSET
044526             0236*  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
044526             0237*  ;
044526 E5          0238*  ESCSET: 		PUSH    HL
044527 21 42 4D 04 0239*          		LD      HL,FLAGS		; Pointer to FLAGS
04452B CB 76       0240*          		BIT     6,(HL)			; If bit 6 is set, then
04452D 20 02       0241*          		JR      NZ,ESCDIS		; escape is disabled, so skip
04452F CB FE       0242*          		SET     7,(HL)			; Set bit 7, the escape flag
044531 E1          0243*  ESCDIS: 		POP     HL
044532 C9          0244*          		RET
044533             0245*  ;
044533             0246*  ; ESCTEST
044533             0247*  ; Test for ESC key
044533             0248*  ;
044533 CD 3D 45 04 0249*  ESCTEST:		CALL	READKEY			; Read the keyboard
044537 C0          0250*  			RET	NZ			; Skip if no key is pressed
044538 FE 1B       0251*  			CP	1BH			; If ESC pressed then
04453A 28 EA       0252*  			JR	Z,ESCSET		; jump to the escape set routine
04453C C9          0253*  			RET
04453D             0254*  
04453D             0255*  ; Read the keyboard
04453D             0256*  ; Returns:
04453D             0257*  ; - A: ASCII of the pressed key
04453D             0258*  ; - F: Z if the key is pressed, otherwise NZ
04453D             0259*  ;
04453D 3A 47 4D 04 0260*  READKEY:		LD	A, (KEYDOWN)		; Get key down
044541 3D          0261*  			DEC	A 			; Set Z flag if keydown is 1
044542 3A 48 4D 04 0262*  			LD	A, (KEYASCII)		; Get key ASCII value
044546 C9          0263*  			RET
044547             0264*  ;
044547             0265*  ; TRAP
044547             0266*  ; This is called whenever BASIC needs to check for ESC
044547             0267*  ;
044547 CD 33 45 04 0268*  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
04454B             0269*  ;
04454B 3A 42 4D 04 0270*  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
04454F B7          0271*  			OR	A			; This checks for bit 7; if it is not set then the result will
044550 F0          0272*  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
044551 21 42 4D 04 0273*  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
044555 CB BE       0274*  			RES	7,(HL)			; Clear the escape pressed flag and
044557 C3 A2 1A 04 0275*  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
04455B             0276*  
04455B             0277*  ;OSINIT - Initialise RAM mapping etc.
04455B             0278*  ;If BASIC is entered by BBCBASIC FILENAME then file
04455B             0279*  ;FILENAME.BBC is automatically CHAINed.
04455B             0280*  ;   Outputs: DE = initial value of HIMEM (top of RAM)
04455B             0281*  ;            HL = initial value of PAGE (user program)
04455B             0282*  ;            Z-flag reset indicates AUTO-RUN.
04455B             0283*  ;  Destroys: A,D,E,H,L,F
04455B             0284*  ;
04455B CD ED 3D 04 0285*  OSINIT:			CALL	VBLANK_INIT
04455F AF          0286*  			XOR	A
044560 21 00 4E 04 0287*  			LD 	HL, USER
044564 11 00 00 0B 0288*  			LD	DE, RAM_Top
044568 5F          0289*  			LD	E, A			; Page boundary
044569 C9          0290*  			RET
04456A             0291*  
04456A             0292*  ;
04456A             0293*  ;OSCLI - Process a MOS command
04456A             0294*  ;
04456A CD DE 45 04 0295*  OSCLI: 			CALL    SKIPSP
04456E FE 0D       0296*  			CP      CR
044570 C8          0297*  			RET     Z
044571 FE 7C       0298*  			CP      '|'
044573 C8          0299*  			RET     Z
044574 EB          0300*  			EX      DE,HL
044575 21 ED 45 04 0301*  			LD      HL,COMDS
044579 1A          0302*  OSCLI0:			LD      A,(DE)
04457A CD E5 45 04 0303*  			CALL    UPPRC
04457E BE          0304*  			CP      (HL)
04457F 28 0B       0305*  			JR      Z,OSCLI2
044581 38 30       0306*  			JR      C,OSCLI6
044583 CB 7E       0307*  OSCLI1:			BIT     7,(HL)
044585 23          0308*  			INC     HL
044586 28 FB       0309*  			JR      Z,OSCLI1
044588 23          0310*  			INC     HL
044589 23          0311*  			INC     HL
04458A 18 ED       0312*  			JR      OSCLI0
04458C             0313*  ;
04458C D5          0314*  OSCLI2:			PUSH    DE
04458D 13          0315*  OSCLI3:			INC     DE
04458E 23          0316*  			INC     HL
04458F 1A          0317*  			LD      A,(DE)
044590 CD E5 45 04 0318*  			CALL    UPPRC
044594 FE 2E       0319*  			CP      '.'			; ABBREVIATED?
044596 28 0A       0320*  			JR      Z,OSCLI4
044598 AE          0321*  			XOR     (HL)
044599 28 F2       0322*  			JR      Z,OSCLI3
04459B FE 80       0323*  			CP      80H
04459D 28 03       0324*  			JR      Z,OSCLI4
04459F D1          0325*  			POP     DE
0445A0 18 E1       0326*  			JR      OSCLI1
0445A2             0327*  ;
0445A2 F1          0328*  OSCLI4:			POP     AF
0445A3 13          0329*  		        INC     DE
0445A4 CB 7E       0330*  OSCLI5:			BIT     7,(HL)
0445A6 23          0331*  			INC     HL
0445A7 28 FB       0332*  			JR      Z,OSCLI5
0445A9 7E          0333*  			LD      A,(HL)
0445AA 23          0334*  			INC     HL
0445AB 66          0335*  			LD      H,(HL)
0445AC 6F          0336*  			LD      L,A
0445AD E5          0337*  			PUSH    HL
0445AE EB          0338*  			EX      DE,HL
0445AF C3 DE 45 04 0339*  			JP      SKIPSP
0445B3             0340*  ;
0445B3 EB          0341*  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0445B4 11 00 4A 04 0342*  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0445B8 D5          0343*  			PUSH	DE			; Store buffer address
0445B9 CD 05 44 04 0344*  			CALL	CSTR_LINE		; Fetch the line
0445BD E1          0345*  			POP	HL			; HL: Pointer to command string in ACCS
0445BE FD E5       0346*  			PUSH	IY
0445C0             0347*  			MOSCALL	mos_oscli		; Returns OSCLI error in A
0445C0 3E 10       0001*M 			LD	A, function
0445C2 49 CF       0002*M 			RST.LIS	08h
0445C4 FD E1       0348*  			POP	IY
0445C6 B7          0349*  			OR	A			; 0 means MOS returned OK
0445C7 C8          0350*  			RET	Z			; So don't do anything
0445C8 C3 02 48 04 0351*  			JP 	OSERROR			; Otherwise it's a MOS error
0445CC             0352*  
0445CC 3E FE       0353*  HUH:    		LD      A,254			; Bad command error
0445CE CD E9 08 04 0354*          		CALL    EXTERR
0445D2 42 61 64 20 0355*          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0445DD 00          0356*          		DEFB    0
0445DE             0357*  
0445DE 7E          0358*  SKIPSP:			LD      A,(HL)
0445DF FE 20       0359*          		CP      ' '
0445E1 C0          0360*          		RET     NZ
0445E2 23          0361*          		INC     HL
0445E3 18 F9       0362*          		JR      SKIPSP
0445E5             0363*  
0445E5 E6 7F       0364*  UPPRC:  		AND     7FH
0445E7 FE 60       0365*  			CP      '`'
0445E9 D8          0366*  			RET     C
0445EA E6 5F       0367*  			AND     5FH			; CONVERT TO UPPER CASE
0445EC C9          0368*  			RET
0445ED             0369*  
0445ED             0370*  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0445ED             0371*  ; These must be in alphabetical order
0445ED             0372*  ;
0445ED 41 53 4D    0373*  COMDS:  		DB	"AS","M"+80h		; ASM
0445F0 0B 46       0374*  			DW	STAR_ASM
0445F2 42 59 45    0375*  			DB	"BY","E"+80h		; BYE
0445F5 17 46       0376*  			DW	STAR_BYE
0445F7 45 44 49 54 0377*  			DB	"EDI","T"+80h		; EDIT
0445FB 4C 46       0378*  			DW	STAR_EDIT
0445FD 46 58       0379*  			DB	"F","X"+80h		; FX
0445FF 8C 46       0380*  			DW	STAR_FX
044601 56 45 52 53 0381*  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
044608 23 46       0382*  			DW	STAR_VERSION
04460A FF          0383*  			DB	FFh
04460B             0384*  
04460B             0385*  ; *ASM string
04460B             0386*  ;
04460B FD E5       0387*  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
04460D E5          0388*  			PUSH	HL			; HL = IY
04460E FD E1       0389*  			POP	IY
044610 CD CC 26 04 0390*  			CALL	ASSEM			; Invoke the assembler
044614 FD E1       0391*  			POP	IY
044616 C9          0392*  			RET
044617             0393*  
044617             0394*  ; *BYE
044617             0395*  ;
044617 CD 01 3E 04 0396*  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
04461B 21 00 00 00 0397*  			LD	HL, 0			; The return value
04461F C3 68 00 04 0398*  			JP	_end 			; Jump back to the end routine in init.asm
044623             0399*  
044623             0400*  ; *VERSION
044623             0401*  ;
044623 CD 02 0F 04 0402*  STAR_VERSION:		CALL    TELL			; Output the welcome message
044627 42 42 43 20 0403*  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
04464B C9          0404*  			RET
04464C             0405*  
04464C             0406*  ; *EDIT linenum
04464C             0407*  ;
04464C CD 71 43 04 0408*  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
044650 EB          0409*  			EX	DE, HL			; HL: Line number
044651 CD 01 0B 04 0410*  			CALL	FINDL			; HL: Address in RAM of tokenised line
044655 3E 29       0411*  			LD	A, 41			; F:NZ If the line is not found
044657 C2 D2 08 04 0412*  			JP	NZ, ERROR_		; Do error 41: No such line in that case
04465B             0413*  ;
04465B             0414*  ; Use LISTIT to output the line to the ACCS buffer
04465B             0415*  ;
04465B 23          0416*  			INC	HL			; Skip the length byte
04465C 5E          0417*  			LD	E, (HL)			; Fetch the line number
04465D 23          0418*  			INC	HL
04465E 56          0419*  			LD	D, (HL)
04465F 23          0420*  			INC	HL
044660 DD 21 00 4A 0421*  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
044665 DD 22 43 4D 0422*  			LD	(OSWRCHPT), IX
       04          
04466A DD 21 40 4D 0423*  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
04466F DD 7E 00    0424*  			LD	A, (IX)			; Store that variable
044672 F5          0425*  			PUSH	AF
044673 DD 36 00 09 0426*  			LD	(IX), 09h		; Set to echo to buffer
044677 CD 04 0A 04 0427*  			CALL	LISTIT
04467B F1          0428*  			POP	AF
04467C DD 77 00    0429*  			LD	(IX), A			; Restore the original LISTON variable
04467F 21 00 4A 04 0430*  			LD	HL, ACCS		; HL: ACCS
044683 5D          0431*  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
044684 CD 3B 44 04 0432*  			CALL	OSLINE1			; Invoke the editor
044688 C3 42 02 04 0433*  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
04468C             0434*  
04468C             0435*  ; OSCLI FX n
04468C             0436*  ;
04468C CD 71 43 04 0437*  STAR_FX:		CALL	ASC_TO_NUMBER
044690 4B          0438*  			LD	C, E			; C: Save FX #
044691 CD 71 43 04 0439*  			CALL	ASC_TO_NUMBER
044695 7A          0440*  			LD	A, D  			; Is first parameter > 255?
044696 B7          0441*  			OR 	A
044697 28 03       0442*  			JR	Z, STAR_FX1		; Yes, so skip next bit
044699 EB          0443*  			EX	DE, HL 			; Parameter is 16-bit
04469A 18 07       0444*  			JR	STAR_FX2
04469C             0445*  ;
04469C 43          0446*  STAR_FX1:		LD	B, E 			; B: Save First parameter
04469D CD 71 43 04 0447*  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0446A1 68          0448*  			LD	L, B 			; L: First parameter
0446A2 63          0449*  			LD	H, E 			; H: Second parameter
0446A3             0450*  ;
0446A3 79          0451*  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0446A4             0452*  ;
0446A4             0453*  ; OSBYTE
0446A4             0454*  ;  A: FX #
0446A4             0455*  ;  L: First parameter
0446A4             0456*  ;  H: Second parameter
0446A4             0457*  ;
0446A4 FE 0B       0458*  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0446A6 28 18       0459*  			JR	Z, OSBYTE_0B
0446A8 FE 0C       0460*  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0446AA 28 43       0461*  			JR	Z, OSBYTE_0C
0446AC FE 13       0462*  			CP	13H			; *FX 19: Wait for vblank
0446AE 28 6E       0463*  			JR	Z, OSBYTE_13
0446B0 FE 76       0464*  			CP	76H			; *FX 118, n: Set keyboard LED
0446B2 CA 39 47 04 0465*  			JP	Z, OSBYTE_76
0446B6 FE A0       0466*  			CP	A0H
0446B8 CA 69 47 04 0467*  			JP	Z, OSBYTE_A0
0446BC C3 CC 45 04 0468*  			JP	HUH			; Anything else trips an error
0446C0             0469*  
0446C0             0470*  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0446C0             0471*  ; Parameters:
0446C0             0472*  ; - HL: Repeat delay
0446C0             0473*  ;
0446C0             0474*  OSBYTE_0B:		VDU	23
0446C0 3E 17       0001*M 		LD	A, val
0446C2 CD DA 44 04 0002*M 		CALL	OSWRCH
0446C6             0475*  			VDU	0
0446C6 3E 00       0001*M 		LD	A, val
0446C8 CD DA 44 04 0002*M 		CALL	OSWRCH
0446CC             0476*  			VDU	vdp_keystate
0446CC 3E 88       0001*M 		LD	A, val
0446CE CD DA 44 04 0002*M 		CALL	OSWRCH
0446D2             0477*  			VDU	L
0446D2 7D          0001*M 		LD	A, val
0446D3 CD DA 44 04 0002*M 		CALL	OSWRCH
0446D7             0478*  			VDU	H
0446D7 7C          0001*M 		LD	A, val
0446D8 CD DA 44 04 0002*M 		CALL	OSWRCH
0446DC             0479*  			VDU	0
0446DC 3E 00       0001*M 		LD	A, val
0446DE CD DA 44 04 0002*M 		CALL	OSWRCH
0446E2             0480*  			VDU 	0
0446E2 3E 00       0001*M 		LD	A, val
0446E4 CD DA 44 04 0002*M 		CALL	OSWRCH
0446E8             0481*  			VDU	255
0446E8 3E FF       0001*M 		LD	A, val
0446EA CD DA 44 04 0002*M 		CALL	OSWRCH
0446EE C9          0482*  			RET
0446EF             0483*  
0446EF             0484*  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0446EF             0485*  ; Parameters:
0446EF             0486*  ; - HL: Repeat rate
0446EF             0487*  ;
0446EF             0488*  OSBYTE_0C:		VDU	23
0446EF 3E 17       0001*M 		LD	A, val
0446F1 CD DA 44 04 0002*M 		CALL	OSWRCH
0446F5             0489*  			VDU	0
0446F5 3E 00       0001*M 		LD	A, val
0446F7 CD DA 44 04 0002*M 		CALL	OSWRCH
0446FB             0490*  			VDU	vdp_keystate
0446FB 3E 88       0001*M 		LD	A, val
0446FD CD DA 44 04 0002*M 		CALL	OSWRCH
044701             0491*  			VDU	0
044701 3E 00       0001*M 		LD	A, val
044703 CD DA 44 04 0002*M 		CALL	OSWRCH
044707             0492*  			VDU 	0
044707 3E 00       0001*M 		LD	A, val
044709 CD DA 44 04 0002*M 		CALL	OSWRCH
04470D             0493*  			VDU	L
04470D 7D          0001*M 		LD	A, val
04470E CD DA 44 04 0002*M 		CALL	OSWRCH
044712             0494*  			VDU	H
044712 7C          0001*M 		LD	A, val
044713 CD DA 44 04 0002*M 		CALL	OSWRCH
044717             0495*  			VDU	255
044717 3E FF       0001*M 		LD	A, val
044719 CD DA 44 04 0002*M 		CALL	OSWRCH
04471D C9          0496*  			RET
04471E             0497*  
04471E             0498*  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
04471E             0499*  ;
04471E CD 28 47 04 0500*  OSBYTE_13:		CALL	WAIT_VBLANK
044722 2E 00       0501*  			LD	L, 0			; Returns 0
044724 C3 83 13 04 0502*  			JP	COUNT0
044728             0503*  ;
044728 DD E5       0504*  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
04472A             0505*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
04472A 3E 08       0001*M 			LD	A, function
04472C 49 CF       0002*M 			RST.LIS	08h
04472E DD 7E 00    0506*  			LD	A, (IX + sysvar_time + 0)
044731 DD BE 00    0507*  @@:			CP 	A, (IX + sysvar_time + 0)
044734 28 FB       0508*  			JR	Z, @B
044736 DD E1       0509*  			POP	IX
044738 C9          0510*  			RET
044739             0511*  
044739             0512*  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
044739             0513*  ; Parameters:
044739             0514*  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
044739             0515*  ;
044739             0516*  OSBYTE_76:		VDU	23
044739 3E 17       0001*M 		LD	A, val
04473B CD DA 44 04 0002*M 		CALL	OSWRCH
04473F             0517*  			VDU	0
04473F 3E 00       0001*M 		LD	A, val
044741 CD DA 44 04 0002*M 		CALL	OSWRCH
044745             0518*  			VDU	vdp_keystate
044745 3E 88       0001*M 		LD	A, val
044747 CD DA 44 04 0002*M 		CALL	OSWRCH
04474B             0519*  			VDU	0
04474B 3E 00       0001*M 		LD	A, val
04474D CD DA 44 04 0002*M 		CALL	OSWRCH
044751             0520*  			VDU 	0
044751 3E 00       0001*M 		LD	A, val
044753 CD DA 44 04 0002*M 		CALL	OSWRCH
044757             0521*  			VDU	0
044757 3E 00       0001*M 		LD	A, val
044759 CD DA 44 04 0002*M 		CALL	OSWRCH
04475D             0522*  			VDU	0
04475D 3E 00       0001*M 		LD	A, val
04475F CD DA 44 04 0002*M 		CALL	OSWRCH
044763             0523*  			VDU	L
044763 7D          0001*M 		LD	A, val
044764 CD DA 44 04 0002*M 		CALL	OSWRCH
044768 C9          0524*  			RET
044769             0525*  
044769             0526*  ; OSBYTE 0xA0: Fetch system variable
044769             0527*  ; Parameters:
044769             0528*  ; - L: The system variable to fetch
044769             0529*  ;
044769 DD E5       0530*  OSBYTE_A0:		PUSH	IX
04476B             0531*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
04476B 3E 08       0001*M 			LD	A, function
04476D 49 CF       0002*M 			RST.LIS	08h
04476F 01 00 00 00 0532*  			LD	BC, 0
044773 4D          0533*  			LD	C, L			; BCU = L
044774 DD 09       0534*  			ADD	IX, BC			; Add to IX
044776 DD 6E 00    0535*  			LD	L, (IX + 0)		; Fetch the return value
044779 DD E1       0536*  			POP	IX
04477B C3 83 13 04 0537*  			JP 	COUNT0
04477F             0538*  
04477F             0539*  ;OSLOAD - Load an area of memory from a file.
04477F             0540*  ;   Inputs: HL addresses filename (CR terminated)
04477F             0541*  ;           DE = address at which to load
04477F             0542*  ;           BC = maximum allowed size (bytes)
04477F             0543*  ;  Outputs: Carry reset indicates no room for file.
04477F             0544*  ; Destroys: A,B,C,D,E,H,L,F
04477F             0545*  ;
04477F C5          0546*  OSLOAD:			PUSH	BC			; Stack the size
044780 D5          0547*  			PUSH	DE			; Stack the load address
044781 11 00 4A 04 0548*  			LD	DE, ACCS		; Buffer address for filename
044785 CD F3 43 04 0549*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044789 21 00 4A 04 0550*  			LD	HL, ACCS		; HL: Filename
04478D CD 7F 48 04 0551*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
044791 CD 93 48 04 0552*  			CALL	EXT_HANDLER		; Get the default handler
044795 D1          0553*  			POP	DE			; Restore the load address
044796 C1          0554*  			POP	BC			; Restore the size
044797 B7          0555*  			OR	A
044798 28 60       0556*  			JR 	Z, OSLOAD_BBC
04479A             0557*  ;
04479A             0558*  ; Load the file in as a text file
04479A             0559*  ;
04479A AF          0560*  OSLOAD_TXT:		XOR	A			; Set file attributes to read
04479B CD 07 49 04 0561*  			CALL	OSOPEN			; Open the file
04479F 5F          0562*  			LD 	E, A 			; The filehandle
0447A0 B7          0563*  			OR	A
0447A1 3E 04       0564*  			LD	A, 4			; File not found error
0447A3 28 5D       0565*  			JR	Z, OSERROR		; Jump to error handler
0447A5 CD DE 09 04 0566*  			CALL	NEWIT			; Call NEW to clear the program space
0447A9             0567*  ;
0447A9 21 00 4A 04 0568*  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0447AD             0569*  ;
0447AD             0570*  ; First skip any whitespace (indents) at the beginning of the input
0447AD             0571*  ;
0447AD CD 1E 49 04 0572*  @@:			CALL	OSBGET			; Read the byte into A
0447B1 38 1E       0573*  			JR	C, OSLOAD_TXT3		; Is it EOF?
0447B3 FE 0A       0574*  			CP	LF 			; Is it LF?
0447B5 28 1A       0575*  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0447B7 FE 21       0576*  			CP	21h			; Is it less than or equal to ASCII space?
0447B9 38 F2       0577*  			JR	C, @B 			; Yes, so keep looping
0447BB 77          0578*  			LD	(HL), A 		; Store the first character
0447BC 2C          0579*  			INC	L
0447BD             0580*  ;
0447BD             0581*  ; Now read the rest of the line in
0447BD             0582*  ;
0447BD CD 1E 49 04 0583*  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0447C1 38 2B       0584*  			JR	C, OSLOAD_TXT4		; Is it EOF?
0447C3 FE 20       0585*  			CP	20h			; Skip if not an ASCII character
0447C5 38 06       0586*  			JR	C, @F
0447C7 77          0587*  			LD	(HL), A 		; Store in the input buffer
0447C8 2C          0588*  			INC	L			; Increment the buffer pointer
0447C9 CA 6A 08 04 0589*  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0447CD FE 0A       0590*  @@:			CP	LF			; Check for LF
0447CF 20 EC       0591*  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0447D1             0592*  ;
0447D1             0593*  ; Finally, handle EOL/EOF
0447D1             0594*  ;
0447D1 36 0D       0595*  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0447D3 7D          0596*  			LD	A, L			; Check for minimum line length
0447D4 FE 02       0597*  			CP	2			; If it is 2 characters or less (including CR)
0447D6 38 0A       0598*  			JR	C, @F			; Then don't bother entering it
0447D8 D5          0599*  			PUSH	DE			; Preserve the filehandle
0447D9 CD 4E 02 04 0600*  			CALL	ONEDIT1			; Enter the line in memory
0447DD DC B1 09 04 0601*  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0447E1 D1          0602*  			POP	DE
0447E2 CD 2F 49 04 0603*  @@:			CALL	OSSTAT			; End of file?
0447E6 20 C1       0604*  			JR	NZ, OSLOAD_TXT1		; No, so loop
0447E8 CD 16 49 04 0605*  			CALL	OSSHUT			; Close the file
0447EC 37          0606*  			SCF				; Flag to BASIC that we're good
0447ED C9          0607*  			RET
0447EE             0608*  ;
0447EE             0609*  ; Special case for BASIC programs with no blank line at the end
0447EE             0610*  ;
0447EE FE 20       0611*  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0447F0 38 06       0612*  			JR	C, @F
0447F2 77          0613*  			LD	(HL), A			; Store the character
0447F3 2C          0614*  			INC	L
0447F4 CA 6A 08 04 0615*  			JP	Z, BAD
0447F8 18 D7       0616*  @@:			JR	OSLOAD_TXT3
0447FA             0617*  
0447FA             0618*  ;
0447FA             0619*  ; Load the file in as a tokenised binary blob
0447FA             0620*  ;
0447FA             0621*  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0447FA 3E 01       0001*M 			LD	A, function
0447FC 49 CF       0002*M 			RST.LIS	08h
0447FE D0          0622*  			RET	NC			; If load returns with carry reset - NO ROOM
0447FF B7          0623*  			OR	A			; If there is no error (A=0)
044800 37          0624*  			SCF				; Need to set carry indicating there was room
044801 C8          0625*  			RET	Z			; Return
044802             0626*  ;
044802 F5          0627*  OSERROR:		PUSH	AF			; Handle the MOS error
044803 21 00 4A 04 0628*  			LD	HL, ACCS		; Address of the buffer
044807 01 00 01 00 0629*  			LD	BC, 256			; Length of the buffer
04480B 5F          0630*  			LD	E, A			; The error code
04480C             0631*  			MOSCALL	mos_getError		; Copy the error message into the buffer
04480C 3E 0F       0001*M 			LD	A, function
04480E 49 CF       0002*M 			RST.LIS	08h
044810 F1          0632*  			POP	AF
044811 E5          0633*  			PUSH	HL			; Stack the address of the error (now in ACCS)
044812 C6 7F       0634*  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
044814 C3 E9 08 04 0635*  			JP	EXTERR			; Trigger an external error
044818             0636*  
044818             0637*  ;OSSAVE - Save an area of memory to a file.
044818             0638*  ;   Inputs: HL addresses filename (term CR)
044818             0639*  ;           DE = start address of data to save
044818             0640*  ;           BC = length of data to save (bytes)
044818             0641*  ; Destroys: A,B,C,D,E,H,L,F
044818             0642*  ;
044818 C5          0643*  OSSAVE:			PUSH	BC			; Stack the size
044819 D5          0644*  			PUSH	DE			; Stack the save address
04481A 11 00 4A 04 0645*  			LD	DE, ACCS		; Buffer address for filename
04481E CD F3 43 04 0646*  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
044822 21 00 4A 04 0647*  			LD	HL, ACCS		; HL: Filename
044826 CD 7F 48 04 0648*  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
04482A CD 93 48 04 0649*  			CALL	EXT_HANDLER		; Get the default handler
04482E D1          0650*  			POP	DE			; Restore the save address
04482F C1          0651*  			POP	BC			; Restore the size
044830 B7          0652*  			OR	A			; Is the extension .BBC
044831 28 44       0653*  			JR	Z, OSSAVE_BBC		; Yes, so use that
044833             0654*  ;
044833             0655*  ; Save the file out as a text file
044833             0656*  ;
044833 3A 45 4D 04 0657*  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
044837 F5          0658*  			PUSH	AF
044838 AF          0659*  			XOR	A
044839 3C          0660*  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
04483A 32 45 4D 04 0661*  			LD	(OSWRCHCH), A
04483E CD 07 49 04 0662*  			CALL	OSOPEN			; Open the file
044842 32 46 4D 04 0663*  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
044846 DD 21 40 4D 0664*  			LD	IX, LISTON		; Required for LISTIT
       04          
04484B 2A 14 4D 04 0665*  			LD	HL, (PAGE_)		; Get start of program area
04484F D9          0666*  			EXX
044850 01 00 00 00 0667*  			LD	BC, 0			; Set the initial indent counters
044854 D9          0668*  			EXX
044855 7E          0669*  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
044856 B7          0670*  			OR	A
044857 28 0F       0671*  			JR	Z, OSSAVE_TXT2
044859 23          0672*  			INC	HL			; Skip the length byte
04485A 11 00 00 00 0673*  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
04485E 5E          0674*  			LD	E, (HL)			; Get the line number
04485F 23          0675*  			INC	HL
044860 56          0676*  			LD	D, (HL)
044861 23          0677*  			INC	HL
044862 CD 04 0A 04 0678*  			CALL	LISTIT			; List the line
044866 18 ED       0679*  			JR	OSSAVE_TXT1
044868 3A 46 4D 04 0680*  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
04486C 5F          0681*  			LD	E, A
04486D CD 16 49 04 0682*  			CALL	OSSHUT			; Close it
044871 F1          0683*  			POP	AF			; Restore the channel
044872 32 45 4D 04 0684*  			LD	(OSWRCHCH), A
044876 C9          0685*  			RET
044877             0686*  ;
044877             0687*  ; Save the file out as a tokenised binary blob
044877             0688*  ;
044877             0689*  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
044877 3E 02       0001*M 			LD	A, function
044879 49 CF       0002*M 			RST.LIS	08h
04487B B7          0690*  			OR	A			; If there is no error (A=0)
04487C C8          0691*  			RET	Z			; Just return
04487D 18 83       0692*  			JR	OSERROR			; Trip an error
04487F             0693*  
04487F             0694*  ; Check if an extension is specified in the filename
04487F             0695*  ; Add a default if not specified
04487F             0696*  ; HL: Filename (CSTR format)
04487F             0697*  ;
04487F E5          0698*  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
044880 0E 2E       0699*  			LD	C, '.'			; Search for dot (marks start of extension)
044882 CD 13 44 04 0700*  			CALL	CSTR_FINDCH
044886 B7          0701*  			OR	A			; Check for end of string marker
044887 20 08       0702*  			JR	NZ, @F			; No, so skip as we have an extension at this point
044889 11 C3 48 04 0703*  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
04488D CD 2A 44 04 0704*  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
044891 E1          0705*  @@:			POP	HL			; Restore the filename pointer
044892 C9          0706*  			RET
044893             0707*  
044893             0708*  ; Check if an extension is valid and, if so, provide a pointer to a handler
044893             0709*  ; HL: Filename (CSTR format)
044893             0710*  ; Returns:
044893             0711*  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
044893             0712*  ;
044893 E5          0713*  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
044894 0E 2E       0714*  			LD	C, '.'			; Find the '.'
044896 CD 13 44 04 0715*  			CALL	CSTR_FINDCH
04489A 11 C3 48 04 0716*  			LD	DE, EXT_LOOKUP		; The lookup table
04489E             0717*  ;
04489E E5          0718*  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
04489F CD 1B 44 04 0719*  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0448A3 E1          0720*  			POP	HL			; Restore the pointer to the extension
0448A4 28 19       0721*  			JR	Z, EXT_HANDLER_2	; We have a match!
0448A6             0722*  ;
0448A6 1A          0723*  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0448A7 13          0724*  			INC	DE
0448A8 B7          0725*  			OR	A
0448A9 20 FB       0726*  			JR	NZ, @B
0448AB 13          0727*  			INC	DE			; Skip the file extension # byte
0448AC             0728*  ;
0448AC 1A          0729*  			LD	A, (DE)			; Are we at the end of the table?
0448AD B7          0730*  			OR	A
0448AE 20 EE       0731*  			JR	NZ, EXT_HANDLER_1	; No, so loop
0448B0             0732*  ;
0448B0 3E CC       0733*  			LD      A,204			; Throw a "Bad name" error
0448B2 CD E9 08 04 0734*          		CALL    EXTERR
0448B6 42 61 64 20 0735*          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0448BF             0736*  ;
0448BF 13          0737*  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0448C0 1A          0738*  			LD	A, (DE)
0448C1 E1          0739*  			POP	HL			; Restore the filename pointer
0448C2 C9          0740*  			RET
0448C3             0741*  ;
0448C3             0742*  
0448C3             0743*  
0448C3             0744*  ; Extension lookup table
0448C3             0745*  ; CSTR, TYPE
0448C3             0746*  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0448C3             0747*  ; 	- 1: Human readable plain text
0448C3             0748*  ;
0448C3 2E 42 42 43 0749*  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0448C9 2E 54 58 54 0750*  			DB	".TXT", 0, 1
       00 01       
0448CF 2E 41 53 43 0751*  			DB	".ASC", 0, 1
       00 01       
0448D5 2E 42 41 53 0752*  			DB	".BAS", 0, 1
       00 01       
0448DB 00          0753*  			DB	0			; End of table
0448DC             0754*  
0448DC             0755*  ;OSCALL - Intercept page &FF calls and provide an alternative address
0448DC             0756*  ;
0448DC             0757*  ;&FFF7:	OSCLI	Execute *command.
0448DC             0758*  ;&FFF4:	OSBYTE	Various byte-wide functions.
0448DC             0759*  ;&FFF1:	OSWORD	Various control block functions.
0448DC             0760*  ;&FFEE:	OSWRCH	Write character to output stream.
0448DC             0761*  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0448DC             0762*  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0448DC             0763*  ;&FFE0:	OSRDCH	Wait for character from input stream.
0448DC             0764*  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0448DC             0765*  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0448DC             0766*  ;&FFD7:	OSBGET	Read a byte from an a channel.
0448DC             0767*  ;&FFD4:	OSBPUT	Write a byte to a channel.
0448DC             0768*  ;&FFD1:	OSGBPB	Read and write blocks of data.
0448DC             0769*  ;&FFCE:	OSFIND	Open or close a file.
0448DC             0770*  ;
0448DC 21 F2 48 04 0771*  OSCALL:			LD	HL, OSCALL_TABLE
0448E0 7E          0772*  OSCALL_1:		LD	A, (HL)
0448E1 23          0773*  			INC	HL
0448E2 FE FF       0774*  			CP	FFh
0448E4 C8          0775*  			RET	Z
0448E5 FD BD       0776*  			CP	A, IYL
0448E7 28 06       0777*  			JR	Z, OSCALL_2
0448E9 D0          0778*  			RET	NC
0448EA 23          0779*  			INC	HL
0448EB 23          0780*  			INC	HL
0448EC 23          0781*  			INC	HL
0448ED 18 F1       0782*  			JR	OSCALL_1
0448EF ED 31       0783*  OSCALL_2:		LD	IY,(HL)
0448F1 C9          0784*  			RET
0448F2 D4          0785*  OSCALL_TABLE:		DB 	D4h
0448F3 26 49 04    0786*  			DW24 	OSBPUT
0448F6 D7          0787*  			DB 	D7h
0448F7 1E 49 04    0788*  			DW24 	OSBGET
0448FA EE          0789*  			DB 	EEh
0448FB DA 44 04    0790*  			DW24 	OSWRCH
0448FE F4          0791*  			DB	F4h
0448FF A4 46 04    0792*  			DW24 	OSBYTE
044902 F7          0793*  			DB	F7h
044903 6A 45 04    0794*  			DW24	OSCLI
044906 FF          0795*  			DB	FFh
044907             0796*  
044907             0797*  ; OSOPEN
044907             0798*  ; HL: Pointer to path
044907             0799*  ;  F: C Z
044907             0800*  ;     x x OPENIN
044907             0801*  ; 	  OPENOUT
044907             0802*  ;     x	  OPENUP
044907             0803*  ; Returns:
044907             0804*  ;  A: Filehandle, 0 if cannot open
044907             0805*  ;
044907 0E 01       0806*  OSOPEN:			LD	C, fa_read
044909 28 06       0807*  			JR	Z, @F
04490B 0E 32       0808*  			LD	C, fa_write | fa_open_append
04490D 38 02       0809*  			JR	C, @F
04490F 0E 0A       0810*  			LD	C, fa_write | fa_create_always
044911             0811*  @@:			MOSCALL	mos_fopen
044911 3E 0A       0001*M 			LD	A, function
044913 49 CF       0002*M 			RST.LIS	08h
044915 C9          0812*  			RET
044916             0813*  
044916             0814*  ;OSSHUT - Close disk file(s).
044916             0815*  ; E = file channel
044916             0816*  ;  If E=0 all files are closed (except SPOOL)
044916             0817*  ; Destroys: A,B,C,D,E,H,L,F
044916             0818*  ;
044916 C5          0819*  OSSHUT:			PUSH	BC
044917 4B          0820*  			LD	C, E
044918             0821*  			MOSCALL	mos_fclose
044918 3E 0B       0001*M 			LD	A, function
04491A 49 CF       0002*M 			RST.LIS	08h
04491C C1          0822*  			POP	BC
04491D C9          0823*  			RET
04491E             0824*  
04491E             0825*  ; OSBGET - Read a byte from a random disk file.
04491E             0826*  ;  E = file channel
04491E             0827*  ; Returns
04491E             0828*  ;  A = byte read
04491E             0829*  ;  Carry set if LAST BYTE of file
04491E             0830*  ; Destroys: A,B,C,F
04491E             0831*  ;
04491E C5          0832*  OSBGET:			PUSH	BC
04491F 4B          0833*  			LD	C, E
044920             0834*  			MOSCALL	mos_fgetc
044920 3E 0C       0001*M 			LD	A, function
044922 49 CF       0002*M 			RST.LIS	08h
044924 C1          0835*  			POP	BC
044925 C9          0836*  			RET
044926             0837*  
044926             0838*  ; OSBPUT - Write a byte to a random disk file.
044926             0839*  ;  E = file channel
044926             0840*  ;  A = byte to write
044926             0841*  ; Destroys: A,B,C,F
044926             0842*  ;
044926 C5          0843*  OSBPUT:			PUSH	BC
044927 4B          0844*  			LD	C, E
044928 47          0845*  			LD	B, A
044929             0846*  			MOSCALL	mos_fputc
044929 3E 0D       0001*M 			LD	A, function
04492B 49 CF       0002*M 			RST.LIS	08h
04492D C1          0847*  			POP	BC
04492E C9          0848*  			RET
04492F             0849*  
04492F             0850*  ; OSSTAT - Read file status
04492F             0851*  ;  E = file channel
04492F             0852*  ; Returns
04492F             0853*  ;  F: Z flag set - EOF
04492F             0854*  ;  A: If Z then A = 0
04492F             0855*  ; Destroys: A,D,E,H,L,F
04492F             0856*  ;
04492F C5          0857*  OSSTAT:			PUSH	BC
044930 4B          0858*  			LD	C, E
044931             0859*  			MOSCALL	mos_feof
044931 3E 0E       0001*M 			LD	A, function
044933 49 CF       0002*M 			RST.LIS	08h
044935 C1          0860*  			POP	BC
044936 FE 01       0861*  			CP	1
044938 C9          0862*  			RET
044939             0863*  
044939             0864*  ; GETPTR - Return file pointer.
044939             0865*  ;    E = file channel
044939             0866*  ; Returns:
044939             0867*  ; DEHL = pointer (0-&7FFFFF)
044939             0868*  ; Destroys: A,B,C,D,E,H,L,F
044939             0869*  ;
044939 FD E5       0870*  GETPTR:			PUSH		IY
04493B 4B          0871*  			LD		C, E
04493C             0872*  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
04493C 3E 19       0001*M 			LD	A, function
04493E 49 CF       0002*M 			RST.LIS	08h
044940 E5          0873*  			PUSH		HL
044941 FD E1       0874*  			POP		IY		; IYU: Pointer to FIL structure
044943 FD 6E 11    0875*  			LD		L, (IY + FIL.fptr + 0)
044946 FD 66 12    0876*  			LD		H, (IY + FIL.fptr + 1)
044949 FD 5E 13    0877*  			LD		E, (IY + FIL.fptr + 2)
04494C FD 56 14    0878*  			LD		D, (IY + FIL.fptr + 3)
04494F FD E1       0879*  			POP		IY
044951 C9          0880*  			RET
044952             0881*  
044952             0882*  ; PUTPTR - Update file pointer.
044952             0883*  ;    A = file channel
044952             0884*  ; DEHL = new pointer (0-&7FFFFF)
044952             0885*  ; Destroys: A,B,C,D,E,H,L,F
044952             0886*  ;
044952 FD E5       0887*  PUTPTR:			PUSH		IY
044954 4F          0888*  			LD		C, A  		; C: Filehandle
044955 E5          0889*  			PUSH		HL
044956 21 02 00 00 0890*  			LD		HL, 2
04495A 39          0891*  			ADD		HL, SP
04495B 73          0892*  			LD		(HL), E 	; 3rd byte of DWORD set to E
04495C E1          0893*  			POP		HL
04495D 5A          0894*  			LD		E, D  		; 4th byte passed as E
04495E             0895*  			MOSCALL		mos_flseek
04495E 3E 1C       0001*M 			LD	A, function
044960 49 CF       0002*M 			RST.LIS	08h
044962 FD E1       0896*  			POP		IY
044964 C9          0897*  			RET
044965             0898*  
044965             0899*  ; GETEXT - Find file size.
044965             0900*  ;    E = file channel
044965             0901*  ; Returns:
044965             0902*  ; DEHL = file size (0-&800000)
044965             0903*  ; Destroys: A,B,C,D,E,H,L,F
044965             0904*  ;
044965 FD E5       0905*  GETEXT:         PUSH    IY
044967 4B          0906*                  LD      C, E
044968             0907*                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
044968 3E 19       0001*M 			LD	A, function
04496A 49 CF       0002*M 			RST.LIS	08h
04496C E5          0908*                  PUSH    HL
04496D FD E1       0909*                  POP     IY          ; IYU: Pointer to FIL structure
04496F             0910*                  ; Access the obj.objsize field using the offset values
04496F FD 6E 0B    0911*                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
044972 FD 66 0C    0912*                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
044975 FD 5E 0D    0913*                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
044978 FD 56 0E    0914*                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
04497B             0915*  
04497B FD E1       0916*                  POP     IY
04497D C9          0917*  			RET
04497E             0918*  
04497E             0919*  ; GETIMS - Get time from RTC
04497E             0920*  ;
04497E FD E5       0921*  GETIMS:			PUSH	IY
044980 21 00 4A 04 0922*  			LD	HL, ACCS 		; Where to store the time string
044984             0923*  			MOSCALL	mos_getrtc
044984 3E 12       0001*M 			LD	A, function
044986 49 CF       0002*M 			RST.LIS	08h
044988 11 00 4A 04 0924*  			LD	DE, ACCS		; DE: pointer to start of string accumulator
04498C 5F          0925*  			LD	E, A 			;  E: now points to the end of the string
04498D FD E1       0926*  			POP	IY
04498F C9          0927*  			RET
044990             0928*  
044990             0929*  ; Get two word values from EXPR in DE, HL
044990             0930*  ; IY: Pointer to expression string
044990             0931*  ; Returns:
044990             0932*  ; DE: P1
044990             0933*  ; HL: P2
044990             0934*  ;
044990 CD 0E 11 04 0935*  EXPR_W2:		CALL	EXPRI			; Get first parameter
044994 D9          0936*  			EXX
044995 E5          0937*  			PUSH	HL
044996 CD 29 18 04 0938*  			CALL	COMMA
04499A CD 0E 11 04 0939*  			CALL	EXPRI			; Get second parameter
04499E D9          0940*  			EXX
04499F D1          0941*  			POP	DE
0449A0 C9          0942*  			RET
0449A1             0943*  
0449A1             0944*  ; Stuff not implemented yet
0449A1             0945*  ;
0449A1 C9          0946*  RESET:			RET
0449A2             0016       include "sorry.asm"
0449A2             0001*  ;
0449A2             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0449A2             0003*  ;		Catch-all for unimplemented functionality
0449A2             0004*  ; Author:	Dean Belfield
0449A2             0005*  ; Created:	12/05/2023
0449A2             0006*  ; Last Updated:	12/05/2023
0449A2             0007*  ;
0449A2             0008*  ; Modinfo:
0449A2             0009*  
0449A2             0010*  			; .ASSUME	ADL = 1
0449A2             0011*  
0449A2             0012*  			; SEGMENT CODE
0449A2             0013*  
0449A2             0014*  			; XDEF	ENVEL
0449A2             0015*  			; XDEF	ADVAL
0449A2             0016*  			; XDEF	PUTIMS
0449A2             0017*  
0449A2             0018*  			; XREF	EXTERR
0449A2             0019*  
0449A2             0020*  ENVEL:
0449A2             0021*  ADVAL:
0449A2             0022*  PUTIMS:
0449A2 AF          0023*  			XOR     A
0449A3 CD E9 08 04 0024*  			CALL    EXTERR
0449A7 53 6F 72 72 0025*  			DEFB    "Sorry"
       79          
0449AC 00          0026*  			DEFB    0
0449AD             0017       include "ram.asm"
0449AD             0001*  ;
0449AD             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0449AD             0003*  ;		RAM Module for BBC Basic Interpreter
0449AD             0004*  ;		For use with Version 2.0 of BBC BASIC
0449AD             0005*  ;		Standard CP/M Distribution Version
0449AD             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0449AD             0007*  ; Modified By:	Dean Belfield
0449AD             0008*  ; Created:	12/05/2023
0449AD             0009*  ; Last Updated:	26/06/2023
0449AD             0010*  ;
0449AD             0011*  ; Modinfo:
0449AD             0012*  ; 06/06/2023:	Modified to run in ADL mode
0449AD             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
0449AD             0014*  
0449AD             0015*  			; .ASSUME	ADL = 1
0449AD             0016*  
0449AD             0017*  			; DEFINE	LORAM, SPACE = ROM
0449AD             0018*  			; SEGMENT LORAM
0449AD             0019*  
0449AD             0020*  			; XDEF	ACCS
0449AD             0021*  			; XDEF	BUFFER
0449AD             0022*  			; XDEF	STAVAR
0449AD             0023*  			; XDEF	DYNVAR
0449AD             0024*  			; XDEF	FNPTR
0449AD             0025*  			; XDEF	PROPTR
0449AD             0026*  			; XDEF	PAGE_
0449AD             0027*  			; XDEF	TOP
0449AD             0028*  			; XDEF	LOMEM
0449AD             0029*  			; XDEF 	FREE
0449AD             0030*  			; XDEF	HIMEM
0449AD             0031*  			; XDEF	LINENO
0449AD             0032*  			; XDEF	TRACEN
0449AD             0033*  			; XDEF	AUTONO
0449AD             0034*  			; XDEF	ERRTRP
0449AD             0035*  			; XDEF	ERRTXT
0449AD             0036*  			; XDEF	DATPTR
0449AD             0037*  			; XDEF	ERL
0449AD             0038*  			; XDEF	ERRLIN
0449AD             0039*  			; XDEF	RANDOM
0449AD             0040*  			; XDEF	COUNT
0449AD             0041*  			; XDEF	WIDTH
0449AD             0042*  			; XDEF	ERR
0449AD             0043*  			; XDEF	LISTON
0449AD             0044*  			; XDEF	INCREM
0449AD             0045*  
0449AD             0046*  			; XDEF	FLAGS
0449AD             0047*  			; XDEF	OSWRCHPT
0449AD             0048*  			; XDEF	OSWRCHCH
0449AD             0049*  			; XDEF	OSWRCHFH
0449AD             0050*  			; XDEF	KEYDOWN
0449AD             0051*  			; XDEF	KEYASCII
0449AD             0052*  			; XDEF	KEYCOUNT
0449AD             0053*  
0449AD             0054*  			; XDEF	R0
0449AD             0055*  			; XDEF	R1
0449AD             0056*  
0449AD             0057*  			; XDEF	RAM_START
0449AD             0058*  			; XDEF	RAM_END
0449AD             0059*  			; XDEF	USER
0449AD             0060*  
0449AD FF FF FF FF 0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
044A00             0062*  RAM_START:
044A00             0063*  ;
044A00 00 00 00 00 0064*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044B00 00 00 00 00 0065*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C00 00 00 00 00 0066*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C6C 00 00 00 00 0067*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
044D0E 00 00 00    0068*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
044D11 00 00 00    0069*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
044D14             0070*  ;
044D14 00 00 00    0071*  PAGE_:          BLKB    3,0               ; Start of User Program
044D17 00 00 00    0072*  TOP:            BLKB    3,0               ; First Location after User Program
044D1A 00 00 00    0073*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
044D1D 00 00 00    0074*  FREE:           BLKB    3,0               ; First Free Space Byte
044D20 00 00 00    0075*  HIMEM:          BLKB    3,0               ; First Protected Byte
044D23             0076*  ;
044D23 00 00 00    0077*  LINENO:         BLKB    3,0               ; Line Number
044D26 00 00 00    0078*  TRACEN:         BLKB    3,0               ; Trace Flag
044D29 00 00 00    0079*  AUTONO:         BLKB    3,0               ; Auto Flag
044D2C 00 00 00    0080*  ERRTRP:         BLKB    3,0               ; Error Trap
044D2F 00 00       0081*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
044D31 00 00       0082*  DATPTR:         BLKB    2,0               ; Data Pointer
044D33 00 00       0083*  ERL:            BLKB    2,0               ; Error Line
044D35 00 00 00    0084*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
044D38 00 00 00 00 0085*  RANDOM:         BLKB    5,0               ; Random Number
       00          
044D3D 00          0086*  COUNT:          BLKB    1,0               ; Print Position
044D3E 00          0087*  WIDTH:          BLKB    1,0               ; Print Width
044D3F 00          0088*  ERR:            BLKB    1,0               ; Error Number
044D40 00          0089*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
044D41             0090*                                  ; - BIT 0: If set, output a space after the line number
044D41             0091*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
044D41             0092*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
044D41             0093*                                  ; - BIT 3: If set, then output to buffer for *EDIT
044D41             0094*                                  ; OPT FLAG (top nibble)
044D41             0095*                                  ; - BIT 4: If set, then list whilst assembling
044D41             0096*                                  ; - BIT 5: If set, then assembler errors are reported
044D41             0097*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
044D41             0098*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
044D41 00          0099*  INCREM:         BLKB    1,0               ; Auto-Increment Value
044D42             0100*  ;
044D42             0101*  ; Extra Agon-implementation specific system variables
044D42             0102*  ;
044D42 00          0103*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
044D43             0104*                                  ; - BIT 7: Set if ESC pressed
044D43             0105*                                  ; - BIT 6: Set to disable ESC
044D43 00 00       0106*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
044D45 00          0107*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
044D46             0108*                                  ; - 0: Console
044D46             0109*                                  ; - 1: File
044D46 00          0110*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
044D47 00          0111*  KEYDOWN:        BLKB    1,0       ; Keydown flag
044D48 00          0112*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
044D49 00          0113*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
044D4A 00 00 00    0114*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
044D4D 00 00 00    0115*  R1:             BLKB    3,0
044D50             0116*  
044D50             0117*  ;
044D50             0118*  ; This must be at the end
044D50             0119*  ;
044D50             0120*  RAM_END:
044D50             0121*  ; moved to user.asm
044D50             0122*  ; 			ALIGN	256
044D50             0123*  ; USER:							; Must be aligned on a page boundary
044D50             0124*  
044D50             0018       include "user.asm"
044D50             0001*  ; this must be the last include to allow unbounded user space for programs
044D50             0002*  
044D50             0003*  			; .ASSUME	ADL = 1
044D50             0004*  
044D50 FF FF FF FF 0005*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
044E00             0006*  USER:							; Must be aligned on a page boundary
044E00             0019       include "equs_bottom.inc"
044E00             0001*  ; --- Begin equs.inc ---
044E00             0002*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
044E00             0003*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
044E00             0004*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
044E00             0005*  ; --- End equs.inc ---
044E00             0006*  
044E00             0007*  ; --- Begin eval.asm ---
044E00             0008*  TCMD:			EQU C6H ;    FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
044E00             0009*  ; 041DFA D6 C6       0258*  			SUB     TCMD
044E00             0010*  
044E00             0011*  ; --- End eval.asm ---
044E00             0012*  
044E00             0013*  ; --- Begin exec.asm ---
044E00             0014*  ; --- End exec.asm ---
044E00             0015*  
044E00             0016*  ; --- Begin fpp.asm ---
044E00             0017*  ; --- End fpp.asm ---
044E00             0018*  
044E00             0019*  ; --- Begin init.asm ---
044E00             0020*  ; --- End init.asm ---
044E00             0021*  
044E00             0022*  ; --- Begin main.asm ---
044E00             0023*  ; --- End main.asm ---
044E00             0024*  
044E00             0025*  ; --- Begin mos_api.inc ---
044E00             0026*  ; --- End mos_api.inc ---
044E00             0027*  
